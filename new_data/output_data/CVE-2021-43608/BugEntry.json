{"buggy_code": ["<?php\n\nnamespace Doctrine\\DBAL\\Platforms;\n\nuse Doctrine\\Common\\EventManager;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableAddColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableChangeColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableRemoveColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableRenameColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaCreateTableColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaCreateTableEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaDropTableEventArgs;\nuse Doctrine\\DBAL\\Events;\nuse Doctrine\\DBAL\\Exception;\nuse Doctrine\\DBAL\\Exception\\InvalidLockMode;\nuse Doctrine\\DBAL\\LockMode;\nuse Doctrine\\DBAL\\Platforms\\Keywords\\KeywordList;\nuse Doctrine\\DBAL\\Schema\\Column;\nuse Doctrine\\DBAL\\Schema\\ColumnDiff;\nuse Doctrine\\DBAL\\Schema\\Constraint;\nuse Doctrine\\DBAL\\Schema\\ForeignKeyConstraint;\nuse Doctrine\\DBAL\\Schema\\Identifier;\nuse Doctrine\\DBAL\\Schema\\Index;\nuse Doctrine\\DBAL\\Schema\\Sequence;\nuse Doctrine\\DBAL\\Schema\\Table;\nuse Doctrine\\DBAL\\Schema\\TableDiff;\nuse Doctrine\\DBAL\\Schema\\UniqueConstraint;\nuse Doctrine\\DBAL\\SQL\\Parser;\nuse Doctrine\\DBAL\\TransactionIsolationLevel;\nuse Doctrine\\DBAL\\Types;\nuse Doctrine\\DBAL\\Types\\Type;\nuse Doctrine\\Deprecations\\Deprecation;\nuse InvalidArgumentException;\nuse UnexpectedValueException;\n\nuse function addcslashes;\nuse function array_map;\nuse function array_merge;\nuse function array_unique;\nuse function array_values;\nuse function assert;\nuse function count;\nuse function explode;\nuse function func_get_arg;\nuse function func_get_args;\nuse function func_num_args;\nuse function implode;\nuse function in_array;\nuse function is_array;\nuse function is_bool;\nuse function is_int;\nuse function is_string;\nuse function preg_quote;\nuse function preg_replace;\nuse function sprintf;\nuse function str_replace;\nuse function strlen;\nuse function strpos;\nuse function strtolower;\nuse function strtoupper;\n\n/**\n * Base class for all DatabasePlatforms. The DatabasePlatforms are the central\n * point of abstraction of platform-specific behaviors, features and SQL dialects.\n * They are a passive source of information.\n *\n * @todo Remove any unnecessary methods.\n */\nabstract class AbstractPlatform\n{\n    public const CREATE_INDEXES = 1;\n\n    public const CREATE_FOREIGNKEYS = 2;\n\n    /** @var string[]|null */\n    protected $doctrineTypeMapping;\n\n    /**\n     * Contains a list of all columns that should generate parseable column comments for type-detection\n     * in reverse engineering scenarios.\n     *\n     * @var string[]|null\n     */\n    protected $doctrineTypeComments;\n\n    /** @var EventManager|null */\n    protected $_eventManager;\n\n    /**\n     * Holds the KeywordList instance for the current platform.\n     *\n     * @var KeywordList|null\n     */\n    protected $_keywords;\n\n    public function __construct()\n    {\n    }\n\n    /**\n     * Sets the EventManager used by the Platform.\n     *\n     * @return void\n     */\n    public function setEventManager(EventManager $eventManager)\n    {\n        $this->_eventManager = $eventManager;\n    }\n\n    /**\n     * Gets the EventManager used by the Platform.\n     *\n     * @return EventManager|null\n     */\n    public function getEventManager()\n    {\n        return $this->_eventManager;\n    }\n\n    /**\n     * Returns the SQL snippet that declares a boolean column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getBooleanTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL snippet that declares a 4 byte integer column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getIntegerTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL snippet that declares an 8 byte integer column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getBigIntTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL snippet that declares a 2 byte integer column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getSmallIntTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL snippet that declares common properties of an integer column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract protected function _getCommonIntegerTypeDeclarationSQL(array $column);\n\n    /**\n     * Lazy load Doctrine Type Mappings.\n     *\n     * @return void\n     */\n    abstract protected function initializeDoctrineTypeMappings();\n\n    /**\n     * Initializes Doctrine Type Mappings with the platform defaults\n     * and with all additional type mappings.\n     *\n     * @return void\n     */\n    private function initializeAllDoctrineTypeMappings()\n    {\n        $this->initializeDoctrineTypeMappings();\n\n        foreach (Type::getTypesMap() as $typeName => $className) {\n            foreach (Type::getType($typeName)->getMappedDatabaseTypes($this) as $dbType) {\n                $this->doctrineTypeMapping[$dbType] = $typeName;\n            }\n        }\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a column that can\n     * store characters in the ASCII character set\n     *\n     * @param mixed[] $column\n     */\n    public function getAsciiStringTypeDeclarationSQL(array $column): string\n    {\n        return $this->getVarcharTypeDeclarationSQL($column);\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a VARCHAR column type.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getVarcharTypeDeclarationSQL(array $column)\n    {\n        if (! isset($column['length'])) {\n            $column['length'] = $this->getVarcharDefaultLength();\n        }\n\n        $fixed = $column['fixed'] ?? false;\n\n        $maxLength = $fixed\n            ? $this->getCharMaxLength()\n            : $this->getVarcharMaxLength();\n\n        if ($column['length'] > $maxLength) {\n            return $this->getClobTypeDeclarationSQL($column);\n        }\n\n        return $this->getVarcharTypeDeclarationSQLSnippet($column['length'], $fixed);\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a BINARY/VARBINARY column type.\n     *\n     * @param mixed[] $column The column definition.\n     *\n     * @return string\n     */\n    public function getBinaryTypeDeclarationSQL(array $column)\n    {\n        if (! isset($column['length'])) {\n            $column['length'] = $this->getBinaryDefaultLength();\n        }\n\n        $fixed = $column['fixed'] ?? false;\n\n        $maxLength = $this->getBinaryMaxLength();\n\n        if ($column['length'] > $maxLength) {\n            if ($maxLength > 0) {\n                Deprecation::trigger(\n                    'doctrine/dbal',\n                    'https://github.com/doctrine/dbal/issues/3187',\n                    'Binary column length %d is greater than supported by the platform (%d).'\n                        . ' Reduce the column length or use a BLOB column instead.',\n                    $column['length'],\n                    $maxLength\n                );\n            }\n\n            return $this->getBlobTypeDeclarationSQL($column);\n        }\n\n        return $this->getBinaryTypeDeclarationSQLSnippet($column['length'], $fixed);\n    }\n\n    /**\n     * Returns the SQL snippet to declare a GUID/UUID column.\n     *\n     * By default this maps directly to a CHAR(36) and only maps to more\n     * special datatypes when the underlying databases support this datatype.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getGuidTypeDeclarationSQL(array $column)\n    {\n        $column['length'] = 36;\n        $column['fixed']  = true;\n\n        return $this->getVarcharTypeDeclarationSQL($column);\n    }\n\n    /**\n     * Returns the SQL snippet to declare a JSON column.\n     *\n     * By default this maps directly to a CLOB and only maps to more\n     * special datatypes when the underlying databases support this datatype.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getJsonTypeDeclarationSQL(array $column)\n    {\n        return $this->getClobTypeDeclarationSQL($column);\n    }\n\n    /**\n     * @param int|false $length\n     * @param bool      $fixed\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    protected function getVarcharTypeDeclarationSQLSnippet($length, $fixed)\n    {\n        throw Exception::notSupported('VARCHARs not supported by Platform.');\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a BINARY/VARBINARY column type.\n     *\n     * @param int|false $length The length of the column.\n     * @param bool      $fixed  Whether the column length is fixed.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    protected function getBinaryTypeDeclarationSQLSnippet($length, $fixed)\n    {\n        throw Exception::notSupported('BINARY/VARBINARY column types are not supported by this platform.');\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a CLOB column type.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getClobTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL Snippet used to declare a BLOB column type.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getBlobTypeDeclarationSQL(array $column);\n\n    /**\n     * Gets the name of the platform.\n     *\n     * @return string\n     */\n    abstract public function getName();\n\n    /**\n     * Registers a doctrine type to be used in conjunction with a column type of this platform.\n     *\n     * @param string $dbType\n     * @param string $doctrineType\n     *\n     * @return void\n     *\n     * @throws Exception If the type is not found.\n     */\n    public function registerDoctrineTypeMapping($dbType, $doctrineType)\n    {\n        if ($this->doctrineTypeMapping === null) {\n            $this->initializeAllDoctrineTypeMappings();\n        }\n\n        if (! Types\\Type::hasType($doctrineType)) {\n            throw Exception::typeNotFound($doctrineType);\n        }\n\n        $dbType                             = strtolower($dbType);\n        $this->doctrineTypeMapping[$dbType] = $doctrineType;\n\n        $doctrineType = Type::getType($doctrineType);\n\n        if (! $doctrineType->requiresSQLCommentHint($this)) {\n            return;\n        }\n\n        $this->markDoctrineTypeCommented($doctrineType);\n    }\n\n    /**\n     * Gets the Doctrine type that is mapped for the given database column type.\n     *\n     * @param string $dbType\n     *\n     * @return string\n     *\n     * @throws Exception\n     */\n    public function getDoctrineTypeMapping($dbType)\n    {\n        if ($this->doctrineTypeMapping === null) {\n            $this->initializeAllDoctrineTypeMappings();\n        }\n\n        $dbType = strtolower($dbType);\n\n        if (! isset($this->doctrineTypeMapping[$dbType])) {\n            throw new Exception(\n                'Unknown database type ' . $dbType . ' requested, ' . static::class . ' may not support it.'\n            );\n        }\n\n        return $this->doctrineTypeMapping[$dbType];\n    }\n\n    /**\n     * Checks if a database type is currently supported by this platform.\n     *\n     * @param string $dbType\n     *\n     * @return bool\n     */\n    public function hasDoctrineTypeMappingFor($dbType)\n    {\n        if ($this->doctrineTypeMapping === null) {\n            $this->initializeAllDoctrineTypeMappings();\n        }\n\n        $dbType = strtolower($dbType);\n\n        return isset($this->doctrineTypeMapping[$dbType]);\n    }\n\n    /**\n     * Initializes the Doctrine Type comments instance variable for in_array() checks.\n     *\n     * @return void\n     */\n    protected function initializeCommentedDoctrineTypes()\n    {\n        $this->doctrineTypeComments = [];\n\n        foreach (Type::getTypesMap() as $typeName => $className) {\n            $type = Type::getType($typeName);\n\n            if (! $type->requiresSQLCommentHint($this)) {\n                continue;\n            }\n\n            $this->doctrineTypeComments[] = $typeName;\n        }\n    }\n\n    /**\n     * Is it necessary for the platform to add a parsable type comment to allow reverse engineering the given type?\n     *\n     * @return bool\n     */\n    public function isCommentedDoctrineType(Type $doctrineType)\n    {\n        if ($this->doctrineTypeComments === null) {\n            $this->initializeCommentedDoctrineTypes();\n        }\n\n        assert(is_array($this->doctrineTypeComments));\n\n        return in_array($doctrineType->getName(), $this->doctrineTypeComments, true);\n    }\n\n    /**\n     * Marks this type as to be commented in ALTER TABLE and CREATE TABLE statements.\n     *\n     * @param string|Type $doctrineType\n     *\n     * @return void\n     */\n    public function markDoctrineTypeCommented($doctrineType)\n    {\n        if ($this->doctrineTypeComments === null) {\n            $this->initializeCommentedDoctrineTypes();\n        }\n\n        assert(is_array($this->doctrineTypeComments));\n\n        $this->doctrineTypeComments[] = $doctrineType instanceof Type ? $doctrineType->getName() : $doctrineType;\n    }\n\n    /**\n     * Gets the comment to append to a column comment that helps parsing this type in reverse engineering.\n     *\n     * @return string\n     */\n    public function getDoctrineTypeComment(Type $doctrineType)\n    {\n        return '(DC2Type:' . $doctrineType->getName() . ')';\n    }\n\n    /**\n     * Gets the comment of a passed column modified by potential doctrine type comment hints.\n     *\n     * @return string|null\n     */\n    protected function getColumnComment(Column $column)\n    {\n        $comment = $column->getComment();\n\n        if ($this->isCommentedDoctrineType($column->getType())) {\n            $comment .= $this->getDoctrineTypeComment($column->getType());\n        }\n\n        return $comment;\n    }\n\n    /**\n     * Gets the character used for identifier quoting.\n     *\n     * @return string\n     */\n    public function getIdentifierQuoteCharacter()\n    {\n        return '\"';\n    }\n\n    /**\n     * Gets the string portion that starts an SQL comment.\n     *\n     * @return string\n     */\n    public function getSqlCommentStartString()\n    {\n        return '--';\n    }\n\n    /**\n     * Gets the string portion that ends an SQL comment.\n     *\n     * @return string\n     */\n    public function getSqlCommentEndString()\n    {\n        return \"\\n\";\n    }\n\n    /**\n     * Gets the maximum length of a char column.\n     */\n    public function getCharMaxLength(): int\n    {\n        return $this->getVarcharMaxLength();\n    }\n\n    /**\n     * Gets the maximum length of a varchar column.\n     *\n     * @return int\n     */\n    public function getVarcharMaxLength()\n    {\n        return 4000;\n    }\n\n    /**\n     * Gets the default length of a varchar column.\n     *\n     * @return int\n     */\n    public function getVarcharDefaultLength()\n    {\n        return 255;\n    }\n\n    /**\n     * Gets the maximum length of a binary column.\n     *\n     * @return int\n     */\n    public function getBinaryMaxLength()\n    {\n        return 4000;\n    }\n\n    /**\n     * Gets the default length of a binary column.\n     *\n     * @return int\n     */\n    public function getBinaryDefaultLength()\n    {\n        return 255;\n    }\n\n    /**\n     * Gets all SQL wildcard characters of the platform.\n     *\n     * @return string[]\n     */\n    public function getWildcards()\n    {\n        return ['%', '_'];\n    }\n\n    /**\n     * Returns the regular expression operator.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getRegexpExpression()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL snippet to get the average value of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including an AVG aggregate function.\n     */\n    public function getAvgExpression($column)\n    {\n        return 'AVG(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the number of rows (without a NULL value) of a column.\n     *\n     * If a '*' is used instead of a column the number of selected rows is returned.\n     *\n     * @param string|int $column The column to use.\n     *\n     * @return string Generated SQL including a COUNT aggregate function.\n     */\n    public function getCountExpression($column)\n    {\n        return 'COUNT(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the highest value of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including a MAX aggregate function.\n     */\n    public function getMaxExpression($column)\n    {\n        return 'MAX(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the lowest value of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including a MIN aggregate function.\n     */\n    public function getMinExpression($column)\n    {\n        return 'MIN(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the total sum of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including a SUM aggregate function.\n     */\n    public function getSumExpression($column)\n    {\n        return 'SUM(' . $column . ')';\n    }\n\n    // scalar functions\n\n    /**\n     * Returns the SQL snippet to get the md5 sum of a column.\n     *\n     * Note: Not SQL92, but common functionality.\n     *\n     * @param string $column\n     *\n     * @return string\n     */\n    public function getMd5Expression($column)\n    {\n        return 'MD5(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the length of a text column.\n     *\n     * @param string $column\n     *\n     * @return string\n     */\n    public function getLengthExpression($column)\n    {\n        return 'LENGTH(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the squared value of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including an SQRT aggregate function.\n     */\n    public function getSqrtExpression($column)\n    {\n        return 'SQRT(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to round a numeric column to the number of decimals specified.\n     *\n     * @param string $column\n     * @param int    $decimals\n     *\n     * @return string\n     */\n    public function getRoundExpression($column, $decimals = 0)\n    {\n        return 'ROUND(' . $column . ', ' . $decimals . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the remainder of the division operation $expression1 / $expression2.\n     *\n     * @param string $expression1\n     * @param string $expression2\n     *\n     * @return string\n     */\n    public function getModExpression($expression1, $expression2)\n    {\n        return 'MOD(' . $expression1 . ', ' . $expression2 . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to trim a string.\n     *\n     * @param string      $str  The expression to apply the trim to.\n     * @param int         $mode The position of the trim (leading/trailing/both).\n     * @param string|bool $char The char to trim, has to be quoted already. Defaults to space.\n     *\n     * @return string\n     */\n    public function getTrimExpression($str, $mode = TrimMode::UNSPECIFIED, $char = false)\n    {\n        $expression = '';\n\n        switch ($mode) {\n            case TrimMode::LEADING:\n                $expression = 'LEADING ';\n                break;\n\n            case TrimMode::TRAILING:\n                $expression = 'TRAILING ';\n                break;\n\n            case TrimMode::BOTH:\n                $expression = 'BOTH ';\n                break;\n        }\n\n        if ($char !== false) {\n            $expression .= $char . ' ';\n        }\n\n        if ($mode !== TrimMode::UNSPECIFIED || $char !== false) {\n            $expression .= 'FROM ';\n        }\n\n        return 'TRIM(' . $expression . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to trim trailing space characters from the expression.\n     *\n     * @param string $str Literal string or column name.\n     *\n     * @return string\n     */\n    public function getRtrimExpression($str)\n    {\n        return 'RTRIM(' . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to trim leading space characters from the expression.\n     *\n     * @param string $str Literal string or column name.\n     *\n     * @return string\n     */\n    public function getLtrimExpression($str)\n    {\n        return 'LTRIM(' . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to change all characters from the expression to uppercase,\n     * according to the current character set mapping.\n     *\n     * @param string $str Literal string or column name.\n     *\n     * @return string\n     */\n    public function getUpperExpression($str)\n    {\n        return 'UPPER(' . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to change all characters from the expression to lowercase,\n     * according to the current character set mapping.\n     *\n     * @param string $str Literal string or column name.\n     *\n     * @return string\n     */\n    public function getLowerExpression($str)\n    {\n        return 'LOWER(' . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the position of the first occurrence of substring $substr in string $str.\n     *\n     * @param string    $str      Literal string.\n     * @param string    $substr   Literal string to find.\n     * @param int|false $startPos Position to start at, beginning of string by default.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getLocateExpression($str, $substr, $startPos = false)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL snippet to get the current system date.\n     *\n     * @return string\n     */\n    public function getNowExpression()\n    {\n        return 'NOW()';\n    }\n\n    /**\n     * Returns a SQL snippet to get a substring inside an SQL statement.\n     *\n     * Note: Not SQL92, but common functionality.\n     *\n     * SQLite only supports the 2 parameter variant of this function.\n     *\n     * @param string   $string An sql string literal or column name/alias.\n     * @param int      $start  Where to start the substring portion.\n     * @param int|null $length The substring portion length.\n     *\n     * @return string\n     */\n    public function getSubstringExpression($string, $start, $length = null)\n    {\n        if ($length === null) {\n            return 'SUBSTRING(' . $string . ' FROM ' . $start . ')';\n        }\n\n        return 'SUBSTRING(' . $string . ' FROM ' . $start . ' FOR ' . $length . ')';\n    }\n\n    /**\n     * Returns a SQL snippet to concatenate the given expressions.\n     *\n     * Accepts an arbitrary number of string parameters. Each parameter must contain an expression.\n     *\n     * @return string\n     */\n    public function getConcatExpression()\n    {\n        return implode(' || ', func_get_args());\n    }\n\n    /**\n     * Returns the SQL for a logical not.\n     *\n     * Example:\n     * <code>\n     * $q = new Doctrine_Query();\n     * $e = $q->expr;\n     * $q->select('*')->from('table')\n     *   ->where($e->eq('id', $e->not('null'));\n     * </code>\n     *\n     * @param string $expression\n     *\n     * @return string The logical expression.\n     */\n    public function getNotExpression($expression)\n    {\n        return 'NOT(' . $expression . ')';\n    }\n\n    /**\n     * Returns the SQL that checks if an expression is null.\n     *\n     * @param string $expression The expression that should be compared to null.\n     *\n     * @return string The logical expression.\n     */\n    public function getIsNullExpression($expression)\n    {\n        return $expression . ' IS NULL';\n    }\n\n    /**\n     * Returns the SQL that checks if an expression is not null.\n     *\n     * @param string $expression The expression that should be compared to null.\n     *\n     * @return string The logical expression.\n     */\n    public function getIsNotNullExpression($expression)\n    {\n        return $expression . ' IS NOT NULL';\n    }\n\n    /**\n     * Returns the SQL that checks if an expression evaluates to a value between two values.\n     *\n     * The parameter $expression is checked if it is between $value1 and $value2.\n     *\n     * Note: There is a slight difference in the way BETWEEN works on some databases.\n     * http://www.w3schools.com/sql/sql_between.asp. If you want complete database\n     * independence you should avoid using between().\n     *\n     * @param string $expression The value to compare to.\n     * @param string $value1     The lower value to compare with.\n     * @param string $value2     The higher value to compare with.\n     *\n     * @return string The logical expression.\n     */\n    public function getBetweenExpression($expression, $value1, $value2)\n    {\n        return $expression . ' BETWEEN ' . $value1 . ' AND ' . $value2;\n    }\n\n    /**\n     * Returns the SQL to get the arccosine of a value.\n     *\n     * @param string $value\n     *\n     * @return string\n     */\n    public function getAcosExpression($value)\n    {\n        return 'ACOS(' . $value . ')';\n    }\n\n    /**\n     * Returns the SQL to get the sine of a value.\n     *\n     * @param string $value\n     *\n     * @return string\n     */\n    public function getSinExpression($value)\n    {\n        return 'SIN(' . $value . ')';\n    }\n\n    /**\n     * Returns the SQL to get the PI value.\n     *\n     * @return string\n     */\n    public function getPiExpression()\n    {\n        return 'PI()';\n    }\n\n    /**\n     * Returns the SQL to get the cosine of a value.\n     *\n     * @param string $value\n     *\n     * @return string\n     */\n    public function getCosExpression($value)\n    {\n        return 'COS(' . $value . ')';\n    }\n\n    /**\n     * Returns the SQL to calculate the difference in days between the two passed dates.\n     *\n     * Computes diff = date1 - date2.\n     *\n     * @param string $date1\n     * @param string $date2\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateDiffExpression($date1, $date2)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to add the number of given seconds to a date.\n     *\n     * @param string $date\n     * @param int    $seconds\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddSecondsExpression($date, $seconds)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $seconds, DateIntervalUnit::SECOND);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given seconds from a date.\n     *\n     * @param string $date\n     * @param int    $seconds\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubSecondsExpression($date, $seconds)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $seconds, DateIntervalUnit::SECOND);\n    }\n\n    /**\n     * Returns the SQL to add the number of given minutes to a date.\n     *\n     * @param string $date\n     * @param int    $minutes\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddMinutesExpression($date, $minutes)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $minutes, DateIntervalUnit::MINUTE);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given minutes from a date.\n     *\n     * @param string $date\n     * @param int    $minutes\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubMinutesExpression($date, $minutes)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $minutes, DateIntervalUnit::MINUTE);\n    }\n\n    /**\n     * Returns the SQL to add the number of given hours to a date.\n     *\n     * @param string $date\n     * @param int    $hours\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddHourExpression($date, $hours)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $hours, DateIntervalUnit::HOUR);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given hours to a date.\n     *\n     * @param string $date\n     * @param int    $hours\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubHourExpression($date, $hours)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $hours, DateIntervalUnit::HOUR);\n    }\n\n    /**\n     * Returns the SQL to add the number of given days to a date.\n     *\n     * @param string $date\n     * @param int    $days\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddDaysExpression($date, $days)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $days, DateIntervalUnit::DAY);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given days to a date.\n     *\n     * @param string $date\n     * @param int    $days\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubDaysExpression($date, $days)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $days, DateIntervalUnit::DAY);\n    }\n\n    /**\n     * Returns the SQL to add the number of given weeks to a date.\n     *\n     * @param string $date\n     * @param int    $weeks\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddWeeksExpression($date, $weeks)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $weeks, DateIntervalUnit::WEEK);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given weeks from a date.\n     *\n     * @param string $date\n     * @param int    $weeks\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubWeeksExpression($date, $weeks)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $weeks, DateIntervalUnit::WEEK);\n    }\n\n    /**\n     * Returns the SQL to add the number of given months to a date.\n     *\n     * @param string $date\n     * @param int    $months\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddMonthExpression($date, $months)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $months, DateIntervalUnit::MONTH);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given months to a date.\n     *\n     * @param string $date\n     * @param int    $months\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubMonthExpression($date, $months)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $months, DateIntervalUnit::MONTH);\n    }\n\n    /**\n     * Returns the SQL to add the number of given quarters to a date.\n     *\n     * @param string $date\n     * @param int    $quarters\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddQuartersExpression($date, $quarters)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $quarters, DateIntervalUnit::QUARTER);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given quarters from a date.\n     *\n     * @param string $date\n     * @param int    $quarters\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubQuartersExpression($date, $quarters)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $quarters, DateIntervalUnit::QUARTER);\n    }\n\n    /**\n     * Returns the SQL to add the number of given years to a date.\n     *\n     * @param string $date\n     * @param int    $years\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddYearsExpression($date, $years)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $years, DateIntervalUnit::YEAR);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given years from a date.\n     *\n     * @param string $date\n     * @param int    $years\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubYearsExpression($date, $years)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $years, DateIntervalUnit::YEAR);\n    }\n\n    /**\n     * Returns the SQL for a date arithmetic expression.\n     *\n     * @param string $date     The column or literal representing a date to perform the arithmetic operation on.\n     * @param string $operator The arithmetic operator (+ or -).\n     * @param int    $interval The interval that shall be calculated into the date.\n     * @param string $unit     The unit of the interval that shall be calculated into the date.\n     *                         One of the DATE_INTERVAL_UNIT_* constants.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    protected function getDateArithmeticIntervalExpression($date, $operator, $interval, $unit)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL bit AND comparison expression.\n     *\n     * @param string $value1\n     * @param string $value2\n     *\n     * @return string\n     */\n    public function getBitAndComparisonExpression($value1, $value2)\n    {\n        return '(' . $value1 . ' & ' . $value2 . ')';\n    }\n\n    /**\n     * Returns the SQL bit OR comparison expression.\n     *\n     * @param string $value1\n     * @param string $value2\n     *\n     * @return string\n     */\n    public function getBitOrComparisonExpression($value1, $value2)\n    {\n        return '(' . $value1 . ' | ' . $value2 . ')';\n    }\n\n    /**\n     * Returns the SQL expression which represents the currently selected database.\n     */\n    abstract public function getCurrentDatabaseExpression(): string;\n\n    /**\n     * Returns the FOR UPDATE expression.\n     *\n     * @return string\n     */\n    public function getForUpdateSQL()\n    {\n        return 'FOR UPDATE';\n    }\n\n    /**\n     * Honors that some SQL vendors such as MsSql use table hints for locking instead of the\n     * ANSI SQL FOR UPDATE specification.\n     *\n     * @param string $fromClause The FROM clause to append the hint for the given lock mode to\n     * @param int    $lockMode   One of the Doctrine\\DBAL\\LockMode::* constants\n     */\n    public function appendLockHint(string $fromClause, int $lockMode): string\n    {\n        switch ($lockMode) {\n            case LockMode::NONE:\n            case LockMode::OPTIMISTIC:\n            case LockMode::PESSIMISTIC_READ:\n            case LockMode::PESSIMISTIC_WRITE:\n                return $fromClause;\n\n            default:\n                throw InvalidLockMode::fromLockMode($lockMode);\n        }\n    }\n\n    /**\n     * Returns the SQL snippet to append to any SELECT statement which locks rows in shared read lock.\n     *\n     * This defaults to the ANSI SQL \"FOR UPDATE\", which is an exclusive lock (Write). Some database\n     * vendors allow to lighten this constraint up to be a real read lock.\n     *\n     * @return string\n     */\n    public function getReadLockSQL()\n    {\n        return $this->getForUpdateSQL();\n    }\n\n    /**\n     * Returns the SQL snippet to append to any SELECT statement which obtains an exclusive lock on the rows.\n     *\n     * The semantics of this lock mode should equal the SELECT .. FOR UPDATE of the ANSI SQL standard.\n     *\n     * @return string\n     */\n    public function getWriteLockSQL()\n    {\n        return $this->getForUpdateSQL();\n    }\n\n    /**\n     * Returns the SQL snippet to drop an existing database.\n     *\n     * @param string $name The name of the database that should be dropped.\n     *\n     * @return string\n     */\n    public function getDropDatabaseSQL($name)\n    {\n        return 'DROP DATABASE ' . $name;\n    }\n\n    /**\n     * Returns the SQL snippet to drop a schema.\n     */\n    public function getDropSchemaSQL(string $schemaName): string\n    {\n        return 'DROP SCHEMA ' . $schemaName;\n    }\n\n    /**\n     * Returns the SQL snippet to drop an existing table.\n     *\n     * @param Table|string $table\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getDropTableSQL($table)\n    {\n        $tableArg = $table;\n\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        if (! is_string($table)) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() expects $table parameter to be string or ' . Table::class . '.'\n            );\n        }\n\n        if ($this->_eventManager !== null && $this->_eventManager->hasListeners(Events::onSchemaDropTable)) {\n            $eventArgs = new SchemaDropTableEventArgs($tableArg, $this);\n            $this->_eventManager->dispatchEvent(Events::onSchemaDropTable, $eventArgs);\n\n            if ($eventArgs->isDefaultPrevented()) {\n                $sql = $eventArgs->getSql();\n\n                if ($sql === null) {\n                    throw new UnexpectedValueException('Default implementation of DROP TABLE was overridden with NULL');\n                }\n\n                return $sql;\n            }\n        }\n\n        return 'DROP TABLE ' . $table;\n    }\n\n    /**\n     * Returns the SQL to safely drop a temporary table WITHOUT implicitly committing an open transaction.\n     *\n     * @param Table|string $table\n     *\n     * @return string\n     */\n    public function getDropTemporaryTableSQL($table)\n    {\n        return $this->getDropTableSQL($table);\n    }\n\n    /**\n     * Returns the SQL to drop an index from a table.\n     *\n     * @param Index|string $index\n     * @param Table|string $table\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getDropIndexSQL($index, $table = null)\n    {\n        if ($index instanceof Index) {\n            $index = $index->getQuotedName($this);\n        } elseif (! is_string($index)) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() expects $index parameter to be string or ' . Index::class . '.'\n            );\n        }\n\n        return 'DROP INDEX ' . $index;\n    }\n\n    /**\n     * Returns the SQL to drop a constraint.\n     *\n     * @param Constraint|string $constraint\n     * @param Table|string      $table\n     *\n     * @return string\n     */\n    public function getDropConstraintSQL($constraint, $table)\n    {\n        if (! $constraint instanceof Constraint) {\n            $constraint = new Identifier($constraint);\n        }\n\n        if (! $table instanceof Table) {\n            $table = new Identifier($table);\n        }\n\n        $constraint = $constraint->getQuotedName($this);\n        $table      = $table->getQuotedName($this);\n\n        return 'ALTER TABLE ' . $table . ' DROP CONSTRAINT ' . $constraint;\n    }\n\n    /**\n     * Returns the SQL to drop a foreign key.\n     *\n     * @param ForeignKeyConstraint|string $foreignKey\n     * @param Table|string                $table\n     *\n     * @return string\n     */\n    public function getDropForeignKeySQL($foreignKey, $table)\n    {\n        if (! $foreignKey instanceof ForeignKeyConstraint) {\n            $foreignKey = new Identifier($foreignKey);\n        }\n\n        if (! $table instanceof Table) {\n            $table = new Identifier($table);\n        }\n\n        $foreignKey = $foreignKey->getQuotedName($this);\n        $table      = $table->getQuotedName($this);\n\n        return 'ALTER TABLE ' . $table . ' DROP FOREIGN KEY ' . $foreignKey;\n    }\n\n    /**\n     * Returns the SQL statement(s) to create a table with the specified name, columns and constraints\n     * on this platform.\n     *\n     * @param int $createFlags\n     *\n     * @return string[] The sequence of SQL statements.\n     *\n     * @throws Exception\n     * @throws InvalidArgumentException\n     */\n    public function getCreateTableSQL(Table $table, $createFlags = self::CREATE_INDEXES)\n    {\n        if (! is_int($createFlags)) {\n            throw new InvalidArgumentException(\n                'Second argument of AbstractPlatform::getCreateTableSQL() has to be integer.'\n            );\n        }\n\n        if (count($table->getColumns()) === 0) {\n            throw Exception::noColumnsSpecifiedForTable($table->getName());\n        }\n\n        $tableName                    = $table->getQuotedName($this);\n        $options                      = $table->getOptions();\n        $options['uniqueConstraints'] = [];\n        $options['indexes']           = [];\n        $options['primary']           = [];\n\n        if (($createFlags & self::CREATE_INDEXES) > 0) {\n            foreach ($table->getIndexes() as $index) {\n                if (! $index->isPrimary()) {\n                    $options['indexes'][$index->getQuotedName($this)] = $index;\n\n                    continue;\n                }\n\n                $options['primary']       = $index->getQuotedColumns($this);\n                $options['primary_index'] = $index;\n            }\n\n            foreach ($table->getUniqueConstraints() as $uniqueConstraint) {\n                $options['uniqueConstraints'][$uniqueConstraint->getQuotedName($this)] = $uniqueConstraint;\n            }\n        }\n\n        if (($createFlags & self::CREATE_FOREIGNKEYS) > 0) {\n            $options['foreignKeys'] = [];\n\n            foreach ($table->getForeignKeys() as $fkConstraint) {\n                $options['foreignKeys'][] = $fkConstraint;\n            }\n        }\n\n        $columnSql = [];\n        $columns   = [];\n\n        foreach ($table->getColumns() as $column) {\n            if (\n                $this->_eventManager !== null\n                && $this->_eventManager->hasListeners(Events::onSchemaCreateTableColumn)\n            ) {\n                $eventArgs = new SchemaCreateTableColumnEventArgs($column, $table, $this);\n\n                $this->_eventManager->dispatchEvent(Events::onSchemaCreateTableColumn, $eventArgs);\n\n                $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n                if ($eventArgs->isDefaultPrevented()) {\n                    continue;\n                }\n            }\n\n            $name = $column->getQuotedName($this);\n\n            $columnData = array_merge($column->toArray(), [\n                'name' => $name,\n                'version' => $column->hasPlatformOption('version') ? $column->getPlatformOption('version') : false,\n                'comment' => $this->getColumnComment($column),\n            ]);\n\n            if ($columnData['type'] instanceof Types\\StringType && $columnData['length'] === null) {\n                $columnData['length'] = 255;\n            }\n\n            if (in_array($column->getName(), $options['primary'], true)) {\n                $columnData['primary'] = true;\n            }\n\n            $columns[$name] = $columnData;\n        }\n\n        if ($this->_eventManager !== null && $this->_eventManager->hasListeners(Events::onSchemaCreateTable)) {\n            $eventArgs = new SchemaCreateTableEventArgs($table, $columns, $options, $this);\n\n            $this->_eventManager->dispatchEvent(Events::onSchemaCreateTable, $eventArgs);\n\n            if ($eventArgs->isDefaultPrevented()) {\n                return array_merge($eventArgs->getSql(), $columnSql);\n            }\n        }\n\n        $sql = $this->_getCreateTableSQL($tableName, $columns, $options);\n\n        if ($this->supportsCommentOnStatement()) {\n            if ($table->hasOption('comment')) {\n                $sql[] = $this->getCommentOnTableSQL($tableName, $table->getOption('comment'));\n            }\n\n            foreach ($table->getColumns() as $column) {\n                $comment = $this->getColumnComment($column);\n\n                if ($comment === null || $comment === '') {\n                    continue;\n                }\n\n                $sql[] = $this->getCommentOnColumnSQL($tableName, $column->getQuotedName($this), $comment);\n            }\n        }\n\n        return array_merge($sql, $columnSql);\n    }\n\n    protected function getCommentOnTableSQL(string $tableName, ?string $comment): string\n    {\n        $tableName = new Identifier($tableName);\n\n        return sprintf(\n            'COMMENT ON TABLE %s IS %s',\n            $tableName->getQuotedName($this),\n            $this->quoteStringLiteral((string) $comment)\n        );\n    }\n\n    /**\n     * @param string      $tableName\n     * @param string      $columnName\n     * @param string|null $comment\n     *\n     * @return string\n     */\n    public function getCommentOnColumnSQL($tableName, $columnName, $comment)\n    {\n        $tableName  = new Identifier($tableName);\n        $columnName = new Identifier($columnName);\n\n        return sprintf(\n            'COMMENT ON COLUMN %s.%s IS %s',\n            $tableName->getQuotedName($this),\n            $columnName->getQuotedName($this),\n            $this->quoteStringLiteral((string) $comment)\n        );\n    }\n\n    /**\n     * Returns the SQL to create inline comment on a column.\n     *\n     * @param string $comment\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getInlineColumnCommentSQL($comment)\n    {\n        if (! $this->supportsInlineColumnComments()) {\n            throw Exception::notSupported(__METHOD__);\n        }\n\n        return 'COMMENT ' . $this->quoteStringLiteral($comment);\n    }\n\n    /**\n     * Returns the SQL used to create a table.\n     *\n     * @param string    $name\n     * @param mixed[][] $columns\n     * @param mixed[]   $options\n     *\n     * @return string[]\n     */\n    protected function _getCreateTableSQL($name, array $columns, array $options = [])\n    {\n        $columnListSql = $this->getColumnDeclarationListSQL($columns);\n\n        if (isset($options['uniqueConstraints']) && ! empty($options['uniqueConstraints'])) {\n            foreach ($options['uniqueConstraints'] as $index => $definition) {\n                $columnListSql .= ', ' . $this->getUniqueConstraintDeclarationSQL($index, $definition);\n            }\n        }\n\n        if (isset($options['primary']) && ! empty($options['primary'])) {\n            $columnListSql .= ', PRIMARY KEY(' . implode(', ', array_unique(array_values($options['primary']))) . ')';\n        }\n\n        if (isset($options['indexes']) && ! empty($options['indexes'])) {\n            foreach ($options['indexes'] as $index => $definition) {\n                $columnListSql .= ', ' . $this->getIndexDeclarationSQL($index, $definition);\n            }\n        }\n\n        $query = 'CREATE TABLE ' . $name . ' (' . $columnListSql;\n        $check = $this->getCheckDeclarationSQL($columns);\n\n        if (! empty($check)) {\n            $query .= ', ' . $check;\n        }\n\n        $query .= ')';\n\n        $sql = [$query];\n\n        if (isset($options['foreignKeys'])) {\n            foreach ((array) $options['foreignKeys'] as $definition) {\n                $sql[] = $this->getCreateForeignKeySQL($definition, $name);\n            }\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @return string\n     */\n    public function getCreateTemporaryTableSnippetSQL()\n    {\n        return 'CREATE TEMPORARY TABLE';\n    }\n\n    /**\n     * Returns the SQL to create a sequence on this platform.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getCreateSequenceSQL(Sequence $sequence)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to change a sequence on this platform.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getAlterSequenceSQL(Sequence $sequence)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to create a constraint on a table on this platform.\n     *\n     * @param Table|string $table\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getCreateConstraintSQL(Constraint $constraint, $table)\n    {\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        $query = 'ALTER TABLE ' . $table . ' ADD CONSTRAINT ' . $constraint->getQuotedName($this);\n\n        $columnList = '(' . implode(', ', $constraint->getQuotedColumns($this)) . ')';\n\n        $referencesClause = '';\n        if ($constraint instanceof Index) {\n            if ($constraint->isPrimary()) {\n                $query .= ' PRIMARY KEY';\n            } elseif ($constraint->isUnique()) {\n                $query .= ' UNIQUE';\n            } else {\n                throw new InvalidArgumentException(\n                    'Can only create primary or unique constraints, no common indexes with getCreateConstraintSQL().'\n                );\n            }\n        } elseif ($constraint instanceof UniqueConstraint) {\n            $query .= ' UNIQUE';\n        } elseif ($constraint instanceof ForeignKeyConstraint) {\n            $query .= ' FOREIGN KEY';\n\n            $referencesClause = ' REFERENCES ' . $constraint->getQuotedForeignTableName($this) .\n                ' (' . implode(', ', $constraint->getQuotedForeignColumns($this)) . ')';\n        }\n\n        $query .= ' ' . $columnList . $referencesClause;\n\n        return $query;\n    }\n\n    /**\n     * Returns the SQL to create an index on a table on this platform.\n     *\n     * @param Table|string $table The name of the table on which the index is to be created.\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getCreateIndexSQL(Index $index, $table)\n    {\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        $name    = $index->getQuotedName($this);\n        $columns = $index->getColumns();\n\n        if (count($columns) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'columns' required.\");\n        }\n\n        if ($index->isPrimary()) {\n            return $this->getCreatePrimaryKeySQL($index, $table);\n        }\n\n        $query  = 'CREATE ' . $this->getCreateIndexSQLFlags($index) . 'INDEX ' . $name . ' ON ' . $table;\n        $query .= ' (' . $this->getIndexFieldDeclarationListSQL($index) . ')' . $this->getPartialIndexSQL($index);\n\n        return $query;\n    }\n\n    /**\n     * Adds condition for partial index.\n     *\n     * @return string\n     */\n    protected function getPartialIndexSQL(Index $index)\n    {\n        if ($this->supportsPartialIndexes() && $index->hasOption('where')) {\n            return ' WHERE ' . $index->getOption('where');\n        }\n\n        return '';\n    }\n\n    /**\n     * Adds additional flags for index generation.\n     *\n     * @return string\n     */\n    protected function getCreateIndexSQLFlags(Index $index)\n    {\n        return $index->isUnique() ? 'UNIQUE ' : '';\n    }\n\n    /**\n     * Returns the SQL to create an unnamed primary key constraint.\n     *\n     * @param Table|string $table\n     *\n     * @return string\n     */\n    public function getCreatePrimaryKeySQL(Index $index, $table)\n    {\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        return 'ALTER TABLE ' . $table . ' ADD PRIMARY KEY (' . $this->getIndexFieldDeclarationListSQL($index) . ')';\n    }\n\n    /**\n     * Returns the SQL to create a named schema.\n     *\n     * @param string $schemaName\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getCreateSchemaSQL($schemaName)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Quotes a string so that it can be safely used as a table or column name,\n     * even if it is a reserved word of the platform. This also detects identifier\n     * chains separated by dot and quotes them independently.\n     *\n     * NOTE: Just because you CAN use quoted identifiers doesn't mean\n     * you SHOULD use them. In general, they end up causing way more\n     * problems than they solve.\n     *\n     * @param string $str The identifier name to be quoted.\n     *\n     * @return string The quoted identifier string.\n     */\n    public function quoteIdentifier($str)\n    {\n        if (strpos($str, '.') !== false) {\n            $parts = array_map([$this, 'quoteSingleIdentifier'], explode('.', $str));\n\n            return implode('.', $parts);\n        }\n\n        return $this->quoteSingleIdentifier($str);\n    }\n\n    /**\n     * Quotes a single identifier (no dot chain separation).\n     *\n     * @param string $str The identifier name to be quoted.\n     *\n     * @return string The quoted identifier string.\n     */\n    public function quoteSingleIdentifier($str)\n    {\n        $c = $this->getIdentifierQuoteCharacter();\n\n        return $c . str_replace($c, $c . $c, $str) . $c;\n    }\n\n    /**\n     * Returns the SQL to create a new foreign key.\n     *\n     * @param ForeignKeyConstraint $foreignKey The foreign key constraint.\n     * @param Table|string         $table      The name of the table on which the foreign key is to be created.\n     *\n     * @return string\n     */\n    public function getCreateForeignKeySQL(ForeignKeyConstraint $foreignKey, $table)\n    {\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        return 'ALTER TABLE ' . $table . ' ADD ' . $this->getForeignKeyDeclarationSQL($foreignKey);\n    }\n\n    /**\n     * Gets the SQL statements for altering an existing table.\n     *\n     * This method returns an array of SQL statements, since some platforms need several statements.\n     *\n     * @return string[]\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getAlterTableSQL(TableDiff $diff)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param mixed[] $columnSql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTableAddColumn(Column $column, TableDiff $diff, &$columnSql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTableAddColumn)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableAddColumnEventArgs($column, $diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTableAddColumn, $eventArgs);\n\n        $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @param string[] $columnSql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTableRemoveColumn(Column $column, TableDiff $diff, &$columnSql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTableRemoveColumn)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableRemoveColumnEventArgs($column, $diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTableRemoveColumn, $eventArgs);\n\n        $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @param string[] $columnSql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTableChangeColumn(ColumnDiff $columnDiff, TableDiff $diff, &$columnSql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTableChangeColumn)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableChangeColumnEventArgs($columnDiff, $diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTableChangeColumn, $eventArgs);\n\n        $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @param string   $oldColumnName\n     * @param string[] $columnSql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTableRenameColumn($oldColumnName, Column $column, TableDiff $diff, &$columnSql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTableRenameColumn)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableRenameColumnEventArgs($oldColumnName, $column, $diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTableRenameColumn, $eventArgs);\n\n        $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @param string[] $sql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTable(TableDiff $diff, &$sql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTable)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableEventArgs($diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTable, $eventArgs);\n\n        $sql = array_merge($sql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getPreAlterTableIndexForeignKeySQL(TableDiff $diff)\n    {\n        $tableName = $diff->getName($this)->getQuotedName($this);\n\n        $sql = [];\n        if ($this->supportsForeignKeyConstraints()) {\n            foreach ($diff->removedForeignKeys as $foreignKey) {\n                $sql[] = $this->getDropForeignKeySQL($foreignKey, $tableName);\n            }\n\n            foreach ($diff->changedForeignKeys as $foreignKey) {\n                $sql[] = $this->getDropForeignKeySQL($foreignKey, $tableName);\n            }\n        }\n\n        foreach ($diff->removedIndexes as $index) {\n            $sql[] = $this->getDropIndexSQL($index, $tableName);\n        }\n\n        foreach ($diff->changedIndexes as $index) {\n            $sql[] = $this->getDropIndexSQL($index, $tableName);\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getPostAlterTableIndexForeignKeySQL(TableDiff $diff)\n    {\n        $sql     = [];\n        $newName = $diff->getNewName();\n\n        if ($newName !== false) {\n            $tableName = $newName->getQuotedName($this);\n        } else {\n            $tableName = $diff->getName($this)->getQuotedName($this);\n        }\n\n        if ($this->supportsForeignKeyConstraints()) {\n            foreach ($diff->addedForeignKeys as $foreignKey) {\n                $sql[] = $this->getCreateForeignKeySQL($foreignKey, $tableName);\n            }\n\n            foreach ($diff->changedForeignKeys as $foreignKey) {\n                $sql[] = $this->getCreateForeignKeySQL($foreignKey, $tableName);\n            }\n        }\n\n        foreach ($diff->addedIndexes as $index) {\n            $sql[] = $this->getCreateIndexSQL($index, $tableName);\n        }\n\n        foreach ($diff->changedIndexes as $index) {\n            $sql[] = $this->getCreateIndexSQL($index, $tableName);\n        }\n\n        foreach ($diff->renamedIndexes as $oldIndexName => $index) {\n            $oldIndexName = new Identifier($oldIndexName);\n            $sql          = array_merge(\n                $sql,\n                $this->getRenameIndexSQL($oldIndexName->getQuotedName($this), $index, $tableName)\n            );\n        }\n\n        return $sql;\n    }\n\n    /**\n     * Returns the SQL for renaming an index on a table.\n     *\n     * @param string $oldIndexName The name of the index to rename from.\n     * @param Index  $index        The definition of the index to rename to.\n     * @param string $tableName    The table to rename the given index on.\n     *\n     * @return string[] The sequence of SQL statements for renaming the given index.\n     */\n    protected function getRenameIndexSQL($oldIndexName, Index $index, $tableName)\n    {\n        return [\n            $this->getDropIndexSQL($oldIndexName, $tableName),\n            $this->getCreateIndexSQL($index, $tableName),\n        ];\n    }\n\n    /**\n     * Gets declaration of a number of columns in bulk.\n     *\n     * @param mixed[][] $columns A multidimensional associative array.\n     *                           The first dimension determines the column name, while the second\n     *                           dimension is keyed with the name of the properties\n     *                           of the column being declared as array indexes. Currently, the types\n     *                           of supported column properties are as follows:\n     *\n     *      length\n     *          Integer value that determines the maximum length of the text\n     *          column. If this argument is missing the column should be\n     *          declared to have the longest length allowed by the DBMS.\n     *\n     *      default\n     *          Text value to be used as default for this column.\n     *\n     *      notnull\n     *          Boolean flag that indicates whether this column is constrained\n     *          to not be set to null.\n     *      charset\n     *          Text value with the default CHARACTER SET for this column.\n     *      collation\n     *          Text value with the default COLLATION for this column.\n     *      unique\n     *          unique constraint\n     *\n     * @return string\n     */\n    public function getColumnDeclarationListSQL(array $columns)\n    {\n        $declarations = [];\n\n        foreach ($columns as $name => $column) {\n            $declarations[] = $this->getColumnDeclarationSQL($name, $column);\n        }\n\n        return implode(', ', $declarations);\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to declare a generic type\n     * column to be used in statements like CREATE TABLE.\n     *\n     * @param string  $name   The name the column to be declared.\n     * @param mixed[] $column An associative array with the name of the properties\n     *                        of the column being declared as array indexes. Currently, the types\n     *                        of supported column properties are as follows:\n     *\n     *      length\n     *          Integer value that determines the maximum length of the text\n     *          column. If this argument is missing the column should be\n     *          declared to have the longest length allowed by the DBMS.\n     *\n     *      default\n     *          Text value to be used as default for this column.\n     *\n     *      notnull\n     *          Boolean flag that indicates whether this column is constrained\n     *          to not be set to null.\n     *      charset\n     *          Text value with the default CHARACTER SET for this column.\n     *      collation\n     *          Text value with the default COLLATION for this column.\n     *      unique\n     *          unique constraint\n     *      check\n     *          column check constraint\n     *      columnDefinition\n     *          a string that defines the complete column\n     *\n     * @return string DBMS specific SQL code portion that should be used to declare the column.\n     *\n     * @throws Exception\n     */\n    public function getColumnDeclarationSQL($name, array $column)\n    {\n        if (isset($column['columnDefinition'])) {\n            $declaration = $this->getCustomTypeDeclarationSQL($column);\n        } else {\n            $default = $this->getDefaultValueDeclarationSQL($column);\n\n            $charset = ! empty($column['charset']) ?\n                ' ' . $this->getColumnCharsetDeclarationSQL($column['charset']) : '';\n\n            $collation = ! empty($column['collation']) ?\n                ' ' . $this->getColumnCollationDeclarationSQL($column['collation']) : '';\n\n            $notnull = ! empty($column['notnull']) ? ' NOT NULL' : '';\n\n            $unique = ! empty($column['unique']) ?\n                ' ' . $this->getUniqueFieldDeclarationSQL() : '';\n\n            $check = ! empty($column['check']) ? ' ' . $column['check'] : '';\n\n            $typeDecl    = $column['type']->getSQLDeclaration($column, $this);\n            $declaration = $typeDecl . $charset . $default . $notnull . $unique . $check . $collation;\n\n            if ($this->supportsInlineColumnComments() && isset($column['comment']) && $column['comment'] !== '') {\n                $declaration .= ' ' . $this->getInlineColumnCommentSQL($column['comment']);\n            }\n        }\n\n        return $name . ' ' . $declaration;\n    }\n\n    /**\n     * Returns the SQL snippet that declares a floating point column of arbitrary precision.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getDecimalTypeDeclarationSQL(array $column)\n    {\n        $column['precision'] = ! isset($column['precision']) || empty($column['precision'])\n            ? 10 : $column['precision'];\n        $column['scale']     = ! isset($column['scale']) || empty($column['scale'])\n            ? 0 : $column['scale'];\n\n        return 'NUMERIC(' . $column['precision'] . ', ' . $column['scale'] . ')';\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set a default value\n     * declaration to be used in statements like CREATE TABLE.\n     *\n     * @param mixed[] $column The column definition array.\n     *\n     * @return string DBMS specific SQL code portion needed to set a default value.\n     */\n    public function getDefaultValueDeclarationSQL($column)\n    {\n        if (! isset($column['default'])) {\n            return empty($column['notnull']) ? ' DEFAULT NULL' : '';\n        }\n\n        $default = $column['default'];\n\n        if (! isset($column['type'])) {\n            return \" DEFAULT '\" . $default . \"'\";\n        }\n\n        $type = $column['type'];\n\n        if ($type instanceof Types\\PhpIntegerMappingType) {\n            return ' DEFAULT ' . $default;\n        }\n\n        if ($type instanceof Types\\PhpDateTimeMappingType && $default === $this->getCurrentTimestampSQL()) {\n            return ' DEFAULT ' . $this->getCurrentTimestampSQL();\n        }\n\n        if ($type instanceof Types\\TimeType && $default === $this->getCurrentTimeSQL()) {\n            return ' DEFAULT ' . $this->getCurrentTimeSQL();\n        }\n\n        if ($type instanceof Types\\DateType && $default === $this->getCurrentDateSQL()) {\n            return ' DEFAULT ' . $this->getCurrentDateSQL();\n        }\n\n        if ($type instanceof Types\\BooleanType) {\n            return \" DEFAULT '\" . $this->convertBooleans($default) . \"'\";\n        }\n\n        return ' DEFAULT ' . $this->quoteStringLiteral($default);\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set a CHECK constraint\n     * declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string[]|mixed[][] $definition The check definition.\n     *\n     * @return string DBMS specific SQL code portion needed to set a CHECK constraint.\n     */\n    public function getCheckDeclarationSQL(array $definition)\n    {\n        $constraints = [];\n        foreach ($definition as $column => $def) {\n            if (is_string($def)) {\n                $constraints[] = 'CHECK (' . $def . ')';\n            } else {\n                if (isset($def['min'])) {\n                    $constraints[] = 'CHECK (' . $column . ' >= ' . $def['min'] . ')';\n                }\n\n                if (isset($def['max'])) {\n                    $constraints[] = 'CHECK (' . $column . ' <= ' . $def['max'] . ')';\n                }\n            }\n        }\n\n        return implode(', ', $constraints);\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set a unique\n     * constraint declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string           $name       The name of the unique constraint.\n     * @param UniqueConstraint $constraint The unique constraint definition.\n     *\n     * @return string DBMS specific SQL code portion needed to set a constraint.\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getUniqueConstraintDeclarationSQL($name, UniqueConstraint $constraint)\n    {\n        $columns = $constraint->getQuotedColumns($this);\n        $name    = new Identifier($name);\n\n        if (count($columns) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'columns' required.\");\n        }\n\n        $constraintFlags = array_merge(['UNIQUE'], array_map('strtoupper', $constraint->getFlags()));\n        $constraintName  = $name->getQuotedName($this);\n        $columnListNames = $this->getColumnsFieldDeclarationListSQL($columns);\n\n        return sprintf('CONSTRAINT %s %s (%s)', $constraintName, implode(' ', $constraintFlags), $columnListNames);\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set an index\n     * declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string $name  The name of the index.\n     * @param Index  $index The index definition.\n     *\n     * @return string DBMS specific SQL code portion needed to set an index.\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getIndexDeclarationSQL($name, Index $index)\n    {\n        $columns = $index->getColumns();\n        $name    = new Identifier($name);\n\n        if (count($columns) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'columns' required.\");\n        }\n\n        return $this->getCreateIndexSQLFlags($index) . 'INDEX ' . $name->getQuotedName($this)\n            . ' (' . $this->getIndexFieldDeclarationListSQL($index) . ')' . $this->getPartialIndexSQL($index);\n    }\n\n    /**\n     * Obtains SQL code portion needed to create a custom column,\n     * e.g. when a column has the \"columnDefinition\" keyword.\n     * Only \"AUTOINCREMENT\" and \"PRIMARY KEY\" are added if appropriate.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getCustomTypeDeclarationSQL(array $column)\n    {\n        return $column['columnDefinition'];\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set an index\n     * declaration to be used in statements like CREATE TABLE.\n     */\n    public function getIndexFieldDeclarationListSQL(Index $index): string\n    {\n        return implode(', ', $index->getQuotedColumns($this));\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set an index\n     * declaration to be used in statements like CREATE TABLE.\n     *\n     * @param mixed[] $columns\n     */\n    public function getColumnsFieldDeclarationListSQL(array $columns): string\n    {\n        $ret = [];\n\n        foreach ($columns as $column => $definition) {\n            if (is_array($definition)) {\n                $ret[] = $column;\n            } else {\n                $ret[] = $definition;\n            }\n        }\n\n        return implode(', ', $ret);\n    }\n\n    /**\n     * Returns the required SQL string that fits between CREATE ... TABLE\n     * to create the table as a temporary table.\n     *\n     * Should be overridden in driver classes to return the correct string for the\n     * specific database type.\n     *\n     * The default is to return the string \"TEMPORARY\" - this will result in a\n     * SQL error for any database that does not support temporary tables, or that\n     * requires a different SQL command from \"CREATE TEMPORARY TABLE\".\n     *\n     * @return string The string required to be placed between \"CREATE\" and \"TABLE\"\n     *                to generate a temporary table, if possible.\n     */\n    public function getTemporaryTableSQL()\n    {\n        return 'TEMPORARY';\n    }\n\n    /**\n     * Some vendors require temporary table names to be qualified specially.\n     *\n     * @param string $tableName\n     *\n     * @return string\n     */\n    public function getTemporaryTableName($tableName)\n    {\n        return $tableName;\n    }\n\n    /**\n     * Obtain DBMS specific SQL code portion needed to set the FOREIGN KEY constraint\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @return string DBMS specific SQL code portion needed to set the FOREIGN KEY constraint\n     *                of a column declaration.\n     */\n    public function getForeignKeyDeclarationSQL(ForeignKeyConstraint $foreignKey)\n    {\n        $sql  = $this->getForeignKeyBaseDeclarationSQL($foreignKey);\n        $sql .= $this->getAdvancedForeignKeyOptionsSQL($foreignKey);\n\n        return $sql;\n    }\n\n    /**\n     * Returns the FOREIGN KEY query section dealing with non-standard options\n     * as MATCH, INITIALLY DEFERRED, ON UPDATE, ...\n     *\n     * @param ForeignKeyConstraint $foreignKey The foreign key definition.\n     *\n     * @return string\n     */\n    public function getAdvancedForeignKeyOptionsSQL(ForeignKeyConstraint $foreignKey)\n    {\n        $query = '';\n        if ($foreignKey->hasOption('onUpdate')) {\n            $query .= ' ON UPDATE ' . $this->getForeignKeyReferentialActionSQL($foreignKey->getOption('onUpdate'));\n        }\n\n        if ($foreignKey->hasOption('onDelete')) {\n            $query .= ' ON DELETE ' . $this->getForeignKeyReferentialActionSQL($foreignKey->getOption('onDelete'));\n        }\n\n        return $query;\n    }\n\n    /**\n     * Returns the given referential action in uppercase if valid, otherwise throws an exception.\n     *\n     * @param string $action The foreign key referential action.\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException If unknown referential action given.\n     */\n    public function getForeignKeyReferentialActionSQL($action)\n    {\n        $upper = strtoupper($action);\n        switch ($upper) {\n            case 'CASCADE':\n            case 'SET NULL':\n            case 'NO ACTION':\n            case 'RESTRICT':\n            case 'SET DEFAULT':\n                return $upper;\n\n            default:\n                throw new InvalidArgumentException('Invalid foreign key action: ' . $upper);\n        }\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set the FOREIGN KEY constraint\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getForeignKeyBaseDeclarationSQL(ForeignKeyConstraint $foreignKey)\n    {\n        $sql = '';\n        if (strlen($foreignKey->getName()) > 0) {\n            $sql .= 'CONSTRAINT ' . $foreignKey->getQuotedName($this) . ' ';\n        }\n\n        $sql .= 'FOREIGN KEY (';\n\n        if (count($foreignKey->getLocalColumns()) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'local' required.\");\n        }\n\n        if (count($foreignKey->getForeignColumns()) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'foreign' required.\");\n        }\n\n        if (strlen($foreignKey->getForeignTableName()) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'foreignTable' required.\");\n        }\n\n        return $sql . implode(', ', $foreignKey->getQuotedLocalColumns($this))\n            . ') REFERENCES '\n            . $foreignKey->getQuotedForeignTableName($this) . ' ('\n            . implode(', ', $foreignKey->getQuotedForeignColumns($this)) . ')';\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set the UNIQUE constraint\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @return string DBMS specific SQL code portion needed to set the UNIQUE constraint\n     *                of a column declaration.\n     */\n    public function getUniqueFieldDeclarationSQL()\n    {\n        return 'UNIQUE';\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set the CHARACTER SET\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string $charset The name of the charset.\n     *\n     * @return string DBMS specific SQL code portion needed to set the CHARACTER SET\n     *                of a column declaration.\n     */\n    public function getColumnCharsetDeclarationSQL($charset)\n    {\n        return '';\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set the COLLATION\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string $collation The name of the collation.\n     *\n     * @return string DBMS specific SQL code portion needed to set the COLLATION\n     *                of a column declaration.\n     */\n    public function getColumnCollationDeclarationSQL($collation)\n    {\n        return $this->supportsColumnCollation() ? 'COLLATE ' . $collation : '';\n    }\n\n    /**\n     * Whether the platform prefers identity columns (eg. autoincrement) for ID generation.\n     * Subclasses should override this method to return TRUE if they prefer identity columns.\n     *\n     * @return bool\n     */\n    public function prefersIdentityColumns()\n    {\n        return false;\n    }\n\n    /**\n     * Some platforms need the boolean values to be converted.\n     *\n     * The default conversion in this implementation converts to integers (false => 0, true => 1).\n     *\n     * Note: if the input is not a boolean the original input might be returned.\n     *\n     * There are two contexts when converting booleans: Literals and Prepared Statements.\n     * This method should handle the literal case\n     *\n     * @param mixed $item A boolean or an array of them.\n     *\n     * @return mixed A boolean database value or an array of them.\n     */\n    public function convertBooleans($item)\n    {\n        if (is_array($item)) {\n            foreach ($item as $k => $value) {\n                if (! is_bool($value)) {\n                    continue;\n                }\n\n                $item[$k] = (int) $value;\n            }\n        } elseif (is_bool($item)) {\n            $item = (int) $item;\n        }\n\n        return $item;\n    }\n\n    /**\n     * Some platforms have boolean literals that needs to be correctly converted\n     *\n     * The default conversion tries to convert value into bool \"(bool)$item\"\n     *\n     * @param mixed $item\n     *\n     * @return bool|null\n     */\n    public function convertFromBoolean($item)\n    {\n        return $item === null ? null : (bool) $item;\n    }\n\n    /**\n     * This method should handle the prepared statements case. When there is no\n     * distinction, it's OK to use the same method.\n     *\n     * Note: if the input is not a boolean the original input might be returned.\n     *\n     * @param mixed $item A boolean or an array of them.\n     *\n     * @return mixed A boolean database value or an array of them.\n     */\n    public function convertBooleansToDatabaseValue($item)\n    {\n        return $this->convertBooleans($item);\n    }\n\n    /**\n     * Returns the SQL specific for the platform to get the current date.\n     *\n     * @return string\n     */\n    public function getCurrentDateSQL()\n    {\n        return 'CURRENT_DATE';\n    }\n\n    /**\n     * Returns the SQL specific for the platform to get the current time.\n     *\n     * @return string\n     */\n    public function getCurrentTimeSQL()\n    {\n        return 'CURRENT_TIME';\n    }\n\n    /**\n     * Returns the SQL specific for the platform to get the current timestamp\n     *\n     * @return string\n     */\n    public function getCurrentTimestampSQL()\n    {\n        return 'CURRENT_TIMESTAMP';\n    }\n\n    /**\n     * Returns the SQL for a given transaction isolation level Connection constant.\n     *\n     * @param int $level\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function _getTransactionIsolationLevelSQL($level)\n    {\n        switch ($level) {\n            case TransactionIsolationLevel::READ_UNCOMMITTED:\n                return 'READ UNCOMMITTED';\n\n            case TransactionIsolationLevel::READ_COMMITTED:\n                return 'READ COMMITTED';\n\n            case TransactionIsolationLevel::REPEATABLE_READ:\n                return 'REPEATABLE READ';\n\n            case TransactionIsolationLevel::SERIALIZABLE:\n                return 'SERIALIZABLE';\n\n            default:\n                throw new InvalidArgumentException('Invalid isolation level:' . $level);\n        }\n    }\n\n    /**\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListDatabasesSQL()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL statement for retrieving the namespaces defined in the database.\n     *\n     * @deprecated Use {@link AbstractSchemaManager::listSchemaNames()} instead.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListNamespacesSQL()\n    {\n        Deprecation::triggerIfCalledFromOutside(\n            'doctrine/dbal',\n            'https://github.com/doctrine/dbal/issues/4503',\n            'AbstractPlatform::getListNamespacesSQL() is deprecated,'\n                . ' use AbstractSchemaManager::listSchemaNames() instead.'\n        );\n\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $database\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListSequencesSQL($database)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $table\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTableConstraintsSQL($table)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $table\n     * @param string $database\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTableColumnsSQL($table, $database = null)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTablesSQL()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListUsersSQL()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to list all views of a database or user.\n     *\n     * @param string $database\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListViewsSQL($database)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the list of indexes for the current database.\n     *\n     * The current database parameter is optional but will always be passed\n     * when using the SchemaManager API and is the database the given table is in.\n     *\n     * Attention: Some platforms only support currentDatabase when they\n     * are connected with that database. Cross-database information schema\n     * requests may be impossible.\n     *\n     * @param string $table\n     * @param string $database\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTableIndexesSQL($table, $database = null)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $table\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTableForeignKeysSQL($table)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $name\n     * @param string $sql\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getCreateViewSQL($name, $sql)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $name\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDropViewSQL($name)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL snippet to drop an existing sequence.\n     *\n     * @param Sequence|string $sequence\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDropSequenceSQL($sequence)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $sequence\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getSequenceNextValSQL($sequence)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to create a new database.\n     *\n     * @param string $name The name of the database that should be created.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getCreateDatabaseSQL($name)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to set the transaction isolation level.\n     *\n     * @param int $level\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getSetTransactionIsolationSQL($level)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Obtains DBMS specific SQL to be used to create datetime columns in\n     * statements like CREATE TABLE.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateTimeTypeDeclarationSQL(array $column)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Obtains DBMS specific SQL to be used to create datetime with timezone offset columns.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getDateTimeTzTypeDeclarationSQL(array $column)\n    {\n        return $this->getDateTimeTypeDeclarationSQL($column);\n    }\n\n    /**\n     * Obtains DBMS specific SQL to be used to create date columns in statements\n     * like CREATE TABLE.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateTypeDeclarationSQL(array $column)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Obtains DBMS specific SQL to be used to create time columns in statements\n     * like CREATE TABLE.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getTimeTypeDeclarationSQL(array $column)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getFloatDeclarationSQL(array $column)\n    {\n        return 'DOUBLE PRECISION';\n    }\n\n    /**\n     * Gets the default transaction isolation level of the platform.\n     *\n     * @see TransactionIsolationLevel\n     *\n     * @return int The default isolation level.\n     */\n    public function getDefaultTransactionIsolationLevel()\n    {\n        return TransactionIsolationLevel::READ_COMMITTED;\n    }\n\n    /* supports*() methods */\n\n    /**\n     * Whether the platform supports sequences.\n     *\n     * @return bool\n     */\n    public function supportsSequences()\n    {\n        return false;\n    }\n\n    /**\n     * Whether the platform supports identity columns.\n     *\n     * Identity columns are columns that receive an auto-generated value from the\n     * database on insert of a row.\n     *\n     * @return bool\n     */\n    public function supportsIdentityColumns()\n    {\n        return false;\n    }\n\n    /**\n     * Whether the platform emulates identity columns through sequences.\n     *\n     * Some platforms that do not support identity columns natively\n     * but support sequences can emulate identity columns by using\n     * sequences.\n     *\n     * @return bool\n     */\n    public function usesSequenceEmulatedIdentityColumns()\n    {\n        return false;\n    }\n\n    /**\n     * Returns the name of the sequence for a particular identity column in a particular table.\n     *\n     * @see usesSequenceEmulatedIdentityColumns\n     *\n     * @param string $tableName  The name of the table to return the sequence name for.\n     * @param string $columnName The name of the identity column in the table to return the sequence name for.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getIdentitySequenceName($tableName, $columnName)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Whether the platform supports indexes.\n     *\n     * @return bool\n     */\n    public function supportsIndexes()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports partial indexes.\n     *\n     * @return bool\n     */\n    public function supportsPartialIndexes()\n    {\n        return false;\n    }\n\n    /**\n     * Whether the platform supports indexes with column length definitions.\n     */\n    public function supportsColumnLengthIndexes(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Whether the platform supports altering tables.\n     *\n     * @return bool\n     */\n    public function supportsAlterTable()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports transactions.\n     *\n     * @return bool\n     */\n    public function supportsTransactions()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports savepoints.\n     *\n     * @return bool\n     */\n    public function supportsSavepoints()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports releasing savepoints.\n     *\n     * @return bool\n     */\n    public function supportsReleaseSavepoints()\n    {\n        return $this->supportsSavepoints();\n    }\n\n    /**\n     * Whether the platform supports primary key constraints.\n     *\n     * @return bool\n     */\n    public function supportsPrimaryConstraints()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports foreign key constraints.\n     *\n     * @return bool\n     */\n    public function supportsForeignKeyConstraints()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports database schemas.\n     *\n     * @return bool\n     */\n    public function supportsSchemas()\n    {\n        return false;\n    }\n\n    /**\n     * Whether this platform can emulate schemas.\n     *\n     * Platforms that either support or emulate schemas don't automatically\n     * filter a schema for the namespaced elements in {@link AbstractManager::createSchema()}.\n     *\n     * @return bool\n     */\n    public function canEmulateSchemas()\n    {\n        return false;\n    }\n\n    /**\n     * Returns the default schema name.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDefaultSchemaName()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Whether this platform supports create database.\n     *\n     * Some databases don't allow to create and drop databases at all or only with certain tools.\n     *\n     * @return bool\n     */\n    public function supportsCreateDropDatabase()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports getting the affected rows of a recent update/delete type query.\n     *\n     * @return bool\n     */\n    public function supportsGettingAffectedRows()\n    {\n        return true;\n    }\n\n    /**\n     * Whether this platform support to add inline column comments as postfix.\n     *\n     * @return bool\n     */\n    public function supportsInlineColumnComments()\n    {\n        return false;\n    }\n\n    /**\n     * Whether this platform support the proprietary syntax \"COMMENT ON asset\".\n     *\n     * @return bool\n     */\n    public function supportsCommentOnStatement()\n    {\n        return false;\n    }\n\n    /**\n     * Does this platform have native guid type.\n     *\n     * @return bool\n     */\n    public function hasNativeGuidType()\n    {\n        return false;\n    }\n\n    /**\n     * Does this platform have native JSON type.\n     *\n     * @return bool\n     */\n    public function hasNativeJsonType()\n    {\n        return false;\n    }\n\n    /**\n     * Whether this platform supports views.\n     *\n     * @return bool\n     */\n    public function supportsViews()\n    {\n        return true;\n    }\n\n    /**\n     * Does this platform support column collation?\n     *\n     * @return bool\n     */\n    public function supportsColumnCollation()\n    {\n        return false;\n    }\n\n    /**\n     * Gets the format string, as accepted by the date() function, that describes\n     * the format of a stored datetime value of this platform.\n     *\n     * @return string The format string.\n     */\n    public function getDateTimeFormatString()\n    {\n        return 'Y-m-d H:i:s';\n    }\n\n    /**\n     * Gets the format string, as accepted by the date() function, that describes\n     * the format of a stored datetime with timezone value of this platform.\n     *\n     * @return string The format string.\n     */\n    public function getDateTimeTzFormatString()\n    {\n        return 'Y-m-d H:i:s';\n    }\n\n    /**\n     * Gets the format string, as accepted by the date() function, that describes\n     * the format of a stored date value of this platform.\n     *\n     * @return string The format string.\n     */\n    public function getDateFormatString()\n    {\n        return 'Y-m-d';\n    }\n\n    /**\n     * Gets the format string, as accepted by the date() function, that describes\n     * the format of a stored time value of this platform.\n     *\n     * @return string The format string.\n     */\n    public function getTimeFormatString()\n    {\n        return 'H:i:s';\n    }\n\n    /**\n     * Adds an driver-specific LIMIT clause to the query.\n     *\n     * @param string   $query\n     * @param int|null $limit\n     * @param int      $offset\n     *\n     * @return string\n     *\n     * @throws Exception\n     */\n    final public function modifyLimitQuery($query, $limit, $offset = 0)\n    {\n        if ($offset < 0) {\n            throw new Exception(sprintf(\n                'Offset must be a positive integer or zero, %d given',\n                $offset\n            ));\n        }\n\n        if ($offset > 0 && ! $this->supportsLimitOffset()) {\n            throw new Exception(sprintf(\n                'Platform %s does not support offset values in limit queries.',\n                $this->getName()\n            ));\n        }\n\n        return $this->doModifyLimitQuery($query, $limit, $offset);\n    }\n\n    /**\n     * Adds an platform-specific LIMIT clause to the query.\n     *\n     * @param string   $query\n     * @param int|null $limit\n     * @param int      $offset\n     *\n     * @return string\n     */\n    protected function doModifyLimitQuery($query, $limit, $offset)\n    {\n        if ($limit !== null) {\n            $query .= ' LIMIT ' . $limit;\n        }\n\n        if ($offset > 0) {\n            $query .= ' OFFSET ' . $offset;\n        }\n\n        return $query;\n    }\n\n    /**\n     * Whether the database platform support offsets in modify limit clauses.\n     *\n     * @return bool\n     */\n    public function supportsLimitOffset()\n    {\n        return true;\n    }\n\n    /**\n     * Maximum length of any given database identifier, like tables or column names.\n     *\n     * @return int\n     */\n    public function getMaxIdentifierLength()\n    {\n        return 63;\n    }\n\n    /**\n     * Returns the insert SQL for an empty insert statement.\n     *\n     * @param string $quotedTableName\n     * @param string $quotedIdentifierColumnName\n     *\n     * @return string\n     */\n    public function getEmptyIdentityInsertSQL($quotedTableName, $quotedIdentifierColumnName)\n    {\n        return 'INSERT INTO ' . $quotedTableName . ' (' . $quotedIdentifierColumnName . ') VALUES (null)';\n    }\n\n    /**\n     * Generates a Truncate Table SQL statement for a given table.\n     *\n     * Cascade is not supported on many platforms but would optionally cascade the truncate by\n     * following the foreign keys.\n     *\n     * @param string $tableName\n     * @param bool   $cascade\n     *\n     * @return string\n     */\n    public function getTruncateTableSQL($tableName, $cascade = false)\n    {\n        $tableIdentifier = new Identifier($tableName);\n\n        return 'TRUNCATE ' . $tableIdentifier->getQuotedName($this);\n    }\n\n    /**\n     * This is for test reasons, many vendors have special requirements for dummy statements.\n     *\n     * @return string\n     */\n    public function getDummySelectSQL()\n    {\n        $expression = func_num_args() > 0 ? func_get_arg(0) : '1';\n\n        return sprintf('SELECT %s', $expression);\n    }\n\n    /**\n     * Returns the SQL to create a new savepoint.\n     *\n     * @param string $savepoint\n     *\n     * @return string\n     */\n    public function createSavePoint($savepoint)\n    {\n        return 'SAVEPOINT ' . $savepoint;\n    }\n\n    /**\n     * Returns the SQL to release a savepoint.\n     *\n     * @param string $savepoint\n     *\n     * @return string\n     */\n    public function releaseSavePoint($savepoint)\n    {\n        return 'RELEASE SAVEPOINT ' . $savepoint;\n    }\n\n    /**\n     * Returns the SQL to rollback a savepoint.\n     *\n     * @param string $savepoint\n     *\n     * @return string\n     */\n    public function rollbackSavePoint($savepoint)\n    {\n        return 'ROLLBACK TO SAVEPOINT ' . $savepoint;\n    }\n\n    /**\n     * Returns the keyword list instance of this platform.\n     *\n     * @return KeywordList\n     *\n     * @throws Exception If no keyword list is specified.\n     */\n    final public function getReservedKeywordsList()\n    {\n        // Check for an existing instantiation of the keywords class.\n        if ($this->_keywords === null) {\n            // Store the instance so it doesn't need to be generated on every request.\n            $this->_keywords = $this->createReservedKeywordsList();\n        }\n\n        return $this->_keywords;\n    }\n\n    /**\n     * Creates an instance of the reserved keyword list of this platform.\n     *\n     * This method will become @abstract in DBAL 4.0.0.\n     *\n     * @throws Exception\n     */\n    protected function createReservedKeywordsList(): KeywordList\n    {\n        $class    = $this->getReservedKeywordsClass();\n        $keywords = new $class();\n        if (! $keywords instanceof KeywordList) {\n            throw Exception::notSupported(__METHOD__);\n        }\n\n        return $keywords;\n    }\n\n    /**\n     * Returns the class name of the reserved keywords list.\n     *\n     * @deprecated Implement {@link createReservedKeywordsList()} instead.\n     *\n     * @return string\n     * @psalm-return class-string<KeywordList>\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    protected function getReservedKeywordsClass()\n    {\n        Deprecation::triggerIfCalledFromOutside(\n            'doctrine/dbal',\n            'https://github.com/doctrine/dbal/issues/4510',\n            'AbstractPlatform::getReservedKeywordsClass() is deprecated,'\n                . ' use AbstractPlatform::createReservedKeywordsList() instead.'\n        );\n\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Quotes a literal string.\n     * This method is NOT meant to fix SQL injections!\n     * It is only meant to escape this platform's string literal\n     * quote character inside the given literal string.\n     *\n     * @param string $str The literal string to be quoted.\n     *\n     * @return string The quoted literal string.\n     */\n    public function quoteStringLiteral($str)\n    {\n        $c = $this->getStringLiteralQuoteCharacter();\n\n        return $c . str_replace($c, $c . $c, $str) . $c;\n    }\n\n    /**\n     * Gets the character used for string literal quoting.\n     *\n     * @return string\n     */\n    public function getStringLiteralQuoteCharacter()\n    {\n        return \"'\";\n    }\n\n    /**\n     * Escapes metacharacters in a string intended to be used with a LIKE\n     * operator.\n     *\n     * @param string $inputString a literal, unquoted string\n     * @param string $escapeChar  should be reused by the caller in the LIKE\n     *                            expression.\n     */\n    final public function escapeStringForLike(string $inputString, string $escapeChar): string\n    {\n        return preg_replace(\n            '~([' . preg_quote($this->getLikeWildcardCharacters() . $escapeChar, '~') . '])~u',\n            addcslashes($escapeChar, '\\\\') . '$1',\n            $inputString\n        );\n    }\n\n    /**\n     * @internal\n     */\n    public function createSQLParser(): Parser\n    {\n        return new Parser(false);\n    }\n\n    protected function getLikeWildcardCharacters(): string\n    {\n        return '%_';\n    }\n}\n", "<?php\n\nnamespace Doctrine\\DBAL\\Tests\\Platforms;\n\nuse Doctrine\\Common\\EventManager;\nuse Doctrine\\DBAL\\Events;\nuse Doctrine\\DBAL\\Exception;\nuse Doctrine\\DBAL\\Exception\\InvalidLockMode;\nuse Doctrine\\DBAL\\Platforms\\AbstractPlatform;\nuse Doctrine\\DBAL\\Platforms\\Keywords\\KeywordList;\nuse Doctrine\\DBAL\\Schema\\Column;\nuse Doctrine\\DBAL\\Schema\\ColumnDiff;\nuse Doctrine\\DBAL\\Schema\\Comparator;\nuse Doctrine\\DBAL\\Schema\\ForeignKeyConstraint;\nuse Doctrine\\DBAL\\Schema\\Index;\nuse Doctrine\\DBAL\\Schema\\Table;\nuse Doctrine\\DBAL\\Schema\\TableDiff;\nuse Doctrine\\DBAL\\Schema\\UniqueConstraint;\nuse Doctrine\\DBAL\\Types\\Type;\nuse InvalidArgumentException;\nuse PHPUnit\\Framework\\TestCase;\n\nuse function get_class;\nuse function implode;\nuse function sprintf;\nuse function str_repeat;\n\n/**\n * @template T of AbstractPlatform\n */\nabstract class AbstractPlatformTestCase extends TestCase\n{\n    /** @var T */\n    protected $platform;\n\n    /**\n     * @return T\n     */\n    abstract public function createPlatform(): AbstractPlatform;\n\n    protected function setUp(): void\n    {\n        $this->platform = $this->createPlatform();\n    }\n\n    public function testQuoteIdentifier(): void\n    {\n        if ($this->platform->getName() === 'mssql') {\n            self::markTestSkipped('Not working this way on mssql.');\n        }\n\n        $c = $this->platform->getIdentifierQuoteCharacter();\n        self::assertEquals($c . 'test' . $c, $this->platform->quoteIdentifier('test'));\n        self::assertEquals($c . 'test' . $c . '.' . $c . 'test' . $c, $this->platform->quoteIdentifier('test.test'));\n        self::assertEquals(str_repeat($c, 4), $this->platform->quoteIdentifier($c));\n    }\n\n    public function testQuoteSingleIdentifier(): void\n    {\n        if ($this->platform->getName() === 'mssql') {\n            self::markTestSkipped('Not working this way on mssql.');\n        }\n\n        $c = $this->platform->getIdentifierQuoteCharacter();\n        self::assertEquals($c . 'test' . $c, $this->platform->quoteSingleIdentifier('test'));\n        self::assertEquals($c . 'test.test' . $c, $this->platform->quoteSingleIdentifier('test.test'));\n        self::assertEquals(str_repeat($c, 4), $this->platform->quoteSingleIdentifier($c));\n    }\n\n    /**\n     * @dataProvider getReturnsForeignKeyReferentialActionSQL\n     */\n    public function testReturnsForeignKeyReferentialActionSQL(string $action, string $expectedSQL): void\n    {\n        self::assertSame($expectedSQL, $this->platform->getForeignKeyReferentialActionSQL($action));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getReturnsForeignKeyReferentialActionSQL(): iterable\n    {\n        return [\n            ['CASCADE', 'CASCADE'],\n            ['SET NULL', 'SET NULL'],\n            ['NO ACTION', 'NO ACTION'],\n            ['RESTRICT', 'RESTRICT'],\n            ['SET DEFAULT', 'SET DEFAULT'],\n            ['CaScAdE', 'CASCADE'],\n        ];\n    }\n\n    public function testGetInvalidForeignKeyReferentialActionSQL(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->platform->getForeignKeyReferentialActionSQL('unknown');\n    }\n\n    public function testGetUnknownDoctrineMappingType(): void\n    {\n        $this->expectException(Exception::class);\n        $this->platform->getDoctrineTypeMapping('foobar');\n    }\n\n    public function testRegisterDoctrineMappingType(): void\n    {\n        $this->platform->registerDoctrineTypeMapping('foo', 'integer');\n        self::assertEquals('integer', $this->platform->getDoctrineTypeMapping('foo'));\n    }\n\n    public function testRegisterUnknownDoctrineMappingType(): void\n    {\n        $this->expectException(Exception::class);\n        $this->platform->registerDoctrineTypeMapping('foo', 'bar');\n    }\n\n    public function testRegistersCommentedDoctrineMappingTypeImplicitly(): void\n    {\n        $type = Type::getType('array');\n        $this->platform->registerDoctrineTypeMapping('foo', 'array');\n\n        self::assertTrue($this->platform->isCommentedDoctrineType($type));\n    }\n\n    /**\n     * @dataProvider getIsCommentedDoctrineType\n     */\n    public function testIsCommentedDoctrineType(Type $type, bool $commented): void\n    {\n        self::assertSame($commented, $this->platform->isCommentedDoctrineType($type));\n    }\n\n    /**\n     * @return mixed[]\n     */\n    public function getIsCommentedDoctrineType(): iterable\n    {\n        $this->setUp();\n\n        $data = [];\n\n        foreach (Type::getTypesMap() as $typeName => $className) {\n            $type = Type::getType($typeName);\n\n            $data[$typeName] = [\n                $type,\n                $type->requiresSQLCommentHint($this->platform),\n            ];\n        }\n\n        return $data;\n    }\n\n    public function testCreateWithNoColumns(): void\n    {\n        $table = new Table('test');\n\n        $this->expectException(Exception::class);\n        $this->platform->getCreateTableSQL($table);\n    }\n\n    public function testGeneratesTableCreationSql(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer', ['notnull' => true, 'autoincrement' => true]);\n        $table->addColumn('test', 'string', ['notnull' => false, 'length' => 255]);\n        $table->setPrimaryKey(['id']);\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getGenerateTableSql(), $sql[0]);\n    }\n\n    abstract public function getGenerateTableSql(): string;\n\n    public function testGenerateTableWithMultiColumnUniqueIndex(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('foo', 'string', ['notnull' => false, 'length' => 255]);\n        $table->addColumn('bar', 'string', ['notnull' => false, 'length' => 255]);\n        $table->addUniqueIndex(['foo', 'bar']);\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getGenerateTableWithMultiColumnUniqueIndexSql(), $sql);\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract public function getGenerateTableWithMultiColumnUniqueIndexSql(): array;\n\n    public function testGeneratesIndexCreationSql(): void\n    {\n        $indexDef = new Index('my_idx', ['user_name', 'last_login']);\n\n        self::assertEquals(\n            $this->getGenerateIndexSql(),\n            $this->platform->getCreateIndexSQL($indexDef, 'mytable')\n        );\n    }\n\n    abstract public function getGenerateIndexSql(): string;\n\n    public function testGeneratesUniqueIndexCreationSql(): void\n    {\n        $indexDef = new Index('index_name', ['test', 'test2'], true);\n\n        $sql = $this->platform->getCreateIndexSQL($indexDef, 'test');\n        self::assertEquals($this->getGenerateUniqueIndexSql(), $sql);\n    }\n\n    abstract public function getGenerateUniqueIndexSql(): string;\n\n    public function testGeneratesPartialIndexesSqlOnlyWhenSupportingPartialIndexes(): void\n    {\n        $where            = 'test IS NULL AND test2 IS NOT NULL';\n        $indexDef         = new Index('name', ['test', 'test2'], false, false, [], ['where' => $where]);\n        $uniqueConstraint = new UniqueConstraint('name', ['test', 'test2'], [], []);\n\n        $expected = ' WHERE ' . $where;\n\n        $indexes = [];\n\n        if ($this->supportsInlineIndexDeclaration()) {\n            $indexes[] = $this->platform->getIndexDeclarationSQL('name', $indexDef);\n        }\n\n        $uniqueConstraintSQL = $this->platform->getUniqueConstraintDeclarationSQL('name', $uniqueConstraint);\n        $this->assertStringEndsNotWith($expected, $uniqueConstraintSQL, 'WHERE clause should NOT be present');\n\n        $indexes[] = $this->platform->getCreateIndexSQL($indexDef, 'table');\n\n        foreach ($indexes as $index) {\n            if ($this->platform->supportsPartialIndexes()) {\n                self::assertStringEndsWith($expected, $index, 'WHERE clause should be present');\n            } else {\n                self::assertStringEndsNotWith($expected, $index, 'WHERE clause should NOT be present');\n            }\n        }\n    }\n\n    public function testGeneratesForeignKeyCreationSql(): void\n    {\n        $fk = new ForeignKeyConstraint(['fk_name_id'], 'other_table', ['id'], '');\n\n        $sql = $this->platform->getCreateForeignKeySQL($fk, 'test');\n        self::assertEquals($sql, $this->getGenerateForeignKeySql());\n    }\n\n    abstract protected function getGenerateForeignKeySql(): string;\n\n    public function testGeneratesConstraintCreationSql(): void\n    {\n        $idx = new Index('constraint_name', ['test'], true, false);\n        $sql = $this->platform->getCreateConstraintSQL($idx, 'test');\n        self::assertEquals($this->getGenerateConstraintUniqueIndexSql(), $sql);\n\n        $pk  = new Index('constraint_name', ['test'], true, true);\n        $sql = $this->platform->getCreateConstraintSQL($pk, 'test');\n        self::assertEquals($this->getGenerateConstraintPrimaryIndexSql(), $sql);\n\n        $uc  = new UniqueConstraint('constraint_name', ['test']);\n        $sql = $this->platform->getCreateConstraintSQL($uc, 'test');\n        self::assertEquals($this->getGenerateConstraintUniqueIndexSql(), $sql);\n\n        $fk  = new ForeignKeyConstraint(['fk_name'], 'foreign', ['id'], 'constraint_fk');\n        $sql = $this->platform->getCreateConstraintSQL($fk, 'test');\n        self::assertEquals($this->getGenerateConstraintForeignKeySql($fk), $sql);\n    }\n\n    public function testGeneratesForeignKeySqlOnlyWhenSupportingForeignKeys(): void\n    {\n        $fk = new ForeignKeyConstraint(['fk_name'], 'foreign', ['id'], 'constraint_fk');\n\n        if ($this->platform->supportsForeignKeyConstraints()) {\n            self::assertIsString($this->platform->getCreateForeignKeySQL($fk, 'test'));\n        } else {\n            $this->expectException(Exception::class);\n            $this->platform->getCreateForeignKeySQL($fk, 'test');\n        }\n    }\n\n    protected function getBitAndComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return '(' . $value1 . ' & ' . $value2 . ')';\n    }\n\n    public function testGeneratesBitAndComparisonExpressionSql(): void\n    {\n        $sql = $this->platform->getBitAndComparisonExpression(2, 4);\n        self::assertEquals($this->getBitAndComparisonExpressionSql(2, 4), $sql);\n    }\n\n    protected function getBitOrComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return '(' . $value1 . ' | ' . $value2 . ')';\n    }\n\n    public function testGeneratesBitOrComparisonExpressionSql(): void\n    {\n        $sql = $this->platform->getBitOrComparisonExpression(2, 4);\n        self::assertEquals($this->getBitOrComparisonExpressionSql(2, 4), $sql);\n    }\n\n    public function getGenerateConstraintUniqueIndexSql(): string\n    {\n        return 'ALTER TABLE test ADD CONSTRAINT constraint_name UNIQUE (test)';\n    }\n\n    public function getGenerateConstraintPrimaryIndexSql(): string\n    {\n        return 'ALTER TABLE test ADD CONSTRAINT constraint_name PRIMARY KEY (test)';\n    }\n\n    public function getGenerateConstraintForeignKeySql(ForeignKeyConstraint $fk): string\n    {\n        $quotedForeignTable = $fk->getQuotedForeignTableName($this->platform);\n\n        return sprintf(\n            'ALTER TABLE test ADD CONSTRAINT constraint_fk FOREIGN KEY (fk_name) REFERENCES %s (id)',\n            $quotedForeignTable\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract public function getGenerateAlterTableSql(): array;\n\n    public function testGeneratesTableAlterationSql(): void\n    {\n        $expectedSql = $this->getGenerateAlterTableSql();\n\n        $table = new Table('mytable');\n        $table->addColumn('id', 'integer', ['autoincrement' => true]);\n        $table->addColumn('foo', 'integer');\n        $table->addColumn('bar', 'string');\n        $table->addColumn('bloo', 'boolean');\n        $table->setPrimaryKey(['id']);\n\n        $tableDiff                         = new TableDiff('mytable');\n        $tableDiff->fromTable              = $table;\n        $tableDiff->newName                = 'userlist';\n        $tableDiff->addedColumns['quota']  = new Column('quota', Type::getType('integer'), ['notnull' => false]);\n        $tableDiff->removedColumns['foo']  = new Column('foo', Type::getType('integer'));\n        $tableDiff->changedColumns['bar']  = new ColumnDiff(\n            'bar',\n            new Column(\n                'baz',\n                Type::getType('string'),\n                ['default' => 'def']\n            ),\n            ['type', 'notnull', 'default']\n        );\n        $tableDiff->changedColumns['bloo'] = new ColumnDiff(\n            'bloo',\n            new Column(\n                'bloo',\n                Type::getType('boolean'),\n                ['default' => false]\n            ),\n            ['type', 'notnull', 'default']\n        );\n\n        $sql = $this->platform->getAlterTableSQL($tableDiff);\n\n        self::assertEquals($expectedSql, $sql);\n    }\n\n    public function testGetCustomColumnDeclarationSql(): void\n    {\n        self::assertEquals(\n            'foo MEDIUMINT(6) UNSIGNED',\n            $this->platform->getColumnDeclarationSQL('foo', ['columnDefinition' => 'MEDIUMINT(6) UNSIGNED'])\n        );\n    }\n\n    public function testGetCreateTableSqlDispatchEvent(): void\n    {\n        $listenerMock = $this->createMock(GetCreateTableSqlDispatchEventListener::class);\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaCreateTable');\n        $listenerMock\n            ->expects(self::exactly(2))\n            ->method('onSchemaCreateTableColumn');\n\n        $eventManager = new EventManager();\n        $eventManager->addEventListener([\n            Events::onSchemaCreateTable,\n            Events::onSchemaCreateTableColumn,\n        ], $listenerMock);\n\n        $this->platform->setEventManager($eventManager);\n\n        $table = new Table('test');\n        $table->addColumn('foo', 'string', ['notnull' => false, 'length' => 255]);\n        $table->addColumn('bar', 'string', ['notnull' => false, 'length' => 255]);\n\n        $this->platform->getCreateTableSQL($table);\n    }\n\n    public function testGetDropTableSqlDispatchEvent(): void\n    {\n        $listenerMock = $this->createMock(GetDropTableSqlDispatchEventListener::class);\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaDropTable');\n\n        $eventManager = new EventManager();\n        $eventManager->addEventListener([Events::onSchemaDropTable], $listenerMock);\n\n        $this->platform->setEventManager($eventManager);\n\n        $this->platform->getDropTableSQL('TABLE');\n    }\n\n    public function testGetAlterTableSqlDispatchEvent(): void\n    {\n        $listenerMock = $this->createMock(GetAlterTableSqlDispatchEventListener::class);\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTable');\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTableAddColumn');\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTableRemoveColumn');\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTableChangeColumn');\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTableRenameColumn');\n\n        $eventManager = new EventManager();\n        $events       = [\n            Events::onSchemaAlterTable,\n            Events::onSchemaAlterTableAddColumn,\n            Events::onSchemaAlterTableRemoveColumn,\n            Events::onSchemaAlterTableChangeColumn,\n            Events::onSchemaAlterTableRenameColumn,\n        ];\n        $eventManager->addEventListener($events, $listenerMock);\n\n        $this->platform->setEventManager($eventManager);\n\n        $table = new Table('mytable');\n        $table->addColumn('removed', 'integer');\n        $table->addColumn('changed', 'integer');\n        $table->addColumn('renamed', 'integer');\n\n        $tableDiff                            = new TableDiff('mytable');\n        $tableDiff->fromTable                 = $table;\n        $tableDiff->addedColumns['added']     = new Column('added', Type::getType('integer'), []);\n        $tableDiff->removedColumns['removed'] = new Column('removed', Type::getType('integer'), []);\n        $tableDiff->changedColumns['changed'] = new ColumnDiff(\n            'changed',\n            new Column(\n                'changed2',\n                Type::getType('string'),\n                []\n            ),\n            []\n        );\n        $tableDiff->renamedColumns['renamed'] = new Column('renamed2', Type::getType('integer'), []);\n\n        $this->platform->getAlterTableSQL($tableDiff);\n    }\n\n    public function testCreateTableColumnComments(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer', ['comment' => 'This is a comment']);\n        $table->setPrimaryKey(['id']);\n\n        self::assertEquals($this->getCreateTableColumnCommentsSQL(), $this->platform->getCreateTableSQL($table));\n    }\n\n    public function testAlterTableColumnComments(): void\n    {\n        $tableDiff                        = new TableDiff('mytable');\n        $tableDiff->addedColumns['quota'] = new Column('quota', Type::getType('integer'), ['comment' => 'A comment']);\n        $tableDiff->changedColumns['foo'] = new ColumnDiff(\n            'foo',\n            new Column(\n                'foo',\n                Type::getType('string')\n            ),\n            ['comment']\n        );\n        $tableDiff->changedColumns['bar'] = new ColumnDiff(\n            'bar',\n            new Column(\n                'baz',\n                Type::getType('string'),\n                ['comment' => 'B comment']\n            ),\n            ['comment']\n        );\n\n        self::assertEquals($this->getAlterTableColumnCommentsSQL(), $this->platform->getAlterTableSQL($tableDiff));\n    }\n\n    public function testCreateTableColumnTypeComments(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('data', 'array');\n        $table->setPrimaryKey(['id']);\n\n        self::assertEquals($this->getCreateTableColumnTypeCommentsSQL(), $this->platform->getCreateTableSQL($table));\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getCreateTableColumnCommentsSQL(): array\n    {\n        self::markTestSkipped('Platform does not support Column comments.');\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getAlterTableColumnCommentsSQL(): array\n    {\n        self::markTestSkipped('Platform does not support Column comments.');\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getCreateTableColumnTypeCommentsSQL(): array\n    {\n        self::markTestSkipped('Platform does not support Column comments.');\n    }\n\n    public function testGetDefaultValueDeclarationSQL(): void\n    {\n        // non-timestamp value will get single quotes\n        self::assertEquals(\" DEFAULT 'non_timestamp'\", $this->platform->getDefaultValueDeclarationSQL([\n            'type' => Type::getType('string'),\n            'default' => 'non_timestamp',\n        ]));\n    }\n\n    public function testGetDefaultValueDeclarationSQLDateTime(): void\n    {\n        // timestamps on datetime types should not be quoted\n        foreach (['datetime', 'datetimetz', 'datetime_immutable', 'datetimetz_immutable'] as $type) {\n            self::assertSame(\n                ' DEFAULT ' . $this->platform->getCurrentTimestampSQL(),\n                $this->platform->getDefaultValueDeclarationSQL([\n                    'type'    => Type::getType($type),\n                    'default' => $this->platform->getCurrentTimestampSQL(),\n                ])\n            );\n        }\n    }\n\n    public function testGetDefaultValueDeclarationSQLForIntegerTypes(): void\n    {\n        foreach (['bigint', 'integer', 'smallint'] as $type) {\n            self::assertEquals(\n                ' DEFAULT 1',\n                $this->platform->getDefaultValueDeclarationSQL([\n                    'type'    => Type::getType($type),\n                    'default' => 1,\n                ])\n            );\n        }\n    }\n\n    public function testGetDefaultValueDeclarationSQLForDateType(): void\n    {\n        $currentDateSql = $this->platform->getCurrentDateSQL();\n        foreach (['date', 'date_immutable'] as $type) {\n            self::assertSame(\n                ' DEFAULT ' . $currentDateSql,\n                $this->platform->getDefaultValueDeclarationSQL([\n                    'type'    => Type::getType($type),\n                    'default' => $currentDateSql,\n                ])\n            );\n        }\n    }\n\n    public function testKeywordList(): void\n    {\n        $keywordList = $this->platform->getReservedKeywordsList();\n        self::assertInstanceOf(KeywordList::class, $keywordList);\n\n        self::assertTrue($keywordList->isKeyword('table'));\n    }\n\n    public function testQuotedColumnInPrimaryKeyPropagation(): void\n    {\n        $table = new Table('`quoted`');\n        $table->addColumn('create', 'string');\n        $table->setPrimaryKey(['create']);\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getQuotedColumnInPrimaryKeySQL(), $sql);\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotedColumnInPrimaryKeySQL(): array;\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotedColumnInIndexSQL(): array;\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotedNameInIndexSQL(): array;\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotedColumnInForeignKeySQL(): array;\n\n    public function testQuotedColumnInIndexPropagation(): void\n    {\n        $table = new Table('`quoted`');\n        $table->addColumn('create', 'string');\n        $table->addIndex(['create']);\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getQuotedColumnInIndexSQL(), $sql);\n    }\n\n    public function testQuotedNameInIndexSQL(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('column1', 'string');\n        $table->addIndex(['column1'], '`key`');\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getQuotedNameInIndexSQL(), $sql);\n    }\n\n    public function testQuotedColumnInForeignKeyPropagation(): void\n    {\n        $table = new Table('`quoted`');\n        $table->addColumn('create', 'string');\n        $table->addColumn('foo', 'string');\n        $table->addColumn('`bar`', 'string');\n\n        // Foreign table with reserved keyword as name (needs quotation).\n        $foreignTable = new Table('foreign');\n\n        // Foreign column with reserved keyword as name (needs quotation).\n        $foreignTable->addColumn('create', 'string');\n\n        // Foreign column with non-reserved keyword as name (does not need quotation).\n        $foreignTable->addColumn('bar', 'string');\n\n        // Foreign table with special character in name (needs quotation on some platforms, e.g. Sqlite).\n        $foreignTable->addColumn('`foo-bar`', 'string');\n\n        $table->addForeignKeyConstraint(\n            $foreignTable,\n            ['create', 'foo', '`bar`'],\n            ['create', 'bar', '`foo-bar`'],\n            [],\n            'FK_WITH_RESERVED_KEYWORD'\n        );\n\n        // Foreign table with non-reserved keyword as name (does not need quotation).\n        $foreignTable = new Table('foo');\n\n        // Foreign column with reserved keyword as name (needs quotation).\n        $foreignTable->addColumn('create', 'string');\n\n        // Foreign column with non-reserved keyword as name (does not need quotation).\n        $foreignTable->addColumn('bar', 'string');\n\n        // Foreign table with special character in name (needs quotation on some platforms, e.g. Sqlite).\n        $foreignTable->addColumn('`foo-bar`', 'string');\n\n        $table->addForeignKeyConstraint(\n            $foreignTable,\n            ['create', 'foo', '`bar`'],\n            ['create', 'bar', '`foo-bar`'],\n            [],\n            'FK_WITH_NON_RESERVED_KEYWORD'\n        );\n\n        // Foreign table with special character in name (needs quotation on some platforms, e.g. Sqlite).\n        $foreignTable = new Table('`foo-bar`');\n\n        // Foreign column with reserved keyword as name (needs quotation).\n        $foreignTable->addColumn('create', 'string');\n\n        // Foreign column with non-reserved keyword as name (does not need quotation).\n        $foreignTable->addColumn('bar', 'string');\n\n        // Foreign table with special character in name (needs quotation on some platforms, e.g. Sqlite).\n        $foreignTable->addColumn('`foo-bar`', 'string');\n\n        $table->addForeignKeyConstraint(\n            $foreignTable,\n            ['create', 'foo', '`bar`'],\n            ['create', 'bar', '`foo-bar`'],\n            [],\n            'FK_WITH_INTENDED_QUOTATION'\n        );\n\n        $sql = $this->platform->getCreateTableSQL($table, AbstractPlatform::CREATE_FOREIGNKEYS);\n        self::assertEquals($this->getQuotedColumnInForeignKeySQL(), $sql);\n    }\n\n    public function testQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): void\n    {\n        $constraint = new UniqueConstraint('select', ['foo'], [], []);\n\n        self::assertSame(\n            $this->getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(),\n            $this->platform->getUniqueConstraintDeclarationSQL('select', $constraint)\n        );\n    }\n\n    abstract protected function getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): string;\n\n    public function testQuotesReservedKeywordInTruncateTableSQL(): void\n    {\n        self::assertSame(\n            $this->getQuotesReservedKeywordInTruncateTableSQL(),\n            $this->platform->getTruncateTableSQL('select')\n        );\n    }\n\n    abstract protected function getQuotesReservedKeywordInTruncateTableSQL(): string;\n\n    public function testQuotesReservedKeywordInIndexDeclarationSQL(): void\n    {\n        $index = new Index('select', ['foo']);\n\n        if (! $this->supportsInlineIndexDeclaration()) {\n            $this->expectException(Exception::class);\n        }\n\n        self::assertSame(\n            $this->getQuotesReservedKeywordInIndexDeclarationSQL(),\n            $this->platform->getIndexDeclarationSQL('select', $index)\n        );\n    }\n\n    abstract protected function getQuotesReservedKeywordInIndexDeclarationSQL(): string;\n\n    protected function supportsInlineIndexDeclaration(): bool\n    {\n        return true;\n    }\n\n    public function testSupportsCommentOnStatement(): void\n    {\n        self::assertSame($this->supportsCommentOnStatement(), $this->platform->supportsCommentOnStatement());\n    }\n\n    protected function supportsCommentOnStatement(): bool\n    {\n        return false;\n    }\n\n    public function testGetCreateSchemaSQL(): void\n    {\n        $this->expectException(Exception::class);\n\n        $this->platform->getCreateSchemaSQL('schema');\n    }\n\n    public function testAlterTableChangeQuotedColumn(): void\n    {\n        $table = new Table('mytable');\n        $table->addColumn('select', 'integer');\n\n        $tableDiff                           = new TableDiff('mytable');\n        $tableDiff->fromTable                = $table;\n        $tableDiff->changedColumns['select'] = new ColumnDiff(\n            'select',\n            new Column(\n                'select',\n                Type::getType('string')\n            ),\n            ['type']\n        );\n\n        self::assertStringContainsString(\n            $this->platform->quoteIdentifier('select'),\n            implode(';', $this->platform->getAlterTableSQL($tableDiff))\n        );\n    }\n\n    public function testUsesSequenceEmulatedIdentityColumns(): void\n    {\n        self::assertFalse($this->platform->usesSequenceEmulatedIdentityColumns());\n    }\n\n    /**\n     * @group DBAL-563\n     */\n    public function testReturnsIdentitySequenceName(): void\n    {\n        $this->expectException(Exception::class);\n\n        $this->platform->getIdentitySequenceName('mytable', 'mycolumn');\n    }\n\n    public function testReturnsBinaryDefaultLength(): void\n    {\n        self::assertSame($this->getBinaryDefaultLength(), $this->platform->getBinaryDefaultLength());\n    }\n\n    protected function getBinaryDefaultLength(): int\n    {\n        return 255;\n    }\n\n    public function testReturnsBinaryMaxLength(): void\n    {\n        self::assertSame($this->getBinaryMaxLength(), $this->platform->getBinaryMaxLength());\n    }\n\n    protected function getBinaryMaxLength(): int\n    {\n        return 4000;\n    }\n\n    public function testReturnsBinaryTypeDeclarationSQL(): void\n    {\n        $this->expectException(Exception::class);\n\n        $this->platform->getBinaryTypeDeclarationSQL([]);\n    }\n\n    public function testReturnsBinaryTypeLongerThanMaxDeclarationSQL(): void\n    {\n        $this->markTestSkipped('Not applicable to the platform');\n    }\n\n    public function hasNativeJsonType(): void\n    {\n        self::assertFalse($this->platform->hasNativeJsonType());\n    }\n\n    public function testReturnsJsonTypeDeclarationSQL(): void\n    {\n        $column = [\n            'length'  => 666,\n            'notnull' => true,\n            'type'    => Type::getType('json'),\n        ];\n\n        self::assertSame(\n            $this->platform->getClobTypeDeclarationSQL($column),\n            $this->platform->getJsonTypeDeclarationSQL($column)\n        );\n    }\n\n    public function testAlterTableRenameIndex(): void\n    {\n        $tableDiff            = new TableDiff('mytable');\n        $tableDiff->fromTable = new Table('mytable');\n        $tableDiff->fromTable->addColumn('id', 'integer');\n        $tableDiff->fromTable->setPrimaryKey(['id']);\n        $tableDiff->renamedIndexes = [\n            'idx_foo' => new Index('idx_bar', ['id']),\n        ];\n\n        self::assertSame(\n            $this->getAlterTableRenameIndexSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getAlterTableRenameIndexSQL(): array\n    {\n        return [\n            'DROP INDEX idx_foo',\n            'CREATE INDEX idx_bar ON mytable (id)',\n        ];\n    }\n\n    public function testQuotesAlterTableRenameIndex(): void\n    {\n        $tableDiff            = new TableDiff('table');\n        $tableDiff->fromTable = new Table('table');\n        $tableDiff->fromTable->addColumn('id', 'integer');\n        $tableDiff->fromTable->setPrimaryKey(['id']);\n        $tableDiff->renamedIndexes = [\n            'create' => new Index('select', ['id']),\n            '`foo`'  => new Index('`bar`', ['id']),\n        ];\n\n        self::assertSame(\n            $this->getQuotedAlterTableRenameIndexSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getQuotedAlterTableRenameIndexSQL(): array\n    {\n        return [\n            'DROP INDEX \"create\"',\n            'CREATE INDEX \"select\" ON \"table\" (id)',\n            'DROP INDEX \"foo\"',\n            'CREATE INDEX \"bar\" ON \"table\" (id)',\n        ];\n    }\n\n    public function testQuotesAlterTableRenameColumn(): void\n    {\n        $fromTable = new Table('mytable');\n\n        $fromTable->addColumn('unquoted1', 'integer', ['comment' => 'Unquoted 1']);\n        $fromTable->addColumn('unquoted2', 'integer', ['comment' => 'Unquoted 2']);\n        $fromTable->addColumn('unquoted3', 'integer', ['comment' => 'Unquoted 3']);\n\n        $fromTable->addColumn('create', 'integer', ['comment' => 'Reserved keyword 1']);\n        $fromTable->addColumn('table', 'integer', ['comment' => 'Reserved keyword 2']);\n        $fromTable->addColumn('select', 'integer', ['comment' => 'Reserved keyword 3']);\n\n        $fromTable->addColumn('`quoted1`', 'integer', ['comment' => 'Quoted 1']);\n        $fromTable->addColumn('`quoted2`', 'integer', ['comment' => 'Quoted 2']);\n        $fromTable->addColumn('`quoted3`', 'integer', ['comment' => 'Quoted 3']);\n\n        $toTable = new Table('mytable');\n\n        // unquoted -> unquoted\n        $toTable->addColumn('unquoted', 'integer', ['comment' => 'Unquoted 1']);\n\n        // unquoted -> reserved keyword\n        $toTable->addColumn('where', 'integer', ['comment' => 'Unquoted 2']);\n\n        // unquoted -> quoted\n        $toTable->addColumn('`foo`', 'integer', ['comment' => 'Unquoted 3']);\n\n        // reserved keyword -> unquoted\n        $toTable->addColumn('reserved_keyword', 'integer', ['comment' => 'Reserved keyword 1']);\n\n        // reserved keyword -> reserved keyword\n        $toTable->addColumn('from', 'integer', ['comment' => 'Reserved keyword 2']);\n\n        // reserved keyword -> quoted\n        $toTable->addColumn('`bar`', 'integer', ['comment' => 'Reserved keyword 3']);\n\n        // quoted -> unquoted\n        $toTable->addColumn('quoted', 'integer', ['comment' => 'Quoted 1']);\n\n        // quoted -> reserved keyword\n        $toTable->addColumn('and', 'integer', ['comment' => 'Quoted 2']);\n\n        // quoted -> quoted\n        $toTable->addColumn('`baz`', 'integer', ['comment' => 'Quoted 3']);\n\n        $diff = (new Comparator())->diffTable($fromTable, $toTable);\n        self::assertNotFalse($diff);\n\n        self::assertEquals(\n            $this->getQuotedAlterTableRenameColumnSQL(),\n            $this->platform->getAlterTableSQL($diff)\n        );\n    }\n\n    /**\n     * Returns SQL statements for {@link testQuotesAlterTableRenameColumn}.\n     *\n     * @return string[]\n     */\n    abstract protected function getQuotedAlterTableRenameColumnSQL(): array;\n\n    public function testQuotesAlterTableChangeColumnLength(): void\n    {\n        $fromTable = new Table('mytable');\n\n        $fromTable->addColumn('unquoted1', 'string', ['comment' => 'Unquoted 1', 'length' => 10]);\n        $fromTable->addColumn('unquoted2', 'string', ['comment' => 'Unquoted 2', 'length' => 10]);\n        $fromTable->addColumn('unquoted3', 'string', ['comment' => 'Unquoted 3', 'length' => 10]);\n\n        $fromTable->addColumn('create', 'string', ['comment' => 'Reserved keyword 1', 'length' => 10]);\n        $fromTable->addColumn('table', 'string', ['comment' => 'Reserved keyword 2', 'length' => 10]);\n        $fromTable->addColumn('select', 'string', ['comment' => 'Reserved keyword 3', 'length' => 10]);\n\n        $toTable = new Table('mytable');\n\n        $toTable->addColumn('unquoted1', 'string', ['comment' => 'Unquoted 1', 'length' => 255]);\n        $toTable->addColumn('unquoted2', 'string', ['comment' => 'Unquoted 2', 'length' => 255]);\n        $toTable->addColumn('unquoted3', 'string', ['comment' => 'Unquoted 3', 'length' => 255]);\n\n        $toTable->addColumn('create', 'string', ['comment' => 'Reserved keyword 1', 'length' => 255]);\n        $toTable->addColumn('table', 'string', ['comment' => 'Reserved keyword 2', 'length' => 255]);\n        $toTable->addColumn('select', 'string', ['comment' => 'Reserved keyword 3', 'length' => 255]);\n\n        $diff = (new Comparator())->diffTable($fromTable, $toTable);\n        self::assertNotFalse($diff);\n\n        self::assertEquals(\n            $this->getQuotedAlterTableChangeColumnLengthSQL(),\n            $this->platform->getAlterTableSQL($diff)\n        );\n    }\n\n    /**\n     * Returns SQL statements for {@link testQuotesAlterTableChangeColumnLength}.\n     *\n     * @return string[]\n     */\n    abstract protected function getQuotedAlterTableChangeColumnLengthSQL(): array;\n\n    public function testAlterTableRenameIndexInSchema(): void\n    {\n        $tableDiff            = new TableDiff('myschema.mytable');\n        $tableDiff->fromTable = new Table('myschema.mytable');\n        $tableDiff->fromTable->addColumn('id', 'integer');\n        $tableDiff->fromTable->setPrimaryKey(['id']);\n        $tableDiff->renamedIndexes = [\n            'idx_foo' => new Index('idx_bar', ['id']),\n        ];\n\n        self::assertSame(\n            $this->getAlterTableRenameIndexInSchemaSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return [\n            'DROP INDEX idx_foo',\n            'CREATE INDEX idx_bar ON myschema.mytable (id)',\n        ];\n    }\n\n    public function testQuotesAlterTableRenameIndexInSchema(): void\n    {\n        $tableDiff            = new TableDiff('`schema`.table');\n        $tableDiff->fromTable = new Table('`schema`.table');\n        $tableDiff->fromTable->addColumn('id', 'integer');\n        $tableDiff->fromTable->setPrimaryKey(['id']);\n        $tableDiff->renamedIndexes = [\n            'create' => new Index('select', ['id']),\n            '`foo`'  => new Index('`bar`', ['id']),\n        ];\n\n        self::assertSame(\n            $this->getQuotedAlterTableRenameIndexInSchemaSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getQuotedAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return [\n            'DROP INDEX \"schema\".\"create\"',\n            'CREATE INDEX \"select\" ON \"schema\".\"table\" (id)',\n            'DROP INDEX \"schema\".\"foo\"',\n            'CREATE INDEX \"bar\" ON \"schema\".\"table\" (id)',\n        ];\n    }\n\n    public function testQuotesDropForeignKeySQL(): void\n    {\n        if (! $this->platform->supportsForeignKeyConstraints()) {\n            $this->markTestSkipped(\n                sprintf('%s does not support foreign key constraints.', get_class($this->platform))\n            );\n        }\n\n        $tableName      = 'table';\n        $table          = new Table($tableName);\n        $foreignKeyName = 'select';\n        $foreignKey     = new ForeignKeyConstraint([], 'foo', [], 'select');\n        $expectedSql    = $this->getQuotesDropForeignKeySQL();\n\n        self::assertSame($expectedSql, $this->platform->getDropForeignKeySQL($foreignKeyName, $tableName));\n        self::assertSame($expectedSql, $this->platform->getDropForeignKeySQL($foreignKey, $table));\n    }\n\n    protected function getQuotesDropForeignKeySQL(): string\n    {\n        return 'ALTER TABLE \"table\" DROP FOREIGN KEY \"select\"';\n    }\n\n    public function testQuotesDropConstraintSQL(): void\n    {\n        $tableName      = 'table';\n        $table          = new Table($tableName);\n        $constraintName = 'select';\n        $constraint     = new ForeignKeyConstraint([], 'foo', [], 'select');\n        $expectedSql    = $this->getQuotesDropConstraintSQL();\n\n        self::assertSame($expectedSql, $this->platform->getDropConstraintSQL($constraintName, $tableName));\n        self::assertSame($expectedSql, $this->platform->getDropConstraintSQL($constraint, $table));\n    }\n\n    protected function getQuotesDropConstraintSQL(): string\n    {\n        return 'ALTER TABLE \"table\" DROP CONSTRAINT \"select\"';\n    }\n\n    protected function getStringLiteralQuoteCharacter(): string\n    {\n        return \"'\";\n    }\n\n    public function testGetStringLiteralQuoteCharacter(): void\n    {\n        self::assertSame($this->getStringLiteralQuoteCharacter(), $this->platform->getStringLiteralQuoteCharacter());\n    }\n\n    protected function getQuotedCommentOnColumnSQLWithoutQuoteCharacter(): string\n    {\n        return \"COMMENT ON COLUMN mytable.id IS 'This is a comment'\";\n    }\n\n    public function testGetCommentOnColumnSQLWithoutQuoteCharacter(): void\n    {\n        self::assertEquals(\n            $this->getQuotedCommentOnColumnSQLWithoutQuoteCharacter(),\n            $this->platform->getCommentOnColumnSQL('mytable', 'id', 'This is a comment')\n        );\n    }\n\n    protected function getQuotedCommentOnColumnSQLWithQuoteCharacter(): string\n    {\n        return \"COMMENT ON COLUMN mytable.id IS 'It''s a quote !'\";\n    }\n\n    public function testGetCommentOnColumnSQLWithQuoteCharacter(): void\n    {\n        $c = $this->getStringLiteralQuoteCharacter();\n\n        self::assertEquals(\n            $this->getQuotedCommentOnColumnSQLWithQuoteCharacter(),\n            $this->platform->getCommentOnColumnSQL('mytable', 'id', 'It' . $c . 's a quote !')\n        );\n    }\n\n    /**\n     * @see testGetCommentOnColumnSQL\n     *\n     * @return string[]\n     */\n    abstract protected function getCommentOnColumnSQL(): array;\n\n    public function testGetCommentOnColumnSQL(): void\n    {\n        self::assertSame(\n            $this->getCommentOnColumnSQL(),\n            [\n                $this->platform->getCommentOnColumnSQL('foo', 'bar', 'comment'), // regular identifiers\n                $this->platform->getCommentOnColumnSQL('`Foo`', '`BAR`', 'comment'), // explicitly quoted identifiers\n                $this->platform->getCommentOnColumnSQL('select', 'from', 'comment'), // reserved keyword identifiers\n            ]\n        );\n    }\n\n    /**\n     * @dataProvider getGeneratesInlineColumnCommentSQL\n     */\n    public function testGeneratesInlineColumnCommentSQL(string $comment, string $expectedSql): void\n    {\n        if (! $this->platform->supportsInlineColumnComments()) {\n            self::markTestSkipped(sprintf('%s does not support inline column comments.', get_class($this->platform)));\n        }\n\n        self::assertSame($expectedSql, $this->platform->getInlineColumnCommentSQL($comment));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesInlineColumnCommentSQL(): iterable\n    {\n        return [\n            'regular comment' => ['Regular comment', static::getInlineColumnRegularCommentSQL()],\n            'comment requiring escaping' => [\n                sprintf(\n                    'Using inline comment delimiter %s works',\n                    static::getInlineColumnCommentDelimiter()\n                ),\n                static::getInlineColumnCommentRequiringEscapingSQL(),\n            ],\n            'empty comment' => ['', static::getInlineColumnEmptyCommentSQL()],\n        ];\n    }\n\n    protected static function getInlineColumnCommentDelimiter(): string\n    {\n        return \"'\";\n    }\n\n    protected static function getInlineColumnRegularCommentSQL(): string\n    {\n        return \"COMMENT 'Regular comment'\";\n    }\n\n    protected static function getInlineColumnCommentRequiringEscapingSQL(): string\n    {\n        return \"COMMENT 'Using inline comment delimiter '' works'\";\n    }\n\n    protected static function getInlineColumnEmptyCommentSQL(): string\n    {\n        return \"COMMENT ''\";\n    }\n\n    protected function getQuotedStringLiteralWithoutQuoteCharacter(): string\n    {\n        return \"'No quote'\";\n    }\n\n    protected function getQuotedStringLiteralWithQuoteCharacter(): string\n    {\n        return \"'It''s a quote'\";\n    }\n\n    protected function getQuotedStringLiteralQuoteCharacter(): string\n    {\n        return \"''''\";\n    }\n\n    public function testThrowsExceptionOnGeneratingInlineColumnCommentSQLIfUnsupported(): void\n    {\n        if ($this->platform->supportsInlineColumnComments()) {\n            self::markTestSkipped(sprintf('%s supports inline column comments.', get_class($this->platform)));\n        }\n\n        $this->expectException(Exception::class);\n        $this->expectExceptionMessage(\n            \"Operation '\" . AbstractPlatform::class . \"::getInlineColumnCommentSQL' is not supported by platform.\"\n        );\n        $this->expectExceptionCode(0);\n\n        $this->platform->getInlineColumnCommentSQL('unsupported');\n    }\n\n    public function testQuoteStringLiteral(): void\n    {\n        $c = $this->getStringLiteralQuoteCharacter();\n\n        self::assertEquals(\n            $this->getQuotedStringLiteralWithoutQuoteCharacter(),\n            $this->platform->quoteStringLiteral('No quote')\n        );\n        self::assertEquals(\n            $this->getQuotedStringLiteralWithQuoteCharacter(),\n            $this->platform->quoteStringLiteral('It' . $c . 's a quote')\n        );\n        self::assertEquals(\n            $this->getQuotedStringLiteralQuoteCharacter(),\n            $this->platform->quoteStringLiteral($c)\n        );\n    }\n\n    public function testReturnsGuidTypeDeclarationSQL(): void\n    {\n        $this->expectException(Exception::class);\n\n        $this->platform->getGuidTypeDeclarationSQL([]);\n    }\n\n    public function testGeneratesAlterTableRenameColumnSQL(): void\n    {\n        $table = new Table('foo');\n        $table->addColumn(\n            'bar',\n            'integer',\n            ['notnull' => true, 'default' => 666, 'comment' => 'rename test']\n        );\n\n        $tableDiff                        = new TableDiff('foo');\n        $tableDiff->fromTable             = $table;\n        $tableDiff->renamedColumns['bar'] = new Column(\n            'baz',\n            Type::getType('integer'),\n            ['notnull' => true, 'default' => 666, 'comment' => 'rename test']\n        );\n\n        self::assertSame($this->getAlterTableRenameColumnSQL(), $this->platform->getAlterTableSQL($tableDiff));\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract public function getAlterTableRenameColumnSQL(): array;\n\n    public function testQuotesTableIdentifiersInAlterTableSQL(): void\n    {\n        $table = new Table('\"foo\"');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('fk', 'integer');\n        $table->addColumn('fk2', 'integer');\n        $table->addColumn('fk3', 'integer');\n        $table->addColumn('bar', 'integer');\n        $table->addColumn('baz', 'integer');\n        $table->addForeignKeyConstraint('fk_table', ['fk'], ['id'], [], 'fk1');\n        $table->addForeignKeyConstraint('fk_table', ['fk2'], ['id'], [], 'fk2');\n\n        $tableDiff                        = new TableDiff('\"foo\"');\n        $tableDiff->fromTable             = $table;\n        $tableDiff->newName               = 'table';\n        $tableDiff->addedColumns['bloo']  = new Column('bloo', Type::getType('integer'));\n        $tableDiff->changedColumns['bar'] = new ColumnDiff(\n            'bar',\n            new Column('bar', Type::getType('integer'), ['notnull' => false]),\n            ['notnull'],\n            $table->getColumn('bar')\n        );\n        $tableDiff->renamedColumns['id']  = new Column('war', Type::getType('integer'));\n        $tableDiff->removedColumns['baz'] = new Column('baz', Type::getType('integer'));\n        $tableDiff->addedForeignKeys[]    = new ForeignKeyConstraint(['fk3'], 'fk_table', ['id'], 'fk_add');\n        $tableDiff->changedForeignKeys[]  = new ForeignKeyConstraint(['fk2'], 'fk_table2', ['id'], 'fk2');\n        $tableDiff->removedForeignKeys[]  = new ForeignKeyConstraint(['fk'], 'fk_table', ['id'], 'fk1');\n\n        self::assertSame(\n            $this->getQuotesTableIdentifiersInAlterTableSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotesTableIdentifiersInAlterTableSQL(): array;\n\n    public function testAlterStringToFixedString(): void\n    {\n        $table = new Table('mytable');\n        $table->addColumn('name', 'string', ['length' => 2]);\n\n        $tableDiff            = new TableDiff('mytable');\n        $tableDiff->fromTable = $table;\n\n        $tableDiff->changedColumns['name'] = new ColumnDiff(\n            'name',\n            new Column(\n                'name',\n                Type::getType('string'),\n                ['fixed' => true, 'length' => 2]\n            ),\n            ['fixed']\n        );\n\n        $sql = $this->platform->getAlterTableSQL($tableDiff);\n\n        $expectedSql = $this->getAlterStringToFixedStringSQL();\n\n        self::assertEquals($expectedSql, $sql);\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getAlterStringToFixedStringSQL(): array;\n\n    public function testGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): void\n    {\n        $foreignTable = new Table('foreign_table');\n        $foreignTable->addColumn('id', 'integer');\n        $foreignTable->setPrimaryKey(['id']);\n\n        $primaryTable = new Table('mytable');\n        $primaryTable->addColumn('foo', 'integer');\n        $primaryTable->addColumn('bar', 'integer');\n        $primaryTable->addColumn('baz', 'integer');\n        $primaryTable->addIndex(['foo'], 'idx_foo');\n        $primaryTable->addIndex(['bar'], 'idx_bar');\n        $primaryTable->addForeignKeyConstraint($foreignTable, ['foo'], ['id'], [], 'fk_foo');\n        $primaryTable->addForeignKeyConstraint($foreignTable, ['bar'], ['id'], [], 'fk_bar');\n\n        $tableDiff                            = new TableDiff('mytable');\n        $tableDiff->fromTable                 = $primaryTable;\n        $tableDiff->renamedIndexes['idx_foo'] = new Index('idx_foo_renamed', ['foo']);\n\n        self::assertSame(\n            $this->getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): array;\n\n    /**\n     * @param mixed[] $column\n     *\n     * @dataProvider getGeneratesDecimalTypeDeclarationSQL\n     */\n    public function testGeneratesDecimalTypeDeclarationSQL(array $column, string $expectedSql): void\n    {\n        self::assertSame($expectedSql, $this->platform->getDecimalTypeDeclarationSQL($column));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesDecimalTypeDeclarationSQL(): iterable\n    {\n        return [\n            [[], 'NUMERIC(10, 0)'],\n            [['unsigned' => true], 'NUMERIC(10, 0)'],\n            [['unsigned' => false], 'NUMERIC(10, 0)'],\n            [['precision' => 5], 'NUMERIC(5, 0)'],\n            [['scale' => 5], 'NUMERIC(10, 5)'],\n            [['precision' => 8, 'scale' => 2], 'NUMERIC(8, 2)'],\n        ];\n    }\n\n    /**\n     * @param mixed[] $column\n     *\n     * @dataProvider getGeneratesFloatDeclarationSQL\n     */\n    public function testGeneratesFloatDeclarationSQL(array $column, string $expectedSql): void\n    {\n        self::assertSame($expectedSql, $this->platform->getFloatDeclarationSQL($column));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesFloatDeclarationSQL(): iterable\n    {\n        return [\n            [[], 'DOUBLE PRECISION'],\n            [['unsigned' => true], 'DOUBLE PRECISION'],\n            [['unsigned' => false], 'DOUBLE PRECISION'],\n            [['precision' => 5], 'DOUBLE PRECISION'],\n            [['scale' => 5], 'DOUBLE PRECISION'],\n            [['precision' => 8, 'scale' => 2], 'DOUBLE PRECISION'],\n        ];\n    }\n\n    public function testItEscapesStringsForLike(): void\n    {\n        self::assertSame(\n            '\\_25\\% off\\_ your next purchase \\\\\\\\o/',\n            $this->platform->escapeStringForLike('_25% off_ your next purchase \\o/', '\\\\')\n        );\n    }\n\n    public function testZeroOffsetWithoutLimitIsIgnored(): void\n    {\n        $query = 'SELECT * FROM user';\n\n        self::assertSame(\n            $query,\n            $this->platform->modifyLimitQuery($query, null, 0)\n        );\n    }\n\n    /**\n     * @param array<string, mixed> $column\n     *\n     * @dataProvider asciiStringSqlDeclarationDataProvider\n     */\n    public function testAsciiSQLDeclaration(string $expectedSql, array $column): void\n    {\n        $declarationSql = $this->platform->getAsciiStringTypeDeclarationSQL($column);\n        self::assertEquals($expectedSql, $declarationSql);\n    }\n\n    /**\n     * @return array<int, array{string, array<string, mixed>}>\n     */\n    public function asciiStringSqlDeclarationDataProvider(): array\n    {\n        return [\n            ['VARCHAR(12)', ['length' => 12]],\n            ['CHAR(12)', ['length' => 12, 'fixed' => true]],\n        ];\n    }\n\n    public function testInvalidLockMode(): void\n    {\n        $this->expectException(InvalidLockMode::class);\n        $this->platform->appendLockHint('TABLE', 128);\n    }\n}\n\ninterface GetCreateTableSqlDispatchEventListener\n{\n    public function onSchemaCreateTable(): void;\n\n    public function onSchemaCreateTableColumn(): void;\n}\n\ninterface GetAlterTableSqlDispatchEventListener\n{\n    public function onSchemaAlterTable(): void;\n\n    public function onSchemaAlterTableAddColumn(): void;\n\n    public function onSchemaAlterTableRemoveColumn(): void;\n\n    public function onSchemaAlterTableChangeColumn(): void;\n\n    public function onSchemaAlterTableRenameColumn(): void;\n}\n\ninterface GetDropTableSqlDispatchEventListener\n{\n    public function onSchemaDropTable(): void;\n}\n", "<?php\n\nnamespace Doctrine\\DBAL\\Tests\\Platforms;\n\nuse Doctrine\\DBAL\\Platforms\\AbstractPlatform;\nuse Doctrine\\DBAL\\Platforms\\DB2Platform;\nuse Doctrine\\DBAL\\Schema\\Column;\nuse Doctrine\\DBAL\\Schema\\ColumnDiff;\nuse Doctrine\\DBAL\\Schema\\Index;\nuse Doctrine\\DBAL\\Schema\\Table;\nuse Doctrine\\DBAL\\Schema\\TableDiff;\nuse Doctrine\\DBAL\\Types\\Type;\nuse Doctrine\\DBAL\\Types\\Types;\n\n/**\n * @extends AbstractPlatformTestCase<DB2Platform>\n */\nclass DB2PlatformTest extends AbstractPlatformTestCase\n{\n    public function createPlatform(): AbstractPlatform\n    {\n        return new DB2Platform();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getGenerateAlterTableSql(): array\n    {\n        return [\n            'ALTER TABLE mytable ALTER COLUMN baz SET DATA TYPE VARCHAR(255)',\n            'ALTER TABLE mytable ALTER COLUMN baz SET NOT NULL',\n            \"ALTER TABLE mytable ALTER COLUMN baz SET DEFAULT 'def'\",\n            'ALTER TABLE mytable ALTER COLUMN bloo SET DATA TYPE SMALLINT',\n            'ALTER TABLE mytable ALTER COLUMN bloo SET NOT NULL',\n            \"ALTER TABLE mytable ALTER COLUMN bloo SET DEFAULT '0'\",\n            'ALTER TABLE mytable ' .\n            'ADD COLUMN quota INTEGER DEFAULT NULL ' .\n            'DROP COLUMN foo',\n            \"CALL SYSPROC.ADMIN_CMD ('REORG TABLE mytable')\",\n            'RENAME TABLE mytable TO userlist',\n        ];\n    }\n\n    protected function getGenerateForeignKeySql(): string\n    {\n        return 'ALTER TABLE test ADD FOREIGN KEY (fk_name_id) REFERENCES other_table (id)';\n    }\n\n    public function getGenerateIndexSql(): string\n    {\n        return 'CREATE INDEX my_idx ON mytable (user_name, last_login)';\n    }\n\n    public function getGenerateTableSql(): string\n    {\n        return 'CREATE TABLE test (id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL, '\n            . 'test VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id))';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getGenerateTableWithMultiColumnUniqueIndexSql(): array\n    {\n        return [\n            'CREATE TABLE test (foo VARCHAR(255) DEFAULT NULL, bar VARCHAR(255) DEFAULT NULL)',\n            'CREATE UNIQUE INDEX UNIQ_D87F7E0C8C73652176FF8CAA ON test (foo, bar)',\n        ];\n    }\n\n    public function getGenerateUniqueIndexSql(): string\n    {\n        return 'CREATE UNIQUE INDEX index_name ON test (test, test2)';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInForeignKeySQL(): array\n    {\n        return [\n            'CREATE TABLE \"quoted\" (\"create\" VARCHAR(255) NOT NULL, foo VARCHAR(255) NOT NULL, '\n                . '\"bar\" VARCHAR(255) NOT NULL)',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_RESERVED_KEYWORD FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES \"foreign\" (\"create\", bar, \"foo-bar\")',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_NON_RESERVED_KEYWORD FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES foo (\"create\", bar, \"foo-bar\")',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_INTENDED_QUOTATION FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES \"foo-bar\" (\"create\", bar, \"foo-bar\")',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInIndexSQL(): array\n    {\n        return [\n            'CREATE TABLE \"quoted\" (\"create\" VARCHAR(255) NOT NULL)',\n            'CREATE INDEX IDX_22660D028FD6E0FB ON \"quoted\" (\"create\")',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedNameInIndexSQL(): array\n    {\n        return [\n            'CREATE TABLE test (column1 VARCHAR(255) NOT NULL)',\n            'CREATE INDEX \"key\" ON test (column1)',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInPrimaryKeySQL(): array\n    {\n        return ['CREATE TABLE \"quoted\" (\"create\" VARCHAR(255) NOT NULL, PRIMARY KEY(\"create\"))'];\n    }\n\n    protected function getBitAndComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return 'BITAND(' . $value1 . ', ' . $value2 . ')';\n    }\n\n    protected function getBitOrComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return 'BITOR(' . $value1 . ', ' . $value2 . ')';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getCreateTableColumnCommentsSQL(): array\n    {\n        return [\n            'CREATE TABLE test (id INTEGER NOT NULL, PRIMARY KEY(id))',\n            \"COMMENT ON COLUMN test.id IS 'This is a comment'\",\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getAlterTableColumnCommentsSQL(): array\n    {\n        return [\n            'ALTER TABLE mytable ' .\n            'ADD COLUMN quota INTEGER NOT NULL WITH DEFAULT',\n            \"CALL SYSPROC.ADMIN_CMD ('REORG TABLE mytable')\",\n            \"COMMENT ON COLUMN mytable.quota IS 'A comment'\",\n            \"COMMENT ON COLUMN mytable.foo IS ''\",\n            \"COMMENT ON COLUMN mytable.baz IS 'B comment'\",\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getCreateTableColumnTypeCommentsSQL(): array\n    {\n        return [\n            'CREATE TABLE test (id INTEGER NOT NULL, \"data\" CLOB(1M) NOT NULL, PRIMARY KEY(id))',\n            'COMMENT ON COLUMN test.\"data\" IS \\'(DC2Type:array)\\'',\n        ];\n    }\n\n    public function testHasCorrectPlatformName(): void\n    {\n        self::assertEquals('db2', $this->platform->getName());\n    }\n\n    public function testGeneratesCreateTableSQLWithCommonIndexes(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('name', 'string', ['length' => 50]);\n        $table->setPrimaryKey(['id']);\n        $table->addIndex(['name']);\n        $table->addIndex(['id', 'name'], 'composite_idx');\n\n        self::assertEquals(\n            [\n                'CREATE TABLE test (id INTEGER NOT NULL, name VARCHAR(50) NOT NULL, PRIMARY KEY(id))',\n                'CREATE INDEX IDX_D87F7E0C5E237E06 ON test (name)',\n                'CREATE INDEX composite_idx ON test (id, name)',\n            ],\n            $this->platform->getCreateTableSQL($table)\n        );\n    }\n\n    public function testGeneratesCreateTableSQLWithForeignKeyConstraints(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('fk_1', 'integer');\n        $table->addColumn('fk_2', 'integer');\n        $table->setPrimaryKey(['id']);\n        $table->addForeignKeyConstraint('foreign_table', ['fk_1', 'fk_2'], ['pk_1', 'pk_2']);\n        $table->addForeignKeyConstraint(\n            'foreign_table2',\n            ['fk_1', 'fk_2'],\n            ['pk_1', 'pk_2'],\n            [],\n            'named_fk'\n        );\n\n        self::assertEquals(\n            [\n                'CREATE TABLE test (id INTEGER NOT NULL, fk_1 INTEGER NOT NULL, fk_2 INTEGER NOT NULL)',\n                'ALTER TABLE test ADD CONSTRAINT FK_D87F7E0C177612A38E7F4319 FOREIGN KEY (fk_1, fk_2)'\n                    . ' REFERENCES foreign_table (pk_1, pk_2)',\n                'ALTER TABLE test ADD CONSTRAINT named_fk FOREIGN KEY (fk_1, fk_2)'\n                    . ' REFERENCES foreign_table2 (pk_1, pk_2)',\n            ],\n            $this->platform->getCreateTableSQL($table, AbstractPlatform::CREATE_FOREIGNKEYS)\n        );\n    }\n\n    public function testGeneratesCreateTableSQLWithCheckConstraints(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('check_max', 'integer', ['platformOptions' => ['max' => 10]]);\n        $table->addColumn('check_min', 'integer', ['platformOptions' => ['min' => 10]]);\n        $table->setPrimaryKey(['id']);\n\n        self::assertEquals(\n            [\n                'CREATE TABLE test (id INTEGER NOT NULL, check_max INTEGER NOT NULL, '\n                    . 'check_min INTEGER NOT NULL, PRIMARY KEY(id), CHECK (check_max <= 10), CHECK (check_min >= 10))',\n            ],\n            $this->platform->getCreateTableSQL($table)\n        );\n    }\n\n    public function testGeneratesColumnTypesDeclarationSQL(): void\n    {\n        $fullColumnDef = [\n            'length' => 10,\n            'fixed' => true,\n            'unsigned' => true,\n            'autoincrement' => true,\n        ];\n\n        self::assertEquals('VARCHAR(255)', $this->platform->getVarcharTypeDeclarationSQL([]));\n        self::assertEquals('VARCHAR(10)', $this->platform->getVarcharTypeDeclarationSQL(['length' => 10]));\n        self::assertEquals('CHAR(254)', $this->platform->getVarcharTypeDeclarationSQL(['fixed' => true]));\n        self::assertEquals('CHAR(10)', $this->platform->getVarcharTypeDeclarationSQL($fullColumnDef));\n\n        self::assertEquals('SMALLINT', $this->platform->getSmallIntTypeDeclarationSQL([]));\n        self::assertEquals('SMALLINT', $this->platform->getSmallIntTypeDeclarationSQL(['unsigned' => true]));\n\n        self::assertEquals(\n            'SMALLINT GENERATED BY DEFAULT AS IDENTITY',\n            $this->platform->getSmallIntTypeDeclarationSQL($fullColumnDef)\n        );\n\n        self::assertEquals('INTEGER', $this->platform->getIntegerTypeDeclarationSQL([]));\n        self::assertEquals('INTEGER', $this->platform->getIntegerTypeDeclarationSQL(['unsigned' => true]));\n\n        self::assertEquals(\n            'INTEGER GENERATED BY DEFAULT AS IDENTITY',\n            $this->platform->getIntegerTypeDeclarationSQL($fullColumnDef)\n        );\n\n        self::assertEquals('BIGINT', $this->platform->getBigIntTypeDeclarationSQL([]));\n        self::assertEquals('BIGINT', $this->platform->getBigIntTypeDeclarationSQL(['unsigned' => true]));\n\n        self::assertEquals(\n            'BIGINT GENERATED BY DEFAULT AS IDENTITY',\n            $this->platform->getBigIntTypeDeclarationSQL($fullColumnDef)\n        );\n\n        self::assertEquals('BLOB(1M)', $this->platform->getBlobTypeDeclarationSQL($fullColumnDef));\n        self::assertEquals('SMALLINT', $this->platform->getBooleanTypeDeclarationSQL($fullColumnDef));\n        self::assertEquals('CLOB(1M)', $this->platform->getClobTypeDeclarationSQL($fullColumnDef));\n        self::assertEquals('DATE', $this->platform->getDateTypeDeclarationSQL($fullColumnDef));\n\n        self::assertEquals(\n            'TIMESTAMP(0) WITH DEFAULT',\n            $this->platform->getDateTimeTypeDeclarationSQL(['version' => true])\n        );\n\n        self::assertEquals('TIMESTAMP(0)', $this->platform->getDateTimeTypeDeclarationSQL($fullColumnDef));\n        self::assertEquals('TIME', $this->platform->getTimeTypeDeclarationSQL($fullColumnDef));\n    }\n\n    public function testInitializesDoctrineTypeMappings(): void\n    {\n        $this->platform->initializeDoctrineTypeMappings();\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('smallint'));\n        self::assertSame('smallint', $this->platform->getDoctrineTypeMapping('smallint'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('bigint'));\n        self::assertSame('bigint', $this->platform->getDoctrineTypeMapping('bigint'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('integer'));\n        self::assertSame('integer', $this->platform->getDoctrineTypeMapping('integer'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('time'));\n        self::assertSame('time', $this->platform->getDoctrineTypeMapping('time'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('date'));\n        self::assertSame('date', $this->platform->getDoctrineTypeMapping('date'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('varchar'));\n        self::assertSame('string', $this->platform->getDoctrineTypeMapping('varchar'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('character'));\n        self::assertSame('string', $this->platform->getDoctrineTypeMapping('character'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('clob'));\n        self::assertSame('text', $this->platform->getDoctrineTypeMapping('clob'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('blob'));\n        self::assertSame('blob', $this->platform->getDoctrineTypeMapping('blob'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('decimal'));\n        self::assertSame('decimal', $this->platform->getDoctrineTypeMapping('decimal'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('double'));\n        self::assertSame('float', $this->platform->getDoctrineTypeMapping('double'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('real'));\n        self::assertSame('float', $this->platform->getDoctrineTypeMapping('real'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('timestamp'));\n        self::assertSame('datetime', $this->platform->getDoctrineTypeMapping('timestamp'));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getIsCommentedDoctrineType(): array\n    {\n        $data = parent::getIsCommentedDoctrineType();\n\n        $data[Types::BOOLEAN] = [Type::getType(Types::BOOLEAN), true];\n\n        return $data;\n    }\n\n    public function testGeneratesDDLSnippets(): void\n    {\n        self::assertEquals('CREATE DATABASE foobar', $this->platform->getCreateDatabaseSQL('foobar'));\n        self::assertEquals('DROP DATABASE foobar', $this->platform->getDropDatabaseSQL('foobar'));\n        self::assertEquals('DECLARE GLOBAL TEMPORARY TABLE', $this->platform->getCreateTemporaryTableSnippetSQL());\n        self::assertEquals('TRUNCATE foobar IMMEDIATE', $this->platform->getTruncateTableSQL('foobar'));\n        self::assertEquals('TRUNCATE foobar IMMEDIATE', $this->platform->getTruncateTableSQL('foobar'), true);\n\n        $viewSql = 'SELECT * FROM footable';\n\n        self::assertEquals(\n            'CREATE VIEW fooview AS ' . $viewSql,\n            $this->platform->getCreateViewSQL('fooview', $viewSql)\n        );\n\n        self::assertEquals('DROP VIEW fooview', $this->platform->getDropViewSQL('fooview'));\n    }\n\n    public function testGeneratesCreateUnnamedPrimaryKeySQL(): void\n    {\n        self::assertEquals(\n            'ALTER TABLE foo ADD PRIMARY KEY (a, b)',\n            $this->platform->getCreatePrimaryKeySQL(\n                new Index('any_pk_name', ['a', 'b'], true, true),\n                'foo'\n            )\n        );\n    }\n\n    public function testGeneratesSQLSnippets(): void\n    {\n        self::assertEquals('CURRENT DATE', $this->platform->getCurrentDateSQL());\n        self::assertEquals('CURRENT TIME', $this->platform->getCurrentTimeSQL());\n        self::assertEquals('CURRENT TIMESTAMP', $this->platform->getCurrentTimestampSQL());\n        self::assertEquals(\"'1987/05/02' + 4 DAY\", $this->platform->getDateAddDaysExpression(\"'1987/05/02'\", 4));\n        self::assertEquals(\"'1987/05/02' + 12 HOUR\", $this->platform->getDateAddHourExpression(\"'1987/05/02'\", 12));\n        self::assertEquals(\"'1987/05/02' + 2 MINUTE\", $this->platform->getDateAddMinutesExpression(\"'1987/05/02'\", 2));\n        self::assertEquals(\"'1987/05/02' + 102 MONTH\", $this->platform->getDateAddMonthExpression(\"'1987/05/02'\", 102));\n        self::assertEquals(\"'1987/05/02' + 15 MONTH\", $this->platform->getDateAddQuartersExpression(\"'1987/05/02'\", 5));\n        self::assertEquals(\"'1987/05/02' + 1 SECOND\", $this->platform->getDateAddSecondsExpression(\"'1987/05/02'\", 1));\n        self::assertEquals(\"'1987/05/02' + 21 DAY\", $this->platform->getDateAddWeeksExpression(\"'1987/05/02'\", 3));\n        self::assertEquals(\"'1987/05/02' + 10 YEAR\", $this->platform->getDateAddYearsExpression(\"'1987/05/02'\", 10));\n\n        self::assertEquals(\n            \"DAYS('1987/05/02') - DAYS('1987/04/01')\",\n            $this->platform->getDateDiffExpression(\"'1987/05/02'\", \"'1987/04/01'\")\n        );\n\n        self::assertEquals(\"'1987/05/02' - 4 DAY\", $this->platform->getDateSubDaysExpression(\"'1987/05/02'\", 4));\n        self::assertEquals(\"'1987/05/02' - 12 HOUR\", $this->platform->getDateSubHourExpression(\"'1987/05/02'\", 12));\n        self::assertEquals(\"'1987/05/02' - 2 MINUTE\", $this->platform->getDateSubMinutesExpression(\"'1987/05/02'\", 2));\n        self::assertEquals(\"'1987/05/02' - 102 MONTH\", $this->platform->getDateSubMonthExpression(\"'1987/05/02'\", 102));\n        self::assertEquals(\"'1987/05/02' - 15 MONTH\", $this->platform->getDateSubQuartersExpression(\"'1987/05/02'\", 5));\n        self::assertEquals(\"'1987/05/02' - 1 SECOND\", $this->platform->getDateSubSecondsExpression(\"'1987/05/02'\", 1));\n        self::assertEquals(\"'1987/05/02' - 21 DAY\", $this->platform->getDateSubWeeksExpression(\"'1987/05/02'\", 3));\n        self::assertEquals(\"'1987/05/02' - 10 YEAR\", $this->platform->getDateSubYearsExpression(\"'1987/05/02'\", 10));\n        self::assertEquals(' WITH RR USE AND KEEP UPDATE LOCKS', $this->platform->getForUpdateSQL());\n\n        self::assertEquals(\n            'LOCATE(substring_column, string_column)',\n            $this->platform->getLocateExpression('string_column', 'substring_column')\n        );\n\n        self::assertEquals(\n            'LOCATE(substring_column, string_column)',\n            $this->platform->getLocateExpression('string_column', 'substring_column')\n        );\n\n        self::assertEquals(\n            'LOCATE(substring_column, string_column, 1)',\n            $this->platform->getLocateExpression('string_column', 'substring_column', 1)\n        );\n\n        self::assertEquals('SUBSTR(column, 5)', $this->platform->getSubstringExpression('column', 5));\n        self::assertEquals('SUBSTR(column, 5, 2)', $this->platform->getSubstringExpression('column', 5, 2));\n    }\n\n    public function testModifiesLimitQuery(): void\n    {\n        self::assertEquals(\n            'SELECT * FROM user',\n            $this->platform->modifyLimitQuery('SELECT * FROM user', null, 0)\n        );\n\n        self::assertEquals(\n            'SELECT db22.* FROM ('\n                . 'SELECT db21.*, ROW_NUMBER() OVER() AS DC_ROWNUM FROM (SELECT * FROM user) db21'\n                . ') db22 WHERE db22.DC_ROWNUM <= 10',\n            $this->platform->modifyLimitQuery('SELECT * FROM user', 10)\n        );\n\n        self::assertEquals(\n            'SELECT db22.* FROM (SELECT db21.*, ROW_NUMBER() OVER() AS DC_ROWNUM FROM ('\n                . 'SELECT * FROM user) db21'\n                . ') db22 WHERE db22.DC_ROWNUM >= 6 AND db22.DC_ROWNUM <= 15',\n            $this->platform->modifyLimitQuery('SELECT * FROM user', 10, 5)\n        );\n        self::assertEquals(\n            'SELECT db22.* FROM ('\n                . 'SELECT db21.*, ROW_NUMBER() OVER() AS DC_ROWNUM FROM (SELECT * FROM user) db21'\n                . ') db22 WHERE db22.DC_ROWNUM >= 6 AND db22.DC_ROWNUM <= 5',\n            $this->platform->modifyLimitQuery('SELECT * FROM user', 0, 5)\n        );\n    }\n\n    public function testPrefersIdentityColumns(): void\n    {\n        self::assertTrue($this->platform->prefersIdentityColumns());\n    }\n\n    public function testSupportsIdentityColumns(): void\n    {\n        self::assertTrue($this->platform->supportsIdentityColumns());\n    }\n\n    public function testDoesNotSupportSavePoints(): void\n    {\n        self::assertFalse($this->platform->supportsSavepoints());\n    }\n\n    public function testDoesNotSupportReleasePoints(): void\n    {\n        self::assertFalse($this->platform->supportsReleaseSavepoints());\n    }\n\n    public function testDoesNotSupportCreateDropDatabase(): void\n    {\n        self::assertFalse($this->platform->supportsCreateDropDatabase());\n    }\n\n    protected function getBinaryDefaultLength(): int\n    {\n        return 1;\n    }\n\n    protected function getBinaryMaxLength(): int\n    {\n        return 32704;\n    }\n\n    public function testReturnsBinaryTypeDeclarationSQL(): void\n    {\n        self::assertSame('VARCHAR(1) FOR BIT DATA', $this->platform->getBinaryTypeDeclarationSQL([]));\n        self::assertSame('VARCHAR(255) FOR BIT DATA', $this->platform->getBinaryTypeDeclarationSQL(['length' => 0]));\n        self::assertSame(\n            'VARCHAR(32704) FOR BIT DATA',\n            $this->platform->getBinaryTypeDeclarationSQL(['length' => 32704])\n        );\n\n        self::assertSame('CHAR(1) FOR BIT DATA', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true]));\n        self::assertSame('CHAR(254) FOR BIT DATA', $this->platform->getBinaryTypeDeclarationSQL([\n            'fixed' => true,\n            'length' => 0,\n        ]));\n    }\n\n    public function testReturnsBinaryTypeLongerThanMaxDeclarationSQL(): void\n    {\n        self::assertSame('BLOB(1M)', $this->platform->getBinaryTypeDeclarationSQL(['length' => 32705]));\n        self::assertSame('BLOB(1M)', $this->platform->getBinaryTypeDeclarationSQL([\n            'fixed' => true,\n            'length' => 32705,\n        ]));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getAlterTableRenameIndexSQL(): array\n    {\n        return ['RENAME INDEX idx_foo TO idx_bar'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedAlterTableRenameIndexSQL(): array\n    {\n        return [\n            'RENAME INDEX \"create\" TO \"select\"',\n            'RENAME INDEX \"foo\" TO \"bar\"',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotedAlterTableRenameColumnSQL(): array\n    {\n        return ['ALTER TABLE mytable ' .\n            'RENAME COLUMN unquoted1 TO unquoted ' .\n            'RENAME COLUMN unquoted2 TO \"where\" ' .\n            'RENAME COLUMN unquoted3 TO \"foo\" ' .\n            'RENAME COLUMN \"create\" TO reserved_keyword ' .\n            'RENAME COLUMN \"table\" TO \"from\" ' .\n            'RENAME COLUMN \"select\" TO \"bar\" ' .\n            'RENAME COLUMN quoted1 TO quoted ' .\n            'RENAME COLUMN quoted2 TO \"and\" ' .\n            'RENAME COLUMN quoted3 TO \"baz\"',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotedAlterTableChangeColumnLengthSQL(): array\n    {\n        self::markTestIncomplete('Not implemented yet');\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return ['RENAME INDEX myschema.idx_foo TO idx_bar'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return [\n            'RENAME INDEX \"schema\".\"create\" TO \"select\"',\n            'RENAME INDEX \"schema\".\"foo\" TO \"bar\"',\n        ];\n    }\n\n    public function testReturnsGuidTypeDeclarationSQL(): void\n    {\n        self::assertSame('CHAR(36)', $this->platform->getGuidTypeDeclarationSQL([]));\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAlterTableRenameColumnSQL(): array\n    {\n        return ['ALTER TABLE foo RENAME COLUMN bar TO baz'];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotesTableIdentifiersInAlterTableSQL(): array\n    {\n        return [\n            'ALTER TABLE \"foo\" DROP FOREIGN KEY fk1',\n            'ALTER TABLE \"foo\" DROP FOREIGN KEY fk2',\n            'ALTER TABLE \"foo\" ' .\n            'ADD COLUMN bloo INTEGER NOT NULL WITH DEFAULT ' .\n            'DROP COLUMN baz ' .\n            'ALTER COLUMN bar DROP NOT NULL ' .\n            'RENAME COLUMN id TO war',\n            'CALL SYSPROC.ADMIN_CMD (\\'REORG TABLE \"foo\"\\')',\n            'RENAME TABLE \"foo\" TO \"table\"',\n            'ALTER TABLE \"table\" ADD CONSTRAINT fk_add FOREIGN KEY (fk3) REFERENCES fk_table (id)',\n            'ALTER TABLE \"table\" ADD CONSTRAINT fk2 FOREIGN KEY (fk2) REFERENCES fk_table2 (id)',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getCommentOnColumnSQL(): array\n    {\n        return [\n            'COMMENT ON COLUMN foo.bar IS \\'comment\\'',\n            'COMMENT ON COLUMN \"Foo\".\"BAR\" IS \\'comment\\'',\n            'COMMENT ON COLUMN \"select\".\"from\" IS \\'comment\\'',\n        ];\n    }\n\n    /**\n     * @dataProvider getGeneratesAlterColumnSQL\n     */\n    public function testGeneratesAlterColumnSQL(\n        string $changedProperty,\n        Column $column,\n        ?string $expectedSQLClause = null\n    ): void {\n        $tableDiff                        = new TableDiff('foo');\n        $tableDiff->fromTable             = new Table('foo');\n        $tableDiff->changedColumns['bar'] = new ColumnDiff('bar', $column, [$changedProperty]);\n\n        $expectedSQL = [];\n\n        if ($expectedSQLClause !== null) {\n            $expectedSQL[] = 'ALTER TABLE foo ALTER COLUMN bar ' . $expectedSQLClause;\n        }\n\n        $expectedSQL[] = \"CALL SYSPROC.ADMIN_CMD ('REORG TABLE foo')\";\n\n        self::assertSame($expectedSQL, $this->platform->getAlterTableSQL($tableDiff));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesAlterColumnSQL(): iterable\n    {\n        return [\n            [\n                'columnDefinition',\n                new Column('bar', Type::getType('decimal'), ['columnDefinition' => 'MONEY NOT NULL']),\n                'MONEY NOT NULL',\n            ],\n            [\n                'type',\n                new Column('bar', Type::getType('integer')),\n                'SET DATA TYPE INTEGER',\n            ],\n            [\n                'length',\n                new Column('bar', Type::getType('string'), ['length' => 100]),\n                'SET DATA TYPE VARCHAR(100)',\n            ],\n            [\n                'precision',\n                new Column('bar', Type::getType('decimal'), ['precision' => 10, 'scale' => 2]),\n                'SET DATA TYPE NUMERIC(10, 2)',\n            ],\n            [\n                'scale',\n                new Column('bar', Type::getType('decimal'), ['precision' => 5, 'scale' => 4]),\n                'SET DATA TYPE NUMERIC(5, 4)',\n            ],\n            [\n                'fixed',\n                new Column('bar', Type::getType('string'), ['length' => 20, 'fixed' => true]),\n                'SET DATA TYPE CHAR(20)',\n            ],\n            [\n                'notnull',\n                new Column('bar', Type::getType('string'), ['notnull' => true]),\n                'SET NOT NULL',\n            ],\n            [\n                'notnull',\n                new Column('bar', Type::getType('string'), ['notnull' => false]),\n                'DROP NOT NULL',\n            ],\n            [\n                'default',\n                new Column('bar', Type::getType('string'), ['default' => 'foo']),\n                \"SET DEFAULT 'foo'\",\n            ],\n            [\n                'default',\n                new Column('bar', Type::getType('integer'), ['autoincrement' => true, 'default' => 666]),\n                null,\n            ],\n            [\n                'default',\n                new Column('bar', Type::getType('string')),\n                'DROP DEFAULT',\n            ],\n        ];\n    }\n\n    protected function getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): string\n    {\n        return 'CONSTRAINT \"select\" UNIQUE (foo)';\n    }\n\n    protected function getQuotesReservedKeywordInIndexDeclarationSQL(): string\n    {\n        return ''; // not supported by this platform\n    }\n\n    protected function getQuotesReservedKeywordInTruncateTableSQL(): string\n    {\n        return 'TRUNCATE \"select\" IMMEDIATE';\n    }\n\n    protected function supportsInlineIndexDeclaration(): bool\n    {\n        return false;\n    }\n\n    protected function supportsCommentOnStatement(): bool\n    {\n        return true;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getAlterStringToFixedStringSQL(): array\n    {\n        return [\n            'ALTER TABLE mytable ALTER COLUMN name SET DATA TYPE CHAR(2)',\n            'CALL SYSPROC.ADMIN_CMD (\\'REORG TABLE mytable\\')',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): array\n    {\n        return ['RENAME INDEX idx_foo TO idx_foo_renamed'];\n    }\n\n    public function testQuotesTableNameInListTableColumnsSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableColumnsSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableIndexesSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableIndexesSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableForeignKeysSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableForeignKeysSQL(\"Foo'Bar\\\\\")\n        );\n    }\n}\n", "<?php\n\nnamespace Doctrine\\DBAL\\Tests\\Platforms;\n\nuse Doctrine\\DBAL\\Exception;\nuse Doctrine\\DBAL\\Platforms\\AbstractPlatform;\nuse Doctrine\\DBAL\\Platforms\\OraclePlatform;\nuse Doctrine\\DBAL\\Schema\\Column;\nuse Doctrine\\DBAL\\Schema\\ColumnDiff;\nuse Doctrine\\DBAL\\Schema\\Comparator;\nuse Doctrine\\DBAL\\Schema\\ForeignKeyConstraint;\nuse Doctrine\\DBAL\\Schema\\Sequence;\nuse Doctrine\\DBAL\\Schema\\Table;\nuse Doctrine\\DBAL\\Schema\\TableDiff;\nuse Doctrine\\DBAL\\TransactionIsolationLevel;\nuse Doctrine\\DBAL\\Types\\Type;\n\nuse function sprintf;\nuse function strtoupper;\nuse function uniqid;\n\n/**\n * @extends AbstractPlatformTestCase<OraclePlatform>\n */\nclass OraclePlatformTest extends AbstractPlatformTestCase\n{\n    /**\n     * @return mixed[][]\n     */\n    public static function dataValidIdentifiers(): iterable\n    {\n        return [\n            ['a'],\n            ['foo'],\n            ['Foo'],\n            ['Foo123'],\n            ['Foo#bar_baz$'],\n            ['\"a\"'],\n            ['\"1\"'],\n            ['\"foo_bar\"'],\n            ['\"@$%&!\"'],\n        ];\n    }\n\n    /**\n     * @dataProvider dataValidIdentifiers\n     */\n    public function testValidIdentifiers(string $identifier): void\n    {\n        $platform = $this->createPlatform();\n        $platform->assertValidIdentifier($identifier);\n\n        $this->expectNotToPerformAssertions();\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function dataInvalidIdentifiers(): iterable\n    {\n        return [\n            ['1'],\n            ['abc&'],\n            ['abc-def'],\n            ['\"'],\n            ['\"foo\"bar\"'],\n        ];\n    }\n\n    /**\n     * @dataProvider dataInvalidIdentifiers\n     */\n    public function testInvalidIdentifiers(string $identifier): void\n    {\n        $this->expectException(Exception::class);\n\n        $platform = $this->createPlatform();\n        $platform->assertValidIdentifier($identifier);\n    }\n\n    public function createPlatform(): AbstractPlatform\n    {\n        return new OraclePlatform();\n    }\n\n    public function getGenerateTableSql(): string\n    {\n        return 'CREATE TABLE test (id NUMBER(10) NOT NULL, test VARCHAR2(255) DEFAULT NULL NULL, PRIMARY KEY(id))';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getGenerateTableWithMultiColumnUniqueIndexSql(): array\n    {\n        return [\n            'CREATE TABLE test (foo VARCHAR2(255) DEFAULT NULL NULL, bar VARCHAR2(255) DEFAULT NULL NULL)',\n            'CREATE UNIQUE INDEX UNIQ_D87F7E0C8C73652176FF8CAA ON test (foo, bar)',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getGenerateAlterTableSql(): array\n    {\n        return [\n            'ALTER TABLE mytable ADD (quota NUMBER(10) DEFAULT NULL NULL)',\n            \"ALTER TABLE mytable MODIFY (baz VARCHAR2(255) DEFAULT 'def' NOT NULL, \"\n                . \"bloo NUMBER(1) DEFAULT '0' NOT NULL)\",\n            'ALTER TABLE mytable DROP (foo)',\n            'ALTER TABLE mytable RENAME TO userlist',\n        ];\n    }\n\n    public function testRLike(): void\n    {\n        $this->expectException(Exception::class);\n\n        self::assertEquals('RLIKE', $this->platform->getRegexpExpression());\n    }\n\n    public function testGeneratesSqlSnippets(): void\n    {\n        self::assertEquals('\"', $this->platform->getIdentifierQuoteCharacter());\n        self::assertEquals(\n            'column1 || column2 || column3',\n            $this->platform->getConcatExpression('column1', 'column2', 'column3')\n        );\n    }\n\n    public function testGeneratesTransactionsCommands(): void\n    {\n        self::assertEquals(\n            'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED',\n            $this->platform->getSetTransactionIsolationSQL(TransactionIsolationLevel::READ_UNCOMMITTED)\n        );\n        self::assertEquals(\n            'SET TRANSACTION ISOLATION LEVEL READ COMMITTED',\n            $this->platform->getSetTransactionIsolationSQL(TransactionIsolationLevel::READ_COMMITTED)\n        );\n        self::assertEquals(\n            'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE',\n            $this->platform->getSetTransactionIsolationSQL(TransactionIsolationLevel::REPEATABLE_READ)\n        );\n        self::assertEquals(\n            'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE',\n            $this->platform->getSetTransactionIsolationSQL(TransactionIsolationLevel::SERIALIZABLE)\n        );\n    }\n\n    public function testCreateDatabaseThrowsException(): void\n    {\n        $this->expectException(Exception::class);\n\n        self::assertEquals('CREATE DATABASE foobar', $this->platform->getCreateDatabaseSQL('foobar'));\n    }\n\n    public function testDropDatabaseThrowsException(): void\n    {\n        self::assertEquals('DROP USER foobar CASCADE', $this->platform->getDropDatabaseSQL('foobar'));\n    }\n\n    public function testDropTable(): void\n    {\n        self::assertEquals('DROP TABLE foobar', $this->platform->getDropTableSQL('foobar'));\n    }\n\n    public function testGeneratesTypeDeclarationForIntegers(): void\n    {\n        self::assertEquals(\n            'NUMBER(10)',\n            $this->platform->getIntegerTypeDeclarationSQL([])\n        );\n        self::assertEquals(\n            'NUMBER(10)',\n            $this->platform->getIntegerTypeDeclarationSQL(['autoincrement' => true])\n        );\n        self::assertEquals(\n            'NUMBER(10)',\n            $this->platform->getIntegerTypeDeclarationSQL(\n                ['autoincrement' => true, 'primary' => true]\n            )\n        );\n    }\n\n    public function testGeneratesTypeDeclarationsForStrings(): void\n    {\n        self::assertEquals(\n            'CHAR(10)',\n            $this->platform->getVarcharTypeDeclarationSQL(\n                ['length' => 10, 'fixed' => true]\n            )\n        );\n        self::assertEquals(\n            'VARCHAR2(50)',\n            $this->platform->getVarcharTypeDeclarationSQL(['length' => 50])\n        );\n        self::assertEquals(\n            'VARCHAR2(255)',\n            $this->platform->getVarcharTypeDeclarationSQL([])\n        );\n    }\n\n    public function testPrefersIdentityColumns(): void\n    {\n        self::assertFalse($this->platform->prefersIdentityColumns());\n    }\n\n    public function testSupportsIdentityColumns(): void\n    {\n        self::assertFalse($this->platform->supportsIdentityColumns());\n    }\n\n    public function testSupportsSavePoints(): void\n    {\n        self::assertTrue($this->platform->supportsSavepoints());\n    }\n\n    protected function supportsCommentOnStatement(): bool\n    {\n        return true;\n    }\n\n    public function getGenerateIndexSql(): string\n    {\n        return 'CREATE INDEX my_idx ON mytable (user_name, last_login)';\n    }\n\n    public function getGenerateUniqueIndexSql(): string\n    {\n        return 'CREATE UNIQUE INDEX index_name ON test (test, test2)';\n    }\n\n    protected function getGenerateForeignKeySql(): string\n    {\n        return 'ALTER TABLE test ADD FOREIGN KEY (fk_name_id) REFERENCES other_table (id)';\n    }\n\n    /**\n     * @param mixed[] $options\n     *\n     * @dataProvider getGeneratesAdvancedForeignKeyOptionsSQLData\n     */\n    public function testGeneratesAdvancedForeignKeyOptionsSQL(array $options, string $expectedSql): void\n    {\n        $foreignKey = new ForeignKeyConstraint(['foo'], 'foreign_table', ['bar'], null, $options);\n\n        self::assertSame($expectedSql, $this->platform->getAdvancedForeignKeyOptionsSQL($foreignKey));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesAdvancedForeignKeyOptionsSQLData(): iterable\n    {\n        return [\n            [[], ''],\n            [['onUpdate' => 'CASCADE'], ''],\n            [['onDelete' => 'CASCADE'], ' ON DELETE CASCADE'],\n            [['onDelete' => 'NO ACTION'], ''],\n            [['onDelete' => 'RESTRICT'], ''],\n            [['onUpdate' => 'SET NULL', 'onDelete' => 'SET NULL'], ' ON DELETE SET NULL'],\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public static function getReturnsForeignKeyReferentialActionSQL(): iterable\n    {\n        return [\n            ['CASCADE', 'CASCADE'],\n            ['SET NULL', 'SET NULL'],\n            ['NO ACTION', ''],\n            ['RESTRICT', ''],\n            ['CaScAdE', 'CASCADE'],\n        ];\n    }\n\n    public function testModifyLimitQuery(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10, 0);\n        self::assertEquals('SELECT a.* FROM (SELECT * FROM user) a WHERE ROWNUM <= 10', $sql);\n    }\n\n    public function testModifyLimitQueryWithEmptyOffset(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10);\n        self::assertEquals('SELECT a.* FROM (SELECT * FROM user) a WHERE ROWNUM <= 10', $sql);\n    }\n\n    public function testModifyLimitQueryWithNonEmptyOffset(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10, 10);\n\n        self::assertEquals(\n            'SELECT * FROM ('\n                . 'SELECT a.*, ROWNUM AS doctrine_rownum FROM (SELECT * FROM user) a WHERE ROWNUM <= 20'\n                . ') WHERE doctrine_rownum >= 11',\n            $sql\n        );\n    }\n\n    public function testModifyLimitQueryWithEmptyLimit(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', null, 10);\n\n        self::assertEquals(\n            'SELECT * FROM ('\n                . 'SELECT a.*, ROWNUM AS doctrine_rownum FROM (SELECT * FROM user) a'\n                . ') WHERE doctrine_rownum >= 11',\n            $sql\n        );\n    }\n\n    public function testModifyLimitQueryWithAscOrderBy(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user ORDER BY username ASC', 10);\n        self::assertEquals('SELECT a.* FROM (SELECT * FROM user ORDER BY username ASC) a WHERE ROWNUM <= 10', $sql);\n    }\n\n    public function testModifyLimitQueryWithDescOrderBy(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user ORDER BY username DESC', 10);\n        self::assertEquals('SELECT a.* FROM (SELECT * FROM user ORDER BY username DESC) a WHERE ROWNUM <= 10', $sql);\n    }\n\n    public function testGenerateTableWithAutoincrement(): void\n    {\n        $columnName = strtoupper('id' . uniqid());\n        $tableName  = strtoupper('table' . uniqid());\n        $table      = new Table($tableName);\n        $column     = $table->addColumn($columnName, 'integer');\n        $column->setAutoincrement(true);\n\n        self::assertSame([\n            sprintf('CREATE TABLE %s (%s NUMBER(10) NOT NULL)', $tableName, $columnName),\n            sprintf(\n                <<<'SQL'\nDECLARE\n  constraints_Count NUMBER;\nBEGIN\n  SELECT COUNT(CONSTRAINT_NAME) INTO constraints_Count\n    FROM USER_CONSTRAINTS\n   WHERE TABLE_NAME = '%s'\n     AND CONSTRAINT_TYPE = 'P';\n  IF constraints_Count = 0 OR constraints_Count = '' THEN\n    EXECUTE IMMEDIATE 'ALTER TABLE %s ADD CONSTRAINT %s_AI_PK PRIMARY KEY (%s)';\n  END IF;\nEND;\nSQL\n                ,\n                $tableName,\n                $tableName,\n                $tableName,\n                $columnName\n            ),\n            sprintf('CREATE SEQUENCE %s_SEQ START WITH 1 MINVALUE 1 INCREMENT BY 1', $tableName),\n            sprintf(\n                <<<SQL\nCREATE TRIGGER %s_AI_PK\n   BEFORE INSERT\n   ON %s\n   FOR EACH ROW\nDECLARE\n   last_Sequence NUMBER;\n   last_InsertID NUMBER;\nBEGIN\n   IF (:NEW.%s IS NULL OR :NEW.%s = 0) THEN\n      SELECT %s_SEQ.NEXTVAL INTO :NEW.%s FROM DUAL;\n   ELSE\n      SELECT NVL(Last_Number, 0) INTO last_Sequence\n        FROM User_Sequences\n       WHERE Sequence_Name = '%s_SEQ';\n      SELECT :NEW.%s INTO last_InsertID FROM DUAL;\n      WHILE (last_InsertID > last_Sequence) LOOP\n         SELECT %s_SEQ.NEXTVAL INTO last_Sequence FROM DUAL;\n      END LOOP;\n      SELECT %s_SEQ.NEXTVAL INTO last_Sequence FROM DUAL;\n   END IF;\nEND;\nSQL\n                ,\n                $tableName,\n                $tableName,\n                $columnName,\n                $columnName,\n                $tableName,\n                $columnName,\n                $tableName,\n                $columnName,\n                $tableName,\n                $tableName\n            ),\n        ], $this->platform->getCreateTableSQL($table));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getCreateTableColumnCommentsSQL(): array\n    {\n        return [\n            'CREATE TABLE test (id NUMBER(10) NOT NULL, PRIMARY KEY(id))',\n            \"COMMENT ON COLUMN test.id IS 'This is a comment'\",\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getCreateTableColumnTypeCommentsSQL(): array\n    {\n        return [\n            'CREATE TABLE test (id NUMBER(10) NOT NULL, data CLOB NOT NULL, PRIMARY KEY(id))',\n            \"COMMENT ON COLUMN test.data IS '(DC2Type:array)'\",\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getAlterTableColumnCommentsSQL(): array\n    {\n        return [\n            'ALTER TABLE mytable ADD (quota NUMBER(10) NOT NULL)',\n            \"COMMENT ON COLUMN mytable.quota IS 'A comment'\",\n            \"COMMENT ON COLUMN mytable.foo IS ''\",\n            \"COMMENT ON COLUMN mytable.baz IS 'B comment'\",\n        ];\n    }\n\n    public function getBitAndComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return 'BITAND(' . $value1 . ', ' . $value2 . ')';\n    }\n\n    public function getBitOrComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return '(' . $value1 . '-' .\n        $this->getBitAndComparisonExpressionSql($value1, $value2)\n        . '+' . $value2 . ')';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInPrimaryKeySQL(): array\n    {\n        return ['CREATE TABLE \"quoted\" (\"create\" VARCHAR2(255) NOT NULL, PRIMARY KEY(\"create\"))'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInIndexSQL(): array\n    {\n        return [\n            'CREATE TABLE \"quoted\" (\"create\" VARCHAR2(255) NOT NULL)',\n            'CREATE INDEX IDX_22660D028FD6E0FB ON \"quoted\" (\"create\")',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedNameInIndexSQL(): array\n    {\n        return [\n            'CREATE TABLE test (column1 VARCHAR2(255) NOT NULL)',\n            'CREATE INDEX \"key\" ON test (column1)',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInForeignKeySQL(): array\n    {\n        return [\n            'CREATE TABLE \"quoted\" (\"create\" VARCHAR2(255) NOT NULL, foo VARCHAR2(255) NOT NULL, '\n                . '\"bar\" VARCHAR2(255) NOT NULL)',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_RESERVED_KEYWORD FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES foreign (\"create\", bar, \"foo-bar\")',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_NON_RESERVED_KEYWORD FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES foo (\"create\", bar, \"foo-bar\")',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_INTENDED_QUOTATION FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES \"foo-bar\" (\"create\", bar, \"foo-bar\")',\n        ];\n    }\n\n    public function testAlterTableNotNULL(): void\n    {\n        $tableDiff                          = new TableDiff('mytable');\n        $tableDiff->changedColumns['foo']   = new ColumnDiff(\n            'foo',\n            new Column(\n                'foo',\n                Type::getType('string'),\n                ['default' => 'bla', 'notnull' => true]\n            ),\n            ['type']\n        );\n        $tableDiff->changedColumns['bar']   = new ColumnDiff(\n            'bar',\n            new Column(\n                'baz',\n                Type::getType('string'),\n                ['default' => 'bla', 'notnull' => true]\n            ),\n            ['type', 'notnull']\n        );\n        $tableDiff->changedColumns['metar'] = new ColumnDiff(\n            'metar',\n            new Column(\n                'metar',\n                Type::getType('string'),\n                ['length' => 2000, 'notnull' => false]\n            ),\n            ['notnull']\n        );\n\n        $expectedSql = [\n            \"ALTER TABLE mytable MODIFY (foo VARCHAR2(255) DEFAULT 'bla', baz VARCHAR2(255) DEFAULT 'bla' NOT NULL, \"\n                . 'metar VARCHAR2(2000) DEFAULT NULL NULL)',\n        ];\n\n        self::assertEquals($expectedSql, $this->platform->getAlterTableSQL($tableDiff));\n    }\n\n    public function testInitializesDoctrineTypeMappings(): void\n    {\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('long raw'));\n        self::assertSame('blob', $this->platform->getDoctrineTypeMapping('long raw'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('raw'));\n        self::assertSame('binary', $this->platform->getDoctrineTypeMapping('raw'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('date'));\n        self::assertSame('date', $this->platform->getDoctrineTypeMapping('date'));\n    }\n\n    protected function getBinaryMaxLength(): int\n    {\n        return 2000;\n    }\n\n    public function testReturnsBinaryTypeDeclarationSQL(): void\n    {\n        self::assertSame('RAW(255)', $this->platform->getBinaryTypeDeclarationSQL([]));\n        self::assertSame('RAW(2000)', $this->platform->getBinaryTypeDeclarationSQL(['length' => 0]));\n        self::assertSame('RAW(2000)', $this->platform->getBinaryTypeDeclarationSQL(['length' => 2000]));\n\n        self::assertSame('RAW(255)', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true]));\n        self::assertSame('RAW(2000)', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true, 'length' => 0]));\n\n        self::assertSame(\n            'RAW(2000)',\n            $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true, 'length' => 2000])\n        );\n    }\n\n    public function testReturnsBinaryTypeLongerThanMaxDeclarationSQL(): void\n    {\n        self::assertSame('BLOB', $this->platform->getBinaryTypeDeclarationSQL(['length' => 2001]));\n        self::assertSame('BLOB', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true, 'length' => 2001]));\n    }\n\n    public function testDoesNotPropagateUnnecessaryTableAlterationOnBinaryType(): void\n    {\n        $table1 = new Table('mytable');\n        $table1->addColumn('column_varbinary', 'binary');\n        $table1->addColumn('column_binary', 'binary', ['fixed' => true]);\n\n        $table2 = new Table('mytable');\n        $table2->addColumn('column_varbinary', 'binary', ['fixed' => true]);\n        $table2->addColumn('column_binary', 'binary');\n\n        // VARBINARY -> BINARY\n        // BINARY    -> VARBINARY\n        $diff = (new Comparator())->diffTable($table1, $table2);\n        self::assertNotFalse($diff);\n        self::assertEmpty($this->platform->getAlterTableSQL($diff));\n    }\n\n    public function testUsesSequenceEmulatedIdentityColumns(): void\n    {\n        self::assertTrue($this->platform->usesSequenceEmulatedIdentityColumns());\n    }\n\n    public function testReturnsIdentitySequenceName(): void\n    {\n        self::assertSame('MYTABLE_SEQ', $this->platform->getIdentitySequenceName('mytable', 'mycolumn'));\n        self::assertSame('\"mytable_SEQ\"', $this->platform->getIdentitySequenceName('\"mytable\"', 'mycolumn'));\n        self::assertSame('MYTABLE_SEQ', $this->platform->getIdentitySequenceName('mytable', '\"mycolumn\"'));\n        self::assertSame('\"mytable_SEQ\"', $this->platform->getIdentitySequenceName('\"mytable\"', '\"mycolumn\"'));\n    }\n\n    /**\n     * @dataProvider dataCreateSequenceWithCache\n     */\n    public function testCreateSequenceWithCache(int $cacheSize, string $expectedSql): void\n    {\n        $sequence = new Sequence('foo', 1, 1, $cacheSize);\n        self::assertStringContainsString($expectedSql, $this->platform->getCreateSequenceSQL($sequence));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function dataCreateSequenceWithCache(): iterable\n    {\n        return [\n            [1, 'NOCACHE'],\n            [0, 'NOCACHE'],\n            [3, 'CACHE 3'],\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getAlterTableRenameIndexSQL(): array\n    {\n        return ['ALTER INDEX idx_foo RENAME TO idx_bar'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedAlterTableRenameIndexSQL(): array\n    {\n        return [\n            'ALTER INDEX \"create\" RENAME TO \"select\"',\n            'ALTER INDEX \"foo\" RENAME TO \"bar\"',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotedAlterTableRenameColumnSQL(): array\n    {\n        return [\n            'ALTER TABLE mytable RENAME COLUMN unquoted1 TO unquoted',\n            'ALTER TABLE mytable RENAME COLUMN unquoted2 TO \"where\"',\n            'ALTER TABLE mytable RENAME COLUMN unquoted3 TO \"foo\"',\n            'ALTER TABLE mytable RENAME COLUMN \"create\" TO reserved_keyword',\n            'ALTER TABLE mytable RENAME COLUMN \"table\" TO \"from\"',\n            'ALTER TABLE mytable RENAME COLUMN \"select\" TO \"bar\"',\n            'ALTER TABLE mytable RENAME COLUMN quoted1 TO quoted',\n            'ALTER TABLE mytable RENAME COLUMN quoted2 TO \"and\"',\n            'ALTER TABLE mytable RENAME COLUMN quoted3 TO \"baz\"',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotedAlterTableChangeColumnLengthSQL(): array\n    {\n        self::markTestIncomplete('Not implemented yet');\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return ['ALTER INDEX myschema.idx_foo RENAME TO idx_bar'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return [\n            'ALTER INDEX \"schema\".\"create\" RENAME TO \"select\"',\n            'ALTER INDEX \"schema\".\"foo\" RENAME TO \"bar\"',\n        ];\n    }\n\n    protected function getQuotesDropForeignKeySQL(): string\n    {\n        return 'ALTER TABLE \"table\" DROP CONSTRAINT \"select\"';\n    }\n\n    public function testReturnsGuidTypeDeclarationSQL(): void\n    {\n        self::assertSame('CHAR(36)', $this->platform->getGuidTypeDeclarationSQL([]));\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAlterTableRenameColumnSQL(): array\n    {\n        return ['ALTER TABLE foo RENAME COLUMN bar TO baz'];\n    }\n\n    /**\n     * @param string[] $expectedSql\n     *\n     * @dataProvider getReturnsDropAutoincrementSQL\n     */\n    public function testReturnsDropAutoincrementSQL(string $table, array $expectedSql): void\n    {\n        self::assertSame($expectedSql, $this->platform->getDropAutoincrementSql($table));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getReturnsDropAutoincrementSQL(): iterable\n    {\n        return [\n            [\n                'myTable',\n                [\n                    'DROP TRIGGER MYTABLE_AI_PK',\n                    'DROP SEQUENCE MYTABLE_SEQ',\n                    'ALTER TABLE MYTABLE DROP CONSTRAINT MYTABLE_AI_PK',\n                ],\n            ],\n            [\n                '\"myTable\"',\n                [\n                    'DROP TRIGGER \"myTable_AI_PK\"',\n                    'DROP SEQUENCE \"myTable_SEQ\"',\n                    'ALTER TABLE \"myTable\" DROP CONSTRAINT \"myTable_AI_PK\"',\n                ],\n            ],\n            [\n                'table',\n                [\n                    'DROP TRIGGER TABLE_AI_PK',\n                    'DROP SEQUENCE TABLE_SEQ',\n                    'ALTER TABLE \"TABLE\" DROP CONSTRAINT TABLE_AI_PK',\n                ],\n            ],\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotesTableIdentifiersInAlterTableSQL(): array\n    {\n        return [\n            'ALTER TABLE \"foo\" DROP CONSTRAINT fk1',\n            'ALTER TABLE \"foo\" DROP CONSTRAINT fk2',\n            'ALTER TABLE \"foo\" ADD (bloo NUMBER(10) NOT NULL)',\n            'ALTER TABLE \"foo\" MODIFY (bar NUMBER(10) DEFAULT NULL NULL)',\n            'ALTER TABLE \"foo\" RENAME COLUMN id TO war',\n            'ALTER TABLE \"foo\" DROP (baz)',\n            'ALTER TABLE \"foo\" RENAME TO \"table\"',\n            'ALTER TABLE \"table\" ADD CONSTRAINT fk_add FOREIGN KEY (fk3) REFERENCES fk_table (id)',\n            'ALTER TABLE \"table\" ADD CONSTRAINT fk2 FOREIGN KEY (fk2) REFERENCES fk_table2 (id)',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getCommentOnColumnSQL(): array\n    {\n        return [\n            'COMMENT ON COLUMN foo.bar IS \\'comment\\'',\n            'COMMENT ON COLUMN \"Foo\".\"BAR\" IS \\'comment\\'',\n            'COMMENT ON COLUMN \"select\".\"from\" IS \\'comment\\'',\n        ];\n    }\n\n    public function testAltersTableColumnCommentWithExplicitlyQuotedIdentifiers(): void\n    {\n        $table1 = new Table('\"foo\"', [new Column('\"bar\"', Type::getType('integer'))]);\n        $table2 = new Table('\"foo\"', [new Column('\"bar\"', Type::getType('integer'), ['comment' => 'baz'])]);\n\n        $comparator = new Comparator();\n\n        $tableDiff = $comparator->diffTable($table1, $table2);\n\n        self::assertInstanceOf(TableDiff::class, $tableDiff);\n        self::assertSame(\n            ['COMMENT ON COLUMN \"foo\".\"bar\" IS \\'baz\\''],\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    public function testQuotedTableNames(): void\n    {\n        $table = new Table('\"test\"');\n        $table->addColumn('\"id\"', 'integer', ['autoincrement' => true]);\n\n        // assert tabel\n        self::assertTrue($table->isQuoted());\n        self::assertEquals('test', $table->getName());\n        self::assertEquals('\"test\"', $table->getQuotedName($this->platform));\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals('CREATE TABLE \"test\" (\"id\" NUMBER(10) NOT NULL)', $sql[0]);\n        self::assertEquals('CREATE SEQUENCE \"test_SEQ\" START WITH 1 MINVALUE 1 INCREMENT BY 1', $sql[2]);\n        $createTriggerStatement = <<<EOD\nCREATE TRIGGER \"test_AI_PK\"\n   BEFORE INSERT\n   ON \"test\"\n   FOR EACH ROW\nDECLARE\n   last_Sequence NUMBER;\n   last_InsertID NUMBER;\nBEGIN\n   IF (:NEW.\"id\" IS NULL OR :NEW.\"id\" = 0) THEN\n      SELECT \"test_SEQ\".NEXTVAL INTO :NEW.\"id\" FROM DUAL;\n   ELSE\n      SELECT NVL(Last_Number, 0) INTO last_Sequence\n        FROM User_Sequences\n       WHERE Sequence_Name = 'test_SEQ';\n      SELECT :NEW.\"id\" INTO last_InsertID FROM DUAL;\n      WHILE (last_InsertID > last_Sequence) LOOP\n         SELECT \"test_SEQ\".NEXTVAL INTO last_Sequence FROM DUAL;\n      END LOOP;\n      SELECT \"test_SEQ\".NEXTVAL INTO last_Sequence FROM DUAL;\n   END IF;\nEND;\nEOD;\n\n        self::assertEquals($createTriggerStatement, $sql[3]);\n    }\n\n    /**\n     * @dataProvider getReturnsGetListTableColumnsSQL\n     */\n    public function testReturnsGetListTableColumnsSQL(?string $database, string $expectedSql): void\n    {\n        // note: this assertion is a bit strict, as it compares a full SQL string.\n        // Should this break in future, then please try to reduce the matching to substring matching while reworking\n        // the tests\n        self::assertEquals($expectedSql, $this->platform->getListTableColumnsSQL('\"test\"', $database));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getReturnsGetListTableColumnsSQL(): iterable\n    {\n        return [\n            [\n                null,\n                <<<'SQL'\nSELECT   c.*,\n         (\n             SELECT d.comments\n             FROM   user_col_comments d\n             WHERE  d.TABLE_NAME = c.TABLE_NAME\n             AND    d.COLUMN_NAME = c.COLUMN_NAME\n         ) AS comments\nFROM     user_tab_columns c\nWHERE    c.table_name = 'test'\nORDER BY c.column_id\nSQL\n,\n            ],\n            [\n                '/',\n                <<<'SQL'\nSELECT   c.*,\n         (\n             SELECT d.comments\n             FROM   user_col_comments d\n             WHERE  d.TABLE_NAME = c.TABLE_NAME\n             AND    d.COLUMN_NAME = c.COLUMN_NAME\n         ) AS comments\nFROM     user_tab_columns c\nWHERE    c.table_name = 'test'\nORDER BY c.column_id\nSQL\n,\n            ],\n            [\n                'scott',\n                <<<'SQL'\nSELECT   c.*,\n         (\n             SELECT d.comments\n             FROM   all_col_comments d\n             WHERE  d.TABLE_NAME = c.TABLE_NAME AND d.OWNER = c.OWNER\n             AND    d.COLUMN_NAME = c.COLUMN_NAME\n         ) AS comments\nFROM     all_tab_columns c\nWHERE    c.table_name = 'test' AND c.owner = 'SCOTT'\nORDER BY c.column_id\nSQL\n,\n            ],\n        ];\n    }\n\n    protected function getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): string\n    {\n        return 'CONSTRAINT \"select\" UNIQUE (foo)';\n    }\n\n    protected function getQuotesReservedKeywordInIndexDeclarationSQL(): string\n    {\n        return 'INDEX \"select\" (foo)';\n    }\n\n    protected function getQuotesReservedKeywordInTruncateTableSQL(): string\n    {\n        return 'TRUNCATE TABLE \"select\"';\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getAlterStringToFixedStringSQL(): array\n    {\n        return ['ALTER TABLE mytable MODIFY (name CHAR(2) DEFAULT NULL)'];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): array\n    {\n        return ['ALTER INDEX idx_foo RENAME TO idx_foo_renamed'];\n    }\n\n    public function testQuotesDatabaseNameInListSequencesSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListSequencesSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableIndexesSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableIndexesSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableForeignKeysSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableForeignKeysSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableConstraintsSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableConstraintsSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableColumnsSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableColumnsSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesDatabaseNameInListTableColumnsSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableColumnsSQL('foo_table', \"Foo'Bar\\\\\")\n        );\n    }\n\n    /**\n     * @return array<int, array{string, array<string, mixed>}>\n     */\n    public function asciiStringSqlDeclarationDataProvider(): array\n    {\n        return [\n            ['VARCHAR2(12)', ['length' => 12]],\n            ['CHAR(12)', ['length' => 12, 'fixed' => true]],\n        ];\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Doctrine\\DBAL\\Platforms;\n\nuse Doctrine\\Common\\EventManager;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableAddColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableChangeColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableRemoveColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaAlterTableRenameColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaCreateTableColumnEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaCreateTableEventArgs;\nuse Doctrine\\DBAL\\Event\\SchemaDropTableEventArgs;\nuse Doctrine\\DBAL\\Events;\nuse Doctrine\\DBAL\\Exception;\nuse Doctrine\\DBAL\\Exception\\InvalidLockMode;\nuse Doctrine\\DBAL\\LockMode;\nuse Doctrine\\DBAL\\Platforms\\Keywords\\KeywordList;\nuse Doctrine\\DBAL\\Schema\\Column;\nuse Doctrine\\DBAL\\Schema\\ColumnDiff;\nuse Doctrine\\DBAL\\Schema\\Constraint;\nuse Doctrine\\DBAL\\Schema\\ForeignKeyConstraint;\nuse Doctrine\\DBAL\\Schema\\Identifier;\nuse Doctrine\\DBAL\\Schema\\Index;\nuse Doctrine\\DBAL\\Schema\\Sequence;\nuse Doctrine\\DBAL\\Schema\\Table;\nuse Doctrine\\DBAL\\Schema\\TableDiff;\nuse Doctrine\\DBAL\\Schema\\UniqueConstraint;\nuse Doctrine\\DBAL\\SQL\\Parser;\nuse Doctrine\\DBAL\\TransactionIsolationLevel;\nuse Doctrine\\DBAL\\Types;\nuse Doctrine\\DBAL\\Types\\Type;\nuse Doctrine\\Deprecations\\Deprecation;\nuse InvalidArgumentException;\nuse UnexpectedValueException;\n\nuse function addcslashes;\nuse function array_map;\nuse function array_merge;\nuse function array_unique;\nuse function array_values;\nuse function assert;\nuse function count;\nuse function explode;\nuse function func_get_arg;\nuse function func_get_args;\nuse function func_num_args;\nuse function implode;\nuse function in_array;\nuse function is_array;\nuse function is_bool;\nuse function is_int;\nuse function is_string;\nuse function preg_quote;\nuse function preg_replace;\nuse function sprintf;\nuse function str_replace;\nuse function strlen;\nuse function strpos;\nuse function strtolower;\nuse function strtoupper;\n\n/**\n * Base class for all DatabasePlatforms. The DatabasePlatforms are the central\n * point of abstraction of platform-specific behaviors, features and SQL dialects.\n * They are a passive source of information.\n *\n * @todo Remove any unnecessary methods.\n */\nabstract class AbstractPlatform\n{\n    public const CREATE_INDEXES = 1;\n\n    public const CREATE_FOREIGNKEYS = 2;\n\n    /** @var string[]|null */\n    protected $doctrineTypeMapping;\n\n    /**\n     * Contains a list of all columns that should generate parseable column comments for type-detection\n     * in reverse engineering scenarios.\n     *\n     * @var string[]|null\n     */\n    protected $doctrineTypeComments;\n\n    /** @var EventManager|null */\n    protected $_eventManager;\n\n    /**\n     * Holds the KeywordList instance for the current platform.\n     *\n     * @var KeywordList|null\n     */\n    protected $_keywords;\n\n    public function __construct()\n    {\n    }\n\n    /**\n     * Sets the EventManager used by the Platform.\n     *\n     * @return void\n     */\n    public function setEventManager(EventManager $eventManager)\n    {\n        $this->_eventManager = $eventManager;\n    }\n\n    /**\n     * Gets the EventManager used by the Platform.\n     *\n     * @return EventManager|null\n     */\n    public function getEventManager()\n    {\n        return $this->_eventManager;\n    }\n\n    /**\n     * Returns the SQL snippet that declares a boolean column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getBooleanTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL snippet that declares a 4 byte integer column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getIntegerTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL snippet that declares an 8 byte integer column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getBigIntTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL snippet that declares a 2 byte integer column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getSmallIntTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL snippet that declares common properties of an integer column.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract protected function _getCommonIntegerTypeDeclarationSQL(array $column);\n\n    /**\n     * Lazy load Doctrine Type Mappings.\n     *\n     * @return void\n     */\n    abstract protected function initializeDoctrineTypeMappings();\n\n    /**\n     * Initializes Doctrine Type Mappings with the platform defaults\n     * and with all additional type mappings.\n     *\n     * @return void\n     */\n    private function initializeAllDoctrineTypeMappings()\n    {\n        $this->initializeDoctrineTypeMappings();\n\n        foreach (Type::getTypesMap() as $typeName => $className) {\n            foreach (Type::getType($typeName)->getMappedDatabaseTypes($this) as $dbType) {\n                $this->doctrineTypeMapping[$dbType] = $typeName;\n            }\n        }\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a column that can\n     * store characters in the ASCII character set\n     *\n     * @param mixed[] $column\n     */\n    public function getAsciiStringTypeDeclarationSQL(array $column): string\n    {\n        return $this->getVarcharTypeDeclarationSQL($column);\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a VARCHAR column type.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getVarcharTypeDeclarationSQL(array $column)\n    {\n        if (! isset($column['length'])) {\n            $column['length'] = $this->getVarcharDefaultLength();\n        }\n\n        $fixed = $column['fixed'] ?? false;\n\n        $maxLength = $fixed\n            ? $this->getCharMaxLength()\n            : $this->getVarcharMaxLength();\n\n        if ($column['length'] > $maxLength) {\n            return $this->getClobTypeDeclarationSQL($column);\n        }\n\n        return $this->getVarcharTypeDeclarationSQLSnippet($column['length'], $fixed);\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a BINARY/VARBINARY column type.\n     *\n     * @param mixed[] $column The column definition.\n     *\n     * @return string\n     */\n    public function getBinaryTypeDeclarationSQL(array $column)\n    {\n        if (! isset($column['length'])) {\n            $column['length'] = $this->getBinaryDefaultLength();\n        }\n\n        $fixed = $column['fixed'] ?? false;\n\n        $maxLength = $this->getBinaryMaxLength();\n\n        if ($column['length'] > $maxLength) {\n            if ($maxLength > 0) {\n                Deprecation::trigger(\n                    'doctrine/dbal',\n                    'https://github.com/doctrine/dbal/issues/3187',\n                    'Binary column length %d is greater than supported by the platform (%d).'\n                        . ' Reduce the column length or use a BLOB column instead.',\n                    $column['length'],\n                    $maxLength\n                );\n            }\n\n            return $this->getBlobTypeDeclarationSQL($column);\n        }\n\n        return $this->getBinaryTypeDeclarationSQLSnippet($column['length'], $fixed);\n    }\n\n    /**\n     * Returns the SQL snippet to declare a GUID/UUID column.\n     *\n     * By default this maps directly to a CHAR(36) and only maps to more\n     * special datatypes when the underlying databases support this datatype.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getGuidTypeDeclarationSQL(array $column)\n    {\n        $column['length'] = 36;\n        $column['fixed']  = true;\n\n        return $this->getVarcharTypeDeclarationSQL($column);\n    }\n\n    /**\n     * Returns the SQL snippet to declare a JSON column.\n     *\n     * By default this maps directly to a CLOB and only maps to more\n     * special datatypes when the underlying databases support this datatype.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getJsonTypeDeclarationSQL(array $column)\n    {\n        return $this->getClobTypeDeclarationSQL($column);\n    }\n\n    /**\n     * @param int|false $length\n     * @param bool      $fixed\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    protected function getVarcharTypeDeclarationSQLSnippet($length, $fixed)\n    {\n        throw Exception::notSupported('VARCHARs not supported by Platform.');\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a BINARY/VARBINARY column type.\n     *\n     * @param int|false $length The length of the column.\n     * @param bool      $fixed  Whether the column length is fixed.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    protected function getBinaryTypeDeclarationSQLSnippet($length, $fixed)\n    {\n        throw Exception::notSupported('BINARY/VARBINARY column types are not supported by this platform.');\n    }\n\n    /**\n     * Returns the SQL snippet used to declare a CLOB column type.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getClobTypeDeclarationSQL(array $column);\n\n    /**\n     * Returns the SQL Snippet used to declare a BLOB column type.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    abstract public function getBlobTypeDeclarationSQL(array $column);\n\n    /**\n     * Gets the name of the platform.\n     *\n     * @return string\n     */\n    abstract public function getName();\n\n    /**\n     * Registers a doctrine type to be used in conjunction with a column type of this platform.\n     *\n     * @param string $dbType\n     * @param string $doctrineType\n     *\n     * @return void\n     *\n     * @throws Exception If the type is not found.\n     */\n    public function registerDoctrineTypeMapping($dbType, $doctrineType)\n    {\n        if ($this->doctrineTypeMapping === null) {\n            $this->initializeAllDoctrineTypeMappings();\n        }\n\n        if (! Types\\Type::hasType($doctrineType)) {\n            throw Exception::typeNotFound($doctrineType);\n        }\n\n        $dbType                             = strtolower($dbType);\n        $this->doctrineTypeMapping[$dbType] = $doctrineType;\n\n        $doctrineType = Type::getType($doctrineType);\n\n        if (! $doctrineType->requiresSQLCommentHint($this)) {\n            return;\n        }\n\n        $this->markDoctrineTypeCommented($doctrineType);\n    }\n\n    /**\n     * Gets the Doctrine type that is mapped for the given database column type.\n     *\n     * @param string $dbType\n     *\n     * @return string\n     *\n     * @throws Exception\n     */\n    public function getDoctrineTypeMapping($dbType)\n    {\n        if ($this->doctrineTypeMapping === null) {\n            $this->initializeAllDoctrineTypeMappings();\n        }\n\n        $dbType = strtolower($dbType);\n\n        if (! isset($this->doctrineTypeMapping[$dbType])) {\n            throw new Exception(\n                'Unknown database type ' . $dbType . ' requested, ' . static::class . ' may not support it.'\n            );\n        }\n\n        return $this->doctrineTypeMapping[$dbType];\n    }\n\n    /**\n     * Checks if a database type is currently supported by this platform.\n     *\n     * @param string $dbType\n     *\n     * @return bool\n     */\n    public function hasDoctrineTypeMappingFor($dbType)\n    {\n        if ($this->doctrineTypeMapping === null) {\n            $this->initializeAllDoctrineTypeMappings();\n        }\n\n        $dbType = strtolower($dbType);\n\n        return isset($this->doctrineTypeMapping[$dbType]);\n    }\n\n    /**\n     * Initializes the Doctrine Type comments instance variable for in_array() checks.\n     *\n     * @return void\n     */\n    protected function initializeCommentedDoctrineTypes()\n    {\n        $this->doctrineTypeComments = [];\n\n        foreach (Type::getTypesMap() as $typeName => $className) {\n            $type = Type::getType($typeName);\n\n            if (! $type->requiresSQLCommentHint($this)) {\n                continue;\n            }\n\n            $this->doctrineTypeComments[] = $typeName;\n        }\n    }\n\n    /**\n     * Is it necessary for the platform to add a parsable type comment to allow reverse engineering the given type?\n     *\n     * @return bool\n     */\n    public function isCommentedDoctrineType(Type $doctrineType)\n    {\n        if ($this->doctrineTypeComments === null) {\n            $this->initializeCommentedDoctrineTypes();\n        }\n\n        assert(is_array($this->doctrineTypeComments));\n\n        return in_array($doctrineType->getName(), $this->doctrineTypeComments, true);\n    }\n\n    /**\n     * Marks this type as to be commented in ALTER TABLE and CREATE TABLE statements.\n     *\n     * @param string|Type $doctrineType\n     *\n     * @return void\n     */\n    public function markDoctrineTypeCommented($doctrineType)\n    {\n        if ($this->doctrineTypeComments === null) {\n            $this->initializeCommentedDoctrineTypes();\n        }\n\n        assert(is_array($this->doctrineTypeComments));\n\n        $this->doctrineTypeComments[] = $doctrineType instanceof Type ? $doctrineType->getName() : $doctrineType;\n    }\n\n    /**\n     * Gets the comment to append to a column comment that helps parsing this type in reverse engineering.\n     *\n     * @return string\n     */\n    public function getDoctrineTypeComment(Type $doctrineType)\n    {\n        return '(DC2Type:' . $doctrineType->getName() . ')';\n    }\n\n    /**\n     * Gets the comment of a passed column modified by potential doctrine type comment hints.\n     *\n     * @return string|null\n     */\n    protected function getColumnComment(Column $column)\n    {\n        $comment = $column->getComment();\n\n        if ($this->isCommentedDoctrineType($column->getType())) {\n            $comment .= $this->getDoctrineTypeComment($column->getType());\n        }\n\n        return $comment;\n    }\n\n    /**\n     * Gets the character used for identifier quoting.\n     *\n     * @return string\n     */\n    public function getIdentifierQuoteCharacter()\n    {\n        return '\"';\n    }\n\n    /**\n     * Gets the string portion that starts an SQL comment.\n     *\n     * @return string\n     */\n    public function getSqlCommentStartString()\n    {\n        return '--';\n    }\n\n    /**\n     * Gets the string portion that ends an SQL comment.\n     *\n     * @return string\n     */\n    public function getSqlCommentEndString()\n    {\n        return \"\\n\";\n    }\n\n    /**\n     * Gets the maximum length of a char column.\n     */\n    public function getCharMaxLength(): int\n    {\n        return $this->getVarcharMaxLength();\n    }\n\n    /**\n     * Gets the maximum length of a varchar column.\n     *\n     * @return int\n     */\n    public function getVarcharMaxLength()\n    {\n        return 4000;\n    }\n\n    /**\n     * Gets the default length of a varchar column.\n     *\n     * @return int\n     */\n    public function getVarcharDefaultLength()\n    {\n        return 255;\n    }\n\n    /**\n     * Gets the maximum length of a binary column.\n     *\n     * @return int\n     */\n    public function getBinaryMaxLength()\n    {\n        return 4000;\n    }\n\n    /**\n     * Gets the default length of a binary column.\n     *\n     * @return int\n     */\n    public function getBinaryDefaultLength()\n    {\n        return 255;\n    }\n\n    /**\n     * Gets all SQL wildcard characters of the platform.\n     *\n     * @return string[]\n     */\n    public function getWildcards()\n    {\n        return ['%', '_'];\n    }\n\n    /**\n     * Returns the regular expression operator.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getRegexpExpression()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL snippet to get the average value of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including an AVG aggregate function.\n     */\n    public function getAvgExpression($column)\n    {\n        return 'AVG(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the number of rows (without a NULL value) of a column.\n     *\n     * If a '*' is used instead of a column the number of selected rows is returned.\n     *\n     * @param string|int $column The column to use.\n     *\n     * @return string Generated SQL including a COUNT aggregate function.\n     */\n    public function getCountExpression($column)\n    {\n        return 'COUNT(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the highest value of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including a MAX aggregate function.\n     */\n    public function getMaxExpression($column)\n    {\n        return 'MAX(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the lowest value of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including a MIN aggregate function.\n     */\n    public function getMinExpression($column)\n    {\n        return 'MIN(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the total sum of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including a SUM aggregate function.\n     */\n    public function getSumExpression($column)\n    {\n        return 'SUM(' . $column . ')';\n    }\n\n    // scalar functions\n\n    /**\n     * Returns the SQL snippet to get the md5 sum of a column.\n     *\n     * Note: Not SQL92, but common functionality.\n     *\n     * @param string $column\n     *\n     * @return string\n     */\n    public function getMd5Expression($column)\n    {\n        return 'MD5(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the length of a text column.\n     *\n     * @param string $column\n     *\n     * @return string\n     */\n    public function getLengthExpression($column)\n    {\n        return 'LENGTH(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the squared value of a column.\n     *\n     * @param string $column The column to use.\n     *\n     * @return string Generated SQL including an SQRT aggregate function.\n     */\n    public function getSqrtExpression($column)\n    {\n        return 'SQRT(' . $column . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to round a numeric column to the number of decimals specified.\n     *\n     * @param string $column\n     * @param int    $decimals\n     *\n     * @return string\n     */\n    public function getRoundExpression($column, $decimals = 0)\n    {\n        return 'ROUND(' . $column . ', ' . $decimals . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the remainder of the division operation $expression1 / $expression2.\n     *\n     * @param string $expression1\n     * @param string $expression2\n     *\n     * @return string\n     */\n    public function getModExpression($expression1, $expression2)\n    {\n        return 'MOD(' . $expression1 . ', ' . $expression2 . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to trim a string.\n     *\n     * @param string      $str  The expression to apply the trim to.\n     * @param int         $mode The position of the trim (leading/trailing/both).\n     * @param string|bool $char The char to trim, has to be quoted already. Defaults to space.\n     *\n     * @return string\n     */\n    public function getTrimExpression($str, $mode = TrimMode::UNSPECIFIED, $char = false)\n    {\n        $expression = '';\n\n        switch ($mode) {\n            case TrimMode::LEADING:\n                $expression = 'LEADING ';\n                break;\n\n            case TrimMode::TRAILING:\n                $expression = 'TRAILING ';\n                break;\n\n            case TrimMode::BOTH:\n                $expression = 'BOTH ';\n                break;\n        }\n\n        if ($char !== false) {\n            $expression .= $char . ' ';\n        }\n\n        if ($mode !== TrimMode::UNSPECIFIED || $char !== false) {\n            $expression .= 'FROM ';\n        }\n\n        return 'TRIM(' . $expression . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to trim trailing space characters from the expression.\n     *\n     * @param string $str Literal string or column name.\n     *\n     * @return string\n     */\n    public function getRtrimExpression($str)\n    {\n        return 'RTRIM(' . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to trim leading space characters from the expression.\n     *\n     * @param string $str Literal string or column name.\n     *\n     * @return string\n     */\n    public function getLtrimExpression($str)\n    {\n        return 'LTRIM(' . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to change all characters from the expression to uppercase,\n     * according to the current character set mapping.\n     *\n     * @param string $str Literal string or column name.\n     *\n     * @return string\n     */\n    public function getUpperExpression($str)\n    {\n        return 'UPPER(' . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to change all characters from the expression to lowercase,\n     * according to the current character set mapping.\n     *\n     * @param string $str Literal string or column name.\n     *\n     * @return string\n     */\n    public function getLowerExpression($str)\n    {\n        return 'LOWER(' . $str . ')';\n    }\n\n    /**\n     * Returns the SQL snippet to get the position of the first occurrence of substring $substr in string $str.\n     *\n     * @param string    $str      Literal string.\n     * @param string    $substr   Literal string to find.\n     * @param int|false $startPos Position to start at, beginning of string by default.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getLocateExpression($str, $substr, $startPos = false)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL snippet to get the current system date.\n     *\n     * @return string\n     */\n    public function getNowExpression()\n    {\n        return 'NOW()';\n    }\n\n    /**\n     * Returns a SQL snippet to get a substring inside an SQL statement.\n     *\n     * Note: Not SQL92, but common functionality.\n     *\n     * SQLite only supports the 2 parameter variant of this function.\n     *\n     * @param string   $string An sql string literal or column name/alias.\n     * @param int      $start  Where to start the substring portion.\n     * @param int|null $length The substring portion length.\n     *\n     * @return string\n     */\n    public function getSubstringExpression($string, $start, $length = null)\n    {\n        if ($length === null) {\n            return 'SUBSTRING(' . $string . ' FROM ' . $start . ')';\n        }\n\n        return 'SUBSTRING(' . $string . ' FROM ' . $start . ' FOR ' . $length . ')';\n    }\n\n    /**\n     * Returns a SQL snippet to concatenate the given expressions.\n     *\n     * Accepts an arbitrary number of string parameters. Each parameter must contain an expression.\n     *\n     * @return string\n     */\n    public function getConcatExpression()\n    {\n        return implode(' || ', func_get_args());\n    }\n\n    /**\n     * Returns the SQL for a logical not.\n     *\n     * Example:\n     * <code>\n     * $q = new Doctrine_Query();\n     * $e = $q->expr;\n     * $q->select('*')->from('table')\n     *   ->where($e->eq('id', $e->not('null'));\n     * </code>\n     *\n     * @param string $expression\n     *\n     * @return string The logical expression.\n     */\n    public function getNotExpression($expression)\n    {\n        return 'NOT(' . $expression . ')';\n    }\n\n    /**\n     * Returns the SQL that checks if an expression is null.\n     *\n     * @param string $expression The expression that should be compared to null.\n     *\n     * @return string The logical expression.\n     */\n    public function getIsNullExpression($expression)\n    {\n        return $expression . ' IS NULL';\n    }\n\n    /**\n     * Returns the SQL that checks if an expression is not null.\n     *\n     * @param string $expression The expression that should be compared to null.\n     *\n     * @return string The logical expression.\n     */\n    public function getIsNotNullExpression($expression)\n    {\n        return $expression . ' IS NOT NULL';\n    }\n\n    /**\n     * Returns the SQL that checks if an expression evaluates to a value between two values.\n     *\n     * The parameter $expression is checked if it is between $value1 and $value2.\n     *\n     * Note: There is a slight difference in the way BETWEEN works on some databases.\n     * http://www.w3schools.com/sql/sql_between.asp. If you want complete database\n     * independence you should avoid using between().\n     *\n     * @param string $expression The value to compare to.\n     * @param string $value1     The lower value to compare with.\n     * @param string $value2     The higher value to compare with.\n     *\n     * @return string The logical expression.\n     */\n    public function getBetweenExpression($expression, $value1, $value2)\n    {\n        return $expression . ' BETWEEN ' . $value1 . ' AND ' . $value2;\n    }\n\n    /**\n     * Returns the SQL to get the arccosine of a value.\n     *\n     * @param string $value\n     *\n     * @return string\n     */\n    public function getAcosExpression($value)\n    {\n        return 'ACOS(' . $value . ')';\n    }\n\n    /**\n     * Returns the SQL to get the sine of a value.\n     *\n     * @param string $value\n     *\n     * @return string\n     */\n    public function getSinExpression($value)\n    {\n        return 'SIN(' . $value . ')';\n    }\n\n    /**\n     * Returns the SQL to get the PI value.\n     *\n     * @return string\n     */\n    public function getPiExpression()\n    {\n        return 'PI()';\n    }\n\n    /**\n     * Returns the SQL to get the cosine of a value.\n     *\n     * @param string $value\n     *\n     * @return string\n     */\n    public function getCosExpression($value)\n    {\n        return 'COS(' . $value . ')';\n    }\n\n    /**\n     * Returns the SQL to calculate the difference in days between the two passed dates.\n     *\n     * Computes diff = date1 - date2.\n     *\n     * @param string $date1\n     * @param string $date2\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateDiffExpression($date1, $date2)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to add the number of given seconds to a date.\n     *\n     * @param string $date\n     * @param int    $seconds\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddSecondsExpression($date, $seconds)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $seconds, DateIntervalUnit::SECOND);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given seconds from a date.\n     *\n     * @param string $date\n     * @param int    $seconds\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubSecondsExpression($date, $seconds)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $seconds, DateIntervalUnit::SECOND);\n    }\n\n    /**\n     * Returns the SQL to add the number of given minutes to a date.\n     *\n     * @param string $date\n     * @param int    $minutes\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddMinutesExpression($date, $minutes)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $minutes, DateIntervalUnit::MINUTE);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given minutes from a date.\n     *\n     * @param string $date\n     * @param int    $minutes\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubMinutesExpression($date, $minutes)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $minutes, DateIntervalUnit::MINUTE);\n    }\n\n    /**\n     * Returns the SQL to add the number of given hours to a date.\n     *\n     * @param string $date\n     * @param int    $hours\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddHourExpression($date, $hours)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $hours, DateIntervalUnit::HOUR);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given hours to a date.\n     *\n     * @param string $date\n     * @param int    $hours\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubHourExpression($date, $hours)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $hours, DateIntervalUnit::HOUR);\n    }\n\n    /**\n     * Returns the SQL to add the number of given days to a date.\n     *\n     * @param string $date\n     * @param int    $days\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddDaysExpression($date, $days)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $days, DateIntervalUnit::DAY);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given days to a date.\n     *\n     * @param string $date\n     * @param int    $days\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubDaysExpression($date, $days)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $days, DateIntervalUnit::DAY);\n    }\n\n    /**\n     * Returns the SQL to add the number of given weeks to a date.\n     *\n     * @param string $date\n     * @param int    $weeks\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddWeeksExpression($date, $weeks)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $weeks, DateIntervalUnit::WEEK);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given weeks from a date.\n     *\n     * @param string $date\n     * @param int    $weeks\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubWeeksExpression($date, $weeks)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $weeks, DateIntervalUnit::WEEK);\n    }\n\n    /**\n     * Returns the SQL to add the number of given months to a date.\n     *\n     * @param string $date\n     * @param int    $months\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddMonthExpression($date, $months)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $months, DateIntervalUnit::MONTH);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given months to a date.\n     *\n     * @param string $date\n     * @param int    $months\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubMonthExpression($date, $months)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $months, DateIntervalUnit::MONTH);\n    }\n\n    /**\n     * Returns the SQL to add the number of given quarters to a date.\n     *\n     * @param string $date\n     * @param int    $quarters\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddQuartersExpression($date, $quarters)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $quarters, DateIntervalUnit::QUARTER);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given quarters from a date.\n     *\n     * @param string $date\n     * @param int    $quarters\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubQuartersExpression($date, $quarters)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $quarters, DateIntervalUnit::QUARTER);\n    }\n\n    /**\n     * Returns the SQL to add the number of given years to a date.\n     *\n     * @param string $date\n     * @param int    $years\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateAddYearsExpression($date, $years)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '+', $years, DateIntervalUnit::YEAR);\n    }\n\n    /**\n     * Returns the SQL to subtract the number of given years from a date.\n     *\n     * @param string $date\n     * @param int    $years\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateSubYearsExpression($date, $years)\n    {\n        return $this->getDateArithmeticIntervalExpression($date, '-', $years, DateIntervalUnit::YEAR);\n    }\n\n    /**\n     * Returns the SQL for a date arithmetic expression.\n     *\n     * @param string $date     The column or literal representing a date to perform the arithmetic operation on.\n     * @param string $operator The arithmetic operator (+ or -).\n     * @param int    $interval The interval that shall be calculated into the date.\n     * @param string $unit     The unit of the interval that shall be calculated into the date.\n     *                         One of the DATE_INTERVAL_UNIT_* constants.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    protected function getDateArithmeticIntervalExpression($date, $operator, $interval, $unit)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL bit AND comparison expression.\n     *\n     * @param string $value1\n     * @param string $value2\n     *\n     * @return string\n     */\n    public function getBitAndComparisonExpression($value1, $value2)\n    {\n        return '(' . $value1 . ' & ' . $value2 . ')';\n    }\n\n    /**\n     * Returns the SQL bit OR comparison expression.\n     *\n     * @param string $value1\n     * @param string $value2\n     *\n     * @return string\n     */\n    public function getBitOrComparisonExpression($value1, $value2)\n    {\n        return '(' . $value1 . ' | ' . $value2 . ')';\n    }\n\n    /**\n     * Returns the SQL expression which represents the currently selected database.\n     */\n    abstract public function getCurrentDatabaseExpression(): string;\n\n    /**\n     * Returns the FOR UPDATE expression.\n     *\n     * @return string\n     */\n    public function getForUpdateSQL()\n    {\n        return 'FOR UPDATE';\n    }\n\n    /**\n     * Honors that some SQL vendors such as MsSql use table hints for locking instead of the\n     * ANSI SQL FOR UPDATE specification.\n     *\n     * @param string $fromClause The FROM clause to append the hint for the given lock mode to\n     * @param int    $lockMode   One of the Doctrine\\DBAL\\LockMode::* constants\n     */\n    public function appendLockHint(string $fromClause, int $lockMode): string\n    {\n        switch ($lockMode) {\n            case LockMode::NONE:\n            case LockMode::OPTIMISTIC:\n            case LockMode::PESSIMISTIC_READ:\n            case LockMode::PESSIMISTIC_WRITE:\n                return $fromClause;\n\n            default:\n                throw InvalidLockMode::fromLockMode($lockMode);\n        }\n    }\n\n    /**\n     * Returns the SQL snippet to append to any SELECT statement which locks rows in shared read lock.\n     *\n     * This defaults to the ANSI SQL \"FOR UPDATE\", which is an exclusive lock (Write). Some database\n     * vendors allow to lighten this constraint up to be a real read lock.\n     *\n     * @return string\n     */\n    public function getReadLockSQL()\n    {\n        return $this->getForUpdateSQL();\n    }\n\n    /**\n     * Returns the SQL snippet to append to any SELECT statement which obtains an exclusive lock on the rows.\n     *\n     * The semantics of this lock mode should equal the SELECT .. FOR UPDATE of the ANSI SQL standard.\n     *\n     * @return string\n     */\n    public function getWriteLockSQL()\n    {\n        return $this->getForUpdateSQL();\n    }\n\n    /**\n     * Returns the SQL snippet to drop an existing database.\n     *\n     * @param string $name The name of the database that should be dropped.\n     *\n     * @return string\n     */\n    public function getDropDatabaseSQL($name)\n    {\n        return 'DROP DATABASE ' . $name;\n    }\n\n    /**\n     * Returns the SQL snippet to drop a schema.\n     */\n    public function getDropSchemaSQL(string $schemaName): string\n    {\n        return 'DROP SCHEMA ' . $schemaName;\n    }\n\n    /**\n     * Returns the SQL snippet to drop an existing table.\n     *\n     * @param Table|string $table\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getDropTableSQL($table)\n    {\n        $tableArg = $table;\n\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        if (! is_string($table)) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() expects $table parameter to be string or ' . Table::class . '.'\n            );\n        }\n\n        if ($this->_eventManager !== null && $this->_eventManager->hasListeners(Events::onSchemaDropTable)) {\n            $eventArgs = new SchemaDropTableEventArgs($tableArg, $this);\n            $this->_eventManager->dispatchEvent(Events::onSchemaDropTable, $eventArgs);\n\n            if ($eventArgs->isDefaultPrevented()) {\n                $sql = $eventArgs->getSql();\n\n                if ($sql === null) {\n                    throw new UnexpectedValueException('Default implementation of DROP TABLE was overridden with NULL');\n                }\n\n                return $sql;\n            }\n        }\n\n        return 'DROP TABLE ' . $table;\n    }\n\n    /**\n     * Returns the SQL to safely drop a temporary table WITHOUT implicitly committing an open transaction.\n     *\n     * @param Table|string $table\n     *\n     * @return string\n     */\n    public function getDropTemporaryTableSQL($table)\n    {\n        return $this->getDropTableSQL($table);\n    }\n\n    /**\n     * Returns the SQL to drop an index from a table.\n     *\n     * @param Index|string $index\n     * @param Table|string $table\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getDropIndexSQL($index, $table = null)\n    {\n        if ($index instanceof Index) {\n            $index = $index->getQuotedName($this);\n        } elseif (! is_string($index)) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() expects $index parameter to be string or ' . Index::class . '.'\n            );\n        }\n\n        return 'DROP INDEX ' . $index;\n    }\n\n    /**\n     * Returns the SQL to drop a constraint.\n     *\n     * @param Constraint|string $constraint\n     * @param Table|string      $table\n     *\n     * @return string\n     */\n    public function getDropConstraintSQL($constraint, $table)\n    {\n        if (! $constraint instanceof Constraint) {\n            $constraint = new Identifier($constraint);\n        }\n\n        if (! $table instanceof Table) {\n            $table = new Identifier($table);\n        }\n\n        $constraint = $constraint->getQuotedName($this);\n        $table      = $table->getQuotedName($this);\n\n        return 'ALTER TABLE ' . $table . ' DROP CONSTRAINT ' . $constraint;\n    }\n\n    /**\n     * Returns the SQL to drop a foreign key.\n     *\n     * @param ForeignKeyConstraint|string $foreignKey\n     * @param Table|string                $table\n     *\n     * @return string\n     */\n    public function getDropForeignKeySQL($foreignKey, $table)\n    {\n        if (! $foreignKey instanceof ForeignKeyConstraint) {\n            $foreignKey = new Identifier($foreignKey);\n        }\n\n        if (! $table instanceof Table) {\n            $table = new Identifier($table);\n        }\n\n        $foreignKey = $foreignKey->getQuotedName($this);\n        $table      = $table->getQuotedName($this);\n\n        return 'ALTER TABLE ' . $table . ' DROP FOREIGN KEY ' . $foreignKey;\n    }\n\n    /**\n     * Returns the SQL statement(s) to create a table with the specified name, columns and constraints\n     * on this platform.\n     *\n     * @param int $createFlags\n     *\n     * @return string[] The sequence of SQL statements.\n     *\n     * @throws Exception\n     * @throws InvalidArgumentException\n     */\n    public function getCreateTableSQL(Table $table, $createFlags = self::CREATE_INDEXES)\n    {\n        if (! is_int($createFlags)) {\n            throw new InvalidArgumentException(\n                'Second argument of AbstractPlatform::getCreateTableSQL() has to be integer.'\n            );\n        }\n\n        if (count($table->getColumns()) === 0) {\n            throw Exception::noColumnsSpecifiedForTable($table->getName());\n        }\n\n        $tableName                    = $table->getQuotedName($this);\n        $options                      = $table->getOptions();\n        $options['uniqueConstraints'] = [];\n        $options['indexes']           = [];\n        $options['primary']           = [];\n\n        if (($createFlags & self::CREATE_INDEXES) > 0) {\n            foreach ($table->getIndexes() as $index) {\n                if (! $index->isPrimary()) {\n                    $options['indexes'][$index->getQuotedName($this)] = $index;\n\n                    continue;\n                }\n\n                $options['primary']       = $index->getQuotedColumns($this);\n                $options['primary_index'] = $index;\n            }\n\n            foreach ($table->getUniqueConstraints() as $uniqueConstraint) {\n                $options['uniqueConstraints'][$uniqueConstraint->getQuotedName($this)] = $uniqueConstraint;\n            }\n        }\n\n        if (($createFlags & self::CREATE_FOREIGNKEYS) > 0) {\n            $options['foreignKeys'] = [];\n\n            foreach ($table->getForeignKeys() as $fkConstraint) {\n                $options['foreignKeys'][] = $fkConstraint;\n            }\n        }\n\n        $columnSql = [];\n        $columns   = [];\n\n        foreach ($table->getColumns() as $column) {\n            if (\n                $this->_eventManager !== null\n                && $this->_eventManager->hasListeners(Events::onSchemaCreateTableColumn)\n            ) {\n                $eventArgs = new SchemaCreateTableColumnEventArgs($column, $table, $this);\n\n                $this->_eventManager->dispatchEvent(Events::onSchemaCreateTableColumn, $eventArgs);\n\n                $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n                if ($eventArgs->isDefaultPrevented()) {\n                    continue;\n                }\n            }\n\n            $name = $column->getQuotedName($this);\n\n            $columnData = array_merge($column->toArray(), [\n                'name' => $name,\n                'version' => $column->hasPlatformOption('version') ? $column->getPlatformOption('version') : false,\n                'comment' => $this->getColumnComment($column),\n            ]);\n\n            if ($columnData['type'] instanceof Types\\StringType && $columnData['length'] === null) {\n                $columnData['length'] = 255;\n            }\n\n            if (in_array($column->getName(), $options['primary'], true)) {\n                $columnData['primary'] = true;\n            }\n\n            $columns[$name] = $columnData;\n        }\n\n        if ($this->_eventManager !== null && $this->_eventManager->hasListeners(Events::onSchemaCreateTable)) {\n            $eventArgs = new SchemaCreateTableEventArgs($table, $columns, $options, $this);\n\n            $this->_eventManager->dispatchEvent(Events::onSchemaCreateTable, $eventArgs);\n\n            if ($eventArgs->isDefaultPrevented()) {\n                return array_merge($eventArgs->getSql(), $columnSql);\n            }\n        }\n\n        $sql = $this->_getCreateTableSQL($tableName, $columns, $options);\n\n        if ($this->supportsCommentOnStatement()) {\n            if ($table->hasOption('comment')) {\n                $sql[] = $this->getCommentOnTableSQL($tableName, $table->getOption('comment'));\n            }\n\n            foreach ($table->getColumns() as $column) {\n                $comment = $this->getColumnComment($column);\n\n                if ($comment === null || $comment === '') {\n                    continue;\n                }\n\n                $sql[] = $this->getCommentOnColumnSQL($tableName, $column->getQuotedName($this), $comment);\n            }\n        }\n\n        return array_merge($sql, $columnSql);\n    }\n\n    protected function getCommentOnTableSQL(string $tableName, ?string $comment): string\n    {\n        $tableName = new Identifier($tableName);\n\n        return sprintf(\n            'COMMENT ON TABLE %s IS %s',\n            $tableName->getQuotedName($this),\n            $this->quoteStringLiteral((string) $comment)\n        );\n    }\n\n    /**\n     * @param string      $tableName\n     * @param string      $columnName\n     * @param string|null $comment\n     *\n     * @return string\n     */\n    public function getCommentOnColumnSQL($tableName, $columnName, $comment)\n    {\n        $tableName  = new Identifier($tableName);\n        $columnName = new Identifier($columnName);\n\n        return sprintf(\n            'COMMENT ON COLUMN %s.%s IS %s',\n            $tableName->getQuotedName($this),\n            $columnName->getQuotedName($this),\n            $this->quoteStringLiteral((string) $comment)\n        );\n    }\n\n    /**\n     * Returns the SQL to create inline comment on a column.\n     *\n     * @param string $comment\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getInlineColumnCommentSQL($comment)\n    {\n        if (! $this->supportsInlineColumnComments()) {\n            throw Exception::notSupported(__METHOD__);\n        }\n\n        return 'COMMENT ' . $this->quoteStringLiteral($comment);\n    }\n\n    /**\n     * Returns the SQL used to create a table.\n     *\n     * @param string    $name\n     * @param mixed[][] $columns\n     * @param mixed[]   $options\n     *\n     * @return string[]\n     */\n    protected function _getCreateTableSQL($name, array $columns, array $options = [])\n    {\n        $columnListSql = $this->getColumnDeclarationListSQL($columns);\n\n        if (isset($options['uniqueConstraints']) && ! empty($options['uniqueConstraints'])) {\n            foreach ($options['uniqueConstraints'] as $index => $definition) {\n                $columnListSql .= ', ' . $this->getUniqueConstraintDeclarationSQL($index, $definition);\n            }\n        }\n\n        if (isset($options['primary']) && ! empty($options['primary'])) {\n            $columnListSql .= ', PRIMARY KEY(' . implode(', ', array_unique(array_values($options['primary']))) . ')';\n        }\n\n        if (isset($options['indexes']) && ! empty($options['indexes'])) {\n            foreach ($options['indexes'] as $index => $definition) {\n                $columnListSql .= ', ' . $this->getIndexDeclarationSQL($index, $definition);\n            }\n        }\n\n        $query = 'CREATE TABLE ' . $name . ' (' . $columnListSql;\n        $check = $this->getCheckDeclarationSQL($columns);\n\n        if (! empty($check)) {\n            $query .= ', ' . $check;\n        }\n\n        $query .= ')';\n\n        $sql = [$query];\n\n        if (isset($options['foreignKeys'])) {\n            foreach ((array) $options['foreignKeys'] as $definition) {\n                $sql[] = $this->getCreateForeignKeySQL($definition, $name);\n            }\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @return string\n     */\n    public function getCreateTemporaryTableSnippetSQL()\n    {\n        return 'CREATE TEMPORARY TABLE';\n    }\n\n    /**\n     * Returns the SQL to create a sequence on this platform.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getCreateSequenceSQL(Sequence $sequence)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to change a sequence on this platform.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getAlterSequenceSQL(Sequence $sequence)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to create a constraint on a table on this platform.\n     *\n     * @param Table|string $table\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getCreateConstraintSQL(Constraint $constraint, $table)\n    {\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        $query = 'ALTER TABLE ' . $table . ' ADD CONSTRAINT ' . $constraint->getQuotedName($this);\n\n        $columnList = '(' . implode(', ', $constraint->getQuotedColumns($this)) . ')';\n\n        $referencesClause = '';\n        if ($constraint instanceof Index) {\n            if ($constraint->isPrimary()) {\n                $query .= ' PRIMARY KEY';\n            } elseif ($constraint->isUnique()) {\n                $query .= ' UNIQUE';\n            } else {\n                throw new InvalidArgumentException(\n                    'Can only create primary or unique constraints, no common indexes with getCreateConstraintSQL().'\n                );\n            }\n        } elseif ($constraint instanceof UniqueConstraint) {\n            $query .= ' UNIQUE';\n        } elseif ($constraint instanceof ForeignKeyConstraint) {\n            $query .= ' FOREIGN KEY';\n\n            $referencesClause = ' REFERENCES ' . $constraint->getQuotedForeignTableName($this) .\n                ' (' . implode(', ', $constraint->getQuotedForeignColumns($this)) . ')';\n        }\n\n        $query .= ' ' . $columnList . $referencesClause;\n\n        return $query;\n    }\n\n    /**\n     * Returns the SQL to create an index on a table on this platform.\n     *\n     * @param Table|string $table The name of the table on which the index is to be created.\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getCreateIndexSQL(Index $index, $table)\n    {\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        $name    = $index->getQuotedName($this);\n        $columns = $index->getColumns();\n\n        if (count($columns) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'columns' required.\");\n        }\n\n        if ($index->isPrimary()) {\n            return $this->getCreatePrimaryKeySQL($index, $table);\n        }\n\n        $query  = 'CREATE ' . $this->getCreateIndexSQLFlags($index) . 'INDEX ' . $name . ' ON ' . $table;\n        $query .= ' (' . $this->getIndexFieldDeclarationListSQL($index) . ')' . $this->getPartialIndexSQL($index);\n\n        return $query;\n    }\n\n    /**\n     * Adds condition for partial index.\n     *\n     * @return string\n     */\n    protected function getPartialIndexSQL(Index $index)\n    {\n        if ($this->supportsPartialIndexes() && $index->hasOption('where')) {\n            return ' WHERE ' . $index->getOption('where');\n        }\n\n        return '';\n    }\n\n    /**\n     * Adds additional flags for index generation.\n     *\n     * @return string\n     */\n    protected function getCreateIndexSQLFlags(Index $index)\n    {\n        return $index->isUnique() ? 'UNIQUE ' : '';\n    }\n\n    /**\n     * Returns the SQL to create an unnamed primary key constraint.\n     *\n     * @param Table|string $table\n     *\n     * @return string\n     */\n    public function getCreatePrimaryKeySQL(Index $index, $table)\n    {\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        return 'ALTER TABLE ' . $table . ' ADD PRIMARY KEY (' . $this->getIndexFieldDeclarationListSQL($index) . ')';\n    }\n\n    /**\n     * Returns the SQL to create a named schema.\n     *\n     * @param string $schemaName\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getCreateSchemaSQL($schemaName)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Quotes a string so that it can be safely used as a table or column name,\n     * even if it is a reserved word of the platform. This also detects identifier\n     * chains separated by dot and quotes them independently.\n     *\n     * NOTE: Just because you CAN use quoted identifiers doesn't mean\n     * you SHOULD use them. In general, they end up causing way more\n     * problems than they solve.\n     *\n     * @param string $str The identifier name to be quoted.\n     *\n     * @return string The quoted identifier string.\n     */\n    public function quoteIdentifier($str)\n    {\n        if (strpos($str, '.') !== false) {\n            $parts = array_map([$this, 'quoteSingleIdentifier'], explode('.', $str));\n\n            return implode('.', $parts);\n        }\n\n        return $this->quoteSingleIdentifier($str);\n    }\n\n    /**\n     * Quotes a single identifier (no dot chain separation).\n     *\n     * @param string $str The identifier name to be quoted.\n     *\n     * @return string The quoted identifier string.\n     */\n    public function quoteSingleIdentifier($str)\n    {\n        $c = $this->getIdentifierQuoteCharacter();\n\n        return $c . str_replace($c, $c . $c, $str) . $c;\n    }\n\n    /**\n     * Returns the SQL to create a new foreign key.\n     *\n     * @param ForeignKeyConstraint $foreignKey The foreign key constraint.\n     * @param Table|string         $table      The name of the table on which the foreign key is to be created.\n     *\n     * @return string\n     */\n    public function getCreateForeignKeySQL(ForeignKeyConstraint $foreignKey, $table)\n    {\n        if ($table instanceof Table) {\n            $table = $table->getQuotedName($this);\n        }\n\n        return 'ALTER TABLE ' . $table . ' ADD ' . $this->getForeignKeyDeclarationSQL($foreignKey);\n    }\n\n    /**\n     * Gets the SQL statements for altering an existing table.\n     *\n     * This method returns an array of SQL statements, since some platforms need several statements.\n     *\n     * @return string[]\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getAlterTableSQL(TableDiff $diff)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param mixed[] $columnSql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTableAddColumn(Column $column, TableDiff $diff, &$columnSql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTableAddColumn)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableAddColumnEventArgs($column, $diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTableAddColumn, $eventArgs);\n\n        $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @param string[] $columnSql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTableRemoveColumn(Column $column, TableDiff $diff, &$columnSql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTableRemoveColumn)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableRemoveColumnEventArgs($column, $diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTableRemoveColumn, $eventArgs);\n\n        $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @param string[] $columnSql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTableChangeColumn(ColumnDiff $columnDiff, TableDiff $diff, &$columnSql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTableChangeColumn)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableChangeColumnEventArgs($columnDiff, $diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTableChangeColumn, $eventArgs);\n\n        $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @param string   $oldColumnName\n     * @param string[] $columnSql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTableRenameColumn($oldColumnName, Column $column, TableDiff $diff, &$columnSql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTableRenameColumn)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableRenameColumnEventArgs($oldColumnName, $column, $diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTableRenameColumn, $eventArgs);\n\n        $columnSql = array_merge($columnSql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @param string[] $sql\n     *\n     * @return bool\n     */\n    protected function onSchemaAlterTable(TableDiff $diff, &$sql)\n    {\n        if ($this->_eventManager === null) {\n            return false;\n        }\n\n        if (! $this->_eventManager->hasListeners(Events::onSchemaAlterTable)) {\n            return false;\n        }\n\n        $eventArgs = new SchemaAlterTableEventArgs($diff, $this);\n        $this->_eventManager->dispatchEvent(Events::onSchemaAlterTable, $eventArgs);\n\n        $sql = array_merge($sql, $eventArgs->getSql());\n\n        return $eventArgs->isDefaultPrevented();\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getPreAlterTableIndexForeignKeySQL(TableDiff $diff)\n    {\n        $tableName = $diff->getName($this)->getQuotedName($this);\n\n        $sql = [];\n        if ($this->supportsForeignKeyConstraints()) {\n            foreach ($diff->removedForeignKeys as $foreignKey) {\n                $sql[] = $this->getDropForeignKeySQL($foreignKey, $tableName);\n            }\n\n            foreach ($diff->changedForeignKeys as $foreignKey) {\n                $sql[] = $this->getDropForeignKeySQL($foreignKey, $tableName);\n            }\n        }\n\n        foreach ($diff->removedIndexes as $index) {\n            $sql[] = $this->getDropIndexSQL($index, $tableName);\n        }\n\n        foreach ($diff->changedIndexes as $index) {\n            $sql[] = $this->getDropIndexSQL($index, $tableName);\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getPostAlterTableIndexForeignKeySQL(TableDiff $diff)\n    {\n        $sql     = [];\n        $newName = $diff->getNewName();\n\n        if ($newName !== false) {\n            $tableName = $newName->getQuotedName($this);\n        } else {\n            $tableName = $diff->getName($this)->getQuotedName($this);\n        }\n\n        if ($this->supportsForeignKeyConstraints()) {\n            foreach ($diff->addedForeignKeys as $foreignKey) {\n                $sql[] = $this->getCreateForeignKeySQL($foreignKey, $tableName);\n            }\n\n            foreach ($diff->changedForeignKeys as $foreignKey) {\n                $sql[] = $this->getCreateForeignKeySQL($foreignKey, $tableName);\n            }\n        }\n\n        foreach ($diff->addedIndexes as $index) {\n            $sql[] = $this->getCreateIndexSQL($index, $tableName);\n        }\n\n        foreach ($diff->changedIndexes as $index) {\n            $sql[] = $this->getCreateIndexSQL($index, $tableName);\n        }\n\n        foreach ($diff->renamedIndexes as $oldIndexName => $index) {\n            $oldIndexName = new Identifier($oldIndexName);\n            $sql          = array_merge(\n                $sql,\n                $this->getRenameIndexSQL($oldIndexName->getQuotedName($this), $index, $tableName)\n            );\n        }\n\n        return $sql;\n    }\n\n    /**\n     * Returns the SQL for renaming an index on a table.\n     *\n     * @param string $oldIndexName The name of the index to rename from.\n     * @param Index  $index        The definition of the index to rename to.\n     * @param string $tableName    The table to rename the given index on.\n     *\n     * @return string[] The sequence of SQL statements for renaming the given index.\n     */\n    protected function getRenameIndexSQL($oldIndexName, Index $index, $tableName)\n    {\n        return [\n            $this->getDropIndexSQL($oldIndexName, $tableName),\n            $this->getCreateIndexSQL($index, $tableName),\n        ];\n    }\n\n    /**\n     * Gets declaration of a number of columns in bulk.\n     *\n     * @param mixed[][] $columns A multidimensional associative array.\n     *                           The first dimension determines the column name, while the second\n     *                           dimension is keyed with the name of the properties\n     *                           of the column being declared as array indexes. Currently, the types\n     *                           of supported column properties are as follows:\n     *\n     *      length\n     *          Integer value that determines the maximum length of the text\n     *          column. If this argument is missing the column should be\n     *          declared to have the longest length allowed by the DBMS.\n     *\n     *      default\n     *          Text value to be used as default for this column.\n     *\n     *      notnull\n     *          Boolean flag that indicates whether this column is constrained\n     *          to not be set to null.\n     *      charset\n     *          Text value with the default CHARACTER SET for this column.\n     *      collation\n     *          Text value with the default COLLATION for this column.\n     *      unique\n     *          unique constraint\n     *\n     * @return string\n     */\n    public function getColumnDeclarationListSQL(array $columns)\n    {\n        $declarations = [];\n\n        foreach ($columns as $name => $column) {\n            $declarations[] = $this->getColumnDeclarationSQL($name, $column);\n        }\n\n        return implode(', ', $declarations);\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to declare a generic type\n     * column to be used in statements like CREATE TABLE.\n     *\n     * @param string  $name   The name the column to be declared.\n     * @param mixed[] $column An associative array with the name of the properties\n     *                        of the column being declared as array indexes. Currently, the types\n     *                        of supported column properties are as follows:\n     *\n     *      length\n     *          Integer value that determines the maximum length of the text\n     *          column. If this argument is missing the column should be\n     *          declared to have the longest length allowed by the DBMS.\n     *\n     *      default\n     *          Text value to be used as default for this column.\n     *\n     *      notnull\n     *          Boolean flag that indicates whether this column is constrained\n     *          to not be set to null.\n     *      charset\n     *          Text value with the default CHARACTER SET for this column.\n     *      collation\n     *          Text value with the default COLLATION for this column.\n     *      unique\n     *          unique constraint\n     *      check\n     *          column check constraint\n     *      columnDefinition\n     *          a string that defines the complete column\n     *\n     * @return string DBMS specific SQL code portion that should be used to declare the column.\n     *\n     * @throws Exception\n     */\n    public function getColumnDeclarationSQL($name, array $column)\n    {\n        if (isset($column['columnDefinition'])) {\n            $declaration = $this->getCustomTypeDeclarationSQL($column);\n        } else {\n            $default = $this->getDefaultValueDeclarationSQL($column);\n\n            $charset = ! empty($column['charset']) ?\n                ' ' . $this->getColumnCharsetDeclarationSQL($column['charset']) : '';\n\n            $collation = ! empty($column['collation']) ?\n                ' ' . $this->getColumnCollationDeclarationSQL($column['collation']) : '';\n\n            $notnull = ! empty($column['notnull']) ? ' NOT NULL' : '';\n\n            $unique = ! empty($column['unique']) ?\n                ' ' . $this->getUniqueFieldDeclarationSQL() : '';\n\n            $check = ! empty($column['check']) ? ' ' . $column['check'] : '';\n\n            $typeDecl    = $column['type']->getSQLDeclaration($column, $this);\n            $declaration = $typeDecl . $charset . $default . $notnull . $unique . $check . $collation;\n\n            if ($this->supportsInlineColumnComments() && isset($column['comment']) && $column['comment'] !== '') {\n                $declaration .= ' ' . $this->getInlineColumnCommentSQL($column['comment']);\n            }\n        }\n\n        return $name . ' ' . $declaration;\n    }\n\n    /**\n     * Returns the SQL snippet that declares a floating point column of arbitrary precision.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getDecimalTypeDeclarationSQL(array $column)\n    {\n        $column['precision'] = ! isset($column['precision']) || empty($column['precision'])\n            ? 10 : $column['precision'];\n        $column['scale']     = ! isset($column['scale']) || empty($column['scale'])\n            ? 0 : $column['scale'];\n\n        return 'NUMERIC(' . $column['precision'] . ', ' . $column['scale'] . ')';\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set a default value\n     * declaration to be used in statements like CREATE TABLE.\n     *\n     * @param mixed[] $column The column definition array.\n     *\n     * @return string DBMS specific SQL code portion needed to set a default value.\n     */\n    public function getDefaultValueDeclarationSQL($column)\n    {\n        if (! isset($column['default'])) {\n            return empty($column['notnull']) ? ' DEFAULT NULL' : '';\n        }\n\n        $default = $column['default'];\n\n        if (! isset($column['type'])) {\n            return \" DEFAULT '\" . $default . \"'\";\n        }\n\n        $type = $column['type'];\n\n        if ($type instanceof Types\\PhpIntegerMappingType) {\n            return ' DEFAULT ' . $default;\n        }\n\n        if ($type instanceof Types\\PhpDateTimeMappingType && $default === $this->getCurrentTimestampSQL()) {\n            return ' DEFAULT ' . $this->getCurrentTimestampSQL();\n        }\n\n        if ($type instanceof Types\\TimeType && $default === $this->getCurrentTimeSQL()) {\n            return ' DEFAULT ' . $this->getCurrentTimeSQL();\n        }\n\n        if ($type instanceof Types\\DateType && $default === $this->getCurrentDateSQL()) {\n            return ' DEFAULT ' . $this->getCurrentDateSQL();\n        }\n\n        if ($type instanceof Types\\BooleanType) {\n            return \" DEFAULT '\" . $this->convertBooleans($default) . \"'\";\n        }\n\n        return ' DEFAULT ' . $this->quoteStringLiteral($default);\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set a CHECK constraint\n     * declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string[]|mixed[][] $definition The check definition.\n     *\n     * @return string DBMS specific SQL code portion needed to set a CHECK constraint.\n     */\n    public function getCheckDeclarationSQL(array $definition)\n    {\n        $constraints = [];\n        foreach ($definition as $column => $def) {\n            if (is_string($def)) {\n                $constraints[] = 'CHECK (' . $def . ')';\n            } else {\n                if (isset($def['min'])) {\n                    $constraints[] = 'CHECK (' . $column . ' >= ' . $def['min'] . ')';\n                }\n\n                if (isset($def['max'])) {\n                    $constraints[] = 'CHECK (' . $column . ' <= ' . $def['max'] . ')';\n                }\n            }\n        }\n\n        return implode(', ', $constraints);\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set a unique\n     * constraint declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string           $name       The name of the unique constraint.\n     * @param UniqueConstraint $constraint The unique constraint definition.\n     *\n     * @return string DBMS specific SQL code portion needed to set a constraint.\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getUniqueConstraintDeclarationSQL($name, UniqueConstraint $constraint)\n    {\n        $columns = $constraint->getQuotedColumns($this);\n        $name    = new Identifier($name);\n\n        if (count($columns) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'columns' required.\");\n        }\n\n        $constraintFlags = array_merge(['UNIQUE'], array_map('strtoupper', $constraint->getFlags()));\n        $constraintName  = $name->getQuotedName($this);\n        $columnListNames = $this->getColumnsFieldDeclarationListSQL($columns);\n\n        return sprintf('CONSTRAINT %s %s (%s)', $constraintName, implode(' ', $constraintFlags), $columnListNames);\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set an index\n     * declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string $name  The name of the index.\n     * @param Index  $index The index definition.\n     *\n     * @return string DBMS specific SQL code portion needed to set an index.\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getIndexDeclarationSQL($name, Index $index)\n    {\n        $columns = $index->getColumns();\n        $name    = new Identifier($name);\n\n        if (count($columns) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'columns' required.\");\n        }\n\n        return $this->getCreateIndexSQLFlags($index) . 'INDEX ' . $name->getQuotedName($this)\n            . ' (' . $this->getIndexFieldDeclarationListSQL($index) . ')' . $this->getPartialIndexSQL($index);\n    }\n\n    /**\n     * Obtains SQL code portion needed to create a custom column,\n     * e.g. when a column has the \"columnDefinition\" keyword.\n     * Only \"AUTOINCREMENT\" and \"PRIMARY KEY\" are added if appropriate.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getCustomTypeDeclarationSQL(array $column)\n    {\n        return $column['columnDefinition'];\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set an index\n     * declaration to be used in statements like CREATE TABLE.\n     */\n    public function getIndexFieldDeclarationListSQL(Index $index): string\n    {\n        return implode(', ', $index->getQuotedColumns($this));\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set an index\n     * declaration to be used in statements like CREATE TABLE.\n     *\n     * @param mixed[] $columns\n     */\n    public function getColumnsFieldDeclarationListSQL(array $columns): string\n    {\n        $ret = [];\n\n        foreach ($columns as $column => $definition) {\n            if (is_array($definition)) {\n                $ret[] = $column;\n            } else {\n                $ret[] = $definition;\n            }\n        }\n\n        return implode(', ', $ret);\n    }\n\n    /**\n     * Returns the required SQL string that fits between CREATE ... TABLE\n     * to create the table as a temporary table.\n     *\n     * Should be overridden in driver classes to return the correct string for the\n     * specific database type.\n     *\n     * The default is to return the string \"TEMPORARY\" - this will result in a\n     * SQL error for any database that does not support temporary tables, or that\n     * requires a different SQL command from \"CREATE TEMPORARY TABLE\".\n     *\n     * @return string The string required to be placed between \"CREATE\" and \"TABLE\"\n     *                to generate a temporary table, if possible.\n     */\n    public function getTemporaryTableSQL()\n    {\n        return 'TEMPORARY';\n    }\n\n    /**\n     * Some vendors require temporary table names to be qualified specially.\n     *\n     * @param string $tableName\n     *\n     * @return string\n     */\n    public function getTemporaryTableName($tableName)\n    {\n        return $tableName;\n    }\n\n    /**\n     * Obtain DBMS specific SQL code portion needed to set the FOREIGN KEY constraint\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @return string DBMS specific SQL code portion needed to set the FOREIGN KEY constraint\n     *                of a column declaration.\n     */\n    public function getForeignKeyDeclarationSQL(ForeignKeyConstraint $foreignKey)\n    {\n        $sql  = $this->getForeignKeyBaseDeclarationSQL($foreignKey);\n        $sql .= $this->getAdvancedForeignKeyOptionsSQL($foreignKey);\n\n        return $sql;\n    }\n\n    /**\n     * Returns the FOREIGN KEY query section dealing with non-standard options\n     * as MATCH, INITIALLY DEFERRED, ON UPDATE, ...\n     *\n     * @param ForeignKeyConstraint $foreignKey The foreign key definition.\n     *\n     * @return string\n     */\n    public function getAdvancedForeignKeyOptionsSQL(ForeignKeyConstraint $foreignKey)\n    {\n        $query = '';\n        if ($foreignKey->hasOption('onUpdate')) {\n            $query .= ' ON UPDATE ' . $this->getForeignKeyReferentialActionSQL($foreignKey->getOption('onUpdate'));\n        }\n\n        if ($foreignKey->hasOption('onDelete')) {\n            $query .= ' ON DELETE ' . $this->getForeignKeyReferentialActionSQL($foreignKey->getOption('onDelete'));\n        }\n\n        return $query;\n    }\n\n    /**\n     * Returns the given referential action in uppercase if valid, otherwise throws an exception.\n     *\n     * @param string $action The foreign key referential action.\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException If unknown referential action given.\n     */\n    public function getForeignKeyReferentialActionSQL($action)\n    {\n        $upper = strtoupper($action);\n        switch ($upper) {\n            case 'CASCADE':\n            case 'SET NULL':\n            case 'NO ACTION':\n            case 'RESTRICT':\n            case 'SET DEFAULT':\n                return $upper;\n\n            default:\n                throw new InvalidArgumentException('Invalid foreign key action: ' . $upper);\n        }\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set the FOREIGN KEY constraint\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    public function getForeignKeyBaseDeclarationSQL(ForeignKeyConstraint $foreignKey)\n    {\n        $sql = '';\n        if (strlen($foreignKey->getName()) > 0) {\n            $sql .= 'CONSTRAINT ' . $foreignKey->getQuotedName($this) . ' ';\n        }\n\n        $sql .= 'FOREIGN KEY (';\n\n        if (count($foreignKey->getLocalColumns()) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'local' required.\");\n        }\n\n        if (count($foreignKey->getForeignColumns()) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'foreign' required.\");\n        }\n\n        if (strlen($foreignKey->getForeignTableName()) === 0) {\n            throw new InvalidArgumentException(\"Incomplete definition. 'foreignTable' required.\");\n        }\n\n        return $sql . implode(', ', $foreignKey->getQuotedLocalColumns($this))\n            . ') REFERENCES '\n            . $foreignKey->getQuotedForeignTableName($this) . ' ('\n            . implode(', ', $foreignKey->getQuotedForeignColumns($this)) . ')';\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set the UNIQUE constraint\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @return string DBMS specific SQL code portion needed to set the UNIQUE constraint\n     *                of a column declaration.\n     */\n    public function getUniqueFieldDeclarationSQL()\n    {\n        return 'UNIQUE';\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set the CHARACTER SET\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string $charset The name of the charset.\n     *\n     * @return string DBMS specific SQL code portion needed to set the CHARACTER SET\n     *                of a column declaration.\n     */\n    public function getColumnCharsetDeclarationSQL($charset)\n    {\n        return '';\n    }\n\n    /**\n     * Obtains DBMS specific SQL code portion needed to set the COLLATION\n     * of a column declaration to be used in statements like CREATE TABLE.\n     *\n     * @param string $collation The name of the collation.\n     *\n     * @return string DBMS specific SQL code portion needed to set the COLLATION\n     *                of a column declaration.\n     */\n    public function getColumnCollationDeclarationSQL($collation)\n    {\n        return $this->supportsColumnCollation() ? 'COLLATE ' . $collation : '';\n    }\n\n    /**\n     * Whether the platform prefers identity columns (eg. autoincrement) for ID generation.\n     * Subclasses should override this method to return TRUE if they prefer identity columns.\n     *\n     * @return bool\n     */\n    public function prefersIdentityColumns()\n    {\n        return false;\n    }\n\n    /**\n     * Some platforms need the boolean values to be converted.\n     *\n     * The default conversion in this implementation converts to integers (false => 0, true => 1).\n     *\n     * Note: if the input is not a boolean the original input might be returned.\n     *\n     * There are two contexts when converting booleans: Literals and Prepared Statements.\n     * This method should handle the literal case\n     *\n     * @param mixed $item A boolean or an array of them.\n     *\n     * @return mixed A boolean database value or an array of them.\n     */\n    public function convertBooleans($item)\n    {\n        if (is_array($item)) {\n            foreach ($item as $k => $value) {\n                if (! is_bool($value)) {\n                    continue;\n                }\n\n                $item[$k] = (int) $value;\n            }\n        } elseif (is_bool($item)) {\n            $item = (int) $item;\n        }\n\n        return $item;\n    }\n\n    /**\n     * Some platforms have boolean literals that needs to be correctly converted\n     *\n     * The default conversion tries to convert value into bool \"(bool)$item\"\n     *\n     * @param mixed $item\n     *\n     * @return bool|null\n     */\n    public function convertFromBoolean($item)\n    {\n        return $item === null ? null : (bool) $item;\n    }\n\n    /**\n     * This method should handle the prepared statements case. When there is no\n     * distinction, it's OK to use the same method.\n     *\n     * Note: if the input is not a boolean the original input might be returned.\n     *\n     * @param mixed $item A boolean or an array of them.\n     *\n     * @return mixed A boolean database value or an array of them.\n     */\n    public function convertBooleansToDatabaseValue($item)\n    {\n        return $this->convertBooleans($item);\n    }\n\n    /**\n     * Returns the SQL specific for the platform to get the current date.\n     *\n     * @return string\n     */\n    public function getCurrentDateSQL()\n    {\n        return 'CURRENT_DATE';\n    }\n\n    /**\n     * Returns the SQL specific for the platform to get the current time.\n     *\n     * @return string\n     */\n    public function getCurrentTimeSQL()\n    {\n        return 'CURRENT_TIME';\n    }\n\n    /**\n     * Returns the SQL specific for the platform to get the current timestamp\n     *\n     * @return string\n     */\n    public function getCurrentTimestampSQL()\n    {\n        return 'CURRENT_TIMESTAMP';\n    }\n\n    /**\n     * Returns the SQL for a given transaction isolation level Connection constant.\n     *\n     * @param int $level\n     *\n     * @return string\n     *\n     * @throws InvalidArgumentException\n     */\n    protected function _getTransactionIsolationLevelSQL($level)\n    {\n        switch ($level) {\n            case TransactionIsolationLevel::READ_UNCOMMITTED:\n                return 'READ UNCOMMITTED';\n\n            case TransactionIsolationLevel::READ_COMMITTED:\n                return 'READ COMMITTED';\n\n            case TransactionIsolationLevel::REPEATABLE_READ:\n                return 'REPEATABLE READ';\n\n            case TransactionIsolationLevel::SERIALIZABLE:\n                return 'SERIALIZABLE';\n\n            default:\n                throw new InvalidArgumentException('Invalid isolation level:' . $level);\n        }\n    }\n\n    /**\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListDatabasesSQL()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL statement for retrieving the namespaces defined in the database.\n     *\n     * @deprecated Use {@link AbstractSchemaManager::listSchemaNames()} instead.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListNamespacesSQL()\n    {\n        Deprecation::triggerIfCalledFromOutside(\n            'doctrine/dbal',\n            'https://github.com/doctrine/dbal/issues/4503',\n            'AbstractPlatform::getListNamespacesSQL() is deprecated,'\n                . ' use AbstractSchemaManager::listSchemaNames() instead.'\n        );\n\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $database\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListSequencesSQL($database)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $table\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTableConstraintsSQL($table)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $table\n     * @param string $database\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTableColumnsSQL($table, $database = null)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTablesSQL()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListUsersSQL()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to list all views of a database or user.\n     *\n     * @param string $database\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListViewsSQL($database)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the list of indexes for the current database.\n     *\n     * The current database parameter is optional but will always be passed\n     * when using the SchemaManager API and is the database the given table is in.\n     *\n     * Attention: Some platforms only support currentDatabase when they\n     * are connected with that database. Cross-database information schema\n     * requests may be impossible.\n     *\n     * @param string $table\n     * @param string $database\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTableIndexesSQL($table, $database = null)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $table\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getListTableForeignKeysSQL($table)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $name\n     * @param string $sql\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getCreateViewSQL($name, $sql)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $name\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDropViewSQL($name)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL snippet to drop an existing sequence.\n     *\n     * @param Sequence|string $sequence\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDropSequenceSQL($sequence)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param string $sequence\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getSequenceNextValSQL($sequence)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to create a new database.\n     *\n     * @param string $name The name of the database that should be created.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getCreateDatabaseSQL($name)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Returns the SQL to set the transaction isolation level.\n     *\n     * @param int $level\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getSetTransactionIsolationSQL($level)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Obtains DBMS specific SQL to be used to create datetime columns in\n     * statements like CREATE TABLE.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateTimeTypeDeclarationSQL(array $column)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Obtains DBMS specific SQL to be used to create datetime with timezone offset columns.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getDateTimeTzTypeDeclarationSQL(array $column)\n    {\n        return $this->getDateTimeTypeDeclarationSQL($column);\n    }\n\n    /**\n     * Obtains DBMS specific SQL to be used to create date columns in statements\n     * like CREATE TABLE.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDateTypeDeclarationSQL(array $column)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Obtains DBMS specific SQL to be used to create time columns in statements\n     * like CREATE TABLE.\n     *\n     * @param mixed[] $column\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getTimeTypeDeclarationSQL(array $column)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * @param mixed[] $column\n     *\n     * @return string\n     */\n    public function getFloatDeclarationSQL(array $column)\n    {\n        return 'DOUBLE PRECISION';\n    }\n\n    /**\n     * Gets the default transaction isolation level of the platform.\n     *\n     * @see TransactionIsolationLevel\n     *\n     * @return int The default isolation level.\n     */\n    public function getDefaultTransactionIsolationLevel()\n    {\n        return TransactionIsolationLevel::READ_COMMITTED;\n    }\n\n    /* supports*() methods */\n\n    /**\n     * Whether the platform supports sequences.\n     *\n     * @return bool\n     */\n    public function supportsSequences()\n    {\n        return false;\n    }\n\n    /**\n     * Whether the platform supports identity columns.\n     *\n     * Identity columns are columns that receive an auto-generated value from the\n     * database on insert of a row.\n     *\n     * @return bool\n     */\n    public function supportsIdentityColumns()\n    {\n        return false;\n    }\n\n    /**\n     * Whether the platform emulates identity columns through sequences.\n     *\n     * Some platforms that do not support identity columns natively\n     * but support sequences can emulate identity columns by using\n     * sequences.\n     *\n     * @return bool\n     */\n    public function usesSequenceEmulatedIdentityColumns()\n    {\n        return false;\n    }\n\n    /**\n     * Returns the name of the sequence for a particular identity column in a particular table.\n     *\n     * @see usesSequenceEmulatedIdentityColumns\n     *\n     * @param string $tableName  The name of the table to return the sequence name for.\n     * @param string $columnName The name of the identity column in the table to return the sequence name for.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getIdentitySequenceName($tableName, $columnName)\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Whether the platform supports indexes.\n     *\n     * @return bool\n     */\n    public function supportsIndexes()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports partial indexes.\n     *\n     * @return bool\n     */\n    public function supportsPartialIndexes()\n    {\n        return false;\n    }\n\n    /**\n     * Whether the platform supports indexes with column length definitions.\n     */\n    public function supportsColumnLengthIndexes(): bool\n    {\n        return false;\n    }\n\n    /**\n     * Whether the platform supports altering tables.\n     *\n     * @return bool\n     */\n    public function supportsAlterTable()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports transactions.\n     *\n     * @return bool\n     */\n    public function supportsTransactions()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports savepoints.\n     *\n     * @return bool\n     */\n    public function supportsSavepoints()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports releasing savepoints.\n     *\n     * @return bool\n     */\n    public function supportsReleaseSavepoints()\n    {\n        return $this->supportsSavepoints();\n    }\n\n    /**\n     * Whether the platform supports primary key constraints.\n     *\n     * @return bool\n     */\n    public function supportsPrimaryConstraints()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports foreign key constraints.\n     *\n     * @return bool\n     */\n    public function supportsForeignKeyConstraints()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports database schemas.\n     *\n     * @return bool\n     */\n    public function supportsSchemas()\n    {\n        return false;\n    }\n\n    /**\n     * Whether this platform can emulate schemas.\n     *\n     * Platforms that either support or emulate schemas don't automatically\n     * filter a schema for the namespaced elements in {@link AbstractManager::createSchema()}.\n     *\n     * @return bool\n     */\n    public function canEmulateSchemas()\n    {\n        return false;\n    }\n\n    /**\n     * Returns the default schema name.\n     *\n     * @return string\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    public function getDefaultSchemaName()\n    {\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Whether this platform supports create database.\n     *\n     * Some databases don't allow to create and drop databases at all or only with certain tools.\n     *\n     * @return bool\n     */\n    public function supportsCreateDropDatabase()\n    {\n        return true;\n    }\n\n    /**\n     * Whether the platform supports getting the affected rows of a recent update/delete type query.\n     *\n     * @return bool\n     */\n    public function supportsGettingAffectedRows()\n    {\n        return true;\n    }\n\n    /**\n     * Whether this platform support to add inline column comments as postfix.\n     *\n     * @return bool\n     */\n    public function supportsInlineColumnComments()\n    {\n        return false;\n    }\n\n    /**\n     * Whether this platform support the proprietary syntax \"COMMENT ON asset\".\n     *\n     * @return bool\n     */\n    public function supportsCommentOnStatement()\n    {\n        return false;\n    }\n\n    /**\n     * Does this platform have native guid type.\n     *\n     * @return bool\n     */\n    public function hasNativeGuidType()\n    {\n        return false;\n    }\n\n    /**\n     * Does this platform have native JSON type.\n     *\n     * @return bool\n     */\n    public function hasNativeJsonType()\n    {\n        return false;\n    }\n\n    /**\n     * Whether this platform supports views.\n     *\n     * @return bool\n     */\n    public function supportsViews()\n    {\n        return true;\n    }\n\n    /**\n     * Does this platform support column collation?\n     *\n     * @return bool\n     */\n    public function supportsColumnCollation()\n    {\n        return false;\n    }\n\n    /**\n     * Gets the format string, as accepted by the date() function, that describes\n     * the format of a stored datetime value of this platform.\n     *\n     * @return string The format string.\n     */\n    public function getDateTimeFormatString()\n    {\n        return 'Y-m-d H:i:s';\n    }\n\n    /**\n     * Gets the format string, as accepted by the date() function, that describes\n     * the format of a stored datetime with timezone value of this platform.\n     *\n     * @return string The format string.\n     */\n    public function getDateTimeTzFormatString()\n    {\n        return 'Y-m-d H:i:s';\n    }\n\n    /**\n     * Gets the format string, as accepted by the date() function, that describes\n     * the format of a stored date value of this platform.\n     *\n     * @return string The format string.\n     */\n    public function getDateFormatString()\n    {\n        return 'Y-m-d';\n    }\n\n    /**\n     * Gets the format string, as accepted by the date() function, that describes\n     * the format of a stored time value of this platform.\n     *\n     * @return string The format string.\n     */\n    public function getTimeFormatString()\n    {\n        return 'H:i:s';\n    }\n\n    /**\n     * Adds an driver-specific LIMIT clause to the query.\n     *\n     * @param string   $query\n     * @param int|null $limit\n     * @param int      $offset\n     *\n     * @return string\n     *\n     * @throws Exception\n     */\n    final public function modifyLimitQuery($query, $limit, $offset = 0)\n    {\n        if ($offset < 0) {\n            throw new Exception(sprintf(\n                'Offset must be a positive integer or zero, %d given',\n                $offset\n            ));\n        }\n\n        if ($offset > 0 && ! $this->supportsLimitOffset()) {\n            throw new Exception(sprintf(\n                'Platform %s does not support offset values in limit queries.',\n                $this->getName()\n            ));\n        }\n\n        if ($limit !== null) {\n            $limit = (int) $limit;\n        }\n\n        return $this->doModifyLimitQuery($query, $limit, (int) $offset);\n    }\n\n    /**\n     * Adds an platform-specific LIMIT clause to the query.\n     *\n     * @param string   $query\n     * @param int|null $limit\n     * @param int      $offset\n     *\n     * @return string\n     */\n    protected function doModifyLimitQuery($query, $limit, $offset)\n    {\n        if ($limit !== null) {\n            $query .= ' LIMIT ' . $limit;\n        }\n\n        if ($offset > 0) {\n            $query .= ' OFFSET ' . $offset;\n        }\n\n        return $query;\n    }\n\n    /**\n     * Whether the database platform support offsets in modify limit clauses.\n     *\n     * @return bool\n     */\n    public function supportsLimitOffset()\n    {\n        return true;\n    }\n\n    /**\n     * Maximum length of any given database identifier, like tables or column names.\n     *\n     * @return int\n     */\n    public function getMaxIdentifierLength()\n    {\n        return 63;\n    }\n\n    /**\n     * Returns the insert SQL for an empty insert statement.\n     *\n     * @param string $quotedTableName\n     * @param string $quotedIdentifierColumnName\n     *\n     * @return string\n     */\n    public function getEmptyIdentityInsertSQL($quotedTableName, $quotedIdentifierColumnName)\n    {\n        return 'INSERT INTO ' . $quotedTableName . ' (' . $quotedIdentifierColumnName . ') VALUES (null)';\n    }\n\n    /**\n     * Generates a Truncate Table SQL statement for a given table.\n     *\n     * Cascade is not supported on many platforms but would optionally cascade the truncate by\n     * following the foreign keys.\n     *\n     * @param string $tableName\n     * @param bool   $cascade\n     *\n     * @return string\n     */\n    public function getTruncateTableSQL($tableName, $cascade = false)\n    {\n        $tableIdentifier = new Identifier($tableName);\n\n        return 'TRUNCATE ' . $tableIdentifier->getQuotedName($this);\n    }\n\n    /**\n     * This is for test reasons, many vendors have special requirements for dummy statements.\n     *\n     * @return string\n     */\n    public function getDummySelectSQL()\n    {\n        $expression = func_num_args() > 0 ? func_get_arg(0) : '1';\n\n        return sprintf('SELECT %s', $expression);\n    }\n\n    /**\n     * Returns the SQL to create a new savepoint.\n     *\n     * @param string $savepoint\n     *\n     * @return string\n     */\n    public function createSavePoint($savepoint)\n    {\n        return 'SAVEPOINT ' . $savepoint;\n    }\n\n    /**\n     * Returns the SQL to release a savepoint.\n     *\n     * @param string $savepoint\n     *\n     * @return string\n     */\n    public function releaseSavePoint($savepoint)\n    {\n        return 'RELEASE SAVEPOINT ' . $savepoint;\n    }\n\n    /**\n     * Returns the SQL to rollback a savepoint.\n     *\n     * @param string $savepoint\n     *\n     * @return string\n     */\n    public function rollbackSavePoint($savepoint)\n    {\n        return 'ROLLBACK TO SAVEPOINT ' . $savepoint;\n    }\n\n    /**\n     * Returns the keyword list instance of this platform.\n     *\n     * @return KeywordList\n     *\n     * @throws Exception If no keyword list is specified.\n     */\n    final public function getReservedKeywordsList()\n    {\n        // Check for an existing instantiation of the keywords class.\n        if ($this->_keywords === null) {\n            // Store the instance so it doesn't need to be generated on every request.\n            $this->_keywords = $this->createReservedKeywordsList();\n        }\n\n        return $this->_keywords;\n    }\n\n    /**\n     * Creates an instance of the reserved keyword list of this platform.\n     *\n     * This method will become @abstract in DBAL 4.0.0.\n     *\n     * @throws Exception\n     */\n    protected function createReservedKeywordsList(): KeywordList\n    {\n        $class    = $this->getReservedKeywordsClass();\n        $keywords = new $class();\n        if (! $keywords instanceof KeywordList) {\n            throw Exception::notSupported(__METHOD__);\n        }\n\n        return $keywords;\n    }\n\n    /**\n     * Returns the class name of the reserved keywords list.\n     *\n     * @deprecated Implement {@link createReservedKeywordsList()} instead.\n     *\n     * @return string\n     * @psalm-return class-string<KeywordList>\n     *\n     * @throws Exception If not supported on this platform.\n     */\n    protected function getReservedKeywordsClass()\n    {\n        Deprecation::triggerIfCalledFromOutside(\n            'doctrine/dbal',\n            'https://github.com/doctrine/dbal/issues/4510',\n            'AbstractPlatform::getReservedKeywordsClass() is deprecated,'\n                . ' use AbstractPlatform::createReservedKeywordsList() instead.'\n        );\n\n        throw Exception::notSupported(__METHOD__);\n    }\n\n    /**\n     * Quotes a literal string.\n     * This method is NOT meant to fix SQL injections!\n     * It is only meant to escape this platform's string literal\n     * quote character inside the given literal string.\n     *\n     * @param string $str The literal string to be quoted.\n     *\n     * @return string The quoted literal string.\n     */\n    public function quoteStringLiteral($str)\n    {\n        $c = $this->getStringLiteralQuoteCharacter();\n\n        return $c . str_replace($c, $c . $c, $str) . $c;\n    }\n\n    /**\n     * Gets the character used for string literal quoting.\n     *\n     * @return string\n     */\n    public function getStringLiteralQuoteCharacter()\n    {\n        return \"'\";\n    }\n\n    /**\n     * Escapes metacharacters in a string intended to be used with a LIKE\n     * operator.\n     *\n     * @param string $inputString a literal, unquoted string\n     * @param string $escapeChar  should be reused by the caller in the LIKE\n     *                            expression.\n     */\n    final public function escapeStringForLike(string $inputString, string $escapeChar): string\n    {\n        return preg_replace(\n            '~([' . preg_quote($this->getLikeWildcardCharacters() . $escapeChar, '~') . '])~u',\n            addcslashes($escapeChar, '\\\\') . '$1',\n            $inputString\n        );\n    }\n\n    /**\n     * @internal\n     */\n    public function createSQLParser(): Parser\n    {\n        return new Parser(false);\n    }\n\n    protected function getLikeWildcardCharacters(): string\n    {\n        return '%_';\n    }\n}\n", "<?php\n\nnamespace Doctrine\\DBAL\\Tests\\Platforms;\n\nuse Doctrine\\Common\\EventManager;\nuse Doctrine\\DBAL\\Events;\nuse Doctrine\\DBAL\\Exception;\nuse Doctrine\\DBAL\\Exception\\InvalidLockMode;\nuse Doctrine\\DBAL\\Platforms\\AbstractPlatform;\nuse Doctrine\\DBAL\\Platforms\\Keywords\\KeywordList;\nuse Doctrine\\DBAL\\Schema\\Column;\nuse Doctrine\\DBAL\\Schema\\ColumnDiff;\nuse Doctrine\\DBAL\\Schema\\Comparator;\nuse Doctrine\\DBAL\\Schema\\ForeignKeyConstraint;\nuse Doctrine\\DBAL\\Schema\\Index;\nuse Doctrine\\DBAL\\Schema\\Table;\nuse Doctrine\\DBAL\\Schema\\TableDiff;\nuse Doctrine\\DBAL\\Schema\\UniqueConstraint;\nuse Doctrine\\DBAL\\Types\\Type;\nuse InvalidArgumentException;\nuse PHPUnit\\Framework\\TestCase;\n\nuse function get_class;\nuse function implode;\nuse function sprintf;\nuse function str_repeat;\n\n/**\n * @template T of AbstractPlatform\n */\nabstract class AbstractPlatformTestCase extends TestCase\n{\n    /** @var T */\n    protected $platform;\n\n    /**\n     * @return T\n     */\n    abstract public function createPlatform(): AbstractPlatform;\n\n    protected function setUp(): void\n    {\n        $this->platform = $this->createPlatform();\n    }\n\n    public function testQuoteIdentifier(): void\n    {\n        if ($this->platform->getName() === 'mssql') {\n            self::markTestSkipped('Not working this way on mssql.');\n        }\n\n        $c = $this->platform->getIdentifierQuoteCharacter();\n        self::assertEquals($c . 'test' . $c, $this->platform->quoteIdentifier('test'));\n        self::assertEquals($c . 'test' . $c . '.' . $c . 'test' . $c, $this->platform->quoteIdentifier('test.test'));\n        self::assertEquals(str_repeat($c, 4), $this->platform->quoteIdentifier($c));\n    }\n\n    public function testQuoteSingleIdentifier(): void\n    {\n        if ($this->platform->getName() === 'mssql') {\n            self::markTestSkipped('Not working this way on mssql.');\n        }\n\n        $c = $this->platform->getIdentifierQuoteCharacter();\n        self::assertEquals($c . 'test' . $c, $this->platform->quoteSingleIdentifier('test'));\n        self::assertEquals($c . 'test.test' . $c, $this->platform->quoteSingleIdentifier('test.test'));\n        self::assertEquals(str_repeat($c, 4), $this->platform->quoteSingleIdentifier($c));\n    }\n\n    /**\n     * @dataProvider getReturnsForeignKeyReferentialActionSQL\n     */\n    public function testReturnsForeignKeyReferentialActionSQL(string $action, string $expectedSQL): void\n    {\n        self::assertSame($expectedSQL, $this->platform->getForeignKeyReferentialActionSQL($action));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getReturnsForeignKeyReferentialActionSQL(): iterable\n    {\n        return [\n            ['CASCADE', 'CASCADE'],\n            ['SET NULL', 'SET NULL'],\n            ['NO ACTION', 'NO ACTION'],\n            ['RESTRICT', 'RESTRICT'],\n            ['SET DEFAULT', 'SET DEFAULT'],\n            ['CaScAdE', 'CASCADE'],\n        ];\n    }\n\n    public function testGetInvalidForeignKeyReferentialActionSQL(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->platform->getForeignKeyReferentialActionSQL('unknown');\n    }\n\n    public function testGetUnknownDoctrineMappingType(): void\n    {\n        $this->expectException(Exception::class);\n        $this->platform->getDoctrineTypeMapping('foobar');\n    }\n\n    public function testRegisterDoctrineMappingType(): void\n    {\n        $this->platform->registerDoctrineTypeMapping('foo', 'integer');\n        self::assertEquals('integer', $this->platform->getDoctrineTypeMapping('foo'));\n    }\n\n    public function testRegisterUnknownDoctrineMappingType(): void\n    {\n        $this->expectException(Exception::class);\n        $this->platform->registerDoctrineTypeMapping('foo', 'bar');\n    }\n\n    public function testRegistersCommentedDoctrineMappingTypeImplicitly(): void\n    {\n        $type = Type::getType('array');\n        $this->platform->registerDoctrineTypeMapping('foo', 'array');\n\n        self::assertTrue($this->platform->isCommentedDoctrineType($type));\n    }\n\n    /**\n     * @dataProvider getIsCommentedDoctrineType\n     */\n    public function testIsCommentedDoctrineType(Type $type, bool $commented): void\n    {\n        self::assertSame($commented, $this->platform->isCommentedDoctrineType($type));\n    }\n\n    /**\n     * @return mixed[]\n     */\n    public function getIsCommentedDoctrineType(): iterable\n    {\n        $this->setUp();\n\n        $data = [];\n\n        foreach (Type::getTypesMap() as $typeName => $className) {\n            $type = Type::getType($typeName);\n\n            $data[$typeName] = [\n                $type,\n                $type->requiresSQLCommentHint($this->platform),\n            ];\n        }\n\n        return $data;\n    }\n\n    public function testCreateWithNoColumns(): void\n    {\n        $table = new Table('test');\n\n        $this->expectException(Exception::class);\n        $this->platform->getCreateTableSQL($table);\n    }\n\n    public function testGeneratesTableCreationSql(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer', ['notnull' => true, 'autoincrement' => true]);\n        $table->addColumn('test', 'string', ['notnull' => false, 'length' => 255]);\n        $table->setPrimaryKey(['id']);\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getGenerateTableSql(), $sql[0]);\n    }\n\n    abstract public function getGenerateTableSql(): string;\n\n    public function testGenerateTableWithMultiColumnUniqueIndex(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('foo', 'string', ['notnull' => false, 'length' => 255]);\n        $table->addColumn('bar', 'string', ['notnull' => false, 'length' => 255]);\n        $table->addUniqueIndex(['foo', 'bar']);\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getGenerateTableWithMultiColumnUniqueIndexSql(), $sql);\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract public function getGenerateTableWithMultiColumnUniqueIndexSql(): array;\n\n    public function testGeneratesIndexCreationSql(): void\n    {\n        $indexDef = new Index('my_idx', ['user_name', 'last_login']);\n\n        self::assertEquals(\n            $this->getGenerateIndexSql(),\n            $this->platform->getCreateIndexSQL($indexDef, 'mytable')\n        );\n    }\n\n    abstract public function getGenerateIndexSql(): string;\n\n    public function testGeneratesUniqueIndexCreationSql(): void\n    {\n        $indexDef = new Index('index_name', ['test', 'test2'], true);\n\n        $sql = $this->platform->getCreateIndexSQL($indexDef, 'test');\n        self::assertEquals($this->getGenerateUniqueIndexSql(), $sql);\n    }\n\n    abstract public function getGenerateUniqueIndexSql(): string;\n\n    public function testGeneratesPartialIndexesSqlOnlyWhenSupportingPartialIndexes(): void\n    {\n        $where            = 'test IS NULL AND test2 IS NOT NULL';\n        $indexDef         = new Index('name', ['test', 'test2'], false, false, [], ['where' => $where]);\n        $uniqueConstraint = new UniqueConstraint('name', ['test', 'test2'], [], []);\n\n        $expected = ' WHERE ' . $where;\n\n        $indexes = [];\n\n        if ($this->supportsInlineIndexDeclaration()) {\n            $indexes[] = $this->platform->getIndexDeclarationSQL('name', $indexDef);\n        }\n\n        $uniqueConstraintSQL = $this->platform->getUniqueConstraintDeclarationSQL('name', $uniqueConstraint);\n        $this->assertStringEndsNotWith($expected, $uniqueConstraintSQL, 'WHERE clause should NOT be present');\n\n        $indexes[] = $this->platform->getCreateIndexSQL($indexDef, 'table');\n\n        foreach ($indexes as $index) {\n            if ($this->platform->supportsPartialIndexes()) {\n                self::assertStringEndsWith($expected, $index, 'WHERE clause should be present');\n            } else {\n                self::assertStringEndsNotWith($expected, $index, 'WHERE clause should NOT be present');\n            }\n        }\n    }\n\n    public function testGeneratesForeignKeyCreationSql(): void\n    {\n        $fk = new ForeignKeyConstraint(['fk_name_id'], 'other_table', ['id'], '');\n\n        $sql = $this->platform->getCreateForeignKeySQL($fk, 'test');\n        self::assertEquals($sql, $this->getGenerateForeignKeySql());\n    }\n\n    abstract protected function getGenerateForeignKeySql(): string;\n\n    public function testGeneratesConstraintCreationSql(): void\n    {\n        $idx = new Index('constraint_name', ['test'], true, false);\n        $sql = $this->platform->getCreateConstraintSQL($idx, 'test');\n        self::assertEquals($this->getGenerateConstraintUniqueIndexSql(), $sql);\n\n        $pk  = new Index('constraint_name', ['test'], true, true);\n        $sql = $this->platform->getCreateConstraintSQL($pk, 'test');\n        self::assertEquals($this->getGenerateConstraintPrimaryIndexSql(), $sql);\n\n        $uc  = new UniqueConstraint('constraint_name', ['test']);\n        $sql = $this->platform->getCreateConstraintSQL($uc, 'test');\n        self::assertEquals($this->getGenerateConstraintUniqueIndexSql(), $sql);\n\n        $fk  = new ForeignKeyConstraint(['fk_name'], 'foreign', ['id'], 'constraint_fk');\n        $sql = $this->platform->getCreateConstraintSQL($fk, 'test');\n        self::assertEquals($this->getGenerateConstraintForeignKeySql($fk), $sql);\n    }\n\n    public function testGeneratesForeignKeySqlOnlyWhenSupportingForeignKeys(): void\n    {\n        $fk = new ForeignKeyConstraint(['fk_name'], 'foreign', ['id'], 'constraint_fk');\n\n        if ($this->platform->supportsForeignKeyConstraints()) {\n            self::assertIsString($this->platform->getCreateForeignKeySQL($fk, 'test'));\n        } else {\n            $this->expectException(Exception::class);\n            $this->platform->getCreateForeignKeySQL($fk, 'test');\n        }\n    }\n\n    protected function getBitAndComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return '(' . $value1 . ' & ' . $value2 . ')';\n    }\n\n    public function testGeneratesBitAndComparisonExpressionSql(): void\n    {\n        $sql = $this->platform->getBitAndComparisonExpression(2, 4);\n        self::assertEquals($this->getBitAndComparisonExpressionSql(2, 4), $sql);\n    }\n\n    protected function getBitOrComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return '(' . $value1 . ' | ' . $value2 . ')';\n    }\n\n    public function testGeneratesBitOrComparisonExpressionSql(): void\n    {\n        $sql = $this->platform->getBitOrComparisonExpression(2, 4);\n        self::assertEquals($this->getBitOrComparisonExpressionSql(2, 4), $sql);\n    }\n\n    public function getGenerateConstraintUniqueIndexSql(): string\n    {\n        return 'ALTER TABLE test ADD CONSTRAINT constraint_name UNIQUE (test)';\n    }\n\n    public function getGenerateConstraintPrimaryIndexSql(): string\n    {\n        return 'ALTER TABLE test ADD CONSTRAINT constraint_name PRIMARY KEY (test)';\n    }\n\n    public function getGenerateConstraintForeignKeySql(ForeignKeyConstraint $fk): string\n    {\n        $quotedForeignTable = $fk->getQuotedForeignTableName($this->platform);\n\n        return sprintf(\n            'ALTER TABLE test ADD CONSTRAINT constraint_fk FOREIGN KEY (fk_name) REFERENCES %s (id)',\n            $quotedForeignTable\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract public function getGenerateAlterTableSql(): array;\n\n    public function testGeneratesTableAlterationSql(): void\n    {\n        $expectedSql = $this->getGenerateAlterTableSql();\n\n        $table = new Table('mytable');\n        $table->addColumn('id', 'integer', ['autoincrement' => true]);\n        $table->addColumn('foo', 'integer');\n        $table->addColumn('bar', 'string');\n        $table->addColumn('bloo', 'boolean');\n        $table->setPrimaryKey(['id']);\n\n        $tableDiff                         = new TableDiff('mytable');\n        $tableDiff->fromTable              = $table;\n        $tableDiff->newName                = 'userlist';\n        $tableDiff->addedColumns['quota']  = new Column('quota', Type::getType('integer'), ['notnull' => false]);\n        $tableDiff->removedColumns['foo']  = new Column('foo', Type::getType('integer'));\n        $tableDiff->changedColumns['bar']  = new ColumnDiff(\n            'bar',\n            new Column(\n                'baz',\n                Type::getType('string'),\n                ['default' => 'def']\n            ),\n            ['type', 'notnull', 'default']\n        );\n        $tableDiff->changedColumns['bloo'] = new ColumnDiff(\n            'bloo',\n            new Column(\n                'bloo',\n                Type::getType('boolean'),\n                ['default' => false]\n            ),\n            ['type', 'notnull', 'default']\n        );\n\n        $sql = $this->platform->getAlterTableSQL($tableDiff);\n\n        self::assertEquals($expectedSql, $sql);\n    }\n\n    public function testGetCustomColumnDeclarationSql(): void\n    {\n        self::assertEquals(\n            'foo MEDIUMINT(6) UNSIGNED',\n            $this->platform->getColumnDeclarationSQL('foo', ['columnDefinition' => 'MEDIUMINT(6) UNSIGNED'])\n        );\n    }\n\n    public function testGetCreateTableSqlDispatchEvent(): void\n    {\n        $listenerMock = $this->createMock(GetCreateTableSqlDispatchEventListener::class);\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaCreateTable');\n        $listenerMock\n            ->expects(self::exactly(2))\n            ->method('onSchemaCreateTableColumn');\n\n        $eventManager = new EventManager();\n        $eventManager->addEventListener([\n            Events::onSchemaCreateTable,\n            Events::onSchemaCreateTableColumn,\n        ], $listenerMock);\n\n        $this->platform->setEventManager($eventManager);\n\n        $table = new Table('test');\n        $table->addColumn('foo', 'string', ['notnull' => false, 'length' => 255]);\n        $table->addColumn('bar', 'string', ['notnull' => false, 'length' => 255]);\n\n        $this->platform->getCreateTableSQL($table);\n    }\n\n    public function testGetDropTableSqlDispatchEvent(): void\n    {\n        $listenerMock = $this->createMock(GetDropTableSqlDispatchEventListener::class);\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaDropTable');\n\n        $eventManager = new EventManager();\n        $eventManager->addEventListener([Events::onSchemaDropTable], $listenerMock);\n\n        $this->platform->setEventManager($eventManager);\n\n        $this->platform->getDropTableSQL('TABLE');\n    }\n\n    public function testGetAlterTableSqlDispatchEvent(): void\n    {\n        $listenerMock = $this->createMock(GetAlterTableSqlDispatchEventListener::class);\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTable');\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTableAddColumn');\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTableRemoveColumn');\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTableChangeColumn');\n        $listenerMock\n            ->expects(self::once())\n            ->method('onSchemaAlterTableRenameColumn');\n\n        $eventManager = new EventManager();\n        $events       = [\n            Events::onSchemaAlterTable,\n            Events::onSchemaAlterTableAddColumn,\n            Events::onSchemaAlterTableRemoveColumn,\n            Events::onSchemaAlterTableChangeColumn,\n            Events::onSchemaAlterTableRenameColumn,\n        ];\n        $eventManager->addEventListener($events, $listenerMock);\n\n        $this->platform->setEventManager($eventManager);\n\n        $table = new Table('mytable');\n        $table->addColumn('removed', 'integer');\n        $table->addColumn('changed', 'integer');\n        $table->addColumn('renamed', 'integer');\n\n        $tableDiff                            = new TableDiff('mytable');\n        $tableDiff->fromTable                 = $table;\n        $tableDiff->addedColumns['added']     = new Column('added', Type::getType('integer'), []);\n        $tableDiff->removedColumns['removed'] = new Column('removed', Type::getType('integer'), []);\n        $tableDiff->changedColumns['changed'] = new ColumnDiff(\n            'changed',\n            new Column(\n                'changed2',\n                Type::getType('string'),\n                []\n            ),\n            []\n        );\n        $tableDiff->renamedColumns['renamed'] = new Column('renamed2', Type::getType('integer'), []);\n\n        $this->platform->getAlterTableSQL($tableDiff);\n    }\n\n    public function testCreateTableColumnComments(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer', ['comment' => 'This is a comment']);\n        $table->setPrimaryKey(['id']);\n\n        self::assertEquals($this->getCreateTableColumnCommentsSQL(), $this->platform->getCreateTableSQL($table));\n    }\n\n    public function testAlterTableColumnComments(): void\n    {\n        $tableDiff                        = new TableDiff('mytable');\n        $tableDiff->addedColumns['quota'] = new Column('quota', Type::getType('integer'), ['comment' => 'A comment']);\n        $tableDiff->changedColumns['foo'] = new ColumnDiff(\n            'foo',\n            new Column(\n                'foo',\n                Type::getType('string')\n            ),\n            ['comment']\n        );\n        $tableDiff->changedColumns['bar'] = new ColumnDiff(\n            'bar',\n            new Column(\n                'baz',\n                Type::getType('string'),\n                ['comment' => 'B comment']\n            ),\n            ['comment']\n        );\n\n        self::assertEquals($this->getAlterTableColumnCommentsSQL(), $this->platform->getAlterTableSQL($tableDiff));\n    }\n\n    public function testCreateTableColumnTypeComments(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('data', 'array');\n        $table->setPrimaryKey(['id']);\n\n        self::assertEquals($this->getCreateTableColumnTypeCommentsSQL(), $this->platform->getCreateTableSQL($table));\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getCreateTableColumnCommentsSQL(): array\n    {\n        self::markTestSkipped('Platform does not support Column comments.');\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getAlterTableColumnCommentsSQL(): array\n    {\n        self::markTestSkipped('Platform does not support Column comments.');\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getCreateTableColumnTypeCommentsSQL(): array\n    {\n        self::markTestSkipped('Platform does not support Column comments.');\n    }\n\n    public function testGetDefaultValueDeclarationSQL(): void\n    {\n        // non-timestamp value will get single quotes\n        self::assertEquals(\" DEFAULT 'non_timestamp'\", $this->platform->getDefaultValueDeclarationSQL([\n            'type' => Type::getType('string'),\n            'default' => 'non_timestamp',\n        ]));\n    }\n\n    public function testGetDefaultValueDeclarationSQLDateTime(): void\n    {\n        // timestamps on datetime types should not be quoted\n        foreach (['datetime', 'datetimetz', 'datetime_immutable', 'datetimetz_immutable'] as $type) {\n            self::assertSame(\n                ' DEFAULT ' . $this->platform->getCurrentTimestampSQL(),\n                $this->platform->getDefaultValueDeclarationSQL([\n                    'type'    => Type::getType($type),\n                    'default' => $this->platform->getCurrentTimestampSQL(),\n                ])\n            );\n        }\n    }\n\n    public function testGetDefaultValueDeclarationSQLForIntegerTypes(): void\n    {\n        foreach (['bigint', 'integer', 'smallint'] as $type) {\n            self::assertEquals(\n                ' DEFAULT 1',\n                $this->platform->getDefaultValueDeclarationSQL([\n                    'type'    => Type::getType($type),\n                    'default' => 1,\n                ])\n            );\n        }\n    }\n\n    public function testGetDefaultValueDeclarationSQLForDateType(): void\n    {\n        $currentDateSql = $this->platform->getCurrentDateSQL();\n        foreach (['date', 'date_immutable'] as $type) {\n            self::assertSame(\n                ' DEFAULT ' . $currentDateSql,\n                $this->platform->getDefaultValueDeclarationSQL([\n                    'type'    => Type::getType($type),\n                    'default' => $currentDateSql,\n                ])\n            );\n        }\n    }\n\n    public function testKeywordList(): void\n    {\n        $keywordList = $this->platform->getReservedKeywordsList();\n        self::assertInstanceOf(KeywordList::class, $keywordList);\n\n        self::assertTrue($keywordList->isKeyword('table'));\n    }\n\n    public function testQuotedColumnInPrimaryKeyPropagation(): void\n    {\n        $table = new Table('`quoted`');\n        $table->addColumn('create', 'string');\n        $table->setPrimaryKey(['create']);\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getQuotedColumnInPrimaryKeySQL(), $sql);\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotedColumnInPrimaryKeySQL(): array;\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotedColumnInIndexSQL(): array;\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotedNameInIndexSQL(): array;\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotedColumnInForeignKeySQL(): array;\n\n    public function testQuotedColumnInIndexPropagation(): void\n    {\n        $table = new Table('`quoted`');\n        $table->addColumn('create', 'string');\n        $table->addIndex(['create']);\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getQuotedColumnInIndexSQL(), $sql);\n    }\n\n    public function testQuotedNameInIndexSQL(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('column1', 'string');\n        $table->addIndex(['column1'], '`key`');\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals($this->getQuotedNameInIndexSQL(), $sql);\n    }\n\n    public function testQuotedColumnInForeignKeyPropagation(): void\n    {\n        $table = new Table('`quoted`');\n        $table->addColumn('create', 'string');\n        $table->addColumn('foo', 'string');\n        $table->addColumn('`bar`', 'string');\n\n        // Foreign table with reserved keyword as name (needs quotation).\n        $foreignTable = new Table('foreign');\n\n        // Foreign column with reserved keyword as name (needs quotation).\n        $foreignTable->addColumn('create', 'string');\n\n        // Foreign column with non-reserved keyword as name (does not need quotation).\n        $foreignTable->addColumn('bar', 'string');\n\n        // Foreign table with special character in name (needs quotation on some platforms, e.g. Sqlite).\n        $foreignTable->addColumn('`foo-bar`', 'string');\n\n        $table->addForeignKeyConstraint(\n            $foreignTable,\n            ['create', 'foo', '`bar`'],\n            ['create', 'bar', '`foo-bar`'],\n            [],\n            'FK_WITH_RESERVED_KEYWORD'\n        );\n\n        // Foreign table with non-reserved keyword as name (does not need quotation).\n        $foreignTable = new Table('foo');\n\n        // Foreign column with reserved keyword as name (needs quotation).\n        $foreignTable->addColumn('create', 'string');\n\n        // Foreign column with non-reserved keyword as name (does not need quotation).\n        $foreignTable->addColumn('bar', 'string');\n\n        // Foreign table with special character in name (needs quotation on some platforms, e.g. Sqlite).\n        $foreignTable->addColumn('`foo-bar`', 'string');\n\n        $table->addForeignKeyConstraint(\n            $foreignTable,\n            ['create', 'foo', '`bar`'],\n            ['create', 'bar', '`foo-bar`'],\n            [],\n            'FK_WITH_NON_RESERVED_KEYWORD'\n        );\n\n        // Foreign table with special character in name (needs quotation on some platforms, e.g. Sqlite).\n        $foreignTable = new Table('`foo-bar`');\n\n        // Foreign column with reserved keyword as name (needs quotation).\n        $foreignTable->addColumn('create', 'string');\n\n        // Foreign column with non-reserved keyword as name (does not need quotation).\n        $foreignTable->addColumn('bar', 'string');\n\n        // Foreign table with special character in name (needs quotation on some platforms, e.g. Sqlite).\n        $foreignTable->addColumn('`foo-bar`', 'string');\n\n        $table->addForeignKeyConstraint(\n            $foreignTable,\n            ['create', 'foo', '`bar`'],\n            ['create', 'bar', '`foo-bar`'],\n            [],\n            'FK_WITH_INTENDED_QUOTATION'\n        );\n\n        $sql = $this->platform->getCreateTableSQL($table, AbstractPlatform::CREATE_FOREIGNKEYS);\n        self::assertEquals($this->getQuotedColumnInForeignKeySQL(), $sql);\n    }\n\n    public function testQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): void\n    {\n        $constraint = new UniqueConstraint('select', ['foo'], [], []);\n\n        self::assertSame(\n            $this->getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(),\n            $this->platform->getUniqueConstraintDeclarationSQL('select', $constraint)\n        );\n    }\n\n    abstract protected function getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): string;\n\n    public function testQuotesReservedKeywordInTruncateTableSQL(): void\n    {\n        self::assertSame(\n            $this->getQuotesReservedKeywordInTruncateTableSQL(),\n            $this->platform->getTruncateTableSQL('select')\n        );\n    }\n\n    abstract protected function getQuotesReservedKeywordInTruncateTableSQL(): string;\n\n    public function testQuotesReservedKeywordInIndexDeclarationSQL(): void\n    {\n        $index = new Index('select', ['foo']);\n\n        if (! $this->supportsInlineIndexDeclaration()) {\n            $this->expectException(Exception::class);\n        }\n\n        self::assertSame(\n            $this->getQuotesReservedKeywordInIndexDeclarationSQL(),\n            $this->platform->getIndexDeclarationSQL('select', $index)\n        );\n    }\n\n    abstract protected function getQuotesReservedKeywordInIndexDeclarationSQL(): string;\n\n    protected function supportsInlineIndexDeclaration(): bool\n    {\n        return true;\n    }\n\n    public function testSupportsCommentOnStatement(): void\n    {\n        self::assertSame($this->supportsCommentOnStatement(), $this->platform->supportsCommentOnStatement());\n    }\n\n    protected function supportsCommentOnStatement(): bool\n    {\n        return false;\n    }\n\n    public function testGetCreateSchemaSQL(): void\n    {\n        $this->expectException(Exception::class);\n\n        $this->platform->getCreateSchemaSQL('schema');\n    }\n\n    public function testAlterTableChangeQuotedColumn(): void\n    {\n        $table = new Table('mytable');\n        $table->addColumn('select', 'integer');\n\n        $tableDiff                           = new TableDiff('mytable');\n        $tableDiff->fromTable                = $table;\n        $tableDiff->changedColumns['select'] = new ColumnDiff(\n            'select',\n            new Column(\n                'select',\n                Type::getType('string')\n            ),\n            ['type']\n        );\n\n        self::assertStringContainsString(\n            $this->platform->quoteIdentifier('select'),\n            implode(';', $this->platform->getAlterTableSQL($tableDiff))\n        );\n    }\n\n    public function testUsesSequenceEmulatedIdentityColumns(): void\n    {\n        self::assertFalse($this->platform->usesSequenceEmulatedIdentityColumns());\n    }\n\n    /**\n     * @group DBAL-563\n     */\n    public function testReturnsIdentitySequenceName(): void\n    {\n        $this->expectException(Exception::class);\n\n        $this->platform->getIdentitySequenceName('mytable', 'mycolumn');\n    }\n\n    public function testReturnsBinaryDefaultLength(): void\n    {\n        self::assertSame($this->getBinaryDefaultLength(), $this->platform->getBinaryDefaultLength());\n    }\n\n    protected function getBinaryDefaultLength(): int\n    {\n        return 255;\n    }\n\n    public function testReturnsBinaryMaxLength(): void\n    {\n        self::assertSame($this->getBinaryMaxLength(), $this->platform->getBinaryMaxLength());\n    }\n\n    protected function getBinaryMaxLength(): int\n    {\n        return 4000;\n    }\n\n    public function testReturnsBinaryTypeDeclarationSQL(): void\n    {\n        $this->expectException(Exception::class);\n\n        $this->platform->getBinaryTypeDeclarationSQL([]);\n    }\n\n    public function testReturnsBinaryTypeLongerThanMaxDeclarationSQL(): void\n    {\n        $this->markTestSkipped('Not applicable to the platform');\n    }\n\n    public function hasNativeJsonType(): void\n    {\n        self::assertFalse($this->platform->hasNativeJsonType());\n    }\n\n    public function testReturnsJsonTypeDeclarationSQL(): void\n    {\n        $column = [\n            'length'  => 666,\n            'notnull' => true,\n            'type'    => Type::getType('json'),\n        ];\n\n        self::assertSame(\n            $this->platform->getClobTypeDeclarationSQL($column),\n            $this->platform->getJsonTypeDeclarationSQL($column)\n        );\n    }\n\n    public function testAlterTableRenameIndex(): void\n    {\n        $tableDiff            = new TableDiff('mytable');\n        $tableDiff->fromTable = new Table('mytable');\n        $tableDiff->fromTable->addColumn('id', 'integer');\n        $tableDiff->fromTable->setPrimaryKey(['id']);\n        $tableDiff->renamedIndexes = [\n            'idx_foo' => new Index('idx_bar', ['id']),\n        ];\n\n        self::assertSame(\n            $this->getAlterTableRenameIndexSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getAlterTableRenameIndexSQL(): array\n    {\n        return [\n            'DROP INDEX idx_foo',\n            'CREATE INDEX idx_bar ON mytable (id)',\n        ];\n    }\n\n    public function testQuotesAlterTableRenameIndex(): void\n    {\n        $tableDiff            = new TableDiff('table');\n        $tableDiff->fromTable = new Table('table');\n        $tableDiff->fromTable->addColumn('id', 'integer');\n        $tableDiff->fromTable->setPrimaryKey(['id']);\n        $tableDiff->renamedIndexes = [\n            'create' => new Index('select', ['id']),\n            '`foo`'  => new Index('`bar`', ['id']),\n        ];\n\n        self::assertSame(\n            $this->getQuotedAlterTableRenameIndexSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getQuotedAlterTableRenameIndexSQL(): array\n    {\n        return [\n            'DROP INDEX \"create\"',\n            'CREATE INDEX \"select\" ON \"table\" (id)',\n            'DROP INDEX \"foo\"',\n            'CREATE INDEX \"bar\" ON \"table\" (id)',\n        ];\n    }\n\n    public function testQuotesAlterTableRenameColumn(): void\n    {\n        $fromTable = new Table('mytable');\n\n        $fromTable->addColumn('unquoted1', 'integer', ['comment' => 'Unquoted 1']);\n        $fromTable->addColumn('unquoted2', 'integer', ['comment' => 'Unquoted 2']);\n        $fromTable->addColumn('unquoted3', 'integer', ['comment' => 'Unquoted 3']);\n\n        $fromTable->addColumn('create', 'integer', ['comment' => 'Reserved keyword 1']);\n        $fromTable->addColumn('table', 'integer', ['comment' => 'Reserved keyword 2']);\n        $fromTable->addColumn('select', 'integer', ['comment' => 'Reserved keyword 3']);\n\n        $fromTable->addColumn('`quoted1`', 'integer', ['comment' => 'Quoted 1']);\n        $fromTable->addColumn('`quoted2`', 'integer', ['comment' => 'Quoted 2']);\n        $fromTable->addColumn('`quoted3`', 'integer', ['comment' => 'Quoted 3']);\n\n        $toTable = new Table('mytable');\n\n        // unquoted -> unquoted\n        $toTable->addColumn('unquoted', 'integer', ['comment' => 'Unquoted 1']);\n\n        // unquoted -> reserved keyword\n        $toTable->addColumn('where', 'integer', ['comment' => 'Unquoted 2']);\n\n        // unquoted -> quoted\n        $toTable->addColumn('`foo`', 'integer', ['comment' => 'Unquoted 3']);\n\n        // reserved keyword -> unquoted\n        $toTable->addColumn('reserved_keyword', 'integer', ['comment' => 'Reserved keyword 1']);\n\n        // reserved keyword -> reserved keyword\n        $toTable->addColumn('from', 'integer', ['comment' => 'Reserved keyword 2']);\n\n        // reserved keyword -> quoted\n        $toTable->addColumn('`bar`', 'integer', ['comment' => 'Reserved keyword 3']);\n\n        // quoted -> unquoted\n        $toTable->addColumn('quoted', 'integer', ['comment' => 'Quoted 1']);\n\n        // quoted -> reserved keyword\n        $toTable->addColumn('and', 'integer', ['comment' => 'Quoted 2']);\n\n        // quoted -> quoted\n        $toTable->addColumn('`baz`', 'integer', ['comment' => 'Quoted 3']);\n\n        $diff = (new Comparator())->diffTable($fromTable, $toTable);\n        self::assertNotFalse($diff);\n\n        self::assertEquals(\n            $this->getQuotedAlterTableRenameColumnSQL(),\n            $this->platform->getAlterTableSQL($diff)\n        );\n    }\n\n    /**\n     * Returns SQL statements for {@link testQuotesAlterTableRenameColumn}.\n     *\n     * @return string[]\n     */\n    abstract protected function getQuotedAlterTableRenameColumnSQL(): array;\n\n    public function testQuotesAlterTableChangeColumnLength(): void\n    {\n        $fromTable = new Table('mytable');\n\n        $fromTable->addColumn('unquoted1', 'string', ['comment' => 'Unquoted 1', 'length' => 10]);\n        $fromTable->addColumn('unquoted2', 'string', ['comment' => 'Unquoted 2', 'length' => 10]);\n        $fromTable->addColumn('unquoted3', 'string', ['comment' => 'Unquoted 3', 'length' => 10]);\n\n        $fromTable->addColumn('create', 'string', ['comment' => 'Reserved keyword 1', 'length' => 10]);\n        $fromTable->addColumn('table', 'string', ['comment' => 'Reserved keyword 2', 'length' => 10]);\n        $fromTable->addColumn('select', 'string', ['comment' => 'Reserved keyword 3', 'length' => 10]);\n\n        $toTable = new Table('mytable');\n\n        $toTable->addColumn('unquoted1', 'string', ['comment' => 'Unquoted 1', 'length' => 255]);\n        $toTable->addColumn('unquoted2', 'string', ['comment' => 'Unquoted 2', 'length' => 255]);\n        $toTable->addColumn('unquoted3', 'string', ['comment' => 'Unquoted 3', 'length' => 255]);\n\n        $toTable->addColumn('create', 'string', ['comment' => 'Reserved keyword 1', 'length' => 255]);\n        $toTable->addColumn('table', 'string', ['comment' => 'Reserved keyword 2', 'length' => 255]);\n        $toTable->addColumn('select', 'string', ['comment' => 'Reserved keyword 3', 'length' => 255]);\n\n        $diff = (new Comparator())->diffTable($fromTable, $toTable);\n        self::assertNotFalse($diff);\n\n        self::assertEquals(\n            $this->getQuotedAlterTableChangeColumnLengthSQL(),\n            $this->platform->getAlterTableSQL($diff)\n        );\n    }\n\n    /**\n     * Returns SQL statements for {@link testQuotesAlterTableChangeColumnLength}.\n     *\n     * @return string[]\n     */\n    abstract protected function getQuotedAlterTableChangeColumnLengthSQL(): array;\n\n    public function testAlterTableRenameIndexInSchema(): void\n    {\n        $tableDiff            = new TableDiff('myschema.mytable');\n        $tableDiff->fromTable = new Table('myschema.mytable');\n        $tableDiff->fromTable->addColumn('id', 'integer');\n        $tableDiff->fromTable->setPrimaryKey(['id']);\n        $tableDiff->renamedIndexes = [\n            'idx_foo' => new Index('idx_bar', ['id']),\n        ];\n\n        self::assertSame(\n            $this->getAlterTableRenameIndexInSchemaSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return [\n            'DROP INDEX idx_foo',\n            'CREATE INDEX idx_bar ON myschema.mytable (id)',\n        ];\n    }\n\n    public function testQuotesAlterTableRenameIndexInSchema(): void\n    {\n        $tableDiff            = new TableDiff('`schema`.table');\n        $tableDiff->fromTable = new Table('`schema`.table');\n        $tableDiff->fromTable->addColumn('id', 'integer');\n        $tableDiff->fromTable->setPrimaryKey(['id']);\n        $tableDiff->renamedIndexes = [\n            'create' => new Index('select', ['id']),\n            '`foo`'  => new Index('`bar`', ['id']),\n        ];\n\n        self::assertSame(\n            $this->getQuotedAlterTableRenameIndexInSchemaSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    protected function getQuotedAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return [\n            'DROP INDEX \"schema\".\"create\"',\n            'CREATE INDEX \"select\" ON \"schema\".\"table\" (id)',\n            'DROP INDEX \"schema\".\"foo\"',\n            'CREATE INDEX \"bar\" ON \"schema\".\"table\" (id)',\n        ];\n    }\n\n    public function testQuotesDropForeignKeySQL(): void\n    {\n        if (! $this->platform->supportsForeignKeyConstraints()) {\n            $this->markTestSkipped(\n                sprintf('%s does not support foreign key constraints.', get_class($this->platform))\n            );\n        }\n\n        $tableName      = 'table';\n        $table          = new Table($tableName);\n        $foreignKeyName = 'select';\n        $foreignKey     = new ForeignKeyConstraint([], 'foo', [], 'select');\n        $expectedSql    = $this->getQuotesDropForeignKeySQL();\n\n        self::assertSame($expectedSql, $this->platform->getDropForeignKeySQL($foreignKeyName, $tableName));\n        self::assertSame($expectedSql, $this->platform->getDropForeignKeySQL($foreignKey, $table));\n    }\n\n    protected function getQuotesDropForeignKeySQL(): string\n    {\n        return 'ALTER TABLE \"table\" DROP FOREIGN KEY \"select\"';\n    }\n\n    public function testQuotesDropConstraintSQL(): void\n    {\n        $tableName      = 'table';\n        $table          = new Table($tableName);\n        $constraintName = 'select';\n        $constraint     = new ForeignKeyConstraint([], 'foo', [], 'select');\n        $expectedSql    = $this->getQuotesDropConstraintSQL();\n\n        self::assertSame($expectedSql, $this->platform->getDropConstraintSQL($constraintName, $tableName));\n        self::assertSame($expectedSql, $this->platform->getDropConstraintSQL($constraint, $table));\n    }\n\n    protected function getQuotesDropConstraintSQL(): string\n    {\n        return 'ALTER TABLE \"table\" DROP CONSTRAINT \"select\"';\n    }\n\n    protected function getStringLiteralQuoteCharacter(): string\n    {\n        return \"'\";\n    }\n\n    public function testGetStringLiteralQuoteCharacter(): void\n    {\n        self::assertSame($this->getStringLiteralQuoteCharacter(), $this->platform->getStringLiteralQuoteCharacter());\n    }\n\n    protected function getQuotedCommentOnColumnSQLWithoutQuoteCharacter(): string\n    {\n        return \"COMMENT ON COLUMN mytable.id IS 'This is a comment'\";\n    }\n\n    public function testGetCommentOnColumnSQLWithoutQuoteCharacter(): void\n    {\n        self::assertEquals(\n            $this->getQuotedCommentOnColumnSQLWithoutQuoteCharacter(),\n            $this->platform->getCommentOnColumnSQL('mytable', 'id', 'This is a comment')\n        );\n    }\n\n    protected function getQuotedCommentOnColumnSQLWithQuoteCharacter(): string\n    {\n        return \"COMMENT ON COLUMN mytable.id IS 'It''s a quote !'\";\n    }\n\n    public function testGetCommentOnColumnSQLWithQuoteCharacter(): void\n    {\n        $c = $this->getStringLiteralQuoteCharacter();\n\n        self::assertEquals(\n            $this->getQuotedCommentOnColumnSQLWithQuoteCharacter(),\n            $this->platform->getCommentOnColumnSQL('mytable', 'id', 'It' . $c . 's a quote !')\n        );\n    }\n\n    /**\n     * @see testGetCommentOnColumnSQL\n     *\n     * @return string[]\n     */\n    abstract protected function getCommentOnColumnSQL(): array;\n\n    public function testGetCommentOnColumnSQL(): void\n    {\n        self::assertSame(\n            $this->getCommentOnColumnSQL(),\n            [\n                $this->platform->getCommentOnColumnSQL('foo', 'bar', 'comment'), // regular identifiers\n                $this->platform->getCommentOnColumnSQL('`Foo`', '`BAR`', 'comment'), // explicitly quoted identifiers\n                $this->platform->getCommentOnColumnSQL('select', 'from', 'comment'), // reserved keyword identifiers\n            ]\n        );\n    }\n\n    /**\n     * @dataProvider getGeneratesInlineColumnCommentSQL\n     */\n    public function testGeneratesInlineColumnCommentSQL(string $comment, string $expectedSql): void\n    {\n        if (! $this->platform->supportsInlineColumnComments()) {\n            self::markTestSkipped(sprintf('%s does not support inline column comments.', get_class($this->platform)));\n        }\n\n        self::assertSame($expectedSql, $this->platform->getInlineColumnCommentSQL($comment));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesInlineColumnCommentSQL(): iterable\n    {\n        return [\n            'regular comment' => ['Regular comment', static::getInlineColumnRegularCommentSQL()],\n            'comment requiring escaping' => [\n                sprintf(\n                    'Using inline comment delimiter %s works',\n                    static::getInlineColumnCommentDelimiter()\n                ),\n                static::getInlineColumnCommentRequiringEscapingSQL(),\n            ],\n            'empty comment' => ['', static::getInlineColumnEmptyCommentSQL()],\n        ];\n    }\n\n    protected static function getInlineColumnCommentDelimiter(): string\n    {\n        return \"'\";\n    }\n\n    protected static function getInlineColumnRegularCommentSQL(): string\n    {\n        return \"COMMENT 'Regular comment'\";\n    }\n\n    protected static function getInlineColumnCommentRequiringEscapingSQL(): string\n    {\n        return \"COMMENT 'Using inline comment delimiter '' works'\";\n    }\n\n    protected static function getInlineColumnEmptyCommentSQL(): string\n    {\n        return \"COMMENT ''\";\n    }\n\n    protected function getQuotedStringLiteralWithoutQuoteCharacter(): string\n    {\n        return \"'No quote'\";\n    }\n\n    protected function getQuotedStringLiteralWithQuoteCharacter(): string\n    {\n        return \"'It''s a quote'\";\n    }\n\n    protected function getQuotedStringLiteralQuoteCharacter(): string\n    {\n        return \"''''\";\n    }\n\n    public function testThrowsExceptionOnGeneratingInlineColumnCommentSQLIfUnsupported(): void\n    {\n        if ($this->platform->supportsInlineColumnComments()) {\n            self::markTestSkipped(sprintf('%s supports inline column comments.', get_class($this->platform)));\n        }\n\n        $this->expectException(Exception::class);\n        $this->expectExceptionMessage(\n            \"Operation '\" . AbstractPlatform::class . \"::getInlineColumnCommentSQL' is not supported by platform.\"\n        );\n        $this->expectExceptionCode(0);\n\n        $this->platform->getInlineColumnCommentSQL('unsupported');\n    }\n\n    public function testQuoteStringLiteral(): void\n    {\n        $c = $this->getStringLiteralQuoteCharacter();\n\n        self::assertEquals(\n            $this->getQuotedStringLiteralWithoutQuoteCharacter(),\n            $this->platform->quoteStringLiteral('No quote')\n        );\n        self::assertEquals(\n            $this->getQuotedStringLiteralWithQuoteCharacter(),\n            $this->platform->quoteStringLiteral('It' . $c . 's a quote')\n        );\n        self::assertEquals(\n            $this->getQuotedStringLiteralQuoteCharacter(),\n            $this->platform->quoteStringLiteral($c)\n        );\n    }\n\n    public function testReturnsGuidTypeDeclarationSQL(): void\n    {\n        $this->expectException(Exception::class);\n\n        $this->platform->getGuidTypeDeclarationSQL([]);\n    }\n\n    public function testGeneratesAlterTableRenameColumnSQL(): void\n    {\n        $table = new Table('foo');\n        $table->addColumn(\n            'bar',\n            'integer',\n            ['notnull' => true, 'default' => 666, 'comment' => 'rename test']\n        );\n\n        $tableDiff                        = new TableDiff('foo');\n        $tableDiff->fromTable             = $table;\n        $tableDiff->renamedColumns['bar'] = new Column(\n            'baz',\n            Type::getType('integer'),\n            ['notnull' => true, 'default' => 666, 'comment' => 'rename test']\n        );\n\n        self::assertSame($this->getAlterTableRenameColumnSQL(), $this->platform->getAlterTableSQL($tableDiff));\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract public function getAlterTableRenameColumnSQL(): array;\n\n    public function testQuotesTableIdentifiersInAlterTableSQL(): void\n    {\n        $table = new Table('\"foo\"');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('fk', 'integer');\n        $table->addColumn('fk2', 'integer');\n        $table->addColumn('fk3', 'integer');\n        $table->addColumn('bar', 'integer');\n        $table->addColumn('baz', 'integer');\n        $table->addForeignKeyConstraint('fk_table', ['fk'], ['id'], [], 'fk1');\n        $table->addForeignKeyConstraint('fk_table', ['fk2'], ['id'], [], 'fk2');\n\n        $tableDiff                        = new TableDiff('\"foo\"');\n        $tableDiff->fromTable             = $table;\n        $tableDiff->newName               = 'table';\n        $tableDiff->addedColumns['bloo']  = new Column('bloo', Type::getType('integer'));\n        $tableDiff->changedColumns['bar'] = new ColumnDiff(\n            'bar',\n            new Column('bar', Type::getType('integer'), ['notnull' => false]),\n            ['notnull'],\n            $table->getColumn('bar')\n        );\n        $tableDiff->renamedColumns['id']  = new Column('war', Type::getType('integer'));\n        $tableDiff->removedColumns['baz'] = new Column('baz', Type::getType('integer'));\n        $tableDiff->addedForeignKeys[]    = new ForeignKeyConstraint(['fk3'], 'fk_table', ['id'], 'fk_add');\n        $tableDiff->changedForeignKeys[]  = new ForeignKeyConstraint(['fk2'], 'fk_table2', ['id'], 'fk2');\n        $tableDiff->removedForeignKeys[]  = new ForeignKeyConstraint(['fk'], 'fk_table', ['id'], 'fk1');\n\n        self::assertSame(\n            $this->getQuotesTableIdentifiersInAlterTableSQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getQuotesTableIdentifiersInAlterTableSQL(): array;\n\n    public function testAlterStringToFixedString(): void\n    {\n        $table = new Table('mytable');\n        $table->addColumn('name', 'string', ['length' => 2]);\n\n        $tableDiff            = new TableDiff('mytable');\n        $tableDiff->fromTable = $table;\n\n        $tableDiff->changedColumns['name'] = new ColumnDiff(\n            'name',\n            new Column(\n                'name',\n                Type::getType('string'),\n                ['fixed' => true, 'length' => 2]\n            ),\n            ['fixed']\n        );\n\n        $sql = $this->platform->getAlterTableSQL($tableDiff);\n\n        $expectedSql = $this->getAlterStringToFixedStringSQL();\n\n        self::assertEquals($expectedSql, $sql);\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getAlterStringToFixedStringSQL(): array;\n\n    public function testGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): void\n    {\n        $foreignTable = new Table('foreign_table');\n        $foreignTable->addColumn('id', 'integer');\n        $foreignTable->setPrimaryKey(['id']);\n\n        $primaryTable = new Table('mytable');\n        $primaryTable->addColumn('foo', 'integer');\n        $primaryTable->addColumn('bar', 'integer');\n        $primaryTable->addColumn('baz', 'integer');\n        $primaryTable->addIndex(['foo'], 'idx_foo');\n        $primaryTable->addIndex(['bar'], 'idx_bar');\n        $primaryTable->addForeignKeyConstraint($foreignTable, ['foo'], ['id'], [], 'fk_foo');\n        $primaryTable->addForeignKeyConstraint($foreignTable, ['bar'], ['id'], [], 'fk_bar');\n\n        $tableDiff                            = new TableDiff('mytable');\n        $tableDiff->fromTable                 = $primaryTable;\n        $tableDiff->renamedIndexes['idx_foo'] = new Index('idx_foo_renamed', ['foo']);\n\n        self::assertSame(\n            $this->getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(),\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    /**\n     * @return string[]\n     */\n    abstract protected function getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): array;\n\n    /**\n     * @param mixed[] $column\n     *\n     * @dataProvider getGeneratesDecimalTypeDeclarationSQL\n     */\n    public function testGeneratesDecimalTypeDeclarationSQL(array $column, string $expectedSql): void\n    {\n        self::assertSame($expectedSql, $this->platform->getDecimalTypeDeclarationSQL($column));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesDecimalTypeDeclarationSQL(): iterable\n    {\n        return [\n            [[], 'NUMERIC(10, 0)'],\n            [['unsigned' => true], 'NUMERIC(10, 0)'],\n            [['unsigned' => false], 'NUMERIC(10, 0)'],\n            [['precision' => 5], 'NUMERIC(5, 0)'],\n            [['scale' => 5], 'NUMERIC(10, 5)'],\n            [['precision' => 8, 'scale' => 2], 'NUMERIC(8, 2)'],\n        ];\n    }\n\n    /**\n     * @param mixed[] $column\n     *\n     * @dataProvider getGeneratesFloatDeclarationSQL\n     */\n    public function testGeneratesFloatDeclarationSQL(array $column, string $expectedSql): void\n    {\n        self::assertSame($expectedSql, $this->platform->getFloatDeclarationSQL($column));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesFloatDeclarationSQL(): iterable\n    {\n        return [\n            [[], 'DOUBLE PRECISION'],\n            [['unsigned' => true], 'DOUBLE PRECISION'],\n            [['unsigned' => false], 'DOUBLE PRECISION'],\n            [['precision' => 5], 'DOUBLE PRECISION'],\n            [['scale' => 5], 'DOUBLE PRECISION'],\n            [['precision' => 8, 'scale' => 2], 'DOUBLE PRECISION'],\n        ];\n    }\n\n    public function testItEscapesStringsForLike(): void\n    {\n        self::assertSame(\n            '\\_25\\% off\\_ your next purchase \\\\\\\\o/',\n            $this->platform->escapeStringForLike('_25% off_ your next purchase \\o/', '\\\\')\n        );\n    }\n\n    public function testZeroOffsetWithoutLimitIsIgnored(): void\n    {\n        $query = 'SELECT * FROM user';\n\n        self::assertSame(\n            $query,\n            $this->platform->modifyLimitQuery($query, null, 0)\n        );\n    }\n\n    public function testLimitOffsetCastToInt(): void\n    {\n        self::assertSame(\n            $this->getLimitOffsetCastToIntExpectedQuery(),\n            $this->platform->modifyLimitQuery('SELECT * FROM user', '1 BANANA', '2 APPLES')\n        );\n    }\n\n    protected function getLimitOffsetCastToIntExpectedQuery(): string\n    {\n        return 'SELECT * FROM user LIMIT 1 OFFSET 2';\n    }\n\n    /**\n     * @param array<string, mixed> $column\n     *\n     * @dataProvider asciiStringSqlDeclarationDataProvider\n     */\n    public function testAsciiSQLDeclaration(string $expectedSql, array $column): void\n    {\n        $declarationSql = $this->platform->getAsciiStringTypeDeclarationSQL($column);\n        self::assertEquals($expectedSql, $declarationSql);\n    }\n\n    /**\n     * @return array<int, array{string, array<string, mixed>}>\n     */\n    public function asciiStringSqlDeclarationDataProvider(): array\n    {\n        return [\n            ['VARCHAR(12)', ['length' => 12]],\n            ['CHAR(12)', ['length' => 12, 'fixed' => true]],\n        ];\n    }\n\n    public function testInvalidLockMode(): void\n    {\n        $this->expectException(InvalidLockMode::class);\n        $this->platform->appendLockHint('TABLE', 128);\n    }\n}\n\ninterface GetCreateTableSqlDispatchEventListener\n{\n    public function onSchemaCreateTable(): void;\n\n    public function onSchemaCreateTableColumn(): void;\n}\n\ninterface GetAlterTableSqlDispatchEventListener\n{\n    public function onSchemaAlterTable(): void;\n\n    public function onSchemaAlterTableAddColumn(): void;\n\n    public function onSchemaAlterTableRemoveColumn(): void;\n\n    public function onSchemaAlterTableChangeColumn(): void;\n\n    public function onSchemaAlterTableRenameColumn(): void;\n}\n\ninterface GetDropTableSqlDispatchEventListener\n{\n    public function onSchemaDropTable(): void;\n}\n", "<?php\n\nnamespace Doctrine\\DBAL\\Tests\\Platforms;\n\nuse Doctrine\\DBAL\\Platforms\\AbstractPlatform;\nuse Doctrine\\DBAL\\Platforms\\DB2Platform;\nuse Doctrine\\DBAL\\Schema\\Column;\nuse Doctrine\\DBAL\\Schema\\ColumnDiff;\nuse Doctrine\\DBAL\\Schema\\Index;\nuse Doctrine\\DBAL\\Schema\\Table;\nuse Doctrine\\DBAL\\Schema\\TableDiff;\nuse Doctrine\\DBAL\\Types\\Type;\nuse Doctrine\\DBAL\\Types\\Types;\n\n/**\n * @extends AbstractPlatformTestCase<DB2Platform>\n */\nclass DB2PlatformTest extends AbstractPlatformTestCase\n{\n    public function createPlatform(): AbstractPlatform\n    {\n        return new DB2Platform();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getGenerateAlterTableSql(): array\n    {\n        return [\n            'ALTER TABLE mytable ALTER COLUMN baz SET DATA TYPE VARCHAR(255)',\n            'ALTER TABLE mytable ALTER COLUMN baz SET NOT NULL',\n            \"ALTER TABLE mytable ALTER COLUMN baz SET DEFAULT 'def'\",\n            'ALTER TABLE mytable ALTER COLUMN bloo SET DATA TYPE SMALLINT',\n            'ALTER TABLE mytable ALTER COLUMN bloo SET NOT NULL',\n            \"ALTER TABLE mytable ALTER COLUMN bloo SET DEFAULT '0'\",\n            'ALTER TABLE mytable ' .\n            'ADD COLUMN quota INTEGER DEFAULT NULL ' .\n            'DROP COLUMN foo',\n            \"CALL SYSPROC.ADMIN_CMD ('REORG TABLE mytable')\",\n            'RENAME TABLE mytable TO userlist',\n        ];\n    }\n\n    protected function getGenerateForeignKeySql(): string\n    {\n        return 'ALTER TABLE test ADD FOREIGN KEY (fk_name_id) REFERENCES other_table (id)';\n    }\n\n    public function getGenerateIndexSql(): string\n    {\n        return 'CREATE INDEX my_idx ON mytable (user_name, last_login)';\n    }\n\n    public function getGenerateTableSql(): string\n    {\n        return 'CREATE TABLE test (id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL, '\n            . 'test VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id))';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getGenerateTableWithMultiColumnUniqueIndexSql(): array\n    {\n        return [\n            'CREATE TABLE test (foo VARCHAR(255) DEFAULT NULL, bar VARCHAR(255) DEFAULT NULL)',\n            'CREATE UNIQUE INDEX UNIQ_D87F7E0C8C73652176FF8CAA ON test (foo, bar)',\n        ];\n    }\n\n    public function getGenerateUniqueIndexSql(): string\n    {\n        return 'CREATE UNIQUE INDEX index_name ON test (test, test2)';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInForeignKeySQL(): array\n    {\n        return [\n            'CREATE TABLE \"quoted\" (\"create\" VARCHAR(255) NOT NULL, foo VARCHAR(255) NOT NULL, '\n                . '\"bar\" VARCHAR(255) NOT NULL)',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_RESERVED_KEYWORD FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES \"foreign\" (\"create\", bar, \"foo-bar\")',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_NON_RESERVED_KEYWORD FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES foo (\"create\", bar, \"foo-bar\")',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_INTENDED_QUOTATION FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES \"foo-bar\" (\"create\", bar, \"foo-bar\")',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInIndexSQL(): array\n    {\n        return [\n            'CREATE TABLE \"quoted\" (\"create\" VARCHAR(255) NOT NULL)',\n            'CREATE INDEX IDX_22660D028FD6E0FB ON \"quoted\" (\"create\")',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedNameInIndexSQL(): array\n    {\n        return [\n            'CREATE TABLE test (column1 VARCHAR(255) NOT NULL)',\n            'CREATE INDEX \"key\" ON test (column1)',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInPrimaryKeySQL(): array\n    {\n        return ['CREATE TABLE \"quoted\" (\"create\" VARCHAR(255) NOT NULL, PRIMARY KEY(\"create\"))'];\n    }\n\n    protected function getBitAndComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return 'BITAND(' . $value1 . ', ' . $value2 . ')';\n    }\n\n    protected function getBitOrComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return 'BITOR(' . $value1 . ', ' . $value2 . ')';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getCreateTableColumnCommentsSQL(): array\n    {\n        return [\n            'CREATE TABLE test (id INTEGER NOT NULL, PRIMARY KEY(id))',\n            \"COMMENT ON COLUMN test.id IS 'This is a comment'\",\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getAlterTableColumnCommentsSQL(): array\n    {\n        return [\n            'ALTER TABLE mytable ' .\n            'ADD COLUMN quota INTEGER NOT NULL WITH DEFAULT',\n            \"CALL SYSPROC.ADMIN_CMD ('REORG TABLE mytable')\",\n            \"COMMENT ON COLUMN mytable.quota IS 'A comment'\",\n            \"COMMENT ON COLUMN mytable.foo IS ''\",\n            \"COMMENT ON COLUMN mytable.baz IS 'B comment'\",\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getCreateTableColumnTypeCommentsSQL(): array\n    {\n        return [\n            'CREATE TABLE test (id INTEGER NOT NULL, \"data\" CLOB(1M) NOT NULL, PRIMARY KEY(id))',\n            'COMMENT ON COLUMN test.\"data\" IS \\'(DC2Type:array)\\'',\n        ];\n    }\n\n    public function testHasCorrectPlatformName(): void\n    {\n        self::assertEquals('db2', $this->platform->getName());\n    }\n\n    public function testGeneratesCreateTableSQLWithCommonIndexes(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('name', 'string', ['length' => 50]);\n        $table->setPrimaryKey(['id']);\n        $table->addIndex(['name']);\n        $table->addIndex(['id', 'name'], 'composite_idx');\n\n        self::assertEquals(\n            [\n                'CREATE TABLE test (id INTEGER NOT NULL, name VARCHAR(50) NOT NULL, PRIMARY KEY(id))',\n                'CREATE INDEX IDX_D87F7E0C5E237E06 ON test (name)',\n                'CREATE INDEX composite_idx ON test (id, name)',\n            ],\n            $this->platform->getCreateTableSQL($table)\n        );\n    }\n\n    public function testGeneratesCreateTableSQLWithForeignKeyConstraints(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('fk_1', 'integer');\n        $table->addColumn('fk_2', 'integer');\n        $table->setPrimaryKey(['id']);\n        $table->addForeignKeyConstraint('foreign_table', ['fk_1', 'fk_2'], ['pk_1', 'pk_2']);\n        $table->addForeignKeyConstraint(\n            'foreign_table2',\n            ['fk_1', 'fk_2'],\n            ['pk_1', 'pk_2'],\n            [],\n            'named_fk'\n        );\n\n        self::assertEquals(\n            [\n                'CREATE TABLE test (id INTEGER NOT NULL, fk_1 INTEGER NOT NULL, fk_2 INTEGER NOT NULL)',\n                'ALTER TABLE test ADD CONSTRAINT FK_D87F7E0C177612A38E7F4319 FOREIGN KEY (fk_1, fk_2)'\n                    . ' REFERENCES foreign_table (pk_1, pk_2)',\n                'ALTER TABLE test ADD CONSTRAINT named_fk FOREIGN KEY (fk_1, fk_2)'\n                    . ' REFERENCES foreign_table2 (pk_1, pk_2)',\n            ],\n            $this->platform->getCreateTableSQL($table, AbstractPlatform::CREATE_FOREIGNKEYS)\n        );\n    }\n\n    public function testGeneratesCreateTableSQLWithCheckConstraints(): void\n    {\n        $table = new Table('test');\n        $table->addColumn('id', 'integer');\n        $table->addColumn('check_max', 'integer', ['platformOptions' => ['max' => 10]]);\n        $table->addColumn('check_min', 'integer', ['platformOptions' => ['min' => 10]]);\n        $table->setPrimaryKey(['id']);\n\n        self::assertEquals(\n            [\n                'CREATE TABLE test (id INTEGER NOT NULL, check_max INTEGER NOT NULL, '\n                    . 'check_min INTEGER NOT NULL, PRIMARY KEY(id), CHECK (check_max <= 10), CHECK (check_min >= 10))',\n            ],\n            $this->platform->getCreateTableSQL($table)\n        );\n    }\n\n    public function testGeneratesColumnTypesDeclarationSQL(): void\n    {\n        $fullColumnDef = [\n            'length' => 10,\n            'fixed' => true,\n            'unsigned' => true,\n            'autoincrement' => true,\n        ];\n\n        self::assertEquals('VARCHAR(255)', $this->platform->getVarcharTypeDeclarationSQL([]));\n        self::assertEquals('VARCHAR(10)', $this->platform->getVarcharTypeDeclarationSQL(['length' => 10]));\n        self::assertEquals('CHAR(254)', $this->platform->getVarcharTypeDeclarationSQL(['fixed' => true]));\n        self::assertEquals('CHAR(10)', $this->platform->getVarcharTypeDeclarationSQL($fullColumnDef));\n\n        self::assertEquals('SMALLINT', $this->platform->getSmallIntTypeDeclarationSQL([]));\n        self::assertEquals('SMALLINT', $this->platform->getSmallIntTypeDeclarationSQL(['unsigned' => true]));\n\n        self::assertEquals(\n            'SMALLINT GENERATED BY DEFAULT AS IDENTITY',\n            $this->platform->getSmallIntTypeDeclarationSQL($fullColumnDef)\n        );\n\n        self::assertEquals('INTEGER', $this->platform->getIntegerTypeDeclarationSQL([]));\n        self::assertEquals('INTEGER', $this->platform->getIntegerTypeDeclarationSQL(['unsigned' => true]));\n\n        self::assertEquals(\n            'INTEGER GENERATED BY DEFAULT AS IDENTITY',\n            $this->platform->getIntegerTypeDeclarationSQL($fullColumnDef)\n        );\n\n        self::assertEquals('BIGINT', $this->platform->getBigIntTypeDeclarationSQL([]));\n        self::assertEquals('BIGINT', $this->platform->getBigIntTypeDeclarationSQL(['unsigned' => true]));\n\n        self::assertEquals(\n            'BIGINT GENERATED BY DEFAULT AS IDENTITY',\n            $this->platform->getBigIntTypeDeclarationSQL($fullColumnDef)\n        );\n\n        self::assertEquals('BLOB(1M)', $this->platform->getBlobTypeDeclarationSQL($fullColumnDef));\n        self::assertEquals('SMALLINT', $this->platform->getBooleanTypeDeclarationSQL($fullColumnDef));\n        self::assertEquals('CLOB(1M)', $this->platform->getClobTypeDeclarationSQL($fullColumnDef));\n        self::assertEquals('DATE', $this->platform->getDateTypeDeclarationSQL($fullColumnDef));\n\n        self::assertEquals(\n            'TIMESTAMP(0) WITH DEFAULT',\n            $this->platform->getDateTimeTypeDeclarationSQL(['version' => true])\n        );\n\n        self::assertEquals('TIMESTAMP(0)', $this->platform->getDateTimeTypeDeclarationSQL($fullColumnDef));\n        self::assertEquals('TIME', $this->platform->getTimeTypeDeclarationSQL($fullColumnDef));\n    }\n\n    public function testInitializesDoctrineTypeMappings(): void\n    {\n        $this->platform->initializeDoctrineTypeMappings();\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('smallint'));\n        self::assertSame('smallint', $this->platform->getDoctrineTypeMapping('smallint'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('bigint'));\n        self::assertSame('bigint', $this->platform->getDoctrineTypeMapping('bigint'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('integer'));\n        self::assertSame('integer', $this->platform->getDoctrineTypeMapping('integer'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('time'));\n        self::assertSame('time', $this->platform->getDoctrineTypeMapping('time'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('date'));\n        self::assertSame('date', $this->platform->getDoctrineTypeMapping('date'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('varchar'));\n        self::assertSame('string', $this->platform->getDoctrineTypeMapping('varchar'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('character'));\n        self::assertSame('string', $this->platform->getDoctrineTypeMapping('character'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('clob'));\n        self::assertSame('text', $this->platform->getDoctrineTypeMapping('clob'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('blob'));\n        self::assertSame('blob', $this->platform->getDoctrineTypeMapping('blob'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('decimal'));\n        self::assertSame('decimal', $this->platform->getDoctrineTypeMapping('decimal'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('double'));\n        self::assertSame('float', $this->platform->getDoctrineTypeMapping('double'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('real'));\n        self::assertSame('float', $this->platform->getDoctrineTypeMapping('real'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('timestamp'));\n        self::assertSame('datetime', $this->platform->getDoctrineTypeMapping('timestamp'));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getIsCommentedDoctrineType(): array\n    {\n        $data = parent::getIsCommentedDoctrineType();\n\n        $data[Types::BOOLEAN] = [Type::getType(Types::BOOLEAN), true];\n\n        return $data;\n    }\n\n    public function testGeneratesDDLSnippets(): void\n    {\n        self::assertEquals('CREATE DATABASE foobar', $this->platform->getCreateDatabaseSQL('foobar'));\n        self::assertEquals('DROP DATABASE foobar', $this->platform->getDropDatabaseSQL('foobar'));\n        self::assertEquals('DECLARE GLOBAL TEMPORARY TABLE', $this->platform->getCreateTemporaryTableSnippetSQL());\n        self::assertEquals('TRUNCATE foobar IMMEDIATE', $this->platform->getTruncateTableSQL('foobar'));\n        self::assertEquals('TRUNCATE foobar IMMEDIATE', $this->platform->getTruncateTableSQL('foobar'), true);\n\n        $viewSql = 'SELECT * FROM footable';\n\n        self::assertEquals(\n            'CREATE VIEW fooview AS ' . $viewSql,\n            $this->platform->getCreateViewSQL('fooview', $viewSql)\n        );\n\n        self::assertEquals('DROP VIEW fooview', $this->platform->getDropViewSQL('fooview'));\n    }\n\n    public function testGeneratesCreateUnnamedPrimaryKeySQL(): void\n    {\n        self::assertEquals(\n            'ALTER TABLE foo ADD PRIMARY KEY (a, b)',\n            $this->platform->getCreatePrimaryKeySQL(\n                new Index('any_pk_name', ['a', 'b'], true, true),\n                'foo'\n            )\n        );\n    }\n\n    public function testGeneratesSQLSnippets(): void\n    {\n        self::assertEquals('CURRENT DATE', $this->platform->getCurrentDateSQL());\n        self::assertEquals('CURRENT TIME', $this->platform->getCurrentTimeSQL());\n        self::assertEquals('CURRENT TIMESTAMP', $this->platform->getCurrentTimestampSQL());\n        self::assertEquals(\"'1987/05/02' + 4 DAY\", $this->platform->getDateAddDaysExpression(\"'1987/05/02'\", 4));\n        self::assertEquals(\"'1987/05/02' + 12 HOUR\", $this->platform->getDateAddHourExpression(\"'1987/05/02'\", 12));\n        self::assertEquals(\"'1987/05/02' + 2 MINUTE\", $this->platform->getDateAddMinutesExpression(\"'1987/05/02'\", 2));\n        self::assertEquals(\"'1987/05/02' + 102 MONTH\", $this->platform->getDateAddMonthExpression(\"'1987/05/02'\", 102));\n        self::assertEquals(\"'1987/05/02' + 15 MONTH\", $this->platform->getDateAddQuartersExpression(\"'1987/05/02'\", 5));\n        self::assertEquals(\"'1987/05/02' + 1 SECOND\", $this->platform->getDateAddSecondsExpression(\"'1987/05/02'\", 1));\n        self::assertEquals(\"'1987/05/02' + 21 DAY\", $this->platform->getDateAddWeeksExpression(\"'1987/05/02'\", 3));\n        self::assertEquals(\"'1987/05/02' + 10 YEAR\", $this->platform->getDateAddYearsExpression(\"'1987/05/02'\", 10));\n\n        self::assertEquals(\n            \"DAYS('1987/05/02') - DAYS('1987/04/01')\",\n            $this->platform->getDateDiffExpression(\"'1987/05/02'\", \"'1987/04/01'\")\n        );\n\n        self::assertEquals(\"'1987/05/02' - 4 DAY\", $this->platform->getDateSubDaysExpression(\"'1987/05/02'\", 4));\n        self::assertEquals(\"'1987/05/02' - 12 HOUR\", $this->platform->getDateSubHourExpression(\"'1987/05/02'\", 12));\n        self::assertEquals(\"'1987/05/02' - 2 MINUTE\", $this->platform->getDateSubMinutesExpression(\"'1987/05/02'\", 2));\n        self::assertEquals(\"'1987/05/02' - 102 MONTH\", $this->platform->getDateSubMonthExpression(\"'1987/05/02'\", 102));\n        self::assertEquals(\"'1987/05/02' - 15 MONTH\", $this->platform->getDateSubQuartersExpression(\"'1987/05/02'\", 5));\n        self::assertEquals(\"'1987/05/02' - 1 SECOND\", $this->platform->getDateSubSecondsExpression(\"'1987/05/02'\", 1));\n        self::assertEquals(\"'1987/05/02' - 21 DAY\", $this->platform->getDateSubWeeksExpression(\"'1987/05/02'\", 3));\n        self::assertEquals(\"'1987/05/02' - 10 YEAR\", $this->platform->getDateSubYearsExpression(\"'1987/05/02'\", 10));\n        self::assertEquals(' WITH RR USE AND KEEP UPDATE LOCKS', $this->platform->getForUpdateSQL());\n\n        self::assertEquals(\n            'LOCATE(substring_column, string_column)',\n            $this->platform->getLocateExpression('string_column', 'substring_column')\n        );\n\n        self::assertEquals(\n            'LOCATE(substring_column, string_column)',\n            $this->platform->getLocateExpression('string_column', 'substring_column')\n        );\n\n        self::assertEquals(\n            'LOCATE(substring_column, string_column, 1)',\n            $this->platform->getLocateExpression('string_column', 'substring_column', 1)\n        );\n\n        self::assertEquals('SUBSTR(column, 5)', $this->platform->getSubstringExpression('column', 5));\n        self::assertEquals('SUBSTR(column, 5, 2)', $this->platform->getSubstringExpression('column', 5, 2));\n    }\n\n    public function testModifiesLimitQuery(): void\n    {\n        self::assertEquals(\n            'SELECT * FROM user',\n            $this->platform->modifyLimitQuery('SELECT * FROM user', null, 0)\n        );\n\n        self::assertEquals(\n            'SELECT db22.* FROM ('\n                . 'SELECT db21.*, ROW_NUMBER() OVER() AS DC_ROWNUM FROM (SELECT * FROM user) db21'\n                . ') db22 WHERE db22.DC_ROWNUM <= 10',\n            $this->platform->modifyLimitQuery('SELECT * FROM user', 10)\n        );\n\n        self::assertEquals(\n            'SELECT db22.* FROM (SELECT db21.*, ROW_NUMBER() OVER() AS DC_ROWNUM FROM ('\n                . 'SELECT * FROM user) db21'\n                . ') db22 WHERE db22.DC_ROWNUM >= 6 AND db22.DC_ROWNUM <= 15',\n            $this->platform->modifyLimitQuery('SELECT * FROM user', 10, 5)\n        );\n        self::assertEquals(\n            'SELECT db22.* FROM ('\n                . 'SELECT db21.*, ROW_NUMBER() OVER() AS DC_ROWNUM FROM (SELECT * FROM user) db21'\n                . ') db22 WHERE db22.DC_ROWNUM >= 6 AND db22.DC_ROWNUM <= 5',\n            $this->platform->modifyLimitQuery('SELECT * FROM user', 0, 5)\n        );\n    }\n\n    public function testPrefersIdentityColumns(): void\n    {\n        self::assertTrue($this->platform->prefersIdentityColumns());\n    }\n\n    public function testSupportsIdentityColumns(): void\n    {\n        self::assertTrue($this->platform->supportsIdentityColumns());\n    }\n\n    public function testDoesNotSupportSavePoints(): void\n    {\n        self::assertFalse($this->platform->supportsSavepoints());\n    }\n\n    public function testDoesNotSupportReleasePoints(): void\n    {\n        self::assertFalse($this->platform->supportsReleaseSavepoints());\n    }\n\n    public function testDoesNotSupportCreateDropDatabase(): void\n    {\n        self::assertFalse($this->platform->supportsCreateDropDatabase());\n    }\n\n    protected function getBinaryDefaultLength(): int\n    {\n        return 1;\n    }\n\n    protected function getBinaryMaxLength(): int\n    {\n        return 32704;\n    }\n\n    public function testReturnsBinaryTypeDeclarationSQL(): void\n    {\n        self::assertSame('VARCHAR(1) FOR BIT DATA', $this->platform->getBinaryTypeDeclarationSQL([]));\n        self::assertSame('VARCHAR(255) FOR BIT DATA', $this->platform->getBinaryTypeDeclarationSQL(['length' => 0]));\n        self::assertSame(\n            'VARCHAR(32704) FOR BIT DATA',\n            $this->platform->getBinaryTypeDeclarationSQL(['length' => 32704])\n        );\n\n        self::assertSame('CHAR(1) FOR BIT DATA', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true]));\n        self::assertSame('CHAR(254) FOR BIT DATA', $this->platform->getBinaryTypeDeclarationSQL([\n            'fixed' => true,\n            'length' => 0,\n        ]));\n    }\n\n    public function testReturnsBinaryTypeLongerThanMaxDeclarationSQL(): void\n    {\n        self::assertSame('BLOB(1M)', $this->platform->getBinaryTypeDeclarationSQL(['length' => 32705]));\n        self::assertSame('BLOB(1M)', $this->platform->getBinaryTypeDeclarationSQL([\n            'fixed' => true,\n            'length' => 32705,\n        ]));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getAlterTableRenameIndexSQL(): array\n    {\n        return ['RENAME INDEX idx_foo TO idx_bar'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedAlterTableRenameIndexSQL(): array\n    {\n        return [\n            'RENAME INDEX \"create\" TO \"select\"',\n            'RENAME INDEX \"foo\" TO \"bar\"',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotedAlterTableRenameColumnSQL(): array\n    {\n        return ['ALTER TABLE mytable ' .\n            'RENAME COLUMN unquoted1 TO unquoted ' .\n            'RENAME COLUMN unquoted2 TO \"where\" ' .\n            'RENAME COLUMN unquoted3 TO \"foo\" ' .\n            'RENAME COLUMN \"create\" TO reserved_keyword ' .\n            'RENAME COLUMN \"table\" TO \"from\" ' .\n            'RENAME COLUMN \"select\" TO \"bar\" ' .\n            'RENAME COLUMN quoted1 TO quoted ' .\n            'RENAME COLUMN quoted2 TO \"and\" ' .\n            'RENAME COLUMN quoted3 TO \"baz\"',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotedAlterTableChangeColumnLengthSQL(): array\n    {\n        self::markTestIncomplete('Not implemented yet');\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return ['RENAME INDEX myschema.idx_foo TO idx_bar'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return [\n            'RENAME INDEX \"schema\".\"create\" TO \"select\"',\n            'RENAME INDEX \"schema\".\"foo\" TO \"bar\"',\n        ];\n    }\n\n    public function testReturnsGuidTypeDeclarationSQL(): void\n    {\n        self::assertSame('CHAR(36)', $this->platform->getGuidTypeDeclarationSQL([]));\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAlterTableRenameColumnSQL(): array\n    {\n        return ['ALTER TABLE foo RENAME COLUMN bar TO baz'];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotesTableIdentifiersInAlterTableSQL(): array\n    {\n        return [\n            'ALTER TABLE \"foo\" DROP FOREIGN KEY fk1',\n            'ALTER TABLE \"foo\" DROP FOREIGN KEY fk2',\n            'ALTER TABLE \"foo\" ' .\n            'ADD COLUMN bloo INTEGER NOT NULL WITH DEFAULT ' .\n            'DROP COLUMN baz ' .\n            'ALTER COLUMN bar DROP NOT NULL ' .\n            'RENAME COLUMN id TO war',\n            'CALL SYSPROC.ADMIN_CMD (\\'REORG TABLE \"foo\"\\')',\n            'RENAME TABLE \"foo\" TO \"table\"',\n            'ALTER TABLE \"table\" ADD CONSTRAINT fk_add FOREIGN KEY (fk3) REFERENCES fk_table (id)',\n            'ALTER TABLE \"table\" ADD CONSTRAINT fk2 FOREIGN KEY (fk2) REFERENCES fk_table2 (id)',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getCommentOnColumnSQL(): array\n    {\n        return [\n            'COMMENT ON COLUMN foo.bar IS \\'comment\\'',\n            'COMMENT ON COLUMN \"Foo\".\"BAR\" IS \\'comment\\'',\n            'COMMENT ON COLUMN \"select\".\"from\" IS \\'comment\\'',\n        ];\n    }\n\n    /**\n     * @dataProvider getGeneratesAlterColumnSQL\n     */\n    public function testGeneratesAlterColumnSQL(\n        string $changedProperty,\n        Column $column,\n        ?string $expectedSQLClause = null\n    ): void {\n        $tableDiff                        = new TableDiff('foo');\n        $tableDiff->fromTable             = new Table('foo');\n        $tableDiff->changedColumns['bar'] = new ColumnDiff('bar', $column, [$changedProperty]);\n\n        $expectedSQL = [];\n\n        if ($expectedSQLClause !== null) {\n            $expectedSQL[] = 'ALTER TABLE foo ALTER COLUMN bar ' . $expectedSQLClause;\n        }\n\n        $expectedSQL[] = \"CALL SYSPROC.ADMIN_CMD ('REORG TABLE foo')\";\n\n        self::assertSame($expectedSQL, $this->platform->getAlterTableSQL($tableDiff));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesAlterColumnSQL(): iterable\n    {\n        return [\n            [\n                'columnDefinition',\n                new Column('bar', Type::getType('decimal'), ['columnDefinition' => 'MONEY NOT NULL']),\n                'MONEY NOT NULL',\n            ],\n            [\n                'type',\n                new Column('bar', Type::getType('integer')),\n                'SET DATA TYPE INTEGER',\n            ],\n            [\n                'length',\n                new Column('bar', Type::getType('string'), ['length' => 100]),\n                'SET DATA TYPE VARCHAR(100)',\n            ],\n            [\n                'precision',\n                new Column('bar', Type::getType('decimal'), ['precision' => 10, 'scale' => 2]),\n                'SET DATA TYPE NUMERIC(10, 2)',\n            ],\n            [\n                'scale',\n                new Column('bar', Type::getType('decimal'), ['precision' => 5, 'scale' => 4]),\n                'SET DATA TYPE NUMERIC(5, 4)',\n            ],\n            [\n                'fixed',\n                new Column('bar', Type::getType('string'), ['length' => 20, 'fixed' => true]),\n                'SET DATA TYPE CHAR(20)',\n            ],\n            [\n                'notnull',\n                new Column('bar', Type::getType('string'), ['notnull' => true]),\n                'SET NOT NULL',\n            ],\n            [\n                'notnull',\n                new Column('bar', Type::getType('string'), ['notnull' => false]),\n                'DROP NOT NULL',\n            ],\n            [\n                'default',\n                new Column('bar', Type::getType('string'), ['default' => 'foo']),\n                \"SET DEFAULT 'foo'\",\n            ],\n            [\n                'default',\n                new Column('bar', Type::getType('integer'), ['autoincrement' => true, 'default' => 666]),\n                null,\n            ],\n            [\n                'default',\n                new Column('bar', Type::getType('string')),\n                'DROP DEFAULT',\n            ],\n        ];\n    }\n\n    protected function getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): string\n    {\n        return 'CONSTRAINT \"select\" UNIQUE (foo)';\n    }\n\n    protected function getQuotesReservedKeywordInIndexDeclarationSQL(): string\n    {\n        return ''; // not supported by this platform\n    }\n\n    protected function getQuotesReservedKeywordInTruncateTableSQL(): string\n    {\n        return 'TRUNCATE \"select\" IMMEDIATE';\n    }\n\n    protected function supportsInlineIndexDeclaration(): bool\n    {\n        return false;\n    }\n\n    protected function supportsCommentOnStatement(): bool\n    {\n        return true;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getAlterStringToFixedStringSQL(): array\n    {\n        return [\n            'ALTER TABLE mytable ALTER COLUMN name SET DATA TYPE CHAR(2)',\n            'CALL SYSPROC.ADMIN_CMD (\\'REORG TABLE mytable\\')',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): array\n    {\n        return ['RENAME INDEX idx_foo TO idx_foo_renamed'];\n    }\n\n    public function testQuotesTableNameInListTableColumnsSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableColumnsSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableIndexesSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableIndexesSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableForeignKeysSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableForeignKeysSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    protected function getLimitOffsetCastToIntExpectedQuery(): string\n    {\n        return 'SELECT db22.* FROM (SELECT db21.*, ROW_NUMBER() OVER() AS DC_ROWNUM'\n            . ' FROM (SELECT * FROM user) db21) db22 WHERE db22.DC_ROWNUM >= 3 AND db22.DC_ROWNUM <= 3';\n    }\n}\n", "<?php\n\nnamespace Doctrine\\DBAL\\Tests\\Platforms;\n\nuse Doctrine\\DBAL\\Exception;\nuse Doctrine\\DBAL\\Platforms\\AbstractPlatform;\nuse Doctrine\\DBAL\\Platforms\\OraclePlatform;\nuse Doctrine\\DBAL\\Schema\\Column;\nuse Doctrine\\DBAL\\Schema\\ColumnDiff;\nuse Doctrine\\DBAL\\Schema\\Comparator;\nuse Doctrine\\DBAL\\Schema\\ForeignKeyConstraint;\nuse Doctrine\\DBAL\\Schema\\Sequence;\nuse Doctrine\\DBAL\\Schema\\Table;\nuse Doctrine\\DBAL\\Schema\\TableDiff;\nuse Doctrine\\DBAL\\TransactionIsolationLevel;\nuse Doctrine\\DBAL\\Types\\Type;\n\nuse function sprintf;\nuse function strtoupper;\nuse function uniqid;\n\n/**\n * @extends AbstractPlatformTestCase<OraclePlatform>\n */\nclass OraclePlatformTest extends AbstractPlatformTestCase\n{\n    /**\n     * @return mixed[][]\n     */\n    public static function dataValidIdentifiers(): iterable\n    {\n        return [\n            ['a'],\n            ['foo'],\n            ['Foo'],\n            ['Foo123'],\n            ['Foo#bar_baz$'],\n            ['\"a\"'],\n            ['\"1\"'],\n            ['\"foo_bar\"'],\n            ['\"@$%&!\"'],\n        ];\n    }\n\n    /**\n     * @dataProvider dataValidIdentifiers\n     */\n    public function testValidIdentifiers(string $identifier): void\n    {\n        $platform = $this->createPlatform();\n        $platform->assertValidIdentifier($identifier);\n\n        $this->expectNotToPerformAssertions();\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function dataInvalidIdentifiers(): iterable\n    {\n        return [\n            ['1'],\n            ['abc&'],\n            ['abc-def'],\n            ['\"'],\n            ['\"foo\"bar\"'],\n        ];\n    }\n\n    /**\n     * @dataProvider dataInvalidIdentifiers\n     */\n    public function testInvalidIdentifiers(string $identifier): void\n    {\n        $this->expectException(Exception::class);\n\n        $platform = $this->createPlatform();\n        $platform->assertValidIdentifier($identifier);\n    }\n\n    public function createPlatform(): AbstractPlatform\n    {\n        return new OraclePlatform();\n    }\n\n    public function getGenerateTableSql(): string\n    {\n        return 'CREATE TABLE test (id NUMBER(10) NOT NULL, test VARCHAR2(255) DEFAULT NULL NULL, PRIMARY KEY(id))';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getGenerateTableWithMultiColumnUniqueIndexSql(): array\n    {\n        return [\n            'CREATE TABLE test (foo VARCHAR2(255) DEFAULT NULL NULL, bar VARCHAR2(255) DEFAULT NULL NULL)',\n            'CREATE UNIQUE INDEX UNIQ_D87F7E0C8C73652176FF8CAA ON test (foo, bar)',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getGenerateAlterTableSql(): array\n    {\n        return [\n            'ALTER TABLE mytable ADD (quota NUMBER(10) DEFAULT NULL NULL)',\n            \"ALTER TABLE mytable MODIFY (baz VARCHAR2(255) DEFAULT 'def' NOT NULL, \"\n                . \"bloo NUMBER(1) DEFAULT '0' NOT NULL)\",\n            'ALTER TABLE mytable DROP (foo)',\n            'ALTER TABLE mytable RENAME TO userlist',\n        ];\n    }\n\n    public function testRLike(): void\n    {\n        $this->expectException(Exception::class);\n\n        self::assertEquals('RLIKE', $this->platform->getRegexpExpression());\n    }\n\n    public function testGeneratesSqlSnippets(): void\n    {\n        self::assertEquals('\"', $this->platform->getIdentifierQuoteCharacter());\n        self::assertEquals(\n            'column1 || column2 || column3',\n            $this->platform->getConcatExpression('column1', 'column2', 'column3')\n        );\n    }\n\n    public function testGeneratesTransactionsCommands(): void\n    {\n        self::assertEquals(\n            'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED',\n            $this->platform->getSetTransactionIsolationSQL(TransactionIsolationLevel::READ_UNCOMMITTED)\n        );\n        self::assertEquals(\n            'SET TRANSACTION ISOLATION LEVEL READ COMMITTED',\n            $this->platform->getSetTransactionIsolationSQL(TransactionIsolationLevel::READ_COMMITTED)\n        );\n        self::assertEquals(\n            'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE',\n            $this->platform->getSetTransactionIsolationSQL(TransactionIsolationLevel::REPEATABLE_READ)\n        );\n        self::assertEquals(\n            'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE',\n            $this->platform->getSetTransactionIsolationSQL(TransactionIsolationLevel::SERIALIZABLE)\n        );\n    }\n\n    public function testCreateDatabaseThrowsException(): void\n    {\n        $this->expectException(Exception::class);\n\n        self::assertEquals('CREATE DATABASE foobar', $this->platform->getCreateDatabaseSQL('foobar'));\n    }\n\n    public function testDropDatabaseThrowsException(): void\n    {\n        self::assertEquals('DROP USER foobar CASCADE', $this->platform->getDropDatabaseSQL('foobar'));\n    }\n\n    public function testDropTable(): void\n    {\n        self::assertEquals('DROP TABLE foobar', $this->platform->getDropTableSQL('foobar'));\n    }\n\n    public function testGeneratesTypeDeclarationForIntegers(): void\n    {\n        self::assertEquals(\n            'NUMBER(10)',\n            $this->platform->getIntegerTypeDeclarationSQL([])\n        );\n        self::assertEquals(\n            'NUMBER(10)',\n            $this->platform->getIntegerTypeDeclarationSQL(['autoincrement' => true])\n        );\n        self::assertEquals(\n            'NUMBER(10)',\n            $this->platform->getIntegerTypeDeclarationSQL(\n                ['autoincrement' => true, 'primary' => true]\n            )\n        );\n    }\n\n    public function testGeneratesTypeDeclarationsForStrings(): void\n    {\n        self::assertEquals(\n            'CHAR(10)',\n            $this->platform->getVarcharTypeDeclarationSQL(\n                ['length' => 10, 'fixed' => true]\n            )\n        );\n        self::assertEquals(\n            'VARCHAR2(50)',\n            $this->platform->getVarcharTypeDeclarationSQL(['length' => 50])\n        );\n        self::assertEquals(\n            'VARCHAR2(255)',\n            $this->platform->getVarcharTypeDeclarationSQL([])\n        );\n    }\n\n    public function testPrefersIdentityColumns(): void\n    {\n        self::assertFalse($this->platform->prefersIdentityColumns());\n    }\n\n    public function testSupportsIdentityColumns(): void\n    {\n        self::assertFalse($this->platform->supportsIdentityColumns());\n    }\n\n    public function testSupportsSavePoints(): void\n    {\n        self::assertTrue($this->platform->supportsSavepoints());\n    }\n\n    protected function supportsCommentOnStatement(): bool\n    {\n        return true;\n    }\n\n    public function getGenerateIndexSql(): string\n    {\n        return 'CREATE INDEX my_idx ON mytable (user_name, last_login)';\n    }\n\n    public function getGenerateUniqueIndexSql(): string\n    {\n        return 'CREATE UNIQUE INDEX index_name ON test (test, test2)';\n    }\n\n    protected function getGenerateForeignKeySql(): string\n    {\n        return 'ALTER TABLE test ADD FOREIGN KEY (fk_name_id) REFERENCES other_table (id)';\n    }\n\n    /**\n     * @param mixed[] $options\n     *\n     * @dataProvider getGeneratesAdvancedForeignKeyOptionsSQLData\n     */\n    public function testGeneratesAdvancedForeignKeyOptionsSQL(array $options, string $expectedSql): void\n    {\n        $foreignKey = new ForeignKeyConstraint(['foo'], 'foreign_table', ['bar'], null, $options);\n\n        self::assertSame($expectedSql, $this->platform->getAdvancedForeignKeyOptionsSQL($foreignKey));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getGeneratesAdvancedForeignKeyOptionsSQLData(): iterable\n    {\n        return [\n            [[], ''],\n            [['onUpdate' => 'CASCADE'], ''],\n            [['onDelete' => 'CASCADE'], ' ON DELETE CASCADE'],\n            [['onDelete' => 'NO ACTION'], ''],\n            [['onDelete' => 'RESTRICT'], ''],\n            [['onUpdate' => 'SET NULL', 'onDelete' => 'SET NULL'], ' ON DELETE SET NULL'],\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public static function getReturnsForeignKeyReferentialActionSQL(): iterable\n    {\n        return [\n            ['CASCADE', 'CASCADE'],\n            ['SET NULL', 'SET NULL'],\n            ['NO ACTION', ''],\n            ['RESTRICT', ''],\n            ['CaScAdE', 'CASCADE'],\n        ];\n    }\n\n    public function testModifyLimitQuery(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10, 0);\n        self::assertEquals('SELECT a.* FROM (SELECT * FROM user) a WHERE ROWNUM <= 10', $sql);\n    }\n\n    public function testModifyLimitQueryWithEmptyOffset(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10);\n        self::assertEquals('SELECT a.* FROM (SELECT * FROM user) a WHERE ROWNUM <= 10', $sql);\n    }\n\n    public function testModifyLimitQueryWithNonEmptyOffset(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10, 10);\n\n        self::assertEquals(\n            'SELECT * FROM ('\n                . 'SELECT a.*, ROWNUM AS doctrine_rownum FROM (SELECT * FROM user) a WHERE ROWNUM <= 20'\n                . ') WHERE doctrine_rownum >= 11',\n            $sql\n        );\n    }\n\n    public function testModifyLimitQueryWithEmptyLimit(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', null, 10);\n\n        self::assertEquals(\n            'SELECT * FROM ('\n                . 'SELECT a.*, ROWNUM AS doctrine_rownum FROM (SELECT * FROM user) a'\n                . ') WHERE doctrine_rownum >= 11',\n            $sql\n        );\n    }\n\n    public function testModifyLimitQueryWithAscOrderBy(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user ORDER BY username ASC', 10);\n        self::assertEquals('SELECT a.* FROM (SELECT * FROM user ORDER BY username ASC) a WHERE ROWNUM <= 10', $sql);\n    }\n\n    public function testModifyLimitQueryWithDescOrderBy(): void\n    {\n        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user ORDER BY username DESC', 10);\n        self::assertEquals('SELECT a.* FROM (SELECT * FROM user ORDER BY username DESC) a WHERE ROWNUM <= 10', $sql);\n    }\n\n    public function testGenerateTableWithAutoincrement(): void\n    {\n        $columnName = strtoupper('id' . uniqid());\n        $tableName  = strtoupper('table' . uniqid());\n        $table      = new Table($tableName);\n        $column     = $table->addColumn($columnName, 'integer');\n        $column->setAutoincrement(true);\n\n        self::assertSame([\n            sprintf('CREATE TABLE %s (%s NUMBER(10) NOT NULL)', $tableName, $columnName),\n            sprintf(\n                <<<'SQL'\nDECLARE\n  constraints_Count NUMBER;\nBEGIN\n  SELECT COUNT(CONSTRAINT_NAME) INTO constraints_Count\n    FROM USER_CONSTRAINTS\n   WHERE TABLE_NAME = '%s'\n     AND CONSTRAINT_TYPE = 'P';\n  IF constraints_Count = 0 OR constraints_Count = '' THEN\n    EXECUTE IMMEDIATE 'ALTER TABLE %s ADD CONSTRAINT %s_AI_PK PRIMARY KEY (%s)';\n  END IF;\nEND;\nSQL\n                ,\n                $tableName,\n                $tableName,\n                $tableName,\n                $columnName\n            ),\n            sprintf('CREATE SEQUENCE %s_SEQ START WITH 1 MINVALUE 1 INCREMENT BY 1', $tableName),\n            sprintf(\n                <<<SQL\nCREATE TRIGGER %s_AI_PK\n   BEFORE INSERT\n   ON %s\n   FOR EACH ROW\nDECLARE\n   last_Sequence NUMBER;\n   last_InsertID NUMBER;\nBEGIN\n   IF (:NEW.%s IS NULL OR :NEW.%s = 0) THEN\n      SELECT %s_SEQ.NEXTVAL INTO :NEW.%s FROM DUAL;\n   ELSE\n      SELECT NVL(Last_Number, 0) INTO last_Sequence\n        FROM User_Sequences\n       WHERE Sequence_Name = '%s_SEQ';\n      SELECT :NEW.%s INTO last_InsertID FROM DUAL;\n      WHILE (last_InsertID > last_Sequence) LOOP\n         SELECT %s_SEQ.NEXTVAL INTO last_Sequence FROM DUAL;\n      END LOOP;\n      SELECT %s_SEQ.NEXTVAL INTO last_Sequence FROM DUAL;\n   END IF;\nEND;\nSQL\n                ,\n                $tableName,\n                $tableName,\n                $columnName,\n                $columnName,\n                $tableName,\n                $columnName,\n                $tableName,\n                $columnName,\n                $tableName,\n                $tableName\n            ),\n        ], $this->platform->getCreateTableSQL($table));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getCreateTableColumnCommentsSQL(): array\n    {\n        return [\n            'CREATE TABLE test (id NUMBER(10) NOT NULL, PRIMARY KEY(id))',\n            \"COMMENT ON COLUMN test.id IS 'This is a comment'\",\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getCreateTableColumnTypeCommentsSQL(): array\n    {\n        return [\n            'CREATE TABLE test (id NUMBER(10) NOT NULL, data CLOB NOT NULL, PRIMARY KEY(id))',\n            \"COMMENT ON COLUMN test.data IS '(DC2Type:array)'\",\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getAlterTableColumnCommentsSQL(): array\n    {\n        return [\n            'ALTER TABLE mytable ADD (quota NUMBER(10) NOT NULL)',\n            \"COMMENT ON COLUMN mytable.quota IS 'A comment'\",\n            \"COMMENT ON COLUMN mytable.foo IS ''\",\n            \"COMMENT ON COLUMN mytable.baz IS 'B comment'\",\n        ];\n    }\n\n    public function getBitAndComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return 'BITAND(' . $value1 . ', ' . $value2 . ')';\n    }\n\n    public function getBitOrComparisonExpressionSql(string $value1, string $value2): string\n    {\n        return '(' . $value1 . '-' .\n        $this->getBitAndComparisonExpressionSql($value1, $value2)\n        . '+' . $value2 . ')';\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInPrimaryKeySQL(): array\n    {\n        return ['CREATE TABLE \"quoted\" (\"create\" VARCHAR2(255) NOT NULL, PRIMARY KEY(\"create\"))'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInIndexSQL(): array\n    {\n        return [\n            'CREATE TABLE \"quoted\" (\"create\" VARCHAR2(255) NOT NULL)',\n            'CREATE INDEX IDX_22660D028FD6E0FB ON \"quoted\" (\"create\")',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedNameInIndexSQL(): array\n    {\n        return [\n            'CREATE TABLE test (column1 VARCHAR2(255) NOT NULL)',\n            'CREATE INDEX \"key\" ON test (column1)',\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedColumnInForeignKeySQL(): array\n    {\n        return [\n            'CREATE TABLE \"quoted\" (\"create\" VARCHAR2(255) NOT NULL, foo VARCHAR2(255) NOT NULL, '\n                . '\"bar\" VARCHAR2(255) NOT NULL)',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_RESERVED_KEYWORD FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES foreign (\"create\", bar, \"foo-bar\")',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_NON_RESERVED_KEYWORD FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES foo (\"create\", bar, \"foo-bar\")',\n            'ALTER TABLE \"quoted\" ADD CONSTRAINT FK_WITH_INTENDED_QUOTATION FOREIGN KEY (\"create\", foo, \"bar\")'\n                . ' REFERENCES \"foo-bar\" (\"create\", bar, \"foo-bar\")',\n        ];\n    }\n\n    public function testAlterTableNotNULL(): void\n    {\n        $tableDiff                          = new TableDiff('mytable');\n        $tableDiff->changedColumns['foo']   = new ColumnDiff(\n            'foo',\n            new Column(\n                'foo',\n                Type::getType('string'),\n                ['default' => 'bla', 'notnull' => true]\n            ),\n            ['type']\n        );\n        $tableDiff->changedColumns['bar']   = new ColumnDiff(\n            'bar',\n            new Column(\n                'baz',\n                Type::getType('string'),\n                ['default' => 'bla', 'notnull' => true]\n            ),\n            ['type', 'notnull']\n        );\n        $tableDiff->changedColumns['metar'] = new ColumnDiff(\n            'metar',\n            new Column(\n                'metar',\n                Type::getType('string'),\n                ['length' => 2000, 'notnull' => false]\n            ),\n            ['notnull']\n        );\n\n        $expectedSql = [\n            \"ALTER TABLE mytable MODIFY (foo VARCHAR2(255) DEFAULT 'bla', baz VARCHAR2(255) DEFAULT 'bla' NOT NULL, \"\n                . 'metar VARCHAR2(2000) DEFAULT NULL NULL)',\n        ];\n\n        self::assertEquals($expectedSql, $this->platform->getAlterTableSQL($tableDiff));\n    }\n\n    public function testInitializesDoctrineTypeMappings(): void\n    {\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('long raw'));\n        self::assertSame('blob', $this->platform->getDoctrineTypeMapping('long raw'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('raw'));\n        self::assertSame('binary', $this->platform->getDoctrineTypeMapping('raw'));\n\n        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('date'));\n        self::assertSame('date', $this->platform->getDoctrineTypeMapping('date'));\n    }\n\n    protected function getBinaryMaxLength(): int\n    {\n        return 2000;\n    }\n\n    public function testReturnsBinaryTypeDeclarationSQL(): void\n    {\n        self::assertSame('RAW(255)', $this->platform->getBinaryTypeDeclarationSQL([]));\n        self::assertSame('RAW(2000)', $this->platform->getBinaryTypeDeclarationSQL(['length' => 0]));\n        self::assertSame('RAW(2000)', $this->platform->getBinaryTypeDeclarationSQL(['length' => 2000]));\n\n        self::assertSame('RAW(255)', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true]));\n        self::assertSame('RAW(2000)', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true, 'length' => 0]));\n\n        self::assertSame(\n            'RAW(2000)',\n            $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true, 'length' => 2000])\n        );\n    }\n\n    public function testReturnsBinaryTypeLongerThanMaxDeclarationSQL(): void\n    {\n        self::assertSame('BLOB', $this->platform->getBinaryTypeDeclarationSQL(['length' => 2001]));\n        self::assertSame('BLOB', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true, 'length' => 2001]));\n    }\n\n    public function testDoesNotPropagateUnnecessaryTableAlterationOnBinaryType(): void\n    {\n        $table1 = new Table('mytable');\n        $table1->addColumn('column_varbinary', 'binary');\n        $table1->addColumn('column_binary', 'binary', ['fixed' => true]);\n\n        $table2 = new Table('mytable');\n        $table2->addColumn('column_varbinary', 'binary', ['fixed' => true]);\n        $table2->addColumn('column_binary', 'binary');\n\n        // VARBINARY -> BINARY\n        // BINARY    -> VARBINARY\n        $diff = (new Comparator())->diffTable($table1, $table2);\n        self::assertNotFalse($diff);\n        self::assertEmpty($this->platform->getAlterTableSQL($diff));\n    }\n\n    public function testUsesSequenceEmulatedIdentityColumns(): void\n    {\n        self::assertTrue($this->platform->usesSequenceEmulatedIdentityColumns());\n    }\n\n    public function testReturnsIdentitySequenceName(): void\n    {\n        self::assertSame('MYTABLE_SEQ', $this->platform->getIdentitySequenceName('mytable', 'mycolumn'));\n        self::assertSame('\"mytable_SEQ\"', $this->platform->getIdentitySequenceName('\"mytable\"', 'mycolumn'));\n        self::assertSame('MYTABLE_SEQ', $this->platform->getIdentitySequenceName('mytable', '\"mycolumn\"'));\n        self::assertSame('\"mytable_SEQ\"', $this->platform->getIdentitySequenceName('\"mytable\"', '\"mycolumn\"'));\n    }\n\n    /**\n     * @dataProvider dataCreateSequenceWithCache\n     */\n    public function testCreateSequenceWithCache(int $cacheSize, string $expectedSql): void\n    {\n        $sequence = new Sequence('foo', 1, 1, $cacheSize);\n        self::assertStringContainsString($expectedSql, $this->platform->getCreateSequenceSQL($sequence));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function dataCreateSequenceWithCache(): iterable\n    {\n        return [\n            [1, 'NOCACHE'],\n            [0, 'NOCACHE'],\n            [3, 'CACHE 3'],\n        ];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getAlterTableRenameIndexSQL(): array\n    {\n        return ['ALTER INDEX idx_foo RENAME TO idx_bar'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedAlterTableRenameIndexSQL(): array\n    {\n        return [\n            'ALTER INDEX \"create\" RENAME TO \"select\"',\n            'ALTER INDEX \"foo\" RENAME TO \"bar\"',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotedAlterTableRenameColumnSQL(): array\n    {\n        return [\n            'ALTER TABLE mytable RENAME COLUMN unquoted1 TO unquoted',\n            'ALTER TABLE mytable RENAME COLUMN unquoted2 TO \"where\"',\n            'ALTER TABLE mytable RENAME COLUMN unquoted3 TO \"foo\"',\n            'ALTER TABLE mytable RENAME COLUMN \"create\" TO reserved_keyword',\n            'ALTER TABLE mytable RENAME COLUMN \"table\" TO \"from\"',\n            'ALTER TABLE mytable RENAME COLUMN \"select\" TO \"bar\"',\n            'ALTER TABLE mytable RENAME COLUMN quoted1 TO quoted',\n            'ALTER TABLE mytable RENAME COLUMN quoted2 TO \"and\"',\n            'ALTER TABLE mytable RENAME COLUMN quoted3 TO \"baz\"',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotedAlterTableChangeColumnLengthSQL(): array\n    {\n        self::markTestIncomplete('Not implemented yet');\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return ['ALTER INDEX myschema.idx_foo RENAME TO idx_bar'];\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected function getQuotedAlterTableRenameIndexInSchemaSQL(): array\n    {\n        return [\n            'ALTER INDEX \"schema\".\"create\" RENAME TO \"select\"',\n            'ALTER INDEX \"schema\".\"foo\" RENAME TO \"bar\"',\n        ];\n    }\n\n    protected function getQuotesDropForeignKeySQL(): string\n    {\n        return 'ALTER TABLE \"table\" DROP CONSTRAINT \"select\"';\n    }\n\n    public function testReturnsGuidTypeDeclarationSQL(): void\n    {\n        self::assertSame('CHAR(36)', $this->platform->getGuidTypeDeclarationSQL([]));\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getAlterTableRenameColumnSQL(): array\n    {\n        return ['ALTER TABLE foo RENAME COLUMN bar TO baz'];\n    }\n\n    /**\n     * @param string[] $expectedSql\n     *\n     * @dataProvider getReturnsDropAutoincrementSQL\n     */\n    public function testReturnsDropAutoincrementSQL(string $table, array $expectedSql): void\n    {\n        self::assertSame($expectedSql, $this->platform->getDropAutoincrementSql($table));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getReturnsDropAutoincrementSQL(): iterable\n    {\n        return [\n            [\n                'myTable',\n                [\n                    'DROP TRIGGER MYTABLE_AI_PK',\n                    'DROP SEQUENCE MYTABLE_SEQ',\n                    'ALTER TABLE MYTABLE DROP CONSTRAINT MYTABLE_AI_PK',\n                ],\n            ],\n            [\n                '\"myTable\"',\n                [\n                    'DROP TRIGGER \"myTable_AI_PK\"',\n                    'DROP SEQUENCE \"myTable_SEQ\"',\n                    'ALTER TABLE \"myTable\" DROP CONSTRAINT \"myTable_AI_PK\"',\n                ],\n            ],\n            [\n                'table',\n                [\n                    'DROP TRIGGER TABLE_AI_PK',\n                    'DROP SEQUENCE TABLE_SEQ',\n                    'ALTER TABLE \"TABLE\" DROP CONSTRAINT TABLE_AI_PK',\n                ],\n            ],\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getQuotesTableIdentifiersInAlterTableSQL(): array\n    {\n        return [\n            'ALTER TABLE \"foo\" DROP CONSTRAINT fk1',\n            'ALTER TABLE \"foo\" DROP CONSTRAINT fk2',\n            'ALTER TABLE \"foo\" ADD (bloo NUMBER(10) NOT NULL)',\n            'ALTER TABLE \"foo\" MODIFY (bar NUMBER(10) DEFAULT NULL NULL)',\n            'ALTER TABLE \"foo\" RENAME COLUMN id TO war',\n            'ALTER TABLE \"foo\" DROP (baz)',\n            'ALTER TABLE \"foo\" RENAME TO \"table\"',\n            'ALTER TABLE \"table\" ADD CONSTRAINT fk_add FOREIGN KEY (fk3) REFERENCES fk_table (id)',\n            'ALTER TABLE \"table\" ADD CONSTRAINT fk2 FOREIGN KEY (fk2) REFERENCES fk_table2 (id)',\n        ];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getCommentOnColumnSQL(): array\n    {\n        return [\n            'COMMENT ON COLUMN foo.bar IS \\'comment\\'',\n            'COMMENT ON COLUMN \"Foo\".\"BAR\" IS \\'comment\\'',\n            'COMMENT ON COLUMN \"select\".\"from\" IS \\'comment\\'',\n        ];\n    }\n\n    public function testAltersTableColumnCommentWithExplicitlyQuotedIdentifiers(): void\n    {\n        $table1 = new Table('\"foo\"', [new Column('\"bar\"', Type::getType('integer'))]);\n        $table2 = new Table('\"foo\"', [new Column('\"bar\"', Type::getType('integer'), ['comment' => 'baz'])]);\n\n        $comparator = new Comparator();\n\n        $tableDiff = $comparator->diffTable($table1, $table2);\n\n        self::assertInstanceOf(TableDiff::class, $tableDiff);\n        self::assertSame(\n            ['COMMENT ON COLUMN \"foo\".\"bar\" IS \\'baz\\''],\n            $this->platform->getAlterTableSQL($tableDiff)\n        );\n    }\n\n    public function testQuotedTableNames(): void\n    {\n        $table = new Table('\"test\"');\n        $table->addColumn('\"id\"', 'integer', ['autoincrement' => true]);\n\n        // assert tabel\n        self::assertTrue($table->isQuoted());\n        self::assertEquals('test', $table->getName());\n        self::assertEquals('\"test\"', $table->getQuotedName($this->platform));\n\n        $sql = $this->platform->getCreateTableSQL($table);\n        self::assertEquals('CREATE TABLE \"test\" (\"id\" NUMBER(10) NOT NULL)', $sql[0]);\n        self::assertEquals('CREATE SEQUENCE \"test_SEQ\" START WITH 1 MINVALUE 1 INCREMENT BY 1', $sql[2]);\n        $createTriggerStatement = <<<EOD\nCREATE TRIGGER \"test_AI_PK\"\n   BEFORE INSERT\n   ON \"test\"\n   FOR EACH ROW\nDECLARE\n   last_Sequence NUMBER;\n   last_InsertID NUMBER;\nBEGIN\n   IF (:NEW.\"id\" IS NULL OR :NEW.\"id\" = 0) THEN\n      SELECT \"test_SEQ\".NEXTVAL INTO :NEW.\"id\" FROM DUAL;\n   ELSE\n      SELECT NVL(Last_Number, 0) INTO last_Sequence\n        FROM User_Sequences\n       WHERE Sequence_Name = 'test_SEQ';\n      SELECT :NEW.\"id\" INTO last_InsertID FROM DUAL;\n      WHILE (last_InsertID > last_Sequence) LOOP\n         SELECT \"test_SEQ\".NEXTVAL INTO last_Sequence FROM DUAL;\n      END LOOP;\n      SELECT \"test_SEQ\".NEXTVAL INTO last_Sequence FROM DUAL;\n   END IF;\nEND;\nEOD;\n\n        self::assertEquals($createTriggerStatement, $sql[3]);\n    }\n\n    /**\n     * @dataProvider getReturnsGetListTableColumnsSQL\n     */\n    public function testReturnsGetListTableColumnsSQL(?string $database, string $expectedSql): void\n    {\n        // note: this assertion is a bit strict, as it compares a full SQL string.\n        // Should this break in future, then please try to reduce the matching to substring matching while reworking\n        // the tests\n        self::assertEquals($expectedSql, $this->platform->getListTableColumnsSQL('\"test\"', $database));\n    }\n\n    /**\n     * @return mixed[][]\n     */\n    public static function getReturnsGetListTableColumnsSQL(): iterable\n    {\n        return [\n            [\n                null,\n                <<<'SQL'\nSELECT   c.*,\n         (\n             SELECT d.comments\n             FROM   user_col_comments d\n             WHERE  d.TABLE_NAME = c.TABLE_NAME\n             AND    d.COLUMN_NAME = c.COLUMN_NAME\n         ) AS comments\nFROM     user_tab_columns c\nWHERE    c.table_name = 'test'\nORDER BY c.column_id\nSQL\n,\n            ],\n            [\n                '/',\n                <<<'SQL'\nSELECT   c.*,\n         (\n             SELECT d.comments\n             FROM   user_col_comments d\n             WHERE  d.TABLE_NAME = c.TABLE_NAME\n             AND    d.COLUMN_NAME = c.COLUMN_NAME\n         ) AS comments\nFROM     user_tab_columns c\nWHERE    c.table_name = 'test'\nORDER BY c.column_id\nSQL\n,\n            ],\n            [\n                'scott',\n                <<<'SQL'\nSELECT   c.*,\n         (\n             SELECT d.comments\n             FROM   all_col_comments d\n             WHERE  d.TABLE_NAME = c.TABLE_NAME AND d.OWNER = c.OWNER\n             AND    d.COLUMN_NAME = c.COLUMN_NAME\n         ) AS comments\nFROM     all_tab_columns c\nWHERE    c.table_name = 'test' AND c.owner = 'SCOTT'\nORDER BY c.column_id\nSQL\n,\n            ],\n        ];\n    }\n\n    protected function getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): string\n    {\n        return 'CONSTRAINT \"select\" UNIQUE (foo)';\n    }\n\n    protected function getQuotesReservedKeywordInIndexDeclarationSQL(): string\n    {\n        return 'INDEX \"select\" (foo)';\n    }\n\n    protected function getQuotesReservedKeywordInTruncateTableSQL(): string\n    {\n        return 'TRUNCATE TABLE \"select\"';\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getAlterStringToFixedStringSQL(): array\n    {\n        return ['ALTER TABLE mytable MODIFY (name CHAR(2) DEFAULT NULL)'];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): array\n    {\n        return ['ALTER INDEX idx_foo RENAME TO idx_foo_renamed'];\n    }\n\n    public function testQuotesDatabaseNameInListSequencesSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListSequencesSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableIndexesSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableIndexesSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableForeignKeysSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableForeignKeysSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableConstraintsSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableConstraintsSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesTableNameInListTableColumnsSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableColumnsSQL(\"Foo'Bar\\\\\")\n        );\n    }\n\n    public function testQuotesDatabaseNameInListTableColumnsSQL(): void\n    {\n        self::assertStringContainsStringIgnoringCase(\n            \"'Foo''Bar\\\\'\",\n            $this->platform->getListTableColumnsSQL('foo_table', \"Foo'Bar\\\\\")\n        );\n    }\n\n    /**\n     * @return array<int, array{string, array<string, mixed>}>\n     */\n    public function asciiStringSqlDeclarationDataProvider(): array\n    {\n        return [\n            ['VARCHAR2(12)', ['length' => 12]],\n            ['CHAR(12)', ['length' => 12, 'fixed' => true]],\n        ];\n    }\n\n    protected function getLimitOffsetCastToIntExpectedQuery(): string\n    {\n        return 'SELECT * FROM (SELECT a.*, ROWNUM AS doctrine_rownum FROM (SELECT * FROM user) a WHERE ROWNUM <= 3)'\n            . ' WHERE doctrine_rownum >= 3';\n    }\n}\n"], "filenames": ["src/Platforms/AbstractPlatform.php", "tests/Platforms/AbstractPlatformTestCase.php", "tests/Platforms/DB2PlatformTest.php", "tests/Platforms/OraclePlatformTest.php"], "buggy_code_start_loc": [3368, 1472, 775, 988], "buggy_code_end_loc": [3369, 1472, 775, 988], "fixing_code_start_loc": [3368, 1473, 776, 989], "fixing_code_end_loc": [3373, 1486, 782, 995], "type": "CWE-89", "message": "Doctrine DBAL 3.x before 3.1.4 allows SQL Injection. The escaping of offset and length inputs to the generation of a LIMIT clause was not probably cast to an integer, allowing SQL injection to take place if application developers passed unescaped user input to the DBAL QueryBuilder or any other API that ultimately uses the AbstractPlatform::modifyLimitQuery API.", "other": {"cve": {"id": "CVE-2021-43608", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-09T20:15:07.937", "lastModified": "2021-12-15T14:46:41.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Doctrine DBAL 3.x before 3.1.4 allows SQL Injection. The escaping of offset and length inputs to the generation of a LIMIT clause was not probably cast to an integer, allowing SQL injection to take place if application developers passed unescaped user input to the DBAL QueryBuilder or any other API that ultimately uses the AbstractPlatform::modifyLimitQuery API."}, {"lang": "es", "value": "Doctrine DBAL versiones 3.x anteriores a 3.1.4, permite una inyecci\u00f3n de SQL. Es probable que el escape de las entradas de desplazamiento y longitud para la generaci\u00f3n de una cl\u00e1usula LIMIT no sea convertida en un n\u00famero entero, permitiendo que se produzca una inyecci\u00f3n SQL si los desarrolladores de aplicaciones pasan entradas de usuario sin escape al DBAL QueryBuilder o a cualquier otra API que use en \u00faltima instancia la API AbstractPlatform::modifyLimitQuery"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:doctrine-project:database_abstraction_layer:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.1.4", "matchCriteriaId": "19EC328F-0DBC-4E5C-B993-23B9F7AA8B7D"}]}]}], "references": [{"url": "https://github.com/doctrine/dbal/commit/9dcfa4cb6c03250b78a84737ba7ceb82f4b7ba4d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/doctrine/dbal/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/doctrine/dbal/security/advisories/GHSA-r7cj-8hjg-x622", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.doctrine-project.org/2021/11/11/dbal3-vulnerability-fixed.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/doctrine/dbal/commit/9dcfa4cb6c03250b78a84737ba7ceb82f4b7ba4d"}}