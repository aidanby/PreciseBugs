{"buggy_code": ["#ifndef _LINUX_MM_H\n#define _LINUX_MM_H\n\n#include <linux/errno.h>\n\n#ifdef __KERNEL__\n\n#include <linux/gfp.h>\n#include <linux/bug.h>\n#include <linux/list.h>\n#include <linux/mmzone.h>\n#include <linux/rbtree.h>\n#include <linux/atomic.h>\n#include <linux/debug_locks.h>\n#include <linux/mm_types.h>\n#include <linux/range.h>\n#include <linux/pfn.h>\n#include <linux/bit_spinlock.h>\n#include <linux/shrinker.h>\n\nstruct mempolicy;\nstruct anon_vma;\nstruct anon_vma_chain;\nstruct file_ra_state;\nstruct user_struct;\nstruct writeback_control;\n\n#ifndef CONFIG_DISCONTIGMEM          /* Don't use mapnrs, do it properly */\nextern unsigned long max_mapnr;\n#endif\n\nextern unsigned long num_physpages;\nextern unsigned long totalram_pages;\nextern void * high_memory;\nextern int page_cluster;\n\n#ifdef CONFIG_SYSCTL\nextern int sysctl_legacy_va_layout;\n#else\n#define sysctl_legacy_va_layout 0\n#endif\n\n#include <asm/page.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n\n#define nth_page(page,n) pfn_to_page(page_to_pfn((page)) + (n))\n\n/* to align the pointer to the (next) page boundary */\n#define PAGE_ALIGN(addr) ALIGN(addr, PAGE_SIZE)\n\n/*\n * Linux kernel virtual memory manager primitives.\n * The idea being to have a \"virtual\" mm in the same way\n * we have a virtual fs - giving a cleaner interface to the\n * mm details, and allowing different kinds of memory mappings\n * (from shared memory to executable loading to arbitrary\n * mmap() functions).\n */\n\nextern struct kmem_cache *vm_area_cachep;\n\n#ifndef CONFIG_MMU\nextern struct rb_root nommu_region_tree;\nextern struct rw_semaphore nommu_region_sem;\n\nextern unsigned int kobjsize(const void *objp);\n#endif\n\n/*\n * vm_flags in vm_area_struct, see mm_types.h.\n */\n#define VM_NONE\t\t0x00000000\n\n#define VM_READ\t\t0x00000001\t/* currently active flags */\n#define VM_WRITE\t0x00000002\n#define VM_EXEC\t\t0x00000004\n#define VM_SHARED\t0x00000008\n\n/* mprotect() hardcodes VM_MAYREAD >> 4 == VM_READ, and so for r/w/x bits. */\n#define VM_MAYREAD\t0x00000010\t/* limits for mprotect() etc */\n#define VM_MAYWRITE\t0x00000020\n#define VM_MAYEXEC\t0x00000040\n#define VM_MAYSHARE\t0x00000080\n\n#define VM_GROWSDOWN\t0x00000100\t/* general info on the segment */\n#define VM_PFNMAP\t0x00000400\t/* Page-ranges managed without \"struct page\", just pure PFN */\n#define VM_DENYWRITE\t0x00000800\t/* ETXTBSY on write attempts.. */\n\n#define VM_LOCKED\t0x00002000\n#define VM_IO           0x00004000\t/* Memory mapped I/O or similar */\n\n\t\t\t\t\t/* Used by sys_madvise() */\n#define VM_SEQ_READ\t0x00008000\t/* App will access data sequentially */\n#define VM_RAND_READ\t0x00010000\t/* App will not benefit from clustered reads */\n\n#define VM_DONTCOPY\t0x00020000      /* Do not copy this vma on fork */\n#define VM_DONTEXPAND\t0x00040000\t/* Cannot expand with mremap() */\n#define VM_ACCOUNT\t0x00100000\t/* Is a VM accounted object */\n#define VM_NORESERVE\t0x00200000\t/* should the VM suppress accounting */\n#define VM_HUGETLB\t0x00400000\t/* Huge TLB Page VM */\n#define VM_NONLINEAR\t0x00800000\t/* Is non-linear (remap_file_pages) */\n#define VM_ARCH_1\t0x01000000\t/* Architecture-specific flag */\n#define VM_DONTDUMP\t0x04000000\t/* Do not include in the core dump */\n\n#define VM_MIXEDMAP\t0x10000000\t/* Can contain \"struct page\" and pure PFN pages */\n#define VM_HUGEPAGE\t0x20000000\t/* MADV_HUGEPAGE marked this vma */\n#define VM_NOHUGEPAGE\t0x40000000\t/* MADV_NOHUGEPAGE marked this vma */\n#define VM_MERGEABLE\t0x80000000\t/* KSM may merge identical pages */\n\n#if defined(CONFIG_X86)\n# define VM_PAT\t\tVM_ARCH_1\t/* PAT reserves whole VMA at once (x86) */\n#elif defined(CONFIG_PPC)\n# define VM_SAO\t\tVM_ARCH_1\t/* Strong Access Ordering (powerpc) */\n#elif defined(CONFIG_PARISC)\n# define VM_GROWSUP\tVM_ARCH_1\n#elif defined(CONFIG_METAG)\n# define VM_GROWSUP\tVM_ARCH_1\n#elif defined(CONFIG_IA64)\n# define VM_GROWSUP\tVM_ARCH_1\n#elif !defined(CONFIG_MMU)\n# define VM_MAPPED_COPY\tVM_ARCH_1\t/* T if mapped copy of data (nommu mmap) */\n#endif\n\n#ifndef VM_GROWSUP\n# define VM_GROWSUP\tVM_NONE\n#endif\n\n/* Bits set in the VMA until the stack is in its final location */\n#define VM_STACK_INCOMPLETE_SETUP\t(VM_RAND_READ | VM_SEQ_READ)\n\n#ifndef VM_STACK_DEFAULT_FLAGS\t\t/* arch can override this */\n#define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS\n#endif\n\n#ifdef CONFIG_STACK_GROWSUP\n#define VM_STACK_FLAGS\t(VM_GROWSUP | VM_STACK_DEFAULT_FLAGS | VM_ACCOUNT)\n#else\n#define VM_STACK_FLAGS\t(VM_GROWSDOWN | VM_STACK_DEFAULT_FLAGS | VM_ACCOUNT)\n#endif\n\n#define VM_READHINTMASK\t\t\t(VM_SEQ_READ | VM_RAND_READ)\n#define VM_ClearReadHint(v)\t\t(v)->vm_flags &= ~VM_READHINTMASK\n#define VM_NormalReadHint(v)\t\t(!((v)->vm_flags & VM_READHINTMASK))\n#define VM_SequentialReadHint(v)\t((v)->vm_flags & VM_SEQ_READ)\n#define VM_RandomReadHint(v)\t\t((v)->vm_flags & VM_RAND_READ)\n\n/*\n * Special vmas that are non-mergable, non-mlock()able.\n * Note: mm/huge_memory.c VM_NO_THP depends on this definition.\n */\n#define VM_SPECIAL (VM_IO | VM_DONTEXPAND | VM_PFNMAP)\n\n/*\n * mapping from the currently active vm_flags protection bits (the\n * low four bits) to a page protection mask..\n */\nextern pgprot_t protection_map[16];\n\n#define FAULT_FLAG_WRITE\t0x01\t/* Fault was a write access */\n#define FAULT_FLAG_NONLINEAR\t0x02\t/* Fault was via a nonlinear mapping */\n#define FAULT_FLAG_MKWRITE\t0x04\t/* Fault was mkwrite of existing pte */\n#define FAULT_FLAG_ALLOW_RETRY\t0x08\t/* Retry fault if blocking */\n#define FAULT_FLAG_RETRY_NOWAIT\t0x10\t/* Don't drop mmap_sem and wait when retrying */\n#define FAULT_FLAG_KILLABLE\t0x20\t/* The fault task is in SIGKILL killable region */\n#define FAULT_FLAG_TRIED\t0x40\t/* second try */\n\n/*\n * vm_fault is filled by the the pagefault handler and passed to the vma's\n * ->fault function. The vma's ->fault is responsible for returning a bitmask\n * of VM_FAULT_xxx flags that give details about how the fault was handled.\n *\n * pgoff should be used in favour of virtual_address, if possible. If pgoff\n * is used, one may implement ->remap_pages to get nonlinear mapping support.\n */\nstruct vm_fault {\n\tunsigned int flags;\t\t/* FAULT_FLAG_xxx flags */\n\tpgoff_t pgoff;\t\t\t/* Logical page offset based on vma */\n\tvoid __user *virtual_address;\t/* Faulting virtual address */\n\n\tstruct page *page;\t\t/* ->fault handlers should return a\n\t\t\t\t\t * page here, unless VM_FAULT_NOPAGE\n\t\t\t\t\t * is set (which is also implied by\n\t\t\t\t\t * VM_FAULT_ERROR).\n\t\t\t\t\t */\n};\n\n/*\n * These are the virtual MM functions - opening of an area, closing and\n * unmapping it (needed to keep files on disk up-to-date etc), pointer\n * to the functions called when a no-page or a wp-page exception occurs. \n */\nstruct vm_operations_struct {\n\tvoid (*open)(struct vm_area_struct * area);\n\tvoid (*close)(struct vm_area_struct * area);\n\tint (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);\n\n\t/* notification that a previously read-only page is about to become\n\t * writable, if an error is returned it will cause a SIGBUS */\n\tint (*page_mkwrite)(struct vm_area_struct *vma, struct vm_fault *vmf);\n\n\t/* called by access_process_vm when get_user_pages() fails, typically\n\t * for use by special VMAs that can switch between memory and hardware\n\t */\n\tint (*access)(struct vm_area_struct *vma, unsigned long addr,\n\t\t      void *buf, int len, int write);\n#ifdef CONFIG_NUMA\n\t/*\n\t * set_policy() op must add a reference to any non-NULL @new mempolicy\n\t * to hold the policy upon return.  Caller should pass NULL @new to\n\t * remove a policy and fall back to surrounding context--i.e. do not\n\t * install a MPOL_DEFAULT policy, nor the task or system default\n\t * mempolicy.\n\t */\n\tint (*set_policy)(struct vm_area_struct *vma, struct mempolicy *new);\n\n\t/*\n\t * get_policy() op must add reference [mpol_get()] to any policy at\n\t * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure\n\t * in mm/mempolicy.c will do this automatically.\n\t * get_policy() must NOT add a ref if the policy at (vma,addr) is not\n\t * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.\n\t * If no [shared/vma] mempolicy exists at the addr, get_policy() op\n\t * must return NULL--i.e., do not \"fallback\" to task or system default\n\t * policy.\n\t */\n\tstruct mempolicy *(*get_policy)(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr);\n\tint (*migrate)(struct vm_area_struct *vma, const nodemask_t *from,\n\t\tconst nodemask_t *to, unsigned long flags);\n#endif\n\t/* called by sys_remap_file_pages() to populate non-linear mapping */\n\tint (*remap_pages)(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t   unsigned long size, pgoff_t pgoff);\n};\n\nstruct mmu_gather;\nstruct inode;\n\n#define page_private(page)\t\t((page)->private)\n#define set_page_private(page, v)\t((page)->private = (v))\n\n/* It's valid only if the page is free path or free_list */\nstatic inline void set_freepage_migratetype(struct page *page, int migratetype)\n{\n\tpage->index = migratetype;\n}\n\n/* It's valid only if the page is free path or free_list */\nstatic inline int get_freepage_migratetype(struct page *page)\n{\n\treturn page->index;\n}\n\n/*\n * FIXME: take this include out, include page-flags.h in\n * files which need it (119 of them)\n */\n#include <linux/page-flags.h>\n#include <linux/huge_mm.h>\n\n/*\n * Methods to modify the page usage count.\n *\n * What counts for a page usage:\n * - cache mapping   (page->mapping)\n * - private data    (page->private)\n * - page mapped in a task's page tables, each mapping\n *   is counted separately\n *\n * Also, many kernel routines increase the page count before a critical\n * routine so they can be sure the page doesn't go away from under them.\n */\n\n/*\n * Drop a ref, return true if the refcount fell to zero (the page has no users)\n */\nstatic inline int put_page_testzero(struct page *page)\n{\n\tVM_BUG_ON(atomic_read(&page->_count) == 0);\n\treturn atomic_dec_and_test(&page->_count);\n}\n\n/*\n * Try to grab a ref unless the page has a refcount of zero, return false if\n * that is the case.\n */\nstatic inline int get_page_unless_zero(struct page *page)\n{\n\treturn atomic_inc_not_zero(&page->_count);\n}\n\nextern int page_is_ram(unsigned long pfn);\n\n/* Support for virtually mapped pages */\nstruct page *vmalloc_to_page(const void *addr);\nunsigned long vmalloc_to_pfn(const void *addr);\n\n/*\n * Determine if an address is within the vmalloc range\n *\n * On nommu, vmalloc/vfree wrap through kmalloc/kfree directly, so there\n * is no special casing required.\n */\nstatic inline int is_vmalloc_addr(const void *x)\n{\n#ifdef CONFIG_MMU\n\tunsigned long addr = (unsigned long)x;\n\n\treturn addr >= VMALLOC_START && addr < VMALLOC_END;\n#else\n\treturn 0;\n#endif\n}\n#ifdef CONFIG_MMU\nextern int is_vmalloc_or_module_addr(const void *x);\n#else\nstatic inline int is_vmalloc_or_module_addr(const void *x)\n{\n\treturn 0;\n}\n#endif\n\nstatic inline void compound_lock(struct page *page)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tVM_BUG_ON(PageSlab(page));\n\tbit_spin_lock(PG_compound_lock, &page->flags);\n#endif\n}\n\nstatic inline void compound_unlock(struct page *page)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tVM_BUG_ON(PageSlab(page));\n\tbit_spin_unlock(PG_compound_lock, &page->flags);\n#endif\n}\n\nstatic inline unsigned long compound_lock_irqsave(struct page *page)\n{\n\tunsigned long uninitialized_var(flags);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tlocal_irq_save(flags);\n\tcompound_lock(page);\n#endif\n\treturn flags;\n}\n\nstatic inline void compound_unlock_irqrestore(struct page *page,\n\t\t\t\t\t      unsigned long flags)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tcompound_unlock(page);\n\tlocal_irq_restore(flags);\n#endif\n}\n\nstatic inline struct page *compound_head(struct page *page)\n{\n\tif (unlikely(PageTail(page)))\n\t\treturn page->first_page;\n\treturn page;\n}\n\n/*\n * The atomic page->_mapcount, starts from -1: so that transitions\n * both from it and to it can be tracked, using atomic_inc_and_test\n * and atomic_add_negative(-1).\n */\nstatic inline void page_mapcount_reset(struct page *page)\n{\n\tatomic_set(&(page)->_mapcount, -1);\n}\n\nstatic inline int page_mapcount(struct page *page)\n{\n\treturn atomic_read(&(page)->_mapcount) + 1;\n}\n\nstatic inline int page_count(struct page *page)\n{\n\treturn atomic_read(&compound_head(page)->_count);\n}\n\nstatic inline void get_huge_page_tail(struct page *page)\n{\n\t/*\n\t * __split_huge_page_refcount() cannot run\n\t * from under us.\n\t */\n\tVM_BUG_ON(page_mapcount(page) < 0);\n\tVM_BUG_ON(atomic_read(&page->_count) != 0);\n\tatomic_inc(&page->_mapcount);\n}\n\nextern bool __get_page_tail(struct page *page);\n\nstatic inline void get_page(struct page *page)\n{\n\tif (unlikely(PageTail(page)))\n\t\tif (likely(__get_page_tail(page)))\n\t\t\treturn;\n\t/*\n\t * Getting a normal page or the head of a compound page\n\t * requires to already have an elevated page->_count.\n\t */\n\tVM_BUG_ON(atomic_read(&page->_count) <= 0);\n\tatomic_inc(&page->_count);\n}\n\nstatic inline struct page *virt_to_head_page(const void *x)\n{\n\tstruct page *page = virt_to_page(x);\n\treturn compound_head(page);\n}\n\n/*\n * Setup the page count before being freed into the page allocator for\n * the first time (boot or memory hotplug)\n */\nstatic inline void init_page_count(struct page *page)\n{\n\tatomic_set(&page->_count, 1);\n}\n\n/*\n * PageBuddy() indicate that the page is free and in the buddy system\n * (see mm/page_alloc.c).\n *\n * PAGE_BUDDY_MAPCOUNT_VALUE must be <= -2 but better not too close to\n * -2 so that an underflow of the page_mapcount() won't be mistaken\n * for a genuine PAGE_BUDDY_MAPCOUNT_VALUE. -128 can be created very\n * efficiently by most CPU architectures.\n */\n#define PAGE_BUDDY_MAPCOUNT_VALUE (-128)\n\nstatic inline int PageBuddy(struct page *page)\n{\n\treturn atomic_read(&page->_mapcount) == PAGE_BUDDY_MAPCOUNT_VALUE;\n}\n\nstatic inline void __SetPageBuddy(struct page *page)\n{\n\tVM_BUG_ON(atomic_read(&page->_mapcount) != -1);\n\tatomic_set(&page->_mapcount, PAGE_BUDDY_MAPCOUNT_VALUE);\n}\n\nstatic inline void __ClearPageBuddy(struct page *page)\n{\n\tVM_BUG_ON(!PageBuddy(page));\n\tatomic_set(&page->_mapcount, -1);\n}\n\nvoid put_page(struct page *page);\nvoid put_pages_list(struct list_head *pages);\n\nvoid split_page(struct page *page, unsigned int order);\nint split_free_page(struct page *page);\n\n/*\n * Compound pages have a destructor function.  Provide a\n * prototype for that function and accessor functions.\n * These are _only_ valid on the head of a PG_compound page.\n */\ntypedef void compound_page_dtor(struct page *);\n\nstatic inline void set_compound_page_dtor(struct page *page,\n\t\t\t\t\t\tcompound_page_dtor *dtor)\n{\n\tpage[1].lru.next = (void *)dtor;\n}\n\nstatic inline compound_page_dtor *get_compound_page_dtor(struct page *page)\n{\n\treturn (compound_page_dtor *)page[1].lru.next;\n}\n\nstatic inline int compound_order(struct page *page)\n{\n\tif (!PageHead(page))\n\t\treturn 0;\n\treturn (unsigned long)page[1].lru.prev;\n}\n\nstatic inline int compound_trans_order(struct page *page)\n{\n\tint order;\n\tunsigned long flags;\n\n\tif (!PageHead(page))\n\t\treturn 0;\n\n\tflags = compound_lock_irqsave(page);\n\torder = compound_order(page);\n\tcompound_unlock_irqrestore(page, flags);\n\treturn order;\n}\n\nstatic inline void set_compound_order(struct page *page, unsigned long order)\n{\n\tpage[1].lru.prev = (void *)order;\n}\n\n#ifdef CONFIG_MMU\n/*\n * Do pte_mkwrite, but only if the vma says VM_WRITE.  We do this when\n * servicing faults for write access.  In the normal case, do always want\n * pte_mkwrite.  But get_user_pages can cause write faults for mappings\n * that do not have writing enabled, when used by access_process_vm.\n */\nstatic inline pte_t maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpte = pte_mkwrite(pte);\n\treturn pte;\n}\n#endif\n\n/*\n * Multiple processes may \"see\" the same page. E.g. for untouched\n * mappings of /dev/null, all processes see the same page full of\n * zeroes, and text pages of executables and shared libraries have\n * only one copy in memory, at most, normally.\n *\n * For the non-reserved pages, page_count(page) denotes a reference count.\n *   page_count() == 0 means the page is free. page->lru is then used for\n *   freelist management in the buddy allocator.\n *   page_count() > 0  means the page has been allocated.\n *\n * Pages are allocated by the slab allocator in order to provide memory\n * to kmalloc and kmem_cache_alloc. In this case, the management of the\n * page, and the fields in 'struct page' are the responsibility of mm/slab.c\n * unless a particular usage is carefully commented. (the responsibility of\n * freeing the kmalloc memory is the caller's, of course).\n *\n * A page may be used by anyone else who does a __get_free_page().\n * In this case, page_count still tracks the references, and should only\n * be used through the normal accessor functions. The top bits of page->flags\n * and page->virtual store page management information, but all other fields\n * are unused and could be used privately, carefully. The management of this\n * page is the responsibility of the one who allocated it, and those who have\n * subsequently been given references to it.\n *\n * The other pages (we may call them \"pagecache pages\") are completely\n * managed by the Linux memory manager: I/O, buffers, swapping etc.\n * The following discussion applies only to them.\n *\n * A pagecache page contains an opaque `private' member, which belongs to the\n * page's address_space. Usually, this is the address of a circular list of\n * the page's disk buffers. PG_private must be set to tell the VM to call\n * into the filesystem to release these pages.\n *\n * A page may belong to an inode's memory mapping. In this case, page->mapping\n * is the pointer to the inode, and page->index is the file offset of the page,\n * in units of PAGE_CACHE_SIZE.\n *\n * If pagecache pages are not associated with an inode, they are said to be\n * anonymous pages. These may become associated with the swapcache, and in that\n * case PG_swapcache is set, and page->private is an offset into the swapcache.\n *\n * In either case (swapcache or inode backed), the pagecache itself holds one\n * reference to the page. Setting PG_private should also increment the\n * refcount. The each user mapping also has a reference to the page.\n *\n * The pagecache pages are stored in a per-mapping radix tree, which is\n * rooted at mapping->page_tree, and indexed by offset.\n * Where 2.4 and early 2.6 kernels kept dirty/clean pages in per-address_space\n * lists, we instead now tag pages as dirty/writeback in the radix tree.\n *\n * All pagecache pages may be subject to I/O:\n * - inode pages may need to be read from disk,\n * - inode pages which have been modified and are MAP_SHARED may need\n *   to be written back to the inode on disk,\n * - anonymous pages (including MAP_PRIVATE file mappings) which have been\n *   modified may need to be swapped out to swap space and (later) to be read\n *   back into memory.\n */\n\n/*\n * The zone field is never updated after free_area_init_core()\n * sets it, so none of the operations on it need to be atomic.\n */\n\n/* Page flags: | [SECTION] | [NODE] | ZONE | [LAST_NID] | ... | FLAGS | */\n#define SECTIONS_PGOFF\t\t((sizeof(unsigned long)*8) - SECTIONS_WIDTH)\n#define NODES_PGOFF\t\t(SECTIONS_PGOFF - NODES_WIDTH)\n#define ZONES_PGOFF\t\t(NODES_PGOFF - ZONES_WIDTH)\n#define LAST_NID_PGOFF\t\t(ZONES_PGOFF - LAST_NID_WIDTH)\n\n/*\n * Define the bit shifts to access each section.  For non-existent\n * sections we define the shift as 0; that plus a 0 mask ensures\n * the compiler will optimise away reference to them.\n */\n#define SECTIONS_PGSHIFT\t(SECTIONS_PGOFF * (SECTIONS_WIDTH != 0))\n#define NODES_PGSHIFT\t\t(NODES_PGOFF * (NODES_WIDTH != 0))\n#define ZONES_PGSHIFT\t\t(ZONES_PGOFF * (ZONES_WIDTH != 0))\n#define LAST_NID_PGSHIFT\t(LAST_NID_PGOFF * (LAST_NID_WIDTH != 0))\n\n/* NODE:ZONE or SECTION:ZONE is used to ID a zone for the buddy allocator */\n#ifdef NODE_NOT_IN_PAGE_FLAGS\n#define ZONEID_SHIFT\t\t(SECTIONS_SHIFT + ZONES_SHIFT)\n#define ZONEID_PGOFF\t\t((SECTIONS_PGOFF < ZONES_PGOFF)? \\\n\t\t\t\t\t\tSECTIONS_PGOFF : ZONES_PGOFF)\n#else\n#define ZONEID_SHIFT\t\t(NODES_SHIFT + ZONES_SHIFT)\n#define ZONEID_PGOFF\t\t((NODES_PGOFF < ZONES_PGOFF)? \\\n\t\t\t\t\t\tNODES_PGOFF : ZONES_PGOFF)\n#endif\n\n#define ZONEID_PGSHIFT\t\t(ZONEID_PGOFF * (ZONEID_SHIFT != 0))\n\n#if SECTIONS_WIDTH+NODES_WIDTH+ZONES_WIDTH > BITS_PER_LONG - NR_PAGEFLAGS\n#error SECTIONS_WIDTH+NODES_WIDTH+ZONES_WIDTH > BITS_PER_LONG - NR_PAGEFLAGS\n#endif\n\n#define ZONES_MASK\t\t((1UL << ZONES_WIDTH) - 1)\n#define NODES_MASK\t\t((1UL << NODES_WIDTH) - 1)\n#define SECTIONS_MASK\t\t((1UL << SECTIONS_WIDTH) - 1)\n#define LAST_NID_MASK\t\t((1UL << LAST_NID_WIDTH) - 1)\n#define ZONEID_MASK\t\t((1UL << ZONEID_SHIFT) - 1)\n\nstatic inline enum zone_type page_zonenum(const struct page *page)\n{\n\treturn (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;\n}\n\n#if defined(CONFIG_SPARSEMEM) && !defined(CONFIG_SPARSEMEM_VMEMMAP)\n#define SECTION_IN_PAGE_FLAGS\n#endif\n\n/*\n * The identification function is only used by the buddy allocator for\n * determining if two pages could be buddies. We are not really\n * identifying a zone since we could be using a the section number\n * id if we have not node id available in page flags.\n * We guarantee only that it will return the same value for two\n * combinable pages in a zone.\n */\nstatic inline int page_zone_id(struct page *page)\n{\n\treturn (page->flags >> ZONEID_PGSHIFT) & ZONEID_MASK;\n}\n\nstatic inline int zone_to_nid(struct zone *zone)\n{\n#ifdef CONFIG_NUMA\n\treturn zone->node;\n#else\n\treturn 0;\n#endif\n}\n\n#ifdef NODE_NOT_IN_PAGE_FLAGS\nextern int page_to_nid(const struct page *page);\n#else\nstatic inline int page_to_nid(const struct page *page)\n{\n\treturn (page->flags >> NODES_PGSHIFT) & NODES_MASK;\n}\n#endif\n\n#ifdef CONFIG_NUMA_BALANCING\n#ifdef LAST_NID_NOT_IN_PAGE_FLAGS\nstatic inline int page_nid_xchg_last(struct page *page, int nid)\n{\n\treturn xchg(&page->_last_nid, nid);\n}\n\nstatic inline int page_nid_last(struct page *page)\n{\n\treturn page->_last_nid;\n}\nstatic inline void page_nid_reset_last(struct page *page)\n{\n\tpage->_last_nid = -1;\n}\n#else\nstatic inline int page_nid_last(struct page *page)\n{\n\treturn (page->flags >> LAST_NID_PGSHIFT) & LAST_NID_MASK;\n}\n\nextern int page_nid_xchg_last(struct page *page, int nid);\n\nstatic inline void page_nid_reset_last(struct page *page)\n{\n\tint nid = (1 << LAST_NID_SHIFT) - 1;\n\n\tpage->flags &= ~(LAST_NID_MASK << LAST_NID_PGSHIFT);\n\tpage->flags |= (nid & LAST_NID_MASK) << LAST_NID_PGSHIFT;\n}\n#endif /* LAST_NID_NOT_IN_PAGE_FLAGS */\n#else\nstatic inline int page_nid_xchg_last(struct page *page, int nid)\n{\n\treturn page_to_nid(page);\n}\n\nstatic inline int page_nid_last(struct page *page)\n{\n\treturn page_to_nid(page);\n}\n\nstatic inline void page_nid_reset_last(struct page *page)\n{\n}\n#endif\n\nstatic inline struct zone *page_zone(const struct page *page)\n{\n\treturn &NODE_DATA(page_to_nid(page))->node_zones[page_zonenum(page)];\n}\n\n#ifdef SECTION_IN_PAGE_FLAGS\nstatic inline void set_page_section(struct page *page, unsigned long section)\n{\n\tpage->flags &= ~(SECTIONS_MASK << SECTIONS_PGSHIFT);\n\tpage->flags |= (section & SECTIONS_MASK) << SECTIONS_PGSHIFT;\n}\n\nstatic inline unsigned long page_to_section(const struct page *page)\n{\n\treturn (page->flags >> SECTIONS_PGSHIFT) & SECTIONS_MASK;\n}\n#endif\n\nstatic inline void set_page_zone(struct page *page, enum zone_type zone)\n{\n\tpage->flags &= ~(ZONES_MASK << ZONES_PGSHIFT);\n\tpage->flags |= (zone & ZONES_MASK) << ZONES_PGSHIFT;\n}\n\nstatic inline void set_page_node(struct page *page, unsigned long node)\n{\n\tpage->flags &= ~(NODES_MASK << NODES_PGSHIFT);\n\tpage->flags |= (node & NODES_MASK) << NODES_PGSHIFT;\n}\n\nstatic inline void set_page_links(struct page *page, enum zone_type zone,\n\tunsigned long node, unsigned long pfn)\n{\n\tset_page_zone(page, zone);\n\tset_page_node(page, node);\n#ifdef SECTION_IN_PAGE_FLAGS\n\tset_page_section(page, pfn_to_section_nr(pfn));\n#endif\n}\n\n/*\n * Some inline functions in vmstat.h depend on page_zone()\n */\n#include <linux/vmstat.h>\n\nstatic __always_inline void *lowmem_page_address(const struct page *page)\n{\n\treturn __va(PFN_PHYS(page_to_pfn(page)));\n}\n\n#if defined(CONFIG_HIGHMEM) && !defined(WANT_PAGE_VIRTUAL)\n#define HASHED_PAGE_VIRTUAL\n#endif\n\n#if defined(WANT_PAGE_VIRTUAL)\n#define page_address(page) ((page)->virtual)\n#define set_page_address(page, address)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t(page)->virtual = (address);\t\t\\\n\t} while(0)\n#define page_address_init()  do { } while(0)\n#endif\n\n#if defined(HASHED_PAGE_VIRTUAL)\nvoid *page_address(const struct page *page);\nvoid set_page_address(struct page *page, void *virtual);\nvoid page_address_init(void);\n#endif\n\n#if !defined(HASHED_PAGE_VIRTUAL) && !defined(WANT_PAGE_VIRTUAL)\n#define page_address(page) lowmem_page_address(page)\n#define set_page_address(page, address)  do { } while(0)\n#define page_address_init()  do { } while(0)\n#endif\n\n/*\n * On an anonymous page mapped into a user virtual memory area,\n * page->mapping points to its anon_vma, not to a struct address_space;\n * with the PAGE_MAPPING_ANON bit set to distinguish it.  See rmap.h.\n *\n * On an anonymous page in a VM_MERGEABLE area, if CONFIG_KSM is enabled,\n * the PAGE_MAPPING_KSM bit may be set along with the PAGE_MAPPING_ANON bit;\n * and then page->mapping points, not to an anon_vma, but to a private\n * structure which KSM associates with that merged page.  See ksm.h.\n *\n * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is currently never used.\n *\n * Please note that, confusingly, \"page_mapping\" refers to the inode\n * address_space which maps the page from disk; whereas \"page_mapped\"\n * refers to user virtual address space into which the page is mapped.\n */\n#define PAGE_MAPPING_ANON\t1\n#define PAGE_MAPPING_KSM\t2\n#define PAGE_MAPPING_FLAGS\t(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)\n\nextern struct address_space *page_mapping(struct page *page);\n\n/* Neutral page->mapping pointer to address_space or anon_vma or other */\nstatic inline void *page_rmapping(struct page *page)\n{\n\treturn (void *)((unsigned long)page->mapping & ~PAGE_MAPPING_FLAGS);\n}\n\nextern struct address_space *__page_file_mapping(struct page *);\n\nstatic inline\nstruct address_space *page_file_mapping(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn __page_file_mapping(page);\n\n\treturn page->mapping;\n}\n\nstatic inline int PageAnon(struct page *page)\n{\n\treturn ((unsigned long)page->mapping & PAGE_MAPPING_ANON) != 0;\n}\n\n/*\n * Return the pagecache index of the passed page.  Regular pagecache pages\n * use ->index whereas swapcache pages use ->private\n */\nstatic inline pgoff_t page_index(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn page_private(page);\n\treturn page->index;\n}\n\nextern pgoff_t __page_file_index(struct page *page);\n\n/*\n * Return the file index of the page. Regular pagecache pages use ->index\n * whereas swapcache pages use swp_offset(->private)\n */\nstatic inline pgoff_t page_file_index(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn __page_file_index(page);\n\n\treturn page->index;\n}\n\n/*\n * Return true if this page is mapped into pagetables.\n */\nstatic inline int page_mapped(struct page *page)\n{\n\treturn atomic_read(&(page)->_mapcount) >= 0;\n}\n\n/*\n * Different kinds of faults, as returned by handle_mm_fault().\n * Used to decide whether a process gets delivered SIGBUS or\n * just gets major/minor fault counters bumped up.\n */\n\n#define VM_FAULT_MINOR\t0 /* For backwards compat. Remove me quickly. */\n\n#define VM_FAULT_OOM\t0x0001\n#define VM_FAULT_SIGBUS\t0x0002\n#define VM_FAULT_MAJOR\t0x0004\n#define VM_FAULT_WRITE\t0x0008\t/* Special case for get_user_pages */\n#define VM_FAULT_HWPOISON 0x0010\t/* Hit poisoned small page */\n#define VM_FAULT_HWPOISON_LARGE 0x0020  /* Hit poisoned large page. Index encoded in upper bits */\n\n#define VM_FAULT_NOPAGE\t0x0100\t/* ->fault installed the pte, not return page */\n#define VM_FAULT_LOCKED\t0x0200\t/* ->fault locked the returned page */\n#define VM_FAULT_RETRY\t0x0400\t/* ->fault blocked, must retry */\n\n#define VM_FAULT_HWPOISON_LARGE_MASK 0xf000 /* encodes hpage index for large hwpoison */\n\n#define VM_FAULT_ERROR\t(VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_HWPOISON | \\\n\t\t\t VM_FAULT_HWPOISON_LARGE)\n\n/* Encode hstate index for a hwpoisoned large page */\n#define VM_FAULT_SET_HINDEX(x) ((x) << 12)\n#define VM_FAULT_GET_HINDEX(x) (((x) >> 12) & 0xf)\n\n/*\n * Can be called by the pagefault handler when it gets a VM_FAULT_OOM.\n */\nextern void pagefault_out_of_memory(void);\n\n#define offset_in_page(p)\t((unsigned long)(p) & ~PAGE_MASK)\n\n/*\n * Flags passed to show_mem() and show_free_areas() to suppress output in\n * various contexts.\n */\n#define SHOW_MEM_FILTER_NODES\t(0x0001u)\t/* filter disallowed nodes */\n\nextern void show_free_areas(unsigned int flags);\nextern bool skip_free_areas_node(unsigned int flags, int nid);\n\nint shmem_zero_setup(struct vm_area_struct *);\n\nextern int can_do_mlock(void);\nextern int user_shm_lock(size_t, struct user_struct *);\nextern void user_shm_unlock(size_t, struct user_struct *);\n\n/*\n * Parameter block passed down to zap_pte_range in exceptional cases.\n */\nstruct zap_details {\n\tstruct vm_area_struct *nonlinear_vma;\t/* Check page->index if set */\n\tstruct address_space *check_mapping;\t/* Check page->mapping if set */\n\tpgoff_t\tfirst_index;\t\t\t/* Lowest page->index to unmap */\n\tpgoff_t last_index;\t\t\t/* Highest page->index to unmap */\n};\n\nstruct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\tpte_t pte);\n\nint zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size);\nvoid zap_page_range(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *);\nvoid unmap_vmas(struct mmu_gather *tlb, struct vm_area_struct *start_vma,\n\t\tunsigned long start, unsigned long end);\n\n/**\n * mm_walk - callbacks for walk_page_range\n * @pgd_entry: if set, called for each non-empty PGD (top-level) entry\n * @pud_entry: if set, called for each non-empty PUD (2nd-level) entry\n * @pmd_entry: if set, called for each non-empty PMD (3rd-level) entry\n *\t       this handler is required to be able to handle\n *\t       pmd_trans_huge() pmds.  They may simply choose to\n *\t       split_huge_page() instead of handling it explicitly.\n * @pte_entry: if set, called for each non-empty PTE (4th-level) entry\n * @pte_hole: if set, called for each hole at all levels\n * @hugetlb_entry: if set, called for each hugetlb entry\n *\t\t   *Caution*: The caller must hold mmap_sem() if @hugetlb_entry\n * \t\t\t      is used.\n *\n * (see walk_page_range for more details)\n */\nstruct mm_walk {\n\tint (*pgd_entry)(pgd_t *, unsigned long, unsigned long, struct mm_walk *);\n\tint (*pud_entry)(pud_t *, unsigned long, unsigned long, struct mm_walk *);\n\tint (*pmd_entry)(pmd_t *, unsigned long, unsigned long, struct mm_walk *);\n\tint (*pte_entry)(pte_t *, unsigned long, unsigned long, struct mm_walk *);\n\tint (*pte_hole)(unsigned long, unsigned long, struct mm_walk *);\n\tint (*hugetlb_entry)(pte_t *, unsigned long,\n\t\t\t     unsigned long, unsigned long, struct mm_walk *);\n\tstruct mm_struct *mm;\n\tvoid *private;\n};\n\nint walk_page_range(unsigned long addr, unsigned long end,\n\t\tstruct mm_walk *walk);\nvoid free_pgd_range(struct mmu_gather *tlb, unsigned long addr,\n\t\tunsigned long end, unsigned long floor, unsigned long ceiling);\nint copy_page_range(struct mm_struct *dst, struct mm_struct *src,\n\t\t\tstruct vm_area_struct *vma);\nvoid unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows);\nint follow_pfn(struct vm_area_struct *vma, unsigned long address,\n\tunsigned long *pfn);\nint follow_phys(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags, unsigned long *prot, resource_size_t *phys);\nint generic_access_phys(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tvoid *buf, int len, int write);\n\nstatic inline void unmap_shared_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen)\n{\n\tunmap_mapping_range(mapping, holebegin, holelen, 0);\n}\n\nextern void truncate_pagecache(struct inode *inode, loff_t old, loff_t new);\nextern void truncate_setsize(struct inode *inode, loff_t newsize);\nvoid truncate_pagecache_range(struct inode *inode, loff_t offset, loff_t end);\nint truncate_inode_page(struct address_space *mapping, struct page *page);\nint generic_error_remove_page(struct address_space *mapping, struct page *page);\nint invalidate_inode_page(struct page *page);\n\n#ifdef CONFIG_MMU\nextern int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags);\nextern int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,\n\t\t\t    unsigned long address, unsigned int fault_flags);\n#else\nstatic inline int handle_mm_fault(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long address,\n\t\t\tunsigned int flags)\n{\n\t/* should never happen if there's no MMU */\n\tBUG();\n\treturn VM_FAULT_SIGBUS;\n}\nstatic inline int fixup_user_fault(struct task_struct *tsk,\n\t\tstruct mm_struct *mm, unsigned long address,\n\t\tunsigned int fault_flags)\n{\n\t/* should never happen if there's no MMU */\n\tBUG();\n\treturn -EFAULT;\n}\n#endif\n\nextern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);\nextern int access_remote_vm(struct mm_struct *mm, unsigned long addr,\n\t\tvoid *buf, int len, int write);\n\nlong __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\t      unsigned long start, unsigned long nr_pages,\n\t\t      unsigned int foll_flags, struct page **pages,\n\t\t      struct vm_area_struct **vmas, int *nonblocking);\nlong get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\t    unsigned long start, unsigned long nr_pages,\n\t\t    int write, int force, struct page **pages,\n\t\t    struct vm_area_struct **vmas);\nint get_user_pages_fast(unsigned long start, int nr_pages, int write,\n\t\t\tstruct page **pages);\nstruct kvec;\nint get_kernel_pages(const struct kvec *iov, int nr_pages, int write,\n\t\t\tstruct page **pages);\nint get_kernel_page(unsigned long start, int write, struct page **pages);\nstruct page *get_dump_page(unsigned long addr);\n\nextern int try_to_release_page(struct page * page, gfp_t gfp_mask);\nextern void do_invalidatepage(struct page *page, unsigned long offset);\n\nint __set_page_dirty_nobuffers(struct page *page);\nint __set_page_dirty_no_writeback(struct page *page);\nint redirty_page_for_writepage(struct writeback_control *wbc,\n\t\t\t\tstruct page *page);\nvoid account_page_dirtied(struct page *page, struct address_space *mapping);\nvoid account_page_writeback(struct page *page);\nint set_page_dirty(struct page *page);\nint set_page_dirty_lock(struct page *page);\nint clear_page_dirty_for_io(struct page *page);\n\n/* Is the vma a continuation of the stack vma above it? */\nstatic inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)\n{\n\treturn vma && (vma->vm_end == addr) && (vma->vm_flags & VM_GROWSDOWN);\n}\n\nstatic inline int stack_guard_page_start(struct vm_area_struct *vma,\n\t\t\t\t\t     unsigned long addr)\n{\n\treturn (vma->vm_flags & VM_GROWSDOWN) &&\n\t\t(vma->vm_start == addr) &&\n\t\t!vma_growsdown(vma->vm_prev, addr);\n}\n\n/* Is the vma a continuation of the stack vma below it? */\nstatic inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)\n{\n\treturn vma && (vma->vm_start == addr) && (vma->vm_flags & VM_GROWSUP);\n}\n\nstatic inline int stack_guard_page_end(struct vm_area_struct *vma,\n\t\t\t\t\t   unsigned long addr)\n{\n\treturn (vma->vm_flags & VM_GROWSUP) &&\n\t\t(vma->vm_end == addr) &&\n\t\t!vma_growsup(vma->vm_next, addr);\n}\n\nextern pid_t\nvm_is_stack(struct task_struct *task, struct vm_area_struct *vma, int in_group);\n\nextern unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks);\nextern unsigned long do_mremap(unsigned long addr,\n\t\t\t       unsigned long old_len, unsigned long new_len,\n\t\t\t       unsigned long flags, unsigned long new_addr);\nextern unsigned long change_protection(struct vm_area_struct *vma, unsigned long start,\n\t\t\t      unsigned long end, pgprot_t newprot,\n\t\t\t      int dirty_accountable, int prot_numa);\nextern int mprotect_fixup(struct vm_area_struct *vma,\n\t\t\t  struct vm_area_struct **pprev, unsigned long start,\n\t\t\t  unsigned long end, unsigned long newflags);\n\n/*\n * doesn't attempt to fault and will return short.\n */\nint __get_user_pages_fast(unsigned long start, int nr_pages, int write,\n\t\t\t  struct page **pages);\n/*\n * per-process(per-mm_struct) statistics.\n */\nstatic inline unsigned long get_mm_counter(struct mm_struct *mm, int member)\n{\n\tlong val = atomic_long_read(&mm->rss_stat.count[member]);\n\n#ifdef SPLIT_RSS_COUNTING\n\t/*\n\t * counter is updated in asynchronous manner and may go to minus.\n\t * But it's never be expected number for users.\n\t */\n\tif (val < 0)\n\t\tval = 0;\n#endif\n\treturn (unsigned long)val;\n}\n\nstatic inline void add_mm_counter(struct mm_struct *mm, int member, long value)\n{\n\tatomic_long_add(value, &mm->rss_stat.count[member]);\n}\n\nstatic inline void inc_mm_counter(struct mm_struct *mm, int member)\n{\n\tatomic_long_inc(&mm->rss_stat.count[member]);\n}\n\nstatic inline void dec_mm_counter(struct mm_struct *mm, int member)\n{\n\tatomic_long_dec(&mm->rss_stat.count[member]);\n}\n\nstatic inline unsigned long get_mm_rss(struct mm_struct *mm)\n{\n\treturn get_mm_counter(mm, MM_FILEPAGES) +\n\t\tget_mm_counter(mm, MM_ANONPAGES);\n}\n\nstatic inline unsigned long get_mm_hiwater_rss(struct mm_struct *mm)\n{\n\treturn max(mm->hiwater_rss, get_mm_rss(mm));\n}\n\nstatic inline unsigned long get_mm_hiwater_vm(struct mm_struct *mm)\n{\n\treturn max(mm->hiwater_vm, mm->total_vm);\n}\n\nstatic inline void update_hiwater_rss(struct mm_struct *mm)\n{\n\tunsigned long _rss = get_mm_rss(mm);\n\n\tif ((mm)->hiwater_rss < _rss)\n\t\t(mm)->hiwater_rss = _rss;\n}\n\nstatic inline void update_hiwater_vm(struct mm_struct *mm)\n{\n\tif (mm->hiwater_vm < mm->total_vm)\n\t\tmm->hiwater_vm = mm->total_vm;\n}\n\nstatic inline void setmax_mm_hiwater_rss(unsigned long *maxrss,\n\t\t\t\t\t struct mm_struct *mm)\n{\n\tunsigned long hiwater_rss = get_mm_hiwater_rss(mm);\n\n\tif (*maxrss < hiwater_rss)\n\t\t*maxrss = hiwater_rss;\n}\n\n#if defined(SPLIT_RSS_COUNTING)\nvoid sync_mm_rss(struct mm_struct *mm);\n#else\nstatic inline void sync_mm_rss(struct mm_struct *mm)\n{\n}\n#endif\n\nint vma_wants_writenotify(struct vm_area_struct *vma);\n\nextern pte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\t       spinlock_t **ptl);\nstatic inline pte_t *get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\t\t    spinlock_t **ptl)\n{\n\tpte_t *ptep;\n\t__cond_lock(*ptl, ptep = __get_locked_pte(mm, addr, ptl));\n\treturn ptep;\n}\n\n#ifdef __PAGETABLE_PUD_FOLDED\nstatic inline int __pud_alloc(struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t\t\tunsigned long address)\n{\n\treturn 0;\n}\n#else\nint __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address);\n#endif\n\n#ifdef __PAGETABLE_PMD_FOLDED\nstatic inline int __pmd_alloc(struct mm_struct *mm, pud_t *pud,\n\t\t\t\t\t\tunsigned long address)\n{\n\treturn 0;\n}\n#else\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address);\n#endif\n\nint __pte_alloc(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long address);\nint __pte_alloc_kernel(pmd_t *pmd, unsigned long address);\n\n/*\n * The following ifdef needed to get the 4level-fixup.h header to work.\n * Remove it when 4level-fixup.h has been removed.\n */\n#if defined(CONFIG_MMU) && !defined(__ARCH_HAS_4LEVEL_HACK)\nstatic inline pud_t *pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\treturn (unlikely(pgd_none(*pgd)) && __pud_alloc(mm, pgd, address))?\n\t\tNULL: pud_offset(pgd, address);\n}\n\nstatic inline pmd_t *pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\treturn (unlikely(pud_none(*pud)) && __pmd_alloc(mm, pud, address))?\n\t\tNULL: pmd_offset(pud, address);\n}\n#endif /* CONFIG_MMU && !__ARCH_HAS_4LEVEL_HACK */\n\n#if USE_SPLIT_PTLOCKS\n/*\n * We tuck a spinlock to guard each pagetable page into its struct page,\n * at page->private, with BUILD_BUG_ON to make sure that this will not\n * overflow into the next struct page (as it might with DEBUG_SPINLOCK).\n * When freeing, reset page->mapping so free_pages_check won't complain.\n */\n#define __pte_lockptr(page)\t&((page)->ptl)\n#define pte_lock_init(_page)\tdo {\t\t\t\t\t\\\n\tspin_lock_init(__pte_lockptr(_page));\t\t\t\t\\\n} while (0)\n#define pte_lock_deinit(page)\t((page)->mapping = NULL)\n#define pte_lockptr(mm, pmd)\t({(void)(mm); __pte_lockptr(pmd_page(*(pmd)));})\n#else\t/* !USE_SPLIT_PTLOCKS */\n/*\n * We use mm->page_table_lock to guard all pagetable pages of the mm.\n */\n#define pte_lock_init(page)\tdo {} while (0)\n#define pte_lock_deinit(page)\tdo {} while (0)\n#define pte_lockptr(mm, pmd)\t({(void)(pmd); &(mm)->page_table_lock;})\n#endif /* USE_SPLIT_PTLOCKS */\n\nstatic inline void pgtable_page_ctor(struct page *page)\n{\n\tpte_lock_init(page);\n\tinc_zone_page_state(page, NR_PAGETABLE);\n}\n\nstatic inline void pgtable_page_dtor(struct page *page)\n{\n\tpte_lock_deinit(page);\n\tdec_zone_page_state(page, NR_PAGETABLE);\n}\n\n#define pte_offset_map_lock(mm, pmd, address, ptlp)\t\\\n({\t\t\t\t\t\t\t\\\n\tspinlock_t *__ptl = pte_lockptr(mm, pmd);\t\\\n\tpte_t *__pte = pte_offset_map(pmd, address);\t\\\n\t*(ptlp) = __ptl;\t\t\t\t\\\n\tspin_lock(__ptl);\t\t\t\t\\\n\t__pte;\t\t\t\t\t\t\\\n})\n\n#define pte_unmap_unlock(pte, ptl)\tdo {\t\t\\\n\tspin_unlock(ptl);\t\t\t\t\\\n\tpte_unmap(pte);\t\t\t\t\t\\\n} while (0)\n\n#define pte_alloc_map(mm, vma, pmd, address)\t\t\t\t\\\n\t((unlikely(pmd_none(*(pmd))) && __pte_alloc(mm, vma,\t\\\n\t\t\t\t\t\t\tpmd, address))?\t\\\n\t NULL: pte_offset_map(pmd, address))\n\n#define pte_alloc_map_lock(mm, pmd, address, ptlp)\t\\\n\t((unlikely(pmd_none(*(pmd))) && __pte_alloc(mm, NULL,\t\\\n\t\t\t\t\t\t\tpmd, address))?\t\\\n\t\tNULL: pte_offset_map_lock(mm, pmd, address, ptlp))\n\n#define pte_alloc_kernel(pmd, address)\t\t\t\\\n\t((unlikely(pmd_none(*(pmd))) && __pte_alloc_kernel(pmd, address))? \\\n\t\tNULL: pte_offset_kernel(pmd, address))\n\nextern void free_area_init(unsigned long * zones_size);\nextern void free_area_init_node(int nid, unsigned long * zones_size,\n\t\tunsigned long zone_start_pfn, unsigned long *zholes_size);\nextern void free_initmem(void);\n\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n/*\n * With CONFIG_HAVE_MEMBLOCK_NODE_MAP set, an architecture may initialise its\n * zones, allocate the backing mem_map and account for memory holes in a more\n * architecture independent manner. This is a substitute for creating the\n * zone_sizes[] and zholes_size[] arrays and passing them to\n * free_area_init_node()\n *\n * An architecture is expected to register range of page frames backed by\n * physical memory with memblock_add[_node]() before calling\n * free_area_init_nodes() passing in the PFN each zone ends at. At a basic\n * usage, an architecture is expected to do something like\n *\n * unsigned long max_zone_pfns[MAX_NR_ZONES] = {max_dma, max_normal_pfn,\n * \t\t\t\t\t\t\t max_highmem_pfn};\n * for_each_valid_physical_page_range()\n * \tmemblock_add_node(base, size, nid)\n * free_area_init_nodes(max_zone_pfns);\n *\n * free_bootmem_with_active_regions() calls free_bootmem_node() for each\n * registered physical page range.  Similarly\n * sparse_memory_present_with_active_regions() calls memory_present() for\n * each range when SPARSEMEM is enabled.\n *\n * See mm/page_alloc.c for more information on each function exposed by\n * CONFIG_HAVE_MEMBLOCK_NODE_MAP.\n */\nextern void free_area_init_nodes(unsigned long *max_zone_pfn);\nunsigned long node_map_pfn_alignment(void);\nunsigned long __absent_pages_in_range(int nid, unsigned long start_pfn,\n\t\t\t\t\t\tunsigned long end_pfn);\nextern unsigned long absent_pages_in_range(unsigned long start_pfn,\n\t\t\t\t\t\tunsigned long end_pfn);\nextern void get_pfn_range_for_nid(unsigned int nid,\n\t\t\tunsigned long *start_pfn, unsigned long *end_pfn);\nextern unsigned long find_min_pfn_with_active_regions(void);\nextern void free_bootmem_with_active_regions(int nid,\n\t\t\t\t\t\tunsigned long max_low_pfn);\nextern void sparse_memory_present_with_active_regions(int nid);\n\n#endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\n\n#if !defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) && \\\n    !defined(CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID)\nstatic inline int __early_pfn_to_nid(unsigned long pfn)\n{\n\treturn 0;\n}\n#else\n/* please see mm/page_alloc.c */\nextern int __meminit early_pfn_to_nid(unsigned long pfn);\n#ifdef CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID\n/* there is a per-arch backend function. */\nextern int __meminit __early_pfn_to_nid(unsigned long pfn);\n#endif /* CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID */\n#endif\n\nextern void set_dma_reserve(unsigned long new_dma_reserve);\nextern void memmap_init_zone(unsigned long, int, unsigned long,\n\t\t\t\tunsigned long, enum memmap_context);\nextern void setup_per_zone_wmarks(void);\nextern int __meminit init_per_zone_wmark_min(void);\nextern void mem_init(void);\nextern void __init mmap_init(void);\nextern void show_mem(unsigned int flags);\nextern void si_meminfo(struct sysinfo * val);\nextern void si_meminfo_node(struct sysinfo *val, int nid);\n\nextern __printf(3, 4)\nvoid warn_alloc_failed(gfp_t gfp_mask, int order, const char *fmt, ...);\n\nextern void setup_per_cpu_pageset(void);\n\nextern void zone_pcp_update(struct zone *zone);\nextern void zone_pcp_reset(struct zone *zone);\n\n/* page_alloc.c */\nextern int min_free_kbytes;\n\n/* nommu.c */\nextern atomic_long_t mmap_pages_allocated;\nextern int nommu_shrink_inode_mappings(struct inode *, size_t, size_t);\n\n/* interval_tree.c */\nvoid vma_interval_tree_insert(struct vm_area_struct *node,\n\t\t\t      struct rb_root *root);\nvoid vma_interval_tree_insert_after(struct vm_area_struct *node,\n\t\t\t\t    struct vm_area_struct *prev,\n\t\t\t\t    struct rb_root *root);\nvoid vma_interval_tree_remove(struct vm_area_struct *node,\n\t\t\t      struct rb_root *root);\nstruct vm_area_struct *vma_interval_tree_iter_first(struct rb_root *root,\n\t\t\t\tunsigned long start, unsigned long last);\nstruct vm_area_struct *vma_interval_tree_iter_next(struct vm_area_struct *node,\n\t\t\t\tunsigned long start, unsigned long last);\n\n#define vma_interval_tree_foreach(vma, root, start, last)\t\t\\\n\tfor (vma = vma_interval_tree_iter_first(root, start, last);\t\\\n\t     vma; vma = vma_interval_tree_iter_next(vma, start, last))\n\nstatic inline void vma_nonlinear_insert(struct vm_area_struct *vma,\n\t\t\t\t\tstruct list_head *list)\n{\n\tlist_add_tail(&vma->shared.nonlinear, list);\n}\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root *root);\nvoid anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root *root);\nstruct anon_vma_chain *anon_vma_interval_tree_iter_first(\n\tstruct rb_root *root, unsigned long start, unsigned long last);\nstruct anon_vma_chain *anon_vma_interval_tree_iter_next(\n\tstruct anon_vma_chain *node, unsigned long start, unsigned long last);\n#ifdef CONFIG_DEBUG_VM_RB\nvoid anon_vma_interval_tree_verify(struct anon_vma_chain *node);\n#endif\n\n#define anon_vma_interval_tree_foreach(avc, root, start, last)\t\t \\\n\tfor (avc = anon_vma_interval_tree_iter_first(root, start, last); \\\n\t     avc; avc = anon_vma_interval_tree_iter_next(avc, start, last))\n\n/* mmap.c */\nextern int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin);\nextern int vma_adjust(struct vm_area_struct *vma, unsigned long start,\n\tunsigned long end, pgoff_t pgoff, struct vm_area_struct *insert);\nextern struct vm_area_struct *vma_merge(struct mm_struct *,\n\tstruct vm_area_struct *prev, unsigned long addr, unsigned long end,\n\tunsigned long vm_flags, struct anon_vma *, struct file *, pgoff_t,\n\tstruct mempolicy *);\nextern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *);\nextern int split_vma(struct mm_struct *,\n\tstruct vm_area_struct *, unsigned long addr, int new_below);\nextern int insert_vm_struct(struct mm_struct *, struct vm_area_struct *);\nextern void __vma_link_rb(struct mm_struct *, struct vm_area_struct *,\n\tstruct rb_node **, struct rb_node *);\nextern void unlink_file_vma(struct vm_area_struct *);\nextern struct vm_area_struct *copy_vma(struct vm_area_struct **,\n\tunsigned long addr, unsigned long len, pgoff_t pgoff,\n\tbool *need_rmap_locks);\nextern void exit_mmap(struct mm_struct *);\n\nextern int mm_take_all_locks(struct mm_struct *mm);\nextern void mm_drop_all_locks(struct mm_struct *mm);\n\nextern void set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file);\nextern struct file *get_mm_exe_file(struct mm_struct *mm);\n\nextern int may_expand_vm(struct mm_struct *mm, unsigned long npages);\nextern int install_special_mapping(struct mm_struct *mm,\n\t\t\t\t   unsigned long addr, unsigned long len,\n\t\t\t\t   unsigned long flags, struct page **pages);\n\nextern unsigned long get_unmapped_area(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\nextern unsigned long mmap_region(struct file *file, unsigned long addr,\n\tunsigned long len, vm_flags_t vm_flags, unsigned long pgoff);\nextern unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot, unsigned long flags,\n\tunsigned long pgoff, unsigned long *populate);\nextern int do_munmap(struct mm_struct *, unsigned long, size_t);\n\n#ifdef CONFIG_MMU\nextern int __mm_populate(unsigned long addr, unsigned long len,\n\t\t\t int ignore_errors);\nstatic inline void mm_populate(unsigned long addr, unsigned long len)\n{\n\t/* Ignore errors */\n\t(void) __mm_populate(addr, len, 1);\n}\n#else\nstatic inline void mm_populate(unsigned long addr, unsigned long len) {}\n#endif\n\n/* These take the mm semaphore themselves */\nextern unsigned long vm_brk(unsigned long, unsigned long);\nextern int vm_munmap(unsigned long, size_t);\nextern unsigned long vm_mmap(struct file *, unsigned long,\n        unsigned long, unsigned long,\n        unsigned long, unsigned long);\n\nstruct vm_unmapped_area_info {\n#define VM_UNMAPPED_AREA_TOPDOWN 1\n\tunsigned long flags;\n\tunsigned long length;\n\tunsigned long low_limit;\n\tunsigned long high_limit;\n\tunsigned long align_mask;\n\tunsigned long align_offset;\n};\n\nextern unsigned long unmapped_area(struct vm_unmapped_area_info *info);\nextern unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info);\n\n/*\n * Search for an unmapped address range.\n *\n * We are looking for a range that:\n * - does not intersect with any VMA;\n * - is contained within the [low_limit, high_limit) interval;\n * - is at least the desired size.\n * - satisfies (begin_addr & align_mask) == (align_offset & align_mask)\n */\nstatic inline unsigned long\nvm_unmapped_area(struct vm_unmapped_area_info *info)\n{\n\tif (!(info->flags & VM_UNMAPPED_AREA_TOPDOWN))\n\t\treturn unmapped_area(info);\n\telse\n\t\treturn unmapped_area_topdown(info);\n}\n\n/* truncate.c */\nextern void truncate_inode_pages(struct address_space *, loff_t);\nextern void truncate_inode_pages_range(struct address_space *,\n\t\t\t\t       loff_t lstart, loff_t lend);\n\n/* generic vm_area_ops exported for stackable file systems */\nextern int filemap_fault(struct vm_area_struct *, struct vm_fault *);\nextern int filemap_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);\n\n/* mm/page-writeback.c */\nint write_one_page(struct page *page, int wait);\nvoid task_dirty_inc(struct task_struct *tsk);\n\n/* readahead.c */\n#define VM_MAX_READAHEAD\t128\t/* kbytes */\n#define VM_MIN_READAHEAD\t16\t/* kbytes (includes current page) */\n\nint force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\tpgoff_t offset, unsigned long nr_to_read);\n\nvoid page_cache_sync_readahead(struct address_space *mapping,\n\t\t\t       struct file_ra_state *ra,\n\t\t\t       struct file *filp,\n\t\t\t       pgoff_t offset,\n\t\t\t       unsigned long size);\n\nvoid page_cache_async_readahead(struct address_space *mapping,\n\t\t\t\tstruct file_ra_state *ra,\n\t\t\t\tstruct file *filp,\n\t\t\t\tstruct page *pg,\n\t\t\t\tpgoff_t offset,\n\t\t\t\tunsigned long size);\n\nunsigned long max_sane_readahead(unsigned long nr);\nunsigned long ra_submit(struct file_ra_state *ra,\n\t\t\tstruct address_space *mapping,\n\t\t\tstruct file *filp);\n\n/* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */\nextern int expand_stack(struct vm_area_struct *vma, unsigned long address);\n\n/* CONFIG_STACK_GROWSUP still needs to to grow downwards at some places */\nextern int expand_downwards(struct vm_area_struct *vma,\n\t\tunsigned long address);\n#if VM_GROWSUP\nextern int expand_upwards(struct vm_area_struct *vma, unsigned long address);\n#else\n  #define expand_upwards(vma, address) do { } while (0)\n#endif\n\n/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */\nextern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);\nextern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,\n\t\t\t\t\t     struct vm_area_struct **pprev);\n\n/* Look up the first VMA which intersects the interval start_addr..end_addr-1,\n   NULL if none.  Assume start_addr < end_addr. */\nstatic inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)\n{\n\tstruct vm_area_struct * vma = find_vma(mm,start_addr);\n\n\tif (vma && end_addr <= vma->vm_start)\n\t\tvma = NULL;\n\treturn vma;\n}\n\nstatic inline unsigned long vma_pages(struct vm_area_struct *vma)\n{\n\treturn (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\n}\n\n/* Look up the first VMA which exactly match the interval vm_start ... vm_end */\nstatic inline struct vm_area_struct *find_exact_vma(struct mm_struct *mm,\n\t\t\t\tunsigned long vm_start, unsigned long vm_end)\n{\n\tstruct vm_area_struct *vma = find_vma(mm, vm_start);\n\n\tif (vma && (vma->vm_start != vm_start || vma->vm_end != vm_end))\n\t\tvma = NULL;\n\n\treturn vma;\n}\n\n#ifdef CONFIG_MMU\npgprot_t vm_get_page_prot(unsigned long vm_flags);\n#else\nstatic inline pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\treturn __pgprot(0);\n}\n#endif\n\n#ifdef CONFIG_ARCH_USES_NUMA_PROT_NONE\nunsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long start, unsigned long end);\n#endif\n\nstruct vm_area_struct *find_extend_vma(struct mm_struct *, unsigned long addr);\nint remap_pfn_range(struct vm_area_struct *, unsigned long addr,\n\t\t\tunsigned long pfn, unsigned long size, pgprot_t);\nint vm_insert_page(struct vm_area_struct *, unsigned long addr, struct page *);\nint vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn);\nint vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn);\n\nstruct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int foll_flags,\n\t\t\t      unsigned int *page_mask);\n\nstatic inline struct page *follow_page(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int foll_flags)\n{\n\tunsigned int unused_page_mask;\n\treturn follow_page_mask(vma, address, foll_flags, &unused_page_mask);\n}\n\n#define FOLL_WRITE\t0x01\t/* check pte is writable */\n#define FOLL_TOUCH\t0x02\t/* mark page accessed */\n#define FOLL_GET\t0x04\t/* do get_page on page */\n#define FOLL_DUMP\t0x08\t/* give error on hole if it would be zero */\n#define FOLL_FORCE\t0x10\t/* get_user_pages read/write w/o permission */\n#define FOLL_NOWAIT\t0x20\t/* if a disk transfer is needed, start the IO\n\t\t\t\t * and return without waiting upon it */\n#define FOLL_MLOCK\t0x40\t/* mark page as mlocked */\n#define FOLL_SPLIT\t0x80\t/* don't return transhuge pages, split them */\n#define FOLL_HWPOISON\t0x100\t/* check page is hwpoisoned */\n#define FOLL_NUMA\t0x200\t/* force NUMA hinting page fault */\n#define FOLL_MIGRATION\t0x400\t/* wait for page to replace migration entry */\n\ntypedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,\n\t\t\tvoid *data);\nextern int apply_to_page_range(struct mm_struct *mm, unsigned long address,\n\t\t\t       unsigned long size, pte_fn_t fn, void *data);\n\n#ifdef CONFIG_PROC_FS\nvoid vm_stat_account(struct mm_struct *, unsigned long, struct file *, long);\n#else\nstatic inline void vm_stat_account(struct mm_struct *mm,\n\t\t\tunsigned long flags, struct file *file, long pages)\n{\n\tmm->total_vm += pages;\n}\n#endif /* CONFIG_PROC_FS */\n\n#ifdef CONFIG_DEBUG_PAGEALLOC\nextern void kernel_map_pages(struct page *page, int numpages, int enable);\n#ifdef CONFIG_HIBERNATION\nextern bool kernel_page_present(struct page *page);\n#endif /* CONFIG_HIBERNATION */\n#else\nstatic inline void\nkernel_map_pages(struct page *page, int numpages, int enable) {}\n#ifdef CONFIG_HIBERNATION\nstatic inline bool kernel_page_present(struct page *page) { return true; }\n#endif /* CONFIG_HIBERNATION */\n#endif\n\nextern struct vm_area_struct *get_gate_vma(struct mm_struct *mm);\n#ifdef\t__HAVE_ARCH_GATE_AREA\nint in_gate_area_no_mm(unsigned long addr);\nint in_gate_area(struct mm_struct *mm, unsigned long addr);\n#else\nint in_gate_area_no_mm(unsigned long addr);\n#define in_gate_area(mm, addr) ({(void)mm; in_gate_area_no_mm(addr);})\n#endif\t/* __HAVE_ARCH_GATE_AREA */\n\nint drop_caches_sysctl_handler(struct ctl_table *, int,\n\t\t\t\t\tvoid __user *, size_t *, loff_t *);\nunsigned long shrink_slab(struct shrink_control *shrink,\n\t\t\t  unsigned long nr_pages_scanned,\n\t\t\t  unsigned long lru_pages);\n\n#ifndef CONFIG_MMU\n#define randomize_va_space 0\n#else\nextern int randomize_va_space;\n#endif\n\nconst char * arch_vma_name(struct vm_area_struct *vma);\nvoid print_vma_addr(char *prefix, unsigned long rip);\n\nvoid sparse_mem_maps_populate_node(struct page **map_map,\n\t\t\t\t   unsigned long pnum_begin,\n\t\t\t\t   unsigned long pnum_end,\n\t\t\t\t   unsigned long map_count,\n\t\t\t\t   int nodeid);\n\nstruct page *sparse_mem_map_populate(unsigned long pnum, int nid);\npgd_t *vmemmap_pgd_populate(unsigned long addr, int node);\npud_t *vmemmap_pud_populate(pgd_t *pgd, unsigned long addr, int node);\npmd_t *vmemmap_pmd_populate(pud_t *pud, unsigned long addr, int node);\npte_t *vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node);\nvoid *vmemmap_alloc_block(unsigned long size, int node);\nvoid *vmemmap_alloc_block_buf(unsigned long size, int node);\nvoid vmemmap_verify(pte_t *, int, unsigned long, unsigned long);\nint vmemmap_populate_basepages(struct page *start_page,\n\t\t\t\t\t\tunsigned long pages, int node);\nint vmemmap_populate(struct page *start_page, unsigned long pages, int node);\nvoid vmemmap_populate_print_last(void);\n#ifdef CONFIG_MEMORY_HOTPLUG\nvoid vmemmap_free(struct page *memmap, unsigned long nr_pages);\n#endif\nvoid register_page_bootmem_memmap(unsigned long section_nr, struct page *map,\n\t\t\t\t  unsigned long size);\n\nenum mf_flags {\n\tMF_COUNT_INCREASED = 1 << 0,\n\tMF_ACTION_REQUIRED = 1 << 1,\n\tMF_MUST_KILL = 1 << 2,\n};\nextern int memory_failure(unsigned long pfn, int trapno, int flags);\nextern void memory_failure_queue(unsigned long pfn, int trapno, int flags);\nextern int unpoison_memory(unsigned long pfn);\nextern int sysctl_memory_failure_early_kill;\nextern int sysctl_memory_failure_recovery;\nextern void shake_page(struct page *p, int access);\nextern atomic_long_t num_poisoned_pages;\nextern int soft_offline_page(struct page *page, int flags);\n\nextern void dump_page(struct page *page);\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_HUGETLBFS)\nextern void clear_huge_page(struct page *page,\n\t\t\t    unsigned long addr,\n\t\t\t    unsigned int pages_per_huge_page);\nextern void copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t\tunsigned long addr, struct vm_area_struct *vma,\n\t\t\t\tunsigned int pages_per_huge_page);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */\n\n#ifdef CONFIG_DEBUG_PAGEALLOC\nextern unsigned int _debug_guardpage_minorder;\n\nstatic inline unsigned int debug_guardpage_minorder(void)\n{\n\treturn _debug_guardpage_minorder;\n}\n\nstatic inline bool page_is_guard(struct page *page)\n{\n\treturn test_bit(PAGE_DEBUG_FLAG_GUARD, &page->debug_flags);\n}\n#else\nstatic inline unsigned int debug_guardpage_minorder(void) { return 0; }\nstatic inline bool page_is_guard(struct page *page) { return false; }\n#endif /* CONFIG_DEBUG_PAGEALLOC */\n\n#endif /* __KERNEL__ */\n#endif /* _LINUX_MM_H */\n", "/*\n *  linux/mm/memory.c\n *\n *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds\n */\n\n/*\n * demand-loading started 01.12.91 - seems it is high on the list of\n * things wanted, and it should be easy to implement. - Linus\n */\n\n/*\n * Ok, demand-loading was easy, shared pages a little bit tricker. Shared\n * pages started 02.12.91, seems to work. - Linus.\n *\n * Tested sharing by executing about 30 /bin/sh: under the old kernel it\n * would have taken more than the 6M I have free, but it worked well as\n * far as I could see.\n *\n * Also corrected some \"invalidate()\"s - I wasn't doing enough of them.\n */\n\n/*\n * Real VM (paging to/from disk) started 18.12.91. Much more work and\n * thought has to go into this. Oh, well..\n * 19.12.91  -  works, somewhat. Sometimes I get faults, don't know why.\n *\t\tFound it. Everything seems to work now.\n * 20.12.91  -  Ok, making the swap-device changeable like the root.\n */\n\n/*\n * 05.04.94  -  Multi-page memory management added for v1.1.\n * \t\tIdea by Alex Bligh (alex@cconcepts.co.uk)\n *\n * 16.07.99  -  Support of BIGMEM added by Gerhard Wichert, Siemens AG\n *\t\t(Gerhard.Wichert@pdb.siemens.de)\n *\n * Aug/Sep 2004 Changed to four level page tables (Andi Kleen)\n */\n\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/delayacct.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n#include <linux/mmu_notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/swapops.h>\n#include <linux/elf.h>\n#include <linux/gfp.h>\n#include <linux/migrate.h>\n#include <linux/string.h>\n\n#include <asm/io.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/tlb.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n\n#include \"internal.h\"\n\n#ifdef LAST_NID_NOT_IN_PAGE_FLAGS\n#warning Unfortunate NUMA and NUMA Balancing config, growing page-frame for last_nid.\n#endif\n\n#ifndef CONFIG_NEED_MULTIPLE_NODES\n/* use the per-pgdat data instead for discontigmem - mbligh */\nunsigned long max_mapnr;\nstruct page *mem_map;\n\nEXPORT_SYMBOL(max_mapnr);\nEXPORT_SYMBOL(mem_map);\n#endif\n\nunsigned long num_physpages;\n/*\n * A number of key systems in x86 including ioremap() rely on the assumption\n * that high_memory defines the upper bound on direct map memory, then end\n * of ZONE_NORMAL.  Under CONFIG_DISCONTIG this means that max_low_pfn and\n * highstart_pfn must be the same; there must be no gap between ZONE_NORMAL\n * and ZONE_HIGHMEM.\n */\nvoid * high_memory;\n\nEXPORT_SYMBOL(num_physpages);\nEXPORT_SYMBOL(high_memory);\n\n/*\n * Randomize the address space (stacks, mmaps, brk, etc.).\n *\n * ( When CONFIG_COMPAT_BRK=y we exclude brk from randomization,\n *   as ancient (libc5 based) binaries can segfault. )\n */\nint randomize_va_space __read_mostly =\n#ifdef CONFIG_COMPAT_BRK\n\t\t\t\t\t1;\n#else\n\t\t\t\t\t2;\n#endif\n\nstatic int __init disable_randmaps(char *s)\n{\n\trandomize_va_space = 0;\n\treturn 1;\n}\n__setup(\"norandmaps\", disable_randmaps);\n\nunsigned long zero_pfn __read_mostly;\nunsigned long highest_memmap_pfn __read_mostly;\n\n/*\n * CONFIG_MMU architectures set up ZERO_PAGE in their paging_init()\n */\nstatic int __init init_zero_pfn(void)\n{\n\tzero_pfn = page_to_pfn(ZERO_PAGE(0));\n\treturn 0;\n}\ncore_initcall(init_zero_pfn);\n\n\n#if defined(SPLIT_RSS_COUNTING)\n\nvoid sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}\n#define inc_mm_counter_fast(mm, member) add_mm_counter_fast(mm, member, 1)\n#define dec_mm_counter_fast(mm, member) add_mm_counter_fast(mm, member, -1)\n\n/* sync counter once per 64 page faults */\n#define TASK_RSS_EVENTS_THRESH\t(64)\nstatic void check_sync_rss_stat(struct task_struct *task)\n{\n\tif (unlikely(task != current))\n\t\treturn;\n\tif (unlikely(task->rss_stat.events++ > TASK_RSS_EVENTS_THRESH))\n\t\tsync_mm_rss(task->mm);\n}\n#else /* SPLIT_RSS_COUNTING */\n\n#define inc_mm_counter_fast(mm, member) inc_mm_counter(mm, member)\n#define dec_mm_counter_fast(mm, member) dec_mm_counter(mm, member)\n\nstatic void check_sync_rss_stat(struct task_struct *task)\n{\n}\n\n#endif /* SPLIT_RSS_COUNTING */\n\n#ifdef HAVE_GENERIC_MMU_GATHER\n\nstatic int tlb_next_batch(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tbatch = tlb->active;\n\tif (batch->next) {\n\t\ttlb->active = batch->next;\n\t\treturn 1;\n\t}\n\n\tif (tlb->batch_count == MAX_GATHER_BATCH_COUNT)\n\t\treturn 0;\n\n\tbatch = (void *)__get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);\n\tif (!batch)\n\t\treturn 0;\n\n\ttlb->batch_count++;\n\tbatch->next = NULL;\n\tbatch->nr   = 0;\n\tbatch->max  = MAX_GATHER_BATCH;\n\n\ttlb->active->next = batch;\n\ttlb->active = batch;\n\n\treturn 1;\n}\n\n/* tlb_gather_mmu\n *\tCalled to initialize an (on-stack) mmu_gather structure for page-table\n *\ttear-down from @mm. The @fullmm argument is used when @mm is without\n *\tusers and we're going to destroy the full address space (exit/execve).\n */\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm, bool fullmm)\n{\n\ttlb->mm = mm;\n\n\ttlb->fullmm     = fullmm;\n\ttlb->need_flush_all = 0;\n\ttlb->start\t= -1UL;\n\ttlb->end\t= 0;\n\ttlb->need_flush = 0;\n\ttlb->fast_mode  = (num_possible_cpus() == 1);\n\ttlb->local.next = NULL;\n\ttlb->local.nr   = 0;\n\ttlb->local.max  = ARRAY_SIZE(tlb->__pages);\n\ttlb->active     = &tlb->local;\n\ttlb->batch_count = 0;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb->batch = NULL;\n#endif\n}\n\nvoid tlb_flush_mmu(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tif (!tlb->need_flush)\n\t\treturn;\n\ttlb->need_flush = 0;\n\ttlb_flush(tlb);\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\n\tif (tlb_fast_mode(tlb))\n\t\treturn;\n\n\tfor (batch = &tlb->local; batch; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}\n\n/* tlb_finish_mmu\n *\tCalled at the end of the shootdown operation to free up any resources\n *\tthat were required.\n */\nvoid tlb_finish_mmu(struct mmu_gather *tlb, unsigned long start, unsigned long end)\n{\n\tstruct mmu_gather_batch *batch, *next;\n\n\ttlb->start = start;\n\ttlb->end   = end;\n\ttlb_flush_mmu(tlb);\n\n\t/* keep the page table cache within bounds */\n\tcheck_pgt_cache();\n\n\tfor (batch = tlb->local.next; batch; batch = next) {\n\t\tnext = batch->next;\n\t\tfree_pages((unsigned long)batch, 0);\n\t}\n\ttlb->local.next = NULL;\n}\n\n/* __tlb_remove_page\n *\tMust perform the equivalent to __free_pte(pte_get_and_clear(ptep)), while\n *\thandling the additional races in SMP caused by other CPUs caching valid\n *\tmappings in their TLBs. Returns the number of free page slots left.\n *\tWhen out of page slots we must call tlb_flush_mmu().\n */\nint __tlb_remove_page(struct mmu_gather *tlb, struct page *page)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->need_flush);\n\n\tif (tlb_fast_mode(tlb)) {\n\t\tfree_page_and_swap_cache(page);\n\t\treturn 1; /* avoid calling tlb_flush_mmu() */\n\t}\n\n\tbatch = tlb->active;\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn 0;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON(batch->nr > batch->max);\n\n\treturn batch->max - batch->nr;\n}\n\n#endif /* HAVE_GENERIC_MMU_GATHER */\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\n/*\n * See the comment near struct mmu_table_batch.\n */\n\nstatic void tlb_remove_table_smp_sync(void *arg)\n{\n\t/* Simply deliver the interrupt */\n}\n\nstatic void tlb_remove_table_one(void *table)\n{\n\t/*\n\t * This isn't an RCU grace period and hence the page-tables cannot be\n\t * assumed to be actually RCU-freed.\n\t *\n\t * It is however sufficient for software page-table walkers that rely on\n\t * IRQ disabling. See the comment near struct mmu_table_batch.\n\t */\n\tsmp_call_function(tlb_remove_table_smp_sync, NULL, 1);\n\t__tlb_remove_table(table);\n}\n\nstatic void tlb_remove_table_rcu(struct rcu_head *head)\n{\n\tstruct mmu_table_batch *batch;\n\tint i;\n\n\tbatch = container_of(head, struct mmu_table_batch, rcu);\n\n\tfor (i = 0; i < batch->nr; i++)\n\t\t__tlb_remove_table(batch->tables[i]);\n\n\tfree_page((unsigned long)batch);\n}\n\nvoid tlb_table_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch) {\n\t\tcall_rcu_sched(&(*batch)->rcu, tlb_remove_table_rcu);\n\t\t*batch = NULL;\n\t}\n}\n\nvoid tlb_remove_table(struct mmu_gather *tlb, void *table)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\ttlb->need_flush = 1;\n\n\t/*\n\t * When there's less then two users of this mm there cannot be a\n\t * concurrent page-table walk.\n\t */\n\tif (atomic_read(&tlb->mm->mm_users) < 2) {\n\t\t__tlb_remove_table(table);\n\t\treturn;\n\t}\n\n\tif (*batch == NULL) {\n\t\t*batch = (struct mmu_table_batch *)__get_free_page(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (*batch == NULL) {\n\t\t\ttlb_remove_table_one(table);\n\t\t\treturn;\n\t\t}\n\t\t(*batch)->nr = 0;\n\t}\n\t(*batch)->tables[(*batch)->nr++] = table;\n\tif ((*batch)->nr == MAX_TABLE_BATCH)\n\t\ttlb_table_flush(tlb);\n}\n\n#endif /* CONFIG_HAVE_RCU_TABLE_FREE */\n\n/*\n * If a p?d_bad entry is found while walking page tables, report\n * the error, before resetting entry to p?d_none.  Usually (but\n * very seldom) called out from the p?d_none_or_clear_bad macros.\n */\n\nvoid pgd_clear_bad(pgd_t *pgd)\n{\n\tpgd_ERROR(*pgd);\n\tpgd_clear(pgd);\n}\n\nvoid pud_clear_bad(pud_t *pud)\n{\n\tpud_ERROR(*pud);\n\tpud_clear(pud);\n}\n\nvoid pmd_clear_bad(pmd_t *pmd)\n{\n\tpmd_ERROR(*pmd);\n\tpmd_clear(pmd);\n}\n\n/*\n * Note: this doesn't free the actual pages themselves. That\n * has been handled earlier when unmapping all the memory regions.\n */\nstatic void free_pte_range(struct mmu_gather *tlb, pmd_t *pmd,\n\t\t\t   unsigned long addr)\n{\n\tpgtable_t token = pmd_pgtable(*pmd);\n\tpmd_clear(pmd);\n\tpte_free_tlb(tlb, token, addr);\n\ttlb->mm->nr_ptes--;\n}\n\nstatic inline void free_pmd_range(struct mmu_gather *tlb, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tfree_pte_range(tlb, pmd, addr);\n\t} while (pmd++, addr = next, addr != end);\n\n\tstart &= PUD_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PUD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpmd = pmd_offset(pud, start);\n\tpud_clear(pud);\n\tpmd_free_tlb(tlb, pmd, start);\n}\n\nstatic inline void free_pud_range(struct mmu_gather *tlb, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpud = pud_offset(pgd, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tfree_pmd_range(tlb, pud, addr, next, floor, ceiling);\n\t} while (pud++, addr = next, addr != end);\n\n\tstart &= PGDIR_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PGDIR_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpud = pud_offset(pgd, start);\n\tpgd_clear(pgd);\n\tpud_free_tlb(tlb, pud, start);\n}\n\n/*\n * This function frees user-level page tables of a process.\n *\n * Must be called with pagetable lock held.\n */\nvoid free_pgd_range(struct mmu_gather *tlb,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\t/*\n\t * The next few lines have given us lots of grief...\n\t *\n\t * Why are we testing PMD* at this top level?  Because often\n\t * there will be no work to do at all, and we'd prefer not to\n\t * go all the way down to the bottom just to discover that.\n\t *\n\t * Why all these \"- 1\"s?  Because 0 represents both the bottom\n\t * of the address space and the top of it (using -1 for the\n\t * top wouldn't help much: the masks would do the wrong thing).\n\t * The rule is that addr 0 and floor 0 refer to the bottom of\n\t * the address space, but end 0 and ceiling 0 refer to the top\n\t * Comparisons need to use \"end - 1\" and \"ceiling - 1\" (though\n\t * that end 0 case should be mythical).\n\t *\n\t * Wherever addr is brought up or ceiling brought down, we must\n\t * be careful to reject \"the opposite 0\" before it confuses the\n\t * subsequent tests.  But what about where end is brought down\n\t * by PMD_SIZE below? no, end can't go down to 0 there.\n\t *\n\t * Whereas we round start (addr) and ceiling down, by different\n\t * masks at different levels, in order to test whether a table\n\t * now has no other vmas using it, so can be freed, we don't\n\t * bother to round floor or end up - the tests don't need that.\n\t */\n\n\taddr &= PMD_MASK;\n\tif (addr < floor) {\n\t\taddr += PMD_SIZE;\n\t\tif (!addr)\n\t\t\treturn;\n\t}\n\tif (ceiling) {\n\t\tceiling &= PMD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\tend -= PMD_SIZE;\n\tif (addr > end - 1)\n\t\treturn;\n\n\tpgd = pgd_offset(tlb->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tfree_pud_range(tlb, pgd, addr, next, floor, ceiling);\n\t} while (pgd++, addr = next, addr != end);\n}\n\nvoid free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\n\t\t/*\n\t\t * Hide vma from rmap and truncate_pagecache before freeing\n\t\t * pgtables\n\t\t */\n\t\tunlink_anon_vmas(vma);\n\t\tunlink_file_vma(vma);\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Optimization: gather nearby vmas into one call down\n\t\t\t */\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tunlink_anon_vmas(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}\n\nint __pte_alloc(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long address)\n{\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tint wait_split_huge_page;\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tspin_lock(&mm->page_table_lock);\n\twait_split_huge_page = 0;\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm->nr_ptes++;\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t} else if (unlikely(pmd_trans_splitting(*pmd)))\n\t\twait_split_huge_page = 1;\n\tspin_unlock(&mm->page_table_lock);\n\tif (new)\n\t\tpte_free(mm, new);\n\tif (wait_split_huge_page)\n\t\twait_split_huge_page(vma->anon_vma, pmd);\n\treturn 0;\n}\n\nint __pte_alloc_kernel(pmd_t *pmd, unsigned long address)\n{\n\tpte_t *new = pte_alloc_one_kernel(&init_mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&init_mm.page_table_lock);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tpmd_populate_kernel(&init_mm, pmd, new);\n\t\tnew = NULL;\n\t} else\n\t\tVM_BUG_ON(pmd_trans_splitting(*pmd));\n\tspin_unlock(&init_mm.page_table_lock);\n\tif (new)\n\t\tpte_free_kernel(&init_mm, new);\n\treturn 0;\n}\n\nstatic inline void init_rss_vec(int *rss)\n{\n\tmemset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}\n\nstatic inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)\n{\n\tint i;\n\n\tif (current->mm == mm)\n\t\tsync_mm_rss(mm);\n\tfor (i = 0; i < NR_MM_COUNTERS; i++)\n\t\tif (rss[i])\n\t\t\tadd_mm_counter(mm, i, rss[i]);\n}\n\n/*\n * This function is called to print an error when a bad pte\n * is found. For example, we might have a PFN-mapped pte in\n * a region that doesn't allow it.\n *\n * The calling function must still handle the error.\n */\nstatic void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tpud_t *pud = pud_offset(pgd, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tprintk(KERN_ALERT\n\t\t\t\t\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tprintk(KERN_ALERT\n\t\t\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\tcurrent->comm,\n\t\t(long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page);\n\tprintk(KERN_ALERT\n\t\t\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t(void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\t/*\n\t * Choose text because data symbols depend on CONFIG_KALLSYMS_ALL=y\n\t */\n\tif (vma->vm_ops)\n\t\tprint_symbol(KERN_ALERT \"vma->vm_ops->fault: %s\\n\",\n\t\t\t\t(unsigned long)vma->vm_ops->fault);\n\tif (vma->vm_file && vma->vm_file->f_op)\n\t\tprint_symbol(KERN_ALERT \"vma->vm_file->f_op->mmap: %s\\n\",\n\t\t\t\t(unsigned long)vma->vm_file->f_op->mmap);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}\n\n/*\n * vm_normal_page -- This function gets the \"struct page\" associated with a pte.\n *\n * \"Special\" mappings do not wish to be associated with a \"struct page\" (either\n * it doesn't exist, or it exists but they don't want to touch it). In this\n * case, NULL is returned here. \"Normal\" mappings do have a struct page.\n *\n * There are 2 broad cases. Firstly, an architecture may define a pte_special()\n * pte bit, in which case this function is trivial. Secondly, an architecture\n * may not have a spare pte bit, which requires a more complicated scheme,\n * described below.\n *\n * A raw VM_PFNMAP mapping (ie. one that is not COWed) is always considered a\n * special mapping (even if there are underlying and valid \"struct pages\").\n * COWed pages of a VM_PFNMAP are always normal.\n *\n * The way we recognize COWed pages within VM_PFNMAP mappings is through the\n * rules set up by \"remap_pfn_range()\": the vma will have the VM_PFNMAP bit\n * set, and the vm_pgoff will point to the first PFN mapped: thus every special\n * mapping will always honor the rule\n *\n *\tpfn_of_page == vma->vm_pgoff + ((addr - vma->vm_start) >> PAGE_SHIFT)\n *\n * And for normal mappings this is false.\n *\n * This restricts such mappings to be a linear translation from virtual address\n * to pfn. To get around this restriction, we allow arbitrary mappings so long\n * as the vma is not a COW mapping; in that case, we know that all ptes are\n * special (because none can have been COWed).\n *\n *\n * In order to support COW of arbitrary special mappings, we have VM_MIXEDMAP.\n *\n * VM_MIXEDMAP mappings can likewise contain memory with or without \"struct\n * page\" backing, however the difference is that _all_ pages with a struct\n * page (that is, those where pfn_valid is true) are refcounted and considered\n * normal pages by the VM. The disadvantage is that pages are refcounted\n * (which can be slower and simply not an option for some PFNMAP users). The\n * advantage is that we don't have to follow the strict linearity rule of\n * PFNMAP mappings in order to support COWable mappings.\n *\n */\n#ifdef __HAVE_ARCH_PTE_SPECIAL\n# define HAVE_PTE_SPECIAL 1\n#else\n# define HAVE_PTE_SPECIAL 0\n#endif\nstruct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpte_t pte)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (HAVE_PTE_SPECIAL) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (!is_zero_pfn(pfn))\n\t\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !HAVE_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}\n\n/*\n * copy one vm_area from one task to the other. Assumes the page tables\n * already present in the new task to be cleared in the whole range\n * covered by this vma.\n */\n\nstatic inline unsigned long\ncopy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,\n\t\tunsigned long addr, int *rss)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpte_t pte = *src_pte;\n\tstruct page *page;\n\n\t/* pte contains position in swap or file, so copy. */\n\tif (unlikely(!pte_present(pte))) {\n\t\tif (!pte_file(pte)) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (swap_duplicate(entry) < 0)\n\t\t\t\treturn entry.val;\n\n\t\t\t/* make sure dst_mm is on swapoff's mmlist. */\n\t\t\tif (unlikely(list_empty(&dst_mm->mmlist))) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&dst_mm->mmlist))\n\t\t\t\t\tlist_add(&dst_mm->mmlist,\n\t\t\t\t\t\t &src_mm->mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\tif (likely(!non_swap_entry(entry)))\n\t\t\t\trss[MM_SWAPENTS]++;\n\t\t\telse if (is_migration_entry(entry)) {\n\t\t\t\tpage = migration_entry_to_page(entry);\n\n\t\t\t\tif (PageAnon(page))\n\t\t\t\t\trss[MM_ANONPAGES]++;\n\t\t\t\telse\n\t\t\t\t\trss[MM_FILEPAGES]++;\n\n\t\t\t\tif (is_write_migration_entry(entry) &&\n\t\t\t\t    is_cow_mapping(vm_flags)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * COW mappings require pages in both\n\t\t\t\t\t * parent and child to be set to read.\n\t\t\t\t\t */\n\t\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto out_set_pte;\n\t}\n\n\t/*\n\t * If it's a COW mapping, write protect it both\n\t * in the parent and the child\n\t */\n\tif (is_cow_mapping(vm_flags)) {\n\t\tptep_set_wrprotect(src_mm, addr, src_pte);\n\t\tpte = pte_wrprotect(pte);\n\t}\n\n\t/*\n\t * If it's a shared mapping, mark it clean in\n\t * the child\n\t */\n\tif (vm_flags & VM_SHARED)\n\t\tpte = pte_mkclean(pte);\n\tpte = pte_mkold(pte);\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (page) {\n\t\tget_page(page);\n\t\tpage_dup_rmap(page);\n\t\tif (PageAnon(page))\n\t\t\trss[MM_ANONPAGES]++;\n\t\telse\n\t\t\trss[MM_FILEPAGES]++;\n\t}\n\nout_set_pte:\n\tset_pte_at(dst_mm, addr, dst_pte, pte);\n\treturn 0;\n}\n\nint copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t   pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,\n\t\t   unsigned long addr, unsigned long end)\n{\n\tpte_t *orig_src_pte, *orig_dst_pte;\n\tpte_t *src_pte, *dst_pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tint progress = 0;\n\tint rss[NR_MM_COUNTERS];\n\tswp_entry_t entry = (swp_entry_t){0};\n\nagain:\n\tinit_rss_vec(rss);\n\n\tdst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);\n\tif (!dst_pte)\n\t\treturn -ENOMEM;\n\tsrc_pte = pte_offset_map(src_pmd, addr);\n\tsrc_ptl = pte_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\torig_src_pte = src_pte;\n\torig_dst_pte = dst_pte;\n\tarch_enter_lazy_mmu_mode();\n\n\tdo {\n\t\t/*\n\t\t * We are holding two locks at this point - either of them\n\t\t * could generate latencies in another task on another CPU.\n\t\t */\n\t\tif (progress >= 32) {\n\t\t\tprogress = 0;\n\t\t\tif (need_resched() ||\n\t\t\t    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pte_none(*src_pte)) {\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\tentry.val = copy_one_pte(dst_mm, src_mm, dst_pte, src_pte,\n\t\t\t\t\t\t\tvma, addr, rss);\n\t\tif (entry.val)\n\t\t\tbreak;\n\t\tprogress += 8;\n\t} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\tspin_unlock(src_ptl);\n\tpte_unmap(orig_src_pte);\n\tadd_mm_rss_vec(dst_mm, rss);\n\tpte_unmap_unlock(orig_dst_pte, dst_ptl);\n\tcond_resched();\n\n\tif (entry.val) {\n\t\tif (add_swap_count_continuation(entry, GFP_KERNEL) < 0)\n\t\t\treturn -ENOMEM;\n\t\tprogress = 0;\n\t}\n\tif (addr != end)\n\t\tgoto again;\n\treturn 0;\n}\n\nstatic inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON(next-addr != HPAGE_PMD_SIZE);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n\t\t\t\t\t    dst_pmd, src_pmd, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}\n\nstatic inline int copy_pud_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpgd_t *dst_pgd, pgd_t *src_pgd, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpud_t *src_pud, *dst_pud;\n\tunsigned long next;\n\n\tdst_pud = pud_alloc(dst_mm, dst_pgd, addr);\n\tif (!dst_pud)\n\t\treturn -ENOMEM;\n\tsrc_pud = pud_offset(src_pgd, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(src_pud))\n\t\t\tcontinue;\n\t\tif (copy_pmd_range(dst_mm, src_mm, dst_pud, src_pud,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pud++, src_pud++, addr = next, addr != end);\n\treturn 0;\n}\n\nint copy_page_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tstruct vm_area_struct *vma)\n{\n\tpgd_t *src_pgd, *dst_pgd;\n\tunsigned long next;\n\tunsigned long addr = vma->vm_start;\n\tunsigned long end = vma->vm_end;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tbool is_cow;\n\tint ret;\n\n\t/*\n\t * Don't copy ptes where a page fault will fill them correctly.\n\t * Fork becomes much lighter when there are big shared or private\n\t * readonly mappings. The tradeoff is that copy_page_range is more\n\t * efficient than faulting.\n\t */\n\tif (!(vma->vm_flags & (VM_HUGETLB | VM_NONLINEAR |\n\t\t\t       VM_PFNMAP | VM_MIXEDMAP))) {\n\t\tif (!vma->anon_vma)\n\t\t\treturn 0;\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn copy_hugetlb_page_range(dst_mm, src_mm, vma);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP)) {\n\t\t/*\n\t\t * We do not free on error cases below as remove_vma\n\t\t * gets called on error from higher level routine\n\t\t */\n\t\tret = track_pfn_copy(vma);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We need to invalidate the secondary MMU mappings only when\n\t * there could be a permission downgrade on the ptes of the\n\t * parent mm. And a permission downgrade will only happen if\n\t * is_cow_mapping() returns true.\n\t */\n\tis_cow = is_cow_mapping(vma->vm_flags);\n\tmmun_start = addr;\n\tmmun_end   = end;\n\tif (is_cow)\n\t\tmmu_notifier_invalidate_range_start(src_mm, mmun_start,\n\t\t\t\t\t\t    mmun_end);\n\n\tret = 0;\n\tdst_pgd = pgd_offset(dst_mm, addr);\n\tsrc_pgd = pgd_offset(src_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(src_pgd))\n\t\t\tcontinue;\n\t\tif (unlikely(copy_pud_range(dst_mm, src_mm, dst_pgd, src_pgd,\n\t\t\t\t\t    vma, addr, next))) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t} while (dst_pgd++, src_pgd++, addr = next, addr != end);\n\n\tif (is_cow)\n\t\tmmu_notifier_invalidate_range_end(src_mm, mmun_start, mmun_end);\n\treturn ret;\n}\n\nstatic unsigned long zap_pte_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tstruct mm_struct *mm = tlb->mm;\n\tint force_flush = 0;\n\tint rss[NR_MM_COUNTERS];\n\tspinlock_t *ptl;\n\tpte_t *start_pte;\n\tpte_t *pte;\n\nagain:\n\tinit_rss_vec(rss);\n\tstart_pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tpte = start_pte;\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tpte_t ptent = *pte;\n\t\tif (pte_none(ptent)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pte_present(ptent)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\t\tif (unlikely(details) && page) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping &&\n\t\t\t\t    details->check_mapping != page->mapping)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Each page->index must be checked when\n\t\t\t\t * invalidating or truncating nonlinear.\n\t\t\t\t */\n\t\t\t\tif (details->nonlinear_vma &&\n\t\t\t\t    (page->index < details->first_index ||\n\t\t\t\t     page->index > details->last_index))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptent = ptep_get_and_clear_full(mm, addr, pte,\n\t\t\t\t\t\t\ttlb->fullmm);\n\t\t\ttlb_remove_tlb_entry(tlb, pte, addr);\n\t\t\tif (unlikely(!page))\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(details) && details->nonlinear_vma\n\t\t\t    && linear_page_index(details->nonlinear_vma,\n\t\t\t\t\t\taddr) != page->index)\n\t\t\t\tset_pte_at(mm, addr, pte,\n\t\t\t\t\t   pgoff_to_pte(page->index));\n\t\t\tif (PageAnon(page))\n\t\t\t\trss[MM_ANONPAGES]--;\n\t\t\telse {\n\t\t\t\tif (pte_dirty(ptent))\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\tif (pte_young(ptent) &&\n\t\t\t\t    likely(!VM_SequentialReadHint(vma)))\n\t\t\t\t\tmark_page_accessed(page);\n\t\t\t\trss[MM_FILEPAGES]--;\n\t\t\t}\n\t\t\tpage_remove_rmap(page);\n\t\t\tif (unlikely(page_mapcount(page) < 0))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, page);\n\t\t\tforce_flush = !__tlb_remove_page(tlb, page);\n\t\t\tif (force_flush)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If details->check_mapping, we leave swap entries;\n\t\t * if details->nonlinear_vma, we leave file entries.\n\t\t */\n\t\tif (unlikely(details))\n\t\t\tcontinue;\n\t\tif (pte_file(ptent)) {\n\t\t\tif (unlikely(!(vma->vm_flags & VM_NONLINEAR)))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, NULL);\n\t\t} else {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(ptent);\n\n\t\t\tif (!non_swap_entry(entry))\n\t\t\t\trss[MM_SWAPENTS]--;\n\t\t\telse if (is_migration_entry(entry)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = migration_entry_to_page(entry);\n\n\t\t\t\tif (PageAnon(page))\n\t\t\t\t\trss[MM_ANONPAGES]--;\n\t\t\t\telse\n\t\t\t\t\trss[MM_FILEPAGES]--;\n\t\t\t}\n\t\t\tif (unlikely(!free_swap_and_cache(entry)))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, NULL);\n\t\t}\n\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\n\tadd_mm_rss_vec(mm, rss);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(start_pte, ptl);\n\n\t/*\n\t * mmu_gather ran out of room to batch pages, we break out of\n\t * the PTE lock to avoid doing the potential expensive TLB invalidate\n\t * and page-free while holding it.\n\t */\n\tif (force_flush) {\n\t\tforce_flush = 0;\n\n#ifdef HAVE_GENERIC_MMU_GATHER\n\t\ttlb->start = addr;\n\t\ttlb->end = end;\n#endif\n\t\ttlb_flush_mmu(tlb);\n\t\tif (addr != end)\n\t\t\tgoto again;\n\t}\n\n\treturn addr;\n}\n\nstatic inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n#ifdef CONFIG_DEBUG_VM\n\t\t\t\tif (!rwsem_is_locked(&tlb->mm->mmap_sem)) {\n\t\t\t\t\tpr_err(\"%s: mmap_sem is unlocked! addr=0x%lx end=0x%lx vma->vm_start=0x%lx vma->vm_end=0x%lx\\n\",\n\t\t\t\t\t\t__func__, addr, end,\n\t\t\t\t\t\tvma->vm_start,\n\t\t\t\t\t\tvma->vm_end);\n\t\t\t\t\tBUG();\n\t\t\t\t}\n#endif\n\t\t\t\tsplit_huge_page_pmd(vma, addr, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\t/*\n\t\t * Here there can be other concurrent MADV_DONTNEED or\n\t\t * trans huge page faults running, and if the pmd is\n\t\t * none or trans huge it can change under us. This is\n\t\t * because MADV_DONTNEED holds the mmap_sem in read\n\t\t * mode.\n\t\t */\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tgoto next;\n\t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn addr;\n}\n\nstatic inline unsigned long zap_pud_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(pgd, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tnext = zap_pmd_range(tlb, vma, pud, addr, next, details);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn addr;\n}\n\nstatic void unmap_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t     struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tif (details && !details->check_mapping && !details->nonlinear_vma)\n\t\tdetails = NULL;\n\n\tBUG_ON(addr >= end);\n\tmem_cgroup_uncharge_start();\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tnext = zap_pud_range(tlb, vma, pgd, addr, next, details);\n\t} while (pgd++, addr = next, addr != end);\n\ttlb_end_vma(tlb, vma);\n\tmem_cgroup_uncharge_end();\n}\n\n\nstatic void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of do_mmap_pgoff. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * do_mmap_pgoff() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\tmutex_lock(&vma->vm_file->f_mapping->i_mmap_mutex);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\tmutex_unlock(&vma->vm_file->f_mapping->i_mmap_mutex);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}\n\n/**\n * unmap_vmas - unmap a range of memory covered by a list of vma's\n * @tlb: address of the caller's struct mmu_gather\n * @vma: the starting vma\n * @start_addr: virtual address at which to start unmapping\n * @end_addr: virtual address at which to end unmapping\n *\n * Unmap all pages in the vma list.\n *\n * Only addresses between `start' and `end' will be unmapped.\n *\n * The VMA list must be sorted in ascending virtual address order.\n *\n * unmap_vmas() assumes that the caller will flush the whole unmapped address\n * range after unmap_vmas() returns.  So the only responsibility here is to\n * ensure that any thus-far unmapped pages are flushed before unmap_vmas()\n * drops the lock and schedules.\n */\nvoid unmap_vmas(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tmmu_notifier_invalidate_range_start(mm, start_addr, end_addr);\n\tfor ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next)\n\t\tunmap_single_vma(tlb, vma, start_addr, end_addr, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start_addr, end_addr);\n}\n\n/**\n * zap_page_range - remove user pages in a given range\n * @vma: vm_area_struct holding the applicable pages\n * @start: starting address of pages to zap\n * @size: number of bytes to zap\n * @details: details of nonlinear truncation or shared cache invalidation\n *\n * Caller must protect the VMA list\n */\nvoid zap_page_range(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = start + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, 0);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tfor ( ; vma && vma->vm_start < end; vma = vma->vm_next)\n\t\tunmap_single_vma(&tlb, vma, start, end, details);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n}\n\n/**\n * zap_page_range_single - remove user pages in a given range\n * @vma: vm_area_struct holding the applicable pages\n * @address: starting address of pages to zap\n * @size: number of bytes to zap\n * @details: details of nonlinear truncation or shared cache invalidation\n *\n * The range must fit into one VMA.\n */\nstatic void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = address + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, 0);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, address, end);\n\tunmap_single_vma(&tlb, vma, address, end, details);\n\tmmu_notifier_invalidate_range_end(mm, address, end);\n\ttlb_finish_mmu(&tlb, address, end);\n}\n\n/**\n * zap_vma_ptes - remove ptes mapping the vma\n * @vma: vm_area_struct holding ptes to be zapped\n * @address: starting address of pages to zap\n * @size: number of bytes to zap\n *\n * This function only unmaps ptes assigned to VM_PFNMAP vmas.\n *\n * The entire address range must be fully contained within the vma.\n *\n * Returns 0 if successful.\n */\nint zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size)\n{\n\tif (address < vma->vm_start || address + size > vma->vm_end ||\n\t    \t\t!(vma->vm_flags & VM_PFNMAP))\n\t\treturn -1;\n\tzap_page_range_single(vma, address, size, NULL);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(zap_vma_ptes);\n\n/**\n * follow_page_mask - look up a page descriptor from a user-virtual address\n * @vma: vm_area_struct mapping @address\n * @address: virtual address to look up\n * @flags: flags modifying lookup behaviour\n * @page_mask: on output, *page_mask is set according to the size of the page\n *\n * @flags can have FOLL_ flags set, defined in <linux/mm.h>\n *\n * Returns the mapped (struct page *), %NULL if no mapping exists, or\n * an error pointer if there is a mapping to something not represented\n * by a page descriptor (see also vm_normal_page()).\n */\nstruct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int flags,\n\t\t\t      unsigned int *page_mask)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\t*page_mask = 0;\n\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tgoto out;\n\t}\n\n\tpage = NULL;\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto no_page_table;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud))\n\t\tgoto no_page_table;\n\tif (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tpage = follow_huge_pud(mm, address, pud, flags & FOLL_WRITE);\n\t\tgoto out;\n\t}\n\tif (unlikely(pud_bad(*pud)))\n\t\tgoto no_page_table;\n\n\tpmd = pmd_offset(pud, address);\n\tif (pmd_none(*pmd))\n\t\tgoto no_page_table;\n\tif (pmd_huge(*pmd) && vma->vm_flags & VM_HUGETLB) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags & FOLL_WRITE);\n\t\tgoto out;\n\t}\n\tif ((flags & FOLL_NUMA) && pmd_numa(*pmd))\n\t\tgoto no_page_table;\n\tif (pmd_trans_huge(*pmd)) {\n\t\tif (flags & FOLL_SPLIT) {\n\t\t\tsplit_huge_page_pmd(vma, address, pmd);\n\t\t\tgoto split_fallthrough;\n\t\t}\n\t\tspin_lock(&mm->page_table_lock);\n\t\tif (likely(pmd_trans_huge(*pmd))) {\n\t\t\tif (unlikely(pmd_trans_splitting(*pmd))) {\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\twait_split_huge_page(vma->anon_vma, pmd);\n\t\t\t} else {\n\t\t\t\tpage = follow_trans_huge_pmd(vma, address,\n\t\t\t\t\t\t\t     pmd, flags);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\t*page_mask = HPAGE_PMD_NR - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t/* fall through */\n\t}\nsplit_fallthrough:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\tgoto no_page_table;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte) || pte_file(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto split_fallthrough;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_numa(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (unlikely(!page)) {\n\t\tif ((flags & FOLL_DUMP) ||\n\t\t    !is_zero_pfn(pte_pfn(pte)))\n\t\t\tgoto bad_page;\n\t\tpage = pte_page(pte);\n\t}\n\n\tif (flags & FOLL_GET)\n\t\tget_page_foll(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/*\n\t\t * The preliminary mapping check is mainly to avoid the\n\t\t * pointless overhead of lock_page on the ZERO_PAGE\n\t\t * which might bounce very badly if there is contention.\n\t\t *\n\t\t * If the page is already locked, we don't need to\n\t\t * handle it now - vmscan will handle it later if and\n\t\t * when it attempts to reclaim the page.\n\t\t */\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  /* push cached pages to LRU */\n\t\t\t/*\n\t\t\t * Because we lock page here, and migration is\n\t\t\t * blocked by the pte's page reference, and we\n\t\t\t * know the page is still mapped, we don't even\n\t\t\t * need to check for file-cache page truncation.\n\t\t\t */\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn page;\n\nbad_page:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn ERR_PTR(-EFAULT);\n\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn page;\n\nno_page_table:\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) &&\n\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn page;\n}\n\nstatic inline int stack_guard_page(struct vm_area_struct *vma, unsigned long addr)\n{\n\treturn stack_guard_page_start(vma, addr) ||\n\t       stack_guard_page_end(vma, addr+PAGE_SIZE);\n}\n\n/**\n * __get_user_pages() - pin user pages in memory\n * @tsk:\ttask_struct of target task\n * @mm:\t\tmm_struct of target mm\n * @start:\tstarting user address\n * @nr_pages:\tnumber of pages from start to pin\n * @gup_flags:\tflags modifying pin behaviour\n * @pages:\tarray that receives pointers to the pages pinned.\n *\t\tShould be at least nr_pages long. Or NULL, if caller\n *\t\tonly intends to ensure the pages are faulted in.\n * @vmas:\tarray of pointers to vmas corresponding to each page.\n *\t\tOr NULL if the caller does not require them.\n * @nonblocking: whether waiting for disk IO or mmap_sem contention\n *\n * Returns number of pages pinned. This may be fewer than the number\n * requested. If nr_pages is 0 or negative, returns 0. If no pages\n * were pinned, returns -errno. Each page returned must be released\n * with a put_page() call when it is finished with. vmas will only\n * remain valid while mmap_sem is held.\n *\n * Must be called with mmap_sem held for read or write.\n *\n * __get_user_pages walks a process's page tables and takes a reference to\n * each struct page that each user address corresponds to at a given\n * instant. That is, it takes the page that would be accessed if a user\n * thread accesses the given user virtual address at that instant.\n *\n * This does not guarantee that the page exists in the user mappings when\n * __get_user_pages returns, and there may even be a completely different\n * page there in some cases (eg. if mmapped pagecache has been invalidated\n * and subsequently re faulted). However it does guarantee that the page\n * won't be freed completely. And mostly callers simply care that the page\n * contains data that was valid *at some point in time*. Typically, an IO\n * or similar operation cannot guarantee anything stronger anyway because\n * locks can't be held over the syscall boundary.\n *\n * If @gup_flags & FOLL_WRITE == 0, the page must not be written to. If\n * the page is written to, set_page_dirty (or set_page_dirty_lock, as\n * appropriate) must be called after the page is finished with, and\n * before put_page is called.\n *\n * If @nonblocking != NULL, __get_user_pages will not wait for disk IO\n * or mmap_sem contention, and if waiting is needed to pin all pages,\n * *@nonblocking will be set to 0.\n *\n * In most cases, get_user_pages or get_user_pages_fast should be used\n * instead of __get_user_pages. __get_user_pages should be used only if\n * you need some special @gup_flags.\n */\nlong __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *nonblocking)\n{\n\tlong i;\n\tunsigned long vm_flags;\n\tunsigned int page_mask;\n\n\tif (!nr_pages)\n\t\treturn 0;\n\n\tVM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));\n\n\t/* \n\t * Require read or write permissions.\n\t * If FOLL_FORCE is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = (gup_flags & FOLL_WRITE) ?\n\t\t\t(VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= (gup_flags & FOLL_FORCE) ?\n\t\t\t(VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\n\t/*\n\t * If FOLL_FORCE and FOLL_NUMA are both set, handle_mm_fault\n\t * would be called on PROT_NONE ranges. We must never invoke\n\t * handle_mm_fault on PROT_NONE ranges or the NUMA hinting\n\t * page faults would unprotect the PROT_NONE ranges if\n\t * _PAGE_NUMA and _PAGE_PROTNONE are sharing the same pte/pmd\n\t * bitflag. So to avoid that, don't set FOLL_NUMA if\n\t * FOLL_FORCE is set.\n\t */\n\tif (!(gup_flags & FOLL_FORCE))\n\t\tgup_flags |= FOLL_NUMA;\n\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(mm, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\n\t\t\t/* user gate pages are read-only */\n\t\t\tif (gup_flags & FOLL_WRITE)\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tvma = get_gate_vma(mm);\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = vm_normal_page(vma, start, *pte);\n\t\t\t\tif (!page) {\n\t\t\t\t\tif (!(gup_flags & FOLL_DUMP) &&\n\t\t\t\t\t     is_zero_pfn(pte_pfn(*pte)))\n\t\t\t\t\t\tpage = pte_page(*pte);\n\t\t\t\t\telse {\n\t\t\t\t\t\tpte_unmap(pte);\n\t\t\t\t\t\treturn i ? : -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpages[i] = page;\n\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tpage_mask = 0;\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tif (!vma ||\n\t\t    (vma->vm_flags & (VM_IO | VM_PFNMAP)) ||\n\t\t    !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t&start, &nr_pages, i, gup_flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstruct page *page;\n\t\t\tunsigned int foll_flags = gup_flags;\n\t\t\tunsigned int page_increm;\n\n\t\t\t/*\n\t\t\t * If we have a pending SIGKILL, don't keep faulting\n\t\t\t * pages and potentially allocating memory.\n\t\t\t */\n\t\t\tif (unlikely(fatal_signal_pending(current)))\n\t\t\t\treturn i ? i : -ERESTARTSYS;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page_mask(vma, start,\n\t\t\t\t\t\tfoll_flags, &page_mask))) {\n\t\t\t\tint ret;\n\t\t\t\tunsigned int fault_flags = 0;\n\n\t\t\t\t/* For mlock, just skip the stack guard page. */\n\t\t\t\tif (foll_flags & FOLL_MLOCK) {\n\t\t\t\t\tif (stack_guard_page(vma, start))\n\t\t\t\t\t\tgoto next_page;\n\t\t\t\t}\n\t\t\t\tif (foll_flags & FOLL_WRITE)\n\t\t\t\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t\t\t\tif (nonblocking)\n\t\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\t\t\t\tif (foll_flags & FOLL_NOWAIT)\n\t\t\t\t\tfault_flags |= (FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT);\n\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\t\tfault_flags);\n\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\tif (ret & (VM_FAULT_HWPOISON |\n\t\t\t\t\t\t   VM_FAULT_HWPOISON_LARGE)) {\n\t\t\t\t\t\tif (i)\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\telse if (gup_flags & FOLL_HWPOISON)\n\t\t\t\t\t\t\treturn -EHWPOISON;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\tif (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\n\t\t\t\tif (tsk) {\n\t\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\t\telse\n\t\t\t\t\t\ttsk->min_flt++;\n\t\t\t\t}\n\n\t\t\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\t\t\tif (nonblocking)\n\t\t\t\t\t\t*nonblocking = 0;\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads. But only\n\t\t\t\t * do so when looping for pte_write is futile:\n\t\t\t\t * in some cases userspace may also be wanting\n\t\t\t\t * to write to the gotten user page, which a\n\t\t\t\t * read fault here might prevent (a readonly\n\t\t\t\t * page might get reCOWed by userspace write).\n\t\t\t\t */\n\t\t\t\tif ((ret & VM_FAULT_WRITE) &&\n\t\t\t\t    !(vma->vm_flags & VM_WRITE))\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn i ? i : PTR_ERR(page);\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tpage_mask = 0;\n\t\t\t}\nnext_page:\n\t\t\tif (vmas) {\n\t\t\t\tvmas[i] = vma;\n\t\t\t\tpage_mask = 0;\n\t\t\t}\n\t\t\tpage_increm = 1 + (~(start >> PAGE_SHIFT) & page_mask);\n\t\t\tif (page_increm > nr_pages)\n\t\t\t\tpage_increm = nr_pages;\n\t\t\ti += page_increm;\n\t\t\tstart += page_increm * PAGE_SIZE;\n\t\t\tnr_pages -= page_increm;\n\t\t} while (nr_pages && start < vma->vm_end);\n\t} while (nr_pages);\n\treturn i;\n}\nEXPORT_SYMBOL(__get_user_pages);\n\n/*\n * fixup_user_fault() - manually resolve a user page fault\n * @tsk:\tthe task_struct to use for page fault accounting, or\n *\t\tNULL if faults are not to be recorded.\n * @mm:\t\tmm_struct of target mm\n * @address:\tuser address\n * @fault_flags:flags to pass down to handle_mm_fault()\n *\n * This is meant to be called in the specific scenario where for locking reasons\n * we try to access user memory in atomic context (within a pagefault_disable()\n * section), this returns -EFAULT, and we want to resolve the user fault before\n * trying again.\n *\n * Typically this is meant to be used by the futex code.\n *\n * The main difference with get_user_pages() is that this function will\n * unconditionally call handle_mm_fault() which will in turn perform all the\n * necessary SW fixup of the dirty and young bits in the PTE, while\n * handle_mm_fault() only guarantees to update these in the struct page.\n *\n * This is important for some architectures where those bits also gate the\n * access permission to the page because they are maintained in software.  On\n * such architectures, gup() will not be enough to make a subsequent access\n * succeed.\n *\n * This should be called with the mm_sem held for read.\n */\nint fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,\n\t\t     unsigned long address, unsigned int fault_flags)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tvma = find_extend_vma(mm, address);\n\tif (!vma || address < vma->vm_start)\n\t\treturn -EFAULT;\n\n\tret = handle_mm_fault(mm, vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn -EHWPOISON;\n\t\tif (ret & VM_FAULT_SIGBUS)\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\treturn 0;\n}\n\n/*\n * get_user_pages() - pin user pages in memory\n * @tsk:\tthe task_struct to use for page fault accounting, or\n *\t\tNULL if faults are not to be recorded.\n * @mm:\t\tmm_struct of target mm\n * @start:\tstarting user address\n * @nr_pages:\tnumber of pages from start to pin\n * @write:\twhether pages will be written to by the caller\n * @force:\twhether to force write access even if user mapping is\n *\t\treadonly. This will result in the page being COWed even\n *\t\tin MAP_SHARED mappings. You do not want this.\n * @pages:\tarray that receives pointers to the pages pinned.\n *\t\tShould be at least nr_pages long. Or NULL, if caller\n *\t\tonly intends to ensure the pages are faulted in.\n * @vmas:\tarray of pointers to vmas corresponding to each page.\n *\t\tOr NULL if the caller does not require them.\n *\n * Returns number of pages pinned. This may be fewer than the number\n * requested. If nr_pages is 0 or negative, returns 0. If no pages\n * were pinned, returns -errno. Each page returned must be released\n * with a put_page() call when it is finished with. vmas will only\n * remain valid while mmap_sem is held.\n *\n * Must be called with mmap_sem held for read or write.\n *\n * get_user_pages walks a process's page tables and takes a reference to\n * each struct page that each user address corresponds to at a given\n * instant. That is, it takes the page that would be accessed if a user\n * thread accesses the given user virtual address at that instant.\n *\n * This does not guarantee that the page exists in the user mappings when\n * get_user_pages returns, and there may even be a completely different\n * page there in some cases (eg. if mmapped pagecache has been invalidated\n * and subsequently re faulted). However it does guarantee that the page\n * won't be freed completely. And mostly callers simply care that the page\n * contains data that was valid *at some point in time*. Typically, an IO\n * or similar operation cannot guarantee anything stronger anyway because\n * locks can't be held over the syscall boundary.\n *\n * If write=0, the page must not be written to. If the page is written to,\n * set_page_dirty (or set_page_dirty_lock, as appropriate) must be called\n * after the page is finished with, and before put_page is called.\n *\n * get_user_pages is typically used for fewer-copy IO operations, to get a\n * handle on the memory by some means other than accesses via the user virtual\n * addresses. The pages may be submitted for DMA to devices or accessed via\n * their kernel linear mapping (via the kmap APIs). Care should be taken to\n * use the correct cache flushing APIs.\n *\n * See also get_user_pages_fast, for performance critical applications.\n */\nlong get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages, int write,\n\t\tint force, struct page **pages, struct vm_area_struct **vmas)\n{\n\tint flags = FOLL_TOUCH;\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\tif (write)\n\t\tflags |= FOLL_WRITE;\n\tif (force)\n\t\tflags |= FOLL_FORCE;\n\n\treturn __get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas,\n\t\t\t\tNULL);\n}\nEXPORT_SYMBOL(get_user_pages);\n\n/**\n * get_dump_page() - pin user page in memory while writing it to core dump\n * @addr: user address\n *\n * Returns struct page pointer of user page pinned for dump,\n * to be freed afterwards by page_cache_release() or put_page().\n *\n * Returns NULL on any kind of failure - a hole must then be inserted into\n * the corefile, to preserve alignment with its headers; and also returns\n * NULL wherever the ZERO_PAGE, or an anonymous pte_none, has been found -\n * allowing a hole to be left in the corefile to save diskspace.\n *\n * Called without mmap_sem, but after all other threads have been killed.\n */\n#ifdef CONFIG_ELF_CORE\nstruct page *get_dump_page(unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\n\tif (__get_user_pages(current, current->mm, addr, 1,\n\t\t\t     FOLL_FORCE | FOLL_DUMP | FOLL_GET, &page, &vma,\n\t\t\t     NULL) < 1)\n\t\treturn NULL;\n\tflush_cache_page(vma, addr, page_to_pfn(page));\n\treturn page;\n}\n#endif /* CONFIG_ELF_CORE */\n\npte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t * pgd = pgd_offset(mm, addr);\n\tpud_t * pud = pud_alloc(mm, pgd, addr);\n\tif (pud) {\n\t\tpmd_t * pmd = pmd_alloc(mm, pud, addr);\n\t\tif (pmd) {\n\t\t\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\t\t\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n * This is the old fallback for page remapping.\n *\n * For historical reasons, it only allows reserved pages. Only\n * old drivers should use this, and they needed to mark their\n * pages reserved for the old functions anyway.\n */\nstatic int insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tretval = -EINVAL;\n\tif (PageAnon(page))\n\t\tgoto out;\n\tretval = -ENOMEM;\n\tflush_dcache_page(page);\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tget_page(page);\n\tinc_mm_counter_fast(mm, MM_FILEPAGES);\n\tpage_add_file_rmap(page);\n\tset_pte_at(mm, addr, pte, mk_pte(page, prot));\n\n\tretval = 0;\n\tpte_unmap_unlock(pte, ptl);\n\treturn retval;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}\n\n/**\n * vm_insert_page - insert single page into user vma\n * @vma: user vma to map to\n * @addr: target user address of this page\n * @page: source kernel page\n *\n * This allows drivers to insert individual pages they've allocated\n * into a user vma.\n *\n * The page has to be a nice clean _individual_ kernel allocation.\n * If you allocate a compound page, you need to have marked it as\n * such (__GFP_COMP), or manually just split the page up yourself\n * (see split_page()).\n *\n * NOTE! Traditionally this was done with \"remap_pfn_range()\" which\n * took an arbitrary page protection parameter. This doesn't allow\n * that. Your vma protection will have to be set up correctly, which\n * means that if you want a shared writable mapping, you'd better\n * ask for a shared writable mapping!\n *\n * The page does not need to be reserved.\n *\n * Usually this function is called from f_op->mmap() handler\n * under mm->mmap_sem write-lock, so it can change vma->vm_flags.\n * Caller must set VM_MIXEDMAP on vma if it wants to call this\n * function from other places, for example from page-fault handler.\n */\nint vm_insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page)\n{\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (!page_count(page))\n\t\treturn -EINVAL;\n\tif (!(vma->vm_flags & VM_MIXEDMAP)) {\n\t\tBUG_ON(down_read_trylock(&vma->vm_mm->mmap_sem));\n\t\tBUG_ON(vma->vm_flags & VM_PFNMAP);\n\t\tvma->vm_flags |= VM_MIXEDMAP;\n\t}\n\treturn insert_page(vma, addr, page, vma->vm_page_prot);\n}\nEXPORT_SYMBOL(vm_insert_page);\n\nstatic int insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tretval = -ENOMEM;\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tentry = pte_mkspecial(pfn_pte(pfn, prot));\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\n\tretval = 0;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}\n\n/**\n * vm_insert_pfn - insert single pfn into user vma\n * @vma: user vma to map to\n * @addr: target user address of this page\n * @pfn: source kernel pfn\n *\n * Similar to vm_insert_page, this allows drivers to insert individual pages\n * they've allocated into a user vma. Same comments apply.\n *\n * This function should only be called from a vm_ops->fault handler, and\n * in that case the handler should return NULL.\n *\n * vma cannot be a COW mapping.\n *\n * As this is called only for pages that do not currently exist, we\n * do not need to flush old virtual caches or the TLB.\n */\nint vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn)\n{\n\tint ret;\n\tpgprot_t pgprot = vma->vm_page_prot;\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (track_pfn_insert(vma, &pgprot, pfn))\n\t\treturn -EINVAL;\n\n\tret = insert_pfn(vma, addr, pfn, pgprot);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vm_insert_pfn);\n\nint vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn)\n{\n\tBUG_ON(!(vma->vm_flags & VM_MIXEDMAP));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we don't have pte special, then we have to use the pfn_valid()\n\t * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*\n\t * refcount the page if pfn_valid is true (hence insert_page rather\n\t * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP\n\t * without pte special, it would there be refcounted as a normal page.\n\t */\n\tif (!HAVE_PTE_SPECIAL && pfn_valid(pfn)) {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(pfn);\n\t\treturn insert_page(vma, addr, page, vma->vm_page_prot);\n\t}\n\treturn insert_pfn(vma, addr, pfn, vma->vm_page_prot);\n}\nEXPORT_SYMBOL(vm_insert_mixed);\n\n/*\n * maps a range of physical memory into the requested pages. the old\n * mappings are removed. any references to nonexistent pages results\n * in null mappings (currently treated as \"copy-on-access\")\n */\nstatic int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tpte = pte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\treturn 0;\n}\n\nstatic inline int remap_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (remap_pte_range(mm, pmd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot))\n\t\t\treturn -ENOMEM;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}\n\nstatic inline int remap_pud_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpud = pud_alloc(mm, pgd, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (remap_pmd_range(mm, pud, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot))\n\t\t\treturn -ENOMEM;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}\n\n/**\n * remap_pfn_range - remap kernel memory to userspace\n * @vma: user vma to map to\n * @addr: target user address to start at\n * @pfn: physical address of kernel memory\n * @size: size of map area\n * @prot: page protection flags for this mapping\n *\n *  Note: this is only safe if the mm semaphore is held when called.\n */\nint remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t    unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\t/*\n\t * Physically remapped pages are special. Tell the\n\t * rest of the world about it:\n\t *   VM_IO tells people not to look at these pages\n\t *\t(accesses can have side effects).\n\t *   VM_PFNMAP tells the core MM that the base pages are just\n\t *\traw PFN mappings, and do not have a \"struct page\" associated\n\t *\twith them.\n\t *   VM_DONTEXPAND\n\t *      Disable vma merging and expanding with mremap().\n\t *   VM_DONTDUMP\n\t *      Omit vma from core dump, even when VM_IO turned off.\n\t *\n\t * There's a horrible special case to handle copy-on-write\n\t * behaviour that some programs depend on. We mark the \"original\"\n\t * un-COW'ed pages by matching them up with \"vma->vm_pgoff\".\n\t * See vm_normal_page() for details.\n\t */\n\tif (is_cow_mapping(vma->vm_flags)) {\n\t\tif (addr != vma->vm_start || end != vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tvma->vm_pgoff = pfn;\n\t}\n\n\terr = track_pfn_remap(vma, &prot, pfn, addr, PAGE_ALIGN(size));\n\tif (err)\n\t\treturn -EINVAL;\n\n\tvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\n\n\tBUG_ON(addr >= end);\n\tpfn -= addr >> PAGE_SHIFT;\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, pgd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\tif (err)\n\t\tuntrack_pfn(vma, pfn, PAGE_ALIGN(size));\n\n\treturn err;\n}\nEXPORT_SYMBOL(remap_pfn_range);\n\nstatic int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpte_t *pte;\n\tint err;\n\tpgtable_t token;\n\tspinlock_t *uninitialized_var(ptl);\n\n\tpte = (mm == &init_mm) ?\n\t\tpte_alloc_kernel(pmd, addr) :\n\t\tpte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(pmd_huge(*pmd));\n\n\tarch_enter_lazy_mmu_mode();\n\n\ttoken = pmd_pgtable(*pmd);\n\n\tdo {\n\t\terr = fn(pte++, token, addr, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\n\tif (mm != &init_mm)\n\t\tpte_unmap_unlock(pte-1, ptl);\n\treturn err;\n}\n\nstatic int apply_to_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tBUG_ON(pud_huge(*pud));\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = apply_to_pte_range(mm, pmd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\treturn err;\n}\n\nstatic int apply_to_pud_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpud = pud_alloc(mm, pgd, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = apply_to_pmd_range(mm, pud, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\treturn err;\n}\n\n/*\n * Scan a region of virtual memory, filling in page tables as necessary\n * and calling a provided function on each leaf page table.\n */\nint apply_to_page_range(struct mm_struct *mm, unsigned long addr,\n\t\t\tunsigned long size, pte_fn_t fn, void *data)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + size;\n\tint err;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset(mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = apply_to_pud_range(mm, pgd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(apply_to_page_range);\n\n/*\n * handle_pte_fault chooses page fault handler according to an entry\n * which was read non-atomically.  Before making any commitment, on\n * those architectures or configurations (e.g. i386 with PAE) which\n * might give a mix of unmatched parts, do_swap_page and do_nonlinear_fault\n * must check under lock before unmapping the pte and proceeding\n * (but do_wp_page is only called after already making such a check;\n * and do_anonymous_page can safely check later on).\n */\nstatic inline int pte_unmap_same(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tpte_t *page_table, pte_t orig_pte)\n{\n\tint same = 1;\n#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)\n\tif (sizeof(pte_t) > sizeof(unsigned long)) {\n\t\tspinlock_t *ptl = pte_lockptr(mm, pmd);\n\t\tspin_lock(ptl);\n\t\tsame = pte_same(*page_table, orig_pte);\n\t\tspin_unlock(ptl);\n\t}\n#endif\n\tpte_unmap(page_table);\n\treturn same;\n}\n\nstatic inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)\n{\n\t/*\n\t * If the source page was a PFN mapping, we don't have\n\t * a \"struct page\" for it. We do a best-effort copy by\n\t * just copying from the original user address. If that\n\t * fails, we just zero-fill it. Live with it.\n\t */\n\tif (unlikely(!src)) {\n\t\tvoid *kaddr = kmap_atomic(dst);\n\t\tvoid __user *uaddr = (void __user *)(va & PAGE_MASK);\n\n\t\t/*\n\t\t * This really shouldn't fail, because the page is there\n\t\t * in the page tables. But it might just be unreadable,\n\t\t * in which case we just give up and fill the result with\n\t\t * zeroes.\n\t\t */\n\t\tif (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))\n\t\t\tclear_page(kaddr);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(dst);\n\t} else\n\t\tcopy_user_highpage(dst, src, va, vma);\n}\n\n/*\n * This routine handles present pages, when users try to write\n * to a shared page. It is done by copying the page to a new address\n * and decrementing the shared-page counter for the old page.\n *\n * Note that this routine assumes that the protection checks have been\n * done by the caller (the low-level page fault routine in most cases).\n * Thus we can safely just mark it writable once we've done any necessary\n * COW.\n *\n * We also mark the page dirty at this point even though the page will\n * change only once the write actually happens. This avoids a few races,\n * and potentially makes it more efficient.\n *\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), with pte both mapped and locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int do_wp_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tspinlock_t *ptl, pte_t orig_pte)\n\t__releases(ptl)\n{\n\tstruct page *old_page, *new_page = NULL;\n\tpte_t entry;\n\tint ret = 0;\n\tint page_mkwrite = 0;\n\tstruct page *dirty_page = NULL;\n\tunsigned long mmun_start = 0;\t/* For mmu_notifiers */\n\tunsigned long mmun_end = 0;\t/* For mmu_notifiers */\n\n\told_page = vm_normal_page(vma, address, orig_pte);\n\tif (!old_page) {\n\t\t/*\n\t\t * VM_MIXEDMAP !pfn_valid() case\n\t\t *\n\t\t * We should not cow pages in a shared writeable mapping.\n\t\t * Just mark the pages writable as we can't do any dirty\n\t\t * accounting on raw pfn maps.\n\t\t */\n\t\tif ((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t     (VM_WRITE|VM_SHARED))\n\t\t\tgoto reuse;\n\t\tgoto gotten;\n\t}\n\n\t/*\n\t * Take out anonymous pages first, anonymous shared vmas are\n\t * not dirty accountable.\n\t */\n\tif (PageAnon(old_page) && !PageKsm(old_page)) {\n\t\tif (!trylock_page(old_page)) {\n\t\t\tpage_cache_get(old_page);\n\t\t\tpte_unmap_unlock(page_table, ptl);\n\t\t\tlock_page(old_page);\n\t\t\tpage_table = pte_offset_map_lock(mm, pmd, address,\n\t\t\t\t\t\t\t &ptl);\n\t\t\tif (!pte_same(*page_table, orig_pte)) {\n\t\t\t\tunlock_page(old_page);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tpage_cache_release(old_page);\n\t\t}\n\t\tif (reuse_swap_page(old_page)) {\n\t\t\t/*\n\t\t\t * The page is all ours.  Move it to our anon_vma so\n\t\t\t * the rmap code will not search our parent or siblings.\n\t\t\t * Protected against the rmap code by the page lock.\n\t\t\t */\n\t\t\tpage_move_anon_rmap(old_page, vma, address);\n\t\t\tunlock_page(old_page);\n\t\t\tgoto reuse;\n\t\t}\n\t\tunlock_page(old_page);\n\t} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED))) {\n\t\t/*\n\t\t * Only catch write-faults on shared writable pages,\n\t\t * read-only shared pages can get COWed by\n\t\t * get_user_pages(.write=1, .force=1).\n\t\t */\n\t\tif (vma->vm_ops && vma->vm_ops->page_mkwrite) {\n\t\t\tstruct vm_fault vmf;\n\t\t\tint tmp;\n\n\t\t\tvmf.virtual_address = (void __user *)(address &\n\t\t\t\t\t\t\t\tPAGE_MASK);\n\t\t\tvmf.pgoff = old_page->index;\n\t\t\tvmf.flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\t\t\tvmf.page = old_page;\n\n\t\t\t/*\n\t\t\t * Notify the address space that the page is about to\n\t\t\t * become writable so that it can prohibit this or wait\n\t\t\t * for the page to get into an appropriate state.\n\t\t\t *\n\t\t\t * We do this without the lock held, so that it can\n\t\t\t * sleep if it needs to.\n\t\t\t */\n\t\t\tpage_cache_get(old_page);\n\t\t\tpte_unmap_unlock(page_table, ptl);\n\n\t\t\ttmp = vma->vm_ops->page_mkwrite(vma, &vmf);\n\t\t\tif (unlikely(tmp &\n\t\t\t\t\t(VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\t\tret = tmp;\n\t\t\t\tgoto unwritable_page;\n\t\t\t}\n\t\t\tif (unlikely(!(tmp & VM_FAULT_LOCKED))) {\n\t\t\t\tlock_page(old_page);\n\t\t\t\tif (!old_page->mapping) {\n\t\t\t\t\tret = 0; /* retry the fault */\n\t\t\t\t\tunlock_page(old_page);\n\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tVM_BUG_ON(!PageLocked(old_page));\n\n\t\t\t/*\n\t\t\t * Since we dropped the lock we need to revalidate\n\t\t\t * the PTE as someone else may have changed it.  If\n\t\t\t * they did, we just return, as we can count on the\n\t\t\t * MMU to tell us if they didn't also make it writable.\n\t\t\t */\n\t\t\tpage_table = pte_offset_map_lock(mm, pmd, address,\n\t\t\t\t\t\t\t &ptl);\n\t\t\tif (!pte_same(*page_table, orig_pte)) {\n\t\t\t\tunlock_page(old_page);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tpage_mkwrite = 1;\n\t\t}\n\t\tdirty_page = old_page;\n\t\tget_page(dirty_page);\n\nreuse:\n\t\tflush_cache_page(vma, address, pte_pfn(orig_pte));\n\t\tentry = pte_mkyoung(orig_pte);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tif (ptep_set_access_flags(vma, address, page_table, entry,1))\n\t\t\tupdate_mmu_cache(vma, address, page_table);\n\t\tpte_unmap_unlock(page_table, ptl);\n\t\tret |= VM_FAULT_WRITE;\n\n\t\tif (!dirty_page)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * Yes, Virginia, this is actually required to prevent a race\n\t\t * with clear_page_dirty_for_io() from clearing the page dirty\n\t\t * bit after it clear all dirty ptes, but before a racing\n\t\t * do_wp_page installs a dirty pte.\n\t\t *\n\t\t * __do_fault is protected similarly.\n\t\t */\n\t\tif (!page_mkwrite) {\n\t\t\twait_on_page_locked(dirty_page);\n\t\t\tset_page_dirty_balance(dirty_page, page_mkwrite);\n\t\t\t/* file_update_time outside page_lock */\n\t\t\tif (vma->vm_file)\n\t\t\t\tfile_update_time(vma->vm_file);\n\t\t}\n\t\tput_page(dirty_page);\n\t\tif (page_mkwrite) {\n\t\t\tstruct address_space *mapping = dirty_page->mapping;\n\n\t\t\tset_page_dirty(dirty_page);\n\t\t\tunlock_page(dirty_page);\n\t\t\tpage_cache_release(dirty_page);\n\t\t\tif (mapping)\t{\n\t\t\t\t/*\n\t\t\t\t * Some device drivers do not set page.mapping\n\t\t\t\t * but still dirty their pages\n\t\t\t\t */\n\t\t\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Ok, we need to copy. Oh, well..\n\t */\n\tpage_cache_get(old_page);\ngotten:\n\tpte_unmap_unlock(page_table, ptl);\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\n\tif (is_zero_pfn(pte_pfn(orig_pte))) {\n\t\tnew_page = alloc_zeroed_user_highpage_movable(vma, address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t} else {\n\t\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t\tcow_user_page(new_page, old_page, address, vma);\n\t}\n\t__SetPageUptodate(new_page);\n\n\tif (mem_cgroup_newpage_charge(new_page, mm, GFP_KERNEL))\n\t\tgoto oom_free_new;\n\n\tmmun_start  = address & PAGE_MASK;\n\tmmun_end    = mmun_start + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Re-check the pte - we dropped the lock\n\t */\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (likely(pte_same(*page_table, orig_pte))) {\n\t\tif (old_page) {\n\t\t\tif (!PageAnon(old_page)) {\n\t\t\t\tdec_mm_counter_fast(mm, MM_FILEPAGES);\n\t\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\t}\n\t\t} else\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\tflush_cache_page(vma, address, pte_pfn(orig_pte));\n\t\tentry = mk_pte(new_page, vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\t/*\n\t\t * Clear the pte entry and flush it first, before updating the\n\t\t * pte with the new entry. This will avoid a race condition\n\t\t * seen in the presence of one thread doing SMC and another\n\t\t * thread doing COW.\n\t\t */\n\t\tptep_clear_flush(vma, address, page_table);\n\t\tpage_add_new_anon_rmap(new_page, vma, address);\n\t\t/*\n\t\t * We call the notify macro here because, when using secondary\n\t\t * mmu page tables (such as kvm shadow page tables), we want the\n\t\t * new page to be mapped directly into the secondary page table.\n\t\t */\n\t\tset_pte_at_notify(mm, address, page_table, entry);\n\t\tupdate_mmu_cache(vma, address, page_table);\n\t\tif (old_page) {\n\t\t\t/*\n\t\t\t * Only after switching the pte to the new page may\n\t\t\t * we remove the mapcount here. Otherwise another\n\t\t\t * process may come and find the rmap count decremented\n\t\t\t * before the pte is switched to the new page, and\n\t\t\t * \"reuse\" the old page writing into it while our pte\n\t\t\t * here still points into it and can be read by other\n\t\t\t * threads.\n\t\t\t *\n\t\t\t * The critical issue is to order this\n\t\t\t * page_remove_rmap with the ptp_clear_flush above.\n\t\t\t * Those stores are ordered by (if nothing else,)\n\t\t\t * the barrier present in the atomic_add_negative\n\t\t\t * in page_remove_rmap.\n\t\t\t *\n\t\t\t * Then the TLB flush in ptep_clear_flush ensures that\n\t\t\t * no process can access the old page before the\n\t\t\t * decremented mapcount is visible. And the old page\n\t\t\t * cannot be reused until after the decremented\n\t\t\t * mapcount is visible. So transitively, TLBs to\n\t\t\t * old page will be flushed before it can be reused.\n\t\t\t */\n\t\t\tpage_remove_rmap(old_page);\n\t\t}\n\n\t\t/* Free the old page.. */\n\t\tnew_page = old_page;\n\t\tret |= VM_FAULT_WRITE;\n\t} else\n\t\tmem_cgroup_uncharge_page(new_page);\n\n\tif (new_page)\n\t\tpage_cache_release(new_page);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\tif (mmun_end > mmun_start)\n\t\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tif (old_page) {\n\t\t/*\n\t\t * Don't let another task, with possibly unlocked vma,\n\t\t * keep the mlocked page.\n\t\t */\n\t\tif ((ret & VM_FAULT_WRITE) && (vma->vm_flags & VM_LOCKED)) {\n\t\t\tlock_page(old_page);\t/* LRU manipulation */\n\t\t\tmunlock_vma_page(old_page);\n\t\t\tunlock_page(old_page);\n\t\t}\n\t\tpage_cache_release(old_page);\n\t}\n\treturn ret;\noom_free_new:\n\tpage_cache_release(new_page);\noom:\n\tif (old_page)\n\t\tpage_cache_release(old_page);\n\treturn VM_FAULT_OOM;\n\nunwritable_page:\n\tpage_cache_release(old_page);\n\treturn ret;\n}\n\nstatic void unmap_mapping_range_vma(struct vm_area_struct *vma,\n\t\tunsigned long start_addr, unsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tzap_page_range_single(vma, start_addr, end_addr - start_addr, details);\n}\n\nstatic inline void unmap_mapping_range_tree(struct rb_root *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + ((vma->vm_end - vma->vm_start) >> PAGE_SHIFT) - 1;\n\t\t/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}\n\nstatic inline void unmap_mapping_range_list(struct list_head *head,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In nonlinear VMAs there is no correspondence between virtual address\n\t * offset and file offset.  So we must perform an exhaustive search\n\t * across *all* the pages in each nonlinear VMA, not just the pages\n\t * whose virtual address lies outside the file truncation point.\n\t */\n\tlist_for_each_entry(vma, head, shared.nonlinear) {\n\t\tdetails->nonlinear_vma = vma;\n\t\tunmap_mapping_range_vma(vma, vma->vm_start, vma->vm_end, details);\n\t}\n}\n\n/**\n * unmap_mapping_range - unmap the portion of all mmaps in the specified address_space corresponding to the specified page range in the underlying file.\n * @mapping: the address space containing mmaps to be unmapped.\n * @holebegin: byte in first page to unmap, relative to the start of\n * the underlying file.  This will be rounded down to a PAGE_SIZE\n * boundary.  Note that this is different from truncate_pagecache(), which\n * must keep the partial page.  In contrast, we must get rid of\n * partial pages.\n * @holelen: size of prospective hole in bytes.  This will be rounded\n * up to a PAGE_SIZE boundary.  A holelen of zero truncates to the\n * end of the file.\n * @even_cows: 1 when truncating a file, unmap even private COWed pages;\n * but 0 when invalidating pagecache, don't throw away private data.\n */\nvoid unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tstruct zap_details details;\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tdetails.check_mapping = even_cows? NULL: mapping;\n\tdetails.nonlinear_vma = NULL;\n\tdetails.first_index = hba;\n\tdetails.last_index = hba + hlen - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\n\tmutex_lock(&mapping->i_mmap_mutex);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\tif (unlikely(!list_empty(&mapping->i_mmap_nonlinear)))\n\t\tunmap_mapping_range_list(&mapping->i_mmap_nonlinear, &details);\n\tmutex_unlock(&mapping->i_mmap_mutex);\n}\nEXPORT_SYMBOL(unmap_mapping_range);\n\n/*\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte mapped but not yet locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int do_swap_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tspinlock_t *ptl;\n\tstruct page *page, *swapcache;\n\tswp_entry_t entry;\n\tpte_t pte;\n\tint locked;\n\tstruct mem_cgroup *ptr;\n\tint exclusive = 0;\n\tint ret = 0;\n\n\tif (!pte_unmap_same(mm, pmd, page_table, orig_pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(orig_pte);\n\tif (unlikely(non_swap_entry(entry))) {\n\t\tif (is_migration_entry(entry)) {\n\t\t\tmigration_entry_wait(mm, pmd, address);\n\t\t} else if (is_hwpoison_entry(entry)) {\n\t\t\tret = VM_FAULT_HWPOISON;\n\t\t} else {\n\t\t\tprint_bad_pte(vma, address, orig_pte, NULL);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t}\n\t\tgoto out;\n\t}\n\tdelayacct_set_flag(DELAYACCT_PF_SWAPIN);\n\tpage = lookup_swap_cache(entry);\n\tif (!page) {\n\t\tpage = swapin_readahead(entry,\n\t\t\t\t\tGFP_HIGHUSER_MOVABLE, vma, address);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Back out if somebody else faulted in this pte\n\t\t\t * while we released the pte lock.\n\t\t\t */\n\t\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\t\t\tif (likely(pte_same(*page_table, orig_pte)))\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/* Had to read the page from swap area: Major fault */\n\t\tret = VM_FAULT_MAJOR;\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tmem_cgroup_count_vm_event(mm, PGMAJFAULT);\n\t} else if (PageHWPoison(page)) {\n\t\t/*\n\t\t * hwpoisoned dirty swapcache pages are kept for killing\n\t\t * owner processes (which may be unknown at hwpoison time)\n\t\t */\n\t\tret = VM_FAULT_HWPOISON;\n\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\tswapcache = page;\n\t\tgoto out_release;\n\t}\n\n\tswapcache = page;\n\tlocked = lock_page_or_retry(page, mm, flags);\n\n\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\tif (!locked) {\n\t\tret |= VM_FAULT_RETRY;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Make sure try_to_free_swap or reuse_swap_page or swapoff did not\n\t * release the swapcache from under us.  The page pin, and pte_same\n\t * test below, are not enough to exclude that.  Even if it is still\n\t * swapcache, we need to check that the page's swap has not changed.\n\t */\n\tif (unlikely(!PageSwapCache(page) || page_private(page) != entry.val))\n\t\tgoto out_page;\n\n\tpage = ksm_might_need_to_copy(page, vma, address);\n\tif (unlikely(!page)) {\n\t\tret = VM_FAULT_OOM;\n\t\tpage = swapcache;\n\t\tgoto out_page;\n\t}\n\n\tif (mem_cgroup_try_charge_swapin(mm, page, GFP_KERNEL, &ptr)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_page;\n\t}\n\n\t/*\n\t * Back out if somebody else already faulted in this pte.\n\t */\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (unlikely(!pte_same(*page_table, orig_pte)))\n\t\tgoto out_nomap;\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_nomap;\n\t}\n\n\t/*\n\t * The page isn't present yet, go ahead with the fault.\n\t *\n\t * Be careful about the sequence of operations here.\n\t * To get its accounting right, reuse_swap_page() must be called\n\t * while the page is counted on swap but not yet in mapcount i.e.\n\t * before page_add_anon_rmap() and swap_free(); try_to_free_swap()\n\t * must be called after the swap_free(), or it will never succeed.\n\t * Because delete_from_swap_page() may be called by reuse_swap_page(),\n\t * mem_cgroup_commit_charge_swapin() may not be able to find swp_entry\n\t * in page->private. In this case, a record in swap_cgroup  is silently\n\t * discarded at swap_free().\n\t */\n\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tdec_mm_counter_fast(mm, MM_SWAPENTS);\n\tpte = mk_pte(page, vma->vm_page_prot);\n\tif ((flags & FAULT_FLAG_WRITE) && reuse_swap_page(page)) {\n\t\tpte = maybe_mkwrite(pte_mkdirty(pte), vma);\n\t\tflags &= ~FAULT_FLAG_WRITE;\n\t\tret |= VM_FAULT_WRITE;\n\t\texclusive = 1;\n\t}\n\tflush_icache_page(vma, page);\n\tset_pte_at(mm, address, page_table, pte);\n\tif (page == swapcache)\n\t\tdo_page_add_anon_rmap(page, vma, address, exclusive);\n\telse /* ksm created a completely new copy */\n\t\tpage_add_new_anon_rmap(page, vma, address);\n\t/* It's better to call commit-charge after rmap is established */\n\tmem_cgroup_commit_charge_swapin(page, ptr);\n\n\tswap_free(entry);\n\tif (vm_swap_full() || (vma->vm_flags & VM_LOCKED) || PageMlocked(page))\n\t\ttry_to_free_swap(page);\n\tunlock_page(page);\n\tif (page != swapcache) {\n\t\t/*\n\t\t * Hold the lock to avoid the swap entry to be reused\n\t\t * until we take the PT lock for the pte_same() check\n\t\t * (to avoid false positives from pte_same). For\n\t\t * further safety release the lock after the swap_free\n\t\t * so that the swap count won't change under a\n\t\t * parallel locked swapcache.\n\t\t */\n\t\tunlock_page(swapcache);\n\t\tpage_cache_release(swapcache);\n\t}\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tret |= do_wp_page(mm, vma, address, page_table, pmd, ptl, pte);\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tret &= VM_FAULT_ERROR;\n\t\tgoto out;\n\t}\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\nout:\n\treturn ret;\nout_nomap:\n\tmem_cgroup_cancel_charge_swapin(ptr);\n\tpte_unmap_unlock(page_table, ptl);\nout_page:\n\tunlock_page(page);\nout_release:\n\tpage_cache_release(page);\n\tif (page != swapcache) {\n\t\tunlock_page(swapcache);\n\t\tpage_cache_release(swapcache);\n\t}\n\treturn ret;\n}\n\n/*\n * This is like a special single-page \"expand_{down|up}wards()\",\n * except we must first make sure that 'address{-|+}PAGE_SIZE'\n * doesn't hit another vma.\n */\nstatic inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)\n{\n\taddress &= PAGE_MASK;\n\tif ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {\n\t\tstruct vm_area_struct *prev = vma->vm_prev;\n\n\t\t/*\n\t\t * Is there a mapping abutting this one below?\n\t\t *\n\t\t * That's only ok if it's the same stack mapping\n\t\t * that has gotten split..\n\t\t */\n\t\tif (prev && prev->vm_end == address)\n\t\t\treturn prev->vm_flags & VM_GROWSDOWN ? 0 : -ENOMEM;\n\n\t\texpand_downwards(vma, address - PAGE_SIZE);\n\t}\n\tif ((vma->vm_flags & VM_GROWSUP) && address + PAGE_SIZE == vma->vm_end) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\n\t\t/* As VM_GROWSDOWN but s/below/above/ */\n\t\tif (next && next->vm_start == address + PAGE_SIZE)\n\t\t\treturn next->vm_flags & VM_GROWSUP ? 0 : -ENOMEM;\n\n\t\texpand_upwards(vma, address + PAGE_SIZE);\n\t}\n\treturn 0;\n}\n\n/*\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte mapped but not yet locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tpte_unmap(page_table);\n\n\t/* Check if we need to add a guard page to the stack */\n\tif (check_stack_guard_page(vma, address) < 0)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/* Use the zero-page for reads */\n\tif (!(flags & FAULT_FLAG_WRITE)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\t__SetPageUptodate(page);\n\n\tif (mem_cgroup_newpage_charge(page, mm, GFP_KERNEL))\n\t\tgoto oom_free_page;\n\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_uncharge_page(page);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}\n\n/*\n * __do_fault() tries to create a new page mapping. It aggressively\n * tries to share with existing pages, but makes a separate copy if\n * the FAULT_FLAG_WRITE is set in the flags parameter in order to avoid\n * the next page fault.\n *\n * As this is called only for pages that do not currently exist, we\n * do not need to flush old virtual caches or the TLB.\n *\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte neither mapped nor locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int __do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd,\n\t\tpgoff_t pgoff, unsigned int flags, pte_t orig_pte)\n{\n\tpte_t *page_table;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct page *cow_page;\n\tpte_t entry;\n\tint anon = 0;\n\tstruct page *dirty_page = NULL;\n\tstruct vm_fault vmf;\n\tint ret;\n\tint page_mkwrite = 0;\n\n\t/*\n\t * If we do COW later, allocate page befor taking lock_page()\n\t * on the file cache page. This will reduce lock holding time.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\n\t\tif (unlikely(anon_vma_prepare(vma)))\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tcow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\t\tif (!cow_page)\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tif (mem_cgroup_newpage_charge(cow_page, mm, GFP_KERNEL)) {\n\t\t\tpage_cache_release(cow_page);\n\t\t\treturn VM_FAULT_OOM;\n\t\t}\n\t} else\n\t\tcow_page = NULL;\n\n\tvmf.virtual_address = (void __user *)(address & PAGE_MASK);\n\tvmf.pgoff = pgoff;\n\tvmf.flags = flags;\n\tvmf.page = NULL;\n\n\tret = vma->vm_ops->fault(vma, &vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t    VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\n\tif (unlikely(PageHWPoison(vmf.page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf.page);\n\t\tret = VM_FAULT_HWPOISON;\n\t\tgoto uncharge_out;\n\t}\n\n\t/*\n\t * For consistency in subsequent calls, make the faulted page always\n\t * locked.\n\t */\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf.page);\n\telse\n\t\tVM_BUG_ON(!PageLocked(vmf.page));\n\n\t/*\n\t * Should we do an early C-O-W break?\n\t */\n\tpage = vmf.page;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!(vma->vm_flags & VM_SHARED)) {\n\t\t\tpage = cow_page;\n\t\t\tanon = 1;\n\t\t\tcopy_user_highpage(page, vmf.page, address, vma);\n\t\t\t__SetPageUptodate(page);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If the page will be shareable, see if the backing\n\t\t\t * address space wants to know that the page is about\n\t\t\t * to become writable\n\t\t\t */\n\t\t\tif (vma->vm_ops->page_mkwrite) {\n\t\t\t\tint tmp;\n\n\t\t\t\tunlock_page(page);\n\t\t\t\tvmf.flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\t\t\t\ttmp = vma->vm_ops->page_mkwrite(vma, &vmf);\n\t\t\t\tif (unlikely(tmp &\n\t\t\t\t\t  (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\t\t\tret = tmp;\n\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t}\n\t\t\t\tif (unlikely(!(tmp & VM_FAULT_LOCKED))) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\tif (!page->mapping) {\n\t\t\t\t\t\tret = 0; /* retry the fault */\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tVM_BUG_ON(!PageLocked(page));\n\t\t\t\tpage_mkwrite = 1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\t/*\n\t * This silly early PAGE_DIRTY setting removes a race\n\t * due to the bad i386 page protection. But it's valid\n\t * for other architectures too.\n\t *\n\t * Note that if FAULT_FLAG_WRITE is set, we either now have\n\t * an exclusive copy of the page, or this is a shared mapping,\n\t * so we can make it writable and dirty to avoid having to\n\t * handle that later.\n\t */\n\t/* Only go through if we didn't race with anybody else... */\n\tif (likely(pte_same(*page_table, orig_pte))) {\n\t\tflush_icache_page(vma, page);\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tif (anon) {\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\tpage_add_new_anon_rmap(page, vma, address);\n\t\t} else {\n\t\t\tinc_mm_counter_fast(mm, MM_FILEPAGES);\n\t\t\tpage_add_file_rmap(page);\n\t\t\tif (flags & FAULT_FLAG_WRITE) {\n\t\t\t\tdirty_page = page;\n\t\t\t\tget_page(dirty_page);\n\t\t\t}\n\t\t}\n\t\tset_pte_at(mm, address, page_table, entry);\n\n\t\t/* no need to invalidate: a not-present page won't be cached */\n\t\tupdate_mmu_cache(vma, address, page_table);\n\t} else {\n\t\tif (cow_page)\n\t\t\tmem_cgroup_uncharge_page(cow_page);\n\t\tif (anon)\n\t\t\tpage_cache_release(page);\n\t\telse\n\t\t\tanon = 1; /* no anon but release faulted_page */\n\t}\n\n\tpte_unmap_unlock(page_table, ptl);\n\n\tif (dirty_page) {\n\t\tstruct address_space *mapping = page->mapping;\n\t\tint dirtied = 0;\n\n\t\tif (set_page_dirty(dirty_page))\n\t\t\tdirtied = 1;\n\t\tunlock_page(dirty_page);\n\t\tput_page(dirty_page);\n\t\tif ((dirtied || page_mkwrite) && mapping) {\n\t\t\t/*\n\t\t\t * Some device drivers do not set page.mapping but still\n\t\t\t * dirty their pages\n\t\t\t */\n\t\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\t}\n\n\t\t/* file_update_time outside page_lock */\n\t\tif (vma->vm_file && !page_mkwrite)\n\t\t\tfile_update_time(vma->vm_file);\n\t} else {\n\t\tunlock_page(vmf.page);\n\t\tif (anon)\n\t\t\tpage_cache_release(vmf.page);\n\t}\n\n\treturn ret;\n\nunwritable_page:\n\tpage_cache_release(page);\n\treturn ret;\nuncharge_out:\n\t/* fs's fault handler get error */\n\tif (cow_page) {\n\t\tmem_cgroup_uncharge_page(cow_page);\n\t\tpage_cache_release(cow_page);\n\t}\n\treturn ret;\n}\n\nstatic int do_linear_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tpte_unmap(page_table);\n\treturn __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}\n\n/*\n * Fault of a previously existing named mapping. Repopulate the pte\n * from the encoded file_pte if possible. This enables swappable\n * nonlinear vmas.\n *\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte mapped but not yet locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int do_nonlinear_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff;\n\n\tflags |= FAULT_FLAG_NONLINEAR;\n\n\tif (!pte_unmap_same(mm, pmd, page_table, orig_pte))\n\t\treturn 0;\n\n\tif (unlikely(!(vma->vm_flags & VM_NONLINEAR))) {\n\t\t/*\n\t\t * Page table corrupted: show pte and kill process.\n\t\t */\n\t\tprint_bad_pte(vma, address, orig_pte, NULL);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tpgoff = pte_to_pgoff(orig_pte);\n\treturn __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}\n\nint numa_migrate_prep(struct page *page, struct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, int current_nid)\n{\n\tget_page(page);\n\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (current_nid == numa_node_id())\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\n\treturn mpol_misplaced(page, vma, addr);\n}\n\nint do_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t   unsigned long addr, pte_t pte, pte_t *ptep, pmd_t *pmd)\n{\n\tstruct page *page = NULL;\n\tspinlock_t *ptl;\n\tint current_nid = -1;\n\tint target_nid;\n\tbool migrated = false;\n\n\t/*\n\t* The \"pte\" at this point cannot be used safely without\n\t* validation through pte_unmap_same(). It's of NUMA type but\n\t* the pfn may be screwed if the read is non atomic.\n\t*\n\t* ptep_modify_prot_start is not called as this is clearing\n\t* the _PAGE_NUMA bit and it is not really expected that there\n\t* would be concurrent hardware modifications to the PTE.\n\t*/\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*ptep, pte))) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tgoto out;\n\t}\n\n\tpte = pte_mknonnuma(pte);\n\tset_pte_at(mm, addr, ptep, pte);\n\tupdate_mmu_cache(vma, addr, ptep);\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (!page) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn 0;\n\t}\n\n\tcurrent_nid = page_to_nid(page);\n\ttarget_nid = numa_migrate_prep(page, vma, addr, current_nid);\n\tpte_unmap_unlock(ptep, ptl);\n\tif (target_nid == -1) {\n\t\t/*\n\t\t * Account for the fault against the current node if it not\n\t\t * being replaced regardless of where the page is located.\n\t\t */\n\t\tcurrent_nid = numa_node_id();\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/* Migrate to the requested node */\n\tmigrated = migrate_misplaced_page(page, target_nid);\n\tif (migrated)\n\t\tcurrent_nid = target_nid;\n\nout:\n\tif (current_nid != -1)\n\t\ttask_numa_fault(current_nid, 1, migrated);\n\treturn 0;\n}\n\n/* NUMA hinting page fault entry point for regular pmds */\n#ifdef CONFIG_NUMA_BALANCING\nstatic int do_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t     unsigned long addr, pmd_t *pmdp)\n{\n\tpmd_t pmd;\n\tpte_t *pte, *orig_pte;\n\tunsigned long _addr = addr & PMD_MASK;\n\tunsigned long offset;\n\tspinlock_t *ptl;\n\tbool numa = false;\n\tint local_nid = numa_node_id();\n\n\tspin_lock(&mm->page_table_lock);\n\tpmd = *pmdp;\n\tif (pmd_numa(pmd)) {\n\t\tset_pmd_at(mm, _addr, pmdp, pmd_mknonnuma(pmd));\n\t\tnuma = true;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (!numa)\n\t\treturn 0;\n\n\t/* we're in a page fault so some vma must be in the range */\n\tBUG_ON(!vma);\n\tBUG_ON(vma->vm_start >= _addr + PMD_SIZE);\n\toffset = max(_addr, vma->vm_start) & ~PMD_MASK;\n\tVM_BUG_ON(offset >= PMD_SIZE);\n\torig_pte = pte = pte_offset_map_lock(mm, pmdp, _addr, &ptl);\n\tpte += offset >> PAGE_SHIFT;\n\tfor (addr = _addr + offset; addr < _addr + PMD_SIZE; pte++, addr += PAGE_SIZE) {\n\t\tpte_t pteval = *pte;\n\t\tstruct page *page;\n\t\tint curr_nid = local_nid;\n\t\tint target_nid;\n\t\tbool migrated;\n\t\tif (!pte_present(pteval))\n\t\t\tcontinue;\n\t\tif (!pte_numa(pteval))\n\t\t\tcontinue;\n\t\tif (addr >= vma->vm_end) {\n\t\t\tvma = find_vma(mm, addr);\n\t\t\t/* there's a pte present so there must be a vma */\n\t\t\tBUG_ON(!vma);\n\t\t\tBUG_ON(addr < vma->vm_start);\n\t\t}\n\t\tif (pte_numa(pteval)) {\n\t\t\tpteval = pte_mknonnuma(pteval);\n\t\t\tset_pte_at(mm, addr, pte, pteval);\n\t\t}\n\t\tpage = vm_normal_page(vma, addr, pteval);\n\t\tif (unlikely(!page))\n\t\t\tcontinue;\n\t\t/* only check non-shared pages */\n\t\tif (unlikely(page_mapcount(page) != 1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note that the NUMA fault is later accounted to either\n\t\t * the node that is currently running or where the page is\n\t\t * migrated to.\n\t\t */\n\t\tcurr_nid = local_nid;\n\t\ttarget_nid = numa_migrate_prep(page, vma, addr,\n\t\t\t\t\t       page_to_nid(page));\n\t\tif (target_nid == -1) {\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Migrate to the requested node */\n\t\tpte_unmap_unlock(pte, ptl);\n\t\tmigrated = migrate_misplaced_page(page, target_nid);\n\t\tif (migrated)\n\t\t\tcurr_nid = target_nid;\n\t\ttask_numa_fault(curr_nid, 1, migrated);\n\n\t\tpte = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\t}\n\tpte_unmap_unlock(orig_pte, ptl);\n\n\treturn 0;\n}\n#else\nstatic int do_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t     unsigned long addr, pmd_t *pmdp)\n{\n\tBUG();\n\treturn 0;\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n/*\n * These routines also need to handle stuff like marking pages dirty\n * and/or accessed for architectures that don't do it in hardware (most\n * RISC architectures).  The early dirtying is also good on the i386.\n *\n * There is also a hook called \"update_mmu_cache()\" that architectures\n * with external mmu caches can use to update those (ie the Sparc or\n * PowerPC hashed page tables that act as extended TLBs).\n *\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte mapped but not yet locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nint handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\n\tentry = *pte;\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_linear_fault(mm, vma, address,\n\t\t\t\t\t\tpte, pmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\tif (pte_file(entry))\n\t\t\treturn do_nonlinear_fault(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\n\tif (pte_numa(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\t/*\n\t\t * This is needed only for protection faults but the arch code\n\t\t * is not yet telling us if this is a protection fault or not.\n\t\t * This still avoids useless tlb flushes for .text page faults\n\t\t * with threads.\n\t\t */\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}\n\n/*\n * By the time we get here, we already hold the mm semaphore\n */\nint handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tmem_cgroup_count_vm_event(mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\treturn hugetlb_fault(mm, vma, address, flags);\n\nretry:\n\tpgd = pgd_offset(mm, address);\n\tpud = pud_alloc(mm, pgd, address);\n\tif (!pud)\n\t\treturn VM_FAULT_OOM;\n\tpmd = pmd_alloc(mm, pud, address);\n\tif (!pmd)\n\t\treturn VM_FAULT_OOM;\n\tif (pmd_none(*pmd) && transparent_hugepage_enabled(vma)) {\n\t\tif (!vma->vm_ops)\n\t\t\treturn do_huge_pmd_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t\t  pmd, flags);\n\t} else {\n\t\tpmd_t orig_pmd = *pmd;\n\t\tint ret;\n\n\t\tbarrier();\n\t\tif (pmd_trans_huge(orig_pmd)) {\n\t\t\tunsigned int dirty = flags & FAULT_FLAG_WRITE;\n\n\t\t\t/*\n\t\t\t * If the pmd is splitting, return and retry the\n\t\t\t * the fault.  Alternative: wait until the split\n\t\t\t * is done, and goto retry.\n\t\t\t */\n\t\t\tif (pmd_trans_splitting(orig_pmd))\n\t\t\t\treturn 0;\n\n\t\t\tif (pmd_numa(orig_pmd))\n\t\t\t\treturn do_huge_pmd_numa_page(mm, vma, address,\n\t\t\t\t\t\t\t     orig_pmd, pmd);\n\n\t\t\tif (dirty && !pmd_write(orig_pmd)) {\n\t\t\t\tret = do_huge_pmd_wp_page(mm, vma, address, pmd,\n\t\t\t\t\t\t\t  orig_pmd);\n\t\t\t\t/*\n\t\t\t\t * If COW results in an oom, the huge pmd will\n\t\t\t\t * have been split, so retry the fault on the\n\t\t\t\t * pte for a smaller charge.\n\t\t\t\t */\n\t\t\t\tif (unlikely(ret & VM_FAULT_OOM))\n\t\t\t\t\tgoto retry;\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pmd_set_accessed(mm, vma, address, pmd,\n\t\t\t\t\t\t      orig_pmd, dirty);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (pmd_numa(*pmd))\n\t\treturn do_pmd_numa_page(mm, vma, address, pmd);\n\n\t/*\n\t * Use __pte_alloc instead of pte_alloc_map, because we can't\n\t * run pte_offset_map on the pmd, if an huge pmd could\n\t * materialize from under us from a different thread.\n\t */\n\tif (unlikely(pmd_none(*pmd)) &&\n\t    unlikely(__pte_alloc(mm, vma, pmd, address)))\n\t\treturn VM_FAULT_OOM;\n\t/* if an huge pmd materialized from under us just retry later */\n\tif (unlikely(pmd_trans_huge(*pmd)))\n\t\treturn 0;\n\t/*\n\t * A regular pmd is established and it can't morph into a huge pmd\n\t * from under us anymore at this point because we hold the mmap_sem\n\t * read mode and khugepaged takes it in write mode. So now it's\n\t * safe to run pte_offset_map().\n\t */\n\tpte = pte_offset_map(pmd, address);\n\n\treturn handle_pte_fault(mm, vma, address, pte, pmd, flags);\n}\n\n#ifndef __PAGETABLE_PUD_FOLDED\n/*\n * Allocate page upper directory.\n * We've already handled the fast-path in-line.\n */\nint __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tpud_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}\n#endif /* __PAGETABLE_PUD_FOLDED */\n\n#ifndef __PAGETABLE_PMD_FOLDED\n/*\n * Allocate page middle directory.\n * We've already handled the fast-path in-line.\n */\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (pud_present(*pud))\t\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n\telse\n\t\tpud_populate(mm, pud, new);\n#else\n\tif (pgd_present(*pud))\t\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pud, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}\n#endif /* __PAGETABLE_PMD_FOLDED */\n\n#if !defined(__HAVE_ARCH_GATE_AREA)\n\n#if defined(AT_SYSINFO_EHDR)\nstatic struct vm_area_struct gate_vma;\n\nstatic int __init gate_vma_init(void)\n{\n\tgate_vma.vm_mm = NULL;\n\tgate_vma.vm_start = FIXADDR_USER_START;\n\tgate_vma.vm_end = FIXADDR_USER_END;\n\tgate_vma.vm_flags = VM_READ | VM_MAYREAD | VM_EXEC | VM_MAYEXEC;\n\tgate_vma.vm_page_prot = __P101;\n\n\treturn 0;\n}\n__initcall(gate_vma_init);\n#endif\n\nstruct vm_area_struct *get_gate_vma(struct mm_struct *mm)\n{\n#ifdef AT_SYSINFO_EHDR\n\treturn &gate_vma;\n#else\n\treturn NULL;\n#endif\n}\n\nint in_gate_area_no_mm(unsigned long addr)\n{\n#ifdef AT_SYSINFO_EHDR\n\tif ((addr >= FIXADDR_USER_START) && (addr < FIXADDR_USER_END))\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\n#endif\t/* __HAVE_ARCH_GATE_AREA */\n\nstatic int __follow_pte(struct mm_struct *mm, unsigned long address,\n\t\tpte_t **ptepp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\t/* We cannot handle huge page PFN maps. Luckily they don't exist. */\n\tif (pmd_huge(*pmd))\n\t\tgoto out;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!ptep)\n\t\tgoto out;\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\nout:\n\treturn -EINVAL;\n}\n\nstatic inline int follow_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t     pte_t **ptepp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte(mm, address, ptepp, ptlp)));\n\treturn res;\n}\n\n/**\n * follow_pfn - look up PFN at a user virtual address\n * @vma: memory mapping\n * @address: user virtual address\n * @pfn: location to store found PFN\n *\n * Only IO mappings and raw PFN mappings are allowed.\n *\n * Returns zero and the pfn at @pfn on success, -ve otherwise.\n */\nint follow_pfn(struct vm_area_struct *vma, unsigned long address,\n\tunsigned long *pfn)\n{\n\tint ret = -EINVAL;\n\tspinlock_t *ptl;\n\tpte_t *ptep;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\treturn ret;\n\n\tret = follow_pte(vma->vm_mm, address, &ptep, &ptl);\n\tif (ret)\n\t\treturn ret;\n\t*pfn = pte_pfn(*ptep);\n\tpte_unmap_unlock(ptep, ptl);\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_pfn);\n\n#ifdef CONFIG_HAVE_IOREMAP_PROT\nint follow_phys(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags,\n\t\tunsigned long *prot, resource_size_t *phys)\n{\n\tint ret = -EINVAL;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\tgoto out;\n\n\tif (follow_pte(vma->vm_mm, address, &ptep, &ptl))\n\t\tgoto out;\n\tpte = *ptep;\n\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\n\t*prot = pgprot_val(pte_pgprot(pte));\n\t*phys = (resource_size_t)pte_pfn(pte) << PAGE_SHIFT;\n\n\tret = 0;\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn ret;\n}\n\nint generic_access_phys(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tvoid *buf, int len, int write)\n{\n\tresource_size_t phys_addr;\n\tunsigned long prot = 0;\n\tvoid __iomem *maddr;\n\tint offset = addr & (PAGE_SIZE-1);\n\n\tif (follow_phys(vma, addr, write, &prot, &phys_addr))\n\t\treturn -EINVAL;\n\n\tmaddr = ioremap_prot(phys_addr, PAGE_SIZE, prot);\n\tif (write)\n\t\tmemcpy_toio(maddr + offset, buf, len);\n\telse\n\t\tmemcpy_fromio(buf, maddr + offset, len);\n\tiounmap(maddr);\n\n\treturn len;\n}\n#endif\n\n/*\n * Access another process' address space as given in mm.  If non-NULL, use the\n * given task for page fault accounting.\n */\nstatic int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long addr, void *buf, int len, int write)\n{\n\tstruct vm_area_struct *vma;\n\tvoid *old_buf = buf;\n\n\tdown_read(&mm->mmap_sem);\n\t/* ignore errors, just check how much was successfully transferred */\n\twhile (len) {\n\t\tint bytes, ret, offset;\n\t\tvoid *maddr;\n\t\tstruct page *page = NULL;\n\n\t\tret = get_user_pages(tsk, mm, addr, 1,\n\t\t\t\twrite, 1, &page, &vma);\n\t\tif (ret <= 0) {\n\t\t\t/*\n\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\n\t\t\t * we can access using slightly different code.\n\t\t\t */\n#ifdef CONFIG_HAVE_IOREMAP_PROT\n\t\t\tvma = find_vma(mm, addr);\n\t\t\tif (!vma || vma->vm_start > addr)\n\t\t\t\tbreak;\n\t\t\tif (vma->vm_ops && vma->vm_ops->access)\n\t\t\t\tret = vma->vm_ops->access(vma, addr, buf,\n\t\t\t\t\t\t\t  len, write);\n\t\t\tif (ret <= 0)\n#endif\n\t\t\t\tbreak;\n\t\t\tbytes = ret;\n\t\t} else {\n\t\t\tbytes = len;\n\t\t\toffset = addr & (PAGE_SIZE-1);\n\t\t\tif (bytes > PAGE_SIZE-offset)\n\t\t\t\tbytes = PAGE_SIZE-offset;\n\n\t\t\tmaddr = kmap(page);\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr,\n\t\t\t\t\t\t  maddr + offset, buf, bytes);\n\t\t\t\tset_page_dirty_lock(page);\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tlen -= bytes;\n\t\tbuf += bytes;\n\t\taddr += bytes;\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn buf - old_buf;\n}\n\n/**\n * access_remote_vm - access another process' address space\n * @mm:\t\tthe mm_struct of the target address space\n * @addr:\tstart address to access\n * @buf:\tsource or destination buffer\n * @len:\tnumber of bytes to transfer\n * @write:\twhether the access is a write\n *\n * The caller must hold a reference on @mm.\n */\nint access_remote_vm(struct mm_struct *mm, unsigned long addr,\n\t\tvoid *buf, int len, int write)\n{\n\treturn __access_remote_vm(NULL, mm, addr, buf, len, write);\n}\n\n/*\n * Access another process' address space.\n * Source/target buffer must be kernel space,\n * Do not walk the page table directly, use get_user_pages\n */\nint access_process_vm(struct task_struct *tsk, unsigned long addr,\n\t\tvoid *buf, int len, int write)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, write);\n\tmmput(mm);\n\n\treturn ret;\n}\n\n/*\n * Print the name of a VMA.\n */\nvoid print_vma_addr(char *prefix, unsigned long ip)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * Do not print if we are in atomic\n\t * contexts (in exception stacks, etc.):\n\t */\n\tif (preempt_count())\n\t\treturn;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, ip);\n\tif (vma && vma->vm_file) {\n\t\tstruct file *f = vma->vm_file;\n\t\tchar *buf = (char *)__get_free_page(GFP_KERNEL);\n\t\tif (buf) {\n\t\t\tchar *p;\n\n\t\t\tp = d_path(&f->f_path, buf, PAGE_SIZE);\n\t\t\tif (IS_ERR(p))\n\t\t\t\tp = \"?\";\n\t\t\tprintk(\"%s%s[%lx+%lx]\", prefix, kbasename(p),\n\t\t\t\t\tvma->vm_start,\n\t\t\t\t\tvma->vm_end - vma->vm_start);\n\t\t\tfree_page((unsigned long)buf);\n\t\t}\n\t}\n\tup_read(&mm->mmap_sem);\n}\n\n#ifdef CONFIG_PROVE_LOCKING\nvoid might_fault(void)\n{\n\t/*\n\t * Some code (nfs/sunrpc) uses socket ops on kernel memory while\n\t * holding the mmap_sem, this is safe because kernel memory doesn't\n\t * get paged out, therefore we'll never actually fault, and the\n\t * below annotations will generate false positives.\n\t */\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\treturn;\n\n\tmight_sleep();\n\t/*\n\t * it would be nicer only to annotate paths which are not under\n\t * pagefault_disable, however that requires a larger audit and\n\t * providing helpers like get_user_atomic.\n\t */\n\tif (!in_atomic() && current->mm)\n\t\tmight_lock_read(&current->mm->mmap_sem);\n}\nEXPORT_SYMBOL(might_fault);\n#endif\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_HUGETLBFS)\nstatic void clear_gigantic_page(struct page *page,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *p = page;\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page;\n\t     i++, p = mem_map_next(p, page, i)) {\n\t\tcond_resched();\n\t\tclear_user_highpage(p, addr + i * PAGE_SIZE);\n\t}\n}\nvoid clear_huge_page(struct page *page,\n\t\t     unsigned long addr, unsigned int pages_per_huge_page)\n{\n\tint i;\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page; i++) {\n\t\tcond_resched();\n\t\tclear_user_highpage(page + i, addr + i * PAGE_SIZE);\n\t}\n}\n\nstatic void copy_user_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct vm_area_struct *vma,\n\t\t\t\t    unsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < pages_per_huge_page; ) {\n\t\tcond_resched();\n\t\tcopy_user_highpage(dst, src, addr + i*PAGE_SIZE, vma);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}\n\nvoid copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t unsigned long addr, struct vm_area_struct *vma,\n\t\t\t unsigned int pages_per_huge_page)\n{\n\tint i;\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tcopy_user_gigantic_page(dst, src, addr, vma,\n\t\t\t\t\tpages_per_huge_page);\n\t\treturn;\n\t}\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page; i++) {\n\t\tcond_resched();\n\t\tcopy_user_highpage(dst + i, src + i, addr + i*PAGE_SIZE, vma);\n\t}\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */\n"], "fixing_code": ["#ifndef _LINUX_MM_H\n#define _LINUX_MM_H\n\n#include <linux/errno.h>\n\n#ifdef __KERNEL__\n\n#include <linux/gfp.h>\n#include <linux/bug.h>\n#include <linux/list.h>\n#include <linux/mmzone.h>\n#include <linux/rbtree.h>\n#include <linux/atomic.h>\n#include <linux/debug_locks.h>\n#include <linux/mm_types.h>\n#include <linux/range.h>\n#include <linux/pfn.h>\n#include <linux/bit_spinlock.h>\n#include <linux/shrinker.h>\n\nstruct mempolicy;\nstruct anon_vma;\nstruct anon_vma_chain;\nstruct file_ra_state;\nstruct user_struct;\nstruct writeback_control;\n\n#ifndef CONFIG_DISCONTIGMEM          /* Don't use mapnrs, do it properly */\nextern unsigned long max_mapnr;\n#endif\n\nextern unsigned long num_physpages;\nextern unsigned long totalram_pages;\nextern void * high_memory;\nextern int page_cluster;\n\n#ifdef CONFIG_SYSCTL\nextern int sysctl_legacy_va_layout;\n#else\n#define sysctl_legacy_va_layout 0\n#endif\n\n#include <asm/page.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n\n#define nth_page(page,n) pfn_to_page(page_to_pfn((page)) + (n))\n\n/* to align the pointer to the (next) page boundary */\n#define PAGE_ALIGN(addr) ALIGN(addr, PAGE_SIZE)\n\n/*\n * Linux kernel virtual memory manager primitives.\n * The idea being to have a \"virtual\" mm in the same way\n * we have a virtual fs - giving a cleaner interface to the\n * mm details, and allowing different kinds of memory mappings\n * (from shared memory to executable loading to arbitrary\n * mmap() functions).\n */\n\nextern struct kmem_cache *vm_area_cachep;\n\n#ifndef CONFIG_MMU\nextern struct rb_root nommu_region_tree;\nextern struct rw_semaphore nommu_region_sem;\n\nextern unsigned int kobjsize(const void *objp);\n#endif\n\n/*\n * vm_flags in vm_area_struct, see mm_types.h.\n */\n#define VM_NONE\t\t0x00000000\n\n#define VM_READ\t\t0x00000001\t/* currently active flags */\n#define VM_WRITE\t0x00000002\n#define VM_EXEC\t\t0x00000004\n#define VM_SHARED\t0x00000008\n\n/* mprotect() hardcodes VM_MAYREAD >> 4 == VM_READ, and so for r/w/x bits. */\n#define VM_MAYREAD\t0x00000010\t/* limits for mprotect() etc */\n#define VM_MAYWRITE\t0x00000020\n#define VM_MAYEXEC\t0x00000040\n#define VM_MAYSHARE\t0x00000080\n\n#define VM_GROWSDOWN\t0x00000100\t/* general info on the segment */\n#define VM_PFNMAP\t0x00000400\t/* Page-ranges managed without \"struct page\", just pure PFN */\n#define VM_DENYWRITE\t0x00000800\t/* ETXTBSY on write attempts.. */\n\n#define VM_LOCKED\t0x00002000\n#define VM_IO           0x00004000\t/* Memory mapped I/O or similar */\n\n\t\t\t\t\t/* Used by sys_madvise() */\n#define VM_SEQ_READ\t0x00008000\t/* App will access data sequentially */\n#define VM_RAND_READ\t0x00010000\t/* App will not benefit from clustered reads */\n\n#define VM_DONTCOPY\t0x00020000      /* Do not copy this vma on fork */\n#define VM_DONTEXPAND\t0x00040000\t/* Cannot expand with mremap() */\n#define VM_ACCOUNT\t0x00100000\t/* Is a VM accounted object */\n#define VM_NORESERVE\t0x00200000\t/* should the VM suppress accounting */\n#define VM_HUGETLB\t0x00400000\t/* Huge TLB Page VM */\n#define VM_NONLINEAR\t0x00800000\t/* Is non-linear (remap_file_pages) */\n#define VM_ARCH_1\t0x01000000\t/* Architecture-specific flag */\n#define VM_DONTDUMP\t0x04000000\t/* Do not include in the core dump */\n\n#define VM_MIXEDMAP\t0x10000000\t/* Can contain \"struct page\" and pure PFN pages */\n#define VM_HUGEPAGE\t0x20000000\t/* MADV_HUGEPAGE marked this vma */\n#define VM_NOHUGEPAGE\t0x40000000\t/* MADV_NOHUGEPAGE marked this vma */\n#define VM_MERGEABLE\t0x80000000\t/* KSM may merge identical pages */\n\n#if defined(CONFIG_X86)\n# define VM_PAT\t\tVM_ARCH_1\t/* PAT reserves whole VMA at once (x86) */\n#elif defined(CONFIG_PPC)\n# define VM_SAO\t\tVM_ARCH_1\t/* Strong Access Ordering (powerpc) */\n#elif defined(CONFIG_PARISC)\n# define VM_GROWSUP\tVM_ARCH_1\n#elif defined(CONFIG_METAG)\n# define VM_GROWSUP\tVM_ARCH_1\n#elif defined(CONFIG_IA64)\n# define VM_GROWSUP\tVM_ARCH_1\n#elif !defined(CONFIG_MMU)\n# define VM_MAPPED_COPY\tVM_ARCH_1\t/* T if mapped copy of data (nommu mmap) */\n#endif\n\n#ifndef VM_GROWSUP\n# define VM_GROWSUP\tVM_NONE\n#endif\n\n/* Bits set in the VMA until the stack is in its final location */\n#define VM_STACK_INCOMPLETE_SETUP\t(VM_RAND_READ | VM_SEQ_READ)\n\n#ifndef VM_STACK_DEFAULT_FLAGS\t\t/* arch can override this */\n#define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS\n#endif\n\n#ifdef CONFIG_STACK_GROWSUP\n#define VM_STACK_FLAGS\t(VM_GROWSUP | VM_STACK_DEFAULT_FLAGS | VM_ACCOUNT)\n#else\n#define VM_STACK_FLAGS\t(VM_GROWSDOWN | VM_STACK_DEFAULT_FLAGS | VM_ACCOUNT)\n#endif\n\n#define VM_READHINTMASK\t\t\t(VM_SEQ_READ | VM_RAND_READ)\n#define VM_ClearReadHint(v)\t\t(v)->vm_flags &= ~VM_READHINTMASK\n#define VM_NormalReadHint(v)\t\t(!((v)->vm_flags & VM_READHINTMASK))\n#define VM_SequentialReadHint(v)\t((v)->vm_flags & VM_SEQ_READ)\n#define VM_RandomReadHint(v)\t\t((v)->vm_flags & VM_RAND_READ)\n\n/*\n * Special vmas that are non-mergable, non-mlock()able.\n * Note: mm/huge_memory.c VM_NO_THP depends on this definition.\n */\n#define VM_SPECIAL (VM_IO | VM_DONTEXPAND | VM_PFNMAP)\n\n/*\n * mapping from the currently active vm_flags protection bits (the\n * low four bits) to a page protection mask..\n */\nextern pgprot_t protection_map[16];\n\n#define FAULT_FLAG_WRITE\t0x01\t/* Fault was a write access */\n#define FAULT_FLAG_NONLINEAR\t0x02\t/* Fault was via a nonlinear mapping */\n#define FAULT_FLAG_MKWRITE\t0x04\t/* Fault was mkwrite of existing pte */\n#define FAULT_FLAG_ALLOW_RETRY\t0x08\t/* Retry fault if blocking */\n#define FAULT_FLAG_RETRY_NOWAIT\t0x10\t/* Don't drop mmap_sem and wait when retrying */\n#define FAULT_FLAG_KILLABLE\t0x20\t/* The fault task is in SIGKILL killable region */\n#define FAULT_FLAG_TRIED\t0x40\t/* second try */\n\n/*\n * vm_fault is filled by the the pagefault handler and passed to the vma's\n * ->fault function. The vma's ->fault is responsible for returning a bitmask\n * of VM_FAULT_xxx flags that give details about how the fault was handled.\n *\n * pgoff should be used in favour of virtual_address, if possible. If pgoff\n * is used, one may implement ->remap_pages to get nonlinear mapping support.\n */\nstruct vm_fault {\n\tunsigned int flags;\t\t/* FAULT_FLAG_xxx flags */\n\tpgoff_t pgoff;\t\t\t/* Logical page offset based on vma */\n\tvoid __user *virtual_address;\t/* Faulting virtual address */\n\n\tstruct page *page;\t\t/* ->fault handlers should return a\n\t\t\t\t\t * page here, unless VM_FAULT_NOPAGE\n\t\t\t\t\t * is set (which is also implied by\n\t\t\t\t\t * VM_FAULT_ERROR).\n\t\t\t\t\t */\n};\n\n/*\n * These are the virtual MM functions - opening of an area, closing and\n * unmapping it (needed to keep files on disk up-to-date etc), pointer\n * to the functions called when a no-page or a wp-page exception occurs. \n */\nstruct vm_operations_struct {\n\tvoid (*open)(struct vm_area_struct * area);\n\tvoid (*close)(struct vm_area_struct * area);\n\tint (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);\n\n\t/* notification that a previously read-only page is about to become\n\t * writable, if an error is returned it will cause a SIGBUS */\n\tint (*page_mkwrite)(struct vm_area_struct *vma, struct vm_fault *vmf);\n\n\t/* called by access_process_vm when get_user_pages() fails, typically\n\t * for use by special VMAs that can switch between memory and hardware\n\t */\n\tint (*access)(struct vm_area_struct *vma, unsigned long addr,\n\t\t      void *buf, int len, int write);\n#ifdef CONFIG_NUMA\n\t/*\n\t * set_policy() op must add a reference to any non-NULL @new mempolicy\n\t * to hold the policy upon return.  Caller should pass NULL @new to\n\t * remove a policy and fall back to surrounding context--i.e. do not\n\t * install a MPOL_DEFAULT policy, nor the task or system default\n\t * mempolicy.\n\t */\n\tint (*set_policy)(struct vm_area_struct *vma, struct mempolicy *new);\n\n\t/*\n\t * get_policy() op must add reference [mpol_get()] to any policy at\n\t * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure\n\t * in mm/mempolicy.c will do this automatically.\n\t * get_policy() must NOT add a ref if the policy at (vma,addr) is not\n\t * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.\n\t * If no [shared/vma] mempolicy exists at the addr, get_policy() op\n\t * must return NULL--i.e., do not \"fallback\" to task or system default\n\t * policy.\n\t */\n\tstruct mempolicy *(*get_policy)(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr);\n\tint (*migrate)(struct vm_area_struct *vma, const nodemask_t *from,\n\t\tconst nodemask_t *to, unsigned long flags);\n#endif\n\t/* called by sys_remap_file_pages() to populate non-linear mapping */\n\tint (*remap_pages)(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t   unsigned long size, pgoff_t pgoff);\n};\n\nstruct mmu_gather;\nstruct inode;\n\n#define page_private(page)\t\t((page)->private)\n#define set_page_private(page, v)\t((page)->private = (v))\n\n/* It's valid only if the page is free path or free_list */\nstatic inline void set_freepage_migratetype(struct page *page, int migratetype)\n{\n\tpage->index = migratetype;\n}\n\n/* It's valid only if the page is free path or free_list */\nstatic inline int get_freepage_migratetype(struct page *page)\n{\n\treturn page->index;\n}\n\n/*\n * FIXME: take this include out, include page-flags.h in\n * files which need it (119 of them)\n */\n#include <linux/page-flags.h>\n#include <linux/huge_mm.h>\n\n/*\n * Methods to modify the page usage count.\n *\n * What counts for a page usage:\n * - cache mapping   (page->mapping)\n * - private data    (page->private)\n * - page mapped in a task's page tables, each mapping\n *   is counted separately\n *\n * Also, many kernel routines increase the page count before a critical\n * routine so they can be sure the page doesn't go away from under them.\n */\n\n/*\n * Drop a ref, return true if the refcount fell to zero (the page has no users)\n */\nstatic inline int put_page_testzero(struct page *page)\n{\n\tVM_BUG_ON(atomic_read(&page->_count) == 0);\n\treturn atomic_dec_and_test(&page->_count);\n}\n\n/*\n * Try to grab a ref unless the page has a refcount of zero, return false if\n * that is the case.\n */\nstatic inline int get_page_unless_zero(struct page *page)\n{\n\treturn atomic_inc_not_zero(&page->_count);\n}\n\nextern int page_is_ram(unsigned long pfn);\n\n/* Support for virtually mapped pages */\nstruct page *vmalloc_to_page(const void *addr);\nunsigned long vmalloc_to_pfn(const void *addr);\n\n/*\n * Determine if an address is within the vmalloc range\n *\n * On nommu, vmalloc/vfree wrap through kmalloc/kfree directly, so there\n * is no special casing required.\n */\nstatic inline int is_vmalloc_addr(const void *x)\n{\n#ifdef CONFIG_MMU\n\tunsigned long addr = (unsigned long)x;\n\n\treturn addr >= VMALLOC_START && addr < VMALLOC_END;\n#else\n\treturn 0;\n#endif\n}\n#ifdef CONFIG_MMU\nextern int is_vmalloc_or_module_addr(const void *x);\n#else\nstatic inline int is_vmalloc_or_module_addr(const void *x)\n{\n\treturn 0;\n}\n#endif\n\nstatic inline void compound_lock(struct page *page)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tVM_BUG_ON(PageSlab(page));\n\tbit_spin_lock(PG_compound_lock, &page->flags);\n#endif\n}\n\nstatic inline void compound_unlock(struct page *page)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tVM_BUG_ON(PageSlab(page));\n\tbit_spin_unlock(PG_compound_lock, &page->flags);\n#endif\n}\n\nstatic inline unsigned long compound_lock_irqsave(struct page *page)\n{\n\tunsigned long uninitialized_var(flags);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tlocal_irq_save(flags);\n\tcompound_lock(page);\n#endif\n\treturn flags;\n}\n\nstatic inline void compound_unlock_irqrestore(struct page *page,\n\t\t\t\t\t      unsigned long flags)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tcompound_unlock(page);\n\tlocal_irq_restore(flags);\n#endif\n}\n\nstatic inline struct page *compound_head(struct page *page)\n{\n\tif (unlikely(PageTail(page)))\n\t\treturn page->first_page;\n\treturn page;\n}\n\n/*\n * The atomic page->_mapcount, starts from -1: so that transitions\n * both from it and to it can be tracked, using atomic_inc_and_test\n * and atomic_add_negative(-1).\n */\nstatic inline void page_mapcount_reset(struct page *page)\n{\n\tatomic_set(&(page)->_mapcount, -1);\n}\n\nstatic inline int page_mapcount(struct page *page)\n{\n\treturn atomic_read(&(page)->_mapcount) + 1;\n}\n\nstatic inline int page_count(struct page *page)\n{\n\treturn atomic_read(&compound_head(page)->_count);\n}\n\nstatic inline void get_huge_page_tail(struct page *page)\n{\n\t/*\n\t * __split_huge_page_refcount() cannot run\n\t * from under us.\n\t */\n\tVM_BUG_ON(page_mapcount(page) < 0);\n\tVM_BUG_ON(atomic_read(&page->_count) != 0);\n\tatomic_inc(&page->_mapcount);\n}\n\nextern bool __get_page_tail(struct page *page);\n\nstatic inline void get_page(struct page *page)\n{\n\tif (unlikely(PageTail(page)))\n\t\tif (likely(__get_page_tail(page)))\n\t\t\treturn;\n\t/*\n\t * Getting a normal page or the head of a compound page\n\t * requires to already have an elevated page->_count.\n\t */\n\tVM_BUG_ON(atomic_read(&page->_count) <= 0);\n\tatomic_inc(&page->_count);\n}\n\nstatic inline struct page *virt_to_head_page(const void *x)\n{\n\tstruct page *page = virt_to_page(x);\n\treturn compound_head(page);\n}\n\n/*\n * Setup the page count before being freed into the page allocator for\n * the first time (boot or memory hotplug)\n */\nstatic inline void init_page_count(struct page *page)\n{\n\tatomic_set(&page->_count, 1);\n}\n\n/*\n * PageBuddy() indicate that the page is free and in the buddy system\n * (see mm/page_alloc.c).\n *\n * PAGE_BUDDY_MAPCOUNT_VALUE must be <= -2 but better not too close to\n * -2 so that an underflow of the page_mapcount() won't be mistaken\n * for a genuine PAGE_BUDDY_MAPCOUNT_VALUE. -128 can be created very\n * efficiently by most CPU architectures.\n */\n#define PAGE_BUDDY_MAPCOUNT_VALUE (-128)\n\nstatic inline int PageBuddy(struct page *page)\n{\n\treturn atomic_read(&page->_mapcount) == PAGE_BUDDY_MAPCOUNT_VALUE;\n}\n\nstatic inline void __SetPageBuddy(struct page *page)\n{\n\tVM_BUG_ON(atomic_read(&page->_mapcount) != -1);\n\tatomic_set(&page->_mapcount, PAGE_BUDDY_MAPCOUNT_VALUE);\n}\n\nstatic inline void __ClearPageBuddy(struct page *page)\n{\n\tVM_BUG_ON(!PageBuddy(page));\n\tatomic_set(&page->_mapcount, -1);\n}\n\nvoid put_page(struct page *page);\nvoid put_pages_list(struct list_head *pages);\n\nvoid split_page(struct page *page, unsigned int order);\nint split_free_page(struct page *page);\n\n/*\n * Compound pages have a destructor function.  Provide a\n * prototype for that function and accessor functions.\n * These are _only_ valid on the head of a PG_compound page.\n */\ntypedef void compound_page_dtor(struct page *);\n\nstatic inline void set_compound_page_dtor(struct page *page,\n\t\t\t\t\t\tcompound_page_dtor *dtor)\n{\n\tpage[1].lru.next = (void *)dtor;\n}\n\nstatic inline compound_page_dtor *get_compound_page_dtor(struct page *page)\n{\n\treturn (compound_page_dtor *)page[1].lru.next;\n}\n\nstatic inline int compound_order(struct page *page)\n{\n\tif (!PageHead(page))\n\t\treturn 0;\n\treturn (unsigned long)page[1].lru.prev;\n}\n\nstatic inline int compound_trans_order(struct page *page)\n{\n\tint order;\n\tunsigned long flags;\n\n\tif (!PageHead(page))\n\t\treturn 0;\n\n\tflags = compound_lock_irqsave(page);\n\torder = compound_order(page);\n\tcompound_unlock_irqrestore(page, flags);\n\treturn order;\n}\n\nstatic inline void set_compound_order(struct page *page, unsigned long order)\n{\n\tpage[1].lru.prev = (void *)order;\n}\n\n#ifdef CONFIG_MMU\n/*\n * Do pte_mkwrite, but only if the vma says VM_WRITE.  We do this when\n * servicing faults for write access.  In the normal case, do always want\n * pte_mkwrite.  But get_user_pages can cause write faults for mappings\n * that do not have writing enabled, when used by access_process_vm.\n */\nstatic inline pte_t maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpte = pte_mkwrite(pte);\n\treturn pte;\n}\n#endif\n\n/*\n * Multiple processes may \"see\" the same page. E.g. for untouched\n * mappings of /dev/null, all processes see the same page full of\n * zeroes, and text pages of executables and shared libraries have\n * only one copy in memory, at most, normally.\n *\n * For the non-reserved pages, page_count(page) denotes a reference count.\n *   page_count() == 0 means the page is free. page->lru is then used for\n *   freelist management in the buddy allocator.\n *   page_count() > 0  means the page has been allocated.\n *\n * Pages are allocated by the slab allocator in order to provide memory\n * to kmalloc and kmem_cache_alloc. In this case, the management of the\n * page, and the fields in 'struct page' are the responsibility of mm/slab.c\n * unless a particular usage is carefully commented. (the responsibility of\n * freeing the kmalloc memory is the caller's, of course).\n *\n * A page may be used by anyone else who does a __get_free_page().\n * In this case, page_count still tracks the references, and should only\n * be used through the normal accessor functions. The top bits of page->flags\n * and page->virtual store page management information, but all other fields\n * are unused and could be used privately, carefully. The management of this\n * page is the responsibility of the one who allocated it, and those who have\n * subsequently been given references to it.\n *\n * The other pages (we may call them \"pagecache pages\") are completely\n * managed by the Linux memory manager: I/O, buffers, swapping etc.\n * The following discussion applies only to them.\n *\n * A pagecache page contains an opaque `private' member, which belongs to the\n * page's address_space. Usually, this is the address of a circular list of\n * the page's disk buffers. PG_private must be set to tell the VM to call\n * into the filesystem to release these pages.\n *\n * A page may belong to an inode's memory mapping. In this case, page->mapping\n * is the pointer to the inode, and page->index is the file offset of the page,\n * in units of PAGE_CACHE_SIZE.\n *\n * If pagecache pages are not associated with an inode, they are said to be\n * anonymous pages. These may become associated with the swapcache, and in that\n * case PG_swapcache is set, and page->private is an offset into the swapcache.\n *\n * In either case (swapcache or inode backed), the pagecache itself holds one\n * reference to the page. Setting PG_private should also increment the\n * refcount. The each user mapping also has a reference to the page.\n *\n * The pagecache pages are stored in a per-mapping radix tree, which is\n * rooted at mapping->page_tree, and indexed by offset.\n * Where 2.4 and early 2.6 kernels kept dirty/clean pages in per-address_space\n * lists, we instead now tag pages as dirty/writeback in the radix tree.\n *\n * All pagecache pages may be subject to I/O:\n * - inode pages may need to be read from disk,\n * - inode pages which have been modified and are MAP_SHARED may need\n *   to be written back to the inode on disk,\n * - anonymous pages (including MAP_PRIVATE file mappings) which have been\n *   modified may need to be swapped out to swap space and (later) to be read\n *   back into memory.\n */\n\n/*\n * The zone field is never updated after free_area_init_core()\n * sets it, so none of the operations on it need to be atomic.\n */\n\n/* Page flags: | [SECTION] | [NODE] | ZONE | [LAST_NID] | ... | FLAGS | */\n#define SECTIONS_PGOFF\t\t((sizeof(unsigned long)*8) - SECTIONS_WIDTH)\n#define NODES_PGOFF\t\t(SECTIONS_PGOFF - NODES_WIDTH)\n#define ZONES_PGOFF\t\t(NODES_PGOFF - ZONES_WIDTH)\n#define LAST_NID_PGOFF\t\t(ZONES_PGOFF - LAST_NID_WIDTH)\n\n/*\n * Define the bit shifts to access each section.  For non-existent\n * sections we define the shift as 0; that plus a 0 mask ensures\n * the compiler will optimise away reference to them.\n */\n#define SECTIONS_PGSHIFT\t(SECTIONS_PGOFF * (SECTIONS_WIDTH != 0))\n#define NODES_PGSHIFT\t\t(NODES_PGOFF * (NODES_WIDTH != 0))\n#define ZONES_PGSHIFT\t\t(ZONES_PGOFF * (ZONES_WIDTH != 0))\n#define LAST_NID_PGSHIFT\t(LAST_NID_PGOFF * (LAST_NID_WIDTH != 0))\n\n/* NODE:ZONE or SECTION:ZONE is used to ID a zone for the buddy allocator */\n#ifdef NODE_NOT_IN_PAGE_FLAGS\n#define ZONEID_SHIFT\t\t(SECTIONS_SHIFT + ZONES_SHIFT)\n#define ZONEID_PGOFF\t\t((SECTIONS_PGOFF < ZONES_PGOFF)? \\\n\t\t\t\t\t\tSECTIONS_PGOFF : ZONES_PGOFF)\n#else\n#define ZONEID_SHIFT\t\t(NODES_SHIFT + ZONES_SHIFT)\n#define ZONEID_PGOFF\t\t((NODES_PGOFF < ZONES_PGOFF)? \\\n\t\t\t\t\t\tNODES_PGOFF : ZONES_PGOFF)\n#endif\n\n#define ZONEID_PGSHIFT\t\t(ZONEID_PGOFF * (ZONEID_SHIFT != 0))\n\n#if SECTIONS_WIDTH+NODES_WIDTH+ZONES_WIDTH > BITS_PER_LONG - NR_PAGEFLAGS\n#error SECTIONS_WIDTH+NODES_WIDTH+ZONES_WIDTH > BITS_PER_LONG - NR_PAGEFLAGS\n#endif\n\n#define ZONES_MASK\t\t((1UL << ZONES_WIDTH) - 1)\n#define NODES_MASK\t\t((1UL << NODES_WIDTH) - 1)\n#define SECTIONS_MASK\t\t((1UL << SECTIONS_WIDTH) - 1)\n#define LAST_NID_MASK\t\t((1UL << LAST_NID_WIDTH) - 1)\n#define ZONEID_MASK\t\t((1UL << ZONEID_SHIFT) - 1)\n\nstatic inline enum zone_type page_zonenum(const struct page *page)\n{\n\treturn (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;\n}\n\n#if defined(CONFIG_SPARSEMEM) && !defined(CONFIG_SPARSEMEM_VMEMMAP)\n#define SECTION_IN_PAGE_FLAGS\n#endif\n\n/*\n * The identification function is only used by the buddy allocator for\n * determining if two pages could be buddies. We are not really\n * identifying a zone since we could be using a the section number\n * id if we have not node id available in page flags.\n * We guarantee only that it will return the same value for two\n * combinable pages in a zone.\n */\nstatic inline int page_zone_id(struct page *page)\n{\n\treturn (page->flags >> ZONEID_PGSHIFT) & ZONEID_MASK;\n}\n\nstatic inline int zone_to_nid(struct zone *zone)\n{\n#ifdef CONFIG_NUMA\n\treturn zone->node;\n#else\n\treturn 0;\n#endif\n}\n\n#ifdef NODE_NOT_IN_PAGE_FLAGS\nextern int page_to_nid(const struct page *page);\n#else\nstatic inline int page_to_nid(const struct page *page)\n{\n\treturn (page->flags >> NODES_PGSHIFT) & NODES_MASK;\n}\n#endif\n\n#ifdef CONFIG_NUMA_BALANCING\n#ifdef LAST_NID_NOT_IN_PAGE_FLAGS\nstatic inline int page_nid_xchg_last(struct page *page, int nid)\n{\n\treturn xchg(&page->_last_nid, nid);\n}\n\nstatic inline int page_nid_last(struct page *page)\n{\n\treturn page->_last_nid;\n}\nstatic inline void page_nid_reset_last(struct page *page)\n{\n\tpage->_last_nid = -1;\n}\n#else\nstatic inline int page_nid_last(struct page *page)\n{\n\treturn (page->flags >> LAST_NID_PGSHIFT) & LAST_NID_MASK;\n}\n\nextern int page_nid_xchg_last(struct page *page, int nid);\n\nstatic inline void page_nid_reset_last(struct page *page)\n{\n\tint nid = (1 << LAST_NID_SHIFT) - 1;\n\n\tpage->flags &= ~(LAST_NID_MASK << LAST_NID_PGSHIFT);\n\tpage->flags |= (nid & LAST_NID_MASK) << LAST_NID_PGSHIFT;\n}\n#endif /* LAST_NID_NOT_IN_PAGE_FLAGS */\n#else\nstatic inline int page_nid_xchg_last(struct page *page, int nid)\n{\n\treturn page_to_nid(page);\n}\n\nstatic inline int page_nid_last(struct page *page)\n{\n\treturn page_to_nid(page);\n}\n\nstatic inline void page_nid_reset_last(struct page *page)\n{\n}\n#endif\n\nstatic inline struct zone *page_zone(const struct page *page)\n{\n\treturn &NODE_DATA(page_to_nid(page))->node_zones[page_zonenum(page)];\n}\n\n#ifdef SECTION_IN_PAGE_FLAGS\nstatic inline void set_page_section(struct page *page, unsigned long section)\n{\n\tpage->flags &= ~(SECTIONS_MASK << SECTIONS_PGSHIFT);\n\tpage->flags |= (section & SECTIONS_MASK) << SECTIONS_PGSHIFT;\n}\n\nstatic inline unsigned long page_to_section(const struct page *page)\n{\n\treturn (page->flags >> SECTIONS_PGSHIFT) & SECTIONS_MASK;\n}\n#endif\n\nstatic inline void set_page_zone(struct page *page, enum zone_type zone)\n{\n\tpage->flags &= ~(ZONES_MASK << ZONES_PGSHIFT);\n\tpage->flags |= (zone & ZONES_MASK) << ZONES_PGSHIFT;\n}\n\nstatic inline void set_page_node(struct page *page, unsigned long node)\n{\n\tpage->flags &= ~(NODES_MASK << NODES_PGSHIFT);\n\tpage->flags |= (node & NODES_MASK) << NODES_PGSHIFT;\n}\n\nstatic inline void set_page_links(struct page *page, enum zone_type zone,\n\tunsigned long node, unsigned long pfn)\n{\n\tset_page_zone(page, zone);\n\tset_page_node(page, node);\n#ifdef SECTION_IN_PAGE_FLAGS\n\tset_page_section(page, pfn_to_section_nr(pfn));\n#endif\n}\n\n/*\n * Some inline functions in vmstat.h depend on page_zone()\n */\n#include <linux/vmstat.h>\n\nstatic __always_inline void *lowmem_page_address(const struct page *page)\n{\n\treturn __va(PFN_PHYS(page_to_pfn(page)));\n}\n\n#if defined(CONFIG_HIGHMEM) && !defined(WANT_PAGE_VIRTUAL)\n#define HASHED_PAGE_VIRTUAL\n#endif\n\n#if defined(WANT_PAGE_VIRTUAL)\n#define page_address(page) ((page)->virtual)\n#define set_page_address(page, address)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t(page)->virtual = (address);\t\t\\\n\t} while(0)\n#define page_address_init()  do { } while(0)\n#endif\n\n#if defined(HASHED_PAGE_VIRTUAL)\nvoid *page_address(const struct page *page);\nvoid set_page_address(struct page *page, void *virtual);\nvoid page_address_init(void);\n#endif\n\n#if !defined(HASHED_PAGE_VIRTUAL) && !defined(WANT_PAGE_VIRTUAL)\n#define page_address(page) lowmem_page_address(page)\n#define set_page_address(page, address)  do { } while(0)\n#define page_address_init()  do { } while(0)\n#endif\n\n/*\n * On an anonymous page mapped into a user virtual memory area,\n * page->mapping points to its anon_vma, not to a struct address_space;\n * with the PAGE_MAPPING_ANON bit set to distinguish it.  See rmap.h.\n *\n * On an anonymous page in a VM_MERGEABLE area, if CONFIG_KSM is enabled,\n * the PAGE_MAPPING_KSM bit may be set along with the PAGE_MAPPING_ANON bit;\n * and then page->mapping points, not to an anon_vma, but to a private\n * structure which KSM associates with that merged page.  See ksm.h.\n *\n * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is currently never used.\n *\n * Please note that, confusingly, \"page_mapping\" refers to the inode\n * address_space which maps the page from disk; whereas \"page_mapped\"\n * refers to user virtual address space into which the page is mapped.\n */\n#define PAGE_MAPPING_ANON\t1\n#define PAGE_MAPPING_KSM\t2\n#define PAGE_MAPPING_FLAGS\t(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)\n\nextern struct address_space *page_mapping(struct page *page);\n\n/* Neutral page->mapping pointer to address_space or anon_vma or other */\nstatic inline void *page_rmapping(struct page *page)\n{\n\treturn (void *)((unsigned long)page->mapping & ~PAGE_MAPPING_FLAGS);\n}\n\nextern struct address_space *__page_file_mapping(struct page *);\n\nstatic inline\nstruct address_space *page_file_mapping(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn __page_file_mapping(page);\n\n\treturn page->mapping;\n}\n\nstatic inline int PageAnon(struct page *page)\n{\n\treturn ((unsigned long)page->mapping & PAGE_MAPPING_ANON) != 0;\n}\n\n/*\n * Return the pagecache index of the passed page.  Regular pagecache pages\n * use ->index whereas swapcache pages use ->private\n */\nstatic inline pgoff_t page_index(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn page_private(page);\n\treturn page->index;\n}\n\nextern pgoff_t __page_file_index(struct page *page);\n\n/*\n * Return the file index of the page. Regular pagecache pages use ->index\n * whereas swapcache pages use swp_offset(->private)\n */\nstatic inline pgoff_t page_file_index(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn __page_file_index(page);\n\n\treturn page->index;\n}\n\n/*\n * Return true if this page is mapped into pagetables.\n */\nstatic inline int page_mapped(struct page *page)\n{\n\treturn atomic_read(&(page)->_mapcount) >= 0;\n}\n\n/*\n * Different kinds of faults, as returned by handle_mm_fault().\n * Used to decide whether a process gets delivered SIGBUS or\n * just gets major/minor fault counters bumped up.\n */\n\n#define VM_FAULT_MINOR\t0 /* For backwards compat. Remove me quickly. */\n\n#define VM_FAULT_OOM\t0x0001\n#define VM_FAULT_SIGBUS\t0x0002\n#define VM_FAULT_MAJOR\t0x0004\n#define VM_FAULT_WRITE\t0x0008\t/* Special case for get_user_pages */\n#define VM_FAULT_HWPOISON 0x0010\t/* Hit poisoned small page */\n#define VM_FAULT_HWPOISON_LARGE 0x0020  /* Hit poisoned large page. Index encoded in upper bits */\n\n#define VM_FAULT_NOPAGE\t0x0100\t/* ->fault installed the pte, not return page */\n#define VM_FAULT_LOCKED\t0x0200\t/* ->fault locked the returned page */\n#define VM_FAULT_RETRY\t0x0400\t/* ->fault blocked, must retry */\n\n#define VM_FAULT_HWPOISON_LARGE_MASK 0xf000 /* encodes hpage index for large hwpoison */\n\n#define VM_FAULT_ERROR\t(VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_HWPOISON | \\\n\t\t\t VM_FAULT_HWPOISON_LARGE)\n\n/* Encode hstate index for a hwpoisoned large page */\n#define VM_FAULT_SET_HINDEX(x) ((x) << 12)\n#define VM_FAULT_GET_HINDEX(x) (((x) >> 12) & 0xf)\n\n/*\n * Can be called by the pagefault handler when it gets a VM_FAULT_OOM.\n */\nextern void pagefault_out_of_memory(void);\n\n#define offset_in_page(p)\t((unsigned long)(p) & ~PAGE_MASK)\n\n/*\n * Flags passed to show_mem() and show_free_areas() to suppress output in\n * various contexts.\n */\n#define SHOW_MEM_FILTER_NODES\t(0x0001u)\t/* filter disallowed nodes */\n\nextern void show_free_areas(unsigned int flags);\nextern bool skip_free_areas_node(unsigned int flags, int nid);\n\nint shmem_zero_setup(struct vm_area_struct *);\n\nextern int can_do_mlock(void);\nextern int user_shm_lock(size_t, struct user_struct *);\nextern void user_shm_unlock(size_t, struct user_struct *);\n\n/*\n * Parameter block passed down to zap_pte_range in exceptional cases.\n */\nstruct zap_details {\n\tstruct vm_area_struct *nonlinear_vma;\t/* Check page->index if set */\n\tstruct address_space *check_mapping;\t/* Check page->mapping if set */\n\tpgoff_t\tfirst_index;\t\t\t/* Lowest page->index to unmap */\n\tpgoff_t last_index;\t\t\t/* Highest page->index to unmap */\n};\n\nstruct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\tpte_t pte);\n\nint zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size);\nvoid zap_page_range(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *);\nvoid unmap_vmas(struct mmu_gather *tlb, struct vm_area_struct *start_vma,\n\t\tunsigned long start, unsigned long end);\n\n/**\n * mm_walk - callbacks for walk_page_range\n * @pgd_entry: if set, called for each non-empty PGD (top-level) entry\n * @pud_entry: if set, called for each non-empty PUD (2nd-level) entry\n * @pmd_entry: if set, called for each non-empty PMD (3rd-level) entry\n *\t       this handler is required to be able to handle\n *\t       pmd_trans_huge() pmds.  They may simply choose to\n *\t       split_huge_page() instead of handling it explicitly.\n * @pte_entry: if set, called for each non-empty PTE (4th-level) entry\n * @pte_hole: if set, called for each hole at all levels\n * @hugetlb_entry: if set, called for each hugetlb entry\n *\t\t   *Caution*: The caller must hold mmap_sem() if @hugetlb_entry\n * \t\t\t      is used.\n *\n * (see walk_page_range for more details)\n */\nstruct mm_walk {\n\tint (*pgd_entry)(pgd_t *, unsigned long, unsigned long, struct mm_walk *);\n\tint (*pud_entry)(pud_t *, unsigned long, unsigned long, struct mm_walk *);\n\tint (*pmd_entry)(pmd_t *, unsigned long, unsigned long, struct mm_walk *);\n\tint (*pte_entry)(pte_t *, unsigned long, unsigned long, struct mm_walk *);\n\tint (*pte_hole)(unsigned long, unsigned long, struct mm_walk *);\n\tint (*hugetlb_entry)(pte_t *, unsigned long,\n\t\t\t     unsigned long, unsigned long, struct mm_walk *);\n\tstruct mm_struct *mm;\n\tvoid *private;\n};\n\nint walk_page_range(unsigned long addr, unsigned long end,\n\t\tstruct mm_walk *walk);\nvoid free_pgd_range(struct mmu_gather *tlb, unsigned long addr,\n\t\tunsigned long end, unsigned long floor, unsigned long ceiling);\nint copy_page_range(struct mm_struct *dst, struct mm_struct *src,\n\t\t\tstruct vm_area_struct *vma);\nvoid unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows);\nint follow_pfn(struct vm_area_struct *vma, unsigned long address,\n\tunsigned long *pfn);\nint follow_phys(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags, unsigned long *prot, resource_size_t *phys);\nint generic_access_phys(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tvoid *buf, int len, int write);\n\nstatic inline void unmap_shared_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen)\n{\n\tunmap_mapping_range(mapping, holebegin, holelen, 0);\n}\n\nextern void truncate_pagecache(struct inode *inode, loff_t old, loff_t new);\nextern void truncate_setsize(struct inode *inode, loff_t newsize);\nvoid truncate_pagecache_range(struct inode *inode, loff_t offset, loff_t end);\nint truncate_inode_page(struct address_space *mapping, struct page *page);\nint generic_error_remove_page(struct address_space *mapping, struct page *page);\nint invalidate_inode_page(struct page *page);\n\n#ifdef CONFIG_MMU\nextern int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags);\nextern int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,\n\t\t\t    unsigned long address, unsigned int fault_flags);\n#else\nstatic inline int handle_mm_fault(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *vma, unsigned long address,\n\t\t\tunsigned int flags)\n{\n\t/* should never happen if there's no MMU */\n\tBUG();\n\treturn VM_FAULT_SIGBUS;\n}\nstatic inline int fixup_user_fault(struct task_struct *tsk,\n\t\tstruct mm_struct *mm, unsigned long address,\n\t\tunsigned int fault_flags)\n{\n\t/* should never happen if there's no MMU */\n\tBUG();\n\treturn -EFAULT;\n}\n#endif\n\nextern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);\nextern int access_remote_vm(struct mm_struct *mm, unsigned long addr,\n\t\tvoid *buf, int len, int write);\n\nlong __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\t      unsigned long start, unsigned long nr_pages,\n\t\t      unsigned int foll_flags, struct page **pages,\n\t\t      struct vm_area_struct **vmas, int *nonblocking);\nlong get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\t    unsigned long start, unsigned long nr_pages,\n\t\t    int write, int force, struct page **pages,\n\t\t    struct vm_area_struct **vmas);\nint get_user_pages_fast(unsigned long start, int nr_pages, int write,\n\t\t\tstruct page **pages);\nstruct kvec;\nint get_kernel_pages(const struct kvec *iov, int nr_pages, int write,\n\t\t\tstruct page **pages);\nint get_kernel_page(unsigned long start, int write, struct page **pages);\nstruct page *get_dump_page(unsigned long addr);\n\nextern int try_to_release_page(struct page * page, gfp_t gfp_mask);\nextern void do_invalidatepage(struct page *page, unsigned long offset);\n\nint __set_page_dirty_nobuffers(struct page *page);\nint __set_page_dirty_no_writeback(struct page *page);\nint redirty_page_for_writepage(struct writeback_control *wbc,\n\t\t\t\tstruct page *page);\nvoid account_page_dirtied(struct page *page, struct address_space *mapping);\nvoid account_page_writeback(struct page *page);\nint set_page_dirty(struct page *page);\nint set_page_dirty_lock(struct page *page);\nint clear_page_dirty_for_io(struct page *page);\n\n/* Is the vma a continuation of the stack vma above it? */\nstatic inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)\n{\n\treturn vma && (vma->vm_end == addr) && (vma->vm_flags & VM_GROWSDOWN);\n}\n\nstatic inline int stack_guard_page_start(struct vm_area_struct *vma,\n\t\t\t\t\t     unsigned long addr)\n{\n\treturn (vma->vm_flags & VM_GROWSDOWN) &&\n\t\t(vma->vm_start == addr) &&\n\t\t!vma_growsdown(vma->vm_prev, addr);\n}\n\n/* Is the vma a continuation of the stack vma below it? */\nstatic inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)\n{\n\treturn vma && (vma->vm_start == addr) && (vma->vm_flags & VM_GROWSUP);\n}\n\nstatic inline int stack_guard_page_end(struct vm_area_struct *vma,\n\t\t\t\t\t   unsigned long addr)\n{\n\treturn (vma->vm_flags & VM_GROWSUP) &&\n\t\t(vma->vm_end == addr) &&\n\t\t!vma_growsup(vma->vm_next, addr);\n}\n\nextern pid_t\nvm_is_stack(struct task_struct *task, struct vm_area_struct *vma, int in_group);\n\nextern unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks);\nextern unsigned long do_mremap(unsigned long addr,\n\t\t\t       unsigned long old_len, unsigned long new_len,\n\t\t\t       unsigned long flags, unsigned long new_addr);\nextern unsigned long change_protection(struct vm_area_struct *vma, unsigned long start,\n\t\t\t      unsigned long end, pgprot_t newprot,\n\t\t\t      int dirty_accountable, int prot_numa);\nextern int mprotect_fixup(struct vm_area_struct *vma,\n\t\t\t  struct vm_area_struct **pprev, unsigned long start,\n\t\t\t  unsigned long end, unsigned long newflags);\n\n/*\n * doesn't attempt to fault and will return short.\n */\nint __get_user_pages_fast(unsigned long start, int nr_pages, int write,\n\t\t\t  struct page **pages);\n/*\n * per-process(per-mm_struct) statistics.\n */\nstatic inline unsigned long get_mm_counter(struct mm_struct *mm, int member)\n{\n\tlong val = atomic_long_read(&mm->rss_stat.count[member]);\n\n#ifdef SPLIT_RSS_COUNTING\n\t/*\n\t * counter is updated in asynchronous manner and may go to minus.\n\t * But it's never be expected number for users.\n\t */\n\tif (val < 0)\n\t\tval = 0;\n#endif\n\treturn (unsigned long)val;\n}\n\nstatic inline void add_mm_counter(struct mm_struct *mm, int member, long value)\n{\n\tatomic_long_add(value, &mm->rss_stat.count[member]);\n}\n\nstatic inline void inc_mm_counter(struct mm_struct *mm, int member)\n{\n\tatomic_long_inc(&mm->rss_stat.count[member]);\n}\n\nstatic inline void dec_mm_counter(struct mm_struct *mm, int member)\n{\n\tatomic_long_dec(&mm->rss_stat.count[member]);\n}\n\nstatic inline unsigned long get_mm_rss(struct mm_struct *mm)\n{\n\treturn get_mm_counter(mm, MM_FILEPAGES) +\n\t\tget_mm_counter(mm, MM_ANONPAGES);\n}\n\nstatic inline unsigned long get_mm_hiwater_rss(struct mm_struct *mm)\n{\n\treturn max(mm->hiwater_rss, get_mm_rss(mm));\n}\n\nstatic inline unsigned long get_mm_hiwater_vm(struct mm_struct *mm)\n{\n\treturn max(mm->hiwater_vm, mm->total_vm);\n}\n\nstatic inline void update_hiwater_rss(struct mm_struct *mm)\n{\n\tunsigned long _rss = get_mm_rss(mm);\n\n\tif ((mm)->hiwater_rss < _rss)\n\t\t(mm)->hiwater_rss = _rss;\n}\n\nstatic inline void update_hiwater_vm(struct mm_struct *mm)\n{\n\tif (mm->hiwater_vm < mm->total_vm)\n\t\tmm->hiwater_vm = mm->total_vm;\n}\n\nstatic inline void setmax_mm_hiwater_rss(unsigned long *maxrss,\n\t\t\t\t\t struct mm_struct *mm)\n{\n\tunsigned long hiwater_rss = get_mm_hiwater_rss(mm);\n\n\tif (*maxrss < hiwater_rss)\n\t\t*maxrss = hiwater_rss;\n}\n\n#if defined(SPLIT_RSS_COUNTING)\nvoid sync_mm_rss(struct mm_struct *mm);\n#else\nstatic inline void sync_mm_rss(struct mm_struct *mm)\n{\n}\n#endif\n\nint vma_wants_writenotify(struct vm_area_struct *vma);\n\nextern pte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\t       spinlock_t **ptl);\nstatic inline pte_t *get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\t\t    spinlock_t **ptl)\n{\n\tpte_t *ptep;\n\t__cond_lock(*ptl, ptep = __get_locked_pte(mm, addr, ptl));\n\treturn ptep;\n}\n\n#ifdef __PAGETABLE_PUD_FOLDED\nstatic inline int __pud_alloc(struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t\t\tunsigned long address)\n{\n\treturn 0;\n}\n#else\nint __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address);\n#endif\n\n#ifdef __PAGETABLE_PMD_FOLDED\nstatic inline int __pmd_alloc(struct mm_struct *mm, pud_t *pud,\n\t\t\t\t\t\tunsigned long address)\n{\n\treturn 0;\n}\n#else\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address);\n#endif\n\nint __pte_alloc(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long address);\nint __pte_alloc_kernel(pmd_t *pmd, unsigned long address);\n\n/*\n * The following ifdef needed to get the 4level-fixup.h header to work.\n * Remove it when 4level-fixup.h has been removed.\n */\n#if defined(CONFIG_MMU) && !defined(__ARCH_HAS_4LEVEL_HACK)\nstatic inline pud_t *pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\treturn (unlikely(pgd_none(*pgd)) && __pud_alloc(mm, pgd, address))?\n\t\tNULL: pud_offset(pgd, address);\n}\n\nstatic inline pmd_t *pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\treturn (unlikely(pud_none(*pud)) && __pmd_alloc(mm, pud, address))?\n\t\tNULL: pmd_offset(pud, address);\n}\n#endif /* CONFIG_MMU && !__ARCH_HAS_4LEVEL_HACK */\n\n#if USE_SPLIT_PTLOCKS\n/*\n * We tuck a spinlock to guard each pagetable page into its struct page,\n * at page->private, with BUILD_BUG_ON to make sure that this will not\n * overflow into the next struct page (as it might with DEBUG_SPINLOCK).\n * When freeing, reset page->mapping so free_pages_check won't complain.\n */\n#define __pte_lockptr(page)\t&((page)->ptl)\n#define pte_lock_init(_page)\tdo {\t\t\t\t\t\\\n\tspin_lock_init(__pte_lockptr(_page));\t\t\t\t\\\n} while (0)\n#define pte_lock_deinit(page)\t((page)->mapping = NULL)\n#define pte_lockptr(mm, pmd)\t({(void)(mm); __pte_lockptr(pmd_page(*(pmd)));})\n#else\t/* !USE_SPLIT_PTLOCKS */\n/*\n * We use mm->page_table_lock to guard all pagetable pages of the mm.\n */\n#define pte_lock_init(page)\tdo {} while (0)\n#define pte_lock_deinit(page)\tdo {} while (0)\n#define pte_lockptr(mm, pmd)\t({(void)(pmd); &(mm)->page_table_lock;})\n#endif /* USE_SPLIT_PTLOCKS */\n\nstatic inline void pgtable_page_ctor(struct page *page)\n{\n\tpte_lock_init(page);\n\tinc_zone_page_state(page, NR_PAGETABLE);\n}\n\nstatic inline void pgtable_page_dtor(struct page *page)\n{\n\tpte_lock_deinit(page);\n\tdec_zone_page_state(page, NR_PAGETABLE);\n}\n\n#define pte_offset_map_lock(mm, pmd, address, ptlp)\t\\\n({\t\t\t\t\t\t\t\\\n\tspinlock_t *__ptl = pte_lockptr(mm, pmd);\t\\\n\tpte_t *__pte = pte_offset_map(pmd, address);\t\\\n\t*(ptlp) = __ptl;\t\t\t\t\\\n\tspin_lock(__ptl);\t\t\t\t\\\n\t__pte;\t\t\t\t\t\t\\\n})\n\n#define pte_unmap_unlock(pte, ptl)\tdo {\t\t\\\n\tspin_unlock(ptl);\t\t\t\t\\\n\tpte_unmap(pte);\t\t\t\t\t\\\n} while (0)\n\n#define pte_alloc_map(mm, vma, pmd, address)\t\t\t\t\\\n\t((unlikely(pmd_none(*(pmd))) && __pte_alloc(mm, vma,\t\\\n\t\t\t\t\t\t\tpmd, address))?\t\\\n\t NULL: pte_offset_map(pmd, address))\n\n#define pte_alloc_map_lock(mm, pmd, address, ptlp)\t\\\n\t((unlikely(pmd_none(*(pmd))) && __pte_alloc(mm, NULL,\t\\\n\t\t\t\t\t\t\tpmd, address))?\t\\\n\t\tNULL: pte_offset_map_lock(mm, pmd, address, ptlp))\n\n#define pte_alloc_kernel(pmd, address)\t\t\t\\\n\t((unlikely(pmd_none(*(pmd))) && __pte_alloc_kernel(pmd, address))? \\\n\t\tNULL: pte_offset_kernel(pmd, address))\n\nextern void free_area_init(unsigned long * zones_size);\nextern void free_area_init_node(int nid, unsigned long * zones_size,\n\t\tunsigned long zone_start_pfn, unsigned long *zholes_size);\nextern void free_initmem(void);\n\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n/*\n * With CONFIG_HAVE_MEMBLOCK_NODE_MAP set, an architecture may initialise its\n * zones, allocate the backing mem_map and account for memory holes in a more\n * architecture independent manner. This is a substitute for creating the\n * zone_sizes[] and zholes_size[] arrays and passing them to\n * free_area_init_node()\n *\n * An architecture is expected to register range of page frames backed by\n * physical memory with memblock_add[_node]() before calling\n * free_area_init_nodes() passing in the PFN each zone ends at. At a basic\n * usage, an architecture is expected to do something like\n *\n * unsigned long max_zone_pfns[MAX_NR_ZONES] = {max_dma, max_normal_pfn,\n * \t\t\t\t\t\t\t max_highmem_pfn};\n * for_each_valid_physical_page_range()\n * \tmemblock_add_node(base, size, nid)\n * free_area_init_nodes(max_zone_pfns);\n *\n * free_bootmem_with_active_regions() calls free_bootmem_node() for each\n * registered physical page range.  Similarly\n * sparse_memory_present_with_active_regions() calls memory_present() for\n * each range when SPARSEMEM is enabled.\n *\n * See mm/page_alloc.c for more information on each function exposed by\n * CONFIG_HAVE_MEMBLOCK_NODE_MAP.\n */\nextern void free_area_init_nodes(unsigned long *max_zone_pfn);\nunsigned long node_map_pfn_alignment(void);\nunsigned long __absent_pages_in_range(int nid, unsigned long start_pfn,\n\t\t\t\t\t\tunsigned long end_pfn);\nextern unsigned long absent_pages_in_range(unsigned long start_pfn,\n\t\t\t\t\t\tunsigned long end_pfn);\nextern void get_pfn_range_for_nid(unsigned int nid,\n\t\t\tunsigned long *start_pfn, unsigned long *end_pfn);\nextern unsigned long find_min_pfn_with_active_regions(void);\nextern void free_bootmem_with_active_regions(int nid,\n\t\t\t\t\t\tunsigned long max_low_pfn);\nextern void sparse_memory_present_with_active_regions(int nid);\n\n#endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\n\n#if !defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) && \\\n    !defined(CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID)\nstatic inline int __early_pfn_to_nid(unsigned long pfn)\n{\n\treturn 0;\n}\n#else\n/* please see mm/page_alloc.c */\nextern int __meminit early_pfn_to_nid(unsigned long pfn);\n#ifdef CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID\n/* there is a per-arch backend function. */\nextern int __meminit __early_pfn_to_nid(unsigned long pfn);\n#endif /* CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID */\n#endif\n\nextern void set_dma_reserve(unsigned long new_dma_reserve);\nextern void memmap_init_zone(unsigned long, int, unsigned long,\n\t\t\t\tunsigned long, enum memmap_context);\nextern void setup_per_zone_wmarks(void);\nextern int __meminit init_per_zone_wmark_min(void);\nextern void mem_init(void);\nextern void __init mmap_init(void);\nextern void show_mem(unsigned int flags);\nextern void si_meminfo(struct sysinfo * val);\nextern void si_meminfo_node(struct sysinfo *val, int nid);\n\nextern __printf(3, 4)\nvoid warn_alloc_failed(gfp_t gfp_mask, int order, const char *fmt, ...);\n\nextern void setup_per_cpu_pageset(void);\n\nextern void zone_pcp_update(struct zone *zone);\nextern void zone_pcp_reset(struct zone *zone);\n\n/* page_alloc.c */\nextern int min_free_kbytes;\n\n/* nommu.c */\nextern atomic_long_t mmap_pages_allocated;\nextern int nommu_shrink_inode_mappings(struct inode *, size_t, size_t);\n\n/* interval_tree.c */\nvoid vma_interval_tree_insert(struct vm_area_struct *node,\n\t\t\t      struct rb_root *root);\nvoid vma_interval_tree_insert_after(struct vm_area_struct *node,\n\t\t\t\t    struct vm_area_struct *prev,\n\t\t\t\t    struct rb_root *root);\nvoid vma_interval_tree_remove(struct vm_area_struct *node,\n\t\t\t      struct rb_root *root);\nstruct vm_area_struct *vma_interval_tree_iter_first(struct rb_root *root,\n\t\t\t\tunsigned long start, unsigned long last);\nstruct vm_area_struct *vma_interval_tree_iter_next(struct vm_area_struct *node,\n\t\t\t\tunsigned long start, unsigned long last);\n\n#define vma_interval_tree_foreach(vma, root, start, last)\t\t\\\n\tfor (vma = vma_interval_tree_iter_first(root, start, last);\t\\\n\t     vma; vma = vma_interval_tree_iter_next(vma, start, last))\n\nstatic inline void vma_nonlinear_insert(struct vm_area_struct *vma,\n\t\t\t\t\tstruct list_head *list)\n{\n\tlist_add_tail(&vma->shared.nonlinear, list);\n}\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root *root);\nvoid anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root *root);\nstruct anon_vma_chain *anon_vma_interval_tree_iter_first(\n\tstruct rb_root *root, unsigned long start, unsigned long last);\nstruct anon_vma_chain *anon_vma_interval_tree_iter_next(\n\tstruct anon_vma_chain *node, unsigned long start, unsigned long last);\n#ifdef CONFIG_DEBUG_VM_RB\nvoid anon_vma_interval_tree_verify(struct anon_vma_chain *node);\n#endif\n\n#define anon_vma_interval_tree_foreach(avc, root, start, last)\t\t \\\n\tfor (avc = anon_vma_interval_tree_iter_first(root, start, last); \\\n\t     avc; avc = anon_vma_interval_tree_iter_next(avc, start, last))\n\n/* mmap.c */\nextern int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin);\nextern int vma_adjust(struct vm_area_struct *vma, unsigned long start,\n\tunsigned long end, pgoff_t pgoff, struct vm_area_struct *insert);\nextern struct vm_area_struct *vma_merge(struct mm_struct *,\n\tstruct vm_area_struct *prev, unsigned long addr, unsigned long end,\n\tunsigned long vm_flags, struct anon_vma *, struct file *, pgoff_t,\n\tstruct mempolicy *);\nextern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *);\nextern int split_vma(struct mm_struct *,\n\tstruct vm_area_struct *, unsigned long addr, int new_below);\nextern int insert_vm_struct(struct mm_struct *, struct vm_area_struct *);\nextern void __vma_link_rb(struct mm_struct *, struct vm_area_struct *,\n\tstruct rb_node **, struct rb_node *);\nextern void unlink_file_vma(struct vm_area_struct *);\nextern struct vm_area_struct *copy_vma(struct vm_area_struct **,\n\tunsigned long addr, unsigned long len, pgoff_t pgoff,\n\tbool *need_rmap_locks);\nextern void exit_mmap(struct mm_struct *);\n\nextern int mm_take_all_locks(struct mm_struct *mm);\nextern void mm_drop_all_locks(struct mm_struct *mm);\n\nextern void set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file);\nextern struct file *get_mm_exe_file(struct mm_struct *mm);\n\nextern int may_expand_vm(struct mm_struct *mm, unsigned long npages);\nextern int install_special_mapping(struct mm_struct *mm,\n\t\t\t\t   unsigned long addr, unsigned long len,\n\t\t\t\t   unsigned long flags, struct page **pages);\n\nextern unsigned long get_unmapped_area(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\nextern unsigned long mmap_region(struct file *file, unsigned long addr,\n\tunsigned long len, vm_flags_t vm_flags, unsigned long pgoff);\nextern unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot, unsigned long flags,\n\tunsigned long pgoff, unsigned long *populate);\nextern int do_munmap(struct mm_struct *, unsigned long, size_t);\n\n#ifdef CONFIG_MMU\nextern int __mm_populate(unsigned long addr, unsigned long len,\n\t\t\t int ignore_errors);\nstatic inline void mm_populate(unsigned long addr, unsigned long len)\n{\n\t/* Ignore errors */\n\t(void) __mm_populate(addr, len, 1);\n}\n#else\nstatic inline void mm_populate(unsigned long addr, unsigned long len) {}\n#endif\n\n/* These take the mm semaphore themselves */\nextern unsigned long vm_brk(unsigned long, unsigned long);\nextern int vm_munmap(unsigned long, size_t);\nextern unsigned long vm_mmap(struct file *, unsigned long,\n        unsigned long, unsigned long,\n        unsigned long, unsigned long);\n\nstruct vm_unmapped_area_info {\n#define VM_UNMAPPED_AREA_TOPDOWN 1\n\tunsigned long flags;\n\tunsigned long length;\n\tunsigned long low_limit;\n\tunsigned long high_limit;\n\tunsigned long align_mask;\n\tunsigned long align_offset;\n};\n\nextern unsigned long unmapped_area(struct vm_unmapped_area_info *info);\nextern unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info);\n\n/*\n * Search for an unmapped address range.\n *\n * We are looking for a range that:\n * - does not intersect with any VMA;\n * - is contained within the [low_limit, high_limit) interval;\n * - is at least the desired size.\n * - satisfies (begin_addr & align_mask) == (align_offset & align_mask)\n */\nstatic inline unsigned long\nvm_unmapped_area(struct vm_unmapped_area_info *info)\n{\n\tif (!(info->flags & VM_UNMAPPED_AREA_TOPDOWN))\n\t\treturn unmapped_area(info);\n\telse\n\t\treturn unmapped_area_topdown(info);\n}\n\n/* truncate.c */\nextern void truncate_inode_pages(struct address_space *, loff_t);\nextern void truncate_inode_pages_range(struct address_space *,\n\t\t\t\t       loff_t lstart, loff_t lend);\n\n/* generic vm_area_ops exported for stackable file systems */\nextern int filemap_fault(struct vm_area_struct *, struct vm_fault *);\nextern int filemap_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);\n\n/* mm/page-writeback.c */\nint write_one_page(struct page *page, int wait);\nvoid task_dirty_inc(struct task_struct *tsk);\n\n/* readahead.c */\n#define VM_MAX_READAHEAD\t128\t/* kbytes */\n#define VM_MIN_READAHEAD\t16\t/* kbytes (includes current page) */\n\nint force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\tpgoff_t offset, unsigned long nr_to_read);\n\nvoid page_cache_sync_readahead(struct address_space *mapping,\n\t\t\t       struct file_ra_state *ra,\n\t\t\t       struct file *filp,\n\t\t\t       pgoff_t offset,\n\t\t\t       unsigned long size);\n\nvoid page_cache_async_readahead(struct address_space *mapping,\n\t\t\t\tstruct file_ra_state *ra,\n\t\t\t\tstruct file *filp,\n\t\t\t\tstruct page *pg,\n\t\t\t\tpgoff_t offset,\n\t\t\t\tunsigned long size);\n\nunsigned long max_sane_readahead(unsigned long nr);\nunsigned long ra_submit(struct file_ra_state *ra,\n\t\t\tstruct address_space *mapping,\n\t\t\tstruct file *filp);\n\n/* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */\nextern int expand_stack(struct vm_area_struct *vma, unsigned long address);\n\n/* CONFIG_STACK_GROWSUP still needs to to grow downwards at some places */\nextern int expand_downwards(struct vm_area_struct *vma,\n\t\tunsigned long address);\n#if VM_GROWSUP\nextern int expand_upwards(struct vm_area_struct *vma, unsigned long address);\n#else\n  #define expand_upwards(vma, address) do { } while (0)\n#endif\n\n/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */\nextern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);\nextern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,\n\t\t\t\t\t     struct vm_area_struct **pprev);\n\n/* Look up the first VMA which intersects the interval start_addr..end_addr-1,\n   NULL if none.  Assume start_addr < end_addr. */\nstatic inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)\n{\n\tstruct vm_area_struct * vma = find_vma(mm,start_addr);\n\n\tif (vma && end_addr <= vma->vm_start)\n\t\tvma = NULL;\n\treturn vma;\n}\n\nstatic inline unsigned long vma_pages(struct vm_area_struct *vma)\n{\n\treturn (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\n}\n\n/* Look up the first VMA which exactly match the interval vm_start ... vm_end */\nstatic inline struct vm_area_struct *find_exact_vma(struct mm_struct *mm,\n\t\t\t\tunsigned long vm_start, unsigned long vm_end)\n{\n\tstruct vm_area_struct *vma = find_vma(mm, vm_start);\n\n\tif (vma && (vma->vm_start != vm_start || vma->vm_end != vm_end))\n\t\tvma = NULL;\n\n\treturn vma;\n}\n\n#ifdef CONFIG_MMU\npgprot_t vm_get_page_prot(unsigned long vm_flags);\n#else\nstatic inline pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\treturn __pgprot(0);\n}\n#endif\n\n#ifdef CONFIG_ARCH_USES_NUMA_PROT_NONE\nunsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long start, unsigned long end);\n#endif\n\nstruct vm_area_struct *find_extend_vma(struct mm_struct *, unsigned long addr);\nint remap_pfn_range(struct vm_area_struct *, unsigned long addr,\n\t\t\tunsigned long pfn, unsigned long size, pgprot_t);\nint vm_insert_page(struct vm_area_struct *, unsigned long addr, struct page *);\nint vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn);\nint vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn);\nint vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len);\n\n\nstruct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int foll_flags,\n\t\t\t      unsigned int *page_mask);\n\nstatic inline struct page *follow_page(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int foll_flags)\n{\n\tunsigned int unused_page_mask;\n\treturn follow_page_mask(vma, address, foll_flags, &unused_page_mask);\n}\n\n#define FOLL_WRITE\t0x01\t/* check pte is writable */\n#define FOLL_TOUCH\t0x02\t/* mark page accessed */\n#define FOLL_GET\t0x04\t/* do get_page on page */\n#define FOLL_DUMP\t0x08\t/* give error on hole if it would be zero */\n#define FOLL_FORCE\t0x10\t/* get_user_pages read/write w/o permission */\n#define FOLL_NOWAIT\t0x20\t/* if a disk transfer is needed, start the IO\n\t\t\t\t * and return without waiting upon it */\n#define FOLL_MLOCK\t0x40\t/* mark page as mlocked */\n#define FOLL_SPLIT\t0x80\t/* don't return transhuge pages, split them */\n#define FOLL_HWPOISON\t0x100\t/* check page is hwpoisoned */\n#define FOLL_NUMA\t0x200\t/* force NUMA hinting page fault */\n#define FOLL_MIGRATION\t0x400\t/* wait for page to replace migration entry */\n\ntypedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,\n\t\t\tvoid *data);\nextern int apply_to_page_range(struct mm_struct *mm, unsigned long address,\n\t\t\t       unsigned long size, pte_fn_t fn, void *data);\n\n#ifdef CONFIG_PROC_FS\nvoid vm_stat_account(struct mm_struct *, unsigned long, struct file *, long);\n#else\nstatic inline void vm_stat_account(struct mm_struct *mm,\n\t\t\tunsigned long flags, struct file *file, long pages)\n{\n\tmm->total_vm += pages;\n}\n#endif /* CONFIG_PROC_FS */\n\n#ifdef CONFIG_DEBUG_PAGEALLOC\nextern void kernel_map_pages(struct page *page, int numpages, int enable);\n#ifdef CONFIG_HIBERNATION\nextern bool kernel_page_present(struct page *page);\n#endif /* CONFIG_HIBERNATION */\n#else\nstatic inline void\nkernel_map_pages(struct page *page, int numpages, int enable) {}\n#ifdef CONFIG_HIBERNATION\nstatic inline bool kernel_page_present(struct page *page) { return true; }\n#endif /* CONFIG_HIBERNATION */\n#endif\n\nextern struct vm_area_struct *get_gate_vma(struct mm_struct *mm);\n#ifdef\t__HAVE_ARCH_GATE_AREA\nint in_gate_area_no_mm(unsigned long addr);\nint in_gate_area(struct mm_struct *mm, unsigned long addr);\n#else\nint in_gate_area_no_mm(unsigned long addr);\n#define in_gate_area(mm, addr) ({(void)mm; in_gate_area_no_mm(addr);})\n#endif\t/* __HAVE_ARCH_GATE_AREA */\n\nint drop_caches_sysctl_handler(struct ctl_table *, int,\n\t\t\t\t\tvoid __user *, size_t *, loff_t *);\nunsigned long shrink_slab(struct shrink_control *shrink,\n\t\t\t  unsigned long nr_pages_scanned,\n\t\t\t  unsigned long lru_pages);\n\n#ifndef CONFIG_MMU\n#define randomize_va_space 0\n#else\nextern int randomize_va_space;\n#endif\n\nconst char * arch_vma_name(struct vm_area_struct *vma);\nvoid print_vma_addr(char *prefix, unsigned long rip);\n\nvoid sparse_mem_maps_populate_node(struct page **map_map,\n\t\t\t\t   unsigned long pnum_begin,\n\t\t\t\t   unsigned long pnum_end,\n\t\t\t\t   unsigned long map_count,\n\t\t\t\t   int nodeid);\n\nstruct page *sparse_mem_map_populate(unsigned long pnum, int nid);\npgd_t *vmemmap_pgd_populate(unsigned long addr, int node);\npud_t *vmemmap_pud_populate(pgd_t *pgd, unsigned long addr, int node);\npmd_t *vmemmap_pmd_populate(pud_t *pud, unsigned long addr, int node);\npte_t *vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node);\nvoid *vmemmap_alloc_block(unsigned long size, int node);\nvoid *vmemmap_alloc_block_buf(unsigned long size, int node);\nvoid vmemmap_verify(pte_t *, int, unsigned long, unsigned long);\nint vmemmap_populate_basepages(struct page *start_page,\n\t\t\t\t\t\tunsigned long pages, int node);\nint vmemmap_populate(struct page *start_page, unsigned long pages, int node);\nvoid vmemmap_populate_print_last(void);\n#ifdef CONFIG_MEMORY_HOTPLUG\nvoid vmemmap_free(struct page *memmap, unsigned long nr_pages);\n#endif\nvoid register_page_bootmem_memmap(unsigned long section_nr, struct page *map,\n\t\t\t\t  unsigned long size);\n\nenum mf_flags {\n\tMF_COUNT_INCREASED = 1 << 0,\n\tMF_ACTION_REQUIRED = 1 << 1,\n\tMF_MUST_KILL = 1 << 2,\n};\nextern int memory_failure(unsigned long pfn, int trapno, int flags);\nextern void memory_failure_queue(unsigned long pfn, int trapno, int flags);\nextern int unpoison_memory(unsigned long pfn);\nextern int sysctl_memory_failure_early_kill;\nextern int sysctl_memory_failure_recovery;\nextern void shake_page(struct page *p, int access);\nextern atomic_long_t num_poisoned_pages;\nextern int soft_offline_page(struct page *page, int flags);\n\nextern void dump_page(struct page *page);\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_HUGETLBFS)\nextern void clear_huge_page(struct page *page,\n\t\t\t    unsigned long addr,\n\t\t\t    unsigned int pages_per_huge_page);\nextern void copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t\tunsigned long addr, struct vm_area_struct *vma,\n\t\t\t\tunsigned int pages_per_huge_page);\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */\n\n#ifdef CONFIG_DEBUG_PAGEALLOC\nextern unsigned int _debug_guardpage_minorder;\n\nstatic inline unsigned int debug_guardpage_minorder(void)\n{\n\treturn _debug_guardpage_minorder;\n}\n\nstatic inline bool page_is_guard(struct page *page)\n{\n\treturn test_bit(PAGE_DEBUG_FLAG_GUARD, &page->debug_flags);\n}\n#else\nstatic inline unsigned int debug_guardpage_minorder(void) { return 0; }\nstatic inline bool page_is_guard(struct page *page) { return false; }\n#endif /* CONFIG_DEBUG_PAGEALLOC */\n\n#endif /* __KERNEL__ */\n#endif /* _LINUX_MM_H */\n", "/*\n *  linux/mm/memory.c\n *\n *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds\n */\n\n/*\n * demand-loading started 01.12.91 - seems it is high on the list of\n * things wanted, and it should be easy to implement. - Linus\n */\n\n/*\n * Ok, demand-loading was easy, shared pages a little bit tricker. Shared\n * pages started 02.12.91, seems to work. - Linus.\n *\n * Tested sharing by executing about 30 /bin/sh: under the old kernel it\n * would have taken more than the 6M I have free, but it worked well as\n * far as I could see.\n *\n * Also corrected some \"invalidate()\"s - I wasn't doing enough of them.\n */\n\n/*\n * Real VM (paging to/from disk) started 18.12.91. Much more work and\n * thought has to go into this. Oh, well..\n * 19.12.91  -  works, somewhat. Sometimes I get faults, don't know why.\n *\t\tFound it. Everything seems to work now.\n * 20.12.91  -  Ok, making the swap-device changeable like the root.\n */\n\n/*\n * 05.04.94  -  Multi-page memory management added for v1.1.\n * \t\tIdea by Alex Bligh (alex@cconcepts.co.uk)\n *\n * 16.07.99  -  Support of BIGMEM added by Gerhard Wichert, Siemens AG\n *\t\t(Gerhard.Wichert@pdb.siemens.de)\n *\n * Aug/Sep 2004 Changed to four level page tables (Andi Kleen)\n */\n\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/delayacct.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n#include <linux/mmu_notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/swapops.h>\n#include <linux/elf.h>\n#include <linux/gfp.h>\n#include <linux/migrate.h>\n#include <linux/string.h>\n\n#include <asm/io.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/tlb.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n\n#include \"internal.h\"\n\n#ifdef LAST_NID_NOT_IN_PAGE_FLAGS\n#warning Unfortunate NUMA and NUMA Balancing config, growing page-frame for last_nid.\n#endif\n\n#ifndef CONFIG_NEED_MULTIPLE_NODES\n/* use the per-pgdat data instead for discontigmem - mbligh */\nunsigned long max_mapnr;\nstruct page *mem_map;\n\nEXPORT_SYMBOL(max_mapnr);\nEXPORT_SYMBOL(mem_map);\n#endif\n\nunsigned long num_physpages;\n/*\n * A number of key systems in x86 including ioremap() rely on the assumption\n * that high_memory defines the upper bound on direct map memory, then end\n * of ZONE_NORMAL.  Under CONFIG_DISCONTIG this means that max_low_pfn and\n * highstart_pfn must be the same; there must be no gap between ZONE_NORMAL\n * and ZONE_HIGHMEM.\n */\nvoid * high_memory;\n\nEXPORT_SYMBOL(num_physpages);\nEXPORT_SYMBOL(high_memory);\n\n/*\n * Randomize the address space (stacks, mmaps, brk, etc.).\n *\n * ( When CONFIG_COMPAT_BRK=y we exclude brk from randomization,\n *   as ancient (libc5 based) binaries can segfault. )\n */\nint randomize_va_space __read_mostly =\n#ifdef CONFIG_COMPAT_BRK\n\t\t\t\t\t1;\n#else\n\t\t\t\t\t2;\n#endif\n\nstatic int __init disable_randmaps(char *s)\n{\n\trandomize_va_space = 0;\n\treturn 1;\n}\n__setup(\"norandmaps\", disable_randmaps);\n\nunsigned long zero_pfn __read_mostly;\nunsigned long highest_memmap_pfn __read_mostly;\n\n/*\n * CONFIG_MMU architectures set up ZERO_PAGE in their paging_init()\n */\nstatic int __init init_zero_pfn(void)\n{\n\tzero_pfn = page_to_pfn(ZERO_PAGE(0));\n\treturn 0;\n}\ncore_initcall(init_zero_pfn);\n\n\n#if defined(SPLIT_RSS_COUNTING)\n\nvoid sync_mm_rss(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tif (current->rss_stat.count[i]) {\n\t\t\tadd_mm_counter(mm, i, current->rss_stat.count[i]);\n\t\t\tcurrent->rss_stat.count[i] = 0;\n\t\t}\n\t}\n\tcurrent->rss_stat.events = 0;\n}\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}\n#define inc_mm_counter_fast(mm, member) add_mm_counter_fast(mm, member, 1)\n#define dec_mm_counter_fast(mm, member) add_mm_counter_fast(mm, member, -1)\n\n/* sync counter once per 64 page faults */\n#define TASK_RSS_EVENTS_THRESH\t(64)\nstatic void check_sync_rss_stat(struct task_struct *task)\n{\n\tif (unlikely(task != current))\n\t\treturn;\n\tif (unlikely(task->rss_stat.events++ > TASK_RSS_EVENTS_THRESH))\n\t\tsync_mm_rss(task->mm);\n}\n#else /* SPLIT_RSS_COUNTING */\n\n#define inc_mm_counter_fast(mm, member) inc_mm_counter(mm, member)\n#define dec_mm_counter_fast(mm, member) dec_mm_counter(mm, member)\n\nstatic void check_sync_rss_stat(struct task_struct *task)\n{\n}\n\n#endif /* SPLIT_RSS_COUNTING */\n\n#ifdef HAVE_GENERIC_MMU_GATHER\n\nstatic int tlb_next_batch(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tbatch = tlb->active;\n\tif (batch->next) {\n\t\ttlb->active = batch->next;\n\t\treturn 1;\n\t}\n\n\tif (tlb->batch_count == MAX_GATHER_BATCH_COUNT)\n\t\treturn 0;\n\n\tbatch = (void *)__get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);\n\tif (!batch)\n\t\treturn 0;\n\n\ttlb->batch_count++;\n\tbatch->next = NULL;\n\tbatch->nr   = 0;\n\tbatch->max  = MAX_GATHER_BATCH;\n\n\ttlb->active->next = batch;\n\ttlb->active = batch;\n\n\treturn 1;\n}\n\n/* tlb_gather_mmu\n *\tCalled to initialize an (on-stack) mmu_gather structure for page-table\n *\ttear-down from @mm. The @fullmm argument is used when @mm is without\n *\tusers and we're going to destroy the full address space (exit/execve).\n */\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm, bool fullmm)\n{\n\ttlb->mm = mm;\n\n\ttlb->fullmm     = fullmm;\n\ttlb->need_flush_all = 0;\n\ttlb->start\t= -1UL;\n\ttlb->end\t= 0;\n\ttlb->need_flush = 0;\n\ttlb->fast_mode  = (num_possible_cpus() == 1);\n\ttlb->local.next = NULL;\n\ttlb->local.nr   = 0;\n\ttlb->local.max  = ARRAY_SIZE(tlb->__pages);\n\ttlb->active     = &tlb->local;\n\ttlb->batch_count = 0;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb->batch = NULL;\n#endif\n}\n\nvoid tlb_flush_mmu(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tif (!tlb->need_flush)\n\t\treturn;\n\ttlb->need_flush = 0;\n\ttlb_flush(tlb);\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\n\tif (tlb_fast_mode(tlb))\n\t\treturn;\n\n\tfor (batch = &tlb->local; batch; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}\n\n/* tlb_finish_mmu\n *\tCalled at the end of the shootdown operation to free up any resources\n *\tthat were required.\n */\nvoid tlb_finish_mmu(struct mmu_gather *tlb, unsigned long start, unsigned long end)\n{\n\tstruct mmu_gather_batch *batch, *next;\n\n\ttlb->start = start;\n\ttlb->end   = end;\n\ttlb_flush_mmu(tlb);\n\n\t/* keep the page table cache within bounds */\n\tcheck_pgt_cache();\n\n\tfor (batch = tlb->local.next; batch; batch = next) {\n\t\tnext = batch->next;\n\t\tfree_pages((unsigned long)batch, 0);\n\t}\n\ttlb->local.next = NULL;\n}\n\n/* __tlb_remove_page\n *\tMust perform the equivalent to __free_pte(pte_get_and_clear(ptep)), while\n *\thandling the additional races in SMP caused by other CPUs caching valid\n *\tmappings in their TLBs. Returns the number of free page slots left.\n *\tWhen out of page slots we must call tlb_flush_mmu().\n */\nint __tlb_remove_page(struct mmu_gather *tlb, struct page *page)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->need_flush);\n\n\tif (tlb_fast_mode(tlb)) {\n\t\tfree_page_and_swap_cache(page);\n\t\treturn 1; /* avoid calling tlb_flush_mmu() */\n\t}\n\n\tbatch = tlb->active;\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn 0;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON(batch->nr > batch->max);\n\n\treturn batch->max - batch->nr;\n}\n\n#endif /* HAVE_GENERIC_MMU_GATHER */\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\n/*\n * See the comment near struct mmu_table_batch.\n */\n\nstatic void tlb_remove_table_smp_sync(void *arg)\n{\n\t/* Simply deliver the interrupt */\n}\n\nstatic void tlb_remove_table_one(void *table)\n{\n\t/*\n\t * This isn't an RCU grace period and hence the page-tables cannot be\n\t * assumed to be actually RCU-freed.\n\t *\n\t * It is however sufficient for software page-table walkers that rely on\n\t * IRQ disabling. See the comment near struct mmu_table_batch.\n\t */\n\tsmp_call_function(tlb_remove_table_smp_sync, NULL, 1);\n\t__tlb_remove_table(table);\n}\n\nstatic void tlb_remove_table_rcu(struct rcu_head *head)\n{\n\tstruct mmu_table_batch *batch;\n\tint i;\n\n\tbatch = container_of(head, struct mmu_table_batch, rcu);\n\n\tfor (i = 0; i < batch->nr; i++)\n\t\t__tlb_remove_table(batch->tables[i]);\n\n\tfree_page((unsigned long)batch);\n}\n\nvoid tlb_table_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\tif (*batch) {\n\t\tcall_rcu_sched(&(*batch)->rcu, tlb_remove_table_rcu);\n\t\t*batch = NULL;\n\t}\n}\n\nvoid tlb_remove_table(struct mmu_gather *tlb, void *table)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\ttlb->need_flush = 1;\n\n\t/*\n\t * When there's less then two users of this mm there cannot be a\n\t * concurrent page-table walk.\n\t */\n\tif (atomic_read(&tlb->mm->mm_users) < 2) {\n\t\t__tlb_remove_table(table);\n\t\treturn;\n\t}\n\n\tif (*batch == NULL) {\n\t\t*batch = (struct mmu_table_batch *)__get_free_page(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (*batch == NULL) {\n\t\t\ttlb_remove_table_one(table);\n\t\t\treturn;\n\t\t}\n\t\t(*batch)->nr = 0;\n\t}\n\t(*batch)->tables[(*batch)->nr++] = table;\n\tif ((*batch)->nr == MAX_TABLE_BATCH)\n\t\ttlb_table_flush(tlb);\n}\n\n#endif /* CONFIG_HAVE_RCU_TABLE_FREE */\n\n/*\n * If a p?d_bad entry is found while walking page tables, report\n * the error, before resetting entry to p?d_none.  Usually (but\n * very seldom) called out from the p?d_none_or_clear_bad macros.\n */\n\nvoid pgd_clear_bad(pgd_t *pgd)\n{\n\tpgd_ERROR(*pgd);\n\tpgd_clear(pgd);\n}\n\nvoid pud_clear_bad(pud_t *pud)\n{\n\tpud_ERROR(*pud);\n\tpud_clear(pud);\n}\n\nvoid pmd_clear_bad(pmd_t *pmd)\n{\n\tpmd_ERROR(*pmd);\n\tpmd_clear(pmd);\n}\n\n/*\n * Note: this doesn't free the actual pages themselves. That\n * has been handled earlier when unmapping all the memory regions.\n */\nstatic void free_pte_range(struct mmu_gather *tlb, pmd_t *pmd,\n\t\t\t   unsigned long addr)\n{\n\tpgtable_t token = pmd_pgtable(*pmd);\n\tpmd_clear(pmd);\n\tpte_free_tlb(tlb, token, addr);\n\ttlb->mm->nr_ptes--;\n}\n\nstatic inline void free_pmd_range(struct mmu_gather *tlb, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tfree_pte_range(tlb, pmd, addr);\n\t} while (pmd++, addr = next, addr != end);\n\n\tstart &= PUD_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PUD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpmd = pmd_offset(pud, start);\n\tpud_clear(pud);\n\tpmd_free_tlb(tlb, pmd, start);\n}\n\nstatic inline void free_pud_range(struct mmu_gather *tlb, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long start;\n\n\tstart = addr;\n\tpud = pud_offset(pgd, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tfree_pmd_range(tlb, pud, addr, next, floor, ceiling);\n\t} while (pud++, addr = next, addr != end);\n\n\tstart &= PGDIR_MASK;\n\tif (start < floor)\n\t\treturn;\n\tif (ceiling) {\n\t\tceiling &= PGDIR_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\treturn;\n\n\tpud = pud_offset(pgd, start);\n\tpgd_clear(pgd);\n\tpud_free_tlb(tlb, pud, start);\n}\n\n/*\n * This function frees user-level page tables of a process.\n *\n * Must be called with pagetable lock held.\n */\nvoid free_pgd_range(struct mmu_gather *tlb,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long floor, unsigned long ceiling)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\t/*\n\t * The next few lines have given us lots of grief...\n\t *\n\t * Why are we testing PMD* at this top level?  Because often\n\t * there will be no work to do at all, and we'd prefer not to\n\t * go all the way down to the bottom just to discover that.\n\t *\n\t * Why all these \"- 1\"s?  Because 0 represents both the bottom\n\t * of the address space and the top of it (using -1 for the\n\t * top wouldn't help much: the masks would do the wrong thing).\n\t * The rule is that addr 0 and floor 0 refer to the bottom of\n\t * the address space, but end 0 and ceiling 0 refer to the top\n\t * Comparisons need to use \"end - 1\" and \"ceiling - 1\" (though\n\t * that end 0 case should be mythical).\n\t *\n\t * Wherever addr is brought up or ceiling brought down, we must\n\t * be careful to reject \"the opposite 0\" before it confuses the\n\t * subsequent tests.  But what about where end is brought down\n\t * by PMD_SIZE below? no, end can't go down to 0 there.\n\t *\n\t * Whereas we round start (addr) and ceiling down, by different\n\t * masks at different levels, in order to test whether a table\n\t * now has no other vmas using it, so can be freed, we don't\n\t * bother to round floor or end up - the tests don't need that.\n\t */\n\n\taddr &= PMD_MASK;\n\tif (addr < floor) {\n\t\taddr += PMD_SIZE;\n\t\tif (!addr)\n\t\t\treturn;\n\t}\n\tif (ceiling) {\n\t\tceiling &= PMD_MASK;\n\t\tif (!ceiling)\n\t\t\treturn;\n\t}\n\tif (end - 1 > ceiling - 1)\n\t\tend -= PMD_SIZE;\n\tif (addr > end - 1)\n\t\treturn;\n\n\tpgd = pgd_offset(tlb->mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tfree_pud_range(tlb, pgd, addr, next, floor, ceiling);\n\t} while (pgd++, addr = next, addr != end);\n}\n\nvoid free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\n\t\t/*\n\t\t * Hide vma from rmap and truncate_pagecache before freeing\n\t\t * pgtables\n\t\t */\n\t\tunlink_anon_vmas(vma);\n\t\tunlink_file_vma(vma);\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Optimization: gather nearby vmas into one call down\n\t\t\t */\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tunlink_anon_vmas(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}\n\nint __pte_alloc(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tpmd_t *pmd, unsigned long address)\n{\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tint wait_split_huge_page;\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tspin_lock(&mm->page_table_lock);\n\twait_split_huge_page = 0;\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm->nr_ptes++;\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t} else if (unlikely(pmd_trans_splitting(*pmd)))\n\t\twait_split_huge_page = 1;\n\tspin_unlock(&mm->page_table_lock);\n\tif (new)\n\t\tpte_free(mm, new);\n\tif (wait_split_huge_page)\n\t\twait_split_huge_page(vma->anon_vma, pmd);\n\treturn 0;\n}\n\nint __pte_alloc_kernel(pmd_t *pmd, unsigned long address)\n{\n\tpte_t *new = pte_alloc_one_kernel(&init_mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&init_mm.page_table_lock);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tpmd_populate_kernel(&init_mm, pmd, new);\n\t\tnew = NULL;\n\t} else\n\t\tVM_BUG_ON(pmd_trans_splitting(*pmd));\n\tspin_unlock(&init_mm.page_table_lock);\n\tif (new)\n\t\tpte_free_kernel(&init_mm, new);\n\treturn 0;\n}\n\nstatic inline void init_rss_vec(int *rss)\n{\n\tmemset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}\n\nstatic inline void add_mm_rss_vec(struct mm_struct *mm, int *rss)\n{\n\tint i;\n\n\tif (current->mm == mm)\n\t\tsync_mm_rss(mm);\n\tfor (i = 0; i < NR_MM_COUNTERS; i++)\n\t\tif (rss[i])\n\t\t\tadd_mm_counter(mm, i, rss[i]);\n}\n\n/*\n * This function is called to print an error when a bad pte\n * is found. For example, we might have a PFN-mapped pte in\n * a region that doesn't allow it.\n *\n * The calling function must still handle the error.\n */\nstatic void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t  pte_t pte, struct page *page)\n{\n\tpgd_t *pgd = pgd_offset(vma->vm_mm, addr);\n\tpud_t *pud = pud_offset(pgd, addr);\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tstruct address_space *mapping;\n\tpgoff_t index;\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\treturn;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tprintk(KERN_ALERT\n\t\t\t\t\"BUG: Bad page map: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tmapping = vma->vm_file ? vma->vm_file->f_mapping : NULL;\n\tindex = linear_page_index(vma, addr);\n\n\tprintk(KERN_ALERT\n\t\t\"BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\\n\",\n\t\tcurrent->comm,\n\t\t(long long)pte_val(pte), (long long)pmd_val(*pmd));\n\tif (page)\n\t\tdump_page(page);\n\tprintk(KERN_ALERT\n\t\t\"addr:%p vm_flags:%08lx anon_vma:%p mapping:%p index:%lx\\n\",\n\t\t(void *)addr, vma->vm_flags, vma->anon_vma, mapping, index);\n\t/*\n\t * Choose text because data symbols depend on CONFIG_KALLSYMS_ALL=y\n\t */\n\tif (vma->vm_ops)\n\t\tprint_symbol(KERN_ALERT \"vma->vm_ops->fault: %s\\n\",\n\t\t\t\t(unsigned long)vma->vm_ops->fault);\n\tif (vma->vm_file && vma->vm_file->f_op)\n\t\tprint_symbol(KERN_ALERT \"vma->vm_file->f_op->mmap: %s\\n\",\n\t\t\t\t(unsigned long)vma->vm_file->f_op->mmap);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}\n\n/*\n * vm_normal_page -- This function gets the \"struct page\" associated with a pte.\n *\n * \"Special\" mappings do not wish to be associated with a \"struct page\" (either\n * it doesn't exist, or it exists but they don't want to touch it). In this\n * case, NULL is returned here. \"Normal\" mappings do have a struct page.\n *\n * There are 2 broad cases. Firstly, an architecture may define a pte_special()\n * pte bit, in which case this function is trivial. Secondly, an architecture\n * may not have a spare pte bit, which requires a more complicated scheme,\n * described below.\n *\n * A raw VM_PFNMAP mapping (ie. one that is not COWed) is always considered a\n * special mapping (even if there are underlying and valid \"struct pages\").\n * COWed pages of a VM_PFNMAP are always normal.\n *\n * The way we recognize COWed pages within VM_PFNMAP mappings is through the\n * rules set up by \"remap_pfn_range()\": the vma will have the VM_PFNMAP bit\n * set, and the vm_pgoff will point to the first PFN mapped: thus every special\n * mapping will always honor the rule\n *\n *\tpfn_of_page == vma->vm_pgoff + ((addr - vma->vm_start) >> PAGE_SHIFT)\n *\n * And for normal mappings this is false.\n *\n * This restricts such mappings to be a linear translation from virtual address\n * to pfn. To get around this restriction, we allow arbitrary mappings so long\n * as the vma is not a COW mapping; in that case, we know that all ptes are\n * special (because none can have been COWed).\n *\n *\n * In order to support COW of arbitrary special mappings, we have VM_MIXEDMAP.\n *\n * VM_MIXEDMAP mappings can likewise contain memory with or without \"struct\n * page\" backing, however the difference is that _all_ pages with a struct\n * page (that is, those where pfn_valid is true) are refcounted and considered\n * normal pages by the VM. The disadvantage is that pages are refcounted\n * (which can be slower and simply not an option for some PFNMAP users). The\n * advantage is that we don't have to follow the strict linearity rule of\n * PFNMAP mappings in order to support COWable mappings.\n *\n */\n#ifdef __HAVE_ARCH_PTE_SPECIAL\n# define HAVE_PTE_SPECIAL 1\n#else\n# define HAVE_PTE_SPECIAL 0\n#endif\nstruct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpte_t pte)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (HAVE_PTE_SPECIAL) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (!is_zero_pfn(pfn))\n\t\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !HAVE_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}\n\n/*\n * copy one vm_area from one task to the other. Assumes the page tables\n * already present in the new task to be cleared in the whole range\n * covered by this vma.\n */\n\nstatic inline unsigned long\ncopy_one_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpte_t *dst_pte, pte_t *src_pte, struct vm_area_struct *vma,\n\t\tunsigned long addr, int *rss)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpte_t pte = *src_pte;\n\tstruct page *page;\n\n\t/* pte contains position in swap or file, so copy. */\n\tif (unlikely(!pte_present(pte))) {\n\t\tif (!pte_file(pte)) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (swap_duplicate(entry) < 0)\n\t\t\t\treturn entry.val;\n\n\t\t\t/* make sure dst_mm is on swapoff's mmlist. */\n\t\t\tif (unlikely(list_empty(&dst_mm->mmlist))) {\n\t\t\t\tspin_lock(&mmlist_lock);\n\t\t\t\tif (list_empty(&dst_mm->mmlist))\n\t\t\t\t\tlist_add(&dst_mm->mmlist,\n\t\t\t\t\t\t &src_mm->mmlist);\n\t\t\t\tspin_unlock(&mmlist_lock);\n\t\t\t}\n\t\t\tif (likely(!non_swap_entry(entry)))\n\t\t\t\trss[MM_SWAPENTS]++;\n\t\t\telse if (is_migration_entry(entry)) {\n\t\t\t\tpage = migration_entry_to_page(entry);\n\n\t\t\t\tif (PageAnon(page))\n\t\t\t\t\trss[MM_ANONPAGES]++;\n\t\t\t\telse\n\t\t\t\t\trss[MM_FILEPAGES]++;\n\n\t\t\t\tif (is_write_migration_entry(entry) &&\n\t\t\t\t    is_cow_mapping(vm_flags)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * COW mappings require pages in both\n\t\t\t\t\t * parent and child to be set to read.\n\t\t\t\t\t */\n\t\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t\t\tset_pte_at(src_mm, addr, src_pte, pte);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto out_set_pte;\n\t}\n\n\t/*\n\t * If it's a COW mapping, write protect it both\n\t * in the parent and the child\n\t */\n\tif (is_cow_mapping(vm_flags)) {\n\t\tptep_set_wrprotect(src_mm, addr, src_pte);\n\t\tpte = pte_wrprotect(pte);\n\t}\n\n\t/*\n\t * If it's a shared mapping, mark it clean in\n\t * the child\n\t */\n\tif (vm_flags & VM_SHARED)\n\t\tpte = pte_mkclean(pte);\n\tpte = pte_mkold(pte);\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (page) {\n\t\tget_page(page);\n\t\tpage_dup_rmap(page);\n\t\tif (PageAnon(page))\n\t\t\trss[MM_ANONPAGES]++;\n\t\telse\n\t\t\trss[MM_FILEPAGES]++;\n\t}\n\nout_set_pte:\n\tset_pte_at(dst_mm, addr, dst_pte, pte);\n\treturn 0;\n}\n\nint copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t   pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,\n\t\t   unsigned long addr, unsigned long end)\n{\n\tpte_t *orig_src_pte, *orig_dst_pte;\n\tpte_t *src_pte, *dst_pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tint progress = 0;\n\tint rss[NR_MM_COUNTERS];\n\tswp_entry_t entry = (swp_entry_t){0};\n\nagain:\n\tinit_rss_vec(rss);\n\n\tdst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);\n\tif (!dst_pte)\n\t\treturn -ENOMEM;\n\tsrc_pte = pte_offset_map(src_pmd, addr);\n\tsrc_ptl = pte_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\torig_src_pte = src_pte;\n\torig_dst_pte = dst_pte;\n\tarch_enter_lazy_mmu_mode();\n\n\tdo {\n\t\t/*\n\t\t * We are holding two locks at this point - either of them\n\t\t * could generate latencies in another task on another CPU.\n\t\t */\n\t\tif (progress >= 32) {\n\t\t\tprogress = 0;\n\t\t\tif (need_resched() ||\n\t\t\t    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pte_none(*src_pte)) {\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\tentry.val = copy_one_pte(dst_mm, src_mm, dst_pte, src_pte,\n\t\t\t\t\t\t\tvma, addr, rss);\n\t\tif (entry.val)\n\t\t\tbreak;\n\t\tprogress += 8;\n\t} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\tspin_unlock(src_ptl);\n\tpte_unmap(orig_src_pte);\n\tadd_mm_rss_vec(dst_mm, rss);\n\tpte_unmap_unlock(orig_dst_pte, dst_ptl);\n\tcond_resched();\n\n\tif (entry.val) {\n\t\tif (add_swap_count_continuation(entry, GFP_KERNEL) < 0)\n\t\t\treturn -ENOMEM;\n\t\tprogress = 0;\n\t}\n\tif (addr != end)\n\t\tgoto again;\n\treturn 0;\n}\n\nstatic inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON(next-addr != HPAGE_PMD_SIZE);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n\t\t\t\t\t    dst_pmd, src_pmd, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}\n\nstatic inline int copy_pud_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpgd_t *dst_pgd, pgd_t *src_pgd, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpud_t *src_pud, *dst_pud;\n\tunsigned long next;\n\n\tdst_pud = pud_alloc(dst_mm, dst_pgd, addr);\n\tif (!dst_pud)\n\t\treturn -ENOMEM;\n\tsrc_pud = pud_offset(src_pgd, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(src_pud))\n\t\t\tcontinue;\n\t\tif (copy_pmd_range(dst_mm, src_mm, dst_pud, src_pud,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pud++, src_pud++, addr = next, addr != end);\n\treturn 0;\n}\n\nint copy_page_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tstruct vm_area_struct *vma)\n{\n\tpgd_t *src_pgd, *dst_pgd;\n\tunsigned long next;\n\tunsigned long addr = vma->vm_start;\n\tunsigned long end = vma->vm_end;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tbool is_cow;\n\tint ret;\n\n\t/*\n\t * Don't copy ptes where a page fault will fill them correctly.\n\t * Fork becomes much lighter when there are big shared or private\n\t * readonly mappings. The tradeoff is that copy_page_range is more\n\t * efficient than faulting.\n\t */\n\tif (!(vma->vm_flags & (VM_HUGETLB | VM_NONLINEAR |\n\t\t\t       VM_PFNMAP | VM_MIXEDMAP))) {\n\t\tif (!vma->anon_vma)\n\t\t\treturn 0;\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn copy_hugetlb_page_range(dst_mm, src_mm, vma);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP)) {\n\t\t/*\n\t\t * We do not free on error cases below as remove_vma\n\t\t * gets called on error from higher level routine\n\t\t */\n\t\tret = track_pfn_copy(vma);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We need to invalidate the secondary MMU mappings only when\n\t * there could be a permission downgrade on the ptes of the\n\t * parent mm. And a permission downgrade will only happen if\n\t * is_cow_mapping() returns true.\n\t */\n\tis_cow = is_cow_mapping(vma->vm_flags);\n\tmmun_start = addr;\n\tmmun_end   = end;\n\tif (is_cow)\n\t\tmmu_notifier_invalidate_range_start(src_mm, mmun_start,\n\t\t\t\t\t\t    mmun_end);\n\n\tret = 0;\n\tdst_pgd = pgd_offset(dst_mm, addr);\n\tsrc_pgd = pgd_offset(src_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(src_pgd))\n\t\t\tcontinue;\n\t\tif (unlikely(copy_pud_range(dst_mm, src_mm, dst_pgd, src_pgd,\n\t\t\t\t\t    vma, addr, next))) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t} while (dst_pgd++, src_pgd++, addr = next, addr != end);\n\n\tif (is_cow)\n\t\tmmu_notifier_invalidate_range_end(src_mm, mmun_start, mmun_end);\n\treturn ret;\n}\n\nstatic unsigned long zap_pte_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tstruct mm_struct *mm = tlb->mm;\n\tint force_flush = 0;\n\tint rss[NR_MM_COUNTERS];\n\tspinlock_t *ptl;\n\tpte_t *start_pte;\n\tpte_t *pte;\n\nagain:\n\tinit_rss_vec(rss);\n\tstart_pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n\tpte = start_pte;\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tpte_t ptent = *pte;\n\t\tif (pte_none(ptent)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pte_present(ptent)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\t\tif (unlikely(details) && page) {\n\t\t\t\t/*\n\t\t\t\t * unmap_shared_mapping_pages() wants to\n\t\t\t\t * invalidate cache without truncating:\n\t\t\t\t * unmap shared but keep private pages.\n\t\t\t\t */\n\t\t\t\tif (details->check_mapping &&\n\t\t\t\t    details->check_mapping != page->mapping)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Each page->index must be checked when\n\t\t\t\t * invalidating or truncating nonlinear.\n\t\t\t\t */\n\t\t\t\tif (details->nonlinear_vma &&\n\t\t\t\t    (page->index < details->first_index ||\n\t\t\t\t     page->index > details->last_index))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptent = ptep_get_and_clear_full(mm, addr, pte,\n\t\t\t\t\t\t\ttlb->fullmm);\n\t\t\ttlb_remove_tlb_entry(tlb, pte, addr);\n\t\t\tif (unlikely(!page))\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(details) && details->nonlinear_vma\n\t\t\t    && linear_page_index(details->nonlinear_vma,\n\t\t\t\t\t\taddr) != page->index)\n\t\t\t\tset_pte_at(mm, addr, pte,\n\t\t\t\t\t   pgoff_to_pte(page->index));\n\t\t\tif (PageAnon(page))\n\t\t\t\trss[MM_ANONPAGES]--;\n\t\t\telse {\n\t\t\t\tif (pte_dirty(ptent))\n\t\t\t\t\tset_page_dirty(page);\n\t\t\t\tif (pte_young(ptent) &&\n\t\t\t\t    likely(!VM_SequentialReadHint(vma)))\n\t\t\t\t\tmark_page_accessed(page);\n\t\t\t\trss[MM_FILEPAGES]--;\n\t\t\t}\n\t\t\tpage_remove_rmap(page);\n\t\t\tif (unlikely(page_mapcount(page) < 0))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, page);\n\t\t\tforce_flush = !__tlb_remove_page(tlb, page);\n\t\t\tif (force_flush)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If details->check_mapping, we leave swap entries;\n\t\t * if details->nonlinear_vma, we leave file entries.\n\t\t */\n\t\tif (unlikely(details))\n\t\t\tcontinue;\n\t\tif (pte_file(ptent)) {\n\t\t\tif (unlikely(!(vma->vm_flags & VM_NONLINEAR)))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, NULL);\n\t\t} else {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(ptent);\n\n\t\t\tif (!non_swap_entry(entry))\n\t\t\t\trss[MM_SWAPENTS]--;\n\t\t\telse if (is_migration_entry(entry)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = migration_entry_to_page(entry);\n\n\t\t\t\tif (PageAnon(page))\n\t\t\t\t\trss[MM_ANONPAGES]--;\n\t\t\t\telse\n\t\t\t\t\trss[MM_FILEPAGES]--;\n\t\t\t}\n\t\t\tif (unlikely(!free_swap_and_cache(entry)))\n\t\t\t\tprint_bad_pte(vma, addr, ptent, NULL);\n\t\t}\n\t\tpte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\n\tadd_mm_rss_vec(mm, rss);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(start_pte, ptl);\n\n\t/*\n\t * mmu_gather ran out of room to batch pages, we break out of\n\t * the PTE lock to avoid doing the potential expensive TLB invalidate\n\t * and page-free while holding it.\n\t */\n\tif (force_flush) {\n\t\tforce_flush = 0;\n\n#ifdef HAVE_GENERIC_MMU_GATHER\n\t\ttlb->start = addr;\n\t\ttlb->end = end;\n#endif\n\t\ttlb_flush_mmu(tlb);\n\t\tif (addr != end)\n\t\t\tgoto again;\n\t}\n\n\treturn addr;\n}\n\nstatic inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n#ifdef CONFIG_DEBUG_VM\n\t\t\t\tif (!rwsem_is_locked(&tlb->mm->mmap_sem)) {\n\t\t\t\t\tpr_err(\"%s: mmap_sem is unlocked! addr=0x%lx end=0x%lx vma->vm_start=0x%lx vma->vm_end=0x%lx\\n\",\n\t\t\t\t\t\t__func__, addr, end,\n\t\t\t\t\t\tvma->vm_start,\n\t\t\t\t\t\tvma->vm_end);\n\t\t\t\t\tBUG();\n\t\t\t\t}\n#endif\n\t\t\t\tsplit_huge_page_pmd(vma, addr, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tgoto next;\n\t\t\t/* fall through */\n\t\t}\n\t\t/*\n\t\t * Here there can be other concurrent MADV_DONTNEED or\n\t\t * trans huge page faults running, and if the pmd is\n\t\t * none or trans huge it can change under us. This is\n\t\t * because MADV_DONTNEED holds the mmap_sem in read\n\t\t * mode.\n\t\t */\n\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\t\tgoto next;\n\t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn addr;\n}\n\nstatic inline unsigned long zap_pud_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pgd_t *pgd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(pgd, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tnext = zap_pmd_range(tlb, vma, pud, addr, next, details);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn addr;\n}\n\nstatic void unmap_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t     struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tif (details && !details->check_mapping && !details->nonlinear_vma)\n\t\tdetails = NULL;\n\n\tBUG_ON(addr >= end);\n\tmem_cgroup_uncharge_start();\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tnext = zap_pud_range(tlb, vma, pgd, addr, next, details);\n\t} while (pgd++, addr = next, addr != end);\n\ttlb_end_vma(tlb, vma);\n\tmem_cgroup_uncharge_end();\n}\n\n\nstatic void unmap_single_vma(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tunsigned long start = max(vma->vm_start, start_addr);\n\tunsigned long end;\n\n\tif (start >= vma->vm_end)\n\t\treturn;\n\tend = min(vma->vm_end, end_addr);\n\tif (end <= vma->vm_start)\n\t\treturn;\n\n\tif (vma->vm_file)\n\t\tuprobe_munmap(vma, start, end);\n\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn(vma, 0, 0);\n\n\tif (start != end) {\n\t\tif (unlikely(is_vm_hugetlb_page(vma))) {\n\t\t\t/*\n\t\t\t * It is undesirable to test vma->vm_file as it\n\t\t\t * should be non-null for valid hugetlb area.\n\t\t\t * However, vm_file will be NULL in the error\n\t\t\t * cleanup path of do_mmap_pgoff. When\n\t\t\t * hugetlbfs ->mmap method fails,\n\t\t\t * do_mmap_pgoff() nullifies vma->vm_file\n\t\t\t * before calling this function to clean up.\n\t\t\t * Since no pte has actually been setup, it is\n\t\t\t * safe to do nothing in this case.\n\t\t\t */\n\t\t\tif (vma->vm_file) {\n\t\t\t\tmutex_lock(&vma->vm_file->f_mapping->i_mmap_mutex);\n\t\t\t\t__unmap_hugepage_range_final(tlb, vma, start, end, NULL);\n\t\t\t\tmutex_unlock(&vma->vm_file->f_mapping->i_mmap_mutex);\n\t\t\t}\n\t\t} else\n\t\t\tunmap_page_range(tlb, vma, start, end, details);\n\t}\n}\n\n/**\n * unmap_vmas - unmap a range of memory covered by a list of vma's\n * @tlb: address of the caller's struct mmu_gather\n * @vma: the starting vma\n * @start_addr: virtual address at which to start unmapping\n * @end_addr: virtual address at which to end unmapping\n *\n * Unmap all pages in the vma list.\n *\n * Only addresses between `start' and `end' will be unmapped.\n *\n * The VMA list must be sorted in ascending virtual address order.\n *\n * unmap_vmas() assumes that the caller will flush the whole unmapped address\n * range after unmap_vmas() returns.  So the only responsibility here is to\n * ensure that any thus-far unmapped pages are flushed before unmap_vmas()\n * drops the lock and schedules.\n */\nvoid unmap_vmas(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tmmu_notifier_invalidate_range_start(mm, start_addr, end_addr);\n\tfor ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next)\n\t\tunmap_single_vma(tlb, vma, start_addr, end_addr, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start_addr, end_addr);\n}\n\n/**\n * zap_page_range - remove user pages in a given range\n * @vma: vm_area_struct holding the applicable pages\n * @start: starting address of pages to zap\n * @size: number of bytes to zap\n * @details: details of nonlinear truncation or shared cache invalidation\n *\n * Caller must protect the VMA list\n */\nvoid zap_page_range(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = start + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, 0);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, start, end);\n\tfor ( ; vma && vma->vm_start < end; vma = vma->vm_next)\n\t\tunmap_single_vma(&tlb, vma, start, end, details);\n\tmmu_notifier_invalidate_range_end(mm, start, end);\n\ttlb_finish_mmu(&tlb, start, end);\n}\n\n/**\n * zap_page_range_single - remove user pages in a given range\n * @vma: vm_area_struct holding the applicable pages\n * @address: starting address of pages to zap\n * @size: number of bytes to zap\n * @details: details of nonlinear truncation or shared cache invalidation\n *\n * The range must fit into one VMA.\n */\nstatic void zap_page_range_single(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size, struct zap_details *details)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mmu_gather tlb;\n\tunsigned long end = address + size;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, 0);\n\tupdate_hiwater_rss(mm);\n\tmmu_notifier_invalidate_range_start(mm, address, end);\n\tunmap_single_vma(&tlb, vma, address, end, details);\n\tmmu_notifier_invalidate_range_end(mm, address, end);\n\ttlb_finish_mmu(&tlb, address, end);\n}\n\n/**\n * zap_vma_ptes - remove ptes mapping the vma\n * @vma: vm_area_struct holding ptes to be zapped\n * @address: starting address of pages to zap\n * @size: number of bytes to zap\n *\n * This function only unmaps ptes assigned to VM_PFNMAP vmas.\n *\n * The entire address range must be fully contained within the vma.\n *\n * Returns 0 if successful.\n */\nint zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned long size)\n{\n\tif (address < vma->vm_start || address + size > vma->vm_end ||\n\t    \t\t!(vma->vm_flags & VM_PFNMAP))\n\t\treturn -1;\n\tzap_page_range_single(vma, address, size, NULL);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(zap_vma_ptes);\n\n/**\n * follow_page_mask - look up a page descriptor from a user-virtual address\n * @vma: vm_area_struct mapping @address\n * @address: virtual address to look up\n * @flags: flags modifying lookup behaviour\n * @page_mask: on output, *page_mask is set according to the size of the page\n *\n * @flags can have FOLL_ flags set, defined in <linux/mm.h>\n *\n * Returns the mapped (struct page *), %NULL if no mapping exists, or\n * an error pointer if there is a mapping to something not represented\n * by a page descriptor (see also vm_normal_page()).\n */\nstruct page *follow_page_mask(struct vm_area_struct *vma,\n\t\t\t      unsigned long address, unsigned int flags,\n\t\t\t      unsigned int *page_mask)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\t*page_mask = 0;\n\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tgoto out;\n\t}\n\n\tpage = NULL;\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto no_page_table;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud))\n\t\tgoto no_page_table;\n\tif (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tpage = follow_huge_pud(mm, address, pud, flags & FOLL_WRITE);\n\t\tgoto out;\n\t}\n\tif (unlikely(pud_bad(*pud)))\n\t\tgoto no_page_table;\n\n\tpmd = pmd_offset(pud, address);\n\tif (pmd_none(*pmd))\n\t\tgoto no_page_table;\n\tif (pmd_huge(*pmd) && vma->vm_flags & VM_HUGETLB) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags & FOLL_WRITE);\n\t\tgoto out;\n\t}\n\tif ((flags & FOLL_NUMA) && pmd_numa(*pmd))\n\t\tgoto no_page_table;\n\tif (pmd_trans_huge(*pmd)) {\n\t\tif (flags & FOLL_SPLIT) {\n\t\t\tsplit_huge_page_pmd(vma, address, pmd);\n\t\t\tgoto split_fallthrough;\n\t\t}\n\t\tspin_lock(&mm->page_table_lock);\n\t\tif (likely(pmd_trans_huge(*pmd))) {\n\t\t\tif (unlikely(pmd_trans_splitting(*pmd))) {\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\twait_split_huge_page(vma->anon_vma, pmd);\n\t\t\t} else {\n\t\t\t\tpage = follow_trans_huge_pmd(vma, address,\n\t\t\t\t\t\t\t     pmd, flags);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\t*page_mask = HPAGE_PMD_NR - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t/* fall through */\n\t}\nsplit_fallthrough:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\tgoto no_page_table;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte) || pte_file(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto split_fallthrough;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_numa(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (unlikely(!page)) {\n\t\tif ((flags & FOLL_DUMP) ||\n\t\t    !is_zero_pfn(pte_pfn(pte)))\n\t\t\tgoto bad_page;\n\t\tpage = pte_page(pte);\n\t}\n\n\tif (flags & FOLL_GET)\n\t\tget_page_foll(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/*\n\t\t * The preliminary mapping check is mainly to avoid the\n\t\t * pointless overhead of lock_page on the ZERO_PAGE\n\t\t * which might bounce very badly if there is contention.\n\t\t *\n\t\t * If the page is already locked, we don't need to\n\t\t * handle it now - vmscan will handle it later if and\n\t\t * when it attempts to reclaim the page.\n\t\t */\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  /* push cached pages to LRU */\n\t\t\t/*\n\t\t\t * Because we lock page here, and migration is\n\t\t\t * blocked by the pte's page reference, and we\n\t\t\t * know the page is still mapped, we don't even\n\t\t\t * need to check for file-cache page truncation.\n\t\t\t */\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn page;\n\nbad_page:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn ERR_PTR(-EFAULT);\n\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn page;\n\nno_page_table:\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate unnecessary pages or\n\t * page tables.  Return error instead of NULL to skip handle_mm_fault,\n\t * then get_dump_page() will return NULL to leave a hole in the dump.\n\t * But we can only make this optimization where a hole would surely\n\t * be zero-filled if handle_mm_fault() actually did handle it.\n\t */\n\tif ((flags & FOLL_DUMP) &&\n\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn page;\n}\n\nstatic inline int stack_guard_page(struct vm_area_struct *vma, unsigned long addr)\n{\n\treturn stack_guard_page_start(vma, addr) ||\n\t       stack_guard_page_end(vma, addr+PAGE_SIZE);\n}\n\n/**\n * __get_user_pages() - pin user pages in memory\n * @tsk:\ttask_struct of target task\n * @mm:\t\tmm_struct of target mm\n * @start:\tstarting user address\n * @nr_pages:\tnumber of pages from start to pin\n * @gup_flags:\tflags modifying pin behaviour\n * @pages:\tarray that receives pointers to the pages pinned.\n *\t\tShould be at least nr_pages long. Or NULL, if caller\n *\t\tonly intends to ensure the pages are faulted in.\n * @vmas:\tarray of pointers to vmas corresponding to each page.\n *\t\tOr NULL if the caller does not require them.\n * @nonblocking: whether waiting for disk IO or mmap_sem contention\n *\n * Returns number of pages pinned. This may be fewer than the number\n * requested. If nr_pages is 0 or negative, returns 0. If no pages\n * were pinned, returns -errno. Each page returned must be released\n * with a put_page() call when it is finished with. vmas will only\n * remain valid while mmap_sem is held.\n *\n * Must be called with mmap_sem held for read or write.\n *\n * __get_user_pages walks a process's page tables and takes a reference to\n * each struct page that each user address corresponds to at a given\n * instant. That is, it takes the page that would be accessed if a user\n * thread accesses the given user virtual address at that instant.\n *\n * This does not guarantee that the page exists in the user mappings when\n * __get_user_pages returns, and there may even be a completely different\n * page there in some cases (eg. if mmapped pagecache has been invalidated\n * and subsequently re faulted). However it does guarantee that the page\n * won't be freed completely. And mostly callers simply care that the page\n * contains data that was valid *at some point in time*. Typically, an IO\n * or similar operation cannot guarantee anything stronger anyway because\n * locks can't be held over the syscall boundary.\n *\n * If @gup_flags & FOLL_WRITE == 0, the page must not be written to. If\n * the page is written to, set_page_dirty (or set_page_dirty_lock, as\n * appropriate) must be called after the page is finished with, and\n * before put_page is called.\n *\n * If @nonblocking != NULL, __get_user_pages will not wait for disk IO\n * or mmap_sem contention, and if waiting is needed to pin all pages,\n * *@nonblocking will be set to 0.\n *\n * In most cases, get_user_pages or get_user_pages_fast should be used\n * instead of __get_user_pages. __get_user_pages should be used only if\n * you need some special @gup_flags.\n */\nlong __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *nonblocking)\n{\n\tlong i;\n\tunsigned long vm_flags;\n\tunsigned int page_mask;\n\n\tif (!nr_pages)\n\t\treturn 0;\n\n\tVM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));\n\n\t/* \n\t * Require read or write permissions.\n\t * If FOLL_FORCE is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = (gup_flags & FOLL_WRITE) ?\n\t\t\t(VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= (gup_flags & FOLL_FORCE) ?\n\t\t\t(VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\n\t/*\n\t * If FOLL_FORCE and FOLL_NUMA are both set, handle_mm_fault\n\t * would be called on PROT_NONE ranges. We must never invoke\n\t * handle_mm_fault on PROT_NONE ranges or the NUMA hinting\n\t * page faults would unprotect the PROT_NONE ranges if\n\t * _PAGE_NUMA and _PAGE_PROTNONE are sharing the same pte/pmd\n\t * bitflag. So to avoid that, don't set FOLL_NUMA if\n\t * FOLL_FORCE is set.\n\t */\n\tif (!(gup_flags & FOLL_FORCE))\n\t\tgup_flags |= FOLL_NUMA;\n\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(mm, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\n\t\t\t/* user gate pages are read-only */\n\t\t\tif (gup_flags & FOLL_WRITE)\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tvma = get_gate_vma(mm);\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = vm_normal_page(vma, start, *pte);\n\t\t\t\tif (!page) {\n\t\t\t\t\tif (!(gup_flags & FOLL_DUMP) &&\n\t\t\t\t\t     is_zero_pfn(pte_pfn(*pte)))\n\t\t\t\t\t\tpage = pte_page(*pte);\n\t\t\t\t\telse {\n\t\t\t\t\t\tpte_unmap(pte);\n\t\t\t\t\t\treturn i ? : -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpages[i] = page;\n\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tpage_mask = 0;\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tif (!vma ||\n\t\t    (vma->vm_flags & (VM_IO | VM_PFNMAP)) ||\n\t\t    !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t&start, &nr_pages, i, gup_flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstruct page *page;\n\t\t\tunsigned int foll_flags = gup_flags;\n\t\t\tunsigned int page_increm;\n\n\t\t\t/*\n\t\t\t * If we have a pending SIGKILL, don't keep faulting\n\t\t\t * pages and potentially allocating memory.\n\t\t\t */\n\t\t\tif (unlikely(fatal_signal_pending(current)))\n\t\t\t\treturn i ? i : -ERESTARTSYS;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page_mask(vma, start,\n\t\t\t\t\t\tfoll_flags, &page_mask))) {\n\t\t\t\tint ret;\n\t\t\t\tunsigned int fault_flags = 0;\n\n\t\t\t\t/* For mlock, just skip the stack guard page. */\n\t\t\t\tif (foll_flags & FOLL_MLOCK) {\n\t\t\t\t\tif (stack_guard_page(vma, start))\n\t\t\t\t\t\tgoto next_page;\n\t\t\t\t}\n\t\t\t\tif (foll_flags & FOLL_WRITE)\n\t\t\t\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t\t\t\tif (nonblocking)\n\t\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\t\t\t\tif (foll_flags & FOLL_NOWAIT)\n\t\t\t\t\tfault_flags |= (FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT);\n\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\t\tfault_flags);\n\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\tif (ret & (VM_FAULT_HWPOISON |\n\t\t\t\t\t\t   VM_FAULT_HWPOISON_LARGE)) {\n\t\t\t\t\t\tif (i)\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\telse if (gup_flags & FOLL_HWPOISON)\n\t\t\t\t\t\t\treturn -EHWPOISON;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\tif (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\n\t\t\t\tif (tsk) {\n\t\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\t\telse\n\t\t\t\t\t\ttsk->min_flt++;\n\t\t\t\t}\n\n\t\t\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\t\t\tif (nonblocking)\n\t\t\t\t\t\t*nonblocking = 0;\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads. But only\n\t\t\t\t * do so when looping for pte_write is futile:\n\t\t\t\t * in some cases userspace may also be wanting\n\t\t\t\t * to write to the gotten user page, which a\n\t\t\t\t * read fault here might prevent (a readonly\n\t\t\t\t * page might get reCOWed by userspace write).\n\t\t\t\t */\n\t\t\t\tif ((ret & VM_FAULT_WRITE) &&\n\t\t\t\t    !(vma->vm_flags & VM_WRITE))\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn i ? i : PTR_ERR(page);\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tpage_mask = 0;\n\t\t\t}\nnext_page:\n\t\t\tif (vmas) {\n\t\t\t\tvmas[i] = vma;\n\t\t\t\tpage_mask = 0;\n\t\t\t}\n\t\t\tpage_increm = 1 + (~(start >> PAGE_SHIFT) & page_mask);\n\t\t\tif (page_increm > nr_pages)\n\t\t\t\tpage_increm = nr_pages;\n\t\t\ti += page_increm;\n\t\t\tstart += page_increm * PAGE_SIZE;\n\t\t\tnr_pages -= page_increm;\n\t\t} while (nr_pages && start < vma->vm_end);\n\t} while (nr_pages);\n\treturn i;\n}\nEXPORT_SYMBOL(__get_user_pages);\n\n/*\n * fixup_user_fault() - manually resolve a user page fault\n * @tsk:\tthe task_struct to use for page fault accounting, or\n *\t\tNULL if faults are not to be recorded.\n * @mm:\t\tmm_struct of target mm\n * @address:\tuser address\n * @fault_flags:flags to pass down to handle_mm_fault()\n *\n * This is meant to be called in the specific scenario where for locking reasons\n * we try to access user memory in atomic context (within a pagefault_disable()\n * section), this returns -EFAULT, and we want to resolve the user fault before\n * trying again.\n *\n * Typically this is meant to be used by the futex code.\n *\n * The main difference with get_user_pages() is that this function will\n * unconditionally call handle_mm_fault() which will in turn perform all the\n * necessary SW fixup of the dirty and young bits in the PTE, while\n * handle_mm_fault() only guarantees to update these in the struct page.\n *\n * This is important for some architectures where those bits also gate the\n * access permission to the page because they are maintained in software.  On\n * such architectures, gup() will not be enough to make a subsequent access\n * succeed.\n *\n * This should be called with the mm_sem held for read.\n */\nint fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,\n\t\t     unsigned long address, unsigned int fault_flags)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\n\tvma = find_extend_vma(mm, address);\n\tif (!vma || address < vma->vm_start)\n\t\treturn -EFAULT;\n\n\tret = handle_mm_fault(mm, vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn -EHWPOISON;\n\t\tif (ret & VM_FAULT_SIGBUS)\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\treturn 0;\n}\n\n/*\n * get_user_pages() - pin user pages in memory\n * @tsk:\tthe task_struct to use for page fault accounting, or\n *\t\tNULL if faults are not to be recorded.\n * @mm:\t\tmm_struct of target mm\n * @start:\tstarting user address\n * @nr_pages:\tnumber of pages from start to pin\n * @write:\twhether pages will be written to by the caller\n * @force:\twhether to force write access even if user mapping is\n *\t\treadonly. This will result in the page being COWed even\n *\t\tin MAP_SHARED mappings. You do not want this.\n * @pages:\tarray that receives pointers to the pages pinned.\n *\t\tShould be at least nr_pages long. Or NULL, if caller\n *\t\tonly intends to ensure the pages are faulted in.\n * @vmas:\tarray of pointers to vmas corresponding to each page.\n *\t\tOr NULL if the caller does not require them.\n *\n * Returns number of pages pinned. This may be fewer than the number\n * requested. If nr_pages is 0 or negative, returns 0. If no pages\n * were pinned, returns -errno. Each page returned must be released\n * with a put_page() call when it is finished with. vmas will only\n * remain valid while mmap_sem is held.\n *\n * Must be called with mmap_sem held for read or write.\n *\n * get_user_pages walks a process's page tables and takes a reference to\n * each struct page that each user address corresponds to at a given\n * instant. That is, it takes the page that would be accessed if a user\n * thread accesses the given user virtual address at that instant.\n *\n * This does not guarantee that the page exists in the user mappings when\n * get_user_pages returns, and there may even be a completely different\n * page there in some cases (eg. if mmapped pagecache has been invalidated\n * and subsequently re faulted). However it does guarantee that the page\n * won't be freed completely. And mostly callers simply care that the page\n * contains data that was valid *at some point in time*. Typically, an IO\n * or similar operation cannot guarantee anything stronger anyway because\n * locks can't be held over the syscall boundary.\n *\n * If write=0, the page must not be written to. If the page is written to,\n * set_page_dirty (or set_page_dirty_lock, as appropriate) must be called\n * after the page is finished with, and before put_page is called.\n *\n * get_user_pages is typically used for fewer-copy IO operations, to get a\n * handle on the memory by some means other than accesses via the user virtual\n * addresses. The pages may be submitted for DMA to devices or accessed via\n * their kernel linear mapping (via the kmap APIs). Care should be taken to\n * use the correct cache flushing APIs.\n *\n * See also get_user_pages_fast, for performance critical applications.\n */\nlong get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages, int write,\n\t\tint force, struct page **pages, struct vm_area_struct **vmas)\n{\n\tint flags = FOLL_TOUCH;\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\tif (write)\n\t\tflags |= FOLL_WRITE;\n\tif (force)\n\t\tflags |= FOLL_FORCE;\n\n\treturn __get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas,\n\t\t\t\tNULL);\n}\nEXPORT_SYMBOL(get_user_pages);\n\n/**\n * get_dump_page() - pin user page in memory while writing it to core dump\n * @addr: user address\n *\n * Returns struct page pointer of user page pinned for dump,\n * to be freed afterwards by page_cache_release() or put_page().\n *\n * Returns NULL on any kind of failure - a hole must then be inserted into\n * the corefile, to preserve alignment with its headers; and also returns\n * NULL wherever the ZERO_PAGE, or an anonymous pte_none, has been found -\n * allowing a hole to be left in the corefile to save diskspace.\n *\n * Called without mmap_sem, but after all other threads have been killed.\n */\n#ifdef CONFIG_ELF_CORE\nstruct page *get_dump_page(unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\n\tif (__get_user_pages(current, current->mm, addr, 1,\n\t\t\t     FOLL_FORCE | FOLL_DUMP | FOLL_GET, &page, &vma,\n\t\t\t     NULL) < 1)\n\t\treturn NULL;\n\tflush_cache_page(vma, addr, page_to_pfn(page));\n\treturn page;\n}\n#endif /* CONFIG_ELF_CORE */\n\npte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t * pgd = pgd_offset(mm, addr);\n\tpud_t * pud = pud_alloc(mm, pgd, addr);\n\tif (pud) {\n\t\tpmd_t * pmd = pmd_alloc(mm, pud, addr);\n\t\tif (pmd) {\n\t\t\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\t\t\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n * This is the old fallback for page remapping.\n *\n * For historical reasons, it only allows reserved pages. Only\n * old drivers should use this, and they needed to mark their\n * pages reserved for the old functions anyway.\n */\nstatic int insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tretval = -EINVAL;\n\tif (PageAnon(page))\n\t\tgoto out;\n\tretval = -ENOMEM;\n\tflush_dcache_page(page);\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tget_page(page);\n\tinc_mm_counter_fast(mm, MM_FILEPAGES);\n\tpage_add_file_rmap(page);\n\tset_pte_at(mm, addr, pte, mk_pte(page, prot));\n\n\tretval = 0;\n\tpte_unmap_unlock(pte, ptl);\n\treturn retval;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}\n\n/**\n * vm_insert_page - insert single page into user vma\n * @vma: user vma to map to\n * @addr: target user address of this page\n * @page: source kernel page\n *\n * This allows drivers to insert individual pages they've allocated\n * into a user vma.\n *\n * The page has to be a nice clean _individual_ kernel allocation.\n * If you allocate a compound page, you need to have marked it as\n * such (__GFP_COMP), or manually just split the page up yourself\n * (see split_page()).\n *\n * NOTE! Traditionally this was done with \"remap_pfn_range()\" which\n * took an arbitrary page protection parameter. This doesn't allow\n * that. Your vma protection will have to be set up correctly, which\n * means that if you want a shared writable mapping, you'd better\n * ask for a shared writable mapping!\n *\n * The page does not need to be reserved.\n *\n * Usually this function is called from f_op->mmap() handler\n * under mm->mmap_sem write-lock, so it can change vma->vm_flags.\n * Caller must set VM_MIXEDMAP on vma if it wants to call this\n * function from other places, for example from page-fault handler.\n */\nint vm_insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page)\n{\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (!page_count(page))\n\t\treturn -EINVAL;\n\tif (!(vma->vm_flags & VM_MIXEDMAP)) {\n\t\tBUG_ON(down_read_trylock(&vma->vm_mm->mmap_sem));\n\t\tBUG_ON(vma->vm_flags & VM_PFNMAP);\n\t\tvma->vm_flags |= VM_MIXEDMAP;\n\t}\n\treturn insert_page(vma, addr, page, vma->vm_page_prot);\n}\nEXPORT_SYMBOL(vm_insert_page);\n\nstatic int insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tretval = -ENOMEM;\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tentry = pte_mkspecial(pfn_pte(pfn, prot));\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\n\tretval = 0;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}\n\n/**\n * vm_insert_pfn - insert single pfn into user vma\n * @vma: user vma to map to\n * @addr: target user address of this page\n * @pfn: source kernel pfn\n *\n * Similar to vm_insert_page, this allows drivers to insert individual pages\n * they've allocated into a user vma. Same comments apply.\n *\n * This function should only be called from a vm_ops->fault handler, and\n * in that case the handler should return NULL.\n *\n * vma cannot be a COW mapping.\n *\n * As this is called only for pages that do not currently exist, we\n * do not need to flush old virtual caches or the TLB.\n */\nint vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn)\n{\n\tint ret;\n\tpgprot_t pgprot = vma->vm_page_prot;\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (track_pfn_insert(vma, &pgprot, pfn))\n\t\treturn -EINVAL;\n\n\tret = insert_pfn(vma, addr, pfn, pgprot);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vm_insert_pfn);\n\nint vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn)\n{\n\tBUG_ON(!(vma->vm_flags & VM_MIXEDMAP));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we don't have pte special, then we have to use the pfn_valid()\n\t * based VM_MIXEDMAP scheme (see vm_normal_page), and thus we *must*\n\t * refcount the page if pfn_valid is true (hence insert_page rather\n\t * than insert_pfn).  If a zero_pfn were inserted into a VM_MIXEDMAP\n\t * without pte special, it would there be refcounted as a normal page.\n\t */\n\tif (!HAVE_PTE_SPECIAL && pfn_valid(pfn)) {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(pfn);\n\t\treturn insert_page(vma, addr, page, vma->vm_page_prot);\n\t}\n\treturn insert_pfn(vma, addr, pfn, vma->vm_page_prot);\n}\nEXPORT_SYMBOL(vm_insert_mixed);\n\n/*\n * maps a range of physical memory into the requested pages. the old\n * mappings are removed. any references to nonexistent pages results\n * in null mappings (currently treated as \"copy-on-access\")\n */\nstatic int remap_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tpte = pte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\tBUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, addr, pte, pte_mkspecial(pfn_pte(pfn, prot)));\n\t\tpfn++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\treturn 0;\n}\n\nstatic inline int remap_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (remap_pte_range(mm, pmd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot))\n\t\t\treturn -ENOMEM;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}\n\nstatic inline int remap_pud_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpfn -= addr >> PAGE_SHIFT;\n\tpud = pud_alloc(mm, pgd, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (remap_pmd_range(mm, pud, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot))\n\t\t\treturn -ENOMEM;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}\n\n/**\n * remap_pfn_range - remap kernel memory to userspace\n * @vma: user vma to map to\n * @addr: target user address to start at\n * @pfn: physical address of kernel memory\n * @size: size of map area\n * @prot: page protection flags for this mapping\n *\n *  Note: this is only safe if the mm semaphore is held when called.\n */\nint remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t    unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\t/*\n\t * Physically remapped pages are special. Tell the\n\t * rest of the world about it:\n\t *   VM_IO tells people not to look at these pages\n\t *\t(accesses can have side effects).\n\t *   VM_PFNMAP tells the core MM that the base pages are just\n\t *\traw PFN mappings, and do not have a \"struct page\" associated\n\t *\twith them.\n\t *   VM_DONTEXPAND\n\t *      Disable vma merging and expanding with mremap().\n\t *   VM_DONTDUMP\n\t *      Omit vma from core dump, even when VM_IO turned off.\n\t *\n\t * There's a horrible special case to handle copy-on-write\n\t * behaviour that some programs depend on. We mark the \"original\"\n\t * un-COW'ed pages by matching them up with \"vma->vm_pgoff\".\n\t * See vm_normal_page() for details.\n\t */\n\tif (is_cow_mapping(vma->vm_flags)) {\n\t\tif (addr != vma->vm_start || end != vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tvma->vm_pgoff = pfn;\n\t}\n\n\terr = track_pfn_remap(vma, &prot, pfn, addr, PAGE_ALIGN(size));\n\tif (err)\n\t\treturn -EINVAL;\n\n\tvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\n\n\tBUG_ON(addr >= end);\n\tpfn -= addr >> PAGE_SHIFT;\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, pgd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\tif (err)\n\t\tuntrack_pfn(vma, pfn, PAGE_ALIGN(size));\n\n\treturn err;\n}\nEXPORT_SYMBOL(remap_pfn_range);\n\n/**\n * vm_iomap_memory - remap memory to userspace\n * @vma: user vma to map to\n * @start: start of area\n * @len: size of area\n *\n * This is a simplified io_remap_pfn_range() for common driver use. The\n * driver just needs to give us the physical memory range to be mapped,\n * we'll figure out the rest from the vma information.\n *\n * NOTE! Some drivers might want to tweak vma->vm_page_prot first to get\n * whatever write-combining details or similar.\n */\nint vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)\n{\n\tunsigned long vm_len, pfn, pages;\n\n\t/* Check that the physical memory area passed in looks valid */\n\tif (start + len < start)\n\t\treturn -EINVAL;\n\t/*\n\t * You *really* shouldn't map things that aren't page-aligned,\n\t * but we've historically allowed it because IO memory might\n\t * just have smaller alignment.\n\t */\n\tlen += start & ~PAGE_MASK;\n\tpfn = start >> PAGE_SHIFT;\n\tpages = (len + ~PAGE_MASK) >> PAGE_SHIFT;\n\tif (pfn + pages < pfn)\n\t\treturn -EINVAL;\n\n\t/* We start the mapping 'vm_pgoff' pages into the area */\n\tif (vma->vm_pgoff > pages)\n\t\treturn -EINVAL;\n\tpfn += vma->vm_pgoff;\n\tpages -= vma->vm_pgoff;\n\n\t/* Can we fit all of the mapping? */\n\tvm_len = vma->vm_end - vma->vm_start;\n\tif (vm_len >> PAGE_SHIFT > pages)\n\t\treturn -EINVAL;\n\n\t/* Ok, let it rip */\n\treturn io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);\n}\nEXPORT_SYMBOL(vm_iomap_memory);\n\nstatic int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpte_t *pte;\n\tint err;\n\tpgtable_t token;\n\tspinlock_t *uninitialized_var(ptl);\n\n\tpte = (mm == &init_mm) ?\n\t\tpte_alloc_kernel(pmd, addr) :\n\t\tpte_alloc_map_lock(mm, pmd, addr, &ptl);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(pmd_huge(*pmd));\n\n\tarch_enter_lazy_mmu_mode();\n\n\ttoken = pmd_pgtable(*pmd);\n\n\tdo {\n\t\terr = fn(pte++, token, addr, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\n\tif (mm != &init_mm)\n\t\tpte_unmap_unlock(pte-1, ptl);\n\treturn err;\n}\n\nstatic int apply_to_pmd_range(struct mm_struct *mm, pud_t *pud,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err;\n\n\tBUG_ON(pud_huge(*pud));\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\terr = apply_to_pte_range(mm, pmd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\treturn err;\n}\n\nstatic int apply_to_pud_range(struct mm_struct *mm, pgd_t *pgd,\n\t\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t\t     pte_fn_t fn, void *data)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tint err;\n\n\tpud = pud_alloc(mm, pgd, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\terr = apply_to_pmd_range(mm, pud, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pud++, addr = next, addr != end);\n\treturn err;\n}\n\n/*\n * Scan a region of virtual memory, filling in page tables as necessary\n * and calling a provided function on each leaf page table.\n */\nint apply_to_page_range(struct mm_struct *mm, unsigned long addr,\n\t\t\tunsigned long size, pte_fn_t fn, void *data)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + size;\n\tint err;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset(mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = apply_to_pud_range(mm, pgd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(apply_to_page_range);\n\n/*\n * handle_pte_fault chooses page fault handler according to an entry\n * which was read non-atomically.  Before making any commitment, on\n * those architectures or configurations (e.g. i386 with PAE) which\n * might give a mix of unmatched parts, do_swap_page and do_nonlinear_fault\n * must check under lock before unmapping the pte and proceeding\n * (but do_wp_page is only called after already making such a check;\n * and do_anonymous_page can safely check later on).\n */\nstatic inline int pte_unmap_same(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tpte_t *page_table, pte_t orig_pte)\n{\n\tint same = 1;\n#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)\n\tif (sizeof(pte_t) > sizeof(unsigned long)) {\n\t\tspinlock_t *ptl = pte_lockptr(mm, pmd);\n\t\tspin_lock(ptl);\n\t\tsame = pte_same(*page_table, orig_pte);\n\t\tspin_unlock(ptl);\n\t}\n#endif\n\tpte_unmap(page_table);\n\treturn same;\n}\n\nstatic inline void cow_user_page(struct page *dst, struct page *src, unsigned long va, struct vm_area_struct *vma)\n{\n\t/*\n\t * If the source page was a PFN mapping, we don't have\n\t * a \"struct page\" for it. We do a best-effort copy by\n\t * just copying from the original user address. If that\n\t * fails, we just zero-fill it. Live with it.\n\t */\n\tif (unlikely(!src)) {\n\t\tvoid *kaddr = kmap_atomic(dst);\n\t\tvoid __user *uaddr = (void __user *)(va & PAGE_MASK);\n\n\t\t/*\n\t\t * This really shouldn't fail, because the page is there\n\t\t * in the page tables. But it might just be unreadable,\n\t\t * in which case we just give up and fill the result with\n\t\t * zeroes.\n\t\t */\n\t\tif (__copy_from_user_inatomic(kaddr, uaddr, PAGE_SIZE))\n\t\t\tclear_page(kaddr);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(dst);\n\t} else\n\t\tcopy_user_highpage(dst, src, va, vma);\n}\n\n/*\n * This routine handles present pages, when users try to write\n * to a shared page. It is done by copying the page to a new address\n * and decrementing the shared-page counter for the old page.\n *\n * Note that this routine assumes that the protection checks have been\n * done by the caller (the low-level page fault routine in most cases).\n * Thus we can safely just mark it writable once we've done any necessary\n * COW.\n *\n * We also mark the page dirty at this point even though the page will\n * change only once the write actually happens. This avoids a few races,\n * and potentially makes it more efficient.\n *\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), with pte both mapped and locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int do_wp_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tspinlock_t *ptl, pte_t orig_pte)\n\t__releases(ptl)\n{\n\tstruct page *old_page, *new_page = NULL;\n\tpte_t entry;\n\tint ret = 0;\n\tint page_mkwrite = 0;\n\tstruct page *dirty_page = NULL;\n\tunsigned long mmun_start = 0;\t/* For mmu_notifiers */\n\tunsigned long mmun_end = 0;\t/* For mmu_notifiers */\n\n\told_page = vm_normal_page(vma, address, orig_pte);\n\tif (!old_page) {\n\t\t/*\n\t\t * VM_MIXEDMAP !pfn_valid() case\n\t\t *\n\t\t * We should not cow pages in a shared writeable mapping.\n\t\t * Just mark the pages writable as we can't do any dirty\n\t\t * accounting on raw pfn maps.\n\t\t */\n\t\tif ((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t     (VM_WRITE|VM_SHARED))\n\t\t\tgoto reuse;\n\t\tgoto gotten;\n\t}\n\n\t/*\n\t * Take out anonymous pages first, anonymous shared vmas are\n\t * not dirty accountable.\n\t */\n\tif (PageAnon(old_page) && !PageKsm(old_page)) {\n\t\tif (!trylock_page(old_page)) {\n\t\t\tpage_cache_get(old_page);\n\t\t\tpte_unmap_unlock(page_table, ptl);\n\t\t\tlock_page(old_page);\n\t\t\tpage_table = pte_offset_map_lock(mm, pmd, address,\n\t\t\t\t\t\t\t &ptl);\n\t\t\tif (!pte_same(*page_table, orig_pte)) {\n\t\t\t\tunlock_page(old_page);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tpage_cache_release(old_page);\n\t\t}\n\t\tif (reuse_swap_page(old_page)) {\n\t\t\t/*\n\t\t\t * The page is all ours.  Move it to our anon_vma so\n\t\t\t * the rmap code will not search our parent or siblings.\n\t\t\t * Protected against the rmap code by the page lock.\n\t\t\t */\n\t\t\tpage_move_anon_rmap(old_page, vma, address);\n\t\t\tunlock_page(old_page);\n\t\t\tgoto reuse;\n\t\t}\n\t\tunlock_page(old_page);\n\t} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==\n\t\t\t\t\t(VM_WRITE|VM_SHARED))) {\n\t\t/*\n\t\t * Only catch write-faults on shared writable pages,\n\t\t * read-only shared pages can get COWed by\n\t\t * get_user_pages(.write=1, .force=1).\n\t\t */\n\t\tif (vma->vm_ops && vma->vm_ops->page_mkwrite) {\n\t\t\tstruct vm_fault vmf;\n\t\t\tint tmp;\n\n\t\t\tvmf.virtual_address = (void __user *)(address &\n\t\t\t\t\t\t\t\tPAGE_MASK);\n\t\t\tvmf.pgoff = old_page->index;\n\t\t\tvmf.flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\t\t\tvmf.page = old_page;\n\n\t\t\t/*\n\t\t\t * Notify the address space that the page is about to\n\t\t\t * become writable so that it can prohibit this or wait\n\t\t\t * for the page to get into an appropriate state.\n\t\t\t *\n\t\t\t * We do this without the lock held, so that it can\n\t\t\t * sleep if it needs to.\n\t\t\t */\n\t\t\tpage_cache_get(old_page);\n\t\t\tpte_unmap_unlock(page_table, ptl);\n\n\t\t\ttmp = vma->vm_ops->page_mkwrite(vma, &vmf);\n\t\t\tif (unlikely(tmp &\n\t\t\t\t\t(VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\t\tret = tmp;\n\t\t\t\tgoto unwritable_page;\n\t\t\t}\n\t\t\tif (unlikely(!(tmp & VM_FAULT_LOCKED))) {\n\t\t\t\tlock_page(old_page);\n\t\t\t\tif (!old_page->mapping) {\n\t\t\t\t\tret = 0; /* retry the fault */\n\t\t\t\t\tunlock_page(old_page);\n\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tVM_BUG_ON(!PageLocked(old_page));\n\n\t\t\t/*\n\t\t\t * Since we dropped the lock we need to revalidate\n\t\t\t * the PTE as someone else may have changed it.  If\n\t\t\t * they did, we just return, as we can count on the\n\t\t\t * MMU to tell us if they didn't also make it writable.\n\t\t\t */\n\t\t\tpage_table = pte_offset_map_lock(mm, pmd, address,\n\t\t\t\t\t\t\t &ptl);\n\t\t\tif (!pte_same(*page_table, orig_pte)) {\n\t\t\t\tunlock_page(old_page);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tpage_mkwrite = 1;\n\t\t}\n\t\tdirty_page = old_page;\n\t\tget_page(dirty_page);\n\nreuse:\n\t\tflush_cache_page(vma, address, pte_pfn(orig_pte));\n\t\tentry = pte_mkyoung(orig_pte);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tif (ptep_set_access_flags(vma, address, page_table, entry,1))\n\t\t\tupdate_mmu_cache(vma, address, page_table);\n\t\tpte_unmap_unlock(page_table, ptl);\n\t\tret |= VM_FAULT_WRITE;\n\n\t\tif (!dirty_page)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * Yes, Virginia, this is actually required to prevent a race\n\t\t * with clear_page_dirty_for_io() from clearing the page dirty\n\t\t * bit after it clear all dirty ptes, but before a racing\n\t\t * do_wp_page installs a dirty pte.\n\t\t *\n\t\t * __do_fault is protected similarly.\n\t\t */\n\t\tif (!page_mkwrite) {\n\t\t\twait_on_page_locked(dirty_page);\n\t\t\tset_page_dirty_balance(dirty_page, page_mkwrite);\n\t\t\t/* file_update_time outside page_lock */\n\t\t\tif (vma->vm_file)\n\t\t\t\tfile_update_time(vma->vm_file);\n\t\t}\n\t\tput_page(dirty_page);\n\t\tif (page_mkwrite) {\n\t\t\tstruct address_space *mapping = dirty_page->mapping;\n\n\t\t\tset_page_dirty(dirty_page);\n\t\t\tunlock_page(dirty_page);\n\t\t\tpage_cache_release(dirty_page);\n\t\t\tif (mapping)\t{\n\t\t\t\t/*\n\t\t\t\t * Some device drivers do not set page.mapping\n\t\t\t\t * but still dirty their pages\n\t\t\t\t */\n\t\t\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Ok, we need to copy. Oh, well..\n\t */\n\tpage_cache_get(old_page);\ngotten:\n\tpte_unmap_unlock(page_table, ptl);\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\n\tif (is_zero_pfn(pte_pfn(orig_pte))) {\n\t\tnew_page = alloc_zeroed_user_highpage_movable(vma, address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t} else {\n\t\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\t\tif (!new_page)\n\t\t\tgoto oom;\n\t\tcow_user_page(new_page, old_page, address, vma);\n\t}\n\t__SetPageUptodate(new_page);\n\n\tif (mem_cgroup_newpage_charge(new_page, mm, GFP_KERNEL))\n\t\tgoto oom_free_new;\n\n\tmmun_start  = address & PAGE_MASK;\n\tmmun_end    = mmun_start + PAGE_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * Re-check the pte - we dropped the lock\n\t */\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (likely(pte_same(*page_table, orig_pte))) {\n\t\tif (old_page) {\n\t\t\tif (!PageAnon(old_page)) {\n\t\t\t\tdec_mm_counter_fast(mm, MM_FILEPAGES);\n\t\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\t}\n\t\t} else\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\tflush_cache_page(vma, address, pte_pfn(orig_pte));\n\t\tentry = mk_pte(new_page, vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\t/*\n\t\t * Clear the pte entry and flush it first, before updating the\n\t\t * pte with the new entry. This will avoid a race condition\n\t\t * seen in the presence of one thread doing SMC and another\n\t\t * thread doing COW.\n\t\t */\n\t\tptep_clear_flush(vma, address, page_table);\n\t\tpage_add_new_anon_rmap(new_page, vma, address);\n\t\t/*\n\t\t * We call the notify macro here because, when using secondary\n\t\t * mmu page tables (such as kvm shadow page tables), we want the\n\t\t * new page to be mapped directly into the secondary page table.\n\t\t */\n\t\tset_pte_at_notify(mm, address, page_table, entry);\n\t\tupdate_mmu_cache(vma, address, page_table);\n\t\tif (old_page) {\n\t\t\t/*\n\t\t\t * Only after switching the pte to the new page may\n\t\t\t * we remove the mapcount here. Otherwise another\n\t\t\t * process may come and find the rmap count decremented\n\t\t\t * before the pte is switched to the new page, and\n\t\t\t * \"reuse\" the old page writing into it while our pte\n\t\t\t * here still points into it and can be read by other\n\t\t\t * threads.\n\t\t\t *\n\t\t\t * The critical issue is to order this\n\t\t\t * page_remove_rmap with the ptp_clear_flush above.\n\t\t\t * Those stores are ordered by (if nothing else,)\n\t\t\t * the barrier present in the atomic_add_negative\n\t\t\t * in page_remove_rmap.\n\t\t\t *\n\t\t\t * Then the TLB flush in ptep_clear_flush ensures that\n\t\t\t * no process can access the old page before the\n\t\t\t * decremented mapcount is visible. And the old page\n\t\t\t * cannot be reused until after the decremented\n\t\t\t * mapcount is visible. So transitively, TLBs to\n\t\t\t * old page will be flushed before it can be reused.\n\t\t\t */\n\t\t\tpage_remove_rmap(old_page);\n\t\t}\n\n\t\t/* Free the old page.. */\n\t\tnew_page = old_page;\n\t\tret |= VM_FAULT_WRITE;\n\t} else\n\t\tmem_cgroup_uncharge_page(new_page);\n\n\tif (new_page)\n\t\tpage_cache_release(new_page);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\tif (mmun_end > mmun_start)\n\t\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tif (old_page) {\n\t\t/*\n\t\t * Don't let another task, with possibly unlocked vma,\n\t\t * keep the mlocked page.\n\t\t */\n\t\tif ((ret & VM_FAULT_WRITE) && (vma->vm_flags & VM_LOCKED)) {\n\t\t\tlock_page(old_page);\t/* LRU manipulation */\n\t\t\tmunlock_vma_page(old_page);\n\t\t\tunlock_page(old_page);\n\t\t}\n\t\tpage_cache_release(old_page);\n\t}\n\treturn ret;\noom_free_new:\n\tpage_cache_release(new_page);\noom:\n\tif (old_page)\n\t\tpage_cache_release(old_page);\n\treturn VM_FAULT_OOM;\n\nunwritable_page:\n\tpage_cache_release(old_page);\n\treturn ret;\n}\n\nstatic void unmap_mapping_range_vma(struct vm_area_struct *vma,\n\t\tunsigned long start_addr, unsigned long end_addr,\n\t\tstruct zap_details *details)\n{\n\tzap_page_range_single(vma, start_addr, end_addr - start_addr, details);\n}\n\nstatic inline void unmap_mapping_range_tree(struct rb_root *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + ((vma->vm_end - vma->vm_start) >> PAGE_SHIFT) - 1;\n\t\t/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}\n\nstatic inline void unmap_mapping_range_list(struct list_head *head,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In nonlinear VMAs there is no correspondence between virtual address\n\t * offset and file offset.  So we must perform an exhaustive search\n\t * across *all* the pages in each nonlinear VMA, not just the pages\n\t * whose virtual address lies outside the file truncation point.\n\t */\n\tlist_for_each_entry(vma, head, shared.nonlinear) {\n\t\tdetails->nonlinear_vma = vma;\n\t\tunmap_mapping_range_vma(vma, vma->vm_start, vma->vm_end, details);\n\t}\n}\n\n/**\n * unmap_mapping_range - unmap the portion of all mmaps in the specified address_space corresponding to the specified page range in the underlying file.\n * @mapping: the address space containing mmaps to be unmapped.\n * @holebegin: byte in first page to unmap, relative to the start of\n * the underlying file.  This will be rounded down to a PAGE_SIZE\n * boundary.  Note that this is different from truncate_pagecache(), which\n * must keep the partial page.  In contrast, we must get rid of\n * partial pages.\n * @holelen: size of prospective hole in bytes.  This will be rounded\n * up to a PAGE_SIZE boundary.  A holelen of zero truncates to the\n * end of the file.\n * @even_cows: 1 when truncating a file, unmap even private COWed pages;\n * but 0 when invalidating pagecache, don't throw away private data.\n */\nvoid unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tstruct zap_details details;\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tdetails.check_mapping = even_cows? NULL: mapping;\n\tdetails.nonlinear_vma = NULL;\n\tdetails.first_index = hba;\n\tdetails.last_index = hba + hlen - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\n\tmutex_lock(&mapping->i_mmap_mutex);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\tif (unlikely(!list_empty(&mapping->i_mmap_nonlinear)))\n\t\tunmap_mapping_range_list(&mapping->i_mmap_nonlinear, &details);\n\tmutex_unlock(&mapping->i_mmap_mutex);\n}\nEXPORT_SYMBOL(unmap_mapping_range);\n\n/*\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte mapped but not yet locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int do_swap_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tspinlock_t *ptl;\n\tstruct page *page, *swapcache;\n\tswp_entry_t entry;\n\tpte_t pte;\n\tint locked;\n\tstruct mem_cgroup *ptr;\n\tint exclusive = 0;\n\tint ret = 0;\n\n\tif (!pte_unmap_same(mm, pmd, page_table, orig_pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(orig_pte);\n\tif (unlikely(non_swap_entry(entry))) {\n\t\tif (is_migration_entry(entry)) {\n\t\t\tmigration_entry_wait(mm, pmd, address);\n\t\t} else if (is_hwpoison_entry(entry)) {\n\t\t\tret = VM_FAULT_HWPOISON;\n\t\t} else {\n\t\t\tprint_bad_pte(vma, address, orig_pte, NULL);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t}\n\t\tgoto out;\n\t}\n\tdelayacct_set_flag(DELAYACCT_PF_SWAPIN);\n\tpage = lookup_swap_cache(entry);\n\tif (!page) {\n\t\tpage = swapin_readahead(entry,\n\t\t\t\t\tGFP_HIGHUSER_MOVABLE, vma, address);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Back out if somebody else faulted in this pte\n\t\t\t * while we released the pte lock.\n\t\t\t */\n\t\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\t\t\tif (likely(pte_same(*page_table, orig_pte)))\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/* Had to read the page from swap area: Major fault */\n\t\tret = VM_FAULT_MAJOR;\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tmem_cgroup_count_vm_event(mm, PGMAJFAULT);\n\t} else if (PageHWPoison(page)) {\n\t\t/*\n\t\t * hwpoisoned dirty swapcache pages are kept for killing\n\t\t * owner processes (which may be unknown at hwpoison time)\n\t\t */\n\t\tret = VM_FAULT_HWPOISON;\n\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\tswapcache = page;\n\t\tgoto out_release;\n\t}\n\n\tswapcache = page;\n\tlocked = lock_page_or_retry(page, mm, flags);\n\n\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\tif (!locked) {\n\t\tret |= VM_FAULT_RETRY;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Make sure try_to_free_swap or reuse_swap_page or swapoff did not\n\t * release the swapcache from under us.  The page pin, and pte_same\n\t * test below, are not enough to exclude that.  Even if it is still\n\t * swapcache, we need to check that the page's swap has not changed.\n\t */\n\tif (unlikely(!PageSwapCache(page) || page_private(page) != entry.val))\n\t\tgoto out_page;\n\n\tpage = ksm_might_need_to_copy(page, vma, address);\n\tif (unlikely(!page)) {\n\t\tret = VM_FAULT_OOM;\n\t\tpage = swapcache;\n\t\tgoto out_page;\n\t}\n\n\tif (mem_cgroup_try_charge_swapin(mm, page, GFP_KERNEL, &ptr)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_page;\n\t}\n\n\t/*\n\t * Back out if somebody else already faulted in this pte.\n\t */\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (unlikely(!pte_same(*page_table, orig_pte)))\n\t\tgoto out_nomap;\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_nomap;\n\t}\n\n\t/*\n\t * The page isn't present yet, go ahead with the fault.\n\t *\n\t * Be careful about the sequence of operations here.\n\t * To get its accounting right, reuse_swap_page() must be called\n\t * while the page is counted on swap but not yet in mapcount i.e.\n\t * before page_add_anon_rmap() and swap_free(); try_to_free_swap()\n\t * must be called after the swap_free(), or it will never succeed.\n\t * Because delete_from_swap_page() may be called by reuse_swap_page(),\n\t * mem_cgroup_commit_charge_swapin() may not be able to find swp_entry\n\t * in page->private. In this case, a record in swap_cgroup  is silently\n\t * discarded at swap_free().\n\t */\n\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tdec_mm_counter_fast(mm, MM_SWAPENTS);\n\tpte = mk_pte(page, vma->vm_page_prot);\n\tif ((flags & FAULT_FLAG_WRITE) && reuse_swap_page(page)) {\n\t\tpte = maybe_mkwrite(pte_mkdirty(pte), vma);\n\t\tflags &= ~FAULT_FLAG_WRITE;\n\t\tret |= VM_FAULT_WRITE;\n\t\texclusive = 1;\n\t}\n\tflush_icache_page(vma, page);\n\tset_pte_at(mm, address, page_table, pte);\n\tif (page == swapcache)\n\t\tdo_page_add_anon_rmap(page, vma, address, exclusive);\n\telse /* ksm created a completely new copy */\n\t\tpage_add_new_anon_rmap(page, vma, address);\n\t/* It's better to call commit-charge after rmap is established */\n\tmem_cgroup_commit_charge_swapin(page, ptr);\n\n\tswap_free(entry);\n\tif (vm_swap_full() || (vma->vm_flags & VM_LOCKED) || PageMlocked(page))\n\t\ttry_to_free_swap(page);\n\tunlock_page(page);\n\tif (page != swapcache) {\n\t\t/*\n\t\t * Hold the lock to avoid the swap entry to be reused\n\t\t * until we take the PT lock for the pte_same() check\n\t\t * (to avoid false positives from pte_same). For\n\t\t * further safety release the lock after the swap_free\n\t\t * so that the swap count won't change under a\n\t\t * parallel locked swapcache.\n\t\t */\n\t\tunlock_page(swapcache);\n\t\tpage_cache_release(swapcache);\n\t}\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tret |= do_wp_page(mm, vma, address, page_table, pmd, ptl, pte);\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tret &= VM_FAULT_ERROR;\n\t\tgoto out;\n\t}\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\nout:\n\treturn ret;\nout_nomap:\n\tmem_cgroup_cancel_charge_swapin(ptr);\n\tpte_unmap_unlock(page_table, ptl);\nout_page:\n\tunlock_page(page);\nout_release:\n\tpage_cache_release(page);\n\tif (page != swapcache) {\n\t\tunlock_page(swapcache);\n\t\tpage_cache_release(swapcache);\n\t}\n\treturn ret;\n}\n\n/*\n * This is like a special single-page \"expand_{down|up}wards()\",\n * except we must first make sure that 'address{-|+}PAGE_SIZE'\n * doesn't hit another vma.\n */\nstatic inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)\n{\n\taddress &= PAGE_MASK;\n\tif ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {\n\t\tstruct vm_area_struct *prev = vma->vm_prev;\n\n\t\t/*\n\t\t * Is there a mapping abutting this one below?\n\t\t *\n\t\t * That's only ok if it's the same stack mapping\n\t\t * that has gotten split..\n\t\t */\n\t\tif (prev && prev->vm_end == address)\n\t\t\treturn prev->vm_flags & VM_GROWSDOWN ? 0 : -ENOMEM;\n\n\t\texpand_downwards(vma, address - PAGE_SIZE);\n\t}\n\tif ((vma->vm_flags & VM_GROWSUP) && address + PAGE_SIZE == vma->vm_end) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\n\t\t/* As VM_GROWSDOWN but s/below/above/ */\n\t\tif (next && next->vm_start == address + PAGE_SIZE)\n\t\t\treturn next->vm_flags & VM_GROWSUP ? 0 : -ENOMEM;\n\n\t\texpand_upwards(vma, address + PAGE_SIZE);\n\t}\n\treturn 0;\n}\n\n/*\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte mapped but not yet locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tpte_unmap(page_table);\n\n\t/* Check if we need to add a guard page to the stack */\n\tif (check_stack_guard_page(vma, address) < 0)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/* Use the zero-page for reads */\n\tif (!(flags & FAULT_FLAG_WRITE)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\t__SetPageUptodate(page);\n\n\tif (mem_cgroup_newpage_charge(page, mm, GFP_KERNEL))\n\t\tgoto oom_free_page;\n\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_uncharge_page(page);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}\n\n/*\n * __do_fault() tries to create a new page mapping. It aggressively\n * tries to share with existing pages, but makes a separate copy if\n * the FAULT_FLAG_WRITE is set in the flags parameter in order to avoid\n * the next page fault.\n *\n * As this is called only for pages that do not currently exist, we\n * do not need to flush old virtual caches or the TLB.\n *\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte neither mapped nor locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int __do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd,\n\t\tpgoff_t pgoff, unsigned int flags, pte_t orig_pte)\n{\n\tpte_t *page_table;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct page *cow_page;\n\tpte_t entry;\n\tint anon = 0;\n\tstruct page *dirty_page = NULL;\n\tstruct vm_fault vmf;\n\tint ret;\n\tint page_mkwrite = 0;\n\n\t/*\n\t * If we do COW later, allocate page befor taking lock_page()\n\t * on the file cache page. This will reduce lock holding time.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\n\t\tif (unlikely(anon_vma_prepare(vma)))\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tcow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\t\tif (!cow_page)\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tif (mem_cgroup_newpage_charge(cow_page, mm, GFP_KERNEL)) {\n\t\t\tpage_cache_release(cow_page);\n\t\t\treturn VM_FAULT_OOM;\n\t\t}\n\t} else\n\t\tcow_page = NULL;\n\n\tvmf.virtual_address = (void __user *)(address & PAGE_MASK);\n\tvmf.pgoff = pgoff;\n\tvmf.flags = flags;\n\tvmf.page = NULL;\n\n\tret = vma->vm_ops->fault(vma, &vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t    VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\n\tif (unlikely(PageHWPoison(vmf.page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf.page);\n\t\tret = VM_FAULT_HWPOISON;\n\t\tgoto uncharge_out;\n\t}\n\n\t/*\n\t * For consistency in subsequent calls, make the faulted page always\n\t * locked.\n\t */\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf.page);\n\telse\n\t\tVM_BUG_ON(!PageLocked(vmf.page));\n\n\t/*\n\t * Should we do an early C-O-W break?\n\t */\n\tpage = vmf.page;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!(vma->vm_flags & VM_SHARED)) {\n\t\t\tpage = cow_page;\n\t\t\tanon = 1;\n\t\t\tcopy_user_highpage(page, vmf.page, address, vma);\n\t\t\t__SetPageUptodate(page);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If the page will be shareable, see if the backing\n\t\t\t * address space wants to know that the page is about\n\t\t\t * to become writable\n\t\t\t */\n\t\t\tif (vma->vm_ops->page_mkwrite) {\n\t\t\t\tint tmp;\n\n\t\t\t\tunlock_page(page);\n\t\t\t\tvmf.flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\t\t\t\ttmp = vma->vm_ops->page_mkwrite(vma, &vmf);\n\t\t\t\tif (unlikely(tmp &\n\t\t\t\t\t  (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\t\t\tret = tmp;\n\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t}\n\t\t\t\tif (unlikely(!(tmp & VM_FAULT_LOCKED))) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\tif (!page->mapping) {\n\t\t\t\t\t\tret = 0; /* retry the fault */\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tVM_BUG_ON(!PageLocked(page));\n\t\t\t\tpage_mkwrite = 1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\t/*\n\t * This silly early PAGE_DIRTY setting removes a race\n\t * due to the bad i386 page protection. But it's valid\n\t * for other architectures too.\n\t *\n\t * Note that if FAULT_FLAG_WRITE is set, we either now have\n\t * an exclusive copy of the page, or this is a shared mapping,\n\t * so we can make it writable and dirty to avoid having to\n\t * handle that later.\n\t */\n\t/* Only go through if we didn't race with anybody else... */\n\tif (likely(pte_same(*page_table, orig_pte))) {\n\t\tflush_icache_page(vma, page);\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tif (anon) {\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\tpage_add_new_anon_rmap(page, vma, address);\n\t\t} else {\n\t\t\tinc_mm_counter_fast(mm, MM_FILEPAGES);\n\t\t\tpage_add_file_rmap(page);\n\t\t\tif (flags & FAULT_FLAG_WRITE) {\n\t\t\t\tdirty_page = page;\n\t\t\t\tget_page(dirty_page);\n\t\t\t}\n\t\t}\n\t\tset_pte_at(mm, address, page_table, entry);\n\n\t\t/* no need to invalidate: a not-present page won't be cached */\n\t\tupdate_mmu_cache(vma, address, page_table);\n\t} else {\n\t\tif (cow_page)\n\t\t\tmem_cgroup_uncharge_page(cow_page);\n\t\tif (anon)\n\t\t\tpage_cache_release(page);\n\t\telse\n\t\t\tanon = 1; /* no anon but release faulted_page */\n\t}\n\n\tpte_unmap_unlock(page_table, ptl);\n\n\tif (dirty_page) {\n\t\tstruct address_space *mapping = page->mapping;\n\t\tint dirtied = 0;\n\n\t\tif (set_page_dirty(dirty_page))\n\t\t\tdirtied = 1;\n\t\tunlock_page(dirty_page);\n\t\tput_page(dirty_page);\n\t\tif ((dirtied || page_mkwrite) && mapping) {\n\t\t\t/*\n\t\t\t * Some device drivers do not set page.mapping but still\n\t\t\t * dirty their pages\n\t\t\t */\n\t\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\t}\n\n\t\t/* file_update_time outside page_lock */\n\t\tif (vma->vm_file && !page_mkwrite)\n\t\t\tfile_update_time(vma->vm_file);\n\t} else {\n\t\tunlock_page(vmf.page);\n\t\tif (anon)\n\t\t\tpage_cache_release(vmf.page);\n\t}\n\n\treturn ret;\n\nunwritable_page:\n\tpage_cache_release(page);\n\treturn ret;\nuncharge_out:\n\t/* fs's fault handler get error */\n\tif (cow_page) {\n\t\tmem_cgroup_uncharge_page(cow_page);\n\t\tpage_cache_release(cow_page);\n\t}\n\treturn ret;\n}\n\nstatic int do_linear_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tpte_unmap(page_table);\n\treturn __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}\n\n/*\n * Fault of a previously existing named mapping. Repopulate the pte\n * from the encoded file_pte if possible. This enables swappable\n * nonlinear vmas.\n *\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte mapped but not yet locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nstatic int do_nonlinear_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff;\n\n\tflags |= FAULT_FLAG_NONLINEAR;\n\n\tif (!pte_unmap_same(mm, pmd, page_table, orig_pte))\n\t\treturn 0;\n\n\tif (unlikely(!(vma->vm_flags & VM_NONLINEAR))) {\n\t\t/*\n\t\t * Page table corrupted: show pte and kill process.\n\t\t */\n\t\tprint_bad_pte(vma, address, orig_pte, NULL);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tpgoff = pte_to_pgoff(orig_pte);\n\treturn __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}\n\nint numa_migrate_prep(struct page *page, struct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, int current_nid)\n{\n\tget_page(page);\n\n\tcount_vm_numa_event(NUMA_HINT_FAULTS);\n\tif (current_nid == numa_node_id())\n\t\tcount_vm_numa_event(NUMA_HINT_FAULTS_LOCAL);\n\n\treturn mpol_misplaced(page, vma, addr);\n}\n\nint do_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t   unsigned long addr, pte_t pte, pte_t *ptep, pmd_t *pmd)\n{\n\tstruct page *page = NULL;\n\tspinlock_t *ptl;\n\tint current_nid = -1;\n\tint target_nid;\n\tbool migrated = false;\n\n\t/*\n\t* The \"pte\" at this point cannot be used safely without\n\t* validation through pte_unmap_same(). It's of NUMA type but\n\t* the pfn may be screwed if the read is non atomic.\n\t*\n\t* ptep_modify_prot_start is not called as this is clearing\n\t* the _PAGE_NUMA bit and it is not really expected that there\n\t* would be concurrent hardware modifications to the PTE.\n\t*/\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*ptep, pte))) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tgoto out;\n\t}\n\n\tpte = pte_mknonnuma(pte);\n\tset_pte_at(mm, addr, ptep, pte);\n\tupdate_mmu_cache(vma, addr, ptep);\n\n\tpage = vm_normal_page(vma, addr, pte);\n\tif (!page) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn 0;\n\t}\n\n\tcurrent_nid = page_to_nid(page);\n\ttarget_nid = numa_migrate_prep(page, vma, addr, current_nid);\n\tpte_unmap_unlock(ptep, ptl);\n\tif (target_nid == -1) {\n\t\t/*\n\t\t * Account for the fault against the current node if it not\n\t\t * being replaced regardless of where the page is located.\n\t\t */\n\t\tcurrent_nid = numa_node_id();\n\t\tput_page(page);\n\t\tgoto out;\n\t}\n\n\t/* Migrate to the requested node */\n\tmigrated = migrate_misplaced_page(page, target_nid);\n\tif (migrated)\n\t\tcurrent_nid = target_nid;\n\nout:\n\tif (current_nid != -1)\n\t\ttask_numa_fault(current_nid, 1, migrated);\n\treturn 0;\n}\n\n/* NUMA hinting page fault entry point for regular pmds */\n#ifdef CONFIG_NUMA_BALANCING\nstatic int do_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t     unsigned long addr, pmd_t *pmdp)\n{\n\tpmd_t pmd;\n\tpte_t *pte, *orig_pte;\n\tunsigned long _addr = addr & PMD_MASK;\n\tunsigned long offset;\n\tspinlock_t *ptl;\n\tbool numa = false;\n\tint local_nid = numa_node_id();\n\n\tspin_lock(&mm->page_table_lock);\n\tpmd = *pmdp;\n\tif (pmd_numa(pmd)) {\n\t\tset_pmd_at(mm, _addr, pmdp, pmd_mknonnuma(pmd));\n\t\tnuma = true;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (!numa)\n\t\treturn 0;\n\n\t/* we're in a page fault so some vma must be in the range */\n\tBUG_ON(!vma);\n\tBUG_ON(vma->vm_start >= _addr + PMD_SIZE);\n\toffset = max(_addr, vma->vm_start) & ~PMD_MASK;\n\tVM_BUG_ON(offset >= PMD_SIZE);\n\torig_pte = pte = pte_offset_map_lock(mm, pmdp, _addr, &ptl);\n\tpte += offset >> PAGE_SHIFT;\n\tfor (addr = _addr + offset; addr < _addr + PMD_SIZE; pte++, addr += PAGE_SIZE) {\n\t\tpte_t pteval = *pte;\n\t\tstruct page *page;\n\t\tint curr_nid = local_nid;\n\t\tint target_nid;\n\t\tbool migrated;\n\t\tif (!pte_present(pteval))\n\t\t\tcontinue;\n\t\tif (!pte_numa(pteval))\n\t\t\tcontinue;\n\t\tif (addr >= vma->vm_end) {\n\t\t\tvma = find_vma(mm, addr);\n\t\t\t/* there's a pte present so there must be a vma */\n\t\t\tBUG_ON(!vma);\n\t\t\tBUG_ON(addr < vma->vm_start);\n\t\t}\n\t\tif (pte_numa(pteval)) {\n\t\t\tpteval = pte_mknonnuma(pteval);\n\t\t\tset_pte_at(mm, addr, pte, pteval);\n\t\t}\n\t\tpage = vm_normal_page(vma, addr, pteval);\n\t\tif (unlikely(!page))\n\t\t\tcontinue;\n\t\t/* only check non-shared pages */\n\t\tif (unlikely(page_mapcount(page) != 1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note that the NUMA fault is later accounted to either\n\t\t * the node that is currently running or where the page is\n\t\t * migrated to.\n\t\t */\n\t\tcurr_nid = local_nid;\n\t\ttarget_nid = numa_migrate_prep(page, vma, addr,\n\t\t\t\t\t       page_to_nid(page));\n\t\tif (target_nid == -1) {\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Migrate to the requested node */\n\t\tpte_unmap_unlock(pte, ptl);\n\t\tmigrated = migrate_misplaced_page(page, target_nid);\n\t\tif (migrated)\n\t\t\tcurr_nid = target_nid;\n\t\ttask_numa_fault(curr_nid, 1, migrated);\n\n\t\tpte = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\t}\n\tpte_unmap_unlock(orig_pte, ptl);\n\n\treturn 0;\n}\n#else\nstatic int do_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t     unsigned long addr, pmd_t *pmdp)\n{\n\tBUG();\n\treturn 0;\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n/*\n * These routines also need to handle stuff like marking pages dirty\n * and/or accessed for architectures that don't do it in hardware (most\n * RISC architectures).  The early dirtying is also good on the i386.\n *\n * There is also a hook called \"update_mmu_cache()\" that architectures\n * with external mmu caches can use to update those (ie the Sparc or\n * PowerPC hashed page tables that act as extended TLBs).\n *\n * We enter with non-exclusive mmap_sem (to exclude vma changes,\n * but allow concurrent faults), and pte mapped but not yet locked.\n * We return with mmap_sem still held, but pte unmapped and unlocked.\n */\nint handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\n\tentry = *pte;\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_linear_fault(mm, vma, address,\n\t\t\t\t\t\tpte, pmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\tif (pte_file(entry))\n\t\t\treturn do_nonlinear_fault(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\n\tif (pte_numa(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\t/*\n\t\t * This is needed only for protection faults but the arch code\n\t\t * is not yet telling us if this is a protection fault or not.\n\t\t * This still avoids useless tlb flushes for .text page faults\n\t\t * with threads.\n\t\t */\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}\n\n/*\n * By the time we get here, we already hold the mm semaphore\n */\nint handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tmem_cgroup_count_vm_event(mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\treturn hugetlb_fault(mm, vma, address, flags);\n\nretry:\n\tpgd = pgd_offset(mm, address);\n\tpud = pud_alloc(mm, pgd, address);\n\tif (!pud)\n\t\treturn VM_FAULT_OOM;\n\tpmd = pmd_alloc(mm, pud, address);\n\tif (!pmd)\n\t\treturn VM_FAULT_OOM;\n\tif (pmd_none(*pmd) && transparent_hugepage_enabled(vma)) {\n\t\tif (!vma->vm_ops)\n\t\t\treturn do_huge_pmd_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t\t  pmd, flags);\n\t} else {\n\t\tpmd_t orig_pmd = *pmd;\n\t\tint ret;\n\n\t\tbarrier();\n\t\tif (pmd_trans_huge(orig_pmd)) {\n\t\t\tunsigned int dirty = flags & FAULT_FLAG_WRITE;\n\n\t\t\t/*\n\t\t\t * If the pmd is splitting, return and retry the\n\t\t\t * the fault.  Alternative: wait until the split\n\t\t\t * is done, and goto retry.\n\t\t\t */\n\t\t\tif (pmd_trans_splitting(orig_pmd))\n\t\t\t\treturn 0;\n\n\t\t\tif (pmd_numa(orig_pmd))\n\t\t\t\treturn do_huge_pmd_numa_page(mm, vma, address,\n\t\t\t\t\t\t\t     orig_pmd, pmd);\n\n\t\t\tif (dirty && !pmd_write(orig_pmd)) {\n\t\t\t\tret = do_huge_pmd_wp_page(mm, vma, address, pmd,\n\t\t\t\t\t\t\t  orig_pmd);\n\t\t\t\t/*\n\t\t\t\t * If COW results in an oom, the huge pmd will\n\t\t\t\t * have been split, so retry the fault on the\n\t\t\t\t * pte for a smaller charge.\n\t\t\t\t */\n\t\t\t\tif (unlikely(ret & VM_FAULT_OOM))\n\t\t\t\t\tgoto retry;\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\thuge_pmd_set_accessed(mm, vma, address, pmd,\n\t\t\t\t\t\t      orig_pmd, dirty);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (pmd_numa(*pmd))\n\t\treturn do_pmd_numa_page(mm, vma, address, pmd);\n\n\t/*\n\t * Use __pte_alloc instead of pte_alloc_map, because we can't\n\t * run pte_offset_map on the pmd, if an huge pmd could\n\t * materialize from under us from a different thread.\n\t */\n\tif (unlikely(pmd_none(*pmd)) &&\n\t    unlikely(__pte_alloc(mm, vma, pmd, address)))\n\t\treturn VM_FAULT_OOM;\n\t/* if an huge pmd materialized from under us just retry later */\n\tif (unlikely(pmd_trans_huge(*pmd)))\n\t\treturn 0;\n\t/*\n\t * A regular pmd is established and it can't morph into a huge pmd\n\t * from under us anymore at this point because we hold the mmap_sem\n\t * read mode and khugepaged takes it in write mode. So now it's\n\t * safe to run pte_offset_map().\n\t */\n\tpte = pte_offset_map(pmd, address);\n\n\treturn handle_pte_fault(mm, vma, address, pte, pmd, flags);\n}\n\n#ifndef __PAGETABLE_PUD_FOLDED\n/*\n * Allocate page upper directory.\n * We've already handled the fast-path in-line.\n */\nint __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tpud_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}\n#endif /* __PAGETABLE_PUD_FOLDED */\n\n#ifndef __PAGETABLE_PMD_FOLDED\n/*\n * Allocate page middle directory.\n * We've already handled the fast-path in-line.\n */\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (pud_present(*pud))\t\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n\telse\n\t\tpud_populate(mm, pud, new);\n#else\n\tif (pgd_present(*pud))\t\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pud, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}\n#endif /* __PAGETABLE_PMD_FOLDED */\n\n#if !defined(__HAVE_ARCH_GATE_AREA)\n\n#if defined(AT_SYSINFO_EHDR)\nstatic struct vm_area_struct gate_vma;\n\nstatic int __init gate_vma_init(void)\n{\n\tgate_vma.vm_mm = NULL;\n\tgate_vma.vm_start = FIXADDR_USER_START;\n\tgate_vma.vm_end = FIXADDR_USER_END;\n\tgate_vma.vm_flags = VM_READ | VM_MAYREAD | VM_EXEC | VM_MAYEXEC;\n\tgate_vma.vm_page_prot = __P101;\n\n\treturn 0;\n}\n__initcall(gate_vma_init);\n#endif\n\nstruct vm_area_struct *get_gate_vma(struct mm_struct *mm)\n{\n#ifdef AT_SYSINFO_EHDR\n\treturn &gate_vma;\n#else\n\treturn NULL;\n#endif\n}\n\nint in_gate_area_no_mm(unsigned long addr)\n{\n#ifdef AT_SYSINFO_EHDR\n\tif ((addr >= FIXADDR_USER_START) && (addr < FIXADDR_USER_END))\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\n#endif\t/* __HAVE_ARCH_GATE_AREA */\n\nstatic int __follow_pte(struct mm_struct *mm, unsigned long address,\n\t\tpte_t **ptepp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\t/* We cannot handle huge page PFN maps. Luckily they don't exist. */\n\tif (pmd_huge(*pmd))\n\t\tgoto out;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!ptep)\n\t\tgoto out;\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\nout:\n\treturn -EINVAL;\n}\n\nstatic inline int follow_pte(struct mm_struct *mm, unsigned long address,\n\t\t\t     pte_t **ptepp, spinlock_t **ptlp)\n{\n\tint res;\n\n\t/* (void) is needed to make gcc happy */\n\t(void) __cond_lock(*ptlp,\n\t\t\t   !(res = __follow_pte(mm, address, ptepp, ptlp)));\n\treturn res;\n}\n\n/**\n * follow_pfn - look up PFN at a user virtual address\n * @vma: memory mapping\n * @address: user virtual address\n * @pfn: location to store found PFN\n *\n * Only IO mappings and raw PFN mappings are allowed.\n *\n * Returns zero and the pfn at @pfn on success, -ve otherwise.\n */\nint follow_pfn(struct vm_area_struct *vma, unsigned long address,\n\tunsigned long *pfn)\n{\n\tint ret = -EINVAL;\n\tspinlock_t *ptl;\n\tpte_t *ptep;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\treturn ret;\n\n\tret = follow_pte(vma->vm_mm, address, &ptep, &ptl);\n\tif (ret)\n\t\treturn ret;\n\t*pfn = pte_pfn(*ptep);\n\tpte_unmap_unlock(ptep, ptl);\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_pfn);\n\n#ifdef CONFIG_HAVE_IOREMAP_PROT\nint follow_phys(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int flags,\n\t\tunsigned long *prot, resource_size_t *phys)\n{\n\tint ret = -EINVAL;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\n\tif (!(vma->vm_flags & (VM_IO | VM_PFNMAP)))\n\t\tgoto out;\n\n\tif (follow_pte(vma->vm_mm, address, &ptep, &ptl))\n\t\tgoto out;\n\tpte = *ptep;\n\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\n\t*prot = pgprot_val(pte_pgprot(pte));\n\t*phys = (resource_size_t)pte_pfn(pte) << PAGE_SHIFT;\n\n\tret = 0;\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn ret;\n}\n\nint generic_access_phys(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tvoid *buf, int len, int write)\n{\n\tresource_size_t phys_addr;\n\tunsigned long prot = 0;\n\tvoid __iomem *maddr;\n\tint offset = addr & (PAGE_SIZE-1);\n\n\tif (follow_phys(vma, addr, write, &prot, &phys_addr))\n\t\treturn -EINVAL;\n\n\tmaddr = ioremap_prot(phys_addr, PAGE_SIZE, prot);\n\tif (write)\n\t\tmemcpy_toio(maddr + offset, buf, len);\n\telse\n\t\tmemcpy_fromio(buf, maddr + offset, len);\n\tiounmap(maddr);\n\n\treturn len;\n}\n#endif\n\n/*\n * Access another process' address space as given in mm.  If non-NULL, use the\n * given task for page fault accounting.\n */\nstatic int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long addr, void *buf, int len, int write)\n{\n\tstruct vm_area_struct *vma;\n\tvoid *old_buf = buf;\n\n\tdown_read(&mm->mmap_sem);\n\t/* ignore errors, just check how much was successfully transferred */\n\twhile (len) {\n\t\tint bytes, ret, offset;\n\t\tvoid *maddr;\n\t\tstruct page *page = NULL;\n\n\t\tret = get_user_pages(tsk, mm, addr, 1,\n\t\t\t\twrite, 1, &page, &vma);\n\t\tif (ret <= 0) {\n\t\t\t/*\n\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\n\t\t\t * we can access using slightly different code.\n\t\t\t */\n#ifdef CONFIG_HAVE_IOREMAP_PROT\n\t\t\tvma = find_vma(mm, addr);\n\t\t\tif (!vma || vma->vm_start > addr)\n\t\t\t\tbreak;\n\t\t\tif (vma->vm_ops && vma->vm_ops->access)\n\t\t\t\tret = vma->vm_ops->access(vma, addr, buf,\n\t\t\t\t\t\t\t  len, write);\n\t\t\tif (ret <= 0)\n#endif\n\t\t\t\tbreak;\n\t\t\tbytes = ret;\n\t\t} else {\n\t\t\tbytes = len;\n\t\t\toffset = addr & (PAGE_SIZE-1);\n\t\t\tif (bytes > PAGE_SIZE-offset)\n\t\t\t\tbytes = PAGE_SIZE-offset;\n\n\t\t\tmaddr = kmap(page);\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr,\n\t\t\t\t\t\t  maddr + offset, buf, bytes);\n\t\t\t\tset_page_dirty_lock(page);\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tlen -= bytes;\n\t\tbuf += bytes;\n\t\taddr += bytes;\n\t}\n\tup_read(&mm->mmap_sem);\n\n\treturn buf - old_buf;\n}\n\n/**\n * access_remote_vm - access another process' address space\n * @mm:\t\tthe mm_struct of the target address space\n * @addr:\tstart address to access\n * @buf:\tsource or destination buffer\n * @len:\tnumber of bytes to transfer\n * @write:\twhether the access is a write\n *\n * The caller must hold a reference on @mm.\n */\nint access_remote_vm(struct mm_struct *mm, unsigned long addr,\n\t\tvoid *buf, int len, int write)\n{\n\treturn __access_remote_vm(NULL, mm, addr, buf, len, write);\n}\n\n/*\n * Access another process' address space.\n * Source/target buffer must be kernel space,\n * Do not walk the page table directly, use get_user_pages\n */\nint access_process_vm(struct task_struct *tsk, unsigned long addr,\n\t\tvoid *buf, int len, int write)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tret = __access_remote_vm(tsk, mm, addr, buf, len, write);\n\tmmput(mm);\n\n\treturn ret;\n}\n\n/*\n * Print the name of a VMA.\n */\nvoid print_vma_addr(char *prefix, unsigned long ip)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * Do not print if we are in atomic\n\t * contexts (in exception stacks, etc.):\n\t */\n\tif (preempt_count())\n\t\treturn;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, ip);\n\tif (vma && vma->vm_file) {\n\t\tstruct file *f = vma->vm_file;\n\t\tchar *buf = (char *)__get_free_page(GFP_KERNEL);\n\t\tif (buf) {\n\t\t\tchar *p;\n\n\t\t\tp = d_path(&f->f_path, buf, PAGE_SIZE);\n\t\t\tif (IS_ERR(p))\n\t\t\t\tp = \"?\";\n\t\t\tprintk(\"%s%s[%lx+%lx]\", prefix, kbasename(p),\n\t\t\t\t\tvma->vm_start,\n\t\t\t\t\tvma->vm_end - vma->vm_start);\n\t\t\tfree_page((unsigned long)buf);\n\t\t}\n\t}\n\tup_read(&mm->mmap_sem);\n}\n\n#ifdef CONFIG_PROVE_LOCKING\nvoid might_fault(void)\n{\n\t/*\n\t * Some code (nfs/sunrpc) uses socket ops on kernel memory while\n\t * holding the mmap_sem, this is safe because kernel memory doesn't\n\t * get paged out, therefore we'll never actually fault, and the\n\t * below annotations will generate false positives.\n\t */\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\treturn;\n\n\tmight_sleep();\n\t/*\n\t * it would be nicer only to annotate paths which are not under\n\t * pagefault_disable, however that requires a larger audit and\n\t * providing helpers like get_user_atomic.\n\t */\n\tif (!in_atomic() && current->mm)\n\t\tmight_lock_read(&current->mm->mmap_sem);\n}\nEXPORT_SYMBOL(might_fault);\n#endif\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_HUGETLBFS)\nstatic void clear_gigantic_page(struct page *page,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *p = page;\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page;\n\t     i++, p = mem_map_next(p, page, i)) {\n\t\tcond_resched();\n\t\tclear_user_highpage(p, addr + i * PAGE_SIZE);\n\t}\n}\nvoid clear_huge_page(struct page *page,\n\t\t     unsigned long addr, unsigned int pages_per_huge_page)\n{\n\tint i;\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tclear_gigantic_page(page, addr, pages_per_huge_page);\n\t\treturn;\n\t}\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page; i++) {\n\t\tcond_resched();\n\t\tclear_user_highpage(page + i, addr + i * PAGE_SIZE);\n\t}\n}\n\nstatic void copy_user_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct vm_area_struct *vma,\n\t\t\t\t    unsigned int pages_per_huge_page)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < pages_per_huge_page; ) {\n\t\tcond_resched();\n\t\tcopy_user_highpage(dst, src, addr + i*PAGE_SIZE, vma);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}\n\nvoid copy_user_huge_page(struct page *dst, struct page *src,\n\t\t\t unsigned long addr, struct vm_area_struct *vma,\n\t\t\t unsigned int pages_per_huge_page)\n{\n\tint i;\n\n\tif (unlikely(pages_per_huge_page > MAX_ORDER_NR_PAGES)) {\n\t\tcopy_user_gigantic_page(dst, src, addr, vma,\n\t\t\t\t\tpages_per_huge_page);\n\t\treturn;\n\t}\n\n\tmight_sleep();\n\tfor (i = 0; i < pages_per_huge_page; i++) {\n\t\tcond_resched();\n\t\tcopy_user_highpage(dst + i, src + i, addr + i*PAGE_SIZE, vma);\n\t}\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */\n"], "filenames": ["include/linux/mm.h", "mm/memory.c"], "buggy_code_start_loc": [1613, 2395], "buggy_code_end_loc": [1613, 2395], "fixing_code_start_loc": [1614, 2396], "fixing_code_end_loc": [1616, 2443], "type": "CWE-189", "message": "Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program.", "other": {"cve": {"id": "CVE-2013-2596", "sourceIdentifier": "cve@mitre.org", "published": "2013-04-13T02:59:46.627", "lastModified": "2016-12-31T02:59:02.887", "vulnStatus": "Modified", "cisaExploitAdd": "2022-09-15", "cisaActionDue": "2022-10-06", "cisaRequiredAction": "Apply updates per vendor instructions.", "cisaVulnerabilityName": "Linux Kernel Integer Overflow Vulnerability", "descriptions": [{"lang": "en", "value": "Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program."}, {"lang": "es", "value": "Una determinada version de Android v4.1.2 en dispositivos Motorola Razr HD, Razr M, y Atrix HD con el chipset Qualcomm MSM8960 permite a atacantes f\u00edsicamente pr\u00f3ximos obtener acceso de root entrando en el modo de depuraci\u00f3n USB, usando Android Debug Bridge (ADB) para establecer una conexi\u00f3n USB, y cargar y ejecutar el programa pwn Motochopper."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": true, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.8", "matchCriteriaId": "D11FDC31-8717-4FE1-A2F0-731D2F387B2E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:motorola:android:4.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "62EFFAAF-F122-4019-8554-9E9CEF73CDAE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:h:motorola:atrix_hd:-:*:*:*:*:*:*:*", "matchCriteriaId": "75B24D97-F98A-4A1A-B20E-EB6D610C71EA"}, {"vulnerable": true, "criteria": "cpe:2.3:h:motorola:razr_hd:-:*:*:*:*:*:*:*", "matchCriteriaId": "A5D2D0B7-8170-46F2-9FC8-2DDD3E96DE66"}, {"vulnerable": true, "criteria": "cpe:2.3:h:motorola:razr_m:-:*:*:*:*:*:*:*", "matchCriteriaId": "01FE07B3-068A-4C2A-A985-631070C17F51"}, {"vulnerable": true, "criteria": "cpe:2.3:h:qualcomm:msm8960:-:*:*:*:*:*:*:*", "matchCriteriaId": "73B9587B-78D0-4057-B694-E1E6655F624F"}]}]}], "references": [{"url": "http://forum.xda-developers.com/showthread.php?t=2255491", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=b4cbb197c7e7a68dbad0d491242e3ca67420c13e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=fc9bbca8f650e5f738af8806317c0a041a48ae4a", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "http://kb.juniper.net/InfoCenter/index?page=content&id=JSA10761", "source": "cve@mitre.org"}, {"url": "http://marc.info/?l=linux-kernel&m=136616837923938&w=2", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0695.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0782.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0803.html", "source": "cve@mitre.org"}, {"url": "http://www.droid-life.com/2013/04/09/root-method-released-for-droid-razr-hd-running-android-4-1-2-other-devices-too/", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "http://www.droidrzr.com/index.php/topic/15208-root-motochopper-yet-another-android-root-exploit/", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.8.9", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:176", "source": "cve@mitre.org"}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjan2016-2867209.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/59264", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/b4cbb197c7e7a68dbad0d491242e3ca67420c13e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/fc9bbca8f650e5f738af8806317c0a041a48ae4a", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b4cbb197c7e7a68dbad0d491242e3ca67420c13e"}}