{"buggy_code": ["# Copyright (C) 2016 JWCrypto Project Contributors - see LICENSE file\n\nimport abc\nimport os\nimport struct\nfrom binascii import hexlify, unhexlify\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import constant_time, hashes, hmac\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric import utils as ec_utils\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives.padding import PKCS7\n\nimport six\n\nfrom jwcrypto.common import InvalidCEKeyLength\nfrom jwcrypto.common import InvalidJWAAlgorithm\nfrom jwcrypto.common import InvalidJWEKeyLength\nfrom jwcrypto.common import InvalidJWEKeyType\nfrom jwcrypto.common import InvalidJWEOperation\nfrom jwcrypto.common import base64url_decode, base64url_encode\nfrom jwcrypto.common import json_decode\nfrom jwcrypto.jwk import JWK\n\n# Implements RFC 7518 - JSON Web Algorithms (JWA)\n\n\n@six.add_metaclass(abc.ABCMeta)\nclass JWAAlgorithm(object):\n\n    @abc.abstractproperty\n    def name(self):\n        \"\"\"The algorithm Name\"\"\"\n        pass\n\n    @abc.abstractproperty\n    def description(self):\n        \"\"\"A short description\"\"\"\n        pass\n\n    @abc.abstractproperty\n    def keysize(self):\n        \"\"\"The actual/recommended/minimum key size\"\"\"\n        pass\n\n    @abc.abstractproperty\n    def algorithm_usage_location(self):\n        \"\"\"One of 'alg', 'enc' or 'JWK'\"\"\"\n        pass\n\n    @abc.abstractproperty\n    def algorithm_use(self):\n        \"\"\"One of 'sig', 'kex', 'enc'\"\"\"\n        pass\n\n\ndef _bitsize(x):\n    return len(x) * 8\n\n\ndef _inbytes(x):\n    return x // 8\n\n\ndef _randombits(x):\n    if x % 8 != 0:\n        raise ValueError(\"lenght must be a multiple of 8\")\n    return os.urandom(_inbytes(x))\n\n\n# Note: the number of bits should be a multiple of 16\ndef _encode_int(n, bits):\n    e = '{:x}'.format(n)\n    ilen = ((bits + 7) // 8) * 2  # number of bytes rounded up times 2 bytes\n    return unhexlify(e.rjust(ilen, '0')[:ilen])\n\n\ndef _decode_int(n):\n    return int(hexlify(n), 16)\n\n\nclass _RawJWS(object):\n\n    def sign(self, key, payload):\n        raise NotImplementedError\n\n    def verify(self, key, payload, signature):\n        raise NotImplementedError\n\n\nclass _RawHMAC(_RawJWS):\n\n    def __init__(self, hashfn):\n        self.backend = default_backend()\n        self.hashfn = hashfn\n\n    def _hmac_setup(self, key, payload):\n        h = hmac.HMAC(key, self.hashfn, backend=self.backend)\n        h.update(payload)\n        return h\n\n    def sign(self, key, payload):\n        skey = base64url_decode(key.get_op_key('sign'))\n        h = self._hmac_setup(skey, payload)\n        return h.finalize()\n\n    def verify(self, key, payload, signature):\n        vkey = base64url_decode(key.get_op_key('verify'))\n        h = self._hmac_setup(vkey, payload)\n        h.verify(signature)\n\n\nclass _RawRSA(_RawJWS):\n    def __init__(self, padfn, hashfn):\n        self.padfn = padfn\n        self.hashfn = hashfn\n\n    def sign(self, key, payload):\n        skey = key.get_op_key('sign')\n        signer = skey.signer(self.padfn, self.hashfn)\n        signer.update(payload)\n        return signer.finalize()\n\n    def verify(self, key, payload, signature):\n        pkey = key.get_op_key('verify')\n        verifier = pkey.verifier(signature, self.padfn, self.hashfn)\n        verifier.update(payload)\n        verifier.verify()\n\n\nclass _RawEC(_RawJWS):\n    def __init__(self, curve, hashfn):\n        self._curve = curve\n        self.hashfn = hashfn\n\n    @property\n    def curve(self):\n        return self._curve\n\n    def sign(self, key, payload):\n        skey = key.get_op_key('sign', self._curve)\n        signer = skey.signer(ec.ECDSA(self.hashfn))\n        signer.update(payload)\n        signature = signer.finalize()\n        r, s = ec_utils.decode_rfc6979_signature(signature)\n        l = key.get_curve(self._curve).key_size\n        return _encode_int(r, l) + _encode_int(s, l)\n\n    def verify(self, key, payload, signature):\n        pkey = key.get_op_key('verify', self._curve)\n        r = signature[:len(signature) // 2]\n        s = signature[len(signature) // 2:]\n        enc_signature = ec_utils.encode_rfc6979_signature(\n            int(hexlify(r), 16), int(hexlify(s), 16))\n        verifier = pkey.verifier(enc_signature, ec.ECDSA(self.hashfn))\n        verifier.update(payload)\n        verifier.verify()\n\n\nclass _RawNone(_RawJWS):\n\n    def sign(self, key, payload):\n        return ''\n\n    def verify(self, key, payload, signature):\n        raise InvalidSignature('The \"none\" signature cannot be verified')\n\n\nclass _HS256(_RawHMAC, JWAAlgorithm):\n\n    name = \"HS256\"\n    description = \"HMAC using SHA-256\"\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_HS256, self).__init__(hashes.SHA256())\n\n\nclass _HS384(_RawHMAC, JWAAlgorithm):\n\n    name = \"HS384\"\n    description = \"HMAC using SHA-384\"\n    keysize = 384\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_HS384, self).__init__(hashes.SHA384())\n\n\nclass _HS512(_RawHMAC, JWAAlgorithm):\n\n    name = \"HS512\"\n    description = \"HMAC using SHA-512\"\n    keysize = 512\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_HS512, self).__init__(hashes.SHA512())\n\n\nclass _RS256(_RawRSA, JWAAlgorithm):\n\n    name = \"RS256\"\n    description = \"RSASSA-PKCS1-v1_5 using SHA-256\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_RS256, self).__init__(padding.PKCS1v15(), hashes.SHA256())\n\n\nclass _RS384(_RawRSA, JWAAlgorithm):\n\n    name = \"RS384\"\n    description = \"RSASSA-PKCS1-v1_5 using SHA-384\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_RS384, self).__init__(padding.PKCS1v15(), hashes.SHA384())\n\n\nclass _RS512(_RawRSA, JWAAlgorithm):\n\n    name = \"RS512\"\n    description = \"RSASSA-PKCS1-v1_5 using SHA-512\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_RS512, self).__init__(padding.PKCS1v15(), hashes.SHA512())\n\n\nclass _ES256(_RawEC, JWAAlgorithm):\n\n    name = \"ES256\"\n    description = \"ECDSA using P-256 and SHA-256\"\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_ES256, self).__init__('P-256', hashes.SHA256())\n\n\nclass _ES384(_RawEC, JWAAlgorithm):\n\n    name = \"ES384\"\n    description = \"ECDSA using P-384 and SHA-384\"\n    keysize = 384\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_ES384, self).__init__('P-384', hashes.SHA384())\n\n\nclass _ES512(_RawEC, JWAAlgorithm):\n\n    name = \"ES512\"\n    description = \"ECDSA using P-521 and SHA-512\"\n    keysize = 512\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_ES512, self).__init__('P-521', hashes.SHA512())\n\n\nclass _PS256(_RawRSA, JWAAlgorithm):\n\n    name = \"PS256\"\n    description = \"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        padfn = padding.PSS(padding.MGF1(hashes.SHA256()),\n                            hashes.SHA256.digest_size)\n        super(_PS256, self).__init__(padfn, hashes.SHA256())\n\n\nclass _PS384(_RawRSA, JWAAlgorithm):\n\n    name = \"PS384\"\n    description = \"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        padfn = padding.PSS(padding.MGF1(hashes.SHA384()),\n                            hashes.SHA384.digest_size)\n        super(_PS384, self).__init__(padfn, hashes.SHA384())\n\n\nclass _PS512(_RawRSA, JWAAlgorithm):\n\n    name = \"PS512\"\n    description = \"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        padfn = padding.PSS(padding.MGF1(hashes.SHA512()),\n                            hashes.SHA512.digest_size)\n        super(_PS512, self).__init__(padfn, hashes.SHA512())\n\n\nclass _None(_RawNone, JWAAlgorithm):\n\n    name = \"none\"\n    description = \"No digital signature or MAC performed\"\n    keysize = 0\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n\nclass _RawKeyMgmt(object):\n\n    def wrap(self, key, bitsize, cek, headers):\n        raise NotImplementedError\n\n    def unwrap(self, key, bitsize, ek, headers):\n        raise NotImplementedError\n\n\nclass _RSA(_RawKeyMgmt):\n\n    def __init__(self, padfn):\n        self.padfn = padfn\n\n    def _check_key(self, key):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'RSA':\n            raise InvalidJWEKeyType('RSA', key.key_type)\n\n    # FIXME: get key size and insure > 2048 bits\n    def wrap(self, key, bitsize, cek, headers):\n        self._check_key(key)\n        if not cek:\n            cek = _randombits(bitsize)\n        rk = key.get_op_key('wrapKey')\n        ek = rk.encrypt(cek, self.padfn)\n        return {'cek': cek, 'ek': ek}\n\n    def unwrap(self, key, bitsize, ek, headers):\n        self._check_key(key)\n        rk = key.get_op_key('decrypt')\n        cek = rk.decrypt(ek, self.padfn)\n        if _bitsize(cek) != bitsize:\n            raise InvalidJWEKeyLength(bitsize, _bitsize(cek))\n        return cek\n\n\nclass _Rsa15(_RSA, JWAAlgorithm):\n\n    name = 'RSA1_5'\n    description = \"RSAES-PKCS1-v1_5\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n    def __init__(self):\n        super(_Rsa15, self).__init__(padding.PKCS1v15())\n\n\nclass _RsaOaep(_RSA, JWAAlgorithm):\n\n    name = 'RSA-OAEP'\n    description = \"RSAES OAEP using default parameters\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n    def __init__(self):\n        super(_RsaOaep, self).__init__(\n            padding.OAEP(padding.MGF1(hashes.SHA1()),\n                         hashes.SHA1(), None))\n\n\nclass _RsaOaep256(_RSA, JWAAlgorithm):  # noqa: ignore=N801\n\n    name = 'RSA-OAEP-256'\n    description = \"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n    def __init__(self):\n        super(_RsaOaep256, self).__init__(\n            padding.OAEP(padding.MGF1(hashes.SHA256()),\n                         hashes.SHA256(), None))\n\n\nclass _AesKw(_RawKeyMgmt):\n\n    keysize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n\n    def _get_key(self, key, op):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'oct':\n            raise InvalidJWEKeyType('oct', key.key_type)\n        rk = base64url_decode(key.get_op_key(op))\n        if _bitsize(rk) != self.keysize:\n            raise InvalidJWEKeyLength(self.keysize, _bitsize(rk))\n        return rk\n\n    def wrap(self, key, bitsize, cek, headers):\n        rk = self._get_key(key, 'encrypt')\n        if not cek:\n            cek = _randombits(bitsize)\n\n        # Implement RFC 3394 Key Unwrap - 2.2.2\n        # TODO: Use cryptography once issue #1733 is resolved\n        iv = 'a6a6a6a6a6a6a6a6'\n        a = unhexlify(iv)\n        r = [cek[i:i + 8] for i in range(0, len(cek), 8)]\n        n = len(r)\n        for j in range(0, 6):\n            for i in range(0, n):\n                e = Cipher(algorithms.AES(rk), modes.ECB(),\n                           backend=self.backend).encryptor()\n                b = e.update(a + r[i]) + e.finalize()\n                a = _encode_int(_decode_int(b[:8]) ^ ((n * j) + i + 1), 64)\n                r[i] = b[-8:]\n        ek = a\n        for i in range(0, n):\n            ek += r[i]\n        return {'cek': cek, 'ek': ek}\n\n    def unwrap(self, key, bitsize, ek, headers):\n        rk = self._get_key(key, 'decrypt')\n\n        # Implement RFC 3394 Key Unwrap - 2.2.3\n        # TODO: Use cryptography once issue #1733 is resolved\n        iv = 'a6a6a6a6a6a6a6a6'\n        aiv = unhexlify(iv)\n\n        r = [ek[i:i + 8] for i in range(0, len(ek), 8)]\n        a = r.pop(0)\n        n = len(r)\n        for j in range(5, -1, -1):\n            for i in range(n - 1, -1, -1):\n                da = _decode_int(a)\n                atr = _encode_int((da ^ ((n * j) + i + 1)), 64) + r[i]\n                d = Cipher(algorithms.AES(rk), modes.ECB(),\n                           backend=self.backend).decryptor()\n                b = d.update(atr) + d.finalize()\n                a = b[:8]\n                r[i] = b[-8:]\n\n        if a != aiv:\n            raise RuntimeError('Decryption Failed')\n\n        cek = b''.join(r)\n        if _bitsize(cek) != bitsize:\n            raise InvalidJWEKeyLength(bitsize, _bitsize(cek))\n        return cek\n\n\nclass _A128KW(_AesKw, JWAAlgorithm):\n\n    name = 'A128KW'\n    description = \"AES Key Wrap using 128-bit key\"\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _A192KW(_AesKw, JWAAlgorithm):\n\n    name = 'A192KW'\n    description = \"AES Key Wrap using 192-bit key\"\n    keysize = 192\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _A256KW(_AesKw, JWAAlgorithm):\n\n    name = 'A256KW'\n    description = \"AES Key Wrap using 256-bit key\"\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _AesGcmKw(_RawKeyMgmt):\n\n    keysize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n\n    def _get_key(self, key, op):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'oct':\n            raise InvalidJWEKeyType('oct', key.key_type)\n        rk = base64url_decode(key.get_op_key(op))\n        if _bitsize(rk) != self.keysize:\n            raise InvalidJWEKeyLength(self.keysize, _bitsize(rk))\n        return rk\n\n    def wrap(self, key, bitsize, cek, headers):\n        rk = self._get_key(key, 'encrypt')\n        if not cek:\n            cek = _randombits(bitsize)\n\n        iv = _randombits(96)\n        cipher = Cipher(algorithms.AES(rk), modes.GCM(iv),\n                        backend=self.backend)\n        encryptor = cipher.encryptor()\n        ek = encryptor.update(cek) + encryptor.finalize()\n\n        tag = encryptor.tag\n        return {'cek': cek, 'ek': ek,\n                'header': {'iv': base64url_encode(iv),\n                           'tag': base64url_encode(tag)}}\n\n    def unwrap(self, key, bitsize, ek, headers):\n        rk = self._get_key(key, 'decrypt')\n\n        if 'iv' not in headers:\n            raise ValueError('Invalid Header, missing \"iv\" parameter')\n        iv = base64url_decode(headers['iv'])\n        if 'tag' not in headers:\n            raise ValueError('Invalid Header, missing \"tag\" parameter')\n        tag = base64url_decode(headers['tag'])\n\n        cipher = Cipher(algorithms.AES(rk), modes.GCM(iv, tag),\n                        backend=self.backend)\n        decryptor = cipher.decryptor()\n        cek = decryptor.update(ek) + decryptor.finalize()\n        if _bitsize(cek) != bitsize:\n            raise InvalidJWEKeyLength(bitsize, _bitsize(cek))\n        return cek\n\n\nclass _A128GcmKw(_AesGcmKw, JWAAlgorithm):\n\n    name = 'A128GCMKW'\n    description = \"Key wrapping with AES GCM using 128-bit key\"\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _A192GcmKw(_AesGcmKw, JWAAlgorithm):\n\n    name = 'A192GCMKW'\n    description = \"Key wrapping with AES GCM using 192-bit key\"\n    keysize = 192\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _A256GcmKw(_AesGcmKw, JWAAlgorithm):\n\n    name = 'A256GCMKW'\n    description = \"Key wrapping with AES GCM using 256-bit key\"\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _Pbes2HsAesKw(_RawKeyMgmt):\n\n    name = None\n    keysize = None\n    hashsize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n        self.aeskwmap = {128: _A128KW, 192: _A192KW, 256: _A256KW}\n\n    def _get_key(self, alg, key, p2s, p2c):\n        if isinstance(key, bytes):\n            plain = key\n        else:\n            plain = key.encode('utf8')\n        salt = bytes(self.name.encode('utf8')) + b'\\x00' + p2s\n\n        if self.hashsize == 256:\n            hashalg = hashes.SHA256()\n        elif self.hashsize == 384:\n            hashalg = hashes.SHA384()\n        elif self.hashsize == 512:\n            hashalg = hashes.SHA512()\n        else:\n            raise ValueError('Unknown Hash Size')\n\n        kdf = PBKDF2HMAC(algorithm=hashalg, length=_inbytes(self.keysize),\n                         salt=salt, iterations=p2c, backend=self.backend)\n        rk = kdf.derive(plain)\n        if _bitsize(rk) != self.keysize:\n            raise InvalidJWEKeyLength(self.keysize, len(rk))\n        return JWK(kty=\"oct\", use=\"enc\", k=base64url_encode(rk))\n\n    def wrap(self, key, bitsize, cek, headers):\n        p2s = _randombits(128)\n        p2c = 8192\n        kek = self._get_key(headers['alg'], key, p2s, p2c)\n\n        aeskw = self.aeskwmap[self.keysize]()\n        ret = aeskw.wrap(kek, bitsize, cek, headers)\n        ret['header'] = {'p2s': base64url_encode(p2s), 'p2c': p2c}\n        return ret\n\n    def unwrap(self, key, bitsize, ek, headers):\n        if 'p2s' not in headers:\n            raise ValueError('Invalid Header, missing \"p2s\" parameter')\n        if 'p2c' not in headers:\n            raise ValueError('Invalid Header, missing \"p2c\" parameter')\n        p2s = base64url_decode(headers['p2s'])\n        p2c = headers['p2c']\n        kek = self._get_key(headers['alg'], key, p2s, p2c)\n\n        aeskw = self.aeskwmap[self.keysize]()\n        return aeskw.unwrap(kek, bitsize, ek, headers)\n\n\nclass _Pbes2Hs256A128Kw(_Pbes2HsAesKw, JWAAlgorithm):\n\n    name = 'PBES2-HS256+A128KW'\n    description = 'PBES2 with HMAC SHA-256 and \"A128KW\" wrapping'\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n    hashsize = 256\n\n\nclass _Pbes2Hs384A192Kw(_Pbes2HsAesKw, JWAAlgorithm):\n\n    name = 'PBES2-HS384+A192KW'\n    description = 'PBES2 with HMAC SHA-384 and \"A192KW\" wrapping'\n    keysize = 192\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n    hashsize = 384\n\n\nclass _Pbes2Hs512A256Kw(_Pbes2HsAesKw, JWAAlgorithm):\n\n    name = 'PBES2-HS512+A256KW'\n    description = 'PBES2 with HMAC SHA-512 and \"A256KW\" wrapping'\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n    hashsize = 512\n\n\nclass _Direct(_RawKeyMgmt, JWAAlgorithm):\n\n    name = 'dir'\n    description = \"Direct use of a shared symmetric key\"\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n    def _check_key(self, key):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'oct':\n            raise InvalidJWEKeyType('oct', key.key_type)\n\n    def wrap(self, key, bitsize, cek, headers):\n        self._check_key(key)\n        if cek:\n            return (cek, None)\n        k = base64url_decode(key.get_op_key('encrypt'))\n        if _bitsize(k) != bitsize:\n            raise InvalidCEKeyLength(bitsize, _bitsize(k))\n        return {'cek': k}\n\n    def unwrap(self, key, bitsize, ek, headers):\n        self._check_key(key)\n        if ek != b'':\n            raise ValueError('Invalid Encryption Key.')\n        cek = base64url_decode(key.get_op_key('decrypt'))\n        if _bitsize(cek) != bitsize:\n            raise InvalidJWEKeyLength(bitsize, _bitsize(cek))\n        return cek\n\n\nclass _EcdhEs(_RawKeyMgmt):\n\n    name = 'ECDH-ES'\n    description = \"ECDH-ES using Concat KDF\"\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n    keysize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n        self.aeskwmap = {128: _A128KW, 192: _A192KW, 256: _A256KW}\n\n    def _check_key(self, key):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'EC':\n            raise InvalidJWEKeyType('EC', key.key_type)\n\n    def _derive(self, privkey, pubkey, alg, bitsize, headers):\n        # OtherInfo is defined in NIST SP 56A 5.8.1.2.1\n\n        # AlgorithmID\n        otherinfo = struct.pack('>I', len(alg))\n        otherinfo += bytes(alg.encode('utf8'))\n\n        # PartyUInfo\n        apu = base64url_decode(headers['apu']) if 'apu' in headers else b''\n        otherinfo += struct.pack('>I', len(apu))\n        otherinfo += apu\n\n        # PartyVInfo\n        apv = base64url_decode(headers['apv']) if 'apv' in headers else b''\n        otherinfo += struct.pack('>I', len(apv))\n        otherinfo += apv\n\n        # SuppPubInfo\n        otherinfo += struct.pack('>I', bitsize)\n\n        # no SuppPrivInfo\n\n        shared_key = privkey.exchange(ec.ECDH(), pubkey)\n        ckdf = ConcatKDFHash(algorithm=hashes.SHA256(),\n                             length=_inbytes(bitsize),\n                             otherinfo=otherinfo,\n                             backend=self.backend)\n        return ckdf.derive(shared_key)\n\n    def wrap(self, key, bitsize, cek, headers):\n        self._check_key(key)\n        if self.keysize is None:\n            if cek is not None:\n                raise InvalidJWEOperation('ECDH-ES cannot use an existing CEK')\n            alg = headers['enc']\n        else:\n            bitsize = self.keysize\n            alg = headers['alg']\n\n        epk = JWK.generate(kty=key.key_type, crv=key.key_curve)\n        dk = self._derive(epk.get_op_key('unwrapKey'),\n                          key.get_op_key('wrapKey'),\n                          alg, bitsize, headers)\n\n        if self.keysize is None:\n            ret = {'cek': dk}\n        else:\n            aeskw = self.aeskwmap[bitsize]()\n            kek = JWK(kty=\"oct\", use=\"enc\", k=base64url_encode(dk))\n            ret = aeskw.wrap(kek, bitsize, cek, headers)\n\n        ret['header'] = {'epk': json_decode(epk.export_public())}\n        return ret\n\n    def unwrap(self, key, bitsize, ek, headers):\n        if 'epk' not in headers:\n            raise ValueError('Invalid Header, missing \"epk\" parameter')\n        self._check_key(key)\n        if self.keysize is None:\n            alg = headers['enc']\n        else:\n            bitsize = self.keysize\n            alg = headers['alg']\n\n        epk = JWK(**headers['epk'])\n        dk = self._derive(key.get_op_key('unwrapKey'),\n                          epk.get_op_key('wrapKey'),\n                          alg, bitsize, headers)\n        if self.keysize is None:\n            return dk\n        else:\n            aeskw = self.aeskwmap[bitsize]()\n            kek = JWK(kty=\"oct\", use=\"enc\", k=base64url_encode(dk))\n            cek = aeskw.unwrap(kek, bitsize, ek, headers)\n            return cek\n\n\nclass _EcdhEsAes128Kw(_EcdhEs, JWAAlgorithm):\n\n    name = 'ECDH-ES+A128KW'\n    description = 'ECDH-ES using Concat KDF and \"A128KW\" wrapping'\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _EcdhEsAes192Kw(_EcdhEs, JWAAlgorithm):\n\n    name = 'ECDH-ES+A192KW'\n    description = 'ECDH-ES using Concat KDF and \"A192KW\" wrapping'\n    keysize = 192\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _EcdhEsAes256Kw(_EcdhEs, JWAAlgorithm):\n\n    name = 'ECDH-ES+A256KW'\n    description = 'ECDH-ES using Concat KDF and \"A128KW\" wrapping'\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _RawJWE(object):\n\n    def encrypt(self, k, a, m):\n        raise NotImplementedError\n\n    def decrypt(self, k, a, iv, e, t):\n        raise NotImplementedError\n\n\nclass _AesCbcHmacSha2(_RawJWE):\n\n    keysize = None\n\n    def __init__(self, hashfn):\n        self.backend = default_backend()\n        self.hashfn = hashfn\n        self.blocksize = algorithms.AES.block_size\n        self.wrap_key_size = self.keysize * 2\n\n    def _mac(self, k, a, iv, e):\n        al = _encode_int(_bitsize(a), 64)\n        h = hmac.HMAC(k, self.hashfn, backend=self.backend)\n        h.update(a)\n        h.update(iv)\n        h.update(e)\n        h.update(al)\n        m = h.finalize()\n        return m[:_inbytes(self.keysize)]\n\n    # RFC 7518 - 5.2.2\n    def encrypt(self, k, a, m):\n        \"\"\" Encrypt according to the selected encryption and hashing\n        functions.\n\n        :param k: Encryption key (optional)\n        :param a: Additional Authentication Data\n        :param m: Plaintext\n\n        Returns a dictionary with the computed data.\n        \"\"\"\n        hkey = k[:_inbytes(self.keysize)]\n        ekey = k[_inbytes(self.keysize):]\n\n        # encrypt\n        iv = _randombits(self.blocksize)\n        cipher = Cipher(algorithms.AES(ekey), modes.CBC(iv),\n                        backend=self.backend)\n        encryptor = cipher.encryptor()\n        padder = PKCS7(self.blocksize).padder()\n        padded_data = padder.update(m) + padder.finalize()\n        e = encryptor.update(padded_data) + encryptor.finalize()\n\n        # mac\n        t = self._mac(hkey, a, iv, e)\n\n        return (iv, e, t)\n\n    def decrypt(self, k, a, iv, e, t):\n        \"\"\" Decrypt according to the selected encryption and hashing\n        functions.\n        :param k: Encryption key (optional)\n        :param a: Additional Authenticated Data\n        :param iv: Initialization Vector\n        :param e: Ciphertext\n        :param t: Authentication Tag\n\n        Returns plaintext or raises an error\n        \"\"\"\n        hkey = k[:_inbytes(self.keysize)]\n        dkey = k[_inbytes(self.keysize):]\n\n        # verify mac\n        if not constant_time.bytes_eq(t, self._mac(hkey, a, iv, e)):\n            raise InvalidSignature('Failed to verify MAC')\n\n        # decrypt\n        cipher = Cipher(algorithms.AES(dkey), modes.CBC(iv),\n                        backend=self.backend)\n        decryptor = cipher.decryptor()\n        d = decryptor.update(e) + decryptor.finalize()\n        unpadder = PKCS7(self.blocksize).unpadder()\n        return unpadder.update(d) + unpadder.finalize()\n\n\nclass _A128CbcHs256(_AesCbcHmacSha2, JWAAlgorithm):\n\n    name = 'A128CBC-HS256'\n    description = \"AES_128_CBC_HMAC_SHA_256 authenticated\"\n    keysize = 128\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n    def __init__(self):\n        super(_A128CbcHs256, self).__init__(hashes.SHA256())\n\n\nclass _A192CbcHs384(_AesCbcHmacSha2, JWAAlgorithm):\n\n    name = 'A192CBC-HS384'\n    description = \"AES_192_CBC_HMAC_SHA_384 authenticated\"\n    keysize = 192\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n    def __init__(self):\n        super(_A192CbcHs384, self).__init__(hashes.SHA384())\n\n\nclass _A256CbcHs512(_AesCbcHmacSha2, JWAAlgorithm):\n\n    name = 'A256CBC-HS512'\n    description = \"AES_256_CBC_HMAC_SHA_512 authenticated\"\n    keysize = 256\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n    def __init__(self):\n        super(_A256CbcHs512, self).__init__(hashes.SHA512())\n\n\nclass _AesGcm(_RawJWE):\n\n    keysize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n        self.wrap_key_size = self.keysize\n\n    # RFC 7518 - 5.3\n    def encrypt(self, k, a, m):\n        \"\"\" Encrypt accoriding to the selected encryption and hashing\n        functions.\n\n        :param k: Encryption key (optional)\n        :param a: Additional Authentication Data\n        :param m: Plaintext\n\n        Returns a dictionary with the computed data.\n        \"\"\"\n        iv = _randombits(96)\n        cipher = Cipher(algorithms.AES(k), modes.GCM(iv),\n                        backend=self.backend)\n        encryptor = cipher.encryptor()\n        encryptor.authenticate_additional_data(a)\n        e = encryptor.update(m) + encryptor.finalize()\n\n        return (iv, e, encryptor.tag)\n\n    def decrypt(self, k, a, iv, e, t):\n        \"\"\" Decrypt accoriding to the selected encryption and hashing\n        functions.\n        :param k: Encryption key (optional)\n        :param a: Additional Authenticated Data\n        :param iv: Initialization Vector\n        :param e: Ciphertext\n        :param t: Authentication Tag\n\n        Returns plaintext or raises an error\n        \"\"\"\n        cipher = Cipher(algorithms.AES(k), modes.GCM(iv, t),\n                        backend=self.backend)\n        decryptor = cipher.decryptor()\n        decryptor.authenticate_additional_data(a)\n        return decryptor.update(e) + decryptor.finalize()\n\n\nclass _A128Gcm(_AesGcm, JWAAlgorithm):\n\n    name = 'A128GCM'\n    description = \"AES GCM using 128-bit key\"\n    keysize = 128\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n\nclass _A192Gcm(_AesGcm, JWAAlgorithm):\n\n    name = 'A192GCM'\n    description = \"AES GCM using 192-bit key\"\n    keysize = 192\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n\nclass _A256Gcm(_AesGcm, JWAAlgorithm):\n\n    name = 'A256GCM'\n    description = \"AES GCM using 256-bit key\"\n    keysize = 256\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n\nclass JWA(object):\n    \"\"\"JWA Signing Algorithms.\n\n    This class provides access to all JWA algorithms.\n    \"\"\"\n\n    algorithms_registry = {\n        'HS256': _HS256,\n        'HS384': _HS384,\n        'HS512': _HS512,\n        'RS256': _RS256,\n        'RS384': _RS384,\n        'RS512': _RS512,\n        'ES256': _ES256,\n        'ES384': _ES384,\n        'ES512': _ES512,\n        'PS256': _PS256,\n        'PS384': _PS384,\n        'PS512': _PS512,\n        'none': _None,\n        'RSA1_5': _Rsa15,\n        'RSA-OAEP': _RsaOaep,\n        'RSA-OAEP-256': _RsaOaep256,\n        'A128KW': _A128KW,\n        'A192KW': _A192KW,\n        'A256KW': _A256KW,\n        'dir': _Direct,\n        'ECDH-ES': _EcdhEs,\n        'ECDH-ES+A128KW': _EcdhEsAes128Kw,\n        'ECDH-ES+A192KW': _EcdhEsAes192Kw,\n        'ECDH-ES+A256KW': _EcdhEsAes256Kw,\n        'A128GCMKW': _A128GcmKw,\n        'A192GCMKW': _A192GcmKw,\n        'A256GCMKW': _A256GcmKw,\n        'PBES2-HS256+A128KW': _Pbes2Hs256A128Kw,\n        'PBES2-HS384+A192KW': _Pbes2Hs384A192Kw,\n        'PBES2-HS512+A256KW': _Pbes2Hs512A256Kw,\n        'A128CBC-HS256': _A128CbcHs256,\n        'A192CBC-HS384': _A192CbcHs384,\n        'A256CBC-HS512': _A256CbcHs512,\n        'A128GCM': _A128Gcm,\n        'A192GCM': _A192Gcm,\n        'A256GCM': _A256Gcm\n    }\n\n    @classmethod\n    def instantiate_alg(cls, name, use=None):\n        alg = cls.algorithms_registry[name]\n        if use is not None and alg.algorithm_use != use:\n            raise KeyError\n        return alg()\n\n    @classmethod\n    def signing_alg(cls, name):\n        try:\n            return cls.instantiate_alg(name, use='sig')\n        except KeyError:\n            raise InvalidJWAAlgorithm(\n                '%s is not a valid Signign algorithm name' % name)\n\n    @classmethod\n    def keymgmt_alg(cls, name):\n        try:\n            return cls.instantiate_alg(name, use='kex')\n        except KeyError:\n            raise InvalidJWAAlgorithm(\n                '%s is not a valid Key Management algorithm name' % name)\n\n    @classmethod\n    def encryption_alg(cls, name):\n        try:\n            return cls.instantiate_alg(name, use='enc')\n        except KeyError:\n            raise InvalidJWAAlgorithm(\n                '%s is not a valid Encryption algorithm name' % name)\n"], "fixing_code": ["# Copyright (C) 2016 JWCrypto Project Contributors - see LICENSE file\n\nimport abc\nimport os\nimport struct\nfrom binascii import hexlify, unhexlify\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import constant_time, hashes, hmac\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric import utils as ec_utils\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives.padding import PKCS7\n\nimport six\n\nfrom jwcrypto.common import InvalidCEKeyLength\nfrom jwcrypto.common import InvalidJWAAlgorithm\nfrom jwcrypto.common import InvalidJWEKeyLength\nfrom jwcrypto.common import InvalidJWEKeyType\nfrom jwcrypto.common import InvalidJWEOperation\nfrom jwcrypto.common import base64url_decode, base64url_encode\nfrom jwcrypto.common import json_decode\nfrom jwcrypto.jwk import JWK\n\n# Implements RFC 7518 - JSON Web Algorithms (JWA)\n\n\n@six.add_metaclass(abc.ABCMeta)\nclass JWAAlgorithm(object):\n\n    @abc.abstractproperty\n    def name(self):\n        \"\"\"The algorithm Name\"\"\"\n        pass\n\n    @abc.abstractproperty\n    def description(self):\n        \"\"\"A short description\"\"\"\n        pass\n\n    @abc.abstractproperty\n    def keysize(self):\n        \"\"\"The actual/recommended/minimum key size\"\"\"\n        pass\n\n    @abc.abstractproperty\n    def algorithm_usage_location(self):\n        \"\"\"One of 'alg', 'enc' or 'JWK'\"\"\"\n        pass\n\n    @abc.abstractproperty\n    def algorithm_use(self):\n        \"\"\"One of 'sig', 'kex', 'enc'\"\"\"\n        pass\n\n\ndef _bitsize(x):\n    return len(x) * 8\n\n\ndef _inbytes(x):\n    return x // 8\n\n\ndef _randombits(x):\n    if x % 8 != 0:\n        raise ValueError(\"lenght must be a multiple of 8\")\n    return os.urandom(_inbytes(x))\n\n\n# Note: the number of bits should be a multiple of 16\ndef _encode_int(n, bits):\n    e = '{:x}'.format(n)\n    ilen = ((bits + 7) // 8) * 2  # number of bytes rounded up times 2 bytes\n    return unhexlify(e.rjust(ilen, '0')[:ilen])\n\n\ndef _decode_int(n):\n    return int(hexlify(n), 16)\n\n\nclass _RawJWS(object):\n\n    def sign(self, key, payload):\n        raise NotImplementedError\n\n    def verify(self, key, payload, signature):\n        raise NotImplementedError\n\n\nclass _RawHMAC(_RawJWS):\n\n    def __init__(self, hashfn):\n        self.backend = default_backend()\n        self.hashfn = hashfn\n\n    def _hmac_setup(self, key, payload):\n        h = hmac.HMAC(key, self.hashfn, backend=self.backend)\n        h.update(payload)\n        return h\n\n    def sign(self, key, payload):\n        skey = base64url_decode(key.get_op_key('sign'))\n        h = self._hmac_setup(skey, payload)\n        return h.finalize()\n\n    def verify(self, key, payload, signature):\n        vkey = base64url_decode(key.get_op_key('verify'))\n        h = self._hmac_setup(vkey, payload)\n        h.verify(signature)\n\n\nclass _RawRSA(_RawJWS):\n    def __init__(self, padfn, hashfn):\n        self.padfn = padfn\n        self.hashfn = hashfn\n\n    def sign(self, key, payload):\n        skey = key.get_op_key('sign')\n        signer = skey.signer(self.padfn, self.hashfn)\n        signer.update(payload)\n        return signer.finalize()\n\n    def verify(self, key, payload, signature):\n        pkey = key.get_op_key('verify')\n        verifier = pkey.verifier(signature, self.padfn, self.hashfn)\n        verifier.update(payload)\n        verifier.verify()\n\n\nclass _RawEC(_RawJWS):\n    def __init__(self, curve, hashfn):\n        self._curve = curve\n        self.hashfn = hashfn\n\n    @property\n    def curve(self):\n        return self._curve\n\n    def sign(self, key, payload):\n        skey = key.get_op_key('sign', self._curve)\n        signer = skey.signer(ec.ECDSA(self.hashfn))\n        signer.update(payload)\n        signature = signer.finalize()\n        r, s = ec_utils.decode_rfc6979_signature(signature)\n        l = key.get_curve(self._curve).key_size\n        return _encode_int(r, l) + _encode_int(s, l)\n\n    def verify(self, key, payload, signature):\n        pkey = key.get_op_key('verify', self._curve)\n        r = signature[:len(signature) // 2]\n        s = signature[len(signature) // 2:]\n        enc_signature = ec_utils.encode_rfc6979_signature(\n            int(hexlify(r), 16), int(hexlify(s), 16))\n        verifier = pkey.verifier(enc_signature, ec.ECDSA(self.hashfn))\n        verifier.update(payload)\n        verifier.verify()\n\n\nclass _RawNone(_RawJWS):\n\n    def sign(self, key, payload):\n        return ''\n\n    def verify(self, key, payload, signature):\n        raise InvalidSignature('The \"none\" signature cannot be verified')\n\n\nclass _HS256(_RawHMAC, JWAAlgorithm):\n\n    name = \"HS256\"\n    description = \"HMAC using SHA-256\"\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_HS256, self).__init__(hashes.SHA256())\n\n\nclass _HS384(_RawHMAC, JWAAlgorithm):\n\n    name = \"HS384\"\n    description = \"HMAC using SHA-384\"\n    keysize = 384\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_HS384, self).__init__(hashes.SHA384())\n\n\nclass _HS512(_RawHMAC, JWAAlgorithm):\n\n    name = \"HS512\"\n    description = \"HMAC using SHA-512\"\n    keysize = 512\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_HS512, self).__init__(hashes.SHA512())\n\n\nclass _RS256(_RawRSA, JWAAlgorithm):\n\n    name = \"RS256\"\n    description = \"RSASSA-PKCS1-v1_5 using SHA-256\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_RS256, self).__init__(padding.PKCS1v15(), hashes.SHA256())\n\n\nclass _RS384(_RawRSA, JWAAlgorithm):\n\n    name = \"RS384\"\n    description = \"RSASSA-PKCS1-v1_5 using SHA-384\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_RS384, self).__init__(padding.PKCS1v15(), hashes.SHA384())\n\n\nclass _RS512(_RawRSA, JWAAlgorithm):\n\n    name = \"RS512\"\n    description = \"RSASSA-PKCS1-v1_5 using SHA-512\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_RS512, self).__init__(padding.PKCS1v15(), hashes.SHA512())\n\n\nclass _ES256(_RawEC, JWAAlgorithm):\n\n    name = \"ES256\"\n    description = \"ECDSA using P-256 and SHA-256\"\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_ES256, self).__init__('P-256', hashes.SHA256())\n\n\nclass _ES384(_RawEC, JWAAlgorithm):\n\n    name = \"ES384\"\n    description = \"ECDSA using P-384 and SHA-384\"\n    keysize = 384\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_ES384, self).__init__('P-384', hashes.SHA384())\n\n\nclass _ES512(_RawEC, JWAAlgorithm):\n\n    name = \"ES512\"\n    description = \"ECDSA using P-521 and SHA-512\"\n    keysize = 512\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        super(_ES512, self).__init__('P-521', hashes.SHA512())\n\n\nclass _PS256(_RawRSA, JWAAlgorithm):\n\n    name = \"PS256\"\n    description = \"RSASSA-PSS using SHA-256 and MGF1 with SHA-256\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        padfn = padding.PSS(padding.MGF1(hashes.SHA256()),\n                            hashes.SHA256.digest_size)\n        super(_PS256, self).__init__(padfn, hashes.SHA256())\n\n\nclass _PS384(_RawRSA, JWAAlgorithm):\n\n    name = \"PS384\"\n    description = \"RSASSA-PSS using SHA-384 and MGF1 with SHA-384\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        padfn = padding.PSS(padding.MGF1(hashes.SHA384()),\n                            hashes.SHA384.digest_size)\n        super(_PS384, self).__init__(padfn, hashes.SHA384())\n\n\nclass _PS512(_RawRSA, JWAAlgorithm):\n\n    name = \"PS512\"\n    description = \"RSASSA-PSS using SHA-512 and MGF1 with SHA-512\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n    def __init__(self):\n        padfn = padding.PSS(padding.MGF1(hashes.SHA512()),\n                            hashes.SHA512.digest_size)\n        super(_PS512, self).__init__(padfn, hashes.SHA512())\n\n\nclass _None(_RawNone, JWAAlgorithm):\n\n    name = \"none\"\n    description = \"No digital signature or MAC performed\"\n    keysize = 0\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'sig'\n\n\nclass _RawKeyMgmt(object):\n\n    def wrap(self, key, bitsize, cek, headers):\n        raise NotImplementedError\n\n    def unwrap(self, key, bitsize, ek, headers):\n        raise NotImplementedError\n\n\nclass _RSA(_RawKeyMgmt):\n\n    def __init__(self, padfn):\n        self.padfn = padfn\n\n    def _check_key(self, key):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'RSA':\n            raise InvalidJWEKeyType('RSA', key.key_type)\n\n    # FIXME: get key size and insure > 2048 bits\n    def wrap(self, key, bitsize, cek, headers):\n        self._check_key(key)\n        if not cek:\n            cek = _randombits(bitsize)\n        rk = key.get_op_key('wrapKey')\n        ek = rk.encrypt(cek, self.padfn)\n        return {'cek': cek, 'ek': ek}\n\n    def unwrap(self, key, bitsize, ek, headers):\n        self._check_key(key)\n        rk = key.get_op_key('decrypt')\n        cek = rk.decrypt(ek, self.padfn)\n        if _bitsize(cek) != bitsize:\n            raise InvalidJWEKeyLength(bitsize, _bitsize(cek))\n        return cek\n\n\nclass _Rsa15(_RSA, JWAAlgorithm):\n\n    name = 'RSA1_5'\n    description = \"RSAES-PKCS1-v1_5\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n    def __init__(self):\n        super(_Rsa15, self).__init__(padding.PKCS1v15())\n\n    def unwrap(self, key, bitsize, ek, headers):\n        self._check_key(key)\n        # Address MMA attack by implementing RFC 3218 - 2.3.2. Random Filling\n        # provides a random cek that will cause the decryption engine to\n        # run to the end, but will fail decryption later.\n\n        # always generate a random cek so we spend roughly the\n        # same time as in the exception side of the branch\n        cek = _randombits(bitsize)\n        try:\n            cek = super(_Rsa15, self).unwrap(key, bitsize, ek, headers)\n            # always raise so we always run through the exception handling\n            # code in all cases\n            raise Exception('Dummy')\n        except Exception:  # pylint: disable=broad-except\n            return cek\n\n\nclass _RsaOaep(_RSA, JWAAlgorithm):\n\n    name = 'RSA-OAEP'\n    description = \"RSAES OAEP using default parameters\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n    def __init__(self):\n        super(_RsaOaep, self).__init__(\n            padding.OAEP(padding.MGF1(hashes.SHA1()),\n                         hashes.SHA1(), None))\n\n\nclass _RsaOaep256(_RSA, JWAAlgorithm):  # noqa: ignore=N801\n\n    name = 'RSA-OAEP-256'\n    description = \"RSAES OAEP using SHA-256 and MGF1 with SHA-256\"\n    keysize = 2048\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n    def __init__(self):\n        super(_RsaOaep256, self).__init__(\n            padding.OAEP(padding.MGF1(hashes.SHA256()),\n                         hashes.SHA256(), None))\n\n\nclass _AesKw(_RawKeyMgmt):\n\n    keysize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n\n    def _get_key(self, key, op):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'oct':\n            raise InvalidJWEKeyType('oct', key.key_type)\n        rk = base64url_decode(key.get_op_key(op))\n        if _bitsize(rk) != self.keysize:\n            raise InvalidJWEKeyLength(self.keysize, _bitsize(rk))\n        return rk\n\n    def wrap(self, key, bitsize, cek, headers):\n        rk = self._get_key(key, 'encrypt')\n        if not cek:\n            cek = _randombits(bitsize)\n\n        # Implement RFC 3394 Key Unwrap - 2.2.2\n        # TODO: Use cryptography once issue #1733 is resolved\n        iv = 'a6a6a6a6a6a6a6a6'\n        a = unhexlify(iv)\n        r = [cek[i:i + 8] for i in range(0, len(cek), 8)]\n        n = len(r)\n        for j in range(0, 6):\n            for i in range(0, n):\n                e = Cipher(algorithms.AES(rk), modes.ECB(),\n                           backend=self.backend).encryptor()\n                b = e.update(a + r[i]) + e.finalize()\n                a = _encode_int(_decode_int(b[:8]) ^ ((n * j) + i + 1), 64)\n                r[i] = b[-8:]\n        ek = a\n        for i in range(0, n):\n            ek += r[i]\n        return {'cek': cek, 'ek': ek}\n\n    def unwrap(self, key, bitsize, ek, headers):\n        rk = self._get_key(key, 'decrypt')\n\n        # Implement RFC 3394 Key Unwrap - 2.2.3\n        # TODO: Use cryptography once issue #1733 is resolved\n        iv = 'a6a6a6a6a6a6a6a6'\n        aiv = unhexlify(iv)\n\n        r = [ek[i:i + 8] for i in range(0, len(ek), 8)]\n        a = r.pop(0)\n        n = len(r)\n        for j in range(5, -1, -1):\n            for i in range(n - 1, -1, -1):\n                da = _decode_int(a)\n                atr = _encode_int((da ^ ((n * j) + i + 1)), 64) + r[i]\n                d = Cipher(algorithms.AES(rk), modes.ECB(),\n                           backend=self.backend).decryptor()\n                b = d.update(atr) + d.finalize()\n                a = b[:8]\n                r[i] = b[-8:]\n\n        if a != aiv:\n            raise RuntimeError('Decryption Failed')\n\n        cek = b''.join(r)\n        if _bitsize(cek) != bitsize:\n            raise InvalidJWEKeyLength(bitsize, _bitsize(cek))\n        return cek\n\n\nclass _A128KW(_AesKw, JWAAlgorithm):\n\n    name = 'A128KW'\n    description = \"AES Key Wrap using 128-bit key\"\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _A192KW(_AesKw, JWAAlgorithm):\n\n    name = 'A192KW'\n    description = \"AES Key Wrap using 192-bit key\"\n    keysize = 192\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _A256KW(_AesKw, JWAAlgorithm):\n\n    name = 'A256KW'\n    description = \"AES Key Wrap using 256-bit key\"\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _AesGcmKw(_RawKeyMgmt):\n\n    keysize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n\n    def _get_key(self, key, op):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'oct':\n            raise InvalidJWEKeyType('oct', key.key_type)\n        rk = base64url_decode(key.get_op_key(op))\n        if _bitsize(rk) != self.keysize:\n            raise InvalidJWEKeyLength(self.keysize, _bitsize(rk))\n        return rk\n\n    def wrap(self, key, bitsize, cek, headers):\n        rk = self._get_key(key, 'encrypt')\n        if not cek:\n            cek = _randombits(bitsize)\n\n        iv = _randombits(96)\n        cipher = Cipher(algorithms.AES(rk), modes.GCM(iv),\n                        backend=self.backend)\n        encryptor = cipher.encryptor()\n        ek = encryptor.update(cek) + encryptor.finalize()\n\n        tag = encryptor.tag\n        return {'cek': cek, 'ek': ek,\n                'header': {'iv': base64url_encode(iv),\n                           'tag': base64url_encode(tag)}}\n\n    def unwrap(self, key, bitsize, ek, headers):\n        rk = self._get_key(key, 'decrypt')\n\n        if 'iv' not in headers:\n            raise ValueError('Invalid Header, missing \"iv\" parameter')\n        iv = base64url_decode(headers['iv'])\n        if 'tag' not in headers:\n            raise ValueError('Invalid Header, missing \"tag\" parameter')\n        tag = base64url_decode(headers['tag'])\n\n        cipher = Cipher(algorithms.AES(rk), modes.GCM(iv, tag),\n                        backend=self.backend)\n        decryptor = cipher.decryptor()\n        cek = decryptor.update(ek) + decryptor.finalize()\n        if _bitsize(cek) != bitsize:\n            raise InvalidJWEKeyLength(bitsize, _bitsize(cek))\n        return cek\n\n\nclass _A128GcmKw(_AesGcmKw, JWAAlgorithm):\n\n    name = 'A128GCMKW'\n    description = \"Key wrapping with AES GCM using 128-bit key\"\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _A192GcmKw(_AesGcmKw, JWAAlgorithm):\n\n    name = 'A192GCMKW'\n    description = \"Key wrapping with AES GCM using 192-bit key\"\n    keysize = 192\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _A256GcmKw(_AesGcmKw, JWAAlgorithm):\n\n    name = 'A256GCMKW'\n    description = \"Key wrapping with AES GCM using 256-bit key\"\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _Pbes2HsAesKw(_RawKeyMgmt):\n\n    name = None\n    keysize = None\n    hashsize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n        self.aeskwmap = {128: _A128KW, 192: _A192KW, 256: _A256KW}\n\n    def _get_key(self, alg, key, p2s, p2c):\n        if isinstance(key, bytes):\n            plain = key\n        else:\n            plain = key.encode('utf8')\n        salt = bytes(self.name.encode('utf8')) + b'\\x00' + p2s\n\n        if self.hashsize == 256:\n            hashalg = hashes.SHA256()\n        elif self.hashsize == 384:\n            hashalg = hashes.SHA384()\n        elif self.hashsize == 512:\n            hashalg = hashes.SHA512()\n        else:\n            raise ValueError('Unknown Hash Size')\n\n        kdf = PBKDF2HMAC(algorithm=hashalg, length=_inbytes(self.keysize),\n                         salt=salt, iterations=p2c, backend=self.backend)\n        rk = kdf.derive(plain)\n        if _bitsize(rk) != self.keysize:\n            raise InvalidJWEKeyLength(self.keysize, len(rk))\n        return JWK(kty=\"oct\", use=\"enc\", k=base64url_encode(rk))\n\n    def wrap(self, key, bitsize, cek, headers):\n        p2s = _randombits(128)\n        p2c = 8192\n        kek = self._get_key(headers['alg'], key, p2s, p2c)\n\n        aeskw = self.aeskwmap[self.keysize]()\n        ret = aeskw.wrap(kek, bitsize, cek, headers)\n        ret['header'] = {'p2s': base64url_encode(p2s), 'p2c': p2c}\n        return ret\n\n    def unwrap(self, key, bitsize, ek, headers):\n        if 'p2s' not in headers:\n            raise ValueError('Invalid Header, missing \"p2s\" parameter')\n        if 'p2c' not in headers:\n            raise ValueError('Invalid Header, missing \"p2c\" parameter')\n        p2s = base64url_decode(headers['p2s'])\n        p2c = headers['p2c']\n        kek = self._get_key(headers['alg'], key, p2s, p2c)\n\n        aeskw = self.aeskwmap[self.keysize]()\n        return aeskw.unwrap(kek, bitsize, ek, headers)\n\n\nclass _Pbes2Hs256A128Kw(_Pbes2HsAesKw, JWAAlgorithm):\n\n    name = 'PBES2-HS256+A128KW'\n    description = 'PBES2 with HMAC SHA-256 and \"A128KW\" wrapping'\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n    hashsize = 256\n\n\nclass _Pbes2Hs384A192Kw(_Pbes2HsAesKw, JWAAlgorithm):\n\n    name = 'PBES2-HS384+A192KW'\n    description = 'PBES2 with HMAC SHA-384 and \"A192KW\" wrapping'\n    keysize = 192\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n    hashsize = 384\n\n\nclass _Pbes2Hs512A256Kw(_Pbes2HsAesKw, JWAAlgorithm):\n\n    name = 'PBES2-HS512+A256KW'\n    description = 'PBES2 with HMAC SHA-512 and \"A256KW\" wrapping'\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n    hashsize = 512\n\n\nclass _Direct(_RawKeyMgmt, JWAAlgorithm):\n\n    name = 'dir'\n    description = \"Direct use of a shared symmetric key\"\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n    def _check_key(self, key):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'oct':\n            raise InvalidJWEKeyType('oct', key.key_type)\n\n    def wrap(self, key, bitsize, cek, headers):\n        self._check_key(key)\n        if cek:\n            return (cek, None)\n        k = base64url_decode(key.get_op_key('encrypt'))\n        if _bitsize(k) != bitsize:\n            raise InvalidCEKeyLength(bitsize, _bitsize(k))\n        return {'cek': k}\n\n    def unwrap(self, key, bitsize, ek, headers):\n        self._check_key(key)\n        if ek != b'':\n            raise ValueError('Invalid Encryption Key.')\n        cek = base64url_decode(key.get_op_key('decrypt'))\n        if _bitsize(cek) != bitsize:\n            raise InvalidJWEKeyLength(bitsize, _bitsize(cek))\n        return cek\n\n\nclass _EcdhEs(_RawKeyMgmt):\n\n    name = 'ECDH-ES'\n    description = \"ECDH-ES using Concat KDF\"\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n    keysize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n        self.aeskwmap = {128: _A128KW, 192: _A192KW, 256: _A256KW}\n\n    def _check_key(self, key):\n        if not isinstance(key, JWK):\n            raise ValueError('key is not a JWK object')\n        if key.key_type != 'EC':\n            raise InvalidJWEKeyType('EC', key.key_type)\n\n    def _derive(self, privkey, pubkey, alg, bitsize, headers):\n        # OtherInfo is defined in NIST SP 56A 5.8.1.2.1\n\n        # AlgorithmID\n        otherinfo = struct.pack('>I', len(alg))\n        otherinfo += bytes(alg.encode('utf8'))\n\n        # PartyUInfo\n        apu = base64url_decode(headers['apu']) if 'apu' in headers else b''\n        otherinfo += struct.pack('>I', len(apu))\n        otherinfo += apu\n\n        # PartyVInfo\n        apv = base64url_decode(headers['apv']) if 'apv' in headers else b''\n        otherinfo += struct.pack('>I', len(apv))\n        otherinfo += apv\n\n        # SuppPubInfo\n        otherinfo += struct.pack('>I', bitsize)\n\n        # no SuppPrivInfo\n\n        shared_key = privkey.exchange(ec.ECDH(), pubkey)\n        ckdf = ConcatKDFHash(algorithm=hashes.SHA256(),\n                             length=_inbytes(bitsize),\n                             otherinfo=otherinfo,\n                             backend=self.backend)\n        return ckdf.derive(shared_key)\n\n    def wrap(self, key, bitsize, cek, headers):\n        self._check_key(key)\n        if self.keysize is None:\n            if cek is not None:\n                raise InvalidJWEOperation('ECDH-ES cannot use an existing CEK')\n            alg = headers['enc']\n        else:\n            bitsize = self.keysize\n            alg = headers['alg']\n\n        epk = JWK.generate(kty=key.key_type, crv=key.key_curve)\n        dk = self._derive(epk.get_op_key('unwrapKey'),\n                          key.get_op_key('wrapKey'),\n                          alg, bitsize, headers)\n\n        if self.keysize is None:\n            ret = {'cek': dk}\n        else:\n            aeskw = self.aeskwmap[bitsize]()\n            kek = JWK(kty=\"oct\", use=\"enc\", k=base64url_encode(dk))\n            ret = aeskw.wrap(kek, bitsize, cek, headers)\n\n        ret['header'] = {'epk': json_decode(epk.export_public())}\n        return ret\n\n    def unwrap(self, key, bitsize, ek, headers):\n        if 'epk' not in headers:\n            raise ValueError('Invalid Header, missing \"epk\" parameter')\n        self._check_key(key)\n        if self.keysize is None:\n            alg = headers['enc']\n        else:\n            bitsize = self.keysize\n            alg = headers['alg']\n\n        epk = JWK(**headers['epk'])\n        dk = self._derive(key.get_op_key('unwrapKey'),\n                          epk.get_op_key('wrapKey'),\n                          alg, bitsize, headers)\n        if self.keysize is None:\n            return dk\n        else:\n            aeskw = self.aeskwmap[bitsize]()\n            kek = JWK(kty=\"oct\", use=\"enc\", k=base64url_encode(dk))\n            cek = aeskw.unwrap(kek, bitsize, ek, headers)\n            return cek\n\n\nclass _EcdhEsAes128Kw(_EcdhEs, JWAAlgorithm):\n\n    name = 'ECDH-ES+A128KW'\n    description = 'ECDH-ES using Concat KDF and \"A128KW\" wrapping'\n    keysize = 128\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _EcdhEsAes192Kw(_EcdhEs, JWAAlgorithm):\n\n    name = 'ECDH-ES+A192KW'\n    description = 'ECDH-ES using Concat KDF and \"A192KW\" wrapping'\n    keysize = 192\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _EcdhEsAes256Kw(_EcdhEs, JWAAlgorithm):\n\n    name = 'ECDH-ES+A256KW'\n    description = 'ECDH-ES using Concat KDF and \"A128KW\" wrapping'\n    keysize = 256\n    algorithm_usage_location = 'alg'\n    algorithm_use = 'kex'\n\n\nclass _RawJWE(object):\n\n    def encrypt(self, k, a, m):\n        raise NotImplementedError\n\n    def decrypt(self, k, a, iv, e, t):\n        raise NotImplementedError\n\n\nclass _AesCbcHmacSha2(_RawJWE):\n\n    keysize = None\n\n    def __init__(self, hashfn):\n        self.backend = default_backend()\n        self.hashfn = hashfn\n        self.blocksize = algorithms.AES.block_size\n        self.wrap_key_size = self.keysize * 2\n\n    def _mac(self, k, a, iv, e):\n        al = _encode_int(_bitsize(a), 64)\n        h = hmac.HMAC(k, self.hashfn, backend=self.backend)\n        h.update(a)\n        h.update(iv)\n        h.update(e)\n        h.update(al)\n        m = h.finalize()\n        return m[:_inbytes(self.keysize)]\n\n    # RFC 7518 - 5.2.2\n    def encrypt(self, k, a, m):\n        \"\"\" Encrypt according to the selected encryption and hashing\n        functions.\n\n        :param k: Encryption key (optional)\n        :param a: Additional Authentication Data\n        :param m: Plaintext\n\n        Returns a dictionary with the computed data.\n        \"\"\"\n        hkey = k[:_inbytes(self.keysize)]\n        ekey = k[_inbytes(self.keysize):]\n\n        # encrypt\n        iv = _randombits(self.blocksize)\n        cipher = Cipher(algorithms.AES(ekey), modes.CBC(iv),\n                        backend=self.backend)\n        encryptor = cipher.encryptor()\n        padder = PKCS7(self.blocksize).padder()\n        padded_data = padder.update(m) + padder.finalize()\n        e = encryptor.update(padded_data) + encryptor.finalize()\n\n        # mac\n        t = self._mac(hkey, a, iv, e)\n\n        return (iv, e, t)\n\n    def decrypt(self, k, a, iv, e, t):\n        \"\"\" Decrypt according to the selected encryption and hashing\n        functions.\n        :param k: Encryption key (optional)\n        :param a: Additional Authenticated Data\n        :param iv: Initialization Vector\n        :param e: Ciphertext\n        :param t: Authentication Tag\n\n        Returns plaintext or raises an error\n        \"\"\"\n        hkey = k[:_inbytes(self.keysize)]\n        dkey = k[_inbytes(self.keysize):]\n\n        # verify mac\n        if not constant_time.bytes_eq(t, self._mac(hkey, a, iv, e)):\n            raise InvalidSignature('Failed to verify MAC')\n\n        # decrypt\n        cipher = Cipher(algorithms.AES(dkey), modes.CBC(iv),\n                        backend=self.backend)\n        decryptor = cipher.decryptor()\n        d = decryptor.update(e) + decryptor.finalize()\n        unpadder = PKCS7(self.blocksize).unpadder()\n        return unpadder.update(d) + unpadder.finalize()\n\n\nclass _A128CbcHs256(_AesCbcHmacSha2, JWAAlgorithm):\n\n    name = 'A128CBC-HS256'\n    description = \"AES_128_CBC_HMAC_SHA_256 authenticated\"\n    keysize = 128\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n    def __init__(self):\n        super(_A128CbcHs256, self).__init__(hashes.SHA256())\n\n\nclass _A192CbcHs384(_AesCbcHmacSha2, JWAAlgorithm):\n\n    name = 'A192CBC-HS384'\n    description = \"AES_192_CBC_HMAC_SHA_384 authenticated\"\n    keysize = 192\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n    def __init__(self):\n        super(_A192CbcHs384, self).__init__(hashes.SHA384())\n\n\nclass _A256CbcHs512(_AesCbcHmacSha2, JWAAlgorithm):\n\n    name = 'A256CBC-HS512'\n    description = \"AES_256_CBC_HMAC_SHA_512 authenticated\"\n    keysize = 256\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n    def __init__(self):\n        super(_A256CbcHs512, self).__init__(hashes.SHA512())\n\n\nclass _AesGcm(_RawJWE):\n\n    keysize = None\n\n    def __init__(self):\n        self.backend = default_backend()\n        self.wrap_key_size = self.keysize\n\n    # RFC 7518 - 5.3\n    def encrypt(self, k, a, m):\n        \"\"\" Encrypt accoriding to the selected encryption and hashing\n        functions.\n\n        :param k: Encryption key (optional)\n        :param a: Additional Authentication Data\n        :param m: Plaintext\n\n        Returns a dictionary with the computed data.\n        \"\"\"\n        iv = _randombits(96)\n        cipher = Cipher(algorithms.AES(k), modes.GCM(iv),\n                        backend=self.backend)\n        encryptor = cipher.encryptor()\n        encryptor.authenticate_additional_data(a)\n        e = encryptor.update(m) + encryptor.finalize()\n\n        return (iv, e, encryptor.tag)\n\n    def decrypt(self, k, a, iv, e, t):\n        \"\"\" Decrypt accoriding to the selected encryption and hashing\n        functions.\n        :param k: Encryption key (optional)\n        :param a: Additional Authenticated Data\n        :param iv: Initialization Vector\n        :param e: Ciphertext\n        :param t: Authentication Tag\n\n        Returns plaintext or raises an error\n        \"\"\"\n        cipher = Cipher(algorithms.AES(k), modes.GCM(iv, t),\n                        backend=self.backend)\n        decryptor = cipher.decryptor()\n        decryptor.authenticate_additional_data(a)\n        return decryptor.update(e) + decryptor.finalize()\n\n\nclass _A128Gcm(_AesGcm, JWAAlgorithm):\n\n    name = 'A128GCM'\n    description = \"AES GCM using 128-bit key\"\n    keysize = 128\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n\nclass _A192Gcm(_AesGcm, JWAAlgorithm):\n\n    name = 'A192GCM'\n    description = \"AES GCM using 192-bit key\"\n    keysize = 192\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n\nclass _A256Gcm(_AesGcm, JWAAlgorithm):\n\n    name = 'A256GCM'\n    description = \"AES GCM using 256-bit key\"\n    keysize = 256\n    algorithm_usage_location = 'enc'\n    algorithm_use = 'enc'\n\n\nclass JWA(object):\n    \"\"\"JWA Signing Algorithms.\n\n    This class provides access to all JWA algorithms.\n    \"\"\"\n\n    algorithms_registry = {\n        'HS256': _HS256,\n        'HS384': _HS384,\n        'HS512': _HS512,\n        'RS256': _RS256,\n        'RS384': _RS384,\n        'RS512': _RS512,\n        'ES256': _ES256,\n        'ES384': _ES384,\n        'ES512': _ES512,\n        'PS256': _PS256,\n        'PS384': _PS384,\n        'PS512': _PS512,\n        'none': _None,\n        'RSA1_5': _Rsa15,\n        'RSA-OAEP': _RsaOaep,\n        'RSA-OAEP-256': _RsaOaep256,\n        'A128KW': _A128KW,\n        'A192KW': _A192KW,\n        'A256KW': _A256KW,\n        'dir': _Direct,\n        'ECDH-ES': _EcdhEs,\n        'ECDH-ES+A128KW': _EcdhEsAes128Kw,\n        'ECDH-ES+A192KW': _EcdhEsAes192Kw,\n        'ECDH-ES+A256KW': _EcdhEsAes256Kw,\n        'A128GCMKW': _A128GcmKw,\n        'A192GCMKW': _A192GcmKw,\n        'A256GCMKW': _A256GcmKw,\n        'PBES2-HS256+A128KW': _Pbes2Hs256A128Kw,\n        'PBES2-HS384+A192KW': _Pbes2Hs384A192Kw,\n        'PBES2-HS512+A256KW': _Pbes2Hs512A256Kw,\n        'A128CBC-HS256': _A128CbcHs256,\n        'A192CBC-HS384': _A192CbcHs384,\n        'A256CBC-HS512': _A256CbcHs512,\n        'A128GCM': _A128Gcm,\n        'A192GCM': _A192Gcm,\n        'A256GCM': _A256Gcm\n    }\n\n    @classmethod\n    def instantiate_alg(cls, name, use=None):\n        alg = cls.algorithms_registry[name]\n        if use is not None and alg.algorithm_use != use:\n            raise KeyError\n        return alg()\n\n    @classmethod\n    def signing_alg(cls, name):\n        try:\n            return cls.instantiate_alg(name, use='sig')\n        except KeyError:\n            raise InvalidJWAAlgorithm(\n                '%s is not a valid Signign algorithm name' % name)\n\n    @classmethod\n    def keymgmt_alg(cls, name):\n        try:\n            return cls.instantiate_alg(name, use='kex')\n        except KeyError:\n            raise InvalidJWAAlgorithm(\n                '%s is not a valid Key Management algorithm name' % name)\n\n    @classmethod\n    def encryption_alg(cls, name):\n        try:\n            return cls.instantiate_alg(name, use='enc')\n        except KeyError:\n            raise InvalidJWAAlgorithm(\n                '%s is not a valid Encryption algorithm name' % name)\n"], "filenames": ["jwcrypto/jwa.py"], "buggy_code_start_loc": [380], "buggy_code_end_loc": [380], "fixing_code_start_loc": [381], "fixing_code_end_loc": [398], "type": "CWE-200", "message": "The _Rsa15 class in the RSA 1.5 algorithm implementation in jwa.py in jwcrypto before 0.3.2 lacks the Random Filling protection mechanism, which makes it easier for remote attackers to obtain cleartext data via a Million Message Attack (MMA).", "other": {"cve": {"id": "CVE-2016-6298", "sourceIdentifier": "secalert@redhat.com", "published": "2016-09-01T23:59:01.160", "lastModified": "2016-11-28T20:31:14.547", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The _Rsa15 class in the RSA 1.5 algorithm implementation in jwa.py in jwcrypto before 0.3.2 lacks the Random Filling protection mechanism, which makes it easier for remote attackers to obtain cleartext data via a Million Message Attack (MMA)."}, {"lang": "es", "value": "La clase _Rsa15 en la implementaci\u00f3n de algoritmo RSA 1.5 en jwa.py en jwcrypto en versiones anteriores a 0.3.2 carece del mecanismo de protecci\u00f3n Random Filling, lo que facilita a atacantes remotos obtener datos en texto plano a trav\u00e9s de un Million Message Attack (MMA)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jwcrypto_project:jwcrypto:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.3.1", "matchCriteriaId": "9AE9884F-4F22-4826-9D85-C1A57BE64BB0"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/92729", "source": "secalert@redhat.com"}, {"url": "https://github.com/latchset/jwcrypto/commit/eb5be5bd94c8cae1d7f3ba9801377084d8e5a7ba", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/latchset/jwcrypto/issues/65", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/latchset/jwcrypto/pull/66", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/latchset/jwcrypto/releases/tag/v0.3.2", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/latchset/jwcrypto/commit/eb5be5bd94c8cae1d7f3ba9801377084d8e5a7ba"}}