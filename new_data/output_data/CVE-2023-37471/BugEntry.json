{"buggy_code": ["/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 2006 Sun Microsystems Inc. All Rights Reserved\n *\n * The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * https://opensso.dev.java.net/public/CDDLv1.0.html or\n * opensso/legal/CDDLv1.0.txt\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at opensso/legal/CDDLv1.0.txt.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: SAMLUtils.java,v 1.16 2010/01/09 19:41:06 qcheng Exp $\n *\n * Portions Copyrighted 2012-2016 ForgeRock AS.\n */\n\npackage com.sun.identity.saml.common;\n\nimport static org.forgerock.openam.utils.Time.*;\n\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Map;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Enumeration;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\nimport java.text.StringCharacterIterator;\nimport java.text.CharacterIterator;\nimport java.io.UnsupportedEncodingException;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.ByteArrayInputStream;\n\nimport java.security.MessageDigest;\n\nimport java.net.URL;\nimport java.net.MalformedURLException;\n\nimport org.w3c.dom.*;\n\nimport com.sun.identity.common.PeriodicGroupRunnable;\nimport com.sun.identity.common.ScheduleableGroupAction;\nimport com.sun.identity.common.SystemConfigurationUtil;\nimport com.sun.identity.common.SystemConfigurationException;\nimport com.sun.identity.common.SystemTimerPool;\nimport com.sun.identity.common.TaskRunnable;\nimport com.sun.identity.common.TimerPool;\nimport com.sun.identity.shared.xml.XMLUtils;\nimport com.sun.identity.shared.encode.URLEncDec;\nimport com.sun.identity.shared.encode.Base64;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletRequest;\n\nimport javax.xml.soap.MimeHeaders;\nimport javax.xml.soap.MimeHeader;\n\nimport com.sun.identity.saml.assertion.SubjectConfirmation;\nimport com.sun.identity.saml.assertion.Assertion;\nimport com.sun.identity.saml.assertion.Attribute;\nimport com.sun.identity.saml.assertion.AttributeStatement;\nimport com.sun.identity.saml.assertion.AuthenticationStatement;\nimport com.sun.identity.saml.assertion.AudienceRestrictionCondition;\nimport com.sun.identity.saml.assertion.Condition;\nimport com.sun.identity.saml.assertion.Conditions;\nimport com.sun.identity.saml.assertion.Statement;\nimport com.sun.identity.saml.assertion.SubjectStatement;\nimport com.sun.identity.saml.xmlsig.XMLSignatureManager;\nimport com.sun.identity.saml.plugins.PartnerAccountMapper;\nimport com.sun.identity.saml.protocol.*;\nimport com.sun.identity.saml.servlet.POSTCleanUpRunnable;\nimport com.sun.identity.plugin.session.SessionException;\nimport com.sun.identity.plugin.session.SessionManager;\nimport com.sun.identity.plugin.session.SessionProvider;\nimport com.sun.identity.saml.assertion.Subject;\nimport com.sun.identity.saml.SAMLClient;\nimport com.sun.identity.federation.common.FSUtils;\n\nimport javax.xml.parsers.DocumentBuilder;\n\nimport org.apache.xml.security.c14n.Canonicalizer;\n\n/**\n * This class contains some utility methods for processing SAML protocols.\n *\n * \n */\npublic class SAMLUtils  extends SAMLUtilsCommon {\n\n    /**\n     * Attribute that specifies maximum content length for SAML request in\n     * <code>AMConfig.properties</code> file.\n     */\n    public static final String HTTP_MAX_CONTENT_LENGTH =\n        \"com.sun.identity.saml.request.maxContentLength\";\n\n    /**\n     * Default maximum content length is set to 16k.\n     */\n    public static final int defaultMaxLength = 16384;\n\n    /**\n     * Default maximum content length in string format.\n     */\n    public static final String DEFAULT_CONTENT_LENGTH =\n    String.valueOf(defaultMaxLength);\n\n    private static final String ERROR_JSP = \"/saml2/jsp/autosubmittingerror.jsp\";\n    \n    private static int maxContentLength = 0;\n    private static Map idTimeMap = Collections.synchronizedMap(new HashMap());\n    private static TaskRunnable cGoThrough = null;\n    private static TaskRunnable cPeriodic = null;\n    private static Object ssoToken;\n \n    static {\n        org.apache.xml.security.Init.init();\n        if (SystemConfigurationUtil.isServerMode()) {\n            long period = ((Integer) SAMLServiceManager.getAttribute(\n                        SAMLConstants.CLEANUP_INTERVAL_NAME)).intValue() * 1000;\n            cGoThrough = new POSTCleanUpRunnable(period, idTimeMap);\n            TimerPool timerPool = SystemTimerPool.getTimerPool();\n            timerPool.schedule(cGoThrough, new Date(((currentTimeMillis()\n                    + period) / 1000) * 1000));\n            ScheduleableGroupAction periodicAction = new\n                ScheduleableGroupAction() {\n                public void doGroupAction(Object obj) {\n                    idTimeMap.remove(obj);\n                }\n            };\n            cPeriodic = new PeriodicGroupRunnable(periodicAction, period,\n                180000, true);\n            timerPool.schedule(cPeriodic, new Date(((currentTimeMillis() +\n                    period) / 1000) * 1000));\n        }\n        try {\n            maxContentLength = Integer.parseInt(SystemConfigurationUtil.\n                getProperty(SAMLUtils.HTTP_MAX_CONTENT_LENGTH,\n                SAMLUtils.DEFAULT_CONTENT_LENGTH));\n        } catch (NumberFormatException ne) {\n            SAMLUtils.debug.error(\"Wrong format of SAML request max content \"\n                + \"length. Take default value.\");\n            maxContentLength=  SAMLUtils.defaultMaxLength;\n        }\n    }\n    \n    /**\n     * Constructor\n     * iPlanet-PRIVATE-DEFAULT-CONSTRUCTOR\n     */\n    private SAMLUtils() {\n    }\n    \n    \n    /**\n     * Generates an ID String with length of SAMLConstants.ID_LENGTH.\n     * @return string the ID String; or null if it fails.\n     */\n    public static String generateAssertionID() {\n        String encodedID = generateID();\n        if (encodedID == null) {\n            return null;\n        }\n        \n        String id = null;\n        try {\n            id = SystemConfigurationUtil.getServerID(\n            SAMLServiceManager.getServerProtocol(),\n            SAMLServiceManager.getServerHost(),\n            Integer.parseInt(SAMLServiceManager.getServerPort()),\n            SAMLServiceManager.getServerURI());\n        } catch (Exception ex) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtil:generateAssertionID: \"\n                + \"exception obtain serverID:\", ex);\n            }\n        }\n        if (id == null) {\n            return encodedID;\n        } else {\n            return (encodedID + id);\n        }\n    }\n    \n    /**\n     * Verifies if an element is a type of a specific query.\n     * Currently, this method is used by class AuthenticationQuery,\n     * AuthorizationDecisionQuery, and AttributeQuery.\n     * @param element a DOM Element which needs to be verified.\n     * @param queryname A specific name of a query, for example,\n     *          AuthenticationQuery, AuthorizationDecisionQuery, or\n     *                AttributeQuery.\n     * @return true if the element is a type of the specified query; false\n     *                otherwise.\n     */\n    public static boolean checkQuery(Element element, String queryname) {\n        String tag = element.getLocalName();\n        if (tag == null) {\n            return false;\n        } else if (tag.equals(\"Query\") || tag.equals(\"SubjectQuery\")) {\n            NamedNodeMap nm = element.getAttributes();\n            int len = nm.getLength();\n            String attrName;\n            Attr attr;\n            boolean found = false;\n            for (int j = 0; j < len; j++) {\n                attr = (Attr) nm.item(j);\n                attrName = attr.getLocalName();\n                if ((attrName != null) && (attrName.equals(\"type\")) &&\n                (attr.getNodeValue().equals(queryname + \"Type\"))) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        } else if (!tag.equals(queryname)) {\n            return false;\n        }\n        return true;\n    }\n    \n    /**\n     * Generates sourceID of a site.\n     * @param siteURL a String that uniquely identifies a site.\n     * @return <code>Base64</code> encoded SHA digest of siteURL.\n     */\n    public static String generateSourceID(String siteURL) {\n        if ((siteURL == null) || (siteURL.length() == 0)) {\n            SAMLUtils.debug.error(\"SAMLUtils.genrateSourceID: empty siteURL.\");\n            return null;\n        }\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (Exception e) {\n            SAMLUtils.debug.error(\"SAMLUtils.generateSourceID: Exception when\"\n            + \" generating digest:\",e);\n            return null;\n        }\n        md.update(SAMLUtils.stringToByteArray(siteURL));\n        byte byteResult[] = md.digest();\n        String result = null;\n        try {\n            result = Base64.encode(byteResult).trim();\n        } catch (Exception e) {\n            SAMLUtils.debug.error(\"SAMLUtils.generateSourceID: Exception:\",e);\n        }\n        return result;\n    }\n\n    /**\n     * Generates assertion handle.\n     * @return 20-byte random string to be used to form an artifact.\n     */\n    public static String generateAssertionHandle() {\n        if (random == null) {\n            return null;\n        }\n        byte bytes[] = new byte[SAMLConstants.ID_LENGTH];\n        random.nextBytes(bytes);\n        String id = null;\n        try {\n            id = SystemConfigurationUtil.getServerID(\n                SAMLServiceManager.getServerProtocol(),\n                SAMLServiceManager.getServerHost(),\n                Integer.parseInt(SAMLServiceManager.getServerPort()),\n                SAMLServiceManager.getServerURI());\n        } catch (Exception ex) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtil:generateAssertionHandle: \"\n                + \"exception obtain serverID:\", ex);\n            }\n        }\n        if (id != null) {\n            byte idBytes[] = stringToByteArray(id);\n            // TODO: should we check if idBytes.length == 2 ?\n            if (idBytes.length < bytes.length) {\n                for (int i = 1; i <= idBytes.length; i++) {\n                    bytes[bytes.length - i] = idBytes[idBytes.length - i];\n                }\n            }\n        }\n        return byteArrayToString(bytes);\n    }\n\n    /**\n     * Converts a HEX encoded string to a byte array.\n     * @param hexString HEX encoded string\n     * @return byte array.\n     */\n    public static byte[] hexStringToByteArray(String hexString) {\n        int read = hexString.length();\n        byte[] byteArray = new byte[read/2];\n        for (int i=0, j=0; i < read; i++, j++) {\n            String part = hexString.substring(i,i+2);\n            byteArray[j] =\n            new Short(Integer.toString(Integer.parseInt(part,16))).\n            byteValue();\n            i++;\n        }\n        return byteArray;\n    }\n\n    /**\n     * Converts HEX encoded string to Base64 encoded string.\n     * @param hexString HEX encoded string.\n     * @return Base64 encoded string.\n     */\n    public static String hexStringToBase64(String hexString) {\n        int read = hexString.length();\n        byte[] byteArray = new byte[read/2];\n        for (int i=0, j=0; i < read; i++, j++) {\n            String part = hexString.substring(i,i+2);\n            byteArray[j] =\n            new Short(Integer.toString(Integer.parseInt(part,16))).\n            byteValue();\n            i++;\n        }\n        String encodedID = null;\n        try {\n            encodedID = Base64.encode(byteArray).trim();\n        } catch (Exception e) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtil:hexStringToBase64: \"\n                + \"exception encode input:\", e);\n            }\n        }\n        if (SAMLUtils.debug.messageEnabled()) {\n            SAMLUtils.debug.message(\"base 64 source id is :\"+encodedID);\n        }\n        return encodedID;\n    }\n    \n    /**\n     * Gets sourceSite corresponding to an issuer from the partner URL list.\n     * @param issuer The issuer string.\n     * @return SAMLServiceManager.SOAPEntry of the issuer if it's on the list;\n     *                        null otherwise.\n     */\n    public static SAMLServiceManager.SOAPEntry getSourceSite(String issuer) {\n        if (issuer == null) {\n            return null;\n        }\n        Map entries = (Map) SAMLServiceManager.getAttribute(\n        SAMLConstants.PARTNER_URLS);\n        if (entries == null) {\n            SAMLUtils.debug.error(\"SAMLUtils.isOnPartnerURLList: PartnerURL \"\n            + \"list is null.\");\n            return null;\n        }\n        \n        Iterator entryIter = entries.values().iterator();\n        boolean found = false;\n        SAMLServiceManager.SOAPEntry srcSite = null;\n        String theIssuer = null;\n        while (entryIter.hasNext()) {\n            srcSite = (SAMLServiceManager.SOAPEntry) entryIter.next();\n            if ((srcSite != null) &&\n            ((theIssuer = srcSite.getIssuer()) != null) &&\n            (theIssuer.equals(issuer))) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            return srcSite;\n        } else {\n            return null;\n        }\n    }\n    \n    /**\n     * Returns site ID based on the host name. The site ID\n     * will be in Base64 encoded format. This method will print out site ID\n     * to the standard output\n     * @param args host name\n     */\n    public static void main(String args[]) {\n        \n        if (args.length != 1) {\n            System.out.println(\"usage : java SAMLUtils <host_name>\");\n            return;\n        }\n        \n        System.out.println(generateSourceID(args[0]));\n    }\n    \n    /**\n     * Checks if a <code>SubjectConfirmation</code> is correct.\n     * @param sc <code>SubjectConfirmation</code> instance to be checked.\n     * @return true if the <code>SubjectConfirmation</code> instance passed in\n     * has only one <code>ConfirmationMethod</code>, and this\n     * <code>ConfirmationMethod</code> is set to\n     * <code>SAMLConstants.CONFIRMATION_METHOD_IS</code>.\n     */\n    public static boolean isCorrectConfirmationMethod(SubjectConfirmation sc) {\n        if (sc == null) {\n            return false;\n        }\n        \n        Set cmSet = sc.getConfirmationMethod();\n        if ((cmSet == null) || (cmSet.size() != 1)) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.isCorrectConfirmationMethod:\"\n                + \" missing ConfirmationMethod in the Subject.\");\n            }\n            return false;\n        }\n        \n        String conMethod = (String) cmSet.iterator().next();\n        if ((conMethod == null) ||\n        (!conMethod.equals(SAMLConstants.CONFIRMATION_METHOD_IS))) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.isCorrectConfirmationMethod:\"\n                + \" wrong ConfirmationMethod value.\");\n            }\n            return false;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Returns true if the assertion is valid both time wise and\n     * signature wise, and contains at least one AuthenticationStatement.\n     * @param assertion <code>Assertion</code> instance to be checked.\n     * @return <code>true</code> if the assertion is valid both time wise and\n     * signature wise, and contains at least one AuthenticationStatement.\n     */\n    public static boolean isAuthNAssertion(Assertion assertion) {\n        if (assertion == null) {\n            return false;\n        }\n        \n        if ((!assertion.isTimeValid()) || (!assertion.isSignatureValid())) {\n            return false;\n        }\n        \n        Set statements = assertion.getStatement();\n        Statement statement = null;\n        Iterator iterator = statements.iterator();\n        while (iterator.hasNext()) {\n            statement = (Statement) iterator.next();\n            if (statement.getStatementType() ==\n            Statement.AUTHENTICATION_STATEMENT) {\n                return true;\n            }\n        } // loop through statements\n        return false;\n    }\n \n    /**\n     * Converts a string to a byte array.\n     * @param input a String to be converted.\n     * @return result byte array.\n     */\n    public static byte[] stringToByteArray(String input) {\n        char chars[] = input.toCharArray();\n        byte bytes[] = new byte[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            bytes[i] = (byte) chars[i];\n        }\n        return bytes;\n    }\n \n\n    /**\n     * Returns server ID.\n     * @param idTypeString An ID string\n     * @return server ID part of the id.\n     */\n    public static String getServerID(String idTypeString) {\n        if (idTypeString == null) {\n            return null;\n        }\n        int len = idTypeString.length();\n        String id = null;\n        if (len >= SAMLConstants.SERVER_ID_LENGTH) {\n            id = idTypeString.substring((len - SAMLConstants.SERVER_ID_LENGTH),\n            len);\n            return id;\n        } else {\n            return null;\n        }\n    }\n    \n    /**\n     * Returns server url of a site.\n     * @param str Server ID.\n     * @return Server url corresponding to the server id.\n     */\n    public static String getServerURL(String str) {\n        String id = SAMLUtils.getServerID(str);\n        if (id == null) {\n            return null;\n        }\n        \n        if (SAMLUtils.debug.messageEnabled()) {\n            SAMLUtils.debug.message(\"SAMLUtils.getServerURL: id=\" + id);\n        }\n        \n        String remoteUrl = null;\n        try {\n            remoteUrl = SystemConfigurationUtil.getServerFromID(id);\n        } catch (SystemConfigurationException se) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.getServerURL: ServerEntry\" +\n                \"NotFoundException for \" + id);\n            }\n            return null;\n        }\n        String thisUrl = SAMLServiceManager.getServerURL();\n        if (SAMLUtils.debug.messageEnabled()) {\n            SAMLUtils.debug.message(\"SAMLUtils.getServerURL: remoteUrl=\" +\n            remoteUrl + \", thisUrl=\" + thisUrl);\n        }\n        if ((remoteUrl == null) || (thisUrl == null) ||\n        (remoteUrl.equalsIgnoreCase(thisUrl))) {\n            return null;\n        } else {\n            return remoteUrl;\n        }\n    }\n    \n    /**\n     * Returns full service url.\n     * @param shortUrl short URL of the service.\n     * @return full service url.\n     */\n    public static String getFullServiceURL(String shortUrl) {\n        String result = null;\n        try {\n            URL u = new URL(shortUrl);\n            URL weburl = SystemConfigurationUtil.getServiceURL(\n                SAMLConstants.SAML_AM_NAMING, u.getProtocol(), u.getHost(),\n                    u.getPort(), u.getPath());\n            result = weburl.toString();\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.getFullServiceURL:\" +\n                \"full remote URL is: \" + result);\n            }\n        } catch (Exception e) {\n            if (SAMLUtils.debug.warningEnabled()) {\n                SAMLUtils.debug.warning(\"SAMLUtils.getFullServiceURL:\" +\n                \"Exception:\", e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns attributes included in <code>AttributeStatement</code> of the\n     * assertion.\n     * @param envParameters return map which includes name value pairs of \n     *   attributes included in <code>AttributeStatement</code> of the assertion\n     * @param assertion an <code>Assertion</code> object which contains\n     *   <code>AttributeStatement</code>\n     * @param subject the <code>Subject</code> instance from\n     *   <code>AuthenticationStatement</code>. The <code>Subject</code>\n     *   included in <code>AttributeStatement</code> must match this\n     *   <code>Subject</code> instance.\n     */\n    public static void addEnvParamsFromAssertion(Map envParameters,\n    Assertion assertion,\n    com.sun.identity.saml.assertion.Subject subject) {\n        Set statements = assertion.getStatement();\n        Statement statement = null;\n        Iterator stmtIter = null;\n        List attrs = null;\n        Iterator attrIter = null;\n        Attribute attribute = null;\n        Element attrValue = null;\n        List attrValues = null;\n        String attrName = null;\n        String attrValueString = null;\n        if ((statements != null) && (!statements.isEmpty())) {\n            stmtIter = statements.iterator();\n            while (stmtIter.hasNext()) {\n                statement = (Statement) stmtIter.next();\n                if (statement.getStatementType() ==\n                Statement.ATTRIBUTE_STATEMENT) {\n                    // check for subject\n                    if (!subject.equals(\n                    ((AttributeStatement)statement).getSubject())) {\n                        continue;\n                    }\n                    \n                    attrs = ((AttributeStatement) statement).getAttribute();\n                    attrIter = attrs.iterator();\n                    while (attrIter.hasNext()) {\n                        attribute = (Attribute) attrIter.next();\n                        try {\n                            attrValues = attribute.getAttributeValue();\n                        } catch (Exception e) {\n                            debug.error(\"SAMLUtils.addEnvParamsFromAssertion:\"+\n                            \" cannot obtain attribute value:\", e);\n                            continue;\n                        }\n                        attrName = attribute.getAttributeName();\n                        List attrValueList = null;\n\n                        for(Iterator avIter = attrValues.iterator();\n                            avIter.hasNext(); ) {\n\n                            attrValue = (Element) avIter.next();\n                            if (!XMLUtils.hasElementChild(attrValue)) {\n                                attrValueString =\n                                    XMLUtils.getElementValue(attrValue);\n                                if (attrValueList == null) {\n                                    attrValueList = new ArrayList();\n                                }\n                                attrValueList.add(attrValueString);\n                            }\n                        }\n                        if (attrValueList != null) {\n                            if (debug.messageEnabled()) {\n                                debug.message(\n                                    \"SAMLUtils.addEnvParamsFromAssertion:\" +\n                                    \" attrName = \" + attrName +\n                                    \" attrValue = \" + attrValueList);\n                            }\n                            String[] attrValueStrs = (String[])attrValueList.\n                                toArray(new String[attrValueList.size()]);\n                            try {\n                                envParameters.put(attrName, attrValueStrs);\n                            } catch (Exception ex) {\n                                if (debug.messageEnabled()) {\n                                    debug.message(\n                                        \"SAMLUtils.addEnvParamsFromAssertion:\",\n                                        ex);\n                                }\n                            }\n                        } else if (debug.messageEnabled()) {\n                            if (debug.messageEnabled()) {\n                                debug.message(\n                                    \"SAMLUtils.addEnvParamsFromAssertion:\" +\n                                    \" attrName = \" + attrName +\n                                    \" has no value\");\n                            }\n                        }\n                    }\n                } // if it's an attribute statement\n            }\n        }\n    }\n\n    /**\n     * Returns maximum content length of a SAML request.\n     * @return maximum content length of a SAML request.\n     */\n    public static int getMaxContentLength() {\n        return maxContentLength;\n    }\n    \n    // ************************************************************************\n    // Methods used by SAML Servlets\n    // ************************************************************************\n \n    /**\n     * Checks content length of a http request to avoid dos attack.\n     * In case SAML inter-op with other SAML vendor who may not provide content\n     * length in HttpServletRequest. We decide to support no length restriction\n     * for Http communication. Here, we use a special value (e.g. 0) to\n     * indicate that no enforcement is required.\n     * @param request <code>HttpServletRequest</code> instance to be checked.\n     * @exception ServletException if context length of the request exceeds\n     *   maximum content length allowed.\n     */\n    public static void checkHTTPContentLength(HttpServletRequest request)\n    throws ServletException {\n        if (maxContentLength != 0) {\n            int length =  request.getContentLength();\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"HttpRequest content length= \" +length);\n            }\n            if (length > maxContentLength) {\n                if (SAMLUtils.debug.messageEnabled()) {\n                    SAMLUtils.debug.message(\n                        \"content length too large\" + length);\n                }\n                throw new ServletException(\n                SAMLUtils.bundle.getString(\"largeContentLength\"));\n            }\n        }\n    }\n    \n    /**\n     * Post assertions and attributes to the target url.\n     * This method opens a URL connection to the target specified and POSTs\n     * assertions to it using the passed HttpServletResponse object. It POSTs\n     * multiple parameter names \"assertion\" with value being each of the \n     * <code>Assertion</code> in the passed Set.\n     * @param response <code>HttpServletResponse</code> object\n     * @param out The print writer which for content is to be written too.\n     * @param assertion List of <code>Assertion</code>s to be posted.\n     * @param targeturl target url\n     * @param attrMap Map of attributes to be posted to the target\n     */\n    public static void postToTarget(HttpServletResponse response, PrintWriter out,\n                                    List assertion, String targeturl, Map attrMap) throws IOException {\n        out.println(\"<HTML>\");\n        out.println(\"<HEAD>\\n\");\n        out.println(\"<TITLE>Access rights validated</TITLE>\\n\");\n        out.println(\"</HEAD>\\n\");\n        out.println(\"<BODY Onload=\\\"document.forms[0].submit()\\\">\");\n        Iterator it = null;\n        if (SAMLUtils.debug.messageEnabled()) {\n            out.println(\"<H1>Access rights validated</H1>\\n\");\n            out.println(\"<meta http-equiv=\\\"refresh\\\" content=\\\"20\\\">\\n\");\n            out.println(\"<P>We have verified your access rights <STRONG>\" +\n            \"</STRONG> according to the assertion shown \"\n            +\"below. \\n\");\n            out.println(\"You are being redirected to the resource.\\n\");\n            out.println(\"Please wait ......\\n\");\n            out.println(\"</P>\\n\");\n            out.println(\"<HR><P>\\n\");\n            if (assertion != null) {\n                it = assertion.iterator();\n                while (it.hasNext()) {\n                    out.println(SAMLUtils.displayXML((String)it.next()));\n                }\n            }\n            out.println(\"</P>\\n\");\n        }\n        out.println(\"<FORM METHOD=\\\"POST\\\" ACTION=\\\"\" + targeturl + \"\\\">\");\n        if (assertion != null) {\n            it = assertion.iterator();\n            while (it.hasNext()) {\n                out.println(\"<INPUT TYPE=\\\"HIDDEN\\\" NAME=\\\"\"+\n                SAMLConstants.POST_ASSERTION_NAME + \"\\\"\");\n                out.println(\"VALUE=\\\"\" +\n                    URLEncDec.encode((String)it.next()) + \"\\\">\");\n            }\n        }\n        if (attrMap != null && !attrMap.isEmpty()) {\n            StringBuffer attrNamesSB = new StringBuffer();\n            Set entrySet = attrMap.entrySet();\n            for(Iterator iter = entrySet.iterator(); iter.hasNext();) {\n                Map.Entry entry = (Map.Entry)iter.next();\n                String attrName = HTMLEncode((String)entry.getKey(), '\\\"');\n                String attrValue = HTMLEncode((String)entry.getValue(), '\\\"');\n                out.println(\"<INPUT TYPE=\\\"HIDDEN\\\" NAME=\\\"\"+ attrName +\n                \"\\\" VALUE=\\\"\" + attrValue + \"\\\">\");\n                if (attrNamesSB.length() > 0) {\n                    attrNamesSB.append(\":\");\n                }\n                attrNamesSB.append(attrName);\n            }\n            out.println(\"<INPUT TYPE=\\\"HIDDEN\\\" NAME=\\\"\"+\n            SAMLConstants.POST_ATTR_NAMES + \"\\\" VALUE=\\\"\" +\n            attrNamesSB + \"\\\">\");\n        }\n        out.println(\"</FORM>\");\n        out.println(\"</BODY></HTML>\");\n        out.close();\n    }\n    \n    /**\n     * Returns true of false based on whether the target passed as parameter\n     * accepts form POST.\n     * @param targetIn url to be checked\n     * @return true if it should post assertion to the target passed in; false\n     *   otherwise.\n     */\n    public static boolean postYN(String targetIn) {\n        SAMLUtils.debug.message(\"Inside postYN()\");\n        if ((targetIn == null) || (targetIn.length() == 0)) {\n            return false;\n        }\n        Set targets = (Set) SAMLServiceManager.\n        getAttribute(SAMLConstants.POST_TO_TARGET_URLS);\n        if ((targets == null) || (targets.size() == 0)) {\n            return false;\n        }\n        URL targetUrl = null;\n        try {\n            targetUrl = new URL(targetIn);\n        } catch (MalformedURLException me ) {\n            SAMLUtils.debug.error(\"SAMLUtils:postYN(): Malformed URL passed\");\n            return false;\n        }\n        String targetInHost = targetUrl.getHost();\n        int targetInPort = targetUrl.getPort();\n        String targetInPath = targetUrl.getPath();\n        // making target string without protocol\n        String targetToCompare = new StringBuffer(targetInHost.toLowerCase())\n        .append(\":\").append(String.valueOf(targetInPort))\n        .append(\"/\").append(targetInPath).toString();\n        if (targets.contains(targetToCompare)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    /**\n     * Replaces every occurence of ch with \n     * \"&#&lt;ascii code of ch>;\"\n     * @param srcStr orginal string to to be encoded.\n     * @param ch the charactor needs to be encoded.\n     * @return encoded string\n     */\n    public static String HTMLEncode(String srcStr, char ch) {\n        if (srcStr == null) {\n            return null;\n        }\n        \n        int fromIndex = 0;\n        int toIndex;\n        StringBuffer dstSB = new StringBuffer();\n        \n        while((toIndex = srcStr.indexOf(ch, fromIndex)) != -1) {\n            dstSB.append(srcStr.substring(fromIndex, toIndex))\n            .append(\"&#\" + (int)ch + \";\");\n            fromIndex = toIndex + 1;\n        }\n        dstSB.append(srcStr.substring(fromIndex));\n        \n        return dstSB.toString();\n    }\n\n    /**\n     * Displays an XML string.\n     * This is a utility function used to hack up an HTML display of an XML\n     * string.\n     * @param input original string\n     * @return encoded string so it can be displayed properly by html.\n     */\n    public static String displayXML(String input) {\n        debug.message(\"In displayXML \");\n        StringCharacterIterator iter = new StringCharacterIterator(input);\n        StringBuffer buf = new StringBuffer();\n        \n        for(char c = iter.first();c != CharacterIterator.DONE;c = iter.next()) {\n            if (c=='>') {\n                buf.append(\"&gt;\");\n            } else if (c=='<') {\n                buf.append(\"&lt;\");\n            } else if (c=='\\n'){\n                buf.append(\"<BR>\\n\");\n            } else {\n                buf.append(c);\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Gets the list of <code>Assertion</code> objects from a list of\n     * 'String' assertions.\n     * @param assertions List of assertions in string format\n     * @return List of <code>Assertion</code> objects\n     */\n    public static List getListOfAssertions(List assertions) {\n        List returnAssertions = new ArrayList();\n        try {\n            if (assertions != null) {\n                Iterator it = assertions.iterator();\n                while (it.hasNext()) {\n                    Document doc = XMLUtils.toDOMDocument((String)it.next(),\n                                                            debug);\n                    Element root = doc.getDocumentElement();\n                    if (root != null) {\n                        Assertion assertion = new Assertion(root);\n                        returnAssertions.add(assertion);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (debug.messageEnabled()) {\n                debug.message(\"SAMLUtils.getListOfAssertions : \" +\n                \"Exception : \", e);\n            }\n        }\n        return returnAssertions;\n    }\n    \n    \n    // ************************************************************************\n    // Methods used / shared by SAML Authentication Module and SAML Servlets\n    // ************************************************************************\n\n    /**\n     * Returns byte array from a SAML <code>Response</code>.\n     * @param samlResponse <code>Response</code> object\n     * @return byte array\n     * @exception SAMLException if error occurrs during the process.\n     */\n    public static byte[] getResponseBytes(Response samlResponse)\n        throws SAMLException\n    {\n        byte ret[] = null;\n        try {\n            ret = samlResponse.toString(true, true, true).\n            getBytes(SAMLConstants.DEFAULT_ENCODING);\n        } catch (UnsupportedEncodingException ue) {\n            if (debug.messageEnabled()) {\n                debug.message(\"getResponseBytes : \" , ue);\n            }\n            throw new SAMLException(ue.getMessage());\n        }\n        return ret;\n    }\n \n    /**\n     * Returns <code>Response</code> object from byte array.\n     * @param bytes byte array\n     * @return <code>Response</code> object\n     */\n    public static Response getResponse(byte [] bytes) {\n        Response temp = null;\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            temp = Response.parseXML(new ByteArrayInputStream(bytes));\n        } catch (SAMLException se) {\n            debug.error(\"getResponse : \" , se);\n        }\n        return temp;\n    }\n\n    /**\n     * Verifies a <code>Response</code>.\n     * @param response SAML <code>Response</code> object\n     * @param requestUrl this server's POST profile URL\n     * @param request <code>HttpServletRequest</code> object\n     * @return true if the response is valid; false otherwise.\n     */\n    public static boolean verifyResponse(Response response,\n    String requestUrl, HttpServletRequest request) {\n        if (!response.isSignatureValid()) {\n            debug.message(\"verifyResponse: Response's signature is invalid.\");\n            return false;\n        }\n\n        // check Recipient == this server's POST profile URL(requestURL)\n        String recipient = response.getRecipient();\n        if ((recipient == null) || (recipient.length() == 0) ||\n        ((!equalURL(recipient, requestUrl)) &&\n        (!equalURL(recipient,getLBURL(requestUrl, request))))) {\n            debug.error(\"verifyResponse : Incorrect Recipient.\");\n            return false;\n        }\n        \n        // check status of the Response\n        if (!response.getStatus().getStatusCode().getValue().endsWith(\n        SAMLConstants.STATUS_CODE_SUCCESS_NO_PREFIX)) {\n            debug.error(\"verifyResponse : Incorrect StatusCode value.\");\n            return false;\n        }\n        \n        return true;\n    }\n    \n    private static String getLBURL(String requestUrl,\n                                 HttpServletRequest request)\n    {\n        String host = request.getHeader(\"host\");\n        if (host == null) {\n            return requestUrl;\n        }\n        int index = requestUrl.indexOf(\"//\");\n        if (index == -1) {\n            return requestUrl;\n        }\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(requestUrl.substring(0, index + 2)).append(host);\n        String rest = requestUrl.substring(index +2, requestUrl.length());\n        if ((index = rest.indexOf(\"/\")) != -1) {\n            sb.append(rest.substring(index, rest.length()));\n        }\n        if (debug.messageEnabled()) {\n            debug.message(\"getLBURL: LBURL = \" + sb.toString());\n        }\n        return sb.toString().trim();\n    }\n    \n    // ************************************************************************\n    // Methods used by SAML Authentication Module\n    // ************************************************************************\n    \n    /**\n     * Gets List of assertions in String format from a list of \n     * <code>Assertion</code> objects.\n     * @param assertions List of <code>Assertion</code> objects.\n     * @return List of assertions in String format\n     */\n    public static List getStrAssertions(List assertions) {\n        List returnAssertions = new ArrayList();\n        if (assertions != null) {\n            Iterator it = assertions.iterator();\n            while (it.hasNext()) {\n                returnAssertions.add(\n                    ((Assertion)(it.next())).toString(true,true));\n            }\n        }\n        return returnAssertions;\n    }\n    \n    /**\n     * Verifies Signature for Post response.\n     * @param samlResponse <code>Response</code> object from post profile.\n     * @return true if the signature on the reponse is valid; false otherwise.\n     */\n    public static boolean verifySignature(Response samlResponse) {\n        if ((samlResponse != null) &&\n        (!samlResponse.isSigned() || (!samlResponse.isSignatureValid()))) {\n            return false;\n        }\n        return true;\n    }\n    \n    /**\n     * Gets Attribute Map to be set in the Session.\n     * @param partnerdest <code>SOAPEntry</code> object\n     * @param assertions List of <code>Assertion</code>s\n     * @param subject <code>Subject</code> object\n     * @param target target of final SSO\n     * @return Map which contains name and attributes.\n     * @exception Exception if an error occurrs.\n     */\n    public static Map getAttributeMap(\n    SAMLServiceManager.SOAPEntry partnerdest,\n    List assertions,\n    com.sun.identity.saml.assertion.Subject subject,\n    String target)\n    throws Exception {\n        String srcID = partnerdest.getSourceID();\n        String name = null;\n        String org = null;\n        Map attrMap = new HashMap();\n        PartnerAccountMapper paMapper = partnerdest.getPartnerAccountMapper();\n        \n        if (paMapper != null) {\n            Map map = paMapper.getUser(assertions, srcID, target);\n            name = (String) map.get(PartnerAccountMapper.NAME);\n            org =  (String) map.get(PartnerAccountMapper.ORG);\n            attrMap = (Map) map.get(PartnerAccountMapper.ATTRIBUTE);\n        }\n        \n        if (attrMap == null) {\n            attrMap = new HashMap();\n        }\n        attrMap.put(SAMLConstants.USER_NAME, name);\n        if ((org != null) && (org.length() != 0)) {\n            attrMap.put(SessionProvider.REALM, org);\n        } else {\n            attrMap.put(SessionProvider.REALM, \"/\");\n        }\n        \n        if (debug.messageEnabled()) {\n            debug.message(\"getAttributeMap : \" + \"name = \" +\n            name + \", realm=\" + org + \", attrMap = \" + attrMap);\n        }\n        \n        return attrMap;\n    }\n    \n    /**\n     * Checks response and get back a Map of relevant data including,\n     * Subject, SOAPEntry for the partner and the List of Assertions.\n     * @param response <code>Response</code> object\n     * @return Map of data including Subject, SOAPEntry, and list of assertions.\n     */\n    public static Map verifyAssertionAndGetSSMap(Response response) {\n        // loop to check assertions\n        com.sun.identity.saml.assertion.Subject subject = null;\n        SAMLServiceManager.SOAPEntry srcSite = null;\n        List assertions = response.getAssertion();\n        Iterator iter = assertions.iterator();\n        Assertion assertion = null;\n        String aIDString = null;\n        String issuer = null;\n        Iterator stmtIter = null;\n        Statement statement = null;\n        int stmtType = Statement.NOT_SUPPORTED;\n        com.sun.identity.saml.assertion.Subject sub = null;\n        SubjectConfirmation subConf = null;\n        Set confMethods = null;\n        String confMethod = null;\n        Date date = null;\n        while (iter.hasNext()) {\n            assertion = (Assertion) iter.next();\n            aIDString = assertion.getAssertionID();\n            // make sure it's not being used\n            if (idTimeMap.containsKey(aIDString)) {\n                debug.error(\"verifyAssertion \"\n                + \"AndGetSSMap: Assertion: \" + aIDString + \" is used.\");\n                return null;\n            }\n            \n            // check issuer of the assertions\n            issuer = assertion.getIssuer();\n            if ((srcSite = SAMLUtils.getSourceSite(issuer)) == null) {\n                debug.error(\"verifyAsserti \"\n                + \"onAndGetSSMap: issuer is not on the Partner list.\");\n                return null;\n            }\n            \n            if (!assertion.isSignatureValid()) {\n                debug.error(\"verifyAssertion \"\n                + \"AndGetSSMap: assertion's signature is not valid.\");\n                return null;\n            }\n            \n            // must be valid (timewise)\n            if (!assertion.isTimeValid()) {\n                debug.error(\"verifyAssertion \"\n                + \"AndGetSSMap: assertion's time is not valid.\");\n                return null;\n            }\n            \n            // TODO: IssuerInstant of the assertion is within a few minutes\n            // This is a MAY in spec. Which number to use for the few minutes?\n            \n            // TODO: check AudienceRestrictionCondition\n            \n            //for each assertion, loop to check each statement\n            stmtIter = assertion.getStatement().iterator();\n            while (stmtIter.hasNext()) {\n                statement = (Statement) stmtIter.next();\n                stmtType = statement.getStatementType();\n                if ((stmtType == Statement.AUTHENTICATION_STATEMENT) ||\n                (stmtType == Statement.ATTRIBUTE_STATEMENT) ||\n                (stmtType == Statement.AUTHORIZATION_DECISION_STATEMENT)) {\n                    sub = ((SubjectStatement)statement).getSubject();\n                    \n                    // ConfirmationMethod of each subject must be set to bearer\n                    if (((subConf = sub.getSubjectConfirmation()) == null) ||\n                    ((confMethods = subConf.getConfirmationMethod())\n                    == null) ||\n                    (confMethods.size() != 1)) {\n                        debug.error(\"verify \"\n                        + \"AssertionAndGetSSMap: missing or extra \"\n                        + \"ConfirmationMethod.\");\n                        return null;\n                    }\n                    if (((confMethod = (String) confMethods.iterator().next())\n                    == null) ||\n                    (!confMethod.equals(\n                    SAMLConstants.CONFIRMATION_METHOD_BEARER))) {\n                        debug.error(\"verify \"\n                        + \"AssertionAndGetSSMap:wrong ConfirmationMethod.\");\n                        return null;\n                    }\n                    \n                    //TODO: must contain same Subject for all statements?\n                    \n                    if (stmtType == Statement.AUTHENTICATION_STATEMENT) {\n                        //TODO: if it has SubjectLocality,its IP must == sender\n                        // browser IP. This is a MAY item in the spec.\n                        if (subject == null) {\n                            subject = sub;\n                        }\n                    }\n                }\n            }\n            \n            // add the assertion to idTimeMap\n            if (debug.messageEnabled()) {\n                debug.message(\"Adding \" + aIDString + \" to idTimeMap.\");\n            }\n            Conditions conds = assertion.getConditions();\n            if ((conds != null) && ((date = conds.getNotOnorAfter()) != null)) {\n                cGoThrough.addElement(aIDString);\n                idTimeMap.put(aIDString, new Long(date.getTime()));\n            } else {\n                cPeriodic.addElement(aIDString);\n                // it doesn't matter what we store for the value.\n                idTimeMap.put(aIDString, aIDString);\n            }\n        }\n        \n        // must have at least one SSO assertion\n        if ((subject == null) || (srcSite == null)) {\n            debug.error(\"verifyAssertion AndGetSSMap: couldn't find Subject.\");\n            return null;\n        }\n        Map ssMap = new HashMap();\n        ssMap.put(SAMLConstants.SUBJECT, subject);\n        ssMap.put(SAMLConstants.SOURCE_SITE_SOAP_ENTRY, srcSite);\n        ssMap.put(SAMLConstants.POST_ASSERTION, assertions);\n        return ssMap;\n    }\n    \n    /**\n     * Checks if the Assertion is time valid and\n     * if the Assertion is allowed by AudienceRestrictionCondition.\n     *\n     * @param assertion an Assertion object\n     * @return true if the operation is successful otherwise, return false\n     * @exception IOException IOException\n     */\n    private static boolean checkCondition(Assertion assertion)\n        throws IOException\n    {\n        if (assertion == null) {\n            return false;\n        }\n        if (!assertion.isSignatureValid()) {\n            debug.error(bundle.getString(\"assertionSignatureNotValid\"));\n            return false;\n        }\n        // check if the Assertion is time valid\n        if (!(assertion.isTimeValid())) {\n            debug.error(bundle.getString(\"assertionTimeNotValid\"));\n            return false;\n        }\n        // check the Assertion is allowed by AudienceRestrictionCondition\n        Conditions cnds = assertion.getConditions();\n        Set audienceCnd = new HashSet();\n        audienceCnd = cnds.getAudienceRestrictionCondition();\n        Iterator it = null;\n        if (audienceCnd != null) {\n            if (!audienceCnd.isEmpty()) {\n                it = audienceCnd.iterator();\n                while (it.hasNext()) {\n                    if ((((AudienceRestrictionCondition) it.next()).\n                    evaluate()) == Condition.INDETERMINATE ) {\n                        if (debug.messageEnabled()) {\n                            debug.message(\"Audience \" +\n                            \"RestrictionConditions is indeterminate.\");\n                        }\n                    } else {\n                        debug.error(\"Failed AudienceRestrictionCondition\");\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Determines if there is a valid SSO Assertion\n     * inside of SAML Response.\n     *\n     * @param assertions a List of <code>Assertion</code> objects\n     * @return a Subject object\n     * @exception IOException IOException\n     */\n    public static com.sun.identity.saml.assertion.Subject examAssertions(\n    List assertions) throws IOException {\n        if (assertions == null) {\n            return null;\n        }\n        boolean validation = false;\n        com.sun.identity.saml.assertion.Subject subject = null;\n        Iterator iter = assertions.iterator();\n        \n        while (iter.hasNext()) {\n            Assertion assertion = (Assertion)iter.next();\n            \n            if (!checkCondition(assertion)) {\n                return null;\n            }\n            debug.message(\"Passed checking Conditions!\");\n            \n            // exam the Statement inside the Assertion\n            Set statements = new HashSet();\n            statements = assertion.getStatement();\n            \n            if (statements == null || statements.isEmpty()) {\n                debug.error(bundle.getString(\"noStatement\"));\n                return null;\n            }\n            Iterator iterator = statements.iterator();\n            while (iterator.hasNext()) {\n                Statement statement = (Statement) iterator.next();\n                subject = ((SubjectStatement)statement).getSubject();\n                SubjectConfirmation sc = subject.getSubjectConfirmation();\n                Set cm = new HashSet();\n                cm =  sc.getConfirmationMethod();\n                if (cm == null || cm.isEmpty()) {\n                    debug.error(\"Subject confirmation method is null\");\n                    return null;\n                }\n                String conMethod = (String) cm.iterator().next();\n                // add checking artifact confirmation method identifier based\n                // on Assertion version number\n                if ((conMethod != null) && (assertion.getMajorVersion() ==\n                SAMLConstants.ASSERTION_MAJOR_VERSION) &&\n                (((assertion.getMinorVersion() ==\n                SAMLConstants.ASSERTION_MINOR_VERSION_ONE) &&\n                conMethod.equals(SAMLConstants.CONFIRMATION_METHOD_ARTIFACT))\n                ||\n                ((assertion.getMinorVersion() ==\n                SAMLConstants.ASSERTION_MINOR_VERSION_ZERO) &&\n                (conMethod.equals(\n                SAMLConstants.DEPRECATED_CONFIRMATION_METHOD_ARTIFACT))))) {\n                    if (debug.messageEnabled()) {\n                        debug.message(\"Correct Confirmation method\");\n                    }\n                } else {\n                    debug.error(\"Wrong Confirmation Method.\");\n                    return null;\n                }\n                if (statement instanceof AuthenticationStatement) {\n                    //found an SSO Assertion\n                    validation = true;\n                }\n            }  // end of  while (iterator.hasNext()) for Statements\n        } // end of while (iter.hasNext()) for Assertions\n        \n        if (!validation) {\n            debug.error(bundle.getString(\"noSSOAssertion\"));\n            return null;\n        }\n        return subject;\n    }\n\n    /**\n     * Return whether the signature on the object is valid or not.\n     * @param xmlString input XML String \n     * @param idAttribute ASSERTION_ID_ATTRIBUTE or RESPONSE_ID_ATTRIBUTE\n     * @param issuer the issuer of the Assertion \n     * @return true if the signature on the object is valid; false otherwise.\n     */\n    public static boolean checkSignatureValid(String xmlString, \n                                                  String idAttribute, \n                                                  String issuer)\n    {\n            String certAlias = null;\n            boolean valid = true; \n            Map entries = (Map) SAMLServiceManager.getAttribute(\n                                SAMLConstants.PARTNER_URLS);\n        if (entries != null) {\n            SAMLServiceManager.SOAPEntry srcSite =\n                (SAMLServiceManager.SOAPEntry) entries.get(issuer);\n            if (srcSite != null) {\n                certAlias = srcSite.getCertAlias();\n            }\n        }\n      \n        try {\n            SAMLUtils.debug.message(\"SAMLUtils.checkSignatureValid for certAlias {}\", certAlias);\n            XMLSignatureManager manager = XMLSignatureManager.getInstance();\n            valid = manager.verifyXMLSignature(xmlString, \n                                   idAttribute, certAlias);\n        } catch (Exception e) {\n            SAMLUtils.debug.warning(\"SAMLUtils.checkSignatureValid:\"+\n                                \" signature validation exception\", e);\n            valid = false;\n        }\n        if (!valid) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.checkSignatureValid:\"+\n                                        \" Couldn't verify signature.\");\n            }\n        }\n        return valid;\n    }\n\n    /**\n     * Sets the given <code>HttpServletResponse</code> object with the\n     * headers in the given <code>MimeHeaders</code> object.\n     * @param headers the <code>MimeHeaders</code> object\n     * @param response the <code>HttpServletResponse</code> object to which the\n     *        headers are to be written.\n     */\n    public static void setMimeHeaders(\n         MimeHeaders headers, HttpServletResponse response) {\n        \n         if(headers == null || response == null) {\n            debug.message(\"SAMLUtils.setMimeHeaders : null input\");\n            return;\n         }\n\n         for (Iterator iter = headers.getAllHeaders(); iter.hasNext();){\n              MimeHeader header = (MimeHeader)iter.next();\n\n              String[] values = headers.getHeader(header.getName());\n              if (values.length == 1) {\n                  response.setHeader(header.getName(), header.getValue());\n              } else {\n                  StringBuffer concat = new StringBuffer();\n                  int i = 0;\n                  while (i < values.length) {\n                      if (i != 0) {\n                          concat.append(',');\n                      }\n                      concat.append(values[i++]);\n                   }\n                   response.setHeader(header.getName(),concat.toString());\n              }\n\n         }\n         return; \n    }\n\n    /**\n     * Returns a <code>MimeHeaders</code> object that contains the headers\n     * in the given <code>HttpServletRequest</code> object.\n     *\n     * @param req the <code>HttpServletRequest</code> object.\n     * @return a new <code>MimeHeaders</code> object containing the headers.\n     */\n    public static MimeHeaders getMimeHeaders(HttpServletRequest req) {\n\n         MimeHeaders headers = new MimeHeaders();\n\n         if(req == null) {\n            debug.message(\"SAMLUtils.getMimeHeaders: null input\");\n            return headers;\n         }\n\n         Enumeration enumerator = req.getHeaderNames();\n\n         while(enumerator.hasMoreElements()) {\n             String headerName = (String)enumerator.nextElement();\n             String headerValue = req.getHeader(headerName);\n\n             StringTokenizer values = new StringTokenizer(headerValue, \",\");\n             while(values.hasMoreTokens()) {\n                 headers.addHeader(headerName, values.nextToken().trim());\n             }\n         }\n\n         return headers; \n    }\n     \n    /**\n     * Returns the authenticaion login url with goto parameter\n     * in the given <code>HttpServletRequest</code> object.\n     *\n     * @param req the <code>HttpServletRequest</code> object.\n     * @return a new authenticaion login url with goto parameter.\n     */\n    public static String getLoginRedirectURL(HttpServletRequest req) {\n        String qs = req.getQueryString();\n        String gotoUrl = req.getRequestURL().toString();\n        String key = null; \n        if (qs != null && qs.length() > 0) {\n            gotoUrl = gotoUrl + \"?\" + qs;\n            int startIdx = -1;\n            int endIdx = -1; \n            StringBuffer result = new StringBuffer(); \n            if ((startIdx = qs.indexOf((String) SAMLServiceManager.\n                getAttribute(SAMLConstants.TARGET_SPECIFIER))) > 0) {\n                result.append(qs.substring(0, startIdx - 1)); \n            }    \n            if ((endIdx = qs.indexOf(\"&\", startIdx)) != -1) {\n                if (startIdx == 0) {\n                    result.append(qs.substring(endIdx + 1)); \n                } else {\n                    result.append(qs.substring(endIdx));\n                }    \n            } \n            key = result.toString();\n        }\n\n        String reqUrl = req.getScheme() + \"://\" + req.getServerName() + \":\" +\n            req.getServerPort() + req.getContextPath();\n        String redirectUrl = null;\n        if (key == null || key.equals(\"\")) {\n            redirectUrl = reqUrl +\"/UI/Login?goto=\" +  \n                URLEncDec.encode(gotoUrl);\n        } else {\n            redirectUrl = reqUrl +\"/UI/Login?\" + key + \"&goto=\"+ \n                URLEncDec.encode(gotoUrl);\n        }\n        if (SAMLUtils.debug.messageEnabled()) {\n            SAMLUtils.debug.message(\"Redirect to auth login via:\" +\n                redirectUrl);\n        }    \n        return redirectUrl; \n    }    \n    \n      \n    /** \n     * Processes SAML Artifact\n     * @param artifact SAML Artifact\n     * @param target Target URL \n     * @return Attribute Map\n     * @exception SAMLException if failed to get the Assertions or\n     *     Attribute Map.\n     */\n    public static Map processArtifact(String[] artifact, String target) \n        throws SAMLException {\n        List assts = null;  \n        Subject assertionSubject = null; \n        AssertionArtifact firstArtifact = null;  \n        Map sessMap = null; \n        // Call SAMLClient to do the Single-sign-on\n        try {\n            assts = SAMLClient.artifactQueryHandler(artifact, (String) null);\n            //exam the SAML response\n            if ((assertionSubject = examAssertions(assts)) == null) {\n                return null; \n            }\n            firstArtifact = new AssertionArtifact(artifact[0]);\n            String sid = firstArtifact.getSourceID();\n            Map partner = (Map) SAMLServiceManager.getAttribute(\n                SAMLConstants.PARTNER_URLS);\n            if (partner == null) {\n                throw new SAMLException(bundle.getString\n                    (\"nullPartnerUrl\"));\n            }\n            SAMLServiceManager.SOAPEntry partnerdest = \n                (SAMLServiceManager.SOAPEntry) partner.get(sid);\n            if (partnerdest == null) {\n                throw new SAMLException(bundle.getString\n                    (\"failedAccountMapping\"));\n            }\n            sessMap = getAttributeMap(partnerdest, assts,\n                assertionSubject, target); \n        } catch (Exception se) {\n            debug.error(\"SAMLUtils.processArtifact :\" , se);\n            throw new SAMLException(\n                bundle.getString(\"failProcessArtifact\"));\n        }    \n        return sessMap;   \n    }\n    \n    /**\n     * Creates Session \n     * @param request HttpServletRequest\n     * @param response HttpServletResponse\n     * @param attrMap Attribute Map \n     * @exception if failed to create Session\n     */\n    public static Object generateSession(HttpServletRequest request,\n        HttpServletResponse response, \n        Map attrMap) throws SAMLException {  \n        Map sessionInfoMap = new HashMap();\n        String realm = (String) attrMap.get(SessionProvider.REALM);\n        if ((realm == null) || (realm.length() == 0)) {\n            realm = \"/\";\n        } \n        sessionInfoMap.put(SessionProvider.REALM, realm);\n        String principalName = \n            (String) attrMap.get(SessionProvider.PRINCIPAL_NAME);\n        if (principalName == null) {\n            principalName = (String) attrMap.get(SAMLConstants.USER_NAME);\n        }\n        sessionInfoMap.put(SessionProvider.PRINCIPAL_NAME, principalName);\n        //TODO: sessionInfoMap.put(SessionProvider.AUTH_LEVEL, \"0\");\n        Object session = null;  \n        try {  \n            SessionProvider sessionProvider = SessionManager.getProvider();\n            session = sessionProvider.createSession(\n                sessionInfoMap, request, response, null);\n            setAttrMapInSession(sessionProvider, attrMap, session);\n        } catch (SessionException se) {\n            if (debug.messageEnabled()) {\n                debug.message(\"SAMLUtils.generateSession:\", se);\n            }\n            throw new SAMLException(se);\n        }\n        return session;\n    }\n    \n    /**\n     * Processes SAML Response\n     * @param samlResponse SAML Response object\n     * @param target Target URL \n     * @return Attribute Map\n     * @exception SAMLException if failed to get Attribute Map.\n     */\n    public static Map processResponse(Response samlResponse, String target) \n        throws SAMLException {\n        List assertions = null;    \n        SAMLServiceManager.SOAPEntry partnerdest = null;\n        Subject assertionSubject = null;\n        if (samlResponse.isSigned()) {\n            // verify the signature\n            boolean isSignedandValid = verifySignature(samlResponse);\n            if (!isSignedandValid) {\n                throw new SAMLException(bundle.getString(\"invalidResponse\"));\n            }\n        }\n        // check Assertion and get back a Map of relevant data including,\n        // Subject, SOAPEntry for the partner and the List of Assertions.\n        Map ssMap = verifyAssertionAndGetSSMap(samlResponse);\n        if (debug.messageEnabled()) {\n            debug.message(\"processResponse: ssMap = \" + ssMap);\n        }\n        \n        if (ssMap == null) {\n            throw new SAMLException(bundle.getString(\"invalidAssertion\"));\n        }\n        assertionSubject = (com.sun.identity.saml.assertion.Subject)\n            ssMap.get(SAMLConstants.SUBJECT);\n        if (assertionSubject == null) {\n            throw new SAMLException(bundle.getString(\"nullSubject\"));\n        }\n        \n        partnerdest = (SAMLServiceManager.SOAPEntry)ssMap\n            .get(SAMLConstants.SOURCE_SITE_SOAP_ENTRY);\n        if (partnerdest == null) {\n            throw new SAMLException(bundle.getString(\"failedAccountMapping\"));\n        }\n        \n        assertions = (List)ssMap.get(SAMLConstants.POST_ASSERTION);\n        Map sessMap = null;\n        try { \n            sessMap = getAttributeMap(partnerdest, assertions,\n                assertionSubject, target); \n        } catch (Exception se) {\n            debug.error(\"SAMLUtils.processResponse :\" , se);\n            throw new SAMLException(\n                bundle.getString(\"failProcessResponse\"));\n        }\n        return sessMap;\n    }\n    \n    /**\n     *Sets the attribute map in the session\n     *\n     *@param attrMap, the Attribute Map\n     *@param session, the valid session object\n     *@exception SessionException if failed to set Attribute in the \n     *    Session.  \n     */\n    private static void setAttrMapInSession(\n        SessionProvider sessionProvider,\n        Map attrMap, Object session)\n        throws SessionException {\n        if (attrMap != null && !attrMap.isEmpty()) {\n            Set entrySet = attrMap.entrySet();\n            for(Iterator iter = entrySet.iterator(); iter.hasNext();) {\n                Map.Entry entry = (Map.Entry)iter.next();\n                String attrName = (String)entry.getKey();\n                String[] attrValues = null;\n                if (attrName.equals(SAMLConstants.USER_NAME) ||\n                    attrName.equals(SessionProvider.PRINCIPAL_NAME)) {\n                    String attrValue = (String)entry.getValue();\n                    attrValues = new String[1];\n                    attrValues[0] = attrValue;\n                } else if (attrName.equals(SessionProvider.REALM) ||\n                    attrName.equals(SessionProvider.AUTH_LEVEL)) {\n                    // ignore\n                    continue; \n                } else {\n                    attrValues = (String[])entry.getValue();\n                }\n                sessionProvider.setProperty(session, attrName, attrValues);\n                if (debug.messageEnabled()) {\n                    debug.message(\"SAMLUtils.setAttrMapInSessioin: attrName =\"+\n                        attrName);\n                }\n            }\n        } \n    }\n\n    /**\n     * Compares two URLs to see if they are equal. Two URLs are equal if\n     * they have same protocol, host, port and path (case ignored).\n     * Note : the method is provided to avoid URL.equals() call which requires\n     * name lookup. Name lookup is a blocking operation and very expensive\n     * if the hostname could not be resolved.\n     *\n     * @return true if the URLs are equal, false otherwise.\n     */\n    private static boolean equalURL(String url1, String url2) {\n        try {\n            URL u1 = new URL(url1);\n            URL u2 = new URL(url2);\n            int port1 = u1.getPort();\n            if (port1 == -1) {\n                port1 = u1.getDefaultPort();\n            }\n            int port2 = u2.getPort();\n            if (port2 == -1) {\n                port2 = u2.getDefaultPort();\n            }\n            if ((u1.getProtocol().equalsIgnoreCase(u2.getProtocol())) &&\n                (u1.getHost().equalsIgnoreCase(u2.getHost())) &&\n                (port1 == port2) &&\n                (u1.getPath().equalsIgnoreCase(u2.getPath()))) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (MalformedURLException m) {\n            debug.message(\"Error in SAMLUtils.equalURL\", m);\n            return false;\n        }\n    }\n\n      /**\n       * Gets input Node Canonicalized\n       *\n       * @param node Node\n       * @return Canonical element if the operation succeeded.\n       *     Otherwise, return null.\n       */\n      public static Element getCanonicalElement(Node node) {\n          try {\n              Canonicalizer c14n = Canonicalizer.getInstance(\n                  \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\");\n              byte outputBytes[] = c14n.canonicalizeSubtree(node);\n              DocumentBuilder documentBuilder = \n                 XMLUtils.getSafeDocumentBuilder(false);\n              Document doc = documentBuilder.parse(\n                  new ByteArrayInputStream(outputBytes));\n              Element result = doc.getDocumentElement();\n              return result;\n          } catch (Exception e) {\n              SAMLUtils.debug.error(\"Response:getCanonicalElement: \" +\n                  \"Error while performing canonicalization on \" +\n                  \"the input Node.\");\n              return null;\n          }\n      }\n      \n     /**\n      * Sends to error page URL for SAML protocols. If the error page is\n      * hosted in the same web application, forward is used with\n      * parameters. Otherwise, redirection or HTTP POST is used with\n      * parameters.\n      * Three parameters are passed to the error URL:\n      *  -- errorcode : Error key, this is the I18n key of the error message.\n      *  -- httpstatuscode : Http status code for the error\n      *  -- message : detailed I18n'd error message\n      * @param request HttpServletRequest object\n      * @param response HttpServletResponse object\n      * @param httpStatusCode Http Status code\n      * @param errorCode Error code\n      * @param errorMsg Detailed error message\n      */\n     public static void sendError(HttpServletRequest request,\n         HttpServletResponse response, int httpStatusCode,\n         String errorCode, String errorMsg) {\n                 String errorUrl = SystemConfigurationUtil.getProperty(\n               SAMLConstants.ERROR_PAGE_URL,\n               SAMLConstants.DEFAULT_ERROR_PAGE_URL);\n         if(debug.messageEnabled()) {\n            debug.message(\"SAMLUtils.sendError: error page\" + errorUrl);\n         }\n         String tmp = errorUrl.toLowerCase();\n         if (!tmp.startsWith(\"http://\") && !tmp.startsWith(\"https://\")) {\n             // use forward\n             String jointString = \"?\";\n             if (errorUrl.indexOf(\"?\") != -1) {\n                 jointString = \"&\";\n             }\n             String newUrl = errorUrl.trim() + jointString\n                  + SAMLConstants.ERROR_CODE + \"=\" + errorCode + \"&\"\n                  + SAMLConstants.HTTP_STATUS_CODE + \"=\" + httpStatusCode\n                  + \"&\" + SAMLConstants.ERROR_MESSAGE + \"=\"\n                  + URLEncDec.encode(errorMsg);\n\n             forwardRequest(newUrl, request, response);\n         } else {\n           String binding = SystemConfigurationUtil.getProperty(\n                            SAMLConstants.ERROR_PAGE_HTTP_BINDING,\n                            SAMLConstants.HTTP_POST);\n           if(SAMLConstants.HTTP_REDIRECT.equals(binding)) {\n               // use FSUtils, this may be redirection or forward\n              String jointString = \"?\";\n              if (errorUrl.indexOf(\"?\") != -1) {\n                  jointString = \"&\";\n              }\n              String newUrl = errorUrl.trim() + jointString\n                   + SAMLConstants.ERROR_CODE + \"=\" + errorCode + \"&\"\n                   + SAMLConstants.HTTP_STATUS_CODE + \"=\" + httpStatusCode\n                   + \"&\" + SAMLConstants.ERROR_MESSAGE + \"=\"\n                   + URLEncDec.encode(errorMsg);\n\n              FSUtils.forwardRequest(request, response, newUrl) ;\n           } else {\n               // Populate request attributes to be available for rendering.\n               request.setAttribute(\"ERROR_URL\", errorUrl);\n               request.setAttribute(\"ERROR_CODE_NAME\", SAMLConstants.ERROR_CODE);\n               request.setAttribute(\"ERROR_CODE\", errorCode);\n               request.setAttribute(\"ERROR_MESSAGE_NAME\", SAMLConstants.ERROR_MESSAGE);\n               request.setAttribute(\"ERROR_MESSAGE\", URLEncDec.encode(errorMsg));\n               request.setAttribute(\"HTTP_STATUS_CODE_NAME\", SAMLConstants.HTTP_STATUS_CODE);\n               request.setAttribute(\"HTTP_STATUS_CODE\", httpStatusCode);\n               request.setAttribute(\"SAML_ERROR_KEY\", bundle.getString(\"samlErrorKey\"));\n               // Forward to auto-submitting form.\n               forwardRequest(ERROR_JSP, request, response);\n           }\n         }\n     }\n\n    /**\n     * Forwards to the passed URL.\n     *\n     * @param url\n     *         Forward URL\n     * @param request\n     *         Request object\n     * @param response\n     *         Response object\n     */\n    private static void forwardRequest(String url, HttpServletRequest request, HttpServletResponse response) {\n        try {\n            request.getRequestDispatcher(url).forward(request, response);\n\n        } catch (ServletException sE) {\n            handleForwardError(url, sE, response);\n        } catch (IOException ioE) {\n            handleForwardError(url, ioE, response);\n        }\n    }\n\n    /**\n     * Handle any forward error.\n     *\n     * @param url\n     *         Attempted forward URL\n     * @param exception\n     *         Caught exception\n     * @param response\n     *         Response object\n     */\n    private static void handleForwardError(String url, Exception exception, HttpServletResponse response) {\n        debug.error(\"SAMLUtils.sendError: Exception occurred while trying to forward to resource: \" + url, exception);\n\n        try {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, exception.getMessage());\n        } catch (IOException ioE) {\n            debug.error(\"Failed to inform the response of caught exception\", ioE);\n        }\n    }\n\n}\n"], "fixing_code": ["/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 2006 Sun Microsystems Inc. All Rights Reserved\n *\n * The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * https://opensso.dev.java.net/public/CDDLv1.0.html or\n * opensso/legal/CDDLv1.0.txt\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at opensso/legal/CDDLv1.0.txt.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: SAMLUtils.java,v 1.16 2010/01/09 19:41:06 qcheng Exp $\n *\n * Portions Copyrighted 2012-2016 ForgeRock AS.\n */\n\npackage com.sun.identity.saml.common;\n\nimport static org.forgerock.openam.utils.Time.*;\n\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Map;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Enumeration;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\nimport java.text.StringCharacterIterator;\nimport java.text.CharacterIterator;\nimport java.io.UnsupportedEncodingException;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.ByteArrayInputStream;\n\nimport java.security.MessageDigest;\n\nimport java.net.URL;\nimport java.net.MalformedURLException;\n\nimport org.w3c.dom.*;\n\nimport com.sun.identity.common.PeriodicGroupRunnable;\nimport com.sun.identity.common.ScheduleableGroupAction;\nimport com.sun.identity.common.SystemConfigurationUtil;\nimport com.sun.identity.common.SystemConfigurationException;\nimport com.sun.identity.common.SystemTimerPool;\nimport com.sun.identity.common.TaskRunnable;\nimport com.sun.identity.common.TimerPool;\nimport com.sun.identity.shared.xml.XMLUtils;\nimport com.sun.identity.shared.encode.URLEncDec;\nimport com.sun.identity.shared.encode.Base64;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletRequest;\n\nimport javax.xml.soap.MimeHeaders;\nimport javax.xml.soap.MimeHeader;\n\nimport com.sun.identity.saml.assertion.SubjectConfirmation;\nimport com.sun.identity.saml.assertion.Assertion;\nimport com.sun.identity.saml.assertion.Attribute;\nimport com.sun.identity.saml.assertion.AttributeStatement;\nimport com.sun.identity.saml.assertion.AuthenticationStatement;\nimport com.sun.identity.saml.assertion.AudienceRestrictionCondition;\nimport com.sun.identity.saml.assertion.Condition;\nimport com.sun.identity.saml.assertion.Conditions;\nimport com.sun.identity.saml.assertion.Statement;\nimport com.sun.identity.saml.assertion.SubjectStatement;\nimport com.sun.identity.saml.xmlsig.XMLSignatureManager;\nimport com.sun.identity.saml.plugins.PartnerAccountMapper;\nimport com.sun.identity.saml.protocol.*;\nimport com.sun.identity.saml.servlet.POSTCleanUpRunnable;\nimport com.sun.identity.plugin.session.SessionException;\nimport com.sun.identity.plugin.session.SessionManager;\nimport com.sun.identity.plugin.session.SessionProvider;\nimport com.sun.identity.saml.assertion.Subject;\nimport com.sun.identity.saml.SAMLClient;\nimport com.sun.identity.federation.common.FSUtils;\n\nimport javax.xml.parsers.DocumentBuilder;\n\nimport org.apache.xml.security.c14n.Canonicalizer;\n\n/**\n * This class contains some utility methods for processing SAML protocols.\n *\n * \n */\npublic class SAMLUtils  extends SAMLUtilsCommon {\n\n    /**\n     * Attribute that specifies maximum content length for SAML request in\n     * <code>AMConfig.properties</code> file.\n     */\n    public static final String HTTP_MAX_CONTENT_LENGTH =\n        \"com.sun.identity.saml.request.maxContentLength\";\n\n    /**\n     * Default maximum content length is set to 16k.\n     */\n    public static final int defaultMaxLength = 16384;\n\n    /**\n     * Default maximum content length in string format.\n     */\n    public static final String DEFAULT_CONTENT_LENGTH =\n    String.valueOf(defaultMaxLength);\n\n    private static final String ERROR_JSP = \"/saml2/jsp/autosubmittingerror.jsp\";\n    \n    private static int maxContentLength = 0;\n    private static Map idTimeMap = Collections.synchronizedMap(new HashMap());\n    private static TaskRunnable cGoThrough = null;\n    private static TaskRunnable cPeriodic = null;\n    private static Object ssoToken;\n \n    static {\n        org.apache.xml.security.Init.init();\n        if (SystemConfigurationUtil.isServerMode()) {\n            long period = ((Integer) SAMLServiceManager.getAttribute(\n                        SAMLConstants.CLEANUP_INTERVAL_NAME)).intValue() * 1000;\n            cGoThrough = new POSTCleanUpRunnable(period, idTimeMap);\n            TimerPool timerPool = SystemTimerPool.getTimerPool();\n            timerPool.schedule(cGoThrough, new Date(((currentTimeMillis()\n                    + period) / 1000) * 1000));\n            ScheduleableGroupAction periodicAction = new\n                ScheduleableGroupAction() {\n                public void doGroupAction(Object obj) {\n                    idTimeMap.remove(obj);\n                }\n            };\n            cPeriodic = new PeriodicGroupRunnable(periodicAction, period,\n                180000, true);\n            timerPool.schedule(cPeriodic, new Date(((currentTimeMillis() +\n                    period) / 1000) * 1000));\n        }\n        try {\n            maxContentLength = Integer.parseInt(SystemConfigurationUtil.\n                getProperty(SAMLUtils.HTTP_MAX_CONTENT_LENGTH,\n                SAMLUtils.DEFAULT_CONTENT_LENGTH));\n        } catch (NumberFormatException ne) {\n            SAMLUtils.debug.error(\"Wrong format of SAML request max content \"\n                + \"length. Take default value.\");\n            maxContentLength=  SAMLUtils.defaultMaxLength;\n        }\n    }\n    \n    /**\n     * Constructor\n     * iPlanet-PRIVATE-DEFAULT-CONSTRUCTOR\n     */\n    private SAMLUtils() {\n    }\n    \n    \n    /**\n     * Generates an ID String with length of SAMLConstants.ID_LENGTH.\n     * @return string the ID String; or null if it fails.\n     */\n    public static String generateAssertionID() {\n        String encodedID = generateID();\n        if (encodedID == null) {\n            return null;\n        }\n        \n        String id = null;\n        try {\n            id = SystemConfigurationUtil.getServerID(\n            SAMLServiceManager.getServerProtocol(),\n            SAMLServiceManager.getServerHost(),\n            Integer.parseInt(SAMLServiceManager.getServerPort()),\n            SAMLServiceManager.getServerURI());\n        } catch (Exception ex) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtil:generateAssertionID: \"\n                + \"exception obtain serverID:\", ex);\n            }\n        }\n        if (id == null) {\n            return encodedID;\n        } else {\n            return (encodedID + id);\n        }\n    }\n    \n    /**\n     * Verifies if an element is a type of a specific query.\n     * Currently, this method is used by class AuthenticationQuery,\n     * AuthorizationDecisionQuery, and AttributeQuery.\n     * @param element a DOM Element which needs to be verified.\n     * @param queryname A specific name of a query, for example,\n     *          AuthenticationQuery, AuthorizationDecisionQuery, or\n     *                AttributeQuery.\n     * @return true if the element is a type of the specified query; false\n     *                otherwise.\n     */\n    public static boolean checkQuery(Element element, String queryname) {\n        String tag = element.getLocalName();\n        if (tag == null) {\n            return false;\n        } else if (tag.equals(\"Query\") || tag.equals(\"SubjectQuery\")) {\n            NamedNodeMap nm = element.getAttributes();\n            int len = nm.getLength();\n            String attrName;\n            Attr attr;\n            boolean found = false;\n            for (int j = 0; j < len; j++) {\n                attr = (Attr) nm.item(j);\n                attrName = attr.getLocalName();\n                if ((attrName != null) && (attrName.equals(\"type\")) &&\n                (attr.getNodeValue().equals(queryname + \"Type\"))) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        } else if (!tag.equals(queryname)) {\n            return false;\n        }\n        return true;\n    }\n    \n    /**\n     * Generates sourceID of a site.\n     * @param siteURL a String that uniquely identifies a site.\n     * @return <code>Base64</code> encoded SHA digest of siteURL.\n     */\n    public static String generateSourceID(String siteURL) {\n        if ((siteURL == null) || (siteURL.length() == 0)) {\n            SAMLUtils.debug.error(\"SAMLUtils.genrateSourceID: empty siteURL.\");\n            return null;\n        }\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (Exception e) {\n            SAMLUtils.debug.error(\"SAMLUtils.generateSourceID: Exception when\"\n            + \" generating digest:\",e);\n            return null;\n        }\n        md.update(SAMLUtils.stringToByteArray(siteURL));\n        byte byteResult[] = md.digest();\n        String result = null;\n        try {\n            result = Base64.encode(byteResult).trim();\n        } catch (Exception e) {\n            SAMLUtils.debug.error(\"SAMLUtils.generateSourceID: Exception:\",e);\n        }\n        return result;\n    }\n\n    /**\n     * Generates assertion handle.\n     * @return 20-byte random string to be used to form an artifact.\n     */\n    public static String generateAssertionHandle() {\n        if (random == null) {\n            return null;\n        }\n        byte bytes[] = new byte[SAMLConstants.ID_LENGTH];\n        random.nextBytes(bytes);\n        String id = null;\n        try {\n            id = SystemConfigurationUtil.getServerID(\n                SAMLServiceManager.getServerProtocol(),\n                SAMLServiceManager.getServerHost(),\n                Integer.parseInt(SAMLServiceManager.getServerPort()),\n                SAMLServiceManager.getServerURI());\n        } catch (Exception ex) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtil:generateAssertionHandle: \"\n                + \"exception obtain serverID:\", ex);\n            }\n        }\n        if (id != null) {\n            byte idBytes[] = stringToByteArray(id);\n            // TODO: should we check if idBytes.length == 2 ?\n            if (idBytes.length < bytes.length) {\n                for (int i = 1; i <= idBytes.length; i++) {\n                    bytes[bytes.length - i] = idBytes[idBytes.length - i];\n                }\n            }\n        }\n        return byteArrayToString(bytes);\n    }\n\n    /**\n     * Converts a HEX encoded string to a byte array.\n     * @param hexString HEX encoded string\n     * @return byte array.\n     */\n    public static byte[] hexStringToByteArray(String hexString) {\n        int read = hexString.length();\n        byte[] byteArray = new byte[read/2];\n        for (int i=0, j=0; i < read; i++, j++) {\n            String part = hexString.substring(i,i+2);\n            byteArray[j] =\n            new Short(Integer.toString(Integer.parseInt(part,16))).\n            byteValue();\n            i++;\n        }\n        return byteArray;\n    }\n\n    /**\n     * Converts HEX encoded string to Base64 encoded string.\n     * @param hexString HEX encoded string.\n     * @return Base64 encoded string.\n     */\n    public static String hexStringToBase64(String hexString) {\n        int read = hexString.length();\n        byte[] byteArray = new byte[read/2];\n        for (int i=0, j=0; i < read; i++, j++) {\n            String part = hexString.substring(i,i+2);\n            byteArray[j] =\n            new Short(Integer.toString(Integer.parseInt(part,16))).\n            byteValue();\n            i++;\n        }\n        String encodedID = null;\n        try {\n            encodedID = Base64.encode(byteArray).trim();\n        } catch (Exception e) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtil:hexStringToBase64: \"\n                + \"exception encode input:\", e);\n            }\n        }\n        if (SAMLUtils.debug.messageEnabled()) {\n            SAMLUtils.debug.message(\"base 64 source id is :\"+encodedID);\n        }\n        return encodedID;\n    }\n    \n    /**\n     * Gets sourceSite corresponding to an issuer from the partner URL list.\n     * @param issuer The issuer string.\n     * @return SAMLServiceManager.SOAPEntry of the issuer if it's on the list;\n     *                        null otherwise.\n     */\n    public static SAMLServiceManager.SOAPEntry getSourceSite(String issuer) {\n        if (issuer == null) {\n            return null;\n        }\n        Map entries = (Map) SAMLServiceManager.getAttribute(\n        SAMLConstants.PARTNER_URLS);\n        if (entries == null) {\n            SAMLUtils.debug.error(\"SAMLUtils.isOnPartnerURLList: PartnerURL \"\n            + \"list is null.\");\n            return null;\n        }\n        \n        Iterator entryIter = entries.values().iterator();\n        boolean found = false;\n        SAMLServiceManager.SOAPEntry srcSite = null;\n        String theIssuer = null;\n        while (entryIter.hasNext()) {\n            srcSite = (SAMLServiceManager.SOAPEntry) entryIter.next();\n            if ((srcSite != null) &&\n            ((theIssuer = srcSite.getIssuer()) != null) &&\n            (theIssuer.equals(issuer))) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            return srcSite;\n        } else {\n            return null;\n        }\n    }\n    \n    /**\n     * Returns site ID based on the host name. The site ID\n     * will be in Base64 encoded format. This method will print out site ID\n     * to the standard output\n     * @param args host name\n     */\n    public static void main(String args[]) {\n        \n        if (args.length != 1) {\n            System.out.println(\"usage : java SAMLUtils <host_name>\");\n            return;\n        }\n        \n        System.out.println(generateSourceID(args[0]));\n    }\n    \n    /**\n     * Checks if a <code>SubjectConfirmation</code> is correct.\n     * @param sc <code>SubjectConfirmation</code> instance to be checked.\n     * @return true if the <code>SubjectConfirmation</code> instance passed in\n     * has only one <code>ConfirmationMethod</code>, and this\n     * <code>ConfirmationMethod</code> is set to\n     * <code>SAMLConstants.CONFIRMATION_METHOD_IS</code>.\n     */\n    public static boolean isCorrectConfirmationMethod(SubjectConfirmation sc) {\n        if (sc == null) {\n            return false;\n        }\n        \n        Set cmSet = sc.getConfirmationMethod();\n        if ((cmSet == null) || (cmSet.size() != 1)) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.isCorrectConfirmationMethod:\"\n                + \" missing ConfirmationMethod in the Subject.\");\n            }\n            return false;\n        }\n        \n        String conMethod = (String) cmSet.iterator().next();\n        if ((conMethod == null) ||\n        (!conMethod.equals(SAMLConstants.CONFIRMATION_METHOD_IS))) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.isCorrectConfirmationMethod:\"\n                + \" wrong ConfirmationMethod value.\");\n            }\n            return false;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Returns true if the assertion is valid both time wise and\n     * signature wise, and contains at least one AuthenticationStatement.\n     * @param assertion <code>Assertion</code> instance to be checked.\n     * @return <code>true</code> if the assertion is valid both time wise and\n     * signature wise, and contains at least one AuthenticationStatement.\n     */\n    public static boolean isAuthNAssertion(Assertion assertion) {\n        if (assertion == null) {\n            return false;\n        }\n        \n        if ((!assertion.isTimeValid()) || (!assertion.isSignatureValid())) {\n            return false;\n        }\n        \n        Set statements = assertion.getStatement();\n        Statement statement = null;\n        Iterator iterator = statements.iterator();\n        while (iterator.hasNext()) {\n            statement = (Statement) iterator.next();\n            if (statement.getStatementType() ==\n            Statement.AUTHENTICATION_STATEMENT) {\n                return true;\n            }\n        } // loop through statements\n        return false;\n    }\n \n    /**\n     * Converts a string to a byte array.\n     * @param input a String to be converted.\n     * @return result byte array.\n     */\n    public static byte[] stringToByteArray(String input) {\n        char chars[] = input.toCharArray();\n        byte bytes[] = new byte[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            bytes[i] = (byte) chars[i];\n        }\n        return bytes;\n    }\n \n\n    /**\n     * Returns server ID.\n     * @param idTypeString An ID string\n     * @return server ID part of the id.\n     */\n    public static String getServerID(String idTypeString) {\n        if (idTypeString == null) {\n            return null;\n        }\n        int len = idTypeString.length();\n        String id = null;\n        if (len >= SAMLConstants.SERVER_ID_LENGTH) {\n            id = idTypeString.substring((len - SAMLConstants.SERVER_ID_LENGTH),\n            len);\n            return id;\n        } else {\n            return null;\n        }\n    }\n    \n    /**\n     * Returns server url of a site.\n     * @param str Server ID.\n     * @return Server url corresponding to the server id.\n     */\n    public static String getServerURL(String str) {\n        String id = SAMLUtils.getServerID(str);\n        if (id == null) {\n            return null;\n        }\n        \n        if (SAMLUtils.debug.messageEnabled()) {\n            SAMLUtils.debug.message(\"SAMLUtils.getServerURL: id=\" + id);\n        }\n        \n        String remoteUrl = null;\n        try {\n            remoteUrl = SystemConfigurationUtil.getServerFromID(id);\n        } catch (SystemConfigurationException se) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.getServerURL: ServerEntry\" +\n                \"NotFoundException for \" + id);\n            }\n            return null;\n        }\n        String thisUrl = SAMLServiceManager.getServerURL();\n        if (SAMLUtils.debug.messageEnabled()) {\n            SAMLUtils.debug.message(\"SAMLUtils.getServerURL: remoteUrl=\" +\n            remoteUrl + \", thisUrl=\" + thisUrl);\n        }\n        if ((remoteUrl == null) || (thisUrl == null) ||\n        (remoteUrl.equalsIgnoreCase(thisUrl))) {\n            return null;\n        } else {\n            return remoteUrl;\n        }\n    }\n    \n    /**\n     * Returns full service url.\n     * @param shortUrl short URL of the service.\n     * @return full service url.\n     */\n    public static String getFullServiceURL(String shortUrl) {\n        String result = null;\n        try {\n            URL u = new URL(shortUrl);\n            URL weburl = SystemConfigurationUtil.getServiceURL(\n                SAMLConstants.SAML_AM_NAMING, u.getProtocol(), u.getHost(),\n                    u.getPort(), u.getPath());\n            result = weburl.toString();\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.getFullServiceURL:\" +\n                \"full remote URL is: \" + result);\n            }\n        } catch (Exception e) {\n            if (SAMLUtils.debug.warningEnabled()) {\n                SAMLUtils.debug.warning(\"SAMLUtils.getFullServiceURL:\" +\n                \"Exception:\", e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns attributes included in <code>AttributeStatement</code> of the\n     * assertion.\n     * @param envParameters return map which includes name value pairs of \n     *   attributes included in <code>AttributeStatement</code> of the assertion\n     * @param assertion an <code>Assertion</code> object which contains\n     *   <code>AttributeStatement</code>\n     * @param subject the <code>Subject</code> instance from\n     *   <code>AuthenticationStatement</code>. The <code>Subject</code>\n     *   included in <code>AttributeStatement</code> must match this\n     *   <code>Subject</code> instance.\n     */\n    public static void addEnvParamsFromAssertion(Map envParameters,\n    Assertion assertion,\n    com.sun.identity.saml.assertion.Subject subject) {\n        Set statements = assertion.getStatement();\n        Statement statement = null;\n        Iterator stmtIter = null;\n        List attrs = null;\n        Iterator attrIter = null;\n        Attribute attribute = null;\n        Element attrValue = null;\n        List attrValues = null;\n        String attrName = null;\n        String attrValueString = null;\n        if ((statements != null) && (!statements.isEmpty())) {\n            stmtIter = statements.iterator();\n            while (stmtIter.hasNext()) {\n                statement = (Statement) stmtIter.next();\n                if (statement.getStatementType() ==\n                Statement.ATTRIBUTE_STATEMENT) {\n                    // check for subject\n                    if (!subject.equals(\n                    ((AttributeStatement)statement).getSubject())) {\n                        continue;\n                    }\n                    \n                    attrs = ((AttributeStatement) statement).getAttribute();\n                    attrIter = attrs.iterator();\n                    while (attrIter.hasNext()) {\n                        attribute = (Attribute) attrIter.next();\n                        try {\n                            attrValues = attribute.getAttributeValue();\n                        } catch (Exception e) {\n                            debug.error(\"SAMLUtils.addEnvParamsFromAssertion:\"+\n                            \" cannot obtain attribute value:\", e);\n                            continue;\n                        }\n                        attrName = attribute.getAttributeName();\n                        List attrValueList = null;\n\n                        for(Iterator avIter = attrValues.iterator();\n                            avIter.hasNext(); ) {\n\n                            attrValue = (Element) avIter.next();\n                            if (!XMLUtils.hasElementChild(attrValue)) {\n                                attrValueString =\n                                    XMLUtils.getElementValue(attrValue);\n                                if (attrValueList == null) {\n                                    attrValueList = new ArrayList();\n                                }\n                                attrValueList.add(attrValueString);\n                            }\n                        }\n                        if (attrValueList != null) {\n                            if (debug.messageEnabled()) {\n                                debug.message(\n                                    \"SAMLUtils.addEnvParamsFromAssertion:\" +\n                                    \" attrName = \" + attrName +\n                                    \" attrValue = \" + attrValueList);\n                            }\n                            String[] attrValueStrs = (String[])attrValueList.\n                                toArray(new String[attrValueList.size()]);\n                            try {\n                                envParameters.put(attrName, attrValueStrs);\n                            } catch (Exception ex) {\n                                if (debug.messageEnabled()) {\n                                    debug.message(\n                                        \"SAMLUtils.addEnvParamsFromAssertion:\",\n                                        ex);\n                                }\n                            }\n                        } else if (debug.messageEnabled()) {\n                            if (debug.messageEnabled()) {\n                                debug.message(\n                                    \"SAMLUtils.addEnvParamsFromAssertion:\" +\n                                    \" attrName = \" + attrName +\n                                    \" has no value\");\n                            }\n                        }\n                    }\n                } // if it's an attribute statement\n            }\n        }\n    }\n\n    /**\n     * Returns maximum content length of a SAML request.\n     * @return maximum content length of a SAML request.\n     */\n    public static int getMaxContentLength() {\n        return maxContentLength;\n    }\n    \n    // ************************************************************************\n    // Methods used by SAML Servlets\n    // ************************************************************************\n \n    /**\n     * Checks content length of a http request to avoid dos attack.\n     * In case SAML inter-op with other SAML vendor who may not provide content\n     * length in HttpServletRequest. We decide to support no length restriction\n     * for Http communication. Here, we use a special value (e.g. 0) to\n     * indicate that no enforcement is required.\n     * @param request <code>HttpServletRequest</code> instance to be checked.\n     * @exception ServletException if context length of the request exceeds\n     *   maximum content length allowed.\n     */\n    public static void checkHTTPContentLength(HttpServletRequest request)\n    throws ServletException {\n        if (maxContentLength != 0) {\n            int length =  request.getContentLength();\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"HttpRequest content length= \" +length);\n            }\n            if (length > maxContentLength) {\n                if (SAMLUtils.debug.messageEnabled()) {\n                    SAMLUtils.debug.message(\n                        \"content length too large\" + length);\n                }\n                throw new ServletException(\n                SAMLUtils.bundle.getString(\"largeContentLength\"));\n            }\n        }\n    }\n    \n    /**\n     * Post assertions and attributes to the target url.\n     * This method opens a URL connection to the target specified and POSTs\n     * assertions to it using the passed HttpServletResponse object. It POSTs\n     * multiple parameter names \"assertion\" with value being each of the \n     * <code>Assertion</code> in the passed Set.\n     * @param response <code>HttpServletResponse</code> object\n     * @param out The print writer which for content is to be written too.\n     * @param assertion List of <code>Assertion</code>s to be posted.\n     * @param targeturl target url\n     * @param attrMap Map of attributes to be posted to the target\n     */\n    public static void postToTarget(HttpServletResponse response, PrintWriter out,\n                                    List assertion, String targeturl, Map attrMap) throws IOException {\n        out.println(\"<HTML>\");\n        out.println(\"<HEAD>\\n\");\n        out.println(\"<TITLE>Access rights validated</TITLE>\\n\");\n        out.println(\"</HEAD>\\n\");\n        out.println(\"<BODY Onload=\\\"document.forms[0].submit()\\\">\");\n        Iterator it = null;\n        if (SAMLUtils.debug.messageEnabled()) {\n            out.println(\"<H1>Access rights validated</H1>\\n\");\n            out.println(\"<meta http-equiv=\\\"refresh\\\" content=\\\"20\\\">\\n\");\n            out.println(\"<P>We have verified your access rights <STRONG>\" +\n            \"</STRONG> according to the assertion shown \"\n            +\"below. \\n\");\n            out.println(\"You are being redirected to the resource.\\n\");\n            out.println(\"Please wait ......\\n\");\n            out.println(\"</P>\\n\");\n            out.println(\"<HR><P>\\n\");\n            if (assertion != null) {\n                it = assertion.iterator();\n                while (it.hasNext()) {\n                    out.println(SAMLUtils.displayXML((String)it.next()));\n                }\n            }\n            out.println(\"</P>\\n\");\n        }\n        out.println(\"<FORM METHOD=\\\"POST\\\" ACTION=\\\"\" + targeturl + \"\\\">\");\n        if (assertion != null) {\n            it = assertion.iterator();\n            while (it.hasNext()) {\n                out.println(\"<INPUT TYPE=\\\"HIDDEN\\\" NAME=\\\"\"+\n                SAMLConstants.POST_ASSERTION_NAME + \"\\\"\");\n                out.println(\"VALUE=\\\"\" +\n                    URLEncDec.encode((String)it.next()) + \"\\\">\");\n            }\n        }\n        if (attrMap != null && !attrMap.isEmpty()) {\n            StringBuffer attrNamesSB = new StringBuffer();\n            Set entrySet = attrMap.entrySet();\n            for(Iterator iter = entrySet.iterator(); iter.hasNext();) {\n                Map.Entry entry = (Map.Entry)iter.next();\n                String attrName = HTMLEncode((String)entry.getKey(), '\\\"');\n                String attrValue = HTMLEncode((String)entry.getValue(), '\\\"');\n                out.println(\"<INPUT TYPE=\\\"HIDDEN\\\" NAME=\\\"\"+ attrName +\n                \"\\\" VALUE=\\\"\" + attrValue + \"\\\">\");\n                if (attrNamesSB.length() > 0) {\n                    attrNamesSB.append(\":\");\n                }\n                attrNamesSB.append(attrName);\n            }\n            out.println(\"<INPUT TYPE=\\\"HIDDEN\\\" NAME=\\\"\"+\n            SAMLConstants.POST_ATTR_NAMES + \"\\\" VALUE=\\\"\" +\n            attrNamesSB + \"\\\">\");\n        }\n        out.println(\"</FORM>\");\n        out.println(\"</BODY></HTML>\");\n        out.close();\n    }\n    \n    /**\n     * Returns true of false based on whether the target passed as parameter\n     * accepts form POST.\n     * @param targetIn url to be checked\n     * @return true if it should post assertion to the target passed in; false\n     *   otherwise.\n     */\n    public static boolean postYN(String targetIn) {\n        SAMLUtils.debug.message(\"Inside postYN()\");\n        if ((targetIn == null) || (targetIn.length() == 0)) {\n            return false;\n        }\n        Set targets = (Set) SAMLServiceManager.\n        getAttribute(SAMLConstants.POST_TO_TARGET_URLS);\n        if ((targets == null) || (targets.size() == 0)) {\n            return false;\n        }\n        URL targetUrl = null;\n        try {\n            targetUrl = new URL(targetIn);\n        } catch (MalformedURLException me ) {\n            SAMLUtils.debug.error(\"SAMLUtils:postYN(): Malformed URL passed\");\n            return false;\n        }\n        String targetInHost = targetUrl.getHost();\n        int targetInPort = targetUrl.getPort();\n        String targetInPath = targetUrl.getPath();\n        // making target string without protocol\n        String targetToCompare = new StringBuffer(targetInHost.toLowerCase())\n        .append(\":\").append(String.valueOf(targetInPort))\n        .append(\"/\").append(targetInPath).toString();\n        if (targets.contains(targetToCompare)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    /**\n     * Replaces every occurence of ch with \n     * \"&#&lt;ascii code of ch>;\"\n     * @param srcStr orginal string to to be encoded.\n     * @param ch the charactor needs to be encoded.\n     * @return encoded string\n     */\n    public static String HTMLEncode(String srcStr, char ch) {\n        if (srcStr == null) {\n            return null;\n        }\n        \n        int fromIndex = 0;\n        int toIndex;\n        StringBuffer dstSB = new StringBuffer();\n        \n        while((toIndex = srcStr.indexOf(ch, fromIndex)) != -1) {\n            dstSB.append(srcStr.substring(fromIndex, toIndex))\n            .append(\"&#\" + (int)ch + \";\");\n            fromIndex = toIndex + 1;\n        }\n        dstSB.append(srcStr.substring(fromIndex));\n        \n        return dstSB.toString();\n    }\n\n    /**\n     * Displays an XML string.\n     * This is a utility function used to hack up an HTML display of an XML\n     * string.\n     * @param input original string\n     * @return encoded string so it can be displayed properly by html.\n     */\n    public static String displayXML(String input) {\n        debug.message(\"In displayXML \");\n        StringCharacterIterator iter = new StringCharacterIterator(input);\n        StringBuffer buf = new StringBuffer();\n        \n        for(char c = iter.first();c != CharacterIterator.DONE;c = iter.next()) {\n            if (c=='>') {\n                buf.append(\"&gt;\");\n            } else if (c=='<') {\n                buf.append(\"&lt;\");\n            } else if (c=='\\n'){\n                buf.append(\"<BR>\\n\");\n            } else {\n                buf.append(c);\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Gets the list of <code>Assertion</code> objects from a list of\n     * 'String' assertions.\n     * @param assertions List of assertions in string format\n     * @return List of <code>Assertion</code> objects\n     */\n    public static List getListOfAssertions(List assertions) {\n        List returnAssertions = new ArrayList();\n        try {\n            if (assertions != null) {\n                Iterator it = assertions.iterator();\n                while (it.hasNext()) {\n                    Document doc = XMLUtils.toDOMDocument((String)it.next(),\n                                                            debug);\n                    Element root = doc.getDocumentElement();\n                    if (root != null) {\n                        Assertion assertion = new Assertion(root);\n                        returnAssertions.add(assertion);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (debug.messageEnabled()) {\n                debug.message(\"SAMLUtils.getListOfAssertions : \" +\n                \"Exception : \", e);\n            }\n        }\n        return returnAssertions;\n    }\n    \n    \n    // ************************************************************************\n    // Methods used / shared by SAML Authentication Module and SAML Servlets\n    // ************************************************************************\n\n    /**\n     * Returns byte array from a SAML <code>Response</code>.\n     * @param samlResponse <code>Response</code> object\n     * @return byte array\n     * @exception SAMLException if error occurrs during the process.\n     */\n    public static byte[] getResponseBytes(Response samlResponse)\n        throws SAMLException\n    {\n        byte ret[] = null;\n        try {\n            ret = samlResponse.toString(true, true, true).\n            getBytes(SAMLConstants.DEFAULT_ENCODING);\n        } catch (UnsupportedEncodingException ue) {\n            if (debug.messageEnabled()) {\n                debug.message(\"getResponseBytes : \" , ue);\n            }\n            throw new SAMLException(ue.getMessage());\n        }\n        return ret;\n    }\n \n    /**\n     * Returns <code>Response</code> object from byte array.\n     * @param bytes byte array\n     * @return <code>Response</code> object\n     */\n    public static Response getResponse(byte [] bytes) {\n        Response temp = null;\n        if (bytes == null) {\n            return null;\n        }\n        try {\n            temp = Response.parseXML(new ByteArrayInputStream(bytes));\n        } catch (SAMLException se) {\n            debug.error(\"getResponse : \" , se);\n        }\n        return temp;\n    }\n\n    /**\n     * Verifies a <code>Response</code>.\n     * @param response SAML <code>Response</code> object\n     * @param requestUrl this server's POST profile URL\n     * @param request <code>HttpServletRequest</code> object\n     * @return true if the response is valid; false otherwise.\n     */\n    public static boolean verifyResponse(Response response,\n    String requestUrl, HttpServletRequest request) {\n        if(!response.isSigned()) {\n            debug.message(\"verifyResponse: Response is not signed\");\n            return false;\n        }\n        if (!response.isSignatureValid()) {\n            debug.message(\"verifyResponse: Response's signature is invalid.\");\n            return false;\n        }\n\n        // check Recipient == this server's POST profile URL(requestURL)\n        String recipient = response.getRecipient();\n        if ((recipient == null) || (recipient.length() == 0) ||\n        ((!equalURL(recipient, requestUrl)) &&\n        (!equalURL(recipient,getLBURL(requestUrl, request))))) {\n            debug.error(\"verifyResponse : Incorrect Recipient.\");\n            return false;\n        }\n        \n        // check status of the Response\n        if (!response.getStatus().getStatusCode().getValue().endsWith(\n        SAMLConstants.STATUS_CODE_SUCCESS_NO_PREFIX)) {\n            debug.error(\"verifyResponse : Incorrect StatusCode value.\");\n            return false;\n        }\n        \n        return true;\n    }\n    \n    private static String getLBURL(String requestUrl,\n                                 HttpServletRequest request)\n    {\n        String host = request.getHeader(\"host\");\n        if (host == null) {\n            return requestUrl;\n        }\n        int index = requestUrl.indexOf(\"//\");\n        if (index == -1) {\n            return requestUrl;\n        }\n        StringBuffer sb = new StringBuffer(200);\n        sb.append(requestUrl.substring(0, index + 2)).append(host);\n        String rest = requestUrl.substring(index +2, requestUrl.length());\n        if ((index = rest.indexOf(\"/\")) != -1) {\n            sb.append(rest.substring(index, rest.length()));\n        }\n        if (debug.messageEnabled()) {\n            debug.message(\"getLBURL: LBURL = \" + sb.toString());\n        }\n        return sb.toString().trim();\n    }\n    \n    // ************************************************************************\n    // Methods used by SAML Authentication Module\n    // ************************************************************************\n    \n    /**\n     * Gets List of assertions in String format from a list of \n     * <code>Assertion</code> objects.\n     * @param assertions List of <code>Assertion</code> objects.\n     * @return List of assertions in String format\n     */\n    public static List getStrAssertions(List assertions) {\n        List returnAssertions = new ArrayList();\n        if (assertions != null) {\n            Iterator it = assertions.iterator();\n            while (it.hasNext()) {\n                returnAssertions.add(\n                    ((Assertion)(it.next())).toString(true,true));\n            }\n        }\n        return returnAssertions;\n    }\n    \n    /**\n     * Verifies Signature for Post response.\n     * @param samlResponse <code>Response</code> object from post profile.\n     * @return true if the signature on the reponse is valid; false otherwise.\n     */\n    public static boolean verifySignature(Response samlResponse) {\n        if ((samlResponse != null) &&\n        (!samlResponse.isSigned() || (!samlResponse.isSignatureValid()))) {\n            return false;\n        }\n        return true;\n    }\n    \n    /**\n     * Gets Attribute Map to be set in the Session.\n     * @param partnerdest <code>SOAPEntry</code> object\n     * @param assertions List of <code>Assertion</code>s\n     * @param subject <code>Subject</code> object\n     * @param target target of final SSO\n     * @return Map which contains name and attributes.\n     * @exception Exception if an error occurrs.\n     */\n    public static Map getAttributeMap(\n    SAMLServiceManager.SOAPEntry partnerdest,\n    List assertions,\n    com.sun.identity.saml.assertion.Subject subject,\n    String target)\n    throws Exception {\n        String srcID = partnerdest.getSourceID();\n        String name = null;\n        String org = null;\n        Map attrMap = new HashMap();\n        PartnerAccountMapper paMapper = partnerdest.getPartnerAccountMapper();\n        \n        if (paMapper != null) {\n            Map map = paMapper.getUser(assertions, srcID, target);\n            name = (String) map.get(PartnerAccountMapper.NAME);\n            org =  (String) map.get(PartnerAccountMapper.ORG);\n            attrMap = (Map) map.get(PartnerAccountMapper.ATTRIBUTE);\n        }\n        \n        if (attrMap == null) {\n            attrMap = new HashMap();\n        }\n        attrMap.put(SAMLConstants.USER_NAME, name);\n        if ((org != null) && (org.length() != 0)) {\n            attrMap.put(SessionProvider.REALM, org);\n        } else {\n            attrMap.put(SessionProvider.REALM, \"/\");\n        }\n        \n        if (debug.messageEnabled()) {\n            debug.message(\"getAttributeMap : \" + \"name = \" +\n            name + \", realm=\" + org + \", attrMap = \" + attrMap);\n        }\n        \n        return attrMap;\n    }\n    \n    /**\n     * Checks response and get back a Map of relevant data including,\n     * Subject, SOAPEntry for the partner and the List of Assertions.\n     * @param response <code>Response</code> object\n     * @return Map of data including Subject, SOAPEntry, and list of assertions.\n     */\n    public static Map verifyAssertionAndGetSSMap(Response response) {\n        // loop to check assertions\n        com.sun.identity.saml.assertion.Subject subject = null;\n        SAMLServiceManager.SOAPEntry srcSite = null;\n        List assertions = response.getAssertion();\n        Iterator iter = assertions.iterator();\n        Assertion assertion = null;\n        String aIDString = null;\n        String issuer = null;\n        Iterator stmtIter = null;\n        Statement statement = null;\n        int stmtType = Statement.NOT_SUPPORTED;\n        com.sun.identity.saml.assertion.Subject sub = null;\n        SubjectConfirmation subConf = null;\n        Set confMethods = null;\n        String confMethod = null;\n        Date date = null;\n        while (iter.hasNext()) {\n            assertion = (Assertion) iter.next();\n            aIDString = assertion.getAssertionID();\n            // make sure it's not being used\n            if (idTimeMap.containsKey(aIDString)) {\n                debug.error(\"verifyAssertion \"\n                + \"AndGetSSMap: Assertion: \" + aIDString + \" is used.\");\n                return null;\n            }\n            \n            // check issuer of the assertions\n            issuer = assertion.getIssuer();\n            if ((srcSite = SAMLUtils.getSourceSite(issuer)) == null) {\n                debug.error(\"verifyAsserti \"\n                + \"onAndGetSSMap: issuer is not on the Partner list.\");\n                return null;\n            }\n            \n            if (!assertion.isSignatureValid()) {\n                debug.error(\"verifyAssertion \"\n                + \"AndGetSSMap: assertion's signature is not valid.\");\n                return null;\n            }\n            \n            // must be valid (timewise)\n            if (!assertion.isTimeValid()) {\n                debug.error(\"verifyAssertion \"\n                + \"AndGetSSMap: assertion's time is not valid.\");\n                return null;\n            }\n            \n            // TODO: IssuerInstant of the assertion is within a few minutes\n            // This is a MAY in spec. Which number to use for the few minutes?\n            \n            // TODO: check AudienceRestrictionCondition\n            \n            //for each assertion, loop to check each statement\n            stmtIter = assertion.getStatement().iterator();\n            while (stmtIter.hasNext()) {\n                statement = (Statement) stmtIter.next();\n                stmtType = statement.getStatementType();\n                if ((stmtType == Statement.AUTHENTICATION_STATEMENT) ||\n                (stmtType == Statement.ATTRIBUTE_STATEMENT) ||\n                (stmtType == Statement.AUTHORIZATION_DECISION_STATEMENT)) {\n                    sub = ((SubjectStatement)statement).getSubject();\n                    \n                    // ConfirmationMethod of each subject must be set to bearer\n                    if (((subConf = sub.getSubjectConfirmation()) == null) ||\n                    ((confMethods = subConf.getConfirmationMethod())\n                    == null) ||\n                    (confMethods.size() != 1)) {\n                        debug.error(\"verify \"\n                        + \"AssertionAndGetSSMap: missing or extra \"\n                        + \"ConfirmationMethod.\");\n                        return null;\n                    }\n                    if (((confMethod = (String) confMethods.iterator().next())\n                    == null) ||\n                    (!confMethod.equals(\n                    SAMLConstants.CONFIRMATION_METHOD_BEARER))) {\n                        debug.error(\"verify \"\n                        + \"AssertionAndGetSSMap:wrong ConfirmationMethod.\");\n                        return null;\n                    }\n                    \n                    //TODO: must contain same Subject for all statements?\n                    \n                    if (stmtType == Statement.AUTHENTICATION_STATEMENT) {\n                        //TODO: if it has SubjectLocality,its IP must == sender\n                        // browser IP. This is a MAY item in the spec.\n                        if (subject == null) {\n                            subject = sub;\n                        }\n                    }\n                }\n            }\n            \n            // add the assertion to idTimeMap\n            if (debug.messageEnabled()) {\n                debug.message(\"Adding \" + aIDString + \" to idTimeMap.\");\n            }\n            Conditions conds = assertion.getConditions();\n            if ((conds != null) && ((date = conds.getNotOnorAfter()) != null)) {\n                cGoThrough.addElement(aIDString);\n                idTimeMap.put(aIDString, new Long(date.getTime()));\n            } else {\n                cPeriodic.addElement(aIDString);\n                // it doesn't matter what we store for the value.\n                idTimeMap.put(aIDString, aIDString);\n            }\n        }\n        \n        // must have at least one SSO assertion\n        if ((subject == null) || (srcSite == null)) {\n            debug.error(\"verifyAssertion AndGetSSMap: couldn't find Subject.\");\n            return null;\n        }\n        Map ssMap = new HashMap();\n        ssMap.put(SAMLConstants.SUBJECT, subject);\n        ssMap.put(SAMLConstants.SOURCE_SITE_SOAP_ENTRY, srcSite);\n        ssMap.put(SAMLConstants.POST_ASSERTION, assertions);\n        return ssMap;\n    }\n    \n    /**\n     * Checks if the Assertion is time valid and\n     * if the Assertion is allowed by AudienceRestrictionCondition.\n     *\n     * @param assertion an Assertion object\n     * @return true if the operation is successful otherwise, return false\n     * @exception IOException IOException\n     */\n    private static boolean checkCondition(Assertion assertion)\n        throws IOException\n    {\n        if (assertion == null) {\n            return false;\n        }\n        if (!assertion.isSignatureValid()) {\n            debug.error(bundle.getString(\"assertionSignatureNotValid\"));\n            return false;\n        }\n        // check if the Assertion is time valid\n        if (!(assertion.isTimeValid())) {\n            debug.error(bundle.getString(\"assertionTimeNotValid\"));\n            return false;\n        }\n        // check the Assertion is allowed by AudienceRestrictionCondition\n        Conditions cnds = assertion.getConditions();\n        Set audienceCnd = new HashSet();\n        audienceCnd = cnds.getAudienceRestrictionCondition();\n        Iterator it = null;\n        if (audienceCnd != null) {\n            if (!audienceCnd.isEmpty()) {\n                it = audienceCnd.iterator();\n                while (it.hasNext()) {\n                    if ((((AudienceRestrictionCondition) it.next()).\n                    evaluate()) == Condition.INDETERMINATE ) {\n                        if (debug.messageEnabled()) {\n                            debug.message(\"Audience \" +\n                            \"RestrictionConditions is indeterminate.\");\n                        }\n                    } else {\n                        debug.error(\"Failed AudienceRestrictionCondition\");\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Determines if there is a valid SSO Assertion\n     * inside of SAML Response.\n     *\n     * @param assertions a List of <code>Assertion</code> objects\n     * @return a Subject object\n     * @exception IOException IOException\n     */\n    public static com.sun.identity.saml.assertion.Subject examAssertions(\n    List assertions) throws IOException {\n        if (assertions == null) {\n            return null;\n        }\n        boolean validation = false;\n        com.sun.identity.saml.assertion.Subject subject = null;\n        Iterator iter = assertions.iterator();\n        \n        while (iter.hasNext()) {\n            Assertion assertion = (Assertion)iter.next();\n            \n            if (!checkCondition(assertion)) {\n                return null;\n            }\n            debug.message(\"Passed checking Conditions!\");\n            \n            // exam the Statement inside the Assertion\n            Set statements = new HashSet();\n            statements = assertion.getStatement();\n            \n            if (statements == null || statements.isEmpty()) {\n                debug.error(bundle.getString(\"noStatement\"));\n                return null;\n            }\n            Iterator iterator = statements.iterator();\n            while (iterator.hasNext()) {\n                Statement statement = (Statement) iterator.next();\n                subject = ((SubjectStatement)statement).getSubject();\n                SubjectConfirmation sc = subject.getSubjectConfirmation();\n                Set cm = new HashSet();\n                cm =  sc.getConfirmationMethod();\n                if (cm == null || cm.isEmpty()) {\n                    debug.error(\"Subject confirmation method is null\");\n                    return null;\n                }\n                String conMethod = (String) cm.iterator().next();\n                // add checking artifact confirmation method identifier based\n                // on Assertion version number\n                if ((conMethod != null) && (assertion.getMajorVersion() ==\n                SAMLConstants.ASSERTION_MAJOR_VERSION) &&\n                (((assertion.getMinorVersion() ==\n                SAMLConstants.ASSERTION_MINOR_VERSION_ONE) &&\n                conMethod.equals(SAMLConstants.CONFIRMATION_METHOD_ARTIFACT))\n                ||\n                ((assertion.getMinorVersion() ==\n                SAMLConstants.ASSERTION_MINOR_VERSION_ZERO) &&\n                (conMethod.equals(\n                SAMLConstants.DEPRECATED_CONFIRMATION_METHOD_ARTIFACT))))) {\n                    if (debug.messageEnabled()) {\n                        debug.message(\"Correct Confirmation method\");\n                    }\n                } else {\n                    debug.error(\"Wrong Confirmation Method.\");\n                    return null;\n                }\n                if (statement instanceof AuthenticationStatement) {\n                    //found an SSO Assertion\n                    validation = true;\n                }\n            }  // end of  while (iterator.hasNext()) for Statements\n        } // end of while (iter.hasNext()) for Assertions\n        \n        if (!validation) {\n            debug.error(bundle.getString(\"noSSOAssertion\"));\n            return null;\n        }\n        return subject;\n    }\n\n    /**\n     * Return whether the signature on the object is valid or not.\n     * @param xmlString input XML String \n     * @param idAttribute ASSERTION_ID_ATTRIBUTE or RESPONSE_ID_ATTRIBUTE\n     * @param issuer the issuer of the Assertion \n     * @return true if the signature on the object is valid; false otherwise.\n     */\n    public static boolean checkSignatureValid(String xmlString, \n                                                  String idAttribute, \n                                                  String issuer)\n    {\n            String certAlias = null;\n            boolean valid = true; \n            Map entries = (Map) SAMLServiceManager.getAttribute(\n                                SAMLConstants.PARTNER_URLS);\n        if (entries != null) {\n            SAMLServiceManager.SOAPEntry srcSite =\n                (SAMLServiceManager.SOAPEntry) entries.get(issuer);\n            if (srcSite != null) {\n                certAlias = srcSite.getCertAlias();\n            }\n        }\n      \n        try {\n            SAMLUtils.debug.message(\"SAMLUtils.checkSignatureValid for certAlias {}\", certAlias);\n            XMLSignatureManager manager = XMLSignatureManager.getInstance();\n            valid = manager.verifyXMLSignature(xmlString, \n                                   idAttribute, certAlias);\n        } catch (Exception e) {\n            SAMLUtils.debug.warning(\"SAMLUtils.checkSignatureValid:\"+\n                                \" signature validation exception\", e);\n            valid = false;\n        }\n        if (!valid) {\n            if (SAMLUtils.debug.messageEnabled()) {\n                SAMLUtils.debug.message(\"SAMLUtils.checkSignatureValid:\"+\n                                        \" Couldn't verify signature.\");\n            }\n        }\n        return valid;\n    }\n\n    /**\n     * Sets the given <code>HttpServletResponse</code> object with the\n     * headers in the given <code>MimeHeaders</code> object.\n     * @param headers the <code>MimeHeaders</code> object\n     * @param response the <code>HttpServletResponse</code> object to which the\n     *        headers are to be written.\n     */\n    public static void setMimeHeaders(\n         MimeHeaders headers, HttpServletResponse response) {\n        \n         if(headers == null || response == null) {\n            debug.message(\"SAMLUtils.setMimeHeaders : null input\");\n            return;\n         }\n\n         for (Iterator iter = headers.getAllHeaders(); iter.hasNext();){\n              MimeHeader header = (MimeHeader)iter.next();\n\n              String[] values = headers.getHeader(header.getName());\n              if (values.length == 1) {\n                  response.setHeader(header.getName(), header.getValue());\n              } else {\n                  StringBuffer concat = new StringBuffer();\n                  int i = 0;\n                  while (i < values.length) {\n                      if (i != 0) {\n                          concat.append(',');\n                      }\n                      concat.append(values[i++]);\n                   }\n                   response.setHeader(header.getName(),concat.toString());\n              }\n\n         }\n         return; \n    }\n\n    /**\n     * Returns a <code>MimeHeaders</code> object that contains the headers\n     * in the given <code>HttpServletRequest</code> object.\n     *\n     * @param req the <code>HttpServletRequest</code> object.\n     * @return a new <code>MimeHeaders</code> object containing the headers.\n     */\n    public static MimeHeaders getMimeHeaders(HttpServletRequest req) {\n\n         MimeHeaders headers = new MimeHeaders();\n\n         if(req == null) {\n            debug.message(\"SAMLUtils.getMimeHeaders: null input\");\n            return headers;\n         }\n\n         Enumeration enumerator = req.getHeaderNames();\n\n         while(enumerator.hasMoreElements()) {\n             String headerName = (String)enumerator.nextElement();\n             String headerValue = req.getHeader(headerName);\n\n             StringTokenizer values = new StringTokenizer(headerValue, \",\");\n             while(values.hasMoreTokens()) {\n                 headers.addHeader(headerName, values.nextToken().trim());\n             }\n         }\n\n         return headers; \n    }\n     \n    /**\n     * Returns the authenticaion login url with goto parameter\n     * in the given <code>HttpServletRequest</code> object.\n     *\n     * @param req the <code>HttpServletRequest</code> object.\n     * @return a new authenticaion login url with goto parameter.\n     */\n    public static String getLoginRedirectURL(HttpServletRequest req) {\n        String qs = req.getQueryString();\n        String gotoUrl = req.getRequestURL().toString();\n        String key = null; \n        if (qs != null && qs.length() > 0) {\n            gotoUrl = gotoUrl + \"?\" + qs;\n            int startIdx = -1;\n            int endIdx = -1; \n            StringBuffer result = new StringBuffer(); \n            if ((startIdx = qs.indexOf((String) SAMLServiceManager.\n                getAttribute(SAMLConstants.TARGET_SPECIFIER))) > 0) {\n                result.append(qs.substring(0, startIdx - 1)); \n            }    \n            if ((endIdx = qs.indexOf(\"&\", startIdx)) != -1) {\n                if (startIdx == 0) {\n                    result.append(qs.substring(endIdx + 1)); \n                } else {\n                    result.append(qs.substring(endIdx));\n                }    \n            } \n            key = result.toString();\n        }\n\n        String reqUrl = req.getScheme() + \"://\" + req.getServerName() + \":\" +\n            req.getServerPort() + req.getContextPath();\n        String redirectUrl = null;\n        if (key == null || key.equals(\"\")) {\n            redirectUrl = reqUrl +\"/UI/Login?goto=\" +  \n                URLEncDec.encode(gotoUrl);\n        } else {\n            redirectUrl = reqUrl +\"/UI/Login?\" + key + \"&goto=\"+ \n                URLEncDec.encode(gotoUrl);\n        }\n        if (SAMLUtils.debug.messageEnabled()) {\n            SAMLUtils.debug.message(\"Redirect to auth login via:\" +\n                redirectUrl);\n        }    \n        return redirectUrl; \n    }    \n    \n      \n    /** \n     * Processes SAML Artifact\n     * @param artifact SAML Artifact\n     * @param target Target URL \n     * @return Attribute Map\n     * @exception SAMLException if failed to get the Assertions or\n     *     Attribute Map.\n     */\n    public static Map processArtifact(String[] artifact, String target) \n        throws SAMLException {\n        List assts = null;  \n        Subject assertionSubject = null; \n        AssertionArtifact firstArtifact = null;  \n        Map sessMap = null; \n        // Call SAMLClient to do the Single-sign-on\n        try {\n            assts = SAMLClient.artifactQueryHandler(artifact, (String) null);\n            //exam the SAML response\n            if ((assertionSubject = examAssertions(assts)) == null) {\n                return null; \n            }\n            firstArtifact = new AssertionArtifact(artifact[0]);\n            String sid = firstArtifact.getSourceID();\n            Map partner = (Map) SAMLServiceManager.getAttribute(\n                SAMLConstants.PARTNER_URLS);\n            if (partner == null) {\n                throw new SAMLException(bundle.getString\n                    (\"nullPartnerUrl\"));\n            }\n            SAMLServiceManager.SOAPEntry partnerdest = \n                (SAMLServiceManager.SOAPEntry) partner.get(sid);\n            if (partnerdest == null) {\n                throw new SAMLException(bundle.getString\n                    (\"failedAccountMapping\"));\n            }\n            sessMap = getAttributeMap(partnerdest, assts,\n                assertionSubject, target); \n        } catch (Exception se) {\n            debug.error(\"SAMLUtils.processArtifact :\" , se);\n            throw new SAMLException(\n                bundle.getString(\"failProcessArtifact\"));\n        }    \n        return sessMap;   \n    }\n    \n    /**\n     * Creates Session \n     * @param request HttpServletRequest\n     * @param response HttpServletResponse\n     * @param attrMap Attribute Map \n     * @exception if failed to create Session\n     */\n    public static Object generateSession(HttpServletRequest request,\n        HttpServletResponse response, \n        Map attrMap) throws SAMLException {  \n        Map sessionInfoMap = new HashMap();\n        String realm = (String) attrMap.get(SessionProvider.REALM);\n        if ((realm == null) || (realm.length() == 0)) {\n            realm = \"/\";\n        } \n        sessionInfoMap.put(SessionProvider.REALM, realm);\n        String principalName = \n            (String) attrMap.get(SessionProvider.PRINCIPAL_NAME);\n        if (principalName == null) {\n            principalName = (String) attrMap.get(SAMLConstants.USER_NAME);\n        }\n        sessionInfoMap.put(SessionProvider.PRINCIPAL_NAME, principalName);\n        //TODO: sessionInfoMap.put(SessionProvider.AUTH_LEVEL, \"0\");\n        Object session = null;  \n        try {  \n            SessionProvider sessionProvider = SessionManager.getProvider();\n            session = sessionProvider.createSession(\n                sessionInfoMap, request, response, null);\n            setAttrMapInSession(sessionProvider, attrMap, session);\n        } catch (SessionException se) {\n            if (debug.messageEnabled()) {\n                debug.message(\"SAMLUtils.generateSession:\", se);\n            }\n            throw new SAMLException(se);\n        }\n        return session;\n    }\n    \n    /**\n     * Processes SAML Response\n     * @param samlResponse SAML Response object\n     * @param target Target URL \n     * @return Attribute Map\n     * @exception SAMLException if failed to get Attribute Map.\n     */\n    public static Map processResponse(Response samlResponse, String target) \n        throws SAMLException {\n        List assertions = null;    \n        SAMLServiceManager.SOAPEntry partnerdest = null;\n        Subject assertionSubject = null;\n\n        // verify the signature\n        boolean isSignedandValid = verifySignature(samlResponse);\n        if (!isSignedandValid) {\n            throw new SAMLException(bundle.getString(\"invalidResponse\"));\n        }\n\n        // check Assertion and get back a Map of relevant data including,\n        // Subject, SOAPEntry for the partner and the List of Assertions.\n        Map ssMap = verifyAssertionAndGetSSMap(samlResponse);\n        if (debug.messageEnabled()) {\n            debug.message(\"processResponse: ssMap = \" + ssMap);\n        }\n        \n        if (ssMap == null) {\n            throw new SAMLException(bundle.getString(\"invalidAssertion\"));\n        }\n        assertionSubject = (com.sun.identity.saml.assertion.Subject)\n            ssMap.get(SAMLConstants.SUBJECT);\n        if (assertionSubject == null) {\n            throw new SAMLException(bundle.getString(\"nullSubject\"));\n        }\n        \n        partnerdest = (SAMLServiceManager.SOAPEntry)ssMap\n            .get(SAMLConstants.SOURCE_SITE_SOAP_ENTRY);\n        if (partnerdest == null) {\n            throw new SAMLException(bundle.getString(\"failedAccountMapping\"));\n        }\n        \n        assertions = (List)ssMap.get(SAMLConstants.POST_ASSERTION);\n        Map sessMap = null;\n        try { \n            sessMap = getAttributeMap(partnerdest, assertions,\n                assertionSubject, target); \n        } catch (Exception se) {\n            debug.error(\"SAMLUtils.processResponse :\" , se);\n            throw new SAMLException(\n                bundle.getString(\"failProcessResponse\"));\n        }\n        return sessMap;\n    }\n    \n    /**\n     *Sets the attribute map in the session\n     *\n     *@param attrMap, the Attribute Map\n     *@param session, the valid session object\n     *@exception SessionException if failed to set Attribute in the \n     *    Session.  \n     */\n    private static void setAttrMapInSession(\n        SessionProvider sessionProvider,\n        Map attrMap, Object session)\n        throws SessionException {\n        if (attrMap != null && !attrMap.isEmpty()) {\n            Set entrySet = attrMap.entrySet();\n            for(Iterator iter = entrySet.iterator(); iter.hasNext();) {\n                Map.Entry entry = (Map.Entry)iter.next();\n                String attrName = (String)entry.getKey();\n                String[] attrValues = null;\n                if (attrName.equals(SAMLConstants.USER_NAME) ||\n                    attrName.equals(SessionProvider.PRINCIPAL_NAME)) {\n                    String attrValue = (String)entry.getValue();\n                    attrValues = new String[1];\n                    attrValues[0] = attrValue;\n                } else if (attrName.equals(SessionProvider.REALM) ||\n                    attrName.equals(SessionProvider.AUTH_LEVEL)) {\n                    // ignore\n                    continue; \n                } else {\n                    attrValues = (String[])entry.getValue();\n                }\n                sessionProvider.setProperty(session, attrName, attrValues);\n                if (debug.messageEnabled()) {\n                    debug.message(\"SAMLUtils.setAttrMapInSessioin: attrName =\"+\n                        attrName);\n                }\n            }\n        } \n    }\n\n    /**\n     * Compares two URLs to see if they are equal. Two URLs are equal if\n     * they have same protocol, host, port and path (case ignored).\n     * Note : the method is provided to avoid URL.equals() call which requires\n     * name lookup. Name lookup is a blocking operation and very expensive\n     * if the hostname could not be resolved.\n     *\n     * @return true if the URLs are equal, false otherwise.\n     */\n    private static boolean equalURL(String url1, String url2) {\n        try {\n            URL u1 = new URL(url1);\n            URL u2 = new URL(url2);\n            int port1 = u1.getPort();\n            if (port1 == -1) {\n                port1 = u1.getDefaultPort();\n            }\n            int port2 = u2.getPort();\n            if (port2 == -1) {\n                port2 = u2.getDefaultPort();\n            }\n            if ((u1.getProtocol().equalsIgnoreCase(u2.getProtocol())) &&\n                (u1.getHost().equalsIgnoreCase(u2.getHost())) &&\n                (port1 == port2) &&\n                (u1.getPath().equalsIgnoreCase(u2.getPath()))) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (MalformedURLException m) {\n            debug.message(\"Error in SAMLUtils.equalURL\", m);\n            return false;\n        }\n    }\n\n      /**\n       * Gets input Node Canonicalized\n       *\n       * @param node Node\n       * @return Canonical element if the operation succeeded.\n       *     Otherwise, return null.\n       */\n      public static Element getCanonicalElement(Node node) {\n          try {\n              Canonicalizer c14n = Canonicalizer.getInstance(\n                  \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\");\n              byte outputBytes[] = c14n.canonicalizeSubtree(node);\n              DocumentBuilder documentBuilder = \n                 XMLUtils.getSafeDocumentBuilder(false);\n              Document doc = documentBuilder.parse(\n                  new ByteArrayInputStream(outputBytes));\n              Element result = doc.getDocumentElement();\n              return result;\n          } catch (Exception e) {\n              SAMLUtils.debug.error(\"Response:getCanonicalElement: \" +\n                  \"Error while performing canonicalization on \" +\n                  \"the input Node.\");\n              return null;\n          }\n      }\n      \n     /**\n      * Sends to error page URL for SAML protocols. If the error page is\n      * hosted in the same web application, forward is used with\n      * parameters. Otherwise, redirection or HTTP POST is used with\n      * parameters.\n      * Three parameters are passed to the error URL:\n      *  -- errorcode : Error key, this is the I18n key of the error message.\n      *  -- httpstatuscode : Http status code for the error\n      *  -- message : detailed I18n'd error message\n      * @param request HttpServletRequest object\n      * @param response HttpServletResponse object\n      * @param httpStatusCode Http Status code\n      * @param errorCode Error code\n      * @param errorMsg Detailed error message\n      */\n     public static void sendError(HttpServletRequest request,\n         HttpServletResponse response, int httpStatusCode,\n         String errorCode, String errorMsg) {\n                 String errorUrl = SystemConfigurationUtil.getProperty(\n               SAMLConstants.ERROR_PAGE_URL,\n               SAMLConstants.DEFAULT_ERROR_PAGE_URL);\n         if(debug.messageEnabled()) {\n            debug.message(\"SAMLUtils.sendError: error page\" + errorUrl);\n         }\n         String tmp = errorUrl.toLowerCase();\n         if (!tmp.startsWith(\"http://\") && !tmp.startsWith(\"https://\")) {\n             // use forward\n             String jointString = \"?\";\n             if (errorUrl.indexOf(\"?\") != -1) {\n                 jointString = \"&\";\n             }\n             String newUrl = errorUrl.trim() + jointString\n                  + SAMLConstants.ERROR_CODE + \"=\" + errorCode + \"&\"\n                  + SAMLConstants.HTTP_STATUS_CODE + \"=\" + httpStatusCode\n                  + \"&\" + SAMLConstants.ERROR_MESSAGE + \"=\"\n                  + URLEncDec.encode(errorMsg);\n\n             forwardRequest(newUrl, request, response);\n         } else {\n           String binding = SystemConfigurationUtil.getProperty(\n                            SAMLConstants.ERROR_PAGE_HTTP_BINDING,\n                            SAMLConstants.HTTP_POST);\n           if(SAMLConstants.HTTP_REDIRECT.equals(binding)) {\n               // use FSUtils, this may be redirection or forward\n              String jointString = \"?\";\n              if (errorUrl.indexOf(\"?\") != -1) {\n                  jointString = \"&\";\n              }\n              String newUrl = errorUrl.trim() + jointString\n                   + SAMLConstants.ERROR_CODE + \"=\" + errorCode + \"&\"\n                   + SAMLConstants.HTTP_STATUS_CODE + \"=\" + httpStatusCode\n                   + \"&\" + SAMLConstants.ERROR_MESSAGE + \"=\"\n                   + URLEncDec.encode(errorMsg);\n\n              FSUtils.forwardRequest(request, response, newUrl) ;\n           } else {\n               // Populate request attributes to be available for rendering.\n               request.setAttribute(\"ERROR_URL\", errorUrl);\n               request.setAttribute(\"ERROR_CODE_NAME\", SAMLConstants.ERROR_CODE);\n               request.setAttribute(\"ERROR_CODE\", errorCode);\n               request.setAttribute(\"ERROR_MESSAGE_NAME\", SAMLConstants.ERROR_MESSAGE);\n               request.setAttribute(\"ERROR_MESSAGE\", URLEncDec.encode(errorMsg));\n               request.setAttribute(\"HTTP_STATUS_CODE_NAME\", SAMLConstants.HTTP_STATUS_CODE);\n               request.setAttribute(\"HTTP_STATUS_CODE\", httpStatusCode);\n               request.setAttribute(\"SAML_ERROR_KEY\", bundle.getString(\"samlErrorKey\"));\n               // Forward to auto-submitting form.\n               forwardRequest(ERROR_JSP, request, response);\n           }\n         }\n     }\n\n    /**\n     * Forwards to the passed URL.\n     *\n     * @param url\n     *         Forward URL\n     * @param request\n     *         Request object\n     * @param response\n     *         Response object\n     */\n    private static void forwardRequest(String url, HttpServletRequest request, HttpServletResponse response) {\n        try {\n            request.getRequestDispatcher(url).forward(request, response);\n\n        } catch (ServletException sE) {\n            handleForwardError(url, sE, response);\n        } catch (IOException ioE) {\n            handleForwardError(url, ioE, response);\n        }\n    }\n\n    /**\n     * Handle any forward error.\n     *\n     * @param url\n     *         Attempted forward URL\n     * @param exception\n     *         Caught exception\n     * @param response\n     *         Response object\n     */\n    private static void handleForwardError(String url, Exception exception, HttpServletResponse response) {\n        debug.error(\"SAMLUtils.sendError: Exception occurred while trying to forward to resource: \" + url, exception);\n\n        try {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, exception.getMessage());\n        } catch (IOException ioE) {\n            debug.error(\"Failed to inform the response of caught exception\", ioE);\n        }\n    }\n\n}\n"], "filenames": ["openam-federation/openam-federation-library/src/main/java/com/sun/identity/saml/common/SAMLUtils.java"], "buggy_code_start_loc": [953], "buggy_code_end_loc": [1595], "fixing_code_start_loc": [954], "fixing_code_end_loc": [1599], "type": "CWE-287", "message": "Open Access Management (OpenAM) is an access management solution that includes Authentication, SSO, Authorization, Federation, Entitlements and Web Services Security. OpenAM up to version 14.7.2 does not properly validate the signature of SAML responses received as part of the SAMLv1.x Single Sign-On process. Attackers can use this fact to impersonate any OpenAM user, including the administrator, by sending a specially crafted SAML response to the SAMLPOSTProfileServlet servlet. This problem has been patched in  OpenAM 14.7.3-SNAPSHOT and later. User unable to upgrade should comment servlet `SAMLPOSTProfileServlet` from their pom file. See the linked GHSA for details.", "other": {"cve": {"id": "CVE-2023-37471", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-20T17:15:10.917", "lastModified": "2023-07-31T18:44:03.953", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open Access Management (OpenAM) is an access management solution that includes Authentication, SSO, Authorization, Federation, Entitlements and Web Services Security. OpenAM up to version 14.7.2 does not properly validate the signature of SAML responses received as part of the SAMLv1.x Single Sign-On process. Attackers can use this fact to impersonate any OpenAM user, including the administrator, by sending a specially crafted SAML response to the SAMLPOSTProfileServlet servlet. This problem has been patched in  OpenAM 14.7.3-SNAPSHOT and later. User unable to upgrade should comment servlet `SAMLPOSTProfileServlet` from their pom file. See the linked GHSA for details."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openidentityplatform:openam:*:*:*:*:*:*:*:*", "versionEndExcluding": "14.7.3", "matchCriteriaId": "F68AE6B9-32C3-4885-980E-7488E560855B"}]}]}], "references": [{"url": "https://github.com/OpenIdentityPlatform/OpenAM/commit/7c18543d126e8a567b83bb4535631825aaa9d742", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/OpenIdentityPlatform/OpenAM/pull/624", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/OpenIdentityPlatform/OpenAM/security/advisories/GHSA-4mh8-9wq6-rjxg", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenIdentityPlatform/OpenAM/commit/7c18543d126e8a567b83bb4535631825aaa9d742"}}