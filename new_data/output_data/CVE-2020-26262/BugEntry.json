{"buggy_code": ["/*\n * Copyright (C) 2011, 2012, 2013 Citrix Systems\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"ns_turn_ioaddr.h\"\n#include <netdb.h>\n#include <string.h>\n\n//////////////////////////////////////////////////////////////\n\nuint32_t get_ioa_addr_len(const ioa_addr* addr) {\n  if(addr->ss.sa_family == AF_INET) return sizeof(struct sockaddr_in);\n  else if(addr->ss.sa_family == AF_INET6) return sizeof(struct sockaddr_in6);\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////\n\nvoid addr_set_any(ioa_addr *addr) {\n\tif(addr)\n\t\tbzero(addr,sizeof(ioa_addr));\n}\n\nint addr_any(const ioa_addr* addr) {\n\n\tif(!addr)\n\t\treturn 1;\n\n  if(addr->ss.sa_family == AF_INET) {\n    return ((addr->s4.sin_addr.s_addr==0)&&(addr->s4.sin_port==0));\n  } else if(addr->ss.sa_family == AF_INET6) {\n    if(addr->s6.sin6_port!=0) return 0;\n    else {\n      size_t i;\n      for(i=0;i<sizeof(addr->s6.sin6_addr);i++) \n\tif(((const char*)&(addr->s6.sin6_addr))[i]) return 0;\n    }\n  }\n\n  return 1;\n}\n\nint addr_any_no_port(const ioa_addr* addr) {\n\tif(!addr)\n\t\treturn 1;\n\n  if(addr->ss.sa_family == AF_INET) {\n    return (addr->s4.sin_addr.s_addr==0);\n  } else if(addr->ss.sa_family == AF_INET6) {\n    size_t i;\n    for(i=0;i<sizeof(addr->s6.sin6_addr);i++) \n      if(((const char*)(&(addr->s6.sin6_addr)))[i]) return 0;\n  }\n\n  return 1;\n}\n\nuint32_t hash_int32(uint32_t a)\n{\n\ta = a ^ (a>>4);\n\ta = (a^0xdeadbeef) + (a<<5);\n\ta = a ^ (a>>11);\n\treturn a;\n}\n\nuint64_t hash_int64(uint64_t a)\n{\n\ta = a ^ (a>>4);\n\ta = (a^0xdeadbeefdeadbeefLL) + (a<<5);\n\ta = a ^ (a>>11);\n\treturn a;\n}\n\nuint32_t addr_hash(const ioa_addr *addr)\n{\n\tif(!addr)\n\t\treturn 0;\n\n\tuint32_t ret = 0;\n\tif (addr->ss.sa_family == AF_INET) {\n\t\tret = hash_int32(addr->s4.sin_addr.s_addr + addr->s4.sin_port);\n\t} else {\n\t\tuint64_t a[2];\n\t\tbcopy(&(addr->s6.sin6_addr), &a, sizeof(a));\n\t\tret = (uint32_t)((hash_int64(a[0])<<3) + (hash_int64(a[1] + addr->s6.sin6_port)));\n\t}\n\treturn ret;\n}\n\nuint32_t addr_hash_no_port(const ioa_addr *addr)\n{\n\tif(!addr)\n\t\treturn 0;\n\n\tuint32_t ret = 0;\n\tif (addr->ss.sa_family == AF_INET) {\n\t\tret = hash_int32(addr->s4.sin_addr.s_addr);\n\t} else {\n\t\tuint64_t a[2];\n\t\tbcopy(&(addr->s6.sin6_addr), &a, sizeof(a));\n\t\tret = (uint32_t)((hash_int64(a[0])<<3) + (hash_int64(a[1])));\n\t}\n\treturn ret;\n}\n\nvoid addr_cpy(ioa_addr* dst, const ioa_addr* src) {\n\tif(dst && src)\n\t\tbcopy(src,dst,sizeof(ioa_addr));\n}\n\nvoid addr_cpy4(ioa_addr* dst, const struct sockaddr_in* src) {\n\tif(src && dst)\n\t\tbcopy(src,dst,sizeof(struct sockaddr_in));\n}\n\nvoid addr_cpy6(ioa_addr* dst, const struct sockaddr_in6* src) {\n\tif(src && dst)\n\t\tbcopy(src,dst,sizeof(struct sockaddr_in6));\n}\n\nint addr_eq(const ioa_addr* a1, const ioa_addr *a2) {\n\n  if(!a1) return (!a2);\n  else if(!a2) return (!a1);\n\n  if(a1->ss.sa_family == a2->ss.sa_family) {\n    if(a1->ss.sa_family == AF_INET && a1->s4.sin_port == a2->s4.sin_port) {\n      if((int)a1->s4.sin_addr.s_addr == (int)a2->s4.sin_addr.s_addr) {\n\treturn 1;\n      }\n    } else if(a1->ss.sa_family == AF_INET6 && a1->s6.sin6_port == a2->s6.sin6_port) {\n        if( memcmp(&(a1->s6.sin6_addr), &(a2->s6.sin6_addr) ,sizeof(struct in6_addr)) == 0 ) {\n        return 1;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint addr_eq_no_port(const ioa_addr* a1, const ioa_addr *a2) {\n\n  if(!a1) return (!a2);\n  else if(!a2) return (!a1);\n  \n  if(a1->ss.sa_family == a2->ss.sa_family) {\n    if(a1->ss.sa_family == AF_INET) {\n      if((int)a1->s4.sin_addr.s_addr == (int)a2->s4.sin_addr.s_addr) {\n\treturn 1;\n      }\n    } else if(a1->ss.sa_family == AF_INET6) {\n      if( memcmp(&(a1->s6.sin6_addr), &(a2->s6.sin6_addr) ,sizeof(struct in6_addr)) == 0 ) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint make_ioa_addr(const uint8_t* saddr0, int port, ioa_addr *addr) {\n\n  if(!saddr0 || !addr) return -1;\n\n  char ssaddr[257];\n  STRCPY(ssaddr,saddr0);\n\n  char* saddr=ssaddr;\n  while(*saddr == ' ') ++saddr;\n\n  size_t len=strlen(saddr);\n  while(len>0) {\n\t  if(saddr[len-1]==' ') {\n\t\t  saddr[len-1]=0;\n\t\t  --len;\n\t  } else {\n\t\t  break;\n\t  }\n  }\n\n  bzero(addr, sizeof(ioa_addr));\n  if((len == 0)||\n     (inet_pton(AF_INET, saddr, &addr->s4.sin_addr) == 1)) {\n    addr->s4.sin_family = AF_INET;\n#if defined(TURN_HAS_SIN_LEN) /* tested when configured */\n    addr->s4.sin_len = sizeof(struct sockaddr_in);\n#endif\n    addr->s4.sin_port = nswap16(port);\n  } else if (inet_pton(AF_INET6, saddr, &addr->s6.sin6_addr) == 1) {\n    addr->s6.sin6_family = AF_INET6;\n#if defined(SIN6_LEN) /* this define is required by IPv6 if used */\n    addr->s6.sin6_len = sizeof(struct sockaddr_in6);\n#endif\n    addr->s6.sin6_port = nswap16(port);\n  } else {\n    struct addrinfo addr_hints;\n    struct addrinfo *addr_result = NULL;\n    int err;\n\n    memset(&addr_hints, 0, sizeof(struct addrinfo));\n    addr_hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n    addr_hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n    addr_hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n    addr_hints.ai_protocol = 0;          /* Any protocol */\n    addr_hints.ai_canonname = NULL;\n    addr_hints.ai_addr = NULL;\n    addr_hints.ai_next = NULL;\n\n    err = getaddrinfo(saddr, NULL, &addr_hints, &addr_result);\n    if ((err != 0)||(!addr_result)) {\n      fprintf(stderr,\"error resolving '%s' hostname: %s\\n\",saddr,gai_strerror(err));\n      return -1;\n    }\n    \n    int family = AF_INET;\n    struct addrinfo *addr_result_orig = addr_result;\n    int found = 0;\n\n    beg_af:\n\n    while(addr_result) {\n\n    \tif(addr_result->ai_family == family) {\n    \t\tif (addr_result->ai_family == AF_INET) {\n    \t\t\tbcopy(addr_result->ai_addr, addr, addr_result->ai_addrlen);\n    \t\t\taddr->s4.sin_port = nswap16(port);\n#if defined(TURN_HAS_SIN_LEN) /* tested when configured */\n    \t\t\taddr->s4.sin_len = sizeof(struct sockaddr_in);\n#endif\n    \t\t\tfound = 1;\n    \t\t\tbreak;\n    \t\t} else if (addr_result->ai_family == AF_INET6) {\n    \t\t\tbcopy(addr_result->ai_addr, addr, addr_result->ai_addrlen);\n    \t\t\taddr->s6.sin6_port = nswap16(port);\n#if defined(SIN6_LEN) /* this define is required by IPv6 if used */\n    \t\t\taddr->s6.sin6_len = sizeof(struct sockaddr_in6);\n#endif\n    \t\t\tfound = 1;\n    \t\t\tbreak;\n    \t\t}\n    \t}\n\n    \taddr_result = addr_result->ai_next;\n    }\n\n    if(!found && family == AF_INET) {\n    \tfamily = AF_INET6;\n    \taddr_result = addr_result_orig;\n    \tgoto beg_af;\n    }\n    \n    freeaddrinfo(addr_result_orig);\n  }\n\n  return 0;\n}\n\nstatic char* get_addr_string_and_port(char* s0, int *port)\n{\n\tchar *s = s0;\n\twhile(*s && (*s==' ')) ++s;\n\tif(*s == '[') {\n\t\t++s;\n\t\tchar *tail = strstr(s,\"]\");\n\t\tif(tail) {\n\t\t\t*tail=0;\n\t\t\t++tail;\n\t\t\twhile(*tail && (*tail==' ')) ++tail;\n\t\t\tif(*tail==':') {\n\t\t\t\t++tail;\n\t\t\t\t*port = atoi(tail);\n\t\t\t\treturn s;\n\t\t\t} else if(*tail == 0) {\n\t\t\t\t*port = 0;\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tchar *tail = strstr(s,\":\");\n\t\tif(tail) {\n\t\t\t*tail = 0;\n\t\t\t++tail;\n\t\t\t*port = atoi(tail);\n\t\t\treturn s;\n\t\t} else {\n\t\t\t*port = 0;\n\t\t\treturn s;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint make_ioa_addr_from_full_string(const uint8_t* saddr, int default_port, ioa_addr *addr)\n{\n\tif(!addr)\n\t\treturn -1;\n\n\tint ret = -1;\n\tint port = 0;\n\tchar* s = strdup((const char*)saddr);\n\tchar *sa = get_addr_string_and_port(s,&port);\n\tif(sa) {\n\t\tif(port<1)\n\t\t\tport = default_port;\n\t\tret = make_ioa_addr((uint8_t*)sa,port,addr);\n\t}\n\tfree(s);\n\treturn ret;\n}\n\nint addr_to_string(const ioa_addr* addr, uint8_t* saddr)\n{\n\n\tif (addr && saddr) {\n\n\t\tchar addrtmp[INET6_ADDRSTRLEN];\n\n\t\tif (addr->ss.sa_family == AF_INET) {\n\t\t\tinet_ntop(AF_INET, &addr->s4.sin_addr, addrtmp, INET_ADDRSTRLEN);\n\t\t\tif(addr_get_port(addr)>0)\n\t\t\t  snprintf((char*)saddr, MAX_IOA_ADDR_STRING, \"%s:%d\", addrtmp, addr_get_port(addr));\n\t\t\telse\n\t\t\t  strncpy((char*)saddr, addrtmp, MAX_IOA_ADDR_STRING);\n\t\t} else if (addr->ss.sa_family == AF_INET6) {\n\t\t\tinet_ntop(AF_INET6, &addr->s6.sin6_addr, addrtmp, INET6_ADDRSTRLEN);\n\t\t\tif(addr_get_port(addr)>0)\n\t\t\t  snprintf((char*)saddr, MAX_IOA_ADDR_STRING, \"[%s]:%d\", addrtmp, addr_get_port(addr));\n\t\t\telse\n\t\t\t  strncpy((char*)saddr, addrtmp, MAX_IOA_ADDR_STRING);\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nint addr_to_string_no_port(const ioa_addr* addr, uint8_t* saddr)\n{\n\n\tif (addr && saddr) {\n\n\t\tchar addrtmp[MAX_IOA_ADDR_STRING];\n\n\t\tif (addr->ss.sa_family == AF_INET) {\n\t\t\tinet_ntop(AF_INET, &addr->s4.sin_addr, addrtmp, INET_ADDRSTRLEN);\n\t\t\tstrncpy((char*)saddr, addrtmp, MAX_IOA_ADDR_STRING);\n\t\t} else if (addr->ss.sa_family == AF_INET6) {\n\t\t\tinet_ntop(AF_INET6, &addr->s6.sin6_addr, addrtmp, INET6_ADDRSTRLEN);\n\t\t\tstrncpy((char*)saddr, addrtmp, MAX_IOA_ADDR_STRING);\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nvoid addr_set_port(ioa_addr* addr, int port) {\n  if(addr) {\n    if(addr->s4.sin_family == AF_INET) {\n      addr->s4.sin_port = nswap16(port);\n    } else if(addr->s6.sin6_family == AF_INET6) {\n      addr->s6.sin6_port = nswap16(port);\n    }\n  }\n}\n\nint addr_get_port(const ioa_addr* addr) {\n\tif(!addr)\n\t\treturn 0;\n\n  if(addr->s4.sin_family == AF_INET) {\n    return nswap16(addr->s4.sin_port);\n  } else if(addr->s6.sin6_family == AF_INET6) {\n    return nswap16(addr->s6.sin6_port);\n  }\n  return 0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\nvoid ioa_addr_range_set(ioa_addr_range* range, const ioa_addr* addr_min, const ioa_addr* addr_max) {\n  if(range) {\n    if(addr_min) addr_cpy(&(range->min),addr_min);\n    else addr_set_any(&(range->min));\n    if(addr_max) addr_cpy(&(range->max),addr_max);\n    else addr_set_any(&(range->max));\n  }\n}\n\nint addr_less_eq(const ioa_addr* addr1, const ioa_addr* addr2) {\n\n  if(!addr1) return 1;\n  else if(!addr2) return 0;\n  else {\n    if(addr1->ss.sa_family != addr2->ss.sa_family) return (addr1->ss.sa_family < addr2->ss.sa_family);\n    else if(addr1->ss.sa_family == AF_INET) {\n      return ((uint32_t)nswap32(addr1->s4.sin_addr.s_addr) <= (uint32_t)nswap32(addr2->s4.sin_addr.s_addr));\n    } else if(addr1->ss.sa_family == AF_INET6) {\n      int i;\n      for(i=0;i<16;i++) {\n\tif((uint8_t)(((const char*)&(addr1->s6.sin6_addr))[i]) > (uint8_t)(((const char*)&(addr2->s6.sin6_addr))[i])) \n\t  return 0;\n      }\n      return 1;\n    } else return 1;\n  }\n}\n\nint ioa_addr_in_range(const ioa_addr_range* range, const ioa_addr* addr) {\n\n  if(range && addr) {\n    if(addr_any(&(range->min)) || addr_less_eq(&(range->min),addr)) {\n      if(addr_any(&(range->max))) {\n\treturn 1;\n      } else {\n\treturn addr_less_eq(addr,&(range->max));\n      }\n    }\n  }\n\n  return 0;\n}\n\nvoid ioa_addr_range_cpy(ioa_addr_range* dest, const ioa_addr_range* src) {\n  if(dest && src) {\n    addr_cpy(&(dest->min),&(src->min));\n    addr_cpy(&(dest->max),&(src->max));\n  }\n}\n\n/////// Check whether this is a good address //////////////\n\nint ioa_addr_is_multicast(ioa_addr *addr)\n{\n\tif(addr) {\n\t\tif(addr->ss.sa_family == AF_INET) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s4.sin_addr));\n\t\t\treturn (u[0] > 223);\n\t\t} else if(addr->ss.sa_family == AF_INET6) {\n\t\t\tuint8_t u = ((const uint8_t*)&(addr->s6.sin6_addr))[0];\n\t\t\treturn (u == 255);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint ioa_addr_is_loopback(ioa_addr *addr)\n{\n\tif(addr) {\n\t\tif(addr->ss.sa_family == AF_INET) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s4.sin_addr));\n\t\t\treturn (u[0] == 127);\n\t\t} else if(addr->ss.sa_family == AF_INET6) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s6.sin6_addr));\n\t\t\tif(u[7] == 1) {\n\t\t\t\tint i;\n\t\t\t\tfor(i=0;i<7;++i) {\n\t\t\t\t\tif(u[i])\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/////// Map \"public\" address to \"private\" address //////////////\n\n// Must be called only in a single-threaded context,\n// before the program starts spawning threads:\n\nstatic ioa_addr **public_addrs = NULL;\nstatic ioa_addr **private_addrs = NULL;\nstatic size_t mcount = 0;\nstatic size_t msz = 0;\n\nvoid ioa_addr_add_mapping(ioa_addr *apub, ioa_addr *apriv)\n{\n\tsize_t new_size = msz + sizeof(ioa_addr*);\n\tpublic_addrs = (ioa_addr**)realloc(public_addrs, new_size);\n\tprivate_addrs = (ioa_addr**)realloc(private_addrs, new_size);\n\tpublic_addrs[mcount]=(ioa_addr*)malloc(sizeof(ioa_addr));\n\tprivate_addrs[mcount]=(ioa_addr*)malloc(sizeof(ioa_addr));\n\taddr_cpy(public_addrs[mcount],apub);\n\taddr_cpy(private_addrs[mcount],apriv);\n\t++mcount;\n\tmsz += sizeof(ioa_addr*);\n}\n\nvoid map_addr_from_public_to_private(const ioa_addr *public_addr, ioa_addr *private_addr)\n{\n\tsize_t i;\n\tfor(i=0;i<mcount;++i) {\n\t\tif(addr_eq_no_port(public_addr,public_addrs[i])) {\n\t\t\taddr_cpy(private_addr,private_addrs[i]);\n\t\t\taddr_set_port(private_addr,addr_get_port(public_addr));\n\t\t\treturn;\n\t\t}\n\t}\n\taddr_cpy(private_addr,public_addr);\n}\n\nvoid map_addr_from_private_to_public(const ioa_addr *private_addr, ioa_addr *public_addr)\n{\n\tsize_t i;\n\tfor(i=0;i<mcount;++i) {\n\t\tif(addr_eq_no_port(private_addr,private_addrs[i])) {\n\t\t\taddr_cpy(public_addr,public_addrs[i]);\n\t\t\taddr_set_port(public_addr,addr_get_port(private_addr));\n\t\t\treturn;\n\t\t}\n\t}\n\taddr_cpy(public_addr,private_addr);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n", "/*\n * Copyright (C) 2011, 2012, 2013 Citrix Systems\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef __IOADDR__\n#define __IOADDR__\n\n#include \"ns_turn_defs.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/////////////////////////////////////////////////////\n\n#define MAX_IOA_ADDR_STRING (65)\n\ntypedef union {\n  struct sockaddr ss;\n  struct sockaddr_in s4;\n  struct sockaddr_in6 s6;\n} ioa_addr;\n\ntypedef struct {\n  ioa_addr min;\n  ioa_addr max;\n} ioa_addr_range;\n\n////////////////////////////\n\nuint32_t get_ioa_addr_len(const ioa_addr* addr);\n\n////////////////////////////\n\nvoid addr_set_any(ioa_addr *addr);\nint addr_any(const ioa_addr* addr);\nint addr_any_no_port(const ioa_addr* addr);\nuint32_t addr_hash(const ioa_addr *addr);\nuint32_t addr_hash_no_port(const ioa_addr *addr);\nvoid addr_cpy(ioa_addr* dst, const ioa_addr* src);\nvoid addr_cpy4(ioa_addr* dst, const struct sockaddr_in* src);\nvoid addr_cpy6(ioa_addr* dst, const struct sockaddr_in6* src);\nint addr_eq(const ioa_addr* a1, const ioa_addr *a2);\nint addr_eq_no_port(const ioa_addr* a1, const ioa_addr *a2);\nint make_ioa_addr(const uint8_t* saddr, int port, ioa_addr *addr);\nint make_ioa_addr_from_full_string(const uint8_t* saddr, int default_port, ioa_addr *addr);\nvoid addr_set_port(ioa_addr* addr, int port);\nint addr_get_port(const ioa_addr* addr);\nint addr_to_string(const ioa_addr* addr, uint8_t* saddr);\nint addr_to_string_no_port(const ioa_addr* addr, uint8_t* saddr);\n\nuint32_t hash_int32(uint32_t a);\nuint64_t hash_int64(uint64_t a);\n\n///////////////////////////////////////////\n\nvoid ioa_addr_range_set(ioa_addr_range* range, const ioa_addr* addr_min, const ioa_addr* addr_max);\nint addr_less_eq(const ioa_addr* addr1, const ioa_addr* addr2);\nint ioa_addr_in_range(const ioa_addr_range* range, const ioa_addr* addr);\nvoid ioa_addr_range_cpy(ioa_addr_range* dest, const ioa_addr_range* src);\n\n/////// Check whether this is a good address //////////////\n\nint ioa_addr_is_multicast(ioa_addr *a);\nint ioa_addr_is_loopback(ioa_addr *addr);\n\n/////// Map \"public\" address to \"private\" address //////////////\n\n// Must be called only in a single-threaded context,\n// before the program starts spawning threads:\n\nvoid ioa_addr_add_mapping(ioa_addr *apub, ioa_addr *apriv);\nvoid map_addr_from_public_to_private(const ioa_addr *public_addr, ioa_addr *private_addr);\nvoid map_addr_from_private_to_public(const ioa_addr *private_addr, ioa_addr *public_addr);\n\n///////////////////////////////////////////\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //__IOADDR__\n", "/*\n * Copyright (C) 2011, 2012, 2013 Citrix Systems\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"ns_turn_server.h\"\n\n#include \"ns_turn_utils.h\"\n#include \"ns_turn_allocation.h\"\n#include \"ns_turn_msg_addr.h\"\n#include \"ns_turn_ioalib.h\"\n#include \"../apps/relay/ns_ioalib_impl.h\"\n\n///////////////////////////////////////////\n\n#define FUNCSTART if(server && eve(server->verbose)) TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"%s:%d:start\\n\",__FUNCTION__,__LINE__)\n#define FUNCEND if(server && eve(server->verbose)) TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"%s:%d:end\\n\",__FUNCTION__,__LINE__)\n\n////////////////////////////////////////////////\n\nstatic inline int get_family(int stun_family, ioa_engine_handle e, ioa_socket_handle client_socket) {\n\tswitch(stun_family) {\n\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4:\n\t\treturn AF_INET;\n\t\tbreak;\n\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6:\n\t\treturn AF_INET6;\n\t\tbreak;\n\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_DEFAULT:\n\t\tif(e->default_relays && get_ioa_socket_address_family(client_socket) == AF_INET6)\n\t\t\t\treturn AF_INET6;\n\t\telse\n\t\t\t\treturn AF_INET;\n\tdefault:\n\t\treturn AF_INET;\n\t};\n}\n\n////////////////////////////////////////////////\n\nconst char * get_version(turn_turnserver *server) {\n\tif(server && !*server->no_software_attribute) {\n\t\treturn (const char *) TURN_SOFTWARE;\n\t} else {\n\t\treturn (const char *) \"None\";\n\t}\n}\n\n#define MAX_NUMBER_OF_UNKNOWN_ATTRS (128)\n\nint TURN_MAX_ALLOCATE_TIMEOUT = 60;\nint TURN_MAX_ALLOCATE_TIMEOUT_STUN_ONLY = 3;\n\nstatic inline void log_method(ts_ur_super_session* ss, const char *method, int err_code, const uint8_t *reason)\n{\n  if(ss) {\n\t  if(!method) method = \"unknown\";\n\t  if(!err_code) {\n\t\t  if(ss->origin[0]) {\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\"session %018llu: origin <%s> realm <%s> user <%s>: incoming packet %s processed, success\\n\",\n\t\t\t\t\t(unsigned long long)(ss->id), (const char*)(ss->origin),(const char*)(ss->realm_options.name),(const char*)(ss->username),method);\n\t\t} else {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\"session %018llu: realm <%s> user <%s>: incoming packet %s processed, success\\n\",\n\t\t\t\t(unsigned long long)(ss->id), (const char*)(ss->realm_options.name),(const char*)(ss->username),method);\n\t\t}\n\t  } else {\n\t\t  if(!reason) reason=get_default_reason(err_code);\n\t\t  if(ss->origin[0]) {\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t  \"session %018llu: origin <%s> realm <%s> user <%s>: incoming packet %s processed, error %d: %s\\n\",\n\t\t\t\t\t  (unsigned long long)(ss->id), (const char*)(ss->origin),(const char*)(ss->realm_options.name),(const char*)(ss->username), method, err_code, reason);\n\t\t  } else {\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t  \"session %018llu: realm <%s> user <%s>: incoming packet %s processed, error %d: %s\\n\",\n\t\t\t\t\t  (unsigned long long)(ss->id), (const char*)(ss->realm_options.name),(const char*)(ss->username), method, err_code, reason);\n\t\t  }\n\t  }\n  }\n}\n\n///////////////////////////////////////////\n\nstatic int attach_socket_to_session(turn_turnserver* server, ioa_socket_handle s, ts_ur_super_session* ss);\n\nstatic int check_stun_auth(turn_turnserver *server,\n\t\t\tts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\tint *err_code, \tconst uint8_t **reason,\n\t\t\tioa_net_data *in_buffer, ioa_network_buffer_handle nbh,\n\t\t\tuint16_t method, int *message_integrity,\n\t\t\tint *postpone_reply,\n\t\t\tint can_resume);\n\nstatic int create_relay_connection(turn_turnserver* server,\n\t\tts_ur_super_session *ss, uint32_t lifetime,\n\t\tint address_family, uint8_t transport,\n\t\tint even_port, uint64_t in_reservation_token, uint64_t *out_reservation_token,\n\t\tint *err_code, const uint8_t **reason, accept_cb acb);\n\nstatic int refresh_relay_connection(turn_turnserver* server,\n\t\tts_ur_super_session *ss, uint32_t lifetime, int even_port,\n\t\tuint64_t in_reservation_token, uint64_t *out_reservation_token,\n\t\tint *err_code, int family);\n\nstatic int write_client_connection(turn_turnserver *server, ts_ur_super_session* ss, ioa_network_buffer_handle nbh, int ttl, int tos);\n\nstatic void tcp_peer_accept_connection(ioa_socket_handle s, void *arg);\n\nstatic int read_client_connection(turn_turnserver *server,\n\t\t\t\t  ts_ur_super_session *ss, ioa_net_data *in_buffer,\n\t\t\t\t  int can_resume, int count_usage);\n\nstatic int need_stun_authentication(turn_turnserver *server, ts_ur_super_session *ss);\n\n/////////////////// timer //////////////////////////\n\nstatic void timer_timeout_handler(ioa_engine_handle e, void *arg)\n{\n\tUNUSED_ARG(e);\n\tif(arg) {\n\t\tturn_turnserver *server=(turn_turnserver*)arg;\n\t\tserver->ctime = turn_time();\n\t}\n}\n\nturn_time_t get_turn_server_time(turn_turnserver *server)\n{\n\tif(server) {\n\t\treturn server->ctime;\n\t}\n\treturn turn_time();\n}\n\n/////////////////// quota //////////////////////\n\nstatic int inc_quota(ts_ur_super_session* ss, uint8_t *username)\n{\n\tif(ss && !(ss->quota_used) && ss->server && ((turn_turnserver*)ss->server)->chquotacb && username) {\n\n\t\tif(((turn_turnserver*)ss->server)->ct == TURN_CREDENTIALS_LONG_TERM) {\n\t\t\tif(!(ss->origin_set)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif((((turn_turnserver*)ss->server)->chquotacb)(username, ss->oauth, (uint8_t*)ss->realm_options.name)<0) {\n\n\t\t\treturn -1;\n\n\t\t} else {\n\n\t\t\tSTRCPY(ss->username,username);\n\n\t\t\tss->quota_used = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void dec_quota(ts_ur_super_session* ss)\n{\n\tif(ss && ss->quota_used && ss->server && ((turn_turnserver*)ss->server)->raqcb) {\n\n\t\tss->quota_used = 0;\n\n\t\t(((turn_turnserver*)ss->server)->raqcb)(ss->username, ss->oauth, (uint8_t*)ss->realm_options.name);\n\t}\n}\n\nstatic void dec_bps(ts_ur_super_session* ss)\n{\n\tif(ss && ss->server) {\n\n\t\tif(ss->bps) {\n\t\t\tif(((turn_turnserver*)ss->server)->allocate_bps_func) {\n\t\t\t\t((turn_turnserver*)ss->server)->allocate_bps_func(ss->bps,0);\n\t\t\t}\n\t\t\tss->bps = 0;\n\t\t}\n\t}\n}\n\n/////////////////// server lists ///////////////////\n\nvoid init_turn_server_addrs_list(turn_server_addrs_list_t *l)\n{\n\tif(l) {\n\t\tl->addrs = NULL;\n\t\tl->size = 0;\n\t\tturn_mutex_init(&(l->m));\n\t}\n}\n\n/////////////////// RFC 5780 ///////////////////////\n\nvoid set_rfc5780(turn_turnserver *server, get_alt_addr_cb cb, send_message_cb smcb)\n{\n\tif(server) {\n\t\tif(!cb || !smcb) {\n\t\t\tserver->rfc5780 = 0;\n\t\t\tserver->alt_addr_cb = NULL;\n\t\t\tserver->sm_cb = NULL;\n\t\t} else {\n\t\t\tserver->rfc5780 = 1;\n\t\t\tserver->alt_addr_cb = cb;\n\t\t\tserver->sm_cb = smcb;\n\t\t}\n\t}\n}\n\nstatic int is_rfc5780(turn_turnserver *server)\n{\n\tif(!server)\n\t\treturn 0;\n\n\treturn ((server->rfc5780) && (server->alt_addr_cb));\n}\n\nstatic int get_other_address(turn_turnserver *server, ts_ur_super_session *ss, ioa_addr *alt_addr)\n{\n\tif(is_rfc5780(server) && ss && ss->client_socket) {\n\t\tint ret = server->alt_addr_cb(get_local_addr_from_ioa_socket(ss->client_socket), alt_addr);\n\t\treturn ret;\n\t}\n\n\treturn -1;\n}\n\nstatic int send_turn_message_to(turn_turnserver *server, ioa_network_buffer_handle nbh, ioa_addr *response_origin, ioa_addr *response_destination)\n{\n\tif(is_rfc5780(server) && nbh && response_origin && response_destination) {\n\t\treturn server->sm_cb(server->e, nbh, response_origin, response_destination);\n\t}\n\n\treturn -1;\n}\n\n/////////////////// Peer addr check /////////////////////////////\n\nstatic int good_peer_addr(turn_turnserver *server, const char* realm, ioa_addr *peer_addr)\n{\n#define CHECK_REALM(r) if((r)[0] && realm && realm[0] && strcmp((r),realm)) continue\n\n\tif(server && peer_addr) {\n\t\tif(*(server->no_multicast_peers) && ioa_addr_is_multicast(peer_addr))\n\t\t\treturn 0;\n\t\tif( !*(server->allow_loopback_peers) && ioa_addr_is_loopback(peer_addr))\n\t\t\treturn 0;\n\n\t\t{\n\t\t\tint i;\n\n\t\t\tif(server->ip_whitelist) {\n\t\t\t\t// White listing of addr ranges\n\t\t\t\tfor (i = server->ip_whitelist->ranges_number - 1; i >= 0; --i) {\n\t\t\t\t\tCHECK_REALM(server->ip_whitelist->rs[i].realm);\n\t\t\t\t\tif (ioa_addr_in_range(&(server->ip_whitelist->rs[i].enc), peer_addr))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tioa_lock_whitelist(server->e);\n\n\t\t\t\tconst ip_range_list_t* wl = ioa_get_whitelist(server->e);\n\t\t\t\tif(wl) {\n\t\t\t\t\t// White listing of addr ranges\n\t\t\t\t\tfor (i = wl->ranges_number - 1; i >= 0; --i) {\n\t\t\t\t\t\tCHECK_REALM(wl->rs[i].realm);\n\t\t\t\t\t\tif (ioa_addr_in_range(&(wl->rs[i].enc), peer_addr)) {\n\t\t\t\t\t\t\tioa_unlock_whitelist(server->e);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tioa_unlock_whitelist(server->e);\n\t\t\t}\n\n\t\t\tif(server->ip_blacklist) {\n\t\t\t\t// Black listing of addr ranges\n\t\t\t\tfor (i = server->ip_blacklist->ranges_number - 1; i >= 0; --i) {\n\t\t\t\t\tCHECK_REALM(server->ip_blacklist->rs[i].realm);\n\t\t\t\t\tif (ioa_addr_in_range(&(server->ip_blacklist->rs[i].enc), peer_addr)) {\n\t\t\t\t\t\tchar saddr[129];\n\t\t\t\t\t\taddr_to_string_no_port(peer_addr,(uint8_t*)saddr);\n\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"A peer IP %s denied in the range: %s\\n\",saddr,server->ip_blacklist->rs[i].str);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tioa_lock_blacklist(server->e);\n\n\t\t\t\tconst ip_range_list_t* bl = ioa_get_blacklist(server->e);\n\t\t\t\tif(bl) {\n\t\t\t\t\t// Black listing of addr ranges\n\t\t\t\t\tfor (i = bl->ranges_number - 1; i >= 0; --i) {\n\t\t\t\t\t\tCHECK_REALM(bl->rs[i].realm);\n\t\t\t\t\t\tif (ioa_addr_in_range(&(bl->rs[i].enc), peer_addr)) {\n\t\t\t\t\t\t\tioa_unlock_blacklist(server->e);\n\t\t\t\t\t\t\tchar saddr[129];\n\t\t\t\t\t\t\taddr_to_string_no_port(peer_addr,(uint8_t*)saddr);\n\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"A peer IP %s denied in the range: %s\\n\",saddr,bl->rs[i].str);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tioa_unlock_blacklist(server->e);\n\t\t\t}\n\t\t}\n\t}\n\n#undef CHECK_REALM\n\n\treturn 1;\n}\n\n/////////////////// Allocation //////////////////////////////////\n\nallocation* get_allocation_ss(ts_ur_super_session *ss) {\n\treturn &(ss->alloc);\n}\n\nstatic inline relay_endpoint_session *get_relay_session_ss(ts_ur_super_session *ss, int family)\n{\n\treturn get_relay_session(&(ss->alloc),family);\n}\n\nstatic inline ioa_socket_handle get_relay_socket_ss(ts_ur_super_session *ss, int family)\n{\n\treturn get_relay_socket(&(ss->alloc),family);\n}\n\n/////////// Session info ///////\n\nvoid turn_session_info_init(struct turn_session_info* tsi) {\n\tif(tsi) {\n\t\tbzero(tsi,sizeof(struct turn_session_info));\n\t}\n}\n\nvoid turn_session_info_clean(struct turn_session_info* tsi) {\n\tif(tsi) {\n\t\tif(tsi->extra_peers_data) {\n\t\t\tfree(tsi->extra_peers_data);\n\t\t}\n\t\tturn_session_info_init(tsi);\n\t}\n}\n\nvoid turn_session_info_add_peer(struct turn_session_info* tsi, ioa_addr *peer)\n{\n\tif(tsi && peer) {\n\t\t{\n\t\t\tsize_t i;\n\t\t\tfor(i=0;i<tsi->main_peers_size;++i) {\n\t\t\t\tif(addr_eq(peer, &(tsi->main_peers_data[i].addr))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(tsi->main_peers_size < TURN_MAIN_PEERS_ARRAY_SIZE) {\n\t\t\t\taddr_cpy(&(tsi->main_peers_data[tsi->main_peers_size].addr),peer);\n\t\t\t\taddr_to_string(&(tsi->main_peers_data[tsi->main_peers_size].addr),\n\t\t\t\t\t(uint8_t*)tsi->main_peers_data[tsi->main_peers_size].saddr);\n\t\t\t\ttsi->main_peers_size += 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif(tsi->extra_peers_data) {\n\t\t\tsize_t sz;\n\t\t\tfor(sz=0;sz<tsi->extra_peers_size;++sz) {\n\t\t\t\tif(addr_eq(peer, &(tsi->extra_peers_data[sz].addr))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttsi->extra_peers_data = (addr_data*)realloc(tsi->extra_peers_data,(tsi->extra_peers_size+1)*sizeof(addr_data));\n\t\taddr_cpy(&(tsi->extra_peers_data[tsi->extra_peers_size].addr),peer);\n\t\taddr_to_string(&(tsi->extra_peers_data[tsi->extra_peers_size].addr),\n\t\t\t       (uint8_t*)tsi->extra_peers_data[tsi->extra_peers_size].saddr);\n\t\ttsi->extra_peers_size += 1;\n\t}\n}\n\nstruct tsi_arg {\n\tstruct turn_session_info* tsi;\n\tioa_addr *addr;\n};\n\nstatic int turn_session_info_foreachcb(ur_map_key_type key, ur_map_value_type value, void *arg)\n{\n\tUNUSED_ARG(value);\n\n\tint port = (int)key;\n\tstruct tsi_arg *ta = (struct tsi_arg *)arg;\n\tif(port && ta && ta->tsi && ta->addr) {\n\t\tioa_addr a;\n\t\taddr_cpy(&a,ta->addr);\n\t\taddr_set_port(&a,port);\n\t\tturn_session_info_add_peer(ta->tsi,&a);\n\t}\n\treturn 0;\n}\n\nint turn_session_info_copy_from(struct turn_session_info* tsi, ts_ur_super_session *ss)\n{\n\tint ret = -1;\n\n\tif(tsi && ss) {\n\t\ttsi->id = ss->id;\n\t\ttsi->bps = ss->bps;\n\t\ttsi->start_time = ss->start_time;\n\t\ttsi->valid = is_allocation_valid(&(ss->alloc)) && !(ss->to_be_closed) && (ss->quota_used);\n\t\tif(tsi->valid) {\n\t\t\tif(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s) {\n\t\t\t\ttsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].expiration_time;\n\t\t\t\tif(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {\n\t\t\t\t\tif(turn_time_before(tsi->expiration_time,ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time)) {\n\t\t\t\t\t\ttsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {\n\t\t\t\ttsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time;\n\t\t\t}\n\t\t\tif(ss->client_socket) {\n\t\t\t\ttsi->client_protocol = get_ioa_socket_type(ss->client_socket);\n\t\t\t\taddr_cpy(&(tsi->local_addr_data.addr),get_local_addr_from_ioa_socket(ss->client_socket));\n\t\t\t\taddr_to_string(&(tsi->local_addr_data.addr),(uint8_t*)tsi->local_addr_data.saddr);\n\t\t\t\taddr_cpy(&(tsi->remote_addr_data.addr),get_remote_addr_from_ioa_socket(ss->client_socket));\n\t\t\t\taddr_to_string(&(tsi->remote_addr_data.addr),(uint8_t*)tsi->remote_addr_data.saddr);\n\t\t\t}\n\t\t\t{\n\t\t\t\tif(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s) {\n\t\t\t\t\ttsi->peer_protocol = get_ioa_socket_type(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s);\n\t\t\t\t\tif(ss->alloc.is_valid) {\n\t\t\t\t\t\taddr_cpy(&(tsi->relay_addr_data_ipv4.addr),get_local_addr_from_ioa_socket(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s));\n\t\t\t\t\t\taddr_to_string(&(tsi->relay_addr_data_ipv4.addr),(uint8_t*)tsi->relay_addr_data_ipv4.saddr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {\n\t\t\t\t\ttsi->peer_protocol = get_ioa_socket_type(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s);\n\t\t\t\t\tif(ss->alloc.is_valid) {\n\t\t\t\t\t\taddr_cpy(&(tsi->relay_addr_data_ipv6.addr),get_local_addr_from_ioa_socket(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s));\n\t\t\t\t\t\taddr_to_string(&(tsi->relay_addr_data_ipv6.addr),(uint8_t*)tsi->relay_addr_data_ipv6.saddr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSTRCPY(tsi->username,ss->username);\n\t\t\ttsi->enforce_fingerprints = ss->enforce_fingerprints;\n\t\t\tSTRCPY(tsi->tls_method, get_ioa_socket_tls_method(ss->client_socket));\n\t\t\tSTRCPY(tsi->tls_cipher, get_ioa_socket_tls_cipher(ss->client_socket));\n\t\t\tSTRCPY(tsi->realm, ss->realm_options.name);\n\t\t\tSTRCPY(tsi->origin, ss->origin);\n\n\t\t\tif(ss->t_received_packets > ss->received_packets)\n\t\t\t\ttsi->received_packets = ss->t_received_packets;\n\t\t\telse\n\t\t\t\ttsi->received_packets = ss->received_packets;\n\n\t\t\tif(ss->t_sent_packets > ss->sent_packets)\n\t\t\t\ttsi->sent_packets = ss->t_sent_packets;\n\t\t\telse\n\t\t\t\ttsi->sent_packets = ss->sent_packets;\n\n\t\t\tif(ss->t_received_bytes > ss->received_bytes)\n\t\t\t\ttsi->received_bytes = ss->t_received_bytes;\n\t\t\telse\n\t\t\t\ttsi->received_bytes = ss->received_bytes;\n\n\t\t\tif(ss->t_sent_bytes > ss->sent_bytes)\n\t\t\t\ttsi->sent_bytes = ss->t_sent_bytes;\n\t\t\telse\n\t\t\t\ttsi->sent_bytes = ss->sent_bytes;\n\n\t\t\tif (ss->t_peer_received_packets > ss->peer_received_packets)\n\t\t\t\ttsi->peer_received_packets = ss->t_peer_received_packets;\n\t\t\telse\n\t\t\t\ttsi->peer_received_packets = ss->peer_received_packets;\n\n\t\t\tif (ss->t_peer_sent_packets > ss->peer_sent_packets)\n\t\t\t\ttsi->peer_sent_packets = ss->t_peer_sent_packets;\n\t\t\telse\n\t\t\t\ttsi->peer_sent_packets = ss->peer_sent_packets;\n\n\t\t\tif (ss->t_peer_received_bytes > ss->peer_received_bytes)\n\t\t\t\ttsi->peer_received_bytes = ss->t_peer_received_bytes;\n\t\t\telse\n\t\t\t\ttsi->peer_received_bytes = ss->peer_received_bytes;\n\n\t\t\tif (ss->t_peer_sent_bytes > ss->peer_sent_bytes)\n\t\t\t\ttsi->peer_sent_bytes = ss->t_peer_sent_bytes;\n\t\t\telse\n\t\t\t\ttsi->peer_sent_bytes = ss->peer_sent_bytes;\n\n\t\t\t{\n\t\t\t\ttsi->received_rate = ss->received_rate;\n\t\t\t\ttsi->sent_rate = ss->sent_rate;\n\t\t\t\ttsi->total_rate = tsi->received_rate + tsi->sent_rate;\n\t\t\t\ttsi->peer_received_rate = ss->peer_received_rate;\n\t\t\t\ttsi->peer_sent_rate = ss->peer_sent_rate;\n\t\t\t\ttsi->peer_total_rate = tsi->peer_received_rate + tsi->peer_sent_rate;\n\t\t\t}\n\n\t\t\ttsi->is_mobile = ss->is_mobile;\n\n\t\t\t{\n\t\t\t\tsize_t i;\n\t\t\t\tfor(i=0;i<TURN_PERMISSION_HASHTABLE_SIZE;++i) {\n\n\t\t\t\t\tturn_permission_array *parray = &(ss->alloc.addr_to_perm.table[i]);\n\n\t\t\t\t\t{\n\t\t\t\t\t\tsize_t j;\n\t\t\t\t\t\tfor(j=0;j<TURN_PERMISSION_ARRAY_SIZE;++j) {\n\t\t\t\t\t\t\tturn_permission_slot* slot = &(parray->main_slots[j]);\n\t\t\t\t\t\t\tif(slot->info.allocated) {\n\t\t\t\t\t\t\t\tturn_session_info_add_peer(tsi,&(slot->info.addr));\n\t\t\t\t\t\t\t\tstruct tsi_arg arg = {\n\t\t\t\t\t\t\t\t\ttsi,\n\t\t\t\t\t\t\t\t\t&(slot->info.addr)\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tlm_map_foreach_arg(&(slot->info.chns), turn_session_info_foreachcb, &arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t{\n\t\t\t\t\t\tturn_permission_slot **slots = parray->extra_slots;\n\t\t\t\t\t\tif(slots) {\n\t\t\t\t\t\t\tsize_t sz = parray->extra_sz;\n\t\t\t\t\t\t\tsize_t j;\n\t\t\t\t\t\t\tfor(j=0;j<sz;++j) {\n\t\t\t\t\t\t\t\tturn_permission_slot* slot = slots[j];\n\t\t\t\t\t\t\t\tif(slot && slot->info.allocated) {\n\t\t\t\t\t\t\t\t\tturn_session_info_add_peer(tsi,&(slot->info.addr));\n\t\t\t\t\t\t\t\t\tstruct tsi_arg arg = {\n\t\t\t\t\t\t\t\t\t\ttsi,\n\t\t\t\t\t\t\t\t\t\t&(slot->info.addr)\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tlm_map_foreach_arg(&(slot->info.chns), turn_session_info_foreachcb, &arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\ttcp_connection_list *tcl = &(ss->alloc.tcs);\n\t\t\t\tif(tcl->elems) {\n\t\t\t\t\tsize_t i;\n\t\t\t\t\tsize_t sz = tcl->sz;\n\t\t\t\t\tfor(i=0;i<sz;++i) {\n\t\t\t\t\t\tif(tcl->elems[i]) {\n\t\t\t\t\t\t\ttcp_connection *tc = tcl->elems[i];\n\t\t\t\t\t\t\tif(tc) {\n\t\t\t\t\t\t\t\tturn_session_info_add_peer(tsi,&(tc->peer_addr));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nint report_turn_session_info(turn_turnserver *server, ts_ur_super_session *ss, int force_invalid)\n{\n\tif(server && ss && server->send_turn_session_info) {\n\t\tstruct turn_session_info tsi;\n\t\tturn_session_info_init(&tsi);\n\t\tif(turn_session_info_copy_from(&tsi,ss)<0) {\n\t\t\tturn_session_info_clean(&tsi);\n\t\t} else {\n\t\t\tif(force_invalid)\n\t\t\t\ttsi.valid = 0;\n\t\t\tif(server->send_turn_session_info(&tsi)<0) {\n\t\t\t\tturn_session_info_clean(&tsi);\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/////////// SS /////////////////\n\nstatic int mobile_id_to_string(mobile_id_t mid, char *dst, size_t dst_sz)\n{\n\tsize_t output_length = 0;\n\n\tif(!dst)\n\t\treturn -1;\n\n\tchar *s = base64_encode((const unsigned char *)&mid,\n\t                    sizeof(mid),\n\t                    &output_length);\n\n\tif(!s)\n\t\treturn -1;\n\n\tif(!output_length || (output_length+1 > dst_sz)) {\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\n\tbcopy(s, dst, output_length);\n\n\tfree(s);\n\n\tdst[output_length] = 0;\n\n\treturn (int)output_length;\n}\n\nstatic mobile_id_t string_to_mobile_id(char* src)\n{\n\tmobile_id_t mid = 0;\n\n\tif(src) {\n\n\t\tsize_t output_length = 0;\n\n\t\tunsigned char *out = base64_decode(src, strlen(src), &output_length);\n\n\t\tif(out) {\n\n\t\t\tif(output_length == sizeof(mid)) {\n\t\t\t\tmid = *((mobile_id_t*)out);\n\t\t\t}\n\n\t\t\tfree(out);\n\t\t}\n\t}\n\n\treturn mid;\n}\n\nstatic mobile_id_t get_new_mobile_id(turn_turnserver* server)\n{\n\tmobile_id_t newid = 0;\n\n\tif(server && server->mobile_connections_map) {\n\t\tur_map *map = server->mobile_connections_map;\n\t\tuint64_t sid = server->id;\n\t\tsid = sid<<56;\n\t\tdo {\n\t\t\twhile (!newid) {\n\t\t\t\tif(TURN_RANDOM_SIZE == sizeof(mobile_id_t))\n\t\t\t\t\tnewid = (mobile_id_t)turn_random();\n\t\t\t\telse {\n\t\t\t\t\tnewid = (mobile_id_t)turn_random();\n\t\t\t\t\tnewid = (newid<<32) + (mobile_id_t)turn_random();\n\t\t\t\t}\n\t\t\t\tif(!newid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnewid = newid & 0x00FFFFFFFFFFFFFFLL;\n\t\t\t\tif(!newid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnewid = newid | sid;\n\t\t\t}\n\t\t} while(ur_map_get(map, (ur_map_key_type)newid, NULL));\n\t}\n\treturn newid;\n}\n\nstatic void put_session_into_mobile_map(ts_ur_super_session *ss)\n{\n\tif(ss && ss->server) {\n\t\tturn_turnserver* server = (turn_turnserver*)(ss->server);\n\t\tif(*(server->mobility) && server->mobile_connections_map) {\n\t\t\tif(!(ss->mobile_id)) {\n\t\t\t\tss->mobile_id = get_new_mobile_id(server);\n\t\t\t\tmobile_id_to_string(ss->mobile_id, ss->s_mobile_id, sizeof(ss->s_mobile_id));\n\t\t\t}\n\t\t\tur_map_put(server->mobile_connections_map, (ur_map_key_type)(ss->mobile_id), (ur_map_value_type)ss);\n\t\t}\n\t}\n\n}\n\nstatic void put_session_into_map(ts_ur_super_session *ss)\n{\n\tif(ss && ss->server) {\n\t\tturn_turnserver* server = (turn_turnserver*)(ss->server);\n\t\tif(!(ss->id)) {\n\t\t\tss->id = (turnsession_id)((turnsession_id)server->id * TURN_SESSION_ID_FACTOR);\n\t\t\tss->id += ++(server->session_id_counter);\n\t\t\tss->start_time = server->ctime;\n\t\t}\n\t\tur_map_put(server->sessions_map, (ur_map_key_type)(ss->id), (ur_map_value_type)ss);\n\t\tput_session_into_mobile_map(ss);\n\t}\n}\n\nstatic void delete_session_from_mobile_map(ts_ur_super_session *ss)\n{\n\tif(ss && ss->server && ss->mobile_id) {\n\t\tturn_turnserver* server = (turn_turnserver*)(ss->server);\n\t\tif(server->mobile_connections_map) {\n\t\t\tur_map_del(server->mobile_connections_map, (ur_map_key_type)(ss->mobile_id), NULL);\n\t\t}\n\t\tss->mobile_id = 0;\n\t\tss->s_mobile_id[0] = 0;\n\t}\n}\n\nstatic void delete_session_from_map(ts_ur_super_session *ss)\n{\n\tif(ss && ss->server) {\n\t\tturn_turnserver* server = (turn_turnserver*)(ss->server);\n\t\tur_map_del(server->sessions_map, (ur_map_key_type)(ss->id), NULL);\n\t\tdelete_session_from_mobile_map(ss);\n\t}\n}\n\nstatic ts_ur_super_session* get_session_from_map(turn_turnserver* server, turnsession_id sid)\n{\n\tts_ur_super_session *ss = NULL;\n\tif(server) {\n\t\tur_map_value_type value = 0;\n\t\tif(ur_map_get(server->sessions_map, (ur_map_key_type)sid, &value) && value) {\n\t\t\tss = (ts_ur_super_session*)value;\n\t\t}\n\t}\n\treturn ss;\n}\n\nvoid turn_cancel_session(turn_turnserver *server, turnsession_id sid)\n{\n\tif(server) {\n\t\tts_ur_super_session* ts = get_session_from_map(server, sid);\n\t\tif(ts) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Session %018llu to be forcefully canceled\\n\",(unsigned long long)sid);\n\t\t\tshutdown_client_connection(server, ts, 0, \"Forceful shutdown\");\n\t\t}\n\t}\n}\n\nstatic ts_ur_super_session* get_session_from_mobile_map(turn_turnserver* server, mobile_id_t mid)\n{\n\tts_ur_super_session *ss = NULL;\n\tif(server && *(server->mobility) && server->mobile_connections_map && mid) {\n\t\tur_map_value_type value = 0;\n\t\tif(ur_map_get(server->mobile_connections_map, (ur_map_key_type)mid, &value) && value) {\n\t\t\tss = (ts_ur_super_session*)value;\n\t\t}\n\t}\n\treturn ss;\n}\n\nstatic ts_ur_super_session* create_new_ss(turn_turnserver* server) {\n\t//\n\t//printf(\"%s: 111.111: session size=%lu\\n\",__FUNCTION__,(unsigned long)sizeof(ts_ur_super_session));\n\t//\n\tts_ur_super_session *ss = (ts_ur_super_session*)malloc(sizeof(ts_ur_super_session));\n\tbzero(ss,sizeof(ts_ur_super_session));\n\tss->server = server;\n\tget_default_realm_options(&(ss->realm_options));\n\tput_session_into_map(ss);\n\tinit_allocation(ss,&(ss->alloc), server->tcp_relay_connections);\n\treturn ss;\n}\n\nstatic void delete_ur_map_ss(void *p) {\n\tif (p) {\n\t\tts_ur_super_session* ss = (ts_ur_super_session*) p;\n\t\tdelete_session_from_map(ss);\n\t\tIOA_CLOSE_SOCKET(ss->client_socket);\n\t\tclear_allocation(get_allocation_ss(ss));\n\t\tIOA_EVENT_DEL(ss->to_be_allocated_timeout_ev);\n\t\tfree(p);\n\t}\n}\n\n/////////// clean all /////////////////////\n\nstatic int turn_server_remove_all_from_ur_map_ss(ts_ur_super_session* ss) {\n\tif (!ss)\n\t\treturn 0;\n\telse {\n\t\tint ret = 0;\n\t\tif (ss->client_socket) {\n\t\t\tclear_ioa_socket_session_if(ss->client_socket, ss);\n\t\t}\n\t\tif (get_relay_socket_ss(ss,AF_INET)) {\n\t\t\tclear_ioa_socket_session_if(get_relay_socket_ss(ss,AF_INET), ss);\n\t\t}\n\t\tif (get_relay_socket_ss(ss,AF_INET6)) {\n\t\t\tclear_ioa_socket_session_if(get_relay_socket_ss(ss,AF_INET6), ss);\n\t\t}\n\t\tdelete_ur_map_ss(ss);\n\t\treturn ret;\n\t}\n}\n\n/////////////////////////////////////////////////////////////////\n\nstatic void client_ss_channel_timeout_handler(ioa_engine_handle e, void* arg) {\n\n\tUNUSED_ARG(e);\n\n\tif (!arg)\n\t\treturn;\n\n\tch_info* chn = (ch_info*) arg;\n\n\tturn_channel_delete(chn);\n}\n\nstatic void client_ss_perm_timeout_handler(ioa_engine_handle e, void* arg) {\n\n\tUNUSED_ARG(e);\n\n\tif (!arg) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"!!! %s: empty permission to be cleaned\\n\",__FUNCTION__);\n\t\treturn;\n\t}\n\n\tturn_permission_info* tinfo = (turn_permission_info*) arg;\n\n\tif(!(tinfo->allocated)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"!!! %s: unallocated permission to be cleaned\\n\",__FUNCTION__);\n\t\treturn;\n\t}\n\n\tif(!(tinfo->lifetime_ev)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"!!! %s: strange (1) permission to be cleaned\\n\",__FUNCTION__);\n\t}\n\n\tif(!(tinfo->owner)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"!!! %s: strange (2) permission to be cleaned\\n\",__FUNCTION__);\n\t}\n\n\tturn_permission_clean(tinfo);\n}\n\n///////////////////////////////////////////////////////////////////\n\nstatic int update_turn_permission_lifetime(ts_ur_super_session *ss, turn_permission_info *tinfo, turn_time_t time_delta) {\n\n\tif (ss && tinfo && tinfo->owner) {\n\n\t\tturn_turnserver *server = (turn_turnserver *) (ss->server);\n\n\t\tif (server) {\n\n\t\t\tif(!time_delta) time_delta = *(server->permission_lifetime);\n\t\t\ttinfo->expiration_time = server->ctime + time_delta;\n\n\t\t\tIOA_EVENT_DEL(tinfo->lifetime_ev);\n\t\t\ttinfo->lifetime_ev = set_ioa_timer(server->e, time_delta, 0,\n\t\t\t\t\t\t\tclient_ss_perm_timeout_handler, tinfo, 0,\n\t\t\t\t\t\t\t\"client_ss_channel_timeout_handler\");\n\n\t\t\tif(server->verbose) {\n\t\t\t\ttinfo->verbose = 1;\n\t\t\t\ttinfo->session_id = ss->id;\n\t\t\t\tchar s[257]=\"\\0\";\n\t\t\t\taddr_to_string(&(tinfo->addr),(uint8_t*)s);\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"session %018llu: peer %s lifetime updated: %lu\\n\",(unsigned long long)ss->id,s,(unsigned long)time_delta);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int update_channel_lifetime(ts_ur_super_session *ss, ch_info* chn)\n{\n\n\tif (chn) {\n\n\t\tturn_permission_info* tinfo = (turn_permission_info*) (chn->owner);\n\n\t\tif (tinfo && tinfo->owner) {\n\n\t\t\tturn_turnserver *server = (turn_turnserver *) (ss->server);\n\n\t\t\tif (server) {\n\n\t\t\t\tif (update_turn_permission_lifetime(ss, tinfo, *(server->channel_lifetime)) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tchn->expiration_time = server->ctime + *(server->channel_lifetime);\n\n\t\t\t\tIOA_EVENT_DEL(chn->lifetime_ev);\n\t\t\t\tchn->lifetime_ev = set_ioa_timer(server->e, *(server->channel_lifetime), 0,\n\t\t\t\t\t\t\t\tclient_ss_channel_timeout_handler,\n\t\t\t\t\t\t\t\tchn, 0,\n\t\t\t\t\t\t\t\t\"client_ss_channel_timeout_handler\");\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n/////////////// TURN ///////////////////////////\n\n#define SKIP_ATTRIBUTES case STUN_ATTRIBUTE_OAUTH_ACCESS_TOKEN: case STUN_ATTRIBUTE_PRIORITY: case STUN_ATTRIBUTE_FINGERPRINT: case STUN_ATTRIBUTE_MESSAGE_INTEGRITY: break; \\\n\tcase STUN_ATTRIBUTE_USERNAME: case STUN_ATTRIBUTE_REALM: case STUN_ATTRIBUTE_NONCE: case STUN_ATTRIBUTE_ORIGIN: \\\n\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\\\n\t\tioa_network_buffer_get_size(in_buffer->nbh), sar); \\\n\tcontinue\n\nstatic uint8_t get_transport_value(const uint8_t *value) {\n\tif((value[0] == STUN_ATTRIBUTE_TRANSPORT_UDP_VALUE)||\n\t   (value[0] == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE)) {\n\t\treturn value[0];\n\t}\n\treturn 0;\n}\n\nstatic int handle_turn_allocate(turn_turnserver *server,\n\t\t\t\tts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\tint *err_code, \tconst uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\tioa_net_data *in_buffer, ioa_network_buffer_handle nbh) {\n\n\n\tint err_code4 = 0;\n\tint err_code6 = 0;\n\n\tallocation* alloc = get_allocation_ss(ss);\n\n\tif (is_allocation_valid(alloc)) {\n\n\t\tif (!stun_tid_equals(tid, &(alloc->tid))) {\n\t\t\t*err_code = 437;\n\t\t\t*reason = (const uint8_t *)\"Wrong TID\";\n\t\t} else {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tioa_addr xor_relayed_addr1, *pxor_relayed_addr1=NULL;\n\t\t\tioa_addr xor_relayed_addr2, *pxor_relayed_addr2=NULL;\n\t\t\tioa_addr *relayed_addr1 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET));\n\t\t\tioa_addr *relayed_addr2 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET6));\n\n\t\t\tif(get_relay_session_failure(alloc,AF_INET)) {\n\t\t\t\taddr_set_any(&xor_relayed_addr1);\n\t\t\t\tpxor_relayed_addr1 = &xor_relayed_addr1;\n\t\t\t} else if(relayed_addr1) {\n\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\taddr_cpy(&xor_relayed_addr1, &(server->external_ip));\n\t\t\t\t\taddr_set_port(&xor_relayed_addr1,addr_get_port(relayed_addr1));\n\t\t\t\t} else {\n\t\t\t\t\taddr_cpy(&xor_relayed_addr1, relayed_addr1);\n\t\t\t\t}\n\t\t\t\tpxor_relayed_addr1 = &xor_relayed_addr1;\n\t\t\t}\n\n\t\t\tif(get_relay_session_failure(alloc,AF_INET6)) {\n\t\t\t\taddr_set_any(&xor_relayed_addr2);\n\t\t\t\tpxor_relayed_addr2 = &xor_relayed_addr2;\n\t\t\t} else if(relayed_addr2) {\n\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\taddr_cpy(&xor_relayed_addr2, &(server->external_ip));\n\t\t\t\t\taddr_set_port(&xor_relayed_addr2,addr_get_port(relayed_addr2));\n\t\t\t\t} else {\n\t\t\t\t\taddr_cpy(&xor_relayed_addr2, relayed_addr2);\n\t\t\t\t}\n\t\t\t\tpxor_relayed_addr2 = &xor_relayed_addr2;\n\t\t\t}\n\n\t\t\tif(pxor_relayed_addr1 || pxor_relayed_addr2) {\n\t\t\t\tuint32_t lifetime = 0;\n\t\t\t\tif(pxor_relayed_addr1) {\n\t\t\t\t\tlifetime = (get_relay_session(alloc,pxor_relayed_addr1->ss.sa_family)->expiration_time - server->ctime);\n\t\t\t\t} else if(pxor_relayed_addr2) {\n\t\t\t\t\tlifetime = (get_relay_session(alloc,pxor_relayed_addr2->ss.sa_family)->expiration_time - server->ctime);\n\t\t\t\t}\n\t\t\t\tstun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\ttid,\n\t\t\t\t\t\t\tpxor_relayed_addr1, pxor_relayed_addr2,\n\t\t\t\t\t\t\tget_remote_addr_from_ioa_socket(ss->client_socket),\n\t\t\t\t\t\t\tlifetime,*(server->max_allocate_lifetime), 0, NULL, 0,\n\t\t\t\t\t\t\tss->s_mobile_id);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t*resp_constructed = 1;\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\tuint8_t transport = 0;\n\t\tturn_time_t lifetime = 0;\n\t\tint even_port = -1;\n\t\tint dont_fragment = 0;\n\t\tuint64_t in_reservation_token = 0;\n\t\tint af4 = 0;\n\t\tint af6 = 0;\n\t\tuint8_t username[STUN_MAX_USERNAME_SIZE+1]=\"\\0\";\n\t\tsize_t ulen = 0;\n\t\tband_limit_t bps = 0;\n\t\tband_limit_t max_bps = 0;\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\n\t\t\tif(attr_type == STUN_ATTRIBUTE_USERNAME) {\n\t\t\t\tconst uint8_t* value = stun_attr_get_value(sar);\n\t\t\t\tif (value) {\n\t\t\t\t\tulen = stun_attr_get_len(sar);\n\t\t\t\t\tif(ulen>=sizeof(username)) {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"User name is too long\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbcopy(value,username,ulen);\n\t\t\t\t\tusername[ulen]=0;\n\t\t\t\t\tif(!is_secure_string(username,1)) {\n\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: wrong username: %s\\n\", __FUNCTION__, (char*)username);\n\t\t\t\t\t\tusername[0]=0;\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_NEW_BANDWIDTH:\n\t\t\t\tbps = stun_attr_get_bandwidth(sar);\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_MOBILITY_TICKET:\n\t\t\t\tif(!(*(server->mobility))) {\n\t\t\t\t\t*err_code = 405;\n\t\t\t\t\t*reason = (const uint8_t *)\"Mobility Forbidden\";\n\t\t\t\t} else if (stun_attr_get_len(sar) != 0) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Mobility Field\";\n\t\t\t\t} else {\n\t\t\t\t\tss->is_mobile = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_REQUESTED_TRANSPORT: {\n\t\t\t\tif (stun_attr_get_len(sar) != 4) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Transport Field\";\n\t\t\t\t} else if(transport) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Duplicate Transport Fields\";\n\t\t\t\t} else {\n\t\t\t\t\tconst uint8_t* value = stun_attr_get_value(sar);\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\ttransport = get_transport_value(value);\n\t\t\t\t\t\tif (!transport) {\n\t\t\t\t\t\t\t*err_code = 442;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && *(server->no_tcp_relay)) {\n\t\t\t\t\t\t\t*err_code = 442;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"TCP Transport is not allowed by the TURN Server configuration\";\n\t\t\t\t\t\t} else if((transport == STUN_ATTRIBUTE_TRANSPORT_UDP_VALUE) && *(server->no_udp_relay)) {\n\t\t\t\t\t\t\t*err_code = 442;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"UDP Transport is not allowed by the TURN Server configuration\";\n\t\t\t\t\t\t} else if(ss->client_socket) {\n\t\t\t\t\t\t\tSOCKET_TYPE cst = get_ioa_socket_type(ss->client_socket);\n\t\t\t\t\t\t\tif((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && !is_stream_socket(cst)) {\n\t\t\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Transport Data\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tss->is_tcp_relay = (transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Transport Data\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_DONT_FRAGMENT:\n\t\t\t\tdont_fragment = 1;\n\t\t\t\tif(!(server->dont_fragment))\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_LIFETIME: {\n\t\t\t  if (stun_attr_get_len(sar) != 4) {\n\t\t\t    *err_code = 400;\n\t\t\t    *reason = (const uint8_t *)\"Wrong Lifetime Field\";\n\t\t\t  } else {\n\t\t\t    const uint8_t* value = stun_attr_get_value(sar);\n\t\t\t    if (!value) {\n\t\t\t      *err_code = 400;\n\t\t\t      *reason = (const uint8_t *)\"Wrong Lifetime Data\";\n\t\t\t    } else {\n\t\t\t      lifetime = nswap32(*((const uint32_t*)value));\n\t\t\t    }\n\t\t\t  }\n\t\t\t}\n\t\t\t  break;\n\t\t\tcase STUN_ATTRIBUTE_EVEN_PORT: {\n\t\t\t  if (in_reservation_token) {\n\t\t\t    *err_code = 400;\n\t\t\t    *reason = (const uint8_t *)\"Even Port and Reservation Token cannot be used together\";\n\t\t\t  } else {\n\t\t\t    even_port = stun_attr_get_even_port(sar);\n\t\t\t    if(even_port) {\n\t\t\t    \tif (af4 && af6) {\n\t\t\t    \t\t*err_code = 400;\n\t\t\t    \t\t*reason = (const uint8_t *)\"Even Port cannot be used with Dual Allocation\";\n\t\t\t    \t}\n\t\t\t    }\n\t\t\t  }\n\t\t\t}\n\t\t\t  break;\n\t\t\tcase STUN_ATTRIBUTE_RESERVATION_TOKEN: {\n\t\t\t  int len = stun_attr_get_len(sar);\n\t\t\t  if (len != 8) {\n\t\t\t    *err_code = 400;\n\t\t\t    *reason = (const uint8_t *)\"Wrong Format of Reservation Token\";\n\t\t\t  } else if(af4 || af6) {\n\t\t\t\t  *err_code = 400;\n\t\t\t\t  *reason = (const uint8_t *)\"Address family attribute can not be used with reservation token request\";\n\t\t\t  } else {\n\t\t\t    if (even_port >= 0) {\n\t\t\t      *err_code = 400;\n\t\t\t      *reason = (const uint8_t *)\"Reservation Token cannot be used in this request with even port\";\n\t\t\t    } else if (in_reservation_token) {\n\t\t\t      *err_code = 400;\n\t\t\t      *reason = (const uint8_t *)\"Reservation Token cannot be used in this request\";\n\t\t\t    } else {\n\t\t\t      in_reservation_token = stun_attr_get_reservation_token_value(sar);\n\t\t\t    }\n\t\t\t  }\n\t\t\t}\n\t\t\t  break;\n\t\t\tcase STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY:\n\t\t\t\tif(even_port>0) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Even Port cannot be used with Dual Allocation\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* Falls through. */\n\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY: {\n\t\t\t\tif(in_reservation_token) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Address family attribute can not be used with reservation token request\";\n\t\t\t\t} else if(af4 || af6) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Extra address family attribute can not be used in the request\";\n\t\t\t\t} else {\n\t\t\t\t\tint af_req = stun_get_requested_address_family(sar);\n\t\t\t\t\tswitch (af_req) {\n\t\t\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4:\n\t\t\t\t\t\tif(attr_type == STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY) {\n\t\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Invalid value of the additional address family attribute\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taf4 = af_req;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6:\n\t\t\t\t\t\tif(attr_type == STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY) {\n\t\t\t\t\t\t\taf4 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taf6 = af_req;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t*err_code = 440;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t  break;\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t     sar);\n\t\t}\n\n\t\tif (!transport) {\n\n\t\t  *err_code = 400;\n\t\t  if(!(*reason))\n\t\t    *reason = (const uint8_t *)\"Transport field missed or wrong\";\n\t\t  \n\t\t} else if (*ua_num > 0) {\n\n\t\t  *err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && (dont_fragment || in_reservation_token || (even_port!=-1))) {\n\n\t\t\t*err_code = 400;\n\t\t\tif(!(*reason))\n\t\t\t    *reason = (const uint8_t *)\"Request parameters are incompatible with TCP transport\";\n\n\t\t} else {\n\n\t\t\tif(*(server->mobility)) {\n\t\t\t\tif(!(ss->is_mobile)) {\n\t\t\t\t\tdelete_session_from_mobile_map(ss);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);\n\t\t\tuint64_t out_reservation_token = 0;\n\n\t\t\tif(inc_quota(ss, username)<0) {\n\n\t\t\t\t*err_code = 486;\n\n\t\t\t} else {\n\n\t\t\t\tif(server->allocate_bps_func) {\n\t\t\t\t\tmax_bps = ss->realm_options.perf_options.max_bps;\n\t\t\t\t\tif(max_bps && (!bps || (bps && (bps>max_bps)))) {\n\t\t\t\t\t\tbps = max_bps;\n\t\t\t\t\t}\n\t\t\t\t\tif(bps && (ss->bps == 0)) {\n\t\t\t\t\t\tss->bps = server->allocate_bps_func(bps,1);\n\t\t\t\t\t\tif(!(ss->bps)) {\n\t\t\t\t\t\t\t*err_code = 486;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Allocation Bandwidth Quota Reached\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(af4) af4 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;\n\t\t\t\tif(af6) af6 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6;\n\n\t\t\t\tif(af4 && af6) {\n\t\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\t\t*err_code = 440;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Dual allocation cannot be supported in the current server configuration\";\n\t\t\t\t\t}\n\t\t\t\t\tif(even_port > 0) {\n\t\t\t\t\t\t*err_code = 440;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Dual allocation cannot be supported with even-port functionality\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\tif(!af4 && !af6) {\n\t\t\t\t\t\tint a_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_DEFAULT;\n\t\t\t\t\t\tif (server->keep_address_family) {\n\t\t\t\t\t\t\tswitch(get_ioa_socket_address_family(ss->client_socket)) {\n\t\t\t\t\t\t\t\tcase AF_INET6 :\n\t\t\t\t\t\t\t\t\ta_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase AF_INET :\n\t\t\t\t\t\t\t\t\ta_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\ta_family, transport,\n\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\terr_code, reason,\n\t\t\t\t\t\ttcp_peer_accept_connection);\n\n\t\t\t\t\t\tif(res<0) {\n\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET);\n\t\t\t\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(!af4 && af6) {\n\t\t\t\t\t\tint af6res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\t\taf6, transport,\n\t\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\t\terr_code, reason,\n\t\t\t\t\t\t\ttcp_peer_accept_connection);\n\t\t\t\t\t\tif(af6res<0) {\n\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET6);\n\t\t\t\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(af4 && !af6) {\n\t\t\t\t\t\tint af4res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\t\taf4, transport,\n\t\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\t\terr_code, reason,\n\t\t\t\t\t\t\ttcp_peer_accept_connection);\n\t\t\t\t\t\tif(af4res<0) {\n\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET);\n\t\t\t\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst uint8_t *reason4 = NULL;\n\t\t\t\t\t\tconst uint8_t *reason6 = NULL;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint af4res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\t\t\t\taf4, transport,\n\t\t\t\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\t\t\t\t&err_code4, &reason4,\n\t\t\t\t\t\t\t\t\ttcp_peer_accept_connection);\n\t\t\t\t\t\t\tif(af4res<0) {\n\t\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET);\n\t\t\t\t\t\t\t\tif(!err_code4) {\n\t\t\t\t\t\t\t\t\terr_code4 = 440;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint af6res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\t\t\t\t\t\t\taf6, transport,\n\t\t\t\t\t\t\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\t\t\t\t\t\t\t&err_code6, &reason6,\n\t\t\t\t\t\t\t\t\t\t\t\ttcp_peer_accept_connection);\n\t\t\t\t\t\t\tif(af6res<0) {\n\t\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET6);\n\t\t\t\t\t\t\t\tif(!err_code6) {\n\t\t\t\t\t\t\t\t\terr_code6 = 440;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(err_code4 && err_code6) {\n\t\t\t\t\t\t\tif(reason4) {\n\t\t\t\t\t\t\t\t*err_code = err_code4;\n\t\t\t\t\t\t\t\t*reason = reason4;\n\t\t\t\t\t\t\t} else if(reason6) {\n\t\t\t\t\t\t\t\t*err_code = err_code6;\n\t\t\t\t\t\t\t\t*reason = reason6;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t*err_code = err_code4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (*err_code) {\n\n\t\t\t\t\tif(!(*reason)) {\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot create relay endpoint(s)\";\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tset_allocation_valid(alloc,1);\n\n\t\t\t\t\tstun_tid_cpy(&(alloc->tid), tid);\n\n\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\n\t\t\t\t\tioa_addr xor_relayed_addr1, *pxor_relayed_addr1=NULL;\n\t\t\t\t\tioa_addr xor_relayed_addr2, *pxor_relayed_addr2=NULL;\n\t\t\t\t\tioa_addr *relayed_addr1 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET));\n\t\t\t\t\tioa_addr *relayed_addr2 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET6));\n\n\t\t\t\t\tif(get_relay_session_failure(alloc,AF_INET)) {\n\t\t\t\t\t\taddr_set_any(&xor_relayed_addr1);\n\t\t\t\t\t\tpxor_relayed_addr1 = &xor_relayed_addr1;\n\t\t\t\t\t} else if(relayed_addr1) {\n\t\t\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\t\t\taddr_cpy(&xor_relayed_addr1, &(server->external_ip));\n\t\t\t\t\t\t\taddr_set_port(&xor_relayed_addr1,addr_get_port(relayed_addr1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddr_cpy(&xor_relayed_addr1, relayed_addr1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpxor_relayed_addr1 = &xor_relayed_addr1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(get_relay_session_failure(alloc,AF_INET6)) {\n\t\t\t\t\t\taddr_set_any(&xor_relayed_addr2);\n\t\t\t\t\t\tpxor_relayed_addr2 = &xor_relayed_addr2;\n\t\t\t\t\t} else if(relayed_addr2) {\n\t\t\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\t\t\taddr_cpy(&xor_relayed_addr2, &(server->external_ip));\n\t\t\t\t\t\t\taddr_set_port(&xor_relayed_addr2,addr_get_port(relayed_addr2));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddr_cpy(&xor_relayed_addr2, relayed_addr2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpxor_relayed_addr2 = &xor_relayed_addr2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(pxor_relayed_addr1 || pxor_relayed_addr2) {\n\n\t\t\t\t\t\tstun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len, tid,\n\t\t\t\t\t\t\t\t\tpxor_relayed_addr1, pxor_relayed_addr2,\n\t\t\t\t\t\t\t\t\tget_remote_addr_from_ioa_socket(ss->client_socket), lifetime,\n\t\t\t\t\t\t\t\t\t*(server->max_allocate_lifetime),0,NULL,\n\t\t\t\t\t\t\t\t\tout_reservation_token,\n\t\t\t\t\t\t\t\t\tss->s_mobile_id);\n\n\t\t\t\t\t\tif(ss->bps) {\n\t\t\t\t\t\t\tstun_attr_add_bandwidth_str(ioa_network_buffer_data(nbh), &len, ss->bps);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t\t\t*resp_constructed = 1;\n\n\t\t\t\t\t\tturn_report_allocation_set(&(ss->alloc), lifetime, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(*resp_constructed)) {\n\n\t\tif (!(*err_code)) {\n\t\t\t*err_code = 437;\n\t\t}\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\tstun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len, tid, NULL, NULL, NULL, 0, *(server->max_allocate_lifetime), *err_code, *reason, 0, ss->s_mobile_id);\n\t\tioa_network_buffer_set_size(nbh,len);\n\t\t*resp_constructed = 1;\n\t}\n\n\tif(*resp_constructed && !(*err_code)) {\n\t\tif(err_code4) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_address_error_code(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4, err_code4);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\t\tif(err_code6) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_address_error_code(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6, err_code6);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void copy_auth_parameters(ts_ur_super_session *orig_ss, ts_ur_super_session *ss) {\n\tif(orig_ss && ss) {\n\t\tdec_quota(ss);\n\t\tbcopy(orig_ss->nonce,ss->nonce,sizeof(ss->nonce));\n\t\tss->nonce_expiration_time = orig_ss->nonce_expiration_time;\n\t\tbcopy(&(orig_ss->realm_options),&(ss->realm_options),sizeof(ss->realm_options));\n\t\tbcopy(orig_ss->username,ss->username,sizeof(ss->username));\n\t\tss->hmackey_set = orig_ss->hmackey_set;\n\t\tbcopy(orig_ss->hmackey,ss->hmackey,sizeof(ss->hmackey));\n\t\tss->oauth = orig_ss->oauth;\n\t\tbcopy(orig_ss->origin,ss->origin,sizeof(ss->origin));\n\t\tss->origin_set = orig_ss->origin_set;\n\t\tbcopy(orig_ss->pwd,ss->pwd,sizeof(ss->pwd));\n\t\tss->max_session_time_auth = orig_ss->max_session_time_auth;\n\t\tinc_quota(ss,ss->username);\n\t}\n}\n\nstatic int handle_turn_refresh(turn_turnserver *server,\n\t\t\t       ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t       int *err_code, \tconst uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t       ioa_net_data *in_buffer, ioa_network_buffer_handle nbh,\n\t\t\t       int message_integrity, int *no_response, int can_resume) {\n\n\tallocation* a = get_allocation_ss(ss);\n\tint af4c = 0;\n\tint af6c = 0;\n\tint af4 = 0;\n\tint af6 = 0;\n\t{\n\t\tint i;\n\t\tfor(i = 0;i<ALLOC_PROTOCOLS_NUMBER; ++i) {\n\t\t\tif(a->relay_sessions[i].s && !ioa_socket_tobeclosed(a->relay_sessions[i].s)) {\n\t\t\t\tint family = get_ioa_socket_address_family(a->relay_sessions[i].s);\n\t\t\t\tif(AF_INET == family) {\n\t\t\t\t\taf4c = 1;\n\t\t\t\t} else if(AF_INET6 == family) {\n\t\t\t\t\taf6c = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!is_allocation_valid(a) && !(*(server->mobility))) {\n\n\t\t*err_code = 437;\n\t\t*reason = (const uint8_t *)\"Invalid allocation\";\n\n\t} else {\n\n\t\tturn_time_t lifetime = 0;\n\t\tint to_delete = 0;\n\t\tmobile_id_t mid = 0;\n\t\tchar smid[sizeof(ss->s_mobile_id)] = \"\\0\";\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_MOBILITY_TICKET: {\n\t\t\t\tif(!(*(server->mobility))) {\n\t\t\t\t\t*err_code = 405;\n\t\t\t\t\t*reason = (const uint8_t *)\"Mobility forbidden\";\n\t\t\t\t} else {\n\t\t\t\t\tint smid_len = stun_attr_get_len(sar);\n\t\t\t\t\tif(smid_len>0 && (((size_t)smid_len)<sizeof(smid))) {\n\t\t\t\t\t\tconst uint8_t* smid_val = stun_attr_get_value(sar);\n\t\t\t\t\t\tif(smid_val) {\n\t\t\t\t\t\t\tbcopy(smid_val, smid, (size_t)smid_len);\n\t\t\t\t\t\t\tmid = string_to_mobile_id(smid);\n\t\t\t\t\t\t\tif(is_allocation_valid(a) && (mid != ss->old_mobile_id)) {\n\t\t\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Mobility ticket cannot be used for a stable, already established allocation\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Mobility ticket has wrong length\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_LIFETIME: {\n\t\t\t\tif (stun_attr_get_len(sar) != 4) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Lifetime field format\";\n\t\t\t\t} else {\n\t\t\t\t\tconst uint8_t* value = stun_attr_get_value(sar);\n\t\t\t\t\tif (!value) {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong lifetime field data\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlifetime = nswap32(*((const uint32_t*)value));\n\t\t\t\t\t\tif (!lifetime)\n\t\t\t\t\t\t\tto_delete = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY: /* deprecated, for backward compatibility with older versions of TURN-bis */\n\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY: {\n\t\t\t\tint af_req = stun_get_requested_address_family(sar);\n\t\t\t\t{\n\t\t\t\t\tint is_err = 0;\n\t\t\t\t\tswitch (af_req) {\n\t\t\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4:\n\t\t\t\t\t\tif(!af4c) {\n\t\t\t\t\t\t\tis_err = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taf4 = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6:\n\t\t\t\t\t\tif(!af6c) {\n\t\t\t\t\t\t\tis_err = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taf6 = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tis_err = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(is_err) {\n\t\t\t\t\t\t*err_code = 443;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Peer Address Family Mismatch (1)\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), sar);\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if(!is_allocation_valid(a)) {\n\n\t\t\tif(mid && smid[0]) {\n\n\t\t\t\tturnserver_id tsid = ((0xFF00000000000000LL) & mid)>>56;\n\n\t\t\t\tif(tsid != server->id) {\n\n\t\t\t\t\tif(server->send_socket_to_relay) {\n\t\t\t\t\t\tioa_socket_handle new_s = detach_ioa_socket(ss->client_socket);\n\t\t\t\t\t\tif(new_s) {\n\t\t\t\t\t\t  if(server->send_socket_to_relay(tsid, mid, tid, new_s, message_integrity, \n\t\t\t\t\t\t\t\t\t\t  RMT_MOBILE_SOCKET, in_buffer, can_resume)<0) {\n\t\t\t\t\t\t    *err_code = 400;\n\t\t\t\t\t\t    *reason = (const uint8_t *)\"Wrong mobile ticket\";\n\t\t\t\t\t\t  } else {\n\t\t\t\t\t\t    *no_response = 1;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot create new socket\";\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Server send socket procedure is not set\";\n\t\t\t\t\t}\n\n\t\t\t\t\tss->to_be_closed = 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tts_ur_super_session *orig_ss = get_session_from_mobile_map(server, mid);\n\t\t\t\t\tif(!orig_ss || orig_ss->to_be_closed || ioa_socket_tobeclosed(orig_ss->client_socket)) {\n\t\t\t\t\t\t*err_code = 404;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Allocation not found\";\n\t\t\t\t\t} else if(orig_ss == ss) {\n\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Invalid allocation\";\n\t\t\t\t\t} else if(!(orig_ss->is_mobile)) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Software error: invalid mobile allocation\";\n\t\t\t\t\t} else if(orig_ss->client_socket == ss->client_socket) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Software error: invalid mobile client socket (orig)\";\n\t\t\t\t\t} else if(!(ss->client_socket)) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Software error: invalid mobile client socket (new)\";\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tget_realm_options_by_name(orig_ss->realm_options.name, &(ss->realm_options));\n\n\t\t\t\t\t\t//Check security:\n\t\t\t\t\t\tint postpone_reply = 0;\n\n\t\t\t\t\t\tif(!(ss->hmackey_set)) {\n\t\t\t\t\t\t\tcopy_auth_parameters(orig_ss,ss);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(check_stun_auth(server, ss, tid, resp_constructed, err_code, reason, in_buffer, nbh,\n\t\t\t\t\t\t\t\tSTUN_METHOD_REFRESH, &message_integrity, &postpone_reply, can_resume)<0) {\n\t\t\t\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\t\t\t\t*err_code = 401;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(postpone_reply) {\n\n\t\t\t\t\t\t\t*no_response = 1;\n\n\t\t\t\t\t\t} else if(!(*err_code)) {\n\n\t\t\t\t\t\t\t//Session transfer:\n\n\t\t\t\t\t\t\tif (to_delete)\n\t\t\t\t\t\t\t\tlifetime = 0;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (af4c && refresh_relay_connection(server, orig_ss, lifetime, 0, 0, 0,\n\t\t\t\t\t\t\t\t\t\terr_code, AF_INET) < 0) {\n\n\t\t\t\t\t\t\t\tif (!(*err_code)) {\n\t\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot refresh relay connection (internal error)\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else if (af6c && refresh_relay_connection(server, orig_ss, lifetime, 0, 0, 0,\n\t\t\t\t\t\t\t\t\t\terr_code, AF_INET6) < 0) {\n\n\t\t\t\t\t\t\t\tif (!(*err_code)) {\n\t\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot refresh relay connection (internal error)\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t//Transfer socket:\n\n\t\t\t\t\t\t\t\tioa_socket_handle s = detach_ioa_socket(ss->client_socket);\n\n\t\t\t\t\t\t\t\tss->to_be_closed = 1;\n\n\t\t\t\t\t\t\t\tif(!s) {\n\t\t\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tif(attach_socket_to_session(server, s, orig_ss) < 0) {\n\t\t\t\t\t\t\t\t\t\tif(orig_ss->client_socket != s) {\n\t\t\t\t\t\t\t\t\t\t\tIOA_CLOSE_SOCKET(s);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tif(ss->hmackey_set) {\n\t\t\t\t\t\t\t\t\t\t\tcopy_auth_parameters(ss,orig_ss);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdelete_session_from_mobile_map(ss);\n\t\t\t\t\t\t\t\t\t\tdelete_session_from_mobile_map(orig_ss);\n\t\t\t\t\t\t\t\t\t\tput_session_into_mobile_map(orig_ss);\n\n\t\t\t\t\t\t\t\t\t\t//Use new buffer and redefine ss:\n\t\t\t\t\t\t\t\t\t\tnbh = ioa_network_buffer_allocate(server->e);\n\n\t\t\t\t\t\t\t\t\t\tdec_quota(ss);\n\t\t\t\t\t\t\t\t\t\tss = orig_ss;\n\t\t\t\t\t\t\t\t\t\tinc_quota(ss,ss->username);\n\n\t\t\t\t\t\t\t\t\t\tss->old_mobile_id = mid;\n\t\t\t\t\t\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\n\t\t\t\t\t\t\t\t\t\tturn_report_allocation_set(&(ss->alloc), lifetime, 1);\n\n\t\t\t\t\t\t\t\t\t\tstun_init_success_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, tid);\n\t\t\t\t\t\t\t\t\t\tuint32_t lt = nswap32(lifetime);\n\n\t\t\t\t\t\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_LIFETIME,\n\t\t\t\t\t\t\t\t\t\t\t\t(const uint8_t*) &lt, 4);\n\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\t\t\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\t\t\tSTUN_ATTRIBUTE_MOBILITY_TICKET,\n\t\t\t\t\t\t\t\t\t\t\t(uint8_t*)ss->s_mobile_id,strlen(ss->s_mobile_id));\n\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\t\t\t\t\t\t\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\t\t\t\t\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\t\t\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif(message_integrity) {\n\t\t\t\t\t\t\t\t\t\t\tstun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);\n\t\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ((server->fingerprint) || ss->enforce_fingerprints) {\n\t\t\t\t\t\t\t\t\t\t\tif (stun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len) < 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t\t\t\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t*no_response = 1;\n\n\t\t\t\t\t\t\t\t\t\treturn write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treport_turn_session_info(server,orig_ss,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err_code = 437;\n\t\t\t\t*reason = (const uint8_t *)\"Invalid allocation\";\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (to_delete)\n\t\t\t\tlifetime = 0;\n\t\t\telse {\n\t\t\t\tlifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);\n\t\t\t}\n\n\t\t\tif(!af4 && !af6) {\n\t\t\t\taf4 = af4c;\n\t\t\t\taf6 = af6c;\n\t\t\t}\n\n\t\t\tif (af4 && refresh_relay_connection(server, ss, lifetime, 0, 0, 0,\n\t\t\t\t\terr_code, AF_INET) < 0) {\n\n\t\t\t\tif (!(*err_code)) {\n\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t*reason = (const uint8_t *)\"Cannot refresh relay connection (internal error)\";\n\t\t\t\t}\n\n\t\t\t} else if (af6 && refresh_relay_connection(server, ss, lifetime, 0, 0, 0,\n\t\t\t\t\terr_code, AF_INET6) < 0) {\n\n\t\t\t\tif (!(*err_code)) {\n\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t*reason = (const uint8_t *)\"Cannot refresh relay connection (internal error)\";\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tturn_report_allocation_set(&(ss->alloc), lifetime, 1);\n\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_success_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, tid);\n\n\t\t\t\tif(ss->s_mobile_id[0]) {\n\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tSTUN_ATTRIBUTE_MOBILITY_TICKET,\n\t\t\t\t\t\t\t\t\t(uint8_t*)ss->s_mobile_id,strlen(ss->s_mobile_id));\n\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t}\n\n\t\t\t\tuint32_t lt = nswap32(lifetime);\n\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_LIFETIME,\n\t\t\t\t\t\t(const uint8_t*) &lt, 4);\n\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\t*resp_constructed = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!no_response) {\n\t\tif (!(*resp_constructed)) {\n\n\t\t\tif (!(*err_code)) {\n\t\t\t\t*err_code = 437;\n\t\t\t}\n\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_init_error_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t*resp_constructed = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* RFC 6062 ==>> */\n\nstatic void tcp_deliver_delayed_buffer(unsent_buffer *ub, ioa_socket_handle s, ts_ur_super_session *ss)\n{\n\tif(ub && s && ub->bufs && ub->sz && ss) {\n\t\tsize_t i = 0;\n\t\tdo {\n\t\t\tioa_network_buffer_handle nbh = top_unsent_buffer(ub);\n\t\t\tif(!nbh)\n\t\t\t\tbreak;\n\n\t\t\tuint32_t bytes = (uint32_t)ioa_network_buffer_get_size(nbh);\n\n\t\t\tint ret = send_data_from_ioa_socket_nbh(s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tset_ioa_socket_tobeclosed(s);\n\t\t\t} else {\n\t\t\t\t++(ss->sent_packets);\n\t\t\t\tss->sent_bytes += bytes;\n\t\t\t\tturn_report_session_usage(ss, 0);\n\t\t\t}\n\t\t\tpop_unsent_buffer(ub);\n\t\t} while(!ioa_socket_tobeclosed(s) && ((i++)<MAX_UNSENT_BUFFER_SIZE));\n\t}\n}\n\nstatic void tcp_peer_input_handler(ioa_socket_handle s, int event_type, ioa_net_data *in_buffer, void *arg, int can_resume)\n{\n\tif (!(event_type & IOA_EV_READ) || !arg)\n\t\treturn;\n\n\tUNUSED_ARG(s);\n\tUNUSED_ARG(can_resume);\n\n\ttcp_connection *tc = (tcp_connection*)arg;\n\tts_ur_super_session *ss=NULL;\n\tallocation *a=(allocation*)tc->owner;\n\tif(a) {\n\t\tss=(ts_ur_super_session*)a->owner;\n\t}\n\n\tif((tc->state != TC_STATE_READY) || !(tc->client_s)) {\n\t\tadd_unsent_buffer(&(tc->ub_to_client), in_buffer->nbh);\n\t\tin_buffer->nbh = NULL;\n\t\treturn;\n\t}\n\n\tioa_network_buffer_handle nbh = in_buffer->nbh;\n\tin_buffer->nbh = NULL;\n\n\tuint32_t bytes = (uint32_t)ioa_network_buffer_get_size(nbh);\n\n\tif (ss) {\n\t\t++(ss->peer_received_packets);\n\t\tss->peer_received_bytes += bytes;\n\t}\n\n\tint ret = send_data_from_ioa_socket_nbh(tc->client_s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);\n\tif (ret < 0) {\n\t\tset_ioa_socket_tobeclosed(s);\n\t} else if(ss) {\n\t\t++(ss->sent_packets);\n\t\tss->sent_bytes += bytes;\n\t}\n\n\tif (ss) {\n\t\tturn_report_session_usage(ss, 0);\n\t}\n}\n\nstatic void tcp_client_input_handler_rfc6062data(ioa_socket_handle s, int event_type, ioa_net_data *in_buffer, void *arg, int can_resume)\n{\n\tif (!(event_type & IOA_EV_READ) || !arg)\n\t\treturn;\n\n\tUNUSED_ARG(s);\n\tUNUSED_ARG(can_resume);\n\n\ttcp_connection *tc = (tcp_connection*)arg;\n\tts_ur_super_session *ss=NULL;\n\tallocation *a=(allocation*)tc->owner;\n\tif(a) {\n\t\tss=(ts_ur_super_session*)a->owner;\n\t}\n\n\tif(tc->state != TC_STATE_READY)\n\t\treturn;\n\n\tif(!(tc->peer_s))\n\t\treturn;\n\n\tioa_network_buffer_handle nbh = in_buffer->nbh;\n\tin_buffer->nbh = NULL;\n\n\tuint32_t bytes = (uint32_t)ioa_network_buffer_get_size(nbh);\n\tif(ss) {\n\t\t++(ss->received_packets);\n\t\tss->received_bytes += bytes;\n\t}\n\n\tint skip = 0;\n\tint ret = send_data_from_ioa_socket_nbh(tc->peer_s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, &skip);\n\tif (ret < 0) {\n\t\tset_ioa_socket_tobeclosed(s);\n\t}\n\n\tif (!skip && ss) {\n\t\t++(ss->peer_sent_packets);\n\t\tss->peer_sent_bytes += bytes;\n\t}\n\n\tif(ss)\n\t\tturn_report_session_usage(ss, 0);\n}\n\nstatic void tcp_conn_bind_timeout_handler(ioa_engine_handle e, void *arg)\n{\n\tUNUSED_ARG(e);\n\tif(arg) {\n\t\ttcp_connection *tc = (tcp_connection *)arg;\n\t\tdelete_tcp_connection(tc);\n\t}\n}\n\nstatic void tcp_peer_connection_completed_callback(int success, void *arg)\n{\n\tif(arg) {\n\t\ttcp_connection *tc = (tcp_connection *)arg;\n\t\tallocation *a = (allocation*)(tc->owner);\n\t\tts_ur_super_session *ss = (ts_ur_super_session*)(a->owner);\n\t\tturn_turnserver *server=(turn_turnserver*)(ss->server);\n\t\tint err_code = 0;\n\n\t\tIOA_EVENT_DEL(tc->peer_conn_timeout);\n\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\n\t\tif(success) {\n\t\t\tif(register_callback_on_ioa_socket(server->e, tc->peer_s, IOA_EV_READ, tcp_peer_input_handler, tc, 1)<0) {\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot set TCP peer data input callback\\n\", __FUNCTION__);\n\t\t\t\tsuccess=0;\n\t\t\t\terr_code = 500;\n\t\t\t}\n\t\t}\n\n\t\tif(success) {\n\t\t\ttc->state = TC_STATE_PEER_CONNECTED;\n\t\t\tstun_init_success_response_str(STUN_METHOD_CONNECT, ioa_network_buffer_data(nbh), &len, &(tc->tid));\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_CONNECTION_ID,\n\t\t\t\t\t\t\t\t\t(const uint8_t*)&(tc->id), 4);\n\n\t\t\tIOA_EVENT_DEL(tc->conn_bind_timeout);\n\t\t\ttc->conn_bind_timeout = set_ioa_timer(server->e, TCP_CONN_BIND_TIMEOUT, 0,\n\t\t\t\t\t\t\t\t\ttcp_conn_bind_timeout_handler, tc, 0,\n\t\t\t\t\t\t\t\t\t\"tcp_conn_bind_timeout_handler\");\n\n\t\t} else {\n\t\t\ttc->state = TC_STATE_FAILED;\n\t\t\tif(!err_code) {\n\t\t\t\terr_code = 447;\n\t\t\t}\n\t\t\t{\n\t\t\t\tchar ls[257]=\"\\0\";\n\t\t\t\tchar rs[257]=\"\\0\";\n\t\t\t\tioa_addr *laddr = get_local_addr_from_ioa_socket(ss->client_socket);\n\t\t\t\tif(laddr)\n\t\t\t\t\taddr_to_string(laddr,(uint8_t*)ls);\n\t\t\t\taddr_to_string(&(tc->peer_addr),(uint8_t*)rs);\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: failure to connect from %s to %s\\n\", __FUNCTION__, ls,rs);\n\t\t\t}\n\t\t\tstun_init_error_response_str(STUN_METHOD_CONNECT, ioa_network_buffer_data(nbh), &len, err_code, NULL, &(tc->tid));\n\t\t}\n\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\tif(need_stun_authentication(server, ss)) {\n\t\t\tstun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\n\t\twrite_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\n\t\tif(!success) {\n\t\t\tdelete_tcp_connection(tc);\n\t\t}\n\t\t/* test */\n\t\telse if(0)\n\t\t{\n\t\t\tint i = 0;\n\t\t\tfor(i=0;i<22;i++) {\n\t\t\t\tioa_network_buffer_handle nbh_test = ioa_network_buffer_allocate(server->e);\n\t\t\t\tsize_t len_test = ioa_network_buffer_get_size(nbh_test);\n\t\t\t\tuint8_t *data = ioa_network_buffer_data(nbh_test);\n\t\t\t\tconst char* data_test=\"111.111.111.111.111\";\n\t\t\t\tlen_test = strlen(data_test);\n\t\t\t\tbcopy(data_test,data,len_test);\n\t\t\t\tioa_network_buffer_set_size(nbh_test,len_test);\n\t\t\t\tsend_data_from_ioa_socket_nbh(tc->peer_s, NULL, nbh_test, TTL_IGNORE, TOS_IGNORE, NULL);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void tcp_peer_conn_timeout_handler(ioa_engine_handle e, void *arg)\n{\n\tUNUSED_ARG(e);\n\n\ttcp_peer_connection_completed_callback(0,arg);\n}\n\nstatic int tcp_start_connection_to_peer(turn_turnserver *server, ts_ur_super_session *ss, stun_tid *tid,\n\t\t\t\tallocation *a, ioa_addr *peer_addr,\n\t\t\t\tint *err_code, const uint8_t **reason)\n{\n\tFUNCSTART;\n\n\tif(!ss) {\n\t\t*err_code = 500;\n\t\t*reason = (const uint8_t *)\"Server error: empty session\";\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tif(!peer_addr) {\n\t\t*err_code = 500;\n\t\t*reason = (const uint8_t *)\"Server error: empty peer addr\";\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tif(!get_relay_socket(a,peer_addr->ss.sa_family)) {\n\t\t*err_code = 500;\n\t\t*reason = (const uint8_t *)\"Server error: no relay connection created\";\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\ttcp_connection *tc = get_tcp_connection_by_peer(a, peer_addr);\n\tif(tc) {\n\t\t*err_code = 446;\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\ttc = create_tcp_connection(server->id, a, tid, peer_addr, err_code);\n\tif(!tc) {\n\t\tif(!(*err_code)) {\n\t\t\t*err_code = 500;\n\t\t\t*reason = (const uint8_t *)\"Server error: TCP connection object creation failed\";\n\t\t}\n\t\tFUNCEND;\n\t\treturn -1;\n\t} else if(*err_code) {\n\t\tdelete_tcp_connection(tc);\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tIOA_EVENT_DEL(tc->peer_conn_timeout);\n\ttc->peer_conn_timeout = set_ioa_timer(server->e, TCP_PEER_CONN_TIMEOUT, 0,\n\t\t\t\t\t\ttcp_peer_conn_timeout_handler, tc, 0,\n\t\t\t\t\t\t\"tcp_peer_conn_timeout_handler\");\n\n\tioa_socket_handle tcs = ioa_create_connecting_tcp_relay_socket(get_relay_socket(a,peer_addr->ss.sa_family),\n\t\t\tpeer_addr, tcp_peer_connection_completed_callback, tc);\n\tif(!tcs) {\n\t\tdelete_tcp_connection(tc);\n\t\t*err_code = 500;\n\t\t*reason = (const uint8_t *)\"Server error: TCP relay socket for connection cannot be created\";\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\ttc->state = TC_STATE_CLIENT_TO_PEER_CONNECTING;\n\tif(tc->peer_s != tcs) {\n\t\tIOA_CLOSE_SOCKET(tc->peer_s);\n\t\ttc->peer_s = tcs;\n\t}\n\tset_ioa_socket_sub_session(tc->peer_s,tc);\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic void tcp_peer_accept_connection(ioa_socket_handle s, void *arg)\n{\n\tif(s) {\n\n\t\tif(!arg) {\n\t\t\tclose_ioa_socket(s);\n\t\t\treturn;\n\t\t}\n\n\t\tts_ur_super_session *ss = (ts_ur_super_session*)arg;\n\t\tturn_turnserver *server=(turn_turnserver*)(ss->server);\n\n\t\tFUNCSTART;\n\n\t\tallocation *a = &(ss->alloc);\n\t\tioa_addr *peer_addr = get_remote_addr_from_ioa_socket(s);\n\t\tif(!peer_addr) {\n\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\ttcp_connection *tc = get_tcp_connection_by_peer(a, peer_addr);\n\t\tif(tc) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: peer data socket with this address already exist\\n\", __FUNCTION__);\n\t\t\tif(tc->peer_s != s)\n\t\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\tif(!good_peer_addr(server, ss->realm_options.name, peer_addr)) {\n\t\t\tuint8_t saddr[256];\n\t\t\taddr_to_string(peer_addr, saddr);\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: an attempt to connect from a peer with forbidden address: %s\\n\", __FUNCTION__,saddr);\n\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\tif(!can_accept_tcp_connection_from_peer(a,peer_addr,server->server_relay)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: peer has no permission to connect\\n\", __FUNCTION__);\n\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\tstun_tid tid;\n\t\tbzero(&tid,sizeof(stun_tid));\n\t\tint err_code=0;\n\t\ttc = create_tcp_connection(server->id, a, &tid, peer_addr, &err_code);\n\t\tif(!tc) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot create TCP connection\\n\", __FUNCTION__);\n\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\ttc->state = TC_STATE_PEER_CONNECTED;\n\t\ttc->peer_s = s;\n\n\t\tset_ioa_socket_session(s,ss);\n\t\tset_ioa_socket_sub_session(s,tc);\n\n\t\tif(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, tcp_peer_input_handler, tc, 1)<0) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot set TCP peer data input callback\\n\", __FUNCTION__);\n\t\t\tIOA_CLOSE_SOCKET(tc->peer_s);\n\t\t\ttc->state = TC_STATE_UNKNOWN;\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\tIOA_EVENT_DEL(tc->conn_bind_timeout);\n\t\ttc->conn_bind_timeout = set_ioa_timer(server->e, TCP_CONN_BIND_TIMEOUT, 0,\n\t\t\t\t\t\t\ttcp_conn_bind_timeout_handler, tc, 0,\n\t\t\t\t\t\t\t\"tcp_conn_bind_timeout_handler\");\n\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\n\t\tstun_init_indication_str(STUN_METHOD_CONNECTION_ATTEMPT, ioa_network_buffer_data(nbh), &len);\n\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_CONNECTION_ID,\n\t\t\t\t\t(const uint8_t*)&(tc->id), 4);\n\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_XOR_PEER_ADDRESS, peer_addr);\n\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t{\n\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif ((server->fingerprint) || ss->enforce_fingerprints) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\twrite_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\n\t\tFUNCEND;\n\t}\n}\n\nstatic int handle_turn_connect(turn_turnserver *server,\n\t\t\t\t    ts_ur_super_session *ss, stun_tid *tid,\n\t\t\t\t    int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\t    ioa_net_data *in_buffer) {\n\n\tFUNCSTART;\n\tioa_addr peer_addr;\n\tint peer_found = 0;\n\taddr_set_any(&peer_addr);\n\tallocation* a = get_allocation_ss(ss);\n\n\tif(!(ss->is_tcp_relay)) {\n\t\t*err_code = 403;\n\t\t*reason = (const uint8_t *)\"Connect cannot be used with UDP relay\";\n\t} else if (!is_allocation_valid(a)) {\n\t\t*err_code = 437;\n\t} else {\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS:\n\t\t\t  {\n\t\t\t\tif(stun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t       NULL) == -1) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Bad Peer Address\";\n\t\t\t\t} else {\n\t\t\t\t\tif(!get_relay_socket(a,peer_addr.ss.sa_family)) {\n\t\t\t\t\t\t*err_code = 443;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Peer Address Family Mismatch (2)\";\n\t\t\t\t\t}\n\n\t\t\t\t\tpeer_found = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t     sar);\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if (!peer_found) {\n\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"Where is Peer Address ?\";\n\n\t\t} else {\n\t\t\tif(!good_peer_addr(server,ss->realm_options.name,&peer_addr)) {\n\t\t\t\t*err_code = 403;\n\t\t\t\t*reason = (const uint8_t *) \"Forbidden IP\";\n\t\t\t} else {\n\t\t\t\ttcp_start_connection_to_peer(server, ss, tid, a, &peer_addr, err_code, reason);\n\t\t\t}\n\t\t}\n\t}\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic int handle_turn_connection_bind(turn_turnserver *server,\n\t\t\t       ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t       int *err_code, \tconst uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t       ioa_net_data *in_buffer, ioa_network_buffer_handle nbh, int message_integrity,\n\t\t\t       int can_resume) {\n\n\tallocation* a = get_allocation_ss(ss);\n\n\tuint16_t method = STUN_METHOD_CONNECTION_BIND;\n\n\tif(ss->to_be_closed) {\n\n\t\t*err_code = 400;\n\n\t} else if (is_allocation_valid(a)) {\n\n\t\t*err_code = 400;\n\t\t*reason = (const uint8_t *)\"Bad request: CONNECTION_BIND cannot be issued after allocation\";\n\n\t} else if(!is_stream_socket(get_ioa_socket_type(ss->client_socket))) {\n\n\t\t*err_code = 400;\n\t\t*reason = (const uint8_t *)\"Bad request: CONNECTION_BIND only possible with TCP/TLS\";\n\n\t} else {\n\t\ttcp_connection_id id = 0;\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_CONNECTION_ID: {\n\t\t\t\tif (stun_attr_get_len(sar) != 4) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Connection ID field format\";\n\t\t\t\t} else {\n\t\t\t\t\tconst uint8_t* value = stun_attr_get_value(sar);\n\t\t\t\t\tif (!value) {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Connection ID field data\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tid = *((const uint32_t*)value); //AS-IS encoding, no conversion to/from network byte order\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), sar);\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else {\n\t\t\tif(server->send_socket_to_relay) {\n\t\t\t\tturnserver_id sid = (id & 0xFF000000)>>24;\n\t\t\t\tioa_socket_handle s = ss->client_socket;\n\t\t\t\tif(s && !ioa_socket_tobeclosed(s)) {\n\t\t\t\t\tioa_socket_handle new_s = detach_ioa_socket(s);\n\t\t\t\t\tif(new_s) {\n\t\t\t\t\t  if(server->send_socket_to_relay(sid, id, tid, new_s, message_integrity, RMT_CB_SOCKET, in_buffer, can_resume)<0) {\n\t\t\t\t\t    *err_code = 400;\n\t\t\t\t\t    *reason = (const uint8_t *)\"Wrong connection id\";\n\t\t\t\t\t  }\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t*err_code = 500;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err_code = 500;\n\t\t\t}\n\t\t\tss->to_be_closed = 1;\n\t\t}\n\t}\n\n\tif (!(*resp_constructed) && ss->client_socket && !ioa_socket_tobeclosed(ss->client_socket)) {\n\n\t\tif (!(*err_code)) {\n\t\t\t*err_code = 437;\n\t\t}\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t*resp_constructed = 1;\n\t}\n\n\treturn 0;\n}\n\nint turnserver_accept_tcp_client_data_connection(turn_turnserver *server, tcp_connection_id tcid, stun_tid *tid, ioa_socket_handle s, int message_integrity, ioa_net_data *in_buffer, int can_resume)\n{\n\tif(!server)\n\t\treturn -1;\n\n\tFUNCSTART;\n\n\ttcp_connection *tc = NULL;\n\tts_ur_super_session *ss = NULL;\n\n\tint err_code = 0;\n\tconst uint8_t *reason = NULL;\n\n\tioa_socket_handle s_to_delete = s;\n\n\tif(tcid && tid && s) {\n\n\t\ttc = get_tcp_connection_by_id(server->tcp_relay_connections, tcid);\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tint resp_constructed = 0;\n\t\tif(!tc || (tc->state == TC_STATE_READY) || (tc->client_s)) {\n\t\t\terr_code = 400;\n\t\t} else {\n\t\t\tallocation *a = (allocation*)(tc->owner);\n\t\t\tif(!a || !(a->owner)) {\n\t\t\t\terr_code = 500;\n\t\t\t} else {\n\t\t\t\tss = (ts_ur_super_session*)(a->owner);\n\n\t\t\t\tif(ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {\n\t\t\t\t\terr_code = 404;\n\t\t\t\t} else {\n\t\t\t\t\t//Check security:\n\t\t\t\t\tint postpone_reply = 0;\n\t\t\t\t\tcheck_stun_auth(server, ss, tid, &resp_constructed, &err_code, &reason, in_buffer, nbh,\n\t\t\t\t\t\tSTUN_METHOD_CONNECTION_BIND, &message_integrity, &postpone_reply, can_resume);\n\n\t\t\t\t\tif(postpone_reply) {\n\n\t\t\t\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t} else if(!err_code) {\n\t\t\t\t\t\ttc->state = TC_STATE_READY;\n\t\t\t\t\t\ttc->client_s = s;\n\t\t\t\t\t\ts_to_delete = NULL;\n\t\t\t\t\t\tset_ioa_socket_session(s,ss);\n\t\t\t\t\t\tset_ioa_socket_sub_session(s,tc);\n\t\t\t\t\t\tset_ioa_socket_app_type(s,TCP_CLIENT_DATA_SOCKET);\n\t\t\t\t\t\tif(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, tcp_client_input_handler_rfc6062data, tc, 1)<0) {\n\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot set TCP client data input callback\\n\", __FUNCTION__);\n\t\t\t\t\t\t\terr_code = 500;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tIOA_EVENT_DEL(tc->conn_bind_timeout);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tc)\n\t\t\tget_and_clean_tcp_connection_by_id(server->tcp_relay_connections, tcid);\n\n\t\tif(!resp_constructed) {\n\t\t\tif(!err_code) {\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_success_response_str(STUN_METHOD_CONNECTION_BIND, ioa_network_buffer_data(nbh), &len, tid);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t} else {\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_error_response_str(STUN_METHOD_CONNECTION_BIND, ioa_network_buffer_data(nbh), &len, err_code, NULL, tid);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif(message_integrity && ss) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\n\t\tif ((server->fingerprint) || (ss &&(ss->enforce_fingerprints))) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif(server->verbose) {\n\t\t\tlog_method(ss, \"CONNECTION_BIND\", err_code, reason);\n\t\t}\n\n\t\tif(ss && !err_code) {\n\t\t\tsend_data_from_ioa_socket_nbh(s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);\n\t\t\ttcp_deliver_delayed_buffer(&(tc->ub_to_client),s,ss);\n\t\t\tIOA_CLOSE_SOCKET(s_to_delete);\n\t\t\tFUNCEND;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* Just to set the necessary structures for the packet sending: */\n\t\t\tif(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, NULL, NULL, 1)<0) {\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot set TCP tmp client data input callback\\n\", __FUNCTION__);\n\t\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\t} else {\n\t\t\t\tsend_data_from_ioa_socket_nbh(s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tIOA_CLOSE_SOCKET(s_to_delete);\n\n\tFUNCEND;\n\treturn -1;\n}\n\n/* <<== RFC 6062 */\n\nstatic int handle_turn_channel_bind(turn_turnserver *server,\n\t\t\t\t    ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\t    int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\t    ioa_net_data *in_buffer, ioa_network_buffer_handle nbh) {\n\n\tFUNCSTART;\n\tuint16_t chnum = 0;\n\tioa_addr peer_addr;\n\taddr_set_any(&peer_addr);\n\tallocation* a = get_allocation_ss(ss);\n\tint addr_found = 0;\n\n\tif(ss->is_tcp_relay) {\n\t\t*err_code = 403;\n\t\t*reason = (const uint8_t *)\"Channel bind cannot be used with TCP relay\";\n\t} else if (is_allocation_valid(a)) {\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_CHANNEL_NUMBER: {\n\t\t\t\tif (chnum) {\n\t\t\t\t\tchnum = 0;\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Channel number cannot be duplicated in this request\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchnum = stun_attr_get_channel_number(sar);\n\t\t\t\tif (!chnum) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Channel number cannot be zero in this request\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS:\n\t\t\t  {\n\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t       NULL);\n\n\t\t\t\tif(!get_relay_socket(a,peer_addr.ss.sa_family)) {\n\t\t\t\t\t*err_code = 443;\n\t\t\t\t\t*reason = (const uint8_t *)\"Peer Address Family Mismatch (3)\";\n\t\t\t\t}\n\n\t\t\t\tif(addr_get_port(&peer_addr) < 1) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Empty port number in channel bind request\";\n\t\t\t\t} else {\n\t\t\t\t\taddr_found = 1;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t     sar);\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if (!chnum || addr_any(&peer_addr) || !addr_found) {\n\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"Bad channel bind request\";\n\n\t\t} else if(!STUN_VALID_CHANNEL(chnum)) {\n\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"Bad channel number\";\n\n\t\t} else {\n\n\t\t\tch_info* chn = allocation_get_ch_info(a, chnum);\n\t\t\tturn_permission_info* tinfo = NULL;\n\n\t\t\tif (chn) {\n\t\t\t\tif (!addr_eq(&peer_addr, &(chn->peer_addr))) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"You cannot use the same channel number with different peer\";\n\t\t\t\t} else {\n\t\t\t\t\ttinfo = (turn_permission_info*) (chn->owner);\n\t\t\t\t\tif (!tinfo) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong permission info\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!addr_eq_no_port(&peer_addr, &(tinfo->addr))) {\n\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong permission info and peer addr combination\";\n\t\t\t\t\t\t} else if (chn->port != addr_get_port(&peer_addr)) {\n\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong port number\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tchn = allocation_get_ch_info_by_peer_addr(a, &peer_addr);\n\t\t\t\tif(chn) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"You cannot use the same peer with different channel number\";\n\t\t\t\t} else {\n\t\t\t\t\tif(!good_peer_addr(server,ss->realm_options.name,&peer_addr)) {\n\t\t\t\t\t\t*err_code = 403;\n\t\t\t\t\t\t*reason = (const uint8_t *) \"Forbidden IP\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchn = allocation_get_new_ch_info(a, chnum, &peer_addr);\n\t\t\t\t\t\tif (!chn) {\n\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t*reason = (const uint8_t *) \"Cannot find channel data\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttinfo = (turn_permission_info*) (chn->owner);\n\t\t\t\t\t\t\tif (!tinfo) {\n\t\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t\t*reason\n\t\t\t\t\t\t\t\t\t= (const uint8_t *) \"Wrong turn permission info\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(*err_code) && chn && tinfo) {\n\n\t\t\t  if (update_channel_lifetime(ss,chn) < 0) {\n\t\t\t    *err_code = 500;\n\t\t\t    *reason = (const uint8_t *)\"Cannot update channel lifetime (internal error)\";\n\t\t\t  } else {\n\t\t\t\t  size_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t  stun_set_channel_bind_response_str(ioa_network_buffer_data(nbh), &len, tid, 0, NULL);\n\t\t\t\t  ioa_network_buffer_set_size(nbh,len);\n\t\t\t\t  *resp_constructed = 1;\n\n\t\t\t\t  if(!(ss->is_mobile)) {\n\t\t\t\t\t  if(get_ioa_socket_type(ss->client_socket) == UDP_SOCKET ||\n\t\t\t\t\t\t\t  get_ioa_socket_type(ss->client_socket) == TCP_SOCKET ||\n\t\t\t\t\t\t\t  get_ioa_socket_type(ss->client_socket) == SCTP_SOCKET) {\n\t\t\t\t\t\t  if(get_ioa_socket_type(get_relay_socket(&(ss->alloc),peer_addr.ss.sa_family)) == UDP_SOCKET) {\n\t\t\t\t\t\t\t  chn->kernel_channel = CREATE_TURN_CHANNEL_KERNEL(chn->chnum,\n\t\t\t\t\t\t\t\t  get_ioa_socket_address_family(ss->client_socket),\n\t\t\t\t\t\t\t\t  peer_addr.ss.sa_family,\n\t\t\t\t\t\t\t\t  (get_ioa_socket_type(ss->client_socket)==UDP_SOCKET ? IPPROTO_UDP : IPPROTO_TCP),\n\t\t\t\t\t\t\t\t  &(get_remote_addr_from_ioa_socket(ss->client_socket)->ss),\n\t\t\t\t\t\t\t\t  &(get_local_addr_from_ioa_socket(ss->client_socket)->ss),\n\t\t\t\t\t\t\t\t  &(get_local_addr_from_ioa_socket(get_relay_socket(&(ss->alloc),peer_addr.ss.sa_family))),\n\t\t\t\t\t\t\t\t  &(get_remote_addr_from_ioa_socket(get_relay_socket(&(ss->alloc),peer_addr.ss.sa_family)))\n\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t}\n\t\t}\n\t}\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic int handle_turn_binding(turn_turnserver *server,\n\t\t\t\t    ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\t    int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\t    ioa_net_data *in_buffer, ioa_network_buffer_handle nbh,\n\t\t\t\t    int *origin_changed, ioa_addr *response_origin,\n\t\t\t\t    int *dest_changed, ioa_addr *response_destination,\n\t\t\t\t    uint32_t cookie, int old_stun) {\n\n\tFUNCSTART;\n\tint change_ip = 0;\n\tint change_port = 0;\n\tint padding = 0;\n\tint response_port_present = 0;\n\tuint16_t response_port = 0;\n\tSOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);\n\tint use_reflected_from = 0;\n\n\tif(!(ss->client_socket))\n\t\treturn -1;\n\n\t*origin_changed = 0;\n\t*dest_changed = 0;\n\n\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\tint attr_type = stun_attr_get_type(sar);\n\t\tswitch (attr_type) {\n\t\tcase OLD_STUN_ATTRIBUTE_PASSWORD:\n\t\tSKIP_ATTRIBUTES;\n\t\tcase STUN_ATTRIBUTE_CHANGE_REQUEST:\n/*\n * This fix allows the client program from the Stuntman source to make STUN binding requests\n * to this server.\n *\n * It was provided by  John Selbie, from STUNTMAN project:\n *\n * \"Here's the gist of the change. Stuntman comes with a STUN client library\n * and client program. The client program displays the mapped IP address and\n * port if it gets back a successful binding response.\n * It also interops with JSTUN, a Java implementation of STUN.\n * However, the JSTUN server refuses to respond to any binding request that\n * doesn't have a CHANGE-REQUEST attribute in it.\n * ... workaround is for the client to make a request with an empty CHANGE-REQUEST\n * attribute (neither the ip or port bit are set).\"\n *\n */\n\t\t\tstun_attr_get_change_request_str(sar, &change_ip, &change_port);\n\t\t\tif( (!is_rfc5780(server)) && (change_ip || change_port)) {\n\t\t\t\t*err_code = 420;\n\t\t\t\t*reason = (const uint8_t *)\"Unknown attribute: TURN server was configured without RFC 5780 support\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(change_ip || change_port) {\n\t\t\t\tif(st != UDP_SOCKET) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong request: applicable only to UDP protocol\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STUN_ATTRIBUTE_PADDING:\n\t\t\tif(response_port_present) {\n\t\t\t\t*err_code = 400;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong request format: you cannot use PADDING and RESPONSE_PORT together\";\n\t\t\t} else if((st != UDP_SOCKET) && (st != DTLS_SOCKET)) {\n\t\t\t\t*err_code = 400;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong request: padding applicable only to UDP and DTLS protocols\";\n\t\t\t} else {\n\t\t\t\tpadding = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STUN_ATTRIBUTE_RESPONSE_PORT:\n\t\t\tif(padding) {\n\t\t\t\t*err_code = 400;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong request format: you cannot use PADDING and RESPONSE_PORT together\";\n\t\t\t} else if(st != UDP_SOCKET) {\n\t\t\t\t*err_code = 400;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong request: applicable only to UDP protocol\";\n\t\t\t} else {\n\t\t\t\tint rp = stun_attr_get_response_port_str(sar);\n\t\t\t\tif(rp>=0) {\n\t\t\t\t\tresponse_port_present = 1;\n\t\t\t\t\tresponse_port = (uint16_t)rp;\n\t\t\t\t} else {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong response port format\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OLD_STUN_ATTRIBUTE_RESPONSE_ADDRESS:\n\t\t\tif(old_stun) {\n\t\t\t\tuse_reflected_from = 1;\n\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\tsar, response_destination, response_destination);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t};\n\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t     sar);\n\t}\n\n\tif (*ua_num > 0) {\n\n\t\t*err_code = 420;\n\n\t} else if (*err_code) {\n\n\t\t;\n\n\t} else if(ss->client_socket && get_remote_addr_from_ioa_socket(ss->client_socket)) {\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\tif (stun_set_binding_response_str(ioa_network_buffer_data(nbh), &len, tid,\n\t\t\t\t\tget_remote_addr_from_ioa_socket(ss->client_socket), 0, NULL, cookie, old_stun) >= 0) {\n\n\t\t\taddr_cpy(response_origin, get_local_addr_from_ioa_socket(ss->client_socket));\n\n\t\t\t*resp_constructed = 1;\n\n\t\t\tif(old_stun && use_reflected_from) {\n\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_REFLECTED_FROM,\n\t\t\t\t\t\tget_remote_addr_from_ioa_socket(ss->client_socket));\n\t\t\t}\n\n\t\t\tif(!is_rfc5780(server)) {\n\n\t\t\t\tif(old_stun) {\n\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_SOURCE_ADDRESS, response_origin);\n\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_CHANGED_ADDRESS, response_origin);\n\t\t\t\t} else {\n\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\tSTUN_ATTRIBUTE_RESPONSE_ORIGIN, response_origin);\n\t\t\t\t}\n\n\t\t\t} else if(ss->client_socket) {\n\n\t\t\t\tioa_addr other_address;\n\n\t\t\t\tif(get_other_address(server,ss,&other_address) == 0) {\n\n\t\t\t\t\taddr_cpy(response_destination, get_remote_addr_from_ioa_socket(ss->client_socket));\n\n\t\t\t\t\tif(change_ip) {\n\t\t\t\t\t\t*origin_changed = 1;\n\t\t\t\t\t\tif(change_port) {\n\t\t\t\t\t\t\taddr_cpy(response_origin,&other_address);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint old_port = addr_get_port(response_origin);\n\t\t\t\t\t\t\taddr_cpy(response_origin,&other_address);\n\t\t\t\t\t\t\taddr_set_port(response_origin,old_port);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(change_port) {\n\t\t\t\t\t\t*origin_changed = 1;\n\t\t\t\t\t\taddr_set_port(response_origin,addr_get_port(&other_address));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(old_stun) {\n\t\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_SOURCE_ADDRESS, response_origin);\n\t\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_CHANGED_ADDRESS, &other_address);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tSTUN_ATTRIBUTE_RESPONSE_ORIGIN, response_origin);\n\t\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tSTUN_ATTRIBUTE_OTHER_ADDRESS, &other_address);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(response_port_present) {\n\t\t\t\t\t\t*dest_changed = 1;\n\t\t\t\t\t\taddr_set_port(response_destination, (int)response_port);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(padding) {\n\t\t\t\t\t\tint mtu = get_local_mtu_ioa_socket(ss->client_socket);\n\t\t\t\t\t\tif(mtu<68)\n\t\t\t\t\t\t\tmtu=1500;\n\n\t\t\t\t\t\tmtu = (mtu >> 2) << 2;\n\t\t\t\t\t\tstun_attr_add_padding_str(ioa_network_buffer_data(nbh), &len, (uint16_t)mtu);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tioa_network_buffer_set_size(nbh, len);\n\t}\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic int handle_turn_send(turn_turnserver *server, ts_ur_super_session *ss,\n\t\t\t    int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t    ioa_net_data *in_buffer) {\n\n\tFUNCSTART;\n\n\tioa_addr peer_addr;\n\tconst uint8_t* value = NULL;\n\tint len = -1;\n\tint addr_found = 0;\n\tint set_df = 0;\n\n\taddr_set_any(&peer_addr);\n\tallocation* a = get_allocation_ss(ss);\n\n\tif(ss->is_tcp_relay) {\n\t\t*err_code = 403;\n\t\t*reason = (const uint8_t *)\"Send cannot be used with TCP relay\";\n\t} else if (is_allocation_valid(a) && (in_buffer->recv_ttl != 0)) {\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_DONT_FRAGMENT:\n\t\t\t\tif(!(server->dont_fragment))\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t\telse\n\t\t\t\t\tset_df = 1;\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS: {\n\t\t\t\tif (addr_found) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Address duplication\";\n\t\t\t\t} else {\n\t\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t\t       NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_DATA: {\n\t\t\t\tif (len >= 0) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Data duplication\";\n\t\t\t\t} else {\n\t\t\t\t\tlen = stun_attr_get_len(sar);\n\t\t\t\t\tvalue = stun_attr_get_value(sar);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t     sar);\n\t\t}\n\n\t\tif (*err_code) {\n\t\t\t;\n\t\t} else if (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (!addr_any(&peer_addr) && len >= 0) {\n\n\t\t\tturn_permission_info* tinfo = NULL;\n\n\t\t\tif(!(server->server_relay))\n\t\t\t\ttinfo = allocation_get_permission(a, &peer_addr);\n\n\t\t\tif (tinfo || (server->server_relay)) {\n\n\t\t\t\tset_df_on_ioa_socket(get_relay_socket_ss(ss,peer_addr.ss.sa_family), set_df);\n\n\t\t\t\tioa_network_buffer_handle nbh = in_buffer->nbh;\n\t\t\t\tif(value && len>0) {\n\t\t\t\t\tuint16_t offset = (uint16_t)(value - ioa_network_buffer_data(nbh));\n\t\t\t\t\tioa_network_buffer_add_offset_size(nbh,offset,0,len);\n\t\t\t\t} else {\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t}\n\t\t\t\tioa_network_buffer_header_init(nbh);\n\t\t\t\tint skip = 0;\n\t\t\t\tsend_data_from_ioa_socket_nbh(get_relay_socket_ss(ss,peer_addr.ss.sa_family), &peer_addr, nbh, in_buffer->recv_ttl-1, in_buffer->recv_tos, &skip);\n\t\t\t\tif (!skip) {\n\t\t\t\t\t++(ss->peer_sent_packets);\n\t\t\t\t\tss->peer_sent_bytes += len;\n\t\t\t\t\tturn_report_session_usage(ss, 0);\n\t\t\t\t}\n\t\t\t\tin_buffer->nbh = NULL;\n\t\t\t}\n\n\t\t} else {\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"No address found\";\n\t\t}\n\t}\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic int update_permission(ts_ur_super_session *ss, ioa_addr *peer_addr) {\n\n\tif (!ss || !peer_addr)\n\t\treturn -1;\n\n\tallocation* a = get_allocation_ss(ss);\n\n\tturn_permission_info* tinfo = allocation_get_permission(a, peer_addr);\n\n\tif (!tinfo) {\n\t\ttinfo = allocation_add_permission(a, peer_addr);\n\t}\n\n\tif (!tinfo)\n\t\treturn -1;\n\n\tif (update_turn_permission_lifetime(ss, tinfo, 0) < 0)\n\t\treturn -1;\n\n\tch_info *chn = get_turn_channel(tinfo, peer_addr);\n\tif(chn) {\n\t\tif (update_channel_lifetime(ss, chn) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_turn_create_permission(turn_turnserver *server,\n\t\t\t\t\t ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\t\t int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\t\t ioa_net_data *in_buffer, ioa_network_buffer_handle nbh) {\n\n\tint ret = -1;\n\n\tint addr_found = 0;\n\n\tUNUSED_ARG(server);\n\n\tallocation* a = get_allocation_ss(ss);\n\n\tif (is_allocation_valid(a)) {\n\n\t\t{\n\t\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\n\t\t\t\tint attr_type = stun_attr_get_type(sar);\n\n\t\t\t\tswitch (attr_type) {\n\n\t\t\t\tSKIP_ATTRIBUTES;\n\n\t\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS: {\n\n\t\t\t\t\tioa_addr peer_addr;\n\t\t\t\t\taddr_set_any(&peer_addr);\n\n\t\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t       NULL);\n\n\t\t\t\t\tif(!get_relay_socket(a,peer_addr.ss.sa_family)) {\n\t\t\t\t\t\t*err_code = 443;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Peer Address Family Mismatch (4)\";\n\t\t\t\t\t} else if(!good_peer_addr(server, ss->realm_options.name, &peer_addr)) {\n\t\t\t\t\t\t*err_code = 403;\n\t\t\t\t\t\t*reason = (const uint8_t *) \"Forbidden IP\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddr_found++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t\t};\n\t\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t     sar);\n\t\t\t}\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if (!addr_found) {\n\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"No address found\";\n\n\t\t} else {\n\n\t\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\t\twhile (sar) {\n\n\t\t\t\tint attr_type = stun_attr_get_type(sar);\n\n\t\t\t\tswitch (attr_type) {\n\n\t\t\t\tSKIP_ATTRIBUTES;\n\n\t\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS: {\n\n\t\t\t\t\tioa_addr peer_addr;\n\t\t\t\t\taddr_set_any(&peer_addr);\n\n\t\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t\t\t\t       NULL);\n\n\t\t\t\t\taddr_set_port(&peer_addr, 0);\n\t\t\t\t\tif (update_permission(ss, &peer_addr) < 0) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot update some permissions (critical server software error)\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t;\n\t\t\t\t}\n\n\t\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t     sar);\n\t\t\t}\n\n\t\t\tif(*err_code == 0) {\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_success_response_str(STUN_METHOD_CREATE_PERMISSION,\n\t\t\t\t\t\t\tioa_network_buffer_data(nbh), &len, tid);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\tret = 0;\n\t\t\t\t*resp_constructed = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// AUTH ==>>\n\nstatic int need_stun_authentication(turn_turnserver *server, ts_ur_super_session *ss)\n{\n\tUNUSED_ARG(ss);\n\n\tif(server) {\n\t\tswitch(server->ct) {\n\t\tcase TURN_CREDENTIALS_LONG_TERM:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\t;\n\t\t};\n\t}\n\n\treturn 0;\n}\n\nstatic int create_challenge_response(ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\tint *err_code, \tconst uint8_t **reason,\n\t\t\t\tioa_network_buffer_handle nbh,\n\t\t\t\tuint16_t method)\n{\n\tsize_t len = ioa_network_buffer_get_size(nbh);\n\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);\n\t*resp_constructed = 1;\n\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_NONCE,\n\t\t\t\t\tss->nonce, (int)(NONCE_MAX_SIZE-1));\n\tchar *realm = ss->realm_options.name;\n\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_REALM,\n\t\t\t\t\t(uint8_t*)realm, (int)(strlen((char*)(realm))));\n\n\tif(ss->server) {\n\t\tturn_turnserver* server = (turn_turnserver*)ss->server;\n\t\tif(server->oauth) {\n\t\t\tconst char *server_name = server->oauth_server_name;\n\t\t\tif(!(server_name && server_name[0])) {\n\t\t\t\tserver_name = realm;\n\t\t\t}\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len,\n    \t\t\tSTUN_ATTRIBUTE_THIRD_PARTY_AUTHORIZATION,\n    \t\t\t(const uint8_t*)(server_name),\n    \t\t\tstrlen(server_name));\n\t\t}\n    }\n\n\tioa_network_buffer_set_size(nbh,len);\n\treturn 0;\n}\n\n#if !defined(min)\n#define min(a,b) ((a)<=(b) ? (a) : (b))\n#endif\n\nstatic void resume_processing_after_username_check(int success,  int oauth, int max_session_time, hmackey_t hmackey, password_t pwd, turn_turnserver *server, uint64_t ctxkey, ioa_net_data *in_buffer, uint8_t *realm)\n{\n\n\tif(server && in_buffer && in_buffer->nbh) {\n\n\t\tts_ur_super_session *ss = get_session_from_map(server,(turnsession_id)ctxkey);\n\t\tif(ss && ss->client_socket) {\n\t\t\tturn_turnserver *server = (turn_turnserver *)ss->server;\n\n\t\t\tif(success) {\n\t\t\t\tbcopy(hmackey,ss->hmackey,sizeof(hmackey_t));\n\t\t\t\tss->hmackey_set = 1;\n\t\t\t\tss->oauth = oauth;\n\t\t\t\tss->max_session_time_auth = (turn_time_t)max_session_time;\n\t\t\t\tbcopy(pwd,ss->pwd,sizeof(password_t));\n\t\t\t\tif(realm && realm[0] && strcmp((char*)realm,ss->realm_options.name)) {\n\t\t\t\t\tdec_quota(ss);\n\t\t\t\t\tget_realm_options_by_name((char*)realm, &(ss->realm_options));\n\t\t\t\t\tinc_quota(ss,ss->username);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread_client_connection(server,ss,in_buffer,0,0);\n\n\t\t\tclose_ioa_socket_after_processing_if_necessary(ss->client_socket);\n\n\t\t\tioa_network_buffer_delete(server->e, in_buffer->nbh);\n\t\t\tin_buffer->nbh=NULL;\n\t\t}\n\t}\n}\n\nstatic int check_stun_auth(turn_turnserver *server,\n\t\t\tts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\tint *err_code, \tconst uint8_t **reason,\n\t\t\tioa_net_data *in_buffer, ioa_network_buffer_handle nbh,\n\t\t\tuint16_t method, int *message_integrity,\n\t\t\tint *postpone_reply,\n\t\t\tint can_resume)\n{\n\tuint8_t usname[STUN_MAX_USERNAME_SIZE+1];\n\tuint8_t nonce[STUN_MAX_NONCE_SIZE+1];\n\tuint8_t realm[STUN_MAX_REALM_SIZE+1];\n\tsize_t alen = 0;\n\n\tif(!need_stun_authentication(server, ss))\n\t\treturn 0;\n\n\tint new_nonce = 0;\n\n\t{\n\t\tint generate_new_nonce = 0;\n\t\tif(ss->nonce[0]==0) {\n\t\t\tgenerate_new_nonce = 1;\n\t\t\tnew_nonce = 1;\n\t\t}\n\n\t\tif(*(server->stale_nonce)) {\n\t\t\tif(turn_time_before(ss->nonce_expiration_time,server->ctime)) {\n\t\t\t\tgenerate_new_nonce = 1;\n\t\t\t}\n\t\t}\n\n\t\tif(generate_new_nonce) {\n\n\t\t\tint i = 0;\n\n\t\t\tif(TURN_RANDOM_SIZE == 8) {\n\t\t\t\tfor(i=0;i<(NONCE_LENGTH_32BITS>>1);i++) {\n\t\t\t\t\tuint8_t *s = ss->nonce + 8*i;\n\t\t\t\t\tuint64_t rand=(uint64_t)turn_random();\n\t\t\t\t\tsnprintf((char*)s, NONCE_MAX_SIZE-8*i, \"%08lx\",(unsigned long)rand);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(i=0;i<NONCE_LENGTH_32BITS;i++) {\n\t\t\t\t\tuint8_t *s = ss->nonce + 4*i;\n\t\t\t\t\tuint32_t rand=(uint32_t)turn_random();\n\t\t\t\t\tsnprintf((char*)s, NONCE_MAX_SIZE-4*i, \"%04x\",(unsigned int)rand);\n\t\t\t\t}\n\t\t\t}\n\t\t\tss->nonce_expiration_time = server->ctime + *(server->stale_nonce);\n\t\t}\n\t}\n\n\t/* MESSAGE_INTEGRITY ATTR: */\n\n\tstun_attr_ref sar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\t    STUN_ATTRIBUTE_MESSAGE_INTEGRITY);\n\n\tif(!sar) {\n\t\t*err_code = 401;\n\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t}\n\n\t{\n\t\tint sarlen = stun_attr_get_len(sar);\n\n\t\tswitch(sarlen) {\n\t\tcase SHA1SIZEBYTES:\n\t\t\tbreak;\n\t\tcase SHA256SIZEBYTES:\n\t\tcase SHA384SIZEBYTES:\n\t\tcase SHA512SIZEBYTES:\n\t\tdefault:\n\t\t\t*err_code = 401;\n\t\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t\t};\n\t}\n\n\t{\n\n\t\t/* REALM ATTR: */\n\n\t\tsar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t  STUN_ATTRIBUTE_REALM);\n\n\t\tif(!sar) {\n\t\t\t*err_code = 400;\n\t\t\treturn -1;\n\t\t}\n\n\t\talen = min((size_t)stun_attr_get_len(sar),sizeof(realm)-1);\n\t\tbcopy(stun_attr_get_value(sar),realm,alen);\n\t\trealm[alen]=0;\n\n\t\tif(!is_secure_string(realm,0)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: wrong realm: %s\\n\", __FUNCTION__, (char*)realm);\n\t\t\trealm[0]=0;\n\t\t\t*err_code = 400;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif(method == STUN_METHOD_CONNECTION_BIND) {\n\n\t\t\tget_realm_options_by_name((char *)realm, &(ss->realm_options));\n\n\t\t} else if(strcmp((char*)realm, (char*)(ss->realm_options.name))) {\n\t\t\tif(!(ss->oauth)){\n\t\t\t\tif(method == STUN_METHOD_ALLOCATE) {\n\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t*reason = (const uint8_t*)\"Allocation mismatch: wrong credentials: the realm value is incorrect\";\n\t\t\t\t} else {\n\t\t\t\t\t*err_code = 441;\n\t\t\t\t\t*reason = (const uint8_t*)\"Wrong credentials: the realm value is incorrect\";\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tbcopy(ss->realm_options.name,realm,sizeof(ss->realm_options.name));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* USERNAME ATTR: */\n\n\tsar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t  STUN_ATTRIBUTE_USERNAME);\n\n\tif(!sar) {\n\t\t*err_code = 400;\n\t\treturn -1;\n\t}\n\n\talen = min((size_t)stun_attr_get_len(sar),sizeof(usname)-1);\n\tbcopy(stun_attr_get_value(sar),usname,alen);\n\tusname[alen]=0;\n\n\tif(!is_secure_string(usname,1)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: wrong username: %s\\n\", __FUNCTION__, (char*)usname);\n\t\tusname[0]=0;\n\t\t*err_code = 400;\n\t\treturn -1;\n\t} else if(ss->username[0]) {\n\t\tif(strcmp((char*)ss->username,(char*)usname)) {\n\t\t\tif(ss->oauth) {\n\t\t\t\tss->hmackey_set = 0;\n\t\t\t\tSTRCPY(ss->username,usname);\n\t\t\t} else {\n\t\t\t\tif(method == STUN_METHOD_ALLOCATE) {\n\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t*reason = (const uint8_t*)\"Allocation mismatch: wrong credentials\";\n\t\t\t\t} else {\n\t\t\t\t\t*err_code = 441;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tSTRCPY(ss->username,usname);\n\t}\n\n\t{\n\t\t/* NONCE ATTR: */\n\n\t\tsar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t  STUN_ATTRIBUTE_NONCE);\n\n\t\tif(!sar) {\n\t\t\t*err_code = 400;\n\t\t\treturn -1;\n\t\t}\n\n\t\talen = min((size_t)stun_attr_get_len(sar),sizeof(nonce)-1);\n\t\tbcopy(stun_attr_get_value(sar),nonce,alen);\n\t\tnonce[alen]=0;\n\n\t\t/* Stale Nonce check: */\n\n\t\tif(new_nonce) {\n\t\t\t*err_code = 438;\n\t\t\t*reason = (const uint8_t*)\"Wrong nonce\";\n\t\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t\t}\n\n\t\tif(strcmp((char*)ss->nonce,(char*)nonce)) {\n\t\t\t*err_code = 438;\n\t\t\t*reason = (const uint8_t*)\"Stale nonce\";\n\t\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t\t}\n\t}\n\n\t/* Password */\n\tif(!(ss->hmackey_set) && (ss->pwd[0] == 0)) {\n\t\tif(can_resume) {\n\t\t\t(server->userkeycb)(server->id, server->ct, server->oauth, &(ss->oauth), usname, realm, resume_processing_after_username_check, in_buffer, ss->id, postpone_reply);\n\t\t\tif(*postpone_reply) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\"%s: Cannot find credentials of user <%s>\\n\",\n\t\t\t\t__FUNCTION__, (char*)usname);\n\t\t*err_code = 401;\n\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t}\n\n\t/* Check integrity */\n\tif(stun_check_message_integrity_by_key_str(server->ct,ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t  ss->hmackey,\n\t\t\t\t\t  ss->pwd,\n\t\t\t\t\t  SHATYPE_DEFAULT)<1) {\n\n\t\tif(can_resume) {\n\t\t\t(server->userkeycb)(server->id, server->ct, server->oauth, &(ss->oauth), usname, realm, resume_processing_after_username_check, in_buffer, ss->id, postpone_reply);\n\t\t\tif(*postpone_reply) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\"%s: user %s credentials are incorrect\\n\",\n\t\t\t\t__FUNCTION__, (char*)usname);\n\t\t*err_code = 401;\n\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t}\n\n\t*message_integrity = 1;\n\n\treturn 0;\n}\n\n//<<== AUTH\n\nstatic void set_alternate_server(turn_server_addrs_list_t *asl, const ioa_addr *local_addr, size_t *counter, uint16_t method, stun_tid *tid, int *resp_constructed, int *err_code, const uint8_t **reason, ioa_network_buffer_handle nbh)\n{\n\tif(asl && asl->size && local_addr) {\n\n\t\tsize_t i;\n\n\t\t/* to prevent indefinite cycle: */\n\n\t\tfor(i=0;i<asl->size;++i) {\n\t\t\tioa_addr *addr = &(asl->addrs[i]);\n\t\t\tif(addr_eq(addr,local_addr))\n\t\t\t\treturn;\n\t\t}\n\n\t\tfor(i=0;i<asl->size;++i) {\n\t\t\tif(*counter>=asl->size)\n\t\t\t\t*counter = 0;\n\t\t\tioa_addr *addr = &(asl->addrs[*counter]);\n\t\t\t*counter +=1;\n\t\t\tif(addr->ss.sa_family == local_addr->ss.sa_family) {\n\n\t\t\t\t*err_code = 300;\n\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);\n\t\t\t\t*resp_constructed = 1;\n\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_ALTERNATE_SERVER, addr);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int handle_turn_command(turn_turnserver *server, ts_ur_super_session *ss, ioa_net_data *in_buffer, ioa_network_buffer_handle nbh, int *resp_constructed, int can_resume)\n{\n\n\tstun_tid tid;\n\tint err_code = 0;\n\tconst uint8_t *reason = NULL;\n\tint no_response = 0;\n\tint message_integrity = 0;\n\n\tif(!(ss->client_socket))\n\t\treturn -1;\n\n\tuint16_t unknown_attrs[MAX_NUMBER_OF_UNKNOWN_ATTRS];\n\tuint16_t ua_num = 0;\n\tuint16_t method = stun_get_method_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh));\n\n\t*resp_constructed = 0;\n\n\tstun_tid_from_message_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t  &tid);\n\n\tif (stun_is_request_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh))) {\n\n\t\tif((method == STUN_METHOD_BINDING) && (*(server->no_stun))) {\n\n\t\t\tno_response = 1;\n\t\t\tif(server->verbose) {\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\t\t\"%s: STUN method 0x%x ignored\\n\",\n\t\t\t\t\t\t\t\t\t__FUNCTION__, (unsigned int)method);\n\t\t\t}\n\n\t\t} else if((method != STUN_METHOD_BINDING) && (*(server->stun_only))) {\n\n\t\t\t\tno_response = 1;\n\t\t\t\tif(server->verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\t\t\t\"%s: STUN method 0x%x ignored\\n\",\n\t\t\t\t\t\t\t\t\t\t__FUNCTION__, (unsigned int)method);\n\t\t\t\t}\n\n\t\t} else if((method != STUN_METHOD_BINDING) || (*(server->secure_stun))) {\n\n\t\t\tif(method == STUN_METHOD_ALLOCATE) {\n\n\t\t\t\tallocation *a = get_allocation_ss(ss);\n\t\t\t\tif(is_allocation_valid(a)) {\n\t\t\t\t\tif(!stun_tid_equals(&(a->tid), &tid)) {\n\t\t\t\t\t\terr_code = 437;\n\t\t\t\t\t\treason = (const uint8_t *)\"Mismatched allocation: wrong transaction ID\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!err_code) {\n\t\t\t\t\tSOCKET_TYPE cst = get_ioa_socket_type(ss->client_socket);\n\t\t\t\t\tturn_server_addrs_list_t *asl = server->alternate_servers_list;\n\n\t\t\t\t\tif(((cst == UDP_SOCKET)||(cst == DTLS_SOCKET)) && server->self_udp_balance &&\n\t\t\t\t\t\t\tserver->aux_servers_list && server->aux_servers_list->size) {\n\t\t\t\t\t\tasl = server->aux_servers_list;\n\t\t\t\t\t} else if(((cst == TLS_SOCKET) || (cst == DTLS_SOCKET) ||(cst == TLS_SCTP_SOCKET)) &&\n\t\t\t\t\t\t\tserver->tls_alternate_servers_list && server->tls_alternate_servers_list->size) {\n\t\t\t\t\t\tasl = server->tls_alternate_servers_list;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(asl && asl->size) {\n\t\t\t\t\t\tturn_mutex_lock(&(asl->m));\n\t\t\t\t\t\tset_alternate_server(asl,get_local_addr_from_ioa_socket(ss->client_socket),&(server->as_counter),method,&tid,resp_constructed,&err_code,&reason,nbh);\n\t\t\t\t\t\tturn_mutex_unlock(&(asl->m));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* check that the realm is the same as in the original request */\n\t\t\tif(ss->origin_set) {\n\t\t\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\t\t\tint origin_found = 0;\n\t\t\t\tint norigins = 0;\n\n\t\t\t\twhile(sar && !origin_found) {\n\t\t\t\t\tif(stun_attr_get_type(sar) == STUN_ATTRIBUTE_ORIGIN) {\n\t\t\t\t\t\tint sarlen = stun_attr_get_len(sar);\n\t\t\t\t\t\tif(sarlen>0) {\n\t\t\t\t\t\t\t++norigins;\n\t\t\t\t\t\t\tchar *o = (char*)malloc(sarlen+1);\n\t\t\t\t\t\t\tbcopy(stun_attr_get_value(sar),o,sarlen);\n\t\t\t\t\t\t\to[sarlen]=0;\n\t\t\t\t\t\t\tchar *corigin = (char*)malloc(STUN_MAX_ORIGIN_SIZE+1);\n\t\t\t\t\t\t\tcorigin[0]=0;\n\t\t\t\t\t\t\tif(get_canonic_origin(o,corigin,STUN_MAX_ORIGIN_SIZE)<0) {\n\t\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\t\t\t\t\t\"%s: Wrong origin format: %s\\n\",\n\t\t\t\t\t\t\t\t\t__FUNCTION__, o);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!strncmp(ss->origin,corigin,STUN_MAX_ORIGIN_SIZE)) {\n\t\t\t\t\t\t\t\torigin_found = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfree(corigin);\n\t\t\t\t\t\t\tfree(o);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh), sar);\n\t\t\t\t}\n\n\t\t\t\tif(server->check_origin && *(server->check_origin)) {\n\t\t\t\t\tif(ss->origin[0]) {\n\t\t\t\t\t\tif(!origin_found) {\n\t\t\t\t\t\t\terr_code = 441;\n\t\t\t\t\t\t\treason = (const uint8_t *)\"The origin attribute does not match the initial session origin value\";\n\t\t\t\t\t\t\tif(server->verbose) {\n\t\t\t\t\t\t\t\tchar smethod[129];\n\t\t\t\t\t\t\t\tstun_method_str(method,smethod);\n\t\t\t\t\t\t\t\tlog_method(ss, smethod, err_code, reason);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(norigins > 0){\n\t\t\t\t\t\terr_code = 441;\n\t\t\t\t\t\treason = (const uint8_t *)\"The origin attribute is empty, does not match the initial session origin value\";\n\t\t\t\t\t\tif(server->verbose) {\n\t\t\t\t\t\t\tchar smethod[129];\n\t\t\t\t\t\t\tstun_method_str(method,smethod);\n\t\t\t\t\t\t\tlog_method(ss, smethod, err_code, reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* get the initial origin value */\n\t\t\tif(!err_code && !(ss->origin_set) && (method == STUN_METHOD_ALLOCATE)) {\n\n\t\t\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\t\t\tint origin_found = 0;\n\n\t\t\t\twhile(sar && !origin_found) {\n\t\t\t\t\tif(stun_attr_get_type(sar) == STUN_ATTRIBUTE_ORIGIN) {\n\t\t\t\t\t\tint sarlen = stun_attr_get_len(sar);\n\t\t\t\t\t\tif(sarlen>0) {\n\t\t\t\t\t\t\tchar *o = (char*)malloc(sarlen+1);\n\t\t\t\t\t\t\tbcopy(stun_attr_get_value(sar),o,sarlen);\n\t\t\t\t\t\t\to[sarlen]=0;\n\t\t\t\t\t\t\tchar *corigin = (char*)malloc(STUN_MAX_ORIGIN_SIZE+1);\n\t\t\t\t\t\t\tcorigin[0]=0;\n\t\t\t\t\t\t\tif(get_canonic_origin(o,corigin,STUN_MAX_ORIGIN_SIZE)<0) {\n\t\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\t\t\t\t\t\"%s: Wrong origin format: %s\\n\",\n\t\t\t\t\t\t\t\t\t__FUNCTION__, o);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstrncpy(ss->origin,corigin,STUN_MAX_ORIGIN_SIZE);\n\t\t\t\t\t\t\tfree(corigin);\n\t\t\t\t\t\t\tfree(o);\n\t\t\t\t\t\t\torigin_found = get_realm_options_by_origin(ss->origin,&(ss->realm_options));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh), sar);\n\t\t\t\t}\n\n\t\t\t\tss->origin_set = 1;\n\t\t\t}\n\n\t\t\tif(!err_code && !(*resp_constructed) && !no_response) {\n\t\t\t\tif(method == STUN_METHOD_CONNECTION_BIND) {\n\t\t\t\t\t;\n\t\t\t\t} else if(!(*(server->mobility)) || (method != STUN_METHOD_REFRESH) || is_allocation_valid(get_allocation_ss(ss))) {\n\t\t\t\t\tint postpone_reply = 0;\n\t\t\t\t\tcheck_stun_auth(server, ss, &tid, resp_constructed, &err_code, &reason, in_buffer, nbh, method, &message_integrity, &postpone_reply, can_resume);\n\t\t\t\t\tif(postpone_reply)\n\t\t\t\t\t\tno_response = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!err_code && !(*resp_constructed) && !no_response) {\n\n\t\t\tswitch (method){\n\n\t\t\tcase STUN_METHOD_ALLOCATE:\n\n\t\t\t{\n\t\t\t\thandle_turn_allocate(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"ALLOCATE\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase STUN_METHOD_CONNECT:\n\n\t\t\t\thandle_turn_connect(server, ss, &tid, &err_code, &reason,\n\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"CONNECT\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tif(!err_code)\n\t\t\t\t\tno_response = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_CONNECTION_BIND:\n\n\t\t\t\thandle_turn_connection_bind(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh, message_integrity, can_resume);\n\n\t\t\t\tif(server->verbose && err_code) {\n\t\t\t\t  log_method(ss, \"CONNECTION_BIND\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_REFRESH:\n\n\t\t\t\thandle_turn_refresh(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh, message_integrity,\n\t\t\t\t\t\t\t\t&no_response, can_resume);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"REFRESH\", err_code, reason);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_CHANNEL_BIND:\n\n\t\t\t\thandle_turn_channel_bind(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"CHANNEL_BIND\", err_code, reason);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_CREATE_PERMISSION:\n\n\t\t\t\thandle_turn_create_permission(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"CREATE_PERMISSION\", err_code, reason);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_BINDING:\n\n\t\t\t{\n\t\t\t\tint origin_changed=0;\n\t\t\t\tioa_addr response_origin;\n\t\t\t\tint dest_changed=0;\n\t\t\t\tioa_addr response_destination;\n\n\t\t\t\thandle_turn_binding(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh,\n\t\t\t\t\t\t\t&origin_changed, &response_origin,\n\t\t\t\t\t\t\t&dest_changed, &response_destination,\n\t\t\t\t\t\t\t0, 0);\n\n\t\t\t\tif(server->verbose && server->log_binding) {\n\t\t\t\t  log_method(ss, \"BINDING\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tif(*resp_constructed && !err_code && (origin_changed || dest_changed)) {\n\n\t\t\t\t\tif (server->verbose && server->log_binding) {\n\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"RFC 5780 request successfully processed\\n\");\n\t\t\t\t\t}\n\n\t\t\t\t\t{\n\t\t\t\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\t\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t\t}\n\n\t\t\t\t\tsend_turn_message_to(server, nbh, &response_origin, &response_destination);\n\n\t\t\t\t\tno_response = 1;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"Unsupported STUN request received, method 0x%x\\n\",(unsigned int)method);\n\t\t\t};\n\t\t}\n\n\t} else if (stun_is_indication_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh))) {\n\n\t\tno_response = 1;\n\t\tint postpone = 0;\n\n\t\tif (!postpone && !err_code) {\n\n\t\t\tswitch (method){\n\n\t\t\tcase STUN_METHOD_BINDING:\n\t\t\t\t//ICE ?\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_SEND:\n\n\t\t\t\thandle_turn_send(server, ss, &err_code, &reason, unknown_attrs, &ua_num, in_buffer);\n\n\t\t\t\tif(eve(server->verbose)) {\n\t\t\t\t  log_method(ss, \"SEND\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_DATA:\n\n\t\t\t\terr_code = 403;\n\n\t\t\t\tif(eve(server->verbose)) {\n\t\t\t\t  log_method(ss, \"DATA\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (server->verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Unsupported STUN indication received: method 0x%x\\n\",(unsigned int)method);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t} else {\n\n\t\tno_response = 1;\n\n\t\tif (server->verbose) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Wrong STUN message received\\n\");\n\t\t}\n\t}\n\n\tif(ss->to_be_closed || !(ss->client_socket) || ioa_socket_tobeclosed(ss->client_socket))\n\t\treturn 0;\n\n\tif (ua_num > 0) {\n\n\t\terr_code = 420;\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, NULL, &tid);\n\n\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_UNKNOWN_ATTRIBUTES, (const uint8_t*) unknown_attrs, (ua_num\n\t\t\t\t\t\t* 2));\n\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t*resp_constructed = 1;\n\t}\n\n\tif (!no_response) {\n\n\t\tif (!(*resp_constructed)) {\n\n\t\t\tif (!err_code)\n\t\t\t\terr_code = 400;\n\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, reason, &tid);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t*resp_constructed = 1;\n\t\t}\n\n\t\t{\n\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif(message_integrity) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\n\t\tif(err_code) {\n\t\t\tif(server->verbose) {\n\t\t\t  log_method(ss, \"message\", err_code, reason);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t*resp_constructed = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_old_stun_command(turn_turnserver *server, ts_ur_super_session *ss, ioa_net_data *in_buffer, ioa_network_buffer_handle nbh, int *resp_constructed, uint32_t cookie)\n{\n\n\tstun_tid tid;\n\tint err_code = 0;\n\tconst uint8_t *reason = NULL;\n\tint no_response = 0;\n\n\tuint16_t unknown_attrs[MAX_NUMBER_OF_UNKNOWN_ATTRS];\n\tuint16_t ua_num = 0;\n\tuint16_t method = stun_get_method_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh));\n\n\t*resp_constructed = 0;\n\n\tstun_tid_from_message_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t  &tid);\n\n\tif (stun_is_request_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh))) {\n\n\t\tif(method != STUN_METHOD_BINDING) {\n\t\t\tno_response = 1;\n\t\t\tif(server->verbose) {\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\"%s: OLD STUN method 0x%x ignored\\n\",\n\t\t\t\t\t\t\t__FUNCTION__, (unsigned int)method);\n\t\t\t}\n\t\t}\n\n\t\tif (!err_code && !(*resp_constructed) && !no_response) {\n\n\t\t\tint origin_changed=0;\n\t\t\tioa_addr response_origin;\n\t\t\tint dest_changed=0;\n\t\t\tioa_addr response_destination;\n\n\t\t\thandle_turn_binding(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh,\n\t\t\t\t\t\t&origin_changed, &response_origin,\n\t\t\t\t\t\t&dest_changed, &response_destination,\n\t\t\t\t\t\tcookie,1);\n\n\t\t\tif(server->verbose && *(server->log_binding)) {\n\t\t\t  log_method(ss, \"OLD BINDING\", err_code, reason);\n\t\t\t}\n\n\t\t\tif(*resp_constructed && !err_code && (origin_changed || dest_changed)) {\n\n\t\t\t\tif (server->verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"RFC3489 CHANGE request successfully processed\\n\");\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tsize_t oldsz = strlen(get_version(server));\n\t\t\t\t\tsize_t newsz = (((oldsz)>>2) + 1)<<2;\n\t\t\t\t\tuint8_t software[120];\n\t\t\t\t\tbzero(software,sizeof(software));\n\t\t\t\t\tif(newsz>sizeof(software))\n\t\t\t\t\t\tnewsz = sizeof(software);\n\t\t\t\t\tbcopy(get_version(server),software,oldsz);\n\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, OLD_STUN_ATTRIBUTE_SERVER, software, newsz);\n\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t}\n\n\t\t\t\tsend_turn_message_to(server, nbh, &response_origin, &response_destination);\n\n\t\t\t\tno_response = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\tno_response = 1;\n\n\t\tif (server->verbose) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Wrong OLD STUN message received\\n\");\n\t\t}\n\t}\n\n\tif (ua_num > 0) {\n\n\t\terr_code = 420;\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\told_stun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, NULL, &tid, cookie);\n\n\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_UNKNOWN_ATTRIBUTES, (const uint8_t*) unknown_attrs, (ua_num * 2));\n\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t*resp_constructed = 1;\n\t}\n\n\tif (!no_response) {\n\n\t\tif (!(*resp_constructed)) {\n\n\t\t\tif (!err_code)\n\t\t\t\terr_code = 400;\n\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\told_stun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, reason, &tid, cookie);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t*resp_constructed = 1;\n\t\t}\n\n\t\t{\n\t\t\tsize_t oldsz = strlen(get_version(server));\n\t\t\tsize_t newsz = (((oldsz)>>2) + 1)<<2;\n\t\t\tuint8_t software[120];\n\t\t\tbzero(software,sizeof(software));\n\t\t\tif(newsz>sizeof(software))\n\t\t\t\tnewsz = sizeof(software);\n\t\t\tbcopy(get_version(server),software,oldsz);\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, OLD_STUN_ATTRIBUTE_SERVER, software, newsz);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif(err_code) {\n\t\t\tif(server->verbose) {\n\t\t\t  log_method(ss, \"OLD STUN message\", err_code, reason);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t*resp_constructed = 0;\n\t}\n\n\treturn 0;\n}\n\n//////////////////////////////////////////////////////////////////\n\nstatic int write_to_peerchannel(ts_ur_super_session* ss, uint16_t chnum, ioa_net_data *in_buffer) {\n\n\tint rc = 0;\n\n\tif (ss && (in_buffer->recv_ttl!=0)) {\n\n\t\tallocation* a = get_allocation_ss(ss);\n\n\t\tif (is_allocation_valid(a)) {\n\n\t\t\tch_info* chn = allocation_get_ch_info(a, chnum);\n\n\t\t\tif (!chn)\n\t\t\t\treturn -1;\n\n\t\t\t/* Channel packets are always sent with DF=0: */\n\t\t\tset_df_on_ioa_socket(get_relay_socket_ss(ss, chn->peer_addr.ss.sa_family), 0);\n\n\t\t\tioa_network_buffer_handle nbh = in_buffer->nbh;\n\n\t\t\tioa_network_buffer_add_offset_size(in_buffer->nbh, STUN_CHANNEL_HEADER_LENGTH, 0, ioa_network_buffer_get_size(in_buffer->nbh)-STUN_CHANNEL_HEADER_LENGTH);\n\n\t\t\tioa_network_buffer_header_init(nbh);\n\n\t\t\tint skip = 0;\n\t\t\trc = send_data_from_ioa_socket_nbh(get_relay_socket_ss(ss, chn->peer_addr.ss.sa_family), &(chn->peer_addr), nbh, in_buffer->recv_ttl-1, in_buffer->recv_tos, &skip);\n\n\t\t\tif (!skip && rc > -1) {\n\t\t\t\t++(ss->peer_sent_packets);\n\t\t\t\tss->peer_sent_bytes += (uint32_t)ioa_network_buffer_get_size(in_buffer->nbh);\n\t\t\t\tturn_report_session_usage(ss, 0);\n\t\t\t}\n\n\t\t\tin_buffer->nbh = NULL;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic void client_input_handler(ioa_socket_handle s, int event_type,\n\t\tioa_net_data *data, void *arg, int can_resume);\nstatic void peer_input_handler(ioa_socket_handle s, int event_type,\n\t\tioa_net_data *data, void *arg, int can_resume);\n\n/////////////// Client actions /////////////////\n\nint shutdown_client_connection(turn_turnserver *server, ts_ur_super_session *ss, int force, const char* reason) {\n\n\tFUNCSTART;\n\n\tif (!ss)\n\t\treturn -1;\n\n\tturn_report_session_usage(ss, 1);\n\tdec_quota(ss);\n\tdec_bps(ss);\n\n\tallocation* alloc = get_allocation_ss(ss);\n\tif (!is_allocation_valid(alloc)) {\n\t\tforce = 1;\n\t}\n\n\tif(!force && ss->is_mobile) {\n\n\t\tif (ss->client_socket && server->verbose) {\n\n\t\t\tchar sraddr[129]=\"\\0\";\n\t\t\tchar sladdr[129]=\"\\0\";\n\t\t\taddr_to_string(get_remote_addr_from_ioa_socket(ss->client_socket),(uint8_t*)sraddr);\n\t\t\taddr_to_string(get_local_addr_from_ioa_socket(ss->client_socket),(uint8_t*)sladdr);\n\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"session %018llu: closed (1st stage), user <%s> realm <%s> origin <%s>, local %s, remote %s, reason: %s\\n\",(unsigned long long)(ss->id),(char*)ss->username,(char*)ss->realm_options.name,(char*)ss->origin, sladdr,sraddr,reason);\n\t\t}\n\n\t\tIOA_CLOSE_SOCKET(ss->client_socket);\n\n\t\tFUNCEND;\n\n\t\treturn 0;\n\t}\n\n\tif (eve(server->verbose)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\"closing session 0x%lx, client socket 0x%lx (socket session=0x%lx)\\n\",\n\t\t\t\t(long) ss,\n\t\t\t\t(long) ss->client_socket,\n\t\t\t\t(long)get_ioa_socket_session(ss->client_socket));\n\t}\n\n\tif (server->disconnect)\n\t\tserver->disconnect(ss);\n\n\tif (server->verbose) {\n\n\t\tchar sraddr[129]=\"\\0\";\n\t\tchar sladdr[129]=\"\\0\";\n\t\taddr_to_string(get_remote_addr_from_ioa_socket(ss->client_socket),(uint8_t*)sraddr);\n\t\taddr_to_string(get_local_addr_from_ioa_socket(ss->client_socket),(uint8_t*)sladdr);\n\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"session %018llu: closed (2nd stage), user <%s> realm <%s> origin <%s>, local %s, remote %s, reason: %s\\n\",\n\t\t\t\t\t(unsigned long long)(ss->id), (char*)ss->username,(char*)ss->realm_options.name,(char*)ss->origin, sladdr,sraddr, reason);\n\t}\n\n\tIOA_CLOSE_SOCKET(ss->client_socket);\n\t{\n\t\tint i;\n\t\tfor(i=0;i<ALLOC_PROTOCOLS_NUMBER;++i) {\n\t\t\tIOA_CLOSE_SOCKET(ss->alloc.relay_sessions[i].s);\n\t\t}\n\t}\n\n\tturn_server_remove_all_from_ur_map_ss(ss);\n\n\tFUNCEND;\n\n\treturn 0;\n}\n\nstatic void client_to_be_allocated_timeout_handler(ioa_engine_handle e,\n\t\tvoid *arg) {\n\n\tif (!arg)\n\t\treturn;\n\n\tUNUSED_ARG(e);\n\n\tts_ur_super_session* ss = (ts_ur_super_session*) arg;\n\n\tturn_turnserver* server = (turn_turnserver*) (ss->server);\n\n\tif (!server)\n\t\treturn;\n\n\tFUNCSTART;\n\n\tint to_close = 0;\n\n\tioa_socket_handle s = ss->client_socket;\n\n\tif(!s || ioa_socket_tobeclosed(s)) {\n\t\tto_close = 1;\n\t} else if(get_ioa_socket_app_type(s) == HTTPS_CLIENT_SOCKET) {\n\t\t;\n\t} else {\n\t\tioa_socket_handle rs4 = ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s;\n\t\tioa_socket_handle rs6 = ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s;\n\t\tif((!rs4 || ioa_socket_tobeclosed(rs4)) && (!rs6 || ioa_socket_tobeclosed(rs6))) {\n\t\t\tto_close = 1;\n\t\t} else if(ss->client_socket == NULL) {\n\t\t\tto_close = 1;\n\t\t} else if(!(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].lifetime_ev) &&\n\t\t\t\t!(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].lifetime_ev)) {\n\t\t\tto_close = 1;\n\t\t} else if(!(ss->to_be_allocated_timeout_ev)) {\n\t\t\tto_close = 1;\n\t\t}\n\t}\n\n\tif(to_close) {\n\t\tIOA_EVENT_DEL(ss->to_be_allocated_timeout_ev);\n\t\tshutdown_client_connection(server, ss, 1, \"allocation watchdog determined stale session state\");\n\t}\n\n\tFUNCEND;\n}\n\nstatic int write_client_connection(turn_turnserver *server, ts_ur_super_session* ss, ioa_network_buffer_handle nbh, int ttl, int tos) {\n\n\tFUNCSTART;\n\n\tif (!(ss->client_socket)) {\n\t\tioa_network_buffer_delete(server->e, nbh);\n\t\tFUNCEND;\n\t\treturn -1;\n\t} else {\n\n\t\tif (eve(server->verbose)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\"%s: prepare to write to s 0x%lx\\n\", __FUNCTION__,\n\t\t\t\t(long) (ss->client_socket));\n\t\t}\n\n\t\tint skip = 0;\n\t\tint ret = send_data_from_ioa_socket_nbh(ss->client_socket, NULL, nbh, ttl, tos, &skip);\n\n\t\tif(!skip && ret>-1) {\n\t\t\t++(ss->sent_packets);\n\t\t\tss->sent_bytes += (uint32_t)ioa_network_buffer_get_size(nbh);\n\t\t\tturn_report_session_usage(ss, 0);\n\t\t}\n\n\t\tFUNCEND;\n\t\treturn ret;\n\t}\n}\n\nstatic void client_ss_allocation_timeout_handler(ioa_engine_handle e, void *arg) {\n\n\tUNUSED_ARG(e);\n\n\tif (!arg)\n\t\treturn;\n\n\trelay_endpoint_session *rsession = (relay_endpoint_session*)arg;\n\n\tif(!(rsession->s))\n\t\treturn;\n\n\tts_ur_super_session* ss = get_ioa_socket_session(rsession->s);\n\n\tif (!ss)\n\t\treturn;\n\n\tallocation* a =  get_allocation_ss(ss);\n\n\tturn_turnserver* server = (turn_turnserver*) (ss->server);\n\n\tif (!server) {\n\t\tclear_allocation(a);\n\t\treturn;\n\t}\n\n\tFUNCSTART;\n\n\tint family = get_ioa_socket_address_family(rsession->s);\n\n\tset_allocation_family_invalid(a,family);\n\n\tif(!get_relay_socket(a, AF_INET) && !get_relay_socket(a, AF_INET6)) {\n\t\tshutdown_client_connection(server, ss, 0, \"allocation timeout\");\n\t}\n\n\tFUNCEND;\n}\n\nstatic int create_relay_connection(turn_turnserver* server,\n\t\t\t\t   ts_ur_super_session *ss, uint32_t lifetime,\n\t\t\t\t   int address_family, uint8_t transport,\n\t\t\t\t   int even_port, uint64_t in_reservation_token, uint64_t *out_reservation_token,\n\t\t\t\t   int *err_code, const uint8_t **reason,\n\t\t\t\t   accept_cb acb) {\n\n\tif (server && ss && ss->client_socket && !ioa_socket_tobeclosed(ss->client_socket)) {\n\n\t\tallocation* a = get_allocation_ss(ss);\n\t\trelay_endpoint_session* newelem = NULL;\n\t\tioa_socket_handle rtcp_s = NULL;\n\n\t\tif (in_reservation_token) {\n\n\t\t\tioa_socket_handle s = NULL;\n\n\t\t\tif ((get_ioa_socket_from_reservation(server->e, in_reservation_token,&s) < 0)||\n\t\t\t\t!s ||\n\t\t\t\tioa_socket_tobeclosed(s)) {\n\n\t\t\t\tIOA_CLOSE_SOCKET(s);\n\t\t\t\t*err_code = 404;\n\t\t\t\t*reason = (const uint8_t *)\"Cannot find reserved socket\";\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint family = get_ioa_socket_address_family(s);\n\n\t\t\tnewelem = get_relay_session_ss(ss,family);\n\n\t\t\tif(newelem->s != s) {\n\n\t\t\t\tIOA_CLOSE_SOCKET(newelem->s);\n\n\t\t\t\tbzero(newelem, sizeof(relay_endpoint_session));\n\t\t\t\tnewelem->s = s;\n\t\t\t}\n\n\t\t\taddr_debug_print(server->verbose, get_local_addr_from_ioa_socket(newelem->s), \"Local relay addr (RTCP)\");\n\n\t\t} else {\n\t\t\tint family = get_family(address_family,server->e,ss->client_socket);\n\n\t\t\tnewelem = get_relay_session_ss(ss,family);\n\n\n\t\t\tIOA_CLOSE_SOCKET(newelem->s);\n\n\t\t\tbzero(newelem, sizeof(relay_endpoint_session));\n\t\t\tnewelem->s = NULL;\n\n\t\t\tint res = create_relay_ioa_sockets(server->e,\n\t\t\t\t\t\t\tss->client_socket,\n\t\t\t\t\t\t\taddress_family, transport,\n\t\t\t\t\t\t\teven_port, &(newelem->s), &rtcp_s, out_reservation_token,\n\t\t\t\t\t\t\terr_code, reason, acb, ss);\n\t\t\tif (res < 0) {\n\t\t\t\tif(!(*err_code))\n\t\t\t\t\t*err_code = 508;\n\t\t\t\tif(!(*reason))\n\t\t\t\t\t*reason = (const uint8_t *)\"Cannot create socket\";\n\t\t\t\tIOA_CLOSE_SOCKET(newelem->s);\n\t\t\t\tIOA_CLOSE_SOCKET(rtcp_s);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (newelem->s == NULL) {\n\t\t\tIOA_CLOSE_SOCKET(rtcp_s);\n\t\t\t*err_code = 508;\n\t\t\t*reason = (const uint8_t *)\"Cannot create relay socket\";\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rtcp_s) {\n\t\t\tif (out_reservation_token && *out_reservation_token) {\n\t\t\t\t/* OK */\n\t\t\t} else {\n\t\t\t\tIOA_CLOSE_SOCKET(newelem->s);\n\t\t\t\tIOA_CLOSE_SOCKET(rtcp_s);\n\t\t\t\t*err_code = 500;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong reservation tokens (internal error)\";\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* RFC6156: do not use DF when IPv6 is involved: */\n\t\tif((get_ioa_socket_address_family(newelem->s) == AF_INET6) ||\n\t\t   (get_ioa_socket_address_family(ss->client_socket) == AF_INET6))\n\t\t\tset_do_not_use_df(newelem->s);\n\n\t\tif(get_ioa_socket_type(newelem->s) != TCP_SOCKET) {\n\t\t\tif(register_callback_on_ioa_socket(server->e, newelem->s, IOA_EV_READ,peer_input_handler, ss, 0)<0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (lifetime<1)\n\t\t\tlifetime = STUN_DEFAULT_ALLOCATE_LIFETIME;\n\t\telse if(lifetime>(uint32_t)*(server->max_allocate_lifetime))\n\t\t\tlifetime = (uint32_t)*(server->max_allocate_lifetime);\n\n\t\tioa_timer_handle ev = set_ioa_timer(server->e, lifetime, 0,\n\t\t\t\tclient_ss_allocation_timeout_handler, newelem, 0,\n\t\t\t\t\"client_ss_allocation_timeout_handler\");\n\t\tset_allocation_lifetime_ev(a, server->ctime + lifetime, ev, get_ioa_socket_address_family(newelem->s));\n\n\t\tset_ioa_socket_session(newelem->s, ss);\n\t}\n\n\treturn 0;\n}\n\nstatic int refresh_relay_connection(turn_turnserver* server,\n\t\tts_ur_super_session *ss, uint32_t lifetime, int even_port,\n\t\tuint64_t in_reservation_token, uint64_t *out_reservation_token,\n\t\tint *err_code, int family) {\n\n\tUNUSED_ARG(even_port);\n\tUNUSED_ARG(in_reservation_token);\n\tUNUSED_ARG(out_reservation_token);\n\tUNUSED_ARG(err_code);\n\n\tallocation* a = get_allocation_ss(ss);\n\n\tif (server && ss && is_allocation_valid(a)) {\n\n\t\tif (lifetime < 1) {\n\t\t\tlifetime = 1;\n\t\t}\n\n\t\tioa_timer_handle ev = set_ioa_timer(server->e, lifetime, 0,\n\t\t\t\tclient_ss_allocation_timeout_handler, get_relay_session(a,family), 0,\n\t\t\t\t\"refresh_client_ss_allocation_timeout_handler\");\n\n\t\tset_allocation_lifetime_ev(a, server->ctime + lifetime, ev, family);\n\n\t\treturn 0;\n\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic int read_client_connection(turn_turnserver *server,\n\t\t\t\t  \t  \t  \t  \t  ts_ur_super_session *ss, ioa_net_data *in_buffer,\n\t\t\t\t  \t  \t  \t  \t  int can_resume, int count_usage) {\n\n\tFUNCSTART;\n\n\tif (!server || !ss || !in_buffer || !(ss->client_socket) || ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tint ret = (int)ioa_network_buffer_get_size(in_buffer->nbh);\n\tif (ret < 0) {\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tif(count_usage) {\n\t\t++(ss->received_packets);\n\t\tss->received_bytes += (uint32_t)ioa_network_buffer_get_size(in_buffer->nbh);\n\t\tturn_report_session_usage(ss, 0);\n\t}\n\n\tif (eve(server->verbose)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t      \"%s: data.buffer=0x%lx, data.len=%ld\\n\", __FUNCTION__,\n\t\t\t      (long)ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t      (long)ioa_network_buffer_get_size(in_buffer->nbh));\n\t}\n\n\tuint16_t chnum = 0;\n\tuint32_t old_stun_cookie = 0;\n\n\tsize_t blen = ioa_network_buffer_get_size(in_buffer->nbh);\n\tsize_t orig_blen = blen;\n\tSOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);\n\tSOCKET_APP_TYPE sat = get_ioa_socket_app_type(ss->client_socket);\n\tint is_padding_mandatory = is_stream_socket(st);\n\n\tif(sat == HTTP_CLIENT_SOCKET) {\n\n\t\tif(server->verbose) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: HTTP connection input: %s\\n\", __FUNCTION__, (char*)ioa_network_buffer_data(in_buffer->nbh));\n\t\t}\n\n\t\thandle_http_echo(ss->client_socket);\n\n\t} else if(sat == HTTPS_CLIENT_SOCKET) {\n\n\t\t//???\n\n\t} else if (stun_is_channel_message_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t&blen,\n\t\t\t\t\t&chnum,\n\t\t\t\t\tis_padding_mandatory)) {\n\n\t\tif(ss->is_tcp_relay) {\n\t\t\t//Forbidden\n\t\t\tFUNCEND;\n\t\t\treturn -1;\n\t\t}\n\n\t\tint rc = 0;\n\n\t\tif(blen<=orig_blen) {\n\t\t\tioa_network_buffer_set_size(in_buffer->nbh,blen);\n\t\t\trc = write_to_peerchannel(ss, chnum, in_buffer);\n\t\t}\n\n\t\tif (eve(server->verbose)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: wrote to peer %d bytes\\n\",\n\t\t\t\t\t__FUNCTION__, (int) rc);\n\t\t}\n\n\t\tFUNCEND;\n\t\treturn 0;\n\n\t} else if (stun_is_command_message_full_check_str(ioa_network_buffer_data(in_buffer->nbh), ioa_network_buffer_get_size(in_buffer->nbh), 0, &(ss->enforce_fingerprints))) {\n\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tint resp_constructed = 0;\n\n\t\tuint16_t method = stun_get_method_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\thandle_turn_command(server, ss, in_buffer, nbh, &resp_constructed, can_resume);\n\n\t\tif((method != STUN_METHOD_BINDING) && (method != STUN_METHOD_SEND))\n\t\t\treport_turn_session_info(server,ss,0);\n\n\t\tif(ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {\n\t\t\tFUNCEND;\n\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (resp_constructed) {\n\n\t\t\tif ((server->fingerprint) || ss->enforce_fingerprints) {\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tif (stun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len) < 0) {\n\t\t\t\t\tFUNCEND\t;\n\t\t\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t}\n\n\t\t\tint ret = write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\n\t\t\tFUNCEND\t;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (old_stun_is_command_message_str(ioa_network_buffer_data(in_buffer->nbh), ioa_network_buffer_get_size(in_buffer->nbh), &old_stun_cookie) && !(*(server->no_stun))) {\n\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tint resp_constructed = 0;\n\n\t\thandle_old_stun_command(server, ss, in_buffer, nbh, &resp_constructed, old_stun_cookie);\n\n\t\tif (resp_constructed) {\n\n\t\t\tint ret = write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\n\t\t\tFUNCEND\t;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tSOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);\n\t\tif(is_stream_socket(st)) {\n\t\t\tif(is_http((char*)ioa_network_buffer_data(in_buffer->nbh),\n\t\t\tioa_network_buffer_get_size(in_buffer->nbh))) {\n\n\t\t\t\tconst char *proto = \"HTTP\";\n\t\t\t\tif ((st == TCP_SOCKET) &&\n\t\t\t\t\t(\n\t\t\t\t\t\ttry_acme_redirect(\n\t\t\t\t\t\t\t(char*)ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\tserver->acme_redirect,\n\t\t\t\t\t\t\tss->client_socket\n\t\t\t\t\t\t) == 0\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tss->to_be_closed = 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else if (*server->web_admin_listen_on_workers) {\n\t\t\t\t\tif(st==TLS_SOCKET) {\n\t\t\t\t\t\tproto = \"HTTPS\";\n\t\t\t\t\t\tset_ioa_socket_app_type(ss->client_socket,HTTPS_CLIENT_SOCKET);\n\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: %s (%s %s) request: %s\\n\", __FUNCTION__, proto, get_ioa_socket_cipher(ss->client_socket), get_ioa_socket_ssl_method(ss->client_socket), ioa_network_buffer_get_size(in_buffer->nbh));\n\t\t\t\t\t\tif(server->send_https_socket) {\n\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s socket to be detached: 0x%lx, st=%d, sat=%d\\n\", __FUNCTION__,(long)ss->client_socket, get_ioa_socket_type(ss->client_socket), get_ioa_socket_app_type(ss->client_socket));\n\t\t\t\t\t\t\tioa_socket_handle new_s = detach_ioa_socket(ss->client_socket);\n\t\t\t\t\t\t\tif(new_s) {\n\t\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s new detached socket: 0x%lx, st=%d, sat=%d\\n\", __FUNCTION__,(long)new_s, get_ioa_socket_type(new_s), get_ioa_socket_app_type(new_s));\n\t\t\t\t\t\t\t\tserver->send_https_socket(new_s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tss->to_be_closed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_ioa_socket_app_type(ss->client_socket,HTTP_CLIENT_SOCKET);\n\t\t\t\t\t\tif(server->verbose) {\n\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: %s request: %s\\n\", __FUNCTION__, proto, ioa_network_buffer_get_size(in_buffer->nbh));\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandle_http_echo(ss->client_socket);\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tss->to_be_closed = 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \n\t//Unrecognized message received, ignore it\n\n\tFUNCEND;\n\treturn -1;\n}\n\nstatic int attach_socket_to_session(turn_turnserver* server, ioa_socket_handle s, ts_ur_super_session* ss) {\n\n\tint ret = -1;\n\tFUNCSTART;\n\n\tif(s && server && ss && !ioa_socket_tobeclosed(s)) {\n\n\t\tif(ss->client_socket != s) {\n\n\t\t\tIOA_CLOSE_SOCKET(ss->client_socket);\n\n\t\t\tss->client_socket = s;\n\n\t\t\tif(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ,\n\t\t\t\t\tclient_input_handler, ss, 0)<0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tset_ioa_socket_session(s, ss);\n\t\t}\n\n\t\tret = 0;\n\t}\n\n\tFUNCEND;\n\treturn ret;\n}\n\nint open_client_connection_session(turn_turnserver* server,\n\t\t\t\tstruct socket_message *sm) {\n\n\tFUNCSTART;\n\tif (!server)\n\t\treturn -1;\n\n\tif (!(sm->s))\n\t\treturn -1;\n\n\tts_ur_super_session* ss = create_new_ss(server);\n\n\tss->client_socket = sm->s;\n\n\tif(register_callback_on_ioa_socket(server->e, ss->client_socket, IOA_EV_READ,\n\t\t\tclient_input_handler, ss, 0)<0) {\n\t\treturn -1;\n\t}\n\n\tset_ioa_socket_session(ss->client_socket, ss);\n\n\tint at = TURN_MAX_ALLOCATE_TIMEOUT;\n\tif(*(server->stun_only))\n\t  at = TURN_MAX_ALLOCATE_TIMEOUT_STUN_ONLY;\n\n\tIOA_EVENT_DEL(ss->to_be_allocated_timeout_ev);\n\tss->to_be_allocated_timeout_ev = set_ioa_timer(server->e,\n\t\t\tat, 0,\n\t\t\tclient_to_be_allocated_timeout_handler, ss, 1,\n\t\t\t\"client_to_be_allocated_timeout_handler\");\n\n\tif(sm->nd.nbh) {\n\t\tclient_input_handler(ss->client_socket,IOA_EV_READ,&(sm->nd),ss,sm->can_resume);\n\t\tioa_network_buffer_delete(server->e, sm->nd.nbh);\n\t\tsm->nd.nbh = NULL;\n\t}\n\n\tFUNCEND;\n\n\treturn 0;\n}\n\n/////////////// io handlers ///////////////////\n\nstatic void peer_input_handler(ioa_socket_handle s, int event_type,\n\t\tioa_net_data *in_buffer, void *arg, int can_resume) {\n\n\tif (!(event_type & IOA_EV_READ) || !arg) return;\n\n\tif(in_buffer->recv_ttl==0) return;\n\n\tUNUSED_ARG(can_resume);\n\n\tif(!s || ioa_socket_tobeclosed(s)) return;\n\n\tts_ur_super_session* ss = (ts_ur_super_session*) arg;\n\n\tif(!ss) return;\n\n\tif(ss->to_be_closed) return;\n\n\tif(!(ss->client_socket) || ioa_socket_tobeclosed(ss->client_socket)) return;\n\n\tturn_turnserver *server = (turn_turnserver*) (ss->server);\n\n\tif (!server) return;\n\n\trelay_endpoint_session* elem = get_relay_session_ss(ss, get_ioa_socket_address_family(s));\n\tif (elem->s == NULL) {\n\t\treturn;\n\t}\n\n\tint offset = STUN_CHANNEL_HEADER_LENGTH;\n\n\tint ilen = min((int)ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t(int)(ioa_network_buffer_get_capacity_udp() - offset));\n\n\tif (ilen >= 0) {\n\t\t++(ss->peer_received_packets);\n\t\tss->peer_received_bytes += ilen;\n\t\tturn_report_session_usage(ss, 0);\n\n\t\tallocation* a = get_allocation_ss(ss);\n\t\tif (is_allocation_valid(a)) {\n\n\t\t\tuint16_t chnum = 0;\n\n\t\t\tioa_network_buffer_handle nbh = NULL;\n\n\t\t\tturn_permission_info* tinfo = allocation_get_permission(a,\n\t\t\t\t\t\t\t&(in_buffer->src_addr));\n\t\t\tif (tinfo) {\n\t\t\t\tchnum = get_turn_channel_number(tinfo, &(in_buffer->src_addr));\n\t\t\t} else if(!(server->server_relay)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (chnum) {\n\n\t\t\t\tsize_t len = (size_t)(ilen);\n\n\t\t\t\tnbh = in_buffer->nbh;\n\n\t\t\t\tioa_network_buffer_add_offset_size(nbh,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tSTUN_CHANNEL_HEADER_LENGTH,\n\t\t\t\t\t\t\t\tioa_network_buffer_get_size(nbh)+STUN_CHANNEL_HEADER_LENGTH);\n\n\t\t\t\tioa_network_buffer_header_init(nbh);\n\n\t\t\t\tSOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);\n\t\t\t\tint do_padding = is_stream_socket(st);\n\n\t\t\t\tstun_init_channel_message_str(chnum, ioa_network_buffer_data(nbh), &len, len, do_padding);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\tin_buffer->nbh = NULL;\n\t\t\t\tif (eve(server->verbose)) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\"%s: send channel 0x%x\\n\", __FUNCTION__,\n\t\t\t\t\t\t\t(int) (chnum));\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tsize_t len = 0;\n\n\t\t\t\tnbh = ioa_network_buffer_allocate(server->e);\n\t\t\t\tstun_init_indication_str(STUN_METHOD_DATA, ioa_network_buffer_data(nbh), &len);\n\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_DATA,\n\t\t\t\t\t\t\t\tioa_network_buffer_data(in_buffer->nbh), (size_t)ilen);\n\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\tSTUN_ATTRIBUTE_XOR_PEER_ADDRESS,\n\t\t\t\t\t\t&(in_buffer->src_addr));\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\t{\n\t\t\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t}\n\n\t\t\t\tif ((server->fingerprint) || ss->enforce_fingerprints) {\n\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\tstun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len);\n\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (eve(server->verbose)) {\n\t\t\t\tuint16_t* t = (uint16_t*) ioa_network_buffer_data(nbh);\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Send data: 0x%x\\n\",\n\t\t\t\t\t\t(int) (nswap16(t[0])));\n\t\t\t}\n\n\t\t\twrite_client_connection(server, ss, nbh, in_buffer->recv_ttl-1, in_buffer->recv_tos);\n\t\t}\n\t}\n}\n\nstatic void client_input_handler(ioa_socket_handle s, int event_type,\n\t\tioa_net_data *data, void *arg, int can_resume) {\n\n\tif (!arg)\n\t\treturn;\n\n\tUNUSED_ARG(s);\n\tUNUSED_ARG(event_type);\n\n\tts_ur_super_session* ss = (ts_ur_super_session*)arg;\n\n\tturn_turnserver *server = (turn_turnserver*)ss->server;\n\n\tif (!server) {\n\t\treturn;\n\t}\n\n\tif (ss->client_socket != s) {\n\t\treturn;\n\t}\n\n\tread_client_connection(server, ss, data, can_resume, 1);\n\n\tif (ss->to_be_closed) {\n\t\tif(server->verbose) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\"session %018llu: client socket to be closed in client handler: ss=0x%lx\\n\", (unsigned long long)(ss->id), (long)ss);\n\t\t}\n\t\tset_ioa_socket_tobeclosed(s);\n\t}\n}\n\n///////////////////////////////////////////////////////////\n\nvoid init_turn_server(turn_turnserver* server,\n\t\tturnserver_id id, int verbose, ioa_engine_handle e, turn_credential_type ct,\n\t\tint stun_port, int fingerprint, dont_fragment_option_t dont_fragment,\n\t\tget_user_key_cb userkeycb,\n\t\tcheck_new_allocation_quota_cb chquotacb,\n\t\trelease_allocation_quota_cb raqcb,\n\t\tioa_addr *external_ip,\n\t\tvintp check_origin,\n\t\tvintp no_tcp_relay,\n\t\tvintp no_udp_relay,\n\t\tvintp stale_nonce,\n\t\tvintp max_allocate_lifetime,\n\t\tvintp channel_lifetime,\n\t\tvintp permission_lifetime,\n\t\tvintp stun_only,\n\t\tvintp no_stun,\n\t\tvintp no_software_attribute,\n\t\tvintp web_admin_listen_on_workers,\n\t\tturn_server_addrs_list_t *alternate_servers_list,\n\t\tturn_server_addrs_list_t *tls_alternate_servers_list,\n\t\tturn_server_addrs_list_t *aux_servers_list,\n\t\tint self_udp_balance,\n\t\tvintp no_multicast_peers, vintp allow_loopback_peers,\n\t\tip_range_list_t* ip_whitelist, ip_range_list_t* ip_blacklist,\n\t\tsend_socket_to_relay_cb send_socket_to_relay,\n\t\tvintp secure_stun, vintp mobility, int server_relay,\n\t\tsend_turn_session_info_cb send_turn_session_info,\n\t\tsend_https_socket_cb send_https_socket,\n\t\tallocate_bps_cb allocate_bps_func,\n\t\tint oauth,\n\t\tconst char* oauth_server_name,\n\t\tconst char* acme_redirect,\n\t\tint keep_address_family,\n\t\tvintp log_binding) {\n\n\tif (!server)\n\t\treturn;\n\n\tbzero(server,sizeof(turn_turnserver));\n\n\tserver->e = e;\n\tserver->id = id;\n\tserver->ctime = turn_time();\n\tserver->session_id_counter = 0;\n\tserver->sessions_map = ur_map_create();\n\tserver->tcp_relay_connections = ur_map_create();\n\tserver->ct = ct;\n\tserver->userkeycb = userkeycb;\n\tserver->chquotacb = chquotacb;\n\tserver->raqcb = raqcb;\n\tserver->no_multicast_peers = no_multicast_peers;\n\tserver->allow_loopback_peers = allow_loopback_peers;\n\tserver->secure_stun = secure_stun;\n\tserver->mobility = mobility;\n\tserver->server_relay = server_relay;\n\tserver->send_turn_session_info = send_turn_session_info;\n\tserver->send_https_socket = send_https_socket;\n\tserver->oauth = oauth;\n\tif(oauth)\n\t\tserver->oauth_server_name = oauth_server_name;\n\tif(mobility)\n\t\tserver->mobile_connections_map = ur_map_create();\n\tserver->acme_redirect = acme_redirect;\n\n\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"turn server id=%d created\\n\",(int)id);\n\n\tserver->check_origin = check_origin;\n\tserver->no_tcp_relay = no_tcp_relay;\n\tserver->no_udp_relay = no_udp_relay;\n\n\tserver->alternate_servers_list = alternate_servers_list;\n\tserver->tls_alternate_servers_list = tls_alternate_servers_list;\n\tserver->aux_servers_list = aux_servers_list;\n\tserver->self_udp_balance = self_udp_balance;\n\n\tserver->stale_nonce = stale_nonce;\n\tserver->max_allocate_lifetime = max_allocate_lifetime;\n\tserver->channel_lifetime = channel_lifetime;\n\tserver->permission_lifetime = permission_lifetime;\n\tserver->stun_only = stun_only;\n\tserver->no_stun = no_stun;\n\tserver->no_software_attribute = no_software_attribute;\n\tserver-> web_admin_listen_on_workers = web_admin_listen_on_workers;\n\n\tserver->dont_fragment = dont_fragment;\n\tserver->fingerprint = fingerprint;\n\tif(external_ip) {\n\t\taddr_cpy(&(server->external_ip), external_ip);\n\t\tserver->external_ip_set = 1;\n\t}\n\tif (stun_port < 1)\n\t\tstun_port = DEFAULT_STUN_PORT;\n\n\tserver->verbose = verbose;\n\n\tserver->ip_whitelist = ip_whitelist;\n\tserver->ip_blacklist = ip_blacklist;\n\n\tserver->send_socket_to_relay = send_socket_to_relay;\n\n\tserver->allocate_bps_func = allocate_bps_func;\n\n\tserver->keep_address_family = keep_address_family;\n\n\tset_ioa_timer(server->e, 1, 0, timer_timeout_handler, server, 1, \"timer_timeout_handler\");\n\n\tserver->log_binding = log_binding;\n}\n\nioa_engine_handle turn_server_get_engine(turn_turnserver *s) {\n\tif(s)\n\t\treturn s->e;\n\treturn NULL;\n}\n\nvoid set_disconnect_cb(turn_turnserver* server, int(*disconnect)(\n\t\tts_ur_super_session*)) {\n\tserver->disconnect = disconnect;\n}\n\n//////////////////////////////////////////////////////////////////\n"], "fixing_code": ["/*\n * Copyright (C) 2011, 2012, 2013 Citrix Systems\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"ns_turn_ioaddr.h\"\n#include <netdb.h>\n#include <string.h>\n\n//////////////////////////////////////////////////////////////\n\nuint32_t get_ioa_addr_len(const ioa_addr* addr) {\n  if(addr->ss.sa_family == AF_INET) return sizeof(struct sockaddr_in);\n  else if(addr->ss.sa_family == AF_INET6) return sizeof(struct sockaddr_in6);\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////\n\nvoid addr_set_any(ioa_addr *addr) {\n\tif(addr)\n\t\tbzero(addr,sizeof(ioa_addr));\n}\n\nint addr_any(const ioa_addr* addr) {\n\n\tif(!addr)\n\t\treturn 1;\n\n  if(addr->ss.sa_family == AF_INET) {\n    return ((addr->s4.sin_addr.s_addr==0)&&(addr->s4.sin_port==0));\n  } else if(addr->ss.sa_family == AF_INET6) {\n    if(addr->s6.sin6_port!=0) return 0;\n    else {\n      size_t i;\n      for(i=0;i<sizeof(addr->s6.sin6_addr);i++) \n\tif(((const char*)&(addr->s6.sin6_addr))[i]) return 0;\n    }\n  }\n\n  return 1;\n}\n\nint addr_any_no_port(const ioa_addr* addr) {\n\tif(!addr)\n\t\treturn 1;\n\n  if(addr->ss.sa_family == AF_INET) {\n    return (addr->s4.sin_addr.s_addr==0);\n  } else if(addr->ss.sa_family == AF_INET6) {\n    size_t i;\n    for(i=0;i<sizeof(addr->s6.sin6_addr);i++) \n      if(((const char*)(&(addr->s6.sin6_addr)))[i]) return 0;\n  }\n\n  return 1;\n}\n\nuint32_t hash_int32(uint32_t a)\n{\n\ta = a ^ (a>>4);\n\ta = (a^0xdeadbeef) + (a<<5);\n\ta = a ^ (a>>11);\n\treturn a;\n}\n\nuint64_t hash_int64(uint64_t a)\n{\n\ta = a ^ (a>>4);\n\ta = (a^0xdeadbeefdeadbeefLL) + (a<<5);\n\ta = a ^ (a>>11);\n\treturn a;\n}\n\nuint32_t addr_hash(const ioa_addr *addr)\n{\n\tif(!addr)\n\t\treturn 0;\n\n\tuint32_t ret = 0;\n\tif (addr->ss.sa_family == AF_INET) {\n\t\tret = hash_int32(addr->s4.sin_addr.s_addr + addr->s4.sin_port);\n\t} else {\n\t\tuint64_t a[2];\n\t\tbcopy(&(addr->s6.sin6_addr), &a, sizeof(a));\n\t\tret = (uint32_t)((hash_int64(a[0])<<3) + (hash_int64(a[1] + addr->s6.sin6_port)));\n\t}\n\treturn ret;\n}\n\nuint32_t addr_hash_no_port(const ioa_addr *addr)\n{\n\tif(!addr)\n\t\treturn 0;\n\n\tuint32_t ret = 0;\n\tif (addr->ss.sa_family == AF_INET) {\n\t\tret = hash_int32(addr->s4.sin_addr.s_addr);\n\t} else {\n\t\tuint64_t a[2];\n\t\tbcopy(&(addr->s6.sin6_addr), &a, sizeof(a));\n\t\tret = (uint32_t)((hash_int64(a[0])<<3) + (hash_int64(a[1])));\n\t}\n\treturn ret;\n}\n\nvoid addr_cpy(ioa_addr* dst, const ioa_addr* src) {\n\tif(dst && src)\n\t\tbcopy(src,dst,sizeof(ioa_addr));\n}\n\nvoid addr_cpy4(ioa_addr* dst, const struct sockaddr_in* src) {\n\tif(src && dst)\n\t\tbcopy(src,dst,sizeof(struct sockaddr_in));\n}\n\nvoid addr_cpy6(ioa_addr* dst, const struct sockaddr_in6* src) {\n\tif(src && dst)\n\t\tbcopy(src,dst,sizeof(struct sockaddr_in6));\n}\n\nint addr_eq(const ioa_addr* a1, const ioa_addr *a2) {\n\n  if(!a1) return (!a2);\n  else if(!a2) return (!a1);\n\n  if(a1->ss.sa_family == a2->ss.sa_family) {\n    if(a1->ss.sa_family == AF_INET && a1->s4.sin_port == a2->s4.sin_port) {\n      if((int)a1->s4.sin_addr.s_addr == (int)a2->s4.sin_addr.s_addr) {\n\treturn 1;\n      }\n    } else if(a1->ss.sa_family == AF_INET6 && a1->s6.sin6_port == a2->s6.sin6_port) {\n        if( memcmp(&(a1->s6.sin6_addr), &(a2->s6.sin6_addr) ,sizeof(struct in6_addr)) == 0 ) {\n        return 1;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint addr_eq_no_port(const ioa_addr* a1, const ioa_addr *a2) {\n\n  if(!a1) return (!a2);\n  else if(!a2) return (!a1);\n  \n  if(a1->ss.sa_family == a2->ss.sa_family) {\n    if(a1->ss.sa_family == AF_INET) {\n      if((int)a1->s4.sin_addr.s_addr == (int)a2->s4.sin_addr.s_addr) {\n\treturn 1;\n      }\n    } else if(a1->ss.sa_family == AF_INET6) {\n      if( memcmp(&(a1->s6.sin6_addr), &(a2->s6.sin6_addr) ,sizeof(struct in6_addr)) == 0 ) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint make_ioa_addr(const uint8_t* saddr0, int port, ioa_addr *addr) {\n\n  if(!saddr0 || !addr) return -1;\n\n  char ssaddr[257];\n  STRCPY(ssaddr,saddr0);\n\n  char* saddr=ssaddr;\n  while(*saddr == ' ') ++saddr;\n\n  size_t len=strlen(saddr);\n  while(len>0) {\n\t  if(saddr[len-1]==' ') {\n\t\t  saddr[len-1]=0;\n\t\t  --len;\n\t  } else {\n\t\t  break;\n\t  }\n  }\n\n  bzero(addr, sizeof(ioa_addr));\n  if((len == 0)||\n     (inet_pton(AF_INET, saddr, &addr->s4.sin_addr) == 1)) {\n    addr->s4.sin_family = AF_INET;\n#if defined(TURN_HAS_SIN_LEN) /* tested when configured */\n    addr->s4.sin_len = sizeof(struct sockaddr_in);\n#endif\n    addr->s4.sin_port = nswap16(port);\n  } else if (inet_pton(AF_INET6, saddr, &addr->s6.sin6_addr) == 1) {\n    addr->s6.sin6_family = AF_INET6;\n#if defined(SIN6_LEN) /* this define is required by IPv6 if used */\n    addr->s6.sin6_len = sizeof(struct sockaddr_in6);\n#endif\n    addr->s6.sin6_port = nswap16(port);\n  } else {\n    struct addrinfo addr_hints;\n    struct addrinfo *addr_result = NULL;\n    int err;\n\n    memset(&addr_hints, 0, sizeof(struct addrinfo));\n    addr_hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n    addr_hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n    addr_hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n    addr_hints.ai_protocol = 0;          /* Any protocol */\n    addr_hints.ai_canonname = NULL;\n    addr_hints.ai_addr = NULL;\n    addr_hints.ai_next = NULL;\n\n    err = getaddrinfo(saddr, NULL, &addr_hints, &addr_result);\n    if ((err != 0)||(!addr_result)) {\n      fprintf(stderr,\"error resolving '%s' hostname: %s\\n\",saddr,gai_strerror(err));\n      return -1;\n    }\n    \n    int family = AF_INET;\n    struct addrinfo *addr_result_orig = addr_result;\n    int found = 0;\n\n    beg_af:\n\n    while(addr_result) {\n\n    \tif(addr_result->ai_family == family) {\n    \t\tif (addr_result->ai_family == AF_INET) {\n    \t\t\tbcopy(addr_result->ai_addr, addr, addr_result->ai_addrlen);\n    \t\t\taddr->s4.sin_port = nswap16(port);\n#if defined(TURN_HAS_SIN_LEN) /* tested when configured */\n    \t\t\taddr->s4.sin_len = sizeof(struct sockaddr_in);\n#endif\n    \t\t\tfound = 1;\n    \t\t\tbreak;\n    \t\t} else if (addr_result->ai_family == AF_INET6) {\n    \t\t\tbcopy(addr_result->ai_addr, addr, addr_result->ai_addrlen);\n    \t\t\taddr->s6.sin6_port = nswap16(port);\n#if defined(SIN6_LEN) /* this define is required by IPv6 if used */\n    \t\t\taddr->s6.sin6_len = sizeof(struct sockaddr_in6);\n#endif\n    \t\t\tfound = 1;\n    \t\t\tbreak;\n    \t\t}\n    \t}\n\n    \taddr_result = addr_result->ai_next;\n    }\n\n    if(!found && family == AF_INET) {\n    \tfamily = AF_INET6;\n    \taddr_result = addr_result_orig;\n    \tgoto beg_af;\n    }\n    \n    freeaddrinfo(addr_result_orig);\n  }\n\n  return 0;\n}\n\nstatic char* get_addr_string_and_port(char* s0, int *port)\n{\n\tchar *s = s0;\n\twhile(*s && (*s==' ')) ++s;\n\tif(*s == '[') {\n\t\t++s;\n\t\tchar *tail = strstr(s,\"]\");\n\t\tif(tail) {\n\t\t\t*tail=0;\n\t\t\t++tail;\n\t\t\twhile(*tail && (*tail==' ')) ++tail;\n\t\t\tif(*tail==':') {\n\t\t\t\t++tail;\n\t\t\t\t*port = atoi(tail);\n\t\t\t\treturn s;\n\t\t\t} else if(*tail == 0) {\n\t\t\t\t*port = 0;\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tchar *tail = strstr(s,\":\");\n\t\tif(tail) {\n\t\t\t*tail = 0;\n\t\t\t++tail;\n\t\t\t*port = atoi(tail);\n\t\t\treturn s;\n\t\t} else {\n\t\t\t*port = 0;\n\t\t\treturn s;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint make_ioa_addr_from_full_string(const uint8_t* saddr, int default_port, ioa_addr *addr)\n{\n\tif(!addr)\n\t\treturn -1;\n\n\tint ret = -1;\n\tint port = 0;\n\tchar* s = strdup((const char*)saddr);\n\tchar *sa = get_addr_string_and_port(s,&port);\n\tif(sa) {\n\t\tif(port<1)\n\t\t\tport = default_port;\n\t\tret = make_ioa_addr((uint8_t*)sa,port,addr);\n\t}\n\tfree(s);\n\treturn ret;\n}\n\nint addr_to_string(const ioa_addr* addr, uint8_t* saddr)\n{\n\n\tif (addr && saddr) {\n\n\t\tchar addrtmp[INET6_ADDRSTRLEN];\n\n\t\tif (addr->ss.sa_family == AF_INET) {\n\t\t\tinet_ntop(AF_INET, &addr->s4.sin_addr, addrtmp, INET_ADDRSTRLEN);\n\t\t\tif(addr_get_port(addr)>0)\n\t\t\t  snprintf((char*)saddr, MAX_IOA_ADDR_STRING, \"%s:%d\", addrtmp, addr_get_port(addr));\n\t\t\telse\n\t\t\t  strncpy((char*)saddr, addrtmp, MAX_IOA_ADDR_STRING);\n\t\t} else if (addr->ss.sa_family == AF_INET6) {\n\t\t\tinet_ntop(AF_INET6, &addr->s6.sin6_addr, addrtmp, INET6_ADDRSTRLEN);\n\t\t\tif(addr_get_port(addr)>0)\n\t\t\t  snprintf((char*)saddr, MAX_IOA_ADDR_STRING, \"[%s]:%d\", addrtmp, addr_get_port(addr));\n\t\t\telse\n\t\t\t  strncpy((char*)saddr, addrtmp, MAX_IOA_ADDR_STRING);\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nint addr_to_string_no_port(const ioa_addr* addr, uint8_t* saddr)\n{\n\n\tif (addr && saddr) {\n\n\t\tchar addrtmp[MAX_IOA_ADDR_STRING];\n\n\t\tif (addr->ss.sa_family == AF_INET) {\n\t\t\tinet_ntop(AF_INET, &addr->s4.sin_addr, addrtmp, INET_ADDRSTRLEN);\n\t\t\tstrncpy((char*)saddr, addrtmp, MAX_IOA_ADDR_STRING);\n\t\t} else if (addr->ss.sa_family == AF_INET6) {\n\t\t\tinet_ntop(AF_INET6, &addr->s6.sin6_addr, addrtmp, INET6_ADDRSTRLEN);\n\t\t\tstrncpy((char*)saddr, addrtmp, MAX_IOA_ADDR_STRING);\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nvoid addr_set_port(ioa_addr* addr, int port) {\n  if(addr) {\n    if(addr->s4.sin_family == AF_INET) {\n      addr->s4.sin_port = nswap16(port);\n    } else if(addr->s6.sin6_family == AF_INET6) {\n      addr->s6.sin6_port = nswap16(port);\n    }\n  }\n}\n\nint addr_get_port(const ioa_addr* addr) {\n\tif(!addr)\n\t\treturn 0;\n\n  if(addr->s4.sin_family == AF_INET) {\n    return nswap16(addr->s4.sin_port);\n  } else if(addr->s6.sin6_family == AF_INET6) {\n    return nswap16(addr->s6.sin6_port);\n  }\n  return 0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\nvoid ioa_addr_range_set(ioa_addr_range* range, const ioa_addr* addr_min, const ioa_addr* addr_max) {\n  if(range) {\n    if(addr_min) addr_cpy(&(range->min),addr_min);\n    else addr_set_any(&(range->min));\n    if(addr_max) addr_cpy(&(range->max),addr_max);\n    else addr_set_any(&(range->max));\n  }\n}\n\nint addr_less_eq(const ioa_addr* addr1, const ioa_addr* addr2) {\n\n  if(!addr1) return 1;\n  else if(!addr2) return 0;\n  else {\n    if(addr1->ss.sa_family != addr2->ss.sa_family) return (addr1->ss.sa_family < addr2->ss.sa_family);\n    else if(addr1->ss.sa_family == AF_INET) {\n      return ((uint32_t)nswap32(addr1->s4.sin_addr.s_addr) <= (uint32_t)nswap32(addr2->s4.sin_addr.s_addr));\n    } else if(addr1->ss.sa_family == AF_INET6) {\n      int i;\n      for(i=0;i<16;i++) {\n\tif((uint8_t)(((const char*)&(addr1->s6.sin6_addr))[i]) > (uint8_t)(((const char*)&(addr2->s6.sin6_addr))[i])) \n\t  return 0;\n      }\n      return 1;\n    } else return 1;\n  }\n}\n\nint ioa_addr_in_range(const ioa_addr_range* range, const ioa_addr* addr) {\n\n  if(range && addr) {\n    if(addr_any(&(range->min)) || addr_less_eq(&(range->min),addr)) {\n      if(addr_any(&(range->max))) {\n\treturn 1;\n      } else {\n\treturn addr_less_eq(addr,&(range->max));\n      }\n    }\n  }\n\n  return 0;\n}\n\nvoid ioa_addr_range_cpy(ioa_addr_range* dest, const ioa_addr_range* src) {\n  if(dest && src) {\n    addr_cpy(&(dest->min),&(src->min));\n    addr_cpy(&(dest->max),&(src->max));\n  }\n}\n\n/////// Check whether this is a good address //////////////\n\nint ioa_addr_is_multicast(ioa_addr *addr)\n{\n\tif(addr) {\n\t\tif(addr->ss.sa_family == AF_INET) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s4.sin_addr));\n\t\t\treturn (u[0] > 223);\n\t\t} else if(addr->ss.sa_family == AF_INET6) {\n\t\t\tuint8_t u = ((const uint8_t*)&(addr->s6.sin6_addr))[0];\n\t\t\treturn (u == 255);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint ioa_addr_is_loopback(ioa_addr *addr)\n{\n\tif(addr) {\n\t\tif(addr->ss.sa_family == AF_INET) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s4.sin_addr));\n\t\t\treturn (u[0] == 127);\n\t\t} else if(addr->ss.sa_family == AF_INET6) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s6.sin6_addr));\n\t\t\tif(u[15] == 1) {\n\t\t\t\tint i;\n\t\t\t\tfor(i=0;i<15;++i) {\n\t\t\t\t\tif(u[i])\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\nTo avoid a vulnerability this function checks whether the addr is in 0.0.0.0/8 or ::/128.\nSource from (INADDR_ANY) 0.0.0.0/32 and (in6addr_any) ::/128 routed to loopback on Linux systems for old BSD backward compatibility.\nhttps://github.com/torvalds/linux/blob/a2f5ea9e314ba6778f885c805c921e9362ec0420/net/ipv6/tcp_ipv6.c#L182\nTo avoid any trouble we match the whole 0.0.0.0/8 that defined in RFC6890 as local network \"this\".\n*/\nint ioa_addr_is_zero(ioa_addr *addr)\n{\n\tif(addr) {\n\t\tif(addr->ss.sa_family == AF_INET) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s4.sin_addr));\n\t\t\treturn (u[0] == 0);\n\t\t} else if(addr->ss.sa_family == AF_INET6) {\n\t\t\tconst uint8_t *u = ((const uint8_t*)&(addr->s6.sin6_addr));\n\t\t\tint i;\n\t\t\tfor(i=0;i<=15;++i) {\n\t\t\t\tif(u[i])\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/////// Map \"public\" address to \"private\" address //////////////\n\n// Must be called only in a single-threaded context,\n// before the program starts spawning threads:\n\nstatic ioa_addr **public_addrs = NULL;\nstatic ioa_addr **private_addrs = NULL;\nstatic size_t mcount = 0;\nstatic size_t msz = 0;\n\nvoid ioa_addr_add_mapping(ioa_addr *apub, ioa_addr *apriv)\n{\n\tsize_t new_size = msz + sizeof(ioa_addr*);\n\tpublic_addrs = (ioa_addr**)realloc(public_addrs, new_size);\n\tprivate_addrs = (ioa_addr**)realloc(private_addrs, new_size);\n\tpublic_addrs[mcount]=(ioa_addr*)malloc(sizeof(ioa_addr));\n\tprivate_addrs[mcount]=(ioa_addr*)malloc(sizeof(ioa_addr));\n\taddr_cpy(public_addrs[mcount],apub);\n\taddr_cpy(private_addrs[mcount],apriv);\n\t++mcount;\n\tmsz += sizeof(ioa_addr*);\n}\n\nvoid map_addr_from_public_to_private(const ioa_addr *public_addr, ioa_addr *private_addr)\n{\n\tsize_t i;\n\tfor(i=0;i<mcount;++i) {\n\t\tif(addr_eq_no_port(public_addr,public_addrs[i])) {\n\t\t\taddr_cpy(private_addr,private_addrs[i]);\n\t\t\taddr_set_port(private_addr,addr_get_port(public_addr));\n\t\t\treturn;\n\t\t}\n\t}\n\taddr_cpy(private_addr,public_addr);\n}\n\nvoid map_addr_from_private_to_public(const ioa_addr *private_addr, ioa_addr *public_addr)\n{\n\tsize_t i;\n\tfor(i=0;i<mcount;++i) {\n\t\tif(addr_eq_no_port(private_addr,private_addrs[i])) {\n\t\t\taddr_cpy(public_addr,public_addrs[i]);\n\t\t\taddr_set_port(public_addr,addr_get_port(private_addr));\n\t\t\treturn;\n\t\t}\n\t}\n\taddr_cpy(public_addr,private_addr);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n", "/*\n * Copyright (C) 2011, 2012, 2013 Citrix Systems\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef __IOADDR__\n#define __IOADDR__\n\n#include \"ns_turn_defs.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/////////////////////////////////////////////////////\n\n#define MAX_IOA_ADDR_STRING (65)\n\ntypedef union {\n  struct sockaddr ss;\n  struct sockaddr_in s4;\n  struct sockaddr_in6 s6;\n} ioa_addr;\n\ntypedef struct {\n  ioa_addr min;\n  ioa_addr max;\n} ioa_addr_range;\n\n////////////////////////////\n\nuint32_t get_ioa_addr_len(const ioa_addr* addr);\n\n////////////////////////////\n\nvoid addr_set_any(ioa_addr *addr);\nint addr_any(const ioa_addr* addr);\nint addr_any_no_port(const ioa_addr* addr);\nuint32_t addr_hash(const ioa_addr *addr);\nuint32_t addr_hash_no_port(const ioa_addr *addr);\nvoid addr_cpy(ioa_addr* dst, const ioa_addr* src);\nvoid addr_cpy4(ioa_addr* dst, const struct sockaddr_in* src);\nvoid addr_cpy6(ioa_addr* dst, const struct sockaddr_in6* src);\nint addr_eq(const ioa_addr* a1, const ioa_addr *a2);\nint addr_eq_no_port(const ioa_addr* a1, const ioa_addr *a2);\nint make_ioa_addr(const uint8_t* saddr, int port, ioa_addr *addr);\nint make_ioa_addr_from_full_string(const uint8_t* saddr, int default_port, ioa_addr *addr);\nvoid addr_set_port(ioa_addr* addr, int port);\nint addr_get_port(const ioa_addr* addr);\nint addr_to_string(const ioa_addr* addr, uint8_t* saddr);\nint addr_to_string_no_port(const ioa_addr* addr, uint8_t* saddr);\n\nuint32_t hash_int32(uint32_t a);\nuint64_t hash_int64(uint64_t a);\n\n///////////////////////////////////////////\n\nvoid ioa_addr_range_set(ioa_addr_range* range, const ioa_addr* addr_min, const ioa_addr* addr_max);\nint addr_less_eq(const ioa_addr* addr1, const ioa_addr* addr2);\nint ioa_addr_in_range(const ioa_addr_range* range, const ioa_addr* addr);\nvoid ioa_addr_range_cpy(ioa_addr_range* dest, const ioa_addr_range* src);\n\n/////// Check whether this is a good address //////////////\n\nint ioa_addr_is_multicast(ioa_addr *a);\nint ioa_addr_is_loopback(ioa_addr *addr);\nint ioa_addr_is_zero(ioa_addr *addr);\n\n/////// Map \"public\" address to \"private\" address //////////////\n\n// Must be called only in a single-threaded context,\n// before the program starts spawning threads:\n\nvoid ioa_addr_add_mapping(ioa_addr *apub, ioa_addr *apriv);\nvoid map_addr_from_public_to_private(const ioa_addr *public_addr, ioa_addr *private_addr);\nvoid map_addr_from_private_to_public(const ioa_addr *private_addr, ioa_addr *public_addr);\n\n///////////////////////////////////////////\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //__IOADDR__\n", "/*\n * Copyright (C) 2011, 2012, 2013 Citrix Systems\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"ns_turn_server.h\"\n\n#include \"ns_turn_utils.h\"\n#include \"ns_turn_allocation.h\"\n#include \"ns_turn_msg_addr.h\"\n#include \"ns_turn_ioalib.h\"\n#include \"../apps/relay/ns_ioalib_impl.h\"\n\n///////////////////////////////////////////\n\n#define FUNCSTART if(server && eve(server->verbose)) TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"%s:%d:start\\n\",__FUNCTION__,__LINE__)\n#define FUNCEND if(server && eve(server->verbose)) TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"%s:%d:end\\n\",__FUNCTION__,__LINE__)\n\n////////////////////////////////////////////////\n\nstatic inline int get_family(int stun_family, ioa_engine_handle e, ioa_socket_handle client_socket) {\n\tswitch(stun_family) {\n\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4:\n\t\treturn AF_INET;\n\t\tbreak;\n\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6:\n\t\treturn AF_INET6;\n\t\tbreak;\n\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_DEFAULT:\n\t\tif(e->default_relays && get_ioa_socket_address_family(client_socket) == AF_INET6)\n\t\t\t\treturn AF_INET6;\n\t\telse\n\t\t\t\treturn AF_INET;\n\tdefault:\n\t\treturn AF_INET;\n\t};\n}\n\n////////////////////////////////////////////////\n\nconst char * get_version(turn_turnserver *server) {\n\tif(server && !*server->no_software_attribute) {\n\t\treturn (const char *) TURN_SOFTWARE;\n\t} else {\n\t\treturn (const char *) \"None\";\n\t}\n}\n\n#define MAX_NUMBER_OF_UNKNOWN_ATTRS (128)\n\nint TURN_MAX_ALLOCATE_TIMEOUT = 60;\nint TURN_MAX_ALLOCATE_TIMEOUT_STUN_ONLY = 3;\n\nstatic inline void log_method(ts_ur_super_session* ss, const char *method, int err_code, const uint8_t *reason)\n{\n  if(ss) {\n\t  if(!method) method = \"unknown\";\n\t  if(!err_code) {\n\t\t  if(ss->origin[0]) {\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\"session %018llu: origin <%s> realm <%s> user <%s>: incoming packet %s processed, success\\n\",\n\t\t\t\t\t(unsigned long long)(ss->id), (const char*)(ss->origin),(const char*)(ss->realm_options.name),(const char*)(ss->username),method);\n\t\t} else {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\"session %018llu: realm <%s> user <%s>: incoming packet %s processed, success\\n\",\n\t\t\t\t(unsigned long long)(ss->id), (const char*)(ss->realm_options.name),(const char*)(ss->username),method);\n\t\t}\n\t  } else {\n\t\t  if(!reason) reason=get_default_reason(err_code);\n\t\t  if(ss->origin[0]) {\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t  \"session %018llu: origin <%s> realm <%s> user <%s>: incoming packet %s processed, error %d: %s\\n\",\n\t\t\t\t\t  (unsigned long long)(ss->id), (const char*)(ss->origin),(const char*)(ss->realm_options.name),(const char*)(ss->username), method, err_code, reason);\n\t\t  } else {\n\t\t\t  TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t  \"session %018llu: realm <%s> user <%s>: incoming packet %s processed, error %d: %s\\n\",\n\t\t\t\t\t  (unsigned long long)(ss->id), (const char*)(ss->realm_options.name),(const char*)(ss->username), method, err_code, reason);\n\t\t  }\n\t  }\n  }\n}\n\n///////////////////////////////////////////\n\nstatic int attach_socket_to_session(turn_turnserver* server, ioa_socket_handle s, ts_ur_super_session* ss);\n\nstatic int check_stun_auth(turn_turnserver *server,\n\t\t\tts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\tint *err_code, \tconst uint8_t **reason,\n\t\t\tioa_net_data *in_buffer, ioa_network_buffer_handle nbh,\n\t\t\tuint16_t method, int *message_integrity,\n\t\t\tint *postpone_reply,\n\t\t\tint can_resume);\n\nstatic int create_relay_connection(turn_turnserver* server,\n\t\tts_ur_super_session *ss, uint32_t lifetime,\n\t\tint address_family, uint8_t transport,\n\t\tint even_port, uint64_t in_reservation_token, uint64_t *out_reservation_token,\n\t\tint *err_code, const uint8_t **reason, accept_cb acb);\n\nstatic int refresh_relay_connection(turn_turnserver* server,\n\t\tts_ur_super_session *ss, uint32_t lifetime, int even_port,\n\t\tuint64_t in_reservation_token, uint64_t *out_reservation_token,\n\t\tint *err_code, int family);\n\nstatic int write_client_connection(turn_turnserver *server, ts_ur_super_session* ss, ioa_network_buffer_handle nbh, int ttl, int tos);\n\nstatic void tcp_peer_accept_connection(ioa_socket_handle s, void *arg);\n\nstatic int read_client_connection(turn_turnserver *server,\n\t\t\t\t  ts_ur_super_session *ss, ioa_net_data *in_buffer,\n\t\t\t\t  int can_resume, int count_usage);\n\nstatic int need_stun_authentication(turn_turnserver *server, ts_ur_super_session *ss);\n\n/////////////////// timer //////////////////////////\n\nstatic void timer_timeout_handler(ioa_engine_handle e, void *arg)\n{\n\tUNUSED_ARG(e);\n\tif(arg) {\n\t\tturn_turnserver *server=(turn_turnserver*)arg;\n\t\tserver->ctime = turn_time();\n\t}\n}\n\nturn_time_t get_turn_server_time(turn_turnserver *server)\n{\n\tif(server) {\n\t\treturn server->ctime;\n\t}\n\treturn turn_time();\n}\n\n/////////////////// quota //////////////////////\n\nstatic int inc_quota(ts_ur_super_session* ss, uint8_t *username)\n{\n\tif(ss && !(ss->quota_used) && ss->server && ((turn_turnserver*)ss->server)->chquotacb && username) {\n\n\t\tif(((turn_turnserver*)ss->server)->ct == TURN_CREDENTIALS_LONG_TERM) {\n\t\t\tif(!(ss->origin_set)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif((((turn_turnserver*)ss->server)->chquotacb)(username, ss->oauth, (uint8_t*)ss->realm_options.name)<0) {\n\n\t\t\treturn -1;\n\n\t\t} else {\n\n\t\t\tSTRCPY(ss->username,username);\n\n\t\t\tss->quota_used = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void dec_quota(ts_ur_super_session* ss)\n{\n\tif(ss && ss->quota_used && ss->server && ((turn_turnserver*)ss->server)->raqcb) {\n\n\t\tss->quota_used = 0;\n\n\t\t(((turn_turnserver*)ss->server)->raqcb)(ss->username, ss->oauth, (uint8_t*)ss->realm_options.name);\n\t}\n}\n\nstatic void dec_bps(ts_ur_super_session* ss)\n{\n\tif(ss && ss->server) {\n\n\t\tif(ss->bps) {\n\t\t\tif(((turn_turnserver*)ss->server)->allocate_bps_func) {\n\t\t\t\t((turn_turnserver*)ss->server)->allocate_bps_func(ss->bps,0);\n\t\t\t}\n\t\t\tss->bps = 0;\n\t\t}\n\t}\n}\n\n/////////////////// server lists ///////////////////\n\nvoid init_turn_server_addrs_list(turn_server_addrs_list_t *l)\n{\n\tif(l) {\n\t\tl->addrs = NULL;\n\t\tl->size = 0;\n\t\tturn_mutex_init(&(l->m));\n\t}\n}\n\n/////////////////// RFC 5780 ///////////////////////\n\nvoid set_rfc5780(turn_turnserver *server, get_alt_addr_cb cb, send_message_cb smcb)\n{\n\tif(server) {\n\t\tif(!cb || !smcb) {\n\t\t\tserver->rfc5780 = 0;\n\t\t\tserver->alt_addr_cb = NULL;\n\t\t\tserver->sm_cb = NULL;\n\t\t} else {\n\t\t\tserver->rfc5780 = 1;\n\t\t\tserver->alt_addr_cb = cb;\n\t\t\tserver->sm_cb = smcb;\n\t\t}\n\t}\n}\n\nstatic int is_rfc5780(turn_turnserver *server)\n{\n\tif(!server)\n\t\treturn 0;\n\n\treturn ((server->rfc5780) && (server->alt_addr_cb));\n}\n\nstatic int get_other_address(turn_turnserver *server, ts_ur_super_session *ss, ioa_addr *alt_addr)\n{\n\tif(is_rfc5780(server) && ss && ss->client_socket) {\n\t\tint ret = server->alt_addr_cb(get_local_addr_from_ioa_socket(ss->client_socket), alt_addr);\n\t\treturn ret;\n\t}\n\n\treturn -1;\n}\n\nstatic int send_turn_message_to(turn_turnserver *server, ioa_network_buffer_handle nbh, ioa_addr *response_origin, ioa_addr *response_destination)\n{\n\tif(is_rfc5780(server) && nbh && response_origin && response_destination) {\n\t\treturn server->sm_cb(server->e, nbh, response_origin, response_destination);\n\t}\n\n\treturn -1;\n}\n\n/////////////////// Peer addr check /////////////////////////////\n\nstatic int good_peer_addr(turn_turnserver *server, const char* realm, ioa_addr *peer_addr)\n{\n#define CHECK_REALM(r) if((r)[0] && realm && realm[0] && strcmp((r),realm)) continue\n\n\tif(server && peer_addr) {\n\t\tif(*(server->no_multicast_peers) && ioa_addr_is_multicast(peer_addr))\n\t\t\treturn 0;\n\t\tif( !*(server->allow_loopback_peers) && ioa_addr_is_loopback(peer_addr))\n\t\t\treturn 0;\n\t\tif (ioa_addr_is_zero(peer_addr))\n\t\t\treturn 0;\n\n\t\t{\n\t\t\tint i;\n\n\t\t\tif(server->ip_whitelist) {\n\t\t\t\t// White listing of addr ranges\n\t\t\t\tfor (i = server->ip_whitelist->ranges_number - 1; i >= 0; --i) {\n\t\t\t\t\tCHECK_REALM(server->ip_whitelist->rs[i].realm);\n\t\t\t\t\tif (ioa_addr_in_range(&(server->ip_whitelist->rs[i].enc), peer_addr))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tioa_lock_whitelist(server->e);\n\n\t\t\t\tconst ip_range_list_t* wl = ioa_get_whitelist(server->e);\n\t\t\t\tif(wl) {\n\t\t\t\t\t// White listing of addr ranges\n\t\t\t\t\tfor (i = wl->ranges_number - 1; i >= 0; --i) {\n\t\t\t\t\t\tCHECK_REALM(wl->rs[i].realm);\n\t\t\t\t\t\tif (ioa_addr_in_range(&(wl->rs[i].enc), peer_addr)) {\n\t\t\t\t\t\t\tioa_unlock_whitelist(server->e);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tioa_unlock_whitelist(server->e);\n\t\t\t}\n\n\t\t\tif(server->ip_blacklist) {\n\t\t\t\t// Black listing of addr ranges\n\t\t\t\tfor (i = server->ip_blacklist->ranges_number - 1; i >= 0; --i) {\n\t\t\t\t\tCHECK_REALM(server->ip_blacklist->rs[i].realm);\n\t\t\t\t\tif (ioa_addr_in_range(&(server->ip_blacklist->rs[i].enc), peer_addr)) {\n\t\t\t\t\t\tchar saddr[129];\n\t\t\t\t\t\taddr_to_string_no_port(peer_addr,(uint8_t*)saddr);\n\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"A peer IP %s denied in the range: %s\\n\",saddr,server->ip_blacklist->rs[i].str);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tioa_lock_blacklist(server->e);\n\n\t\t\t\tconst ip_range_list_t* bl = ioa_get_blacklist(server->e);\n\t\t\t\tif(bl) {\n\t\t\t\t\t// Black listing of addr ranges\n\t\t\t\t\tfor (i = bl->ranges_number - 1; i >= 0; --i) {\n\t\t\t\t\t\tCHECK_REALM(bl->rs[i].realm);\n\t\t\t\t\t\tif (ioa_addr_in_range(&(bl->rs[i].enc), peer_addr)) {\n\t\t\t\t\t\t\tioa_unlock_blacklist(server->e);\n\t\t\t\t\t\t\tchar saddr[129];\n\t\t\t\t\t\t\taddr_to_string_no_port(peer_addr,(uint8_t*)saddr);\n\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"A peer IP %s denied in the range: %s\\n\",saddr,bl->rs[i].str);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tioa_unlock_blacklist(server->e);\n\t\t\t}\n\t\t}\n\t}\n\n#undef CHECK_REALM\n\n\treturn 1;\n}\n\n/////////////////// Allocation //////////////////////////////////\n\nallocation* get_allocation_ss(ts_ur_super_session *ss) {\n\treturn &(ss->alloc);\n}\n\nstatic inline relay_endpoint_session *get_relay_session_ss(ts_ur_super_session *ss, int family)\n{\n\treturn get_relay_session(&(ss->alloc),family);\n}\n\nstatic inline ioa_socket_handle get_relay_socket_ss(ts_ur_super_session *ss, int family)\n{\n\treturn get_relay_socket(&(ss->alloc),family);\n}\n\n/////////// Session info ///////\n\nvoid turn_session_info_init(struct turn_session_info* tsi) {\n\tif(tsi) {\n\t\tbzero(tsi,sizeof(struct turn_session_info));\n\t}\n}\n\nvoid turn_session_info_clean(struct turn_session_info* tsi) {\n\tif(tsi) {\n\t\tif(tsi->extra_peers_data) {\n\t\t\tfree(tsi->extra_peers_data);\n\t\t}\n\t\tturn_session_info_init(tsi);\n\t}\n}\n\nvoid turn_session_info_add_peer(struct turn_session_info* tsi, ioa_addr *peer)\n{\n\tif(tsi && peer) {\n\t\t{\n\t\t\tsize_t i;\n\t\t\tfor(i=0;i<tsi->main_peers_size;++i) {\n\t\t\t\tif(addr_eq(peer, &(tsi->main_peers_data[i].addr))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(tsi->main_peers_size < TURN_MAIN_PEERS_ARRAY_SIZE) {\n\t\t\t\taddr_cpy(&(tsi->main_peers_data[tsi->main_peers_size].addr),peer);\n\t\t\t\taddr_to_string(&(tsi->main_peers_data[tsi->main_peers_size].addr),\n\t\t\t\t\t(uint8_t*)tsi->main_peers_data[tsi->main_peers_size].saddr);\n\t\t\t\ttsi->main_peers_size += 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif(tsi->extra_peers_data) {\n\t\t\tsize_t sz;\n\t\t\tfor(sz=0;sz<tsi->extra_peers_size;++sz) {\n\t\t\t\tif(addr_eq(peer, &(tsi->extra_peers_data[sz].addr))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttsi->extra_peers_data = (addr_data*)realloc(tsi->extra_peers_data,(tsi->extra_peers_size+1)*sizeof(addr_data));\n\t\taddr_cpy(&(tsi->extra_peers_data[tsi->extra_peers_size].addr),peer);\n\t\taddr_to_string(&(tsi->extra_peers_data[tsi->extra_peers_size].addr),\n\t\t\t       (uint8_t*)tsi->extra_peers_data[tsi->extra_peers_size].saddr);\n\t\ttsi->extra_peers_size += 1;\n\t}\n}\n\nstruct tsi_arg {\n\tstruct turn_session_info* tsi;\n\tioa_addr *addr;\n};\n\nstatic int turn_session_info_foreachcb(ur_map_key_type key, ur_map_value_type value, void *arg)\n{\n\tUNUSED_ARG(value);\n\n\tint port = (int)key;\n\tstruct tsi_arg *ta = (struct tsi_arg *)arg;\n\tif(port && ta && ta->tsi && ta->addr) {\n\t\tioa_addr a;\n\t\taddr_cpy(&a,ta->addr);\n\t\taddr_set_port(&a,port);\n\t\tturn_session_info_add_peer(ta->tsi,&a);\n\t}\n\treturn 0;\n}\n\nint turn_session_info_copy_from(struct turn_session_info* tsi, ts_ur_super_session *ss)\n{\n\tint ret = -1;\n\n\tif(tsi && ss) {\n\t\ttsi->id = ss->id;\n\t\ttsi->bps = ss->bps;\n\t\ttsi->start_time = ss->start_time;\n\t\ttsi->valid = is_allocation_valid(&(ss->alloc)) && !(ss->to_be_closed) && (ss->quota_used);\n\t\tif(tsi->valid) {\n\t\t\tif(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s) {\n\t\t\t\ttsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].expiration_time;\n\t\t\t\tif(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {\n\t\t\t\t\tif(turn_time_before(tsi->expiration_time,ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time)) {\n\t\t\t\t\t\ttsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {\n\t\t\t\ttsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time;\n\t\t\t}\n\t\t\tif(ss->client_socket) {\n\t\t\t\ttsi->client_protocol = get_ioa_socket_type(ss->client_socket);\n\t\t\t\taddr_cpy(&(tsi->local_addr_data.addr),get_local_addr_from_ioa_socket(ss->client_socket));\n\t\t\t\taddr_to_string(&(tsi->local_addr_data.addr),(uint8_t*)tsi->local_addr_data.saddr);\n\t\t\t\taddr_cpy(&(tsi->remote_addr_data.addr),get_remote_addr_from_ioa_socket(ss->client_socket));\n\t\t\t\taddr_to_string(&(tsi->remote_addr_data.addr),(uint8_t*)tsi->remote_addr_data.saddr);\n\t\t\t}\n\t\t\t{\n\t\t\t\tif(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s) {\n\t\t\t\t\ttsi->peer_protocol = get_ioa_socket_type(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s);\n\t\t\t\t\tif(ss->alloc.is_valid) {\n\t\t\t\t\t\taddr_cpy(&(tsi->relay_addr_data_ipv4.addr),get_local_addr_from_ioa_socket(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s));\n\t\t\t\t\t\taddr_to_string(&(tsi->relay_addr_data_ipv4.addr),(uint8_t*)tsi->relay_addr_data_ipv4.saddr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {\n\t\t\t\t\ttsi->peer_protocol = get_ioa_socket_type(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s);\n\t\t\t\t\tif(ss->alloc.is_valid) {\n\t\t\t\t\t\taddr_cpy(&(tsi->relay_addr_data_ipv6.addr),get_local_addr_from_ioa_socket(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s));\n\t\t\t\t\t\taddr_to_string(&(tsi->relay_addr_data_ipv6.addr),(uint8_t*)tsi->relay_addr_data_ipv6.saddr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSTRCPY(tsi->username,ss->username);\n\t\t\ttsi->enforce_fingerprints = ss->enforce_fingerprints;\n\t\t\tSTRCPY(tsi->tls_method, get_ioa_socket_tls_method(ss->client_socket));\n\t\t\tSTRCPY(tsi->tls_cipher, get_ioa_socket_tls_cipher(ss->client_socket));\n\t\t\tSTRCPY(tsi->realm, ss->realm_options.name);\n\t\t\tSTRCPY(tsi->origin, ss->origin);\n\n\t\t\tif(ss->t_received_packets > ss->received_packets)\n\t\t\t\ttsi->received_packets = ss->t_received_packets;\n\t\t\telse\n\t\t\t\ttsi->received_packets = ss->received_packets;\n\n\t\t\tif(ss->t_sent_packets > ss->sent_packets)\n\t\t\t\ttsi->sent_packets = ss->t_sent_packets;\n\t\t\telse\n\t\t\t\ttsi->sent_packets = ss->sent_packets;\n\n\t\t\tif(ss->t_received_bytes > ss->received_bytes)\n\t\t\t\ttsi->received_bytes = ss->t_received_bytes;\n\t\t\telse\n\t\t\t\ttsi->received_bytes = ss->received_bytes;\n\n\t\t\tif(ss->t_sent_bytes > ss->sent_bytes)\n\t\t\t\ttsi->sent_bytes = ss->t_sent_bytes;\n\t\t\telse\n\t\t\t\ttsi->sent_bytes = ss->sent_bytes;\n\n\t\t\tif (ss->t_peer_received_packets > ss->peer_received_packets)\n\t\t\t\ttsi->peer_received_packets = ss->t_peer_received_packets;\n\t\t\telse\n\t\t\t\ttsi->peer_received_packets = ss->peer_received_packets;\n\n\t\t\tif (ss->t_peer_sent_packets > ss->peer_sent_packets)\n\t\t\t\ttsi->peer_sent_packets = ss->t_peer_sent_packets;\n\t\t\telse\n\t\t\t\ttsi->peer_sent_packets = ss->peer_sent_packets;\n\n\t\t\tif (ss->t_peer_received_bytes > ss->peer_received_bytes)\n\t\t\t\ttsi->peer_received_bytes = ss->t_peer_received_bytes;\n\t\t\telse\n\t\t\t\ttsi->peer_received_bytes = ss->peer_received_bytes;\n\n\t\t\tif (ss->t_peer_sent_bytes > ss->peer_sent_bytes)\n\t\t\t\ttsi->peer_sent_bytes = ss->t_peer_sent_bytes;\n\t\t\telse\n\t\t\t\ttsi->peer_sent_bytes = ss->peer_sent_bytes;\n\n\t\t\t{\n\t\t\t\ttsi->received_rate = ss->received_rate;\n\t\t\t\ttsi->sent_rate = ss->sent_rate;\n\t\t\t\ttsi->total_rate = tsi->received_rate + tsi->sent_rate;\n\t\t\t\ttsi->peer_received_rate = ss->peer_received_rate;\n\t\t\t\ttsi->peer_sent_rate = ss->peer_sent_rate;\n\t\t\t\ttsi->peer_total_rate = tsi->peer_received_rate + tsi->peer_sent_rate;\n\t\t\t}\n\n\t\t\ttsi->is_mobile = ss->is_mobile;\n\n\t\t\t{\n\t\t\t\tsize_t i;\n\t\t\t\tfor(i=0;i<TURN_PERMISSION_HASHTABLE_SIZE;++i) {\n\n\t\t\t\t\tturn_permission_array *parray = &(ss->alloc.addr_to_perm.table[i]);\n\n\t\t\t\t\t{\n\t\t\t\t\t\tsize_t j;\n\t\t\t\t\t\tfor(j=0;j<TURN_PERMISSION_ARRAY_SIZE;++j) {\n\t\t\t\t\t\t\tturn_permission_slot* slot = &(parray->main_slots[j]);\n\t\t\t\t\t\t\tif(slot->info.allocated) {\n\t\t\t\t\t\t\t\tturn_session_info_add_peer(tsi,&(slot->info.addr));\n\t\t\t\t\t\t\t\tstruct tsi_arg arg = {\n\t\t\t\t\t\t\t\t\ttsi,\n\t\t\t\t\t\t\t\t\t&(slot->info.addr)\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tlm_map_foreach_arg(&(slot->info.chns), turn_session_info_foreachcb, &arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t{\n\t\t\t\t\t\tturn_permission_slot **slots = parray->extra_slots;\n\t\t\t\t\t\tif(slots) {\n\t\t\t\t\t\t\tsize_t sz = parray->extra_sz;\n\t\t\t\t\t\t\tsize_t j;\n\t\t\t\t\t\t\tfor(j=0;j<sz;++j) {\n\t\t\t\t\t\t\t\tturn_permission_slot* slot = slots[j];\n\t\t\t\t\t\t\t\tif(slot && slot->info.allocated) {\n\t\t\t\t\t\t\t\t\tturn_session_info_add_peer(tsi,&(slot->info.addr));\n\t\t\t\t\t\t\t\t\tstruct tsi_arg arg = {\n\t\t\t\t\t\t\t\t\t\ttsi,\n\t\t\t\t\t\t\t\t\t\t&(slot->info.addr)\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tlm_map_foreach_arg(&(slot->info.chns), turn_session_info_foreachcb, &arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\ttcp_connection_list *tcl = &(ss->alloc.tcs);\n\t\t\t\tif(tcl->elems) {\n\t\t\t\t\tsize_t i;\n\t\t\t\t\tsize_t sz = tcl->sz;\n\t\t\t\t\tfor(i=0;i<sz;++i) {\n\t\t\t\t\t\tif(tcl->elems[i]) {\n\t\t\t\t\t\t\ttcp_connection *tc = tcl->elems[i];\n\t\t\t\t\t\t\tif(tc) {\n\t\t\t\t\t\t\t\tturn_session_info_add_peer(tsi,&(tc->peer_addr));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nint report_turn_session_info(turn_turnserver *server, ts_ur_super_session *ss, int force_invalid)\n{\n\tif(server && ss && server->send_turn_session_info) {\n\t\tstruct turn_session_info tsi;\n\t\tturn_session_info_init(&tsi);\n\t\tif(turn_session_info_copy_from(&tsi,ss)<0) {\n\t\t\tturn_session_info_clean(&tsi);\n\t\t} else {\n\t\t\tif(force_invalid)\n\t\t\t\ttsi.valid = 0;\n\t\t\tif(server->send_turn_session_info(&tsi)<0) {\n\t\t\t\tturn_session_info_clean(&tsi);\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/////////// SS /////////////////\n\nstatic int mobile_id_to_string(mobile_id_t mid, char *dst, size_t dst_sz)\n{\n\tsize_t output_length = 0;\n\n\tif(!dst)\n\t\treturn -1;\n\n\tchar *s = base64_encode((const unsigned char *)&mid,\n\t                    sizeof(mid),\n\t                    &output_length);\n\n\tif(!s)\n\t\treturn -1;\n\n\tif(!output_length || (output_length+1 > dst_sz)) {\n\t\tfree(s);\n\t\treturn -1;\n\t}\n\n\tbcopy(s, dst, output_length);\n\n\tfree(s);\n\n\tdst[output_length] = 0;\n\n\treturn (int)output_length;\n}\n\nstatic mobile_id_t string_to_mobile_id(char* src)\n{\n\tmobile_id_t mid = 0;\n\n\tif(src) {\n\n\t\tsize_t output_length = 0;\n\n\t\tunsigned char *out = base64_decode(src, strlen(src), &output_length);\n\n\t\tif(out) {\n\n\t\t\tif(output_length == sizeof(mid)) {\n\t\t\t\tmid = *((mobile_id_t*)out);\n\t\t\t}\n\n\t\t\tfree(out);\n\t\t}\n\t}\n\n\treturn mid;\n}\n\nstatic mobile_id_t get_new_mobile_id(turn_turnserver* server)\n{\n\tmobile_id_t newid = 0;\n\n\tif(server && server->mobile_connections_map) {\n\t\tur_map *map = server->mobile_connections_map;\n\t\tuint64_t sid = server->id;\n\t\tsid = sid<<56;\n\t\tdo {\n\t\t\twhile (!newid) {\n\t\t\t\tif(TURN_RANDOM_SIZE == sizeof(mobile_id_t))\n\t\t\t\t\tnewid = (mobile_id_t)turn_random();\n\t\t\t\telse {\n\t\t\t\t\tnewid = (mobile_id_t)turn_random();\n\t\t\t\t\tnewid = (newid<<32) + (mobile_id_t)turn_random();\n\t\t\t\t}\n\t\t\t\tif(!newid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnewid = newid & 0x00FFFFFFFFFFFFFFLL;\n\t\t\t\tif(!newid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnewid = newid | sid;\n\t\t\t}\n\t\t} while(ur_map_get(map, (ur_map_key_type)newid, NULL));\n\t}\n\treturn newid;\n}\n\nstatic void put_session_into_mobile_map(ts_ur_super_session *ss)\n{\n\tif(ss && ss->server) {\n\t\tturn_turnserver* server = (turn_turnserver*)(ss->server);\n\t\tif(*(server->mobility) && server->mobile_connections_map) {\n\t\t\tif(!(ss->mobile_id)) {\n\t\t\t\tss->mobile_id = get_new_mobile_id(server);\n\t\t\t\tmobile_id_to_string(ss->mobile_id, ss->s_mobile_id, sizeof(ss->s_mobile_id));\n\t\t\t}\n\t\t\tur_map_put(server->mobile_connections_map, (ur_map_key_type)(ss->mobile_id), (ur_map_value_type)ss);\n\t\t}\n\t}\n\n}\n\nstatic void put_session_into_map(ts_ur_super_session *ss)\n{\n\tif(ss && ss->server) {\n\t\tturn_turnserver* server = (turn_turnserver*)(ss->server);\n\t\tif(!(ss->id)) {\n\t\t\tss->id = (turnsession_id)((turnsession_id)server->id * TURN_SESSION_ID_FACTOR);\n\t\t\tss->id += ++(server->session_id_counter);\n\t\t\tss->start_time = server->ctime;\n\t\t}\n\t\tur_map_put(server->sessions_map, (ur_map_key_type)(ss->id), (ur_map_value_type)ss);\n\t\tput_session_into_mobile_map(ss);\n\t}\n}\n\nstatic void delete_session_from_mobile_map(ts_ur_super_session *ss)\n{\n\tif(ss && ss->server && ss->mobile_id) {\n\t\tturn_turnserver* server = (turn_turnserver*)(ss->server);\n\t\tif(server->mobile_connections_map) {\n\t\t\tur_map_del(server->mobile_connections_map, (ur_map_key_type)(ss->mobile_id), NULL);\n\t\t}\n\t\tss->mobile_id = 0;\n\t\tss->s_mobile_id[0] = 0;\n\t}\n}\n\nstatic void delete_session_from_map(ts_ur_super_session *ss)\n{\n\tif(ss && ss->server) {\n\t\tturn_turnserver* server = (turn_turnserver*)(ss->server);\n\t\tur_map_del(server->sessions_map, (ur_map_key_type)(ss->id), NULL);\n\t\tdelete_session_from_mobile_map(ss);\n\t}\n}\n\nstatic ts_ur_super_session* get_session_from_map(turn_turnserver* server, turnsession_id sid)\n{\n\tts_ur_super_session *ss = NULL;\n\tif(server) {\n\t\tur_map_value_type value = 0;\n\t\tif(ur_map_get(server->sessions_map, (ur_map_key_type)sid, &value) && value) {\n\t\t\tss = (ts_ur_super_session*)value;\n\t\t}\n\t}\n\treturn ss;\n}\n\nvoid turn_cancel_session(turn_turnserver *server, turnsession_id sid)\n{\n\tif(server) {\n\t\tts_ur_super_session* ts = get_session_from_map(server, sid);\n\t\tif(ts) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Session %018llu to be forcefully canceled\\n\",(unsigned long long)sid);\n\t\t\tshutdown_client_connection(server, ts, 0, \"Forceful shutdown\");\n\t\t}\n\t}\n}\n\nstatic ts_ur_super_session* get_session_from_mobile_map(turn_turnserver* server, mobile_id_t mid)\n{\n\tts_ur_super_session *ss = NULL;\n\tif(server && *(server->mobility) && server->mobile_connections_map && mid) {\n\t\tur_map_value_type value = 0;\n\t\tif(ur_map_get(server->mobile_connections_map, (ur_map_key_type)mid, &value) && value) {\n\t\t\tss = (ts_ur_super_session*)value;\n\t\t}\n\t}\n\treturn ss;\n}\n\nstatic ts_ur_super_session* create_new_ss(turn_turnserver* server) {\n\t//\n\t//printf(\"%s: 111.111: session size=%lu\\n\",__FUNCTION__,(unsigned long)sizeof(ts_ur_super_session));\n\t//\n\tts_ur_super_session *ss = (ts_ur_super_session*)malloc(sizeof(ts_ur_super_session));\n\tbzero(ss,sizeof(ts_ur_super_session));\n\tss->server = server;\n\tget_default_realm_options(&(ss->realm_options));\n\tput_session_into_map(ss);\n\tinit_allocation(ss,&(ss->alloc), server->tcp_relay_connections);\n\treturn ss;\n}\n\nstatic void delete_ur_map_ss(void *p) {\n\tif (p) {\n\t\tts_ur_super_session* ss = (ts_ur_super_session*) p;\n\t\tdelete_session_from_map(ss);\n\t\tIOA_CLOSE_SOCKET(ss->client_socket);\n\t\tclear_allocation(get_allocation_ss(ss));\n\t\tIOA_EVENT_DEL(ss->to_be_allocated_timeout_ev);\n\t\tfree(p);\n\t}\n}\n\n/////////// clean all /////////////////////\n\nstatic int turn_server_remove_all_from_ur_map_ss(ts_ur_super_session* ss) {\n\tif (!ss)\n\t\treturn 0;\n\telse {\n\t\tint ret = 0;\n\t\tif (ss->client_socket) {\n\t\t\tclear_ioa_socket_session_if(ss->client_socket, ss);\n\t\t}\n\t\tif (get_relay_socket_ss(ss,AF_INET)) {\n\t\t\tclear_ioa_socket_session_if(get_relay_socket_ss(ss,AF_INET), ss);\n\t\t}\n\t\tif (get_relay_socket_ss(ss,AF_INET6)) {\n\t\t\tclear_ioa_socket_session_if(get_relay_socket_ss(ss,AF_INET6), ss);\n\t\t}\n\t\tdelete_ur_map_ss(ss);\n\t\treturn ret;\n\t}\n}\n\n/////////////////////////////////////////////////////////////////\n\nstatic void client_ss_channel_timeout_handler(ioa_engine_handle e, void* arg) {\n\n\tUNUSED_ARG(e);\n\n\tif (!arg)\n\t\treturn;\n\n\tch_info* chn = (ch_info*) arg;\n\n\tturn_channel_delete(chn);\n}\n\nstatic void client_ss_perm_timeout_handler(ioa_engine_handle e, void* arg) {\n\n\tUNUSED_ARG(e);\n\n\tif (!arg) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"!!! %s: empty permission to be cleaned\\n\",__FUNCTION__);\n\t\treturn;\n\t}\n\n\tturn_permission_info* tinfo = (turn_permission_info*) arg;\n\n\tif(!(tinfo->allocated)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"!!! %s: unallocated permission to be cleaned\\n\",__FUNCTION__);\n\t\treturn;\n\t}\n\n\tif(!(tinfo->lifetime_ev)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"!!! %s: strange (1) permission to be cleaned\\n\",__FUNCTION__);\n\t}\n\n\tif(!(tinfo->owner)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"!!! %s: strange (2) permission to be cleaned\\n\",__FUNCTION__);\n\t}\n\n\tturn_permission_clean(tinfo);\n}\n\n///////////////////////////////////////////////////////////////////\n\nstatic int update_turn_permission_lifetime(ts_ur_super_session *ss, turn_permission_info *tinfo, turn_time_t time_delta) {\n\n\tif (ss && tinfo && tinfo->owner) {\n\n\t\tturn_turnserver *server = (turn_turnserver *) (ss->server);\n\n\t\tif (server) {\n\n\t\t\tif(!time_delta) time_delta = *(server->permission_lifetime);\n\t\t\ttinfo->expiration_time = server->ctime + time_delta;\n\n\t\t\tIOA_EVENT_DEL(tinfo->lifetime_ev);\n\t\t\ttinfo->lifetime_ev = set_ioa_timer(server->e, time_delta, 0,\n\t\t\t\t\t\t\tclient_ss_perm_timeout_handler, tinfo, 0,\n\t\t\t\t\t\t\t\"client_ss_channel_timeout_handler\");\n\n\t\t\tif(server->verbose) {\n\t\t\t\ttinfo->verbose = 1;\n\t\t\t\ttinfo->session_id = ss->id;\n\t\t\t\tchar s[257]=\"\\0\";\n\t\t\t\taddr_to_string(&(tinfo->addr),(uint8_t*)s);\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"session %018llu: peer %s lifetime updated: %lu\\n\",(unsigned long long)ss->id,s,(unsigned long)time_delta);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int update_channel_lifetime(ts_ur_super_session *ss, ch_info* chn)\n{\n\n\tif (chn) {\n\n\t\tturn_permission_info* tinfo = (turn_permission_info*) (chn->owner);\n\n\t\tif (tinfo && tinfo->owner) {\n\n\t\t\tturn_turnserver *server = (turn_turnserver *) (ss->server);\n\n\t\t\tif (server) {\n\n\t\t\t\tif (update_turn_permission_lifetime(ss, tinfo, *(server->channel_lifetime)) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tchn->expiration_time = server->ctime + *(server->channel_lifetime);\n\n\t\t\t\tIOA_EVENT_DEL(chn->lifetime_ev);\n\t\t\t\tchn->lifetime_ev = set_ioa_timer(server->e, *(server->channel_lifetime), 0,\n\t\t\t\t\t\t\t\tclient_ss_channel_timeout_handler,\n\t\t\t\t\t\t\t\tchn, 0,\n\t\t\t\t\t\t\t\t\"client_ss_channel_timeout_handler\");\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n/////////////// TURN ///////////////////////////\n\n#define SKIP_ATTRIBUTES case STUN_ATTRIBUTE_OAUTH_ACCESS_TOKEN: case STUN_ATTRIBUTE_PRIORITY: case STUN_ATTRIBUTE_FINGERPRINT: case STUN_ATTRIBUTE_MESSAGE_INTEGRITY: break; \\\n\tcase STUN_ATTRIBUTE_USERNAME: case STUN_ATTRIBUTE_REALM: case STUN_ATTRIBUTE_NONCE: case STUN_ATTRIBUTE_ORIGIN: \\\n\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\\\n\t\tioa_network_buffer_get_size(in_buffer->nbh), sar); \\\n\tcontinue\n\nstatic uint8_t get_transport_value(const uint8_t *value) {\n\tif((value[0] == STUN_ATTRIBUTE_TRANSPORT_UDP_VALUE)||\n\t   (value[0] == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE)) {\n\t\treturn value[0];\n\t}\n\treturn 0;\n}\n\nstatic int handle_turn_allocate(turn_turnserver *server,\n\t\t\t\tts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\tint *err_code, \tconst uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\tioa_net_data *in_buffer, ioa_network_buffer_handle nbh) {\n\n\n\tint err_code4 = 0;\n\tint err_code6 = 0;\n\n\tallocation* alloc = get_allocation_ss(ss);\n\n\tif (is_allocation_valid(alloc)) {\n\n\t\tif (!stun_tid_equals(tid, &(alloc->tid))) {\n\t\t\t*err_code = 437;\n\t\t\t*reason = (const uint8_t *)\"Wrong TID\";\n\t\t} else {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tioa_addr xor_relayed_addr1, *pxor_relayed_addr1=NULL;\n\t\t\tioa_addr xor_relayed_addr2, *pxor_relayed_addr2=NULL;\n\t\t\tioa_addr *relayed_addr1 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET));\n\t\t\tioa_addr *relayed_addr2 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET6));\n\n\t\t\tif(get_relay_session_failure(alloc,AF_INET)) {\n\t\t\t\taddr_set_any(&xor_relayed_addr1);\n\t\t\t\tpxor_relayed_addr1 = &xor_relayed_addr1;\n\t\t\t} else if(relayed_addr1) {\n\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\taddr_cpy(&xor_relayed_addr1, &(server->external_ip));\n\t\t\t\t\taddr_set_port(&xor_relayed_addr1,addr_get_port(relayed_addr1));\n\t\t\t\t} else {\n\t\t\t\t\taddr_cpy(&xor_relayed_addr1, relayed_addr1);\n\t\t\t\t}\n\t\t\t\tpxor_relayed_addr1 = &xor_relayed_addr1;\n\t\t\t}\n\n\t\t\tif(get_relay_session_failure(alloc,AF_INET6)) {\n\t\t\t\taddr_set_any(&xor_relayed_addr2);\n\t\t\t\tpxor_relayed_addr2 = &xor_relayed_addr2;\n\t\t\t} else if(relayed_addr2) {\n\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\taddr_cpy(&xor_relayed_addr2, &(server->external_ip));\n\t\t\t\t\taddr_set_port(&xor_relayed_addr2,addr_get_port(relayed_addr2));\n\t\t\t\t} else {\n\t\t\t\t\taddr_cpy(&xor_relayed_addr2, relayed_addr2);\n\t\t\t\t}\n\t\t\t\tpxor_relayed_addr2 = &xor_relayed_addr2;\n\t\t\t}\n\n\t\t\tif(pxor_relayed_addr1 || pxor_relayed_addr2) {\n\t\t\t\tuint32_t lifetime = 0;\n\t\t\t\tif(pxor_relayed_addr1) {\n\t\t\t\t\tlifetime = (get_relay_session(alloc,pxor_relayed_addr1->ss.sa_family)->expiration_time - server->ctime);\n\t\t\t\t} else if(pxor_relayed_addr2) {\n\t\t\t\t\tlifetime = (get_relay_session(alloc,pxor_relayed_addr2->ss.sa_family)->expiration_time - server->ctime);\n\t\t\t\t}\n\t\t\t\tstun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\ttid,\n\t\t\t\t\t\t\tpxor_relayed_addr1, pxor_relayed_addr2,\n\t\t\t\t\t\t\tget_remote_addr_from_ioa_socket(ss->client_socket),\n\t\t\t\t\t\t\tlifetime,*(server->max_allocate_lifetime), 0, NULL, 0,\n\t\t\t\t\t\t\tss->s_mobile_id);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t*resp_constructed = 1;\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\tuint8_t transport = 0;\n\t\tturn_time_t lifetime = 0;\n\t\tint even_port = -1;\n\t\tint dont_fragment = 0;\n\t\tuint64_t in_reservation_token = 0;\n\t\tint af4 = 0;\n\t\tint af6 = 0;\n\t\tuint8_t username[STUN_MAX_USERNAME_SIZE+1]=\"\\0\";\n\t\tsize_t ulen = 0;\n\t\tband_limit_t bps = 0;\n\t\tband_limit_t max_bps = 0;\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\n\t\t\tif(attr_type == STUN_ATTRIBUTE_USERNAME) {\n\t\t\t\tconst uint8_t* value = stun_attr_get_value(sar);\n\t\t\t\tif (value) {\n\t\t\t\t\tulen = stun_attr_get_len(sar);\n\t\t\t\t\tif(ulen>=sizeof(username)) {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"User name is too long\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbcopy(value,username,ulen);\n\t\t\t\t\tusername[ulen]=0;\n\t\t\t\t\tif(!is_secure_string(username,1)) {\n\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: wrong username: %s\\n\", __FUNCTION__, (char*)username);\n\t\t\t\t\t\tusername[0]=0;\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_NEW_BANDWIDTH:\n\t\t\t\tbps = stun_attr_get_bandwidth(sar);\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_MOBILITY_TICKET:\n\t\t\t\tif(!(*(server->mobility))) {\n\t\t\t\t\t*err_code = 405;\n\t\t\t\t\t*reason = (const uint8_t *)\"Mobility Forbidden\";\n\t\t\t\t} else if (stun_attr_get_len(sar) != 0) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Mobility Field\";\n\t\t\t\t} else {\n\t\t\t\t\tss->is_mobile = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_REQUESTED_TRANSPORT: {\n\t\t\t\tif (stun_attr_get_len(sar) != 4) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Transport Field\";\n\t\t\t\t} else if(transport) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Duplicate Transport Fields\";\n\t\t\t\t} else {\n\t\t\t\t\tconst uint8_t* value = stun_attr_get_value(sar);\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\ttransport = get_transport_value(value);\n\t\t\t\t\t\tif (!transport) {\n\t\t\t\t\t\t\t*err_code = 442;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && *(server->no_tcp_relay)) {\n\t\t\t\t\t\t\t*err_code = 442;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"TCP Transport is not allowed by the TURN Server configuration\";\n\t\t\t\t\t\t} else if((transport == STUN_ATTRIBUTE_TRANSPORT_UDP_VALUE) && *(server->no_udp_relay)) {\n\t\t\t\t\t\t\t*err_code = 442;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"UDP Transport is not allowed by the TURN Server configuration\";\n\t\t\t\t\t\t} else if(ss->client_socket) {\n\t\t\t\t\t\t\tSOCKET_TYPE cst = get_ioa_socket_type(ss->client_socket);\n\t\t\t\t\t\t\tif((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && !is_stream_socket(cst)) {\n\t\t\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Transport Data\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tss->is_tcp_relay = (transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Transport Data\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_DONT_FRAGMENT:\n\t\t\t\tdont_fragment = 1;\n\t\t\t\tif(!(server->dont_fragment))\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_LIFETIME: {\n\t\t\t  if (stun_attr_get_len(sar) != 4) {\n\t\t\t    *err_code = 400;\n\t\t\t    *reason = (const uint8_t *)\"Wrong Lifetime Field\";\n\t\t\t  } else {\n\t\t\t    const uint8_t* value = stun_attr_get_value(sar);\n\t\t\t    if (!value) {\n\t\t\t      *err_code = 400;\n\t\t\t      *reason = (const uint8_t *)\"Wrong Lifetime Data\";\n\t\t\t    } else {\n\t\t\t      lifetime = nswap32(*((const uint32_t*)value));\n\t\t\t    }\n\t\t\t  }\n\t\t\t}\n\t\t\t  break;\n\t\t\tcase STUN_ATTRIBUTE_EVEN_PORT: {\n\t\t\t  if (in_reservation_token) {\n\t\t\t    *err_code = 400;\n\t\t\t    *reason = (const uint8_t *)\"Even Port and Reservation Token cannot be used together\";\n\t\t\t  } else {\n\t\t\t    even_port = stun_attr_get_even_port(sar);\n\t\t\t    if(even_port) {\n\t\t\t    \tif (af4 && af6) {\n\t\t\t    \t\t*err_code = 400;\n\t\t\t    \t\t*reason = (const uint8_t *)\"Even Port cannot be used with Dual Allocation\";\n\t\t\t    \t}\n\t\t\t    }\n\t\t\t  }\n\t\t\t}\n\t\t\t  break;\n\t\t\tcase STUN_ATTRIBUTE_RESERVATION_TOKEN: {\n\t\t\t  int len = stun_attr_get_len(sar);\n\t\t\t  if (len != 8) {\n\t\t\t    *err_code = 400;\n\t\t\t    *reason = (const uint8_t *)\"Wrong Format of Reservation Token\";\n\t\t\t  } else if(af4 || af6) {\n\t\t\t\t  *err_code = 400;\n\t\t\t\t  *reason = (const uint8_t *)\"Address family attribute can not be used with reservation token request\";\n\t\t\t  } else {\n\t\t\t    if (even_port >= 0) {\n\t\t\t      *err_code = 400;\n\t\t\t      *reason = (const uint8_t *)\"Reservation Token cannot be used in this request with even port\";\n\t\t\t    } else if (in_reservation_token) {\n\t\t\t      *err_code = 400;\n\t\t\t      *reason = (const uint8_t *)\"Reservation Token cannot be used in this request\";\n\t\t\t    } else {\n\t\t\t      in_reservation_token = stun_attr_get_reservation_token_value(sar);\n\t\t\t    }\n\t\t\t  }\n\t\t\t}\n\t\t\t  break;\n\t\t\tcase STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY:\n\t\t\t\tif(even_port>0) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Even Port cannot be used with Dual Allocation\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* Falls through. */\n\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY: {\n\t\t\t\tif(in_reservation_token) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Address family attribute can not be used with reservation token request\";\n\t\t\t\t} else if(af4 || af6) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Extra address family attribute can not be used in the request\";\n\t\t\t\t} else {\n\t\t\t\t\tint af_req = stun_get_requested_address_family(sar);\n\t\t\t\t\tswitch (af_req) {\n\t\t\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4:\n\t\t\t\t\t\tif(attr_type == STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY) {\n\t\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Invalid value of the additional address family attribute\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taf4 = af_req;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6:\n\t\t\t\t\t\tif(attr_type == STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY) {\n\t\t\t\t\t\t\taf4 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taf6 = af_req;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t*err_code = 440;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t  break;\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t     sar);\n\t\t}\n\n\t\tif (!transport) {\n\n\t\t  *err_code = 400;\n\t\t  if(!(*reason))\n\t\t    *reason = (const uint8_t *)\"Transport field missed or wrong\";\n\t\t  \n\t\t} else if (*ua_num > 0) {\n\n\t\t  *err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && (dont_fragment || in_reservation_token || (even_port!=-1))) {\n\n\t\t\t*err_code = 400;\n\t\t\tif(!(*reason))\n\t\t\t    *reason = (const uint8_t *)\"Request parameters are incompatible with TCP transport\";\n\n\t\t} else {\n\n\t\t\tif(*(server->mobility)) {\n\t\t\t\tif(!(ss->is_mobile)) {\n\t\t\t\t\tdelete_session_from_mobile_map(ss);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);\n\t\t\tuint64_t out_reservation_token = 0;\n\n\t\t\tif(inc_quota(ss, username)<0) {\n\n\t\t\t\t*err_code = 486;\n\n\t\t\t} else {\n\n\t\t\t\tif(server->allocate_bps_func) {\n\t\t\t\t\tmax_bps = ss->realm_options.perf_options.max_bps;\n\t\t\t\t\tif(max_bps && (!bps || (bps && (bps>max_bps)))) {\n\t\t\t\t\t\tbps = max_bps;\n\t\t\t\t\t}\n\t\t\t\t\tif(bps && (ss->bps == 0)) {\n\t\t\t\t\t\tss->bps = server->allocate_bps_func(bps,1);\n\t\t\t\t\t\tif(!(ss->bps)) {\n\t\t\t\t\t\t\t*err_code = 486;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Allocation Bandwidth Quota Reached\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(af4) af4 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;\n\t\t\t\tif(af6) af6 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6;\n\n\t\t\t\tif(af4 && af6) {\n\t\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\t\t*err_code = 440;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Dual allocation cannot be supported in the current server configuration\";\n\t\t\t\t\t}\n\t\t\t\t\tif(even_port > 0) {\n\t\t\t\t\t\t*err_code = 440;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Dual allocation cannot be supported with even-port functionality\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\tif(!af4 && !af6) {\n\t\t\t\t\t\tint a_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_DEFAULT;\n\t\t\t\t\t\tif (server->keep_address_family) {\n\t\t\t\t\t\t\tswitch(get_ioa_socket_address_family(ss->client_socket)) {\n\t\t\t\t\t\t\t\tcase AF_INET6 :\n\t\t\t\t\t\t\t\t\ta_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase AF_INET :\n\t\t\t\t\t\t\t\t\ta_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\ta_family, transport,\n\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\terr_code, reason,\n\t\t\t\t\t\ttcp_peer_accept_connection);\n\n\t\t\t\t\t\tif(res<0) {\n\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET);\n\t\t\t\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(!af4 && af6) {\n\t\t\t\t\t\tint af6res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\t\taf6, transport,\n\t\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\t\terr_code, reason,\n\t\t\t\t\t\t\ttcp_peer_accept_connection);\n\t\t\t\t\t\tif(af6res<0) {\n\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET6);\n\t\t\t\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(af4 && !af6) {\n\t\t\t\t\t\tint af4res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\t\taf4, transport,\n\t\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\t\terr_code, reason,\n\t\t\t\t\t\t\ttcp_peer_accept_connection);\n\t\t\t\t\t\tif(af4res<0) {\n\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET);\n\t\t\t\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst uint8_t *reason4 = NULL;\n\t\t\t\t\t\tconst uint8_t *reason6 = NULL;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint af4res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\t\t\t\taf4, transport,\n\t\t\t\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\t\t\t\t&err_code4, &reason4,\n\t\t\t\t\t\t\t\t\ttcp_peer_accept_connection);\n\t\t\t\t\t\t\tif(af4res<0) {\n\t\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET);\n\t\t\t\t\t\t\t\tif(!err_code4) {\n\t\t\t\t\t\t\t\t\terr_code4 = 440;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint af6res = create_relay_connection(server, ss, lifetime,\n\t\t\t\t\t\t\t\t\t\t\t\taf6, transport,\n\t\t\t\t\t\t\t\t\t\t\t\teven_port, in_reservation_token, &out_reservation_token,\n\t\t\t\t\t\t\t\t\t\t\t\t&err_code6, &reason6,\n\t\t\t\t\t\t\t\t\t\t\t\ttcp_peer_accept_connection);\n\t\t\t\t\t\t\tif(af6res<0) {\n\t\t\t\t\t\t\t\tset_relay_session_failure(alloc,AF_INET6);\n\t\t\t\t\t\t\t\tif(!err_code6) {\n\t\t\t\t\t\t\t\t\terr_code6 = 440;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(err_code4 && err_code6) {\n\t\t\t\t\t\t\tif(reason4) {\n\t\t\t\t\t\t\t\t*err_code = err_code4;\n\t\t\t\t\t\t\t\t*reason = reason4;\n\t\t\t\t\t\t\t} else if(reason6) {\n\t\t\t\t\t\t\t\t*err_code = err_code6;\n\t\t\t\t\t\t\t\t*reason = reason6;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t*err_code = err_code4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (*err_code) {\n\n\t\t\t\t\tif(!(*reason)) {\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot create relay endpoint(s)\";\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tset_allocation_valid(alloc,1);\n\n\t\t\t\t\tstun_tid_cpy(&(alloc->tid), tid);\n\n\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\n\t\t\t\t\tioa_addr xor_relayed_addr1, *pxor_relayed_addr1=NULL;\n\t\t\t\t\tioa_addr xor_relayed_addr2, *pxor_relayed_addr2=NULL;\n\t\t\t\t\tioa_addr *relayed_addr1 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET));\n\t\t\t\t\tioa_addr *relayed_addr2 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET6));\n\n\t\t\t\t\tif(get_relay_session_failure(alloc,AF_INET)) {\n\t\t\t\t\t\taddr_set_any(&xor_relayed_addr1);\n\t\t\t\t\t\tpxor_relayed_addr1 = &xor_relayed_addr1;\n\t\t\t\t\t} else if(relayed_addr1) {\n\t\t\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\t\t\taddr_cpy(&xor_relayed_addr1, &(server->external_ip));\n\t\t\t\t\t\t\taddr_set_port(&xor_relayed_addr1,addr_get_port(relayed_addr1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddr_cpy(&xor_relayed_addr1, relayed_addr1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpxor_relayed_addr1 = &xor_relayed_addr1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(get_relay_session_failure(alloc,AF_INET6)) {\n\t\t\t\t\t\taddr_set_any(&xor_relayed_addr2);\n\t\t\t\t\t\tpxor_relayed_addr2 = &xor_relayed_addr2;\n\t\t\t\t\t} else if(relayed_addr2) {\n\t\t\t\t\t\tif(server->external_ip_set) {\n\t\t\t\t\t\t\taddr_cpy(&xor_relayed_addr2, &(server->external_ip));\n\t\t\t\t\t\t\taddr_set_port(&xor_relayed_addr2,addr_get_port(relayed_addr2));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddr_cpy(&xor_relayed_addr2, relayed_addr2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpxor_relayed_addr2 = &xor_relayed_addr2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(pxor_relayed_addr1 || pxor_relayed_addr2) {\n\n\t\t\t\t\t\tstun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len, tid,\n\t\t\t\t\t\t\t\t\tpxor_relayed_addr1, pxor_relayed_addr2,\n\t\t\t\t\t\t\t\t\tget_remote_addr_from_ioa_socket(ss->client_socket), lifetime,\n\t\t\t\t\t\t\t\t\t*(server->max_allocate_lifetime),0,NULL,\n\t\t\t\t\t\t\t\t\tout_reservation_token,\n\t\t\t\t\t\t\t\t\tss->s_mobile_id);\n\n\t\t\t\t\t\tif(ss->bps) {\n\t\t\t\t\t\t\tstun_attr_add_bandwidth_str(ioa_network_buffer_data(nbh), &len, ss->bps);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t\t\t*resp_constructed = 1;\n\n\t\t\t\t\t\tturn_report_allocation_set(&(ss->alloc), lifetime, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(*resp_constructed)) {\n\n\t\tif (!(*err_code)) {\n\t\t\t*err_code = 437;\n\t\t}\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\tstun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len, tid, NULL, NULL, NULL, 0, *(server->max_allocate_lifetime), *err_code, *reason, 0, ss->s_mobile_id);\n\t\tioa_network_buffer_set_size(nbh,len);\n\t\t*resp_constructed = 1;\n\t}\n\n\tif(*resp_constructed && !(*err_code)) {\n\t\tif(err_code4) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_address_error_code(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4, err_code4);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\t\tif(err_code6) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_address_error_code(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6, err_code6);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void copy_auth_parameters(ts_ur_super_session *orig_ss, ts_ur_super_session *ss) {\n\tif(orig_ss && ss) {\n\t\tdec_quota(ss);\n\t\tbcopy(orig_ss->nonce,ss->nonce,sizeof(ss->nonce));\n\t\tss->nonce_expiration_time = orig_ss->nonce_expiration_time;\n\t\tbcopy(&(orig_ss->realm_options),&(ss->realm_options),sizeof(ss->realm_options));\n\t\tbcopy(orig_ss->username,ss->username,sizeof(ss->username));\n\t\tss->hmackey_set = orig_ss->hmackey_set;\n\t\tbcopy(orig_ss->hmackey,ss->hmackey,sizeof(ss->hmackey));\n\t\tss->oauth = orig_ss->oauth;\n\t\tbcopy(orig_ss->origin,ss->origin,sizeof(ss->origin));\n\t\tss->origin_set = orig_ss->origin_set;\n\t\tbcopy(orig_ss->pwd,ss->pwd,sizeof(ss->pwd));\n\t\tss->max_session_time_auth = orig_ss->max_session_time_auth;\n\t\tinc_quota(ss,ss->username);\n\t}\n}\n\nstatic int handle_turn_refresh(turn_turnserver *server,\n\t\t\t       ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t       int *err_code, \tconst uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t       ioa_net_data *in_buffer, ioa_network_buffer_handle nbh,\n\t\t\t       int message_integrity, int *no_response, int can_resume) {\n\n\tallocation* a = get_allocation_ss(ss);\n\tint af4c = 0;\n\tint af6c = 0;\n\tint af4 = 0;\n\tint af6 = 0;\n\t{\n\t\tint i;\n\t\tfor(i = 0;i<ALLOC_PROTOCOLS_NUMBER; ++i) {\n\t\t\tif(a->relay_sessions[i].s && !ioa_socket_tobeclosed(a->relay_sessions[i].s)) {\n\t\t\t\tint family = get_ioa_socket_address_family(a->relay_sessions[i].s);\n\t\t\t\tif(AF_INET == family) {\n\t\t\t\t\taf4c = 1;\n\t\t\t\t} else if(AF_INET6 == family) {\n\t\t\t\t\taf6c = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!is_allocation_valid(a) && !(*(server->mobility))) {\n\n\t\t*err_code = 437;\n\t\t*reason = (const uint8_t *)\"Invalid allocation\";\n\n\t} else {\n\n\t\tturn_time_t lifetime = 0;\n\t\tint to_delete = 0;\n\t\tmobile_id_t mid = 0;\n\t\tchar smid[sizeof(ss->s_mobile_id)] = \"\\0\";\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_MOBILITY_TICKET: {\n\t\t\t\tif(!(*(server->mobility))) {\n\t\t\t\t\t*err_code = 405;\n\t\t\t\t\t*reason = (const uint8_t *)\"Mobility forbidden\";\n\t\t\t\t} else {\n\t\t\t\t\tint smid_len = stun_attr_get_len(sar);\n\t\t\t\t\tif(smid_len>0 && (((size_t)smid_len)<sizeof(smid))) {\n\t\t\t\t\t\tconst uint8_t* smid_val = stun_attr_get_value(sar);\n\t\t\t\t\t\tif(smid_val) {\n\t\t\t\t\t\t\tbcopy(smid_val, smid, (size_t)smid_len);\n\t\t\t\t\t\t\tmid = string_to_mobile_id(smid);\n\t\t\t\t\t\t\tif(is_allocation_valid(a) && (mid != ss->old_mobile_id)) {\n\t\t\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Mobility ticket cannot be used for a stable, already established allocation\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Mobility ticket has wrong length\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_LIFETIME: {\n\t\t\t\tif (stun_attr_get_len(sar) != 4) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Lifetime field format\";\n\t\t\t\t} else {\n\t\t\t\t\tconst uint8_t* value = stun_attr_get_value(sar);\n\t\t\t\t\tif (!value) {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong lifetime field data\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlifetime = nswap32(*((const uint32_t*)value));\n\t\t\t\t\t\tif (!lifetime)\n\t\t\t\t\t\t\tto_delete = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY: /* deprecated, for backward compatibility with older versions of TURN-bis */\n\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY: {\n\t\t\t\tint af_req = stun_get_requested_address_family(sar);\n\t\t\t\t{\n\t\t\t\t\tint is_err = 0;\n\t\t\t\t\tswitch (af_req) {\n\t\t\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4:\n\t\t\t\t\t\tif(!af4c) {\n\t\t\t\t\t\t\tis_err = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taf4 = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6:\n\t\t\t\t\t\tif(!af6c) {\n\t\t\t\t\t\t\tis_err = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taf6 = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tis_err = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(is_err) {\n\t\t\t\t\t\t*err_code = 443;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Peer Address Family Mismatch (1)\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), sar);\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if(!is_allocation_valid(a)) {\n\n\t\t\tif(mid && smid[0]) {\n\n\t\t\t\tturnserver_id tsid = ((0xFF00000000000000LL) & mid)>>56;\n\n\t\t\t\tif(tsid != server->id) {\n\n\t\t\t\t\tif(server->send_socket_to_relay) {\n\t\t\t\t\t\tioa_socket_handle new_s = detach_ioa_socket(ss->client_socket);\n\t\t\t\t\t\tif(new_s) {\n\t\t\t\t\t\t  if(server->send_socket_to_relay(tsid, mid, tid, new_s, message_integrity, \n\t\t\t\t\t\t\t\t\t\t  RMT_MOBILE_SOCKET, in_buffer, can_resume)<0) {\n\t\t\t\t\t\t    *err_code = 400;\n\t\t\t\t\t\t    *reason = (const uint8_t *)\"Wrong mobile ticket\";\n\t\t\t\t\t\t  } else {\n\t\t\t\t\t\t    *no_response = 1;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot create new socket\";\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Server send socket procedure is not set\";\n\t\t\t\t\t}\n\n\t\t\t\t\tss->to_be_closed = 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tts_ur_super_session *orig_ss = get_session_from_mobile_map(server, mid);\n\t\t\t\t\tif(!orig_ss || orig_ss->to_be_closed || ioa_socket_tobeclosed(orig_ss->client_socket)) {\n\t\t\t\t\t\t*err_code = 404;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Allocation not found\";\n\t\t\t\t\t} else if(orig_ss == ss) {\n\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Invalid allocation\";\n\t\t\t\t\t} else if(!(orig_ss->is_mobile)) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Software error: invalid mobile allocation\";\n\t\t\t\t\t} else if(orig_ss->client_socket == ss->client_socket) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Software error: invalid mobile client socket (orig)\";\n\t\t\t\t\t} else if(!(ss->client_socket)) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Software error: invalid mobile client socket (new)\";\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tget_realm_options_by_name(orig_ss->realm_options.name, &(ss->realm_options));\n\n\t\t\t\t\t\t//Check security:\n\t\t\t\t\t\tint postpone_reply = 0;\n\n\t\t\t\t\t\tif(!(ss->hmackey_set)) {\n\t\t\t\t\t\t\tcopy_auth_parameters(orig_ss,ss);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(check_stun_auth(server, ss, tid, resp_constructed, err_code, reason, in_buffer, nbh,\n\t\t\t\t\t\t\t\tSTUN_METHOD_REFRESH, &message_integrity, &postpone_reply, can_resume)<0) {\n\t\t\t\t\t\t\tif(!(*err_code)) {\n\t\t\t\t\t\t\t\t*err_code = 401;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(postpone_reply) {\n\n\t\t\t\t\t\t\t*no_response = 1;\n\n\t\t\t\t\t\t} else if(!(*err_code)) {\n\n\t\t\t\t\t\t\t//Session transfer:\n\n\t\t\t\t\t\t\tif (to_delete)\n\t\t\t\t\t\t\t\tlifetime = 0;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (af4c && refresh_relay_connection(server, orig_ss, lifetime, 0, 0, 0,\n\t\t\t\t\t\t\t\t\t\terr_code, AF_INET) < 0) {\n\n\t\t\t\t\t\t\t\tif (!(*err_code)) {\n\t\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot refresh relay connection (internal error)\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else if (af6c && refresh_relay_connection(server, orig_ss, lifetime, 0, 0, 0,\n\t\t\t\t\t\t\t\t\t\terr_code, AF_INET6) < 0) {\n\n\t\t\t\t\t\t\t\tif (!(*err_code)) {\n\t\t\t\t\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot refresh relay connection (internal error)\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t//Transfer socket:\n\n\t\t\t\t\t\t\t\tioa_socket_handle s = detach_ioa_socket(ss->client_socket);\n\n\t\t\t\t\t\t\t\tss->to_be_closed = 1;\n\n\t\t\t\t\t\t\t\tif(!s) {\n\t\t\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tif(attach_socket_to_session(server, s, orig_ss) < 0) {\n\t\t\t\t\t\t\t\t\t\tif(orig_ss->client_socket != s) {\n\t\t\t\t\t\t\t\t\t\t\tIOA_CLOSE_SOCKET(s);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tif(ss->hmackey_set) {\n\t\t\t\t\t\t\t\t\t\t\tcopy_auth_parameters(ss,orig_ss);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdelete_session_from_mobile_map(ss);\n\t\t\t\t\t\t\t\t\t\tdelete_session_from_mobile_map(orig_ss);\n\t\t\t\t\t\t\t\t\t\tput_session_into_mobile_map(orig_ss);\n\n\t\t\t\t\t\t\t\t\t\t//Use new buffer and redefine ss:\n\t\t\t\t\t\t\t\t\t\tnbh = ioa_network_buffer_allocate(server->e);\n\n\t\t\t\t\t\t\t\t\t\tdec_quota(ss);\n\t\t\t\t\t\t\t\t\t\tss = orig_ss;\n\t\t\t\t\t\t\t\t\t\tinc_quota(ss,ss->username);\n\n\t\t\t\t\t\t\t\t\t\tss->old_mobile_id = mid;\n\t\t\t\t\t\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\n\t\t\t\t\t\t\t\t\t\tturn_report_allocation_set(&(ss->alloc), lifetime, 1);\n\n\t\t\t\t\t\t\t\t\t\tstun_init_success_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, tid);\n\t\t\t\t\t\t\t\t\t\tuint32_t lt = nswap32(lifetime);\n\n\t\t\t\t\t\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_LIFETIME,\n\t\t\t\t\t\t\t\t\t\t\t\t(const uint8_t*) &lt, 4);\n\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\t\t\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\t\t\tSTUN_ATTRIBUTE_MOBILITY_TICKET,\n\t\t\t\t\t\t\t\t\t\t\t(uint8_t*)ss->s_mobile_id,strlen(ss->s_mobile_id));\n\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\t\t\t\t\t\t\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\t\t\t\t\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\t\t\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif(message_integrity) {\n\t\t\t\t\t\t\t\t\t\t\tstun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);\n\t\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ((server->fingerprint) || ss->enforce_fingerprints) {\n\t\t\t\t\t\t\t\t\t\t\tif (stun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len) < 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t\t\t\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t*no_response = 1;\n\n\t\t\t\t\t\t\t\t\t\treturn write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treport_turn_session_info(server,orig_ss,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err_code = 437;\n\t\t\t\t*reason = (const uint8_t *)\"Invalid allocation\";\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (to_delete)\n\t\t\t\tlifetime = 0;\n\t\t\telse {\n\t\t\t\tlifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);\n\t\t\t}\n\n\t\t\tif(!af4 && !af6) {\n\t\t\t\taf4 = af4c;\n\t\t\t\taf6 = af6c;\n\t\t\t}\n\n\t\t\tif (af4 && refresh_relay_connection(server, ss, lifetime, 0, 0, 0,\n\t\t\t\t\terr_code, AF_INET) < 0) {\n\n\t\t\t\tif (!(*err_code)) {\n\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t*reason = (const uint8_t *)\"Cannot refresh relay connection (internal error)\";\n\t\t\t\t}\n\n\t\t\t} else if (af6 && refresh_relay_connection(server, ss, lifetime, 0, 0, 0,\n\t\t\t\t\terr_code, AF_INET6) < 0) {\n\n\t\t\t\tif (!(*err_code)) {\n\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t*reason = (const uint8_t *)\"Cannot refresh relay connection (internal error)\";\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tturn_report_allocation_set(&(ss->alloc), lifetime, 1);\n\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_success_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, tid);\n\n\t\t\t\tif(ss->s_mobile_id[0]) {\n\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tSTUN_ATTRIBUTE_MOBILITY_TICKET,\n\t\t\t\t\t\t\t\t\t(uint8_t*)ss->s_mobile_id,strlen(ss->s_mobile_id));\n\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t}\n\n\t\t\t\tuint32_t lt = nswap32(lifetime);\n\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_LIFETIME,\n\t\t\t\t\t\t(const uint8_t*) &lt, 4);\n\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\t*resp_constructed = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!no_response) {\n\t\tif (!(*resp_constructed)) {\n\n\t\t\tif (!(*err_code)) {\n\t\t\t\t*err_code = 437;\n\t\t\t}\n\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_init_error_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t*resp_constructed = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* RFC 6062 ==>> */\n\nstatic void tcp_deliver_delayed_buffer(unsent_buffer *ub, ioa_socket_handle s, ts_ur_super_session *ss)\n{\n\tif(ub && s && ub->bufs && ub->sz && ss) {\n\t\tsize_t i = 0;\n\t\tdo {\n\t\t\tioa_network_buffer_handle nbh = top_unsent_buffer(ub);\n\t\t\tif(!nbh)\n\t\t\t\tbreak;\n\n\t\t\tuint32_t bytes = (uint32_t)ioa_network_buffer_get_size(nbh);\n\n\t\t\tint ret = send_data_from_ioa_socket_nbh(s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tset_ioa_socket_tobeclosed(s);\n\t\t\t} else {\n\t\t\t\t++(ss->sent_packets);\n\t\t\t\tss->sent_bytes += bytes;\n\t\t\t\tturn_report_session_usage(ss, 0);\n\t\t\t}\n\t\t\tpop_unsent_buffer(ub);\n\t\t} while(!ioa_socket_tobeclosed(s) && ((i++)<MAX_UNSENT_BUFFER_SIZE));\n\t}\n}\n\nstatic void tcp_peer_input_handler(ioa_socket_handle s, int event_type, ioa_net_data *in_buffer, void *arg, int can_resume)\n{\n\tif (!(event_type & IOA_EV_READ) || !arg)\n\t\treturn;\n\n\tUNUSED_ARG(s);\n\tUNUSED_ARG(can_resume);\n\n\ttcp_connection *tc = (tcp_connection*)arg;\n\tts_ur_super_session *ss=NULL;\n\tallocation *a=(allocation*)tc->owner;\n\tif(a) {\n\t\tss=(ts_ur_super_session*)a->owner;\n\t}\n\n\tif((tc->state != TC_STATE_READY) || !(tc->client_s)) {\n\t\tadd_unsent_buffer(&(tc->ub_to_client), in_buffer->nbh);\n\t\tin_buffer->nbh = NULL;\n\t\treturn;\n\t}\n\n\tioa_network_buffer_handle nbh = in_buffer->nbh;\n\tin_buffer->nbh = NULL;\n\n\tuint32_t bytes = (uint32_t)ioa_network_buffer_get_size(nbh);\n\n\tif (ss) {\n\t\t++(ss->peer_received_packets);\n\t\tss->peer_received_bytes += bytes;\n\t}\n\n\tint ret = send_data_from_ioa_socket_nbh(tc->client_s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);\n\tif (ret < 0) {\n\t\tset_ioa_socket_tobeclosed(s);\n\t} else if(ss) {\n\t\t++(ss->sent_packets);\n\t\tss->sent_bytes += bytes;\n\t}\n\n\tif (ss) {\n\t\tturn_report_session_usage(ss, 0);\n\t}\n}\n\nstatic void tcp_client_input_handler_rfc6062data(ioa_socket_handle s, int event_type, ioa_net_data *in_buffer, void *arg, int can_resume)\n{\n\tif (!(event_type & IOA_EV_READ) || !arg)\n\t\treturn;\n\n\tUNUSED_ARG(s);\n\tUNUSED_ARG(can_resume);\n\n\ttcp_connection *tc = (tcp_connection*)arg;\n\tts_ur_super_session *ss=NULL;\n\tallocation *a=(allocation*)tc->owner;\n\tif(a) {\n\t\tss=(ts_ur_super_session*)a->owner;\n\t}\n\n\tif(tc->state != TC_STATE_READY)\n\t\treturn;\n\n\tif(!(tc->peer_s))\n\t\treturn;\n\n\tioa_network_buffer_handle nbh = in_buffer->nbh;\n\tin_buffer->nbh = NULL;\n\n\tuint32_t bytes = (uint32_t)ioa_network_buffer_get_size(nbh);\n\tif(ss) {\n\t\t++(ss->received_packets);\n\t\tss->received_bytes += bytes;\n\t}\n\n\tint skip = 0;\n\tint ret = send_data_from_ioa_socket_nbh(tc->peer_s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, &skip);\n\tif (ret < 0) {\n\t\tset_ioa_socket_tobeclosed(s);\n\t}\n\n\tif (!skip && ss) {\n\t\t++(ss->peer_sent_packets);\n\t\tss->peer_sent_bytes += bytes;\n\t}\n\n\tif(ss)\n\t\tturn_report_session_usage(ss, 0);\n}\n\nstatic void tcp_conn_bind_timeout_handler(ioa_engine_handle e, void *arg)\n{\n\tUNUSED_ARG(e);\n\tif(arg) {\n\t\ttcp_connection *tc = (tcp_connection *)arg;\n\t\tdelete_tcp_connection(tc);\n\t}\n}\n\nstatic void tcp_peer_connection_completed_callback(int success, void *arg)\n{\n\tif(arg) {\n\t\ttcp_connection *tc = (tcp_connection *)arg;\n\t\tallocation *a = (allocation*)(tc->owner);\n\t\tts_ur_super_session *ss = (ts_ur_super_session*)(a->owner);\n\t\tturn_turnserver *server=(turn_turnserver*)(ss->server);\n\t\tint err_code = 0;\n\n\t\tIOA_EVENT_DEL(tc->peer_conn_timeout);\n\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\n\t\tif(success) {\n\t\t\tif(register_callback_on_ioa_socket(server->e, tc->peer_s, IOA_EV_READ, tcp_peer_input_handler, tc, 1)<0) {\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot set TCP peer data input callback\\n\", __FUNCTION__);\n\t\t\t\tsuccess=0;\n\t\t\t\terr_code = 500;\n\t\t\t}\n\t\t}\n\n\t\tif(success) {\n\t\t\ttc->state = TC_STATE_PEER_CONNECTED;\n\t\t\tstun_init_success_response_str(STUN_METHOD_CONNECT, ioa_network_buffer_data(nbh), &len, &(tc->tid));\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_CONNECTION_ID,\n\t\t\t\t\t\t\t\t\t(const uint8_t*)&(tc->id), 4);\n\n\t\t\tIOA_EVENT_DEL(tc->conn_bind_timeout);\n\t\t\ttc->conn_bind_timeout = set_ioa_timer(server->e, TCP_CONN_BIND_TIMEOUT, 0,\n\t\t\t\t\t\t\t\t\ttcp_conn_bind_timeout_handler, tc, 0,\n\t\t\t\t\t\t\t\t\t\"tcp_conn_bind_timeout_handler\");\n\n\t\t} else {\n\t\t\ttc->state = TC_STATE_FAILED;\n\t\t\tif(!err_code) {\n\t\t\t\terr_code = 447;\n\t\t\t}\n\t\t\t{\n\t\t\t\tchar ls[257]=\"\\0\";\n\t\t\t\tchar rs[257]=\"\\0\";\n\t\t\t\tioa_addr *laddr = get_local_addr_from_ioa_socket(ss->client_socket);\n\t\t\t\tif(laddr)\n\t\t\t\t\taddr_to_string(laddr,(uint8_t*)ls);\n\t\t\t\taddr_to_string(&(tc->peer_addr),(uint8_t*)rs);\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: failure to connect from %s to %s\\n\", __FUNCTION__, ls,rs);\n\t\t\t}\n\t\t\tstun_init_error_response_str(STUN_METHOD_CONNECT, ioa_network_buffer_data(nbh), &len, err_code, NULL, &(tc->tid));\n\t\t}\n\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\tif(need_stun_authentication(server, ss)) {\n\t\t\tstun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\n\t\twrite_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\n\t\tif(!success) {\n\t\t\tdelete_tcp_connection(tc);\n\t\t}\n\t\t/* test */\n\t\telse if(0)\n\t\t{\n\t\t\tint i = 0;\n\t\t\tfor(i=0;i<22;i++) {\n\t\t\t\tioa_network_buffer_handle nbh_test = ioa_network_buffer_allocate(server->e);\n\t\t\t\tsize_t len_test = ioa_network_buffer_get_size(nbh_test);\n\t\t\t\tuint8_t *data = ioa_network_buffer_data(nbh_test);\n\t\t\t\tconst char* data_test=\"111.111.111.111.111\";\n\t\t\t\tlen_test = strlen(data_test);\n\t\t\t\tbcopy(data_test,data,len_test);\n\t\t\t\tioa_network_buffer_set_size(nbh_test,len_test);\n\t\t\t\tsend_data_from_ioa_socket_nbh(tc->peer_s, NULL, nbh_test, TTL_IGNORE, TOS_IGNORE, NULL);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void tcp_peer_conn_timeout_handler(ioa_engine_handle e, void *arg)\n{\n\tUNUSED_ARG(e);\n\n\ttcp_peer_connection_completed_callback(0,arg);\n}\n\nstatic int tcp_start_connection_to_peer(turn_turnserver *server, ts_ur_super_session *ss, stun_tid *tid,\n\t\t\t\tallocation *a, ioa_addr *peer_addr,\n\t\t\t\tint *err_code, const uint8_t **reason)\n{\n\tFUNCSTART;\n\n\tif(!ss) {\n\t\t*err_code = 500;\n\t\t*reason = (const uint8_t *)\"Server error: empty session\";\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tif(!peer_addr) {\n\t\t*err_code = 500;\n\t\t*reason = (const uint8_t *)\"Server error: empty peer addr\";\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tif(!get_relay_socket(a,peer_addr->ss.sa_family)) {\n\t\t*err_code = 500;\n\t\t*reason = (const uint8_t *)\"Server error: no relay connection created\";\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\ttcp_connection *tc = get_tcp_connection_by_peer(a, peer_addr);\n\tif(tc) {\n\t\t*err_code = 446;\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\ttc = create_tcp_connection(server->id, a, tid, peer_addr, err_code);\n\tif(!tc) {\n\t\tif(!(*err_code)) {\n\t\t\t*err_code = 500;\n\t\t\t*reason = (const uint8_t *)\"Server error: TCP connection object creation failed\";\n\t\t}\n\t\tFUNCEND;\n\t\treturn -1;\n\t} else if(*err_code) {\n\t\tdelete_tcp_connection(tc);\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tIOA_EVENT_DEL(tc->peer_conn_timeout);\n\ttc->peer_conn_timeout = set_ioa_timer(server->e, TCP_PEER_CONN_TIMEOUT, 0,\n\t\t\t\t\t\ttcp_peer_conn_timeout_handler, tc, 0,\n\t\t\t\t\t\t\"tcp_peer_conn_timeout_handler\");\n\n\tioa_socket_handle tcs = ioa_create_connecting_tcp_relay_socket(get_relay_socket(a,peer_addr->ss.sa_family),\n\t\t\tpeer_addr, tcp_peer_connection_completed_callback, tc);\n\tif(!tcs) {\n\t\tdelete_tcp_connection(tc);\n\t\t*err_code = 500;\n\t\t*reason = (const uint8_t *)\"Server error: TCP relay socket for connection cannot be created\";\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\ttc->state = TC_STATE_CLIENT_TO_PEER_CONNECTING;\n\tif(tc->peer_s != tcs) {\n\t\tIOA_CLOSE_SOCKET(tc->peer_s);\n\t\ttc->peer_s = tcs;\n\t}\n\tset_ioa_socket_sub_session(tc->peer_s,tc);\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic void tcp_peer_accept_connection(ioa_socket_handle s, void *arg)\n{\n\tif(s) {\n\n\t\tif(!arg) {\n\t\t\tclose_ioa_socket(s);\n\t\t\treturn;\n\t\t}\n\n\t\tts_ur_super_session *ss = (ts_ur_super_session*)arg;\n\t\tturn_turnserver *server=(turn_turnserver*)(ss->server);\n\n\t\tFUNCSTART;\n\n\t\tallocation *a = &(ss->alloc);\n\t\tioa_addr *peer_addr = get_remote_addr_from_ioa_socket(s);\n\t\tif(!peer_addr) {\n\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\ttcp_connection *tc = get_tcp_connection_by_peer(a, peer_addr);\n\t\tif(tc) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: peer data socket with this address already exist\\n\", __FUNCTION__);\n\t\t\tif(tc->peer_s != s)\n\t\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\tif(!good_peer_addr(server, ss->realm_options.name, peer_addr)) {\n\t\t\tuint8_t saddr[256];\n\t\t\taddr_to_string(peer_addr, saddr);\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: an attempt to connect from a peer with forbidden address: %s\\n\", __FUNCTION__,saddr);\n\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\tif(!can_accept_tcp_connection_from_peer(a,peer_addr,server->server_relay)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: peer has no permission to connect\\n\", __FUNCTION__);\n\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\tstun_tid tid;\n\t\tbzero(&tid,sizeof(stun_tid));\n\t\tint err_code=0;\n\t\ttc = create_tcp_connection(server->id, a, &tid, peer_addr, &err_code);\n\t\tif(!tc) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot create TCP connection\\n\", __FUNCTION__);\n\t\t\tclose_ioa_socket(s);\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\ttc->state = TC_STATE_PEER_CONNECTED;\n\t\ttc->peer_s = s;\n\n\t\tset_ioa_socket_session(s,ss);\n\t\tset_ioa_socket_sub_session(s,tc);\n\n\t\tif(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, tcp_peer_input_handler, tc, 1)<0) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot set TCP peer data input callback\\n\", __FUNCTION__);\n\t\t\tIOA_CLOSE_SOCKET(tc->peer_s);\n\t\t\ttc->state = TC_STATE_UNKNOWN;\n\t\t\tFUNCEND;\n\t\t\treturn;\n\t\t}\n\n\t\tIOA_EVENT_DEL(tc->conn_bind_timeout);\n\t\ttc->conn_bind_timeout = set_ioa_timer(server->e, TCP_CONN_BIND_TIMEOUT, 0,\n\t\t\t\t\t\t\ttcp_conn_bind_timeout_handler, tc, 0,\n\t\t\t\t\t\t\t\"tcp_conn_bind_timeout_handler\");\n\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\n\t\tstun_init_indication_str(STUN_METHOD_CONNECTION_ATTEMPT, ioa_network_buffer_data(nbh), &len);\n\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_CONNECTION_ID,\n\t\t\t\t\t(const uint8_t*)&(tc->id), 4);\n\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_XOR_PEER_ADDRESS, peer_addr);\n\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t{\n\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif ((server->fingerprint) || ss->enforce_fingerprints) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\twrite_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\n\t\tFUNCEND;\n\t}\n}\n\nstatic int handle_turn_connect(turn_turnserver *server,\n\t\t\t\t    ts_ur_super_session *ss, stun_tid *tid,\n\t\t\t\t    int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\t    ioa_net_data *in_buffer) {\n\n\tFUNCSTART;\n\tioa_addr peer_addr;\n\tint peer_found = 0;\n\taddr_set_any(&peer_addr);\n\tallocation* a = get_allocation_ss(ss);\n\n\tif(!(ss->is_tcp_relay)) {\n\t\t*err_code = 403;\n\t\t*reason = (const uint8_t *)\"Connect cannot be used with UDP relay\";\n\t} else if (!is_allocation_valid(a)) {\n\t\t*err_code = 437;\n\t} else {\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS:\n\t\t\t  {\n\t\t\t\tif(stun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t       NULL) == -1) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Bad Peer Address\";\n\t\t\t\t} else {\n\t\t\t\t\tif(!get_relay_socket(a,peer_addr.ss.sa_family)) {\n\t\t\t\t\t\t*err_code = 443;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Peer Address Family Mismatch (2)\";\n\t\t\t\t\t}\n\n\t\t\t\t\tpeer_found = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t     sar);\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if (!peer_found) {\n\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"Where is Peer Address ?\";\n\n\t\t} else {\n\t\t\tif(!good_peer_addr(server,ss->realm_options.name,&peer_addr)) {\n\t\t\t\t*err_code = 403;\n\t\t\t\t*reason = (const uint8_t *) \"Forbidden IP\";\n\t\t\t} else {\n\t\t\t\ttcp_start_connection_to_peer(server, ss, tid, a, &peer_addr, err_code, reason);\n\t\t\t}\n\t\t}\n\t}\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic int handle_turn_connection_bind(turn_turnserver *server,\n\t\t\t       ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t       int *err_code, \tconst uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t       ioa_net_data *in_buffer, ioa_network_buffer_handle nbh, int message_integrity,\n\t\t\t       int can_resume) {\n\n\tallocation* a = get_allocation_ss(ss);\n\n\tuint16_t method = STUN_METHOD_CONNECTION_BIND;\n\n\tif(ss->to_be_closed) {\n\n\t\t*err_code = 400;\n\n\t} else if (is_allocation_valid(a)) {\n\n\t\t*err_code = 400;\n\t\t*reason = (const uint8_t *)\"Bad request: CONNECTION_BIND cannot be issued after allocation\";\n\n\t} else if(!is_stream_socket(get_ioa_socket_type(ss->client_socket))) {\n\n\t\t*err_code = 400;\n\t\t*reason = (const uint8_t *)\"Bad request: CONNECTION_BIND only possible with TCP/TLS\";\n\n\t} else {\n\t\ttcp_connection_id id = 0;\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_CONNECTION_ID: {\n\t\t\t\tif (stun_attr_get_len(sar) != 4) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Connection ID field format\";\n\t\t\t\t} else {\n\t\t\t\t\tconst uint8_t* value = stun_attr_get_value(sar);\n\t\t\t\t\tif (!value) {\n\t\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong Connection ID field data\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tid = *((const uint32_t*)value); //AS-IS encoding, no conversion to/from network byte order\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), sar);\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else {\n\t\t\tif(server->send_socket_to_relay) {\n\t\t\t\tturnserver_id sid = (id & 0xFF000000)>>24;\n\t\t\t\tioa_socket_handle s = ss->client_socket;\n\t\t\t\tif(s && !ioa_socket_tobeclosed(s)) {\n\t\t\t\t\tioa_socket_handle new_s = detach_ioa_socket(s);\n\t\t\t\t\tif(new_s) {\n\t\t\t\t\t  if(server->send_socket_to_relay(sid, id, tid, new_s, message_integrity, RMT_CB_SOCKET, in_buffer, can_resume)<0) {\n\t\t\t\t\t    *err_code = 400;\n\t\t\t\t\t    *reason = (const uint8_t *)\"Wrong connection id\";\n\t\t\t\t\t  }\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t*err_code = 500;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err_code = 500;\n\t\t\t}\n\t\t\tss->to_be_closed = 1;\n\t\t}\n\t}\n\n\tif (!(*resp_constructed) && ss->client_socket && !ioa_socket_tobeclosed(ss->client_socket)) {\n\n\t\tif (!(*err_code)) {\n\t\t\t*err_code = 437;\n\t\t}\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t*resp_constructed = 1;\n\t}\n\n\treturn 0;\n}\n\nint turnserver_accept_tcp_client_data_connection(turn_turnserver *server, tcp_connection_id tcid, stun_tid *tid, ioa_socket_handle s, int message_integrity, ioa_net_data *in_buffer, int can_resume)\n{\n\tif(!server)\n\t\treturn -1;\n\n\tFUNCSTART;\n\n\ttcp_connection *tc = NULL;\n\tts_ur_super_session *ss = NULL;\n\n\tint err_code = 0;\n\tconst uint8_t *reason = NULL;\n\n\tioa_socket_handle s_to_delete = s;\n\n\tif(tcid && tid && s) {\n\n\t\ttc = get_tcp_connection_by_id(server->tcp_relay_connections, tcid);\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tint resp_constructed = 0;\n\t\tif(!tc || (tc->state == TC_STATE_READY) || (tc->client_s)) {\n\t\t\terr_code = 400;\n\t\t} else {\n\t\t\tallocation *a = (allocation*)(tc->owner);\n\t\t\tif(!a || !(a->owner)) {\n\t\t\t\terr_code = 500;\n\t\t\t} else {\n\t\t\t\tss = (ts_ur_super_session*)(a->owner);\n\n\t\t\t\tif(ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {\n\t\t\t\t\terr_code = 404;\n\t\t\t\t} else {\n\t\t\t\t\t//Check security:\n\t\t\t\t\tint postpone_reply = 0;\n\t\t\t\t\tcheck_stun_auth(server, ss, tid, &resp_constructed, &err_code, &reason, in_buffer, nbh,\n\t\t\t\t\t\tSTUN_METHOD_CONNECTION_BIND, &message_integrity, &postpone_reply, can_resume);\n\n\t\t\t\t\tif(postpone_reply) {\n\n\t\t\t\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t} else if(!err_code) {\n\t\t\t\t\t\ttc->state = TC_STATE_READY;\n\t\t\t\t\t\ttc->client_s = s;\n\t\t\t\t\t\ts_to_delete = NULL;\n\t\t\t\t\t\tset_ioa_socket_session(s,ss);\n\t\t\t\t\t\tset_ioa_socket_sub_session(s,tc);\n\t\t\t\t\t\tset_ioa_socket_app_type(s,TCP_CLIENT_DATA_SOCKET);\n\t\t\t\t\t\tif(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, tcp_client_input_handler_rfc6062data, tc, 1)<0) {\n\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot set TCP client data input callback\\n\", __FUNCTION__);\n\t\t\t\t\t\t\terr_code = 500;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tIOA_EVENT_DEL(tc->conn_bind_timeout);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(tc)\n\t\t\tget_and_clean_tcp_connection_by_id(server->tcp_relay_connections, tcid);\n\n\t\tif(!resp_constructed) {\n\t\t\tif(!err_code) {\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_success_response_str(STUN_METHOD_CONNECTION_BIND, ioa_network_buffer_data(nbh), &len, tid);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t} else {\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_error_response_str(STUN_METHOD_CONNECTION_BIND, ioa_network_buffer_data(nbh), &len, err_code, NULL, tid);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif(message_integrity && ss) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\n\t\tif ((server->fingerprint) || (ss &&(ss->enforce_fingerprints))) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif(server->verbose) {\n\t\t\tlog_method(ss, \"CONNECTION_BIND\", err_code, reason);\n\t\t}\n\n\t\tif(ss && !err_code) {\n\t\t\tsend_data_from_ioa_socket_nbh(s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);\n\t\t\ttcp_deliver_delayed_buffer(&(tc->ub_to_client),s,ss);\n\t\t\tIOA_CLOSE_SOCKET(s_to_delete);\n\t\t\tFUNCEND;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* Just to set the necessary structures for the packet sending: */\n\t\t\tif(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, NULL, NULL, 1)<0) {\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: cannot set TCP tmp client data input callback\\n\", __FUNCTION__);\n\t\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\t} else {\n\t\t\t\tsend_data_from_ioa_socket_nbh(s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tIOA_CLOSE_SOCKET(s_to_delete);\n\n\tFUNCEND;\n\treturn -1;\n}\n\n/* <<== RFC 6062 */\n\nstatic int handle_turn_channel_bind(turn_turnserver *server,\n\t\t\t\t    ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\t    int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\t    ioa_net_data *in_buffer, ioa_network_buffer_handle nbh) {\n\n\tFUNCSTART;\n\tuint16_t chnum = 0;\n\tioa_addr peer_addr;\n\taddr_set_any(&peer_addr);\n\tallocation* a = get_allocation_ss(ss);\n\tint addr_found = 0;\n\n\tif(ss->is_tcp_relay) {\n\t\t*err_code = 403;\n\t\t*reason = (const uint8_t *)\"Channel bind cannot be used with TCP relay\";\n\t} else if (is_allocation_valid(a)) {\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_CHANNEL_NUMBER: {\n\t\t\t\tif (chnum) {\n\t\t\t\t\tchnum = 0;\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Channel number cannot be duplicated in this request\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchnum = stun_attr_get_channel_number(sar);\n\t\t\t\tif (!chnum) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Channel number cannot be zero in this request\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS:\n\t\t\t  {\n\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t       NULL);\n\n\t\t\t\tif(!get_relay_socket(a,peer_addr.ss.sa_family)) {\n\t\t\t\t\t*err_code = 443;\n\t\t\t\t\t*reason = (const uint8_t *)\"Peer Address Family Mismatch (3)\";\n\t\t\t\t}\n\n\t\t\t\tif(addr_get_port(&peer_addr) < 1) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Empty port number in channel bind request\";\n\t\t\t\t} else {\n\t\t\t\t\taddr_found = 1;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t     sar);\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if (!chnum || addr_any(&peer_addr) || !addr_found) {\n\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"Bad channel bind request\";\n\n\t\t} else if(!STUN_VALID_CHANNEL(chnum)) {\n\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"Bad channel number\";\n\n\t\t} else {\n\n\t\t\tch_info* chn = allocation_get_ch_info(a, chnum);\n\t\t\tturn_permission_info* tinfo = NULL;\n\n\t\t\tif (chn) {\n\t\t\t\tif (!addr_eq(&peer_addr, &(chn->peer_addr))) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"You cannot use the same channel number with different peer\";\n\t\t\t\t} else {\n\t\t\t\t\ttinfo = (turn_permission_info*) (chn->owner);\n\t\t\t\t\tif (!tinfo) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong permission info\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!addr_eq_no_port(&peer_addr, &(tinfo->addr))) {\n\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong permission info and peer addr combination\";\n\t\t\t\t\t\t} else if (chn->port != addr_get_port(&peer_addr)) {\n\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t*reason = (const uint8_t *)\"Wrong port number\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tchn = allocation_get_ch_info_by_peer_addr(a, &peer_addr);\n\t\t\t\tif(chn) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"You cannot use the same peer with different channel number\";\n\t\t\t\t} else {\n\t\t\t\t\tif(!good_peer_addr(server,ss->realm_options.name,&peer_addr)) {\n\t\t\t\t\t\t*err_code = 403;\n\t\t\t\t\t\t*reason = (const uint8_t *) \"Forbidden IP\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchn = allocation_get_new_ch_info(a, chnum, &peer_addr);\n\t\t\t\t\t\tif (!chn) {\n\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t*reason = (const uint8_t *) \"Cannot find channel data\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttinfo = (turn_permission_info*) (chn->owner);\n\t\t\t\t\t\t\tif (!tinfo) {\n\t\t\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t\t\t*reason\n\t\t\t\t\t\t\t\t\t= (const uint8_t *) \"Wrong turn permission info\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(*err_code) && chn && tinfo) {\n\n\t\t\t  if (update_channel_lifetime(ss,chn) < 0) {\n\t\t\t    *err_code = 500;\n\t\t\t    *reason = (const uint8_t *)\"Cannot update channel lifetime (internal error)\";\n\t\t\t  } else {\n\t\t\t\t  size_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t  stun_set_channel_bind_response_str(ioa_network_buffer_data(nbh), &len, tid, 0, NULL);\n\t\t\t\t  ioa_network_buffer_set_size(nbh,len);\n\t\t\t\t  *resp_constructed = 1;\n\n\t\t\t\t  if(!(ss->is_mobile)) {\n\t\t\t\t\t  if(get_ioa_socket_type(ss->client_socket) == UDP_SOCKET ||\n\t\t\t\t\t\t\t  get_ioa_socket_type(ss->client_socket) == TCP_SOCKET ||\n\t\t\t\t\t\t\t  get_ioa_socket_type(ss->client_socket) == SCTP_SOCKET) {\n\t\t\t\t\t\t  if(get_ioa_socket_type(get_relay_socket(&(ss->alloc),peer_addr.ss.sa_family)) == UDP_SOCKET) {\n\t\t\t\t\t\t\t  chn->kernel_channel = CREATE_TURN_CHANNEL_KERNEL(chn->chnum,\n\t\t\t\t\t\t\t\t  get_ioa_socket_address_family(ss->client_socket),\n\t\t\t\t\t\t\t\t  peer_addr.ss.sa_family,\n\t\t\t\t\t\t\t\t  (get_ioa_socket_type(ss->client_socket)==UDP_SOCKET ? IPPROTO_UDP : IPPROTO_TCP),\n\t\t\t\t\t\t\t\t  &(get_remote_addr_from_ioa_socket(ss->client_socket)->ss),\n\t\t\t\t\t\t\t\t  &(get_local_addr_from_ioa_socket(ss->client_socket)->ss),\n\t\t\t\t\t\t\t\t  &(get_local_addr_from_ioa_socket(get_relay_socket(&(ss->alloc),peer_addr.ss.sa_family))),\n\t\t\t\t\t\t\t\t  &(get_remote_addr_from_ioa_socket(get_relay_socket(&(ss->alloc),peer_addr.ss.sa_family)))\n\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t}\n\t\t}\n\t}\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic int handle_turn_binding(turn_turnserver *server,\n\t\t\t\t    ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\t    int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\t    ioa_net_data *in_buffer, ioa_network_buffer_handle nbh,\n\t\t\t\t    int *origin_changed, ioa_addr *response_origin,\n\t\t\t\t    int *dest_changed, ioa_addr *response_destination,\n\t\t\t\t    uint32_t cookie, int old_stun) {\n\n\tFUNCSTART;\n\tint change_ip = 0;\n\tint change_port = 0;\n\tint padding = 0;\n\tint response_port_present = 0;\n\tuint16_t response_port = 0;\n\tSOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);\n\tint use_reflected_from = 0;\n\n\tif(!(ss->client_socket))\n\t\treturn -1;\n\n\t*origin_changed = 0;\n\t*dest_changed = 0;\n\n\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\tint attr_type = stun_attr_get_type(sar);\n\t\tswitch (attr_type) {\n\t\tcase OLD_STUN_ATTRIBUTE_PASSWORD:\n\t\tSKIP_ATTRIBUTES;\n\t\tcase STUN_ATTRIBUTE_CHANGE_REQUEST:\n/*\n * This fix allows the client program from the Stuntman source to make STUN binding requests\n * to this server.\n *\n * It was provided by  John Selbie, from STUNTMAN project:\n *\n * \"Here's the gist of the change. Stuntman comes with a STUN client library\n * and client program. The client program displays the mapped IP address and\n * port if it gets back a successful binding response.\n * It also interops with JSTUN, a Java implementation of STUN.\n * However, the JSTUN server refuses to respond to any binding request that\n * doesn't have a CHANGE-REQUEST attribute in it.\n * ... workaround is for the client to make a request with an empty CHANGE-REQUEST\n * attribute (neither the ip or port bit are set).\"\n *\n */\n\t\t\tstun_attr_get_change_request_str(sar, &change_ip, &change_port);\n\t\t\tif( (!is_rfc5780(server)) && (change_ip || change_port)) {\n\t\t\t\t*err_code = 420;\n\t\t\t\t*reason = (const uint8_t *)\"Unknown attribute: TURN server was configured without RFC 5780 support\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(change_ip || change_port) {\n\t\t\t\tif(st != UDP_SOCKET) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong request: applicable only to UDP protocol\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STUN_ATTRIBUTE_PADDING:\n\t\t\tif(response_port_present) {\n\t\t\t\t*err_code = 400;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong request format: you cannot use PADDING and RESPONSE_PORT together\";\n\t\t\t} else if((st != UDP_SOCKET) && (st != DTLS_SOCKET)) {\n\t\t\t\t*err_code = 400;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong request: padding applicable only to UDP and DTLS protocols\";\n\t\t\t} else {\n\t\t\t\tpadding = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STUN_ATTRIBUTE_RESPONSE_PORT:\n\t\t\tif(padding) {\n\t\t\t\t*err_code = 400;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong request format: you cannot use PADDING and RESPONSE_PORT together\";\n\t\t\t} else if(st != UDP_SOCKET) {\n\t\t\t\t*err_code = 400;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong request: applicable only to UDP protocol\";\n\t\t\t} else {\n\t\t\t\tint rp = stun_attr_get_response_port_str(sar);\n\t\t\t\tif(rp>=0) {\n\t\t\t\t\tresponse_port_present = 1;\n\t\t\t\t\tresponse_port = (uint16_t)rp;\n\t\t\t\t} else {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Wrong response port format\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OLD_STUN_ATTRIBUTE_RESPONSE_ADDRESS:\n\t\t\tif(old_stun) {\n\t\t\t\tuse_reflected_from = 1;\n\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\tsar, response_destination, response_destination);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t};\n\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t     sar);\n\t}\n\n\tif (*ua_num > 0) {\n\n\t\t*err_code = 420;\n\n\t} else if (*err_code) {\n\n\t\t;\n\n\t} else if(ss->client_socket && get_remote_addr_from_ioa_socket(ss->client_socket)) {\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\tif (stun_set_binding_response_str(ioa_network_buffer_data(nbh), &len, tid,\n\t\t\t\t\tget_remote_addr_from_ioa_socket(ss->client_socket), 0, NULL, cookie, old_stun) >= 0) {\n\n\t\t\taddr_cpy(response_origin, get_local_addr_from_ioa_socket(ss->client_socket));\n\n\t\t\t*resp_constructed = 1;\n\n\t\t\tif(old_stun && use_reflected_from) {\n\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_REFLECTED_FROM,\n\t\t\t\t\t\tget_remote_addr_from_ioa_socket(ss->client_socket));\n\t\t\t}\n\n\t\t\tif(!is_rfc5780(server)) {\n\n\t\t\t\tif(old_stun) {\n\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_SOURCE_ADDRESS, response_origin);\n\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_CHANGED_ADDRESS, response_origin);\n\t\t\t\t} else {\n\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\tSTUN_ATTRIBUTE_RESPONSE_ORIGIN, response_origin);\n\t\t\t\t}\n\n\t\t\t} else if(ss->client_socket) {\n\n\t\t\t\tioa_addr other_address;\n\n\t\t\t\tif(get_other_address(server,ss,&other_address) == 0) {\n\n\t\t\t\t\taddr_cpy(response_destination, get_remote_addr_from_ioa_socket(ss->client_socket));\n\n\t\t\t\t\tif(change_ip) {\n\t\t\t\t\t\t*origin_changed = 1;\n\t\t\t\t\t\tif(change_port) {\n\t\t\t\t\t\t\taddr_cpy(response_origin,&other_address);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint old_port = addr_get_port(response_origin);\n\t\t\t\t\t\t\taddr_cpy(response_origin,&other_address);\n\t\t\t\t\t\t\taddr_set_port(response_origin,old_port);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(change_port) {\n\t\t\t\t\t\t*origin_changed = 1;\n\t\t\t\t\t\taddr_set_port(response_origin,addr_get_port(&other_address));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(old_stun) {\n\t\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_SOURCE_ADDRESS, response_origin);\n\t\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tOLD_STUN_ATTRIBUTE_CHANGED_ADDRESS, &other_address);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tSTUN_ATTRIBUTE_RESPONSE_ORIGIN, response_origin);\n\t\t\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\t\t\t\tSTUN_ATTRIBUTE_OTHER_ADDRESS, &other_address);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(response_port_present) {\n\t\t\t\t\t\t*dest_changed = 1;\n\t\t\t\t\t\taddr_set_port(response_destination, (int)response_port);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(padding) {\n\t\t\t\t\t\tint mtu = get_local_mtu_ioa_socket(ss->client_socket);\n\t\t\t\t\t\tif(mtu<68)\n\t\t\t\t\t\t\tmtu=1500;\n\n\t\t\t\t\t\tmtu = (mtu >> 2) << 2;\n\t\t\t\t\t\tstun_attr_add_padding_str(ioa_network_buffer_data(nbh), &len, (uint16_t)mtu);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tioa_network_buffer_set_size(nbh, len);\n\t}\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic int handle_turn_send(turn_turnserver *server, ts_ur_super_session *ss,\n\t\t\t    int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t    ioa_net_data *in_buffer) {\n\n\tFUNCSTART;\n\n\tioa_addr peer_addr;\n\tconst uint8_t* value = NULL;\n\tint len = -1;\n\tint addr_found = 0;\n\tint set_df = 0;\n\n\taddr_set_any(&peer_addr);\n\tallocation* a = get_allocation_ss(ss);\n\n\tif(ss->is_tcp_relay) {\n\t\t*err_code = 403;\n\t\t*reason = (const uint8_t *)\"Send cannot be used with TCP relay\";\n\t} else if (is_allocation_valid(a) && (in_buffer->recv_ttl != 0)) {\n\n\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\t\t\tint attr_type = stun_attr_get_type(sar);\n\t\t\tswitch (attr_type) {\n\t\t\tSKIP_ATTRIBUTES;\n\t\t\tcase STUN_ATTRIBUTE_DONT_FRAGMENT:\n\t\t\t\tif(!(server->dont_fragment))\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t\telse\n\t\t\t\t\tset_df = 1;\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS: {\n\t\t\t\tif (addr_found) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Address duplication\";\n\t\t\t\t} else {\n\t\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t\t       NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase STUN_ATTRIBUTE_DATA: {\n\t\t\t\tif (len >= 0) {\n\t\t\t\t\t*err_code = 400;\n\t\t\t\t\t*reason = (const uint8_t *)\"Data duplication\";\n\t\t\t\t} else {\n\t\t\t\t\tlen = stun_attr_get_len(sar);\n\t\t\t\t\tvalue = stun_attr_get_value(sar);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t};\n\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t     sar);\n\t\t}\n\n\t\tif (*err_code) {\n\t\t\t;\n\t\t} else if (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (!addr_any(&peer_addr) && len >= 0) {\n\n\t\t\tturn_permission_info* tinfo = NULL;\n\n\t\t\tif(!(server->server_relay))\n\t\t\t\ttinfo = allocation_get_permission(a, &peer_addr);\n\n\t\t\tif (tinfo || (server->server_relay)) {\n\n\t\t\t\tset_df_on_ioa_socket(get_relay_socket_ss(ss,peer_addr.ss.sa_family), set_df);\n\n\t\t\t\tioa_network_buffer_handle nbh = in_buffer->nbh;\n\t\t\t\tif(value && len>0) {\n\t\t\t\t\tuint16_t offset = (uint16_t)(value - ioa_network_buffer_data(nbh));\n\t\t\t\t\tioa_network_buffer_add_offset_size(nbh,offset,0,len);\n\t\t\t\t} else {\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\t}\n\t\t\t\tioa_network_buffer_header_init(nbh);\n\t\t\t\tint skip = 0;\n\t\t\t\tsend_data_from_ioa_socket_nbh(get_relay_socket_ss(ss,peer_addr.ss.sa_family), &peer_addr, nbh, in_buffer->recv_ttl-1, in_buffer->recv_tos, &skip);\n\t\t\t\tif (!skip) {\n\t\t\t\t\t++(ss->peer_sent_packets);\n\t\t\t\t\tss->peer_sent_bytes += len;\n\t\t\t\t\tturn_report_session_usage(ss, 0);\n\t\t\t\t}\n\t\t\t\tin_buffer->nbh = NULL;\n\t\t\t}\n\n\t\t} else {\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"No address found\";\n\t\t}\n\t}\n\n\tFUNCEND;\n\treturn 0;\n}\n\nstatic int update_permission(ts_ur_super_session *ss, ioa_addr *peer_addr) {\n\n\tif (!ss || !peer_addr)\n\t\treturn -1;\n\n\tallocation* a = get_allocation_ss(ss);\n\n\tturn_permission_info* tinfo = allocation_get_permission(a, peer_addr);\n\n\tif (!tinfo) {\n\t\ttinfo = allocation_add_permission(a, peer_addr);\n\t}\n\n\tif (!tinfo)\n\t\treturn -1;\n\n\tif (update_turn_permission_lifetime(ss, tinfo, 0) < 0)\n\t\treturn -1;\n\n\tch_info *chn = get_turn_channel(tinfo, peer_addr);\n\tif(chn) {\n\t\tif (update_channel_lifetime(ss, chn) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_turn_create_permission(turn_turnserver *server,\n\t\t\t\t\t ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\t\t int *err_code, const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,\n\t\t\t\t\t ioa_net_data *in_buffer, ioa_network_buffer_handle nbh) {\n\n\tint ret = -1;\n\n\tint addr_found = 0;\n\n\tUNUSED_ARG(server);\n\n\tallocation* a = get_allocation_ss(ss);\n\n\tif (is_allocation_valid(a)) {\n\n\t\t{\n\t\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\t\twhile (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {\n\n\t\t\t\tint attr_type = stun_attr_get_type(sar);\n\n\t\t\t\tswitch (attr_type) {\n\n\t\t\t\tSKIP_ATTRIBUTES;\n\n\t\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS: {\n\n\t\t\t\t\tioa_addr peer_addr;\n\t\t\t\t\taddr_set_any(&peer_addr);\n\n\t\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t       NULL);\n\n\t\t\t\t\tif(!get_relay_socket(a,peer_addr.ss.sa_family)) {\n\t\t\t\t\t\t*err_code = 443;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Peer Address Family Mismatch (4)\";\n\t\t\t\t\t} else if(!good_peer_addr(server, ss->realm_options.name, &peer_addr)) {\n\t\t\t\t\t\t*err_code = 403;\n\t\t\t\t\t\t*reason = (const uint8_t *) \"Forbidden IP\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddr_found++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(attr_type>=0x0000 && attr_type<=0x7FFF)\n\t\t\t\t\t\tunknown_attrs[(*ua_num)++] = nswap16(attr_type);\n\t\t\t\t};\n\t\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t\t\t     sar);\n\t\t\t}\n\t\t}\n\n\t\tif (*ua_num > 0) {\n\n\t\t\t*err_code = 420;\n\n\t\t} else if (*err_code) {\n\n\t\t\t;\n\n\t\t} else if (!addr_found) {\n\n\t\t\t*err_code = 400;\n\t\t\t*reason = (const uint8_t *)\"No address found\";\n\n\t\t} else {\n\n\t\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\t\twhile (sar) {\n\n\t\t\t\tint attr_type = stun_attr_get_type(sar);\n\n\t\t\t\tswitch (attr_type) {\n\n\t\t\t\tSKIP_ATTRIBUTES;\n\n\t\t\t\tcase STUN_ATTRIBUTE_XOR_PEER_ADDRESS: {\n\n\t\t\t\t\tioa_addr peer_addr;\n\t\t\t\t\taddr_set_any(&peer_addr);\n\n\t\t\t\t\tstun_attr_get_addr_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t       ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t       sar, &peer_addr,\n\t\t\t\t\t\t\t\t\t       NULL);\n\n\t\t\t\t\taddr_set_port(&peer_addr, 0);\n\t\t\t\t\tif (update_permission(ss, &peer_addr) < 0) {\n\t\t\t\t\t\t*err_code = 500;\n\t\t\t\t\t\t*reason = (const uint8_t *)\"Cannot update some permissions (critical server software error)\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t;\n\t\t\t\t}\n\n\t\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\t\t\t     sar);\n\t\t\t}\n\n\t\t\tif(*err_code == 0) {\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_success_response_str(STUN_METHOD_CREATE_PERMISSION,\n\t\t\t\t\t\t\tioa_network_buffer_data(nbh), &len, tid);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\tret = 0;\n\t\t\t\t*resp_constructed = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// AUTH ==>>\n\nstatic int need_stun_authentication(turn_turnserver *server, ts_ur_super_session *ss)\n{\n\tUNUSED_ARG(ss);\n\n\tif(server) {\n\t\tswitch(server->ct) {\n\t\tcase TURN_CREDENTIALS_LONG_TERM:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\t;\n\t\t};\n\t}\n\n\treturn 0;\n}\n\nstatic int create_challenge_response(ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\t\tint *err_code, \tconst uint8_t **reason,\n\t\t\t\tioa_network_buffer_handle nbh,\n\t\t\t\tuint16_t method)\n{\n\tsize_t len = ioa_network_buffer_get_size(nbh);\n\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);\n\t*resp_constructed = 1;\n\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_NONCE,\n\t\t\t\t\tss->nonce, (int)(NONCE_MAX_SIZE-1));\n\tchar *realm = ss->realm_options.name;\n\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_REALM,\n\t\t\t\t\t(uint8_t*)realm, (int)(strlen((char*)(realm))));\n\n\tif(ss->server) {\n\t\tturn_turnserver* server = (turn_turnserver*)ss->server;\n\t\tif(server->oauth) {\n\t\t\tconst char *server_name = server->oauth_server_name;\n\t\t\tif(!(server_name && server_name[0])) {\n\t\t\t\tserver_name = realm;\n\t\t\t}\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len,\n    \t\t\tSTUN_ATTRIBUTE_THIRD_PARTY_AUTHORIZATION,\n    \t\t\t(const uint8_t*)(server_name),\n    \t\t\tstrlen(server_name));\n\t\t}\n    }\n\n\tioa_network_buffer_set_size(nbh,len);\n\treturn 0;\n}\n\n#if !defined(min)\n#define min(a,b) ((a)<=(b) ? (a) : (b))\n#endif\n\nstatic void resume_processing_after_username_check(int success,  int oauth, int max_session_time, hmackey_t hmackey, password_t pwd, turn_turnserver *server, uint64_t ctxkey, ioa_net_data *in_buffer, uint8_t *realm)\n{\n\n\tif(server && in_buffer && in_buffer->nbh) {\n\n\t\tts_ur_super_session *ss = get_session_from_map(server,(turnsession_id)ctxkey);\n\t\tif(ss && ss->client_socket) {\n\t\t\tturn_turnserver *server = (turn_turnserver *)ss->server;\n\n\t\t\tif(success) {\n\t\t\t\tbcopy(hmackey,ss->hmackey,sizeof(hmackey_t));\n\t\t\t\tss->hmackey_set = 1;\n\t\t\t\tss->oauth = oauth;\n\t\t\t\tss->max_session_time_auth = (turn_time_t)max_session_time;\n\t\t\t\tbcopy(pwd,ss->pwd,sizeof(password_t));\n\t\t\t\tif(realm && realm[0] && strcmp((char*)realm,ss->realm_options.name)) {\n\t\t\t\t\tdec_quota(ss);\n\t\t\t\t\tget_realm_options_by_name((char*)realm, &(ss->realm_options));\n\t\t\t\t\tinc_quota(ss,ss->username);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread_client_connection(server,ss,in_buffer,0,0);\n\n\t\t\tclose_ioa_socket_after_processing_if_necessary(ss->client_socket);\n\n\t\t\tioa_network_buffer_delete(server->e, in_buffer->nbh);\n\t\t\tin_buffer->nbh=NULL;\n\t\t}\n\t}\n}\n\nstatic int check_stun_auth(turn_turnserver *server,\n\t\t\tts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,\n\t\t\tint *err_code, \tconst uint8_t **reason,\n\t\t\tioa_net_data *in_buffer, ioa_network_buffer_handle nbh,\n\t\t\tuint16_t method, int *message_integrity,\n\t\t\tint *postpone_reply,\n\t\t\tint can_resume)\n{\n\tuint8_t usname[STUN_MAX_USERNAME_SIZE+1];\n\tuint8_t nonce[STUN_MAX_NONCE_SIZE+1];\n\tuint8_t realm[STUN_MAX_REALM_SIZE+1];\n\tsize_t alen = 0;\n\n\tif(!need_stun_authentication(server, ss))\n\t\treturn 0;\n\n\tint new_nonce = 0;\n\n\t{\n\t\tint generate_new_nonce = 0;\n\t\tif(ss->nonce[0]==0) {\n\t\t\tgenerate_new_nonce = 1;\n\t\t\tnew_nonce = 1;\n\t\t}\n\n\t\tif(*(server->stale_nonce)) {\n\t\t\tif(turn_time_before(ss->nonce_expiration_time,server->ctime)) {\n\t\t\t\tgenerate_new_nonce = 1;\n\t\t\t}\n\t\t}\n\n\t\tif(generate_new_nonce) {\n\n\t\t\tint i = 0;\n\n\t\t\tif(TURN_RANDOM_SIZE == 8) {\n\t\t\t\tfor(i=0;i<(NONCE_LENGTH_32BITS>>1);i++) {\n\t\t\t\t\tuint8_t *s = ss->nonce + 8*i;\n\t\t\t\t\tuint64_t rand=(uint64_t)turn_random();\n\t\t\t\t\tsnprintf((char*)s, NONCE_MAX_SIZE-8*i, \"%08lx\",(unsigned long)rand);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(i=0;i<NONCE_LENGTH_32BITS;i++) {\n\t\t\t\t\tuint8_t *s = ss->nonce + 4*i;\n\t\t\t\t\tuint32_t rand=(uint32_t)turn_random();\n\t\t\t\t\tsnprintf((char*)s, NONCE_MAX_SIZE-4*i, \"%04x\",(unsigned int)rand);\n\t\t\t\t}\n\t\t\t}\n\t\t\tss->nonce_expiration_time = server->ctime + *(server->stale_nonce);\n\t\t}\n\t}\n\n\t/* MESSAGE_INTEGRITY ATTR: */\n\n\tstun_attr_ref sar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\t    ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\t    STUN_ATTRIBUTE_MESSAGE_INTEGRITY);\n\n\tif(!sar) {\n\t\t*err_code = 401;\n\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t}\n\n\t{\n\t\tint sarlen = stun_attr_get_len(sar);\n\n\t\tswitch(sarlen) {\n\t\tcase SHA1SIZEBYTES:\n\t\t\tbreak;\n\t\tcase SHA256SIZEBYTES:\n\t\tcase SHA384SIZEBYTES:\n\t\tcase SHA512SIZEBYTES:\n\t\tdefault:\n\t\t\t*err_code = 401;\n\t\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t\t};\n\t}\n\n\t{\n\n\t\t/* REALM ATTR: */\n\n\t\tsar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t  STUN_ATTRIBUTE_REALM);\n\n\t\tif(!sar) {\n\t\t\t*err_code = 400;\n\t\t\treturn -1;\n\t\t}\n\n\t\talen = min((size_t)stun_attr_get_len(sar),sizeof(realm)-1);\n\t\tbcopy(stun_attr_get_value(sar),realm,alen);\n\t\trealm[alen]=0;\n\n\t\tif(!is_secure_string(realm,0)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: wrong realm: %s\\n\", __FUNCTION__, (char*)realm);\n\t\t\trealm[0]=0;\n\t\t\t*err_code = 400;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif(method == STUN_METHOD_CONNECTION_BIND) {\n\n\t\t\tget_realm_options_by_name((char *)realm, &(ss->realm_options));\n\n\t\t} else if(strcmp((char*)realm, (char*)(ss->realm_options.name))) {\n\t\t\tif(!(ss->oauth)){\n\t\t\t\tif(method == STUN_METHOD_ALLOCATE) {\n\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t*reason = (const uint8_t*)\"Allocation mismatch: wrong credentials: the realm value is incorrect\";\n\t\t\t\t} else {\n\t\t\t\t\t*err_code = 441;\n\t\t\t\t\t*reason = (const uint8_t*)\"Wrong credentials: the realm value is incorrect\";\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tbcopy(ss->realm_options.name,realm,sizeof(ss->realm_options.name));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* USERNAME ATTR: */\n\n\tsar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t  STUN_ATTRIBUTE_USERNAME);\n\n\tif(!sar) {\n\t\t*err_code = 400;\n\t\treturn -1;\n\t}\n\n\talen = min((size_t)stun_attr_get_len(sar),sizeof(usname)-1);\n\tbcopy(stun_attr_get_value(sar),usname,alen);\n\tusname[alen]=0;\n\n\tif(!is_secure_string(usname,1)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"%s: wrong username: %s\\n\", __FUNCTION__, (char*)usname);\n\t\tusname[0]=0;\n\t\t*err_code = 400;\n\t\treturn -1;\n\t} else if(ss->username[0]) {\n\t\tif(strcmp((char*)ss->username,(char*)usname)) {\n\t\t\tif(ss->oauth) {\n\t\t\t\tss->hmackey_set = 0;\n\t\t\t\tSTRCPY(ss->username,usname);\n\t\t\t} else {\n\t\t\t\tif(method == STUN_METHOD_ALLOCATE) {\n\t\t\t\t\t*err_code = 437;\n\t\t\t\t\t*reason = (const uint8_t*)\"Allocation mismatch: wrong credentials\";\n\t\t\t\t} else {\n\t\t\t\t\t*err_code = 441;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tSTRCPY(ss->username,usname);\n\t}\n\n\t{\n\t\t/* NONCE ATTR: */\n\n\t\tsar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t  STUN_ATTRIBUTE_NONCE);\n\n\t\tif(!sar) {\n\t\t\t*err_code = 400;\n\t\t\treturn -1;\n\t\t}\n\n\t\talen = min((size_t)stun_attr_get_len(sar),sizeof(nonce)-1);\n\t\tbcopy(stun_attr_get_value(sar),nonce,alen);\n\t\tnonce[alen]=0;\n\n\t\t/* Stale Nonce check: */\n\n\t\tif(new_nonce) {\n\t\t\t*err_code = 438;\n\t\t\t*reason = (const uint8_t*)\"Wrong nonce\";\n\t\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t\t}\n\n\t\tif(strcmp((char*)ss->nonce,(char*)nonce)) {\n\t\t\t*err_code = 438;\n\t\t\t*reason = (const uint8_t*)\"Stale nonce\";\n\t\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t\t}\n\t}\n\n\t/* Password */\n\tif(!(ss->hmackey_set) && (ss->pwd[0] == 0)) {\n\t\tif(can_resume) {\n\t\t\t(server->userkeycb)(server->id, server->ct, server->oauth, &(ss->oauth), usname, realm, resume_processing_after_username_check, in_buffer, ss->id, postpone_reply);\n\t\t\tif(*postpone_reply) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\"%s: Cannot find credentials of user <%s>\\n\",\n\t\t\t\t__FUNCTION__, (char*)usname);\n\t\t*err_code = 401;\n\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t}\n\n\t/* Check integrity */\n\tif(stun_check_message_integrity_by_key_str(server->ct,ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t  ss->hmackey,\n\t\t\t\t\t  ss->pwd,\n\t\t\t\t\t  SHATYPE_DEFAULT)<1) {\n\n\t\tif(can_resume) {\n\t\t\t(server->userkeycb)(server->id, server->ct, server->oauth, &(ss->oauth), usname, realm, resume_processing_after_username_check, in_buffer, ss->id, postpone_reply);\n\t\t\tif(*postpone_reply) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\"%s: user %s credentials are incorrect\\n\",\n\t\t\t\t__FUNCTION__, (char*)usname);\n\t\t*err_code = 401;\n\t\treturn create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);\n\t}\n\n\t*message_integrity = 1;\n\n\treturn 0;\n}\n\n//<<== AUTH\n\nstatic void set_alternate_server(turn_server_addrs_list_t *asl, const ioa_addr *local_addr, size_t *counter, uint16_t method, stun_tid *tid, int *resp_constructed, int *err_code, const uint8_t **reason, ioa_network_buffer_handle nbh)\n{\n\tif(asl && asl->size && local_addr) {\n\n\t\tsize_t i;\n\n\t\t/* to prevent indefinite cycle: */\n\n\t\tfor(i=0;i<asl->size;++i) {\n\t\t\tioa_addr *addr = &(asl->addrs[i]);\n\t\t\tif(addr_eq(addr,local_addr))\n\t\t\t\treturn;\n\t\t}\n\n\t\tfor(i=0;i<asl->size;++i) {\n\t\t\tif(*counter>=asl->size)\n\t\t\t\t*counter = 0;\n\t\t\tioa_addr *addr = &(asl->addrs[*counter]);\n\t\t\t*counter +=1;\n\t\t\tif(addr->ss.sa_family == local_addr->ss.sa_family) {\n\n\t\t\t\t*err_code = 300;\n\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);\n\t\t\t\t*resp_constructed = 1;\n\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_ALTERNATE_SERVER, addr);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int handle_turn_command(turn_turnserver *server, ts_ur_super_session *ss, ioa_net_data *in_buffer, ioa_network_buffer_handle nbh, int *resp_constructed, int can_resume)\n{\n\n\tstun_tid tid;\n\tint err_code = 0;\n\tconst uint8_t *reason = NULL;\n\tint no_response = 0;\n\tint message_integrity = 0;\n\n\tif(!(ss->client_socket))\n\t\treturn -1;\n\n\tuint16_t unknown_attrs[MAX_NUMBER_OF_UNKNOWN_ATTRS];\n\tuint16_t ua_num = 0;\n\tuint16_t method = stun_get_method_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh));\n\n\t*resp_constructed = 0;\n\n\tstun_tid_from_message_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh), \n\t\t\t\t  &tid);\n\n\tif (stun_is_request_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh))) {\n\n\t\tif((method == STUN_METHOD_BINDING) && (*(server->no_stun))) {\n\n\t\t\tno_response = 1;\n\t\t\tif(server->verbose) {\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\t\t\"%s: STUN method 0x%x ignored\\n\",\n\t\t\t\t\t\t\t\t\t__FUNCTION__, (unsigned int)method);\n\t\t\t}\n\n\t\t} else if((method != STUN_METHOD_BINDING) && (*(server->stun_only))) {\n\n\t\t\t\tno_response = 1;\n\t\t\t\tif(server->verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\t\t\t\"%s: STUN method 0x%x ignored\\n\",\n\t\t\t\t\t\t\t\t\t\t__FUNCTION__, (unsigned int)method);\n\t\t\t\t}\n\n\t\t} else if((method != STUN_METHOD_BINDING) || (*(server->secure_stun))) {\n\n\t\t\tif(method == STUN_METHOD_ALLOCATE) {\n\n\t\t\t\tallocation *a = get_allocation_ss(ss);\n\t\t\t\tif(is_allocation_valid(a)) {\n\t\t\t\t\tif(!stun_tid_equals(&(a->tid), &tid)) {\n\t\t\t\t\t\terr_code = 437;\n\t\t\t\t\t\treason = (const uint8_t *)\"Mismatched allocation: wrong transaction ID\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!err_code) {\n\t\t\t\t\tSOCKET_TYPE cst = get_ioa_socket_type(ss->client_socket);\n\t\t\t\t\tturn_server_addrs_list_t *asl = server->alternate_servers_list;\n\n\t\t\t\t\tif(((cst == UDP_SOCKET)||(cst == DTLS_SOCKET)) && server->self_udp_balance &&\n\t\t\t\t\t\t\tserver->aux_servers_list && server->aux_servers_list->size) {\n\t\t\t\t\t\tasl = server->aux_servers_list;\n\t\t\t\t\t} else if(((cst == TLS_SOCKET) || (cst == DTLS_SOCKET) ||(cst == TLS_SCTP_SOCKET)) &&\n\t\t\t\t\t\t\tserver->tls_alternate_servers_list && server->tls_alternate_servers_list->size) {\n\t\t\t\t\t\tasl = server->tls_alternate_servers_list;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(asl && asl->size) {\n\t\t\t\t\t\tturn_mutex_lock(&(asl->m));\n\t\t\t\t\t\tset_alternate_server(asl,get_local_addr_from_ioa_socket(ss->client_socket),&(server->as_counter),method,&tid,resp_constructed,&err_code,&reason,nbh);\n\t\t\t\t\t\tturn_mutex_unlock(&(asl->m));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* check that the realm is the same as in the original request */\n\t\t\tif(ss->origin_set) {\n\t\t\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\t\t\tint origin_found = 0;\n\t\t\t\tint norigins = 0;\n\n\t\t\t\twhile(sar && !origin_found) {\n\t\t\t\t\tif(stun_attr_get_type(sar) == STUN_ATTRIBUTE_ORIGIN) {\n\t\t\t\t\t\tint sarlen = stun_attr_get_len(sar);\n\t\t\t\t\t\tif(sarlen>0) {\n\t\t\t\t\t\t\t++norigins;\n\t\t\t\t\t\t\tchar *o = (char*)malloc(sarlen+1);\n\t\t\t\t\t\t\tbcopy(stun_attr_get_value(sar),o,sarlen);\n\t\t\t\t\t\t\to[sarlen]=0;\n\t\t\t\t\t\t\tchar *corigin = (char*)malloc(STUN_MAX_ORIGIN_SIZE+1);\n\t\t\t\t\t\t\tcorigin[0]=0;\n\t\t\t\t\t\t\tif(get_canonic_origin(o,corigin,STUN_MAX_ORIGIN_SIZE)<0) {\n\t\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\t\t\t\t\t\"%s: Wrong origin format: %s\\n\",\n\t\t\t\t\t\t\t\t\t__FUNCTION__, o);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!strncmp(ss->origin,corigin,STUN_MAX_ORIGIN_SIZE)) {\n\t\t\t\t\t\t\t\torigin_found = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfree(corigin);\n\t\t\t\t\t\t\tfree(o);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh), sar);\n\t\t\t\t}\n\n\t\t\t\tif(server->check_origin && *(server->check_origin)) {\n\t\t\t\t\tif(ss->origin[0]) {\n\t\t\t\t\t\tif(!origin_found) {\n\t\t\t\t\t\t\terr_code = 441;\n\t\t\t\t\t\t\treason = (const uint8_t *)\"The origin attribute does not match the initial session origin value\";\n\t\t\t\t\t\t\tif(server->verbose) {\n\t\t\t\t\t\t\t\tchar smethod[129];\n\t\t\t\t\t\t\t\tstun_method_str(method,smethod);\n\t\t\t\t\t\t\t\tlog_method(ss, smethod, err_code, reason);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(norigins > 0){\n\t\t\t\t\t\terr_code = 441;\n\t\t\t\t\t\treason = (const uint8_t *)\"The origin attribute is empty, does not match the initial session origin value\";\n\t\t\t\t\t\tif(server->verbose) {\n\t\t\t\t\t\t\tchar smethod[129];\n\t\t\t\t\t\t\tstun_method_str(method,smethod);\n\t\t\t\t\t\t\tlog_method(ss, smethod, err_code, reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* get the initial origin value */\n\t\t\tif(!err_code && !(ss->origin_set) && (method == STUN_METHOD_ALLOCATE)) {\n\n\t\t\t\tstun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\t\t\tint origin_found = 0;\n\n\t\t\t\twhile(sar && !origin_found) {\n\t\t\t\t\tif(stun_attr_get_type(sar) == STUN_ATTRIBUTE_ORIGIN) {\n\t\t\t\t\t\tint sarlen = stun_attr_get_len(sar);\n\t\t\t\t\t\tif(sarlen>0) {\n\t\t\t\t\t\t\tchar *o = (char*)malloc(sarlen+1);\n\t\t\t\t\t\t\tbcopy(stun_attr_get_value(sar),o,sarlen);\n\t\t\t\t\t\t\to[sarlen]=0;\n\t\t\t\t\t\t\tchar *corigin = (char*)malloc(STUN_MAX_ORIGIN_SIZE+1);\n\t\t\t\t\t\t\tcorigin[0]=0;\n\t\t\t\t\t\t\tif(get_canonic_origin(o,corigin,STUN_MAX_ORIGIN_SIZE)<0) {\n\t\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,\n\t\t\t\t\t\t\t\t\t\"%s: Wrong origin format: %s\\n\",\n\t\t\t\t\t\t\t\t\t__FUNCTION__, o);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstrncpy(ss->origin,corigin,STUN_MAX_ORIGIN_SIZE);\n\t\t\t\t\t\t\tfree(corigin);\n\t\t\t\t\t\t\tfree(o);\n\t\t\t\t\t\t\torigin_found = get_realm_options_by_origin(ss->origin,&(ss->realm_options));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh), sar);\n\t\t\t\t}\n\n\t\t\t\tss->origin_set = 1;\n\t\t\t}\n\n\t\t\tif(!err_code && !(*resp_constructed) && !no_response) {\n\t\t\t\tif(method == STUN_METHOD_CONNECTION_BIND) {\n\t\t\t\t\t;\n\t\t\t\t} else if(!(*(server->mobility)) || (method != STUN_METHOD_REFRESH) || is_allocation_valid(get_allocation_ss(ss))) {\n\t\t\t\t\tint postpone_reply = 0;\n\t\t\t\t\tcheck_stun_auth(server, ss, &tid, resp_constructed, &err_code, &reason, in_buffer, nbh, method, &message_integrity, &postpone_reply, can_resume);\n\t\t\t\t\tif(postpone_reply)\n\t\t\t\t\t\tno_response = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!err_code && !(*resp_constructed) && !no_response) {\n\n\t\t\tswitch (method){\n\n\t\t\tcase STUN_METHOD_ALLOCATE:\n\n\t\t\t{\n\t\t\t\thandle_turn_allocate(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"ALLOCATE\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase STUN_METHOD_CONNECT:\n\n\t\t\t\thandle_turn_connect(server, ss, &tid, &err_code, &reason,\n\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"CONNECT\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tif(!err_code)\n\t\t\t\t\tno_response = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_CONNECTION_BIND:\n\n\t\t\t\thandle_turn_connection_bind(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh, message_integrity, can_resume);\n\n\t\t\t\tif(server->verbose && err_code) {\n\t\t\t\t  log_method(ss, \"CONNECTION_BIND\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_REFRESH:\n\n\t\t\t\thandle_turn_refresh(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh, message_integrity,\n\t\t\t\t\t\t\t\t&no_response, can_resume);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"REFRESH\", err_code, reason);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_CHANNEL_BIND:\n\n\t\t\t\thandle_turn_channel_bind(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"CHANNEL_BIND\", err_code, reason);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_CREATE_PERMISSION:\n\n\t\t\t\thandle_turn_create_permission(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh);\n\n\t\t\t\tif(server->verbose) {\n\t\t\t\t  log_method(ss, \"CREATE_PERMISSION\", err_code, reason);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_BINDING:\n\n\t\t\t{\n\t\t\t\tint origin_changed=0;\n\t\t\t\tioa_addr response_origin;\n\t\t\t\tint dest_changed=0;\n\t\t\t\tioa_addr response_destination;\n\n\t\t\t\thandle_turn_binding(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh,\n\t\t\t\t\t\t\t&origin_changed, &response_origin,\n\t\t\t\t\t\t\t&dest_changed, &response_destination,\n\t\t\t\t\t\t\t0, 0);\n\n\t\t\t\tif(server->verbose && server->log_binding) {\n\t\t\t\t  log_method(ss, \"BINDING\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tif(*resp_constructed && !err_code && (origin_changed || dest_changed)) {\n\n\t\t\t\t\tif (server->verbose && server->log_binding) {\n\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"RFC 5780 request successfully processed\\n\");\n\t\t\t\t\t}\n\n\t\t\t\t\t{\n\t\t\t\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\t\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t\t}\n\n\t\t\t\t\tsend_turn_message_to(server, nbh, &response_origin, &response_destination);\n\n\t\t\t\t\tno_response = 1;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, \"Unsupported STUN request received, method 0x%x\\n\",(unsigned int)method);\n\t\t\t};\n\t\t}\n\n\t} else if (stun_is_indication_str(ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh))) {\n\n\t\tno_response = 1;\n\t\tint postpone = 0;\n\n\t\tif (!postpone && !err_code) {\n\n\t\t\tswitch (method){\n\n\t\t\tcase STUN_METHOD_BINDING:\n\t\t\t\t//ICE ?\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_SEND:\n\n\t\t\t\thandle_turn_send(server, ss, &err_code, &reason, unknown_attrs, &ua_num, in_buffer);\n\n\t\t\t\tif(eve(server->verbose)) {\n\t\t\t\t  log_method(ss, \"SEND\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase STUN_METHOD_DATA:\n\n\t\t\t\terr_code = 403;\n\n\t\t\t\tif(eve(server->verbose)) {\n\t\t\t\t  log_method(ss, \"DATA\", err_code, reason);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (server->verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Unsupported STUN indication received: method 0x%x\\n\",(unsigned int)method);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t} else {\n\n\t\tno_response = 1;\n\n\t\tif (server->verbose) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Wrong STUN message received\\n\");\n\t\t}\n\t}\n\n\tif(ss->to_be_closed || !(ss->client_socket) || ioa_socket_tobeclosed(ss->client_socket))\n\t\treturn 0;\n\n\tif (ua_num > 0) {\n\n\t\terr_code = 420;\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, NULL, &tid);\n\n\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_UNKNOWN_ATTRIBUTES, (const uint8_t*) unknown_attrs, (ua_num\n\t\t\t\t\t\t* 2));\n\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t*resp_constructed = 1;\n\t}\n\n\tif (!no_response) {\n\n\t\tif (!(*resp_constructed)) {\n\n\t\t\tif (!err_code)\n\t\t\t\terr_code = 400;\n\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, reason, &tid);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t*resp_constructed = 1;\n\t\t}\n\n\t\t{\n\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif(message_integrity) {\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t}\n\n\t\tif(err_code) {\n\t\t\tif(server->verbose) {\n\t\t\t  log_method(ss, \"message\", err_code, reason);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t*resp_constructed = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_old_stun_command(turn_turnserver *server, ts_ur_super_session *ss, ioa_net_data *in_buffer, ioa_network_buffer_handle nbh, int *resp_constructed, uint32_t cookie)\n{\n\n\tstun_tid tid;\n\tint err_code = 0;\n\tconst uint8_t *reason = NULL;\n\tint no_response = 0;\n\n\tuint16_t unknown_attrs[MAX_NUMBER_OF_UNKNOWN_ATTRS];\n\tuint16_t ua_num = 0;\n\tuint16_t method = stun_get_method_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t     ioa_network_buffer_get_size(in_buffer->nbh));\n\n\t*resp_constructed = 0;\n\n\tstun_tid_from_message_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t  ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t  &tid);\n\n\tif (stun_is_request_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh))) {\n\n\t\tif(method != STUN_METHOD_BINDING) {\n\t\t\tno_response = 1;\n\t\t\tif(server->verbose) {\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\"%s: OLD STUN method 0x%x ignored\\n\",\n\t\t\t\t\t\t\t__FUNCTION__, (unsigned int)method);\n\t\t\t}\n\t\t}\n\n\t\tif (!err_code && !(*resp_constructed) && !no_response) {\n\n\t\t\tint origin_changed=0;\n\t\t\tioa_addr response_origin;\n\t\t\tint dest_changed=0;\n\t\t\tioa_addr response_destination;\n\n\t\t\thandle_turn_binding(server, ss, &tid, resp_constructed, &err_code, &reason,\n\t\t\t\t\t\tunknown_attrs, &ua_num, in_buffer, nbh,\n\t\t\t\t\t\t&origin_changed, &response_origin,\n\t\t\t\t\t\t&dest_changed, &response_destination,\n\t\t\t\t\t\tcookie,1);\n\n\t\t\tif(server->verbose && *(server->log_binding)) {\n\t\t\t  log_method(ss, \"OLD BINDING\", err_code, reason);\n\t\t\t}\n\n\t\t\tif(*resp_constructed && !err_code && (origin_changed || dest_changed)) {\n\n\t\t\t\tif (server->verbose) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"RFC3489 CHANGE request successfully processed\\n\");\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tsize_t oldsz = strlen(get_version(server));\n\t\t\t\t\tsize_t newsz = (((oldsz)>>2) + 1)<<2;\n\t\t\t\t\tuint8_t software[120];\n\t\t\t\t\tbzero(software,sizeof(software));\n\t\t\t\t\tif(newsz>sizeof(software))\n\t\t\t\t\t\tnewsz = sizeof(software);\n\t\t\t\t\tbcopy(get_version(server),software,oldsz);\n\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, OLD_STUN_ATTRIBUTE_SERVER, software, newsz);\n\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t}\n\n\t\t\t\tsend_turn_message_to(server, nbh, &response_origin, &response_destination);\n\n\t\t\t\tno_response = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\tno_response = 1;\n\n\t\tif (server->verbose) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Wrong OLD STUN message received\\n\");\n\t\t}\n\t}\n\n\tif (ua_num > 0) {\n\n\t\terr_code = 420;\n\n\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\told_stun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, NULL, &tid, cookie);\n\n\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_UNKNOWN_ATTRIBUTES, (const uint8_t*) unknown_attrs, (ua_num * 2));\n\n\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t*resp_constructed = 1;\n\t}\n\n\tif (!no_response) {\n\n\t\tif (!(*resp_constructed)) {\n\n\t\t\tif (!err_code)\n\t\t\t\terr_code = 400;\n\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\told_stun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, reason, &tid, cookie);\n\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t*resp_constructed = 1;\n\t\t}\n\n\t\t{\n\t\t\tsize_t oldsz = strlen(get_version(server));\n\t\t\tsize_t newsz = (((oldsz)>>2) + 1)<<2;\n\t\t\tuint8_t software[120];\n\t\t\tbzero(software,sizeof(software));\n\t\t\tif(newsz>sizeof(software))\n\t\t\t\tnewsz = sizeof(software);\n\t\t\tbcopy(get_version(server),software,oldsz);\n\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, OLD_STUN_ATTRIBUTE_SERVER, software, newsz);\n\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t}\n\n\t\tif(err_code) {\n\t\t\tif(server->verbose) {\n\t\t\t  log_method(ss, \"OLD STUN message\", err_code, reason);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t*resp_constructed = 0;\n\t}\n\n\treturn 0;\n}\n\n//////////////////////////////////////////////////////////////////\n\nstatic int write_to_peerchannel(ts_ur_super_session* ss, uint16_t chnum, ioa_net_data *in_buffer) {\n\n\tint rc = 0;\n\n\tif (ss && (in_buffer->recv_ttl!=0)) {\n\n\t\tallocation* a = get_allocation_ss(ss);\n\n\t\tif (is_allocation_valid(a)) {\n\n\t\t\tch_info* chn = allocation_get_ch_info(a, chnum);\n\n\t\t\tif (!chn)\n\t\t\t\treturn -1;\n\n\t\t\t/* Channel packets are always sent with DF=0: */\n\t\t\tset_df_on_ioa_socket(get_relay_socket_ss(ss, chn->peer_addr.ss.sa_family), 0);\n\n\t\t\tioa_network_buffer_handle nbh = in_buffer->nbh;\n\n\t\t\tioa_network_buffer_add_offset_size(in_buffer->nbh, STUN_CHANNEL_HEADER_LENGTH, 0, ioa_network_buffer_get_size(in_buffer->nbh)-STUN_CHANNEL_HEADER_LENGTH);\n\n\t\t\tioa_network_buffer_header_init(nbh);\n\n\t\t\tint skip = 0;\n\t\t\trc = send_data_from_ioa_socket_nbh(get_relay_socket_ss(ss, chn->peer_addr.ss.sa_family), &(chn->peer_addr), nbh, in_buffer->recv_ttl-1, in_buffer->recv_tos, &skip);\n\n\t\t\tif (!skip && rc > -1) {\n\t\t\t\t++(ss->peer_sent_packets);\n\t\t\t\tss->peer_sent_bytes += (uint32_t)ioa_network_buffer_get_size(in_buffer->nbh);\n\t\t\t\tturn_report_session_usage(ss, 0);\n\t\t\t}\n\n\t\t\tin_buffer->nbh = NULL;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic void client_input_handler(ioa_socket_handle s, int event_type,\n\t\tioa_net_data *data, void *arg, int can_resume);\nstatic void peer_input_handler(ioa_socket_handle s, int event_type,\n\t\tioa_net_data *data, void *arg, int can_resume);\n\n/////////////// Client actions /////////////////\n\nint shutdown_client_connection(turn_turnserver *server, ts_ur_super_session *ss, int force, const char* reason) {\n\n\tFUNCSTART;\n\n\tif (!ss)\n\t\treturn -1;\n\n\tturn_report_session_usage(ss, 1);\n\tdec_quota(ss);\n\tdec_bps(ss);\n\n\tallocation* alloc = get_allocation_ss(ss);\n\tif (!is_allocation_valid(alloc)) {\n\t\tforce = 1;\n\t}\n\n\tif(!force && ss->is_mobile) {\n\n\t\tif (ss->client_socket && server->verbose) {\n\n\t\t\tchar sraddr[129]=\"\\0\";\n\t\t\tchar sladdr[129]=\"\\0\";\n\t\t\taddr_to_string(get_remote_addr_from_ioa_socket(ss->client_socket),(uint8_t*)sraddr);\n\t\t\taddr_to_string(get_local_addr_from_ioa_socket(ss->client_socket),(uint8_t*)sladdr);\n\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"session %018llu: closed (1st stage), user <%s> realm <%s> origin <%s>, local %s, remote %s, reason: %s\\n\",(unsigned long long)(ss->id),(char*)ss->username,(char*)ss->realm_options.name,(char*)ss->origin, sladdr,sraddr,reason);\n\t\t}\n\n\t\tIOA_CLOSE_SOCKET(ss->client_socket);\n\n\t\tFUNCEND;\n\n\t\treturn 0;\n\t}\n\n\tif (eve(server->verbose)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\"closing session 0x%lx, client socket 0x%lx (socket session=0x%lx)\\n\",\n\t\t\t\t(long) ss,\n\t\t\t\t(long) ss->client_socket,\n\t\t\t\t(long)get_ioa_socket_session(ss->client_socket));\n\t}\n\n\tif (server->disconnect)\n\t\tserver->disconnect(ss);\n\n\tif (server->verbose) {\n\n\t\tchar sraddr[129]=\"\\0\";\n\t\tchar sladdr[129]=\"\\0\";\n\t\taddr_to_string(get_remote_addr_from_ioa_socket(ss->client_socket),(uint8_t*)sraddr);\n\t\taddr_to_string(get_local_addr_from_ioa_socket(ss->client_socket),(uint8_t*)sladdr);\n\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"session %018llu: closed (2nd stage), user <%s> realm <%s> origin <%s>, local %s, remote %s, reason: %s\\n\",\n\t\t\t\t\t(unsigned long long)(ss->id), (char*)ss->username,(char*)ss->realm_options.name,(char*)ss->origin, sladdr,sraddr, reason);\n\t}\n\n\tIOA_CLOSE_SOCKET(ss->client_socket);\n\t{\n\t\tint i;\n\t\tfor(i=0;i<ALLOC_PROTOCOLS_NUMBER;++i) {\n\t\t\tIOA_CLOSE_SOCKET(ss->alloc.relay_sessions[i].s);\n\t\t}\n\t}\n\n\tturn_server_remove_all_from_ur_map_ss(ss);\n\n\tFUNCEND;\n\n\treturn 0;\n}\n\nstatic void client_to_be_allocated_timeout_handler(ioa_engine_handle e,\n\t\tvoid *arg) {\n\n\tif (!arg)\n\t\treturn;\n\n\tUNUSED_ARG(e);\n\n\tts_ur_super_session* ss = (ts_ur_super_session*) arg;\n\n\tturn_turnserver* server = (turn_turnserver*) (ss->server);\n\n\tif (!server)\n\t\treturn;\n\n\tFUNCSTART;\n\n\tint to_close = 0;\n\n\tioa_socket_handle s = ss->client_socket;\n\n\tif(!s || ioa_socket_tobeclosed(s)) {\n\t\tto_close = 1;\n\t} else if(get_ioa_socket_app_type(s) == HTTPS_CLIENT_SOCKET) {\n\t\t;\n\t} else {\n\t\tioa_socket_handle rs4 = ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s;\n\t\tioa_socket_handle rs6 = ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s;\n\t\tif((!rs4 || ioa_socket_tobeclosed(rs4)) && (!rs6 || ioa_socket_tobeclosed(rs6))) {\n\t\t\tto_close = 1;\n\t\t} else if(ss->client_socket == NULL) {\n\t\t\tto_close = 1;\n\t\t} else if(!(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].lifetime_ev) &&\n\t\t\t\t!(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].lifetime_ev)) {\n\t\t\tto_close = 1;\n\t\t} else if(!(ss->to_be_allocated_timeout_ev)) {\n\t\t\tto_close = 1;\n\t\t}\n\t}\n\n\tif(to_close) {\n\t\tIOA_EVENT_DEL(ss->to_be_allocated_timeout_ev);\n\t\tshutdown_client_connection(server, ss, 1, \"allocation watchdog determined stale session state\");\n\t}\n\n\tFUNCEND;\n}\n\nstatic int write_client_connection(turn_turnserver *server, ts_ur_super_session* ss, ioa_network_buffer_handle nbh, int ttl, int tos) {\n\n\tFUNCSTART;\n\n\tif (!(ss->client_socket)) {\n\t\tioa_network_buffer_delete(server->e, nbh);\n\t\tFUNCEND;\n\t\treturn -1;\n\t} else {\n\n\t\tif (eve(server->verbose)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\"%s: prepare to write to s 0x%lx\\n\", __FUNCTION__,\n\t\t\t\t(long) (ss->client_socket));\n\t\t}\n\n\t\tint skip = 0;\n\t\tint ret = send_data_from_ioa_socket_nbh(ss->client_socket, NULL, nbh, ttl, tos, &skip);\n\n\t\tif(!skip && ret>-1) {\n\t\t\t++(ss->sent_packets);\n\t\t\tss->sent_bytes += (uint32_t)ioa_network_buffer_get_size(nbh);\n\t\t\tturn_report_session_usage(ss, 0);\n\t\t}\n\n\t\tFUNCEND;\n\t\treturn ret;\n\t}\n}\n\nstatic void client_ss_allocation_timeout_handler(ioa_engine_handle e, void *arg) {\n\n\tUNUSED_ARG(e);\n\n\tif (!arg)\n\t\treturn;\n\n\trelay_endpoint_session *rsession = (relay_endpoint_session*)arg;\n\n\tif(!(rsession->s))\n\t\treturn;\n\n\tts_ur_super_session* ss = get_ioa_socket_session(rsession->s);\n\n\tif (!ss)\n\t\treturn;\n\n\tallocation* a =  get_allocation_ss(ss);\n\n\tturn_turnserver* server = (turn_turnserver*) (ss->server);\n\n\tif (!server) {\n\t\tclear_allocation(a);\n\t\treturn;\n\t}\n\n\tFUNCSTART;\n\n\tint family = get_ioa_socket_address_family(rsession->s);\n\n\tset_allocation_family_invalid(a,family);\n\n\tif(!get_relay_socket(a, AF_INET) && !get_relay_socket(a, AF_INET6)) {\n\t\tshutdown_client_connection(server, ss, 0, \"allocation timeout\");\n\t}\n\n\tFUNCEND;\n}\n\nstatic int create_relay_connection(turn_turnserver* server,\n\t\t\t\t   ts_ur_super_session *ss, uint32_t lifetime,\n\t\t\t\t   int address_family, uint8_t transport,\n\t\t\t\t   int even_port, uint64_t in_reservation_token, uint64_t *out_reservation_token,\n\t\t\t\t   int *err_code, const uint8_t **reason,\n\t\t\t\t   accept_cb acb) {\n\n\tif (server && ss && ss->client_socket && !ioa_socket_tobeclosed(ss->client_socket)) {\n\n\t\tallocation* a = get_allocation_ss(ss);\n\t\trelay_endpoint_session* newelem = NULL;\n\t\tioa_socket_handle rtcp_s = NULL;\n\n\t\tif (in_reservation_token) {\n\n\t\t\tioa_socket_handle s = NULL;\n\n\t\t\tif ((get_ioa_socket_from_reservation(server->e, in_reservation_token,&s) < 0)||\n\t\t\t\t!s ||\n\t\t\t\tioa_socket_tobeclosed(s)) {\n\n\t\t\t\tIOA_CLOSE_SOCKET(s);\n\t\t\t\t*err_code = 404;\n\t\t\t\t*reason = (const uint8_t *)\"Cannot find reserved socket\";\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint family = get_ioa_socket_address_family(s);\n\n\t\t\tnewelem = get_relay_session_ss(ss,family);\n\n\t\t\tif(newelem->s != s) {\n\n\t\t\t\tIOA_CLOSE_SOCKET(newelem->s);\n\n\t\t\t\tbzero(newelem, sizeof(relay_endpoint_session));\n\t\t\t\tnewelem->s = s;\n\t\t\t}\n\n\t\t\taddr_debug_print(server->verbose, get_local_addr_from_ioa_socket(newelem->s), \"Local relay addr (RTCP)\");\n\n\t\t} else {\n\t\t\tint family = get_family(address_family,server->e,ss->client_socket);\n\n\t\t\tnewelem = get_relay_session_ss(ss,family);\n\n\n\t\t\tIOA_CLOSE_SOCKET(newelem->s);\n\n\t\t\tbzero(newelem, sizeof(relay_endpoint_session));\n\t\t\tnewelem->s = NULL;\n\n\t\t\tint res = create_relay_ioa_sockets(server->e,\n\t\t\t\t\t\t\tss->client_socket,\n\t\t\t\t\t\t\taddress_family, transport,\n\t\t\t\t\t\t\teven_port, &(newelem->s), &rtcp_s, out_reservation_token,\n\t\t\t\t\t\t\terr_code, reason, acb, ss);\n\t\t\tif (res < 0) {\n\t\t\t\tif(!(*err_code))\n\t\t\t\t\t*err_code = 508;\n\t\t\t\tif(!(*reason))\n\t\t\t\t\t*reason = (const uint8_t *)\"Cannot create socket\";\n\t\t\t\tIOA_CLOSE_SOCKET(newelem->s);\n\t\t\t\tIOA_CLOSE_SOCKET(rtcp_s);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (newelem->s == NULL) {\n\t\t\tIOA_CLOSE_SOCKET(rtcp_s);\n\t\t\t*err_code = 508;\n\t\t\t*reason = (const uint8_t *)\"Cannot create relay socket\";\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rtcp_s) {\n\t\t\tif (out_reservation_token && *out_reservation_token) {\n\t\t\t\t/* OK */\n\t\t\t} else {\n\t\t\t\tIOA_CLOSE_SOCKET(newelem->s);\n\t\t\t\tIOA_CLOSE_SOCKET(rtcp_s);\n\t\t\t\t*err_code = 500;\n\t\t\t\t*reason = (const uint8_t *)\"Wrong reservation tokens (internal error)\";\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* RFC6156: do not use DF when IPv6 is involved: */\n\t\tif((get_ioa_socket_address_family(newelem->s) == AF_INET6) ||\n\t\t   (get_ioa_socket_address_family(ss->client_socket) == AF_INET6))\n\t\t\tset_do_not_use_df(newelem->s);\n\n\t\tif(get_ioa_socket_type(newelem->s) != TCP_SOCKET) {\n\t\t\tif(register_callback_on_ioa_socket(server->e, newelem->s, IOA_EV_READ,peer_input_handler, ss, 0)<0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (lifetime<1)\n\t\t\tlifetime = STUN_DEFAULT_ALLOCATE_LIFETIME;\n\t\telse if(lifetime>(uint32_t)*(server->max_allocate_lifetime))\n\t\t\tlifetime = (uint32_t)*(server->max_allocate_lifetime);\n\n\t\tioa_timer_handle ev = set_ioa_timer(server->e, lifetime, 0,\n\t\t\t\tclient_ss_allocation_timeout_handler, newelem, 0,\n\t\t\t\t\"client_ss_allocation_timeout_handler\");\n\t\tset_allocation_lifetime_ev(a, server->ctime + lifetime, ev, get_ioa_socket_address_family(newelem->s));\n\n\t\tset_ioa_socket_session(newelem->s, ss);\n\t}\n\n\treturn 0;\n}\n\nstatic int refresh_relay_connection(turn_turnserver* server,\n\t\tts_ur_super_session *ss, uint32_t lifetime, int even_port,\n\t\tuint64_t in_reservation_token, uint64_t *out_reservation_token,\n\t\tint *err_code, int family) {\n\n\tUNUSED_ARG(even_port);\n\tUNUSED_ARG(in_reservation_token);\n\tUNUSED_ARG(out_reservation_token);\n\tUNUSED_ARG(err_code);\n\n\tallocation* a = get_allocation_ss(ss);\n\n\tif (server && ss && is_allocation_valid(a)) {\n\n\t\tif (lifetime < 1) {\n\t\t\tlifetime = 1;\n\t\t}\n\n\t\tioa_timer_handle ev = set_ioa_timer(server->e, lifetime, 0,\n\t\t\t\tclient_ss_allocation_timeout_handler, get_relay_session(a,family), 0,\n\t\t\t\t\"refresh_client_ss_allocation_timeout_handler\");\n\n\t\tset_allocation_lifetime_ev(a, server->ctime + lifetime, ev, family);\n\n\t\treturn 0;\n\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic int read_client_connection(turn_turnserver *server,\n\t\t\t\t  \t  \t  \t  \t  ts_ur_super_session *ss, ioa_net_data *in_buffer,\n\t\t\t\t  \t  \t  \t  \t  int can_resume, int count_usage) {\n\n\tFUNCSTART;\n\n\tif (!server || !ss || !in_buffer || !(ss->client_socket) || ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tint ret = (int)ioa_network_buffer_get_size(in_buffer->nbh);\n\tif (ret < 0) {\n\t\tFUNCEND;\n\t\treturn -1;\n\t}\n\n\tif(count_usage) {\n\t\t++(ss->received_packets);\n\t\tss->received_bytes += (uint32_t)ioa_network_buffer_get_size(in_buffer->nbh);\n\t\tturn_report_session_usage(ss, 0);\n\t}\n\n\tif (eve(server->verbose)) {\n\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t      \"%s: data.buffer=0x%lx, data.len=%ld\\n\", __FUNCTION__,\n\t\t\t      (long)ioa_network_buffer_data(in_buffer->nbh), \n\t\t\t      (long)ioa_network_buffer_get_size(in_buffer->nbh));\n\t}\n\n\tuint16_t chnum = 0;\n\tuint32_t old_stun_cookie = 0;\n\n\tsize_t blen = ioa_network_buffer_get_size(in_buffer->nbh);\n\tsize_t orig_blen = blen;\n\tSOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);\n\tSOCKET_APP_TYPE sat = get_ioa_socket_app_type(ss->client_socket);\n\tint is_padding_mandatory = is_stream_socket(st);\n\n\tif(sat == HTTP_CLIENT_SOCKET) {\n\n\t\tif(server->verbose) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: HTTP connection input: %s\\n\", __FUNCTION__, (char*)ioa_network_buffer_data(in_buffer->nbh));\n\t\t}\n\n\t\thandle_http_echo(ss->client_socket);\n\n\t} else if(sat == HTTPS_CLIENT_SOCKET) {\n\n\t\t//???\n\n\t} else if (stun_is_channel_message_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t&blen,\n\t\t\t\t\t&chnum,\n\t\t\t\t\tis_padding_mandatory)) {\n\n\t\tif(ss->is_tcp_relay) {\n\t\t\t//Forbidden\n\t\t\tFUNCEND;\n\t\t\treturn -1;\n\t\t}\n\n\t\tint rc = 0;\n\n\t\tif(blen<=orig_blen) {\n\t\t\tioa_network_buffer_set_size(in_buffer->nbh,blen);\n\t\t\trc = write_to_peerchannel(ss, chnum, in_buffer);\n\t\t}\n\n\t\tif (eve(server->verbose)) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: wrote to peer %d bytes\\n\",\n\t\t\t\t\t__FUNCTION__, (int) rc);\n\t\t}\n\n\t\tFUNCEND;\n\t\treturn 0;\n\n\t} else if (stun_is_command_message_full_check_str(ioa_network_buffer_data(in_buffer->nbh), ioa_network_buffer_get_size(in_buffer->nbh), 0, &(ss->enforce_fingerprints))) {\n\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tint resp_constructed = 0;\n\n\t\tuint16_t method = stun_get_method_str(ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh));\n\n\t\thandle_turn_command(server, ss, in_buffer, nbh, &resp_constructed, can_resume);\n\n\t\tif((method != STUN_METHOD_BINDING) && (method != STUN_METHOD_SEND))\n\t\t\treport_turn_session_info(server,ss,0);\n\n\t\tif(ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {\n\t\t\tFUNCEND;\n\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (resp_constructed) {\n\n\t\t\tif ((server->fingerprint) || ss->enforce_fingerprints) {\n\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\tif (stun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len) < 0) {\n\t\t\t\t\tFUNCEND\t;\n\t\t\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t}\n\n\t\t\tint ret = write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\n\t\t\tFUNCEND\t;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (old_stun_is_command_message_str(ioa_network_buffer_data(in_buffer->nbh), ioa_network_buffer_get_size(in_buffer->nbh), &old_stun_cookie) && !(*(server->no_stun))) {\n\n\t\tioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);\n\t\tint resp_constructed = 0;\n\n\t\thandle_old_stun_command(server, ss, in_buffer, nbh, &resp_constructed, old_stun_cookie);\n\n\t\tif (resp_constructed) {\n\n\t\t\tint ret = write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);\n\n\t\t\tFUNCEND\t;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tioa_network_buffer_delete(server->e, nbh);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tSOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);\n\t\tif(is_stream_socket(st)) {\n\t\t\tif(is_http((char*)ioa_network_buffer_data(in_buffer->nbh),\n\t\t\tioa_network_buffer_get_size(in_buffer->nbh))) {\n\n\t\t\t\tconst char *proto = \"HTTP\";\n\t\t\t\tif ((st == TCP_SOCKET) &&\n\t\t\t\t\t(\n\t\t\t\t\t\ttry_acme_redirect(\n\t\t\t\t\t\t\t(char*)ioa_network_buffer_data(in_buffer->nbh),\n\t\t\t\t\t\t\tioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t\t\t\t\tserver->acme_redirect,\n\t\t\t\t\t\t\tss->client_socket\n\t\t\t\t\t\t) == 0\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tss->to_be_closed = 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else if (*server->web_admin_listen_on_workers) {\n\t\t\t\t\tif(st==TLS_SOCKET) {\n\t\t\t\t\t\tproto = \"HTTPS\";\n\t\t\t\t\t\tset_ioa_socket_app_type(ss->client_socket,HTTPS_CLIENT_SOCKET);\n\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: %s (%s %s) request: %s\\n\", __FUNCTION__, proto, get_ioa_socket_cipher(ss->client_socket), get_ioa_socket_ssl_method(ss->client_socket), ioa_network_buffer_get_size(in_buffer->nbh));\n\t\t\t\t\t\tif(server->send_https_socket) {\n\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s socket to be detached: 0x%lx, st=%d, sat=%d\\n\", __FUNCTION__,(long)ss->client_socket, get_ioa_socket_type(ss->client_socket), get_ioa_socket_app_type(ss->client_socket));\n\t\t\t\t\t\t\tioa_socket_handle new_s = detach_ioa_socket(ss->client_socket);\n\t\t\t\t\t\t\tif(new_s) {\n\t\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s new detached socket: 0x%lx, st=%d, sat=%d\\n\", __FUNCTION__,(long)new_s, get_ioa_socket_type(new_s), get_ioa_socket_app_type(new_s));\n\t\t\t\t\t\t\t\tserver->send_https_socket(new_s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tss->to_be_closed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset_ioa_socket_app_type(ss->client_socket,HTTP_CLIENT_SOCKET);\n\t\t\t\t\t\tif(server->verbose) {\n\t\t\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"%s: %s request: %s\\n\", __FUNCTION__, proto, ioa_network_buffer_get_size(in_buffer->nbh));\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandle_http_echo(ss->client_socket);\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tss->to_be_closed = 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \n\t//Unrecognized message received, ignore it\n\n\tFUNCEND;\n\treturn -1;\n}\n\nstatic int attach_socket_to_session(turn_turnserver* server, ioa_socket_handle s, ts_ur_super_session* ss) {\n\n\tint ret = -1;\n\tFUNCSTART;\n\n\tif(s && server && ss && !ioa_socket_tobeclosed(s)) {\n\n\t\tif(ss->client_socket != s) {\n\n\t\t\tIOA_CLOSE_SOCKET(ss->client_socket);\n\n\t\t\tss->client_socket = s;\n\n\t\t\tif(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ,\n\t\t\t\t\tclient_input_handler, ss, 0)<0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tset_ioa_socket_session(s, ss);\n\t\t}\n\n\t\tret = 0;\n\t}\n\n\tFUNCEND;\n\treturn ret;\n}\n\nint open_client_connection_session(turn_turnserver* server,\n\t\t\t\tstruct socket_message *sm) {\n\n\tFUNCSTART;\n\tif (!server)\n\t\treturn -1;\n\n\tif (!(sm->s))\n\t\treturn -1;\n\n\tts_ur_super_session* ss = create_new_ss(server);\n\n\tss->client_socket = sm->s;\n\n\tif(register_callback_on_ioa_socket(server->e, ss->client_socket, IOA_EV_READ,\n\t\t\tclient_input_handler, ss, 0)<0) {\n\t\treturn -1;\n\t}\n\n\tset_ioa_socket_session(ss->client_socket, ss);\n\n\tint at = TURN_MAX_ALLOCATE_TIMEOUT;\n\tif(*(server->stun_only))\n\t  at = TURN_MAX_ALLOCATE_TIMEOUT_STUN_ONLY;\n\n\tIOA_EVENT_DEL(ss->to_be_allocated_timeout_ev);\n\tss->to_be_allocated_timeout_ev = set_ioa_timer(server->e,\n\t\t\tat, 0,\n\t\t\tclient_to_be_allocated_timeout_handler, ss, 1,\n\t\t\t\"client_to_be_allocated_timeout_handler\");\n\n\tif(sm->nd.nbh) {\n\t\tclient_input_handler(ss->client_socket,IOA_EV_READ,&(sm->nd),ss,sm->can_resume);\n\t\tioa_network_buffer_delete(server->e, sm->nd.nbh);\n\t\tsm->nd.nbh = NULL;\n\t}\n\n\tFUNCEND;\n\n\treturn 0;\n}\n\n/////////////// io handlers ///////////////////\n\nstatic void peer_input_handler(ioa_socket_handle s, int event_type,\n\t\tioa_net_data *in_buffer, void *arg, int can_resume) {\n\n\tif (!(event_type & IOA_EV_READ) || !arg) return;\n\n\tif(in_buffer->recv_ttl==0) return;\n\n\tUNUSED_ARG(can_resume);\n\n\tif(!s || ioa_socket_tobeclosed(s)) return;\n\n\tts_ur_super_session* ss = (ts_ur_super_session*) arg;\n\n\tif(!ss) return;\n\n\tif(ss->to_be_closed) return;\n\n\tif(!(ss->client_socket) || ioa_socket_tobeclosed(ss->client_socket)) return;\n\n\tturn_turnserver *server = (turn_turnserver*) (ss->server);\n\n\tif (!server) return;\n\n\trelay_endpoint_session* elem = get_relay_session_ss(ss, get_ioa_socket_address_family(s));\n\tif (elem->s == NULL) {\n\t\treturn;\n\t}\n\n\tint offset = STUN_CHANNEL_HEADER_LENGTH;\n\n\tint ilen = min((int)ioa_network_buffer_get_size(in_buffer->nbh),\n\t\t\t(int)(ioa_network_buffer_get_capacity_udp() - offset));\n\n\tif (ilen >= 0) {\n\t\t++(ss->peer_received_packets);\n\t\tss->peer_received_bytes += ilen;\n\t\tturn_report_session_usage(ss, 0);\n\n\t\tallocation* a = get_allocation_ss(ss);\n\t\tif (is_allocation_valid(a)) {\n\n\t\t\tuint16_t chnum = 0;\n\n\t\t\tioa_network_buffer_handle nbh = NULL;\n\n\t\t\tturn_permission_info* tinfo = allocation_get_permission(a,\n\t\t\t\t\t\t\t&(in_buffer->src_addr));\n\t\t\tif (tinfo) {\n\t\t\t\tchnum = get_turn_channel_number(tinfo, &(in_buffer->src_addr));\n\t\t\t} else if(!(server->server_relay)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (chnum) {\n\n\t\t\t\tsize_t len = (size_t)(ilen);\n\n\t\t\t\tnbh = in_buffer->nbh;\n\n\t\t\t\tioa_network_buffer_add_offset_size(nbh,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tSTUN_CHANNEL_HEADER_LENGTH,\n\t\t\t\t\t\t\t\tioa_network_buffer_get_size(nbh)+STUN_CHANNEL_HEADER_LENGTH);\n\n\t\t\t\tioa_network_buffer_header_init(nbh);\n\n\t\t\t\tSOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);\n\t\t\t\tint do_padding = is_stream_socket(st);\n\n\t\t\t\tstun_init_channel_message_str(chnum, ioa_network_buffer_data(nbh), &len, len, do_padding);\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\t\t\t\tin_buffer->nbh = NULL;\n\t\t\t\tif (eve(server->verbose)) {\n\t\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\t\t\t\"%s: send channel 0x%x\\n\", __FUNCTION__,\n\t\t\t\t\t\t\t(int) (chnum));\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tsize_t len = 0;\n\n\t\t\t\tnbh = ioa_network_buffer_allocate(server->e);\n\t\t\t\tstun_init_indication_str(STUN_METHOD_DATA, ioa_network_buffer_data(nbh), &len);\n\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_DATA,\n\t\t\t\t\t\t\t\tioa_network_buffer_data(in_buffer->nbh), (size_t)ilen);\n\t\t\t\tstun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len,\n\t\t\t\t\t\tSTUN_ATTRIBUTE_XOR_PEER_ADDRESS,\n\t\t\t\t\t\t&(in_buffer->src_addr));\n\t\t\t\tioa_network_buffer_set_size(nbh,len);\n\n\t\t\t\t{\n\t\t\t\t\tconst uint8_t *field = (const uint8_t *) get_version(server);\n\t\t\t\t\tsize_t fsz = strlen(get_version(server));\n\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\tstun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);\n\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t}\n\n\t\t\t\tif ((server->fingerprint) || ss->enforce_fingerprints) {\n\t\t\t\t\tsize_t len = ioa_network_buffer_get_size(nbh);\n\t\t\t\t\tstun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len);\n\t\t\t\t\tioa_network_buffer_set_size(nbh, len);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (eve(server->verbose)) {\n\t\t\t\tuint16_t* t = (uint16_t*) ioa_network_buffer_data(nbh);\n\t\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, \"Send data: 0x%x\\n\",\n\t\t\t\t\t\t(int) (nswap16(t[0])));\n\t\t\t}\n\n\t\t\twrite_client_connection(server, ss, nbh, in_buffer->recv_ttl-1, in_buffer->recv_tos);\n\t\t}\n\t}\n}\n\nstatic void client_input_handler(ioa_socket_handle s, int event_type,\n\t\tioa_net_data *data, void *arg, int can_resume) {\n\n\tif (!arg)\n\t\treturn;\n\n\tUNUSED_ARG(s);\n\tUNUSED_ARG(event_type);\n\n\tts_ur_super_session* ss = (ts_ur_super_session*)arg;\n\n\tturn_turnserver *server = (turn_turnserver*)ss->server;\n\n\tif (!server) {\n\t\treturn;\n\t}\n\n\tif (ss->client_socket != s) {\n\t\treturn;\n\t}\n\n\tread_client_connection(server, ss, data, can_resume, 1);\n\n\tif (ss->to_be_closed) {\n\t\tif(server->verbose) {\n\t\t\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\n\t\t\t\t\"session %018llu: client socket to be closed in client handler: ss=0x%lx\\n\", (unsigned long long)(ss->id), (long)ss);\n\t\t}\n\t\tset_ioa_socket_tobeclosed(s);\n\t}\n}\n\n///////////////////////////////////////////////////////////\n\nvoid init_turn_server(turn_turnserver* server,\n\t\tturnserver_id id, int verbose, ioa_engine_handle e, turn_credential_type ct,\n\t\tint stun_port, int fingerprint, dont_fragment_option_t dont_fragment,\n\t\tget_user_key_cb userkeycb,\n\t\tcheck_new_allocation_quota_cb chquotacb,\n\t\trelease_allocation_quota_cb raqcb,\n\t\tioa_addr *external_ip,\n\t\tvintp check_origin,\n\t\tvintp no_tcp_relay,\n\t\tvintp no_udp_relay,\n\t\tvintp stale_nonce,\n\t\tvintp max_allocate_lifetime,\n\t\tvintp channel_lifetime,\n\t\tvintp permission_lifetime,\n\t\tvintp stun_only,\n\t\tvintp no_stun,\n\t\tvintp no_software_attribute,\n\t\tvintp web_admin_listen_on_workers,\n\t\tturn_server_addrs_list_t *alternate_servers_list,\n\t\tturn_server_addrs_list_t *tls_alternate_servers_list,\n\t\tturn_server_addrs_list_t *aux_servers_list,\n\t\tint self_udp_balance,\n\t\tvintp no_multicast_peers, vintp allow_loopback_peers,\n\t\tip_range_list_t* ip_whitelist, ip_range_list_t* ip_blacklist,\n\t\tsend_socket_to_relay_cb send_socket_to_relay,\n\t\tvintp secure_stun, vintp mobility, int server_relay,\n\t\tsend_turn_session_info_cb send_turn_session_info,\n\t\tsend_https_socket_cb send_https_socket,\n\t\tallocate_bps_cb allocate_bps_func,\n\t\tint oauth,\n\t\tconst char* oauth_server_name,\n\t\tconst char* acme_redirect,\n\t\tint keep_address_family,\n\t\tvintp log_binding) {\n\n\tif (!server)\n\t\treturn;\n\n\tbzero(server,sizeof(turn_turnserver));\n\n\tserver->e = e;\n\tserver->id = id;\n\tserver->ctime = turn_time();\n\tserver->session_id_counter = 0;\n\tserver->sessions_map = ur_map_create();\n\tserver->tcp_relay_connections = ur_map_create();\n\tserver->ct = ct;\n\tserver->userkeycb = userkeycb;\n\tserver->chquotacb = chquotacb;\n\tserver->raqcb = raqcb;\n\tserver->no_multicast_peers = no_multicast_peers;\n\tserver->allow_loopback_peers = allow_loopback_peers;\n\tserver->secure_stun = secure_stun;\n\tserver->mobility = mobility;\n\tserver->server_relay = server_relay;\n\tserver->send_turn_session_info = send_turn_session_info;\n\tserver->send_https_socket = send_https_socket;\n\tserver->oauth = oauth;\n\tif(oauth)\n\t\tserver->oauth_server_name = oauth_server_name;\n\tif(mobility)\n\t\tserver->mobile_connections_map = ur_map_create();\n\tserver->acme_redirect = acme_redirect;\n\n\tTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,\"turn server id=%d created\\n\",(int)id);\n\n\tserver->check_origin = check_origin;\n\tserver->no_tcp_relay = no_tcp_relay;\n\tserver->no_udp_relay = no_udp_relay;\n\n\tserver->alternate_servers_list = alternate_servers_list;\n\tserver->tls_alternate_servers_list = tls_alternate_servers_list;\n\tserver->aux_servers_list = aux_servers_list;\n\tserver->self_udp_balance = self_udp_balance;\n\n\tserver->stale_nonce = stale_nonce;\n\tserver->max_allocate_lifetime = max_allocate_lifetime;\n\tserver->channel_lifetime = channel_lifetime;\n\tserver->permission_lifetime = permission_lifetime;\n\tserver->stun_only = stun_only;\n\tserver->no_stun = no_stun;\n\tserver->no_software_attribute = no_software_attribute;\n\tserver-> web_admin_listen_on_workers = web_admin_listen_on_workers;\n\n\tserver->dont_fragment = dont_fragment;\n\tserver->fingerprint = fingerprint;\n\tif(external_ip) {\n\t\taddr_cpy(&(server->external_ip), external_ip);\n\t\tserver->external_ip_set = 1;\n\t}\n\tif (stun_port < 1)\n\t\tstun_port = DEFAULT_STUN_PORT;\n\n\tserver->verbose = verbose;\n\n\tserver->ip_whitelist = ip_whitelist;\n\tserver->ip_blacklist = ip_blacklist;\n\n\tserver->send_socket_to_relay = send_socket_to_relay;\n\n\tserver->allocate_bps_func = allocate_bps_func;\n\n\tserver->keep_address_family = keep_address_family;\n\n\tset_ioa_timer(server->e, 1, 0, timer_timeout_handler, server, 1, \"timer_timeout_handler\");\n\n\tserver->log_binding = log_binding;\n}\n\nioa_engine_handle turn_server_get_engine(turn_turnserver *s) {\n\tif(s)\n\t\treturn s->e;\n\treturn NULL;\n}\n\nvoid set_disconnect_cb(turn_turnserver* server, int(*disconnect)(\n\t\tts_ur_super_session*)) {\n\tserver->disconnect = disconnect;\n}\n\n//////////////////////////////////////////////////////////////////\n"], "filenames": ["src/client/ns_turn_ioaddr.c", "src/client/ns_turn_ioaddr.h", "src/server/ns_turn_server.c"], "buggy_code_start_loc": [486, 91, 274], "buggy_code_end_loc": [493, 91, 274], "fixing_code_start_loc": [486, 92, 275], "fixing_code_end_loc": [519, 93, 277], "type": "CWE-441", "message": "Coturn is free open source implementation of TURN and STUN Server. Coturn before version 4.5.2 by default does not allow peers to connect and relay packets to loopback addresses in the range of `127.x.x.x`. However, it was observed that when sending a `CONNECT` request with the `XOR-PEER-ADDRESS` value of `0.0.0.0`, a successful response was received and subsequently, `CONNECTIONBIND` also received a successful response. Coturn then is able to relay packets to the loopback interface. Additionally, when coturn is listening on IPv6, which is default, the loopback interface can also be reached by making use of either `[::1]` or `[::]` as the peer address. By using the address `0.0.0.0` as the peer address, a malicious user will be able to relay packets to the loopback interface, unless `--denied-peer-ip=0.0.0.0` (or similar) has been specified. Since the default configuration implies that loopback peers are not allowed, coturn administrators may choose to not set the `denied-peer-ip` setting. The issue patched in version 4.5.2. As a workaround the addresses in the address block `0.0.0.0/8`, `[::1]` and `[::]` should be denied by default unless `--allow-loopback-peers` has been specified.", "other": {"cve": {"id": "CVE-2020-26262", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-13T19:15:16.027", "lastModified": "2022-01-01T18:12:41.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Coturn is free open source implementation of TURN and STUN Server. Coturn before version 4.5.2 by default does not allow peers to connect and relay packets to loopback addresses in the range of `127.x.x.x`. However, it was observed that when sending a `CONNECT` request with the `XOR-PEER-ADDRESS` value of `0.0.0.0`, a successful response was received and subsequently, `CONNECTIONBIND` also received a successful response. Coturn then is able to relay packets to the loopback interface. Additionally, when coturn is listening on IPv6, which is default, the loopback interface can also be reached by making use of either `[::1]` or `[::]` as the peer address. By using the address `0.0.0.0` as the peer address, a malicious user will be able to relay packets to the loopback interface, unless `--denied-peer-ip=0.0.0.0` (or similar) has been specified. Since the default configuration implies that loopback peers are not allowed, coturn administrators may choose to not set the `denied-peer-ip` setting. The issue patched in version 4.5.2. As a workaround the addresses in the address block `0.0.0.0/8`, `[::1]` and `[::]` should be denied by default unless `--allow-loopback-peers` has been specified."}, {"lang": "es", "value": "Coturn es una implementaci\u00f3n gratuita de c\u00f3digo abierto de TURN y STUN Server.&#xa0;Coturn anterior a la versi\u00f3n 4.5.2 por defecto no permite a los peers conectarse y retransmitir paquetes a direcciones loopback en el rango de \"127.xxx\".&#xa0;Sin embargo, se observ\u00f3 que al enviar una petici\u00f3n \"CONNECT\" con el valor \"XOR-PEER-ADDRESS\" de \"0.0.0.0\", se recibi\u00f3 una respuesta con \u00e9xito y, posteriormente, \"CONNECTIONBIND\" tambi\u00e9n recibi\u00f3 una respuesta exitosa.&#xa0;Coturn entonces puede retransmitir paquetes hacia la interfaz loopback.&#xa0;Adem\u00e1s, cuando coturn est\u00e1 escuchando en IPv6, que es el valor predeterminado, tambi\u00e9n se puede acceder a la interfaz de bucle invertido haciendo uso de \"[::1]\" o \"[::]\" como direcci\u00f3n del mismo nivel.&#xa0;Al usar la direcci\u00f3n \"0.0.0.0\" como direcci\u00f3n del peer, un usuario malicioso podr\u00e1 retransmitir paquetes a la interfaz de bucle invertido, a menos que se haya especificado \"--denied-peer-ip=0.0.0.0\" (o similar).&#xa0;Dado que la configuraci\u00f3n predeterminada implica que no se permiten los peers de bucle invertido, los administradores de turno pueden optar por no establecer la configuraci\u00f3n \"denegado-ip\".&#xa0;El problema es parcheado en la versi\u00f3n 4.5.2.&#xa0;Como soluci\u00f3n alternativa, las direcciones en el bloque de direcciones \"0.0.0.0/8\", \"[::1]\" y \"[::]\" deben denegarse por defecto a menos que se haya especificado \"--allow-loopback-peers\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-441"}, {"lang": "en", "value": "CWE-682"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:coturn_project:coturn:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.5.2", "matchCriteriaId": "0AB3C866-6E5A-4FD5-895D-FFF6AEF3BDF2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/coturn/coturn/blob/57180ab60afcaeb13537e69ae8cb8aefd8f3f546/ChangeLog#L48", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/coturn/coturn/commit/abfe1fd08d78baa0947d17dac0f7411c3d948e4d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/coturn/coturn/security/advisories/GHSA-6g6j-r9rf-cm7p", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/G54UIUFTEC6RLPOISMB6FUW7456SBZC4/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M4CJOPAQT43MYAFU3UROGLEXN3Z6RS4H/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/coturn/coturn/commit/abfe1fd08d78baa0947d17dac0f7411c3d948e4d"}}