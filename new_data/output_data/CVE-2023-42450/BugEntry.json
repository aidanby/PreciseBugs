{"buggy_code": ["# frozen_string_literal: true\n\nrequire 'ipaddr'\nrequire 'socket'\nrequire 'resolv'\n\n# Use our own timeout class to avoid using HTTP.rb's timeout block\n# around the Socket#open method, since we use our own timeout blocks inside\n# that method\n#\n# Also changes how the read timeout behaves so that it is cumulative (closer\n# to HTTP::Timeout::Global, but still having distinct timeouts for other\n# operation types)\nclass PerOperationWithDeadline < HTTP::Timeout::PerOperation\n  READ_DEADLINE = 30\n\n  def initialize(*args)\n    super\n\n    @read_deadline = options.fetch(:read_deadline, READ_DEADLINE)\n  end\n\n  def connect(socket_class, host, port, nodelay = false)\n    @socket = socket_class.open(host, port)\n    @socket.setsockopt(Socket::IPPROTO_TCP, Socket::TCP_NODELAY, 1) if nodelay\n  end\n\n  # Reset deadline when the connection is re-used for different requests\n  def reset_counter\n    @deadline = nil\n  end\n\n  # Read data from the socket\n  def readpartial(size, buffer = nil)\n    @deadline ||= Process.clock_gettime(Process::CLOCK_MONOTONIC) + @read_deadline\n\n    timeout = false\n    loop do\n      result = @socket.read_nonblock(size, buffer, exception: false)\n\n      return :eof if result.nil?\n\n      remaining_time = @deadline - Process.clock_gettime(Process::CLOCK_MONOTONIC)\n      raise HTTP::TimeoutError, \"Read timed out after #{@read_timeout} seconds\" if timeout\n      raise HTTP::TimeoutError, \"Read timed out after a total of #{@read_deadline} seconds\" if remaining_time <= 0\n      return result if result != :wait_readable\n\n      # marking the socket for timeout. Why is this not being raised immediately?\n      # it seems there is some race-condition on the network level between calling\n      # #read_nonblock and #wait_readable, in which #read_nonblock signalizes waiting\n      # for reads, and when waiting for x seconds, it returns nil suddenly without completing\n      # the x seconds. In a normal case this would be a timeout on wait/read, but it can\n      # also mean that the socket has been closed by the server. Therefore we \"mark\" the\n      # socket for timeout and try to read more bytes. If it returns :eof, it's all good, no\n      # timeout. Else, the first timeout was a proper timeout.\n      # This hack has to be done because io/wait#wait_readable doesn't provide a value for when\n      # the socket is closed by the server, and HTTP::Parser doesn't provide the limit for the chunks.\n      timeout = true unless @socket.to_io.wait_readable([remaining_time, @read_timeout].min)\n    end\n  end\nend\n\nclass Request\n  REQUEST_TARGET = '(request-target)'\n\n  # We enforce a 5s timeout on DNS resolving, 5s timeout on socket opening\n  # and 5s timeout on the TLS handshake, meaning the worst case should take\n  # about 15s in total\n  TIMEOUT = { connect_timeout: 5, read_timeout: 10, write_timeout: 10, read_deadline: 30 }.freeze\n\n  # Workaround for overly-eager decoding of percent-encoded characters in Addressable::URI#normalized_path\n  # https://github.com/sporkmonger/addressable/issues/366\n  URI_NORMALIZER = lambda do |uri|\n    uri = HTTP::URI.parse(uri)\n\n    HTTP::URI.new(\n      scheme: uri.normalized_scheme,\n      authority: uri.normalized_authority,\n      path: Addressable::URI.normalize_path(encode_non_ascii(uri.path)).presence || '/',\n      query: encode_non_ascii(uri.query)\n    )\n  end\n\n  include RoutingHelper\n\n  def initialize(verb, url, **options)\n    raise ArgumentError if url.blank?\n\n    @verb        = verb\n    @url         = URI_NORMALIZER.call(url)\n    @http_client = options.delete(:http_client)\n    @allow_local = options.delete(:allow_local)\n    @options     = options.merge(socket_class: use_proxy? || @allow_local ? ProxySocket : Socket)\n    @options     = @options.merge(timeout_class: PerOperationWithDeadline, timeout_options: TIMEOUT)\n    @options     = @options.merge(proxy_url) if use_proxy?\n    @headers     = {}\n\n    raise Mastodon::HostValidationError, 'Instance does not support hidden service connections' if block_hidden_service?\n\n    set_common_headers!\n    set_digest! if options.key?(:body)\n  end\n\n  def on_behalf_of(actor, sign_with: nil)\n    raise ArgumentError, 'actor must not be nil' if actor.nil?\n\n    @actor         = actor\n    @keypair       = sign_with.present? ? OpenSSL::PKey::RSA.new(sign_with) : @actor.keypair\n\n    self\n  end\n\n  def add_headers(new_headers)\n    @headers.merge!(new_headers)\n    self\n  end\n\n  def perform\n    begin\n      response = http_client.request(@verb, @url.to_s, @options.merge(headers: headers))\n    rescue => e\n      raise e.class, \"#{e.message} on #{@url}\", e.backtrace[0]\n    end\n\n    begin\n      # If we are using a persistent connection, we have to\n      # read every response to be able to move forward at all.\n      # However, simply calling #to_s or #flush may not be safe,\n      # as the response body, if malicious, could be too big\n      # for our memory. So we use the #body_with_limit method\n      response.body_with_limit if http_client.persistent?\n\n      yield response if block_given?\n    ensure\n      http_client.close unless http_client.persistent?\n    end\n  end\n\n  def headers\n    (@actor ? @headers.merge('Signature' => signature) : @headers).without(REQUEST_TARGET)\n  end\n\n  class << self\n    def valid_url?(url)\n      begin\n        parsed_url = Addressable::URI.parse(url)\n      rescue Addressable::URI::InvalidURIError\n        return false\n      end\n\n      %w(http https).include?(parsed_url.scheme) && parsed_url.host.present?\n    end\n\n    NON_ASCII_PATTERN = /[^\\x00-\\x7F]+/\n\n    def encode_non_ascii(str)\n      str&.gsub(NON_ASCII_PATTERN) { |substr| CGI.escape(substr.encode(Encoding::UTF_8)) }\n    end\n\n    def http_client\n      HTTP.use(:auto_inflate).use(normalize_uri: { normalizer: URI_NORMALIZER }).follow(max_hops: 3)\n    end\n  end\n\n  private\n\n  def set_common_headers!\n    @headers[REQUEST_TARGET]    = \"#{@verb} #{@url.path}\"\n    @headers['User-Agent']      = Mastodon::Version.user_agent\n    @headers['Host']            = @url.host\n    @headers['Date']            = Time.now.utc.httpdate\n    @headers['Accept-Encoding'] = 'gzip' if @verb != :head\n  end\n\n  def set_digest!\n    @headers['Digest'] = \"SHA-256=#{Digest::SHA256.base64digest(@options[:body])}\"\n  end\n\n  def signature\n    algorithm = 'rsa-sha256'\n    signature = Base64.strict_encode64(@keypair.sign(OpenSSL::Digest.new('SHA256'), signed_string))\n\n    \"keyId=\\\"#{key_id}\\\",algorithm=\\\"#{algorithm}\\\",headers=\\\"#{signed_headers.keys.join(' ').downcase}\\\",signature=\\\"#{signature}\\\"\"\n  end\n\n  def signed_string\n    signed_headers.map { |key, value| \"#{key.downcase}: #{value}\" }.join(\"\\n\")\n  end\n\n  def signed_headers\n    @headers.without('User-Agent', 'Accept-Encoding')\n  end\n\n  def key_id\n    ActivityPub::TagManager.instance.key_uri_for(@actor)\n  end\n\n  def http_client\n    @http_client ||= Request.http_client\n  end\n\n  def use_proxy?\n    proxy_url.present?\n  end\n\n  def proxy_url\n    if hidden_service? && Rails.configuration.x.http_client_hidden_proxy.present?\n      Rails.configuration.x.http_client_hidden_proxy\n    else\n      Rails.configuration.x.http_client_proxy\n    end\n  end\n\n  def block_hidden_service?\n    !Rails.configuration.x.access_to_hidden_service && hidden_service?\n  end\n\n  def hidden_service?\n    /\\.(onion|i2p)$/.match?(@url.host)\n  end\n\n  module ClientLimit\n    def truncated_body(limit = 1.megabyte)\n      if charset.nil?\n        encoding = Encoding::BINARY\n      else\n        begin\n          encoding = Encoding.find(charset)\n        rescue ArgumentError\n          encoding = Encoding::BINARY\n        end\n      end\n\n      contents = String.new(encoding: encoding)\n\n      while (chunk = readpartial)\n        contents << chunk\n        chunk.clear\n\n        break if contents.bytesize > limit\n      end\n\n      contents\n    end\n\n    def body_with_limit(limit = 1.megabyte)\n      raise Mastodon::LengthValidationError if content_length.present? && content_length > limit\n\n      contents = truncated_body(limit)\n      raise Mastodon::LengthValidationError if contents.bytesize > limit\n\n      contents\n    end\n  end\n\n  if ::HTTP::Response.methods.include?(:body_with_limit) && !Rails.env.production?\n    abort 'HTTP::Response#body_with_limit is already defined, the monkey patch will not be applied'\n  else\n    class ::HTTP::Response\n      include Request::ClientLimit\n    end\n  end\n\n  class Socket < TCPSocket\n    class << self\n      def open(host, *args)\n        outer_e = nil\n        port    = args.first\n\n        addresses = []\n        begin\n          addresses = [IPAddr.new(host)]\n        rescue IPAddr::InvalidAddressError\n          Resolv::DNS.open do |dns|\n            dns.timeouts = 5\n            addresses = dns.getaddresses(host)\n            addresses = addresses.filter { |addr| addr.is_a?(Resolv::IPv6) }.take(2) + addresses.filter { |addr| !addr.is_a?(Resolv::IPv6) }.take(2)\n          end\n        end\n\n        socks = []\n        addr_by_socket = {}\n\n        addresses.each do |address|\n          check_private_address(address, host)\n\n          sock     = ::Socket.new(address.is_a?(Resolv::IPv6) ? ::Socket::AF_INET6 : ::Socket::AF_INET, ::Socket::SOCK_STREAM, 0)\n          sockaddr = ::Socket.pack_sockaddr_in(port, address.to_s)\n\n          sock.setsockopt(::Socket::IPPROTO_TCP, ::Socket::TCP_NODELAY, 1)\n\n          sock.connect_nonblock(sockaddr)\n\n          # If that hasn't raised an exception, we somehow managed to connect\n          # immediately, close pending sockets and return immediately\n          socks.each(&:close)\n          return sock\n        rescue IO::WaitWritable\n          socks << sock\n          addr_by_socket[sock] = sockaddr\n        rescue => e\n          outer_e = e\n        end\n\n        until socks.empty?\n          _, available_socks, = IO.select(nil, socks, nil, Request::TIMEOUT[:connect_timeout])\n\n          if available_socks.nil?\n            socks.each(&:close)\n            raise HTTP::TimeoutError, \"Connect timed out after #{Request::TIMEOUT[:connect_timeout]} seconds\"\n          end\n\n          available_socks.each do |sock|\n            socks.delete(sock)\n\n            begin\n              sock.connect_nonblock(addr_by_socket[sock])\n            rescue Errno::EISCONN\n              # Do nothing\n            rescue => e\n              sock.close\n              outer_e = e\n              next\n            end\n\n            socks.each(&:close)\n            return sock\n          end\n        end\n\n        if outer_e\n          raise outer_e\n        else\n          raise SocketError, \"No address for #{host}\"\n        end\n      end\n\n      alias new open\n\n      def check_private_address(address, host)\n        addr = IPAddr.new(address.to_s)\n\n        return if Rails.env.development? || private_address_exceptions.any? { |range| range.include?(addr) }\n\n        raise Mastodon::PrivateNetworkAddressError, host if PrivateAddressCheck.private_address?(addr)\n      end\n\n      def private_address_exceptions\n        @private_address_exceptions = (ENV['ALLOWED_PRIVATE_ADDRESSES'] || '').split(/(?:\\s*,\\s*|\\s+)/).map { |addr| IPAddr.new(addr) }\n      end\n    end\n  end\n\n  class ProxySocket < Socket\n    class << self\n      def check_private_address(_address, _host)\n        # Accept connections to private addresses as HTTP proxies will usually\n        # be on local addresses\n        nil\n      end\n    end\n  end\n\n  private_constant :ClientLimit, :Socket, :ProxySocket\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe SignatureVerification do\n  let(:wrapped_actor_class) do\n    Class.new do\n      attr_reader :wrapped_account\n\n      def initialize(wrapped_account)\n        @wrapped_account = wrapped_account\n      end\n\n      delegate :uri, :keypair, to: :wrapped_account\n    end\n  end\n\n  controller(ApplicationController) do\n    include SignatureVerification\n\n    before_action :require_actor_signature!, only: [:signature_required]\n\n    def success\n      head 200\n    end\n\n    def alternative_success\n      head 200\n    end\n\n    def signature_required\n      head 200\n    end\n  end\n\n  before do\n    routes.draw do\n      match :via => [:get, :post], 'success' => 'anonymous#success'\n      match :via => [:get, :post], 'signature_required' => 'anonymous#signature_required'\n    end\n  end\n\n  context 'without signature header' do\n    before do\n      get :success\n    end\n\n    describe '#signed_request?' do\n      it 'returns false' do\n        expect(controller.signed_request?).to be false\n      end\n    end\n\n    describe '#signed_request_account' do\n      it 'returns nil' do\n        expect(controller.signed_request_account).to be_nil\n      end\n    end\n  end\n\n  context 'with signature header' do\n    let!(:author) { Fabricate(:account, domain: 'example.com', uri: 'https://example.com/actor') }\n\n    context 'without body' do\n      before do\n        get :success\n\n        fake_request = Request.new(:get, request.url)\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns an account' do\n          expect(controller.signed_request_account).to eq author\n        end\n\n        it 'returns nil when path does not match' do\n          request.path = '/alternative-path'\n          expect(controller.signed_request_account).to be_nil\n        end\n\n        it 'returns nil when method does not match' do\n          post :success\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n    end\n\n    context 'with a valid actor that is not an Account' do\n      let(:actor) { wrapped_actor_class.new(author) }\n\n      before do\n        get :success\n\n        fake_request = Request.new(:get, request.url)\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n\n        allow(ActivityPub::TagManager.instance).to receive(:uri_to_actor).with(anything) do\n          actor\n        end\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns nil' do\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n\n      describe '#signed_request_actor' do\n        it 'returns the expected actor' do\n          expect(controller.signed_request_actor).to eq actor\n        end\n      end\n    end\n\n    context 'with non-normalized URL' do\n      before do\n        get :success\n\n        fake_request = Request.new(:get, 'http://test.host/subdir/../success')\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n\n        allow(controller).to receive(:actor_refresh_key!).and_return(author)\n      end\n\n      describe '#build_signed_string' do\n        it 'includes the normalized request path' do\n          expect(controller.send(:build_signed_string)).to start_with \"(request-target): get /success\\n\"\n        end\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_actor' do\n        it 'returns an account' do\n          expect(controller.signed_request_account).to eq author\n        end\n      end\n    end\n\n    context 'with request with unparsable Date header' do\n      before do\n        get :success\n\n        fake_request = Request.new(:get, request.url)\n        fake_request.add_headers({ 'Date' => 'wrong date' })\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns nil' do\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n\n      describe '#signature_verification_failure_reason' do\n        it 'contains an error description' do\n          controller.signed_request_account\n          expect(controller.signature_verification_failure_reason[:error]).to eq 'Invalid Date header: not RFC 2616 compliant date: \"wrong date\"'\n        end\n      end\n    end\n\n    context 'with request older than a day' do\n      before do\n        get :success\n\n        fake_request = Request.new(:get, request.url)\n        fake_request.add_headers({ 'Date' => 2.days.ago.utc.httpdate })\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns nil' do\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n\n      describe '#signature_verification_failure_reason' do\n        it 'contains an error description' do\n          controller.signed_request_account\n          expect(controller.signature_verification_failure_reason[:error]).to eq 'Signed request date outside acceptable time window'\n        end\n      end\n    end\n\n    context 'with inaccessible key' do\n      before do\n        get :success\n\n        author = Fabricate(:account, domain: 'localhost:5000', uri: 'http://localhost:5000/actor')\n        fake_request = Request.new(:get, request.url)\n        fake_request.on_behalf_of(author)\n        author.destroy\n\n        request.headers.merge!(fake_request.headers)\n\n        stub_request(:get, 'http://localhost:5000/actor').to_raise(Mastodon::HostValidationError)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns nil' do\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n    end\n\n    context 'with body' do\n      before do\n        allow(controller).to receive(:actor_refresh_key!).and_return(author)\n        post :success, body: 'Hello world'\n\n        fake_request = Request.new(:post, request.url, body: 'Hello world')\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns an account' do\n          expect(controller.signed_request_account).to eq author\n        end\n      end\n\n      context 'when path does not match' do\n        before do\n          request.path = '/alternative-path'\n        end\n\n        describe '#signed_request_account' do\n          it 'returns nil' do\n            expect(controller.signed_request_account).to be_nil\n          end\n        end\n\n        describe '#signature_verification_failure_reason' do\n          it 'contains an error description' do\n            controller.signed_request_account\n            expect(controller.signature_verification_failure_reason[:error]).to include('using rsa-sha256 (RSASSA-PKCS1-v1_5 with SHA-256)')\n            expect(controller.signature_verification_failure_reason[:signed_string]).to include(\"(request-target): post /alternative-path\\n\")\n          end\n        end\n      end\n\n      context 'when method does not match' do\n        before do\n          get :success\n        end\n\n        describe '#signed_request_account' do\n          it 'returns nil' do\n            expect(controller.signed_request_account).to be_nil\n          end\n        end\n      end\n\n      context 'when body has been tampered' do\n        before do\n          post :success, body: 'doo doo doo'\n        end\n\n        describe '#signed_request_account' do\n          it 'returns nil when body has been tampered' do\n            expect(controller.signed_request_account).to be_nil\n          end\n        end\n      end\n    end\n  end\n\n  context 'when a signature is required' do\n    before do\n      get :signature_required\n    end\n\n    context 'without signature header' do\n      it 'returns HTTP 401' do\n        expect(response).to have_http_status(401)\n      end\n\n      it 'returns an error' do\n        expect(Oj.load(response.body)['error']).to eq 'Request not signed'\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'securerandom'\n\ndescribe Request do\n  subject { described_class.new(:get, url) }\n\n  let(:url) { 'http://example.com' }\n\n  describe '#headers' do\n    it 'returns user agent' do\n      expect(subject.headers['User-Agent']).to be_present\n    end\n\n    it 'returns the date header' do\n      expect(subject.headers['Date']).to be_present\n    end\n\n    it 'returns the host header' do\n      expect(subject.headers['Host']).to be_present\n    end\n\n    it 'does not return virtual request-target header' do\n      expect(subject.headers['(request-target)']).to be_nil\n    end\n  end\n\n  describe '#on_behalf_of' do\n    it 'when used, adds signature header' do\n      subject.on_behalf_of(Fabricate(:account))\n      expect(subject.headers['Signature']).to be_present\n    end\n  end\n\n  describe '#add_headers' do\n    it 'adds headers to the request' do\n      subject.add_headers('Test' => 'Foo')\n      expect(subject.headers['Test']).to eq 'Foo'\n    end\n  end\n\n  describe '#perform' do\n    context 'with valid host' do\n      before { stub_request(:get, 'http://example.com') }\n\n      it 'executes a HTTP request' do\n        expect { |block| subject.perform(&block) }.to yield_control\n        expect(a_request(:get, 'http://example.com')).to have_been_made.once\n      end\n\n      it 'executes a HTTP request when the first address is private' do\n        resolver = instance_double(Resolv::DNS)\n\n        allow(resolver).to receive(:getaddresses).with('example.com').and_return(%w(0.0.0.0 2001:4860:4860::8844))\n        allow(resolver).to receive(:timeouts=).and_return(nil)\n        allow(Resolv::DNS).to receive(:open).and_yield(resolver)\n\n        expect { |block| subject.perform(&block) }.to yield_control\n        expect(a_request(:get, 'http://example.com')).to have_been_made.once\n      end\n\n      it 'sets headers' do\n        expect { |block| subject.perform(&block) }.to yield_control\n        expect(a_request(:get, 'http://example.com').with(headers: subject.headers)).to have_been_made\n      end\n\n      it 'closes underlying connection' do\n        expect_any_instance_of(HTTP::Client).to receive(:close)\n        expect { |block| subject.perform(&block) }.to yield_control\n      end\n\n      it 'returns response which implements body_with_limit' do\n        subject.perform do |response|\n          expect(response).to respond_to :body_with_limit\n        end\n      end\n    end\n\n    context 'with private host' do\n      around do |example|\n        WebMock.disable!\n        example.run\n        WebMock.enable!\n      end\n\n      it 'raises Mastodon::ValidationError' do\n        resolver = instance_double(Resolv::DNS)\n\n        allow(resolver).to receive(:getaddresses).with('example.com').and_return(%w(0.0.0.0 2001:db8::face))\n        allow(resolver).to receive(:timeouts=).and_return(nil)\n        allow(Resolv::DNS).to receive(:open).and_yield(resolver)\n\n        expect { subject.perform }.to raise_error Mastodon::ValidationError\n      end\n    end\n\n    context 'with bare domain URL' do\n      let(:url) { 'http://example.com' }\n\n      before do\n        stub_request(:get, 'http://example.com')\n      end\n\n      it 'normalizes path' do\n        subject.perform do |response|\n          expect(response.request.uri.path).to eq '/'\n        end\n      end\n\n      it 'normalizes path used for request signing' do\n        subject.perform\n\n        headers = subject.instance_variable_get(:@headers)\n        expect(headers[Request::REQUEST_TARGET]).to eq 'get /'\n      end\n\n      it 'normalizes path used in request line' do\n        subject.perform do |response|\n          expect(response.request.headline).to eq 'GET / HTTP/1.1'\n        end\n      end\n    end\n\n    context 'with unnormalized URL' do\n      let(:url) { 'HTTP://EXAMPLE.com:80/foo%41%3A?bar=%41%3A#baz' }\n\n      before do\n        stub_request(:get, 'http://example.com/foo%41%3A?bar=%41%3A')\n      end\n\n      it 'normalizes scheme' do\n        subject.perform do |response|\n          expect(response.request.uri.scheme).to eq 'http'\n        end\n      end\n\n      it 'normalizes host' do\n        subject.perform do |response|\n          expect(response.request.uri.authority).to eq 'example.com'\n        end\n      end\n\n      it 'does not modify path' do\n        subject.perform do |response|\n          expect(response.request.uri.path).to eq '/foo%41%3A'\n        end\n      end\n\n      it 'does not modify query string' do\n        subject.perform do |response|\n          expect(response.request.uri.query).to eq 'bar=%41%3A'\n        end\n      end\n\n      it 'does not modify path used for request signing' do\n        subject.perform\n\n        headers = subject.instance_variable_get(:@headers)\n        expect(headers[Request::REQUEST_TARGET]).to eq 'get /foo%41%3A'\n      end\n\n      it 'does not modify path used in request line' do\n        subject.perform do |response|\n          expect(response.request.headline).to eq 'GET /foo%41%3A?bar=%41%3A HTTP/1.1'\n        end\n      end\n\n      it 'strips fragment' do\n        subject.perform do |response|\n          expect(response.request.uri.fragment).to be_nil\n        end\n      end\n    end\n\n    context 'with non-ASCII URL' do\n      let(:url) { 'http://\u00e9xample.com:81/f\u00f6o?b\u00e4r=1' }\n\n      before do\n        stub_request(:get, 'http://xn--xample-9ua.com:81/f%C3%B6o?b%C3%A4r=1')\n      end\n\n      it 'IDN-encodes host' do\n        subject.perform do |response|\n          expect(response.request.uri.authority).to eq 'xn--xample-9ua.com:81'\n        end\n      end\n\n      it 'IDN-encodes host in Host header' do\n        subject.perform do |response|\n          expect(response.request.headers['Host']).to eq 'xn--xample-9ua.com'\n        end\n      end\n\n      it 'percent-escapes path used for request signing' do\n        subject.perform\n\n        headers = subject.instance_variable_get(:@headers)\n        expect(headers[Request::REQUEST_TARGET]).to eq 'get /f%C3%B6o'\n      end\n\n      it 'normalizes path used in request line' do\n        subject.perform do |response|\n          expect(response.request.headline).to eq 'GET /f%C3%B6o?b%C3%A4r=1 HTTP/1.1'\n        end\n      end\n    end\n\n    context 'with redirecting URL' do\n      let(:url) { 'http://example.com/foo' }\n\n      before do\n        stub_request(:get, 'http://example.com/foo').to_return(status: 302, headers: { 'Location' => 'HTTPS://EXAMPLE.net/Bar' })\n        stub_request(:get, 'https://example.net/Bar').to_return(body: 'Lorem ipsum')\n      end\n\n      it 'resolves redirect' do\n        subject.perform do |response|\n          expect(response.body.to_s).to eq 'Lorem ipsum'\n        end\n\n        expect(a_request(:get, 'https://example.net/Bar')).to have_been_made\n      end\n\n      it 'normalizes destination scheme' do\n        subject.perform do |response|\n          expect(response.request.uri.scheme).to eq 'https'\n        end\n      end\n\n      it 'normalizes destination host' do\n        subject.perform do |response|\n          expect(response.request.uri.authority).to eq 'example.net'\n        end\n      end\n\n      it 'does modify path' do\n        subject.perform do |response|\n          expect(response.request.uri.path).to eq '/Bar'\n        end\n      end\n    end\n  end\n\n  describe \"response's body_with_limit method\" do\n    it 'rejects body more than 1 megabyte by default' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.megabytes))\n      expect { subject.perform(&:body_with_limit) }.to raise_error Mastodon::LengthValidationError\n    end\n\n    it 'accepts body less than 1 megabyte by default' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.kilobytes))\n      expect { subject.perform(&:body_with_limit) }.to_not raise_error\n    end\n\n    it 'rejects body by given size' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.kilobytes))\n      expect { subject.perform { |response| response.body_with_limit(1.kilobyte) } }.to raise_error Mastodon::LengthValidationError\n    end\n\n    it 'rejects too large chunked body' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.megabytes), headers: { 'Transfer-Encoding' => 'chunked' })\n      expect { subject.perform(&:body_with_limit) }.to raise_error Mastodon::LengthValidationError\n    end\n\n    it 'rejects too large monolithic body' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.megabytes), headers: { 'Content-Length' => 2.megabytes })\n      expect { subject.perform(&:body_with_limit) }.to raise_error Mastodon::LengthValidationError\n    end\n\n    it 'truncates large monolithic body' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.megabytes), headers: { 'Content-Length' => 2.megabytes })\n      expect(subject.perform { |response| response.truncated_body.bytesize }).to be < 2.megabytes\n    end\n\n    it 'uses binary encoding if Content-Type does not tell encoding' do\n      stub_request(:any, 'http://example.com').to_return(body: '', headers: { 'Content-Type' => 'text/html' })\n      expect(subject.perform { |response| response.body_with_limit.encoding }).to eq Encoding::BINARY\n    end\n\n    it 'uses binary encoding if Content-Type tells unknown encoding' do\n      stub_request(:any, 'http://example.com').to_return(body: '', headers: { 'Content-Type' => 'text/html; charset=unknown' })\n      expect(subject.perform { |response| response.body_with_limit.encoding }).to eq Encoding::BINARY\n    end\n\n    it 'uses encoding specified by Content-Type' do\n      stub_request(:any, 'http://example.com').to_return(body: '', headers: { 'Content-Type' => 'text/html; charset=UTF-8' })\n      expect(subject.perform { |response| response.body_with_limit.encoding }).to eq Encoding::UTF_8\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire 'ipaddr'\nrequire 'socket'\nrequire 'resolv'\n\n# Use our own timeout class to avoid using HTTP.rb's timeout block\n# around the Socket#open method, since we use our own timeout blocks inside\n# that method\n#\n# Also changes how the read timeout behaves so that it is cumulative (closer\n# to HTTP::Timeout::Global, but still having distinct timeouts for other\n# operation types)\nclass PerOperationWithDeadline < HTTP::Timeout::PerOperation\n  READ_DEADLINE = 30\n\n  def initialize(*args)\n    super\n\n    @read_deadline = options.fetch(:read_deadline, READ_DEADLINE)\n  end\n\n  def connect(socket_class, host, port, nodelay = false)\n    @socket = socket_class.open(host, port)\n    @socket.setsockopt(Socket::IPPROTO_TCP, Socket::TCP_NODELAY, 1) if nodelay\n  end\n\n  # Reset deadline when the connection is re-used for different requests\n  def reset_counter\n    @deadline = nil\n  end\n\n  # Read data from the socket\n  def readpartial(size, buffer = nil)\n    @deadline ||= Process.clock_gettime(Process::CLOCK_MONOTONIC) + @read_deadline\n\n    timeout = false\n    loop do\n      result = @socket.read_nonblock(size, buffer, exception: false)\n\n      return :eof if result.nil?\n\n      remaining_time = @deadline - Process.clock_gettime(Process::CLOCK_MONOTONIC)\n      raise HTTP::TimeoutError, \"Read timed out after #{@read_timeout} seconds\" if timeout\n      raise HTTP::TimeoutError, \"Read timed out after a total of #{@read_deadline} seconds\" if remaining_time <= 0\n      return result if result != :wait_readable\n\n      # marking the socket for timeout. Why is this not being raised immediately?\n      # it seems there is some race-condition on the network level between calling\n      # #read_nonblock and #wait_readable, in which #read_nonblock signalizes waiting\n      # for reads, and when waiting for x seconds, it returns nil suddenly without completing\n      # the x seconds. In a normal case this would be a timeout on wait/read, but it can\n      # also mean that the socket has been closed by the server. Therefore we \"mark\" the\n      # socket for timeout and try to read more bytes. If it returns :eof, it's all good, no\n      # timeout. Else, the first timeout was a proper timeout.\n      # This hack has to be done because io/wait#wait_readable doesn't provide a value for when\n      # the socket is closed by the server, and HTTP::Parser doesn't provide the limit for the chunks.\n      timeout = true unless @socket.to_io.wait_readable([remaining_time, @read_timeout].min)\n    end\n  end\nend\n\nclass Request\n  REQUEST_TARGET = '(request-target)'\n\n  # We enforce a 5s timeout on DNS resolving, 5s timeout on socket opening\n  # and 5s timeout on the TLS handshake, meaning the worst case should take\n  # about 15s in total\n  TIMEOUT = { connect_timeout: 5, read_timeout: 10, write_timeout: 10, read_deadline: 30 }.freeze\n\n  include RoutingHelper\n\n  def initialize(verb, url, **options)\n    raise ArgumentError if url.blank?\n\n    @verb        = verb\n    @url         = Addressable::URI.parse(url).normalize\n    @http_client = options.delete(:http_client)\n    @allow_local = options.delete(:allow_local)\n    @options     = options.merge(socket_class: use_proxy? || @allow_local ? ProxySocket : Socket)\n    @options     = @options.merge(timeout_class: PerOperationWithDeadline, timeout_options: TIMEOUT)\n    @options     = @options.merge(proxy_url) if use_proxy?\n    @headers     = {}\n\n    raise Mastodon::HostValidationError, 'Instance does not support hidden service connections' if block_hidden_service?\n\n    set_common_headers!\n    set_digest! if options.key?(:body)\n  end\n\n  def on_behalf_of(actor, sign_with: nil)\n    raise ArgumentError, 'actor must not be nil' if actor.nil?\n\n    @actor         = actor\n    @keypair       = sign_with.present? ? OpenSSL::PKey::RSA.new(sign_with) : @actor.keypair\n\n    self\n  end\n\n  def add_headers(new_headers)\n    @headers.merge!(new_headers)\n    self\n  end\n\n  def perform\n    begin\n      response = http_client.request(@verb, @url.to_s, @options.merge(headers: headers))\n    rescue => e\n      raise e.class, \"#{e.message} on #{@url}\", e.backtrace[0]\n    end\n\n    begin\n      # If we are using a persistent connection, we have to\n      # read every response to be able to move forward at all.\n      # However, simply calling #to_s or #flush may not be safe,\n      # as the response body, if malicious, could be too big\n      # for our memory. So we use the #body_with_limit method\n      response.body_with_limit if http_client.persistent?\n\n      yield response if block_given?\n    ensure\n      http_client.close unless http_client.persistent?\n    end\n  end\n\n  def headers\n    (@actor ? @headers.merge('Signature' => signature) : @headers).without(REQUEST_TARGET)\n  end\n\n  class << self\n    def valid_url?(url)\n      begin\n        parsed_url = Addressable::URI.parse(url)\n      rescue Addressable::URI::InvalidURIError\n        return false\n      end\n\n      %w(http https).include?(parsed_url.scheme) && parsed_url.host.present?\n    end\n\n    def http_client\n      HTTP.use(:auto_inflate).follow(max_hops: 3)\n    end\n  end\n\n  private\n\n  def set_common_headers!\n    @headers[REQUEST_TARGET]    = \"#{@verb} #{@url.path}\"\n    @headers['User-Agent']      = Mastodon::Version.user_agent\n    @headers['Host']            = @url.host\n    @headers['Date']            = Time.now.utc.httpdate\n    @headers['Accept-Encoding'] = 'gzip' if @verb != :head\n  end\n\n  def set_digest!\n    @headers['Digest'] = \"SHA-256=#{Digest::SHA256.base64digest(@options[:body])}\"\n  end\n\n  def signature\n    algorithm = 'rsa-sha256'\n    signature = Base64.strict_encode64(@keypair.sign(OpenSSL::Digest.new('SHA256'), signed_string))\n\n    \"keyId=\\\"#{key_id}\\\",algorithm=\\\"#{algorithm}\\\",headers=\\\"#{signed_headers.keys.join(' ').downcase}\\\",signature=\\\"#{signature}\\\"\"\n  end\n\n  def signed_string\n    signed_headers.map { |key, value| \"#{key.downcase}: #{value}\" }.join(\"\\n\")\n  end\n\n  def signed_headers\n    @headers.without('User-Agent', 'Accept-Encoding')\n  end\n\n  def key_id\n    ActivityPub::TagManager.instance.key_uri_for(@actor)\n  end\n\n  def http_client\n    @http_client ||= Request.http_client\n  end\n\n  def use_proxy?\n    proxy_url.present?\n  end\n\n  def proxy_url\n    if hidden_service? && Rails.configuration.x.http_client_hidden_proxy.present?\n      Rails.configuration.x.http_client_hidden_proxy\n    else\n      Rails.configuration.x.http_client_proxy\n    end\n  end\n\n  def block_hidden_service?\n    !Rails.configuration.x.access_to_hidden_service && hidden_service?\n  end\n\n  def hidden_service?\n    /\\.(onion|i2p)$/.match?(@url.host)\n  end\n\n  module ClientLimit\n    def truncated_body(limit = 1.megabyte)\n      if charset.nil?\n        encoding = Encoding::BINARY\n      else\n        begin\n          encoding = Encoding.find(charset)\n        rescue ArgumentError\n          encoding = Encoding::BINARY\n        end\n      end\n\n      contents = String.new(encoding: encoding)\n\n      while (chunk = readpartial)\n        contents << chunk\n        chunk.clear\n\n        break if contents.bytesize > limit\n      end\n\n      contents\n    end\n\n    def body_with_limit(limit = 1.megabyte)\n      raise Mastodon::LengthValidationError if content_length.present? && content_length > limit\n\n      contents = truncated_body(limit)\n      raise Mastodon::LengthValidationError if contents.bytesize > limit\n\n      contents\n    end\n  end\n\n  if ::HTTP::Response.methods.include?(:body_with_limit) && !Rails.env.production?\n    abort 'HTTP::Response#body_with_limit is already defined, the monkey patch will not be applied'\n  else\n    class ::HTTP::Response\n      include Request::ClientLimit\n    end\n  end\n\n  class Socket < TCPSocket\n    class << self\n      def open(host, *args)\n        outer_e = nil\n        port    = args.first\n\n        addresses = []\n        begin\n          addresses = [IPAddr.new(host)]\n        rescue IPAddr::InvalidAddressError\n          Resolv::DNS.open do |dns|\n            dns.timeouts = 5\n            addresses = dns.getaddresses(host)\n            addresses = addresses.filter { |addr| addr.is_a?(Resolv::IPv6) }.take(2) + addresses.filter { |addr| !addr.is_a?(Resolv::IPv6) }.take(2)\n          end\n        end\n\n        socks = []\n        addr_by_socket = {}\n\n        addresses.each do |address|\n          check_private_address(address, host)\n\n          sock     = ::Socket.new(address.is_a?(Resolv::IPv6) ? ::Socket::AF_INET6 : ::Socket::AF_INET, ::Socket::SOCK_STREAM, 0)\n          sockaddr = ::Socket.pack_sockaddr_in(port, address.to_s)\n\n          sock.setsockopt(::Socket::IPPROTO_TCP, ::Socket::TCP_NODELAY, 1)\n\n          sock.connect_nonblock(sockaddr)\n\n          # If that hasn't raised an exception, we somehow managed to connect\n          # immediately, close pending sockets and return immediately\n          socks.each(&:close)\n          return sock\n        rescue IO::WaitWritable\n          socks << sock\n          addr_by_socket[sock] = sockaddr\n        rescue => e\n          outer_e = e\n        end\n\n        until socks.empty?\n          _, available_socks, = IO.select(nil, socks, nil, Request::TIMEOUT[:connect_timeout])\n\n          if available_socks.nil?\n            socks.each(&:close)\n            raise HTTP::TimeoutError, \"Connect timed out after #{Request::TIMEOUT[:connect_timeout]} seconds\"\n          end\n\n          available_socks.each do |sock|\n            socks.delete(sock)\n\n            begin\n              sock.connect_nonblock(addr_by_socket[sock])\n            rescue Errno::EISCONN\n              # Do nothing\n            rescue => e\n              sock.close\n              outer_e = e\n              next\n            end\n\n            socks.each(&:close)\n            return sock\n          end\n        end\n\n        if outer_e\n          raise outer_e\n        else\n          raise SocketError, \"No address for #{host}\"\n        end\n      end\n\n      alias new open\n\n      def check_private_address(address, host)\n        addr = IPAddr.new(address.to_s)\n\n        return if Rails.env.development? || private_address_exceptions.any? { |range| range.include?(addr) }\n\n        raise Mastodon::PrivateNetworkAddressError, host if PrivateAddressCheck.private_address?(addr)\n      end\n\n      def private_address_exceptions\n        @private_address_exceptions = (ENV['ALLOWED_PRIVATE_ADDRESSES'] || '').split(/(?:\\s*,\\s*|\\s+)/).map { |addr| IPAddr.new(addr) }\n      end\n    end\n  end\n\n  class ProxySocket < Socket\n    class << self\n      def check_private_address(_address, _host)\n        # Accept connections to private addresses as HTTP proxies will usually\n        # be on local addresses\n        nil\n      end\n    end\n  end\n\n  private_constant :ClientLimit, :Socket, :ProxySocket\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe SignatureVerification do\n  let(:wrapped_actor_class) do\n    Class.new do\n      attr_reader :wrapped_account\n\n      def initialize(wrapped_account)\n        @wrapped_account = wrapped_account\n      end\n\n      delegate :uri, :keypair, to: :wrapped_account\n    end\n  end\n\n  controller(ApplicationController) do\n    include SignatureVerification\n\n    before_action :require_actor_signature!, only: [:signature_required]\n\n    def success\n      head 200\n    end\n\n    def alternative_success\n      head 200\n    end\n\n    def signature_required\n      head 200\n    end\n  end\n\n  before do\n    routes.draw do\n      match :via => [:get, :post], 'success' => 'anonymous#success'\n      match :via => [:get, :post], 'signature_required' => 'anonymous#signature_required'\n    end\n  end\n\n  context 'without signature header' do\n    before do\n      get :success\n    end\n\n    describe '#signed_request?' do\n      it 'returns false' do\n        expect(controller.signed_request?).to be false\n      end\n    end\n\n    describe '#signed_request_account' do\n      it 'returns nil' do\n        expect(controller.signed_request_account).to be_nil\n      end\n    end\n  end\n\n  context 'with signature header' do\n    let!(:author) { Fabricate(:account, domain: 'example.com', uri: 'https://example.com/actor') }\n\n    context 'without body' do\n      before do\n        get :success\n\n        fake_request = Request.new(:get, request.url)\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns an account' do\n          expect(controller.signed_request_account).to eq author\n        end\n\n        it 'returns nil when path does not match' do\n          request.path = '/alternative-path'\n          expect(controller.signed_request_account).to be_nil\n        end\n\n        it 'returns nil when method does not match' do\n          post :success\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n    end\n\n    context 'with a valid actor that is not an Account' do\n      let(:actor) { wrapped_actor_class.new(author) }\n\n      before do\n        get :success\n\n        fake_request = Request.new(:get, request.url)\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n\n        allow(ActivityPub::TagManager.instance).to receive(:uri_to_actor).with(anything) do\n          actor\n        end\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns nil' do\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n\n      describe '#signed_request_actor' do\n        it 'returns the expected actor' do\n          expect(controller.signed_request_actor).to eq actor\n        end\n      end\n    end\n\n    context 'with request with unparsable Date header' do\n      before do\n        get :success\n\n        fake_request = Request.new(:get, request.url)\n        fake_request.add_headers({ 'Date' => 'wrong date' })\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns nil' do\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n\n      describe '#signature_verification_failure_reason' do\n        it 'contains an error description' do\n          controller.signed_request_account\n          expect(controller.signature_verification_failure_reason[:error]).to eq 'Invalid Date header: not RFC 2616 compliant date: \"wrong date\"'\n        end\n      end\n    end\n\n    context 'with request older than a day' do\n      before do\n        get :success\n\n        fake_request = Request.new(:get, request.url)\n        fake_request.add_headers({ 'Date' => 2.days.ago.utc.httpdate })\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns nil' do\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n\n      describe '#signature_verification_failure_reason' do\n        it 'contains an error description' do\n          controller.signed_request_account\n          expect(controller.signature_verification_failure_reason[:error]).to eq 'Signed request date outside acceptable time window'\n        end\n      end\n    end\n\n    context 'with inaccessible key' do\n      before do\n        get :success\n\n        author = Fabricate(:account, domain: 'localhost:5000', uri: 'http://localhost:5000/actor')\n        fake_request = Request.new(:get, request.url)\n        fake_request.on_behalf_of(author)\n        author.destroy\n\n        request.headers.merge!(fake_request.headers)\n\n        stub_request(:get, 'http://localhost:5000/actor#main-key').to_raise(Mastodon::HostValidationError)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns nil' do\n          expect(controller.signed_request_account).to be_nil\n        end\n      end\n    end\n\n    context 'with body' do\n      before do\n        allow(controller).to receive(:actor_refresh_key!).and_return(author)\n        post :success, body: 'Hello world'\n\n        fake_request = Request.new(:post, request.url, body: 'Hello world')\n        fake_request.on_behalf_of(author)\n\n        request.headers.merge!(fake_request.headers)\n      end\n\n      describe '#signed_request?' do\n        it 'returns true' do\n          expect(controller.signed_request?).to be true\n        end\n      end\n\n      describe '#signed_request_account' do\n        it 'returns an account' do\n          expect(controller.signed_request_account).to eq author\n        end\n      end\n\n      context 'when path does not match' do\n        before do\n          request.path = '/alternative-path'\n        end\n\n        describe '#signed_request_account' do\n          it 'returns nil' do\n            expect(controller.signed_request_account).to be_nil\n          end\n        end\n\n        describe '#signature_verification_failure_reason' do\n          it 'contains an error description' do\n            controller.signed_request_account\n            expect(controller.signature_verification_failure_reason[:error]).to include('using rsa-sha256 (RSASSA-PKCS1-v1_5 with SHA-256)')\n            expect(controller.signature_verification_failure_reason[:signed_string]).to include(\"(request-target): post /alternative-path\\n\")\n          end\n        end\n      end\n\n      context 'when method does not match' do\n        before do\n          get :success\n        end\n\n        describe '#signed_request_account' do\n          it 'returns nil' do\n            expect(controller.signed_request_account).to be_nil\n          end\n        end\n      end\n\n      context 'when body has been tampered' do\n        before do\n          post :success, body: 'doo doo doo'\n        end\n\n        describe '#signed_request_account' do\n          it 'returns nil when body has been tampered' do\n            expect(controller.signed_request_account).to be_nil\n          end\n        end\n      end\n    end\n  end\n\n  context 'when a signature is required' do\n    before do\n      get :signature_required\n    end\n\n    context 'without signature header' do\n      it 'returns HTTP 401' do\n        expect(response).to have_http_status(401)\n      end\n\n      it 'returns an error' do\n        expect(Oj.load(response.body)['error']).to eq 'Request not signed'\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'securerandom'\n\ndescribe Request do\n  subject { described_class.new(:get, 'http://example.com') }\n\n  describe '#headers' do\n    it 'returns user agent' do\n      expect(subject.headers['User-Agent']).to be_present\n    end\n\n    it 'returns the date header' do\n      expect(subject.headers['Date']).to be_present\n    end\n\n    it 'returns the host header' do\n      expect(subject.headers['Host']).to be_present\n    end\n\n    it 'does not return virtual request-target header' do\n      expect(subject.headers['(request-target)']).to be_nil\n    end\n  end\n\n  describe '#on_behalf_of' do\n    it 'when used, adds signature header' do\n      subject.on_behalf_of(Fabricate(:account))\n      expect(subject.headers['Signature']).to be_present\n    end\n  end\n\n  describe '#add_headers' do\n    it 'adds headers to the request' do\n      subject.add_headers('Test' => 'Foo')\n      expect(subject.headers['Test']).to eq 'Foo'\n    end\n  end\n\n  describe '#perform' do\n    context 'with valid host' do\n      before { stub_request(:get, 'http://example.com') }\n\n      it 'executes a HTTP request' do\n        expect { |block| subject.perform(&block) }.to yield_control\n        expect(a_request(:get, 'http://example.com')).to have_been_made.once\n      end\n\n      it 'executes a HTTP request when the first address is private' do\n        resolver = instance_double(Resolv::DNS)\n\n        allow(resolver).to receive(:getaddresses).with('example.com').and_return(%w(0.0.0.0 2001:4860:4860::8844))\n        allow(resolver).to receive(:timeouts=).and_return(nil)\n        allow(Resolv::DNS).to receive(:open).and_yield(resolver)\n\n        expect { |block| subject.perform(&block) }.to yield_control\n        expect(a_request(:get, 'http://example.com')).to have_been_made.once\n      end\n\n      it 'sets headers' do\n        expect { |block| subject.perform(&block) }.to yield_control\n        expect(a_request(:get, 'http://example.com').with(headers: subject.headers)).to have_been_made\n      end\n\n      it 'closes underlying connection' do\n        expect_any_instance_of(HTTP::Client).to receive(:close)\n        expect { |block| subject.perform(&block) }.to yield_control\n      end\n\n      it 'returns response which implements body_with_limit' do\n        subject.perform do |response|\n          expect(response).to respond_to :body_with_limit\n        end\n      end\n    end\n\n    context 'with private host' do\n      around do |example|\n        WebMock.disable!\n        example.run\n        WebMock.enable!\n      end\n\n      it 'raises Mastodon::ValidationError' do\n        resolver = instance_double(Resolv::DNS)\n\n        allow(resolver).to receive(:getaddresses).with('example.com').and_return(%w(0.0.0.0 2001:db8::face))\n        allow(resolver).to receive(:timeouts=).and_return(nil)\n        allow(Resolv::DNS).to receive(:open).and_yield(resolver)\n\n        expect { subject.perform }.to raise_error Mastodon::ValidationError\n      end\n    end\n  end\n\n  describe \"response's body_with_limit method\" do\n    it 'rejects body more than 1 megabyte by default' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.megabytes))\n      expect { subject.perform(&:body_with_limit) }.to raise_error Mastodon::LengthValidationError\n    end\n\n    it 'accepts body less than 1 megabyte by default' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.kilobytes))\n      expect { subject.perform(&:body_with_limit) }.to_not raise_error\n    end\n\n    it 'rejects body by given size' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.kilobytes))\n      expect { subject.perform { |response| response.body_with_limit(1.kilobyte) } }.to raise_error Mastodon::LengthValidationError\n    end\n\n    it 'rejects too large chunked body' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.megabytes), headers: { 'Transfer-Encoding' => 'chunked' })\n      expect { subject.perform(&:body_with_limit) }.to raise_error Mastodon::LengthValidationError\n    end\n\n    it 'rejects too large monolithic body' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.megabytes), headers: { 'Content-Length' => 2.megabytes })\n      expect { subject.perform(&:body_with_limit) }.to raise_error Mastodon::LengthValidationError\n    end\n\n    it 'truncates large monolithic body' do\n      stub_request(:any, 'http://example.com').to_return(body: SecureRandom.random_bytes(2.megabytes), headers: { 'Content-Length' => 2.megabytes })\n      expect(subject.perform { |response| response.truncated_body.bytesize }).to be < 2.megabytes\n    end\n\n    it 'uses binary encoding if Content-Type does not tell encoding' do\n      stub_request(:any, 'http://example.com').to_return(body: '', headers: { 'Content-Type' => 'text/html' })\n      expect(subject.perform { |response| response.body_with_limit.encoding }).to eq Encoding::BINARY\n    end\n\n    it 'uses binary encoding if Content-Type tells unknown encoding' do\n      stub_request(:any, 'http://example.com').to_return(body: '', headers: { 'Content-Type' => 'text/html; charset=unknown' })\n      expect(subject.perform { |response| response.body_with_limit.encoding }).to eq Encoding::BINARY\n    end\n\n    it 'uses encoding specified by Content-Type' do\n      stub_request(:any, 'http://example.com').to_return(body: '', headers: { 'Content-Type' => 'text/html; charset=UTF-8' })\n      expect(subject.perform { |response| response.body_with_limit.encoding }).to eq Encoding::UTF_8\n    end\n  end\nend\n"], "filenames": ["app/lib/request.rb", "spec/controllers/concerns/signature_verification_spec.rb", "spec/lib/request_spec.rb"], "buggy_code_start_loc": [71, 132, 7], "buggy_code_end_loc": [162, 237, 243], "fixing_code_start_loc": [70, 131, 7], "fixing_code_end_loc": [143, 206, 94], "type": "CWE-113", "message": "Mastodon is a free, open-source social network server based on ActivityPub. Starting in version 4.2.0-beta1 and prior to version 4.2.0-rc2, by crafting specific input, attackers can inject arbitrary data into HTTP requests issued by Mastodon. This can be used to perform confused deputy attacks if the server configuration includes `ALLOWED_PRIVATE_ADDRESSES` to allow access to local exploitable services. Version 4.2.0-rc2 has a patch for the issue.", "other": {"cve": {"id": "CVE-2023-42450", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-19T16:15:12.897", "lastModified": "2024-02-16T20:35:15.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mastodon is a free, open-source social network server based on ActivityPub. Starting in version 4.2.0-beta1 and prior to version 4.2.0-rc2, by crafting specific input, attackers can inject arbitrary data into HTTP requests issued by Mastodon. This can be used to perform confused deputy attacks if the server configuration includes `ALLOWED_PRIVATE_ADDRESSES` to allow access to local exploitable services. Version 4.2.0-rc2 has a patch for the issue."}, {"lang": "es", "value": "Mastodon es un servidor de red social gratuito y de c\u00f3digo abierto basado en ActivityPub. A partir de la versi\u00f3n 4.2.0-beta1 y antes de la versi\u00f3n 4.2.0-rc2, al crear entradas espec\u00edficas, los atacantes pueden inyectar datos arbitrarios en las solicitudes HTTP emitidas por Mastodon. Esto se puede utilizar para realizar ataques adjuntos confusos si la configuraci\u00f3n del servidor incluye `ALLOWED_PRIVATE_ADDRESSES` para permitir el acceso a servicios locales explotables. La versi\u00f3n 4.2.0-rc2 tiene un parche para el problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-113"}, {"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:4.2.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "D76FF8DD-B11D-4119-9B4E-32CE8365A25B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:4.2.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "19DC8A22-E8EF-4FAB-B60E-64FE54AE0968"}, {"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:4.2.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "1406EB6A-186B-4A9C-95F6-5EC509867C3C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:4.2.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "089015EE-D7E4-4370-B1ED-52283B06FF0A"}]}]}], "references": [{"url": "https://github.com/mastodon/mastodon/commit/94893cf24fc95b32cc7a756262acbe008c20a9d2", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mastodon/mastodon/security/advisories/GHSA-hcqf-fw2r-52g4", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mastodon/mastodon/commit/94893cf24fc95b32cc7a756262acbe008c20a9d2"}}