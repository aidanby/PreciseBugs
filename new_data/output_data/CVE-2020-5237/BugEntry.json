{"buggy_code": ["<?php\n\nnamespace Oneup\\UploaderBundle\\Controller;\n\nuse Oneup\\UploaderBundle\\Uploader\\Response\\EmptyResponse;\nuse Symfony\\Component\\HttpFoundation\\File\\Exception\\UploadException;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass DropzoneController extends AbstractChunkedController\n{\n    public function upload()\n    {\n        $request = $this->getRequest();\n        $response = new EmptyResponse();\n        $files = $this->getFiles($request->files);\n        $statusCode = 200;\n\n        $chunked = null !== $request->request->get('dzchunkindex');\n\n        foreach ($files as $file) {\n            try {\n                $chunked ?\n                    $this->handleChunkedUpload($file, $response, $request) :\n                    $this->handleUpload($file, $response, $request)\n                ;\n            } catch (UploadException $e) {\n                $statusCode = 500; //Dropzone displays error if HTTP response is 40x or 50x\n                $this->errorHandler->addException($response, $e);\n                $translator = $this->container->get('translator');\n                $message = $translator->trans($e->getMessage(), [], 'OneupUploaderBundle');\n                $response = $this->createSupportedJsonResponse(['error' => $message]);\n                $response->setStatusCode(400);\n\n                return $response;\n            }\n        }\n\n        return $this->createSupportedJsonResponse($response->assemble(), $statusCode);\n    }\n\n    protected function parseChunkedRequest(Request $request)\n    {\n        $totalChunkCount = $request->get('dztotalchunkcount');\n        $index = $request->get('dzchunkindex');\n        $last = ((int) $index + 1) === (int) $totalChunkCount;\n        $uuid = $request->get('dzuuid');\n\n        /**\n         * @var UploadedFile\n         */\n        $file = $request->files->get('file')->getClientOriginalName();\n        $orig = $file;\n\n        return [$last, $uuid, $index, $orig];\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Controller;\n\nuse Oneup\\UploaderBundle\\Uploader\\Response\\FineUploaderResponse;\nuse Symfony\\Component\\HttpFoundation\\File\\Exception\\UploadException;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass FineUploaderController extends AbstractChunkedController\n{\n    public function upload()\n    {\n        $request = $this->getRequest();\n        $translator = $this->container->get('translator');\n\n        $response = new FineUploaderResponse();\n        $totalParts = $request->get('qqtotalparts', 1);\n        $files = $this->getFiles($request->files);\n        $chunked = $totalParts > 1;\n\n        foreach ($files as $file) {\n            try {\n                $chunked ?\n                    $this->handleChunkedUpload($file, $response, $request) :\n                    $this->handleUpload($file, $response, $request)\n                ;\n            } catch (UploadException $e) {\n                $response->setSuccess(false);\n                $response->setError($translator->trans($e->getMessage(), [], 'OneupUploaderBundle'));\n\n                $this->errorHandler->addException($response, $e);\n\n                // an error happended, return this error message.\n                return $this->createSupportedJsonResponse($response->assemble());\n            }\n        }\n\n        return $this->createSupportedJsonResponse($response->assemble());\n    }\n\n    protected function parseChunkedRequest(Request $request)\n    {\n        $index = $request->get('qqpartindex');\n        $total = $request->get('qqtotalparts');\n        $uuid = $request->get('qquuid');\n        $orig = $request->get('qqfilename');\n        $last = ((int) $total - 1) === (int) $index;\n\n        return [$last, $uuid, $index, $orig];\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Controller;\n\nuse Oneup\\UploaderBundle\\Uploader\\Response\\EmptyResponse;\nuse Symfony\\Component\\HttpFoundation\\File\\Exception\\UploadException;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass PluploadController extends AbstractChunkedController\n{\n    public function upload()\n    {\n        $request = $this->getRequest();\n        $response = new EmptyResponse();\n        $files = $this->getFiles($request->files);\n\n        $chunked = null !== $request->get('chunks');\n\n        foreach ($files as $file) {\n            try {\n                $chunked ?\n                    $this->handleChunkedUpload($file, $response, $request) :\n                    $this->handleUpload($file, $response, $request)\n                ;\n            } catch (UploadException $e) {\n                $this->errorHandler->addException($response, $e);\n            }\n        }\n\n        return $this->createSupportedJsonResponse($response->assemble());\n    }\n\n    protected function parseChunkedRequest(Request $request)\n    {\n        $session = $this->container->get('session');\n\n        $orig = $request->get('name');\n        $index = $request->get('chunk');\n        $last = (int) $request->get('chunks') - 1 === (int) $request->get('chunk');\n\n        // it is possible, that two clients send a file with the\n        // exact same filename, therefore we have to add the session\n        // to the uuid otherwise we will get a mess\n        $uuid = md5(sprintf('%s.%s', $orig, $session->getId()));\n\n        return [$last, $uuid, $index, $orig];\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Uploader\\Chunk\\Storage;\n\nuse Oneup\\UploaderBundle\\Uploader\\File\\FilesystemFile;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\Finder\\Finder;\nuse Symfony\\Component\\HttpFoundation\\File\\File;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass FilesystemStorage implements ChunkStorageInterface\n{\n    protected $directory;\n\n    public function __construct($directory)\n    {\n        $this->directory = $directory;\n    }\n\n    public function clear($maxAge)\n    {\n        $system = new Filesystem();\n        $finder = new Finder();\n\n        try {\n            $finder->in($this->directory)->date('<='.-1 * (int) $maxAge.'seconds')->files();\n        } catch (\\InvalidArgumentException $e) {\n            // the finder will throw an exception of type InvalidArgumentException\n            // if the directory he should search in does not exist\n            // in that case we don't have anything to clean\n            return;\n        }\n\n        foreach ($finder as $file) {\n            $system->remove($file);\n        }\n    }\n\n    public function addChunk($uuid, $index, UploadedFile $chunk, $original)\n    {\n        $filesystem = new Filesystem();\n        $path = sprintf('%s/%s', $this->directory, $uuid);\n        $name = sprintf('%s_%s', $index, $original);\n\n        // create directory if it does not yet exist\n        if (!$filesystem->exists($path)) {\n            $filesystem->mkdir(sprintf('%s/%s', $this->directory, $uuid));\n        }\n\n        return $chunk->move($path, $name);\n    }\n\n    public function assembleChunks($chunks, $removeChunk, $renameChunk)\n    {\n        if (!($chunks instanceof \\IteratorAggregate)) {\n            throw new \\InvalidArgumentException('The first argument must implement \\IteratorAggregate interface.');\n        }\n\n        $iterator = $chunks->getIterator();\n\n        $base = $iterator->current();\n        $iterator->next();\n\n        while ($iterator->valid()) {\n            $file = $iterator->current();\n\n            if (false === file_put_contents($base->getPathname(), file_get_contents($file->getPathname()), \\FILE_APPEND | \\LOCK_EX)) {\n                throw new \\RuntimeException('Reassembling chunks failed.');\n            }\n\n            if ($removeChunk) {\n                $filesystem = new Filesystem();\n                $filesystem->remove($file->getPathname());\n            }\n\n            $iterator->next();\n        }\n\n        $name = $base->getBasename();\n\n        if ($renameChunk) {\n            // remove the prefix added by self::addChunk\n            $name = preg_replace('/^(\\d+)_/', '', $base->getBasename());\n        }\n\n        $assembled = new File($base->getRealPath());\n        $assembled = $assembled->move($base->getPath(), $name);\n\n        // the file is only renamed before it is uploaded\n        if ($renameChunk) {\n            // create an file to meet interface restrictions\n            $assembled = new FilesystemFile(new UploadedFile($assembled->getPathname(), $assembled->getBasename(), null, $assembled->getSize(), null, true));\n        }\n\n        return $assembled;\n    }\n\n    public function cleanup($path)\n    {\n        // cleanup\n        $filesystem = new Filesystem();\n        $filesystem->remove($path);\n\n        return true;\n    }\n\n    public function getChunks($uuid)\n    {\n        $finder = new Finder();\n        $finder\n            ->in(sprintf('%s/%s', $this->directory, $uuid))->files()->sort(function (\\SplFileInfo $a, \\SplFileInfo $b) {\n                $t = explode('_', $a->getBasename());\n                $s = explode('_', $b->getBasename());\n                $t = (int) $t[0];\n                $s = (int) $s[0];\n\n                return $s < $t;\n            });\n\n        return $finder;\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Uploader\\Chunk\\Storage;\n\nuse League\\Flysystem\\FileNotFoundException;\nuse League\\Flysystem\\Filesystem;\nuse Oneup\\UploaderBundle\\Uploader\\File\\FlysystemFile;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass FlysystemStorage implements ChunkStorageInterface\n{\n    public $bufferSize;\n    protected $unhandledChunk;\n    protected $prefix;\n    protected $streamWrapperPrefix;\n\n    /**\n     * @var Filesystem\n     */\n    private $filesystem;\n\n    public function __construct(Filesystem $filesystem, $bufferSize, $streamWrapperPrefix, $prefix)\n    {\n        if (null === $streamWrapperPrefix) {\n            throw new \\InvalidArgumentException('Stream wrapper must be configured.');\n        }\n\n        $this->filesystem = $filesystem;\n        $this->bufferSize = $bufferSize;\n        $this->prefix = $prefix;\n        $this->streamWrapperPrefix = $streamWrapperPrefix;\n    }\n\n    public function clear($maxAge, $prefix = null)\n    {\n        $prefix = $prefix ?: $this->prefix;\n        $matches = $this->filesystem->listContents($prefix, true);\n\n        $now = time();\n        $toDelete = [];\n\n        // Collect the directories that are old,\n        // this also means the files inside are old\n        // but after the files are deleted the dirs\n        // would remain\n        foreach ($matches as $key) {\n            $path = $key['path'];\n            $timestamp = isset($key['timestamp']) ? $key['timestamp'] : $this->filesystem->getTimestamp($path);\n\n            if ($maxAge <= $now - $timestamp) {\n                $toDelete[] = $path;\n            }\n        }\n\n        foreach ($toDelete as $path) {\n            // The filesystem will throw exceptions if\n            // a directory is not empty\n            try {\n                $this->filesystem->delete($path);\n            } catch (\\Exception $e) {\n                continue;\n            }\n        }\n    }\n\n    public function addChunk($uuid, $index, UploadedFile $chunk, $original)\n    {\n        $this->unhandledChunk = [\n            'uuid' => $uuid,\n            'index' => $index,\n            'chunk' => $chunk,\n            'original' => $original,\n        ];\n    }\n\n    public function assembleChunks($chunks, $removeChunk, $renameChunk)\n    {\n        // the index is only added to be in sync with the filesystem storage\n        $path = $this->prefix.'/'.$this->unhandledChunk['uuid'].'/';\n        $filename = $this->unhandledChunk['index'].'_'.$this->unhandledChunk['original'];\n\n        if (empty($chunks)) {\n            $target = $filename;\n        } else {\n            sort($chunks, SORT_STRING | SORT_FLAG_CASE);\n            $target = pathinfo($chunks[0]['path'], PATHINFO_BASENAME);\n        }\n\n        $mode = 'ab';\n        if (0 === $this->unhandledChunk['index']) {\n            // if it's the first chunk overwrite the already existing part\n            // to avoid appending to earlier failed uploads\n            $mode = 'wb';\n        }\n\n        $file = fopen($this->unhandledChunk['chunk']->getPathname(), 'rb');\n        $dest = fopen($this->streamWrapperPrefix.'/'.$path.$target, $mode);\n\n        stream_copy_to_stream($file, $dest);\n\n        fclose($file);\n        fclose($dest);\n\n        if ($renameChunk) {\n            $name = $this->unhandledChunk['original'];\n            /* The name can only match if the same user in the same session is\n             * trying to upload a file under the same name AND the previous upload failed,\n             * somewhere between this function, and the cleanup call. If that happened\n             * the previous file is unaccessible by the user, but if it is not removed\n             * it will block the user from trying to re-upload it.\n             */\n            if ($this->filesystem->has($path.$name)) {\n                $this->filesystem->delete($path.$name);\n            }\n\n            $this->filesystem->rename($path.$target, $path.$name);\n            $target = $name;\n        }\n        $uploaded = $this->filesystem->get($path.$target);\n\n        if (!$renameChunk) {\n            return $uploaded;\n        }\n\n        return new FlysystemFile($uploaded, $this->filesystem, $this->streamWrapperPrefix);\n    }\n\n    public function cleanup($path)\n    {\n        try {\n            $this->filesystem->delete($path);\n        } catch (FileNotFoundException $e) {\n            // File already gone.\n        }\n    }\n\n    public function getChunks($uuid)\n    {\n        return $this->filesystem->listFiles($this->prefix.'/'.$uuid);\n    }\n\n    public function getFilesystem()\n    {\n        return $this->filesystem;\n    }\n\n    public function getStreamWrapperPrefix()\n    {\n        return $this->streamWrapperPrefix;\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Uploader\\Chunk\\Storage;\n\nuse Gaufrette\\Adapter\\StreamFactory;\nuse Gaufrette\\Filesystem;\nuse Gaufrette\\FilesystemInterface;\nuse Oneup\\UploaderBundle\\Uploader\\File\\FilesystemFile;\nuse Oneup\\UploaderBundle\\Uploader\\File\\GaufretteFile;\nuse Oneup\\UploaderBundle\\Uploader\\Gaufrette\\StreamManager;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass GaufretteStorage extends StreamManager implements ChunkStorageInterface\n{\n    protected $unhandledChunk;\n    protected $prefix;\n    protected $streamWrapperPrefix;\n\n    /**\n     * @param FilesystemInterface|Filesystem $filesystem\n     * @param int                            $bufferSize\n     * @param string                         $streamWrapperPrefix\n     * @param string                         $prefix\n     */\n    public function __construct($filesystem, $bufferSize, $streamWrapperPrefix, $prefix)\n    {\n        $base = interface_exists('Gaufrette\\FilesystemInterface')\n            ? 'Gaufrette\\FilesystemInterface'\n            : 'Gaufrette\\Filesystem';\n\n        if (!$filesystem instanceof $base) {\n            throw new \\InvalidArgumentException(sprintf('Expected an instance of \"%s\", got \"%s\".', $base, is_object($filesystem) ? get_class($filesystem) : gettype($filesystem)));\n        }\n\n        if (!($filesystem->getAdapter() instanceof StreamFactory)) {\n            throw new \\InvalidArgumentException('The filesystem used as chunk storage must implement StreamFactory');\n        }\n        $this->filesystem = $filesystem;\n        $this->buffersize = $bufferSize;\n        $this->prefix = $prefix;\n        $this->streamWrapperPrefix = $streamWrapperPrefix;\n    }\n\n    /**\n     * Clears files and folders older than $maxAge in $prefix\n     * $prefix must be passable so it can clean the orphanage too\n     * as it is forced to be the same filesystem.\n     *\n     * @param      $maxAge\n     * @param null $prefix\n     */\n    public function clear($maxAge, $prefix = null)\n    {\n        $prefix = $prefix ?: $this->prefix;\n        $matches = $this->filesystem->listKeys($prefix);\n\n        $now = time();\n        $toDelete = [];\n\n        // Collect the directories that are old,\n        // this also means the files inside are old\n        // but after the files are deleted the dirs\n        // would remain\n        foreach ($matches['dirs'] as $key) {\n            if ($maxAge <= $now - $this->filesystem->mtime($key)) {\n                $toDelete[] = $key;\n            }\n        }\n        // The same directory is returned for every file it contains\n        array_unique($toDelete);\n        foreach ($matches['keys'] as $key) {\n            if ($maxAge <= $now - $this->filesystem->mtime($key)) {\n                $this->filesystem->delete($key);\n            }\n        }\n\n        foreach ($toDelete as $key) {\n            // The filesystem will throw exceptions if\n            // a directory is not empty\n            try {\n                $this->filesystem->delete($key);\n            } catch (\\Exception $e) {\n                continue;\n            }\n        }\n    }\n\n    /**\n     * Only saves the information about the chunk to avoid moving it\n     * forth-and-back to reassemble it. Load distribution is enforced\n     * for gaufrette based chunk storage therefore assembleChunks will\n     * be called in the same request.\n     *\n     * @param              $uuid\n     * @param              $index\n     * @param UploadedFile $chunk\n     * @param              $original\n     */\n    public function addChunk($uuid, $index, UploadedFile $chunk, $original)\n    {\n        $this->unhandledChunk = [\n            'uuid' => $uuid,\n            'index' => $index,\n            'chunk' => $chunk,\n            'original' => $original,\n        ];\n    }\n\n    public function assembleChunks($chunks, $removeChunk, $renameChunk)\n    {\n        // the index is only added to be in sync with the filesystem storage\n        $path = $this->prefix.'/'.$this->unhandledChunk['uuid'].'/';\n        $filename = $this->unhandledChunk['index'].'_'.$this->unhandledChunk['original'];\n\n        if (empty($chunks)) {\n            $target = $filename;\n            $this->ensureRemotePathExists($path.$target);\n        } else {\n            /*\n             * The array only contains items with matching prefix until the filename\n             * therefore the order will be decided depending on the filename\n             * It is only case-insensitive to be overly-careful.\n             */\n            sort($chunks, SORT_STRING | SORT_FLAG_CASE);\n            $target = pathinfo($chunks[0], PATHINFO_BASENAME);\n        }\n\n        $dst = $this->filesystem->createStream($path.$target);\n        if (0 === $this->unhandledChunk['index']) {\n            // if it's the first chunk overwrite the already existing part\n            // to avoid appending to earlier failed uploads\n            $this->openStream($dst, 'w');\n        } else {\n            $this->openStream($dst, 'a');\n        }\n\n        // Meet the interface requirements\n        $uploadedFile = new FilesystemFile($this->unhandledChunk['chunk']);\n\n        $this->stream($uploadedFile, $dst);\n\n        if ($renameChunk) {\n            $name = preg_replace('/^(\\d+)_/', '', $target);\n            /* The name can only match if the same user in the same session is\n             * trying to upload a file under the same name AND the previous upload failed,\n             * somewhere between this function, and the cleanup call. If that happened\n             * the previous file is unaccessible by the user, but if it is not removed\n             * it will block the user from trying to re-upload it.\n             */\n            if ($this->filesystem->has($path.$name)) {\n                $this->filesystem->delete($path.$name);\n            }\n\n            $this->filesystem->rename($path.$target, $path.$name);\n            $target = $name;\n        }\n        $uploaded = $this->filesystem->get($path.$target);\n\n        if (!$renameChunk) {\n            return $uploaded;\n        }\n\n        return new GaufretteFile($uploaded, $this->filesystem, $this->streamWrapperPrefix);\n    }\n\n    public function cleanup($path)\n    {\n        $this->filesystem->delete($path);\n    }\n\n    public function getChunks($uuid)\n    {\n        $results = $this->filesystem->listKeys($this->prefix.'/'.$uuid);\n\n        /* exclude files without an index, so if there is a completed file which\n         * failed to upload it will not get mixed together with new one's chunks.\n         */\n\n        return preg_grep('/^.+\\/(\\d+)_/', $results['keys']);\n    }\n\n    public function getFilesystem()\n    {\n        return $this->filesystem;\n    }\n\n    public function getStreamWrapperPrefix()\n    {\n        return $this->streamWrapperPrefix;\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Oneup\\UploaderBundle\\Controller;\n\nuse Oneup\\UploaderBundle\\Uploader\\Response\\EmptyResponse;\nuse Symfony\\Component\\HttpFoundation\\File\\Exception\\UploadException;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass DropzoneController extends AbstractChunkedController\n{\n    public function upload()\n    {\n        $request = $this->getRequest();\n        $response = new EmptyResponse();\n        $files = $this->getFiles($request->files);\n        $statusCode = 200;\n\n        $chunked = null !== $request->request->get('dzchunkindex');\n\n        foreach ($files as $file) {\n            try {\n                $chunked ?\n                    $this->handleChunkedUpload($file, $response, $request) :\n                    $this->handleUpload($file, $response, $request)\n                ;\n            } catch (UploadException $e) {\n                $statusCode = 500; //Dropzone displays error if HTTP response is 40x or 50x\n                $this->errorHandler->addException($response, $e);\n                $translator = $this->container->get('translator');\n                $message = $translator->trans($e->getMessage(), [], 'OneupUploaderBundle');\n                $response = $this->createSupportedJsonResponse(['error' => $message]);\n                $response->setStatusCode(400);\n\n                return $response;\n            }\n        }\n\n        return $this->createSupportedJsonResponse($response->assemble(), $statusCode);\n    }\n\n    protected function parseChunkedRequest(Request $request)\n    {\n        $totalChunkCount = $request->get('dztotalchunkcount');\n        $index = (int) $request->get('dzchunkindex');\n        $last = ($index + 1) === (int) $totalChunkCount;\n        $uuid = $request->get('dzuuid');\n\n        /**\n         * @var UploadedFile\n         */\n        $file = $request->files->get('file')->getClientOriginalName();\n        $orig = $file;\n\n        return [$last, $uuid, $index, $orig];\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Controller;\n\nuse Oneup\\UploaderBundle\\Uploader\\Response\\FineUploaderResponse;\nuse Symfony\\Component\\HttpFoundation\\File\\Exception\\UploadException;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass FineUploaderController extends AbstractChunkedController\n{\n    public function upload()\n    {\n        $request = $this->getRequest();\n        $translator = $this->container->get('translator');\n\n        $response = new FineUploaderResponse();\n        $totalParts = $request->get('qqtotalparts', 1);\n        $files = $this->getFiles($request->files);\n        $chunked = $totalParts > 1;\n\n        foreach ($files as $file) {\n            try {\n                $chunked ?\n                    $this->handleChunkedUpload($file, $response, $request) :\n                    $this->handleUpload($file, $response, $request)\n                ;\n            } catch (UploadException $e) {\n                $response->setSuccess(false);\n                $response->setError($translator->trans($e->getMessage(), [], 'OneupUploaderBundle'));\n\n                $this->errorHandler->addException($response, $e);\n\n                // an error happended, return this error message.\n                return $this->createSupportedJsonResponse($response->assemble());\n            }\n        }\n\n        return $this->createSupportedJsonResponse($response->assemble());\n    }\n\n    protected function parseChunkedRequest(Request $request)\n    {\n        $index = (int) $request->get('qqpartindex');\n        $total = (int) $request->get('qqtotalparts');\n        $uuid = $request->get('qquuid');\n        $orig = $request->get('qqfilename');\n        $last = ($total - 1) === $index;\n\n        return [$last, $uuid, $index, $orig];\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Controller;\n\nuse Oneup\\UploaderBundle\\Uploader\\Response\\EmptyResponse;\nuse Symfony\\Component\\HttpFoundation\\File\\Exception\\UploadException;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass PluploadController extends AbstractChunkedController\n{\n    public function upload()\n    {\n        $request = $this->getRequest();\n        $response = new EmptyResponse();\n        $files = $this->getFiles($request->files);\n\n        $chunked = null !== $request->get('chunks');\n\n        foreach ($files as $file) {\n            try {\n                $chunked ?\n                    $this->handleChunkedUpload($file, $response, $request) :\n                    $this->handleUpload($file, $response, $request)\n                ;\n            } catch (UploadException $e) {\n                $this->errorHandler->addException($response, $e);\n            }\n        }\n\n        return $this->createSupportedJsonResponse($response->assemble());\n    }\n\n    protected function parseChunkedRequest(Request $request)\n    {\n        $session = $this->container->get('session');\n\n        $orig = $request->get('name');\n        $index = (int) $request->get('chunk');\n        $last = (int) $request->get('chunks') - 1 === (int) $request->get('chunk');\n\n        // it is possible, that two clients send a file with the\n        // exact same filename, therefore we have to add the session\n        // to the uuid otherwise we will get a mess\n        $uuid = md5(sprintf('%s.%s', $orig, $session->getId()));\n\n        return [$last, $uuid, $index, $orig];\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Uploader\\Chunk\\Storage;\n\nuse Oneup\\UploaderBundle\\Uploader\\File\\FilesystemFile;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\Finder\\Finder;\nuse Symfony\\Component\\HttpFoundation\\File\\File;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass FilesystemStorage implements ChunkStorageInterface\n{\n    protected $directory;\n\n    public function __construct($directory)\n    {\n        $this->directory = $directory;\n    }\n\n    public function clear($maxAge)\n    {\n        $system = new Filesystem();\n        $finder = new Finder();\n\n        try {\n            $finder->in($this->directory)->date('<='.-1 * (int) $maxAge.'seconds')->files();\n        } catch (\\InvalidArgumentException $e) {\n            // the finder will throw an exception of type InvalidArgumentException\n            // if the directory he should search in does not exist\n            // in that case we don't have anything to clean\n            return;\n        }\n\n        foreach ($finder as $file) {\n            $system->remove($file);\n        }\n    }\n\n    public function addChunk($uuid, $index, UploadedFile $chunk, $original)\n    {\n        // Prevent path traversal attacks\n        $uuid = basename($uuid);\n\n        $filesystem = new Filesystem();\n        $path = sprintf('%s/%s', $this->directory, $uuid);\n        $name = sprintf('%s_%s', $index, $original);\n\n        // create directory if it does not yet exist\n        if (!$filesystem->exists($path)) {\n            $filesystem->mkdir(sprintf('%s/%s', $this->directory, $uuid));\n        }\n\n        return $chunk->move($path, $name);\n    }\n\n    public function assembleChunks($chunks, $removeChunk, $renameChunk)\n    {\n        if (!($chunks instanceof \\IteratorAggregate)) {\n            throw new \\InvalidArgumentException('The first argument must implement \\IteratorAggregate interface.');\n        }\n\n        $iterator = $chunks->getIterator();\n\n        $base = $iterator->current();\n        $iterator->next();\n\n        while ($iterator->valid()) {\n            $file = $iterator->current();\n\n            if (false === file_put_contents($base->getPathname(), file_get_contents($file->getPathname()), \\FILE_APPEND | \\LOCK_EX)) {\n                throw new \\RuntimeException('Reassembling chunks failed.');\n            }\n\n            if ($removeChunk) {\n                $filesystem = new Filesystem();\n                $filesystem->remove($file->getPathname());\n            }\n\n            $iterator->next();\n        }\n\n        $name = $base->getBasename();\n\n        if ($renameChunk) {\n            // remove the prefix added by self::addChunk\n            $name = preg_replace('/^(\\d+)_/', '', $base->getBasename());\n        }\n\n        $assembled = new File($base->getRealPath());\n        $assembled = $assembled->move($base->getPath(), $name);\n\n        // the file is only renamed before it is uploaded\n        if ($renameChunk) {\n            // create an file to meet interface restrictions\n            $assembled = new FilesystemFile(new UploadedFile($assembled->getPathname(), $assembled->getBasename(), null, $assembled->getSize(), null, true));\n        }\n\n        return $assembled;\n    }\n\n    public function cleanup($path)\n    {\n        // cleanup\n        $filesystem = new Filesystem();\n        $filesystem->remove($path);\n\n        return true;\n    }\n\n    public function getChunks($uuid)\n    {\n        // Prevent path traversal attacks\n        $uuid = basename($uuid);\n\n        $finder = new Finder();\n        $finder\n            ->in(sprintf('%s/%s', $this->directory, $uuid))->files()->sort(function (\\SplFileInfo $a, \\SplFileInfo $b) {\n                $t = explode('_', $a->getBasename());\n                $s = explode('_', $b->getBasename());\n                $t = (int) $t[0];\n                $s = (int) $s[0];\n\n                return $s < $t;\n            });\n\n        return $finder;\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Uploader\\Chunk\\Storage;\n\nuse League\\Flysystem\\FileNotFoundException;\nuse League\\Flysystem\\Filesystem;\nuse Oneup\\UploaderBundle\\Uploader\\File\\FlysystemFile;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass FlysystemStorage implements ChunkStorageInterface\n{\n    public $bufferSize;\n    protected $unhandledChunk;\n    protected $prefix;\n    protected $streamWrapperPrefix;\n\n    /**\n     * @var Filesystem\n     */\n    private $filesystem;\n\n    public function __construct(Filesystem $filesystem, $bufferSize, $streamWrapperPrefix, $prefix)\n    {\n        if (null === $streamWrapperPrefix) {\n            throw new \\InvalidArgumentException('Stream wrapper must be configured.');\n        }\n\n        $this->filesystem = $filesystem;\n        $this->bufferSize = $bufferSize;\n        $this->prefix = $prefix;\n        $this->streamWrapperPrefix = $streamWrapperPrefix;\n    }\n\n    public function clear($maxAge, $prefix = null)\n    {\n        $prefix = $prefix ?: $this->prefix;\n        $matches = $this->filesystem->listContents($prefix, true);\n\n        $now = time();\n        $toDelete = [];\n\n        // Collect the directories that are old,\n        // this also means the files inside are old\n        // but after the files are deleted the dirs\n        // would remain\n        foreach ($matches as $key) {\n            $path = $key['path'];\n            $timestamp = isset($key['timestamp']) ? $key['timestamp'] : $this->filesystem->getTimestamp($path);\n\n            if ($maxAge <= $now - $timestamp) {\n                $toDelete[] = $path;\n            }\n        }\n\n        foreach ($toDelete as $path) {\n            // The filesystem will throw exceptions if\n            // a directory is not empty\n            try {\n                $this->filesystem->delete($path);\n            } catch (\\Exception $e) {\n                continue;\n            }\n        }\n    }\n\n    public function addChunk($uuid, $index, UploadedFile $chunk, $original)\n    {\n        // Prevent path traversal attacks\n        $uuid = basename($uuid);\n\n        $this->unhandledChunk = [\n            'uuid' => $uuid,\n            'index' => $index,\n            'chunk' => $chunk,\n            'original' => $original,\n        ];\n    }\n\n    public function assembleChunks($chunks, $removeChunk, $renameChunk)\n    {\n        // the index is only added to be in sync with the filesystem storage\n        $path = $this->prefix.'/'.$this->unhandledChunk['uuid'].'/';\n        $filename = $this->unhandledChunk['index'].'_'.$this->unhandledChunk['original'];\n\n        if (empty($chunks)) {\n            $target = $filename;\n        } else {\n            sort($chunks, SORT_STRING | SORT_FLAG_CASE);\n            $target = pathinfo($chunks[0]['path'], PATHINFO_BASENAME);\n        }\n\n        $mode = 'ab';\n        if (0 === $this->unhandledChunk['index']) {\n            // if it's the first chunk overwrite the already existing part\n            // to avoid appending to earlier failed uploads\n            $mode = 'wb';\n        }\n\n        $file = fopen($this->unhandledChunk['chunk']->getPathname(), 'rb');\n        $dest = fopen($this->streamWrapperPrefix.'/'.$path.$target, $mode);\n\n        stream_copy_to_stream($file, $dest);\n\n        fclose($file);\n        fclose($dest);\n\n        if ($renameChunk) {\n            $name = $this->unhandledChunk['original'];\n            /* The name can only match if the same user in the same session is\n             * trying to upload a file under the same name AND the previous upload failed,\n             * somewhere between this function, and the cleanup call. If that happened\n             * the previous file is unaccessible by the user, but if it is not removed\n             * it will block the user from trying to re-upload it.\n             */\n            if ($this->filesystem->has($path.$name)) {\n                $this->filesystem->delete($path.$name);\n            }\n\n            $this->filesystem->rename($path.$target, $path.$name);\n            $target = $name;\n        }\n        $uploaded = $this->filesystem->get($path.$target);\n\n        if (!$renameChunk) {\n            return $uploaded;\n        }\n\n        return new FlysystemFile($uploaded, $this->filesystem, $this->streamWrapperPrefix);\n    }\n\n    public function cleanup($path)\n    {\n        try {\n            $this->filesystem->delete($path);\n        } catch (FileNotFoundException $e) {\n            // File already gone.\n        }\n    }\n\n    public function getChunks($uuid)\n    {\n        // Prevent path traversal attacks\n        $uuid = basename($uuid);\n\n        return $this->filesystem->listFiles($this->prefix.'/'.$uuid);\n    }\n\n    public function getFilesystem()\n    {\n        return $this->filesystem;\n    }\n\n    public function getStreamWrapperPrefix()\n    {\n        return $this->streamWrapperPrefix;\n    }\n}\n", "<?php\n\nnamespace Oneup\\UploaderBundle\\Uploader\\Chunk\\Storage;\n\nuse Gaufrette\\Adapter\\StreamFactory;\nuse Gaufrette\\Filesystem;\nuse Gaufrette\\FilesystemInterface;\nuse Oneup\\UploaderBundle\\Uploader\\File\\FilesystemFile;\nuse Oneup\\UploaderBundle\\Uploader\\File\\GaufretteFile;\nuse Oneup\\UploaderBundle\\Uploader\\Gaufrette\\StreamManager;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\n\nclass GaufretteStorage extends StreamManager implements ChunkStorageInterface\n{\n    protected $unhandledChunk;\n    protected $prefix;\n    protected $streamWrapperPrefix;\n\n    /**\n     * @param FilesystemInterface|Filesystem $filesystem\n     * @param int                            $bufferSize\n     * @param string                         $streamWrapperPrefix\n     * @param string                         $prefix\n     */\n    public function __construct($filesystem, $bufferSize, $streamWrapperPrefix, $prefix)\n    {\n        $base = interface_exists('Gaufrette\\FilesystemInterface')\n            ? 'Gaufrette\\FilesystemInterface'\n            : 'Gaufrette\\Filesystem';\n\n        if (!$filesystem instanceof $base) {\n            throw new \\InvalidArgumentException(sprintf('Expected an instance of \"%s\", got \"%s\".', $base, is_object($filesystem) ? get_class($filesystem) : gettype($filesystem)));\n        }\n\n        if (!($filesystem->getAdapter() instanceof StreamFactory)) {\n            throw new \\InvalidArgumentException('The filesystem used as chunk storage must implement StreamFactory');\n        }\n        $this->filesystem = $filesystem;\n        $this->buffersize = $bufferSize;\n        $this->prefix = $prefix;\n        $this->streamWrapperPrefix = $streamWrapperPrefix;\n    }\n\n    /**\n     * Clears files and folders older than $maxAge in $prefix\n     * $prefix must be passable so it can clean the orphanage too\n     * as it is forced to be the same filesystem.\n     *\n     * @param      $maxAge\n     * @param null $prefix\n     */\n    public function clear($maxAge, $prefix = null)\n    {\n        $prefix = $prefix ?: $this->prefix;\n        $matches = $this->filesystem->listKeys($prefix);\n\n        $now = time();\n        $toDelete = [];\n\n        // Collect the directories that are old,\n        // this also means the files inside are old\n        // but after the files are deleted the dirs\n        // would remain\n        foreach ($matches['dirs'] as $key) {\n            if ($maxAge <= $now - $this->filesystem->mtime($key)) {\n                $toDelete[] = $key;\n            }\n        }\n        // The same directory is returned for every file it contains\n        array_unique($toDelete);\n        foreach ($matches['keys'] as $key) {\n            if ($maxAge <= $now - $this->filesystem->mtime($key)) {\n                $this->filesystem->delete($key);\n            }\n        }\n\n        foreach ($toDelete as $key) {\n            // The filesystem will throw exceptions if\n            // a directory is not empty\n            try {\n                $this->filesystem->delete($key);\n            } catch (\\Exception $e) {\n                continue;\n            }\n        }\n    }\n\n    /**\n     * Only saves the information about the chunk to avoid moving it\n     * forth-and-back to reassemble it. Load distribution is enforced\n     * for gaufrette based chunk storage therefore assembleChunks will\n     * be called in the same request.\n     *\n     * @param              $uuid\n     * @param              $index\n     * @param UploadedFile $chunk\n     * @param              $original\n     */\n    public function addChunk($uuid, $index, UploadedFile $chunk, $original)\n    {\n        // Prevent path traversal attacks\n        $uuid = basename($uuid);\n\n        $this->unhandledChunk = [\n            'uuid' => $uuid,\n            'index' => $index,\n            'chunk' => $chunk,\n            'original' => $original,\n        ];\n    }\n\n    public function assembleChunks($chunks, $removeChunk, $renameChunk)\n    {\n        // the index is only added to be in sync with the filesystem storage\n        $path = $this->prefix.'/'.$this->unhandledChunk['uuid'].'/';\n        $filename = $this->unhandledChunk['index'].'_'.$this->unhandledChunk['original'];\n\n        if (empty($chunks)) {\n            $target = $filename;\n            $this->ensureRemotePathExists($path.$target);\n        } else {\n            /*\n             * The array only contains items with matching prefix until the filename\n             * therefore the order will be decided depending on the filename\n             * It is only case-insensitive to be overly-careful.\n             */\n            sort($chunks, SORT_STRING | SORT_FLAG_CASE);\n            $target = pathinfo($chunks[0], PATHINFO_BASENAME);\n        }\n\n        $dst = $this->filesystem->createStream($path.$target);\n        if (0 === $this->unhandledChunk['index']) {\n            // if it's the first chunk overwrite the already existing part\n            // to avoid appending to earlier failed uploads\n            $this->openStream($dst, 'w');\n        } else {\n            $this->openStream($dst, 'a');\n        }\n\n        // Meet the interface requirements\n        $uploadedFile = new FilesystemFile($this->unhandledChunk['chunk']);\n\n        $this->stream($uploadedFile, $dst);\n\n        if ($renameChunk) {\n            $name = preg_replace('/^(\\d+)_/', '', $target);\n            /* The name can only match if the same user in the same session is\n             * trying to upload a file under the same name AND the previous upload failed,\n             * somewhere between this function, and the cleanup call. If that happened\n             * the previous file is unaccessible by the user, but if it is not removed\n             * it will block the user from trying to re-upload it.\n             */\n            if ($this->filesystem->has($path.$name)) {\n                $this->filesystem->delete($path.$name);\n            }\n\n            $this->filesystem->rename($path.$target, $path.$name);\n            $target = $name;\n        }\n        $uploaded = $this->filesystem->get($path.$target);\n\n        if (!$renameChunk) {\n            return $uploaded;\n        }\n\n        return new GaufretteFile($uploaded, $this->filesystem, $this->streamWrapperPrefix);\n    }\n\n    public function cleanup($path)\n    {\n        $this->filesystem->delete($path);\n    }\n\n    public function getChunks($uuid)\n    {\n        // Prevent path traversal attacks\n        $uuid = basename($uuid);\n\n        $results = $this->filesystem->listKeys($this->prefix.'/'.$uuid);\n\n        /* exclude files without an index, so if there is a completed file which\n         * failed to upload it will not get mixed together with new one's chunks.\n         */\n\n        return preg_grep('/^.+\\/(\\d+)_/', $results['keys']);\n    }\n\n    public function getFilesystem()\n    {\n        return $this->filesystem;\n    }\n\n    public function getStreamWrapperPrefix()\n    {\n        return $this->streamWrapperPrefix;\n    }\n}\n"], "filenames": ["Controller/DropzoneController.php", "Controller/FineUploaderController.php", "Controller/PluploadController.php", "Uploader/Chunk/Storage/FilesystemStorage.php", "Uploader/Chunk/Storage/FlysystemStorage.php", "Uploader/Chunk/Storage/GaufretteStorage.php"], "buggy_code_start_loc": [45, 43, 38, 40, 67, 100], "buggy_code_end_loc": [47, 48, 39, 108, 138, 172], "fixing_code_start_loc": [45, 43, 38, 41, 68, 101], "fixing_code_end_loc": [47, 48, 39, 115, 145, 179], "type": "CWE-22", "message": "Multiple relative path traversal vulnerabilities in the oneup/uploader-bundle before 1.9.3 and 2.1.5 allow remote attackers to upload, copy, and modify files on the filesystem (potentially leading to arbitrary code execution) via the (1) filename parameter to BlueimpController.php; the (2) dzchunkindex, (3) dzuuid, or (4) filename parameter to DropzoneController.php; the (5) qqpartindex, (6) qqfilename, or (7) qquuid parameter to FineUploaderController.php; the (8) x-file-id or (9) x-file-name parameter to MooUploadController.php; or the (10) name or (11) chunk parameter to PluploadController.php. This is fixed in versions 1.9.3 and 2.1.5.", "other": {"cve": {"id": "CVE-2020-5237", "sourceIdentifier": "security-advisories@github.com", "published": "2020-02-05T14:15:11.527", "lastModified": "2021-12-30T13:39:39.763", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple relative path traversal vulnerabilities in the oneup/uploader-bundle before 1.9.3 and 2.1.5 allow remote attackers to upload, copy, and modify files on the filesystem (potentially leading to arbitrary code execution) via the (1) filename parameter to BlueimpController.php; the (2) dzchunkindex, (3) dzuuid, or (4) filename parameter to DropzoneController.php; the (5) qqpartindex, (6) qqfilename, or (7) qquuid parameter to FineUploaderController.php; the (8) x-file-id or (9) x-file-name parameter to MooUploadController.php; or the (10) name or (11) chunk parameter to PluploadController.php. This is fixed in versions 1.9.3 and 2.1.5."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de recorrido relativo en el paquete oneup / uploader anterior a 1.9.3 y 2.1.5 permiten a los atacantes remotos cargar, copiar y modificar archivos en el sistema de archivos (lo que puede conducir a la ejecuci\u00f3n de c\u00f3digo arbitrario) a trav\u00e9s del (1) par\u00e1metro de nombre de archivo para BlueimpController.php; el (2) dzchunkindex, (3) dzuuid o (4) par\u00e1metro de nombre de archivo a DropzoneController.php; el (5) qqpartindex, (6) qqfilename o (7) qquuid par\u00e1metro a FineUploaderController.php; el par\u00e1metro (8) x-file-id o (9) x-file-name a MooUploadController.php; o el nombre (10) o el par\u00e1metro (11) fragmento a PluploadController.php. Esto se soluciona en las versiones 1.9.3 y 2.1.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-23"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:1up:oneupuploaderbundle:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.3", "matchCriteriaId": "ECD8AECE-2DDD-447B-B55A-716F249CA873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:1up:oneupuploaderbundle:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.9.4", "versionEndExcluding": "2.1.5", "matchCriteriaId": "93957E45-77E4-47E5-A831-1BAA55226980"}]}]}], "references": [{"url": "https://github.com/1up-lab/OneupUploaderBundle/commit/a6011449b716f163fe1ae323053077e59212350c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/1up-lab/OneupUploaderBundle/security/advisories/GHSA-x8wj-6m73-gfqp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2020-003.txt", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/1up-lab/OneupUploaderBundle/commit/a6011449b716f163fe1ae323053077e59212350c"}}