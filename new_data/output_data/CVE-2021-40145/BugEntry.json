{"buggy_code": ["/*\n   * gd_gd2.c\n   *\n   * Implements the I/O and support for the GD2 format.\n   *\n   * Changing the definition of GD2_DBG (below) will cause copious messages\n   * to be displayed while it processes requests.\n   *\n   * Designed, Written & Copyright 1999, Philip Warner.\n   *\n */\n\n/**\n * File: GD2 IO\n *\n * Read and write GD2 images.\n *\n * The GD2 image format is a proprietary image format of libgd. *It has to be*\n * *regarded as being obsolete, and should only be used for development and*\n * *testing purposes.*\n *\n * Structure of a GD2 image file:\n *  - file header\n *  - chunk headers (only for compressed data)\n *  - color header (either truecolor or palette)\n *  - chunks of image data (chunk-row-major, top to bottom, left to right)\n *\n * All numbers are stored in big-endian format.\n *\n * File header structure:\n *  signature     - 4 bytes (always \"gd2\\0\")\n *  version       - 1 word (e.g. \"\\0\\002\")\n *  width         - 1 word\n *  height        - 1 word\n *  chunk_size    - 1 word\n *  format        - 1 word\n *  x_chunk_count - 1 word\n *  y_chunk_count - 1 word\n *\n * Recognized formats:\n *  1 - raw palette image data\n *  2 - compressed palette image data\n *  3 - raw truecolor image data\n *  4 - compressed truecolor image data\n *\n * Chunk header:\n *  offset - 1 dword\n *  size   - 1 dword\n *\n * There are x_chunk_count * y_chunk_count chunk headers.\n *\n * Truecolor image color header:\n *  truecolor   - 1 byte (always \"\\001\")\n *  transparent - 1 dword (ARGB color); \"\\377\\377\\377\\377\" means that no\n *\t\t\t\t  transparent color is set\n *\n * Palette image color header:\n *  truecolor   - 1 byte (always \"\\0\")\n *  count       - 1 word (the number of used palette colors)\n *  transparent - 1 dword (palette index); \"\\377\\377\\377\\377\" means that no\n *\t\t\t\t  transparent color is set\n *  palette     - 256 dwords (RGBA colors)\n *\n * Chunk structure:\n *  Sequential pixel data of a rectangular area (chunk_size x chunk_size),\n *  row-major from top to bottom, left to right:\n *  - 1 byte per pixel for palette images\n *  - 1 dword (ARGB) per pixel for truecolor images\n *\n *  Depending on format, the chunk may be ZLIB compressed.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n/* 2.0.29: no more errno.h, makes windows happy */\n#include <math.h>\n#include <limits.h>\n#include <string.h>\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n/* 2.03: gd2 is no longer mandatory */\n/* JCE - test after including gd.h so that HAVE_LIBZ can be set in\n * a config.h file included by gd.h */\n#if defined(HAVE_LIBZ) && ENABLE_GD_FORMATS\n#include <zlib.h>\n\n#define TRUE 1\n#define FALSE 0\n\n/* 2.11: not part of the API, as the save routine can figure it out\n\tfrom im->trueColor, and the load routine doesn't need to tell\n\tthe end user the saved format. NOTE: adding 2 is assumed\n\tto result in the correct format value for truecolor! */\n#define GD2_FMT_TRUECOLOR_RAW 3\n#define GD2_FMT_TRUECOLOR_COMPRESSED 4\n\n#define gd2_compressed(fmt) (((fmt) == GD2_FMT_COMPRESSED) || \\\n\t((fmt) == GD2_FMT_TRUECOLOR_COMPRESSED))\n\n#define gd2_truecolor(fmt) (((fmt) == GD2_FMT_TRUECOLOR_RAW) || \\\n\t((fmt) == GD2_FMT_TRUECOLOR_COMPRESSED))\n\n/* Use this for commenting out debug-print statements. */\n/* Just use the first '#define' to allow all the prints... */\n/*#define GD2_DBG(s) (s) */\n#define GD2_DBG(s)\n\ntypedef struct {\n\tint offset;\n\tint size;\n}\nt_chunk_info;\n\nextern int _gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag);\nextern void _gdPutColors (gdImagePtr im, gdIOCtx * out);\n\n/* */\n/* Read the extra info in the gd2 header. */\n/* */\nstatic int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tif (overflow2(*ncx, *ncy)) {\n\t\t\tGD2_DBG(printf (\"Illegal chunk counts: %d * %d\\n\", *ncx, *ncy));\n\t\t\tgoto fail1;\n\t\t}\n\t\tnc = (*ncx) * (*ncy);\n\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0 || cidx[i].size == INT_MAX)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n\nstatic gdImagePtr\n_gd2CreateFromFile (gdIOCtxPtr in, int *sx, int *sy,\n                    int *cs, int *vers, int *fmt,\n                    int *ncx, int *ncy, t_chunk_info ** cidx)\n{\n\tgdImagePtr im;\n\n\tif (_gd2GetHeader (in, sx, sy, cs, vers, fmt, ncx, ncy, cidx) != 1) {\n\t\tGD2_DBG (printf (\"Bad GD2 header\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (gd2_truecolor (*fmt)) {\n\t\tim = gdImageCreateTrueColor (*sx, *sy);\n\t} else {\n\t\tim = gdImageCreate (*sx, *sy);\n\t}\n\tif (im == NULL) {\n\t\tGD2_DBG (printf (\"Could not create gdImage\\n\"));\n\t\tgoto fail2;\n\t};\n\n\tif (!_gdGetColors (in, im, (*vers) == 2)) {\n\t\tGD2_DBG (printf (\"Could not read color palette\\n\"));\n\t\tgoto fail3;\n\t}\n\tGD2_DBG (printf (\"Image palette completed: %d colours\\n\", im->colorsTotal));\n\n\treturn im;\n\nfail3:\n\tgdImageDestroy (im);\nfail2:\n\tgdFree(*cidx);\nfail1:\n\treturn 0;\n\n}\n\nstatic int\n_gd2ReadChunk (int offset, char *compBuf, int compSize, char *chunkBuf,\n               uLongf * chunkLen, gdIOCtx * in)\n{\n\tint zerr;\n\n\tif (gdTell (in) != offset) {\n\t\tGD2_DBG (printf (\"Positioning in file to %d\\n\", offset));\n\t\tgdSeek (in, offset);\n\t} else {\n\t\tGD2_DBG (printf (\"Already Positioned in file to %d\\n\", offset));\n\t};\n\n\t/* Read and uncompress an entire chunk. */\n\tGD2_DBG (printf (\"Reading file\\n\"));\n\tif (gdGetBuf (compBuf, compSize, in) != compSize) {\n\t\treturn FALSE;\n\t};\n\tGD2_DBG (printf\n\t         (\"Got %d bytes. Uncompressing into buffer of %d bytes\\n\", compSize,\n\t          *chunkLen));\n\tzerr =\n\t    uncompress ((unsigned char *) chunkBuf, chunkLen,\n\t                (unsigned char *) compBuf, compSize);\n\tif (zerr != Z_OK) {\n\t\tGD2_DBG (printf (\"Error %d from uncompress\\n\", zerr));\n\t\treturn FALSE;\n\t};\n\tGD2_DBG (printf (\"Got chunk\\n\"));\n\treturn TRUE;\n}\n\n\n/*\n  Function: gdImageCreateFromGd2\n\n    <gdImageCreateFromGd2> is called to load images from gd2 format\n    files. Invoke <gdImageCreateFromGd2> with an already opened\n    pointer to a file containing the desired image in the gd2 file\n    format, which is specific to gd2 and intended for fast loading of\n    parts of large images. (It is a compressed format, but generally\n    not as good as maximum compression of the entire image would be.)\n\n    <gdImageCreateFromGd2> returns a <gdImagePtr> to the new image, or\n    NULL if unable to load the image (most often because the file is\n    corrupt or does not contain a gd format\n    image). <gdImageCreateFromGd2> does not close the file. You can\n    inspect the sx and sy members of the image to determine its\n    size. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n\n  Variants:\n\n    <gdImageCreateFromGd2Ptr> creates an image from GD data (i.e. the\n    contents of a GD2 file) already in memory.\n\n    <gdImageCreateFromGd2Ctx> reads in an image using the functions in\n    a <gdIOCtx> struct.\n\n  Parameters:\n\n    infile - The input FILE pointer\n\n  Returns:\n\n    A pointer to the new image or NULL if an error occurred.\n\n  Example:\n\n    > gdImagePtr im;\n    > FILE *in;\n    > in = fopen(\"mygd.gd2\", \"rb\");\n    > im = gdImageCreateFromGd2(in);\n    > fclose(in);\n    > // ... Use the image ...\n    > gdImageDestroy(im);\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2 (FILE * inFile)\n{\n\tgdIOCtx *in = gdNewFileCtx (inFile);\n\tgdImagePtr im;\n\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromGd2Ctx (in);\n\n\tin->gd_free (in);\n\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromGd2Ptr\n\n  Parameters:\n\n    size - size of GD2 data in bytes.\n    data - GD2 data (i.e. contents of a GIF file).\n\n  See <gdImageCreateFromGd2>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ptr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif(!in)\n\t\treturn 0;\n\tim = gdImageCreateFromGd2Ctx (in);\n\tin->gd_free (in);\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromGd2Ctx\n\n  Reads in a GD2 image via a <gdIOCtx> struct.  See\n  <gdImageCreateFromGd2>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tif (overflow2(ncx, ncy))\n\t\tgoto fail;\n\tnc = ncx * ncy;\n\n\tif (overflow2(ncy, cs) || overflow2(ncx, cs) || overflow2(bytesPerPixel, cs))\n\t\tgoto fail;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ch;\n\t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tim->pixels[y][x] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}\n\n\n/*\n  Function: gdImageCreateFromGd2Part\n\n    <gdImageCreateFromGd2Part> is called to load parts of images from\n    gd2 format files. Invoked in the same way as <gdImageCreateFromGd2>,\n    but with extra parameters indicating the source (x, y) and\n    width/height of the desired image. <gdImageCreateFromGd2Part>\n    returns a <gdImagePtr> to the new image, or NULL if unable to load\n    the image. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n  Variants:\n\n    <gdImageCreateFromGd2PartPtr> creates an image from GD2 data\n    (i.e. the contents of a GD2 file) already in memory.\n\n    <gdImageCreateFromGd2Ctx> reads in an image using the functions in\n    a <gdIOCtx> struct.\n\n  Parameters:\n\n    infile      - The input FILE pointer\n    srcx, srcy  - The source X and Y coordinates\n    w, h        - The resulting image's width and height\n\n  Returns:\n\n    A pointer to the new image or NULL if an error occurred.\n\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Part (FILE * inFile, int srcx, int srcy, int w, int h)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewFileCtx (inFile);\n\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromGd2PartCtx (in, srcx, srcy, w, h);\n\n\tin->gd_free (in);\n\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromGd2PartPtr\n\n  Parameters:\n\n    size        - size of GD data in bytes.\n    data        - GD data (i.e. contents of a GIF file).\n    srcx, srcy  - The source X and Y coordinates\n    w, h        - The resulting image's width and height\n\n  Reads in part of a GD2 image file stored from memory. See\n  <gdImageCreateFromGd2Part>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartPtr (int size, void *data, int srcx, int srcy, int w,\n        int h)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif(!in)\n\t\treturn 0;\n\tim = gdImageCreateFromGd2PartCtx (in, srcx, srcy, w, h);\n\tin->gd_free (in);\n\treturn im;\n}\n\n\n/*\n  Function: gdImageCreateFromGd2PartCtx\n\n  Parameters:\n\n    in          - The data source.\n    srcx, srcy  - The source X and Y coordinates\n    w, h        - The resulting image's width and height\n\n  Reads in part of a GD2 data image file via a <gdIOCtx> struct.  See\n  <gdImageCreateFromGd2Part>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartCtx (gdIOCtx * in, int srcx, int srcy, int w, int h)\n{\n\tint scx, scy, ecx, ecy, fsx, fsy;\n\tint nc, ncx, ncy, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint dstart, dpos;\n\tint i;\n\t/* 2.0.12: unsigned is correct; fixes problems with color munging.\n\t   Thanks to Steven Brown. */\n\tunsigned int ch;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\n\tunsigned char *chunkBuf = NULL;\n\tint chunkNum;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax;\n\tchar *compBuf = NULL;\n\n\tgdImagePtr im;\n\n\t/* */\n\t/* The next few lines are basically copied from gd2CreateFromFile */\n\t/* - we change the file size, so don't want to use the code directly. */\n\t/*   but we do need to know the file size. */\n\t/* */\n\tif (_gd2GetHeader (in, &fsx, &fsy, &cs, &vers, &fmt, &ncx, &ncy, &chunkIdx)\n\t        != 1) {\n\t\tgoto fail1;\n\t}\n\n\tGD2_DBG (printf (\"File size is %dx%d\\n\", fsx, fsy));\n\n\t/* This is the difference - make a file based on size of chunks. */\n\tif (gd2_truecolor (fmt)) {\n\t\tim = gdImageCreateTrueColor (w, h);\n\t} else {\n\t\tim = gdImageCreate (w, h);\n\t}\n\tif (im == NULL) {\n\t\tgoto fail1;\n\t};\n\n\tif (!_gdGetColors (in, im, vers == 2)) {\n\t\tgoto fail2;\n\t}\n\tGD2_DBG (printf (\"Image palette completed: %d colours\\n\", im->colorsTotal));\n\n\t/* Process the header info */\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\tif (im->trueColor) {\n\t\t\tchunkMax = cs * cs * 4;\n\t\t} else {\n\t\t\tchunkMax = cs * cs;\n\t\t}\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail2;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail2;\n\t\t}\n\n\t};\n\n\t/*      Don't bother with this... */\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\n\t/* Work out start/end chunks */\n\tscx = srcx / cs;\n\tscy = srcy / cs;\n\tif (scx < 0) {\n\t\tscx = 0;\n\t};\n\tif (scy < 0) {\n\t\tscy = 0;\n\t};\n\n\tecx = (srcx + w) / cs;\n\tecy = (srcy + h) / cs;\n\tif (ecx >= ncx) {\n\t\tecx = ncx - 1;\n\t};\n\tif (ecy >= ncy) {\n\t\tecy = ncy - 1;\n\t};\n\n\t/* Remember file position of image data. */\n\tdstart = gdTell (in);\n\tGD2_DBG (printf (\"Data starts at %d\\n\", dstart));\n\n\t/* Loop through the chunks. */\n\tfor (cy = scy; (cy <= ecy); cy++) {\n\n\t\tylo = cy * cs;\n\t\tyhi = ylo + cs;\n\t\tif (yhi > fsy) {\n\t\t\tyhi = fsy;\n\t\t};\n\n\t\tfor (cx = scx; (cx <= ecx); cx++) {\n\n\t\t\txlo = cx * cs;\n\t\t\txhi = xlo + cs;\n\t\t\tif (xhi > fsx) {\n\t\t\t\txhi = fsx;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk (%d, %d), from %d to %d\\n\", cx, cy, ylo,\n\t\t\t          yhi));\n\n\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\tGD2_DBG (printf (\"Using raw format data\\n\"));\n\t\t\t\tif (im->trueColor) {\n\t\t\t\t\tdpos =\n\t\t\t\t\t    (cy * (cs * fsx) * 4 + cx * cs * (yhi - ylo) * 4) +\n\t\t\t\t\t    dstart;\n\t\t\t\t} else {\n\t\t\t\t\tdpos = cy * (cs * fsx) + cx * cs * (yhi - ylo) + dstart;\n\t\t\t\t}\n\t\t\t\t/* gd 2.0.11: gdSeek returns TRUE on success, not 0.\n\t\t\t\t   Longstanding bug. 01/16/03 */\n\t\t\t\tif (!gdSeek (in, dpos)) {\n\t\t\t\t\tgd_error(\"Seek error\\n\");\n\t\t\t\t\tgoto fail2;\n\t\t\t\t};\n\t\t\t\tGD2_DBG (printf\n\t\t\t\t         (\"Reading (%d, %d) from position %d\\n\", cx, cy,\n\t\t\t\t          dpos - dstart));\n\t\t\t} else {\n\t\t\t\tchunkNum = cx + cy * ncx;\n\n\t\t\t\tchunkLen = chunkMax;\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tprintf (\"Error reading comproessed chunk\\n\");\n\t\t\t\t\tgoto fail2;\n\t\t\t\t};\n\t\t\t\tchunkPos = 0;\n\t\t\t\tGD2_DBG (printf\n\t\t\t\t         (\"Reading (%d, %d) from chunk %d\\n\", cx, cy,\n\t\t\t\t          chunkNum));\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"   into (%d, %d) - (%d, %d)\\n\", xlo, ylo, xhi, yhi));\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt ((int *) &ch, in)) {\n\t\t\t\t\t\t\t\tch = 0;\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading file\\n\"); */\n\t\t\t\t\t\t\t\t/*goto fail2; */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tch = gdGetC (in);\n\t\t\t\t\t\t\tif ((int) ch == EOF) {\n\t\t\t\t\t\t\t\tch = 0;\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading file\\n\"); */\n\t\t\t\t\t\t\t\t/*goto fail2; */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tch = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\tch = (ch << 8) + chunkBuf[chunkPos++];\n\t\t\t\t\t\t\tch = (ch << 8) + chunkBuf[chunkPos++];\n\t\t\t\t\t\t\tch = (ch << 8) + chunkBuf[chunkPos++];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tch = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/* Only use a point that is in the image. */\n\t\t\t\t\tif ((x >= srcx) && (x < (srcx + w)) && (x < fsx) && (x >= 0)\n\t\t\t\t\t        && (y >= srcy) && (y < (srcy + h)) && (y < fsy)\n\t\t\t\t\t        && (y >= 0)) {\n\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tim->tpixels[y - srcy][x - srcx] = ch;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y - srcy][x - srcx] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\treturn im;\n\nfail2:\n\tgdImageDestroy (im);\nfail1:\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n\n}\n\nstatic void\n_gd2PutHeader (gdImagePtr im, gdIOCtx * out, int cs, int fmt, int cx, int cy)\n{\n\tint i;\n\n\t/* Send the gd2 id, to verify file format. */\n\tfor (i = 0; i < 4; i++) {\n\t\tgdPutC ((unsigned char) (GD2_ID[i]), out);\n\t};\n\n\t/* */\n\t/* We put the version info first, so future versions can easily change header info. */\n\t/* */\n\tgdPutWord (GD2_VERS, out);\n\tgdPutWord (im->sx, out);\n\tgdPutWord (im->sy, out);\n\tgdPutWord (cs, out);\n\tgdPutWord (fmt, out);\n\tgdPutWord (cx, out);\n\tgdPutWord (cy, out);\n\n}\n\nstatic void\n_gdImageGd2 (gdImagePtr im, gdIOCtx * out, int cs, int fmt)\n{\n\tint ncx, ncy, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint chunkLen;\n\tint chunkNum = 0;\n\tchar *chunkData = NULL;\t/* So we can gdFree it with impunity. */\n\tchar *compData = NULL;\t/* So we can gdFree it with impunity. */\n\tuLongf compLen;\n\tint idxPos = 0;\n\tint idxSize;\n\tt_chunk_info *chunkIdx = NULL;\n\tint posSave;\n\tint bytesPerPixel = im->trueColor ? 4 : 1;\n\tint compMax = 0;\n\n\t/*printf(\"Trying to write GD2 file\\n\"); */\n\n\t/* */\n\t/* Force fmt to a valid value since we don't return anything. */\n\t/* */\n\tif ((fmt != GD2_FMT_RAW) && (fmt != GD2_FMT_COMPRESSED)) {\n\t\tfmt = GD2_FMT_COMPRESSED;\n\t};\n\tif (im->trueColor) {\n\t\tfmt += 2;\n\t}\n\t/* */\n\t/* Make sure chunk size is valid. These are arbitrary values; 64 because it seems */\n\t/* a little silly to expect performance improvements on a 64x64 bit scale, and  */\n\t/* 4096 because we buffer one chunk, and a 16MB buffer seems a little large - it may be */\n\t/* OK for one user, but for another to read it, they require the buffer. */\n\t/* */\n\tif (cs == 0) {\n\t\tcs = GD2_CHUNKSIZE;\n\t} else if (cs < GD2_CHUNKSIZE_MIN) {\n\t\tcs = GD2_CHUNKSIZE_MIN;\n\t} else if (cs > GD2_CHUNKSIZE_MAX) {\n\t\tcs = GD2_CHUNKSIZE_MAX;\n\t};\n\n\t/* Work out number of chunks. */\n\tncx = (im->sx + cs - 1) / cs;\n\tncy = (im->sy + cs - 1) / cs;\n\n\t/* Write the standard header. */\n\t_gd2PutHeader (im, out, cs, fmt, ncx, ncy);\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* */\n\t\t/* Work out size of buffer for compressed data, If CHUNKSIZE is large, */\n\t\t/* then these will be large! */\n\t\t/* */\n\t\t/* The zlib notes say output buffer size should be (input size) * 1.01 * 12 */\n\t\t/* - we'll use 1.02 to be paranoid. */\n\t\t/* */\n\t\tcompMax = cs * bytesPerPixel * cs * 1.02 + 12;\n\n\t\t/* */\n\t\t/* Allocate the buffers.  */\n\t\t/* */\n\t\tchunkData = gdCalloc (cs * bytesPerPixel * cs, 1);\n\t\tif (!chunkData) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompData = gdCalloc (compMax, 1);\n\t\tif (!compData) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* */\n\t\t/* Save the file position of chunk index, and allocate enough space for */\n\t\t/* each chunk_info block . */\n\t\t/* */\n\t\tidxPos = gdTell (out);\n\t\tidxSize = ncx * ncy * sizeof (t_chunk_info);\n\t\tGD2_DBG (printf (\"Index size is %d\\n\", idxSize));\n\t\tgdSeek (out, idxPos + idxSize);\n\n\t\tchunkIdx = gdCalloc (idxSize * sizeof (t_chunk_info), 1);\n\t\tif (!chunkIdx) {\n\t\t\tgoto fail;\n\t\t}\n\t};\n\n\t_gdPutColors (im, out);\n\n\tGD2_DBG (printf (\"Size: %dx%d\\n\", im->sx, im->sy));\n\tGD2_DBG (printf (\"Chunks: %dx%d\\n\", ncx, ncy));\n\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk (%dx%d), y from %d to %d\\n\", cx, cy,\n\t\t\t          ylo, yhi));\n\t\t\tchunkLen = 0;\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\n\t\t\t\tif (gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\t/* 2.0.11: use truecolor pixel array. TBB */\n\t\t\t\t\t\t/*GD2_DBG(printf(\"%d...\",x)); */\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tint p = im->tpixels[y][x];\n\t\t\t\t\t\t\tchunkData[chunkLen++] = gdTrueColorGetAlpha (p);\n\t\t\t\t\t\t\tchunkData[chunkLen++] = gdTrueColorGetRed (p);\n\t\t\t\t\t\t\tchunkData[chunkLen++] = gdTrueColorGetGreen (p);\n\t\t\t\t\t\t\tchunkData[chunkLen++] = gdTrueColorGetBlue (p);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint p = im->pixels[y][x];\n\t\t\t\t\t\t\tchunkData[chunkLen++] = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\t/*GD2_DBG(printf(\"%d, \",x)); */\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tgdPutInt (im->tpixels[y][x], out);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgdPutC ((unsigned char) im->pixels[y][x], out);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d done.\\n\",y)); */\n\t\t\t};\n\t\t\tif (gd2_compressed (fmt)) {\n\t\t\t\tcompLen = compMax;\n\t\t\t\tif (compress ((unsigned char *)\n\t\t\t\t              &compData[0], &compLen,\n\t\t\t\t              (unsigned char *) &chunkData[0],\n\t\t\t\t              chunkLen) != Z_OK) {\n\t\t\t\t\tprintf (\"Error from compressing\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tchunkIdx[chunkNum].offset = gdTell (out);\n\t\t\t\t\tchunkIdx[chunkNum++].size = compLen;\n\t\t\t\t\tGD2_DBG (printf\n\t\t\t\t\t         (\"Chunk %d size %d offset %d\\n\", chunkNum,\n\t\t\t\t\t          chunkIdx[chunkNum - 1].size,\n\t\t\t\t\t          chunkIdx[chunkNum - 1].offset));\n\n\t\t\t\t\tif (gdPutBuf (compData, compLen, out) <= 0) {\n\t\t\t\t\t\tgd_error(\"gd write error\\n\");\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\tif (gd2_compressed (fmt)) {\n\t\t/* Save the position, write the index, restore position (paranoia). */\n\t\tGD2_DBG (printf (\"Seeking %d to write index\\n\", idxPos));\n\t\tposSave = gdTell (out);\n\t\tgdSeek (out, idxPos);\n\t\tGD2_DBG (printf (\"Writing index\\n\"));\n\t\tfor (x = 0; x < chunkNum; x++) {\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Chunk %d size %d offset %d\\n\", x, chunkIdx[x].size,\n\t\t\t          chunkIdx[x].offset));\n\t\t\tgdPutInt (chunkIdx[x].offset, out);\n\t\t\tgdPutInt (chunkIdx[x].size, out);\n\t\t};\n\t\t/* We don't use fwrite for *endian reasons. */\n\t\t/*fwrite(chunkIdx, sizeof(int)*2, chunkNum, out); */\n\t\tgdSeek (out, posSave);\n\t};\n\n\t/*printf(\"Memory block size is %d\\n\",gdTell(out)); */\nfail:\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tif (chunkData) {\n\t\tgdFree (chunkData);\n\t}\n\tif (compData) {\n\t\tgdFree (compData);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\tGD2_DBG (printf (\"Done\\n\"));\n\n}\n\n/*\n\tFunction: gdImageGd2\n*/\nBGD_DECLARE(void) gdImageGd2 (gdImagePtr im, FILE * outFile, int cs, int fmt)\n{\n\tgdIOCtx *out = gdNewFileCtx (outFile);\n\tif (out == NULL) return;\n\t_gdImageGd2 (im, out, cs, fmt);\n\tout->gd_free (out);\n}\n\n/*\n\tFunction: gdImageGd2Ptr\n*/\nBGD_DECLARE(void *) gdImageGd2Ptr (gdImagePtr im, int cs, int fmt, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (out == NULL) return NULL;\n\t_gdImageGd2 (im, out, cs, fmt);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\treturn rv;\n}\n\n#else /* no HAVE_LIBZ or !ENABLE_GD_FORMATS */\nstatic void _noGd2Error (void)\n{\n#if !ENABLE_GD_FORMATS\n\tgd_error(\"GD2 image support has been disabled\\n\");\n#else\n\tgd_error(\"GD2 support is not available - no libz\\n\");\n#endif\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2 (FILE * inFile)\n{\n\tARG_NOT_USED(inFile);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tARG_NOT_USED(in);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Part (FILE * inFile, int srcx, int srcy, int w, int h)\n{\n\tARG_NOT_USED(inFile);\n\tARG_NOT_USED(srcx);\n\tARG_NOT_USED(srcy);\n\tARG_NOT_USED(w);\n\tARG_NOT_USED(h);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ptr (int size, void *data)\n{\n\tARG_NOT_USED(size);\n\tARG_NOT_USED(data);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartCtx (gdIOCtx * in, int srcx, int srcy, int w, int h)\n{\n\tARG_NOT_USED(in);\n\tARG_NOT_USED(srcx);\n\tARG_NOT_USED(srcy);\n\tARG_NOT_USED(w);\n\tARG_NOT_USED(h);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartPtr (int size, void *data, int srcx, int srcy, int w, int h)\n{\n\tARG_NOT_USED(size);\n\tARG_NOT_USED(data);\n\tARG_NOT_USED(srcx);\n\tARG_NOT_USED(srcy);\n\tARG_NOT_USED(w);\n\tARG_NOT_USED(h);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(void) gdImageGd2 (gdImagePtr im, FILE * outFile, int cs, int fmt)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(outFile);\n\tARG_NOT_USED(cs);\n\tARG_NOT_USED(fmt);\n\t_noGd2Error();\n}\n\nBGD_DECLARE(void *) gdImageGd2Ptr (gdImagePtr im, int cs, int fmt, int *size)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(cs);\n\tARG_NOT_USED(fmt);\n\tARG_NOT_USED(size);\n\t_noGd2Error();\n\treturn NULL;\n}\n#endif /* HAVE_LIBZ */\n"], "fixing_code": ["/*\n   * gd_gd2.c\n   *\n   * Implements the I/O and support for the GD2 format.\n   *\n   * Changing the definition of GD2_DBG (below) will cause copious messages\n   * to be displayed while it processes requests.\n   *\n   * Designed, Written & Copyright 1999, Philip Warner.\n   *\n */\n\n/**\n * File: GD2 IO\n *\n * Read and write GD2 images.\n *\n * The GD2 image format is a proprietary image format of libgd. *It has to be*\n * *regarded as being obsolete, and should only be used for development and*\n * *testing purposes.*\n *\n * Structure of a GD2 image file:\n *  - file header\n *  - chunk headers (only for compressed data)\n *  - color header (either truecolor or palette)\n *  - chunks of image data (chunk-row-major, top to bottom, left to right)\n *\n * All numbers are stored in big-endian format.\n *\n * File header structure:\n *  signature     - 4 bytes (always \"gd2\\0\")\n *  version       - 1 word (e.g. \"\\0\\002\")\n *  width         - 1 word\n *  height        - 1 word\n *  chunk_size    - 1 word\n *  format        - 1 word\n *  x_chunk_count - 1 word\n *  y_chunk_count - 1 word\n *\n * Recognized formats:\n *  1 - raw palette image data\n *  2 - compressed palette image data\n *  3 - raw truecolor image data\n *  4 - compressed truecolor image data\n *\n * Chunk header:\n *  offset - 1 dword\n *  size   - 1 dword\n *\n * There are x_chunk_count * y_chunk_count chunk headers.\n *\n * Truecolor image color header:\n *  truecolor   - 1 byte (always \"\\001\")\n *  transparent - 1 dword (ARGB color); \"\\377\\377\\377\\377\" means that no\n *\t\t\t\t  transparent color is set\n *\n * Palette image color header:\n *  truecolor   - 1 byte (always \"\\0\")\n *  count       - 1 word (the number of used palette colors)\n *  transparent - 1 dword (palette index); \"\\377\\377\\377\\377\" means that no\n *\t\t\t\t  transparent color is set\n *  palette     - 256 dwords (RGBA colors)\n *\n * Chunk structure:\n *  Sequential pixel data of a rectangular area (chunk_size x chunk_size),\n *  row-major from top to bottom, left to right:\n *  - 1 byte per pixel for palette images\n *  - 1 dword (ARGB) per pixel for truecolor images\n *\n *  Depending on format, the chunk may be ZLIB compressed.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n/* 2.0.29: no more errno.h, makes windows happy */\n#include <math.h>\n#include <limits.h>\n#include <string.h>\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n/* 2.03: gd2 is no longer mandatory */\n/* JCE - test after including gd.h so that HAVE_LIBZ can be set in\n * a config.h file included by gd.h */\n#if defined(HAVE_LIBZ) && ENABLE_GD_FORMATS\n#include <zlib.h>\n\n#define TRUE 1\n#define FALSE 0\n\n/* 2.11: not part of the API, as the save routine can figure it out\n\tfrom im->trueColor, and the load routine doesn't need to tell\n\tthe end user the saved format. NOTE: adding 2 is assumed\n\tto result in the correct format value for truecolor! */\n#define GD2_FMT_TRUECOLOR_RAW 3\n#define GD2_FMT_TRUECOLOR_COMPRESSED 4\n\n#define gd2_compressed(fmt) (((fmt) == GD2_FMT_COMPRESSED) || \\\n\t((fmt) == GD2_FMT_TRUECOLOR_COMPRESSED))\n\n#define gd2_truecolor(fmt) (((fmt) == GD2_FMT_TRUECOLOR_RAW) || \\\n\t((fmt) == GD2_FMT_TRUECOLOR_COMPRESSED))\n\n/* Use this for commenting out debug-print statements. */\n/* Just use the first '#define' to allow all the prints... */\n/*#define GD2_DBG(s) (s) */\n#define GD2_DBG(s)\n\ntypedef struct {\n\tint offset;\n\tint size;\n}\nt_chunk_info;\n\nextern int _gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag);\nextern void _gdPutColors (gdImagePtr im, gdIOCtx * out);\n\n/* */\n/* Read the extra info in the gd2 header. */\n/* */\nstatic int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tif (overflow2(*ncx, *ncy)) {\n\t\t\tGD2_DBG(printf (\"Illegal chunk counts: %d * %d\\n\", *ncx, *ncy));\n\t\t\tgoto fail1;\n\t\t}\n\t\tnc = (*ncx) * (*ncy);\n\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0 || cidx[i].size == INT_MAX)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n\nstatic gdImagePtr\n_gd2CreateFromFile (gdIOCtxPtr in, int *sx, int *sy,\n                    int *cs, int *vers, int *fmt,\n                    int *ncx, int *ncy, t_chunk_info ** cidx)\n{\n\tgdImagePtr im;\n\n\tif (_gd2GetHeader (in, sx, sy, cs, vers, fmt, ncx, ncy, cidx) != 1) {\n\t\tGD2_DBG (printf (\"Bad GD2 header\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (gd2_truecolor (*fmt)) {\n\t\tim = gdImageCreateTrueColor (*sx, *sy);\n\t} else {\n\t\tim = gdImageCreate (*sx, *sy);\n\t}\n\tif (im == NULL) {\n\t\tGD2_DBG (printf (\"Could not create gdImage\\n\"));\n\t\tgoto fail2;\n\t};\n\n\tif (!_gdGetColors (in, im, (*vers) == 2)) {\n\t\tGD2_DBG (printf (\"Could not read color palette\\n\"));\n\t\tgoto fail3;\n\t}\n\tGD2_DBG (printf (\"Image palette completed: %d colours\\n\", im->colorsTotal));\n\n\treturn im;\n\nfail3:\n\tgdImageDestroy (im);\nfail2:\n\tgdFree(*cidx);\nfail1:\n\treturn 0;\n\n}\n\nstatic int\n_gd2ReadChunk (int offset, char *compBuf, int compSize, char *chunkBuf,\n               uLongf * chunkLen, gdIOCtx * in)\n{\n\tint zerr;\n\n\tif (gdTell (in) != offset) {\n\t\tGD2_DBG (printf (\"Positioning in file to %d\\n\", offset));\n\t\tgdSeek (in, offset);\n\t} else {\n\t\tGD2_DBG (printf (\"Already Positioned in file to %d\\n\", offset));\n\t};\n\n\t/* Read and uncompress an entire chunk. */\n\tGD2_DBG (printf (\"Reading file\\n\"));\n\tif (gdGetBuf (compBuf, compSize, in) != compSize) {\n\t\treturn FALSE;\n\t};\n\tGD2_DBG (printf\n\t         (\"Got %d bytes. Uncompressing into buffer of %d bytes\\n\", compSize,\n\t          *chunkLen));\n\tzerr =\n\t    uncompress ((unsigned char *) chunkBuf, chunkLen,\n\t                (unsigned char *) compBuf, compSize);\n\tif (zerr != Z_OK) {\n\t\tGD2_DBG (printf (\"Error %d from uncompress\\n\", zerr));\n\t\treturn FALSE;\n\t};\n\tGD2_DBG (printf (\"Got chunk\\n\"));\n\treturn TRUE;\n}\n\n\n/*\n  Function: gdImageCreateFromGd2\n\n    <gdImageCreateFromGd2> is called to load images from gd2 format\n    files. Invoke <gdImageCreateFromGd2> with an already opened\n    pointer to a file containing the desired image in the gd2 file\n    format, which is specific to gd2 and intended for fast loading of\n    parts of large images. (It is a compressed format, but generally\n    not as good as maximum compression of the entire image would be.)\n\n    <gdImageCreateFromGd2> returns a <gdImagePtr> to the new image, or\n    NULL if unable to load the image (most often because the file is\n    corrupt or does not contain a gd format\n    image). <gdImageCreateFromGd2> does not close the file. You can\n    inspect the sx and sy members of the image to determine its\n    size. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n\n  Variants:\n\n    <gdImageCreateFromGd2Ptr> creates an image from GD data (i.e. the\n    contents of a GD2 file) already in memory.\n\n    <gdImageCreateFromGd2Ctx> reads in an image using the functions in\n    a <gdIOCtx> struct.\n\n  Parameters:\n\n    infile - The input FILE pointer\n\n  Returns:\n\n    A pointer to the new image or NULL if an error occurred.\n\n  Example:\n\n    > gdImagePtr im;\n    > FILE *in;\n    > in = fopen(\"mygd.gd2\", \"rb\");\n    > im = gdImageCreateFromGd2(in);\n    > fclose(in);\n    > // ... Use the image ...\n    > gdImageDestroy(im);\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2 (FILE * inFile)\n{\n\tgdIOCtx *in = gdNewFileCtx (inFile);\n\tgdImagePtr im;\n\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromGd2Ctx (in);\n\n\tin->gd_free (in);\n\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromGd2Ptr\n\n  Parameters:\n\n    size - size of GD2 data in bytes.\n    data - GD2 data (i.e. contents of a GIF file).\n\n  See <gdImageCreateFromGd2>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ptr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif(!in)\n\t\treturn 0;\n\tim = gdImageCreateFromGd2Ctx (in);\n\tin->gd_free (in);\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromGd2Ctx\n\n  Reads in a GD2 image via a <gdIOCtx> struct.  See\n  <gdImageCreateFromGd2>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tif (overflow2(ncx, ncy))\n\t\tgoto fail;\n\tnc = ncx * ncy;\n\n\tif (overflow2(ncy, cs) || overflow2(ncx, cs) || overflow2(bytesPerPixel, cs))\n\t\tgoto fail;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ch;\n\t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tim->pixels[y][x] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}\n\n\n/*\n  Function: gdImageCreateFromGd2Part\n\n    <gdImageCreateFromGd2Part> is called to load parts of images from\n    gd2 format files. Invoked in the same way as <gdImageCreateFromGd2>,\n    but with extra parameters indicating the source (x, y) and\n    width/height of the desired image. <gdImageCreateFromGd2Part>\n    returns a <gdImagePtr> to the new image, or NULL if unable to load\n    the image. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n  Variants:\n\n    <gdImageCreateFromGd2PartPtr> creates an image from GD2 data\n    (i.e. the contents of a GD2 file) already in memory.\n\n    <gdImageCreateFromGd2Ctx> reads in an image using the functions in\n    a <gdIOCtx> struct.\n\n  Parameters:\n\n    infile      - The input FILE pointer\n    srcx, srcy  - The source X and Y coordinates\n    w, h        - The resulting image's width and height\n\n  Returns:\n\n    A pointer to the new image or NULL if an error occurred.\n\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Part (FILE * inFile, int srcx, int srcy, int w, int h)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewFileCtx (inFile);\n\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromGd2PartCtx (in, srcx, srcy, w, h);\n\n\tin->gd_free (in);\n\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromGd2PartPtr\n\n  Parameters:\n\n    size        - size of GD data in bytes.\n    data        - GD data (i.e. contents of a GIF file).\n    srcx, srcy  - The source X and Y coordinates\n    w, h        - The resulting image's width and height\n\n  Reads in part of a GD2 image file stored from memory. See\n  <gdImageCreateFromGd2Part>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartPtr (int size, void *data, int srcx, int srcy, int w,\n        int h)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif(!in)\n\t\treturn 0;\n\tim = gdImageCreateFromGd2PartCtx (in, srcx, srcy, w, h);\n\tin->gd_free (in);\n\treturn im;\n}\n\n\n/*\n  Function: gdImageCreateFromGd2PartCtx\n\n  Parameters:\n\n    in          - The data source.\n    srcx, srcy  - The source X and Y coordinates\n    w, h        - The resulting image's width and height\n\n  Reads in part of a GD2 data image file via a <gdIOCtx> struct.  See\n  <gdImageCreateFromGd2Part>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartCtx (gdIOCtx * in, int srcx, int srcy, int w, int h)\n{\n\tint scx, scy, ecx, ecy, fsx, fsy;\n\tint nc, ncx, ncy, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint dstart, dpos;\n\tint i;\n\t/* 2.0.12: unsigned is correct; fixes problems with color munging.\n\t   Thanks to Steven Brown. */\n\tunsigned int ch;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\n\tunsigned char *chunkBuf = NULL;\n\tint chunkNum;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax;\n\tchar *compBuf = NULL;\n\n\tgdImagePtr im;\n\n\t/* */\n\t/* The next few lines are basically copied from gd2CreateFromFile */\n\t/* - we change the file size, so don't want to use the code directly. */\n\t/*   but we do need to know the file size. */\n\t/* */\n\tif (_gd2GetHeader (in, &fsx, &fsy, &cs, &vers, &fmt, &ncx, &ncy, &chunkIdx)\n\t        != 1) {\n\t\tgoto fail1;\n\t}\n\n\tGD2_DBG (printf (\"File size is %dx%d\\n\", fsx, fsy));\n\n\t/* This is the difference - make a file based on size of chunks. */\n\tif (gd2_truecolor (fmt)) {\n\t\tim = gdImageCreateTrueColor (w, h);\n\t} else {\n\t\tim = gdImageCreate (w, h);\n\t}\n\tif (im == NULL) {\n\t\tgoto fail1;\n\t};\n\n\tif (!_gdGetColors (in, im, vers == 2)) {\n\t\tgoto fail2;\n\t}\n\tGD2_DBG (printf (\"Image palette completed: %d colours\\n\", im->colorsTotal));\n\n\t/* Process the header info */\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\tif (im->trueColor) {\n\t\t\tchunkMax = cs * cs * 4;\n\t\t} else {\n\t\t\tchunkMax = cs * cs;\n\t\t}\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail2;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail2;\n\t\t}\n\n\t};\n\n\t/*      Don't bother with this... */\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\n\t/* Work out start/end chunks */\n\tscx = srcx / cs;\n\tscy = srcy / cs;\n\tif (scx < 0) {\n\t\tscx = 0;\n\t};\n\tif (scy < 0) {\n\t\tscy = 0;\n\t};\n\n\tecx = (srcx + w) / cs;\n\tecy = (srcy + h) / cs;\n\tif (ecx >= ncx) {\n\t\tecx = ncx - 1;\n\t};\n\tif (ecy >= ncy) {\n\t\tecy = ncy - 1;\n\t};\n\n\t/* Remember file position of image data. */\n\tdstart = gdTell (in);\n\tGD2_DBG (printf (\"Data starts at %d\\n\", dstart));\n\n\t/* Loop through the chunks. */\n\tfor (cy = scy; (cy <= ecy); cy++) {\n\n\t\tylo = cy * cs;\n\t\tyhi = ylo + cs;\n\t\tif (yhi > fsy) {\n\t\t\tyhi = fsy;\n\t\t};\n\n\t\tfor (cx = scx; (cx <= ecx); cx++) {\n\n\t\t\txlo = cx * cs;\n\t\t\txhi = xlo + cs;\n\t\t\tif (xhi > fsx) {\n\t\t\t\txhi = fsx;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk (%d, %d), from %d to %d\\n\", cx, cy, ylo,\n\t\t\t          yhi));\n\n\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\tGD2_DBG (printf (\"Using raw format data\\n\"));\n\t\t\t\tif (im->trueColor) {\n\t\t\t\t\tdpos =\n\t\t\t\t\t    (cy * (cs * fsx) * 4 + cx * cs * (yhi - ylo) * 4) +\n\t\t\t\t\t    dstart;\n\t\t\t\t} else {\n\t\t\t\t\tdpos = cy * (cs * fsx) + cx * cs * (yhi - ylo) + dstart;\n\t\t\t\t}\n\t\t\t\t/* gd 2.0.11: gdSeek returns TRUE on success, not 0.\n\t\t\t\t   Longstanding bug. 01/16/03 */\n\t\t\t\tif (!gdSeek (in, dpos)) {\n\t\t\t\t\tgd_error(\"Seek error\\n\");\n\t\t\t\t\tgoto fail2;\n\t\t\t\t};\n\t\t\t\tGD2_DBG (printf\n\t\t\t\t         (\"Reading (%d, %d) from position %d\\n\", cx, cy,\n\t\t\t\t          dpos - dstart));\n\t\t\t} else {\n\t\t\t\tchunkNum = cx + cy * ncx;\n\n\t\t\t\tchunkLen = chunkMax;\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tprintf (\"Error reading comproessed chunk\\n\");\n\t\t\t\t\tgoto fail2;\n\t\t\t\t};\n\t\t\t\tchunkPos = 0;\n\t\t\t\tGD2_DBG (printf\n\t\t\t\t         (\"Reading (%d, %d) from chunk %d\\n\", cx, cy,\n\t\t\t\t          chunkNum));\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"   into (%d, %d) - (%d, %d)\\n\", xlo, ylo, xhi, yhi));\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt ((int *) &ch, in)) {\n\t\t\t\t\t\t\t\tch = 0;\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading file\\n\"); */\n\t\t\t\t\t\t\t\t/*goto fail2; */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tch = gdGetC (in);\n\t\t\t\t\t\t\tif ((int) ch == EOF) {\n\t\t\t\t\t\t\t\tch = 0;\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading file\\n\"); */\n\t\t\t\t\t\t\t\t/*goto fail2; */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tch = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\tch = (ch << 8) + chunkBuf[chunkPos++];\n\t\t\t\t\t\t\tch = (ch << 8) + chunkBuf[chunkPos++];\n\t\t\t\t\t\t\tch = (ch << 8) + chunkBuf[chunkPos++];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tch = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/* Only use a point that is in the image. */\n\t\t\t\t\tif ((x >= srcx) && (x < (srcx + w)) && (x < fsx) && (x >= 0)\n\t\t\t\t\t        && (y >= srcy) && (y < (srcy + h)) && (y < fsy)\n\t\t\t\t\t        && (y >= 0)) {\n\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tim->tpixels[y - srcy][x - srcx] = ch;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y - srcy][x - srcx] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\treturn im;\n\nfail2:\n\tgdImageDestroy (im);\nfail1:\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n\n}\n\nstatic void\n_gd2PutHeader (gdImagePtr im, gdIOCtx * out, int cs, int fmt, int cx, int cy)\n{\n\tint i;\n\n\t/* Send the gd2 id, to verify file format. */\n\tfor (i = 0; i < 4; i++) {\n\t\tgdPutC ((unsigned char) (GD2_ID[i]), out);\n\t};\n\n\t/* */\n\t/* We put the version info first, so future versions can easily change header info. */\n\t/* */\n\tgdPutWord (GD2_VERS, out);\n\tgdPutWord (im->sx, out);\n\tgdPutWord (im->sy, out);\n\tgdPutWord (cs, out);\n\tgdPutWord (fmt, out);\n\tgdPutWord (cx, out);\n\tgdPutWord (cy, out);\n\n}\n\n/* returns 0 on success, 1 on failure */\nstatic int\n_gdImageGd2 (gdImagePtr im, gdIOCtx * out, int cs, int fmt)\n{\n\tint ret = 0;\n\tint ncx, ncy, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint chunkLen;\n\tint chunkNum = 0;\n\tchar *chunkData = NULL;\t/* So we can gdFree it with impunity. */\n\tchar *compData = NULL;\t/* So we can gdFree it with impunity. */\n\tuLongf compLen;\n\tint idxPos = 0;\n\tint idxSize;\n\tt_chunk_info *chunkIdx = NULL;\n\tint posSave;\n\tint bytesPerPixel = im->trueColor ? 4 : 1;\n\tint compMax = 0;\n\n\t/*printf(\"Trying to write GD2 file\\n\"); */\n\n\t/* */\n\t/* Force fmt to a valid value since we don't return anything. */\n\t/* */\n\tif ((fmt != GD2_FMT_RAW) && (fmt != GD2_FMT_COMPRESSED)) {\n\t\tfmt = GD2_FMT_COMPRESSED;\n\t};\n\tif (im->trueColor) {\n\t\tfmt += 2;\n\t}\n\t/* */\n\t/* Make sure chunk size is valid. These are arbitrary values; 64 because it seems */\n\t/* a little silly to expect performance improvements on a 64x64 bit scale, and  */\n\t/* 4096 because we buffer one chunk, and a 16MB buffer seems a little large - it may be */\n\t/* OK for one user, but for another to read it, they require the buffer. */\n\t/* */\n\tif (cs == 0) {\n\t\tcs = GD2_CHUNKSIZE;\n\t} else if (cs < GD2_CHUNKSIZE_MIN) {\n\t\tcs = GD2_CHUNKSIZE_MIN;\n\t} else if (cs > GD2_CHUNKSIZE_MAX) {\n\t\tcs = GD2_CHUNKSIZE_MAX;\n\t};\n\n\t/* Work out number of chunks. */\n\tncx = (im->sx + cs - 1) / cs;\n\tncy = (im->sy + cs - 1) / cs;\n\n\t/* Write the standard header. */\n\t_gd2PutHeader (im, out, cs, fmt, ncx, ncy);\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* */\n\t\t/* Work out size of buffer for compressed data, If CHUNKSIZE is large, */\n\t\t/* then these will be large! */\n\t\t/* */\n\t\t/* The zlib notes say output buffer size should be (input size) * 1.01 * 12 */\n\t\t/* - we'll use 1.02 to be paranoid. */\n\t\t/* */\n\t\tcompMax = cs * bytesPerPixel * cs * 1.02 + 12;\n\n\t\t/* */\n\t\t/* Allocate the buffers.  */\n\t\t/* */\n\t\tchunkData = gdCalloc (cs * bytesPerPixel * cs, 1);\n\t\tif (!chunkData) {\n\t\t\tret = 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tcompData = gdCalloc (compMax, 1);\n\t\tif (!compData) {\n\t\t\tret = 1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* */\n\t\t/* Save the file position of chunk index, and allocate enough space for */\n\t\t/* each chunk_info block . */\n\t\t/* */\n\t\tidxPos = gdTell (out);\n\t\tidxSize = ncx * ncy * sizeof (t_chunk_info);\n\t\tGD2_DBG (printf (\"Index size is %d\\n\", idxSize));\n\t\tgdSeek (out, idxPos + idxSize);\n\n\t\tchunkIdx = gdCalloc (idxSize * sizeof (t_chunk_info), 1);\n\t\tif (!chunkIdx) {\n\t\t\tret = 1;\n\t\t\tgoto fail;\n\t\t}\n\t};\n\n\t_gdPutColors (im, out);\n\n\tGD2_DBG (printf (\"Size: %dx%d\\n\", im->sx, im->sy));\n\tGD2_DBG (printf (\"Chunks: %dx%d\\n\", ncx, ncy));\n\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk (%dx%d), y from %d to %d\\n\", cx, cy,\n\t\t\t          ylo, yhi));\n\t\t\tchunkLen = 0;\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\n\t\t\t\tif (gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\t/* 2.0.11: use truecolor pixel array. TBB */\n\t\t\t\t\t\t/*GD2_DBG(printf(\"%d...\",x)); */\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tint p = im->tpixels[y][x];\n\t\t\t\t\t\t\tchunkData[chunkLen++] = gdTrueColorGetAlpha (p);\n\t\t\t\t\t\t\tchunkData[chunkLen++] = gdTrueColorGetRed (p);\n\t\t\t\t\t\t\tchunkData[chunkLen++] = gdTrueColorGetGreen (p);\n\t\t\t\t\t\t\tchunkData[chunkLen++] = gdTrueColorGetBlue (p);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint p = im->pixels[y][x];\n\t\t\t\t\t\t\tchunkData[chunkLen++] = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\t/*GD2_DBG(printf(\"%d, \",x)); */\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tgdPutInt (im->tpixels[y][x], out);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgdPutC ((unsigned char) im->pixels[y][x], out);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d done.\\n\",y)); */\n\t\t\t};\n\t\t\tif (gd2_compressed (fmt)) {\n\t\t\t\tcompLen = compMax;\n\t\t\t\tif (compress ((unsigned char *)\n\t\t\t\t              &compData[0], &compLen,\n\t\t\t\t              (unsigned char *) &chunkData[0],\n\t\t\t\t              chunkLen) != Z_OK) {\n\t\t\t\t\tprintf (\"Error from compressing\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tchunkIdx[chunkNum].offset = gdTell (out);\n\t\t\t\t\tchunkIdx[chunkNum++].size = compLen;\n\t\t\t\t\tGD2_DBG (printf\n\t\t\t\t\t         (\"Chunk %d size %d offset %d\\n\", chunkNum,\n\t\t\t\t\t          chunkIdx[chunkNum - 1].size,\n\t\t\t\t\t          chunkIdx[chunkNum - 1].offset));\n\n\t\t\t\t\tif (gdPutBuf (compData, compLen, out) <= 0) {\n\t\t\t\t\t\tgd_error(\"gd write error\\n\");\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\tif (gd2_compressed (fmt)) {\n\t\t/* Save the position, write the index, restore position (paranoia). */\n\t\tGD2_DBG (printf (\"Seeking %d to write index\\n\", idxPos));\n\t\tposSave = gdTell (out);\n\t\tgdSeek (out, idxPos);\n\t\tGD2_DBG (printf (\"Writing index\\n\"));\n\t\tfor (x = 0; x < chunkNum; x++) {\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Chunk %d size %d offset %d\\n\", x, chunkIdx[x].size,\n\t\t\t          chunkIdx[x].offset));\n\t\t\tgdPutInt (chunkIdx[x].offset, out);\n\t\t\tgdPutInt (chunkIdx[x].size, out);\n\t\t};\n\t\t/* We don't use fwrite for *endian reasons. */\n\t\t/*fwrite(chunkIdx, sizeof(int)*2, chunkNum, out); */\n\t\tgdSeek (out, posSave);\n\t};\n\n\t/*printf(\"Memory block size is %d\\n\",gdTell(out)); */\nfail:\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tif (chunkData) {\n\t\tgdFree (chunkData);\n\t}\n\tif (compData) {\n\t\tgdFree (compData);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn ret;\n\n}\n\n/*\n\tFunction: gdImageGd2\n*/\nBGD_DECLARE(void) gdImageGd2 (gdImagePtr im, FILE * outFile, int cs, int fmt)\n{\n\tgdIOCtx *out = gdNewFileCtx (outFile);\n\tif (out == NULL) return;\n\t_gdImageGd2 (im, out, cs, fmt);\n\tout->gd_free (out);\n}\n\n/*\n\tFunction: gdImageGd2Ptr\n*/\nBGD_DECLARE(void *) gdImageGd2Ptr (gdImagePtr im, int cs, int fmt, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (out == NULL) return NULL;\n\t\n\tif (_gdImageGd2(im, out, cs, fmt)) {\n\t\trv = NULL;\n\t} else {\n\t\trv = gdDPExtractData(out, size);\n\t}\n\t\n\tout->gd_free (out);\n\treturn rv;\n}\n\n#else /* no HAVE_LIBZ or !ENABLE_GD_FORMATS */\nstatic void _noGd2Error (void)\n{\n#if !ENABLE_GD_FORMATS\n\tgd_error(\"GD2 image support has been disabled\\n\");\n#else\n\tgd_error(\"GD2 support is not available - no libz\\n\");\n#endif\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2 (FILE * inFile)\n{\n\tARG_NOT_USED(inFile);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tARG_NOT_USED(in);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Part (FILE * inFile, int srcx, int srcy, int w, int h)\n{\n\tARG_NOT_USED(inFile);\n\tARG_NOT_USED(srcx);\n\tARG_NOT_USED(srcy);\n\tARG_NOT_USED(w);\n\tARG_NOT_USED(h);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ptr (int size, void *data)\n{\n\tARG_NOT_USED(size);\n\tARG_NOT_USED(data);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartCtx (gdIOCtx * in, int srcx, int srcy, int w, int h)\n{\n\tARG_NOT_USED(in);\n\tARG_NOT_USED(srcx);\n\tARG_NOT_USED(srcy);\n\tARG_NOT_USED(w);\n\tARG_NOT_USED(h);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartPtr (int size, void *data, int srcx, int srcy, int w, int h)\n{\n\tARG_NOT_USED(size);\n\tARG_NOT_USED(data);\n\tARG_NOT_USED(srcx);\n\tARG_NOT_USED(srcy);\n\tARG_NOT_USED(w);\n\tARG_NOT_USED(h);\n\t_noGd2Error();\n\treturn NULL;\n}\n\nBGD_DECLARE(void) gdImageGd2 (gdImagePtr im, FILE * outFile, int cs, int fmt)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(outFile);\n\tARG_NOT_USED(cs);\n\tARG_NOT_USED(fmt);\n\t_noGd2Error();\n}\n\nBGD_DECLARE(void *) gdImageGd2Ptr (gdImagePtr im, int cs, int fmt, int *size)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(cs);\n\tARG_NOT_USED(fmt);\n\tARG_NOT_USED(size);\n\t_noGd2Error();\n\treturn NULL;\n}\n#endif /* HAVE_LIBZ */\n"], "filenames": ["src/gd_gd2.c"], "buggy_code_start_loc": [913], "buggy_code_end_loc": [1133], "fixing_code_start_loc": [913], "fixing_code_end_loc": [1145], "type": "CWE-415", "message": "** DISPUTED ** gdImageGd2Ptr in gd_gd2.c in the GD Graphics Library (aka LibGD) through 2.3.2 has a double free. NOTE: the vendor's position is \"The GD2 image format is a proprietary image format of libgd. It has to be regarded as being obsolete, and should only be used for development and testing purposes.\"", "other": {"cve": {"id": "CVE-2021-40145", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-26T01:15:11.747", "lastModified": "2021-09-01T21:27:29.860", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** gdImageGd2Ptr in gd_gd2.c in the GD Graphics Library (aka LibGD) through 2.3.2 has a double free. NOTE: the vendor's position is \"The GD2 image format is a proprietary image format of libgd. It has to be regarded as being obsolete, and should only be used for development and testing purposes.\""}, {"lang": "es", "value": "** EN DISPUTA ** la funci\u00f3n gdImageGd2Ptr en el archivo gd_gd2.c en GD Graphics Library (tambi\u00e9n se conoce como LibGD) hasta la versi\u00f3n 2.3.2, presenta una doble liberaci\u00f3n. NOTA: la posici\u00f3n del proveedor es \"The GD2 image format is a proprietary image format of libgd. It has to be regarded as being obsolete, and should only be used for development and testing purposes.\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgd:libgd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.2", "matchCriteriaId": "BC97C2E1-5409-4013-BFB0-8BDD23AEFF0E"}]}]}], "references": [{"url": "https://github.com/libgd/libgd/commit/c5fd25ce0e48fd5618a972ca9f5e28d6d62006af", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgd/libgd/issues/700", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/libgd/libgd/pull/713", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libgd/libgd/commit/c5fd25ce0e48fd5618a972ca9f5e28d6d62006af"}}