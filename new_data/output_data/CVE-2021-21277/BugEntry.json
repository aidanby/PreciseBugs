{"buggy_code": ["### 1.1.1\n\nPrevious version was published with ES6 feature, now the published JS uses ES5 only\n\n### 1.1.0\n\n- Add support for special characters by using the following :\n\n```javascript\nfunction validChars(ch) {\n  return (\n    (ch >= \"a\" && ch <= \"z\") ||\n    (ch >= \"A\" && ch <= \"Z\") ||\n    ch === \"_\" ||\n    ch === \"$\" ||\n    \"\u00c0\u00c8\u00cc\u00d2\u00d9\u00e0\u00e8\u00ec\u00f2\u00f9\u00c1\u00c9\u00cd\u00d3\u00da\u00e1\u00e9\u00ed\u00f3\u00fa\u00c2\u00ca\u00ce\u00d4\u00db\u00e2\u00ea\u00ee\u00f4\u00fb\u00c3\u00d1\u00d5\u00e3\u00f1\u00f5\u00c4\u00cb\u00cf\u00d6\u00dc\u0178\u00e4\u00eb\u00ef\u00f6\u00fc\u00ff\u00df\".indexOf(ch) !== -1\n  );\n}\nevaluate = compile(\"\u00eatre_embarass\u00e9\", {\n  isIdentifierStart: validChars,\n  isIdentifierContinue: validChars\n});\n\nevaluate({ \u00eatre_embarass\u00e9: \"Ping\" });\n```\n\n### 1.0.1\n\n- Disallow access to prototype chain (CVE-2020-5219)\n\n### 1.0.0\n\n- Add support for `this` keyword to write :\n\n```javascript\nevaluate = compile(\"this + 2\")(2); // which gives 4\n```\n", "/* remove eslint errors to see if there is something really wrong */\n/*eslint quotes: [0]*/\n/*eslint indent: [0]*/\n/*eslint vars-on-top: [0]*/\n/*eslint yoda: 0*/\n/*eslint curly: 0*/\n/*eslint no-implicit-coercion: 0*/\n/*eslint newline-after-var: 0*/\n/*eslint space-before-function-paren: 0*/\n/*eslint block-spacing: 0*/\n/*eslint brace-style: 0*/\n/*eslint complexity: 0*/\n/*eslint one-var: 0*/\n/*eslint eqeqeq: 0*/\n/*eslint object-curly-spacing: 0*/\n/*eslint quote-props: 0*/\n/*eslint key-spacing: 0*/\n/*eslint valid-jsdoc: 0*/\n/*eslint func-style: 0*/\n/*eslint no-nested-ternary: 0*/\n/*eslint operator-linebreak: 0*/\n/*eslint no-multi-spaces: 0*/\n/*eslint no-constant-condition: 0*/\n/*eslint comma-spacing: 0*/\n/*eslint no-else-return: 0*/\n/*eslint no-warning-comments: 0*/\n/*eslint default-case: 0*/\n/*eslint consistent-return: 0*/\n/*eslint no-undefined: 0*/\n/*eslint no-new-func: 0*/\n/*eslint max-nested-callbacks: 0*/\n/*eslint padded-blocks: 0*/\n/*eslint no-self-compare: 0*/\n/*eslint no-multiple-empty-lines: 0*/\n/*eslint no-new: 0*/\n/*eslint no-unused-vars: 0*/\n\"use strict\";\n\nvar window = { document: {} };\n\n/* We need to tell ESLint what variables are being exported */\n/* exported\n  angular,\n  msie,\n  jqLite,\n  jQuery,\n  slice,\n  splice,\n  push,\n  toString,\n  ngMinErr,\n  angularModule,\n  uid,\n  REGEX_STRING_REGEXP,\n  VALIDITY_STATE_PROPERTY,\n\n  lowercase,\n  uppercase,\n  manualLowercase,\n  manualUppercase,\n  nodeName_,\n  isArrayLike,\n  forEach,\n  forEachSorted,\n  reverseParams,\n  nextUid,\n  setHashKey,\n  extend,\n  toInt,\n  inherit,\n  merge,\n  noop,\n  identity,\n  valueFn,\n  isUndefined,\n  isDefined,\n  isObject,\n  isBlankObject,\n  isString,\n  isNumber,\n  isNumberNaN,\n  isDate,\n  isArray,\n  isFunction,\n  isRegExp,\n  isWindow,\n  isScope,\n  isFile,\n  isFormData,\n  isBlob,\n  isBoolean,\n  isPromiseLike,\n  trim,\n  escapeForRegexp,\n  isElement,\n  makeMap,\n  includes,\n  arrayRemove,\n  copy,\n  equals,\n  csp,\n  jq,\n  concat,\n  sliceArgs,\n  bind,\n  toJsonReplacer,\n  toJson,\n  fromJson,\n  convertTimezoneToLocal,\n  timezoneToOffset,\n  startingTag,\n  tryDecodeURIComponent,\n  parseKeyValue,\n  toKeyValue,\n  encodeUriSegment,\n  encodeUriQuery,\n  angularInit,\n  bootstrap,\n  getTestability,\n  snake_case,\n  bindJQuery,\n  assertArg,\n  assertArgFn,\n  assertNotHasOwnProperty,\n  getter,\n  getBlockNodes,\n  hasOwnProperty,\n  createMap,\n  stringify,\n\n  NODE_TYPE_ELEMENT,\n  NODE_TYPE_ATTRIBUTE,\n  NODE_TYPE_TEXT,\n  NODE_TYPE_COMMENT,\n  NODE_TYPE_DOCUMENT,\n  NODE_TYPE_DOCUMENT_FRAGMENT\n*/\n\n////////////////////////////////////\n\n/**\n * @ngdoc module\n * @name ng\n * @module ng\n * @installation\n * @description\n *\n * # ng (core module)\n * The ng module is loaded by default when an AngularJS application is started. The module itself\n * contains the essential components for an AngularJS application to function. The table below\n * lists a high level breakdown of each of the services/factories, filters, directives and testing\n * components available within this core module.\n *\n * <div doc-module-components=\"ng\"></div>\n */\n\nvar NODE_TYPE_ELEMENT = 1;\nvar NODE_TYPE_ATTRIBUTE = 2;\nvar NODE_TYPE_TEXT = 3;\nvar NODE_TYPE_COMMENT = 8;\nvar NODE_TYPE_DOCUMENT = 9;\nvar NODE_TYPE_DOCUMENT_FRAGMENT = 11;\nvar REGEX_STRING_REGEXP = /^\\/(.+)\\/([a-z]*)$/;\n\n// The name of a form control's ValidityState property.\n// This is used so that it's possible for internal tests to create mock ValidityStates.\nvar VALIDITY_STATE_PROPERTY = \"validity\";\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar lowercase = function (string) {\n\treturn isString(string) ? string.toLowerCase() : string;\n};\nvar uppercase = function (string) {\n\treturn isString(string) ? string.toUpperCase() : string;\n};\n\n/**\n * @ngdoc function\n * @name angular.isArray\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is an `Array`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Array`.\n */\nvar isArray = Array.isArray;\n\nvar ngAttrPrefixes = [\"ng-\", \"data-ng-\", \"ng:\", \"x-ng-\"];\n\nvar manualLowercase = function (s) {\n\t/* eslint-disable no-bitwise */\n\treturn isString(s)\n\t\t? s.replace(/[A-Z]/g, function (ch) {\n\t\t\t\treturn String.fromCharCode(ch.charCodeAt(0) | 32);\n\t\t  })\n\t\t: s;\n\t/* eslint-enable */\n};\nvar manualUppercase = function (s) {\n\t/* eslint-disable no-bitwise */\n\treturn isString(s)\n\t\t? s.replace(/[a-z]/g, function (ch) {\n\t\t\t\treturn String.fromCharCode(ch.charCodeAt(0) & ~32);\n\t\t  })\n\t\t: s;\n\t/* eslint-enable */\n};\n\n// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish\n// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods\n// with correct but slower alternatives. See https://github.com/angular/angular.js/issues/11387\nif (\"i\" !== \"I\".toLowerCase()) {\n\tlowercase = manualLowercase;\n\tuppercase = manualUppercase;\n}\n\nvar msie, // holds major version number for IE, or NaN if UA is not IE.\n\tjqLite, // delay binding since jQuery could be loaded after us.\n\tjQuery, // delay binding\n\tslice = [].slice,\n\tsplice = [].splice,\n\tpush = [].push,\n\ttoString = Object.prototype.toString,\n\tgetPrototypeOf = Object.getPrototypeOf,\n\tngMinErr = minErr(\"ng\"),\n\t/** @name angular */\n\tangular = window.angular || (window.angular = {}),\n\tangularModule,\n\tuid = 0;\n\n/**\n * documentMode is an IE-only property\n * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx\n */\nmsie = window.document.documentMode;\n\n/**\n * @private\n * @param {*} obj\n * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,\n *                   String ...)\n */\nfunction isArrayLike(obj) {\n\t// `null`, `undefined` and `window` are not array-like\n\tif (obj == null || isWindow(obj)) return false;\n\n\t// arrays, strings and jQuery/jqLite objects are array like\n\t// * jqLite is either the jQuery or jqLite constructor function\n\t// * we have to check the existence of jqLite first as this method is called\n\t//   via the forEach method when constructing the jqLite object in the first place\n\tif (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))\n\t\treturn true;\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// \"length\" in obj used to prevent JIT error (gh-11508)\n\tvar length = \"length\" in Object(obj) && obj.length;\n\n\t// NodeList objects (with `item` method) and\n\t// other objects with suitable length characteristics are array-like\n\treturn (\n\t\tisNumber(length) &&\n\t\t((length >= 0 && (length - 1 in obj || obj instanceof Array)) ||\n\t\t\ttypeof obj.item === \"function\")\n\t);\n}\n\n/**\n * @ngdoc function\n * @name angular.forEach\n * @module ng\n * @kind function\n *\n * @description\n * Invokes the `iterator` function once for each item in `obj` collection, which can be either an\n * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`\n * is the value of an object property or an array element, `key` is the object property key or\n * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.\n *\n * It is worth noting that `.forEach` does not iterate over inherited properties because it filters\n * using the `hasOwnProperty` method.\n *\n * Unlike ES262's\n * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),\n * providing 'undefined' or 'null' values for `obj` will not throw a TypeError, but rather just\n * return the value provided.\n *\n   ```js\n     var values = {name: 'misko', gender: 'male'};\n     var log = [];\n     angular.forEach(values, function(value, key) {\n       this.push(key + ': ' + value);\n     }, log);\n     expect(log).toEqual(['name: misko', 'gender: male']);\n   ```\n *\n * @param {Object|Array} obj Object to iterate over.\n * @param {Function} iterator Iterator function.\n * @param {Object=} context Object to become context (`this`) for the iterator function.\n * @returns {Object|Array} Reference to `obj`.\n */\n\nfunction forEach(obj, iterator, context) {\n\tvar key, length;\n\tif (obj) {\n\t\tif (isFunction(obj)) {\n\t\t\tfor (key in obj) {\n\t\t\t\tif (\n\t\t\t\t\tkey !== \"prototype\" &&\n\t\t\t\t\tkey !== \"length\" &&\n\t\t\t\t\tkey !== \"name\" &&\n\t\t\t\t\tobj.hasOwnProperty(key)\n\t\t\t\t) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isArray(obj) || isArrayLike(obj)) {\n\t\t\tvar isPrimitive = typeof obj !== \"object\";\n\t\t\tfor (key = 0, length = obj.length; key < length; key++) {\n\t\t\t\tif (isPrimitive || key in obj) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (obj.forEach && obj.forEach !== forEach) {\n\t\t\tobj.forEach(iterator, context, obj);\n\t\t} else if (isBlankObject(obj)) {\n\t\t\t// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (key in obj) {\n\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t}\n\t\t} else if (typeof obj.hasOwnProperty === \"function\") {\n\t\t\t// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed\n\t\t\tfor (key in obj) {\n\t\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Slow path for objects which do not have a method `hasOwnProperty`\n\t\t\tfor (key in obj) {\n\t\t\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\nfunction forEachSorted(obj, iterator, context) {\n\tvar keys = Object.keys(obj).sort();\n\tfor (var i = 0; i < keys.length; i++) {\n\t\titerator.call(context, obj[keys[i]], keys[i]);\n\t}\n\treturn keys;\n}\n\n/**\n * when using forEach the params are value, key, but it is often useful to have key, value.\n * @param {function(string, *)} iteratorFn\n * @returns {function(*, string)}\n */\nfunction reverseParams(iteratorFn) {\n\treturn function (value, key) {\n\t\titeratorFn(key, value);\n\t};\n}\n\n/**\n * A consistent way of creating unique IDs in angular.\n *\n * Using simple numbers allows us to generate 28.6 million unique ids per second for 10 years before\n * we hit number precision issues in JavaScript.\n *\n * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 = 28.6M\n *\n * @returns {number} an unique alpha-numeric string\n */\nfunction nextUid() {\n\treturn ++uid;\n}\n\n/**\n * Set or clear the hashkey for an object.\n * @param obj object\n * @param h the hashkey (!truthy to delete the hashkey)\n */\nfunction setHashKey(obj, h) {\n\tif (h) {\n\t\tobj.$$hashKey = h;\n\t} else {\n\t\tdelete obj.$$hashKey;\n\t}\n}\n\nfunction baseExtend(dst, objs, deep) {\n\tvar h = dst.$$hashKey;\n\n\tfor (var i = 0, ii = objs.length; i < ii; ++i) {\n\t\tvar obj = objs[i];\n\t\tif (!isObject(obj) && !isFunction(obj)) continue;\n\t\tvar keys = Object.keys(obj);\n\t\tfor (var j = 0, jj = keys.length; j < jj; j++) {\n\t\t\tvar key = keys[j];\n\t\t\tvar src = obj[key];\n\n\t\t\tif (deep && isObject(src)) {\n\t\t\t\tif (isDate(src)) {\n\t\t\t\t\tdst[key] = new Date(src.valueOf());\n\t\t\t\t} else if (isRegExp(src)) {\n\t\t\t\t\tdst[key] = new RegExp(src);\n\t\t\t\t} else if (src.nodeName) {\n\t\t\t\t\tdst[key] = src.cloneNode(true);\n\t\t\t\t} else if (isElement(src)) {\n\t\t\t\t\tdst[key] = src.clone();\n\t\t\t\t} else {\n\t\t\t\t\tif (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};\n\t\t\t\t\tbaseExtend(dst[key], [src], true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst[key] = src;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetHashKey(dst, h);\n\treturn dst;\n}\n\n/**\n * @ngdoc function\n * @name angular.extend\n * @module ng\n * @kind function\n *\n * @description\n * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)\n * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so\n * by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.\n *\n * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy). Use\n * {@link angular.merge} for this.\n *\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nfunction extend(dst) {\n\treturn baseExtend(dst, slice.call(arguments, 1), false);\n}\n\n/**\n * @ngdoc function\n * @name angular.merge\n * @module ng\n * @kind function\n *\n * @description\n * Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)\n * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so\n * by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.\n *\n * Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source\n * objects, performing a deep copy.\n *\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nfunction merge(dst) {\n\treturn baseExtend(dst, slice.call(arguments, 1), true);\n}\n\nfunction toInt(str) {\n\treturn parseInt(str, 10);\n}\n\nvar isNumberNaN =\n\tNumber.isNaN ||\n\tfunction isNumberNaN(num) {\n\t\t// eslint-disable-next-line no-self-compare\n\t\treturn num !== num;\n\t};\n\nfunction inherit(parent, extra) {\n\treturn extend(Object.create(parent), extra);\n}\n\n/**\n * @ngdoc function\n * @name angular.noop\n * @module ng\n * @kind function\n *\n * @description\n * A function that performs no operations. This function can be useful when writing code in the\n * functional style.\n   ```js\n     function foo(callback) {\n       var result = calculateResult();\n       (callback || angular.noop)(result);\n     }\n   ```\n */\nfunction noop() {}\nnoop.$inject = [];\n\n/**\n * @ngdoc function\n * @name angular.identity\n * @module ng\n * @kind function\n *\n * @description\n * A function that returns its first argument. This function is useful when writing code in the\n * functional style.\n *\n   ```js\n   function transformer(transformationFn, value) {\n     return (transformationFn || angular.identity)(value);\n   };\n\n   // E.g.\n   function getResult(fn, input) {\n     return (fn || angular.identity)(input);\n   };\n\n   getResult(function(n) { return n * 2; }, 21);   // returns 42\n   getResult(null, 21);                            // returns 21\n   getResult(undefined, 21);                       // returns 21\n   ```\n *\n * @param {*} value to be returned.\n * @returns {*} the value passed in.\n */\nfunction identity($) {\n\treturn $;\n}\nidentity.$inject = [];\n\nfunction valueFn(value) {\n\treturn function valueRef() {\n\t\treturn value;\n\t};\n}\n\nfunction hasCustomToString(obj) {\n\treturn isFunction(obj.toString) && obj.toString !== toString;\n}\n\n/**\n * @ngdoc function\n * @name angular.isUndefined\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is undefined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is undefined.\n */\nfunction isUndefined(value) {\n\treturn typeof value === \"undefined\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isDefined\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is defined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is defined.\n */\nfunction isDefined(value) {\n\treturn typeof value !== \"undefined\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isObject\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\n * considered to be objects. Note that JavaScript arrays are objects.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Object` but not `null`.\n */\nfunction isObject(value) {\n\t// http://jsperf.com/isobject4\n\treturn value !== null && typeof value === \"object\";\n}\n\n/**\n * Determine if a value is an object with a null prototype\n *\n * @returns {boolean} True if `value` is an `Object` with a null prototype\n */\nfunction isBlankObject(value) {\n\treturn value !== null && typeof value === \"object\" && !getPrototypeOf(value);\n}\n\n/**\n * @ngdoc function\n * @name angular.isString\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `String`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `String`.\n */\nfunction isString(value) {\n\treturn typeof value === \"string\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isNumber\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `Number`.\n *\n * This includes the \"special\" numbers `NaN`, `+Infinity` and `-Infinity`.\n *\n * If you wish to exclude these then you can use the native\n * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)\n * method.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Number`.\n */\nfunction isNumber(value) {\n\treturn typeof value === \"number\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isDate\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a value is a date.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Date`.\n */\nfunction isDate(value) {\n\treturn toString.call(value) === \"[object Date]\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isFunction\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `Function`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Function`.\n */\nfunction isFunction(value) {\n\treturn typeof value === \"function\";\n}\n\n/**\n * Determines if a value is a regular expression object.\n *\n * @private\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `RegExp`.\n */\nfunction isRegExp(value) {\n\treturn toString.call(value) === \"[object RegExp]\";\n}\n\n/**\n * Checks if `obj` is a window object.\n *\n * @private\n * @param {*} obj Object to check\n * @returns {boolean} True if `obj` is a window obj.\n */\nfunction isWindow(obj) {\n\treturn obj && obj.window === obj;\n}\n\nfunction isScope(obj) {\n\treturn obj && obj.$evalAsync && obj.$watch;\n}\n\nfunction isFile(obj) {\n\treturn toString.call(obj) === \"[object File]\";\n}\n\nfunction isFormData(obj) {\n\treturn toString.call(obj) === \"[object FormData]\";\n}\n\nfunction isBlob(obj) {\n\treturn toString.call(obj) === \"[object Blob]\";\n}\n\nfunction isBoolean(value) {\n\treturn typeof value === \"boolean\";\n}\n\nfunction isPromiseLike(obj) {\n\treturn obj && isFunction(obj.then);\n}\n\nvar TYPED_ARRAY_REGEXP = /^\\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\\]$/;\nfunction isTypedArray(value) {\n\treturn (\n\t\tvalue &&\n\t\tisNumber(value.length) &&\n\t\tTYPED_ARRAY_REGEXP.test(toString.call(value))\n\t);\n}\n\nfunction isArrayBuffer(obj) {\n\treturn toString.call(obj) === \"[object ArrayBuffer]\";\n}\n\nvar trim = function (value) {\n\treturn isString(value) ? value.trim() : value;\n};\n\n// Copied from:\n// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021\n// Prereq: s is a string.\nvar escapeForRegexp = function (s) {\n\treturn (\n\t\ts\n\t\t\t.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, \"\\\\$1\")\n\t\t\t// eslint-disable-next-line no-control-regex\n\t\t\t.replace(/\\x08/g, \"\\\\x08\")\n\t);\n};\n\n/**\n * @ngdoc function\n * @name angular.isElement\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a DOM element (or wrapped jQuery element).\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).\n */\nfunction isElement(node) {\n\treturn !!(\n\t\tnode &&\n\t\t(node.nodeName || // We are a direct element.\n\t\t\t(node.prop && node.attr && node.find))\n\t); // We have an on and find method part of jQuery API.\n}\n\n/**\n * @param str 'key1,key2,...'\n * @returns {object} in the form of {key1:true, key2:true, ...}\n */\nfunction makeMap(str) {\n\tvar obj = {},\n\t\titems = str.split(\",\"),\n\t\ti;\n\tfor (i = 0; i < items.length; i++) {\n\t\tobj[items[i]] = true;\n\t}\n\treturn obj;\n}\n\nfunction nodeName_(element) {\n\treturn lowercase(element.nodeName || (element[0] && element[0].nodeName));\n}\n\nfunction includes(array, obj) {\n\treturn Array.prototype.indexOf.call(array, obj) !== -1;\n}\n\nfunction arrayRemove(array, value) {\n\tvar index = array.indexOf(value);\n\tif (index >= 0) {\n\t\tarray.splice(index, 1);\n\t}\n\treturn index;\n}\n\n/**\n * @ngdoc function\n * @name angular.copy\n * @module ng\n * @kind function\n *\n * @description\n * Creates a deep copy of `source`, which should be an object or an array.\n *\n * * If no destination is supplied, a copy of the object or array is created.\n * * If a destination is provided, all of its elements (for arrays) or properties (for objects)\n *   are deleted and then all elements/properties from the source are copied to it.\n * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.\n * * If `source` is identical to `destination` an exception will be thrown.\n *\n * <br />\n * <div class=\"alert alert-warning\">\n *   Only enumerable properties are taken into account. Non-enumerable properties (both on `source`\n *   and on `destination`) will be ignored.\n * </div>\n *\n * @param {*} source The source that will be used to make a copy.\n *                   Can be any type, including primitives, `null`, and `undefined`.\n * @param {(Object|Array)=} destination Destination into which the source is copied. If\n *     provided, must be of the same type as `source`.\n * @returns {*} The copy or updated `destination`, if `destination` was specified.\n *\n * @example\n  <example module=\"copyExample\" name=\"angular-copy\">\n    <file name=\"index.html\">\n      <div ng-controller=\"ExampleController\">\n        <form novalidate class=\"simple-form\">\n          <label>Name: <input type=\"text\" ng-model=\"user.name\" /></label><br />\n          <label>Age:  <input type=\"number\" ng-model=\"user.age\" /></label><br />\n          Gender: <label><input type=\"radio\" ng-model=\"user.gender\" value=\"male\" />male</label>\n                  <label><input type=\"radio\" ng-model=\"user.gender\" value=\"female\" />female</label><br />\n          <button ng-click=\"reset()\">RESET</button>\n          <button ng-click=\"update(user)\">SAVE</button>\n        </form>\n        <pre>form = {{user | json}}</pre>\n        <pre>master = {{master | json}}</pre>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      // Module: copyExample\n      angular.\n        module('copyExample', []).\n        controller('ExampleController', ['$scope', function($scope) {\n          $scope.master = {};\n\n          $scope.reset = function() {\n            // Example with 1 argument\n            $scope.user = angular.copy($scope.master);\n          };\n\n          $scope.update = function(user) {\n            // Example with 2 arguments\n            angular.copy(user, $scope.master);\n          };\n\n          $scope.reset();\n        }]);\n    </file>\n  </example>\n */\nfunction copy(source, destination) {\n\tvar stackSource = [];\n\tvar stackDest = [];\n\n\tif (destination) {\n\t\tif (isTypedArray(destination) || isArrayBuffer(destination)) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpta\",\n\t\t\t\t\"Can't copy! TypedArray destination cannot be mutated.\"\n\t\t\t);\n\t\t}\n\t\tif (source === destination) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpi\",\n\t\t\t\t\"Can't copy! Source and destination are identical.\"\n\t\t\t);\n\t\t}\n\n\t\t// Empty the destination object\n\t\tif (isArray(destination)) {\n\t\t\tdestination.length = 0;\n\t\t} else {\n\t\t\tforEach(destination, function (value, key) {\n\t\t\t\tif (key !== \"$$hashKey\") {\n\t\t\t\t\tdelete destination[key];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tstackSource.push(source);\n\t\tstackDest.push(destination);\n\t\treturn copyRecurse(source, destination);\n\t}\n\n\treturn copyElement(source);\n\n\tfunction copyRecurse(source, destination) {\n\t\tvar h = destination.$$hashKey;\n\t\tvar key;\n\t\tif (isArray(source)) {\n\t\t\tfor (var i = 0, ii = source.length; i < ii; i++) {\n\t\t\t\tdestination.push(copyElement(source[i]));\n\t\t\t}\n\t\t} else if (isBlankObject(source)) {\n\t\t\t// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (key in source) {\n\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t}\n\t\t} else if (source && typeof source.hasOwnProperty === \"function\") {\n\t\t\t// Slow path, which must rely on hasOwnProperty\n\t\t\tfor (key in source) {\n\t\t\t\tif (source.hasOwnProperty(key)) {\n\t\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Slowest path --- hasOwnProperty can't be called as a method\n\t\t\tfor (key in source) {\n\t\t\t\tif (hasOwnProperty.call(source, key)) {\n\t\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetHashKey(destination, h);\n\t\treturn destination;\n\t}\n\n\tfunction copyElement(source) {\n\t\t// Simple values\n\t\tif (!isObject(source)) {\n\t\t\treturn source;\n\t\t}\n\n\t\t// Already copied values\n\t\tvar index = stackSource.indexOf(source);\n\t\tif (index !== -1) {\n\t\t\treturn stackDest[index];\n\t\t}\n\n\t\tif (isWindow(source) || isScope(source)) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpws\",\n\t\t\t\t\"Can't copy! Making copies of Window or Scope instances is not supported.\"\n\t\t\t);\n\t\t}\n\n\t\tvar needsRecurse = false;\n\t\tvar destination = copyType(source);\n\n\t\tif (destination === undefined) {\n\t\t\tdestination = isArray(source)\n\t\t\t\t? []\n\t\t\t\t: Object.create(getPrototypeOf(source));\n\t\t\tneedsRecurse = true;\n\t\t}\n\n\t\tstackSource.push(source);\n\t\tstackDest.push(destination);\n\n\t\treturn needsRecurse ? copyRecurse(source, destination) : destination;\n\t}\n\n\tfunction copyType(source) {\n\t\tswitch (toString.call(source)) {\n\t\t\tcase \"[object Int8Array]\":\n\t\t\tcase \"[object Int16Array]\":\n\t\t\tcase \"[object Int32Array]\":\n\t\t\tcase \"[object Float32Array]\":\n\t\t\tcase \"[object Float64Array]\":\n\t\t\tcase \"[object Uint8Array]\":\n\t\t\tcase \"[object Uint8ClampedArray]\":\n\t\t\tcase \"[object Uint16Array]\":\n\t\t\tcase \"[object Uint32Array]\":\n\t\t\t\treturn new source.constructor(\n\t\t\t\t\tcopyElement(source.buffer),\n\t\t\t\t\tsource.byteOffset,\n\t\t\t\t\tsource.length\n\t\t\t\t);\n\n\t\t\tcase \"[object ArrayBuffer]\":\n\t\t\t\t// Support: IE10\n\t\t\t\tif (!source.slice) {\n\t\t\t\t\t// If we're in this case we know the environment supports ArrayBuffer\n\t\t\t\t\t/* eslint-disable no-undef */\n\t\t\t\t\tvar copied = new ArrayBuffer(source.byteLength);\n\t\t\t\t\tnew Uint8Array(copied).set(new Uint8Array(source));\n\t\t\t\t\t/* eslint-enable */\n\t\t\t\t\treturn copied;\n\t\t\t\t}\n\t\t\t\treturn source.slice(0);\n\n\t\t\tcase \"[object Boolean]\":\n\t\t\tcase \"[object Number]\":\n\t\t\tcase \"[object String]\":\n\t\t\tcase \"[object Date]\":\n\t\t\t\treturn new source.constructor(source.valueOf());\n\n\t\t\tcase \"[object RegExp]\":\n\t\t\t\tvar re = new RegExp(\n\t\t\t\t\tsource.source,\n\t\t\t\t\tsource.toString().match(/[^\\/]*$/)[0]\n\t\t\t\t);\n\t\t\t\tre.lastIndex = source.lastIndex;\n\t\t\t\treturn re;\n\n\t\t\tcase \"[object Blob]\":\n\t\t\t\treturn new source.constructor([source], { type: source.type });\n\t\t}\n\n\t\tif (isFunction(source.cloneNode)) {\n\t\t\treturn source.cloneNode(true);\n\t\t}\n\t}\n}\n\n/**\n * @ngdoc function\n * @name angular.equals\n * @module ng\n * @kind function\n *\n * @description\n * Determines if two objects or two values are equivalent. Supports value types, regular\n * expressions, arrays and objects.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties are equal by\n *   comparing them with `angular.equals`.\n * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)\n * * Both values represent the same regular expression (In JavaScript,\n *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual\n *   representation matches).\n *\n * During a property comparison, properties of `function` type and properties with names\n * that begin with `$` are ignored.\n *\n * Scope and DOMWindow objects are being compared only by identify (`===`).\n *\n * @param {*} o1 Object or value to compare.\n * @param {*} o2 Object or value to compare.\n * @returns {boolean} True if arguments are equal.\n *\n * @example\n   <example module=\"equalsExample\" name=\"equalsExample\">\n     <file name=\"index.html\">\n      <div ng-controller=\"ExampleController\">\n        <form novalidate>\n          <h3>User 1</h3>\n          Name: <input type=\"text\" ng-model=\"user1.name\">\n          Age: <input type=\"number\" ng-model=\"user1.age\">\n\n          <h3>User 2</h3>\n          Name: <input type=\"text\" ng-model=\"user2.name\">\n          Age: <input type=\"number\" ng-model=\"user2.age\">\n\n          <div>\n            <br/>\n            <input type=\"button\" value=\"Compare\" ng-click=\"compare()\">\n          </div>\n          User 1: <pre>{{user1 | json}}</pre>\n          User 2: <pre>{{user2 | json}}</pre>\n          Equal: <pre>{{result}}</pre>\n        </form>\n      </div>\n    </file>\n    <file name=\"script.js\">\n        angular.module('equalsExample', []).controller('ExampleController', ['$scope', function($scope) {\n          $scope.user1 = {};\n          $scope.user2 = {};\n          $scope.compare = function() {\n            $scope.result = angular.equals($scope.user1, $scope.user2);\n          };\n        }]);\n    </file>\n  </example>\n */\nfunction equals(o1, o2) {\n\tif (o1 === o2) return true;\n\tif (o1 === null || o2 === null) return false;\n\t// eslint-disable-next-line no-self-compare\n\tif (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n\tvar t1 = typeof o1,\n\t\tt2 = typeof o2,\n\t\tlength,\n\t\tkey,\n\t\tkeySet;\n\tif (t1 === t2 && t1 === \"object\") {\n\t\tif (isArray(o1)) {\n\t\t\tif (!isArray(o2)) return false;\n\t\t\tif ((length = o1.length) === o2.length) {\n\t\t\t\tfor (key = 0; key < length; key++) {\n\t\t\t\t\tif (!equals(o1[key], o2[key])) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (isDate(o1)) {\n\t\t\tif (!isDate(o2)) return false;\n\t\t\treturn equals(o1.getTime(), o2.getTime());\n\t\t} else if (isRegExp(o1)) {\n\t\t\tif (!isRegExp(o2)) return false;\n\t\t\treturn o1.toString() === o2.toString();\n\t\t} else {\n\t\t\tif (\n\t\t\t\tisScope(o1) ||\n\t\t\t\tisScope(o2) ||\n\t\t\t\tisWindow(o1) ||\n\t\t\t\tisWindow(o2) ||\n\t\t\t\tisArray(o2) ||\n\t\t\t\tisDate(o2) ||\n\t\t\t\tisRegExp(o2)\n\t\t\t)\n\t\t\t\treturn false;\n\t\t\tkeySet = createMap();\n\t\t\tfor (key in o1) {\n\t\t\t\tif (key.charAt(0) === \"$\" || isFunction(o1[key])) continue;\n\t\t\t\tif (!equals(o1[key], o2[key])) return false;\n\t\t\t\tkeySet[key] = true;\n\t\t\t}\n\t\t\tfor (key in o2) {\n\t\t\t\tif (\n\t\t\t\t\t!(key in keySet) &&\n\t\t\t\t\tkey.charAt(0) !== \"$\" &&\n\t\t\t\t\tisDefined(o2[key]) &&\n\t\t\t\t\t!isFunction(o2[key])\n\t\t\t\t)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvar csp = function () {\n\tif (!isDefined(csp.rules)) {\n\t\tvar ngCspElement =\n\t\t\twindow.document.querySelector(\"[ng-csp]\") ||\n\t\t\twindow.document.querySelector(\"[data-ng-csp]\");\n\n\t\tif (ngCspElement) {\n\t\t\tvar ngCspAttribute =\n\t\t\t\tngCspElement.getAttribute(\"ng-csp\") ||\n\t\t\t\tngCspElement.getAttribute(\"data-ng-csp\");\n\t\t\tcsp.rules = {\n\t\t\t\tnoUnsafeEval:\n\t\t\t\t\t!ngCspAttribute || ngCspAttribute.indexOf(\"no-unsafe-eval\") !== -1,\n\t\t\t\tnoInlineStyle:\n\t\t\t\t\t!ngCspAttribute || ngCspAttribute.indexOf(\"no-inline-style\") !== -1,\n\t\t\t};\n\t\t} else {\n\t\t\tcsp.rules = {\n\t\t\t\tnoUnsafeEval: noUnsafeEval(),\n\t\t\t\tnoInlineStyle: false,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn csp.rules;\n\n\tfunction noUnsafeEval() {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new, no-new-func\n\t\t\tnew Function(\"\");\n\t\t\treturn false;\n\t\t} catch (e) {\n\t\t\treturn true;\n\t\t}\n\t}\n};\n\n/**\n * @ngdoc directive\n * @module ng\n * @name ngJq\n *\n * @element ANY\n * @param {string=} ngJq the name of the library available under `window`\n * to be used for angular.element\n * @description\n * Use this directive to force the angular.element library.  This should be\n * used to force either jqLite by leaving ng-jq blank or setting the name of\n * the jquery variable under window (eg. jQuery).\n *\n * Since angular looks for this directive when it is loaded (doesn't wait for the\n * DOMContentLoaded event), it must be placed on an element that comes before the script\n * which loads angular. Also, only the first instance of `ng-jq` will be used and all\n * others ignored.\n *\n * @example\n * This example shows how to force jqLite using the `ngJq` directive to the `html` tag.\n ```html\n <!doctype html>\n <html ng-app ng-jq>\n ...\n ...\n </html>\n ```\n * @example\n * This example shows how to use a jQuery based library of a different name.\n * The library name must be available at the top most 'window'.\n ```html\n <!doctype html>\n <html ng-app ng-jq=\"jQueryLib\">\n ...\n ...\n </html>\n ```\n */\nvar jq = function () {\n\tif (isDefined(jq.name_)) return jq.name_;\n\tvar el;\n\tvar i,\n\t\tii = ngAttrPrefixes.length,\n\t\tprefix,\n\t\tname;\n\tfor (i = 0; i < ii; ++i) {\n\t\tprefix = ngAttrPrefixes[i];\n\t\tel = window.document.querySelector(\n\t\t\t\"[\" + prefix.replace(\":\", \"\\\\:\") + \"jq]\"\n\t\t);\n\t\tif (el) {\n\t\t\tname = el.getAttribute(prefix + \"jq\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (jq.name_ = name);\n};\n\nfunction concat(array1, array2, index) {\n\treturn array1.concat(slice.call(array2, index));\n}\n\nfunction sliceArgs(args, startIndex) {\n\treturn slice.call(args, startIndex || 0);\n}\n\n/**\n * @ngdoc function\n * @name angular.bind\n * @module ng\n * @kind function\n *\n * @description\n * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\n * `fn`). You can supply optional `args` that are prebound to the function. This feature is also\n * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as\n * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).\n *\n * @param {Object} self Context which `fn` should be evaluated in.\n * @param {function()} fn Function to be bound.\n * @param {...*} args Optional arguments to be prebound to the `fn` function call.\n * @returns {function()} Function that wraps the `fn` with all the specified bindings.\n */\n// eslint-disable-next-line consistent-this\nfunction bind(self, fn) {\n\tvar curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];\n\tif (isFunction(fn) && !(fn instanceof RegExp)) {\n\t\treturn curryArgs.length\n\t\t\t? function () {\n\t\t\t\t\treturn arguments.length\n\t\t\t\t\t\t? fn.apply(self, concat(curryArgs, arguments, 0))\n\t\t\t\t\t\t: fn.apply(self, curryArgs);\n\t\t\t  }\n\t\t\t: function () {\n\t\t\t\t\treturn arguments.length ? fn.apply(self, arguments) : fn.call(self);\n\t\t\t  };\n\t} else {\n\t\t// In IE, native methods are not functions so they cannot be bound (note: they don't need to be).\n\t\treturn fn;\n\t}\n}\n\nfunction toJsonReplacer(key, value) {\n\tvar val = value;\n\n\tif (\n\t\ttypeof key === \"string\" &&\n\t\tkey.charAt(0) === \"$\" &&\n\t\tkey.charAt(1) === \"$\"\n\t) {\n\t\tval = undefined;\n\t} else if (isWindow(value)) {\n\t\tval = \"$WINDOW\";\n\t} else if (value && window.document === value) {\n\t\tval = \"$DOCUMENT\";\n\t} else if (isScope(value)) {\n\t\tval = \"$SCOPE\";\n\t}\n\n\treturn val;\n}\n\n/**\n * @ngdoc function\n * @name angular.toJson\n * @module ng\n * @kind function\n *\n * @description\n * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be\n * stripped since angular uses this notation internally.\n *\n * @param {Object|Array|Date|string|number|boolean} obj Input to be serialized into JSON.\n * @param {boolean|number} [pretty=2] If set to true, the JSON output will contain newlines and whitespace.\n *    If set to an integer, the JSON output will contain that many spaces per indentation.\n * @returns {string|undefined} JSON-ified string representing `obj`.\n * @knownIssue\n *\n * The Safari browser throws a `RangeError` instead of returning `null` when it tries to stringify a `Date`\n * object with an invalid date value. The only reliable way to prevent this is to monkeypatch the\n * `Date.prototype.toJSON` method as follows:\n *\n * ```\n * var _DatetoJSON = Date.prototype.toJSON;\n * Date.prototype.toJSON = function() {\n *   try {\n *     return _DatetoJSON.call(this);\n *   } catch(e) {\n *     if (e instanceof RangeError) {\n *       return null;\n *     }\n *     throw e;\n *   }\n * };\n * ```\n *\n * See https://github.com/angular/angular.js/pull/14221 for more information.\n */\nfunction toJson(obj, pretty) {\n\tif (isUndefined(obj)) return undefined;\n\tif (!isNumber(pretty)) {\n\t\tpretty = pretty ? 2 : null;\n\t}\n\treturn JSON.stringify(obj, toJsonReplacer, pretty);\n}\n\n/**\n * @ngdoc function\n * @name angular.fromJson\n * @module ng\n * @kind function\n *\n * @description\n * Deserializes a JSON string.\n *\n * @param {string} json JSON string to deserialize.\n * @returns {Object|Array|string|number} Deserialized JSON string.\n */\nfunction fromJson(json) {\n\treturn isString(json) ? JSON.parse(json) : json;\n}\n\nvar ALL_COLONS = /:/g;\nfunction timezoneToOffset(timezone, fallback) {\n\t// IE/Edge do not \"understand\" colon (`:`) in timezone\n\ttimezone = timezone.replace(ALL_COLONS, \"\");\n\tvar requestedTimezoneOffset =\n\t\tDate.parse(\"Jan 01, 1970 00:00:00 \" + timezone) / 60000;\n\treturn isNumberNaN(requestedTimezoneOffset)\n\t\t? fallback\n\t\t: requestedTimezoneOffset;\n}\n\nfunction addDateMinutes(date, minutes) {\n\tdate = new Date(date.getTime());\n\tdate.setMinutes(date.getMinutes() + minutes);\n\treturn date;\n}\n\nfunction convertTimezoneToLocal(date, timezone, reverse) {\n\treverse = reverse ? -1 : 1;\n\tvar dateTimezoneOffset = date.getTimezoneOffset();\n\tvar timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n\treturn addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));\n}\n\n/**\n * @returns {string} Returns the string representation of the element.\n */\nfunction startingTag(element) {\n\telement = jqLite(element).clone();\n\ttry {\n\t\t// turns out IE does not let you set .html() on elements which\n\t\t// are not allowed to have children. So we just ignore it.\n\t\telement.empty();\n\t} catch (e) {\n\t\t/* empty */\n\t}\n\tvar elemHtml = jqLite(\"<div>\").append(element).html();\n\ttry {\n\t\treturn element[0].nodeType === NODE_TYPE_TEXT\n\t\t\t? lowercase(elemHtml)\n\t\t\t: elemHtml\n\t\t\t\t\t.match(/^(<[^>]+>)/)[1]\n\t\t\t\t\t.replace(/^<([\\w\\-]+)/, function (match, nodeName) {\n\t\t\t\t\t\treturn \"<\" + lowercase(nodeName);\n\t\t\t\t\t});\n\t} catch (e) {\n\t\treturn lowercase(elemHtml);\n\t}\n}\n\n/////////////////////////////////////////////////\n\n/**\n * Tries to decode the URI component without throwing an exception.\n *\n * @private\n * @param str value potential URI component to check.\n * @returns {boolean} True if `value` can be decoded\n * with the decodeURIComponent function.\n */\nfunction tryDecodeURIComponent(value) {\n\ttry {\n\t\treturn decodeURIComponent(value);\n\t} catch (e) {\n\t\t// Ignore any invalid uri component.\n\t}\n}\n\n/**\n * Parses an escaped url query string into key-value pairs.\n * @returns {Object.<string,boolean|Array>}\n */\nfunction parseKeyValue(/**string*/ keyValue) {\n\tvar obj = {};\n\tforEach((keyValue || \"\").split(\"&\"), function (keyValue) {\n\t\tvar splitPoint, key, val;\n\t\tif (keyValue) {\n\t\t\tkey = keyValue = keyValue.replace(/\\+/g, \"%20\");\n\t\t\tsplitPoint = keyValue.indexOf(\"=\");\n\t\t\tif (splitPoint !== -1) {\n\t\t\t\tkey = keyValue.substring(0, splitPoint);\n\t\t\t\tval = keyValue.substring(splitPoint + 1);\n\t\t\t}\n\t\t\tkey = tryDecodeURIComponent(key);\n\t\t\tif (isDefined(key)) {\n\t\t\t\tval = isDefined(val) ? tryDecodeURIComponent(val) : true;\n\t\t\t\tif (!hasOwnProperty.call(obj, key)) {\n\t\t\t\t\tobj[key] = val;\n\t\t\t\t} else if (isArray(obj[key])) {\n\t\t\t\t\tobj[key].push(val);\n\t\t\t\t} else {\n\t\t\t\t\tobj[key] = [obj[key], val];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\treturn obj;\n}\n\nfunction toKeyValue(obj) {\n\tvar parts = [];\n\tforEach(obj, function (value, key) {\n\t\tif (isArray(value)) {\n\t\t\tforEach(value, function (arrayValue) {\n\t\t\t\tparts.push(\n\t\t\t\t\tencodeUriQuery(key, true) +\n\t\t\t\t\t\t(arrayValue === true ? \"\" : \"=\" + encodeUriQuery(arrayValue, true))\n\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tparts.push(\n\t\t\t\tencodeUriQuery(key, true) +\n\t\t\t\t\t(value === true ? \"\" : \"=\" + encodeUriQuery(value, true))\n\t\t\t);\n\t\t}\n\t});\n\treturn parts.length ? parts.join(\"&\") : \"\";\n}\n\n/**\n * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\n * segments:\n *    segment       = *pchar\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriSegment(val) {\n\treturn encodeUriQuery(val, true)\n\t\t.replace(/%26/gi, \"&\")\n\t\t.replace(/%3D/gi, \"=\")\n\t\t.replace(/%2B/gi, \"+\");\n}\n\n/**\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\n * encoded per http://tools.ietf.org/html/rfc3986:\n *    query         = *( pchar / \"/\" / \"?\" )\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriQuery(val, pctEncodeSpaces) {\n\treturn encodeURIComponent(val)\n\t\t.replace(/%40/gi, \"@\")\n\t\t.replace(/%3A/gi, \":\")\n\t\t.replace(/%24/g, \"$\")\n\t\t.replace(/%2C/gi, \",\")\n\t\t.replace(/%3B/gi, \";\")\n\t\t.replace(/%20/g, pctEncodeSpaces ? \"%20\" : \"+\");\n}\n\nfunction getNgAttribute(element, ngAttr) {\n\tvar attr,\n\t\ti,\n\t\tii = ngAttrPrefixes.length;\n\tfor (i = 0; i < ii; ++i) {\n\t\tattr = ngAttrPrefixes[i] + ngAttr;\n\t\tif (isString((attr = element.getAttribute(attr)))) {\n\t\t\treturn attr;\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction allowAutoBootstrap(document) {\n\tif (!document.currentScript) {\n\t\treturn true;\n\t}\n\tvar src = document.currentScript.getAttribute(\"src\");\n\tvar link = document.createElement(\"a\");\n\tlink.href = src;\n\tvar scriptProtocol = link.protocol;\n\tvar docLoadProtocol = document.location.protocol;\n\tif (\n\t\t(scriptProtocol === \"resource:\" ||\n\t\t\tscriptProtocol === \"chrome-extension:\") &&\n\t\tdocLoadProtocol !== scriptProtocol\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Cached as it has to run during loading so that document.currentScript is available.\nvar isAutoBootstrapAllowed = allowAutoBootstrap(window.document);\n\n/**\n * @ngdoc directive\n * @name ngApp\n * @module ng\n *\n * @element ANY\n * @param {angular.Module} ngApp an optional application\n *   {@link angular.module module} name to load.\n * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be\n *   created in \"strict-di\" mode. This means that the application will fail to invoke functions which\n *   do not use explicit function annotation (and are thus unsuitable for minification), as described\n *   in {@link guide/di the Dependency Injection guide}, and useful debugging info will assist in\n *   tracking down the root of these bugs.\n *\n * @description\n *\n * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive\n * designates the **root element** of the application and is typically placed near the root element\n * of the page - e.g. on the `<body>` or `<html>` tags.\n *\n * There are a few things to keep in mind when using `ngApp`:\n * - only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`\n *   found in the document will be used to define the root element to auto-bootstrap as an\n *   application. To run multiple applications in an HTML document you must manually bootstrap them using\n *   {@link angular.bootstrap} instead.\n * - AngularJS applications cannot be nested within each other.\n * - Do not use a directive that uses {@link ng.$compile#transclusion transclusion} on the same element as `ngApp`.\n *   This includes directives such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and\n *   {@link ngRoute.ngView `ngView`}.\n *   Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},\n *   causing animations to stop working and making the injector inaccessible from outside the app.\n *\n * You can specify an **AngularJS module** to be used as the root module for the application.  This\n * module will be loaded into the {@link auto.$injector} when the application is bootstrapped. It\n * should contain the application code needed or have dependencies on other modules that will\n * contain the code. See {@link angular.module} for more information.\n *\n * In the example below if the `ngApp` directive were not placed on the `html` element then the\n * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`\n * would not be resolved to `3`.\n *\n * `ngApp` is the easiest, and most common way to bootstrap an application.\n *\n <example module=\"ngAppDemo\" name=\"ng-app\">\n   <file name=\"index.html\">\n   <div ng-controller=\"ngAppDemoController\">\n     I can add: {{a}} + {{b}} =  {{ a+b }}\n   </div>\n   </file>\n   <file name=\"script.js\">\n   angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {\n     $scope.a = 1;\n     $scope.b = 2;\n   });\n   </file>\n </example>\n *\n * Using `ngStrictDi`, you would see something like this:\n *\n <example ng-app-included=\"true\" name=\"strict-di\">\n   <file name=\"index.html\">\n   <div ng-app=\"ngAppStrictDemo\" ng-strict-di>\n       <div ng-controller=\"GoodController1\">\n           I can add: {{a}} + {{b}} =  {{ a+b }}\n\n           <p>This renders because the controller does not fail to\n              instantiate, by using explicit annotation style (see\n              script.js for details)\n           </p>\n       </div>\n\n       <div ng-controller=\"GoodController2\">\n           Name: <input ng-model=\"name\"><br />\n           Hello, {{name}}!\n\n           <p>This renders because the controller does not fail to\n              instantiate, by using explicit annotation style\n              (see script.js for details)\n           </p>\n       </div>\n\n       <div ng-controller=\"BadController\">\n           I can add: {{a}} + {{b}} =  {{ a+b }}\n\n           <p>The controller could not be instantiated, due to relying\n              on automatic function annotations (which are disabled in\n              strict mode). As such, the content of this section is not\n              interpolated, and there should be an error in your web console.\n           </p>\n       </div>\n   </div>\n   </file>\n   <file name=\"script.js\">\n   angular.module('ngAppStrictDemo', [])\n     // BadController will fail to instantiate, due to relying on automatic function annotation,\n     // rather than an explicit annotation\n     .controller('BadController', function($scope) {\n       $scope.a = 1;\n       $scope.b = 2;\n     })\n     // Unlike BadController, GoodController1 and GoodController2 will not fail to be instantiated,\n     // due to using explicit annotations using the array style and $inject property, respectively.\n     .controller('GoodController1', ['$scope', function($scope) {\n       $scope.a = 1;\n       $scope.b = 2;\n     }])\n     .controller('GoodController2', GoodController2);\n     function GoodController2($scope) {\n       $scope.name = 'World';\n     }\n     GoodController2.$inject = ['$scope'];\n   </file>\n   <file name=\"style.css\">\n   div[ng-controller] {\n       margin-bottom: 1em;\n       -webkit-border-radius: 4px;\n       border-radius: 4px;\n       border: 1px solid;\n       padding: .5em;\n   }\n   div[ng-controller^=Good] {\n       border-color: #d6e9c6;\n       background-color: #dff0d8;\n       color: #3c763d;\n   }\n   div[ng-controller^=Bad] {\n       border-color: #ebccd1;\n       background-color: #f2dede;\n       color: #a94442;\n       margin-bottom: 0;\n   }\n   </file>\n </example>\n */\nfunction angularInit(element, bootstrap) {\n\tvar appElement,\n\t\tmodule,\n\t\tconfig = {};\n\n\t// The element `element` has priority over any other element.\n\tforEach(ngAttrPrefixes, function (prefix) {\n\t\tvar name = prefix + \"app\";\n\n\t\tif (!appElement && element.hasAttribute && element.hasAttribute(name)) {\n\t\t\tappElement = element;\n\t\t\tmodule = element.getAttribute(name);\n\t\t}\n\t});\n\tforEach(ngAttrPrefixes, function (prefix) {\n\t\tvar name = prefix + \"app\";\n\t\tvar candidate;\n\n\t\tif (\n\t\t\t!appElement &&\n\t\t\t(candidate = element.querySelector(\"[\" + name.replace(\":\", \"\\\\:\") + \"]\"))\n\t\t) {\n\t\t\tappElement = candidate;\n\t\t\tmodule = candidate.getAttribute(name);\n\t\t}\n\t});\n\tif (appElement) {\n\t\tif (!isAutoBootstrapAllowed) {\n\t\t\twindow.console.error(\n\t\t\t\t\"Angular: disabling automatic bootstrap. <script> protocol indicates \" +\n\t\t\t\t\t\"an extension, document.location.href does not match.\"\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tconfig.strictDi = getNgAttribute(appElement, \"strict-di\") !== null;\n\t\tbootstrap(appElement, module ? [module] : [], config);\n\t}\n}\n\n/**\n * @ngdoc function\n * @name angular.bootstrap\n * @module ng\n * @description\n * Use this function to manually start up angular application.\n *\n * For more information, see the {@link guide/bootstrap Bootstrap guide}.\n *\n * Angular will detect if it has been loaded into the browser more than once and only allow the\n * first loaded script to be bootstrapped and will report a warning to the browser console for\n * each of the subsequent scripts. This prevents strange results in applications, where otherwise\n * multiple instances of Angular try to work on the DOM.\n *\n * <div class=\"alert alert-warning\">\n * **Note:** Protractor based end-to-end tests cannot use this function to bootstrap manually.\n * They must use {@link ng.directive:ngApp ngApp}.\n * </div>\n *\n * <div class=\"alert alert-warning\">\n * **Note:** Do not bootstrap the app on an element with a directive that uses {@link ng.$compile#transclusion transclusion},\n * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and {@link ngRoute.ngView `ngView`}.\n * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},\n * causing animations to stop working and making the injector inaccessible from outside the app.\n * </div>\n *\n * ```html\n * <!doctype html>\n * <html>\n * <body>\n * <div ng-controller=\"WelcomeController\">\n *   {{greeting}}\n * </div>\n *\n * <script src=\"angular.js\"></script>\n * <script>\n *   var app = angular.module('demo', [])\n *   .controller('WelcomeController', function($scope) {\n *       $scope.greeting = 'Welcome!';\n *   });\n *   angular.bootstrap(document, ['demo']);\n * </script>\n * </body>\n * </html>\n * ```\n *\n * @param {DOMElement} element DOM element which is the root of angular application.\n * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.\n *     Each item in the array should be the name of a predefined module or a (DI annotated)\n *     function that will be invoked by the injector as a `config` block.\n *     See: {@link angular.module modules}\n * @param {Object=} config an object for defining configuration options for the application. The\n *     following keys are supported:\n *\n * * `strictDi` - disable automatic function annotation for the application. This is meant to\n *   assist in finding bugs which break minified code. Defaults to `false`.\n *\n * @returns {auto.$injector} Returns the newly created injector for this app.\n */\nfunction bootstrap(element, modules, config) {\n\tif (!isObject(config)) config = {};\n\tvar defaultConfig = {\n\t\tstrictDi: false,\n\t};\n\tconfig = extend(defaultConfig, config);\n\tvar doBootstrap = function () {\n\t\telement = jqLite(element);\n\n\t\tif (element.injector()) {\n\t\t\tvar tag =\n\t\t\t\telement[0] === window.document ? \"document\" : startingTag(element);\n\t\t\t// Encode angle brackets to prevent input from being sanitized to empty string #8683.\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"btstrpd\",\n\t\t\t\t\"App already bootstrapped with this element '{0}'\",\n\t\t\t\ttag.replace(/</, \"&lt;\").replace(/>/, \"&gt;\")\n\t\t\t);\n\t\t}\n\n\t\tmodules = modules || [];\n\t\tmodules.unshift([\n\t\t\t\"$provide\",\n\t\t\tfunction ($provide) {\n\t\t\t\t$provide.value(\"$rootElement\", element);\n\t\t\t},\n\t\t]);\n\n\t\tif (config.debugInfoEnabled) {\n\t\t\t// Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.\n\t\t\tmodules.push([\n\t\t\t\t\"$compileProvider\",\n\t\t\t\tfunction ($compileProvider) {\n\t\t\t\t\t$compileProvider.debugInfoEnabled(true);\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tmodules.unshift(\"ng\");\n\t};\n\n\tvar NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;\n\tvar NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;\n\n\tif (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {\n\t\tconfig.debugInfoEnabled = true;\n\t\twindow.name = window.name.replace(NG_ENABLE_DEBUG_INFO, \"\");\n\t}\n\n\tif (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {\n\t\treturn doBootstrap();\n\t}\n\n\twindow.name = window.name.replace(NG_DEFER_BOOTSTRAP, \"\");\n\tangular.resumeBootstrap = function (extraModules) {\n\t\tforEach(extraModules, function (module) {\n\t\t\tmodules.push(module);\n\t\t});\n\t\treturn doBootstrap();\n\t};\n\n\tif (isFunction(angular.resumeDeferredBootstrap)) {\n\t\tangular.resumeDeferredBootstrap();\n\t}\n}\n\n/**\n * @ngdoc function\n * @name angular.reloadWithDebugInfo\n * @module ng\n * @description\n * Use this function to reload the current application with debug information turned on.\n * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.\n *\n * See {@link ng.$compileProvider#debugInfoEnabled} for more.\n */\nfunction reloadWithDebugInfo() {\n\twindow.name = \"NG_ENABLE_DEBUG_INFO!\" + window.name;\n\twindow.location.reload();\n}\n\n/**\n * @name angular.getTestability\n * @module ng\n * @description\n * Get the testability service for the instance of Angular on the given\n * element.\n * @param {DOMElement} element DOM element which is the root of angular application.\n */\nfunction getTestability(rootElement) {\n\tvar injector = angular.element(rootElement).injector();\n\tif (!injector) {\n\t\tthrow ngMinErr(\n\t\t\t\"test\",\n\t\t\t\"no injector found for element argument to getTestability\"\n\t\t);\n\t}\n\treturn injector.get(\"$$testability\");\n}\n\nvar SNAKE_CASE_REGEXP = /[A-Z]/g;\nfunction snake_case(name, separator) {\n\tseparator = separator || \"_\";\n\treturn name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {\n\t\treturn (pos ? separator : \"\") + letter.toLowerCase();\n\t});\n}\n\nvar bindJQueryFired = false;\nfunction bindJQuery() {\n\tvar originalCleanData;\n\n\tif (bindJQueryFired) {\n\t\treturn;\n\t}\n\n\t// bind to jQuery if present;\n\tvar jqName = jq();\n\tjQuery = isUndefined(jqName)\n\t\t? window.jQuery // use jQuery (if present)\n\t\t: !jqName\n\t\t? undefined // use jqLite\n\t\t: window[jqName]; // use jQuery specified by `ngJq`\n\n\t// Use jQuery if it exists with proper functionality, otherwise default to us.\n\t// Angular 1.2+ requires jQuery 1.7+ for on()/off() support.\n\t// Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older\n\t// versions. It will not work for sure with jQuery <1.7, though.\n\tif (jQuery && jQuery.fn.on) {\n\t\tjqLite = jQuery;\n\t\textend(jQuery.fn, {\n\t\t\tscope: JQLitePrototype.scope,\n\t\t\tisolateScope: JQLitePrototype.isolateScope,\n\t\t\tcontroller: JQLitePrototype.controller,\n\t\t\tinjector: JQLitePrototype.injector,\n\t\t\tinheritedData: JQLitePrototype.inheritedData,\n\t\t});\n\n\t\t// All nodes removed from the DOM via various jQuery APIs like .remove()\n\t\t// are passed through jQuery.cleanData. Monkey-patch this method to fire\n\t\t// the $destroy event on all removed nodes.\n\t\toriginalCleanData = jQuery.cleanData;\n\t\tjQuery.cleanData = function (elems) {\n\t\t\tvar events;\n\t\t\tfor (var i = 0, elem; (elem = elems[i]) != null; i++) {\n\t\t\t\tevents = jQuery._data(elem, \"events\");\n\t\t\t\tif (events && events.$destroy) {\n\t\t\t\t\tjQuery(elem).triggerHandler(\"$destroy\");\n\t\t\t\t}\n\t\t\t}\n\t\t\toriginalCleanData(elems);\n\t\t};\n\t} else {\n\t\tjqLite = JQLite;\n\t}\n\n\tangular.element = jqLite;\n\n\t// Prevent double-proxying.\n\tbindJQueryFired = true;\n}\n\n/**\n * throw error if the argument is falsy.\n */\nfunction assertArg(arg, name, reason) {\n\tif (!arg) {\n\t\tthrow ngMinErr(\n\t\t\t\"areq\",\n\t\t\t\"Argument '{0}' is {1}\",\n\t\t\tname || \"?\",\n\t\t\treason || \"required\"\n\t\t);\n\t}\n\treturn arg;\n}\n\nfunction assertArgFn(arg, name, acceptArrayAnnotation) {\n\tif (acceptArrayAnnotation && isArray(arg)) {\n\t\targ = arg[arg.length - 1];\n\t}\n\n\tassertArg(\n\t\tisFunction(arg),\n\t\tname,\n\t\t\"not a function, got \" +\n\t\t\t(arg && typeof arg === \"object\"\n\t\t\t\t? arg.constructor.name || \"Object\"\n\t\t\t\t: typeof arg)\n\t);\n\treturn arg;\n}\n\n/**\n * throw error if the name given is hasOwnProperty\n * @param  {String} name    the name to test\n * @param  {String} context the context in which the name is used, such as module or directive\n */\nfunction assertNotHasOwnProperty(name, context) {\n\tif (name === \"hasOwnProperty\") {\n\t\tthrow ngMinErr(\n\t\t\t\"badname\",\n\t\t\t\"hasOwnProperty is not a valid {0} name\",\n\t\t\tcontext\n\t\t);\n\t}\n}\n\n/**\n * Return the value accessible from the object by path. Any undefined traversals are ignored\n * @param {Object} obj starting object\n * @param {String} path path to traverse\n * @param {boolean} [bindFnToScope=true]\n * @returns {Object} value as accessible by path\n */\n//TODO(misko): this function needs to be removed\nfunction getter(obj, path, bindFnToScope) {\n\tif (!path) return obj;\n\tvar keys = path.split(\".\");\n\tvar key;\n\tvar lastInstance = obj;\n\tvar len = keys.length;\n\n\tfor (var i = 0; i < len; i++) {\n\t\tkey = keys[i];\n\t\tif (obj) {\n\t\t\tobj = (lastInstance = obj)[key];\n\t\t}\n\t}\n\tif (!bindFnToScope && isFunction(obj)) {\n\t\treturn bind(lastInstance, obj);\n\t}\n\treturn obj;\n}\n\n/**\n * Return the DOM siblings between the first and last node in the given array.\n * @param {Array} array like object\n * @returns {Array} the inputted object or a jqLite collection containing the nodes\n */\nfunction getBlockNodes(nodes) {\n\t// TODO(perf): update `nodes` instead of creating a new object?\n\tvar node = nodes[0];\n\tvar endNode = nodes[nodes.length - 1];\n\tvar blockNodes;\n\n\tfor (var i = 1; node !== endNode && (node = node.nextSibling); i++) {\n\t\tif (blockNodes || nodes[i] !== node) {\n\t\t\tif (!blockNodes) {\n\t\t\t\tblockNodes = jqLite(slice.call(nodes, 0, i));\n\t\t\t}\n\t\t\tblockNodes.push(node);\n\t\t}\n\t}\n\n\treturn blockNodes || nodes;\n}\n\n/**\n * Creates a new object without a prototype. This object is useful for lookup without having to\n * guard against prototypically inherited properties via hasOwnProperty.\n *\n * Related micro-benchmarks:\n * - http://jsperf.com/object-create2\n * - http://jsperf.com/proto-map-lookup/2\n * - http://jsperf.com/for-in-vs-object-keys2\n *\n * @returns {Object}\n */\nfunction createMap() {\n\treturn Object.create(null);\n}\n\nfunction stringify(value) {\n\tif (value == null) {\n\t\t// null || undefined\n\t\treturn \"\";\n\t}\n\tswitch (typeof value) {\n\t\tcase \"string\":\n\t\t\tbreak;\n\t\tcase \"number\":\n\t\t\tvalue = \"\" + value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (hasCustomToString(value) && !isArray(value) && !isDate(value)) {\n\t\t\t\tvalue = value.toString();\n\t\t\t} else {\n\t\t\t\tvalue = toJson(value);\n\t\t\t}\n\t}\n\n\treturn value;\n}\n\n/* global toDebugString: true */\n\nfunction serializeObject(obj) {\n\tvar seen = [];\n\n\treturn JSON.stringify(obj, function (key, val) {\n\t\tval = toJsonReplacer(key, val);\n\t\tif (isObject(val)) {\n\t\t\tif (seen.indexOf(val) >= 0) return \"...\";\n\n\t\t\tseen.push(val);\n\t\t}\n\t\treturn val;\n\t});\n}\n\nfunction toDebugString(obj) {\n\tif (typeof obj === \"function\") {\n\t\treturn obj.toString().replace(/ \\{[\\s\\S]*$/, \"\");\n\t} else if (isUndefined(obj)) {\n\t\treturn \"undefined\";\n\t} else if (typeof obj !== \"string\") {\n\t\treturn serializeObject(obj);\n\t}\n\treturn obj;\n}\n\n/**\n * @description\n *\n * This object provides a utility for producing rich Error messages within\n * Angular. It can be called as follows:\n *\n * var exampleMinErr = minErr('example');\n * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);\n *\n * The above creates an instance of minErr in the example namespace. The\n * resulting error will have a namespaced error code of example.one.  The\n * resulting error will replace {0} with the value of foo, and {1} with the\n * value of bar. The object is not restricted in the number of arguments it can\n * take.\n *\n * If fewer arguments are specified than necessary for interpolation, the extra\n * interpolation markers will be preserved in the final string.\n *\n * Since data will be parsed statically during a build step, some restrictions\n * are applied with respect to how minErr instances are created and called.\n * Instances should have names of the form namespaceMinErr for a minErr created\n * using minErr('namespace') . Error codes, namespaces and template strings\n * should all be static strings, not variables or general expressions.\n *\n * @param {string} module The namespace to use for the new minErr instance.\n * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning\n *   error from returned function, for cases when a particular type of error is useful.\n * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance\n */\n\nfunction minErr(module, ErrorConstructor) {\n\tErrorConstructor = ErrorConstructor || Error;\n\treturn function () {\n\t\tvar SKIP_INDEXES = 2;\n\n\t\tvar templateArgs = arguments,\n\t\t\tcode = templateArgs[0],\n\t\t\tmessage = \"[\" + (module ? module + \":\" : \"\") + code + \"] \",\n\t\t\ttemplate = templateArgs[1],\n\t\t\tparamPrefix,\n\t\t\ti;\n\n\t\tmessage += template.replace(/\\{\\d+\\}/g, function (match) {\n\t\t\tvar index = +match.slice(1, -1),\n\t\t\t\tshiftedIndex = index + SKIP_INDEXES;\n\n\t\t\tif (shiftedIndex < templateArgs.length) {\n\t\t\t\treturn toDebugString(templateArgs[shiftedIndex]);\n\t\t\t}\n\n\t\t\treturn match;\n\t\t});\n\n\t\tmessage +=\n\t\t\t'\\nhttp://errors.angularjs.org/\"NG_VERSION_FULL\"/' +\n\t\t\t(module ? module + \"/\" : \"\") +\n\t\t\tcode;\n\n\t\tfor (\n\t\t\ti = SKIP_INDEXES, paramPrefix = \"?\";\n\t\t\ti < templateArgs.length;\n\t\t\ti++, paramPrefix = \"&\"\n\t\t) {\n\t\t\tmessage +=\n\t\t\t\tparamPrefix +\n\t\t\t\t\"p\" +\n\t\t\t\t(i - SKIP_INDEXES) +\n\t\t\t\t\"=\" +\n\t\t\t\tencodeURIComponent(toDebugString(templateArgs[i]));\n\t\t}\n\n\t\treturn new ErrorConstructor(message);\n\t};\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $parseMinErr = minErr(\"$parse\");\n\nvar objectValueOf = {}.constructor.prototype.valueOf;\n\n// Sandboxing Angular Expressions\n// ------------------------------\n// Angular expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by\n// various means such as obtaining a reference to native JS functions like the Function constructor.\n//\n// As an example, consider the following Angular expression:\n//\n//   {}.toString.constructor('alert(\"evil JS code\")')\n//\n// It is important to realize that if you create an expression from a string that contains user provided\n// content then it is possible that your application contains a security vulnerability to an XSS style attack.\n//\n// See https://docs.angularjs.org/guide/security\n\nfunction getStringValue(name) {\n\t// Property names must be strings. This means that non-string objects cannot be used\n\t// as keys in an object. Any non-string object, including a number, is typecasted\n\t// into a string via the toString method.\n\t// -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names\n\t//\n\t// So, to ensure that we are checking the same `name` that JavaScript would use, we cast it\n\t// to a string. It's not always possible. If `name` is an object and its `toString` method is\n\t// 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:\n\t//\n\t// TypeError: Cannot convert object to primitive value\n\t//\n\t// For performance reasons, we don't catch this error here and allow it to propagate up the call\n\t// stack. Note that you'll get the same error in JavaScript if you try to access a property using\n\t// such a 'broken' object as a key.\n\treturn name + \"\";\n}\n\nvar OPERATORS = createMap();\nforEach(\n\t\"+ - * / % === !== == != < > <= >= && || ! = |\".split(\" \"),\n\tfunction (operator) {\n\t\tOPERATORS[operator] = true;\n\t}\n);\nvar ESCAPE = {\n\tn: \"\\n\",\n\tf: \"\\f\",\n\tr: \"\\r\",\n\tt: \"\\t\",\n\tv: \"\\v\",\n\t\"'\": \"'\",\n\t'\"': '\"',\n};\n\n/////////////////////////////////////////\n\n/**\n * @constructor\n */\nvar Lexer = function Lexer(options) {\n\tthis.options = options;\n};\n\nLexer.prototype = {\n\tconstructor: Lexer,\n\n\tlex: function (text) {\n\t\tthis.text = text;\n\t\tthis.index = 0;\n\t\tthis.tokens = [];\n\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.text.charAt(this.index);\n\t\t\tif (ch === '\"' || ch === \"'\") {\n\t\t\t\tthis.readString(ch);\n\t\t\t} else if (\n\t\t\t\tthis.isNumber(ch) ||\n\t\t\t\t(ch === \".\" && this.isNumber(this.peek()))\n\t\t\t) {\n\t\t\t\tthis.readNumber();\n\t\t\t} else if (this.isIdentifierStart(this.peekMultichar())) {\n\t\t\t\tthis.readIdent();\n\t\t\t} else if (this.is(ch, \"(){}[].,;:?\")) {\n\t\t\t\tthis.tokens.push({ index: this.index, text: ch });\n\t\t\t\tthis.index++;\n\t\t\t} else if (this.isWhitespace(ch)) {\n\t\t\t\tthis.index++;\n\t\t\t} else {\n\t\t\t\tvar ch2 = ch + this.peek();\n\t\t\t\tvar ch3 = ch2 + this.peek(2);\n\t\t\t\tvar op1 = OPERATORS[ch];\n\t\t\t\tvar op2 = OPERATORS[ch2];\n\t\t\t\tvar op3 = OPERATORS[ch3];\n\t\t\t\tif (op1 || op2 || op3) {\n\t\t\t\t\tvar token = op3 ? ch3 : op2 ? ch2 : ch;\n\t\t\t\t\tthis.tokens.push({ index: this.index, text: token, operator: true });\n\t\t\t\t\tthis.index += token.length;\n\t\t\t\t} else {\n\t\t\t\t\tthis.throwError(\n\t\t\t\t\t\t\"Unexpected next character \",\n\t\t\t\t\t\tthis.index,\n\t\t\t\t\t\tthis.index + 1\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.tokens;\n\t},\n\n\tis: function (ch, chars) {\n\t\treturn chars.indexOf(ch) !== -1;\n\t},\n\n\tpeek: function (i) {\n\t\tvar num = i || 1;\n\t\treturn this.index + num < this.text.length\n\t\t\t? this.text.charAt(this.index + num)\n\t\t\t: false;\n\t},\n\n\tisNumber: function (ch) {\n\t\treturn \"0\" <= ch && ch <= \"9\" && typeof ch === \"string\";\n\t},\n\n\tisWhitespace: function (ch) {\n\t\t// IE treats non-breaking space as \\u00A0\n\t\treturn (\n\t\t\tch === \" \" ||\n\t\t\tch === \"\\r\" ||\n\t\t\tch === \"\\t\" ||\n\t\t\tch === \"\\n\" ||\n\t\t\tch === \"\\v\" ||\n\t\t\tch === \"\\u00A0\"\n\t\t);\n\t},\n\n\tisIdentifierStart: function (ch) {\n\t\treturn this.options.isIdentifierStart\n\t\t\t? this.options.isIdentifierStart(ch, this.codePointAt(ch))\n\t\t\t: this.isValidIdentifierStart(ch);\n\t},\n\n\tisValidIdentifierStart: function (ch) {\n\t\treturn (\n\t\t\t(\"a\" <= ch && ch <= \"z\") ||\n\t\t\t(\"A\" <= ch && ch <= \"Z\") ||\n\t\t\t\"_\" === ch ||\n\t\t\tch === \"$\"\n\t\t);\n\t},\n\n\tisIdentifierContinue: function (ch) {\n\t\treturn this.options.isIdentifierContinue\n\t\t\t? this.options.isIdentifierContinue(ch, this.codePointAt(ch))\n\t\t\t: this.isValidIdentifierContinue(ch);\n\t},\n\n\tisValidIdentifierContinue: function (ch, cp) {\n\t\treturn this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);\n\t},\n\n\tcodePointAt: function (ch) {\n\t\tif (ch.length === 1) return ch.charCodeAt(0);\n\t\t// eslint-disable-next-line no-bitwise\n\t\treturn (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35fdc00;\n\t},\n\n\tpeekMultichar: function () {\n\t\tvar ch = this.text.charAt(this.index);\n\t\tvar peek = this.peek();\n\t\tif (!peek) {\n\t\t\treturn ch;\n\t\t}\n\t\tvar cp1 = ch.charCodeAt(0);\n\t\tvar cp2 = peek.charCodeAt(0);\n\t\tif (cp1 >= 0xd800 && cp1 <= 0xdbff && cp2 >= 0xdc00 && cp2 <= 0xdfff) {\n\t\t\treturn ch + peek;\n\t\t}\n\t\treturn ch;\n\t},\n\n\tisExpOperator: function (ch) {\n\t\treturn ch === \"-\" || ch === \"+\" || this.isNumber(ch);\n\t},\n\n\tthrowError: function (error, start, end) {\n\t\tend = end || this.index;\n\t\tvar colStr = isDefined(start)\n\t\t\t? \"s \" +\n\t\t\t  start +\n\t\t\t  \"-\" +\n\t\t\t  this.index +\n\t\t\t  \" [\" +\n\t\t\t  this.text.substring(start, end) +\n\t\t\t  \"]\"\n\t\t\t: \" \" + end;\n\t\tthrow $parseMinErr(\n\t\t\t\"lexerr\",\n\t\t\t\"Lexer Error: {0} at column{1} in expression [{2}].\",\n\t\t\terror,\n\t\t\tcolStr,\n\t\t\tthis.text\n\t\t);\n\t},\n\n\treadNumber: function () {\n\t\tvar number = \"\";\n\t\tvar start = this.index;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = lowercase(this.text.charAt(this.index));\n\t\t\tif (ch === \".\" || this.isNumber(ch)) {\n\t\t\t\tnumber += ch;\n\t\t\t} else {\n\t\t\t\tvar peekCh = this.peek();\n\t\t\t\tif (ch === \"e\" && this.isExpOperator(peekCh)) {\n\t\t\t\t\tnumber += ch;\n\t\t\t\t} else if (\n\t\t\t\t\tthis.isExpOperator(ch) &&\n\t\t\t\t\tpeekCh &&\n\t\t\t\t\tthis.isNumber(peekCh) &&\n\t\t\t\t\tnumber.charAt(number.length - 1) === \"e\"\n\t\t\t\t) {\n\t\t\t\t\tnumber += ch;\n\t\t\t\t} else if (\n\t\t\t\t\tthis.isExpOperator(ch) &&\n\t\t\t\t\t(!peekCh || !this.isNumber(peekCh)) &&\n\t\t\t\t\tnumber.charAt(number.length - 1) === \"e\"\n\t\t\t\t) {\n\t\t\t\t\tthis.throwError(\"Invalid exponent\");\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.index++;\n\t\t}\n\t\tthis.tokens.push({\n\t\t\tindex: start,\n\t\t\ttext: number,\n\t\t\tconstant: true,\n\t\t\tvalue: Number(number),\n\t\t});\n\t},\n\n\treadIdent: function () {\n\t\tvar start = this.index;\n\t\tthis.index += this.peekMultichar().length;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.peekMultichar();\n\t\t\tif (!this.isIdentifierContinue(ch)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.index += ch.length;\n\t\t}\n\t\tthis.tokens.push({\n\t\t\tindex: start,\n\t\t\ttext: this.text.slice(start, this.index),\n\t\t\tidentifier: true,\n\t\t});\n\t},\n\n\treadString: function (quote) {\n\t\tvar start = this.index;\n\t\tthis.index++;\n\t\tvar string = \"\";\n\t\tvar rawString = quote;\n\t\tvar escape = false;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.text.charAt(this.index);\n\t\t\trawString += ch;\n\t\t\tif (escape) {\n\t\t\t\tif (ch === \"u\") {\n\t\t\t\t\tvar hex = this.text.substring(this.index + 1, this.index + 5);\n\t\t\t\t\tif (!hex.match(/[\\da-f]{4}/i)) {\n\t\t\t\t\t\tthis.throwError(\"Invalid unicode escape [\\\\u\" + hex + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.index += 4;\n\t\t\t\t\tstring += String.fromCharCode(parseInt(hex, 16));\n\t\t\t\t} else {\n\t\t\t\t\tvar rep = ESCAPE[ch];\n\t\t\t\t\tstring = string + (rep || ch);\n\t\t\t\t}\n\t\t\t\tescape = false;\n\t\t\t} else if (ch === \"\\\\\") {\n\t\t\t\tescape = true;\n\t\t\t} else if (ch === quote) {\n\t\t\t\tthis.index++;\n\t\t\t\tthis.tokens.push({\n\t\t\t\t\tindex: start,\n\t\t\t\t\ttext: rawString,\n\t\t\t\t\tconstant: true,\n\t\t\t\t\tvalue: string,\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tstring += ch;\n\t\t\t}\n\t\t\tthis.index++;\n\t\t}\n\t\tthis.throwError(\"Unterminated quote\", start);\n\t},\n};\n\nvar AST = function AST(lexer, options) {\n\tthis.lexer = lexer;\n\tthis.options = options;\n};\n\nAST.Program = \"Program\";\nAST.ExpressionStatement = \"ExpressionStatement\";\nAST.AssignmentExpression = \"AssignmentExpression\";\nAST.ConditionalExpression = \"ConditionalExpression\";\nAST.LogicalExpression = \"LogicalExpression\";\nAST.BinaryExpression = \"BinaryExpression\";\nAST.UnaryExpression = \"UnaryExpression\";\nAST.CallExpression = \"CallExpression\";\nAST.MemberExpression = \"MemberExpression\";\nAST.Identifier = \"Identifier\";\nAST.Literal = \"Literal\";\nAST.ArrayExpression = \"ArrayExpression\";\nAST.Property = \"Property\";\nAST.ObjectExpression = \"ObjectExpression\";\nAST.ThisExpression = \"ThisExpression\";\nAST.LocalsExpression = \"LocalsExpression\";\n\n// Internal use only\nAST.NGValueParameter = \"NGValueParameter\";\n\nAST.prototype = {\n\tast: function (text) {\n\t\tthis.text = text;\n\t\tthis.tokens = this.lexer.lex(text);\n\n\t\tvar value = this.program();\n\n\t\tif (this.tokens.length !== 0) {\n\t\t\tthis.throwError(\"is an unexpected token\", this.tokens[0]);\n\t\t}\n\n\t\treturn value;\n\t},\n\n\tprogram: function () {\n\t\tvar body = [];\n\t\twhile (true) {\n\t\t\tif (this.tokens.length > 0 && !this.peek(\"}\", \")\", \";\", \"]\"))\n\t\t\t\tbody.push(this.expressionStatement());\n\t\t\tif (!this.expect(\";\")) {\n\t\t\t\treturn { type: AST.Program, body: body };\n\t\t\t}\n\t\t}\n\t},\n\n\texpressionStatement: function () {\n\t\treturn { type: AST.ExpressionStatement, expression: this.filterChain() };\n\t},\n\n\tfilterChain: function () {\n\t\tvar left = this.expression();\n\t\twhile (this.expect(\"|\")) {\n\t\t\tleft = this.filter(left);\n\t\t}\n\t\treturn left;\n\t},\n\n\texpression: function () {\n\t\treturn this.assignment();\n\t},\n\n\tassignment: function () {\n\t\tvar result = this.ternary();\n\t\tif (this.expect(\"=\")) {\n\t\t\tif (!isAssignable(result)) {\n\t\t\t\tthrow $parseMinErr(\"lval\", \"Trying to assign a value to a non l-value\");\n\t\t\t}\n\n\t\t\tresult = {\n\t\t\t\ttype: AST.AssignmentExpression,\n\t\t\t\tleft: result,\n\t\t\t\tright: this.assignment(),\n\t\t\t\toperator: \"=\",\n\t\t\t};\n\t\t}\n\t\treturn result;\n\t},\n\n\tternary: function () {\n\t\tvar test = this.logicalOR();\n\t\tvar alternate;\n\t\tvar consequent;\n\t\tif (this.expect(\"?\")) {\n\t\t\talternate = this.expression();\n\t\t\tif (this.consume(\":\")) {\n\t\t\t\tconsequent = this.expression();\n\t\t\t\treturn {\n\t\t\t\t\ttype: AST.ConditionalExpression,\n\t\t\t\t\ttest: test,\n\t\t\t\t\talternate: alternate,\n\t\t\t\t\tconsequent: consequent,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn test;\n\t},\n\n\tlogicalOR: function () {\n\t\tvar left = this.logicalAND();\n\t\twhile (this.expect(\"||\")) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.LogicalExpression,\n\t\t\t\toperator: \"||\",\n\t\t\t\tleft: left,\n\t\t\t\tright: this.logicalAND(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tlogicalAND: function () {\n\t\tvar left = this.equality();\n\t\twhile (this.expect(\"&&\")) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.LogicalExpression,\n\t\t\t\toperator: \"&&\",\n\t\t\t\tleft: left,\n\t\t\t\tright: this.equality(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tequality: function () {\n\t\tvar left = this.relational();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"==\", \"!=\", \"===\", \"!==\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.relational(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\trelational: function () {\n\t\tvar left = this.additive();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"<\", \">\", \"<=\", \">=\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.additive(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tadditive: function () {\n\t\tvar left = this.multiplicative();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"+\", \"-\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.multiplicative(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tmultiplicative: function () {\n\t\tvar left = this.unary();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"*\", \"/\", \"%\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.unary(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tunary: function () {\n\t\tvar token;\n\t\tif ((token = this.expect(\"+\", \"-\", \"!\"))) {\n\t\t\treturn {\n\t\t\t\ttype: AST.UnaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tprefix: true,\n\t\t\t\targument: this.unary(),\n\t\t\t};\n\t\t} else {\n\t\t\treturn this.primary();\n\t\t}\n\t},\n\n\tprimary: function () {\n\t\tvar primary;\n\t\tif (this.expect(\"(\")) {\n\t\t\tprimary = this.filterChain();\n\t\t\tthis.consume(\")\");\n\t\t} else if (this.expect(\"[\")) {\n\t\t\tprimary = this.arrayDeclaration();\n\t\t} else if (this.expect(\"{\")) {\n\t\t\tprimary = this.object();\n\t\t} else if (this.selfReferential.hasOwnProperty(this.peek().text)) {\n\t\t\tprimary = copy(this.selfReferential[this.consume().text]);\n\t\t} else if (this.options.literals.hasOwnProperty(this.peek().text)) {\n\t\t\tprimary = {\n\t\t\t\ttype: AST.Literal,\n\t\t\t\tvalue: this.options.literals[this.consume().text],\n\t\t\t};\n\t\t} else if (this.peek().identifier) {\n\t\t\tprimary = this.identifier();\n\t\t} else if (this.peek().constant) {\n\t\t\tprimary = this.constant();\n\t\t} else {\n\t\t\tthis.throwError(\"not a primary expression\", this.peek());\n\t\t}\n\n\t\tvar next;\n\t\twhile ((next = this.expect(\"(\", \"[\", \".\"))) {\n\t\t\tif (next.text === \"(\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.CallExpression,\n\t\t\t\t\tcallee: primary,\n\t\t\t\t\targuments: this.parseArguments(),\n\t\t\t\t};\n\t\t\t\tthis.consume(\")\");\n\t\t\t} else if (next.text === \"[\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.MemberExpression,\n\t\t\t\t\tobject: primary,\n\t\t\t\t\tproperty: this.expression(),\n\t\t\t\t\tcomputed: true,\n\t\t\t\t};\n\t\t\t\tthis.consume(\"]\");\n\t\t\t} else if (next.text === \".\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.MemberExpression,\n\t\t\t\t\tobject: primary,\n\t\t\t\t\tproperty: this.identifier(),\n\t\t\t\t\tcomputed: false,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.throwError(\"IMPOSSIBLE\");\n\t\t\t}\n\t\t}\n\t\treturn primary;\n\t},\n\n\tfilter: function (baseExpression) {\n\t\tvar args = [baseExpression];\n\t\tvar result = {\n\t\t\ttype: AST.CallExpression,\n\t\t\tcallee: this.identifier(),\n\t\t\targuments: args,\n\t\t\tfilter: true,\n\t\t};\n\n\t\twhile (this.expect(\":\")) {\n\t\t\targs.push(this.expression());\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tparseArguments: function () {\n\t\tvar args = [];\n\t\tif (this.peekToken().text !== \")\") {\n\t\t\tdo {\n\t\t\t\targs.push(this.filterChain());\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\treturn args;\n\t},\n\n\tidentifier: function () {\n\t\tvar token = this.consume();\n\t\tif (!token.identifier) {\n\t\t\tthis.throwError(\"is not a valid identifier\", token);\n\t\t}\n\t\treturn { type: AST.Identifier, name: token.text };\n\t},\n\n\tconstant: function () {\n\t\t// TODO check that it is a constant\n\t\treturn { type: AST.Literal, value: this.consume().value };\n\t},\n\n\tarrayDeclaration: function () {\n\t\tvar elements = [];\n\t\tif (this.peekToken().text !== \"]\") {\n\t\t\tdo {\n\t\t\t\tif (this.peek(\"]\")) {\n\t\t\t\t\t// Support trailing commas per ES5.1.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telements.push(this.expression());\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\tthis.consume(\"]\");\n\n\t\treturn { type: AST.ArrayExpression, elements: elements };\n\t},\n\n\tobject: function () {\n\t\tvar properties = [],\n\t\t\tproperty;\n\t\tif (this.peekToken().text !== \"}\") {\n\t\t\tdo {\n\t\t\t\tif (this.peek(\"}\")) {\n\t\t\t\t\t// Support trailing commas per ES5.1.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tproperty = { type: AST.Property, kind: \"init\" };\n\t\t\t\tif (this.peek().constant) {\n\t\t\t\t\tproperty.key = this.constant();\n\t\t\t\t\tproperty.computed = false;\n\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t} else if (this.peek().identifier) {\n\t\t\t\t\tproperty.key = this.identifier();\n\t\t\t\t\tproperty.computed = false;\n\t\t\t\t\tif (this.peek(\":\")) {\n\t\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproperty.value = property.key;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.peek(\"[\")) {\n\t\t\t\t\tthis.consume(\"[\");\n\t\t\t\t\tproperty.key = this.expression();\n\t\t\t\t\tthis.consume(\"]\");\n\t\t\t\t\tproperty.computed = true;\n\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t} else {\n\t\t\t\t\tthis.throwError(\"invalid key\", this.peek());\n\t\t\t\t}\n\t\t\t\tproperties.push(property);\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\tthis.consume(\"}\");\n\n\t\treturn { type: AST.ObjectExpression, properties: properties };\n\t},\n\n\tthrowError: function (msg, token) {\n\t\tthrow $parseMinErr(\n\t\t\t\"syntax\",\n\t\t\t\"Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].\",\n\t\t\ttoken.text,\n\t\t\tmsg,\n\t\t\ttoken.index + 1,\n\t\t\tthis.text,\n\t\t\tthis.text.substring(token.index)\n\t\t);\n\t},\n\n\tconsume: function (e1) {\n\t\tif (this.tokens.length === 0) {\n\t\t\tthrow $parseMinErr(\n\t\t\t\t\"ueoe\",\n\t\t\t\t\"Unexpected end of expression: {0}\",\n\t\t\t\tthis.text\n\t\t\t);\n\t\t}\n\n\t\tvar token = this.expect(e1);\n\t\tif (!token) {\n\t\t\tthis.throwError(\"is unexpected, expecting [\" + e1 + \"]\", this.peek());\n\t\t}\n\t\treturn token;\n\t},\n\n\tpeekToken: function () {\n\t\tif (this.tokens.length === 0) {\n\t\t\tthrow $parseMinErr(\n\t\t\t\t\"ueoe\",\n\t\t\t\t\"Unexpected end of expression: {0}\",\n\t\t\t\tthis.text\n\t\t\t);\n\t\t}\n\t\treturn this.tokens[0];\n\t},\n\n\tpeek: function (e1, e2, e3, e4) {\n\t\treturn this.peekAhead(0, e1, e2, e3, e4);\n\t},\n\n\tpeekAhead: function (i, e1, e2, e3, e4) {\n\t\tif (this.tokens.length > i) {\n\t\t\tvar token = this.tokens[i];\n\t\t\tvar t = token.text;\n\t\t\tif (\n\t\t\t\tt === e1 ||\n\t\t\t\tt === e2 ||\n\t\t\t\tt === e3 ||\n\t\t\t\tt === e4 ||\n\t\t\t\t(!e1 && !e2 && !e3 && !e4)\n\t\t\t) {\n\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\texpect: function (e1, e2, e3, e4) {\n\t\tvar token = this.peek(e1, e2, e3, e4);\n\t\tif (token) {\n\t\t\tthis.tokens.shift();\n\t\t\treturn token;\n\t\t}\n\t\treturn false;\n\t},\n\n\tselfReferential: {\n\t\tthis: { type: AST.ThisExpression },\n\t\t$locals: { type: AST.LocalsExpression },\n\t},\n};\n\nfunction ifDefined(v, d) {\n\treturn typeof v !== \"undefined\" ? v : d;\n}\n\nfunction plusFn(l, r) {\n\tif (typeof l === \"undefined\") return r;\n\tif (typeof r === \"undefined\") return l;\n\treturn l + r;\n}\n\nfunction isStateless($filter, filterName) {\n\tvar fn = $filter(filterName);\n\treturn !fn.$stateful;\n}\n\nfunction findConstantAndWatchExpressions(ast, $filter) {\n\tvar allConstants;\n\tvar argsToWatch;\n\tvar isStatelessFilter;\n\tswitch (ast.type) {\n\t\tcase AST.Program:\n\t\t\tallConstants = true;\n\t\t\tforEach(ast.body, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr.expression, $filter);\n\t\t\t\tallConstants = allConstants && expr.expression.constant;\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tbreak;\n\t\tcase AST.Literal:\n\t\t\tast.constant = true;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t\tcase AST.UnaryExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.argument, $filter);\n\t\t\tast.constant = ast.argument.constant;\n\t\t\tast.toWatch = ast.argument.toWatch;\n\t\t\tbreak;\n\t\tcase AST.BinaryExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);\n\t\t\tbreak;\n\t\tcase AST.LogicalExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = ast.constant ? [] : [ast];\n\t\t\tbreak;\n\t\tcase AST.ConditionalExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.test, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.alternate, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.consequent, $filter);\n\t\t\tast.constant =\n\t\t\t\tast.test.constant && ast.alternate.constant && ast.consequent.constant;\n\t\t\tast.toWatch = ast.constant ? [] : [ast];\n\t\t\tbreak;\n\t\tcase AST.Identifier:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.MemberExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.object, $filter);\n\t\t\tif (ast.computed) {\n\t\t\t\tfindConstantAndWatchExpressions(ast.property, $filter);\n\t\t\t}\n\t\t\tast.constant =\n\t\t\t\tast.object.constant && (!ast.computed || ast.property.constant);\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.CallExpression:\n\t\t\tisStatelessFilter = ast.filter\n\t\t\t\t? isStateless($filter, ast.callee.name)\n\t\t\t\t: false;\n\t\t\tallConstants = isStatelessFilter;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr, $filter);\n\t\t\t\tallConstants = allConstants && expr.constant;\n\t\t\t\tif (!expr.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, expr.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = isStatelessFilter ? argsToWatch : [ast];\n\t\t\tbreak;\n\t\tcase AST.AssignmentExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.ArrayExpression:\n\t\t\tallConstants = true;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr, $filter);\n\t\t\t\tallConstants = allConstants && expr.constant;\n\t\t\t\tif (!expr.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, expr.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = argsToWatch;\n\t\t\tbreak;\n\t\tcase AST.ObjectExpression:\n\t\t\tallConstants = true;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\tfindConstantAndWatchExpressions(property.value, $filter);\n\t\t\t\tallConstants =\n\t\t\t\t\tallConstants && property.value.constant && !property.computed;\n\t\t\t\tif (!property.value.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, property.value.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = argsToWatch;\n\t\t\tbreak;\n\t\tcase AST.ThisExpression:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t\tcase AST.LocalsExpression:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t}\n}\n\nfunction getInputs(body) {\n\tif (body.length !== 1) return;\n\tvar lastExpression = body[0].expression;\n\tvar candidate = lastExpression.toWatch;\n\tif (candidate.length !== 1) return candidate;\n\treturn candidate[0] !== lastExpression ? candidate : undefined;\n}\n\nfunction isAssignable(ast) {\n\treturn ast.type === AST.Identifier || ast.type === AST.MemberExpression;\n}\n\nfunction assignableAST(ast) {\n\tif (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {\n\t\treturn {\n\t\t\ttype: AST.AssignmentExpression,\n\t\t\tleft: ast.body[0].expression,\n\t\t\tright: { type: AST.NGValueParameter },\n\t\t\toperator: \"=\",\n\t\t};\n\t}\n}\n\nfunction isLiteral(ast) {\n\treturn (\n\t\tast.body.length === 0 ||\n\t\t(ast.body.length === 1 &&\n\t\t\t(ast.body[0].expression.type === AST.Literal ||\n\t\t\t\tast.body[0].expression.type === AST.ArrayExpression ||\n\t\t\t\tast.body[0].expression.type === AST.ObjectExpression))\n\t);\n}\n\nfunction isConstant(ast) {\n\treturn ast.constant;\n}\n\nfunction ASTCompiler(astBuilder, $filter) {\n\tthis.astBuilder = astBuilder;\n\tthis.$filter = $filter;\n}\n\nASTCompiler.prototype = {\n\tcompile: function (expression) {\n\t\tvar self = this;\n\t\tvar ast = this.astBuilder.ast(expression);\n\t\tthis.state = {\n\t\t\tnextId: 0,\n\t\t\tfilters: {},\n\t\t\tfn: { vars: [], body: [], own: {} },\n\t\t\tassign: { vars: [], body: [], own: {} },\n\t\t\tinputs: [],\n\t\t};\n\t\tfindConstantAndWatchExpressions(ast, self.$filter);\n\t\tvar extra = \"\";\n\t\tvar assignable;\n\t\tthis.stage = \"assign\";\n\t\tif ((assignable = assignableAST(ast))) {\n\t\t\tthis.state.computing = \"assign\";\n\t\t\tvar result = this.nextId();\n\t\t\tthis.recurse(assignable, result);\n\t\t\tthis.return_(result);\n\t\t\textra = \"fn.assign=\" + this.generateFunction(\"assign\", \"s,v,l\");\n\t\t}\n\t\tvar toWatch = getInputs(ast.body);\n\t\tself.stage = \"inputs\";\n\t\tforEach(toWatch, function (watch, key) {\n\t\t\tvar fnKey = \"fn\" + key;\n\t\t\tself.state[fnKey] = { vars: [], body: [], own: {} };\n\t\t\tself.state.computing = fnKey;\n\t\t\tvar intoId = self.nextId();\n\t\t\tself.recurse(watch, intoId);\n\t\t\tself.return_(intoId);\n\t\t\tself.state.inputs.push(fnKey);\n\t\t\twatch.watchId = key;\n\t\t});\n\t\tthis.state.computing = \"fn\";\n\t\tthis.stage = \"main\";\n\t\tthis.recurse(ast);\n\t\tvar fnString =\n\t\t\t// The build and minification steps remove the string \"use strict\" from the code, but this is done using a regex.\n\t\t\t// This is a workaround for this until we do a better job at only removing the prefix only when we should.\n\t\t\t'\"' +\n\t\t\tthis.USE +\n\t\t\t\" \" +\n\t\t\tthis.STRICT +\n\t\t\t'\";\\n' +\n\t\t\tthis.filterPrefix() +\n\t\t\t\"var fn=\" +\n\t\t\tthis.generateFunction(\"fn\", \"s,l,a,i\") +\n\t\t\textra +\n\t\t\tthis.watchFns() +\n\t\t\t\"return fn;\";\n\t\t// eslint-disable-next-line no-new-func\n\t\tvar fn = new Function(\n\t\t\t\"$filter\",\n\t\t\t\"getStringValue\",\n\t\t\t\"ifDefined\",\n\t\t\t\"plus\",\n\t\t\tfnString\n\t\t)(this.$filter, getStringValue, ifDefined, plusFn);\n\n\t\tthis.state = this.stage = undefined;\n\t\tfn.ast = ast;\n\t\tfn.literal = isLiteral(ast);\n\t\tfn.constant = isConstant(ast);\n\t\treturn fn;\n\t},\n\n\tUSE: \"use\",\n\n\tSTRICT: \"strict\",\n\n\twatchFns: function () {\n\t\tvar result = [];\n\t\tvar fns = this.state.inputs;\n\t\tvar self = this;\n\t\tforEach(fns, function (name) {\n\t\t\tresult.push(\"var \" + name + \"=\" + self.generateFunction(name, \"s\"));\n\t\t});\n\t\tif (fns.length) {\n\t\t\tresult.push(\"fn.inputs=[\" + fns.join(\",\") + \"];\");\n\t\t}\n\t\treturn result.join(\"\");\n\t},\n\n\tgenerateFunction: function (name, params) {\n\t\treturn (\n\t\t\t\"function(\" +\n\t\t\tparams +\n\t\t\t\"){\" +\n\t\t\tthis.varsPrefix(name) +\n\t\t\tthis.body(name) +\n\t\t\t\"};\"\n\t\t);\n\t},\n\n\tfilterPrefix: function () {\n\t\tvar parts = [];\n\t\tvar self = this;\n\t\tforEach(this.state.filters, function (id, filter) {\n\t\t\tparts.push(id + \"=$filter(\" + self.escape(filter) + \")\");\n\t\t});\n\t\tif (parts.length) return \"var \" + parts.join(\",\") + \";\";\n\t\treturn \"\";\n\t},\n\n\tvarsPrefix: function (section) {\n\t\treturn this.state[section].vars.length\n\t\t\t? \"var \" + this.state[section].vars.join(\",\") + \";\"\n\t\t\t: \"\";\n\t},\n\n\tbody: function (section) {\n\t\treturn this.state[section].body.join(\"\");\n\t},\n\n\trecurse: function (\n\t\tast,\n\t\tintoId,\n\t\tnameId,\n\t\trecursionFn,\n\t\tcreate,\n\t\tskipWatchIdCheck\n\t) {\n\t\tvar left,\n\t\t\tright,\n\t\t\tself = this,\n\t\t\targs,\n\t\t\texpression,\n\t\t\tcomputed;\n\t\trecursionFn = recursionFn || noop;\n\t\tif (!skipWatchIdCheck && isDefined(ast.watchId)) {\n\t\t\tintoId = intoId || this.nextId();\n\t\t\tthis.if_(\n\t\t\t\t\"i\",\n\t\t\t\tthis.lazyAssign(intoId, this.computedMember(\"i\", ast.watchId)),\n\t\t\t\tthis.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tswitch (ast.type) {\n\t\t\tcase AST.Program:\n\t\t\t\tforEach(ast.body, function (expression, pos) {\n\t\t\t\t\tself.recurse(\n\t\t\t\t\t\texpression.expression,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tfunction (expr) {\n\t\t\t\t\t\t\tright = expr;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tif (pos !== ast.body.length - 1) {\n\t\t\t\t\t\tself.current().body.push(right, \";\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.return_(right);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase AST.Literal:\n\t\t\t\texpression = this.escape(ast.value);\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.UnaryExpression:\n\t\t\t\tthis.recurse(ast.argument, undefined, undefined, function (expr) {\n\t\t\t\t\tright = expr;\n\t\t\t\t});\n\t\t\t\texpression = ast.operator + \"(\" + this.ifDefined(right, 0) + \")\";\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.BinaryExpression:\n\t\t\t\tthis.recurse(ast.left, undefined, undefined, function (expr) {\n\t\t\t\t\tleft = expr;\n\t\t\t\t});\n\t\t\t\tthis.recurse(ast.right, undefined, undefined, function (expr) {\n\t\t\t\t\tright = expr;\n\t\t\t\t});\n\t\t\t\tif (ast.operator === \"+\") {\n\t\t\t\t\texpression = this.plus(left, right);\n\t\t\t\t} else if (ast.operator === \"-\") {\n\t\t\t\t\texpression =\n\t\t\t\t\t\tthis.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);\n\t\t\t\t} else {\n\t\t\t\t\texpression = \"(\" + left + \")\" + ast.operator + \"(\" + right + \")\";\n\t\t\t\t}\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.LogicalExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(ast.left, intoId);\n\t\t\t\tself.if_(\n\t\t\t\t\tast.operator === \"&&\" ? intoId : self.not(intoId),\n\t\t\t\t\tself.lazyRecurse(ast.right, intoId)\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.ConditionalExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(ast.test, intoId);\n\t\t\t\tself.if_(\n\t\t\t\t\tintoId,\n\t\t\t\t\tself.lazyRecurse(ast.alternate, intoId),\n\t\t\t\t\tself.lazyRecurse(ast.consequent, intoId)\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.Identifier:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tif (nameId) {\n\t\t\t\t\tnameId.context =\n\t\t\t\t\t\tself.stage === \"inputs\"\n\t\t\t\t\t\t\t? \"s\"\n\t\t\t\t\t\t\t: this.assign(\n\t\t\t\t\t\t\t\t\tthis.nextId(),\n\t\t\t\t\t\t\t\t\tthis.getHasOwnProperty(\"l\", ast.name) + \"?l:s\"\n\t\t\t\t\t\t\t  );\n\t\t\t\t\tnameId.computed = false;\n\t\t\t\t\tnameId.name = ast.name;\n\t\t\t\t}\n\t\t\t\tself.if_(\n\t\t\t\t\tself.stage === \"inputs\" ||\n\t\t\t\t\t\tself.not(self.getHasOwnProperty(\"l\", ast.name)),\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.stage === \"inputs\" ||\n\t\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\t\t\"s\",\n\t\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\t\tself.isNull(self.nonComputedMember(\"s\", ast.name)),\n\t\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(\"s\", ast.name)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\t\t\t\tself.isNull(self.nonComputedMember(\"s\", ast.name)),\n\t\t\t\t\t\t\t\t\t\tself.lazyAssign(self.nonComputedMember(\"s\", ast.name), \"{}\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tself.assign(intoId, self.nonComputedMember(\"s\", ast.name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\tintoId &&\n\t\t\t\t\t\tself.lazyAssign(intoId, self.nonComputedMember(\"l\", ast.name))\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.MemberExpression:\n\t\t\t\tleft = (nameId && (nameId.context = this.nextId())) || this.nextId();\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(\n\t\t\t\t\tast.object,\n\t\t\t\t\tleft,\n\t\t\t\t\tundefined,\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tvar member = null;\n\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\tright = self.nextId();\n\t\t\t\t\t\t\tmember = self.computedMember(left, right);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmember = self.nonComputedMember(left, ast.property.name);\n\t\t\t\t\t\t\tright = ast.property.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\tif (ast.property.type === AST.Literal) {\n\t\t\t\t\t\t\t\tself.recurse(ast.property, right);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\tself.notNull(left),\n\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\tself.isNull(member),\n\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(left, right, ast.computed)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\t\t\tif (ast.property.type !== AST.Literal) {\n\t\t\t\t\t\t\t\t\t\tself.recurse(ast.property, right);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\t\tself.if_(self.not(member), self.lazyAssign(member, \"{}\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tself.assign(intoId, member);\n\t\t\t\t\t\t\t\t\tif (nameId) {\n\t\t\t\t\t\t\t\t\t\tnameId.computed = true;\n\t\t\t\t\t\t\t\t\t\tnameId.name = right;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\t\t\t\t\tself.isNull(member),\n\t\t\t\t\t\t\t\t\t\t\tself.lazyAssign(member, \"{}\")\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tself.assign(intoId, member);\n\t\t\t\t\t\t\t\t\tif (nameId) {\n\t\t\t\t\t\t\t\t\t\tnameId.computed = false;\n\t\t\t\t\t\t\t\t\t\tnameId.name = ast.property.name;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.assign(intoId, \"undefined\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t\t},\n\t\t\t\t\t!!create\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase AST.CallExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tif (ast.filter) {\n\t\t\t\t\tright = self.filter(ast.callee.name);\n\t\t\t\t\targs = [];\n\t\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\t\tvar argument = self.nextId();\n\t\t\t\t\t\tself.recurse(expr, argument);\n\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t});\n\t\t\t\t\texpression = right + \".call(\" + right + \",\" + args.join(\",\") + \")\";\n\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t} else {\n\t\t\t\t\tright = self.nextId();\n\t\t\t\t\tleft = {};\n\t\t\t\t\targs = [];\n\t\t\t\t\tself.recurse(ast.callee, right, left, function () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.notNull(right),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\t\t\t\t\tself.recurse(\n\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tfunction (argument) {\n\t\t\t\t\t\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (left.name) {\n\t\t\t\t\t\t\t\t\tvar x = self.member(left.context, left.name, left.computed);\n\t\t\t\t\t\t\t\t\texpression =\n\t\t\t\t\t\t\t\t\t\tx + \".call(\" + [left.context].concat(args).join(\",\") + \")\";\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\texpression = right + \"(\" + args.join(\",\") + \")\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.assign(intoId, \"undefined\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AST.AssignmentExpression:\n\t\t\t\tright = this.nextId();\n\t\t\t\tleft = {};\n\t\t\t\tthis.recurse(\n\t\t\t\t\tast.left,\n\t\t\t\t\tundefined,\n\t\t\t\t\tleft,\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\tself.notNull(left.context),\n\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(left.context, left.name),\n\t\t\t\t\t\t\t\t\tself.isNull(\n\t\t\t\t\t\t\t\t\t\tself.member(left.context, left.name, left.computed)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.recurse(ast.right, right);\n\t\t\t\t\t\t\t\texpression =\n\t\t\t\t\t\t\t\t\tself.member(left.context, left.name, left.computed) +\n\t\t\t\t\t\t\t\t\tast.operator +\n\t\t\t\t\t\t\t\t\tright;\n\t\t\t\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase AST.ArrayExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\t\tself.recurse(\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tfunction (argument) {\n\t\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\texpression = \"[\" + args.join(\",\") + \"]\";\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.ObjectExpression:\n\t\t\t\targs = [];\n\t\t\t\tcomputed = false;\n\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\tcomputed = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (computed) {\n\t\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\t\tthis.assign(intoId, \"{}\");\n\t\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\t\tleft = self.nextId();\n\t\t\t\t\t\t\tself.recurse(property.key, left);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft =\n\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t: \"\" + property.key.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright = self.nextId();\n\t\t\t\t\t\tself.recurse(property.value, right);\n\t\t\t\t\t\tself.assign(self.member(intoId, left, property.computed), right);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\t\tself.recurse(\n\t\t\t\t\t\t\tproperty.value,\n\t\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tfunction (expr) {\n\t\t\t\t\t\t\t\targs.push(\n\t\t\t\t\t\t\t\t\tself.escape(\n\t\t\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t\t\t: \"\" + property.key.value\n\t\t\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t\t\t\t\":\" +\n\t\t\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\texpression = \"{\" + args.join(\",\") + \"}\";\n\t\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\t}\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.ThisExpression:\n\t\t\t\tthis.assign(intoId, \"s\");\n\t\t\t\trecursionFn(intoId || \"s\");\n\t\t\t\tbreak;\n\t\t\tcase AST.LocalsExpression:\n\t\t\t\tthis.assign(intoId, \"l\");\n\t\t\t\trecursionFn(intoId || \"l\");\n\t\t\t\tbreak;\n\t\t\tcase AST.NGValueParameter:\n\t\t\t\tthis.assign(intoId, \"v\");\n\t\t\t\trecursionFn(intoId || \"v\");\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\tgetHasOwnProperty: function (element, property) {\n\t\tvar key = element + \".\" + property;\n\t\tvar own = this.current().own;\n\t\tif (!own.hasOwnProperty(key)) {\n\t\t\town[key] = this.nextId(\n\t\t\t\tfalse,\n\t\t\t\telement + \"&&(\" + this.escape(property) + \" in \" + element + \")\"\n\t\t\t);\n\t\t}\n\t\treturn own[key];\n\t},\n\n\tassign: function (id, value) {\n\t\tif (!id) return;\n\t\tthis.current().body.push(id, \"=\", value, \";\");\n\t\treturn id;\n\t},\n\n\tfilter: function (filterName) {\n\t\tif (!this.state.filters.hasOwnProperty(filterName)) {\n\t\t\tthis.state.filters[filterName] = this.nextId(true);\n\t\t}\n\t\treturn this.state.filters[filterName];\n\t},\n\n\tifDefined: function (id, defaultValue) {\n\t\treturn \"ifDefined(\" + id + \",\" + this.escape(defaultValue) + \")\";\n\t},\n\n\tplus: function (left, right) {\n\t\treturn \"plus(\" + left + \",\" + right + \")\";\n\t},\n\n\treturn_: function (id) {\n\t\tthis.current().body.push(\"return \", id, \";\");\n\t},\n\n\tif_: function (test, alternate, consequent) {\n\t\tif (test === true) {\n\t\t\talternate();\n\t\t} else {\n\t\t\tvar body = this.current().body;\n\t\t\tbody.push(\"if(\", test, \"){\");\n\t\t\talternate();\n\t\t\tbody.push(\"}\");\n\t\t\tif (consequent) {\n\t\t\t\tbody.push(\"else{\");\n\t\t\t\tconsequent();\n\t\t\t\tbody.push(\"}\");\n\t\t\t}\n\t\t}\n\t},\n\tor_: function (expr1, expr2) {\n\t\treturn \"(\" + expr1 + \") || (\" + expr2 + \")\";\n\t},\n\thasOwnProperty_: function (obj, prop, computed) {\n\t\tif (computed) {\n\t\t\treturn \"(Object.prototype.hasOwnProperty.call(\" + obj + \",\" + prop + \"))\";\n\t\t} else {\n\t\t\treturn (\n\t\t\t\t\"(Object.prototype.hasOwnProperty.call(\" + obj + \",'\" + prop + \"'))\"\n\t\t\t);\n\t\t}\n\t},\n\tand_: function (expr1, expr2) {\n\t\treturn \"(\" + expr1 + \") && (\" + expr2 + \")\";\n\t},\n\tnot: function (expression) {\n\t\treturn \"!(\" + expression + \")\";\n\t},\n\n\tisNull: function (expression) {\n\t\treturn expression + \"==null\";\n\t},\n\n\tnotNull: function (expression) {\n\t\treturn expression + \"!=null\";\n\t},\n\n\tnonComputedMember: function (left, right) {\n\t\tvar SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;\n\t\tvar UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;\n\t\tvar expr = \"\";\n\t\tif (SAFE_IDENTIFIER.test(right)) {\n\t\t\texpr = left + \".\" + right;\n\t\t} else {\n\t\t\tright = right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn);\n\t\t\texpr = left + '[\"' + right + '\"]';\n\t\t}\n\n\t\treturn expr;\n\t},\n\n\tcomputedMember: function (left, right) {\n\t\treturn left + \"[\" + right + \"]\";\n\t},\n\n\tmember: function (left, right, computed) {\n\t\tif (computed) return this.computedMember(left, right);\n\t\treturn this.nonComputedMember(left, right);\n\t},\n\n\tgetStringValue: function (item) {\n\t\tthis.assign(item, \"getStringValue(\" + item + \")\");\n\t},\n\n\tlazyRecurse: function (\n\t\tast,\n\t\tintoId,\n\t\tnameId,\n\t\trecursionFn,\n\t\tcreate,\n\t\tskipWatchIdCheck\n\t) {\n\t\tvar self = this;\n\t\treturn function () {\n\t\t\tself.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);\n\t\t};\n\t},\n\n\tlazyAssign: function (id, value) {\n\t\tvar self = this;\n\t\treturn function () {\n\t\t\tself.assign(id, value);\n\t\t};\n\t},\n\n\tstringEscapeRegex: /[^ a-zA-Z0-9]/g,\n\n\tstringEscapeFn: function (c) {\n\t\treturn \"\\\\u\" + (\"0000\" + c.charCodeAt(0).toString(16)).slice(-4);\n\t},\n\n\tescape: function (value) {\n\t\tif (isString(value))\n\t\t\treturn (\n\t\t\t\t\"'\" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + \"'\"\n\t\t\t);\n\t\tif (isNumber(value)) return value.toString();\n\t\tif (value === true) return \"true\";\n\t\tif (value === false) return \"false\";\n\t\tif (value === null) return \"null\";\n\t\tif (typeof value === \"undefined\") return \"undefined\";\n\n\t\tthrow $parseMinErr(\"esc\", \"IMPOSSIBLE\");\n\t},\n\n\tnextId: function (skip, init) {\n\t\tvar id = \"v\" + this.state.nextId++;\n\t\tif (!skip) {\n\t\t\tthis.current().vars.push(id + (init ? \"=\" + init : \"\"));\n\t\t}\n\t\treturn id;\n\t},\n\n\tcurrent: function () {\n\t\treturn this.state[this.state.computing];\n\t},\n};\n\nfunction ASTInterpreter(astBuilder, $filter) {\n\tthis.astBuilder = astBuilder;\n\tthis.$filter = $filter;\n}\n\nASTInterpreter.prototype = {\n\tcompile: function (expression) {\n\t\tvar self = this;\n\t\tvar ast = this.astBuilder.ast(expression);\n\t\tfindConstantAndWatchExpressions(ast, self.$filter);\n\t\tvar assignable;\n\t\tvar assign;\n\t\tif ((assignable = assignableAST(ast))) {\n\t\t\tassign = this.recurse(assignable);\n\t\t}\n\t\tvar toWatch = getInputs(ast.body);\n\t\tvar inputs;\n\t\tif (toWatch) {\n\t\t\tinputs = [];\n\t\t\tforEach(toWatch, function (watch, key) {\n\t\t\t\tvar input = self.recurse(watch);\n\t\t\t\twatch.input = input;\n\t\t\t\tinputs.push(input);\n\t\t\t\twatch.watchId = key;\n\t\t\t});\n\t\t}\n\t\tvar expressions = [];\n\t\tforEach(ast.body, function (expression) {\n\t\t\texpressions.push(self.recurse(expression.expression));\n\t\t});\n\t\tvar fn =\n\t\t\tast.body.length === 0\n\t\t\t\t? noop\n\t\t\t\t: ast.body.length === 1\n\t\t\t\t? expressions[0]\n\t\t\t\t: function (scope, locals) {\n\t\t\t\t\t\tvar lastValue;\n\t\t\t\t\t\tforEach(expressions, function (exp) {\n\t\t\t\t\t\t\tlastValue = exp(scope, locals);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn lastValue;\n\t\t\t\t  };\n\n\t\tif (assign) {\n\t\t\tfn.assign = function (scope, value, locals) {\n\t\t\t\treturn assign(scope, locals, value);\n\t\t\t};\n\t\t}\n\t\tif (inputs) {\n\t\t\tfn.inputs = inputs;\n\t\t}\n\t\tfn.ast = ast;\n\t\tfn.literal = isLiteral(ast);\n\t\tfn.constant = isConstant(ast);\n\t\treturn fn;\n\t},\n\n\trecurse: function (ast, context, create) {\n\t\tvar left,\n\t\t\tright,\n\t\t\tself = this,\n\t\t\targs;\n\t\tif (ast.input) {\n\t\t\treturn this.inputs(ast.input, ast.watchId);\n\t\t}\n\t\tswitch (ast.type) {\n\t\t\tcase AST.Literal:\n\t\t\t\treturn this.value(ast.value, context);\n\t\t\tcase AST.UnaryExpression:\n\t\t\t\tright = this.recurse(ast.argument);\n\t\t\t\treturn this[\"unary\" + ast.operator](right, context);\n\t\t\tcase AST.BinaryExpression:\n\t\t\t\tleft = this.recurse(ast.left);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn this[\"binary\" + ast.operator](left, right, context);\n\t\t\tcase AST.LogicalExpression:\n\t\t\t\tleft = this.recurse(ast.left);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn this[\"binary\" + ast.operator](left, right, context);\n\t\t\tcase AST.ConditionalExpression:\n\t\t\t\treturn this[\"ternary?:\"](\n\t\t\t\t\tthis.recurse(ast.test),\n\t\t\t\t\tthis.recurse(ast.alternate),\n\t\t\t\t\tthis.recurse(ast.consequent),\n\t\t\t\t\tcontext\n\t\t\t\t);\n\t\t\tcase AST.Identifier:\n\t\t\t\treturn self.identifier(ast.name, context, create);\n\t\t\tcase AST.MemberExpression:\n\t\t\t\tleft = this.recurse(ast.object, false, !!create);\n\t\t\t\tif (!ast.computed) {\n\t\t\t\t\tright = ast.property.name;\n\t\t\t\t}\n\t\t\t\tif (ast.computed) right = this.recurse(ast.property);\n\t\t\t\treturn ast.computed\n\t\t\t\t\t? this.computedMember(left, right, context, create)\n\t\t\t\t\t: this.nonComputedMember(left, right, context, create);\n\t\t\tcase AST.CallExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\targs.push(self.recurse(expr));\n\t\t\t\t});\n\t\t\t\tif (ast.filter) right = this.$filter(ast.callee.name);\n\t\t\t\tif (!ast.filter) right = this.recurse(ast.callee, true);\n\t\t\t\treturn ast.filter\n\t\t\t\t\t? function (scope, locals, assign, inputs) {\n\t\t\t\t\t\t\tvar values = [];\n\t\t\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\t\t\tvalues.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar value = right.apply(undefined, values, inputs);\n\t\t\t\t\t\t\treturn context\n\t\t\t\t\t\t\t\t? { context: undefined, name: undefined, value: value }\n\t\t\t\t\t\t\t\t: value;\n\t\t\t\t\t  }\n\t\t\t\t\t: function (scope, locals, assign, inputs) {\n\t\t\t\t\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\t\t\t\t\tvar value;\n\t\t\t\t\t\t\tif (rhs.value != null) {\n\t\t\t\t\t\t\t\tvar values = [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\t\t\t\tvalues.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalue = rhs.value.apply(rhs.context, values);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t\t  };\n\t\t\tcase AST.AssignmentExpression:\n\t\t\t\tleft = this.recurse(ast.left, true, 1);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\t\t\tlhs.context[lhs.name] = rhs;\n\t\t\t\t\treturn context ? { value: rhs } : rhs;\n\t\t\t\t};\n\t\t\tcase AST.ArrayExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\t\targs.push(self.recurse(expr));\n\t\t\t\t});\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar value = [];\n\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tvalue.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t}\n\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t};\n\t\t\tcase AST.ObjectExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\targs.push({\n\t\t\t\t\t\t\tkey: self.recurse(property.key),\n\t\t\t\t\t\t\tcomputed: true,\n\t\t\t\t\t\t\tvalue: self.recurse(property.value),\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push({\n\t\t\t\t\t\t\tkey:\n\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t: \"\" + property.key.value,\n\t\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\t\tvalue: self.recurse(property.value),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar value = {};\n\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tif (args[i].computed) {\n\t\t\t\t\t\t\tvalue[args[i].key(scope, locals, assign, inputs)] = args[i].value(\n\t\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\t\tlocals,\n\t\t\t\t\t\t\t\tassign,\n\t\t\t\t\t\t\t\tinputs\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue[args[i].key] = args[i].value(scope, locals, assign, inputs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t};\n\t\t\tcase AST.ThisExpression:\n\t\t\t\treturn function (scope) {\n\t\t\t\t\treturn context ? { value: scope } : scope;\n\t\t\t\t};\n\t\t\tcase AST.LocalsExpression:\n\t\t\t\treturn function (scope, locals) {\n\t\t\t\t\treturn context ? { value: locals } : locals;\n\t\t\t\t};\n\t\t\tcase AST.NGValueParameter:\n\t\t\t\treturn function (scope, locals, assign) {\n\t\t\t\t\treturn context ? { value: assign } : assign;\n\t\t\t\t};\n\t\t}\n\t},\n\n\t\"unary+\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = argument(scope, locals, assign, inputs);\n\t\t\tif (isDefined(arg)) {\n\t\t\t\targ = +arg;\n\t\t\t} else {\n\t\t\t\targ = 0;\n\t\t\t}\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"unary-\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = argument(scope, locals, assign, inputs);\n\t\t\tif (isDefined(arg)) {\n\t\t\t\targ = -arg;\n\t\t\t} else {\n\t\t\t\targ = -0;\n\t\t\t}\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"unary!\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = !argument(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary+\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\tvar arg = plusFn(lhs, rhs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary-\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\tvar arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary*\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) *\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary/\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) /\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary%\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) %\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary===\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ===\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary!==\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) !==\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary==\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ==\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary!=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) !=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary<\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) <\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary>\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) >\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary<=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) <=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary>=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) >=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary&&\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) &&\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary||\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ||\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"ternary?:\": function (test, alternate, consequent, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = test(scope, locals, assign, inputs)\n\t\t\t\t? alternate(scope, locals, assign, inputs)\n\t\t\t\t: consequent(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\tvalue: function (value, context) {\n\t\treturn function () {\n\t\t\treturn context\n\t\t\t\t? { context: undefined, name: undefined, value: value }\n\t\t\t\t: value;\n\t\t};\n\t},\n\tidentifier: function (name, context, create) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar base = locals && name in locals ? locals : scope;\n\t\t\tif (create && create !== 1 && base && base[name] == null) {\n\t\t\t\tbase[name] = {};\n\t\t\t}\n\t\t\tvar value = base ? base[name] : undefined;\n\t\t\tif (context) {\n\t\t\t\treturn { context: base, name: name, value: value };\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t};\n\t},\n\tcomputedMember: function (left, right, context, create) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs;\n\t\t\tvar value;\n\t\t\tif (lhs != null) {\n\t\t\t\trhs = right(scope, locals, assign, inputs);\n\t\t\t\trhs = getStringValue(rhs);\n\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\tif (lhs && !lhs[rhs]) {\n\t\t\t\t\t\tlhs[rhs] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(lhs, rhs)) {\n\t\t\t\t\tvalue = lhs[rhs];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (context) {\n\t\t\t\treturn { context: lhs, name: rhs, value: value };\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t};\n\t},\n\tnonComputedMember: function (left, right, context, create) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tif (create && create !== 1) {\n\t\t\t\tif (lhs && lhs[right] == null) {\n\t\t\t\t\tlhs[right] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar value = undefined;\n\t\t\tif (lhs != null && Object.prototype.hasOwnProperty.call(lhs, right)) {\n\t\t\t\tvalue = lhs[right];\n\t\t\t}\n\n\t\t\tif (context) {\n\t\t\t\treturn { context: lhs, name: right, value: value };\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t};\n\t},\n\tinputs: function (input, watchId) {\n\t\treturn function (scope, value, locals, inputs) {\n\t\t\tif (inputs) return inputs[watchId];\n\t\t\treturn input(scope, value, locals);\n\t\t};\n\t},\n};\n\n/**\n * @constructor\n */\nvar Parser = function Parser(lexer, $filter, options) {\n\tthis.lexer = lexer;\n\tthis.$filter = $filter;\n\tthis.options = options;\n\tthis.ast = new AST(lexer, options);\n\tthis.astCompiler = options.csp\n\t\t? new ASTInterpreter(this.ast, $filter)\n\t\t: new ASTCompiler(this.ast, $filter);\n};\n\nParser.prototype = {\n\tconstructor: Parser,\n\n\tparse: function (text) {\n\t\treturn this.astCompiler.compile(text);\n\t},\n};\n\nfunction getValueOf(value) {\n\treturn isFunction(value.valueOf)\n\t\t? value.valueOf()\n\t\t: objectValueOf.call(value);\n}\n\n///////////////////////////////////\n\n/**\n * @ngdoc service\n * @name $parse\n * @kind function\n *\n * @description\n *\n * Converts Angular {@link guide/expression expression} into a function.\n *\n * ```js\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'angular'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('angular');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * ```\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context` \u2013 `{object}` \u2013 an object against which any expressions embedded in the strings\n *      are evaluated against (typically a scope object).\n *    * `locals` \u2013 `{object=}` \u2013 local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The returned function also has the following properties:\n *      * `literal` \u2013 `{boolean}` \u2013 whether the expression's top-level node is a JavaScript\n *        literal.\n *      * `constant` \u2013 `{boolean}` \u2013 whether the expression is made entirely of JavaScript\n *        constant literals.\n *      * `assign` \u2013 `{?function(context, value)}` \u2013 if the expression is assignable, this will be\n *        set to a function to change its value on the given context.\n *\n */\n\n/**\n * @ngdoc provider\n * @name $parseProvider\n * @this\n *\n * @description\n * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}\n *  service.\n */\nfunction $ParseProvider() {\n\tvar cache = createMap();\n\tvar literals = {\n\t\ttrue: true,\n\t\tfalse: false,\n\t\tnull: null,\n\t\tundefined: undefined,\n\t};\n\tvar identStart, identContinue;\n\n\t/**\n\t * @ngdoc method\n\t * @name $parseProvider#addLiteral\n\t * @description\n\t *\n\t * Configure $parse service to add literal values that will be present as literal at expressions.\n\t *\n\t * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.\n\t * @param {*} literalValue Value for this literal. All literal values must be primitives or `undefined`.\n\t *\n\t **/\n\tthis.addLiteral = function (literalName, literalValue) {\n\t\tliterals[literalName] = literalValue;\n\t};\n\n\t/**\n\t * @ngdoc method\n\t * @name $parseProvider#setIdentifierFns\n\t *\n\t * @description\n\t *\n\t * Allows defining the set of characters that are allowed in Angular expressions. The function\n\t * `identifierStart` will get called to know if a given character is a valid character to be the\n\t * first character for an identifier. The function `identifierContinue` will get called to know if\n\t * a given character is a valid character to be a follow-up identifier character. The functions\n\t * `identifierStart` and `identifierContinue` will receive as arguments the single character to be\n\t * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in\n\t * mind that the `string` parameter can be two characters long depending on the character\n\t * representation. It is expected for the function to return `true` or `false`, whether that\n\t * character is allowed or not.\n\t *\n\t * Since this function will be called extensively, keep the implementation of these functions fast,\n\t * as the performance of these functions have a direct impact on the expressions parsing speed.\n\t *\n\t * @param {function=} identifierStart The function that will decide whether the given character is\n\t *   a valid identifier start character.\n\t * @param {function=} identifierContinue The function that will decide whether the given character is\n\t *   a valid identifier continue character.\n\t */\n\tthis.setIdentifierFns = function (identifierStart, identifierContinue) {\n\t\tidentStart = identifierStart;\n\t\tidentContinue = identifierContinue;\n\t\treturn this;\n\t};\n\n\tthis.$get = [\n\t\t\"$filter\",\n\t\tfunction ($filter) {\n\t\t\tvar noUnsafeEval = csp().noUnsafeEval;\n\t\t\tvar $parseOptions = {\n\t\t\t\tcsp: noUnsafeEval,\n\t\t\t\tliterals: copy(literals),\n\t\t\t\tisIdentifierStart: isFunction(identStart) && identStart,\n\t\t\t\tisIdentifierContinue: isFunction(identContinue) && identContinue,\n\t\t\t};\n\t\t\treturn $parse;\n\n\t\t\tfunction $parse(exp, interceptorFn) {\n\t\t\t\tvar parsedExpression, oneTime, cacheKey;\n\n\t\t\t\tswitch (typeof exp) {\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\texp = exp.trim();\n\t\t\t\t\t\tcacheKey = exp;\n\n\t\t\t\t\t\tparsedExpression = cache[cacheKey];\n\n\t\t\t\t\t\tif (!parsedExpression) {\n\t\t\t\t\t\t\tif (exp.charAt(0) === \":\" && exp.charAt(1) === \":\") {\n\t\t\t\t\t\t\t\toneTime = true;\n\t\t\t\t\t\t\t\texp = exp.substring(2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar lexer = new Lexer($parseOptions);\n\t\t\t\t\t\t\tvar parser = new Parser(lexer, $filter, $parseOptions);\n\t\t\t\t\t\t\tparsedExpression = parser.parse(exp);\n\t\t\t\t\t\t\tif (parsedExpression.constant) {\n\t\t\t\t\t\t\t\tparsedExpression.$$watchDelegate = constantWatchDelegate;\n\t\t\t\t\t\t\t} else if (oneTime) {\n\t\t\t\t\t\t\t\tparsedExpression.$$watchDelegate = parsedExpression.literal\n\t\t\t\t\t\t\t\t\t? oneTimeLiteralWatchDelegate\n\t\t\t\t\t\t\t\t\t: oneTimeWatchDelegate;\n\t\t\t\t\t\t\t} else if (parsedExpression.inputs) {\n\t\t\t\t\t\t\t\tparsedExpression.$$watchDelegate = inputsWatchDelegate;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcache[cacheKey] = parsedExpression;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn addInterceptor(parsedExpression, interceptorFn);\n\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\treturn addInterceptor(exp, interceptorFn);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn addInterceptor(noop, interceptorFn);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction expressionInputDirtyCheck(newValue, oldValueOfValue) {\n\t\t\t\tif (newValue == null || oldValueOfValue == null) {\n\t\t\t\t\t// null/undefined\n\t\t\t\t\treturn newValue === oldValueOfValue;\n\t\t\t\t}\n\n\t\t\t\tif (typeof newValue === \"object\") {\n\t\t\t\t\t// attempt to convert the value to a primitive type\n\t\t\t\t\t// TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can\n\t\t\t\t\t//             be cheaply dirty-checked\n\t\t\t\t\tnewValue = getValueOf(newValue);\n\n\t\t\t\t\tif (typeof newValue === \"object\") {\n\t\t\t\t\t\t// objects/arrays are not supported - deep-watching them would be too expensive\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// fall-through to the primitive equality check\n\t\t\t\t}\n\n\t\t\t\t//Primitive or NaN\n\t\t\t\t// eslint-disable-next-line no-self-compare\n\t\t\t\treturn (\n\t\t\t\t\tnewValue === oldValueOfValue ||\n\t\t\t\t\t(newValue !== newValue && oldValueOfValue !== oldValueOfValue)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction inputsWatchDelegate(\n\t\t\t\tscope,\n\t\t\t\tlistener,\n\t\t\t\tobjectEquality,\n\t\t\t\tparsedExpression,\n\t\t\t\tprettyPrintExpression\n\t\t\t) {\n\t\t\t\tvar inputExpressions = parsedExpression.inputs;\n\t\t\t\tvar lastResult;\n\n\t\t\t\tif (inputExpressions.length === 1) {\n\t\t\t\t\tvar oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails\n\t\t\t\t\tinputExpressions = inputExpressions[0];\n\t\t\t\t\treturn scope.$watch(\n\t\t\t\t\t\tfunction expressionInputWatch(scope) {\n\t\t\t\t\t\t\tvar newInputValue = inputExpressions(scope);\n\t\t\t\t\t\t\tif (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {\n\t\t\t\t\t\t\t\tlastResult = parsedExpression(scope, undefined, undefined, [\n\t\t\t\t\t\t\t\t\tnewInputValue,\n\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\toldInputValueOf = newInputValue && getValueOf(newInputValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn lastResult;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlistener,\n\t\t\t\t\t\tobjectEquality,\n\t\t\t\t\t\tprettyPrintExpression\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tvar oldInputValueOfValues = [];\n\t\t\t\tvar oldInputValues = [];\n\t\t\t\tfor (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n\t\t\t\t\toldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails\n\t\t\t\t\toldInputValues[i] = null;\n\t\t\t\t}\n\n\t\t\t\treturn scope.$watch(\n\t\t\t\t\tfunction expressionInputsWatch(scope) {\n\t\t\t\t\t\tvar changed = false;\n\n\t\t\t\t\t\tfor (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n\t\t\t\t\t\t\tvar newInputValue = inputExpressions[i](scope);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tchanged ||\n\t\t\t\t\t\t\t\t(changed = !expressionInputDirtyCheck(\n\t\t\t\t\t\t\t\t\tnewInputValue,\n\t\t\t\t\t\t\t\t\toldInputValueOfValues[i]\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toldInputValues[i] = newInputValue;\n\t\t\t\t\t\t\t\toldInputValueOfValues[i] =\n\t\t\t\t\t\t\t\t\tnewInputValue && getValueOf(newInputValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\tlastResult = parsedExpression(\n\t\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\toldInputValues\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastResult;\n\t\t\t\t\t},\n\t\t\t\t\tlistener,\n\t\t\t\t\tobjectEquality,\n\t\t\t\t\tprettyPrintExpression\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction oneTimeWatchDelegate(\n\t\t\t\tscope,\n\t\t\t\tlistener,\n\t\t\t\tobjectEquality,\n\t\t\t\tparsedExpression,\n\t\t\t\tprettyPrintExpression\n\t\t\t) {\n\t\t\t\tvar unwatch, lastValue;\n\t\t\t\tif (parsedExpression.inputs) {\n\t\t\t\t\tunwatch = inputsWatchDelegate(\n\t\t\t\t\t\tscope,\n\t\t\t\t\t\toneTimeListener,\n\t\t\t\t\t\tobjectEquality,\n\t\t\t\t\t\tparsedExpression,\n\t\t\t\t\t\tprettyPrintExpression\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tunwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);\n\t\t\t\t}\n\t\t\t\treturn unwatch;\n\n\t\t\t\tfunction oneTimeWatch(scope) {\n\t\t\t\t\treturn parsedExpression(scope);\n\t\t\t\t}\n\t\t\t\tfunction oneTimeListener(value, old, scope) {\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tif (isFunction(listener)) {\n\t\t\t\t\t\tlistener(value, old, scope);\n\t\t\t\t\t}\n\t\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\t\tscope.$$postDigest(function () {\n\t\t\t\t\t\t\tif (isDefined(lastValue)) {\n\t\t\t\t\t\t\t\tunwatch();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction oneTimeLiteralWatchDelegate(\n\t\t\t\tscope,\n\t\t\t\tlistener,\n\t\t\t\tobjectEquality,\n\t\t\t\tparsedExpression\n\t\t\t) {\n\t\t\t\tvar unwatch, lastValue;\n\t\t\t\tunwatch = scope.$watch(\n\t\t\t\t\tfunction oneTimeWatch(scope) {\n\t\t\t\t\t\treturn parsedExpression(scope);\n\t\t\t\t\t},\n\t\t\t\t\tfunction oneTimeListener(value, old, scope) {\n\t\t\t\t\t\tlastValue = value;\n\t\t\t\t\t\tif (isFunction(listener)) {\n\t\t\t\t\t\t\tlistener(value, old, scope);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isAllDefined(value)) {\n\t\t\t\t\t\t\tscope.$$postDigest(function () {\n\t\t\t\t\t\t\t\tif (isAllDefined(lastValue)) unwatch();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tobjectEquality\n\t\t\t\t);\n\n\t\t\t\treturn unwatch;\n\n\t\t\t\tfunction isAllDefined(value) {\n\t\t\t\t\tvar allDefined = true;\n\t\t\t\t\tforEach(value, function (val) {\n\t\t\t\t\t\tif (!isDefined(val)) allDefined = false;\n\t\t\t\t\t});\n\t\t\t\t\treturn allDefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction constantWatchDelegate(\n\t\t\t\tscope,\n\t\t\t\tlistener,\n\t\t\t\tobjectEquality,\n\t\t\t\tparsedExpression\n\t\t\t) {\n\t\t\t\tvar unwatch = scope.$watch(\n\t\t\t\t\tfunction constantWatch(scope) {\n\t\t\t\t\t\tunwatch();\n\t\t\t\t\t\treturn parsedExpression(scope);\n\t\t\t\t\t},\n\t\t\t\t\tlistener,\n\t\t\t\t\tobjectEquality\n\t\t\t\t);\n\t\t\t\treturn unwatch;\n\t\t\t}\n\n\t\t\tfunction addInterceptor(parsedExpression, interceptorFn) {\n\t\t\t\tif (!interceptorFn) return parsedExpression;\n\t\t\t\tvar watchDelegate = parsedExpression.$$watchDelegate;\n\t\t\t\tvar useInputs = false;\n\n\t\t\t\tvar regularWatch =\n\t\t\t\t\twatchDelegate !== oneTimeLiteralWatchDelegate &&\n\t\t\t\t\twatchDelegate !== oneTimeWatchDelegate;\n\n\t\t\t\tvar fn = regularWatch\n\t\t\t\t\t? function regularInterceptedExpression(\n\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\tlocals,\n\t\t\t\t\t\t\tassign,\n\t\t\t\t\t\t\tinputs\n\t\t\t\t\t  ) {\n\t\t\t\t\t\t\tvar value =\n\t\t\t\t\t\t\t\tuseInputs && inputs\n\t\t\t\t\t\t\t\t\t? inputs[0]\n\t\t\t\t\t\t\t\t\t: parsedExpression(scope, locals, assign, inputs);\n\t\t\t\t\t\t\treturn interceptorFn(value, scope, locals);\n\t\t\t\t\t  }\n\t\t\t\t\t: function oneTimeInterceptedExpression(\n\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\tlocals,\n\t\t\t\t\t\t\tassign,\n\t\t\t\t\t\t\tinputs\n\t\t\t\t\t  ) {\n\t\t\t\t\t\t\tvar value = parsedExpression(scope, locals, assign, inputs);\n\t\t\t\t\t\t\tvar result = interceptorFn(value, scope, locals);\n\t\t\t\t\t\t\t// we only return the interceptor's result if the\n\t\t\t\t\t\t\t// initial value is defined (for bind-once)\n\t\t\t\t\t\t\treturn isDefined(value) ? result : value;\n\t\t\t\t\t  };\n\n\t\t\t\t// Propagate $$watchDelegates other then inputsWatchDelegate\n\t\t\t\tuseInputs = !parsedExpression.inputs;\n\t\t\t\tif (\n\t\t\t\t\tparsedExpression.$$watchDelegate &&\n\t\t\t\t\tparsedExpression.$$watchDelegate !== inputsWatchDelegate\n\t\t\t\t) {\n\t\t\t\t\tfn.$$watchDelegate = parsedExpression.$$watchDelegate;\n\t\t\t\t\tfn.inputs = parsedExpression.inputs;\n\t\t\t\t} else if (!interceptorFn.$stateful) {\n\t\t\t\t\t// If there is an interceptor, but no watchDelegate then treat the interceptor like\n\t\t\t\t\t// we treat filters - it is assumed to be a pure function unless flagged with $stateful\n\t\t\t\t\tfn.$$watchDelegate = inputsWatchDelegate;\n\t\t\t\t\tfn.inputs = parsedExpression.inputs\n\t\t\t\t\t\t? parsedExpression.inputs\n\t\t\t\t\t\t: [parsedExpression];\n\t\t\t\t}\n\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\t];\n}\n\nexports.Lexer = Lexer;\nexports.Parser = Parser;\n", "\"use strict\";\n\nvar chai = require(\"chai\");\nvar expect = chai.expect;\nvar expressions = require(\"../lib/main.js\");\nvar compile = expressions.compile;\n\nchai.config.includeStack = true;\n\n// These tests make no claim to be complete. We only test the most important parts of angular expressions.\n// I hope they have their own tests ;)\ndescribe(\"expressions\", function () {\n\tdescribe(\".Lexer\", function () {\n\t\tit(\"should be a function\", function () {\n\t\t\texpect(expressions.Lexer).to.be.a(\"function\");\n\t\t});\n\n\t\tit(\"should provide a .lex()-method\", function () {\n\t\t\tvar lexer = new expressions.Lexer();\n\n\t\t\texpect(lexer.lex).to.be.a(\"function\");\n\t\t});\n\t});\n\n\tdescribe(\".Parser\", function () {\n\t\tit(\"should be a function\", function () {\n\t\t\texpect(expressions.Parser).to.be.a(\"function\");\n\t\t});\n\n\t\tit(\"should provide a .parse()-method\", function () {\n\t\t\tvar parser = new expressions.Parser(undefined, undefined, {});\n\n\t\t\texpect(parser.parse).to.be.a(\"function\");\n\t\t});\n\t});\n\n\tdescribe(\".compile(src)\", function () {\n\t\tvar scope;\n\t\tvar evaluate;\n\n\t\tbeforeEach(function () {\n\t\t\tscope = {\n\t\t\t\tship: {\n\t\t\t\t\tpirate: {\n\t\t\t\t\t\tname: \"Jenny\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t});\n\n\t\tit(\"should return a function\", function () {\n\t\t\texpect(compile(\"\")).to.be.a(\"function\");\n\t\t});\n\n\t\tit(\"should throw an error if the given value is not a string\", function () {\n\t\t\texpect(function () {\n\t\t\t\tcompile();\n\t\t\t}).to.throw(\"src must be a string, instead saw 'undefined'\");\n\t\t});\n\n\t\tit(\"should expose the ast\", function () {\n\t\t\texpect(compile(\"tmp\").ast).to.be.a(\"object\");\n\t\t});\n\n\t\tdescribe(\"when evaluating literals\", function () {\n\t\t\tit(\"should return null\", function () {\n\t\t\t\tevaluate = compile(\"null\");\n\t\t\t\texpect(evaluate(scope)).to.equal(null);\n\t\t\t});\n\n\t\t\tit(\"should return true\", function () {\n\t\t\t\tevaluate = compile(\"true\");\n\t\t\t\texpect(evaluate(scope)).to.equal(true);\n\t\t\t});\n\n\t\t\tit(\"should return false\", function () {\n\t\t\t\tevaluate = compile(\"false\");\n\t\t\t\texpect(evaluate(scope)).to.equal(false);\n\t\t\t});\n\n\t\t\tit(\"should return 2.34e5\", function () {\n\t\t\t\tevaluate = compile(\"2.34e5\");\n\t\t\t\texpect(evaluate(scope)).to.equal(2.34e5);\n\t\t\t});\n\n\t\t\tit(\"should return 'string'\", function () {\n\t\t\t\tevaluate = compile(\"'string'\");\n\t\t\t\texpect(evaluate(scope)).to.equal(\"string\");\n\t\t\t});\n\n\t\t\tit(\"should return [ship, 1, 2, []]\", function () {\n\t\t\t\tevaluate = compile(\"[ship, 1, 2, []]\");\n\t\t\t\texpect(evaluate(scope)).to.eql([scope.ship, 1, 2, []]);\n\t\t\t});\n\n\t\t\tit(\"should return { test: 'value', 'new-object': {} }\", function () {\n\t\t\t\tevaluate = compile(\"{ test: 'value', 'new-object': {} }\");\n\t\t\t\texpect(evaluate(scope)).to.eql({ test: \"value\", \"new-object\": {} });\n\t\t\t});\n\n\t\t\tit(\"should return context value when nothing in the scope\", function () {\n\t\t\t\tevaluate = compile(\"test\");\n\t\t\t\texpect(evaluate(scope, { test: \"hello\" })).to.equal(\"hello\");\n\t\t\t});\n\n\t\t\tit(\"should return context value when something in the scope\", function () {\n\t\t\t\tevaluate = compile(\"test\");\n\t\t\t\texpect(evaluate({ test: \"bye\" }, { test: \"hello\" })).to.equal(\"hello\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating simple key look-ups\", function () {\n\t\t\tit(\"should return the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ship\");\n\t\t\t\texpect(evaluate(scope)).to.equal(scope.ship);\n\t\t\t});\n\n\t\t\tit(\"should return undefined instead of throwing a ReferenceError if it's not defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"notDefined\");\n\t\t\t\texpect(evaluate(scope)).to.equal(undefined);\n\t\t\t});\n\n\t\t\tit(\"should return the scope even when the 'this' keyword is used\", function () {\n\t\t\t\tevaluate = compile(\"this\");\n\t\t\t\texpect(evaluate(scope)).to.equal(scope);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating simple assignments\", function () {\n\t\t\tit(\"should set the new value on scope\", function () {\n\t\t\t\tevaluate = compile(\"newValue = 'new'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.newValue).to.equal(\"new\");\n\t\t\t});\n\n\t\t\tit(\"should change the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ship = 'ship'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.ship).to.equal(\"ship\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating dot-notated loop-ups\", function () {\n\t\t\tit(\"should return the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ship.pirate.name\");\n\t\t\t\texpect(evaluate(scope)).to.equal(\"Jenny\");\n\t\t\t});\n\n\t\t\tit(\"should return undefined instead of throwing a ReferenceError if it's not defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"island.pirate.name\");\n\t\t\t\texpect(evaluate(scope)).to.equal(undefined);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating dot-notated assignments\", function () {\n\t\t\tit(\"should set the new value on scope\", function () {\n\t\t\t\tevaluate = compile(\"island.pirate.name = 'St\u00f6rtebeker'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.island.pirate.name).to.equal(\"St\u00f6rtebeker\");\n\t\t\t});\n\n\t\t\tit(\"should change the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ship.pirate.name = 'St\u00f6rtebeker'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.ship.pirate.name).to.equal(\"St\u00f6rtebeker\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating array look-ups\", function () {\n\t\t\tbeforeEach(function () {\n\t\t\t\tscope.ships = [{ pirate: \"Jenny\" }, { pirate: \"St\u00f6rtebeker\" }];\n\t\t\t});\n\n\t\t\tit(\"should return the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ships[1].pirate\");\n\t\t\t\texpect(evaluate(scope)).to.equal(\"St\u00f6rtebeker\");\n\t\t\t});\n\n\t\t\tit(\"should return undefined instead of throwing a ReferenceError if it's not defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ships[2].pirate\");\n\t\t\t\texpect(evaluate(scope)).to.equal(undefined);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating array assignments\", function () {\n\t\t\tit(\"should change the value if its defined on scope\", function () {\n\t\t\t\tscope.ships = [{ pirate: \"Jenny\" }];\n\t\t\t\tevaluate = compile(\"ships[0].pirate = 'St\u00f6rtebeker'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.ships[0].pirate).to.equal(\"St\u00f6rtebeker\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating function calls\", function () {\n\t\t\tdescribe(\"using no arguments\", function () {\n\t\t\t\tit(\"should return the function's return value\", function () {\n\t\t\t\t\tscope.findPirate = function () {\n\t\t\t\t\t\treturn scope.ship.pirate;\n\t\t\t\t\t};\n\n\t\t\t\t\tevaluate = compile(\"findPirate()\");\n\t\t\t\t\texpect(evaluate(scope)).to.equal(scope.ship.pirate);\n\t\t\t\t});\n\n\t\t\t\tit(\"should call the function on the scope\", function () {\n\t\t\t\t\tscope.returnThis = function () {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t};\n\t\t\t\t\tevaluate = compile(\"returnThis()\");\n\t\t\t\t\texpect(evaluate(scope)).to.equal(scope);\n\t\t\t\t});\n\n\t\t\t\tit(\"should call the function on the object where it is defined\", function () {\n\t\t\t\t\tscope.ship.returnThis = function () {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t};\n\t\t\t\t\tevaluate = compile(\"ship.returnThis()\");\n\t\t\t\t\texpect(evaluate(scope)).to.equal(scope.ship);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tdescribe(\"using arguments\", function () {\n\t\t\t\tit(\"should parse the arguments accordingly\", function () {\n\t\t\t\t\tscope.findPirate = function () {\n\t\t\t\t\t\treturn Array.prototype.slice.call(arguments);\n\t\t\t\t\t};\n\t\t\t\t\tevaluate = compile(\"findPirate(ship.pirate, 1, [2, 3])\");\n\t\t\t\t\texpect(evaluate(scope)).to.eql([scope.ship.pirate, 1, [2, 3]]);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating operators\", function () {\n\t\t\tit(\"should return the expected result when using +\", function () {\n\t\t\t\tevaluate = compile(\"1 + 1\");\n\t\t\t\texpect(evaluate()).to.equal(2);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using -\", function () {\n\t\t\t\tevaluate = compile(\"1 - 1\");\n\t\t\t\texpect(evaluate()).to.equal(0);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using *\", function () {\n\t\t\t\tevaluate = compile(\"2 * 2\");\n\t\t\t\texpect(evaluate()).to.equal(4);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using /\", function () {\n\t\t\t\tevaluate = compile(\"4 / 2\");\n\t\t\t\texpect(evaluate()).to.equal(2);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using %\", function () {\n\t\t\t\tevaluate = compile(\"3 % 2\");\n\t\t\t\texpect(evaluate()).to.equal(1);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using &&\", function () {\n\t\t\t\tevaluate = compile(\"true && true\");\n\t\t\t\texpect(evaluate()).to.equal(true);\n\t\t\t\tevaluate = compile(\"true && false\");\n\t\t\t\texpect(evaluate()).to.equal(false);\n\t\t\t\tevaluate = compile(\"false && false\");\n\t\t\t\texpect(evaluate()).to.equal(false);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using ||\", function () {\n\t\t\t\tevaluate = compile(\"true || true\");\n\t\t\t\texpect(evaluate()).to.equal(true);\n\t\t\t\tevaluate = compile(\"true || false\");\n\t\t\t\texpect(evaluate()).to.equal(true);\n\t\t\t\tevaluate = compile(\"false || false\");\n\t\t\t\texpect(evaluate()).to.equal(false);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using !\", function () {\n\t\t\t\tevaluate = compile(\"!true\");\n\t\t\t\texpect(evaluate()).to.equal(false);\n\t\t\t\tevaluate = compile(\"!false\");\n\t\t\t\texpect(evaluate()).to.equal(true);\n\t\t\t});\n\n\t\t\t/* Ooops, angular doesn't support ++. Maybe someday?\n            it(\"should return the expected result when using ++\", function () {\n                scope.value = 2;\n                evaluate = compile(\"value++\");\n                expect(evaluate()).to.equal(3);\n                expect(scope.value).to.equal(3);\n            });*/\n\n\t\t\t/* Ooops, angular doesn't support --. Maybe someday?\n            it(\"should return the expected result when using --\", function () {\n                scope.value = 2;\n                evaluate = compile(\"value--\");\n                expect(evaluate()).to.equal(1);\n                expect(scope.value).to.equal(1);\n            });*/\n\n\t\t\tit(\"should return the expected result when using ?\", function () {\n\t\t\t\tevaluate = compile(\"true? 'it works' : false\");\n\t\t\t\texpect(evaluate()).to.equal(\"it works\");\n\t\t\t\tevaluate = compile(\"false? false : 'it works'\");\n\t\t\t\texpect(evaluate()).to.equal(\"it works\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"using complex expressions\", function () {\n\t\t\tbeforeEach(function () {\n\t\t\t\tscope.ships = [\n\t\t\t\t\t{\n\t\t\t\t\t\tpirate: function (str) {\n\t\t\t\t\t\t\treturn str;\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpirate: function (str) {\n\t\t\t\t\t\t\treturn str;\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t\tscope.index = 0;\n\t\t\t\tscope.pi = \"pi\";\n\t\t\t\tscope.Jenny = \"Jenny\";\n\t\t\t});\n\n\t\t\tit(\"should still be parseable and executable\", function () {\n\t\t\t\tevaluate = compile(\"ships[index][pi + 'rate'](Jenny)\");\n\t\t\t\texpect(evaluate(scope)).to.equal(\"Jenny\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating syntactical errors\", function () {\n\t\t\tit(\"should give a readable error message\", function () {\n\t\t\t\texpect(function () {\n\t\t\t\t\tcompile(\"'unterminated string\");\n\t\t\t\t}).to.throw(\n\t\t\t\t\t\"Lexer Error: Unterminated quote at columns 0-20 ['unterminated string] in expression ['unterminated string].\"\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tit(\"should give a readable error message\", function () {\n\t\t\t\texpect(function () {\n\t\t\t\t\tcompile(\"3 = 4\");\n\t\t\t\t}).to.throw(\n\t\t\t\t\t'[$parse:lval] Trying to assign a value to a non l-value\\nhttp://errors.angularjs.org/\"NG_VERSION_FULL\"/$parse/lval'\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when using filters\", function () {\n\t\t\tit(\"should apply the given filter\", function () {\n\t\t\t\texpressions.filters.currency = function (input, currency, digits) {\n\t\t\t\t\tinput = input.toFixed(digits);\n\n\t\t\t\t\tif (currency === \"EUR\") {\n\t\t\t\t\t\treturn input + \"\u20ac\";\n\t\t\t\t\t}\n\t\t\t\t\treturn input + \"$\";\n\t\t\t\t};\n\n\t\t\t\tevaluate = compile(\"1.2345 | currency:selectedCurrency:2\");\n\t\t\t\texpect(\n\t\t\t\t\tevaluate({\n\t\t\t\t\t\tselectedCurrency: \"EUR\",\n\t\t\t\t\t})\n\t\t\t\t).to.equal(\"1.23\u20ac\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating the same expression multiple times\", function () {\n\t\t\tit(\"should cache the generated function\", function () {\n\t\t\t\texpect(compile(\"a\")).to.equal(compile(\"a\"));\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"for assigning values\", function () {\n\t\t\tbeforeEach(function () {\n\t\t\t\tscope = {};\n\t\t\t});\n\n\t\t\tit(\"should expose an 'assign'-function\", function () {\n\t\t\t\tvar fn = compile(\"a\");\n\n\t\t\t\texpect(fn.assign).to.be.a(\"function\");\n\t\t\t\tfn.assign(scope, 123);\n\t\t\t\texpect(scope.a).to.equal(123);\n\t\t\t});\n\n\t\t\tdescribe(\"the 'assign'-function\", function () {\n\t\t\t\tit(\"should work for expressions ending with brackets\", function () {\n\t\t\t\t\tvar fn = compile(\"a.b['c']\");\n\n\t\t\t\t\tfn.assign(scope, 123);\n\t\t\t\t\texpect(scope.a.b.c).to.equal(123);\n\t\t\t\t});\n\n\t\t\t\tit(\"should work for expressions with brackets in the middle\", function () {\n\t\t\t\t\tvar fn = compile('a[\"b\"].c');\n\n\t\t\t\t\tfn.assign(scope, 123);\n\t\t\t\t\texpect(scope.a.b.c).to.equal(123);\n\t\t\t\t});\n\n\t\t\t\tit(\"should return the result of the assignment\", function () {\n\t\t\t\t\tvar fn = compile('a[\"b\"].c');\n\n\t\t\t\t\texpect(fn.assign(scope, 123)).to.equal(123);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\".cache\", function () {\n\t\t\tit(\"should be an object by default\", function () {\n\t\t\t\texpect(compile.cache).to.be.an(\"object\");\n\t\t\t});\n\n\t\t\tit(\"should cache the generated function by the expression\", function () {\n\t\t\t\tvar fn = compile(\"a\");\n\n\t\t\t\texpect(compile.cache.a).to.equal(fn);\n\t\t\t});\n\n\t\t\tdescribe(\"when setting it to false\", function () {\n\t\t\t\tit(\"should disable the cache\", function () {\n\t\t\t\t\tcompile.cache = false;\n\t\t\t\t\texpect(compile(\"a\")).to.not.equal(compile(\"a\"));\n\t\t\t\t\tcompile.cache = Object.create(null);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe(\".filters\", function () {\n\t\tit(\"should be an object\", function () {\n\t\t\texpect(expressions.filters).to.be.an(\"object\");\n\t\t});\n\t});\n\n\tdescribe(\"Special characters\", function () {\n\t\tvar evaluate;\n\t\tit(\"should allow to define isIdentifierStart and isIdentifierContinue\", function () {\n\t\t\tfunction validChars(ch) {\n\t\t\t\treturn (\n\t\t\t\t\t(ch >= \"a\" && ch <= \"z\") ||\n\t\t\t\t\t(ch >= \"A\" && ch <= \"Z\") ||\n\t\t\t\t\tch === \"_\" ||\n\t\t\t\t\tch === \"$\" ||\n\t\t\t\t\t\"\u00c0\u00c8\u00cc\u00d2\u00d9\u00e0\u00e8\u00ec\u00f2\u00f9\u00c1\u00c9\u00cd\u00d3\u00da\u00e1\u00e9\u00ed\u00f3\u00fa\u00c2\u00ca\u00ce\u00d4\u00db\u00e2\u00ea\u00ee\u00f4\u00fb\u00c3\u00d1\u00d5\u00e3\u00f1\u00f5\u00c4\u00cb\u00cf\u00d6\u00dc\u0178\u00e4\u00eb\u00ef\u00f6\u00fc\u00ff\u00df\".indexOf(ch) !== -1\n\t\t\t\t);\n\t\t\t}\n\t\t\tevaluate = compile(\"\u00eatre_embarass\u00e9\", {\n\t\t\t\tisIdentifierStart: validChars,\n\t\t\t\tisIdentifierContinue: validChars,\n\t\t\t});\n\n\t\t\texpect(evaluate({ \u00eatre_embarass\u00e9: \"Ping\" })).to.eql(\"Ping\");\n\t\t});\n\t});\n\n\tdescribe(\"prototype\", function () {\n\t\tvar evaluate;\n\n\t\tit(\"should not leak\", function () {\n\t\t\tevaluate = compile(\"''.split\");\n\t\t\texpect(evaluate({})).to.eql(undefined);\n\t\t});\n\n\t\tit(\"should not leak with computed prop\", function () {\n\t\t\tevaluate = compile(\"a['split']\");\n\t\t\texpect(evaluate({ a: \"\" })).to.eql(undefined);\n\t\t});\n\n\t\tit(\"should allow to read string length\", function () {\n\t\t\tevaluate = compile(\"'abc'.length\");\n\t\t\texpect(evaluate({})).to.eql(3);\n\t\t});\n\n\t\tit(\"should allow to read users length\", function () {\n\t\t\tevaluate = compile(\"users.length\");\n\t\t\texpect(evaluate({ users: [1, 4, 4] })).to.eql(3);\n\t\t});\n\n\t\t// it(\"should disallow from changing prototype\", function() {\n\t\t// \tevaluate = compile(\"name.split = 10\");\n\t\t// \tvar scope = { name: \"hello\" };\n\t\t// \tevaluate(scope);\n\t\t// \texpect(scope.name.split).to.be.a(\"function\");\n\t\t// });\n\t\t//\n\t\t//\n\t\tit(\"should work with __proto__\", function () {\n\t\t\tevaluate = compile(\"__proto__\");\n\t\t\texpect(evaluate({})).to.eql(undefined);\n\t\t});\n\n\t\tit(\"should work with toString\", function () {\n\t\t\tevaluate = compile(\"toString\");\n\t\t\texpect(evaluate({ toString: 10 })).to.eql(10);\n\t\t});\n\t});\n});\n"], "fixing_code": ["### 1.1.2\n\n- Disallow access to prototype chain (CVE-2021-21277)\n\n### 1.1.1\n\nPrevious version was published with ES6 feature, now the published JS uses ES5 only\n\n### 1.1.0\n\n- Add support for special characters by using the following :\n\n```javascript\nfunction validChars(ch) {\n  return (\n    (ch >= \"a\" && ch <= \"z\") ||\n    (ch >= \"A\" && ch <= \"Z\") ||\n    ch === \"_\" ||\n    ch === \"$\" ||\n    \"\u00c0\u00c8\u00cc\u00d2\u00d9\u00e0\u00e8\u00ec\u00f2\u00f9\u00c1\u00c9\u00cd\u00d3\u00da\u00e1\u00e9\u00ed\u00f3\u00fa\u00c2\u00ca\u00ce\u00d4\u00db\u00e2\u00ea\u00ee\u00f4\u00fb\u00c3\u00d1\u00d5\u00e3\u00f1\u00f5\u00c4\u00cb\u00cf\u00d6\u00dc\u0178\u00e4\u00eb\u00ef\u00f6\u00fc\u00ff\u00df\".indexOf(ch) !== -1\n  );\n}\nevaluate = compile(\"\u00eatre_embarass\u00e9\", {\n  isIdentifierStart: validChars,\n  isIdentifierContinue: validChars,\n});\n\nevaluate({ \u00eatre_embarass\u00e9: \"Ping\" });\n```\n\n### 1.0.1\n\n- Disallow access to prototype chain (CVE-2020-5219)\n\n### 1.0.0\n\n- Add support for `this` keyword to write :\n\n```javascript\nevaluate = compile(\"this + 2\")(2); // which gives 4\n```\n", "/* remove eslint errors to see if there is something really wrong */\n/*eslint quotes: [0]*/\n/*eslint indent: [0]*/\n/*eslint vars-on-top: [0]*/\n/*eslint yoda: 0*/\n/*eslint curly: 0*/\n/*eslint no-implicit-coercion: 0*/\n/*eslint newline-after-var: 0*/\n/*eslint space-before-function-paren: 0*/\n/*eslint block-spacing: 0*/\n/*eslint brace-style: 0*/\n/*eslint complexity: 0*/\n/*eslint one-var: 0*/\n/*eslint eqeqeq: 0*/\n/*eslint object-curly-spacing: 0*/\n/*eslint quote-props: 0*/\n/*eslint key-spacing: 0*/\n/*eslint valid-jsdoc: 0*/\n/*eslint func-style: 0*/\n/*eslint no-nested-ternary: 0*/\n/*eslint operator-linebreak: 0*/\n/*eslint no-multi-spaces: 0*/\n/*eslint no-constant-condition: 0*/\n/*eslint comma-spacing: 0*/\n/*eslint no-else-return: 0*/\n/*eslint no-warning-comments: 0*/\n/*eslint default-case: 0*/\n/*eslint consistent-return: 0*/\n/*eslint no-undefined: 0*/\n/*eslint no-new-func: 0*/\n/*eslint max-nested-callbacks: 0*/\n/*eslint padded-blocks: 0*/\n/*eslint no-self-compare: 0*/\n/*eslint no-multiple-empty-lines: 0*/\n/*eslint no-new: 0*/\n/*eslint no-unused-vars: 0*/\n\"use strict\";\n\nvar window = { document: {} };\n\n/* We need to tell ESLint what variables are being exported */\n/* exported\n  angular,\n  msie,\n  jqLite,\n  jQuery,\n  slice,\n  splice,\n  push,\n  toString,\n  ngMinErr,\n  angularModule,\n  uid,\n  REGEX_STRING_REGEXP,\n  VALIDITY_STATE_PROPERTY,\n\n  lowercase,\n  uppercase,\n  manualLowercase,\n  manualUppercase,\n  nodeName_,\n  isArrayLike,\n  forEach,\n  forEachSorted,\n  reverseParams,\n  nextUid,\n  setHashKey,\n  extend,\n  toInt,\n  inherit,\n  merge,\n  noop,\n  identity,\n  valueFn,\n  isUndefined,\n  isDefined,\n  isObject,\n  isBlankObject,\n  isString,\n  isNumber,\n  isNumberNaN,\n  isDate,\n  isArray,\n  isFunction,\n  isRegExp,\n  isWindow,\n  isScope,\n  isFile,\n  isFormData,\n  isBlob,\n  isBoolean,\n  isPromiseLike,\n  trim,\n  escapeForRegexp,\n  isElement,\n  makeMap,\n  includes,\n  arrayRemove,\n  copy,\n  equals,\n  csp,\n  jq,\n  concat,\n  sliceArgs,\n  bind,\n  toJsonReplacer,\n  toJson,\n  fromJson,\n  convertTimezoneToLocal,\n  timezoneToOffset,\n  startingTag,\n  tryDecodeURIComponent,\n  parseKeyValue,\n  toKeyValue,\n  encodeUriSegment,\n  encodeUriQuery,\n  angularInit,\n  bootstrap,\n  getTestability,\n  snake_case,\n  bindJQuery,\n  assertArg,\n  assertArgFn,\n  assertNotHasOwnProperty,\n  getter,\n  getBlockNodes,\n  hasOwnProperty,\n  createMap,\n  stringify,\n\n  NODE_TYPE_ELEMENT,\n  NODE_TYPE_ATTRIBUTE,\n  NODE_TYPE_TEXT,\n  NODE_TYPE_COMMENT,\n  NODE_TYPE_DOCUMENT,\n  NODE_TYPE_DOCUMENT_FRAGMENT\n*/\n\n////////////////////////////////////\n\n/**\n * @ngdoc module\n * @name ng\n * @module ng\n * @installation\n * @description\n *\n * # ng (core module)\n * The ng module is loaded by default when an AngularJS application is started. The module itself\n * contains the essential components for an AngularJS application to function. The table below\n * lists a high level breakdown of each of the services/factories, filters, directives and testing\n * components available within this core module.\n *\n * <div doc-module-components=\"ng\"></div>\n */\n\nvar NODE_TYPE_ELEMENT = 1;\nvar NODE_TYPE_ATTRIBUTE = 2;\nvar NODE_TYPE_TEXT = 3;\nvar NODE_TYPE_COMMENT = 8;\nvar NODE_TYPE_DOCUMENT = 9;\nvar NODE_TYPE_DOCUMENT_FRAGMENT = 11;\nvar REGEX_STRING_REGEXP = /^\\/(.+)\\/([a-z]*)$/;\n\n// The name of a form control's ValidityState property.\n// This is used so that it's possible for internal tests to create mock ValidityStates.\nvar VALIDITY_STATE_PROPERTY = \"validity\";\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar lowercase = function (string) {\n\treturn isString(string) ? string.toLowerCase() : string;\n};\nvar uppercase = function (string) {\n\treturn isString(string) ? string.toUpperCase() : string;\n};\n\n/**\n * @ngdoc function\n * @name angular.isArray\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is an `Array`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Array`.\n */\nvar isArray = Array.isArray;\n\nvar ngAttrPrefixes = [\"ng-\", \"data-ng-\", \"ng:\", \"x-ng-\"];\n\nvar manualLowercase = function (s) {\n\t/* eslint-disable no-bitwise */\n\treturn isString(s)\n\t\t? s.replace(/[A-Z]/g, function (ch) {\n\t\t\t\treturn String.fromCharCode(ch.charCodeAt(0) | 32);\n\t\t  })\n\t\t: s;\n\t/* eslint-enable */\n};\nvar manualUppercase = function (s) {\n\t/* eslint-disable no-bitwise */\n\treturn isString(s)\n\t\t? s.replace(/[a-z]/g, function (ch) {\n\t\t\t\treturn String.fromCharCode(ch.charCodeAt(0) & ~32);\n\t\t  })\n\t\t: s;\n\t/* eslint-enable */\n};\n\n// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish\n// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods\n// with correct but slower alternatives. See https://github.com/angular/angular.js/issues/11387\nif (\"i\" !== \"I\".toLowerCase()) {\n\tlowercase = manualLowercase;\n\tuppercase = manualUppercase;\n}\n\nvar msie, // holds major version number for IE, or NaN if UA is not IE.\n\tjqLite, // delay binding since jQuery could be loaded after us.\n\tjQuery, // delay binding\n\tslice = [].slice,\n\tsplice = [].splice,\n\tpush = [].push,\n\ttoString = Object.prototype.toString,\n\tgetPrototypeOf = Object.getPrototypeOf,\n\tngMinErr = minErr(\"ng\"),\n\t/** @name angular */\n\tangular = window.angular || (window.angular = {}),\n\tangularModule,\n\tuid = 0;\n\n/**\n * documentMode is an IE-only property\n * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx\n */\nmsie = window.document.documentMode;\n\n/**\n * @private\n * @param {*} obj\n * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,\n *                   String ...)\n */\nfunction isArrayLike(obj) {\n\t// `null`, `undefined` and `window` are not array-like\n\tif (obj == null || isWindow(obj)) return false;\n\n\t// arrays, strings and jQuery/jqLite objects are array like\n\t// * jqLite is either the jQuery or jqLite constructor function\n\t// * we have to check the existence of jqLite first as this method is called\n\t//   via the forEach method when constructing the jqLite object in the first place\n\tif (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))\n\t\treturn true;\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// \"length\" in obj used to prevent JIT error (gh-11508)\n\tvar length = \"length\" in Object(obj) && obj.length;\n\n\t// NodeList objects (with `item` method) and\n\t// other objects with suitable length characteristics are array-like\n\treturn (\n\t\tisNumber(length) &&\n\t\t((length >= 0 && (length - 1 in obj || obj instanceof Array)) ||\n\t\t\ttypeof obj.item === \"function\")\n\t);\n}\n\n/**\n * @ngdoc function\n * @name angular.forEach\n * @module ng\n * @kind function\n *\n * @description\n * Invokes the `iterator` function once for each item in `obj` collection, which can be either an\n * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`\n * is the value of an object property or an array element, `key` is the object property key or\n * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.\n *\n * It is worth noting that `.forEach` does not iterate over inherited properties because it filters\n * using the `hasOwnProperty` method.\n *\n * Unlike ES262's\n * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),\n * providing 'undefined' or 'null' values for `obj` will not throw a TypeError, but rather just\n * return the value provided.\n *\n   ```js\n     var values = {name: 'misko', gender: 'male'};\n     var log = [];\n     angular.forEach(values, function(value, key) {\n       this.push(key + ': ' + value);\n     }, log);\n     expect(log).toEqual(['name: misko', 'gender: male']);\n   ```\n *\n * @param {Object|Array} obj Object to iterate over.\n * @param {Function} iterator Iterator function.\n * @param {Object=} context Object to become context (`this`) for the iterator function.\n * @returns {Object|Array} Reference to `obj`.\n */\n\nfunction forEach(obj, iterator, context) {\n\tvar key, length;\n\tif (obj) {\n\t\tif (isFunction(obj)) {\n\t\t\tfor (key in obj) {\n\t\t\t\tif (\n\t\t\t\t\tkey !== \"prototype\" &&\n\t\t\t\t\tkey !== \"length\" &&\n\t\t\t\t\tkey !== \"name\" &&\n\t\t\t\t\tobj.hasOwnProperty(key)\n\t\t\t\t) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isArray(obj) || isArrayLike(obj)) {\n\t\t\tvar isPrimitive = typeof obj !== \"object\";\n\t\t\tfor (key = 0, length = obj.length; key < length; key++) {\n\t\t\t\tif (isPrimitive || key in obj) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (obj.forEach && obj.forEach !== forEach) {\n\t\t\tobj.forEach(iterator, context, obj);\n\t\t} else if (isBlankObject(obj)) {\n\t\t\t// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (key in obj) {\n\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t}\n\t\t} else if (typeof obj.hasOwnProperty === \"function\") {\n\t\t\t// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed\n\t\t\tfor (key in obj) {\n\t\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Slow path for objects which do not have a method `hasOwnProperty`\n\t\t\tfor (key in obj) {\n\t\t\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\t\t\titerator.call(context, obj[key], key, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\nfunction forEachSorted(obj, iterator, context) {\n\tvar keys = Object.keys(obj).sort();\n\tfor (var i = 0; i < keys.length; i++) {\n\t\titerator.call(context, obj[keys[i]], keys[i]);\n\t}\n\treturn keys;\n}\n\n/**\n * when using forEach the params are value, key, but it is often useful to have key, value.\n * @param {function(string, *)} iteratorFn\n * @returns {function(*, string)}\n */\nfunction reverseParams(iteratorFn) {\n\treturn function (value, key) {\n\t\titeratorFn(key, value);\n\t};\n}\n\n/**\n * A consistent way of creating unique IDs in angular.\n *\n * Using simple numbers allows us to generate 28.6 million unique ids per second for 10 years before\n * we hit number precision issues in JavaScript.\n *\n * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 = 28.6M\n *\n * @returns {number} an unique alpha-numeric string\n */\nfunction nextUid() {\n\treturn ++uid;\n}\n\n/**\n * Set or clear the hashkey for an object.\n * @param obj object\n * @param h the hashkey (!truthy to delete the hashkey)\n */\nfunction setHashKey(obj, h) {\n\tif (h) {\n\t\tobj.$$hashKey = h;\n\t} else {\n\t\tdelete obj.$$hashKey;\n\t}\n}\n\nfunction baseExtend(dst, objs, deep) {\n\tvar h = dst.$$hashKey;\n\n\tfor (var i = 0, ii = objs.length; i < ii; ++i) {\n\t\tvar obj = objs[i];\n\t\tif (!isObject(obj) && !isFunction(obj)) continue;\n\t\tvar keys = Object.keys(obj);\n\t\tfor (var j = 0, jj = keys.length; j < jj; j++) {\n\t\t\tvar key = keys[j];\n\t\t\tvar src = obj[key];\n\n\t\t\tif (deep && isObject(src)) {\n\t\t\t\tif (isDate(src)) {\n\t\t\t\t\tdst[key] = new Date(src.valueOf());\n\t\t\t\t} else if (isRegExp(src)) {\n\t\t\t\t\tdst[key] = new RegExp(src);\n\t\t\t\t} else if (src.nodeName) {\n\t\t\t\t\tdst[key] = src.cloneNode(true);\n\t\t\t\t} else if (isElement(src)) {\n\t\t\t\t\tdst[key] = src.clone();\n\t\t\t\t} else {\n\t\t\t\t\tif (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};\n\t\t\t\t\tbaseExtend(dst[key], [src], true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst[key] = src;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetHashKey(dst, h);\n\treturn dst;\n}\n\n/**\n * @ngdoc function\n * @name angular.extend\n * @module ng\n * @kind function\n *\n * @description\n * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)\n * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so\n * by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.\n *\n * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy). Use\n * {@link angular.merge} for this.\n *\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nfunction extend(dst) {\n\treturn baseExtend(dst, slice.call(arguments, 1), false);\n}\n\n/**\n * @ngdoc function\n * @name angular.merge\n * @module ng\n * @kind function\n *\n * @description\n * Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)\n * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so\n * by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.\n *\n * Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source\n * objects, performing a deep copy.\n *\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nfunction merge(dst) {\n\treturn baseExtend(dst, slice.call(arguments, 1), true);\n}\n\nfunction toInt(str) {\n\treturn parseInt(str, 10);\n}\n\nvar isNumberNaN =\n\tNumber.isNaN ||\n\tfunction isNumberNaN(num) {\n\t\t// eslint-disable-next-line no-self-compare\n\t\treturn num !== num;\n\t};\n\nfunction inherit(parent, extra) {\n\treturn extend(Object.create(parent), extra);\n}\n\n/**\n * @ngdoc function\n * @name angular.noop\n * @module ng\n * @kind function\n *\n * @description\n * A function that performs no operations. This function can be useful when writing code in the\n * functional style.\n   ```js\n     function foo(callback) {\n       var result = calculateResult();\n       (callback || angular.noop)(result);\n     }\n   ```\n */\nfunction noop() {}\nnoop.$inject = [];\n\n/**\n * @ngdoc function\n * @name angular.identity\n * @module ng\n * @kind function\n *\n * @description\n * A function that returns its first argument. This function is useful when writing code in the\n * functional style.\n *\n   ```js\n   function transformer(transformationFn, value) {\n     return (transformationFn || angular.identity)(value);\n   };\n\n   // E.g.\n   function getResult(fn, input) {\n     return (fn || angular.identity)(input);\n   };\n\n   getResult(function(n) { return n * 2; }, 21);   // returns 42\n   getResult(null, 21);                            // returns 21\n   getResult(undefined, 21);                       // returns 21\n   ```\n *\n * @param {*} value to be returned.\n * @returns {*} the value passed in.\n */\nfunction identity($) {\n\treturn $;\n}\nidentity.$inject = [];\n\nfunction valueFn(value) {\n\treturn function valueRef() {\n\t\treturn value;\n\t};\n}\n\nfunction hasCustomToString(obj) {\n\treturn isFunction(obj.toString) && obj.toString !== toString;\n}\n\n/**\n * @ngdoc function\n * @name angular.isUndefined\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is undefined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is undefined.\n */\nfunction isUndefined(value) {\n\treturn typeof value === \"undefined\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isDefined\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is defined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is defined.\n */\nfunction isDefined(value) {\n\treturn typeof value !== \"undefined\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isObject\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\n * considered to be objects. Note that JavaScript arrays are objects.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Object` but not `null`.\n */\nfunction isObject(value) {\n\t// http://jsperf.com/isobject4\n\treturn value !== null && typeof value === \"object\";\n}\n\n/**\n * Determine if a value is an object with a null prototype\n *\n * @returns {boolean} True if `value` is an `Object` with a null prototype\n */\nfunction isBlankObject(value) {\n\treturn value !== null && typeof value === \"object\" && !getPrototypeOf(value);\n}\n\n/**\n * @ngdoc function\n * @name angular.isString\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `String`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `String`.\n */\nfunction isString(value) {\n\treturn typeof value === \"string\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isNumber\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `Number`.\n *\n * This includes the \"special\" numbers `NaN`, `+Infinity` and `-Infinity`.\n *\n * If you wish to exclude these then you can use the native\n * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)\n * method.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Number`.\n */\nfunction isNumber(value) {\n\treturn typeof value === \"number\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isDate\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a value is a date.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Date`.\n */\nfunction isDate(value) {\n\treturn toString.call(value) === \"[object Date]\";\n}\n\n/**\n * @ngdoc function\n * @name angular.isFunction\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `Function`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Function`.\n */\nfunction isFunction(value) {\n\treturn typeof value === \"function\";\n}\n\n/**\n * Determines if a value is a regular expression object.\n *\n * @private\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `RegExp`.\n */\nfunction isRegExp(value) {\n\treturn toString.call(value) === \"[object RegExp]\";\n}\n\n/**\n * Checks if `obj` is a window object.\n *\n * @private\n * @param {*} obj Object to check\n * @returns {boolean} True if `obj` is a window obj.\n */\nfunction isWindow(obj) {\n\treturn obj && obj.window === obj;\n}\n\nfunction isScope(obj) {\n\treturn obj && obj.$evalAsync && obj.$watch;\n}\n\nfunction isFile(obj) {\n\treturn toString.call(obj) === \"[object File]\";\n}\n\nfunction isFormData(obj) {\n\treturn toString.call(obj) === \"[object FormData]\";\n}\n\nfunction isBlob(obj) {\n\treturn toString.call(obj) === \"[object Blob]\";\n}\n\nfunction isBoolean(value) {\n\treturn typeof value === \"boolean\";\n}\n\nfunction isPromiseLike(obj) {\n\treturn obj && isFunction(obj.then);\n}\n\nvar TYPED_ARRAY_REGEXP = /^\\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\\]$/;\nfunction isTypedArray(value) {\n\treturn (\n\t\tvalue &&\n\t\tisNumber(value.length) &&\n\t\tTYPED_ARRAY_REGEXP.test(toString.call(value))\n\t);\n}\n\nfunction isArrayBuffer(obj) {\n\treturn toString.call(obj) === \"[object ArrayBuffer]\";\n}\n\nvar trim = function (value) {\n\treturn isString(value) ? value.trim() : value;\n};\n\n// Copied from:\n// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021\n// Prereq: s is a string.\nvar escapeForRegexp = function (s) {\n\treturn (\n\t\ts\n\t\t\t.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, \"\\\\$1\")\n\t\t\t// eslint-disable-next-line no-control-regex\n\t\t\t.replace(/\\x08/g, \"\\\\x08\")\n\t);\n};\n\n/**\n * @ngdoc function\n * @name angular.isElement\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a DOM element (or wrapped jQuery element).\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).\n */\nfunction isElement(node) {\n\treturn !!(\n\t\tnode &&\n\t\t(node.nodeName || // We are a direct element.\n\t\t\t(node.prop && node.attr && node.find))\n\t); // We have an on and find method part of jQuery API.\n}\n\n/**\n * @param str 'key1,key2,...'\n * @returns {object} in the form of {key1:true, key2:true, ...}\n */\nfunction makeMap(str) {\n\tvar obj = {},\n\t\titems = str.split(\",\"),\n\t\ti;\n\tfor (i = 0; i < items.length; i++) {\n\t\tobj[items[i]] = true;\n\t}\n\treturn obj;\n}\n\nfunction nodeName_(element) {\n\treturn lowercase(element.nodeName || (element[0] && element[0].nodeName));\n}\n\nfunction includes(array, obj) {\n\treturn Array.prototype.indexOf.call(array, obj) !== -1;\n}\n\nfunction arrayRemove(array, value) {\n\tvar index = array.indexOf(value);\n\tif (index >= 0) {\n\t\tarray.splice(index, 1);\n\t}\n\treturn index;\n}\n\n/**\n * @ngdoc function\n * @name angular.copy\n * @module ng\n * @kind function\n *\n * @description\n * Creates a deep copy of `source`, which should be an object or an array.\n *\n * * If no destination is supplied, a copy of the object or array is created.\n * * If a destination is provided, all of its elements (for arrays) or properties (for objects)\n *   are deleted and then all elements/properties from the source are copied to it.\n * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.\n * * If `source` is identical to `destination` an exception will be thrown.\n *\n * <br />\n * <div class=\"alert alert-warning\">\n *   Only enumerable properties are taken into account. Non-enumerable properties (both on `source`\n *   and on `destination`) will be ignored.\n * </div>\n *\n * @param {*} source The source that will be used to make a copy.\n *                   Can be any type, including primitives, `null`, and `undefined`.\n * @param {(Object|Array)=} destination Destination into which the source is copied. If\n *     provided, must be of the same type as `source`.\n * @returns {*} The copy or updated `destination`, if `destination` was specified.\n *\n * @example\n  <example module=\"copyExample\" name=\"angular-copy\">\n    <file name=\"index.html\">\n      <div ng-controller=\"ExampleController\">\n        <form novalidate class=\"simple-form\">\n          <label>Name: <input type=\"text\" ng-model=\"user.name\" /></label><br />\n          <label>Age:  <input type=\"number\" ng-model=\"user.age\" /></label><br />\n          Gender: <label><input type=\"radio\" ng-model=\"user.gender\" value=\"male\" />male</label>\n                  <label><input type=\"radio\" ng-model=\"user.gender\" value=\"female\" />female</label><br />\n          <button ng-click=\"reset()\">RESET</button>\n          <button ng-click=\"update(user)\">SAVE</button>\n        </form>\n        <pre>form = {{user | json}}</pre>\n        <pre>master = {{master | json}}</pre>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      // Module: copyExample\n      angular.\n        module('copyExample', []).\n        controller('ExampleController', ['$scope', function($scope) {\n          $scope.master = {};\n\n          $scope.reset = function() {\n            // Example with 1 argument\n            $scope.user = angular.copy($scope.master);\n          };\n\n          $scope.update = function(user) {\n            // Example with 2 arguments\n            angular.copy(user, $scope.master);\n          };\n\n          $scope.reset();\n        }]);\n    </file>\n  </example>\n */\nfunction copy(source, destination) {\n\tvar stackSource = [];\n\tvar stackDest = [];\n\n\tif (destination) {\n\t\tif (isTypedArray(destination) || isArrayBuffer(destination)) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpta\",\n\t\t\t\t\"Can't copy! TypedArray destination cannot be mutated.\"\n\t\t\t);\n\t\t}\n\t\tif (source === destination) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpi\",\n\t\t\t\t\"Can't copy! Source and destination are identical.\"\n\t\t\t);\n\t\t}\n\n\t\t// Empty the destination object\n\t\tif (isArray(destination)) {\n\t\t\tdestination.length = 0;\n\t\t} else {\n\t\t\tforEach(destination, function (value, key) {\n\t\t\t\tif (key !== \"$$hashKey\") {\n\t\t\t\t\tdelete destination[key];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tstackSource.push(source);\n\t\tstackDest.push(destination);\n\t\treturn copyRecurse(source, destination);\n\t}\n\n\treturn copyElement(source);\n\n\tfunction copyRecurse(source, destination) {\n\t\tvar h = destination.$$hashKey;\n\t\tvar key;\n\t\tif (isArray(source)) {\n\t\t\tfor (var i = 0, ii = source.length; i < ii; i++) {\n\t\t\t\tdestination.push(copyElement(source[i]));\n\t\t\t}\n\t\t} else if (isBlankObject(source)) {\n\t\t\t// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (key in source) {\n\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t}\n\t\t} else if (source && typeof source.hasOwnProperty === \"function\") {\n\t\t\t// Slow path, which must rely on hasOwnProperty\n\t\t\tfor (key in source) {\n\t\t\t\tif (source.hasOwnProperty(key)) {\n\t\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Slowest path --- hasOwnProperty can't be called as a method\n\t\t\tfor (key in source) {\n\t\t\t\tif (hasOwnProperty.call(source, key)) {\n\t\t\t\t\tdestination[key] = copyElement(source[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetHashKey(destination, h);\n\t\treturn destination;\n\t}\n\n\tfunction copyElement(source) {\n\t\t// Simple values\n\t\tif (!isObject(source)) {\n\t\t\treturn source;\n\t\t}\n\n\t\t// Already copied values\n\t\tvar index = stackSource.indexOf(source);\n\t\tif (index !== -1) {\n\t\t\treturn stackDest[index];\n\t\t}\n\n\t\tif (isWindow(source) || isScope(source)) {\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"cpws\",\n\t\t\t\t\"Can't copy! Making copies of Window or Scope instances is not supported.\"\n\t\t\t);\n\t\t}\n\n\t\tvar needsRecurse = false;\n\t\tvar destination = copyType(source);\n\n\t\tif (destination === undefined) {\n\t\t\tdestination = isArray(source)\n\t\t\t\t? []\n\t\t\t\t: Object.create(getPrototypeOf(source));\n\t\t\tneedsRecurse = true;\n\t\t}\n\n\t\tstackSource.push(source);\n\t\tstackDest.push(destination);\n\n\t\treturn needsRecurse ? copyRecurse(source, destination) : destination;\n\t}\n\n\tfunction copyType(source) {\n\t\tswitch (toString.call(source)) {\n\t\t\tcase \"[object Int8Array]\":\n\t\t\tcase \"[object Int16Array]\":\n\t\t\tcase \"[object Int32Array]\":\n\t\t\tcase \"[object Float32Array]\":\n\t\t\tcase \"[object Float64Array]\":\n\t\t\tcase \"[object Uint8Array]\":\n\t\t\tcase \"[object Uint8ClampedArray]\":\n\t\t\tcase \"[object Uint16Array]\":\n\t\t\tcase \"[object Uint32Array]\":\n\t\t\t\treturn new source.constructor(\n\t\t\t\t\tcopyElement(source.buffer),\n\t\t\t\t\tsource.byteOffset,\n\t\t\t\t\tsource.length\n\t\t\t\t);\n\n\t\t\tcase \"[object ArrayBuffer]\":\n\t\t\t\t// Support: IE10\n\t\t\t\tif (!source.slice) {\n\t\t\t\t\t// If we're in this case we know the environment supports ArrayBuffer\n\t\t\t\t\t/* eslint-disable no-undef */\n\t\t\t\t\tvar copied = new ArrayBuffer(source.byteLength);\n\t\t\t\t\tnew Uint8Array(copied).set(new Uint8Array(source));\n\t\t\t\t\t/* eslint-enable */\n\t\t\t\t\treturn copied;\n\t\t\t\t}\n\t\t\t\treturn source.slice(0);\n\n\t\t\tcase \"[object Boolean]\":\n\t\t\tcase \"[object Number]\":\n\t\t\tcase \"[object String]\":\n\t\t\tcase \"[object Date]\":\n\t\t\t\treturn new source.constructor(source.valueOf());\n\n\t\t\tcase \"[object RegExp]\":\n\t\t\t\tvar re = new RegExp(\n\t\t\t\t\tsource.source,\n\t\t\t\t\tsource.toString().match(/[^\\/]*$/)[0]\n\t\t\t\t);\n\t\t\t\tre.lastIndex = source.lastIndex;\n\t\t\t\treturn re;\n\n\t\t\tcase \"[object Blob]\":\n\t\t\t\treturn new source.constructor([source], { type: source.type });\n\t\t}\n\n\t\tif (isFunction(source.cloneNode)) {\n\t\t\treturn source.cloneNode(true);\n\t\t}\n\t}\n}\n\n/**\n * @ngdoc function\n * @name angular.equals\n * @module ng\n * @kind function\n *\n * @description\n * Determines if two objects or two values are equivalent. Supports value types, regular\n * expressions, arrays and objects.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties are equal by\n *   comparing them with `angular.equals`.\n * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)\n * * Both values represent the same regular expression (In JavaScript,\n *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual\n *   representation matches).\n *\n * During a property comparison, properties of `function` type and properties with names\n * that begin with `$` are ignored.\n *\n * Scope and DOMWindow objects are being compared only by identify (`===`).\n *\n * @param {*} o1 Object or value to compare.\n * @param {*} o2 Object or value to compare.\n * @returns {boolean} True if arguments are equal.\n *\n * @example\n   <example module=\"equalsExample\" name=\"equalsExample\">\n     <file name=\"index.html\">\n      <div ng-controller=\"ExampleController\">\n        <form novalidate>\n          <h3>User 1</h3>\n          Name: <input type=\"text\" ng-model=\"user1.name\">\n          Age: <input type=\"number\" ng-model=\"user1.age\">\n\n          <h3>User 2</h3>\n          Name: <input type=\"text\" ng-model=\"user2.name\">\n          Age: <input type=\"number\" ng-model=\"user2.age\">\n\n          <div>\n            <br/>\n            <input type=\"button\" value=\"Compare\" ng-click=\"compare()\">\n          </div>\n          User 1: <pre>{{user1 | json}}</pre>\n          User 2: <pre>{{user2 | json}}</pre>\n          Equal: <pre>{{result}}</pre>\n        </form>\n      </div>\n    </file>\n    <file name=\"script.js\">\n        angular.module('equalsExample', []).controller('ExampleController', ['$scope', function($scope) {\n          $scope.user1 = {};\n          $scope.user2 = {};\n          $scope.compare = function() {\n            $scope.result = angular.equals($scope.user1, $scope.user2);\n          };\n        }]);\n    </file>\n  </example>\n */\nfunction equals(o1, o2) {\n\tif (o1 === o2) return true;\n\tif (o1 === null || o2 === null) return false;\n\t// eslint-disable-next-line no-self-compare\n\tif (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n\tvar t1 = typeof o1,\n\t\tt2 = typeof o2,\n\t\tlength,\n\t\tkey,\n\t\tkeySet;\n\tif (t1 === t2 && t1 === \"object\") {\n\t\tif (isArray(o1)) {\n\t\t\tif (!isArray(o2)) return false;\n\t\t\tif ((length = o1.length) === o2.length) {\n\t\t\t\tfor (key = 0; key < length; key++) {\n\t\t\t\t\tif (!equals(o1[key], o2[key])) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (isDate(o1)) {\n\t\t\tif (!isDate(o2)) return false;\n\t\t\treturn equals(o1.getTime(), o2.getTime());\n\t\t} else if (isRegExp(o1)) {\n\t\t\tif (!isRegExp(o2)) return false;\n\t\t\treturn o1.toString() === o2.toString();\n\t\t} else {\n\t\t\tif (\n\t\t\t\tisScope(o1) ||\n\t\t\t\tisScope(o2) ||\n\t\t\t\tisWindow(o1) ||\n\t\t\t\tisWindow(o2) ||\n\t\t\t\tisArray(o2) ||\n\t\t\t\tisDate(o2) ||\n\t\t\t\tisRegExp(o2)\n\t\t\t)\n\t\t\t\treturn false;\n\t\t\tkeySet = createMap();\n\t\t\tfor (key in o1) {\n\t\t\t\tif (key.charAt(0) === \"$\" || isFunction(o1[key])) continue;\n\t\t\t\tif (!equals(o1[key], o2[key])) return false;\n\t\t\t\tkeySet[key] = true;\n\t\t\t}\n\t\t\tfor (key in o2) {\n\t\t\t\tif (\n\t\t\t\t\t!(key in keySet) &&\n\t\t\t\t\tkey.charAt(0) !== \"$\" &&\n\t\t\t\t\tisDefined(o2[key]) &&\n\t\t\t\t\t!isFunction(o2[key])\n\t\t\t\t)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvar csp = function () {\n\tif (!isDefined(csp.rules)) {\n\t\tvar ngCspElement =\n\t\t\twindow.document.querySelector(\"[ng-csp]\") ||\n\t\t\twindow.document.querySelector(\"[data-ng-csp]\");\n\n\t\tif (ngCspElement) {\n\t\t\tvar ngCspAttribute =\n\t\t\t\tngCspElement.getAttribute(\"ng-csp\") ||\n\t\t\t\tngCspElement.getAttribute(\"data-ng-csp\");\n\t\t\tcsp.rules = {\n\t\t\t\tnoUnsafeEval:\n\t\t\t\t\t!ngCspAttribute || ngCspAttribute.indexOf(\"no-unsafe-eval\") !== -1,\n\t\t\t\tnoInlineStyle:\n\t\t\t\t\t!ngCspAttribute || ngCspAttribute.indexOf(\"no-inline-style\") !== -1,\n\t\t\t};\n\t\t} else {\n\t\t\tcsp.rules = {\n\t\t\t\tnoUnsafeEval: noUnsafeEval(),\n\t\t\t\tnoInlineStyle: false,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn csp.rules;\n\n\tfunction noUnsafeEval() {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new, no-new-func\n\t\t\tnew Function(\"\");\n\t\t\treturn false;\n\t\t} catch (e) {\n\t\t\treturn true;\n\t\t}\n\t}\n};\n\n/**\n * @ngdoc directive\n * @module ng\n * @name ngJq\n *\n * @element ANY\n * @param {string=} ngJq the name of the library available under `window`\n * to be used for angular.element\n * @description\n * Use this directive to force the angular.element library.  This should be\n * used to force either jqLite by leaving ng-jq blank or setting the name of\n * the jquery variable under window (eg. jQuery).\n *\n * Since angular looks for this directive when it is loaded (doesn't wait for the\n * DOMContentLoaded event), it must be placed on an element that comes before the script\n * which loads angular. Also, only the first instance of `ng-jq` will be used and all\n * others ignored.\n *\n * @example\n * This example shows how to force jqLite using the `ngJq` directive to the `html` tag.\n ```html\n <!doctype html>\n <html ng-app ng-jq>\n ...\n ...\n </html>\n ```\n * @example\n * This example shows how to use a jQuery based library of a different name.\n * The library name must be available at the top most 'window'.\n ```html\n <!doctype html>\n <html ng-app ng-jq=\"jQueryLib\">\n ...\n ...\n </html>\n ```\n */\nvar jq = function () {\n\tif (isDefined(jq.name_)) return jq.name_;\n\tvar el;\n\tvar i,\n\t\tii = ngAttrPrefixes.length,\n\t\tprefix,\n\t\tname;\n\tfor (i = 0; i < ii; ++i) {\n\t\tprefix = ngAttrPrefixes[i];\n\t\tel = window.document.querySelector(\n\t\t\t\"[\" + prefix.replace(\":\", \"\\\\:\") + \"jq]\"\n\t\t);\n\t\tif (el) {\n\t\t\tname = el.getAttribute(prefix + \"jq\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (jq.name_ = name);\n};\n\nfunction concat(array1, array2, index) {\n\treturn array1.concat(slice.call(array2, index));\n}\n\nfunction sliceArgs(args, startIndex) {\n\treturn slice.call(args, startIndex || 0);\n}\n\n/**\n * @ngdoc function\n * @name angular.bind\n * @module ng\n * @kind function\n *\n * @description\n * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\n * `fn`). You can supply optional `args` that are prebound to the function. This feature is also\n * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as\n * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).\n *\n * @param {Object} self Context which `fn` should be evaluated in.\n * @param {function()} fn Function to be bound.\n * @param {...*} args Optional arguments to be prebound to the `fn` function call.\n * @returns {function()} Function that wraps the `fn` with all the specified bindings.\n */\n// eslint-disable-next-line consistent-this\nfunction bind(self, fn) {\n\tvar curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];\n\tif (isFunction(fn) && !(fn instanceof RegExp)) {\n\t\treturn curryArgs.length\n\t\t\t? function () {\n\t\t\t\t\treturn arguments.length\n\t\t\t\t\t\t? fn.apply(self, concat(curryArgs, arguments, 0))\n\t\t\t\t\t\t: fn.apply(self, curryArgs);\n\t\t\t  }\n\t\t\t: function () {\n\t\t\t\t\treturn arguments.length ? fn.apply(self, arguments) : fn.call(self);\n\t\t\t  };\n\t} else {\n\t\t// In IE, native methods are not functions so they cannot be bound (note: they don't need to be).\n\t\treturn fn;\n\t}\n}\n\nfunction toJsonReplacer(key, value) {\n\tvar val = value;\n\n\tif (\n\t\ttypeof key === \"string\" &&\n\t\tkey.charAt(0) === \"$\" &&\n\t\tkey.charAt(1) === \"$\"\n\t) {\n\t\tval = undefined;\n\t} else if (isWindow(value)) {\n\t\tval = \"$WINDOW\";\n\t} else if (value && window.document === value) {\n\t\tval = \"$DOCUMENT\";\n\t} else if (isScope(value)) {\n\t\tval = \"$SCOPE\";\n\t}\n\n\treturn val;\n}\n\n/**\n * @ngdoc function\n * @name angular.toJson\n * @module ng\n * @kind function\n *\n * @description\n * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be\n * stripped since angular uses this notation internally.\n *\n * @param {Object|Array|Date|string|number|boolean} obj Input to be serialized into JSON.\n * @param {boolean|number} [pretty=2] If set to true, the JSON output will contain newlines and whitespace.\n *    If set to an integer, the JSON output will contain that many spaces per indentation.\n * @returns {string|undefined} JSON-ified string representing `obj`.\n * @knownIssue\n *\n * The Safari browser throws a `RangeError` instead of returning `null` when it tries to stringify a `Date`\n * object with an invalid date value. The only reliable way to prevent this is to monkeypatch the\n * `Date.prototype.toJSON` method as follows:\n *\n * ```\n * var _DatetoJSON = Date.prototype.toJSON;\n * Date.prototype.toJSON = function() {\n *   try {\n *     return _DatetoJSON.call(this);\n *   } catch(e) {\n *     if (e instanceof RangeError) {\n *       return null;\n *     }\n *     throw e;\n *   }\n * };\n * ```\n *\n * See https://github.com/angular/angular.js/pull/14221 for more information.\n */\nfunction toJson(obj, pretty) {\n\tif (isUndefined(obj)) return undefined;\n\tif (!isNumber(pretty)) {\n\t\tpretty = pretty ? 2 : null;\n\t}\n\treturn JSON.stringify(obj, toJsonReplacer, pretty);\n}\n\n/**\n * @ngdoc function\n * @name angular.fromJson\n * @module ng\n * @kind function\n *\n * @description\n * Deserializes a JSON string.\n *\n * @param {string} json JSON string to deserialize.\n * @returns {Object|Array|string|number} Deserialized JSON string.\n */\nfunction fromJson(json) {\n\treturn isString(json) ? JSON.parse(json) : json;\n}\n\nvar ALL_COLONS = /:/g;\nfunction timezoneToOffset(timezone, fallback) {\n\t// IE/Edge do not \"understand\" colon (`:`) in timezone\n\ttimezone = timezone.replace(ALL_COLONS, \"\");\n\tvar requestedTimezoneOffset =\n\t\tDate.parse(\"Jan 01, 1970 00:00:00 \" + timezone) / 60000;\n\treturn isNumberNaN(requestedTimezoneOffset)\n\t\t? fallback\n\t\t: requestedTimezoneOffset;\n}\n\nfunction addDateMinutes(date, minutes) {\n\tdate = new Date(date.getTime());\n\tdate.setMinutes(date.getMinutes() + minutes);\n\treturn date;\n}\n\nfunction convertTimezoneToLocal(date, timezone, reverse) {\n\treverse = reverse ? -1 : 1;\n\tvar dateTimezoneOffset = date.getTimezoneOffset();\n\tvar timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n\treturn addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));\n}\n\n/**\n * @returns {string} Returns the string representation of the element.\n */\nfunction startingTag(element) {\n\telement = jqLite(element).clone();\n\ttry {\n\t\t// turns out IE does not let you set .html() on elements which\n\t\t// are not allowed to have children. So we just ignore it.\n\t\telement.empty();\n\t} catch (e) {\n\t\t/* empty */\n\t}\n\tvar elemHtml = jqLite(\"<div>\").append(element).html();\n\ttry {\n\t\treturn element[0].nodeType === NODE_TYPE_TEXT\n\t\t\t? lowercase(elemHtml)\n\t\t\t: elemHtml\n\t\t\t\t\t.match(/^(<[^>]+>)/)[1]\n\t\t\t\t\t.replace(/^<([\\w\\-]+)/, function (match, nodeName) {\n\t\t\t\t\t\treturn \"<\" + lowercase(nodeName);\n\t\t\t\t\t});\n\t} catch (e) {\n\t\treturn lowercase(elemHtml);\n\t}\n}\n\n/////////////////////////////////////////////////\n\n/**\n * Tries to decode the URI component without throwing an exception.\n *\n * @private\n * @param str value potential URI component to check.\n * @returns {boolean} True if `value` can be decoded\n * with the decodeURIComponent function.\n */\nfunction tryDecodeURIComponent(value) {\n\ttry {\n\t\treturn decodeURIComponent(value);\n\t} catch (e) {\n\t\t// Ignore any invalid uri component.\n\t}\n}\n\n/**\n * Parses an escaped url query string into key-value pairs.\n * @returns {Object.<string,boolean|Array>}\n */\nfunction parseKeyValue(/**string*/ keyValue) {\n\tvar obj = {};\n\tforEach((keyValue || \"\").split(\"&\"), function (keyValue) {\n\t\tvar splitPoint, key, val;\n\t\tif (keyValue) {\n\t\t\tkey = keyValue = keyValue.replace(/\\+/g, \"%20\");\n\t\t\tsplitPoint = keyValue.indexOf(\"=\");\n\t\t\tif (splitPoint !== -1) {\n\t\t\t\tkey = keyValue.substring(0, splitPoint);\n\t\t\t\tval = keyValue.substring(splitPoint + 1);\n\t\t\t}\n\t\t\tkey = tryDecodeURIComponent(key);\n\t\t\tif (isDefined(key)) {\n\t\t\t\tval = isDefined(val) ? tryDecodeURIComponent(val) : true;\n\t\t\t\tif (!hasOwnProperty.call(obj, key)) {\n\t\t\t\t\tobj[key] = val;\n\t\t\t\t} else if (isArray(obj[key])) {\n\t\t\t\t\tobj[key].push(val);\n\t\t\t\t} else {\n\t\t\t\t\tobj[key] = [obj[key], val];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\treturn obj;\n}\n\nfunction toKeyValue(obj) {\n\tvar parts = [];\n\tforEach(obj, function (value, key) {\n\t\tif (isArray(value)) {\n\t\t\tforEach(value, function (arrayValue) {\n\t\t\t\tparts.push(\n\t\t\t\t\tencodeUriQuery(key, true) +\n\t\t\t\t\t\t(arrayValue === true ? \"\" : \"=\" + encodeUriQuery(arrayValue, true))\n\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tparts.push(\n\t\t\t\tencodeUriQuery(key, true) +\n\t\t\t\t\t(value === true ? \"\" : \"=\" + encodeUriQuery(value, true))\n\t\t\t);\n\t\t}\n\t});\n\treturn parts.length ? parts.join(\"&\") : \"\";\n}\n\n/**\n * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\n * segments:\n *    segment       = *pchar\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriSegment(val) {\n\treturn encodeUriQuery(val, true)\n\t\t.replace(/%26/gi, \"&\")\n\t\t.replace(/%3D/gi, \"=\")\n\t\t.replace(/%2B/gi, \"+\");\n}\n\n/**\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\n * encoded per http://tools.ietf.org/html/rfc3986:\n *    query         = *( pchar / \"/\" / \"?\" )\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriQuery(val, pctEncodeSpaces) {\n\treturn encodeURIComponent(val)\n\t\t.replace(/%40/gi, \"@\")\n\t\t.replace(/%3A/gi, \":\")\n\t\t.replace(/%24/g, \"$\")\n\t\t.replace(/%2C/gi, \",\")\n\t\t.replace(/%3B/gi, \";\")\n\t\t.replace(/%20/g, pctEncodeSpaces ? \"%20\" : \"+\");\n}\n\nfunction getNgAttribute(element, ngAttr) {\n\tvar attr,\n\t\ti,\n\t\tii = ngAttrPrefixes.length;\n\tfor (i = 0; i < ii; ++i) {\n\t\tattr = ngAttrPrefixes[i] + ngAttr;\n\t\tif (isString((attr = element.getAttribute(attr)))) {\n\t\t\treturn attr;\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction allowAutoBootstrap(document) {\n\tif (!document.currentScript) {\n\t\treturn true;\n\t}\n\tvar src = document.currentScript.getAttribute(\"src\");\n\tvar link = document.createElement(\"a\");\n\tlink.href = src;\n\tvar scriptProtocol = link.protocol;\n\tvar docLoadProtocol = document.location.protocol;\n\tif (\n\t\t(scriptProtocol === \"resource:\" ||\n\t\t\tscriptProtocol === \"chrome-extension:\") &&\n\t\tdocLoadProtocol !== scriptProtocol\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Cached as it has to run during loading so that document.currentScript is available.\nvar isAutoBootstrapAllowed = allowAutoBootstrap(window.document);\n\n/**\n * @ngdoc directive\n * @name ngApp\n * @module ng\n *\n * @element ANY\n * @param {angular.Module} ngApp an optional application\n *   {@link angular.module module} name to load.\n * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be\n *   created in \"strict-di\" mode. This means that the application will fail to invoke functions which\n *   do not use explicit function annotation (and are thus unsuitable for minification), as described\n *   in {@link guide/di the Dependency Injection guide}, and useful debugging info will assist in\n *   tracking down the root of these bugs.\n *\n * @description\n *\n * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive\n * designates the **root element** of the application and is typically placed near the root element\n * of the page - e.g. on the `<body>` or `<html>` tags.\n *\n * There are a few things to keep in mind when using `ngApp`:\n * - only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`\n *   found in the document will be used to define the root element to auto-bootstrap as an\n *   application. To run multiple applications in an HTML document you must manually bootstrap them using\n *   {@link angular.bootstrap} instead.\n * - AngularJS applications cannot be nested within each other.\n * - Do not use a directive that uses {@link ng.$compile#transclusion transclusion} on the same element as `ngApp`.\n *   This includes directives such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and\n *   {@link ngRoute.ngView `ngView`}.\n *   Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},\n *   causing animations to stop working and making the injector inaccessible from outside the app.\n *\n * You can specify an **AngularJS module** to be used as the root module for the application.  This\n * module will be loaded into the {@link auto.$injector} when the application is bootstrapped. It\n * should contain the application code needed or have dependencies on other modules that will\n * contain the code. See {@link angular.module} for more information.\n *\n * In the example below if the `ngApp` directive were not placed on the `html` element then the\n * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`\n * would not be resolved to `3`.\n *\n * `ngApp` is the easiest, and most common way to bootstrap an application.\n *\n <example module=\"ngAppDemo\" name=\"ng-app\">\n   <file name=\"index.html\">\n   <div ng-controller=\"ngAppDemoController\">\n     I can add: {{a}} + {{b}} =  {{ a+b }}\n   </div>\n   </file>\n   <file name=\"script.js\">\n   angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {\n     $scope.a = 1;\n     $scope.b = 2;\n   });\n   </file>\n </example>\n *\n * Using `ngStrictDi`, you would see something like this:\n *\n <example ng-app-included=\"true\" name=\"strict-di\">\n   <file name=\"index.html\">\n   <div ng-app=\"ngAppStrictDemo\" ng-strict-di>\n       <div ng-controller=\"GoodController1\">\n           I can add: {{a}} + {{b}} =  {{ a+b }}\n\n           <p>This renders because the controller does not fail to\n              instantiate, by using explicit annotation style (see\n              script.js for details)\n           </p>\n       </div>\n\n       <div ng-controller=\"GoodController2\">\n           Name: <input ng-model=\"name\"><br />\n           Hello, {{name}}!\n\n           <p>This renders because the controller does not fail to\n              instantiate, by using explicit annotation style\n              (see script.js for details)\n           </p>\n       </div>\n\n       <div ng-controller=\"BadController\">\n           I can add: {{a}} + {{b}} =  {{ a+b }}\n\n           <p>The controller could not be instantiated, due to relying\n              on automatic function annotations (which are disabled in\n              strict mode). As such, the content of this section is not\n              interpolated, and there should be an error in your web console.\n           </p>\n       </div>\n   </div>\n   </file>\n   <file name=\"script.js\">\n   angular.module('ngAppStrictDemo', [])\n     // BadController will fail to instantiate, due to relying on automatic function annotation,\n     // rather than an explicit annotation\n     .controller('BadController', function($scope) {\n       $scope.a = 1;\n       $scope.b = 2;\n     })\n     // Unlike BadController, GoodController1 and GoodController2 will not fail to be instantiated,\n     // due to using explicit annotations using the array style and $inject property, respectively.\n     .controller('GoodController1', ['$scope', function($scope) {\n       $scope.a = 1;\n       $scope.b = 2;\n     }])\n     .controller('GoodController2', GoodController2);\n     function GoodController2($scope) {\n       $scope.name = 'World';\n     }\n     GoodController2.$inject = ['$scope'];\n   </file>\n   <file name=\"style.css\">\n   div[ng-controller] {\n       margin-bottom: 1em;\n       -webkit-border-radius: 4px;\n       border-radius: 4px;\n       border: 1px solid;\n       padding: .5em;\n   }\n   div[ng-controller^=Good] {\n       border-color: #d6e9c6;\n       background-color: #dff0d8;\n       color: #3c763d;\n   }\n   div[ng-controller^=Bad] {\n       border-color: #ebccd1;\n       background-color: #f2dede;\n       color: #a94442;\n       margin-bottom: 0;\n   }\n   </file>\n </example>\n */\n\n/**\n * @ngdoc function\n * @name angular.bootstrap\n * @module ng\n * @description\n * Use this function to manually start up angular application.\n *\n * For more information, see the {@link guide/bootstrap Bootstrap guide}.\n *\n * Angular will detect if it has been loaded into the browser more than once and only allow the\n * first loaded script to be bootstrapped and will report a warning to the browser console for\n * each of the subsequent scripts. This prevents strange results in applications, where otherwise\n * multiple instances of Angular try to work on the DOM.\n *\n * <div class=\"alert alert-warning\">\n * **Note:** Protractor based end-to-end tests cannot use this function to bootstrap manually.\n * They must use {@link ng.directive:ngApp ngApp}.\n * </div>\n *\n * <div class=\"alert alert-warning\">\n * **Note:** Do not bootstrap the app on an element with a directive that uses {@link ng.$compile#transclusion transclusion},\n * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and {@link ngRoute.ngView `ngView`}.\n * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},\n * causing animations to stop working and making the injector inaccessible from outside the app.\n * </div>\n *\n * ```html\n * <!doctype html>\n * <html>\n * <body>\n * <div ng-controller=\"WelcomeController\">\n *   {{greeting}}\n * </div>\n *\n * <script src=\"angular.js\"></script>\n * <script>\n *   var app = angular.module('demo', [])\n *   .controller('WelcomeController', function($scope) {\n *       $scope.greeting = 'Welcome!';\n *   });\n *   angular.bootstrap(document, ['demo']);\n * </script>\n * </body>\n * </html>\n * ```\n *\n * @param {DOMElement} element DOM element which is the root of angular application.\n * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.\n *     Each item in the array should be the name of a predefined module or a (DI annotated)\n *     function that will be invoked by the injector as a `config` block.\n *     See: {@link angular.module modules}\n * @param {Object=} config an object for defining configuration options for the application. The\n *     following keys are supported:\n *\n * * `strictDi` - disable automatic function annotation for the application. This is meant to\n *   assist in finding bugs which break minified code. Defaults to `false`.\n *\n * @returns {auto.$injector} Returns the newly created injector for this app.\n */\nfunction bootstrap(element, modules, config) {\n\tif (!isObject(config)) config = {};\n\tvar defaultConfig = {\n\t\tstrictDi: false,\n\t};\n\tconfig = extend(defaultConfig, config);\n\tvar doBootstrap = function () {\n\t\telement = jqLite(element);\n\n\t\tif (element.injector()) {\n\t\t\tvar tag =\n\t\t\t\telement[0] === window.document ? \"document\" : startingTag(element);\n\t\t\t// Encode angle brackets to prevent input from being sanitized to empty string #8683.\n\t\t\tthrow ngMinErr(\n\t\t\t\t\"btstrpd\",\n\t\t\t\t\"App already bootstrapped with this element '{0}'\",\n\t\t\t\ttag.replace(/</, \"&lt;\").replace(/>/, \"&gt;\")\n\t\t\t);\n\t\t}\n\n\t\tmodules = modules || [];\n\t\tmodules.unshift([\n\t\t\t\"$provide\",\n\t\t\tfunction ($provide) {\n\t\t\t\t$provide.value(\"$rootElement\", element);\n\t\t\t},\n\t\t]);\n\n\t\tif (config.debugInfoEnabled) {\n\t\t\t// Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.\n\t\t\tmodules.push([\n\t\t\t\t\"$compileProvider\",\n\t\t\t\tfunction ($compileProvider) {\n\t\t\t\t\t$compileProvider.debugInfoEnabled(true);\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tmodules.unshift(\"ng\");\n\t};\n\n\tvar NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;\n\tvar NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;\n\n\tif (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {\n\t\tconfig.debugInfoEnabled = true;\n\t\twindow.name = window.name.replace(NG_ENABLE_DEBUG_INFO, \"\");\n\t}\n\n\tif (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {\n\t\treturn doBootstrap();\n\t}\n\n\twindow.name = window.name.replace(NG_DEFER_BOOTSTRAP, \"\");\n\tangular.resumeBootstrap = function (extraModules) {\n\t\tforEach(extraModules, function (module) {\n\t\t\tmodules.push(module);\n\t\t});\n\t\treturn doBootstrap();\n\t};\n\n\tif (isFunction(angular.resumeDeferredBootstrap)) {\n\t\tangular.resumeDeferredBootstrap();\n\t}\n}\n\n/**\n * @ngdoc function\n * @name angular.reloadWithDebugInfo\n * @module ng\n * @description\n * Use this function to reload the current application with debug information turned on.\n * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.\n *\n * See {@link ng.$compileProvider#debugInfoEnabled} for more.\n */\nfunction reloadWithDebugInfo() {\n\twindow.name = \"NG_ENABLE_DEBUG_INFO!\" + window.name;\n\twindow.location.reload();\n}\n\n/**\n * @name angular.getTestability\n * @module ng\n * @description\n * Get the testability service for the instance of Angular on the given\n * element.\n * @param {DOMElement} element DOM element which is the root of angular application.\n */\nfunction getTestability(rootElement) {\n\tvar injector = angular.element(rootElement).injector();\n\tif (!injector) {\n\t\tthrow ngMinErr(\n\t\t\t\"test\",\n\t\t\t\"no injector found for element argument to getTestability\"\n\t\t);\n\t}\n\treturn injector.get(\"$$testability\");\n}\n\nvar SNAKE_CASE_REGEXP = /[A-Z]/g;\nfunction snake_case(name, separator) {\n\tseparator = separator || \"_\";\n\treturn name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {\n\t\treturn (pos ? separator : \"\") + letter.toLowerCase();\n\t});\n}\n\nvar bindJQueryFired = false;\nfunction bindJQuery() {\n\tvar originalCleanData;\n\n\tif (bindJQueryFired) {\n\t\treturn;\n\t}\n\n\t// bind to jQuery if present;\n\tvar jqName = jq();\n\tjQuery = isUndefined(jqName)\n\t\t? window.jQuery // use jQuery (if present)\n\t\t: !jqName\n\t\t? undefined // use jqLite\n\t\t: window[jqName]; // use jQuery specified by `ngJq`\n\n\t// Use jQuery if it exists with proper functionality, otherwise default to us.\n\t// Angular 1.2+ requires jQuery 1.7+ for on()/off() support.\n\t// Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older\n\t// versions. It will not work for sure with jQuery <1.7, though.\n\tif (jQuery && jQuery.fn.on) {\n\t\tjqLite = jQuery;\n\t\textend(jQuery.fn, {\n\t\t\tscope: JQLitePrototype.scope,\n\t\t\tisolateScope: JQLitePrototype.isolateScope,\n\t\t\tcontroller: JQLitePrototype.controller,\n\t\t\tinjector: JQLitePrototype.injector,\n\t\t\tinheritedData: JQLitePrototype.inheritedData,\n\t\t});\n\n\t\t// All nodes removed from the DOM via various jQuery APIs like .remove()\n\t\t// are passed through jQuery.cleanData. Monkey-patch this method to fire\n\t\t// the $destroy event on all removed nodes.\n\t\toriginalCleanData = jQuery.cleanData;\n\t\tjQuery.cleanData = function (elems) {\n\t\t\tvar events;\n\t\t\tfor (var i = 0, elem; (elem = elems[i]) != null; i++) {\n\t\t\t\tevents = jQuery._data(elem, \"events\");\n\t\t\t\tif (events && events.$destroy) {\n\t\t\t\t\tjQuery(elem).triggerHandler(\"$destroy\");\n\t\t\t\t}\n\t\t\t}\n\t\t\toriginalCleanData(elems);\n\t\t};\n\t} else {\n\t\tjqLite = JQLite;\n\t}\n\n\tangular.element = jqLite;\n\n\t// Prevent double-proxying.\n\tbindJQueryFired = true;\n}\n\n/**\n * throw error if the argument is falsy.\n */\nfunction assertArg(arg, name, reason) {\n\tif (!arg) {\n\t\tthrow ngMinErr(\n\t\t\t\"areq\",\n\t\t\t\"Argument '{0}' is {1}\",\n\t\t\tname || \"?\",\n\t\t\treason || \"required\"\n\t\t);\n\t}\n\treturn arg;\n}\n\nfunction assertArgFn(arg, name, acceptArrayAnnotation) {\n\tif (acceptArrayAnnotation && isArray(arg)) {\n\t\targ = arg[arg.length - 1];\n\t}\n\n\tassertArg(\n\t\tisFunction(arg),\n\t\tname,\n\t\t\"not a function, got \" +\n\t\t\t(arg && typeof arg === \"object\"\n\t\t\t\t? arg.constructor.name || \"Object\"\n\t\t\t\t: typeof arg)\n\t);\n\treturn arg;\n}\n\n/**\n * throw error if the name given is hasOwnProperty\n * @param  {String} name    the name to test\n * @param  {String} context the context in which the name is used, such as module or directive\n */\nfunction assertNotHasOwnProperty(name, context) {\n\tif (name === \"hasOwnProperty\") {\n\t\tthrow ngMinErr(\n\t\t\t\"badname\",\n\t\t\t\"hasOwnProperty is not a valid {0} name\",\n\t\t\tcontext\n\t\t);\n\t}\n}\n\n/**\n * Return the value accessible from the object by path. Any undefined traversals are ignored\n * @param {Object} obj starting object\n * @param {String} path path to traverse\n * @param {boolean} [bindFnToScope=true]\n * @returns {Object} value as accessible by path\n */\n//TODO(misko): this function needs to be removed\nfunction getter(obj, path, bindFnToScope) {\n\tif (!path) return obj;\n\tvar keys = path.split(\".\");\n\tvar key;\n\tvar lastInstance = obj;\n\tvar len = keys.length;\n\n\tfor (var i = 0; i < len; i++) {\n\t\tkey = keys[i];\n\t\tif (obj) {\n\t\t\tobj = (lastInstance = obj)[key];\n\t\t}\n\t}\n\tif (!bindFnToScope && isFunction(obj)) {\n\t\treturn bind(lastInstance, obj);\n\t}\n\treturn obj;\n}\n\n/**\n * Return the DOM siblings between the first and last node in the given array.\n * @param {Array} array like object\n * @returns {Array} the inputted object or a jqLite collection containing the nodes\n */\nfunction getBlockNodes(nodes) {\n\t// TODO(perf): update `nodes` instead of creating a new object?\n\tvar node = nodes[0];\n\tvar endNode = nodes[nodes.length - 1];\n\tvar blockNodes;\n\n\tfor (var i = 1; node !== endNode && (node = node.nextSibling); i++) {\n\t\tif (blockNodes || nodes[i] !== node) {\n\t\t\tif (!blockNodes) {\n\t\t\t\tblockNodes = jqLite(slice.call(nodes, 0, i));\n\t\t\t}\n\t\t\tblockNodes.push(node);\n\t\t}\n\t}\n\n\treturn blockNodes || nodes;\n}\n\n/**\n * Creates a new object without a prototype. This object is useful for lookup without having to\n * guard against prototypically inherited properties via hasOwnProperty.\n *\n * Related micro-benchmarks:\n * - http://jsperf.com/object-create2\n * - http://jsperf.com/proto-map-lookup/2\n * - http://jsperf.com/for-in-vs-object-keys2\n *\n * @returns {Object}\n */\nfunction createMap() {\n\treturn Object.create(null);\n}\n\nfunction stringify(value) {\n\tif (value == null) {\n\t\t// null || undefined\n\t\treturn \"\";\n\t}\n\tswitch (typeof value) {\n\t\tcase \"string\":\n\t\t\tbreak;\n\t\tcase \"number\":\n\t\t\tvalue = \"\" + value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (hasCustomToString(value) && !isArray(value) && !isDate(value)) {\n\t\t\t\tvalue = value.toString();\n\t\t\t} else {\n\t\t\t\tvalue = toJson(value);\n\t\t\t}\n\t}\n\n\treturn value;\n}\n\n/* global toDebugString: true */\n\nfunction serializeObject(obj) {\n\tvar seen = [];\n\n\treturn JSON.stringify(obj, function (key, val) {\n\t\tval = toJsonReplacer(key, val);\n\t\tif (isObject(val)) {\n\t\t\tif (seen.indexOf(val) >= 0) return \"...\";\n\n\t\t\tseen.push(val);\n\t\t}\n\t\treturn val;\n\t});\n}\n\nfunction toDebugString(obj) {\n\tif (typeof obj === \"function\") {\n\t\treturn obj.toString().replace(/ \\{[\\s\\S]*$/, \"\");\n\t} else if (isUndefined(obj)) {\n\t\treturn \"undefined\";\n\t} else if (typeof obj !== \"string\") {\n\t\treturn serializeObject(obj);\n\t}\n\treturn obj;\n}\n\n/**\n * @description\n *\n * This object provides a utility for producing rich Error messages within\n * Angular. It can be called as follows:\n *\n * var exampleMinErr = minErr('example');\n * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);\n *\n * The above creates an instance of minErr in the example namespace. The\n * resulting error will have a namespaced error code of example.one.  The\n * resulting error will replace {0} with the value of foo, and {1} with the\n * value of bar. The object is not restricted in the number of arguments it can\n * take.\n *\n * If fewer arguments are specified than necessary for interpolation, the extra\n * interpolation markers will be preserved in the final string.\n *\n * Since data will be parsed statically during a build step, some restrictions\n * are applied with respect to how minErr instances are created and called.\n * Instances should have names of the form namespaceMinErr for a minErr created\n * using minErr('namespace') . Error codes, namespaces and template strings\n * should all be static strings, not variables or general expressions.\n *\n * @param {string} module The namespace to use for the new minErr instance.\n * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning\n *   error from returned function, for cases when a particular type of error is useful.\n * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance\n */\n\nfunction minErr(module, ErrorConstructor) {\n\tErrorConstructor = ErrorConstructor || Error;\n\treturn function () {\n\t\tvar SKIP_INDEXES = 2;\n\n\t\tvar templateArgs = arguments,\n\t\t\tcode = templateArgs[0],\n\t\t\tmessage = \"[\" + (module ? module + \":\" : \"\") + code + \"] \",\n\t\t\ttemplate = templateArgs[1],\n\t\t\tparamPrefix,\n\t\t\ti;\n\n\t\tmessage += template.replace(/\\{\\d+\\}/g, function (match) {\n\t\t\tvar index = +match.slice(1, -1),\n\t\t\t\tshiftedIndex = index + SKIP_INDEXES;\n\n\t\t\tif (shiftedIndex < templateArgs.length) {\n\t\t\t\treturn toDebugString(templateArgs[shiftedIndex]);\n\t\t\t}\n\n\t\t\treturn match;\n\t\t});\n\n\t\tmessage +=\n\t\t\t'\\nhttp://errors.angularjs.org/\"NG_VERSION_FULL\"/' +\n\t\t\t(module ? module + \"/\" : \"\") +\n\t\t\tcode;\n\n\t\tfor (\n\t\t\ti = SKIP_INDEXES, paramPrefix = \"?\";\n\t\t\ti < templateArgs.length;\n\t\t\ti++, paramPrefix = \"&\"\n\t\t) {\n\t\t\tmessage +=\n\t\t\t\tparamPrefix +\n\t\t\t\t\"p\" +\n\t\t\t\t(i - SKIP_INDEXES) +\n\t\t\t\t\"=\" +\n\t\t\t\tencodeURIComponent(toDebugString(templateArgs[i]));\n\t\t}\n\n\t\treturn new ErrorConstructor(message);\n\t};\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $parseMinErr = minErr(\"$parse\");\n\nvar objectValueOf = {}.constructor.prototype.valueOf;\n\n// Sandboxing Angular Expressions\n// ------------------------------\n// Angular expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by\n// various means such as obtaining a reference to native JS functions like the Function constructor.\n//\n// As an example, consider the following Angular expression:\n//\n//   {}.toString.constructor('alert(\"evil JS code\")')\n//\n// It is important to realize that if you create an expression from a string that contains user provided\n// content then it is possible that your application contains a security vulnerability to an XSS style attack.\n//\n// See https://docs.angularjs.org/guide/security\n\nfunction getStringValue(name) {\n\t// Property names must be strings. This means that non-string objects cannot be used\n\t// as keys in an object. Any non-string object, including a number, is typecasted\n\t// into a string via the toString method.\n\t// -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names\n\t//\n\t// So, to ensure that we are checking the same `name` that JavaScript would use, we cast it\n\t// to a string. It's not always possible. If `name` is an object and its `toString` method is\n\t// 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:\n\t//\n\t// TypeError: Cannot convert object to primitive value\n\t//\n\t// For performance reasons, we don't catch this error here and allow it to propagate up the call\n\t// stack. Note that you'll get the same error in JavaScript if you try to access a property using\n\t// such a 'broken' object as a key.\n\treturn name + \"\";\n}\n\nvar OPERATORS = createMap();\nforEach(\n\t\"+ - * / % === !== == != < > <= >= && || ! = |\".split(\" \"),\n\tfunction (operator) {\n\t\tOPERATORS[operator] = true;\n\t}\n);\nvar ESCAPE = {\n\tn: \"\\n\",\n\tf: \"\\f\",\n\tr: \"\\r\",\n\tt: \"\\t\",\n\tv: \"\\v\",\n\t\"'\": \"'\",\n\t'\"': '\"',\n};\n\n/////////////////////////////////////////\n\n/**\n * @constructor\n */\nvar Lexer = function Lexer(options) {\n\tthis.options = options;\n};\n\nLexer.prototype = {\n\tconstructor: Lexer,\n\n\tlex: function (text) {\n\t\tthis.text = text;\n\t\tthis.index = 0;\n\t\tthis.tokens = [];\n\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.text.charAt(this.index);\n\t\t\tif (ch === '\"' || ch === \"'\") {\n\t\t\t\tthis.readString(ch);\n\t\t\t} else if (\n\t\t\t\tthis.isNumber(ch) ||\n\t\t\t\t(ch === \".\" && this.isNumber(this.peek()))\n\t\t\t) {\n\t\t\t\tthis.readNumber();\n\t\t\t} else if (this.isIdentifierStart(this.peekMultichar())) {\n\t\t\t\tthis.readIdent();\n\t\t\t} else if (this.is(ch, \"(){}[].,;:?\")) {\n\t\t\t\tthis.tokens.push({ index: this.index, text: ch });\n\t\t\t\tthis.index++;\n\t\t\t} else if (this.isWhitespace(ch)) {\n\t\t\t\tthis.index++;\n\t\t\t} else {\n\t\t\t\tvar ch2 = ch + this.peek();\n\t\t\t\tvar ch3 = ch2 + this.peek(2);\n\t\t\t\tvar op1 = OPERATORS[ch];\n\t\t\t\tvar op2 = OPERATORS[ch2];\n\t\t\t\tvar op3 = OPERATORS[ch3];\n\t\t\t\tif (op1 || op2 || op3) {\n\t\t\t\t\tvar token = op3 ? ch3 : op2 ? ch2 : ch;\n\t\t\t\t\tthis.tokens.push({ index: this.index, text: token, operator: true });\n\t\t\t\t\tthis.index += token.length;\n\t\t\t\t} else {\n\t\t\t\t\tthis.throwError(\n\t\t\t\t\t\t\"Unexpected next character \",\n\t\t\t\t\t\tthis.index,\n\t\t\t\t\t\tthis.index + 1\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.tokens;\n\t},\n\n\tis: function (ch, chars) {\n\t\treturn chars.indexOf(ch) !== -1;\n\t},\n\n\tpeek: function (i) {\n\t\tvar num = i || 1;\n\t\treturn this.index + num < this.text.length\n\t\t\t? this.text.charAt(this.index + num)\n\t\t\t: false;\n\t},\n\n\tisNumber: function (ch) {\n\t\treturn \"0\" <= ch && ch <= \"9\" && typeof ch === \"string\";\n\t},\n\n\tisWhitespace: function (ch) {\n\t\t// IE treats non-breaking space as \\u00A0\n\t\treturn (\n\t\t\tch === \" \" ||\n\t\t\tch === \"\\r\" ||\n\t\t\tch === \"\\t\" ||\n\t\t\tch === \"\\n\" ||\n\t\t\tch === \"\\v\" ||\n\t\t\tch === \"\\u00A0\"\n\t\t);\n\t},\n\n\tisIdentifierStart: function (ch) {\n\t\treturn this.options.isIdentifierStart\n\t\t\t? this.options.isIdentifierStart(ch, this.codePointAt(ch))\n\t\t\t: this.isValidIdentifierStart(ch);\n\t},\n\n\tisValidIdentifierStart: function (ch) {\n\t\treturn (\n\t\t\t(\"a\" <= ch && ch <= \"z\") ||\n\t\t\t(\"A\" <= ch && ch <= \"Z\") ||\n\t\t\t\"_\" === ch ||\n\t\t\tch === \"$\"\n\t\t);\n\t},\n\n\tisIdentifierContinue: function (ch) {\n\t\treturn this.options.isIdentifierContinue\n\t\t\t? this.options.isIdentifierContinue(ch, this.codePointAt(ch))\n\t\t\t: this.isValidIdentifierContinue(ch);\n\t},\n\n\tisValidIdentifierContinue: function (ch, cp) {\n\t\treturn this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);\n\t},\n\n\tcodePointAt: function (ch) {\n\t\tif (ch.length === 1) return ch.charCodeAt(0);\n\t\t// eslint-disable-next-line no-bitwise\n\t\treturn (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35fdc00;\n\t},\n\n\tpeekMultichar: function () {\n\t\tvar ch = this.text.charAt(this.index);\n\t\tvar peek = this.peek();\n\t\tif (!peek) {\n\t\t\treturn ch;\n\t\t}\n\t\tvar cp1 = ch.charCodeAt(0);\n\t\tvar cp2 = peek.charCodeAt(0);\n\t\tif (cp1 >= 0xd800 && cp1 <= 0xdbff && cp2 >= 0xdc00 && cp2 <= 0xdfff) {\n\t\t\treturn ch + peek;\n\t\t}\n\t\treturn ch;\n\t},\n\n\tisExpOperator: function (ch) {\n\t\treturn ch === \"-\" || ch === \"+\" || this.isNumber(ch);\n\t},\n\n\tthrowError: function (error, start, end) {\n\t\tend = end || this.index;\n\t\tvar colStr = isDefined(start)\n\t\t\t? \"s \" +\n\t\t\t  start +\n\t\t\t  \"-\" +\n\t\t\t  this.index +\n\t\t\t  \" [\" +\n\t\t\t  this.text.substring(start, end) +\n\t\t\t  \"]\"\n\t\t\t: \" \" + end;\n\t\tthrow $parseMinErr(\n\t\t\t\"lexerr\",\n\t\t\t\"Lexer Error: {0} at column{1} in expression [{2}].\",\n\t\t\terror,\n\t\t\tcolStr,\n\t\t\tthis.text\n\t\t);\n\t},\n\n\treadNumber: function () {\n\t\tvar number = \"\";\n\t\tvar start = this.index;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = lowercase(this.text.charAt(this.index));\n\t\t\tif (ch === \".\" || this.isNumber(ch)) {\n\t\t\t\tnumber += ch;\n\t\t\t} else {\n\t\t\t\tvar peekCh = this.peek();\n\t\t\t\tif (ch === \"e\" && this.isExpOperator(peekCh)) {\n\t\t\t\t\tnumber += ch;\n\t\t\t\t} else if (\n\t\t\t\t\tthis.isExpOperator(ch) &&\n\t\t\t\t\tpeekCh &&\n\t\t\t\t\tthis.isNumber(peekCh) &&\n\t\t\t\t\tnumber.charAt(number.length - 1) === \"e\"\n\t\t\t\t) {\n\t\t\t\t\tnumber += ch;\n\t\t\t\t} else if (\n\t\t\t\t\tthis.isExpOperator(ch) &&\n\t\t\t\t\t(!peekCh || !this.isNumber(peekCh)) &&\n\t\t\t\t\tnumber.charAt(number.length - 1) === \"e\"\n\t\t\t\t) {\n\t\t\t\t\tthis.throwError(\"Invalid exponent\");\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.index++;\n\t\t}\n\t\tthis.tokens.push({\n\t\t\tindex: start,\n\t\t\ttext: number,\n\t\t\tconstant: true,\n\t\t\tvalue: Number(number),\n\t\t});\n\t},\n\n\treadIdent: function () {\n\t\tvar start = this.index;\n\t\tthis.index += this.peekMultichar().length;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.peekMultichar();\n\t\t\tif (!this.isIdentifierContinue(ch)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.index += ch.length;\n\t\t}\n\t\tthis.tokens.push({\n\t\t\tindex: start,\n\t\t\ttext: this.text.slice(start, this.index),\n\t\t\tidentifier: true,\n\t\t});\n\t},\n\n\treadString: function (quote) {\n\t\tvar start = this.index;\n\t\tthis.index++;\n\t\tvar string = \"\";\n\t\tvar rawString = quote;\n\t\tvar escape = false;\n\t\twhile (this.index < this.text.length) {\n\t\t\tvar ch = this.text.charAt(this.index);\n\t\t\trawString += ch;\n\t\t\tif (escape) {\n\t\t\t\tif (ch === \"u\") {\n\t\t\t\t\tvar hex = this.text.substring(this.index + 1, this.index + 5);\n\t\t\t\t\tif (!hex.match(/[\\da-f]{4}/i)) {\n\t\t\t\t\t\tthis.throwError(\"Invalid unicode escape [\\\\u\" + hex + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tthis.index += 4;\n\t\t\t\t\tstring += String.fromCharCode(parseInt(hex, 16));\n\t\t\t\t} else {\n\t\t\t\t\tvar rep = ESCAPE[ch];\n\t\t\t\t\tstring = string + (rep || ch);\n\t\t\t\t}\n\t\t\t\tescape = false;\n\t\t\t} else if (ch === \"\\\\\") {\n\t\t\t\tescape = true;\n\t\t\t} else if (ch === quote) {\n\t\t\t\tthis.index++;\n\t\t\t\tthis.tokens.push({\n\t\t\t\t\tindex: start,\n\t\t\t\t\ttext: rawString,\n\t\t\t\t\tconstant: true,\n\t\t\t\t\tvalue: string,\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tstring += ch;\n\t\t\t}\n\t\t\tthis.index++;\n\t\t}\n\t\tthis.throwError(\"Unterminated quote\", start);\n\t},\n};\n\nvar AST = function AST(lexer, options) {\n\tthis.lexer = lexer;\n\tthis.options = options;\n};\n\nAST.Program = \"Program\";\nAST.ExpressionStatement = \"ExpressionStatement\";\nAST.AssignmentExpression = \"AssignmentExpression\";\nAST.ConditionalExpression = \"ConditionalExpression\";\nAST.LogicalExpression = \"LogicalExpression\";\nAST.BinaryExpression = \"BinaryExpression\";\nAST.UnaryExpression = \"UnaryExpression\";\nAST.CallExpression = \"CallExpression\";\nAST.MemberExpression = \"MemberExpression\";\nAST.Identifier = \"Identifier\";\nAST.Literal = \"Literal\";\nAST.ArrayExpression = \"ArrayExpression\";\nAST.Property = \"Property\";\nAST.ObjectExpression = \"ObjectExpression\";\nAST.ThisExpression = \"ThisExpression\";\nAST.LocalsExpression = \"LocalsExpression\";\n\n// Internal use only\nAST.NGValueParameter = \"NGValueParameter\";\n\nAST.prototype = {\n\tast: function (text) {\n\t\tthis.text = text;\n\t\tthis.tokens = this.lexer.lex(text);\n\n\t\tvar value = this.program();\n\n\t\tif (this.tokens.length !== 0) {\n\t\t\tthis.throwError(\"is an unexpected token\", this.tokens[0]);\n\t\t}\n\n\t\treturn value;\n\t},\n\n\tprogram: function () {\n\t\tvar body = [];\n\t\twhile (true) {\n\t\t\tif (this.tokens.length > 0 && !this.peek(\"}\", \")\", \";\", \"]\"))\n\t\t\t\tbody.push(this.expressionStatement());\n\t\t\tif (!this.expect(\";\")) {\n\t\t\t\treturn { type: AST.Program, body: body };\n\t\t\t}\n\t\t}\n\t},\n\n\texpressionStatement: function () {\n\t\treturn { type: AST.ExpressionStatement, expression: this.filterChain() };\n\t},\n\n\tfilterChain: function () {\n\t\tvar left = this.expression();\n\t\twhile (this.expect(\"|\")) {\n\t\t\tleft = this.filter(left);\n\t\t}\n\t\treturn left;\n\t},\n\n\texpression: function () {\n\t\treturn this.assignment();\n\t},\n\n\tassignment: function () {\n\t\tvar result = this.ternary();\n\t\tif (this.expect(\"=\")) {\n\t\t\tif (!isAssignable(result)) {\n\t\t\t\tthrow $parseMinErr(\"lval\", \"Trying to assign a value to a non l-value\");\n\t\t\t}\n\n\t\t\tresult = {\n\t\t\t\ttype: AST.AssignmentExpression,\n\t\t\t\tleft: result,\n\t\t\t\tright: this.assignment(),\n\t\t\t\toperator: \"=\",\n\t\t\t};\n\t\t}\n\t\treturn result;\n\t},\n\n\tternary: function () {\n\t\tvar test = this.logicalOR();\n\t\tvar alternate;\n\t\tvar consequent;\n\t\tif (this.expect(\"?\")) {\n\t\t\talternate = this.expression();\n\t\t\tif (this.consume(\":\")) {\n\t\t\t\tconsequent = this.expression();\n\t\t\t\treturn {\n\t\t\t\t\ttype: AST.ConditionalExpression,\n\t\t\t\t\ttest: test,\n\t\t\t\t\talternate: alternate,\n\t\t\t\t\tconsequent: consequent,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn test;\n\t},\n\n\tlogicalOR: function () {\n\t\tvar left = this.logicalAND();\n\t\twhile (this.expect(\"||\")) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.LogicalExpression,\n\t\t\t\toperator: \"||\",\n\t\t\t\tleft: left,\n\t\t\t\tright: this.logicalAND(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tlogicalAND: function () {\n\t\tvar left = this.equality();\n\t\twhile (this.expect(\"&&\")) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.LogicalExpression,\n\t\t\t\toperator: \"&&\",\n\t\t\t\tleft: left,\n\t\t\t\tright: this.equality(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tequality: function () {\n\t\tvar left = this.relational();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"==\", \"!=\", \"===\", \"!==\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.relational(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\trelational: function () {\n\t\tvar left = this.additive();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"<\", \">\", \"<=\", \">=\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.additive(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tadditive: function () {\n\t\tvar left = this.multiplicative();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"+\", \"-\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.multiplicative(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tmultiplicative: function () {\n\t\tvar left = this.unary();\n\t\tvar token;\n\t\twhile ((token = this.expect(\"*\", \"/\", \"%\"))) {\n\t\t\tleft = {\n\t\t\t\ttype: AST.BinaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tleft: left,\n\t\t\t\tright: this.unary(),\n\t\t\t};\n\t\t}\n\t\treturn left;\n\t},\n\n\tunary: function () {\n\t\tvar token;\n\t\tif ((token = this.expect(\"+\", \"-\", \"!\"))) {\n\t\t\treturn {\n\t\t\t\ttype: AST.UnaryExpression,\n\t\t\t\toperator: token.text,\n\t\t\t\tprefix: true,\n\t\t\t\targument: this.unary(),\n\t\t\t};\n\t\t} else {\n\t\t\treturn this.primary();\n\t\t}\n\t},\n\n\tprimary: function () {\n\t\tvar primary;\n\t\tif (this.expect(\"(\")) {\n\t\t\tprimary = this.filterChain();\n\t\t\tthis.consume(\")\");\n\t\t} else if (this.expect(\"[\")) {\n\t\t\tprimary = this.arrayDeclaration();\n\t\t} else if (this.expect(\"{\")) {\n\t\t\tprimary = this.object();\n\t\t} else if (this.selfReferential.hasOwnProperty(this.peek().text)) {\n\t\t\tprimary = copy(this.selfReferential[this.consume().text]);\n\t\t} else if (this.options.literals.hasOwnProperty(this.peek().text)) {\n\t\t\tprimary = {\n\t\t\t\ttype: AST.Literal,\n\t\t\t\tvalue: this.options.literals[this.consume().text],\n\t\t\t};\n\t\t} else if (this.peek().identifier) {\n\t\t\tprimary = this.identifier();\n\t\t} else if (this.peek().constant) {\n\t\t\tprimary = this.constant();\n\t\t} else {\n\t\t\tthis.throwError(\"not a primary expression\", this.peek());\n\t\t}\n\n\t\tvar next;\n\t\twhile ((next = this.expect(\"(\", \"[\", \".\"))) {\n\t\t\tif (next.text === \"(\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.CallExpression,\n\t\t\t\t\tcallee: primary,\n\t\t\t\t\targuments: this.parseArguments(),\n\t\t\t\t};\n\t\t\t\tthis.consume(\")\");\n\t\t\t} else if (next.text === \"[\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.MemberExpression,\n\t\t\t\t\tobject: primary,\n\t\t\t\t\tproperty: this.expression(),\n\t\t\t\t\tcomputed: true,\n\t\t\t\t};\n\t\t\t\tthis.consume(\"]\");\n\t\t\t} else if (next.text === \".\") {\n\t\t\t\tprimary = {\n\t\t\t\t\ttype: AST.MemberExpression,\n\t\t\t\t\tobject: primary,\n\t\t\t\t\tproperty: this.identifier(),\n\t\t\t\t\tcomputed: false,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.throwError(\"IMPOSSIBLE\");\n\t\t\t}\n\t\t}\n\t\treturn primary;\n\t},\n\n\tfilter: function (baseExpression) {\n\t\tvar args = [baseExpression];\n\t\tvar result = {\n\t\t\ttype: AST.CallExpression,\n\t\t\tcallee: this.identifier(),\n\t\t\targuments: args,\n\t\t\tfilter: true,\n\t\t};\n\n\t\twhile (this.expect(\":\")) {\n\t\t\targs.push(this.expression());\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tparseArguments: function () {\n\t\tvar args = [];\n\t\tif (this.peekToken().text !== \")\") {\n\t\t\tdo {\n\t\t\t\targs.push(this.filterChain());\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\treturn args;\n\t},\n\n\tidentifier: function () {\n\t\tvar token = this.consume();\n\t\tif (!token.identifier) {\n\t\t\tthis.throwError(\"is not a valid identifier\", token);\n\t\t}\n\t\treturn { type: AST.Identifier, name: token.text };\n\t},\n\n\tconstant: function () {\n\t\t// TODO check that it is a constant\n\t\treturn { type: AST.Literal, value: this.consume().value };\n\t},\n\n\tarrayDeclaration: function () {\n\t\tvar elements = [];\n\t\tif (this.peekToken().text !== \"]\") {\n\t\t\tdo {\n\t\t\t\tif (this.peek(\"]\")) {\n\t\t\t\t\t// Support trailing commas per ES5.1.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telements.push(this.expression());\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\tthis.consume(\"]\");\n\n\t\treturn { type: AST.ArrayExpression, elements: elements };\n\t},\n\n\tobject: function () {\n\t\tvar properties = [],\n\t\t\tproperty;\n\t\tif (this.peekToken().text !== \"}\") {\n\t\t\tdo {\n\t\t\t\tif (this.peek(\"}\")) {\n\t\t\t\t\t// Support trailing commas per ES5.1.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tproperty = { type: AST.Property, kind: \"init\" };\n\t\t\t\tif (this.peek().constant) {\n\t\t\t\t\tproperty.key = this.constant();\n\t\t\t\t\tproperty.computed = false;\n\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t} else if (this.peek().identifier) {\n\t\t\t\t\tproperty.key = this.identifier();\n\t\t\t\t\tproperty.computed = false;\n\t\t\t\t\tif (this.peek(\":\")) {\n\t\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproperty.value = property.key;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.peek(\"[\")) {\n\t\t\t\t\tthis.consume(\"[\");\n\t\t\t\t\tproperty.key = this.expression();\n\t\t\t\t\tthis.consume(\"]\");\n\t\t\t\t\tproperty.computed = true;\n\t\t\t\t\tthis.consume(\":\");\n\t\t\t\t\tproperty.value = this.expression();\n\t\t\t\t} else {\n\t\t\t\t\tthis.throwError(\"invalid key\", this.peek());\n\t\t\t\t}\n\t\t\t\tproperties.push(property);\n\t\t\t} while (this.expect(\",\"));\n\t\t}\n\t\tthis.consume(\"}\");\n\n\t\treturn { type: AST.ObjectExpression, properties: properties };\n\t},\n\n\tthrowError: function (msg, token) {\n\t\tthrow $parseMinErr(\n\t\t\t\"syntax\",\n\t\t\t\"Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].\",\n\t\t\ttoken.text,\n\t\t\tmsg,\n\t\t\ttoken.index + 1,\n\t\t\tthis.text,\n\t\t\tthis.text.substring(token.index)\n\t\t);\n\t},\n\n\tconsume: function (e1) {\n\t\tif (this.tokens.length === 0) {\n\t\t\tthrow $parseMinErr(\n\t\t\t\t\"ueoe\",\n\t\t\t\t\"Unexpected end of expression: {0}\",\n\t\t\t\tthis.text\n\t\t\t);\n\t\t}\n\n\t\tvar token = this.expect(e1);\n\t\tif (!token) {\n\t\t\tthis.throwError(\"is unexpected, expecting [\" + e1 + \"]\", this.peek());\n\t\t}\n\t\treturn token;\n\t},\n\n\tpeekToken: function () {\n\t\tif (this.tokens.length === 0) {\n\t\t\tthrow $parseMinErr(\n\t\t\t\t\"ueoe\",\n\t\t\t\t\"Unexpected end of expression: {0}\",\n\t\t\t\tthis.text\n\t\t\t);\n\t\t}\n\t\treturn this.tokens[0];\n\t},\n\n\tpeek: function (e1, e2, e3, e4) {\n\t\treturn this.peekAhead(0, e1, e2, e3, e4);\n\t},\n\n\tpeekAhead: function (i, e1, e2, e3, e4) {\n\t\tif (this.tokens.length > i) {\n\t\t\tvar token = this.tokens[i];\n\t\t\tvar t = token.text;\n\t\t\tif (\n\t\t\t\tt === e1 ||\n\t\t\t\tt === e2 ||\n\t\t\t\tt === e3 ||\n\t\t\t\tt === e4 ||\n\t\t\t\t(!e1 && !e2 && !e3 && !e4)\n\t\t\t) {\n\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\texpect: function (e1, e2, e3, e4) {\n\t\tvar token = this.peek(e1, e2, e3, e4);\n\t\tif (token) {\n\t\t\tthis.tokens.shift();\n\t\t\treturn token;\n\t\t}\n\t\treturn false;\n\t},\n\n\tselfReferential: {\n\t\tthis: { type: AST.ThisExpression },\n\t\t$locals: { type: AST.LocalsExpression },\n\t},\n};\n\nfunction ifDefined(v, d) {\n\treturn typeof v !== \"undefined\" ? v : d;\n}\n\nfunction plusFn(l, r) {\n\tif (typeof l === \"undefined\") return r;\n\tif (typeof r === \"undefined\") return l;\n\treturn l + r;\n}\n\nfunction isStateless($filter, filterName) {\n\tvar fn = $filter(filterName);\n\treturn !fn.$stateful;\n}\n\nfunction findConstantAndWatchExpressions(ast, $filter) {\n\tvar allConstants;\n\tvar argsToWatch;\n\tvar isStatelessFilter;\n\tswitch (ast.type) {\n\t\tcase AST.Program:\n\t\t\tallConstants = true;\n\t\t\tforEach(ast.body, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr.expression, $filter);\n\t\t\t\tallConstants = allConstants && expr.expression.constant;\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tbreak;\n\t\tcase AST.Literal:\n\t\t\tast.constant = true;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t\tcase AST.UnaryExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.argument, $filter);\n\t\t\tast.constant = ast.argument.constant;\n\t\t\tast.toWatch = ast.argument.toWatch;\n\t\t\tbreak;\n\t\tcase AST.BinaryExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);\n\t\t\tbreak;\n\t\tcase AST.LogicalExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = ast.constant ? [] : [ast];\n\t\t\tbreak;\n\t\tcase AST.ConditionalExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.test, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.alternate, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.consequent, $filter);\n\t\t\tast.constant =\n\t\t\t\tast.test.constant && ast.alternate.constant && ast.consequent.constant;\n\t\t\tast.toWatch = ast.constant ? [] : [ast];\n\t\t\tbreak;\n\t\tcase AST.Identifier:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.MemberExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.object, $filter);\n\t\t\tif (ast.computed) {\n\t\t\t\tfindConstantAndWatchExpressions(ast.property, $filter);\n\t\t\t}\n\t\t\tast.constant =\n\t\t\t\tast.object.constant && (!ast.computed || ast.property.constant);\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.CallExpression:\n\t\t\tisStatelessFilter = ast.filter\n\t\t\t\t? isStateless($filter, ast.callee.name)\n\t\t\t\t: false;\n\t\t\tallConstants = isStatelessFilter;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr, $filter);\n\t\t\t\tallConstants = allConstants && expr.constant;\n\t\t\t\tif (!expr.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, expr.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = isStatelessFilter ? argsToWatch : [ast];\n\t\t\tbreak;\n\t\tcase AST.AssignmentExpression:\n\t\t\tfindConstantAndWatchExpressions(ast.left, $filter);\n\t\t\tfindConstantAndWatchExpressions(ast.right, $filter);\n\t\t\tast.constant = ast.left.constant && ast.right.constant;\n\t\t\tast.toWatch = [ast];\n\t\t\tbreak;\n\t\tcase AST.ArrayExpression:\n\t\t\tallConstants = true;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\tfindConstantAndWatchExpressions(expr, $filter);\n\t\t\t\tallConstants = allConstants && expr.constant;\n\t\t\t\tif (!expr.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, expr.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = argsToWatch;\n\t\t\tbreak;\n\t\tcase AST.ObjectExpression:\n\t\t\tallConstants = true;\n\t\t\targsToWatch = [];\n\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\tfindConstantAndWatchExpressions(property.value, $filter);\n\t\t\t\tallConstants =\n\t\t\t\t\tallConstants && property.value.constant && !property.computed;\n\t\t\t\tif (!property.value.constant) {\n\t\t\t\t\targsToWatch.push.apply(argsToWatch, property.value.toWatch);\n\t\t\t\t}\n\t\t\t});\n\t\t\tast.constant = allConstants;\n\t\t\tast.toWatch = argsToWatch;\n\t\t\tbreak;\n\t\tcase AST.ThisExpression:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t\tcase AST.LocalsExpression:\n\t\t\tast.constant = false;\n\t\t\tast.toWatch = [];\n\t\t\tbreak;\n\t}\n}\n\nfunction getInputs(body) {\n\tif (body.length !== 1) return;\n\tvar lastExpression = body[0].expression;\n\tvar candidate = lastExpression.toWatch;\n\tif (candidate.length !== 1) return candidate;\n\treturn candidate[0] !== lastExpression ? candidate : undefined;\n}\n\nfunction isAssignable(ast) {\n\treturn ast.type === AST.Identifier || ast.type === AST.MemberExpression;\n}\n\nfunction assignableAST(ast) {\n\tif (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {\n\t\treturn {\n\t\t\ttype: AST.AssignmentExpression,\n\t\t\tleft: ast.body[0].expression,\n\t\t\tright: { type: AST.NGValueParameter },\n\t\t\toperator: \"=\",\n\t\t};\n\t}\n}\n\nfunction isLiteral(ast) {\n\treturn (\n\t\tast.body.length === 0 ||\n\t\t(ast.body.length === 1 &&\n\t\t\t(ast.body[0].expression.type === AST.Literal ||\n\t\t\t\tast.body[0].expression.type === AST.ArrayExpression ||\n\t\t\t\tast.body[0].expression.type === AST.ObjectExpression))\n\t);\n}\n\nfunction isConstant(ast) {\n\treturn ast.constant;\n}\n\nfunction ASTCompiler(astBuilder, $filter) {\n\tthis.astBuilder = astBuilder;\n\tthis.$filter = $filter;\n}\n\nASTCompiler.prototype = {\n\tcompile: function (expression) {\n\t\tvar self = this;\n\t\tvar ast = this.astBuilder.ast(expression);\n\t\tthis.state = {\n\t\t\tnextId: 0,\n\t\t\tfilters: {},\n\t\t\tfn: { vars: [], body: [], own: {} },\n\t\t\tassign: { vars: [], body: [], own: {} },\n\t\t\tinputs: [],\n\t\t};\n\t\tfindConstantAndWatchExpressions(ast, self.$filter);\n\t\tvar extra = \"\";\n\t\tvar assignable;\n\t\tthis.stage = \"assign\";\n\t\tif ((assignable = assignableAST(ast))) {\n\t\t\tthis.state.computing = \"assign\";\n\t\t\tvar result = this.nextId();\n\t\t\tthis.recurse(assignable, result);\n\t\t\tthis.return_(result);\n\t\t\textra = \"fn.assign=\" + this.generateFunction(\"assign\", \"s,v,l\");\n\t\t}\n\t\tvar toWatch = getInputs(ast.body);\n\t\tself.stage = \"inputs\";\n\t\tforEach(toWatch, function (watch, key) {\n\t\t\tvar fnKey = \"fn\" + key;\n\t\t\tself.state[fnKey] = { vars: [], body: [], own: {} };\n\t\t\tself.state.computing = fnKey;\n\t\t\tvar intoId = self.nextId();\n\t\t\tself.recurse(watch, intoId);\n\t\t\tself.return_(intoId);\n\t\t\tself.state.inputs.push(fnKey);\n\t\t\twatch.watchId = key;\n\t\t});\n\t\tthis.state.computing = \"fn\";\n\t\tthis.stage = \"main\";\n\t\tthis.recurse(ast);\n\t\tvar fnString =\n\t\t\t// The build and minification steps remove the string \"use strict\" from the code, but this is done using a regex.\n\t\t\t// This is a workaround for this until we do a better job at only removing the prefix only when we should.\n\t\t\t'\"' +\n\t\t\tthis.USE +\n\t\t\t\" \" +\n\t\t\tthis.STRICT +\n\t\t\t'\";\\n' +\n\t\t\tthis.filterPrefix() +\n\t\t\t\"var fn=\" +\n\t\t\tthis.generateFunction(\"fn\", \"s,l,a,i\") +\n\t\t\textra +\n\t\t\tthis.watchFns() +\n\t\t\t\"return fn;\";\n\t\t// eslint-disable-next-line no-new-func\n\t\tvar fn = new Function(\n\t\t\t\"$filter\",\n\t\t\t\"getStringValue\",\n\t\t\t\"ifDefined\",\n\t\t\t\"plus\",\n\t\t\tfnString\n\t\t)(this.$filter, getStringValue, ifDefined, plusFn);\n\n\t\tthis.state = this.stage = undefined;\n\t\tfn.ast = ast;\n\t\tfn.literal = isLiteral(ast);\n\t\tfn.constant = isConstant(ast);\n\t\treturn fn;\n\t},\n\n\tUSE: \"use\",\n\n\tSTRICT: \"strict\",\n\n\twatchFns: function () {\n\t\tvar result = [];\n\t\tvar fns = this.state.inputs;\n\t\tvar self = this;\n\t\tforEach(fns, function (name) {\n\t\t\tresult.push(\"var \" + name + \"=\" + self.generateFunction(name, \"s\"));\n\t\t});\n\t\tif (fns.length) {\n\t\t\tresult.push(\"fn.inputs=[\" + fns.join(\",\") + \"];\");\n\t\t}\n\t\treturn result.join(\"\");\n\t},\n\n\tgenerateFunction: function (name, params) {\n\t\treturn (\n\t\t\t\"function(\" +\n\t\t\tparams +\n\t\t\t\"){\" +\n\t\t\tthis.varsPrefix(name) +\n\t\t\tthis.body(name) +\n\t\t\t\"};\"\n\t\t);\n\t},\n\n\tfilterPrefix: function () {\n\t\tvar parts = [];\n\t\tvar self = this;\n\t\tforEach(this.state.filters, function (id, filter) {\n\t\t\tparts.push(id + \"=$filter(\" + self.escape(filter) + \")\");\n\t\t});\n\t\tif (parts.length) return \"var \" + parts.join(\",\") + \";\";\n\t\treturn \"\";\n\t},\n\n\tvarsPrefix: function (section) {\n\t\treturn this.state[section].vars.length\n\t\t\t? \"var \" + this.state[section].vars.join(\",\") + \";\"\n\t\t\t: \"\";\n\t},\n\n\tbody: function (section) {\n\t\treturn this.state[section].body.join(\"\");\n\t},\n\n\trecurse: function (\n\t\tast,\n\t\tintoId,\n\t\tnameId,\n\t\trecursionFn,\n\t\tcreate,\n\t\tskipWatchIdCheck\n\t) {\n\t\tvar left,\n\t\t\tright,\n\t\t\tself = this,\n\t\t\targs,\n\t\t\texpression,\n\t\t\tcomputed;\n\t\trecursionFn = recursionFn || noop;\n\t\tif (!skipWatchIdCheck && isDefined(ast.watchId)) {\n\t\t\tintoId = intoId || this.nextId();\n\t\t\tthis.if_(\n\t\t\t\t\"i\",\n\t\t\t\tthis.lazyAssign(intoId, this.unsafeComputedMember(\"i\", ast.watchId)),\n\t\t\t\tthis.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (ast.type) {\n\t\t\tcase AST.Program:\n\t\t\t\tforEach(ast.body, function (expression, pos) {\n\t\t\t\t\tself.recurse(\n\t\t\t\t\t\texpression.expression,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tfunction (expr) {\n\t\t\t\t\t\t\tright = expr;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tif (pos !== ast.body.length - 1) {\n\t\t\t\t\t\tself.current().body.push(right, \";\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.return_(right);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase AST.Literal:\n\t\t\t\texpression = this.escape(ast.value);\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.UnaryExpression:\n\t\t\t\tthis.recurse(ast.argument, undefined, undefined, function (expr) {\n\t\t\t\t\tright = expr;\n\t\t\t\t});\n\t\t\t\texpression = ast.operator + \"(\" + this.ifDefined(right, 0) + \")\";\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.BinaryExpression:\n\t\t\t\tthis.recurse(ast.left, undefined, undefined, function (expr) {\n\t\t\t\t\tleft = expr;\n\t\t\t\t});\n\t\t\t\tthis.recurse(ast.right, undefined, undefined, function (expr) {\n\t\t\t\t\tright = expr;\n\t\t\t\t});\n\t\t\t\tif (ast.operator === \"+\") {\n\t\t\t\t\texpression = this.plus(left, right);\n\t\t\t\t} else if (ast.operator === \"-\") {\n\t\t\t\t\texpression =\n\t\t\t\t\t\tthis.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);\n\t\t\t\t} else {\n\t\t\t\t\texpression = \"(\" + left + \")\" + ast.operator + \"(\" + right + \")\";\n\t\t\t\t}\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.LogicalExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(ast.left, intoId);\n\t\t\t\tself.if_(\n\t\t\t\t\tast.operator === \"&&\" ? intoId : self.not(intoId),\n\t\t\t\t\tself.lazyRecurse(ast.right, intoId)\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.ConditionalExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(ast.test, intoId);\n\t\t\t\tself.if_(\n\t\t\t\t\tintoId,\n\t\t\t\t\tself.lazyRecurse(ast.alternate, intoId),\n\t\t\t\t\tself.lazyRecurse(ast.consequent, intoId)\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.Identifier:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tif (nameId) {\n\t\t\t\t\tnameId.context =\n\t\t\t\t\t\tself.stage === \"inputs\"\n\t\t\t\t\t\t\t? \"s\"\n\t\t\t\t\t\t\t: this.assign(\n\t\t\t\t\t\t\t\t\tthis.nextId(),\n\t\t\t\t\t\t\t\t\tthis.getHasOwnProperty(\"l\", ast.name) + \"?l:s\"\n\t\t\t\t\t\t\t  );\n\t\t\t\t\tnameId.computed = false;\n\t\t\t\t\tnameId.name = ast.name;\n\t\t\t\t}\n\t\t\t\tself.if_(\n\t\t\t\t\tself.stage === \"inputs\" ||\n\t\t\t\t\t\tself.not(self.getHasOwnProperty(\"l\", ast.name)),\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.stage === \"inputs\" ||\n\t\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\t\t\"s\",\n\t\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\t\tself.isNull(self.nonComputedMember(\"s\", ast.name)),\n\t\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(\"s\", ast.name)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\t\t\t\tself.isNull(self.nonComputedMember(\"s\", ast.name)),\n\t\t\t\t\t\t\t\t\t\tself.lazyAssign(self.nonComputedMember(\"s\", ast.name), \"{}\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tself.assign(intoId, self.nonComputedMember(\"s\", ast.name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\tintoId &&\n\t\t\t\t\t\tself.lazyAssign(intoId, self.nonComputedMember(\"l\", ast.name))\n\t\t\t\t);\n\t\t\t\trecursionFn(intoId);\n\t\t\t\tbreak;\n\t\t\tcase AST.MemberExpression:\n\t\t\t\tleft = (nameId && (nameId.context = this.nextId())) || this.nextId();\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tself.recurse(\n\t\t\t\t\tast.object,\n\t\t\t\t\tleft,\n\t\t\t\t\tundefined,\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tvar member = null;\n\t\t\t\t\t\tconst inAssignment = self.current().inAssignment;\n\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\tright = self.nextId();\n\t\t\t\t\t\t\tif (inAssignment || self.state.computing === \"assign\") {\n\t\t\t\t\t\t\t\tmember = self.unsafeComputedMember(left, right);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmember = self.computedMember(left, right);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (inAssignment || self.state.computing === \"assign\") {\n\t\t\t\t\t\t\t\tmember = self.unsafeNonComputedMember(left, ast.property.name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmember = self.nonComputedMember(left, ast.property.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tright = ast.property.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\tif (ast.property.type === AST.Literal) {\n\t\t\t\t\t\t\t\tself.recurse(ast.property, right);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\tself.notNull(left),\n\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\tself.isNull(member),\n\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(left, right, ast.computed)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tif (ast.computed) {\n\t\t\t\t\t\t\t\t\tif (ast.property.type !== AST.Literal) {\n\t\t\t\t\t\t\t\t\t\tself.recurse(ast.property, right);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\t\tself.if_(self.not(member), self.lazyAssign(member, \"{}\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tself.assign(intoId, member);\n\t\t\t\t\t\t\t\t\tif (nameId) {\n\t\t\t\t\t\t\t\t\t\tnameId.computed = true;\n\t\t\t\t\t\t\t\t\t\tnameId.name = right;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\t\t\t\t\tself.isNull(member),\n\t\t\t\t\t\t\t\t\t\t\tself.lazyAssign(member, \"{}\")\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tself.assign(intoId, member);\n\t\t\t\t\t\t\t\t\tif (nameId) {\n\t\t\t\t\t\t\t\t\t\tnameId.computed = false;\n\t\t\t\t\t\t\t\t\t\tnameId.name = ast.property.name;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.assign(intoId, \"undefined\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t\t},\n\t\t\t\t\t!!create\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase AST.CallExpression:\n\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\tif (ast.filter) {\n\t\t\t\t\tright = self.filter(ast.callee.name);\n\t\t\t\t\targs = [];\n\t\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\t\tvar argument = self.nextId();\n\t\t\t\t\t\tself.recurse(expr, argument);\n\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t});\n\t\t\t\t\texpression = right + \".call(\" + right + \",\" + args.join(\",\") + \")\";\n\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t} else {\n\t\t\t\t\tright = self.nextId();\n\t\t\t\t\tleft = {};\n\t\t\t\t\targs = [];\n\t\t\t\t\tself.recurse(ast.callee, right, left, function () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.notNull(right),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\t\t\t\t\tself.recurse(\n\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tfunction (argument) {\n\t\t\t\t\t\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (left.name) {\n\t\t\t\t\t\t\t\t\tvar x = self.member(left.context, left.name, left.computed);\n\t\t\t\t\t\t\t\t\texpression =\n\t\t\t\t\t\t\t\t\t\t\"(\" +\n\t\t\t\t\t\t\t\t\t\tx +\n\t\t\t\t\t\t\t\t\t\t\" === null ? null : \" +\n\t\t\t\t\t\t\t\t\t\tself.unsafeMember(left.context, left.name, left.computed) +\n\t\t\t\t\t\t\t\t\t\t\".call(\" +\n\t\t\t\t\t\t\t\t\t\t[left.context].concat(args).join(\",\") +\n\t\t\t\t\t\t\t\t\t\t\"))\";\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\texpression = right + \"(\" + args.join(\",\") + \")\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.assign(intoId, \"undefined\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\trecursionFn(intoId);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AST.AssignmentExpression:\n\t\t\t\tright = this.nextId();\n\t\t\t\tleft = {};\n\t\t\t\tself.current().inAssignment = true;\n\t\t\t\tthis.recurse(\n\t\t\t\t\tast.left,\n\t\t\t\t\tundefined,\n\t\t\t\t\tleft,\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tself.if_(\n\t\t\t\t\t\t\tself.and_(\n\t\t\t\t\t\t\t\tself.notNull(left.context),\n\t\t\t\t\t\t\t\tself.or_(\n\t\t\t\t\t\t\t\t\tself.hasOwnProperty_(left.context, left.name),\n\t\t\t\t\t\t\t\t\tself.isNull(\n\t\t\t\t\t\t\t\t\t\tself.member(left.context, left.name, left.computed)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\tself.recurse(ast.right, right);\n\t\t\t\t\t\t\t\texpression =\n\t\t\t\t\t\t\t\t\tself.member(left.context, left.name, left.computed) +\n\t\t\t\t\t\t\t\t\tast.operator +\n\t\t\t\t\t\t\t\t\tright;\n\t\t\t\t\t\t\t\tself.assign(intoId, expression);\n\t\t\t\t\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tself.current().inAssignment = false;\n\t\t\t\t\t\tself.recurse(ast.right, right);\n\t\t\t\t\t\tself.current().inAssignment = true;\n\t\t\t\t\t},\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t\tself.current().inAssignment = false;\n\t\t\t\tbreak;\n\t\t\tcase AST.ArrayExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\t\tself.recurse(\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tfunction (argument) {\n\t\t\t\t\t\t\targs.push(argument);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\texpression = \"[\" + args.join(\",\") + \"]\";\n\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.ObjectExpression:\n\t\t\t\targs = [];\n\t\t\t\tcomputed = false;\n\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\tcomputed = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (computed) {\n\t\t\t\t\tintoId = intoId || this.nextId();\n\t\t\t\t\tthis.assign(intoId, \"{}\");\n\t\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\t\tleft = self.nextId();\n\t\t\t\t\t\t\tself.recurse(property.key, left);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft =\n\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t: \"\" + property.key.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tright = self.nextId();\n\t\t\t\t\t\tself.recurse(property.value, right);\n\t\t\t\t\t\tself.assign(\n\t\t\t\t\t\t\tself.unsafeMember(intoId, left, property.computed),\n\t\t\t\t\t\t\tright\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\t\tself.recurse(\n\t\t\t\t\t\t\tproperty.value,\n\t\t\t\t\t\t\tast.constant ? undefined : self.nextId(),\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tfunction (expr) {\n\t\t\t\t\t\t\t\targs.push(\n\t\t\t\t\t\t\t\t\tself.escape(\n\t\t\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t\t\t: \"\" + property.key.value\n\t\t\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t\t\t\t\":\" +\n\t\t\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\texpression = \"{\" + args.join(\",\") + \"}\";\n\t\t\t\t\tthis.assign(intoId, expression);\n\t\t\t\t}\n\t\t\t\trecursionFn(intoId || expression);\n\t\t\t\tbreak;\n\t\t\tcase AST.ThisExpression:\n\t\t\t\tthis.assign(intoId, \"s\");\n\t\t\t\trecursionFn(intoId || \"s\");\n\t\t\t\tbreak;\n\t\t\tcase AST.LocalsExpression:\n\t\t\t\tthis.assign(intoId, \"l\");\n\t\t\t\trecursionFn(intoId || \"l\");\n\t\t\t\tbreak;\n\t\t\tcase AST.NGValueParameter:\n\t\t\t\tthis.assign(intoId, \"v\");\n\t\t\t\trecursionFn(intoId || \"v\");\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\tgetHasOwnProperty: function (element, property) {\n\t\tvar key = element + \".\" + property;\n\t\tvar own = this.current().own;\n\t\tif (!own.hasOwnProperty(key)) {\n\t\t\town[key] = this.nextId(\n\t\t\t\tfalse,\n\t\t\t\telement + \"&&(\" + this.escape(property) + \" in \" + element + \")\"\n\t\t\t);\n\t\t}\n\t\treturn own[key];\n\t},\n\n\tassign: function (id, value) {\n\t\tif (!id) return;\n\t\tthis.current().body.push(id, \"=\", value, \";\");\n\t\treturn id;\n\t},\n\n\tfilter: function (filterName) {\n\t\tif (!this.state.filters.hasOwnProperty(filterName)) {\n\t\t\tthis.state.filters[filterName] = this.nextId(true);\n\t\t}\n\t\treturn this.state.filters[filterName];\n\t},\n\n\tifDefined: function (id, defaultValue) {\n\t\treturn \"ifDefined(\" + id + \",\" + this.escape(defaultValue) + \")\";\n\t},\n\n\tplus: function (left, right) {\n\t\treturn \"plus(\" + left + \",\" + right + \")\";\n\t},\n\n\treturn_: function (id) {\n\t\tthis.current().body.push(\"return \", id, \";\");\n\t},\n\n\tif_: function (test, alternate, consequent) {\n\t\tif (test === true) {\n\t\t\talternate();\n\t\t} else {\n\t\t\tvar body = this.current().body;\n\t\t\tbody.push(\"if(\", test, \"){\");\n\t\t\talternate();\n\t\t\tbody.push(\"}\");\n\t\t\tif (consequent) {\n\t\t\t\tbody.push(\"else{\");\n\t\t\t\tconsequent();\n\t\t\t\tbody.push(\"}\");\n\t\t\t}\n\t\t}\n\t},\n\tor_: function (expr1, expr2) {\n\t\treturn \"(\" + expr1 + \") || (\" + expr2 + \")\";\n\t},\n\thasOwnProperty_: function (obj, prop, computed) {\n\t\tif (computed) {\n\t\t\treturn \"(Object.prototype.hasOwnProperty.call(\" + obj + \",\" + prop + \"))\";\n\t\t} else {\n\t\t\treturn (\n\t\t\t\t\"(Object.prototype.hasOwnProperty.call(\" + obj + \",'\" + prop + \"'))\"\n\t\t\t);\n\t\t}\n\t},\n\tand_: function (expr1, expr2) {\n\t\treturn \"(\" + expr1 + \") && (\" + expr2 + \")\";\n\t},\n\tnot: function (expression) {\n\t\treturn \"!(\" + expression + \")\";\n\t},\n\n\tisNull: function (expression) {\n\t\treturn expression + \"==null\";\n\t},\n\n\tnotNull: function (expression) {\n\t\treturn expression + \"!=null\";\n\t},\n\n\tnonComputedMember: function (left, right) {\n\t\tvar SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;\n\t\tvar UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;\n\t\tvar expr = \"\";\n\t\tif (SAFE_IDENTIFIER.test(right)) {\n\t\t\texpr = left + \".\" + right;\n\t\t} else {\n\t\t\tright = right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn);\n\t\t\texpr = left + '[\"' + right + '\"]';\n\t\t}\n\n\t\treturn expr;\n\t},\n\n\tunsafeComputedMember: function (left, right) {\n\t\treturn left + \"[\" + right + \"]\";\n\t},\n\tunsafeNonComputedMember: function (left, right) {\n\t\treturn this.nonComputedMember(left, right);\n\t},\n\n\tcomputedMember: function (left, right) {\n\t\tif (this.state.computing === \"assign\") {\n\t\t\treturn this.unsafeComputedMember(left, right);\n\t\t}\n\t\t// return left + \"[\" + right + \"]\";\n\t\treturn (\n\t\t\t\"(\" +\n\t\t\tleft +\n\t\t\t\".hasOwnProperty(\" +\n\t\t\tright +\n\t\t\t\") ? \" +\n\t\t\tleft +\n\t\t\t\"[\" +\n\t\t\tright +\n\t\t\t\"] : null)\"\n\t\t);\n\t},\n\n\tunsafeMember: function (left, right, computed) {\n\t\tif (computed) return this.unsafeComputedMember(left, right);\n\t\treturn this.unsafeNonComputedMember(left, right);\n\t},\n\n\tmember: function (left, right, computed) {\n\t\tif (computed) return this.computedMember(left, right);\n\t\treturn this.nonComputedMember(left, right);\n\t},\n\n\tgetStringValue: function (item) {\n\t\tthis.assign(item, \"getStringValue(\" + item + \")\");\n\t},\n\n\tlazyRecurse: function (\n\t\tast,\n\t\tintoId,\n\t\tnameId,\n\t\trecursionFn,\n\t\tcreate,\n\t\tskipWatchIdCheck\n\t) {\n\t\tvar self = this;\n\t\treturn function () {\n\t\t\tself.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);\n\t\t};\n\t},\n\n\tlazyAssign: function (id, value) {\n\t\tvar self = this;\n\t\treturn function () {\n\t\t\tself.assign(id, value);\n\t\t};\n\t},\n\n\tstringEscapeRegex: /[^ a-zA-Z0-9]/g,\n\n\tstringEscapeFn: function (c) {\n\t\treturn \"\\\\u\" + (\"0000\" + c.charCodeAt(0).toString(16)).slice(-4);\n\t},\n\n\tescape: function (value) {\n\t\tif (isString(value))\n\t\t\treturn (\n\t\t\t\t\"'\" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + \"'\"\n\t\t\t);\n\t\tif (isNumber(value)) return value.toString();\n\t\tif (value === true) return \"true\";\n\t\tif (value === false) return \"false\";\n\t\tif (value === null) return \"null\";\n\t\tif (typeof value === \"undefined\") return \"undefined\";\n\n\t\tthrow $parseMinErr(\"esc\", \"IMPOSSIBLE\");\n\t},\n\n\tnextId: function (skip, init) {\n\t\tvar id = \"v\" + this.state.nextId++;\n\t\tif (!skip) {\n\t\t\tthis.current().vars.push(id + (init ? \"=\" + init : \"\"));\n\t\t}\n\t\treturn id;\n\t},\n\n\tcurrent: function () {\n\t\treturn this.state[this.state.computing];\n\t},\n};\n\nfunction ASTInterpreter(astBuilder, $filter) {\n\tthis.astBuilder = astBuilder;\n\tthis.$filter = $filter;\n}\n\nASTInterpreter.prototype = {\n\tcompile: function (expression) {\n\t\tvar self = this;\n\t\tvar ast = this.astBuilder.ast(expression);\n\t\tfindConstantAndWatchExpressions(ast, self.$filter);\n\t\tvar assignable;\n\t\tvar assign;\n\t\tif ((assignable = assignableAST(ast))) {\n\t\t\tassign = this.recurse(assignable);\n\t\t}\n\t\tvar toWatch = getInputs(ast.body);\n\t\tvar inputs;\n\t\tif (toWatch) {\n\t\t\tinputs = [];\n\t\t\tforEach(toWatch, function (watch, key) {\n\t\t\t\tvar input = self.recurse(watch);\n\t\t\t\twatch.input = input;\n\t\t\t\tinputs.push(input);\n\t\t\t\twatch.watchId = key;\n\t\t\t});\n\t\t}\n\t\tvar expressions = [];\n\t\tforEach(ast.body, function (expression) {\n\t\t\texpressions.push(self.recurse(expression.expression));\n\t\t});\n\t\tvar fn =\n\t\t\tast.body.length === 0\n\t\t\t\t? noop\n\t\t\t\t: ast.body.length === 1\n\t\t\t\t? expressions[0]\n\t\t\t\t: function (scope, locals) {\n\t\t\t\t\t\tvar lastValue;\n\t\t\t\t\t\tforEach(expressions, function (exp) {\n\t\t\t\t\t\t\tlastValue = exp(scope, locals);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn lastValue;\n\t\t\t\t  };\n\n\t\tif (assign) {\n\t\t\tfn.assign = function (scope, value, locals) {\n\t\t\t\treturn assign(scope, locals, value);\n\t\t\t};\n\t\t}\n\t\tif (inputs) {\n\t\t\tfn.inputs = inputs;\n\t\t}\n\t\tfn.ast = ast;\n\t\tfn.literal = isLiteral(ast);\n\t\tfn.constant = isConstant(ast);\n\t\treturn fn;\n\t},\n\n\trecurse: function (ast, context, create) {\n\t\tvar left,\n\t\t\tright,\n\t\t\tself = this,\n\t\t\targs;\n\t\tif (ast.input) {\n\t\t\treturn this.inputs(ast.input, ast.watchId);\n\t\t}\n\t\tswitch (ast.type) {\n\t\t\tcase AST.Literal:\n\t\t\t\treturn this.value(ast.value, context);\n\t\t\tcase AST.UnaryExpression:\n\t\t\t\tright = this.recurse(ast.argument);\n\t\t\t\treturn this[\"unary\" + ast.operator](right, context);\n\t\t\tcase AST.BinaryExpression:\n\t\t\t\tleft = this.recurse(ast.left);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn this[\"binary\" + ast.operator](left, right, context);\n\t\t\tcase AST.LogicalExpression:\n\t\t\t\tleft = this.recurse(ast.left);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn this[\"binary\" + ast.operator](left, right, context);\n\t\t\tcase AST.ConditionalExpression:\n\t\t\t\treturn this[\"ternary?:\"](\n\t\t\t\t\tthis.recurse(ast.test),\n\t\t\t\t\tthis.recurse(ast.alternate),\n\t\t\t\t\tthis.recurse(ast.consequent),\n\t\t\t\t\tcontext\n\t\t\t\t);\n\t\t\tcase AST.Identifier:\n\t\t\t\treturn self.identifier(ast.name, context, create);\n\t\t\tcase AST.MemberExpression:\n\t\t\t\tleft = this.recurse(ast.object, false, !!create);\n\t\t\t\tif (!ast.computed) {\n\t\t\t\t\tright = ast.property.name;\n\t\t\t\t}\n\t\t\t\tif (ast.computed) right = this.recurse(ast.property);\n\n\t\t\t\treturn ast.computed\n\t\t\t\t\t? this.computedMember(left, right, context, create)\n\t\t\t\t\t: this.nonComputedMember(left, right, context, create);\n\t\t\tcase AST.CallExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.arguments, function (expr) {\n\t\t\t\t\targs.push(self.recurse(expr));\n\t\t\t\t});\n\t\t\t\tif (ast.filter) right = this.$filter(ast.callee.name);\n\t\t\t\tif (!ast.filter) right = this.recurse(ast.callee, true);\n\t\t\t\treturn ast.filter\n\t\t\t\t\t? function (scope, locals, assign, inputs) {\n\t\t\t\t\t\t\tvar values = [];\n\t\t\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\t\t\tvalues.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar value = right.apply(undefined, values, inputs);\n\t\t\t\t\t\t\treturn context\n\t\t\t\t\t\t\t\t? { context: undefined, name: undefined, value: value }\n\t\t\t\t\t\t\t\t: value;\n\t\t\t\t\t  }\n\t\t\t\t\t: function (scope, locals, assign, inputs) {\n\t\t\t\t\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\t\t\t\t\tvar value;\n\t\t\t\t\t\t\tif (rhs.value != null) {\n\t\t\t\t\t\t\t\tvar values = [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\t\t\t\tvalues.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalue = rhs.value.apply(rhs.context, values);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t\t  };\n\t\t\tcase AST.AssignmentExpression:\n\t\t\t\tleft = this.recurse(ast.left, true, 1);\n\t\t\t\tright = this.recurse(ast.right);\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\t\t\tlhs.context[lhs.name] = rhs;\n\t\t\t\t\treturn context ? { value: rhs } : rhs;\n\t\t\t\t};\n\t\t\tcase AST.ArrayExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.elements, function (expr) {\n\t\t\t\t\targs.push(self.recurse(expr));\n\t\t\t\t});\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar value = [];\n\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tvalue.push(args[i](scope, locals, assign, inputs));\n\t\t\t\t\t}\n\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t};\n\t\t\tcase AST.ObjectExpression:\n\t\t\t\targs = [];\n\t\t\t\tforEach(ast.properties, function (property) {\n\t\t\t\t\tif (property.computed) {\n\t\t\t\t\t\targs.push({\n\t\t\t\t\t\t\tkey: self.recurse(property.key),\n\t\t\t\t\t\t\tcomputed: true,\n\t\t\t\t\t\t\tvalue: self.recurse(property.value),\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push({\n\t\t\t\t\t\t\tkey:\n\t\t\t\t\t\t\t\tproperty.key.type === AST.Identifier\n\t\t\t\t\t\t\t\t\t? property.key.name\n\t\t\t\t\t\t\t\t\t: \"\" + property.key.value,\n\t\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\t\tvalue: self.recurse(property.value),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t\t\tvar value = {};\n\t\t\t\t\tfor (var i = 0; i < args.length; ++i) {\n\t\t\t\t\t\tif (args[i].computed) {\n\t\t\t\t\t\t\tvalue[args[i].key(scope, locals, assign, inputs)] = args[i].value(\n\t\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\t\tlocals,\n\t\t\t\t\t\t\t\tassign,\n\t\t\t\t\t\t\t\tinputs\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue[args[i].key] = args[i].value(scope, locals, assign, inputs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn context ? { value: value } : value;\n\t\t\t\t};\n\t\t\tcase AST.ThisExpression:\n\t\t\t\treturn function (scope) {\n\t\t\t\t\treturn context ? { value: scope } : scope;\n\t\t\t\t};\n\t\t\tcase AST.LocalsExpression:\n\t\t\t\treturn function (scope, locals) {\n\t\t\t\t\treturn context ? { value: locals } : locals;\n\t\t\t\t};\n\t\t\tcase AST.NGValueParameter:\n\t\t\t\treturn function (scope, locals, assign) {\n\t\t\t\t\treturn context ? { value: assign } : assign;\n\t\t\t\t};\n\t\t}\n\t},\n\n\t\"unary+\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = argument(scope, locals, assign, inputs);\n\t\t\tif (isDefined(arg)) {\n\t\t\t\targ = +arg;\n\t\t\t} else {\n\t\t\t\targ = 0;\n\t\t\t}\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"unary-\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = argument(scope, locals, assign, inputs);\n\t\t\tif (isDefined(arg)) {\n\t\t\t\targ = -arg;\n\t\t\t} else {\n\t\t\t\targ = -0;\n\t\t\t}\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"unary!\": function (argument, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = !argument(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary+\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\tvar arg = plusFn(lhs, rhs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary-\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs = right(scope, locals, assign, inputs);\n\t\t\tvar arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary*\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) *\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary/\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) /\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary%\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) %\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary===\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ===\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary!==\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) !==\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary==\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ==\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary!=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) !=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary<\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) <\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary>\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) >\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary<=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) <=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary>=\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) >=\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary&&\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) &&\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"binary||\": function (left, right, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg =\n\t\t\t\tleft(scope, locals, assign, inputs) ||\n\t\t\t\tright(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\t\"ternary?:\": function (test, alternate, consequent, context) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar arg = test(scope, locals, assign, inputs)\n\t\t\t\t? alternate(scope, locals, assign, inputs)\n\t\t\t\t: consequent(scope, locals, assign, inputs);\n\t\t\treturn context ? { value: arg } : arg;\n\t\t};\n\t},\n\tvalue: function (value, context) {\n\t\treturn function () {\n\t\t\treturn context\n\t\t\t\t? { context: undefined, name: undefined, value: value }\n\t\t\t\t: value;\n\t\t};\n\t},\n\tidentifier: function (name, context, create) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar base = locals && name in locals ? locals : scope;\n\t\t\tif (create && create !== 1 && base && base[name] == null) {\n\t\t\t\tbase[name] = {};\n\t\t\t}\n\t\t\tvar value = base ? base[name] : undefined;\n\t\t\tif (context) {\n\t\t\t\treturn { context: base, name: name, value: value };\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t};\n\t},\n\tcomputedMember: function (left, right, context, create) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tvar rhs;\n\t\t\tvar value;\n\t\t\tif (lhs != null) {\n\t\t\t\trhs = right(scope, locals, assign, inputs);\n\t\t\t\trhs = getStringValue(rhs);\n\t\t\t\tif (create && create !== 1) {\n\t\t\t\t\tif (lhs && !lhs[rhs]) {\n\t\t\t\t\t\tlhs[rhs] = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(lhs, rhs)) {\n\t\t\t\t\tvalue = lhs[rhs];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (context) {\n\t\t\t\treturn { context: lhs, name: rhs, value: value };\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t};\n\t},\n\tnonComputedMember: function (left, right, context, create) {\n\t\treturn function (scope, locals, assign, inputs) {\n\t\t\tvar lhs = left(scope, locals, assign, inputs);\n\t\t\tif (create && create !== 1) {\n\t\t\t\tif (lhs && lhs[right] == null) {\n\t\t\t\t\tlhs[right] = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar value = undefined;\n\t\t\tif (lhs != null && Object.prototype.hasOwnProperty.call(lhs, right)) {\n\t\t\t\tvalue = lhs[right];\n\t\t\t}\n\n\t\t\tif (context) {\n\t\t\t\treturn { context: lhs, name: right, value: value };\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t};\n\t},\n\tinputs: function (input, watchId) {\n\t\treturn function (scope, value, locals, inputs) {\n\t\t\tif (inputs) return inputs[watchId];\n\t\t\treturn input(scope, value, locals);\n\t\t};\n\t},\n};\n\n/**\n * @constructor\n */\nvar Parser = function Parser(lexer, $filter, options) {\n\tthis.lexer = lexer;\n\tthis.$filter = $filter;\n\tthis.options = options;\n\tthis.ast = new AST(lexer, options);\n\tthis.astCompiler = options.csp\n\t\t? new ASTInterpreter(this.ast, $filter)\n\t\t: new ASTCompiler(this.ast, $filter);\n};\n\nParser.prototype = {\n\tconstructor: Parser,\n\n\tparse: function (text) {\n\t\treturn this.astCompiler.compile(text);\n\t},\n};\n\nfunction getValueOf(value) {\n\treturn isFunction(value.valueOf)\n\t\t? value.valueOf()\n\t\t: objectValueOf.call(value);\n}\n\n///////////////////////////////////\n\n/**\n * @ngdoc service\n * @name $parse\n * @kind function\n *\n * @description\n *\n * Converts Angular {@link guide/expression expression} into a function.\n *\n * ```js\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'angular'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('angular');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * ```\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context` \u2013 `{object}` \u2013 an object against which any expressions embedded in the strings\n *      are evaluated against (typically a scope object).\n *    * `locals` \u2013 `{object=}` \u2013 local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The returned function also has the following properties:\n *      * `literal` \u2013 `{boolean}` \u2013 whether the expression's top-level node is a JavaScript\n *        literal.\n *      * `constant` \u2013 `{boolean}` \u2013 whether the expression is made entirely of JavaScript\n *        constant literals.\n *      * `assign` \u2013 `{?function(context, value)}` \u2013 if the expression is assignable, this will be\n *        set to a function to change its value on the given context.\n *\n */\n\n/**\n * @ngdoc provider\n * @name $parseProvider\n * @this\n *\n * @description\n * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}\n *  service.\n */\nfunction $ParseProvider() {\n\tvar cache = createMap();\n\tvar literals = {\n\t\ttrue: true,\n\t\tfalse: false,\n\t\tnull: null,\n\t\tundefined: undefined,\n\t};\n\tvar identStart, identContinue;\n\n\t/**\n\t * @ngdoc method\n\t * @name $parseProvider#addLiteral\n\t * @description\n\t *\n\t * Configure $parse service to add literal values that will be present as literal at expressions.\n\t *\n\t * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.\n\t * @param {*} literalValue Value for this literal. All literal values must be primitives or `undefined`.\n\t *\n\t **/\n\tthis.addLiteral = function (literalName, literalValue) {\n\t\tliterals[literalName] = literalValue;\n\t};\n\n\t/**\n\t * @ngdoc method\n\t * @name $parseProvider#setIdentifierFns\n\t *\n\t * @description\n\t *\n\t * Allows defining the set of characters that are allowed in Angular expressions. The function\n\t * `identifierStart` will get called to know if a given character is a valid character to be the\n\t * first character for an identifier. The function `identifierContinue` will get called to know if\n\t * a given character is a valid character to be a follow-up identifier character. The functions\n\t * `identifierStart` and `identifierContinue` will receive as arguments the single character to be\n\t * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in\n\t * mind that the `string` parameter can be two characters long depending on the character\n\t * representation. It is expected for the function to return `true` or `false`, whether that\n\t * character is allowed or not.\n\t *\n\t * Since this function will be called extensively, keep the implementation of these functions fast,\n\t * as the performance of these functions have a direct impact on the expressions parsing speed.\n\t *\n\t * @param {function=} identifierStart The function that will decide whether the given character is\n\t *   a valid identifier start character.\n\t * @param {function=} identifierContinue The function that will decide whether the given character is\n\t *   a valid identifier continue character.\n\t */\n\tthis.setIdentifierFns = function (identifierStart, identifierContinue) {\n\t\tidentStart = identifierStart;\n\t\tidentContinue = identifierContinue;\n\t\treturn this;\n\t};\n\n\tthis.$get = [\n\t\t\"$filter\",\n\t\tfunction ($filter) {\n\t\t\tvar noUnsafeEval = csp().noUnsafeEval;\n\t\t\tvar $parseOptions = {\n\t\t\t\tcsp: noUnsafeEval,\n\t\t\t\tliterals: copy(literals),\n\t\t\t\tisIdentifierStart: isFunction(identStart) && identStart,\n\t\t\t\tisIdentifierContinue: isFunction(identContinue) && identContinue,\n\t\t\t};\n\t\t\treturn $parse;\n\n\t\t\tfunction $parse(exp, interceptorFn) {\n\t\t\t\tvar parsedExpression, oneTime, cacheKey;\n\n\t\t\t\tswitch (typeof exp) {\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\texp = exp.trim();\n\t\t\t\t\t\tcacheKey = exp;\n\n\t\t\t\t\t\tparsedExpression = cache[cacheKey];\n\n\t\t\t\t\t\tif (!parsedExpression) {\n\t\t\t\t\t\t\tif (exp.charAt(0) === \":\" && exp.charAt(1) === \":\") {\n\t\t\t\t\t\t\t\toneTime = true;\n\t\t\t\t\t\t\t\texp = exp.substring(2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar lexer = new Lexer($parseOptions);\n\t\t\t\t\t\t\tvar parser = new Parser(lexer, $filter, $parseOptions);\n\t\t\t\t\t\t\tparsedExpression = parser.parse(exp);\n\t\t\t\t\t\t\tif (parsedExpression.constant) {\n\t\t\t\t\t\t\t\tparsedExpression.$$watchDelegate = constantWatchDelegate;\n\t\t\t\t\t\t\t} else if (oneTime) {\n\t\t\t\t\t\t\t\tparsedExpression.$$watchDelegate = parsedExpression.literal\n\t\t\t\t\t\t\t\t\t? oneTimeLiteralWatchDelegate\n\t\t\t\t\t\t\t\t\t: oneTimeWatchDelegate;\n\t\t\t\t\t\t\t} else if (parsedExpression.inputs) {\n\t\t\t\t\t\t\t\tparsedExpression.$$watchDelegate = inputsWatchDelegate;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcache[cacheKey] = parsedExpression;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn addInterceptor(parsedExpression, interceptorFn);\n\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\treturn addInterceptor(exp, interceptorFn);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn addInterceptor(noop, interceptorFn);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction expressionInputDirtyCheck(newValue, oldValueOfValue) {\n\t\t\t\tif (newValue == null || oldValueOfValue == null) {\n\t\t\t\t\t// null/undefined\n\t\t\t\t\treturn newValue === oldValueOfValue;\n\t\t\t\t}\n\n\t\t\t\tif (typeof newValue === \"object\") {\n\t\t\t\t\t// attempt to convert the value to a primitive type\n\t\t\t\t\t// TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can\n\t\t\t\t\t//             be cheaply dirty-checked\n\t\t\t\t\tnewValue = getValueOf(newValue);\n\n\t\t\t\t\tif (typeof newValue === \"object\") {\n\t\t\t\t\t\t// objects/arrays are not supported - deep-watching them would be too expensive\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// fall-through to the primitive equality check\n\t\t\t\t}\n\n\t\t\t\t//Primitive or NaN\n\t\t\t\t// eslint-disable-next-line no-self-compare\n\t\t\t\treturn (\n\t\t\t\t\tnewValue === oldValueOfValue ||\n\t\t\t\t\t(newValue !== newValue && oldValueOfValue !== oldValueOfValue)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction inputsWatchDelegate(\n\t\t\t\tscope,\n\t\t\t\tlistener,\n\t\t\t\tobjectEquality,\n\t\t\t\tparsedExpression,\n\t\t\t\tprettyPrintExpression\n\t\t\t) {\n\t\t\t\tvar inputExpressions = parsedExpression.inputs;\n\t\t\t\tvar lastResult;\n\n\t\t\t\tif (inputExpressions.length === 1) {\n\t\t\t\t\tvar oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails\n\t\t\t\t\tinputExpressions = inputExpressions[0];\n\t\t\t\t\treturn scope.$watch(\n\t\t\t\t\t\tfunction expressionInputWatch(scope) {\n\t\t\t\t\t\t\tvar newInputValue = inputExpressions(scope);\n\t\t\t\t\t\t\tif (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {\n\t\t\t\t\t\t\t\tlastResult = parsedExpression(scope, undefined, undefined, [\n\t\t\t\t\t\t\t\t\tnewInputValue,\n\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\toldInputValueOf = newInputValue && getValueOf(newInputValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn lastResult;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlistener,\n\t\t\t\t\t\tobjectEquality,\n\t\t\t\t\t\tprettyPrintExpression\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tvar oldInputValueOfValues = [];\n\t\t\t\tvar oldInputValues = [];\n\t\t\t\tfor (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n\t\t\t\t\toldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails\n\t\t\t\t\toldInputValues[i] = null;\n\t\t\t\t}\n\n\t\t\t\treturn scope.$watch(\n\t\t\t\t\tfunction expressionInputsWatch(scope) {\n\t\t\t\t\t\tvar changed = false;\n\n\t\t\t\t\t\tfor (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n\t\t\t\t\t\t\tvar newInputValue = inputExpressions[i](scope);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tchanged ||\n\t\t\t\t\t\t\t\t(changed = !expressionInputDirtyCheck(\n\t\t\t\t\t\t\t\t\tnewInputValue,\n\t\t\t\t\t\t\t\t\toldInputValueOfValues[i]\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toldInputValues[i] = newInputValue;\n\t\t\t\t\t\t\t\toldInputValueOfValues[i] =\n\t\t\t\t\t\t\t\t\tnewInputValue && getValueOf(newInputValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\tlastResult = parsedExpression(\n\t\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\toldInputValues\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastResult;\n\t\t\t\t\t},\n\t\t\t\t\tlistener,\n\t\t\t\t\tobjectEquality,\n\t\t\t\t\tprettyPrintExpression\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction oneTimeWatchDelegate(\n\t\t\t\tscope,\n\t\t\t\tlistener,\n\t\t\t\tobjectEquality,\n\t\t\t\tparsedExpression,\n\t\t\t\tprettyPrintExpression\n\t\t\t) {\n\t\t\t\tvar unwatch, lastValue;\n\t\t\t\tif (parsedExpression.inputs) {\n\t\t\t\t\tunwatch = inputsWatchDelegate(\n\t\t\t\t\t\tscope,\n\t\t\t\t\t\toneTimeListener,\n\t\t\t\t\t\tobjectEquality,\n\t\t\t\t\t\tparsedExpression,\n\t\t\t\t\t\tprettyPrintExpression\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tunwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);\n\t\t\t\t}\n\t\t\t\treturn unwatch;\n\n\t\t\t\tfunction oneTimeWatch(scope) {\n\t\t\t\t\treturn parsedExpression(scope);\n\t\t\t\t}\n\t\t\t\tfunction oneTimeListener(value, old, scope) {\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tif (isFunction(listener)) {\n\t\t\t\t\t\tlistener(value, old, scope);\n\t\t\t\t\t}\n\t\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\t\tscope.$$postDigest(function () {\n\t\t\t\t\t\t\tif (isDefined(lastValue)) {\n\t\t\t\t\t\t\t\tunwatch();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction oneTimeLiteralWatchDelegate(\n\t\t\t\tscope,\n\t\t\t\tlistener,\n\t\t\t\tobjectEquality,\n\t\t\t\tparsedExpression\n\t\t\t) {\n\t\t\t\tvar unwatch, lastValue;\n\t\t\t\tunwatch = scope.$watch(\n\t\t\t\t\tfunction oneTimeWatch(scope) {\n\t\t\t\t\t\treturn parsedExpression(scope);\n\t\t\t\t\t},\n\t\t\t\t\tfunction oneTimeListener(value, old, scope) {\n\t\t\t\t\t\tlastValue = value;\n\t\t\t\t\t\tif (isFunction(listener)) {\n\t\t\t\t\t\t\tlistener(value, old, scope);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isAllDefined(value)) {\n\t\t\t\t\t\t\tscope.$$postDigest(function () {\n\t\t\t\t\t\t\t\tif (isAllDefined(lastValue)) unwatch();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tobjectEquality\n\t\t\t\t);\n\n\t\t\t\treturn unwatch;\n\n\t\t\t\tfunction isAllDefined(value) {\n\t\t\t\t\tvar allDefined = true;\n\t\t\t\t\tforEach(value, function (val) {\n\t\t\t\t\t\tif (!isDefined(val)) allDefined = false;\n\t\t\t\t\t});\n\t\t\t\t\treturn allDefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction constantWatchDelegate(\n\t\t\t\tscope,\n\t\t\t\tlistener,\n\t\t\t\tobjectEquality,\n\t\t\t\tparsedExpression\n\t\t\t) {\n\t\t\t\tvar unwatch = scope.$watch(\n\t\t\t\t\tfunction constantWatch(scope) {\n\t\t\t\t\t\tunwatch();\n\t\t\t\t\t\treturn parsedExpression(scope);\n\t\t\t\t\t},\n\t\t\t\t\tlistener,\n\t\t\t\t\tobjectEquality\n\t\t\t\t);\n\t\t\t\treturn unwatch;\n\t\t\t}\n\n\t\t\tfunction addInterceptor(parsedExpression, interceptorFn) {\n\t\t\t\tif (!interceptorFn) return parsedExpression;\n\t\t\t\tvar watchDelegate = parsedExpression.$$watchDelegate;\n\t\t\t\tvar useInputs = false;\n\n\t\t\t\tvar regularWatch =\n\t\t\t\t\twatchDelegate !== oneTimeLiteralWatchDelegate &&\n\t\t\t\t\twatchDelegate !== oneTimeWatchDelegate;\n\n\t\t\t\tvar fn = regularWatch\n\t\t\t\t\t? function regularInterceptedExpression(\n\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\tlocals,\n\t\t\t\t\t\t\tassign,\n\t\t\t\t\t\t\tinputs\n\t\t\t\t\t  ) {\n\t\t\t\t\t\t\tvar value =\n\t\t\t\t\t\t\t\tuseInputs && inputs\n\t\t\t\t\t\t\t\t\t? inputs[0]\n\t\t\t\t\t\t\t\t\t: parsedExpression(scope, locals, assign, inputs);\n\t\t\t\t\t\t\treturn interceptorFn(value, scope, locals);\n\t\t\t\t\t  }\n\t\t\t\t\t: function oneTimeInterceptedExpression(\n\t\t\t\t\t\t\tscope,\n\t\t\t\t\t\t\tlocals,\n\t\t\t\t\t\t\tassign,\n\t\t\t\t\t\t\tinputs\n\t\t\t\t\t  ) {\n\t\t\t\t\t\t\tvar value = parsedExpression(scope, locals, assign, inputs);\n\t\t\t\t\t\t\tvar result = interceptorFn(value, scope, locals);\n\t\t\t\t\t\t\t// we only return the interceptor's result if the\n\t\t\t\t\t\t\t// initial value is defined (for bind-once)\n\t\t\t\t\t\t\treturn isDefined(value) ? result : value;\n\t\t\t\t\t  };\n\n\t\t\t\t// Propagate $$watchDelegates other then inputsWatchDelegate\n\t\t\t\tuseInputs = !parsedExpression.inputs;\n\t\t\t\tif (\n\t\t\t\t\tparsedExpression.$$watchDelegate &&\n\t\t\t\t\tparsedExpression.$$watchDelegate !== inputsWatchDelegate\n\t\t\t\t) {\n\t\t\t\t\tfn.$$watchDelegate = parsedExpression.$$watchDelegate;\n\t\t\t\t\tfn.inputs = parsedExpression.inputs;\n\t\t\t\t} else if (!interceptorFn.$stateful) {\n\t\t\t\t\t// If there is an interceptor, but no watchDelegate then treat the interceptor like\n\t\t\t\t\t// we treat filters - it is assumed to be a pure function unless flagged with $stateful\n\t\t\t\t\tfn.$$watchDelegate = inputsWatchDelegate;\n\t\t\t\t\tfn.inputs = parsedExpression.inputs\n\t\t\t\t\t\t? parsedExpression.inputs\n\t\t\t\t\t\t: [parsedExpression];\n\t\t\t\t}\n\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\t];\n}\n\nexports.Lexer = Lexer;\nexports.Parser = Parser;\n", "\"use strict\";\n\nvar chai = require(\"chai\");\nvar expect = chai.expect;\nvar expressions = require(\"../lib/main.js\");\nvar compile = expressions.compile;\n\nchai.config.includeStack = true;\n\n// These tests make no claim to be complete. We only test the most important parts of angular expressions.\n// I hope they have their own tests ;)\ndescribe(\"expressions\", function () {\n\tdescribe(\".Lexer\", function () {\n\t\tit(\"should be a function\", function () {\n\t\t\texpect(expressions.Lexer).to.be.a(\"function\");\n\t\t});\n\n\t\tit(\"should provide a .lex()-method\", function () {\n\t\t\tvar lexer = new expressions.Lexer();\n\n\t\t\texpect(lexer.lex).to.be.a(\"function\");\n\t\t});\n\t});\n\n\tdescribe(\".Parser\", function () {\n\t\tit(\"should be a function\", function () {\n\t\t\texpect(expressions.Parser).to.be.a(\"function\");\n\t\t});\n\n\t\tit(\"should provide a .parse()-method\", function () {\n\t\t\tvar parser = new expressions.Parser(undefined, undefined, {});\n\n\t\t\texpect(parser.parse).to.be.a(\"function\");\n\t\t});\n\t});\n\n\tdescribe(\".compile(src)\", function () {\n\t\tvar scope;\n\t\tvar evaluate;\n\n\t\tbeforeEach(function () {\n\t\t\tscope = {\n\t\t\t\tship: {\n\t\t\t\t\tpirate: {\n\t\t\t\t\t\tname: \"Jenny\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t});\n\n\t\tit(\"should return a function\", function () {\n\t\t\texpect(compile(\"\")).to.be.a(\"function\");\n\t\t});\n\n\t\tit(\"should throw an error if the given value is not a string\", function () {\n\t\t\texpect(function () {\n\t\t\t\tcompile();\n\t\t\t}).to.throw(\"src must be a string, instead saw 'undefined'\");\n\t\t});\n\n\t\tit(\"should expose the ast\", function () {\n\t\t\texpect(compile(\"tmp\").ast).to.be.a(\"object\");\n\t\t});\n\n\t\tdescribe(\"when evaluating literals\", function () {\n\t\t\tit(\"should return null\", function () {\n\t\t\t\tevaluate = compile(\"null\");\n\t\t\t\texpect(evaluate(scope)).to.equal(null);\n\t\t\t});\n\n\t\t\tit(\"should return true\", function () {\n\t\t\t\tevaluate = compile(\"true\");\n\t\t\t\texpect(evaluate(scope)).to.equal(true);\n\t\t\t});\n\n\t\t\tit(\"should return false\", function () {\n\t\t\t\tevaluate = compile(\"false\");\n\t\t\t\texpect(evaluate(scope)).to.equal(false);\n\t\t\t});\n\n\t\t\tit(\"should return 2.34e5\", function () {\n\t\t\t\tevaluate = compile(\"2.34e5\");\n\t\t\t\texpect(evaluate(scope)).to.equal(2.34e5);\n\t\t\t});\n\n\t\t\tit(\"should return 'string'\", function () {\n\t\t\t\tevaluate = compile(\"'string'\");\n\t\t\t\texpect(evaluate(scope)).to.equal(\"string\");\n\t\t\t});\n\n\t\t\tit(\"should return [ship, 1, 2, []]\", function () {\n\t\t\t\tevaluate = compile(\"[ship, 1, 2, []]\");\n\t\t\t\texpect(evaluate(scope)).to.eql([scope.ship, 1, 2, []]);\n\t\t\t});\n\n\t\t\tit(\"should return { test: 'value', 'new-object': {} }\", function () {\n\t\t\t\tevaluate = compile(\"{ test: 'value', 'new-object': {} }\");\n\t\t\t\texpect(evaluate(scope)).to.eql({ test: \"value\", \"new-object\": {} });\n\t\t\t});\n\n\t\t\tit(\"should return context value when nothing in the scope\", function () {\n\t\t\t\tevaluate = compile(\"test\");\n\t\t\t\texpect(evaluate(scope, { test: \"hello\" })).to.equal(\"hello\");\n\t\t\t});\n\n\t\t\tit(\"should return context value when something in the scope\", function () {\n\t\t\t\tevaluate = compile(\"test\");\n\t\t\t\texpect(evaluate({ test: \"bye\" }, { test: \"hello\" })).to.equal(\"hello\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating simple key look-ups\", function () {\n\t\t\tit(\"should return the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ship\");\n\t\t\t\texpect(evaluate(scope)).to.equal(scope.ship);\n\t\t\t});\n\n\t\t\tit(\"should return undefined instead of throwing a ReferenceError if it's not defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"notDefined\");\n\t\t\t\texpect(evaluate(scope)).to.equal(undefined);\n\t\t\t});\n\n\t\t\tit(\"should return the scope even when the 'this' keyword is used\", function () {\n\t\t\t\tevaluate = compile(\"this\");\n\t\t\t\texpect(evaluate(scope)).to.equal(scope);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating simple assignments\", function () {\n\t\t\tit(\"should set the new value on scope\", function () {\n\t\t\t\tevaluate = compile(\"newValue = 'new'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.newValue).to.equal(\"new\");\n\t\t\t});\n\n\t\t\tit(\"should change the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ship = 'ship'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.ship).to.equal(\"ship\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating dot-notated loop-ups\", function () {\n\t\t\tit(\"should return the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ship.pirate.name\");\n\t\t\t\texpect(evaluate(scope)).to.equal(\"Jenny\");\n\t\t\t});\n\n\t\t\tit(\"should return undefined instead of throwing a ReferenceError if it's not defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"island.pirate.name\");\n\t\t\t\texpect(evaluate(scope)).to.equal(undefined);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"Security\", function () {\n\t\t\tit(\"should not leak\", function () {\n\t\t\t\tevaluate = compile(\n\t\t\t\t\t\"''['c'+'onstructor']['c'+'onstructor']('return process;')()\"\n\t\t\t\t);\n\t\t\t\tconst result = evaluate({});\n\t\t\t\texpect(result).to.equal(undefined);\n\t\t\t});\n\n\t\t\tit(\"should not leak indirectly with string concatenation\", function () {\n\t\t\t\tevaluate = compile(\n\t\t\t\t\t\"a = null; a = ''['c'+'onstructor']['c'+'onstructor']; a = a('return process;'); a();\"\n\t\t\t\t);\n\t\t\t\tconst result = evaluate({});\n\t\t\t\texpect(result).to.equal(undefined);\n\t\t\t});\n\n\t\t\tit(\"should not leak indirectly with literal string\", function () {\n\t\t\t\tevaluate = compile(\n\t\t\t\t\t\"a = null; a = ''['constructor']['constructor']; a = a('return process;'); a();\"\n\t\t\t\t);\n\t\t\t\tconst result = evaluate({});\n\t\t\t\texpect(result).to.equal(undefined);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating dot-notated assignments\", function () {\n\t\t\tit(\"should set the new value on scope\", function () {\n\t\t\t\tevaluate = compile(\"island.pirate.name = 'St\u00f6rtebeker'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.island.pirate.name).to.equal(\"St\u00f6rtebeker\");\n\t\t\t});\n\n\t\t\tit(\"should change the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ship.pirate.name = 'St\u00f6rtebeker'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.ship.pirate.name).to.equal(\"St\u00f6rtebeker\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating array look-ups\", function () {\n\t\t\tbeforeEach(function () {\n\t\t\t\tscope.ships = [{ pirate: \"Jenny\" }, { pirate: \"St\u00f6rtebeker\" }];\n\t\t\t});\n\n\t\t\tit(\"should return the value if its defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ships[1].pirate\");\n\t\t\t\texpect(evaluate(scope)).to.equal(\"St\u00f6rtebeker\");\n\t\t\t});\n\n\t\t\tit(\"should return undefined instead of throwing a ReferenceError if it's not defined on scope\", function () {\n\t\t\t\tevaluate = compile(\"ships[2].pirate\");\n\t\t\t\texpect(evaluate(scope)).to.equal(undefined);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating array assignments\", function () {\n\t\t\tit(\"should change the value if its defined on scope\", function () {\n\t\t\t\tscope.ships = [{ pirate: \"Jenny\" }];\n\t\t\t\tevaluate = compile(\"ships[0].pirate = 'St\u00f6rtebeker'\");\n\t\t\t\tevaluate(scope);\n\t\t\t\texpect(scope.ships[0].pirate).to.equal(\"St\u00f6rtebeker\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating function calls\", function () {\n\t\t\tdescribe(\"using no arguments\", function () {\n\t\t\t\tit(\"should return the function's return value\", function () {\n\t\t\t\t\tscope.findPirate = function () {\n\t\t\t\t\t\treturn scope.ship.pirate;\n\t\t\t\t\t};\n\n\t\t\t\t\tevaluate = compile(\"findPirate()\");\n\t\t\t\t\texpect(evaluate(scope)).to.equal(scope.ship.pirate);\n\t\t\t\t});\n\n\t\t\t\tit(\"should call the function on the scope\", function () {\n\t\t\t\t\tscope.returnThis = function () {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t};\n\t\t\t\t\tevaluate = compile(\"returnThis()\");\n\t\t\t\t\texpect(evaluate(scope)).to.equal(scope);\n\t\t\t\t});\n\n\t\t\t\tit(\"should call the function on the object where it is defined\", function () {\n\t\t\t\t\tscope.ship.returnThis = function () {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t};\n\t\t\t\t\tevaluate = compile(\"ship.returnThis()\");\n\t\t\t\t\texpect(evaluate(scope)).to.equal(scope.ship);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tdescribe(\"using arguments\", function () {\n\t\t\t\tit(\"should parse the arguments accordingly\", function () {\n\t\t\t\t\tscope.findPirate = function () {\n\t\t\t\t\t\treturn Array.prototype.slice.call(arguments);\n\t\t\t\t\t};\n\t\t\t\t\tevaluate = compile(\"findPirate(ship.pirate, 1, [2, 3])\");\n\t\t\t\t\texpect(evaluate(scope)).to.eql([scope.ship.pirate, 1, [2, 3]]);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating operators\", function () {\n\t\t\tit(\"should return the expected result when using +\", function () {\n\t\t\t\tevaluate = compile(\"1 + 1\");\n\t\t\t\texpect(evaluate()).to.equal(2);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using -\", function () {\n\t\t\t\tevaluate = compile(\"1 - 1\");\n\t\t\t\texpect(evaluate()).to.equal(0);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using *\", function () {\n\t\t\t\tevaluate = compile(\"2 * 2\");\n\t\t\t\texpect(evaluate()).to.equal(4);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using /\", function () {\n\t\t\t\tevaluate = compile(\"4 / 2\");\n\t\t\t\texpect(evaluate()).to.equal(2);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using %\", function () {\n\t\t\t\tevaluate = compile(\"3 % 2\");\n\t\t\t\texpect(evaluate()).to.equal(1);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using &&\", function () {\n\t\t\t\tevaluate = compile(\"true && true\");\n\t\t\t\texpect(evaluate()).to.equal(true);\n\t\t\t\tevaluate = compile(\"true && false\");\n\t\t\t\texpect(evaluate()).to.equal(false);\n\t\t\t\tevaluate = compile(\"false && false\");\n\t\t\t\texpect(evaluate()).to.equal(false);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using ||\", function () {\n\t\t\t\tevaluate = compile(\"true || true\");\n\t\t\t\texpect(evaluate()).to.equal(true);\n\t\t\t\tevaluate = compile(\"true || false\");\n\t\t\t\texpect(evaluate()).to.equal(true);\n\t\t\t\tevaluate = compile(\"false || false\");\n\t\t\t\texpect(evaluate()).to.equal(false);\n\t\t\t});\n\n\t\t\tit(\"should return the expected result when using !\", function () {\n\t\t\t\tevaluate = compile(\"!true\");\n\t\t\t\texpect(evaluate()).to.equal(false);\n\t\t\t\tevaluate = compile(\"!false\");\n\t\t\t\texpect(evaluate()).to.equal(true);\n\t\t\t});\n\n\t\t\t/* Ooops, angular doesn't support ++. Maybe someday?\n            it(\"should return the expected result when using ++\", function () {\n                scope.value = 2;\n                evaluate = compile(\"value++\");\n                expect(evaluate()).to.equal(3);\n                expect(scope.value).to.equal(3);\n            });*/\n\n\t\t\t/* Ooops, angular doesn't support --. Maybe someday?\n            it(\"should return the expected result when using --\", function () {\n                scope.value = 2;\n                evaluate = compile(\"value--\");\n                expect(evaluate()).to.equal(1);\n                expect(scope.value).to.equal(1);\n            });*/\n\n\t\t\tit(\"should return the expected result when using ?\", function () {\n\t\t\t\tevaluate = compile(\"true? 'it works' : false\");\n\t\t\t\texpect(evaluate()).to.equal(\"it works\");\n\t\t\t\tevaluate = compile(\"false? false : 'it works'\");\n\t\t\t\texpect(evaluate()).to.equal(\"it works\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"using complex expressions\", function () {\n\t\t\tbeforeEach(function () {\n\t\t\t\tscope.ships = [\n\t\t\t\t\t{\n\t\t\t\t\t\tpirate: function (str) {\n\t\t\t\t\t\t\treturn str;\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpirate: function (str) {\n\t\t\t\t\t\t\treturn str;\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t\tscope.index = 0;\n\t\t\t\tscope.pi = \"pi\";\n\t\t\t\tscope.Jenny = \"Jenny\";\n\t\t\t});\n\n\t\t\tit(\"should still be parseable and executable\", function () {\n\t\t\t\tevaluate = compile(\"ships[index][pi + 'rate'](Jenny)\");\n\t\t\t\texpect(evaluate(scope)).to.equal(\"Jenny\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating syntactical errors\", function () {\n\t\t\tit(\"should give a readable error message\", function () {\n\t\t\t\texpect(function () {\n\t\t\t\t\tcompile(\"'unterminated string\");\n\t\t\t\t}).to.throw(\n\t\t\t\t\t\"Lexer Error: Unterminated quote at columns 0-20 ['unterminated string] in expression ['unterminated string].\"\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tit(\"should give a readable error message\", function () {\n\t\t\t\texpect(function () {\n\t\t\t\t\tcompile(\"3 = 4\");\n\t\t\t\t}).to.throw(\n\t\t\t\t\t'[$parse:lval] Trying to assign a value to a non l-value\\nhttp://errors.angularjs.org/\"NG_VERSION_FULL\"/$parse/lval'\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when using filters\", function () {\n\t\t\tit(\"should apply the given filter\", function () {\n\t\t\t\texpressions.filters.currency = function (input, currency, digits) {\n\t\t\t\t\tinput = input.toFixed(digits);\n\n\t\t\t\t\tif (currency === \"EUR\") {\n\t\t\t\t\t\treturn input + \"\u20ac\";\n\t\t\t\t\t}\n\t\t\t\t\treturn input + \"$\";\n\t\t\t\t};\n\n\t\t\t\tevaluate = compile(\"1.2345 | currency:selectedCurrency:2\");\n\t\t\t\texpect(\n\t\t\t\t\tevaluate({\n\t\t\t\t\t\tselectedCurrency: \"EUR\",\n\t\t\t\t\t})\n\t\t\t\t).to.equal(\"1.23\u20ac\");\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"when evaluating the same expression multiple times\", function () {\n\t\t\tit(\"should cache the generated function\", function () {\n\t\t\t\texpect(compile(\"a\")).to.equal(compile(\"a\"));\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\"for assigning values\", function () {\n\t\t\tbeforeEach(function () {\n\t\t\t\tscope = {};\n\t\t\t});\n\n\t\t\tit(\"should expose an 'assign'-function\", function () {\n\t\t\t\tvar fn = compile(\"a\");\n\n\t\t\t\texpect(fn.assign).to.be.a(\"function\");\n\t\t\t\tfn.assign(scope, 123);\n\t\t\t\texpect(scope.a).to.equal(123);\n\t\t\t});\n\n\t\t\tdescribe(\"the 'assign'-function\", function () {\n\t\t\t\tit(\"should work for expressions ending with brackets\", function () {\n\t\t\t\t\tvar fn = compile(\"a.b['c']\");\n\n\t\t\t\t\tfn.assign(scope, 123);\n\t\t\t\t\texpect(scope.a.b.c).to.equal(123);\n\t\t\t\t});\n\n\t\t\t\tit(\"should work for expressions with brackets in the middle\", function () {\n\t\t\t\t\tvar fn = compile('a[\"b\"].c');\n\n\t\t\t\t\tfn.assign(scope, 123);\n\t\t\t\t\texpect(scope.a.b.c).to.equal(123);\n\t\t\t\t});\n\n\t\t\t\tit(\"should return the result of the assignment\", function () {\n\t\t\t\t\tvar fn = compile('a[\"b\"].c');\n\n\t\t\t\t\texpect(fn.assign(scope, 123)).to.equal(123);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe(\".cache\", function () {\n\t\t\tit(\"should be an object by default\", function () {\n\t\t\t\texpect(compile.cache).to.be.an(\"object\");\n\t\t\t});\n\n\t\t\tit(\"should cache the generated function by the expression\", function () {\n\t\t\t\tvar fn = compile(\"a\");\n\n\t\t\t\texpect(compile.cache.a).to.equal(fn);\n\t\t\t});\n\n\t\t\tdescribe(\"when setting it to false\", function () {\n\t\t\t\tit(\"should disable the cache\", function () {\n\t\t\t\t\tcompile.cache = false;\n\t\t\t\t\texpect(compile(\"a\")).to.not.equal(compile(\"a\"));\n\t\t\t\t\tcompile.cache = Object.create(null);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe(\".filters\", function () {\n\t\tit(\"should be an object\", function () {\n\t\t\texpect(expressions.filters).to.be.an(\"object\");\n\t\t});\n\t});\n\n\tdescribe(\"Special characters\", function () {\n\t\tvar evaluate;\n\t\tit(\"should allow to define isIdentifierStart and isIdentifierContinue\", function () {\n\t\t\tfunction validChars(ch) {\n\t\t\t\treturn (\n\t\t\t\t\t(ch >= \"a\" && ch <= \"z\") ||\n\t\t\t\t\t(ch >= \"A\" && ch <= \"Z\") ||\n\t\t\t\t\tch === \"_\" ||\n\t\t\t\t\tch === \"$\" ||\n\t\t\t\t\t\"\u00c0\u00c8\u00cc\u00d2\u00d9\u00e0\u00e8\u00ec\u00f2\u00f9\u00c1\u00c9\u00cd\u00d3\u00da\u00e1\u00e9\u00ed\u00f3\u00fa\u00c2\u00ca\u00ce\u00d4\u00db\u00e2\u00ea\u00ee\u00f4\u00fb\u00c3\u00d1\u00d5\u00e3\u00f1\u00f5\u00c4\u00cb\u00cf\u00d6\u00dc\u0178\u00e4\u00eb\u00ef\u00f6\u00fc\u00ff\u00df\".indexOf(ch) !== -1\n\t\t\t\t);\n\t\t\t}\n\t\t\tevaluate = compile(\"\u00eatre_embarass\u00e9\", {\n\t\t\t\tisIdentifierStart: validChars,\n\t\t\t\tisIdentifierContinue: validChars,\n\t\t\t});\n\n\t\t\texpect(evaluate({ \u00eatre_embarass\u00e9: \"Ping\" })).to.eql(\"Ping\");\n\t\t});\n\t});\n\n\tdescribe(\"prototype\", function () {\n\t\tvar evaluate;\n\n\t\tit(\"should not leak\", function () {\n\t\t\tevaluate = compile(\"''.split\");\n\t\t\texpect(evaluate({})).to.eql(undefined);\n\t\t});\n\n\t\tit(\"should not leak with computed prop\", function () {\n\t\t\tevaluate = compile(\"a['split']\");\n\t\t\texpect(evaluate({ a: \"\" })).to.eql(null);\n\t\t});\n\n\t\tit(\"should allow to read string length\", function () {\n\t\t\tevaluate = compile(\"'abc'.length\");\n\t\t\texpect(evaluate({})).to.eql(3);\n\t\t});\n\n\t\tit(\"should allow to read users length\", function () {\n\t\t\tevaluate = compile(\"users.length\");\n\t\t\texpect(evaluate({ users: [1, 4, 4] })).to.eql(3);\n\t\t});\n\n\t\t// it(\"should disallow from changing prototype\", function() {\n\t\t// \tevaluate = compile(\"name.split = 10\");\n\t\t// \tvar scope = { name: \"hello\" };\n\t\t// \tevaluate(scope);\n\t\t// \texpect(scope.name.split).to.be.a(\"function\");\n\t\t// });\n\n\t\tit(\"should work with __proto__\", function () {\n\t\t\tevaluate = compile(\"__proto__\");\n\t\t\texpect(evaluate({})).to.eql(undefined);\n\t\t});\n\n\t\tit(\"should work with toString\", function () {\n\t\t\tevaluate = compile(\"toString\");\n\t\t\texpect(evaluate({ toString: 10 })).to.eql(10);\n\t\t});\n\t});\n});\n"], "filenames": ["CHANGELOG.md", "lib/parse.js", "test/main.test.js"], "buggy_code_start_loc": [0, 1697, 151], "buggy_code_end_loc": [22, 3829, 492], "fixing_code_start_loc": [1, 1696, 152], "fixing_code_end_loc": [26, 3843, 517], "type": "CWE-94", "message": "angular-expressions is \"angular's nicest part extracted as a standalone module for the browser and node\". In angular-expressions before version 1.1.2 there is a vulnerability which allows Remote Code Execution if you call \"expressions.compile(userControlledInput)\" where \"userControlledInput\" is text that comes from user input. The security of the package could be bypassed by using a more complex payload, using a \".constructor.constructor\" technique. In terms of impact: If running angular-expressions in the browser, an attacker could run any browser script when the application code calls expressions.compile(userControlledInput). If running angular-expressions on the server, an attacker could run any Javascript expression, thus gaining Remote Code Execution. This is fixed in version 1.1.2 of angular-expressions A temporary workaround might be either to disable user-controlled input that will be fed into angular-expressions in your application or allow only following characters in the userControlledInput.", "other": {"cve": {"id": "CVE-2021-21277", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-01T15:15:13.340", "lastModified": "2022-10-19T19:06:19.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "angular-expressions is \"angular's nicest part extracted as a standalone module for the browser and node\". In angular-expressions before version 1.1.2 there is a vulnerability which allows Remote Code Execution if you call \"expressions.compile(userControlledInput)\" where \"userControlledInput\" is text that comes from user input. The security of the package could be bypassed by using a more complex payload, using a \".constructor.constructor\" technique. In terms of impact: If running angular-expressions in the browser, an attacker could run any browser script when the application code calls expressions.compile(userControlledInput). If running angular-expressions on the server, an attacker could run any Javascript expression, thus gaining Remote Code Execution. This is fixed in version 1.1.2 of angular-expressions A temporary workaround might be either to disable user-controlled input that will be fed into angular-expressions in your application or allow only following characters in the userControlledInput."}, {"lang": "es", "value": "angular-expressions son \"angular's nicest part extracted as a standalone module for the browser and node\".&#xa0;En angular-expressions anteriores a la versi\u00f3n 1.1.2, existe una vulnerabilidad que permite una Ejecuci\u00f3n de C\u00f3digo Remota si llama a \"expression.compile(userControlledInput)\" donde \"userControlledInput\" es texto que proviene de la entrada del usuario.&#xa0;La seguridad del paquete podr\u00eda omitirse usando una carga \u00fatil m\u00e1s compleja, utilizando una t\u00e9cnica \".constructor.constructor\".&#xa0;En t\u00e9rminos de impacto: si ejecuta angular-expressions en el navegador, un atacante podr\u00eda ejecutar cualquier script del navegador cuando el c\u00f3digo de la aplicaci\u00f3n llame a expression.compile(userControlledInput).&#xa0;Si ejecuta angular-expressions en el servidor, un atacante podr\u00eda ejecutar cualquier expresi\u00f3n de Javascript, obteniendo as\u00ed una ejecuci\u00f3n de c\u00f3digo remota.&#xa0;Esto se corrigi\u00f3 en la versi\u00f3n 1.1.2 de angular-expressions. Una soluci\u00f3n temporal podr\u00eda ser deshabilitar la entrada controlada por el usuario que se alimentar\u00e1 en angular-expressions en su aplicaci\u00f3n o permitir solo seguir caracteres en el userControlledInput"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:peerigon:angular-expressions:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.1.2", "matchCriteriaId": "EF59E19D-CD5E-4B96-8445-154B8B913012"}]}]}], "references": [{"url": "http://blog.angularjs.org/2016/09/angular-16-expression-sandbox-removal.html", "source": "security-advisories@github.com", "tags": ["Broken Link", "Vendor Advisory"]}, {"url": "https://github.com/peerigon/angular-expressions/commit/07edb62902b1f6127b3dcc013da61c6316dd0bf1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/peerigon/angular-expressions/security/advisories/GHSA-j6px-jwvv-vpwq", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://www.npmjs.com/package/angular-expressions", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/peerigon/angular-expressions/commit/07edb62902b1f6127b3dcc013da61c6316dd0bf1"}}