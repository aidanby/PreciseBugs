{"buggy_code": ["/*\n\tAudio File Library\n\tCopyright (C) 2013 Michael Pruett <michael@68k.org>\n\n\tThis library is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU Lesser General Public\n\tLicense as published by the Free Software Foundation; either\n\tversion 2.1 of the License, or (at your option) any later version.\n\n\tThis library is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tLesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public\n\tLicense along with this library; if not, write to the\n\tFree Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n\tBoston, MA  02110-1301  USA\n*/\n\n#include \"config.h\"\n#include \"BlockCodec.h\"\n\n#include \"Track.h\"\n\n#include <assert.h>\n\nBlockCodec::BlockCodec(Mode mode, Track *track, File *fh, bool canSeek) :\n\tFileModule(mode, track, fh, canSeek),\n\tm_bytesPerPacket(-1),\n\tm_framesPerPacket(-1),\n\tm_framesToIgnore(-1),\n\tm_savedPositionNextFrame(-1),\n\tm_savedNextFrame(-1)\n{\n\tm_framesPerPacket = track->f.framesPerPacket;\n\tm_bytesPerPacket = track->f.bytesPerPacket;\n}\n\nvoid BlockCodec::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tAFframecount framesRead = 0;\n\n\tassert(framesToRead % m_framesPerPacket == 0);\n\tint blockCount = framesToRead / m_framesPerPacket;\n\n\t// Read the compressed data.\n\tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n\tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n\n\t// Decompress into m_outChunk.\n\tfor (int i=0; i<blocksRead; i++)\n\t{\n\t\tdecodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n\t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);\n\n\t\tframesRead += m_framesPerPacket;\n\t}\n\n\tm_track->nextfframe += framesRead;\n\n\tassert(tell() == m_track->fpos_next_frame);\n\n\tif (framesRead < framesToRead)\n\t\treportReadError(framesRead, framesToRead);\n\n\tm_outChunk->frameCount = framesRead;\n}\n\nvoid BlockCodec::reset1()\n{\n\tAFframecount nextTrackFrame = m_track->nextfframe;\n\tm_track->nextfframe = (nextTrackFrame / m_framesPerPacket) *\n\t\tm_framesPerPacket;\n\n\tm_framesToIgnore = nextTrackFrame - m_track->nextfframe;\n}\n\nvoid BlockCodec::reset2()\n{\n\tm_track->fpos_next_frame = m_track->fpos_first_frame +\n\t\tm_bytesPerPacket * (m_track->nextfframe / m_framesPerPacket);\n\tm_track->frames2ignore += m_framesToIgnore;\n\n\tassert(m_track->nextfframe % m_framesPerPacket == 0);\n}\n\nvoid BlockCodec::runPush()\n{\n\tAFframecount framesToWrite = m_inChunk->frameCount;\n\tint channelCount = m_inChunk->f.channelCount;\n\n\tint blockCount = (framesToWrite + m_framesPerPacket - 1) / m_framesPerPacket;\n\tfor (int i=0; i<blockCount; i++)\n\t{\n\t\tencodeBlock(static_cast<const int16_t *>(m_inChunk->buffer) + i * m_framesPerPacket * channelCount,\n\t\t\tstatic_cast<uint8_t *>(m_outChunk->buffer) + i * m_bytesPerPacket);\n\t}\n\n\tssize_t bytesWritten = write(m_outChunk->buffer, m_bytesPerPacket * blockCount);\n\tssize_t blocksWritten = bytesWritten >= 0 ? bytesWritten / m_bytesPerPacket : 0;\n\tAFframecount framesWritten = std::min((AFframecount) blocksWritten * m_framesPerPacket, framesToWrite);\n\n\tm_track->nextfframe += framesWritten;\n\tm_track->totalfframes = m_track->nextfframe;\n\n\tassert(tell() == m_track->fpos_next_frame);\n\n\tif (framesWritten < framesToWrite)\n\t\treportWriteError(framesWritten, framesToWrite);\n}\n\nvoid BlockCodec::sync1()\n{\n\tm_savedPositionNextFrame = m_track->fpos_next_frame;\n\tm_savedNextFrame = m_track->nextfframe;\n}\n\nvoid BlockCodec::sync2()\n{\n\tassert(tell() == m_track->fpos_next_frame);\n\tm_track->fpos_after_data = tell();\n\tm_track->fpos_next_frame = m_savedPositionNextFrame;\n\tm_track->nextfframe = m_savedNextFrame;\n}\n", "/*\n\tAudio File Library\n\tCopyright (C) 2010-2013, Michael Pruett <michael@68k.org>\n\tCopyright (C) 2001, Silicon Graphics, Inc.\n\n\tThis library is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU Lesser General Public\n\tLicense as published by the Free Software Foundation; either\n\tversion 2.1 of the License, or (at your option) any later version.\n\n\tThis library is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tLesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public\n\tLicense along with this library; if not, write to the\n\tFree Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n\tBoston, MA  02110-1301  USA\n*/\n\n/*\n\tThis module implements Microsoft ADPCM compression.\n*/\n\n#include \"config.h\"\n#include \"MSADPCM.h\"\n\n#include <assert.h>\n#include <cstdlib>\n#include <limits>\n#include <string.h>\n\n#include \"BlockCodec.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"afinternal.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"util.h\"\n#include \"../pcm.h\"\n\nstruct ms_adpcm_state\n{\n\tuint8_t predictorIndex;\n\tint delta;\n\tint16_t sample1, sample2;\n\n\tms_adpcm_state()\n\t{\n\t\tpredictorIndex = 0;\n\t\tdelta = 16;\n\t\tsample1 = 0;\n\t\tsample2 = 0;\n\t}\n};\n\nclass MSADPCM : public BlockCodec\n{\npublic:\n\tstatic MSADPCM *createDecompress(Track *, File *, bool canSeek,\n\t\tbool headerless, AFframecount *chunkFrames);\n\tstatic MSADPCM *createCompress(Track *, File *, bool canSeek,\n\t\tbool headerless, AFframecount *chunkFrames);\n\n\tvirtual ~MSADPCM();\n\n\tbool initializeCoefficients();\n\n\tvirtual const char *name() const OVERRIDE\n\t{\n\t\treturn mode() == Compress ? \"ms_adpcm_compress\" : \"ms_adpcm_decompress\";\n\t}\n\tvirtual void describe() OVERRIDE;\n\nprivate:\n\t// m_coefficients is an array of m_numCoefficients ADPCM coefficient pairs.\n\tint m_numCoefficients;\n\tint16_t m_coefficients[256][2];\n\n\tms_adpcm_state *m_state;\n\n\tMSADPCM(Mode mode, Track *track, File *fh, bool canSeek);\n\n\tint decodeBlock(const uint8_t *encoded, int16_t *decoded) OVERRIDE;\n\tint encodeBlock(const int16_t *decoded, uint8_t *encoded) OVERRIDE;\n\tvoid choosePredictorForBlock(const int16_t *decoded);\n};\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}\n\nstatic const int16_t adaptationTable[] =\n{\n\t230, 230, 230, 230, 307, 409, 512, 614,\n\t768, 614, 512, 409, 307, 230, 230, 230\n};\n\n// Compute a linear PCM value from the given differential coded value.\nstatic int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\n\tint delta = (state.delta * adaptationTable[code]) >> 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\n\treturn static_cast<int16_t>(linearSample);\n}\n\n// Compute a differential coded value from the given linear PCM sample.\nstatic uint8_t encodeSample(ms_adpcm_state &state, int16_t sample,\n\tconst int16_t *coefficient)\n{\n\tint predictor = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint code = sample - predictor;\n\tint bias = state.delta / 2;\n\tif (code < 0)\n\t\tbias = -bias;\n\tcode = (code + bias) / state.delta;\n\tcode = clamp(code, -8, 7) & 0xf;\n\n\tpredictor += ((code & 0x8) ? (code - 0x10) : code) * state.delta;\n\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.delta = (adaptationTable[code] * state.delta) >> 8;\n\tif (state.delta < 16)\n\t\tstate.delta = 16;\n\treturn code;\n}\n\n// Decode one block of MS ADPCM data.\nint MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Calculate the number of bytes needed for decoded data.\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\n\t// Initialize block predictor.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\n\t// Initialize delta.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\t// Initialize first two samples.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\n\t/*\n\t\tThe first two samples have already been 'decoded' in\n\t\tthe block header.\n\t*/\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0]);\n\t\t*decoded++ = newSample;\n\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1]);\n\t\t*decoded++ = newSample;\n\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn outputLength;\n}\n\nint MSADPCM::encodeBlock(const int16_t *decoded, uint8_t *encoded)\n{\n\tchoosePredictorForBlock(decoded);\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Encode predictor.\n\tfor (int c=0; c<channelCount; c++)\n\t\t*encoded++ = m_state[c].predictorIndex;\n\n\t// Encode delta.\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].delta & 0xff;\n\t\t*encoded++ = m_state[c].delta >> 8;\n\t}\n\n\t// Enccode first two samples.\n\tfor (int c=0; c<channelCount; c++)\n\t\tm_state[c].sample2 = *decoded++;\n\n\tfor (int c=0; c<channelCount; c++)\n\t\tm_state[c].sample1 = *decoded++;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].sample1 & 0xff;\n\t\t*encoded++ = m_state[c].sample1 >> 8;\n\t}\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].sample2 & 0xff;\n\t\t*encoded++ = m_state[c].sample2 >> 8;\n\t}\n\n\tms_adpcm_state *state[2] = { &m_state[0], &m_state[channelCount - 1] };\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code1 = encodeSample(*state[0], *decoded++, coefficient[0]);\n\t\tuint8_t code2 = encodeSample(*state[1], *decoded++, coefficient[1]);\n\n\t\t*encoded++ = (code1 << 4) | code2;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn m_bytesPerPacket;\n}\n\nvoid MSADPCM::choosePredictorForBlock(const int16_t *decoded)\n{\n\tconst int kPredictorSampleLength = 3;\n\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tint bestPredictorIndex = 0;\n\t\tint bestPredictorError = std::numeric_limits<int>::max();\n\t\tfor (int k=0; k<m_numCoefficients; k++)\n\t\t{\n\t\t\tint a0 = m_coefficients[k][0];\n\t\t\tint a1 = m_coefficients[k][1];\n\n\t\t\tint currentPredictorError = 0;\n\t\t\tfor (int i=2; i<2+kPredictorSampleLength; i++)\n\t\t\t{\n\t\t\t\tint error = std::abs(decoded[i*channelCount + c] -\n\t\t\t\t\t((a0 * decoded[(i-1)*channelCount + c] +\n\t\t\t\t\ta1 * decoded[(i-2)*channelCount + c]) >> 8));\n\t\t\t\tcurrentPredictorError += error;\n\t\t\t}\n\n\t\t\tcurrentPredictorError /= 4 * kPredictorSampleLength;\n\n\t\t\tif (currentPredictorError < bestPredictorError)\n\t\t\t{\n\t\t\t\tbestPredictorError = currentPredictorError;\n\t\t\t\tbestPredictorIndex = k;\n\t\t\t}\n\n\t\t\tif (!currentPredictorError)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (bestPredictorError < 16)\n\t\t\tbestPredictorError = 16;\n\n\t\tm_state[c].predictorIndex = bestPredictorIndex;\n\t\tm_state[c].delta = bestPredictorError;\n\t}\n}\n\nvoid MSADPCM::describe()\n{\n\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n}\n\nMSADPCM::MSADPCM(Mode mode, Track *track, File *fh, bool canSeek) :\n\tBlockCodec(mode, track, fh, canSeek),\n\tm_numCoefficients(0),\n\tm_state(NULL)\n{\n\tm_state = new ms_adpcm_state[m_track->f.channelCount];\n}\n\nMSADPCM::~MSADPCM()\n{\n\tdelete [] m_state;\n}\n\nbool MSADPCM::initializeCoefficients()\n{\n\tAUpvlist pv = m_track->f.compressionParams;\n\n\tlong l;\n\tif (_af_pv_getlong(pv, _AF_MS_ADPCM_NUM_COEFFICIENTS, &l))\n\t{\n\t\tm_numCoefficients = l;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"number of coefficients not set\");\n\t\treturn false;\n\t}\n\n\tvoid *v;\n\tif (_af_pv_getptr(pv, _AF_MS_ADPCM_COEFFICIENTS, &v))\n\t{\n\t\tmemcpy(m_coefficients, v, m_numCoefficients * 2 * sizeof (int16_t));\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"coefficient array not set\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nMSADPCM *MSADPCM::createDecompress(Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\tassert(fh->tell() == track->fpos_first_frame);\n\n\tMSADPCM *msadpcm = new MSADPCM(Decompress, track, fh, canSeek);\n\n\tif (!msadpcm->initializeCoefficients())\n\t{\n\t\tdelete msadpcm;\n\t\treturn NULL;\n\t}\n\n\t*chunkFrames = msadpcm->m_framesPerPacket;\n\n\treturn msadpcm;\n}\n\nMSADPCM *MSADPCM::createCompress(Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\tassert(fh->tell() == track->fpos_first_frame);\n\n\tMSADPCM *msadpcm = new MSADPCM(Compress, track, fh, canSeek);\n\n\tif (!msadpcm->initializeCoefficients())\n\t{\n\t\tdelete msadpcm;\n\t\treturn NULL;\n\t}\n\n\t*chunkFrames = msadpcm->m_framesPerPacket;\n\n\treturn msadpcm;\n}\n\nbool _af_ms_adpcm_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 16-bit signed integer format\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires native byte order\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nFileModule *_af_ms_adpcm_init_decompress (Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\treturn MSADPCM::createDecompress(track, fh, canSeek, headerless, chunkFrames);\n}\n\nFileModule *_af_ms_adpcm_init_compress (Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\treturn MSADPCM::createCompress(track, fh, canSeek, headerless, chunkFrames);\n}\n"], "fixing_code": ["/*\n\tAudio File Library\n\tCopyright (C) 2013 Michael Pruett <michael@68k.org>\n\n\tThis library is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU Lesser General Public\n\tLicense as published by the Free Software Foundation; either\n\tversion 2.1 of the License, or (at your option) any later version.\n\n\tThis library is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tLesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public\n\tLicense along with this library; if not, write to the\n\tFree Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n\tBoston, MA  02110-1301  USA\n*/\n\n#include \"config.h\"\n#include \"BlockCodec.h\"\n\n#include \"Track.h\"\n\n#include <assert.h>\n\nBlockCodec::BlockCodec(Mode mode, Track *track, File *fh, bool canSeek) :\n\tFileModule(mode, track, fh, canSeek),\n\tm_bytesPerPacket(-1),\n\tm_framesPerPacket(-1),\n\tm_framesToIgnore(-1),\n\tm_savedPositionNextFrame(-1),\n\tm_savedNextFrame(-1)\n{\n\tm_framesPerPacket = track->f.framesPerPacket;\n\tm_bytesPerPacket = track->f.bytesPerPacket;\n}\n\nvoid BlockCodec::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tAFframecount framesRead = 0;\n\n\tassert(framesToRead % m_framesPerPacket == 0);\n\tint blockCount = framesToRead / m_framesPerPacket;\n\n\t// Read the compressed data.\n\tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n\tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n\n\t// Decompress into m_outChunk.\n\tfor (int i=0; i<blocksRead; i++)\n\t{\n\t\tif (decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n\t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount)==0)\n\t\t\tbreak;\n\n\t\tframesRead += m_framesPerPacket;\n\t}\n\n\tm_track->nextfframe += framesRead;\n\n\tassert(tell() == m_track->fpos_next_frame);\n\n\tif (framesRead < framesToRead)\n\t\treportReadError(framesRead, framesToRead);\n\n\tm_outChunk->frameCount = framesRead;\n}\n\nvoid BlockCodec::reset1()\n{\n\tAFframecount nextTrackFrame = m_track->nextfframe;\n\tm_track->nextfframe = (nextTrackFrame / m_framesPerPacket) *\n\t\tm_framesPerPacket;\n\n\tm_framesToIgnore = nextTrackFrame - m_track->nextfframe;\n}\n\nvoid BlockCodec::reset2()\n{\n\tm_track->fpos_next_frame = m_track->fpos_first_frame +\n\t\tm_bytesPerPacket * (m_track->nextfframe / m_framesPerPacket);\n\tm_track->frames2ignore += m_framesToIgnore;\n\n\tassert(m_track->nextfframe % m_framesPerPacket == 0);\n}\n\nvoid BlockCodec::runPush()\n{\n\tAFframecount framesToWrite = m_inChunk->frameCount;\n\tint channelCount = m_inChunk->f.channelCount;\n\n\tint blockCount = (framesToWrite + m_framesPerPacket - 1) / m_framesPerPacket;\n\tfor (int i=0; i<blockCount; i++)\n\t{\n\t\tencodeBlock(static_cast<const int16_t *>(m_inChunk->buffer) + i * m_framesPerPacket * channelCount,\n\t\t\tstatic_cast<uint8_t *>(m_outChunk->buffer) + i * m_bytesPerPacket);\n\t}\n\n\tssize_t bytesWritten = write(m_outChunk->buffer, m_bytesPerPacket * blockCount);\n\tssize_t blocksWritten = bytesWritten >= 0 ? bytesWritten / m_bytesPerPacket : 0;\n\tAFframecount framesWritten = std::min((AFframecount) blocksWritten * m_framesPerPacket, framesToWrite);\n\n\tm_track->nextfframe += framesWritten;\n\tm_track->totalfframes = m_track->nextfframe;\n\n\tassert(tell() == m_track->fpos_next_frame);\n\n\tif (framesWritten < framesToWrite)\n\t\treportWriteError(framesWritten, framesToWrite);\n}\n\nvoid BlockCodec::sync1()\n{\n\tm_savedPositionNextFrame = m_track->fpos_next_frame;\n\tm_savedNextFrame = m_track->nextfframe;\n}\n\nvoid BlockCodec::sync2()\n{\n\tassert(tell() == m_track->fpos_next_frame);\n\tm_track->fpos_after_data = tell();\n\tm_track->fpos_next_frame = m_savedPositionNextFrame;\n\tm_track->nextfframe = m_savedNextFrame;\n}\n", "/*\n\tAudio File Library\n\tCopyright (C) 2010-2013, Michael Pruett <michael@68k.org>\n\tCopyright (C) 2001, Silicon Graphics, Inc.\n\n\tThis library is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU Lesser General Public\n\tLicense as published by the Free Software Foundation; either\n\tversion 2.1 of the License, or (at your option) any later version.\n\n\tThis library is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tLesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public\n\tLicense along with this library; if not, write to the\n\tFree Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n\tBoston, MA  02110-1301  USA\n*/\n\n/*\n\tThis module implements Microsoft ADPCM compression.\n*/\n\n#include \"config.h\"\n#include \"MSADPCM.h\"\n\n#include <assert.h>\n#include <cstdlib>\n#include <limits>\n#include <string.h>\n\n#include \"BlockCodec.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"afinternal.h\"\n#include \"audiofile.h\"\n#include \"byteorder.h\"\n#include \"util.h\"\n#include \"../pcm.h\"\n\nstruct ms_adpcm_state\n{\n\tuint8_t predictorIndex;\n\tint delta;\n\tint16_t sample1, sample2;\n\n\tms_adpcm_state()\n\t{\n\t\tpredictorIndex = 0;\n\t\tdelta = 16;\n\t\tsample1 = 0;\n\t\tsample2 = 0;\n\t}\n};\n\nclass MSADPCM : public BlockCodec\n{\npublic:\n\tstatic MSADPCM *createDecompress(Track *, File *, bool canSeek,\n\t\tbool headerless, AFframecount *chunkFrames);\n\tstatic MSADPCM *createCompress(Track *, File *, bool canSeek,\n\t\tbool headerless, AFframecount *chunkFrames);\n\n\tvirtual ~MSADPCM();\n\n\tbool initializeCoefficients();\n\n\tvirtual const char *name() const OVERRIDE\n\t{\n\t\treturn mode() == Compress ? \"ms_adpcm_compress\" : \"ms_adpcm_decompress\";\n\t}\n\tvirtual void describe() OVERRIDE;\n\nprivate:\n\t// m_coefficients is an array of m_numCoefficients ADPCM coefficient pairs.\n\tint m_numCoefficients;\n\tint16_t m_coefficients[256][2];\n\n\tms_adpcm_state *m_state;\n\n\tMSADPCM(Mode mode, Track *track, File *fh, bool canSeek);\n\n\tint decodeBlock(const uint8_t *encoded, int16_t *decoded) OVERRIDE;\n\tint encodeBlock(const int16_t *decoded, uint8_t *encoded) OVERRIDE;\n\tvoid choosePredictorForBlock(const int16_t *decoded);\n};\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}\n\nstatic const int16_t adaptationTable[] =\n{\n\t230, 230, 230, 230, 307, 409, 512, 614,\n\t768, 614, 512, 409, 307, 230, 230, 230\n};\n\nint firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}\n\n#ifndef __has_builtin\n#define __has_builtin(x) 0\n#endif\n\nint multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits\n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}\n\n\n// Compute a linear PCM value from the given differential coded value.\nstatic int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient, bool *ok=NULL)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint delta;\n\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\n\tif (multiplyCheckOverflow(state.delta, adaptationTable[code], &delta))\n\t{\n                if (ok) *ok=false;\n\t\t_af_error(AF_BAD_COMPRESSION, \"Error decoding sample\");\n\t\treturn 0;\n\t}\n\tdelta >>= 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\tif (ok) *ok=true;\n\n\treturn static_cast<int16_t>(linearSample);\n}\n\n// Compute a differential coded value from the given linear PCM sample.\nstatic uint8_t encodeSample(ms_adpcm_state &state, int16_t sample,\n\tconst int16_t *coefficient)\n{\n\tint predictor = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint code = sample - predictor;\n\tint bias = state.delta / 2;\n\tif (code < 0)\n\t\tbias = -bias;\n\tcode = (code + bias) / state.delta;\n\tcode = clamp(code, -8, 7) & 0xf;\n\n\tpredictor += ((code & 0x8) ? (code - 0x10) : code) * state.delta;\n\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.delta = (adaptationTable[code] * state.delta) >> 8;\n\tif (state.delta < 16)\n\t\tstate.delta = 16;\n\treturn code;\n}\n\n// Decode one block of MS ADPCM data.\nint MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Calculate the number of bytes needed for decoded data.\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\n\t// Initialize block predictor.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\n\t// Initialize delta.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\t// Initialize first two samples.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\n\t/*\n\t\tThe first two samples have already been 'decoded' in\n\t\tthe block header.\n\t*/\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\t\tbool ok;\n\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0], &ok);\n\t\tif (!ok) return 0;\n\t\t*decoded++ = newSample;\n\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1], &ok);\n\t\tif (!ok) return 0;\n\t\t*decoded++ = newSample;\n\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn outputLength;\n}\n\nint MSADPCM::encodeBlock(const int16_t *decoded, uint8_t *encoded)\n{\n\tchoosePredictorForBlock(decoded);\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Encode predictor.\n\tfor (int c=0; c<channelCount; c++)\n\t\t*encoded++ = m_state[c].predictorIndex;\n\n\t// Encode delta.\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].delta & 0xff;\n\t\t*encoded++ = m_state[c].delta >> 8;\n\t}\n\n\t// Enccode first two samples.\n\tfor (int c=0; c<channelCount; c++)\n\t\tm_state[c].sample2 = *decoded++;\n\n\tfor (int c=0; c<channelCount; c++)\n\t\tm_state[c].sample1 = *decoded++;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].sample1 & 0xff;\n\t\t*encoded++ = m_state[c].sample1 >> 8;\n\t}\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\t*encoded++ = m_state[c].sample2 & 0xff;\n\t\t*encoded++ = m_state[c].sample2 >> 8;\n\t}\n\n\tms_adpcm_state *state[2] = { &m_state[0], &m_state[channelCount - 1] };\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code1 = encodeSample(*state[0], *decoded++, coefficient[0]);\n\t\tuint8_t code2 = encodeSample(*state[1], *decoded++, coefficient[1]);\n\n\t\t*encoded++ = (code1 << 4) | code2;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn m_bytesPerPacket;\n}\n\nvoid MSADPCM::choosePredictorForBlock(const int16_t *decoded)\n{\n\tconst int kPredictorSampleLength = 3;\n\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tint bestPredictorIndex = 0;\n\t\tint bestPredictorError = std::numeric_limits<int>::max();\n\t\tfor (int k=0; k<m_numCoefficients; k++)\n\t\t{\n\t\t\tint a0 = m_coefficients[k][0];\n\t\t\tint a1 = m_coefficients[k][1];\n\n\t\t\tint currentPredictorError = 0;\n\t\t\tfor (int i=2; i<2+kPredictorSampleLength; i++)\n\t\t\t{\n\t\t\t\tint error = std::abs(decoded[i*channelCount + c] -\n\t\t\t\t\t((a0 * decoded[(i-1)*channelCount + c] +\n\t\t\t\t\ta1 * decoded[(i-2)*channelCount + c]) >> 8));\n\t\t\t\tcurrentPredictorError += error;\n\t\t\t}\n\n\t\t\tcurrentPredictorError /= 4 * kPredictorSampleLength;\n\n\t\t\tif (currentPredictorError < bestPredictorError)\n\t\t\t{\n\t\t\t\tbestPredictorError = currentPredictorError;\n\t\t\t\tbestPredictorIndex = k;\n\t\t\t}\n\n\t\t\tif (!currentPredictorError)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (bestPredictorError < 16)\n\t\t\tbestPredictorError = 16;\n\n\t\tm_state[c].predictorIndex = bestPredictorIndex;\n\t\tm_state[c].delta = bestPredictorError;\n\t}\n}\n\nvoid MSADPCM::describe()\n{\n\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n}\n\nMSADPCM::MSADPCM(Mode mode, Track *track, File *fh, bool canSeek) :\n\tBlockCodec(mode, track, fh, canSeek),\n\tm_numCoefficients(0),\n\tm_state(NULL)\n{\n\tm_state = new ms_adpcm_state[m_track->f.channelCount];\n}\n\nMSADPCM::~MSADPCM()\n{\n\tdelete [] m_state;\n}\n\nbool MSADPCM::initializeCoefficients()\n{\n\tAUpvlist pv = m_track->f.compressionParams;\n\n\tlong l;\n\tif (_af_pv_getlong(pv, _AF_MS_ADPCM_NUM_COEFFICIENTS, &l))\n\t{\n\t\tm_numCoefficients = l;\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"number of coefficients not set\");\n\t\treturn false;\n\t}\n\n\tvoid *v;\n\tif (_af_pv_getptr(pv, _AF_MS_ADPCM_COEFFICIENTS, &v))\n\t{\n\t\tmemcpy(m_coefficients, v, m_numCoefficients * 2 * sizeof (int16_t));\n\t}\n\telse\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"coefficient array not set\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nMSADPCM *MSADPCM::createDecompress(Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\tassert(fh->tell() == track->fpos_first_frame);\n\n\tMSADPCM *msadpcm = new MSADPCM(Decompress, track, fh, canSeek);\n\n\tif (!msadpcm->initializeCoefficients())\n\t{\n\t\tdelete msadpcm;\n\t\treturn NULL;\n\t}\n\n\t*chunkFrames = msadpcm->m_framesPerPacket;\n\n\treturn msadpcm;\n}\n\nMSADPCM *MSADPCM::createCompress(Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\tassert(fh->tell() == track->fpos_first_frame);\n\n\tMSADPCM *msadpcm = new MSADPCM(Compress, track, fh, canSeek);\n\n\tif (!msadpcm->initializeCoefficients())\n\t{\n\t\tdelete msadpcm;\n\t\treturn NULL;\n\t}\n\n\t*chunkFrames = msadpcm->m_framesPerPacket;\n\n\treturn msadpcm;\n}\n\nbool _af_ms_adpcm_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 16-bit signed integer format\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires native byte order\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nFileModule *_af_ms_adpcm_init_decompress (Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\treturn MSADPCM::createDecompress(track, fh, canSeek, headerless, chunkFrames);\n}\n\nFileModule *_af_ms_adpcm_init_compress (Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\treturn MSADPCM::createCompress(track, fh, canSeek, headerless, chunkFrames);\n}\n"], "filenames": ["libaudiofile/modules/BlockCodec.cpp", "libaudiofile/modules/MSADPCM.cpp"], "buggy_code_start_loc": [55, 103], "buggy_code_end_loc": [57, 222], "fixing_code_start_loc": [55, 104], "fixing_code_end_loc": [58, 261], "type": "CWE-190", "message": "Integer overflow in modules/MSADPCM.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.", "other": {"cve": {"id": "CVE-2017-6839", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-20T16:59:03.030", "lastModified": "2017-11-04T01:29:49.773", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in modules/MSADPCM.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file."}, {"lang": "es", "value": "Desbordamiento de entero en modules/MSADPCM.cpp en Audio File Library (tambi\u00e9n conocido como audiofile) 0.3.6 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "3C7E74B2-432B-4CCD-873F-AA7E012D8C7F"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3814", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2017/03/13/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://blogs.gentoo.org/ago/2017/02/20/audiofile-multiple-ubsan-crashes/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/antlarr/audiofile/commit/beacc44eb8cdf6d58717ec1a5103c5141f1b37f9", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mpruett/audiofile/issues/41", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/antlarr/audiofile/commit/beacc44eb8cdf6d58717ec1a5103c5141f1b37f9"}}