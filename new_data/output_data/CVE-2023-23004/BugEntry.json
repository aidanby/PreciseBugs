{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * (C) COPYRIGHT 2016 ARM Limited. All rights reserved.\n * Author: Liviu Dudau <Liviu.Dudau@arm.com>\n *\n * ARM Mali DP plane manipulation routines.\n */\n\n#include <linux/iommu.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_cma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_cma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_print.h>\n\n#include \"malidp_hw.h\"\n#include \"malidp_drv.h\"\n\n/* Layer specific register offsets */\n#define MALIDP_LAYER_FORMAT\t\t0x000\n#define   LAYER_FORMAT_MASK\t\t0x3f\n#define MALIDP_LAYER_CONTROL\t\t0x004\n#define   LAYER_ENABLE\t\t\t(1 << 0)\n#define   LAYER_FLOWCFG_MASK\t\t7\n#define   LAYER_FLOWCFG(x)\t\t(((x) & LAYER_FLOWCFG_MASK) << 1)\n#define     LAYER_FLOWCFG_SCALE_SE\t3\n#define   LAYER_ROT_OFFSET\t\t8\n#define   LAYER_H_FLIP\t\t\t(1 << 10)\n#define   LAYER_V_FLIP\t\t\t(1 << 11)\n#define   LAYER_ROT_MASK\t\t(0xf << 8)\n#define   LAYER_COMP_MASK\t\t(0x3 << 12)\n#define   LAYER_COMP_PIXEL\t\t(0x3 << 12)\n#define   LAYER_COMP_PLANE\t\t(0x2 << 12)\n#define   LAYER_PMUL_ENABLE\t\t(0x1 << 14)\n#define   LAYER_ALPHA_OFFSET\t\t(16)\n#define   LAYER_ALPHA_MASK\t\t(0xff)\n#define   LAYER_ALPHA(x)\t\t(((x) & LAYER_ALPHA_MASK) << LAYER_ALPHA_OFFSET)\n#define MALIDP_LAYER_COMPOSE\t\t0x008\n#define MALIDP_LAYER_SIZE\t\t0x00c\n#define   LAYER_H_VAL(x)\t\t(((x) & 0x1fff) << 0)\n#define   LAYER_V_VAL(x)\t\t(((x) & 0x1fff) << 16)\n#define MALIDP_LAYER_COMP_SIZE\t\t0x010\n#define MALIDP_LAYER_OFFSET\t\t0x014\n#define MALIDP550_LS_ENABLE\t\t0x01c\n#define MALIDP550_LS_R1_IN_SIZE\t\t0x020\n\n#define MODIFIERS_COUNT_MAX\t\t15\n\n/*\n * This 4-entry look-up-table is used to determine the full 8-bit alpha value\n * for formats with 1- or 2-bit alpha channels.\n * We set it to give 100%/0% opacity for 1-bit formats and 100%/66%/33%/0%\n * opacity for 2-bit formats.\n */\n#define MALIDP_ALPHA_LUT 0xffaa5500\n\n/* page sizes the MMU prefetcher can support */\n#define MALIDP_MMU_PREFETCH_PARTIAL_PGSIZES\t(SZ_4K | SZ_64K)\n#define MALIDP_MMU_PREFETCH_FULL_PGSIZES\t(SZ_1M | SZ_2M)\n\n/* readahead for partial-frame prefetch */\n#define MALIDP_MMU_PREFETCH_READAHEAD\t\t8\n\nstatic void malidp_de_plane_destroy(struct drm_plane *plane)\n{\n\tstruct malidp_plane *mp = to_malidp_plane(plane);\n\n\tdrm_plane_cleanup(plane);\n\tkfree(mp);\n}\n\n/*\n * Replicate what the default ->reset hook does: free the state pointer and\n * allocate a new empty object. We just need enough space to store\n * a malidp_plane_state instead of a drm_plane_state.\n */\nstatic void malidp_plane_reset(struct drm_plane *plane)\n{\n\tstruct malidp_plane_state *state = to_malidp_plane_state(plane->state);\n\n\tif (state)\n\t\t__drm_atomic_helper_plane_destroy_state(&state->base);\n\tkfree(state);\n\tplane->state = NULL;\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_plane_reset(plane, &state->base);\n}\n\nstatic struct\ndrm_plane_state *malidp_duplicate_plane_state(struct drm_plane *plane)\n{\n\tstruct malidp_plane_state *state, *m_state;\n\n\tif (!plane->state)\n\t\treturn NULL;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tm_state = to_malidp_plane_state(plane->state);\n\t__drm_atomic_helper_plane_duplicate_state(plane, &state->base);\n\tstate->rotmem_size = m_state->rotmem_size;\n\tstate->format = m_state->format;\n\tstate->n_planes = m_state->n_planes;\n\n\tstate->mmu_prefetch_mode = m_state->mmu_prefetch_mode;\n\tstate->mmu_prefetch_pgsize = m_state->mmu_prefetch_pgsize;\n\n\treturn &state->base;\n}\n\nstatic void malidp_destroy_plane_state(struct drm_plane *plane,\n\t\t\t\t       struct drm_plane_state *state)\n{\n\tstruct malidp_plane_state *m_state = to_malidp_plane_state(state);\n\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(m_state);\n}\n\nstatic const char * const prefetch_mode_names[] = {\n\t[MALIDP_PREFETCH_MODE_NONE] = \"MMU_PREFETCH_NONE\",\n\t[MALIDP_PREFETCH_MODE_PARTIAL] = \"MMU_PREFETCH_PARTIAL\",\n\t[MALIDP_PREFETCH_MODE_FULL] = \"MMU_PREFETCH_FULL\",\n};\n\nstatic void malidp_plane_atomic_print_state(struct drm_printer *p,\n\t\t\t\t\t    const struct drm_plane_state *state)\n{\n\tstruct malidp_plane_state *ms = to_malidp_plane_state(state);\n\n\tdrm_printf(p, \"\\trotmem_size=%u\\n\", ms->rotmem_size);\n\tdrm_printf(p, \"\\tformat_id=%u\\n\", ms->format);\n\tdrm_printf(p, \"\\tn_planes=%u\\n\", ms->n_planes);\n\tdrm_printf(p, \"\\tmmu_prefetch_mode=%s\\n\",\n\t\t   prefetch_mode_names[ms->mmu_prefetch_mode]);\n\tdrm_printf(p, \"\\tmmu_prefetch_pgsize=%d\\n\", ms->mmu_prefetch_pgsize);\n}\n\nbool malidp_format_mod_supported(struct drm_device *drm,\n\t\t\t\t u32 format, u64 modifier)\n{\n\tconst struct drm_format_info *info;\n\tconst u64 *modifiers;\n\tstruct malidp_drm *malidp = drm->dev_private;\n\tconst struct malidp_hw_regmap *map = &malidp->dev->hw->map;\n\n\tif (WARN_ON(modifier == DRM_FORMAT_MOD_INVALID))\n\t\treturn false;\n\n\t/* Some pixel formats are supported without any modifier */\n\tif (modifier == DRM_FORMAT_MOD_LINEAR) {\n\t\t/*\n\t\t * However these pixel formats need to be supported with\n\t\t * modifiers only\n\t\t */\n\t\treturn !malidp_hw_format_is_afbc_only(format);\n\t}\n\n\tif (!fourcc_mod_is_vendor(modifier, ARM)) {\n\t\tDRM_ERROR(\"Unknown modifier (not Arm)\\n\");\n\t\treturn false;\n\t}\n\n\tif (modifier &\n\t    ~DRM_FORMAT_MOD_ARM_AFBC(AFBC_MOD_VALID_BITS)) {\n\t\tDRM_DEBUG_KMS(\"Unsupported modifiers\\n\");\n\t\treturn false;\n\t}\n\n\tmodifiers = malidp_format_modifiers;\n\n\t/* SPLIT buffers must use SPARSE layout */\n\tif (WARN_ON_ONCE((modifier & AFBC_SPLIT) && !(modifier & AFBC_SPARSE)))\n\t\treturn false;\n\n\t/* CBR only applies to YUV formats, where YTR should be always 0 */\n\tif (WARN_ON_ONCE((modifier & AFBC_CBR) && (modifier & AFBC_YTR)))\n\t\treturn false;\n\n\twhile (*modifiers != DRM_FORMAT_MOD_INVALID) {\n\t\tif (*modifiers == modifier)\n\t\t\tbreak;\n\n\t\tmodifiers++;\n\t}\n\n\t/* return false, if the modifier was not found */\n\tif (*modifiers == DRM_FORMAT_MOD_INVALID) {\n\t\tDRM_DEBUG_KMS(\"Unsupported modifier\\n\");\n\t\treturn false;\n\t}\n\n\tinfo = drm_format_info(format);\n\n\tif (info->num_planes != 1) {\n\t\tDRM_DEBUG_KMS(\"AFBC buffers expect one plane\\n\");\n\t\treturn false;\n\t}\n\n\tif (malidp_hw_format_is_linear_only(format) == true) {\n\t\tDRM_DEBUG_KMS(\"Given format (0x%x) is supported is linear mode only\\n\",\n\t\t\t      format);\n\t\treturn false;\n\t}\n\n\t/*\n\t * RGB formats need to provide YTR modifier and YUV formats should not\n\t * provide YTR modifier.\n\t */\n\tif (!(info->is_yuv) != !!(modifier & AFBC_FORMAT_MOD_YTR)) {\n\t\tDRM_DEBUG_KMS(\"AFBC_FORMAT_MOD_YTR is %s for %s formats\\n\",\n\t\t\t      info->is_yuv ? \"disallowed\" : \"mandatory\",\n\t\t\t      info->is_yuv ? \"YUV\" : \"RGB\");\n\t\treturn false;\n\t}\n\n\tif (modifier & AFBC_SPLIT) {\n\t\tif (!info->is_yuv) {\n\t\t\tif (info->cpp[0] <= 2) {\n\t\t\t\tDRM_DEBUG_KMS(\"RGB formats <= 16bpp are not supported with SPLIT\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif ((info->hsub != 1) || (info->vsub != 1)) {\n\t\t\tif (!(format == DRM_FORMAT_YUV420_10BIT &&\n\t\t\t      (map->features & MALIDP_DEVICE_AFBC_YUV_420_10_SUPPORT_SPLIT))) {\n\t\t\t\tDRM_DEBUG_KMS(\"Formats which are sub-sampled should never be split\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (modifier & AFBC_CBR) {\n\t\tif ((info->hsub == 1) || (info->vsub == 1)) {\n\t\t\tDRM_DEBUG_KMS(\"Formats which are not sub-sampled should not have CBR set\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool malidp_format_mod_supported_per_plane(struct drm_plane *plane,\n\t\t\t\t\t\t  u32 format, u64 modifier)\n{\n\treturn malidp_format_mod_supported(plane->dev, format, modifier);\n}\n\nstatic const struct drm_plane_funcs malidp_de_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = malidp_de_plane_destroy,\n\t.reset = malidp_plane_reset,\n\t.atomic_duplicate_state = malidp_duplicate_plane_state,\n\t.atomic_destroy_state = malidp_destroy_plane_state,\n\t.atomic_print_state = malidp_plane_atomic_print_state,\n\t.format_mod_supported = malidp_format_mod_supported_per_plane,\n};\n\nstatic int malidp_se_check_scaling(struct malidp_plane *mp,\n\t\t\t\t   struct drm_plane_state *state)\n{\n\tstruct drm_crtc_state *crtc_state =\n\t\tdrm_atomic_get_existing_crtc_state(state->state, state->crtc);\n\tstruct malidp_crtc_state *mc;\n\tu32 src_w, src_h;\n\tint ret;\n\n\tif (!crtc_state)\n\t\treturn -EINVAL;\n\n\tmc = to_malidp_crtc_state(crtc_state);\n\n\tret = drm_atomic_helper_check_plane_state(state, crtc_state,\n\t\t\t\t\t\t  0, INT_MAX, true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state->rotation & MALIDP_ROTATED_MASK) {\n\t\tsrc_w = state->src_h >> 16;\n\t\tsrc_h = state->src_w >> 16;\n\t} else {\n\t\tsrc_w = state->src_w >> 16;\n\t\tsrc_h = state->src_h >> 16;\n\t}\n\n\tif ((state->crtc_w == src_w) && (state->crtc_h == src_h)) {\n\t\t/* Scaling not necessary for this plane. */\n\t\tmc->scaled_planes_mask &= ~(mp->layer->id);\n\t\treturn 0;\n\t}\n\n\tif (mp->layer->id & (DE_SMART | DE_GRAPHICS2))\n\t\treturn -EINVAL;\n\n\tmc->scaled_planes_mask |= mp->layer->id;\n\t/* Defer scaling requirements calculation to the crtc check. */\n\treturn 0;\n}\n\nstatic u32 malidp_get_pgsize_bitmap(struct malidp_plane *mp)\n{\n\tstruct iommu_domain *mmu_dom;\n\n\tmmu_dom = iommu_get_domain_for_dev(mp->base.dev->dev);\n\tif (mmu_dom)\n\t\treturn mmu_dom->pgsize_bitmap;\n\n\treturn 0;\n}\n\n/*\n * Check if the framebuffer is entirely made up of pages at least pgsize in\n * size. Only a heuristic: assumes that each scatterlist entry has been aligned\n * to the largest page size smaller than its length and that the MMU maps to\n * the largest page size possible.\n */\nstatic bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\n\t\tif (!sgt)\n\t\t\treturn false;\n\n\t\tsgl = sgt->sgl;\n\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\n\treturn true;\n}\n\n/*\n * Check if it is possible to enable partial-frame MMU prefetch given the\n * current format, AFBC state and rotation.\n */\nstatic bool malidp_partial_prefetch_supported(u32 format, u64 modifier,\n\t\t\t\t\t      unsigned int rotation)\n{\n\tbool afbc, sparse;\n\n\t/* rotation and horizontal flip not supported for partial prefetch */\n\tif (rotation & (DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_180 |\n\t\t\tDRM_MODE_ROTATE_270 | DRM_MODE_REFLECT_X))\n\t\treturn false;\n\n\tafbc = modifier & DRM_FORMAT_MOD_ARM_AFBC(0);\n\tsparse = modifier & AFBC_FORMAT_MOD_SPARSE;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_RGBA1010102:\n\tcase DRM_FORMAT_BGRA1010102:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_RGBA8888:\n\tcase DRM_FORMAT_BGRA8888:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_RGBX8888:\n\tcase DRM_FORMAT_BGRX8888:\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_RGBA5551:\n\tcase DRM_FORMAT_RGB565:\n\t\t/* always supported */\n\t\treturn true;\n\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_ABGR1555:\n\tcase DRM_FORMAT_BGR565:\n\t\t/* supported, but if AFBC then must be sparse mode */\n\t\treturn (!afbc) || (afbc && sparse);\n\n\tcase DRM_FORMAT_BGR888:\n\t\t/* supported, but not for AFBC */\n\t\treturn !afbc;\n\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_YUV420:\n\t\t/* not supported */\n\t\treturn false;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/*\n * Select the preferred MMU prefetch mode. Full-frame prefetch is preferred as\n * long as the framebuffer is all large pages. Otherwise partial-frame prefetch\n * is selected as long as it is supported for the current format. The selected\n * page size for prefetch is returned in pgsize_bitmap.\n */\nstatic enum mmu_prefetch_mode malidp_mmu_prefetch_select_mode\n\t\t(struct malidp_plane_state *ms,\tu32 *pgsize_bitmap)\n{\n\tu32 pgsizes;\n\n\t/* get the full-frame prefetch page size(s) supported by the MMU */\n\tpgsizes = *pgsize_bitmap & MALIDP_MMU_PREFETCH_FULL_PGSIZES;\n\n\twhile (pgsizes) {\n\t\tu32 largest_pgsize = 1 << __fls(pgsizes);\n\n\t\tif (malidp_check_pages_threshold(ms, largest_pgsize)) {\n\t\t\t*pgsize_bitmap = largest_pgsize;\n\t\t\treturn MALIDP_PREFETCH_MODE_FULL;\n\t\t}\n\n\t\tpgsizes -= largest_pgsize;\n\t}\n\n\t/* get the partial-frame prefetch page size(s) supported by the MMU */\n\tpgsizes = *pgsize_bitmap & MALIDP_MMU_PREFETCH_PARTIAL_PGSIZES;\n\n\tif (malidp_partial_prefetch_supported(ms->base.fb->format->format,\n\t\t\t\t\t      ms->base.fb->modifier,\n\t\t\t\t\t      ms->base.rotation)) {\n\t\t/* partial prefetch using the smallest page size */\n\t\t*pgsize_bitmap = 1 << __ffs(pgsizes);\n\t\treturn MALIDP_PREFETCH_MODE_PARTIAL;\n\t}\n\t*pgsize_bitmap = 0;\n\treturn MALIDP_PREFETCH_MODE_NONE;\n}\n\nstatic u32 malidp_calc_mmu_control_value(enum mmu_prefetch_mode mode,\n\t\t\t\t\t u8 readahead, u8 n_planes, u32 pgsize)\n{\n\tu32 mmu_ctrl = 0;\n\n\tif (mode != MALIDP_PREFETCH_MODE_NONE) {\n\t\tmmu_ctrl |= MALIDP_MMU_CTRL_EN;\n\n\t\tif (mode == MALIDP_PREFETCH_MODE_PARTIAL) {\n\t\t\tmmu_ctrl |= MALIDP_MMU_CTRL_MODE;\n\t\t\tmmu_ctrl |= MALIDP_MMU_CTRL_PP_NUM_REQ(readahead);\n\t\t}\n\n\t\tif (pgsize == SZ_64K || pgsize == SZ_2M) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < n_planes; i++)\n\t\t\t\tmmu_ctrl |= MALIDP_MMU_CTRL_PX_PS(i);\n\t\t}\n\t}\n\n\treturn mmu_ctrl;\n}\n\nstatic void malidp_de_prefetch_settings(struct malidp_plane *mp,\n\t\t\t\t\tstruct malidp_plane_state *ms)\n{\n\tif (!mp->layer->mmu_ctrl_offset)\n\t\treturn;\n\n\t/* get the page sizes supported by the MMU */\n\tms->mmu_prefetch_pgsize = malidp_get_pgsize_bitmap(mp);\n\tms->mmu_prefetch_mode  =\n\t\tmalidp_mmu_prefetch_select_mode(ms, &ms->mmu_prefetch_pgsize);\n}\n\nstatic int malidp_de_plane_check(struct drm_plane *plane,\n\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct malidp_plane *mp = to_malidp_plane(plane);\n\tstruct malidp_plane_state *ms = to_malidp_plane_state(new_plane_state);\n\tbool rotated = new_plane_state->rotation & MALIDP_ROTATED_MASK;\n\tstruct drm_framebuffer *fb;\n\tu16 pixel_alpha = new_plane_state->pixel_blend_mode;\n\tint i, ret;\n\tunsigned int block_w, block_h;\n\n\tif (!new_plane_state->crtc || WARN_ON(!new_plane_state->fb))\n\t\treturn 0;\n\n\tfb = new_plane_state->fb;\n\n\tms->format = malidp_hw_get_format_id(&mp->hwdev->hw->map,\n\t\t\t\t\t     mp->layer->id, fb->format->format,\n\t\t\t\t\t     !!fb->modifier);\n\tif (ms->format == MALIDP_INVALID_FORMAT_ID)\n\t\treturn -EINVAL;\n\n\tms->n_planes = fb->format->num_planes;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tu8 alignment = malidp_hw_get_pitch_align(mp->hwdev, rotated);\n\n\t\tif (((fb->pitches[i] * drm_format_info_block_height(fb->format, i))\n\t\t\t\t& (alignment - 1)) && !(fb->modifier)) {\n\t\t\tDRM_DEBUG_KMS(\"Invalid pitch %u for plane %d\\n\",\n\t\t\t\t      fb->pitches[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tblock_w = drm_format_info_block_width(fb->format, 0);\n\tblock_h = drm_format_info_block_height(fb->format, 0);\n\tif (fb->width % block_w || fb->height % block_h) {\n\t\tDRM_DEBUG_KMS(\"Buffer width/height needs to be a multiple of tile sizes\");\n\t\treturn -EINVAL;\n\t}\n\tif ((new_plane_state->src_x >> 16) % block_w || (new_plane_state->src_y >> 16) % block_h) {\n\t\tDRM_DEBUG_KMS(\"Plane src_x/src_y needs to be a multiple of tile sizes\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((new_plane_state->crtc_w > mp->hwdev->max_line_size) ||\n\t    (new_plane_state->crtc_h > mp->hwdev->max_line_size) ||\n\t    (new_plane_state->crtc_w < mp->hwdev->min_line_size) ||\n\t    (new_plane_state->crtc_h < mp->hwdev->min_line_size))\n\t\treturn -EINVAL;\n\n\t/*\n\t * DP550/650 video layers can accept 3 plane formats only if\n\t * fb->pitches[1] == fb->pitches[2] since they don't have a\n\t * third plane stride register.\n\t */\n\tif (ms->n_planes == 3 &&\n\t    !(mp->hwdev->hw->features & MALIDP_DEVICE_LV_HAS_3_STRIDES) &&\n\t    (new_plane_state->fb->pitches[1] != new_plane_state->fb->pitches[2]))\n\t\treturn -EINVAL;\n\n\tret = malidp_se_check_scaling(mp, new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* validate the rotation constraints for each layer */\n\tif (new_plane_state->rotation != DRM_MODE_ROTATE_0) {\n\t\tif (mp->layer->rot == ROTATE_NONE)\n\t\t\treturn -EINVAL;\n\t\tif ((mp->layer->rot == ROTATE_COMPRESSED) && !(fb->modifier))\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * packed RGB888 / BGR888 can't be rotated or flipped\n\t\t * unless they are stored in a compressed way\n\t\t */\n\t\tif ((fb->format->format == DRM_FORMAT_RGB888 ||\n\t\t     fb->format->format == DRM_FORMAT_BGR888) && !(fb->modifier))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* SMART layer does not support AFBC */\n\tif (mp->layer->id == DE_SMART && fb->modifier) {\n\t\tDRM_ERROR(\"AFBC framebuffer not supported in SMART layer\");\n\t\treturn -EINVAL;\n\t}\n\n\tms->rotmem_size = 0;\n\tif (new_plane_state->rotation & MALIDP_ROTATED_MASK) {\n\t\tint val;\n\n\t\tval = mp->hwdev->hw->rotmem_required(mp->hwdev, new_plane_state->crtc_w,\n\t\t\t\t\t\t     new_plane_state->crtc_h,\n\t\t\t\t\t\t     fb->format->format,\n\t\t\t\t\t\t     !!(fb->modifier));\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tms->rotmem_size = val;\n\t}\n\n\t/* HW can't support plane + pixel blending */\n\tif ((new_plane_state->alpha != DRM_BLEND_ALPHA_OPAQUE) &&\n\t    (pixel_alpha != DRM_MODE_BLEND_PIXEL_NONE) &&\n\t    fb->format->has_alpha)\n\t\treturn -EINVAL;\n\n\tmalidp_de_prefetch_settings(mp, ms);\n\n\treturn 0;\n}\n\nstatic void malidp_de_set_plane_pitches(struct malidp_plane *mp,\n\t\t\t\t\tint num_planes, unsigned int pitches[3])\n{\n\tint i;\n\tint num_strides = num_planes;\n\n\tif (!mp->layer->stride_offset)\n\t\treturn;\n\n\tif (num_planes == 3)\n\t\tnum_strides = (mp->hwdev->hw->features &\n\t\t\t       MALIDP_DEVICE_LV_HAS_3_STRIDES) ? 3 : 2;\n\n\t/*\n\t * The drm convention for pitch is that it needs to cover width * cpp,\n\t * but our hardware wants the pitch/stride to cover all rows included\n\t * in a tile.\n\t */\n\tfor (i = 0; i < num_strides; ++i) {\n\t\tunsigned int block_h = drm_format_info_block_height(mp->base.state->fb->format, i);\n\n\t\tmalidp_hw_write(mp->hwdev, pitches[i] * block_h,\n\t\t\t\tmp->layer->base +\n\t\t\t\tmp->layer->stride_offset + i * 4);\n\t}\n}\n\nstatic const s16\nmalidp_yuv2rgb_coeffs[][DRM_COLOR_RANGE_MAX][MALIDP_COLORADJ_NUM_COEFFS] = {\n\t[DRM_COLOR_YCBCR_BT601][DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t1192,    0, 1634,\n\t\t1192, -401, -832,\n\t\t1192, 2066,    0,\n\t\t  64,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT601][DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t1024,    0, 1436,\n\t\t1024, -352, -731,\n\t\t1024, 1815,    0,\n\t\t   0,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT709][DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t1192,    0, 1836,\n\t\t1192, -218, -546,\n\t\t1192, 2163,    0,\n\t\t  64,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT709][DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t1024,    0, 1613,\n\t\t1024, -192, -479,\n\t\t1024, 1900,    0,\n\t\t   0,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT2020][DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t1024,    0, 1476,\n\t\t1024, -165, -572,\n\t\t1024, 1884,    0,\n\t\t   0,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT2020][DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t1024,    0, 1510,\n\t\t1024, -168, -585,\n\t\t1024, 1927,    0,\n\t\t   0,  512,  512\n\t}\n};\n\nstatic void malidp_de_set_color_encoding(struct malidp_plane *plane,\n\t\t\t\t\t enum drm_color_encoding enc,\n\t\t\t\t\t enum drm_color_range range)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MALIDP_COLORADJ_NUM_COEFFS; i++) {\n\t\t/* coefficients are signed, two's complement values */\n\t\tmalidp_hw_write(plane->hwdev, malidp_yuv2rgb_coeffs[enc][range][i],\n\t\t\t\tplane->layer->base + plane->layer->yuv2rgb_offset +\n\t\t\t\ti * 4);\n\t}\n}\n\nstatic void malidp_de_set_mmu_control(struct malidp_plane *mp,\n\t\t\t\t      struct malidp_plane_state *ms)\n{\n\tu32 mmu_ctrl;\n\n\t/* check hardware supports MMU prefetch */\n\tif (!mp->layer->mmu_ctrl_offset)\n\t\treturn;\n\n\tmmu_ctrl = malidp_calc_mmu_control_value(ms->mmu_prefetch_mode,\n\t\t\t\t\t\t MALIDP_MMU_PREFETCH_READAHEAD,\n\t\t\t\t\t\t ms->n_planes,\n\t\t\t\t\t\t ms->mmu_prefetch_pgsize);\n\n\tmalidp_hw_write(mp->hwdev, mmu_ctrl,\n\t\t\tmp->layer->base + mp->layer->mmu_ctrl_offset);\n}\n\nstatic void malidp_set_plane_base_addr(struct drm_framebuffer *fb,\n\t\t\t\t       struct malidp_plane *mp,\n\t\t\t\t       int plane_index)\n{\n\tdma_addr_t paddr;\n\tu16 ptr;\n\tstruct drm_plane *plane = &mp->base;\n\tbool afbc = fb->modifier ? true : false;\n\n\tptr = mp->layer->ptr + (plane_index << 4);\n\n\t/*\n\t * drm_fb_cma_get_gem_addr() alters the physical base address of the\n\t * framebuffer as per the plane's src_x, src_y co-ordinates (ie to\n\t * take care of source cropping).\n\t * For AFBC, this is not needed as the cropping is handled by _AD_CROP_H\n\t * and _AD_CROP_V registers.\n\t */\n\tif (!afbc) {\n\t\tpaddr = drm_fb_cma_get_gem_addr(fb, plane->state,\n\t\t\t\t\t\tplane_index);\n\t} else {\n\t\tstruct drm_gem_cma_object *obj;\n\n\t\tobj = drm_fb_cma_get_gem_obj(fb, plane_index);\n\n\t\tif (WARN_ON(!obj))\n\t\t\treturn;\n\t\tpaddr = obj->paddr;\n\t}\n\n\tmalidp_hw_write(mp->hwdev, lower_32_bits(paddr), ptr);\n\tmalidp_hw_write(mp->hwdev, upper_32_bits(paddr), ptr + 4);\n}\n\nstatic void malidp_de_set_plane_afbc(struct drm_plane *plane)\n{\n\tstruct malidp_plane *mp;\n\tu32 src_w, src_h, val = 0, src_x, src_y;\n\tstruct drm_framebuffer *fb = plane->state->fb;\n\n\tmp = to_malidp_plane(plane);\n\n\t/* no afbc_decoder_offset means AFBC is not supported on this plane */\n\tif (!mp->layer->afbc_decoder_offset)\n\t\treturn;\n\n\tif (!fb->modifier) {\n\t\tmalidp_hw_write(mp->hwdev, 0, mp->layer->afbc_decoder_offset);\n\t\treturn;\n\t}\n\n\t/* convert src values from Q16 fixed point to integer */\n\tsrc_w = plane->state->src_w >> 16;\n\tsrc_h = plane->state->src_h >> 16;\n\tsrc_x = plane->state->src_x >> 16;\n\tsrc_y = plane->state->src_y >> 16;\n\n\tval = ((fb->width - (src_x + src_w)) << MALIDP_AD_CROP_RIGHT_OFFSET) |\n\t\t   src_x;\n\tmalidp_hw_write(mp->hwdev, val,\n\t\t\tmp->layer->afbc_decoder_offset + MALIDP_AD_CROP_H);\n\n\tval = ((fb->height - (src_y + src_h)) << MALIDP_AD_CROP_BOTTOM_OFFSET) |\n\t\t   src_y;\n\tmalidp_hw_write(mp->hwdev, val,\n\t\t\tmp->layer->afbc_decoder_offset + MALIDP_AD_CROP_V);\n\n\tval = MALIDP_AD_EN;\n\tif (fb->modifier & AFBC_FORMAT_MOD_SPLIT)\n\t\tval |= MALIDP_AD_BS;\n\tif (fb->modifier & AFBC_FORMAT_MOD_YTR)\n\t\tval |= MALIDP_AD_YTR;\n\n\tmalidp_hw_write(mp->hwdev, val, mp->layer->afbc_decoder_offset);\n}\n\nstatic void malidp_de_plane_update(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct malidp_plane *mp;\n\tstruct malidp_plane_state *ms = to_malidp_plane_state(plane->state);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tu16 pixel_alpha = new_state->pixel_blend_mode;\n\tu8 plane_alpha = new_state->alpha >> 8;\n\tu32 src_w, src_h, dest_w, dest_h, val;\n\tint i;\n\tstruct drm_framebuffer *fb = plane->state->fb;\n\n\tmp = to_malidp_plane(plane);\n\n\t/*\n\t * For AFBC framebuffer, use the framebuffer width and height for\n\t * configuring layer input size register.\n\t */\n\tif (fb->modifier) {\n\t\tsrc_w = fb->width;\n\t\tsrc_h = fb->height;\n\t} else {\n\t\t/* convert src values from Q16 fixed point to integer */\n\t\tsrc_w = new_state->src_w >> 16;\n\t\tsrc_h = new_state->src_h >> 16;\n\t}\n\n\tdest_w = new_state->crtc_w;\n\tdest_h = new_state->crtc_h;\n\n\tval = malidp_hw_read(mp->hwdev, mp->layer->base);\n\tval = (val & ~LAYER_FORMAT_MASK) | ms->format;\n\tmalidp_hw_write(mp->hwdev, val, mp->layer->base);\n\n\tfor (i = 0; i < ms->n_planes; i++)\n\t\tmalidp_set_plane_base_addr(fb, mp, i);\n\n\tmalidp_de_set_mmu_control(mp, ms);\n\n\tmalidp_de_set_plane_pitches(mp, ms->n_planes,\n\t\t\t\t    new_state->fb->pitches);\n\n\tif ((plane->state->color_encoding != old_state->color_encoding) ||\n\t    (plane->state->color_range != old_state->color_range))\n\t\tmalidp_de_set_color_encoding(mp, plane->state->color_encoding,\n\t\t\t\t\t     plane->state->color_range);\n\n\tmalidp_hw_write(mp->hwdev, LAYER_H_VAL(src_w) | LAYER_V_VAL(src_h),\n\t\t\tmp->layer->base + MALIDP_LAYER_SIZE);\n\n\tmalidp_hw_write(mp->hwdev, LAYER_H_VAL(dest_w) | LAYER_V_VAL(dest_h),\n\t\t\tmp->layer->base + MALIDP_LAYER_COMP_SIZE);\n\n\tmalidp_hw_write(mp->hwdev, LAYER_H_VAL(new_state->crtc_x) |\n\t\t\tLAYER_V_VAL(new_state->crtc_y),\n\t\t\tmp->layer->base + MALIDP_LAYER_OFFSET);\n\n\tif (mp->layer->id == DE_SMART) {\n\t\t/*\n\t\t * Enable the first rectangle in the SMART layer to be\n\t\t * able to use it as a drm plane.\n\t\t */\n\t\tmalidp_hw_write(mp->hwdev, 1,\n\t\t\t\tmp->layer->base + MALIDP550_LS_ENABLE);\n\t\tmalidp_hw_write(mp->hwdev,\n\t\t\t\tLAYER_H_VAL(src_w) | LAYER_V_VAL(src_h),\n\t\t\t\tmp->layer->base + MALIDP550_LS_R1_IN_SIZE);\n\t}\n\n\tmalidp_de_set_plane_afbc(plane);\n\n\t/* first clear the rotation bits */\n\tval = malidp_hw_read(mp->hwdev, mp->layer->base + MALIDP_LAYER_CONTROL);\n\tval &= ~LAYER_ROT_MASK;\n\n\t/* setup the rotation and axis flip bits */\n\tif (new_state->rotation & DRM_MODE_ROTATE_MASK)\n\t\tval |= ilog2(plane->state->rotation & DRM_MODE_ROTATE_MASK) <<\n\t\t       LAYER_ROT_OFFSET;\n\tif (new_state->rotation & DRM_MODE_REFLECT_X)\n\t\tval |= LAYER_H_FLIP;\n\tif (new_state->rotation & DRM_MODE_REFLECT_Y)\n\t\tval |= LAYER_V_FLIP;\n\n\tval &= ~(LAYER_COMP_MASK | LAYER_PMUL_ENABLE | LAYER_ALPHA(0xff));\n\n\tif (new_state->alpha != DRM_BLEND_ALPHA_OPAQUE) {\n\t\tval |= LAYER_COMP_PLANE;\n\t} else if (new_state->fb->format->has_alpha) {\n\t\t/* We only care about blend mode if the format has alpha */\n\t\tswitch (pixel_alpha) {\n\t\tcase DRM_MODE_BLEND_PREMULTI:\n\t\t\tval |= LAYER_COMP_PIXEL | LAYER_PMUL_ENABLE;\n\t\t\tbreak;\n\t\tcase DRM_MODE_BLEND_COVERAGE:\n\t\t\tval |= LAYER_COMP_PIXEL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tval |= LAYER_ALPHA(plane_alpha);\n\n\tval &= ~LAYER_FLOWCFG(LAYER_FLOWCFG_MASK);\n\tif (new_state->crtc) {\n\t\tstruct malidp_crtc_state *m =\n\t\t\tto_malidp_crtc_state(new_state->crtc->state);\n\n\t\tif (m->scaler_config.scale_enable &&\n\t\t    m->scaler_config.plane_src_id == mp->layer->id)\n\t\t\tval |= LAYER_FLOWCFG(LAYER_FLOWCFG_SCALE_SE);\n\t}\n\n\t/* set the 'enable layer' bit */\n\tval |= LAYER_ENABLE;\n\n\tmalidp_hw_write(mp->hwdev, val,\n\t\t\tmp->layer->base + MALIDP_LAYER_CONTROL);\n}\n\nstatic void malidp_de_plane_disable(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct malidp_plane *mp = to_malidp_plane(plane);\n\n\tmalidp_hw_clearbits(mp->hwdev,\n\t\t\t    LAYER_ENABLE | LAYER_FLOWCFG(LAYER_FLOWCFG_MASK),\n\t\t\t    mp->layer->base + MALIDP_LAYER_CONTROL);\n}\n\nstatic const struct drm_plane_helper_funcs malidp_de_plane_helper_funcs = {\n\t.atomic_check = malidp_de_plane_check,\n\t.atomic_update = malidp_de_plane_update,\n\t.atomic_disable = malidp_de_plane_disable,\n};\n\nstatic const uint64_t linear_only_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nint malidp_de_planes_init(struct drm_device *drm)\n{\n\tstruct malidp_drm *malidp = drm->dev_private;\n\tconst struct malidp_hw_regmap *map = &malidp->dev->hw->map;\n\tstruct malidp_plane *plane = NULL;\n\tenum drm_plane_type plane_type;\n\tunsigned long crtcs = BIT(drm->mode_config.num_crtc);\n\tunsigned long flags = DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_180 |\n\t\t\t      DRM_MODE_ROTATE_270 | DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y;\n\tunsigned int blend_caps = BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t  BIT(DRM_MODE_BLEND_PREMULTI)   |\n\t\t\t\t  BIT(DRM_MODE_BLEND_COVERAGE);\n\tu32 *formats;\n\tint ret, i = 0, j = 0, n;\n\tu64 supported_modifiers[MODIFIERS_COUNT_MAX];\n\tconst u64 *modifiers;\n\n\tmodifiers = malidp_format_modifiers;\n\n\tif (!(map->features & MALIDP_DEVICE_AFBC_SUPPORT_SPLIT)) {\n\t\t/*\n\t\t * Since our hardware does not support SPLIT, so build the list\n\t\t * of supported modifiers excluding SPLIT ones.\n\t\t */\n\t\twhile (*modifiers != DRM_FORMAT_MOD_INVALID) {\n\t\t\tif (!(*modifiers & AFBC_SPLIT))\n\t\t\t\tsupported_modifiers[j++] = *modifiers;\n\n\t\t\tmodifiers++;\n\t\t}\n\t\tsupported_modifiers[j++] = DRM_FORMAT_MOD_INVALID;\n\t\tmodifiers = supported_modifiers;\n\t}\n\n\tformats = kcalloc(map->n_pixel_formats, sizeof(*formats), GFP_KERNEL);\n\tif (!formats) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < map->n_layers; i++) {\n\t\tu8 id = map->layers[i].id;\n\n\t\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\t\tif (!plane) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* build the list of DRM supported formats based on the map */\n\t\tfor (n = 0, j = 0;  j < map->n_pixel_formats; j++) {\n\t\t\tif ((map->pixel_formats[j].layer & id) == id)\n\t\t\t\tformats[n++] = map->pixel_formats[j].format;\n\t\t}\n\n\t\tplane_type = (i == 0) ? DRM_PLANE_TYPE_PRIMARY :\n\t\t\t\t\tDRM_PLANE_TYPE_OVERLAY;\n\n\t\t/*\n\t\t * All the layers except smart layer supports AFBC modifiers.\n\t\t */\n\t\tret = drm_universal_plane_init(drm, &plane->base, crtcs,\n\t\t\t\t&malidp_de_plane_funcs, formats, n,\n\t\t\t\t(id == DE_SMART) ? linear_only_modifiers : modifiers,\n\t\t\t\tplane_type, NULL);\n\n\t\tif (ret < 0)\n\t\t\tgoto cleanup;\n\n\t\tdrm_plane_helper_add(&plane->base,\n\t\t\t\t     &malidp_de_plane_helper_funcs);\n\t\tplane->hwdev = malidp->dev;\n\t\tplane->layer = &map->layers[i];\n\n\t\tdrm_plane_create_alpha_property(&plane->base);\n\t\tdrm_plane_create_blend_mode_property(&plane->base, blend_caps);\n\n\t\tif (id == DE_SMART) {\n\t\t\t/* Skip the features which the SMART layer doesn't have. */\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_plane_create_rotation_property(&plane->base, DRM_MODE_ROTATE_0, flags);\n\t\tmalidp_hw_write(malidp->dev, MALIDP_ALPHA_LUT,\n\t\t\t\tplane->layer->base + MALIDP_LAYER_COMPOSE);\n\n\t\t/* Attach the YUV->RGB property only to video layers */\n\t\tif (id & (DE_VIDEO1 | DE_VIDEO2)) {\n\t\t\t/* default encoding for YUV->RGB is BT601 NARROW */\n\t\t\tenum drm_color_encoding enc = DRM_COLOR_YCBCR_BT601;\n\t\t\tenum drm_color_range range = DRM_COLOR_YCBCR_LIMITED_RANGE;\n\n\t\t\tret = drm_plane_create_color_properties(&plane->base,\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT601) | \\\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT709) | \\\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT2020),\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_LIMITED_RANGE) | \\\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_FULL_RANGE),\n\t\t\t\t\tenc, range);\n\t\t\tif (!ret)\n\t\t\t\t/* program the HW registers */\n\t\t\t\tmalidp_de_set_color_encoding(plane, enc, range);\n\t\t\telse\n\t\t\t\tDRM_WARN(\"Failed to create video layer %d color properties\\n\", id);\n\t\t}\n\t}\n\n\tkfree(formats);\n\n\treturn 0;\n\ncleanup:\n\tkfree(formats);\n\n\treturn ret;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * (C) COPYRIGHT 2016 ARM Limited. All rights reserved.\n * Author: Liviu Dudau <Liviu.Dudau@arm.com>\n *\n * ARM Mali DP plane manipulation routines.\n */\n\n#include <linux/iommu.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_cma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_cma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_print.h>\n\n#include \"malidp_hw.h\"\n#include \"malidp_drv.h\"\n\n/* Layer specific register offsets */\n#define MALIDP_LAYER_FORMAT\t\t0x000\n#define   LAYER_FORMAT_MASK\t\t0x3f\n#define MALIDP_LAYER_CONTROL\t\t0x004\n#define   LAYER_ENABLE\t\t\t(1 << 0)\n#define   LAYER_FLOWCFG_MASK\t\t7\n#define   LAYER_FLOWCFG(x)\t\t(((x) & LAYER_FLOWCFG_MASK) << 1)\n#define     LAYER_FLOWCFG_SCALE_SE\t3\n#define   LAYER_ROT_OFFSET\t\t8\n#define   LAYER_H_FLIP\t\t\t(1 << 10)\n#define   LAYER_V_FLIP\t\t\t(1 << 11)\n#define   LAYER_ROT_MASK\t\t(0xf << 8)\n#define   LAYER_COMP_MASK\t\t(0x3 << 12)\n#define   LAYER_COMP_PIXEL\t\t(0x3 << 12)\n#define   LAYER_COMP_PLANE\t\t(0x2 << 12)\n#define   LAYER_PMUL_ENABLE\t\t(0x1 << 14)\n#define   LAYER_ALPHA_OFFSET\t\t(16)\n#define   LAYER_ALPHA_MASK\t\t(0xff)\n#define   LAYER_ALPHA(x)\t\t(((x) & LAYER_ALPHA_MASK) << LAYER_ALPHA_OFFSET)\n#define MALIDP_LAYER_COMPOSE\t\t0x008\n#define MALIDP_LAYER_SIZE\t\t0x00c\n#define   LAYER_H_VAL(x)\t\t(((x) & 0x1fff) << 0)\n#define   LAYER_V_VAL(x)\t\t(((x) & 0x1fff) << 16)\n#define MALIDP_LAYER_COMP_SIZE\t\t0x010\n#define MALIDP_LAYER_OFFSET\t\t0x014\n#define MALIDP550_LS_ENABLE\t\t0x01c\n#define MALIDP550_LS_R1_IN_SIZE\t\t0x020\n\n#define MODIFIERS_COUNT_MAX\t\t15\n\n/*\n * This 4-entry look-up-table is used to determine the full 8-bit alpha value\n * for formats with 1- or 2-bit alpha channels.\n * We set it to give 100%/0% opacity for 1-bit formats and 100%/66%/33%/0%\n * opacity for 2-bit formats.\n */\n#define MALIDP_ALPHA_LUT 0xffaa5500\n\n/* page sizes the MMU prefetcher can support */\n#define MALIDP_MMU_PREFETCH_PARTIAL_PGSIZES\t(SZ_4K | SZ_64K)\n#define MALIDP_MMU_PREFETCH_FULL_PGSIZES\t(SZ_1M | SZ_2M)\n\n/* readahead for partial-frame prefetch */\n#define MALIDP_MMU_PREFETCH_READAHEAD\t\t8\n\nstatic void malidp_de_plane_destroy(struct drm_plane *plane)\n{\n\tstruct malidp_plane *mp = to_malidp_plane(plane);\n\n\tdrm_plane_cleanup(plane);\n\tkfree(mp);\n}\n\n/*\n * Replicate what the default ->reset hook does: free the state pointer and\n * allocate a new empty object. We just need enough space to store\n * a malidp_plane_state instead of a drm_plane_state.\n */\nstatic void malidp_plane_reset(struct drm_plane *plane)\n{\n\tstruct malidp_plane_state *state = to_malidp_plane_state(plane->state);\n\n\tif (state)\n\t\t__drm_atomic_helper_plane_destroy_state(&state->base);\n\tkfree(state);\n\tplane->state = NULL;\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_plane_reset(plane, &state->base);\n}\n\nstatic struct\ndrm_plane_state *malidp_duplicate_plane_state(struct drm_plane *plane)\n{\n\tstruct malidp_plane_state *state, *m_state;\n\n\tif (!plane->state)\n\t\treturn NULL;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tm_state = to_malidp_plane_state(plane->state);\n\t__drm_atomic_helper_plane_duplicate_state(plane, &state->base);\n\tstate->rotmem_size = m_state->rotmem_size;\n\tstate->format = m_state->format;\n\tstate->n_planes = m_state->n_planes;\n\n\tstate->mmu_prefetch_mode = m_state->mmu_prefetch_mode;\n\tstate->mmu_prefetch_pgsize = m_state->mmu_prefetch_pgsize;\n\n\treturn &state->base;\n}\n\nstatic void malidp_destroy_plane_state(struct drm_plane *plane,\n\t\t\t\t       struct drm_plane_state *state)\n{\n\tstruct malidp_plane_state *m_state = to_malidp_plane_state(state);\n\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(m_state);\n}\n\nstatic const char * const prefetch_mode_names[] = {\n\t[MALIDP_PREFETCH_MODE_NONE] = \"MMU_PREFETCH_NONE\",\n\t[MALIDP_PREFETCH_MODE_PARTIAL] = \"MMU_PREFETCH_PARTIAL\",\n\t[MALIDP_PREFETCH_MODE_FULL] = \"MMU_PREFETCH_FULL\",\n};\n\nstatic void malidp_plane_atomic_print_state(struct drm_printer *p,\n\t\t\t\t\t    const struct drm_plane_state *state)\n{\n\tstruct malidp_plane_state *ms = to_malidp_plane_state(state);\n\n\tdrm_printf(p, \"\\trotmem_size=%u\\n\", ms->rotmem_size);\n\tdrm_printf(p, \"\\tformat_id=%u\\n\", ms->format);\n\tdrm_printf(p, \"\\tn_planes=%u\\n\", ms->n_planes);\n\tdrm_printf(p, \"\\tmmu_prefetch_mode=%s\\n\",\n\t\t   prefetch_mode_names[ms->mmu_prefetch_mode]);\n\tdrm_printf(p, \"\\tmmu_prefetch_pgsize=%d\\n\", ms->mmu_prefetch_pgsize);\n}\n\nbool malidp_format_mod_supported(struct drm_device *drm,\n\t\t\t\t u32 format, u64 modifier)\n{\n\tconst struct drm_format_info *info;\n\tconst u64 *modifiers;\n\tstruct malidp_drm *malidp = drm->dev_private;\n\tconst struct malidp_hw_regmap *map = &malidp->dev->hw->map;\n\n\tif (WARN_ON(modifier == DRM_FORMAT_MOD_INVALID))\n\t\treturn false;\n\n\t/* Some pixel formats are supported without any modifier */\n\tif (modifier == DRM_FORMAT_MOD_LINEAR) {\n\t\t/*\n\t\t * However these pixel formats need to be supported with\n\t\t * modifiers only\n\t\t */\n\t\treturn !malidp_hw_format_is_afbc_only(format);\n\t}\n\n\tif (!fourcc_mod_is_vendor(modifier, ARM)) {\n\t\tDRM_ERROR(\"Unknown modifier (not Arm)\\n\");\n\t\treturn false;\n\t}\n\n\tif (modifier &\n\t    ~DRM_FORMAT_MOD_ARM_AFBC(AFBC_MOD_VALID_BITS)) {\n\t\tDRM_DEBUG_KMS(\"Unsupported modifiers\\n\");\n\t\treturn false;\n\t}\n\n\tmodifiers = malidp_format_modifiers;\n\n\t/* SPLIT buffers must use SPARSE layout */\n\tif (WARN_ON_ONCE((modifier & AFBC_SPLIT) && !(modifier & AFBC_SPARSE)))\n\t\treturn false;\n\n\t/* CBR only applies to YUV formats, where YTR should be always 0 */\n\tif (WARN_ON_ONCE((modifier & AFBC_CBR) && (modifier & AFBC_YTR)))\n\t\treturn false;\n\n\twhile (*modifiers != DRM_FORMAT_MOD_INVALID) {\n\t\tif (*modifiers == modifier)\n\t\t\tbreak;\n\n\t\tmodifiers++;\n\t}\n\n\t/* return false, if the modifier was not found */\n\tif (*modifiers == DRM_FORMAT_MOD_INVALID) {\n\t\tDRM_DEBUG_KMS(\"Unsupported modifier\\n\");\n\t\treturn false;\n\t}\n\n\tinfo = drm_format_info(format);\n\n\tif (info->num_planes != 1) {\n\t\tDRM_DEBUG_KMS(\"AFBC buffers expect one plane\\n\");\n\t\treturn false;\n\t}\n\n\tif (malidp_hw_format_is_linear_only(format) == true) {\n\t\tDRM_DEBUG_KMS(\"Given format (0x%x) is supported is linear mode only\\n\",\n\t\t\t      format);\n\t\treturn false;\n\t}\n\n\t/*\n\t * RGB formats need to provide YTR modifier and YUV formats should not\n\t * provide YTR modifier.\n\t */\n\tif (!(info->is_yuv) != !!(modifier & AFBC_FORMAT_MOD_YTR)) {\n\t\tDRM_DEBUG_KMS(\"AFBC_FORMAT_MOD_YTR is %s for %s formats\\n\",\n\t\t\t      info->is_yuv ? \"disallowed\" : \"mandatory\",\n\t\t\t      info->is_yuv ? \"YUV\" : \"RGB\");\n\t\treturn false;\n\t}\n\n\tif (modifier & AFBC_SPLIT) {\n\t\tif (!info->is_yuv) {\n\t\t\tif (info->cpp[0] <= 2) {\n\t\t\t\tDRM_DEBUG_KMS(\"RGB formats <= 16bpp are not supported with SPLIT\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif ((info->hsub != 1) || (info->vsub != 1)) {\n\t\t\tif (!(format == DRM_FORMAT_YUV420_10BIT &&\n\t\t\t      (map->features & MALIDP_DEVICE_AFBC_YUV_420_10_SUPPORT_SPLIT))) {\n\t\t\t\tDRM_DEBUG_KMS(\"Formats which are sub-sampled should never be split\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (modifier & AFBC_CBR) {\n\t\tif ((info->hsub == 1) || (info->vsub == 1)) {\n\t\t\tDRM_DEBUG_KMS(\"Formats which are not sub-sampled should not have CBR set\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool malidp_format_mod_supported_per_plane(struct drm_plane *plane,\n\t\t\t\t\t\t  u32 format, u64 modifier)\n{\n\treturn malidp_format_mod_supported(plane->dev, format, modifier);\n}\n\nstatic const struct drm_plane_funcs malidp_de_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = malidp_de_plane_destroy,\n\t.reset = malidp_plane_reset,\n\t.atomic_duplicate_state = malidp_duplicate_plane_state,\n\t.atomic_destroy_state = malidp_destroy_plane_state,\n\t.atomic_print_state = malidp_plane_atomic_print_state,\n\t.format_mod_supported = malidp_format_mod_supported_per_plane,\n};\n\nstatic int malidp_se_check_scaling(struct malidp_plane *mp,\n\t\t\t\t   struct drm_plane_state *state)\n{\n\tstruct drm_crtc_state *crtc_state =\n\t\tdrm_atomic_get_existing_crtc_state(state->state, state->crtc);\n\tstruct malidp_crtc_state *mc;\n\tu32 src_w, src_h;\n\tint ret;\n\n\tif (!crtc_state)\n\t\treturn -EINVAL;\n\n\tmc = to_malidp_crtc_state(crtc_state);\n\n\tret = drm_atomic_helper_check_plane_state(state, crtc_state,\n\t\t\t\t\t\t  0, INT_MAX, true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state->rotation & MALIDP_ROTATED_MASK) {\n\t\tsrc_w = state->src_h >> 16;\n\t\tsrc_h = state->src_w >> 16;\n\t} else {\n\t\tsrc_w = state->src_w >> 16;\n\t\tsrc_h = state->src_h >> 16;\n\t}\n\n\tif ((state->crtc_w == src_w) && (state->crtc_h == src_h)) {\n\t\t/* Scaling not necessary for this plane. */\n\t\tmc->scaled_planes_mask &= ~(mp->layer->id);\n\t\treturn 0;\n\t}\n\n\tif (mp->layer->id & (DE_SMART | DE_GRAPHICS2))\n\t\treturn -EINVAL;\n\n\tmc->scaled_planes_mask |= mp->layer->id;\n\t/* Defer scaling requirements calculation to the crtc check. */\n\treturn 0;\n}\n\nstatic u32 malidp_get_pgsize_bitmap(struct malidp_plane *mp)\n{\n\tstruct iommu_domain *mmu_dom;\n\n\tmmu_dom = iommu_get_domain_for_dev(mp->base.dev->dev);\n\tif (mmu_dom)\n\t\treturn mmu_dom->pgsize_bitmap;\n\n\treturn 0;\n}\n\n/*\n * Check if the framebuffer is entirely made up of pages at least pgsize in\n * size. Only a heuristic: assumes that each scatterlist entry has been aligned\n * to the largest page size smaller than its length and that the MMU maps to\n * the largest page size possible.\n */\nstatic bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\n\t\tif (IS_ERR(sgt))\n\t\t\treturn false;\n\n\t\tsgl = sgt->sgl;\n\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\n\treturn true;\n}\n\n/*\n * Check if it is possible to enable partial-frame MMU prefetch given the\n * current format, AFBC state and rotation.\n */\nstatic bool malidp_partial_prefetch_supported(u32 format, u64 modifier,\n\t\t\t\t\t      unsigned int rotation)\n{\n\tbool afbc, sparse;\n\n\t/* rotation and horizontal flip not supported for partial prefetch */\n\tif (rotation & (DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_180 |\n\t\t\tDRM_MODE_ROTATE_270 | DRM_MODE_REFLECT_X))\n\t\treturn false;\n\n\tafbc = modifier & DRM_FORMAT_MOD_ARM_AFBC(0);\n\tsparse = modifier & AFBC_FORMAT_MOD_SPARSE;\n\n\tswitch (format) {\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_RGBA1010102:\n\tcase DRM_FORMAT_BGRA1010102:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_RGBA8888:\n\tcase DRM_FORMAT_BGRA8888:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_RGBX8888:\n\tcase DRM_FORMAT_BGRX8888:\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_RGBA5551:\n\tcase DRM_FORMAT_RGB565:\n\t\t/* always supported */\n\t\treturn true;\n\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_ABGR1555:\n\tcase DRM_FORMAT_BGR565:\n\t\t/* supported, but if AFBC then must be sparse mode */\n\t\treturn (!afbc) || (afbc && sparse);\n\n\tcase DRM_FORMAT_BGR888:\n\t\t/* supported, but not for AFBC */\n\t\treturn !afbc;\n\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_YUV420:\n\t\t/* not supported */\n\t\treturn false;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/*\n * Select the preferred MMU prefetch mode. Full-frame prefetch is preferred as\n * long as the framebuffer is all large pages. Otherwise partial-frame prefetch\n * is selected as long as it is supported for the current format. The selected\n * page size for prefetch is returned in pgsize_bitmap.\n */\nstatic enum mmu_prefetch_mode malidp_mmu_prefetch_select_mode\n\t\t(struct malidp_plane_state *ms,\tu32 *pgsize_bitmap)\n{\n\tu32 pgsizes;\n\n\t/* get the full-frame prefetch page size(s) supported by the MMU */\n\tpgsizes = *pgsize_bitmap & MALIDP_MMU_PREFETCH_FULL_PGSIZES;\n\n\twhile (pgsizes) {\n\t\tu32 largest_pgsize = 1 << __fls(pgsizes);\n\n\t\tif (malidp_check_pages_threshold(ms, largest_pgsize)) {\n\t\t\t*pgsize_bitmap = largest_pgsize;\n\t\t\treturn MALIDP_PREFETCH_MODE_FULL;\n\t\t}\n\n\t\tpgsizes -= largest_pgsize;\n\t}\n\n\t/* get the partial-frame prefetch page size(s) supported by the MMU */\n\tpgsizes = *pgsize_bitmap & MALIDP_MMU_PREFETCH_PARTIAL_PGSIZES;\n\n\tif (malidp_partial_prefetch_supported(ms->base.fb->format->format,\n\t\t\t\t\t      ms->base.fb->modifier,\n\t\t\t\t\t      ms->base.rotation)) {\n\t\t/* partial prefetch using the smallest page size */\n\t\t*pgsize_bitmap = 1 << __ffs(pgsizes);\n\t\treturn MALIDP_PREFETCH_MODE_PARTIAL;\n\t}\n\t*pgsize_bitmap = 0;\n\treturn MALIDP_PREFETCH_MODE_NONE;\n}\n\nstatic u32 malidp_calc_mmu_control_value(enum mmu_prefetch_mode mode,\n\t\t\t\t\t u8 readahead, u8 n_planes, u32 pgsize)\n{\n\tu32 mmu_ctrl = 0;\n\n\tif (mode != MALIDP_PREFETCH_MODE_NONE) {\n\t\tmmu_ctrl |= MALIDP_MMU_CTRL_EN;\n\n\t\tif (mode == MALIDP_PREFETCH_MODE_PARTIAL) {\n\t\t\tmmu_ctrl |= MALIDP_MMU_CTRL_MODE;\n\t\t\tmmu_ctrl |= MALIDP_MMU_CTRL_PP_NUM_REQ(readahead);\n\t\t}\n\n\t\tif (pgsize == SZ_64K || pgsize == SZ_2M) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < n_planes; i++)\n\t\t\t\tmmu_ctrl |= MALIDP_MMU_CTRL_PX_PS(i);\n\t\t}\n\t}\n\n\treturn mmu_ctrl;\n}\n\nstatic void malidp_de_prefetch_settings(struct malidp_plane *mp,\n\t\t\t\t\tstruct malidp_plane_state *ms)\n{\n\tif (!mp->layer->mmu_ctrl_offset)\n\t\treturn;\n\n\t/* get the page sizes supported by the MMU */\n\tms->mmu_prefetch_pgsize = malidp_get_pgsize_bitmap(mp);\n\tms->mmu_prefetch_mode  =\n\t\tmalidp_mmu_prefetch_select_mode(ms, &ms->mmu_prefetch_pgsize);\n}\n\nstatic int malidp_de_plane_check(struct drm_plane *plane,\n\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct malidp_plane *mp = to_malidp_plane(plane);\n\tstruct malidp_plane_state *ms = to_malidp_plane_state(new_plane_state);\n\tbool rotated = new_plane_state->rotation & MALIDP_ROTATED_MASK;\n\tstruct drm_framebuffer *fb;\n\tu16 pixel_alpha = new_plane_state->pixel_blend_mode;\n\tint i, ret;\n\tunsigned int block_w, block_h;\n\n\tif (!new_plane_state->crtc || WARN_ON(!new_plane_state->fb))\n\t\treturn 0;\n\n\tfb = new_plane_state->fb;\n\n\tms->format = malidp_hw_get_format_id(&mp->hwdev->hw->map,\n\t\t\t\t\t     mp->layer->id, fb->format->format,\n\t\t\t\t\t     !!fb->modifier);\n\tif (ms->format == MALIDP_INVALID_FORMAT_ID)\n\t\treturn -EINVAL;\n\n\tms->n_planes = fb->format->num_planes;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tu8 alignment = malidp_hw_get_pitch_align(mp->hwdev, rotated);\n\n\t\tif (((fb->pitches[i] * drm_format_info_block_height(fb->format, i))\n\t\t\t\t& (alignment - 1)) && !(fb->modifier)) {\n\t\t\tDRM_DEBUG_KMS(\"Invalid pitch %u for plane %d\\n\",\n\t\t\t\t      fb->pitches[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tblock_w = drm_format_info_block_width(fb->format, 0);\n\tblock_h = drm_format_info_block_height(fb->format, 0);\n\tif (fb->width % block_w || fb->height % block_h) {\n\t\tDRM_DEBUG_KMS(\"Buffer width/height needs to be a multiple of tile sizes\");\n\t\treturn -EINVAL;\n\t}\n\tif ((new_plane_state->src_x >> 16) % block_w || (new_plane_state->src_y >> 16) % block_h) {\n\t\tDRM_DEBUG_KMS(\"Plane src_x/src_y needs to be a multiple of tile sizes\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((new_plane_state->crtc_w > mp->hwdev->max_line_size) ||\n\t    (new_plane_state->crtc_h > mp->hwdev->max_line_size) ||\n\t    (new_plane_state->crtc_w < mp->hwdev->min_line_size) ||\n\t    (new_plane_state->crtc_h < mp->hwdev->min_line_size))\n\t\treturn -EINVAL;\n\n\t/*\n\t * DP550/650 video layers can accept 3 plane formats only if\n\t * fb->pitches[1] == fb->pitches[2] since they don't have a\n\t * third plane stride register.\n\t */\n\tif (ms->n_planes == 3 &&\n\t    !(mp->hwdev->hw->features & MALIDP_DEVICE_LV_HAS_3_STRIDES) &&\n\t    (new_plane_state->fb->pitches[1] != new_plane_state->fb->pitches[2]))\n\t\treturn -EINVAL;\n\n\tret = malidp_se_check_scaling(mp, new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/* validate the rotation constraints for each layer */\n\tif (new_plane_state->rotation != DRM_MODE_ROTATE_0) {\n\t\tif (mp->layer->rot == ROTATE_NONE)\n\t\t\treturn -EINVAL;\n\t\tif ((mp->layer->rot == ROTATE_COMPRESSED) && !(fb->modifier))\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * packed RGB888 / BGR888 can't be rotated or flipped\n\t\t * unless they are stored in a compressed way\n\t\t */\n\t\tif ((fb->format->format == DRM_FORMAT_RGB888 ||\n\t\t     fb->format->format == DRM_FORMAT_BGR888) && !(fb->modifier))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* SMART layer does not support AFBC */\n\tif (mp->layer->id == DE_SMART && fb->modifier) {\n\t\tDRM_ERROR(\"AFBC framebuffer not supported in SMART layer\");\n\t\treturn -EINVAL;\n\t}\n\n\tms->rotmem_size = 0;\n\tif (new_plane_state->rotation & MALIDP_ROTATED_MASK) {\n\t\tint val;\n\n\t\tval = mp->hwdev->hw->rotmem_required(mp->hwdev, new_plane_state->crtc_w,\n\t\t\t\t\t\t     new_plane_state->crtc_h,\n\t\t\t\t\t\t     fb->format->format,\n\t\t\t\t\t\t     !!(fb->modifier));\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tms->rotmem_size = val;\n\t}\n\n\t/* HW can't support plane + pixel blending */\n\tif ((new_plane_state->alpha != DRM_BLEND_ALPHA_OPAQUE) &&\n\t    (pixel_alpha != DRM_MODE_BLEND_PIXEL_NONE) &&\n\t    fb->format->has_alpha)\n\t\treturn -EINVAL;\n\n\tmalidp_de_prefetch_settings(mp, ms);\n\n\treturn 0;\n}\n\nstatic void malidp_de_set_plane_pitches(struct malidp_plane *mp,\n\t\t\t\t\tint num_planes, unsigned int pitches[3])\n{\n\tint i;\n\tint num_strides = num_planes;\n\n\tif (!mp->layer->stride_offset)\n\t\treturn;\n\n\tif (num_planes == 3)\n\t\tnum_strides = (mp->hwdev->hw->features &\n\t\t\t       MALIDP_DEVICE_LV_HAS_3_STRIDES) ? 3 : 2;\n\n\t/*\n\t * The drm convention for pitch is that it needs to cover width * cpp,\n\t * but our hardware wants the pitch/stride to cover all rows included\n\t * in a tile.\n\t */\n\tfor (i = 0; i < num_strides; ++i) {\n\t\tunsigned int block_h = drm_format_info_block_height(mp->base.state->fb->format, i);\n\n\t\tmalidp_hw_write(mp->hwdev, pitches[i] * block_h,\n\t\t\t\tmp->layer->base +\n\t\t\t\tmp->layer->stride_offset + i * 4);\n\t}\n}\n\nstatic const s16\nmalidp_yuv2rgb_coeffs[][DRM_COLOR_RANGE_MAX][MALIDP_COLORADJ_NUM_COEFFS] = {\n\t[DRM_COLOR_YCBCR_BT601][DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t1192,    0, 1634,\n\t\t1192, -401, -832,\n\t\t1192, 2066,    0,\n\t\t  64,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT601][DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t1024,    0, 1436,\n\t\t1024, -352, -731,\n\t\t1024, 1815,    0,\n\t\t   0,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT709][DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t1192,    0, 1836,\n\t\t1192, -218, -546,\n\t\t1192, 2163,    0,\n\t\t  64,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT709][DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t1024,    0, 1613,\n\t\t1024, -192, -479,\n\t\t1024, 1900,    0,\n\t\t   0,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT2020][DRM_COLOR_YCBCR_LIMITED_RANGE] = {\n\t\t1024,    0, 1476,\n\t\t1024, -165, -572,\n\t\t1024, 1884,    0,\n\t\t   0,  512,  512\n\t},\n\t[DRM_COLOR_YCBCR_BT2020][DRM_COLOR_YCBCR_FULL_RANGE] = {\n\t\t1024,    0, 1510,\n\t\t1024, -168, -585,\n\t\t1024, 1927,    0,\n\t\t   0,  512,  512\n\t}\n};\n\nstatic void malidp_de_set_color_encoding(struct malidp_plane *plane,\n\t\t\t\t\t enum drm_color_encoding enc,\n\t\t\t\t\t enum drm_color_range range)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < MALIDP_COLORADJ_NUM_COEFFS; i++) {\n\t\t/* coefficients are signed, two's complement values */\n\t\tmalidp_hw_write(plane->hwdev, malidp_yuv2rgb_coeffs[enc][range][i],\n\t\t\t\tplane->layer->base + plane->layer->yuv2rgb_offset +\n\t\t\t\ti * 4);\n\t}\n}\n\nstatic void malidp_de_set_mmu_control(struct malidp_plane *mp,\n\t\t\t\t      struct malidp_plane_state *ms)\n{\n\tu32 mmu_ctrl;\n\n\t/* check hardware supports MMU prefetch */\n\tif (!mp->layer->mmu_ctrl_offset)\n\t\treturn;\n\n\tmmu_ctrl = malidp_calc_mmu_control_value(ms->mmu_prefetch_mode,\n\t\t\t\t\t\t MALIDP_MMU_PREFETCH_READAHEAD,\n\t\t\t\t\t\t ms->n_planes,\n\t\t\t\t\t\t ms->mmu_prefetch_pgsize);\n\n\tmalidp_hw_write(mp->hwdev, mmu_ctrl,\n\t\t\tmp->layer->base + mp->layer->mmu_ctrl_offset);\n}\n\nstatic void malidp_set_plane_base_addr(struct drm_framebuffer *fb,\n\t\t\t\t       struct malidp_plane *mp,\n\t\t\t\t       int plane_index)\n{\n\tdma_addr_t paddr;\n\tu16 ptr;\n\tstruct drm_plane *plane = &mp->base;\n\tbool afbc = fb->modifier ? true : false;\n\n\tptr = mp->layer->ptr + (plane_index << 4);\n\n\t/*\n\t * drm_fb_cma_get_gem_addr() alters the physical base address of the\n\t * framebuffer as per the plane's src_x, src_y co-ordinates (ie to\n\t * take care of source cropping).\n\t * For AFBC, this is not needed as the cropping is handled by _AD_CROP_H\n\t * and _AD_CROP_V registers.\n\t */\n\tif (!afbc) {\n\t\tpaddr = drm_fb_cma_get_gem_addr(fb, plane->state,\n\t\t\t\t\t\tplane_index);\n\t} else {\n\t\tstruct drm_gem_cma_object *obj;\n\n\t\tobj = drm_fb_cma_get_gem_obj(fb, plane_index);\n\n\t\tif (WARN_ON(!obj))\n\t\t\treturn;\n\t\tpaddr = obj->paddr;\n\t}\n\n\tmalidp_hw_write(mp->hwdev, lower_32_bits(paddr), ptr);\n\tmalidp_hw_write(mp->hwdev, upper_32_bits(paddr), ptr + 4);\n}\n\nstatic void malidp_de_set_plane_afbc(struct drm_plane *plane)\n{\n\tstruct malidp_plane *mp;\n\tu32 src_w, src_h, val = 0, src_x, src_y;\n\tstruct drm_framebuffer *fb = plane->state->fb;\n\n\tmp = to_malidp_plane(plane);\n\n\t/* no afbc_decoder_offset means AFBC is not supported on this plane */\n\tif (!mp->layer->afbc_decoder_offset)\n\t\treturn;\n\n\tif (!fb->modifier) {\n\t\tmalidp_hw_write(mp->hwdev, 0, mp->layer->afbc_decoder_offset);\n\t\treturn;\n\t}\n\n\t/* convert src values from Q16 fixed point to integer */\n\tsrc_w = plane->state->src_w >> 16;\n\tsrc_h = plane->state->src_h >> 16;\n\tsrc_x = plane->state->src_x >> 16;\n\tsrc_y = plane->state->src_y >> 16;\n\n\tval = ((fb->width - (src_x + src_w)) << MALIDP_AD_CROP_RIGHT_OFFSET) |\n\t\t   src_x;\n\tmalidp_hw_write(mp->hwdev, val,\n\t\t\tmp->layer->afbc_decoder_offset + MALIDP_AD_CROP_H);\n\n\tval = ((fb->height - (src_y + src_h)) << MALIDP_AD_CROP_BOTTOM_OFFSET) |\n\t\t   src_y;\n\tmalidp_hw_write(mp->hwdev, val,\n\t\t\tmp->layer->afbc_decoder_offset + MALIDP_AD_CROP_V);\n\n\tval = MALIDP_AD_EN;\n\tif (fb->modifier & AFBC_FORMAT_MOD_SPLIT)\n\t\tval |= MALIDP_AD_BS;\n\tif (fb->modifier & AFBC_FORMAT_MOD_YTR)\n\t\tval |= MALIDP_AD_YTR;\n\n\tmalidp_hw_write(mp->hwdev, val, mp->layer->afbc_decoder_offset);\n}\n\nstatic void malidp_de_plane_update(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct malidp_plane *mp;\n\tstruct malidp_plane_state *ms = to_malidp_plane_state(plane->state);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tu16 pixel_alpha = new_state->pixel_blend_mode;\n\tu8 plane_alpha = new_state->alpha >> 8;\n\tu32 src_w, src_h, dest_w, dest_h, val;\n\tint i;\n\tstruct drm_framebuffer *fb = plane->state->fb;\n\n\tmp = to_malidp_plane(plane);\n\n\t/*\n\t * For AFBC framebuffer, use the framebuffer width and height for\n\t * configuring layer input size register.\n\t */\n\tif (fb->modifier) {\n\t\tsrc_w = fb->width;\n\t\tsrc_h = fb->height;\n\t} else {\n\t\t/* convert src values from Q16 fixed point to integer */\n\t\tsrc_w = new_state->src_w >> 16;\n\t\tsrc_h = new_state->src_h >> 16;\n\t}\n\n\tdest_w = new_state->crtc_w;\n\tdest_h = new_state->crtc_h;\n\n\tval = malidp_hw_read(mp->hwdev, mp->layer->base);\n\tval = (val & ~LAYER_FORMAT_MASK) | ms->format;\n\tmalidp_hw_write(mp->hwdev, val, mp->layer->base);\n\n\tfor (i = 0; i < ms->n_planes; i++)\n\t\tmalidp_set_plane_base_addr(fb, mp, i);\n\n\tmalidp_de_set_mmu_control(mp, ms);\n\n\tmalidp_de_set_plane_pitches(mp, ms->n_planes,\n\t\t\t\t    new_state->fb->pitches);\n\n\tif ((plane->state->color_encoding != old_state->color_encoding) ||\n\t    (plane->state->color_range != old_state->color_range))\n\t\tmalidp_de_set_color_encoding(mp, plane->state->color_encoding,\n\t\t\t\t\t     plane->state->color_range);\n\n\tmalidp_hw_write(mp->hwdev, LAYER_H_VAL(src_w) | LAYER_V_VAL(src_h),\n\t\t\tmp->layer->base + MALIDP_LAYER_SIZE);\n\n\tmalidp_hw_write(mp->hwdev, LAYER_H_VAL(dest_w) | LAYER_V_VAL(dest_h),\n\t\t\tmp->layer->base + MALIDP_LAYER_COMP_SIZE);\n\n\tmalidp_hw_write(mp->hwdev, LAYER_H_VAL(new_state->crtc_x) |\n\t\t\tLAYER_V_VAL(new_state->crtc_y),\n\t\t\tmp->layer->base + MALIDP_LAYER_OFFSET);\n\n\tif (mp->layer->id == DE_SMART) {\n\t\t/*\n\t\t * Enable the first rectangle in the SMART layer to be\n\t\t * able to use it as a drm plane.\n\t\t */\n\t\tmalidp_hw_write(mp->hwdev, 1,\n\t\t\t\tmp->layer->base + MALIDP550_LS_ENABLE);\n\t\tmalidp_hw_write(mp->hwdev,\n\t\t\t\tLAYER_H_VAL(src_w) | LAYER_V_VAL(src_h),\n\t\t\t\tmp->layer->base + MALIDP550_LS_R1_IN_SIZE);\n\t}\n\n\tmalidp_de_set_plane_afbc(plane);\n\n\t/* first clear the rotation bits */\n\tval = malidp_hw_read(mp->hwdev, mp->layer->base + MALIDP_LAYER_CONTROL);\n\tval &= ~LAYER_ROT_MASK;\n\n\t/* setup the rotation and axis flip bits */\n\tif (new_state->rotation & DRM_MODE_ROTATE_MASK)\n\t\tval |= ilog2(plane->state->rotation & DRM_MODE_ROTATE_MASK) <<\n\t\t       LAYER_ROT_OFFSET;\n\tif (new_state->rotation & DRM_MODE_REFLECT_X)\n\t\tval |= LAYER_H_FLIP;\n\tif (new_state->rotation & DRM_MODE_REFLECT_Y)\n\t\tval |= LAYER_V_FLIP;\n\n\tval &= ~(LAYER_COMP_MASK | LAYER_PMUL_ENABLE | LAYER_ALPHA(0xff));\n\n\tif (new_state->alpha != DRM_BLEND_ALPHA_OPAQUE) {\n\t\tval |= LAYER_COMP_PLANE;\n\t} else if (new_state->fb->format->has_alpha) {\n\t\t/* We only care about blend mode if the format has alpha */\n\t\tswitch (pixel_alpha) {\n\t\tcase DRM_MODE_BLEND_PREMULTI:\n\t\t\tval |= LAYER_COMP_PIXEL | LAYER_PMUL_ENABLE;\n\t\t\tbreak;\n\t\tcase DRM_MODE_BLEND_COVERAGE:\n\t\t\tval |= LAYER_COMP_PIXEL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tval |= LAYER_ALPHA(plane_alpha);\n\n\tval &= ~LAYER_FLOWCFG(LAYER_FLOWCFG_MASK);\n\tif (new_state->crtc) {\n\t\tstruct malidp_crtc_state *m =\n\t\t\tto_malidp_crtc_state(new_state->crtc->state);\n\n\t\tif (m->scaler_config.scale_enable &&\n\t\t    m->scaler_config.plane_src_id == mp->layer->id)\n\t\t\tval |= LAYER_FLOWCFG(LAYER_FLOWCFG_SCALE_SE);\n\t}\n\n\t/* set the 'enable layer' bit */\n\tval |= LAYER_ENABLE;\n\n\tmalidp_hw_write(mp->hwdev, val,\n\t\t\tmp->layer->base + MALIDP_LAYER_CONTROL);\n}\n\nstatic void malidp_de_plane_disable(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct malidp_plane *mp = to_malidp_plane(plane);\n\n\tmalidp_hw_clearbits(mp->hwdev,\n\t\t\t    LAYER_ENABLE | LAYER_FLOWCFG(LAYER_FLOWCFG_MASK),\n\t\t\t    mp->layer->base + MALIDP_LAYER_CONTROL);\n}\n\nstatic const struct drm_plane_helper_funcs malidp_de_plane_helper_funcs = {\n\t.atomic_check = malidp_de_plane_check,\n\t.atomic_update = malidp_de_plane_update,\n\t.atomic_disable = malidp_de_plane_disable,\n};\n\nstatic const uint64_t linear_only_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nint malidp_de_planes_init(struct drm_device *drm)\n{\n\tstruct malidp_drm *malidp = drm->dev_private;\n\tconst struct malidp_hw_regmap *map = &malidp->dev->hw->map;\n\tstruct malidp_plane *plane = NULL;\n\tenum drm_plane_type plane_type;\n\tunsigned long crtcs = BIT(drm->mode_config.num_crtc);\n\tunsigned long flags = DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_180 |\n\t\t\t      DRM_MODE_ROTATE_270 | DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y;\n\tunsigned int blend_caps = BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t  BIT(DRM_MODE_BLEND_PREMULTI)   |\n\t\t\t\t  BIT(DRM_MODE_BLEND_COVERAGE);\n\tu32 *formats;\n\tint ret, i = 0, j = 0, n;\n\tu64 supported_modifiers[MODIFIERS_COUNT_MAX];\n\tconst u64 *modifiers;\n\n\tmodifiers = malidp_format_modifiers;\n\n\tif (!(map->features & MALIDP_DEVICE_AFBC_SUPPORT_SPLIT)) {\n\t\t/*\n\t\t * Since our hardware does not support SPLIT, so build the list\n\t\t * of supported modifiers excluding SPLIT ones.\n\t\t */\n\t\twhile (*modifiers != DRM_FORMAT_MOD_INVALID) {\n\t\t\tif (!(*modifiers & AFBC_SPLIT))\n\t\t\t\tsupported_modifiers[j++] = *modifiers;\n\n\t\t\tmodifiers++;\n\t\t}\n\t\tsupported_modifiers[j++] = DRM_FORMAT_MOD_INVALID;\n\t\tmodifiers = supported_modifiers;\n\t}\n\n\tformats = kcalloc(map->n_pixel_formats, sizeof(*formats), GFP_KERNEL);\n\tif (!formats) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < map->n_layers; i++) {\n\t\tu8 id = map->layers[i].id;\n\n\t\tplane = kzalloc(sizeof(*plane), GFP_KERNEL);\n\t\tif (!plane) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* build the list of DRM supported formats based on the map */\n\t\tfor (n = 0, j = 0;  j < map->n_pixel_formats; j++) {\n\t\t\tif ((map->pixel_formats[j].layer & id) == id)\n\t\t\t\tformats[n++] = map->pixel_formats[j].format;\n\t\t}\n\n\t\tplane_type = (i == 0) ? DRM_PLANE_TYPE_PRIMARY :\n\t\t\t\t\tDRM_PLANE_TYPE_OVERLAY;\n\n\t\t/*\n\t\t * All the layers except smart layer supports AFBC modifiers.\n\t\t */\n\t\tret = drm_universal_plane_init(drm, &plane->base, crtcs,\n\t\t\t\t&malidp_de_plane_funcs, formats, n,\n\t\t\t\t(id == DE_SMART) ? linear_only_modifiers : modifiers,\n\t\t\t\tplane_type, NULL);\n\n\t\tif (ret < 0)\n\t\t\tgoto cleanup;\n\n\t\tdrm_plane_helper_add(&plane->base,\n\t\t\t\t     &malidp_de_plane_helper_funcs);\n\t\tplane->hwdev = malidp->dev;\n\t\tplane->layer = &map->layers[i];\n\n\t\tdrm_plane_create_alpha_property(&plane->base);\n\t\tdrm_plane_create_blend_mode_property(&plane->base, blend_caps);\n\n\t\tif (id == DE_SMART) {\n\t\t\t/* Skip the features which the SMART layer doesn't have. */\n\t\t\tcontinue;\n\t\t}\n\n\t\tdrm_plane_create_rotation_property(&plane->base, DRM_MODE_ROTATE_0, flags);\n\t\tmalidp_hw_write(malidp->dev, MALIDP_ALPHA_LUT,\n\t\t\t\tplane->layer->base + MALIDP_LAYER_COMPOSE);\n\n\t\t/* Attach the YUV->RGB property only to video layers */\n\t\tif (id & (DE_VIDEO1 | DE_VIDEO2)) {\n\t\t\t/* default encoding for YUV->RGB is BT601 NARROW */\n\t\t\tenum drm_color_encoding enc = DRM_COLOR_YCBCR_BT601;\n\t\t\tenum drm_color_range range = DRM_COLOR_YCBCR_LIMITED_RANGE;\n\n\t\t\tret = drm_plane_create_color_properties(&plane->base,\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT601) | \\\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT709) | \\\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_BT2020),\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_LIMITED_RANGE) | \\\n\t\t\t\t\tBIT(DRM_COLOR_YCBCR_FULL_RANGE),\n\t\t\t\t\tenc, range);\n\t\t\tif (!ret)\n\t\t\t\t/* program the HW registers */\n\t\t\t\tmalidp_de_set_color_encoding(plane, enc, range);\n\t\t\telse\n\t\t\t\tDRM_WARN(\"Failed to create video layer %d color properties\\n\", id);\n\t\t}\n\t}\n\n\tkfree(formats);\n\n\treturn 0;\n\ncleanup:\n\tkfree(formats);\n\n\treturn ret;\n}\n"], "filenames": ["drivers/gpu/drm/arm/malidp_planes.c"], "buggy_code_start_loc": [347], "buggy_code_end_loc": [348], "fixing_code_start_loc": [347], "fixing_code_end_loc": [348], "type": "CWE-476", "message": "In the Linux kernel before 5.19, drivers/gpu/drm/arm/malidp_planes.c misinterprets the get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).", "other": {"cve": {"id": "CVE-2023-23004", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-01T20:15:14.673", "lastModified": "2023-05-03T01:15:13.347", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.19, drivers/gpu/drm/arm/malidp_planes.c misinterprets the get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.19", "matchCriteriaId": "E74E9AF8-BDF5-4917-A9CA-0AAD8E13149B"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/15342f930ebebcfe36f2415049736a77d7d2e045", "source": "cve@mitre.org", "tags": ["Broken Link", "Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/15342f930ebebcfe36f2415049736a77d7d2e045"}}