{"buggy_code": ["/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       http://www.danga.com/memcached/\n *\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n */\n#include \"memcached.h\"\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <signal.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <ctype.h>\n#include <stdarg.h>\n\n/* some POSIX systems need the following definition\n * to get mlockall flags out of sys/mman.h.  */\n#ifndef _P1003_1B_VISIBLE\n#define _P1003_1B_VISIBLE\n#endif\n/* need this to get IOV_MAX on some platforms. */\n#ifndef __need_IOV_MAX\n#define __need_IOV_MAX\n#endif\n#include <pwd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n#include <sysexits.h>\n#include <stddef.h>\n\n/* FreeBSD 4.x doesn't have IOV_MAX exposed. */\n#ifndef IOV_MAX\n#if defined(__FreeBSD__) || defined(__APPLE__)\n# define IOV_MAX 1024\n#endif\n#endif\n\n/*\n * forward declarations\n */\nstatic void drive_machine(conn *c);\nstatic int new_socket(struct addrinfo *ai);\nstatic int try_read_command(conn *c);\n\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occured (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\nstatic void conn_set_state(conn *c, enum conn_states state);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\n\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void conn_close(conn *c);\nstatic void conn_init(void);\nstatic bool update_event(conn *c, const int new_flags);\nstatic void complete_nread(conn *c);\nstatic void process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic int ensure_iov_space(conn *c);\nstatic int add_iov(conn *c, const void *buf, int len);\nstatic int add_msghdr(conn *c);\n\n\n/* time handling */\nstatic void set_current_time(void);  /* update the global variable holding\n                              global 32-bit seconds-since-start time\n                              (to avoid 64 bit time_t) */\n\nstatic void conn_free(conn *c);\n\n/** exported globals **/\nstruct stats stats;\nstruct settings settings;\ntime_t process_started;     /* when the process was started */\n\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic struct event_base *main_base;\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\nstatic enum transmit_result transmit(conn *c);\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n/*\n * given time value that's either unix time or delta from current unix time, return\n * unix time. Use the fact that delta can't exceed one month (and real time value can't\n * be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\nstatic void stats_init(void) {\n    stats.curr_items = stats.total_items = stats.curr_conns = stats.total_conns = stats.conn_structs = 0;\n    stats.get_cmds = stats.set_cmds = stats.get_hits = stats.get_misses = stats.evictions = 0;\n    stats.curr_bytes = stats.listen_disabled_num = 0;\n    stats.accepting_conns = true; /* assuming we start in this state. */\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - 2;\n    stats_prefix_init();\n}\n\nstatic void stats_reset(void) {\n    STATS_LOCK();\n    stats.total_items = stats.total_conns = 0;\n    stats.evictions = 0;\n    stats.listen_disabled_num = 0;\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset();\n    item_stats_reset();\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n}\n\n/*\n * Adds a message header to a connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int add_msghdr(conn *c)\n{\n    struct msghdr *msg;\n\n    assert(c != NULL);\n\n    if (c->msgsize == c->msgused) {\n        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));\n        if (! msg)\n            return -1;\n        c->msglist = msg;\n        c->msgsize *= 2;\n    }\n\n    msg = c->msglist + c->msgused;\n\n    /* this wipes msg_iovlen, msg_control, msg_controllen, and\n       msg_flags, the last 3 of which aren't defined on solaris: */\n    memset(msg, 0, sizeof(struct msghdr));\n\n    msg->msg_iov = &c->iov[c->iovused];\n\n    if (c->request_addr_size > 0) {\n        msg->msg_name = &c->request_addr;\n        msg->msg_namelen = c->request_addr_size;\n    }\n\n    c->msgbytes = 0;\n    c->msgused++;\n\n    if (IS_UDP(c->transport)) {\n        /* Leave room for the UDP header, which we'll fill in later. */\n        return add_iov(c, NULL, UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\n/*\n * Free list management for connections.\n */\n\nstatic conn **freeconns;\nstatic int freetotal;\nstatic int freecurr;\n/* Lock for connection freelist */\nstatic pthread_mutex_t conn_lock = PTHREAD_MUTEX_INITIALIZER;\n\n\nstatic void conn_init(void) {\n    freetotal = 200;\n    freecurr = 0;\n    if ((freeconns = calloc(freetotal, sizeof(conn *))) == NULL) {\n        fprintf(stderr, \"Failed to allocate connection structures\\n\");\n    }\n    return;\n}\n\n/*\n * Returns a connection from the freelist, if any.\n */\nconn *conn_from_freelist() {\n    conn *c;\n\n    pthread_mutex_lock(&conn_lock);\n    if (freecurr > 0) {\n        c = freeconns[--freecurr];\n    } else {\n        c = NULL;\n    }\n    pthread_mutex_unlock(&conn_lock);\n\n    return c;\n}\n\n/*\n * Adds a connection to the freelist. 0 = success.\n */\nbool conn_add_to_freelist(conn *c) {\n    bool ret = true;\n    pthread_mutex_lock(&conn_lock);\n    if (freecurr < freetotal) {\n        freeconns[freecurr++] = c;\n        ret = false;\n    } else {\n        /* try to enlarge free connections array */\n        size_t newsize = freetotal * 2;\n        conn **new_freeconns = realloc(freeconns, sizeof(conn *) * newsize);\n        if (new_freeconns) {\n            freetotal = newsize;\n            freeconns = new_freeconns;\n            freeconns[freecurr++] = c;\n            ret = false;\n        }\n    }\n    pthread_mutex_unlock(&conn_lock);\n    return ret;\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nconn *conn_new(const int sfd, enum conn_states init_state,\n                const int event_flags,\n                const int read_buffer_size, enum network_transport transport,\n                struct event_base *base) {\n    conn *c = conn_from_freelist();\n\n    if (NULL == c) {\n        if (!(c = (conn *)calloc(1, sizeof(conn)))) {\n            fprintf(stderr, \"calloc()\\n\");\n            return NULL;\n        }\n        MEMCACHED_CONN_CREATE(c);\n\n        c->rbuf = c->wbuf = 0;\n        c->ilist = 0;\n        c->suffixlist = 0;\n        c->iov = 0;\n        c->msglist = 0;\n        c->hdrbuf = 0;\n\n        c->rsize = read_buffer_size;\n        c->wsize = DATA_BUFFER_SIZE;\n        c->isize = ITEM_LIST_INITIAL;\n        c->suffixsize = SUFFIX_LIST_INITIAL;\n        c->iovsize = IOV_LIST_INITIAL;\n        c->msgsize = MSG_LIST_INITIAL;\n        c->hdrsize = 0;\n\n        c->rbuf = (char *)malloc((size_t)c->rsize);\n        c->wbuf = (char *)malloc((size_t)c->wsize);\n        c->ilist = (item **)malloc(sizeof(item *) * c->isize);\n        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);\n        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);\n        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);\n\n        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||\n                c->msglist == 0 || c->suffixlist == 0) {\n            conn_free(c);\n            fprintf(stderr, \"malloc()\\n\");\n            return NULL;\n        }\n\n        STATS_LOCK();\n        stats.conn_structs++;\n        STATS_UNLOCK();\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    /* unix socket mode doesn't need this, so zeroed out.  but why\n     * is this done for every command?  presumably for UDP\n     * mode.  */\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            fprintf(stderr, \"<%d server listening (%s)\\n\", sfd,\n                prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            fprintf(stderr, \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            fprintf(stderr, \"<%d new auto-negotiating client connection\\n\",\n                    sfd);\n        } else if (c->protocol == ascii_prot) {\n            fprintf(stderr, \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            fprintf(stderr, \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            fprintf(stderr, \"<%d new unknown (%d) client connection\\n\",\n                sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (event_add(&c->event, 0) == -1) {\n        if (conn_add_to_freelist(c)) {\n            conn_free(c);\n        }\n        perror(\"event_add\");\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.curr_conns++;\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    return c;\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        item_remove(c->item);\n        c->item = 0;\n    }\n\n    if (c->ileft != 0) {\n        for (; c->ileft > 0; c->ileft--,c->icurr++) {\n            item_remove(*(c->icurr));\n        }\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n\n    if (c->write_and_free) {\n        free(c->write_and_free);\n        c->write_and_free = 0;\n    }\n\n    if (c->sasl_conn) {\n        assert(settings.sasl);\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n}\n\n/*\n * Frees a connection.\n */\nvoid conn_free(conn *c) {\n    if (c) {\n        MEMCACHED_CONN_DESTROY(c);\n        if (c->hdrbuf)\n            free(c->hdrbuf);\n        if (c->msglist)\n            free(c->msglist);\n        if (c->rbuf)\n            free(c->rbuf);\n        if (c->wbuf)\n            free(c->wbuf);\n        if (c->ilist)\n            free(c->ilist);\n        if (c->suffixlist)\n            free(c->suffixlist);\n        if (c->iov)\n            free(c->iov);\n        free(c);\n    }\n}\n\nstatic void conn_close(conn *c) {\n    assert(c != NULL);\n\n    /* delete the event, the socket and the conn */\n    event_del(&c->event);\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d connection closed.\\n\", c->sfd);\n\n    MEMCACHED_CONN_RELEASE(c->sfd);\n    close(c->sfd);\n    accept_new_conns(true);\n    conn_cleanup(c);\n\n    /* if the connection has big buffers, just free it */\n    if (c->rsize > READ_BUFFER_HIGHWAT || conn_add_to_freelist(c)) {\n        conn_free(c);\n    }\n\n    STATS_LOCK();\n    stats.curr_conns--;\n    STATS_UNLOCK();\n\n    return;\n}\n\n/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\nstatic void conn_shrink(conn *c) {\n    assert(c != NULL);\n\n    if (IS_UDP(c->transport))\n        return;\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nstatic const char *state_text(enum conn_states state) {\n    const char* const statenames[] = { \"conn_listening\",\n                                       \"conn_new_cmd\",\n                                       \"conn_waiting\",\n                                       \"conn_read\",\n                                       \"conn_parse_cmd\",\n                                       \"conn_write\",\n                                       \"conn_nread\",\n                                       \"conn_swallow\",\n                                       \"conn_closing\",\n                                       \"conn_mwrite\" };\n    return statenames[state];\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nstatic void conn_set_state(conn *c, enum conn_states state) {\n    assert(c != NULL);\n    assert(state >= conn_listening && state < conn_max_state);\n\n    if (state != c->state) {\n        if (settings.verbose > 2) {\n            fprintf(stderr, \"%d: going from %s to %s\\n\",\n                    c->sfd, state_text(c->state),\n                    state_text(state));\n        }\n\n        c->state = state;\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n    }\n}\n\n/*\n * Ensures that there is room for another struct iovec in a connection's\n * iov list.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int ensure_iov_space(conn *c) {\n    assert(c != NULL);\n\n    if (c->iovused >= c->iovsize) {\n        int i, iovnum;\n        struct iovec *new_iov = (struct iovec *)realloc(c->iov,\n                                (c->iovsize * 2) * sizeof(struct iovec));\n        if (! new_iov)\n            return -1;\n        c->iov = new_iov;\n        c->iovsize *= 2;\n\n        /* Point all the msghdr structures at the new list. */\n        for (i = 0, iovnum = 0; i < c->msgused; i++) {\n            c->msglist[i].msg_iov = &c->iov[iovnum];\n            iovnum += c->msglist[i].msg_iovlen;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n\nstatic int add_iov(conn *c, const void *buf, int len) {\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}\n\n\n/*\n * Constructs a set of UDP headers and attaches them to the outgoing messages.\n */\nstatic int build_udp_headers(conn *c) {\n    int i;\n    unsigned char *hdr;\n\n    assert(c != NULL);\n\n    if (c->msgused > c->hdrsize) {\n        void *new_hdrbuf;\n        if (c->hdrbuf)\n            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);\n        else\n            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);\n        if (! new_hdrbuf)\n            return -1;\n        c->hdrbuf = (unsigned char *)new_hdrbuf;\n        c->hdrsize = c->msgused * 2;\n    }\n\n    hdr = c->hdrbuf;\n    for (i = 0; i < c->msgused; i++) {\n        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;\n        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;\n        *hdr++ = c->request_id / 256;\n        *hdr++ = c->request_id % 256;\n        *hdr++ = i / 256;\n        *hdr++ = i % 256;\n        *hdr++ = c->msgused / 256;\n        *hdr++ = c->msgused % 256;\n        *hdr++ = 0;\n        *hdr++ = 0;\n        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n\n    assert(c != NULL);\n\n    if (c->noreply) {\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        c->noreply = false;\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n\n    len = strlen(str);\n    if ((len + 2) > c->wsize) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(c->wbuf, str, len);\n    memcpy(c->wbuf + len, \"\\r\\n\", 2);\n    c->wbytes = len + 2;\n    c->wcurr = c->wbuf;\n\n    conn_set_state(c, conn_write);\n    c->write_and_go = conn_new_cmd;\n    return;\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_nread_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    int comm = c->cmd;\n    enum store_item_type ret;\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.slab_stats[it->slabs_clsid].set_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    if (strncmp(ITEM_data(it) + it->nbytes - 2, \"\\r\\n\", 2) != 0) {\n        out_string(c, \"CLIENT_ERROR bad data chunk\");\n    } else {\n      ret = store_item(it, comm, c);\n\n#ifdef ENABLE_DTRACE\n      uint64_t cas = ITEM_get_cas(it);\n      switch (c->cmd) {\n      case NREAD_ADD:\n          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,\n                                (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_REPLACE:\n          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,\n                                    (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_APPEND:\n          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,\n                                   (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_PREPEND:\n          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,\n                                    (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_SET:\n          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,\n                                (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_CAS:\n          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,\n                                cas);\n          break;\n      }\n#endif\n\n      switch (ret) {\n      case STORED:\n          out_string(c, \"STORED\");\n          break;\n      case EXISTS:\n          out_string(c, \"EXISTS\");\n          break;\n      case NOT_FOUND:\n          out_string(c, \"NOT_FOUND\");\n          break;\n      case NOT_STORED:\n          out_string(c, \"NOT_STORED\");\n          break;\n      default:\n          out_string(c, \"SERVER_ERROR Unhandled storage type.\");\n      }\n\n    }\n\n    item_remove(c->item);       /* release the c->item reference */\n    c->item = 0;\n}\n\n/**\n * get a pointer to the start of the request struct for the current command\n */\nstatic void* binary_get_request(conn *c) {\n    char *ret = c->rcurr;\n    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +\n            c->binary_header.request.extlen);\n\n    assert(ret >= c->rbuf);\n    return ret;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n\n    assert(c);\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        /* XXX:  out_string is inappropriate here */\n        out_string(c, \"SERVER_ERROR out of memory\");\n        return;\n    }\n\n    header = (protocol_binary_response_header *)c->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \">%d Writing bin response:\", c->sfd);\n        for (ii = 0; ii < sizeof(header->bytes); ++ii) {\n            if (ii % 4 == 0) {\n                fprintf(stderr, \"\\n>%d  \", c->sfd);\n            }\n            fprintf(stderr, \" 0x%02x\", header->bytes[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    add_iov(c, c->wbuf, sizeof(header->response));\n}\n\nstatic void write_bin_error(conn *c, protocol_binary_response_status err, int swallow) {\n    const char *errstr = \"Unknown error\";\n    size_t len;\n\n    switch (err) {\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n        errstr = \"Out of memory\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n        errstr = \"Unknown command\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n        errstr = \"Not found\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n        errstr = \"Invalid arguments\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n        errstr = \"Data exists for key.\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n        errstr = \"Too large.\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n        errstr = \"Non-numeric server-side value for incr or decr\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n        errstr = \"Not stored.\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n        errstr = \"Auth failure.\";\n        break;\n    default:\n        assert(false);\n        errstr = \"UNHANDLED ERROR\";\n        fprintf(stderr, \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \">%d Writing an error: %s\\n\", c->sfd, errstr);\n    }\n\n    len = strlen(errstr);\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        add_iov(c, errstr, len);\n    }\n    conn_set_state(c, conn_mwrite);\n    if(swallow > 0) {\n        c->sbytes = swallow;\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}\n\nstatic void complete_incr_bin(conn *c) {\n    item *it;\n    char *key;\n    size_t nkey;\n\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;\n    protocol_binary_request_incr* req = binary_get_request(c);\n\n    assert(c != NULL);\n    assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    req->message.body.delta = ntohll(req->message.body.delta);\n    req->message.body.initial = ntohll(req->message.body.initial);\n    req->message.body.expiration = ntohl(req->message.body.expiration);\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int i;\n        fprintf(stderr, \"incr \");\n\n        for (i = 0; i < nkey; i++) {\n            fprintf(stderr, \"%c\", key[i]);\n        }\n        fprintf(stderr, \" %lld, %llu, %d\\n\",\n                (long long)req->message.body.delta,\n                (long long)req->message.body.initial,\n                req->message.body.expiration);\n    }\n\n    it = item_get(key, nkey);\n    if (it && (c->binary_header.request.cas == 0 ||\n               c->binary_header.request.cas == ITEM_get_cas(it))) {\n        /* Weird magic in add_delta forces me to pad here */\n        char tmpbuf[INCR_MAX_STORAGE_LEN];\n        protocol_binary_response_status st = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n\n        switch(add_delta(c, it, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,\n                         req->message.body.delta, tmpbuf)) {\n        case OK:\n            break;\n        case NON_NUMERIC:\n            st = PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL;\n            break;\n        case EOM:\n            st = PROTOCOL_BINARY_RESPONSE_ENOMEM;\n            break;\n        }\n\n        if (st != PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n            write_bin_error(c, st, 0);\n        } else {\n            rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));\n            c->cas = ITEM_get_cas(it);\n            write_bin_response(c, &rsp->message.body, 0, 0,\n                               sizeof(rsp->message.body.value));\n        }\n\n        item_remove(it);         /* release our reference */\n    } else if (!it && req->message.body.expiration != 0xffffffff) {\n        /* Save some room for the response */\n        rsp->message.body.value = htonll(req->message.body.initial);\n        it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),\n                        INCR_MAX_STORAGE_LEN);\n\n        if (it != NULL) {\n            snprintf(ITEM_data(it), INCR_MAX_STORAGE_LEN, \"%llu\",\n                     (unsigned long long)req->message.body.initial);\n\n            if (store_item(it, NREAD_SET, c)) {\n                c->cas = ITEM_get_cas(it);\n                write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));\n            } else {\n                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);\n            }\n            item_remove(it);         /* release our reference */\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        }\n    } else if (it) {\n        /* incorrect CAS */\n        item_remove(it);         /* release our reference */\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n    } else {\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            c->thread->stats.incr_misses++;\n        } else {\n            c->thread->stats.decr_misses++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    enum store_item_type ret = NOT_STORED;\n    assert(c != NULL);\n\n    item *it = c->item;\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.slab_stats[it->slabs_clsid].set_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    /* We don't actually receive the trailing two characters in the bin\n     * protocol, so we're going to just set them here */\n    *(ITEM_data(it) + it->nbytes - 2) = '\\r';\n    *(ITEM_data(it) + it->nbytes - 1) = '\\n';\n\n    ret = store_item(it, c->cmd, c);\n\n#ifdef ENABLE_DTRACE\n    uint64_t cas = ITEM_get_cas(it);\n    switch (c->cmd) {\n    case NREAD_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,\n                              (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,\n                                  (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,\n                                 (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,\n                                 (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,\n                              (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case STORED:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case EXISTS:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case NOT_FOUND:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case NOT_STORED:\n        if (c->cmd == NREAD_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->cmd == NREAD_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_error(c, eno, 0);\n    }\n\n    item_remove(c->item);       /* release the c->item reference */\n    c->item = 0;\n}\n\nstatic void process_bin_get(conn *c) {\n    item *it;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \"<%d GET \", c->sfd);\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", key[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    it = item_get(key, nkey);\n    if (it) {\n        /* the length has two unnecessary bytes (\"\\r\\n\") */\n        uint16_t keylen = 0;\n        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.get_cmds++;\n        c->thread->stats.slab_stats[it->slabs_clsid].get_hits++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                              it->nbytes, ITEM_get_cas(it));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));\n\n        // add the flags\n        rsp->message.body.flags = htonl(strtoul(ITEM_suffix(it), NULL, 10));\n        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            add_iov(c, ITEM_key(it), nkey);\n        }\n\n        /* Add the data minus the CRLF */\n        add_iov(c, ITEM_data(it), it->nbytes - 2);\n        conn_set_state(c, conn_mwrite);\n        /* Remember this command so we can garbage collect it later */\n        c->item = it;\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.get_cmds++;\n        c->thread->stats.get_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);\n                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                        0, nkey, nkey);\n                memcpy(ofs, key, nkey);\n                add_iov(c, ofs, nkey);\n                conn_set_state(c, conn_mwrite);\n            } else {\n                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_get(key, nkey, NULL != it);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->stats.buffer + c->stats.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->stats.offset += sizeof(header.response) + bodylen;\n}\n\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->stats.buffer + c->stats.offset;\n    uint32_t nbytes = 0;\n    int remaining = c->stats.size - c->stats.offset;\n    int room = remaining - 1;\n\n    if (klen == 0 && vlen == 0) {\n        nbytes = snprintf(pos, room, \"END\\r\\n\");\n    } else if (vlen == 0) {\n        nbytes = snprintf(pos, room, \"STAT %s\\r\\n\", key);\n    } else {\n        nbytes = snprintf(pos, room, \"STAT %s %s\\r\\n\", key, val);\n    }\n\n    c->stats.offset += nbytes;\n}\n\nstatic bool grow_stats_buf(conn *c, size_t needed) {\n    size_t nsize = c->stats.size;\n    size_t available = nsize - c->stats.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->stats.buffer == NULL) {\n        nsize = 1024;\n        available = c->stats.size = c->stats.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->stats.offset;\n    }\n\n    if (nsize != c->stats.size) {\n        char *ptr = realloc(c->stats.buffer, nsize);\n        if (ptr) {\n            c->stats.buffer = ptr;\n            c->stats.size = nsize;\n        } else {\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                  const char *val, const uint32_t vlen,\n                  const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return ;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_stats_buf(c, needed)) {\n            return ;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_stats_buf(c, needed)) {\n            return ;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->stats.offset <= c->stats.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \"<%d STATS \", c->sfd);\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", subcommand[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (nkey == 0) {\n        /* request all statistics */\n        server_stats(&append_stats, c);\n        (void)get_stats(NULL, 0, &append_stats, c);\n    } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n        stats_reset();\n    } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n        char *subcmd_pos = subcommand + 6;\n        if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n            int len;\n            char *dump_buf = stats_prefix_dump(&len);\n            if (dump_buf == NULL || len <= 0) {\n                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                return ;\n            } else {\n                append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                free(dump_buf);\n            }\n        } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n            settings.detail_enabled = 1;\n        } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n            settings.detail_enabled = 0;\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            return;\n        }\n    } else {\n        if (get_stats(subcommand, nkey, &append_stats, c)) {\n            if (c->stats.buffer == NULL) {\n                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n            } else {\n                write_and_free(c, c->stats.buffer, c->stats.offset);\n                c->stats.buffer = NULL;\n            }\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        }\n\n        return;\n    }\n\n    /* Append termination package and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n    if (c->stats.buffer == NULL) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n    } else {\n        write_and_free(c, c->stats.buffer, c->stats.offset);\n        c->stats.buffer = NULL;\n    }\n}\n\nstatic void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {\n    assert(c);\n    c->substate = next_substate;\n    c->rlbytes = c->keylen + extra;\n\n    /* Ok... do we have room for the extras and the key in the input buffer? */\n    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;\n    if (c->rlbytes > c->rsize - offset) {\n        size_t nsize = c->rsize;\n        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);\n\n        while (size > nsize) {\n            nsize *= 2;\n        }\n\n        if (nsize != c->rsize) {\n            if (settings.verbose > 1) {\n                fprintf(stderr, \"%d: Need to grow buffer from %lu to %lu\\n\",\n                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);\n            }\n            char *newm = realloc(c->rbuf, nsize);\n            if (newm == NULL) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"%d: Failed to grow buffer.. closing connection\\n\",\n                            c->sfd);\n                }\n                conn_set_state(c, conn_closing);\n                return;\n            }\n\n            c->rbuf= newm;\n            /* rcurr should point to the same offset in the packet */\n            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);\n            c->rsize = nsize;\n        }\n        if (c->rbuf != c->rcurr) {\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n            c->rcurr = c->rbuf;\n            if (settings.verbose > 1) {\n                fprintf(stderr, \"%d: Repack input buffer\\n\", c->sfd);\n            }\n        }\n    }\n\n    /* preserve the header in the buffer.. */\n    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);\n    conn_set_state(c, conn_nread);\n}\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        fprintf(stderr, \"Protocol error (opcode %02x), close connection %d\\n\",\n                c->binary_header.request.opcode, c->sfd);\n    }\n    c->write_and_go = conn_closing;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    /* should something else be returned? */\n    if (!settings.sasl)\n        return;\n\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL, NULL, NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                fprintf(stderr, \"Failed to initialize SASL conn.\\n\");\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void bin_list_sasl_mechs(conn *c) {\n    // Guard against a disabled SASL.\n    if (!settings.sasl) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                        c->binary_header.request.bodylen\n                        - c->binary_header.request.keylen);\n        return;\n    }\n\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            fprintf(stderr, \"Failed to list SASL mechanisms.\\n\");\n        }\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n\nstatic void process_bin_sasl_auth(conn *c) {\n    // Guard for handling disabled SASL on the server.\n    if (!settings.sasl) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                        c->binary_header.request.bodylen\n                        - c->binary_header.request.keylen);\n        return;\n    }\n\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    item *it = item_alloc(key, nkey, 0, 0, vlen);\n\n    if (it == 0) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    assert(settings.sasl);\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    char mech[nkey+1];\n    memcpy(mech, ITEM_key((item*)c->item), nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose)\n        fprintf(stderr, \"mech:  ``%s'' with %d bytes of data\\n\", mech, vlen);\n\n    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            fprintf(stderr, \"Unhandled command %d with challenge %s\\n\",\n                    c->cmd, challenge);\n        }\n        break;\n    }\n\n    item_unlink(c->item);\n\n    if (settings.verbose) {\n        fprintf(stderr, \"sasl result code:  %d\\n\", result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if(outlen > 0) {\n            add_iov(c, out, outlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n        break;\n    default:\n        if (settings.verbose)\n            fprintf(stderr, \"Unknown sasl response:  %d\\n\", result);\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    assert(settings.sasl);\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        if (c->sasl_conn) {\n            const void *uname = NULL;\n            sasl_getprop(c->sasl_conn, SASL_USERNAME, &uname);\n            rv = uname != NULL;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"authenticated() in cmd 0x%02x is %s\\n\",\n                c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic void dispatch_bin_command(conn *c) {\n    int protocol_error = 0;\n\n    int extlen = c->binary_header.request.extlen;\n    int keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (settings.sasl && !authenticated(c)) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        c->write_and_go = conn_closing;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                bin_read_key(c, bin_read_flush_exptime, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                bin_read_key(c, bin_reading_set_header, 8);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                bin_read_key(c, bin_reading_get_key, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                bin_read_key(c, bin_reading_del_header, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                bin_read_key(c, bin_reading_incr_header, 20);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                bin_read_key(c, bin_reading_set_header, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                bin_read_key(c, bin_reading_stat, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                c->write_and_go = conn_closing;\n                if (c->noreply) {\n                    conn_set_state(c, conn_closing);\n                }\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                bin_read_key(c, bin_reading_sasl_auth, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, bodylen);\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n    protocol_binary_request_set* req = binary_get_request(c);\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = ntohl(req->message.body.flags);\n    req->message.body.expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        int ii;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            fprintf(stderr, \"<%d ADD \", c->sfd);\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            fprintf(stderr, \"<%d SET \", c->sfd);\n        } else {\n            fprintf(stderr, \"<%d REPLACE \", c->sfd);\n        }\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", key[ii]);\n        }\n\n        fprintf(stderr, \" Value len is %d\", vlen);\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, req->message.body.flags,\n            realtime(req->message.body.expiration), vlen+2);\n\n    if (it == 0) {\n        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            it = item_get(key, nkey);\n            if (it) {\n                item_unlink(it);\n                item_remove(it);\n            }\n        }\n\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    ITEM_set_cas(it, c->binary_header.request.cas);\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->cmd = NREAD_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->cmd = NREAD_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->cmd = NREAD_REPLACE;\n            break;\n        default:\n            assert(0);\n    }\n\n    if (ITEM_get_cas(it) != 0) {\n        c->cmd = NREAD_CAS;\n    }\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_read_set_value;\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, 0, 0, vlen+2);\n\n    if (it == 0) {\n        if (! item_size_ok(nkey, 0, vlen + 2)) {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    ITEM_set_cas(it, c->binary_header.request.cas);\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->cmd = NREAD_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->cmd = NREAD_PREPEND;\n            break;\n        default:\n            assert(0);\n    }\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_read_set_value;\n}\n\nstatic void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    set_current_time();\n\n    if (exptime > 0) {\n        settings.oldest_live = realtime(exptime) - 1;\n    } else {\n        settings.oldest_live = current_time - 1;\n    }\n    item_flush_expired();\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.flush_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_delete(conn *c) {\n    item *it;\n\n    protocol_binary_request_delete* req = binary_get_request(c);\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"Deleting %s\\n\", key);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n\n    it = item_get(key, nkey);\n    if (it) {\n        uint64_t cas = ntohll(req->message.header.request.cas);\n        if (cas == 0 || cas == ITEM_get_cas(it)) {\n            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n            item_unlink(it);\n            write_bin_response(c, NULL, 0, 0, 0);\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        }\n        item_remove(it);      /* release our reference */\n    } else {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n    }\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_reading_set_header:\n        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||\n                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n            process_bin_append_prepend(c);\n        } else {\n            process_bin_update(c);\n        }\n        break;\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_get_key:\n        process_bin_get(c);\n        break;\n    case bin_reading_stat:\n        process_bin_stat(c);\n        break;\n    case bin_reading_del_header:\n        process_bin_delete(c);\n        break;\n    case bin_reading_incr_header:\n        complete_incr_bin(c);\n        break;\n    case bin_read_flush_exptime:\n        process_bin_flush(c);\n        break;\n    case bin_reading_sasl_auth:\n        process_bin_sasl_auth(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        break;\n    default:\n        fprintf(stderr, \"Not handling substate %d\\n\", c->substate);\n        assert(0);\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if(c->item != NULL) {\n        item_remove(c->item);\n        c->item = NULL;\n    }\n    conn_shrink(c);\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n/*\n * Stores an item in the cache according to the semantics of one of the set\n * commands. In threaded mode, this is protected by the cache lock.\n *\n * Returns the state of storage.\n */\nenum store_item_type do_store_item(item *it, int comm, conn *c) {\n    char *key = ITEM_key(it);\n    item *old_it = do_item_get(key, it->nkey);\n    enum store_item_type stored = NOT_STORED;\n\n    item *new_it = NULL;\n    int flags;\n\n    if (old_it != NULL && comm == NREAD_ADD) {\n        /* add only adds a nonexistent item, but promote to head of LRU */\n        do_item_update(old_it);\n    } else if (!old_it && (comm == NREAD_REPLACE\n        || comm == NREAD_APPEND || comm == NREAD_PREPEND))\n    {\n        /* replace only replaces an existing value; don't store */\n    } else if (comm == NREAD_CAS) {\n        /* validate cas operation */\n        if(old_it == NULL) {\n            // LRU expired\n            stored = NOT_FOUND;\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.cas_misses++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n        }\n        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {\n            // cas validates\n            // it and old_it may belong to different classes.\n            // I'm updating the stats for the one that's getting pushed out\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.slab_stats[old_it->slabs_clsid].cas_hits++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            item_replace(old_it, it);\n            stored = STORED;\n        } else {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.slab_stats[old_it->slabs_clsid].cas_badval++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            if(settings.verbose > 1) {\n                fprintf(stderr, \"CAS:  failure: expected %llu, got %llu\\n\",\n                        (unsigned long long)ITEM_get_cas(old_it),\n                        (unsigned long long)ITEM_get_cas(it));\n            }\n            stored = EXISTS;\n        }\n    } else {\n        /*\n         * Append - combine new and old record into single one. Here it's\n         * atomic and thread-safe.\n         */\n        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {\n            /*\n             * Validate CAS\n             */\n            if (ITEM_get_cas(it) != 0) {\n                // CAS much be equal\n                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {\n                    stored = EXISTS;\n                }\n            }\n\n            if (stored == NOT_STORED) {\n                /* we have it and old_it here - alloc memory to hold both */\n                /* flags was already lost - so recover them from ITEM_suffix(it) */\n\n                flags = (int) strtol(ITEM_suffix(old_it), (char **) NULL, 10);\n\n                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);\n\n                if (new_it == NULL) {\n                    /* SERVER_ERROR out of memory */\n                    if (old_it != NULL)\n                        do_item_remove(old_it);\n\n                    return NOT_STORED;\n                }\n\n                /* copy data from it and old_it to new_it */\n\n                if (comm == NREAD_APPEND) {\n                    memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);\n                    memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(it), it->nbytes);\n                } else {\n                    /* NREAD_PREPEND */\n                    memcpy(ITEM_data(new_it), ITEM_data(it), it->nbytes);\n                    memcpy(ITEM_data(new_it) + it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);\n                }\n\n                it = new_it;\n            }\n        }\n\n        if (stored == NOT_STORED) {\n            if (old_it != NULL)\n                item_replace(old_it, it);\n            else\n                do_item_link(it);\n\n            c->cas = ITEM_get_cas(it);\n\n            stored = STORED;\n        }\n    }\n\n    if (old_it != NULL)\n        do_item_remove(old_it);         /* release our reference */\n    if (new_it != NULL)\n        do_item_remove(new_it);\n\n    if (stored == STORED) {\n        c->cas = ITEM_get_cas(it);\n    }\n\n    return stored;\n}\n\ntypedef struct token_s {\n    char *value;\n    size_t length;\n} token_t;\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 8\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    for (s = e = command; ntokens < max_tokens - 1; ++e) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n            }\n            s = e + 1;\n        }\n        else if (*e == '\\0') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n            }\n\n            break; /* string end */\n        }\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline void set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (strcmp(command, \"on\") == 0) {\n        settings.detail_enabled = 1;\n        out_string(c, \"OK\");\n    }\n    else if (strcmp(command, \"off\") == 0) {\n        settings.detail_enabled = 0;\n        out_string(c, \"OK\");\n    }\n    else if (strcmp(command, \"dump\") == 0) {\n        int len;\n        char *stats = stats_prefix_dump(&len);\n        write_and_free(c, stats, len);\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n    }\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_aggregate(&thread_stats);\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef WIN32\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif /* !WIN32 */\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef WIN32\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif /* !WIN32 */\n\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns - 1);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"cmd_get\", \"%llu\", (unsigned long long)thread_stats.get_cmds);\n    APPEND_STAT(\"cmd_set\", \"%llu\", (unsigned long long)slab_stats.set_cmds);\n    APPEND_STAT(\"cmd_flush\", \"%llu\", (unsigned long long)thread_stats.flush_cmds);\n    APPEND_STAT(\"get_hits\", \"%llu\", (unsigned long long)slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%llu\", (unsigned long long)thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%llu\", (unsigned long long)thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%llu\", (unsigned long long)slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%llu\", (unsigned long long)thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%llu\", (unsigned long long)slab_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%llu\", (unsigned long long)thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%llu\", (unsigned long long)slab_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%llu\", (unsigned long long)thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%llu\", (unsigned long long)slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%llu\", (unsigned long long)slab_stats.cas_badval);\n    APPEND_STAT(\"bytes_read\", \"%llu\", (unsigned long long)thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%llu\", (unsigned long long)thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%llu\", (unsigned long long)settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\", stats.accepting_conns);\n    APPEND_STAT(\"listen_disabled_num\", \"%llu\", (unsigned long long)stats.listen_disabled_num);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%llu\", (unsigned long long)thread_stats.conn_yields);\n    STATS_UNLOCK();\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n}\n\nstatic void process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    assert(c != NULL);\n\n    if (ntokens < 2) {\n        out_string(c, \"CLIENT_ERROR bad command line\");\n        return;\n    }\n\n    if (ntokens == 2) {\n        server_stats(&append_stats, c);\n        (void)get_stats(NULL, 0, &append_stats, c);\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset();\n        out_string(c, \"RESET\");\n        return ;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4)\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        else\n            process_stats_detail(c, tokens[2].value);\n        /* Output already generated */\n        return ;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf;\n        unsigned int bytes, id, limit = 0;\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n\n        if (id >= POWER_LARGEST) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return;\n        }\n\n        buf = item_cachedump(id, limit, &bytes);\n        write_and_free(c, buf, bytes);\n        return ;\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {\n            if (c->stats.buffer == NULL) {\n                out_string(c, \"SERVER_ERROR out of memory writing stats\");\n            } else {\n                write_and_free(c, c->stats.buffer, c->stats.offset);\n                c->stats.buffer = NULL;\n            }\n        } else {\n            out_string(c, \"ERROR\");\n        }\n        return ;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->stats.buffer == NULL) {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->stats.buffer, c->stats.offset);\n        c->stats.buffer = NULL;\n    }\n}\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n\n            it = item_get(key, nkey);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    item_remove(it);\n                    return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                            \" %llu\\r\\n\",\n                                            (unsigned long long)ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, ITEM_data(it), it->nbytes) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1)\n                    fprintf(stderr, \">%d sending key %s\\n\", c->sfd, ITEM_key(it));\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[it->slabs_clsid].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                item_update(it);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return;\n}\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    time_t exptime;\n    int vlen;\n    uint64_t req_cas_id=0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */\n    exptime = exptime_int;\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    vlen += 2;\n    if (vlen < 0 || vlen - 2 < 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);\n\n    if (it == 0) {\n        if (! item_size_ok(nkey, flags, vlen))\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n        else\n            out_string(c, \"SERVER_ERROR out of memory storing object\");\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        c->sbytes = vlen;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (comm == NREAD_SET) {\n            it = item_get(key, nkey);\n            if (it) {\n                item_unlink(it);\n                item_remove(it);\n            }\n        }\n\n        return;\n    }\n    ITEM_set_cas(it, req_cas_id);\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = it->nbytes;\n    c->cmd = comm;\n    conn_set_state(c, conn_nread);\n}\n\nstatic void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n    char temp[INCR_MAX_STORAGE_LEN];\n    item *it;\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return;\n    }\n\n    it = item_get(key, nkey);\n    if (!it) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (incr) {\n            c->thread->stats.incr_misses++;\n        } else {\n            c->thread->stats.decr_misses++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n        return;\n    }\n\n    switch(add_delta(c, it, incr, delta, temp)) {\n    case OK:\n        out_string(c, temp);\n        break;\n    case NON_NUMERIC:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case EOM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    }\n    item_remove(it);         /* release our reference */\n}\n\n/*\n * adds a delta value to a numeric item.\n *\n * c     connection requesting the operation\n * it    item to adjust\n * incr  true to increment value, false to decrement\n * delta amount to adjust value by\n * buf   buffer for response string\n *\n * returns a response string to send back to the client.\n */\nenum delta_result_type do_add_delta(conn *c, item *it, const bool incr,\n                                    const int64_t delta, char *buf) {\n    char *ptr;\n    uint64_t value;\n    int res;\n\n    ptr = ITEM_data(it);\n\n    if (!safe_strtoull(ptr, &value)) {\n        return NON_NUMERIC;\n    }\n\n    if (incr) {\n        value += delta;\n        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);\n    } else {\n        if(delta > value) {\n            value = 0;\n        } else {\n            value -= delta;\n        }\n        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);\n    }\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    if (incr) {\n        c->thread->stats.slab_stats[it->slabs_clsid].incr_hits++;\n    } else {\n        c->thread->stats.slab_stats[it->slabs_clsid].decr_hits++;\n    }\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    snprintf(buf, INCR_MAX_STORAGE_LEN, \"%llu\", (unsigned long long)value);\n    res = strlen(buf);\n    if (res + 2 > it->nbytes) { /* need to realloc */\n        item *new_it;\n        new_it = do_item_alloc(ITEM_key(it), it->nkey, atoi(ITEM_suffix(it) + 1), it->exptime, res + 2 );\n        if (new_it == 0) {\n            return EOM;\n        }\n        memcpy(ITEM_data(new_it), buf, res);\n        memcpy(ITEM_data(new_it) + res, \"\\r\\n\", 2);\n        item_replace(it, new_it);\n        do_item_remove(new_it);       /* release our reference */\n    } else { /* replace in-place */\n        /* When changing the value without replacing the item, we\n           need to update the CAS on the existing item. */\n        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);\n\n        memcpy(ITEM_data(it), buf, res);\n        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);\n    }\n\n    return OK;\n}\n\nstatic void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if(nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n\n    it = item_get(key, nkey);\n    if (it) {\n        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.slab_stats[it->slabs_clsid].delete_hits++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        item_unlink(it);\n        item_remove(it);      /* release our reference */\n        out_string(c, \"DELETED\");\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.delete_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n    }\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    level = strtoul(tokens[1].value, NULL, 10);\n    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n    out_string(c, \"OK\");\n    return;\n}\n\nstatic void process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d %s\\n\", c->sfd, command);\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        out_string(c, \"SERVER_ERROR out of memory preparing response\");\n        return;\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        process_get_command(c, tokens, ntokens, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = NREAD_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = NREAD_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = NREAD_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = NREAD_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = NREAD_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = NREAD_CAS))) {\n\n        process_update_command(c, tokens, ntokens, comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        process_get_command(c, tokens, ntokens, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        process_delete_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime = 0;\n        set_current_time();\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.flush_cmds++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        if(ntokens == (c->noreply ? 3 : 2)) {\n            settings.oldest_live = current_time - 1;\n            item_flush_expired();\n            out_string(c, \"OK\");\n            return;\n        }\n\n        exptime = strtol(tokens[1].value, NULL, 10);\n        if(errno == ERANGE) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n\n        /*\n          If exptime is zero realtime() would return zero too, and\n          realtime(exptime) - 1 would overflow to the max unsigned\n          value.  So we process exptime == 0 the same way we do when\n          no delay is given at all.\n        */\n        if (exptime > 0)\n            settings.oldest_live = realtime(exptime) - 1;\n        else /* exptime == 0 */\n            settings.oldest_live = current_time - 1;\n        item_flush_expired();\n        out_string(c, \"OK\");\n        return;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_closing);\n\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else {\n        out_string(c, \"ERROR\");\n    }\n    return;\n}\n\n/*\n * if we have a complete line in the buffer, process it.\n */\nstatic int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el)\n            return 0;\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, &c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_read += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes += res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = read(c->sfd, c->rbuf + c->rbytes, avail);\n        if (res > 0) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.bytes_read += res;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nstatic bool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n    if (event_del(&c->event) == -1) return false;\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n    if (event_add(&c->event, 0) == -1) return false;\n    return true;\n}\n\n/*\n * Sets whether we are listening for new connections or not.\n */\nvoid do_accept_new_conns(const bool do_accept) {\n    conn *next;\n\n    for (next = listen_conn; next; next = next->next) {\n        if (do_accept) {\n            update_event(next, EV_READ | EV_PERSIST);\n            if (listen(next->sfd, settings.backlog) != 0) {\n                perror(\"listen\");\n            }\n        }\n        else {\n            update_event(next, 0);\n            if (listen(next->sfd, 0) != 0) {\n                perror(\"listen\");\n            }\n        }\n    }\n\n    if (do_accept) {\n        STATS_LOCK();\n        stats.accepting_conns = true;\n        STATS_UNLOCK();\n    } else {\n        STATS_LOCK();\n        stats.accepting_conns = false;\n        stats.listen_disabled_num++;\n        STATS_UNLOCK();\n    }\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.bytes_written += res;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't update event\\n\");\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0)\n            perror(\"Failed to write, and not due to blocking\");\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}\n\nstatic void drive_machine(conn *c) {\n    bool stop = false;\n    int sfd, flags = 1;\n    socklen_t addrlen;\n    struct sockaddr_storage addr;\n    int nreqs = settings.reqs_per_event;\n    int res;\n\n    assert(c != NULL);\n\n    while (!stop) {\n\n        switch(c->state) {\n        case conn_listening:\n            addrlen = sizeof(addr);\n            if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    /* these are transient, so don't log anything */\n                    stop = true;\n                } else if (errno == EMFILE) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Too many open connections\\n\");\n                    accept_new_conns(false);\n                    stop = true;\n                } else {\n                    perror(\"accept()\");\n                    stop = true;\n                }\n                break;\n            }\n            if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n                fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n                perror(\"setting O_NONBLOCK\");\n                close(sfd);\n                break;\n            }\n\n            dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                                     DATA_BUFFER_SIZE, tcp_transport);\n            stop = true;\n            break;\n\n        case conn_waiting:\n            if (!update_event(c, EV_READ | EV_PERSIST)) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't update event\\n\");\n                conn_set_state(c, conn_closing);\n                break;\n            }\n\n            conn_set_state(c, conn_read);\n            stop = true;\n            break;\n\n        case conn_read:\n            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);\n\n            switch (res) {\n            case READ_NO_DATA_RECEIVED:\n                conn_set_state(c, conn_waiting);\n                break;\n            case READ_DATA_RECEIVED:\n                conn_set_state(c, conn_parse_cmd);\n                break;\n            case READ_ERROR:\n                conn_set_state(c, conn_closing);\n                break;\n            case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n                /* State already set by try_read_network */\n                break;\n            }\n            break;\n\n        case conn_parse_cmd :\n            if (try_read_command(c) == 0) {\n                /* wee need more data! */\n                conn_set_state(c, conn_waiting);\n            }\n\n            break;\n\n        case conn_new_cmd:\n            /* Only process nreqs at a time to avoid starving other\n               connections */\n\n            --nreqs;\n            if (nreqs >= 0) {\n                reset_cmd_handler(c);\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.conn_yields++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                if (c->rbytes > 0) {\n                    /* We have already read in data into the input buffer,\n                       so libevent will most likely not signal read events\n                       on the socket (unless more data is available. As a\n                       hack we should just put in a request to write data,\n                       because that should be possible ;-)\n                    */\n                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                        if (settings.verbose > 0)\n                            fprintf(stderr, \"Couldn't update event\\n\");\n                        conn_set_state(c, conn_closing);\n                    }\n                }\n                stop = true;\n            }\n            break;\n\n        case conn_nread:\n            if (c->rlbytes == 0) {\n                complete_nread(c);\n                break;\n            }\n            /* first check if we have leftovers in the conn_read buffer */\n            if (c->rbytes > 0) {\n                int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n                if (c->ritem != c->rcurr) {\n                    memmove(c->ritem, c->rcurr, tocopy);\n                }\n                c->ritem += tocopy;\n                c->rlbytes -= tocopy;\n                c->rcurr += tocopy;\n                c->rbytes -= tocopy;\n                if (c->rlbytes == 0) {\n                    break;\n                }\n            }\n\n            /*  now try reading from the socket */\n            res = read(c->sfd, c->ritem, c->rlbytes);\n            if (res > 0) {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.bytes_read += res;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                if (c->rcurr == c->ritem) {\n                    c->rcurr += res;\n                }\n                c->ritem += res;\n                c->rlbytes -= res;\n                break;\n            }\n            if (res == 0) { /* end of stream */\n                conn_set_state(c, conn_closing);\n                break;\n            }\n            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n                if (!update_event(c, EV_READ | EV_PERSIST)) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't update event\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                stop = true;\n                break;\n            }\n            /* otherwise we have a real error, on which we close the connection */\n            if (settings.verbose > 0) {\n                fprintf(stderr, \"Failed to read, and not due to blocking:\\n\"\n                        \"errno: %d %s \\n\"\n                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                        errno, strerror(errno),\n                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                        (int)c->rlbytes, (int)c->rsize);\n            }\n            conn_set_state(c, conn_closing);\n            break;\n\n        case conn_swallow:\n            /* we are reading sbytes and throwing them away */\n            if (c->sbytes == 0) {\n                conn_set_state(c, conn_new_cmd);\n                break;\n            }\n\n            /* first check if we have leftovers in the conn_read buffer */\n            if (c->rbytes > 0) {\n                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n                c->sbytes -= tocopy;\n                c->rcurr += tocopy;\n                c->rbytes -= tocopy;\n                break;\n            }\n\n            /*  now try reading from the socket */\n            res = read(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);\n            if (res > 0) {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.bytes_read += res;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                c->sbytes -= res;\n                break;\n            }\n            if (res == 0) { /* end of stream */\n                conn_set_state(c, conn_closing);\n                break;\n            }\n            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n                if (!update_event(c, EV_READ | EV_PERSIST)) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't update event\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                stop = true;\n                break;\n            }\n            /* otherwise we have a real error, on which we close the connection */\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Failed to read, and not due to blocking\\n\");\n            conn_set_state(c, conn_closing);\n            break;\n\n        case conn_write:\n            /*\n             * We want to write out a simple response. If we haven't already,\n             * assemble it into a msgbuf list (this will be a single-entry\n             * list for TCP or a two-entry list for UDP).\n             */\n            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {\n                if (add_iov(c, c->wcurr, c->wbytes) != 0) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't build response\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n            }\n\n            /* fall through... */\n\n        case conn_mwrite:\n          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {\n            if (settings.verbose > 0)\n              fprintf(stderr, \"Failed to build UDP headers\\n\");\n            conn_set_state(c, conn_closing);\n            break;\n          }\n            switch (transmit(c)) {\n            case TRANSMIT_COMPLETE:\n                if (c->state == conn_mwrite) {\n                    while (c->ileft > 0) {\n                        item *it = *(c->icurr);\n                        assert((it->it_flags & ITEM_SLABBED) == 0);\n                        item_remove(it);\n                        c->icurr++;\n                        c->ileft--;\n                    }\n                    while (c->suffixleft > 0) {\n                        char *suffix = *(c->suffixcurr);\n                        cache_free(c->thread->suffix_cache, suffix);\n                        c->suffixcurr++;\n                        c->suffixleft--;\n                    }\n                    /* XXX:  I don't know why this wasn't the general case */\n                    if(c->protocol == binary_prot) {\n                        conn_set_state(c, c->write_and_go);\n                    } else {\n                        conn_set_state(c, conn_new_cmd);\n                    }\n                } else if (c->state == conn_write) {\n                    if (c->write_and_free) {\n                        free(c->write_and_free);\n                        c->write_and_free = 0;\n                    }\n                    conn_set_state(c, c->write_and_go);\n                } else {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Unexpected state %d\\n\", c->state);\n                    conn_set_state(c, conn_closing);\n                }\n                break;\n\n            case TRANSMIT_INCOMPLETE:\n            case TRANSMIT_HARD_ERROR:\n                break;                   /* Continue in state machine. */\n\n            case TRANSMIT_SOFT_ERROR:\n                stop = true;\n                break;\n            }\n            break;\n\n        case conn_closing:\n            if (IS_UDP(c->transport))\n                conn_cleanup(c);\n            else\n                conn_close(c);\n            stop = true;\n            break;\n\n        case conn_max_state:\n            assert(false);\n            break;\n        }\n    }\n\n    return;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (settings.verbose > 0)\n            fprintf(stderr, \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        conn_close(c);\n        return;\n    }\n\n    drive_machine(c);\n\n    /* wait for next event */\n    return;\n}\n\nstatic int new_socket(struct addrinfo *ai) {\n    int sfd;\n    int flags;\n\n    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {\n        return -1;\n    }\n\n    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n        perror(\"setting O_NONBLOCK\");\n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {\n        if (settings.verbose > 0)\n            perror(\"getsockopt(SO_SNDBUF)\");\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n}\n\n/**\n * Create a socket and bind it to a specific port number\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(int port, enum network_transport transport,\n                         FILE *portnumber_file) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(settings.inter, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM)\n          fprintf(stderr, \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        else\n          perror(\"getaddrinfo()\");\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == -1) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                perror(\"setsockopt\");\n                close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {\n            if (errno != EADDRINUSE) {\n                perror(\"bind()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {\n                perror(\"listen()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base))) {\n                fprintf(stderr, \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n    int flags;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n        perror(\"socket()\");\n        return -1;\n    }\n\n    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n        perror(\"setting O_NONBLOCK\");\n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        perror(\"bind()\");\n        close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        perror(\"listen()\");\n        close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base))) {\n        fprintf(stderr, \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\nstatic struct event clockevent;\n\n/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\nstatic void set_current_time(void) {\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - process_started);\n}\n\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n    set_current_time();\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p <num>      TCP port number to listen on (default: 11211)\\n\"\n           \"-U <num>      UDP port number to listen on (default: 11211, 0 is off)\\n\"\n           \"-s <file>     UNIX socket path to listen on (disables network support)\\n\"\n           \"-a <mask>     access mask for UNIX socket, in octal (default: 0700)\\n\"\n           \"-l <ip_addr>  interface to listen on (default: INADDR_ANY, all addresses)\\n\"\n           \"-d            run as a daemon\\n\"\n           \"-r            maximize core file limit\\n\"\n           \"-u <username> assume identity of <username> (only when run as root)\\n\"\n           \"-m <num>      max memory to use for items in megabytes (default: 64 MB)\\n\"\n           \"-M            return error on memory exhausted (rather than removing items)\\n\"\n           \"-c <num>      max simultaneous connections (default: 1024)\\n\"\n           \"-k            lock down all paged memory.  Note that there is a\\n\"\n           \"              limit on how much memory you may lock.  Trying to\\n\"\n           \"              allocate more than that would fail, so be sure you\\n\"\n           \"              set the limit correctly for the user you started\\n\"\n           \"              the daemon with (not for -u <username> user;\\n\"\n           \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"\n           \"-v            verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv           very verbose (also print client commands/reponses)\\n\"\n           \"-vvv          extremely verbose (also print internal state transitions)\\n\"\n           \"-h            print this help and exit\\n\"\n           \"-i            print memcached and libevent license\\n\"\n           \"-P <file>     save PID in <file>, only used with -d option\\n\"\n           \"-f <factor>   chunk size growth factor (default: 1.25)\\n\"\n           \"-n <bytes>    minimum space allocated for key+value+flags (default: 48)\\n\");\n    printf(\"-L            Try to use large memory pages (if available). Increasing\\n\"\n           \"              the memory page size could reduce the number of TLB misses\\n\"\n           \"              and improve the performance. In order to get large pages\\n\"\n           \"              from the OS, memcached will allocate the total item-cache\\n\"\n           \"              in one large chunk.\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\":\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\");\n    printf(\"-t <num>      number of threads to use (default: 4)\\n\");\n    printf(\"-R            Maximum number of requests per event, limits the number of\\n\"\n           \"              requests process for a given connection to prevent \\n\"\n           \"              starvation (default: 20)\\n\");\n    printf(\"-C            Disable use of CAS\\n\");\n    printf(\"-b            Set the backlog queue limit (default: 1024)\\n\");\n    printf(\"-B            Binding protocol - one of ascii, binary, or auto (default)\\n\");\n    printf(\"-I            Override the size of each slab page. Adjusts max item size\\n\"\n           \"              (default: 1mb, min: 1k, max: 128m)\\n\");\n#ifdef ENABLE_SASL\n    printf(\"-S            Turn on Sasl authentication\\n\");\n#endif\n    return;\n}\n\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const pid_t pid, const char *pid_file) {\n    FILE *fp;\n    if (pid_file == NULL)\n        return;\n\n    if ((fp = fopen(pid_file, \"w\")) == NULL) {\n        fprintf(stderr, \"Could not open the pid file %s for writing\\n\", pid_file);\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)pid);\n    if (fclose(fp) == -1) {\n        fprintf(stderr, \"Could not close the pid file %s.\\n\", pid_file);\n        return;\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n  if (pid_file == NULL)\n      return;\n\n  if (unlink(pid_file) != 0) {\n      fprintf(stderr, \"Could not remove the pid file %s.\\n\", pid_file);\n  }\n\n}\n\nstatic void sig_handler(const int sig) {\n    printf(\"SIGINT handled.\\n\");\n    exit(EXIT_SUCCESS);\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif\n\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            fprintf(stderr, \"Failed to set large pages: %s\\n\",\n                    strerror(errno));\n            fprintf(stderr, \"Will use default page size\\n\");\n        } else {\n            ret = 0;\n        }\n    } else {\n        fprintf(stderr, \"Failed to get supported pagesizes: %s\\n\",\n                strerror(errno));\n        fprintf(stderr, \"Will use default page size\\n\");\n    }\n\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nint main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char unit = '\\0';\n    int size_max = 0;\n    /* listening sockets */\n    static int *l_socket = NULL;\n\n    /* udp socket */\n    static int *u_socket = NULL;\n    bool protocol_specified = false;\n\n    /* handle SIGINT */\n    signal(SIGINT, sig_handler);\n\n    /* init settings */\n    settings_init();\n\n    /* set stderr non-buffering (for running under, say, daemontools) */\n    setbuf(stderr, NULL);\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  /* access mask for unix socket */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hi\"  /* help, licence info */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n        ))) {\n        switch (c) {\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n            break;\n        case 'M':\n            settings.evict_to_free = 0;\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            break;\n        case 'l':\n            settings.inter= strdup(optarg);\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event == 0) {\n                fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                fprintf(stderr, \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n            break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                fprintf(stderr, \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                fprintf(stderr, \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                fprintf(stderr, \"WARNING: Setting a high number of worker\"\n                                \"threads is not recommended.\\n\"\n                                \" Set this value to the number of cores in\"\n                                \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            if (! optarg || ! optarg[0]) {\n                fprintf(stderr, \"No delimiter specified\\n\");\n                return 1;\n            }\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                fprintf(stderr, \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            unit = optarg[strlen(optarg)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                optarg[strlen(optarg)-1] = '\\0';\n                size_max = atoi(optarg);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(optarg);\n            }\n            if (settings.item_size_max < 1024) {\n                fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                fprintf(stderr, \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                fprintf(stderr, \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef ENABLE_SASL\n            fprintf(stderr, \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.sasl = true;\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    if (settings.sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol != binary_prot) {\n                fprintf(stderr, \"WARNING: You shouldn't allow the ASCII protocol while using SASL\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            fprintf(stderr, \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        fprintf(stderr, \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        int maxfiles = settings.maxconns;\n        if (rlim.rlim_cur < maxfiles)\n            rlim.rlim_cur = maxfiles;\n        if (rlim.rlim_max < rlim.rlim_cur)\n            rlim.rlim_max = rlim.rlim_cur;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            fprintf(stderr, \"failed to set rlimit for open files. Try running as root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            fprintf(stderr, \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            fprintf(stderr, \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            fprintf(stderr, \"failed to assume identity of user %s\\n\", username);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* Initialize Sasl if -S was specified */\n    if (settings.sasl) {\n        init_sasl();\n    }\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            perror(\"Failed to ignore SIGHUP\");\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n            fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            fprintf(stderr, \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n    main_base = event_init();\n\n    /* initialize other stuff */\n    stats_init();\n    assoc_init();\n    conn_init();\n    slabs_init(settings.maxbytes, settings.factor, preallocate);\n\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        perror(\"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n    /* start up worker threads if MT mode */\n    thread_init(settings.num_threads, main_base);\n    /* save the PID in if we're a daemon, do this after thread_init due to\n       a file descriptor handling bug somewhere in libevent */\n\n    if (start_assoc_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    if (do_daemonize)\n        save_pid(getpid(), pid_file);\n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        errno = 0;\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char temp_portnumber_filename[PATH_MAX];\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            snprintf(temp_portnumber_filename,\n                     sizeof(temp_portnumber_filename),\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        errno = 0;\n        if (settings.port && server_socket(settings.port, tcp_transport,\n                                           portnumber_file)) {\n            vperror(\"failed to listen on TCP port %d\", settings.port);\n            exit(EX_OSERR);\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        errno = 0;\n        if (settings.udpport && server_socket(settings.udpport, udp_transport,\n                                              portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n    }\n\n    /* Drop privileges no longer needed */\n    drop_privileges();\n\n    /* enter the event loop */\n    event_base_loop(main_base, 0);\n\n    stop_assoc_maintenance_thread();\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n    if (l_socket)\n      free(l_socket);\n    if (u_socket)\n      free(u_socket);\n\n    return EXIT_SUCCESS;\n}\n", "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#undef NDEBUG\n#include <pthread.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <fcntl.h>\n\n#include \"protocol_binary.h\"\n#include \"config.h\"\n#include \"cache.h\"\n#include \"util.h\"\n\n#define TMP_TEMPLATE \"/tmp/test_file.XXXXXXX\"\n\nenum test_return { TEST_SKIP, TEST_PASS, TEST_FAIL };\n\nstatic pid_t server_pid;\nstatic in_port_t port;\nstatic int sock;\nstatic bool allow_closed_read = false;\n\nstatic enum test_return cache_create_test(void)\n{\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, NULL);\n    assert(cache != NULL);\n    cache_destroy(cache);\n    return TEST_PASS;\n}\n\nconst uint64_t constructor_pattern = 0xdeadcafebabebeef;\n\nstatic int cache_constructor(void *buffer, void *notused1, int notused2) {\n    uint64_t *ptr = buffer;\n    *ptr = constructor_pattern;\n    return 0;\n}\n\nstatic enum test_return cache_constructor_test(void)\n{\n    cache_t *cache = cache_create(\"test\", sizeof(uint64_t), sizeof(uint64_t),\n                                  cache_constructor, NULL);\n    assert(cache != NULL);\n    uint64_t *ptr = cache_alloc(cache);\n    uint64_t pattern = *ptr;\n    cache_free(cache, ptr);\n    cache_destroy(cache);\n    return (pattern == constructor_pattern) ? TEST_PASS : TEST_FAIL;\n}\n\nstatic int cache_fail_constructor(void *buffer, void *notused1, int notused2) {\n    return 1;\n}\n\nstatic enum test_return cache_fail_constructor_test(void)\n{\n    enum test_return ret = TEST_PASS;\n\n    cache_t *cache = cache_create(\"test\", sizeof(uint64_t), sizeof(uint64_t),\n                                  cache_fail_constructor, NULL);\n    assert(cache != NULL);\n    uint64_t *ptr = cache_alloc(cache);\n    if (ptr != NULL) {\n        ret = TEST_FAIL;\n    }\n    cache_destroy(cache);\n    return ret;\n}\n\nstatic void *destruct_data = 0;\n\nstatic void cache_destructor(void *buffer, void *notused) {\n    destruct_data = buffer;\n}\n\nstatic enum test_return cache_destructor_test(void)\n{\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, cache_destructor);\n    assert(cache != NULL);\n    char *ptr = cache_alloc(cache);\n    cache_free(cache, ptr);\n    cache_destroy(cache);\n\n    return (ptr == destruct_data) ? TEST_PASS : TEST_FAIL;\n}\n\nstatic enum test_return cache_reuse_test(void)\n{\n    int ii;\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, NULL);\n    char *ptr = cache_alloc(cache);\n    cache_free(cache, ptr);\n    for (ii = 0; ii < 100; ++ii) {\n        char *p = cache_alloc(cache);\n        assert(p == ptr);\n        cache_free(cache, ptr);\n    }\n    cache_destroy(cache);\n    return TEST_PASS;\n}\n\nstatic enum test_return cache_redzone_test(void)\n{\n#ifndef HAVE_UMEM_H\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, NULL);\n\n    /* Ignore SIGABORT */\n    struct sigaction old_action;\n    struct sigaction action = { .sa_handler = SIG_IGN, .sa_flags = 0};\n    sigemptyset(&action.sa_mask);\n    sigaction(SIGABRT, &action, &old_action);\n\n    /* check memory debug.. */\n    char *p = cache_alloc(cache);\n    char old = *(p - 1);\n    *(p - 1) = 0;\n    cache_free(cache, p);\n    assert(cache_error == -1);\n    *(p - 1) = old;\n\n    p[sizeof(uint32_t)] = 0;\n    cache_free(cache, p);\n    assert(cache_error == 1);\n\n    /* restore signal handler */\n    sigaction(SIGABRT, &old_action, NULL);\n\n    cache_destroy(cache);\n\n    return TEST_PASS;\n#else\n    return TEST_SKIP;\n#endif\n}\n\nstatic enum test_return test_safe_strtoul(void) {\n    uint32_t val;\n    assert(safe_strtoul(\"123\", &val));\n    assert(val == 123);\n    assert(safe_strtoul(\"+123\", &val));\n    assert(val == 123);\n    assert(!safe_strtoul(\"\", &val));  // empty\n    assert(!safe_strtoul(\"123BOGUS\", &val));  // non-numeric\n    /* Not sure what it does, but this works with ICC :/\n       assert(!safe_strtoul(\"92837498237498237498029383\", &val)); // out of range\n    */\n\n    // extremes:\n    assert(safe_strtoul(\"4294967295\", &val)); // 2**32 - 1\n    assert(val == 4294967295L);\n    /* This actually works on 64-bit ubuntu\n       assert(!safe_strtoul(\"4294967296\", &val)); // 2**32\n    */\n    assert(!safe_strtoul(\"-1\", &val));  // negative\n    return TEST_PASS;\n}\n\n\nstatic enum test_return test_safe_strtoull(void) {\n    uint64_t val;\n    assert(safe_strtoull(\"123\", &val));\n    assert(val == 123);\n    assert(safe_strtoull(\"+123\", &val));\n    assert(val == 123);\n    assert(!safe_strtoull(\"\", &val));  // empty\n    assert(!safe_strtoull(\"123BOGUS\", &val));  // non-numeric\n    assert(!safe_strtoull(\"92837498237498237498029383\", &val)); // out of range\n\n    // extremes:\n    assert(safe_strtoull(\"18446744073709551615\", &val)); // 2**64 - 1\n    assert(val == 18446744073709551615ULL);\n    assert(!safe_strtoull(\"18446744073709551616\", &val)); // 2**64\n    assert(!safe_strtoull(\"-1\", &val));  // negative\n    return TEST_PASS;\n}\n\nstatic enum test_return test_safe_strtoll(void) {\n    int64_t val;\n    assert(safe_strtoll(\"123\", &val));\n    assert(val == 123);\n    assert(safe_strtoll(\"+123\", &val));\n    assert(val == 123);\n    assert(safe_strtoll(\"-123\", &val));\n    assert(val == -123);\n    assert(!safe_strtoll(\"\", &val));  // empty\n    assert(!safe_strtoll(\"123BOGUS\", &val));  // non-numeric\n    assert(!safe_strtoll(\"92837498237498237498029383\", &val)); // out of range\n\n    // extremes:\n    assert(!safe_strtoll(\"18446744073709551615\", &val)); // 2**64 - 1\n    assert(safe_strtoll(\"9223372036854775807\", &val)); // 2**63 - 1\n    assert(val == 9223372036854775807LL);\n    /*\n      assert(safe_strtoll(\"-9223372036854775808\", &val)); // -2**63\n      assert(val == -9223372036854775808LL);\n    */\n    assert(!safe_strtoll(\"-9223372036854775809\", &val)); // -2**63 - 1\n\n    // We'll allow space to terminate the string.  And leading space.\n    assert(safe_strtoll(\" 123 foo\", &val));\n    assert(val == 123);\n    return TEST_PASS;\n}\n\nstatic enum test_return test_safe_strtol(void) {\n    int32_t val;\n    assert(safe_strtol(\"123\", &val));\n    assert(val == 123);\n    assert(safe_strtol(\"+123\", &val));\n    assert(val == 123);\n    assert(safe_strtol(\"-123\", &val));\n    assert(val == -123);\n    assert(!safe_strtol(\"\", &val));  // empty\n    assert(!safe_strtol(\"123BOGUS\", &val));  // non-numeric\n    assert(!safe_strtol(\"92837498237498237498029383\", &val)); // out of range\n\n    // extremes:\n    /* This actually works on 64-bit ubuntu\n       assert(!safe_strtol(\"2147483648\", &val)); // (expt 2.0 31.0)\n    */\n    assert(safe_strtol(\"2147483647\", &val)); // (- (expt 2.0 31) 1)\n    assert(val == 2147483647L);\n    /* This actually works on 64-bit ubuntu\n       assert(!safe_strtol(\"-2147483649\", &val)); // (- (expt -2.0 31) 1)\n    */\n\n    // We'll allow space to terminate the string.  And leading space.\n    assert(safe_strtol(\" 123 foo\", &val));\n    assert(val == 123);\n    return TEST_PASS;\n}\n\n/**\n * Function to start the server and let it listen on a random port\n *\n * @param port_out where to store the TCP port number the server is\n *                 listening on\n * @param daemon set to true if you want to run the memcached server\n *               as a daemon process\n * @return the pid of the memcached server\n */\nstatic pid_t start_server(in_port_t *port_out, bool daemon, int timeout) {\n    char environment[80];\n    snprintf(environment, sizeof(environment),\n             \"MEMCACHED_PORT_FILENAME=/tmp/ports.%lu\", (long)getpid());\n    char *filename= environment + strlen(\"MEMCACHED_PORT_FILENAME=\");\n    char pid_file[80];\n    snprintf(pid_file, sizeof(pid_file), \"/tmp/pid.%lu\", (long)getpid());\n\n    remove(filename);\n    remove(pid_file);\n\n#ifdef __sun\n    /* I want to name the corefiles differently so that they don't\n       overwrite each other\n    */\n    char coreadm[128];\n    sprintf(coreadm, \"coreadm -p core.%%f.%%p %lu\", (unsigned long)getpid());\n    system(coreadm);\n#endif\n\n    pid_t pid = fork();\n    assert(pid != -1);\n\n    if (pid == 0) {\n        /* Child */\n        char *argv[20];\n        int arg = 0;\n        char tmo[24];\n        snprintf(tmo, sizeof(tmo), \"%u\", timeout);\n\n        putenv(environment);\n#ifdef __sun\n        putenv(\"LD_PRELOAD=watchmalloc.so.1\");\n        putenv(\"MALLOC_DEBUG=WATCH\");\n#endif\n\n        if (!daemon) {\n            argv[arg++] = \"./timedrun\";\n            argv[arg++] = tmo;\n        }\n        argv[arg++] = \"./memcached-debug\";\n        argv[arg++] = \"-p\";\n        argv[arg++] = \"-1\";\n        argv[arg++] = \"-U\";\n        argv[arg++] = \"0\";\n        /* Handle rpmbuild and the like doing this as root */\n        if (getuid() == 0) {\n            argv[arg++] = \"-u\";\n            argv[arg++] = \"root\";\n        }\n        if (daemon) {\n            argv[arg++] = \"-d\";\n            argv[arg++] = \"-P\";\n            argv[arg++] = pid_file;\n        }\n#ifdef MESSAGE_DEBUG\n         argv[arg++] = \"-vvv\";\n#endif\n        argv[arg++] = NULL;\n        assert(execv(argv[0], argv) != -1);\n    }\n\n    /* Yeah just let us \"busy-wait\" for the file to be created ;-) */\n    while (access(filename, F_OK) == -1) {\n        usleep(10);\n    }\n\n    FILE *fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        fprintf(stderr, \"Failed to open the file containing port numbers: %s\\n\",\n                strerror(errno));\n        assert(false);\n    }\n\n    *port_out = (in_port_t)-1;\n    char buffer[80];\n    while ((fgets(buffer, sizeof(buffer), fp)) != NULL) {\n        if (strncmp(buffer, \"TCP INET: \", 10) == 0) {\n            int32_t val;\n            assert(safe_strtol(buffer + 10, &val));\n            *port_out = (in_port_t)val;\n        }\n    }\n    fclose(fp);\n    assert(remove(filename) == 0);\n\n    if (daemon) {\n        /* loop and wait for the pid file.. There is a potential race\n         * condition that the server just created the file but isn't\n         * finished writing the content, but I'll take the chance....\n         */\n        while (access(pid_file, F_OK) == -1) {\n            usleep(10);\n        }\n\n        fp = fopen(pid_file, \"r\");\n        if (fp == NULL) {\n            fprintf(stderr, \"Failed to open pid file: %s\\n\",\n                    strerror(errno));\n            assert(false);\n        }\n        assert(fgets(buffer, sizeof(buffer), fp) != NULL);\n        fclose(fp);\n\n        int32_t val;\n        assert(safe_strtol(buffer, &val));\n        pid = (pid_t)val;\n    }\n\n    return pid;\n}\n\nstatic enum test_return test_issue_44(void) {\n    in_port_t port;\n    pid_t pid = start_server(&port, true, 15);\n    assert(kill(pid, SIGHUP) == 0);\n    sleep(1);\n    assert(kill(pid, SIGTERM) == 0);\n\n    return TEST_PASS;\n}\n\nstatic struct addrinfo *lookuphost(const char *hostname, in_port_t port)\n{\n    struct addrinfo *ai = 0;\n    struct addrinfo hints = { .ai_family = AF_UNSPEC,\n                              .ai_protocol = IPPROTO_TCP,\n                              .ai_socktype = SOCK_STREAM };\n    char service[NI_MAXSERV];\n    int error;\n\n    (void)snprintf(service, NI_MAXSERV, \"%d\", port);\n    if ((error = getaddrinfo(hostname, service, &hints, &ai)) != 0) {\n       if (error != EAI_SYSTEM) {\n          fprintf(stderr, \"getaddrinfo(): %s\\n\", gai_strerror(error));\n       } else {\n          perror(\"getaddrinfo()\");\n       }\n    }\n\n    return ai;\n}\n\nstatic int connect_server(const char *hostname, in_port_t port, bool nonblock)\n{\n    struct addrinfo *ai = lookuphost(hostname, port);\n    int sock = -1;\n    if (ai != NULL) {\n       if ((sock = socket(ai->ai_family, ai->ai_socktype,\n                          ai->ai_protocol)) != -1) {\n          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {\n             fprintf(stderr, \"Failed to connect socket: %s\\n\",\n                     strerror(errno));\n             close(sock);\n             sock = -1;\n          } else if (nonblock) {\n              int flags = fcntl(sock, F_GETFL, 0);\n              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {\n                  fprintf(stderr, \"Failed to enable nonblocking mode: %s\\n\",\n                          strerror(errno));\n                  close(sock);\n                  sock = -1;\n              }\n          }\n       } else {\n          fprintf(stderr, \"Failed to create socket: %s\\n\", strerror(errno));\n       }\n\n       freeaddrinfo(ai);\n    }\n    return sock;\n}\n\nstatic enum test_return test_vperror(void) {\n    int rv = 0;\n    int oldstderr = dup(STDERR_FILENO);\n    char tmpl[sizeof(TMP_TEMPLATE)+1];\n    strncpy(tmpl, TMP_TEMPLATE, sizeof(TMP_TEMPLATE)+1);\n\n    int newfile = mkstemp(tmpl);\n    assert(newfile > 0);\n    rv = dup2(newfile, STDERR_FILENO);\n    assert(rv == STDERR_FILENO);\n    rv = close(newfile);\n    assert(rv == 0);\n\n    errno = EIO;\n    vperror(\"Old McDonald had a farm.  %s\", \"EI EIO\");\n\n    /* Restore stderr */\n    rv = dup2(oldstderr, STDERR_FILENO);\n    assert(rv == STDERR_FILENO);\n\n\n    /* Go read the file */\n    char buf[80] = { 0 };\n    FILE *efile = fopen(tmpl, \"r\");\n    assert(efile);\n    char *prv = fgets(buf, sizeof(buf), efile);\n    assert(prv);\n    fclose(efile);\n\n    unlink(tmpl);\n\n    char expected[80] = { 0 };\n    snprintf(expected, sizeof(expected),\n             \"Old McDonald had a farm.  EI EIO: %s\\n\", strerror(EIO));\n\n    /*\n    fprintf(stderr,\n            \"\\nExpected:  ``%s''\"\n            \"\\nGot:       ``%s''\\n\", expected, buf);\n    */\n\n    return strcmp(expected, buf) == 0 ? TEST_PASS : TEST_FAIL;\n}\n\nstatic void send_ascii_command(const char *buf) {\n    off_t offset = 0;\n    const char* ptr = buf;\n    size_t len = strlen(buf);\n\n    do {\n        ssize_t nw = write(sock, ptr + offset, len - offset);\n        if (nw == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to write: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            offset += nw;\n        }\n    } while (offset < len);\n}\n\n/*\n * This is a dead slow single byte read, but it should only read out\n * _one_ response and I don't have an input buffer... The current\n * implementation only supports single-line responses, so if you want to use\n * it for get commands you need to implement that first ;-)\n */\nstatic void read_ascii_response(char *buffer, size_t size) {\n    off_t offset = 0;\n    bool need_more = true;\n    do {\n        ssize_t nr = read(sock, buffer + offset, 1);\n        if (nr == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to read: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            assert(nr == 1);\n            if (buffer[offset] == '\\n') {\n                need_more = false;\n                buffer[offset + 1] = '\\0';\n            }\n            offset += nr;\n            assert(offset + 1 < size);\n        }\n    } while (need_more);\n}\n\nstatic enum test_return test_issue_92(void) {\n    char buffer[1024];\n\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n\n    send_ascii_command(\"stats cachedump 1 0 0\\r\\n\");\n    read_ascii_response(buffer, sizeof(buffer));\n    assert(strncmp(buffer, \"END\", strlen(\"END\")) == 0);\n\n    send_ascii_command(\"stats cachedump 200 0 0\\r\\n\");\n    read_ascii_response(buffer, sizeof(buffer));\n    assert(strncmp(buffer, \"CLIENT_ERROR\", strlen(\"CLIENT_ERROR\")) == 0);\n\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n    return TEST_PASS;\n}\n\nstatic enum test_return start_memcached_server(void) {\n    server_pid = start_server(&port, false, 600);\n    sock = connect_server(\"127.0.0.1\", port, false);\n    return TEST_PASS;\n}\n\nstatic enum test_return stop_memcached_server(void) {\n    close(sock);\n    assert(kill(server_pid, SIGTERM) == 0);\n    return TEST_PASS;\n}\n\nstatic void safe_send(const void* buf, size_t len, bool hickup)\n{\n    off_t offset = 0;\n    const char* ptr = buf;\n#ifdef MESSAGE_DEBUG\n    uint8_t val = *ptr;\n    assert(val == (uint8_t)0x80);\n    fprintf(stderr, \"About to send %lu bytes:\", (unsigned long)len);\n    for (int ii = 0; ii < len; ++ii) {\n        if (ii % 4 == 0) {\n            fprintf(stderr, \"\\n   \");\n        }\n        val = *(ptr + ii);\n        fprintf(stderr, \" 0x%02x\", val);\n    }\n    fprintf(stderr, \"\\n\");\n    usleep(500);\n#endif\n\n    do {\n        size_t num_bytes = len - offset;\n        if (hickup) {\n            if (num_bytes > 1024) {\n                num_bytes = (rand() % 1023) + 1;\n            }\n        }\n\n        ssize_t nw = write(sock, ptr + offset, num_bytes);\n        if (nw == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to write: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            if (hickup) {\n                usleep(100);\n            }\n            offset += nw;\n        }\n    } while (offset < len);\n}\n\nstatic bool safe_recv(void *buf, size_t len) {\n    if (len == 0) {\n        return true;\n    }\n    off_t offset = 0;\n    do {\n        ssize_t nr = read(sock, ((char*)buf) + offset, len - offset);\n        if (nr == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to read: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            if (nr == 0 && allow_closed_read) {\n                return false;\n            }\n            assert(nr != 0);\n            offset += nr;\n        }\n    } while (offset < len);\n\n    return true;\n}\n\nstatic bool safe_recv_packet(void *buf, size_t size) {\n    protocol_binary_response_no_extras *response = buf;\n    assert(size > sizeof(*response));\n    if (!safe_recv(response, sizeof(*response))) {\n        return false;\n    }\n    response->message.header.response.keylen = ntohs(response->message.header.response.keylen);\n    response->message.header.response.status = ntohs(response->message.header.response.status);\n    response->message.header.response.bodylen = ntohl(response->message.header.response.bodylen);\n\n    size_t len = sizeof(*response);\n\n    char *ptr = buf;\n    ptr += len;\n    if (!safe_recv(ptr, response->message.header.response.bodylen)) {\n        return false;\n    }\n\n#ifdef MESSAGE_DEBUG\n    usleep(500);\n    ptr = buf;\n    len += response->message.header.response.bodylen;\n    uint8_t val = *ptr;\n    assert(val == (uint8_t)0x81);\n    fprintf(stderr, \"Received %lu bytes:\", (unsigned long)len);\n    for (int ii = 0; ii < len; ++ii) {\n        if (ii % 4 == 0) {\n            fprintf(stderr, \"\\n   \");\n        }\n        val = *(ptr + ii);\n        fprintf(stderr, \" 0x%02x\", val);\n    }\n    fprintf(stderr, \"\\n\");\n#endif\n    return true;\n}\n\nstatic off_t storage_command(char*buf,\n                             size_t bufsz,\n                             uint8_t cmd,\n                             const void* key,\n                             size_t keylen,\n                             const void* dta,\n                             size_t dtalen,\n                             uint32_t flags,\n                             uint32_t exp) {\n    /* all of the storage commands use the same command layout */\n    protocol_binary_request_set *request = (void*)buf;\n    assert(bufsz > sizeof(*request) + keylen + dtalen);\n\n    memset(request, 0, sizeof(*request));\n    request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n    request->message.header.request.opcode = cmd;\n    request->message.header.request.keylen = htons(keylen);\n    request->message.header.request.extlen = 8;\n    request->message.header.request.bodylen = htonl(keylen + 8 + dtalen);\n    request->message.header.request.opaque = 0xdeadbeef;\n    request->message.body.flags = flags;\n    request->message.body.expiration = exp;\n\n    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n\n    memcpy(buf + key_offset, key, keylen);\n    if (dta != NULL) {\n        memcpy(buf + key_offset + keylen, dta, dtalen);\n    }\n\n    return key_offset + keylen + dtalen;\n}\n\nstatic off_t raw_command(char* buf,\n                         size_t bufsz,\n                         uint8_t cmd,\n                         const void* key,\n                         size_t keylen,\n                         const void* dta,\n                         size_t dtalen) {\n    /* all of the storage commands use the same command layout */\n    protocol_binary_request_no_extras *request = (void*)buf;\n    assert(bufsz > sizeof(*request) + keylen + dtalen);\n\n    memset(request, 0, sizeof(*request));\n    request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n    request->message.header.request.opcode = cmd;\n    request->message.header.request.keylen = htons(keylen);\n    request->message.header.request.bodylen = htonl(keylen + dtalen);\n    request->message.header.request.opaque = 0xdeadbeef;\n\n    off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n    if (key != NULL) {\n        memcpy(buf + key_offset, key, keylen);\n    }\n    if (dta != NULL) {\n        memcpy(buf + key_offset + keylen, dta, dtalen);\n    }\n\n    return sizeof(*request) + keylen + dtalen;\n}\n\nstatic off_t flush_command(char* buf, size_t bufsz, uint8_t cmd, uint32_t exptime, bool use_extra) {\n    protocol_binary_request_flush *request = (void*)buf;\n    assert(bufsz > sizeof(*request));\n\n    memset(request, 0, sizeof(*request));\n    request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n    request->message.header.request.opcode = cmd;\n\n    off_t size = sizeof(protocol_binary_request_no_extras);\n    if (use_extra) {\n        request->message.header.request.extlen = 4;\n        request->message.body.expiration = htonl(exptime);\n        request->message.header.request.bodylen = htonl(4);\n        size += 4;\n    }\n\n    request->message.header.request.opaque = 0xdeadbeef;\n\n    return size;\n}\n\nstatic off_t arithmetic_command(char* buf,\n                                size_t bufsz,\n                                uint8_t cmd,\n                                const void* key,\n                                size_t keylen,\n                                uint64_t delta,\n                                uint64_t initial,\n                                uint32_t exp) {\n    protocol_binary_request_incr *request = (void*)buf;\n    assert(bufsz > sizeof(*request) + keylen);\n\n    memset(request, 0, sizeof(*request));\n    request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n    request->message.header.request.opcode = cmd;\n    request->message.header.request.keylen = htons(keylen);\n    request->message.header.request.extlen = 20;\n    request->message.header.request.bodylen = htonl(keylen + 20);\n    request->message.header.request.opaque = 0xdeadbeef;\n    request->message.body.delta = htonll(delta);\n    request->message.body.initial = htonll(initial);\n    request->message.body.expiration = htonl(exp);\n\n    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;\n\n    memcpy(buf + key_offset, key, keylen);\n    return key_offset + keylen;\n}\n\nstatic void validate_response_header(protocol_binary_response_no_extras *response,\n                                     uint8_t cmd, uint16_t status)\n{\n    assert(response->message.header.response.magic == PROTOCOL_BINARY_RES);\n    assert(response->message.header.response.opcode == cmd);\n    assert(response->message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n    assert(response->message.header.response.status == status);\n    assert(response->message.header.response.opaque == 0xdeadbeef);\n\n    if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n        switch (cmd) {\n        case PROTOCOL_BINARY_CMD_ADDQ:\n        case PROTOCOL_BINARY_CMD_APPENDQ:\n        case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        case PROTOCOL_BINARY_CMD_DELETEQ:\n        case PROTOCOL_BINARY_CMD_FLUSHQ:\n        case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        case PROTOCOL_BINARY_CMD_PREPENDQ:\n        case PROTOCOL_BINARY_CMD_QUITQ:\n        case PROTOCOL_BINARY_CMD_REPLACEQ:\n        case PROTOCOL_BINARY_CMD_SETQ:\n            assert(\"Quiet command shouldn't return on success\" == NULL);\n        default:\n            break;\n        }\n\n        switch (cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n        case PROTOCOL_BINARY_CMD_REPLACE:\n        case PROTOCOL_BINARY_CMD_SET:\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 0);\n            assert(response->message.header.response.bodylen == 0);\n            assert(response->message.header.response.cas != 0);\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n        case PROTOCOL_BINARY_CMD_NOOP:\n        case PROTOCOL_BINARY_CMD_QUIT:\n        case PROTOCOL_BINARY_CMD_DELETE:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 0);\n            assert(response->message.header.response.bodylen == 0);\n            assert(response->message.header.response.cas == 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 0);\n            assert(response->message.header.response.bodylen == 8);\n            assert(response->message.header.response.cas != 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_STAT:\n            assert(response->message.header.response.extlen == 0);\n            /* key and value exists in all packets except in the terminating */\n            assert(response->message.header.response.cas == 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_VERSION:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 0);\n            assert(response->message.header.response.bodylen != 0);\n            assert(response->message.header.response.cas == 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_GET:\n        case PROTOCOL_BINARY_CMD_GETQ:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 4);\n            assert(response->message.header.response.cas != 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_GETK:\n        case PROTOCOL_BINARY_CMD_GETKQ:\n            assert(response->message.header.response.keylen != 0);\n            assert(response->message.header.response.extlen == 4);\n            assert(response->message.header.response.cas != 0);\n            break;\n\n        default:\n            /* Undefined command code */\n            break;\n        }\n    } else {\n        assert(response->message.header.response.cas == 0);\n        assert(response->message.header.response.extlen == 0);\n        if (cmd != PROTOCOL_BINARY_CMD_GETK) {\n            assert(response->message.header.response.keylen == 0);\n        }\n    }\n}\n\nstatic enum test_return test_binary_noop(void) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } buffer;\n\n    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                             PROTOCOL_BINARY_CMD_NOOP,\n                             NULL, 0, NULL, 0);\n\n    safe_send(buffer.bytes, len, false);\n    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_NOOP,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_quit_impl(uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } buffer;\n    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                             cmd, NULL, 0, NULL, 0);\n\n    safe_send(buffer.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_QUIT) {\n        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_QUIT,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    /* Socket should be closed now, read should return 0 */\n    assert(read(sock, buffer.bytes, sizeof(buffer.bytes)) == 0);\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_quit(void) {\n    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUIT);\n}\n\nstatic enum test_return test_binary_quitq(void) {\n    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUITQ);\n}\n\nstatic enum test_return test_binary_set_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    uint64_t value = 0xdeadbeefdeadcafe;\n    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,\n                                 key, strlen(key), &value, sizeof(value),\n                                 0, 0);\n\n    /* Set should work over and over again */\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_SET) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        }\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_SETQ) {\n        return test_binary_noop();\n    }\n\n    send.request.message.header.request.cas = receive.response.message.header.response.cas;\n    safe_send(send.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_SET) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        assert(receive.response.message.header.response.cas != send.request.message.header.request.cas);\n    } else {\n        return test_binary_noop();\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_set(void) {\n    return test_binary_set_impl(\"test_binary_set\", PROTOCOL_BINARY_CMD_SET);\n}\n\nstatic enum test_return test_binary_setq(void) {\n    return test_binary_set_impl(\"test_binary_setq\", PROTOCOL_BINARY_CMD_SETQ);\n}\n\n\nstatic enum test_return test_binary_add_impl(const char *key, uint8_t cmd) {\n    uint64_t value = 0xdeadbeefdeadcafe;\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd, key,\n                                 strlen(key), &value, sizeof(value),\n                                 0, 0);\n\n    /* Add should only work the first time */\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (ii == 0) {\n            if (cmd == PROTOCOL_BINARY_CMD_ADD) {\n                safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n                validate_response_header(&receive.response, cmd,\n                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);\n            }\n        } else {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS);\n        }\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_add(void) {\n    return test_binary_add_impl(\"test_binary_add\", PROTOCOL_BINARY_CMD_ADD);\n}\n\nstatic enum test_return test_binary_addq(void) {\n    return test_binary_add_impl(\"test_binary_addq\", PROTOCOL_BINARY_CMD_ADDQ);\n}\n\nstatic enum test_return test_binary_replace_impl(const char* key, uint8_t cmd) {\n    uint64_t value = 0xdeadbeefdeadcafe;\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,\n                                 key, strlen(key), &value, sizeof(value),\n                                 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n    len = storage_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_ADD,\n                          key, strlen(key), &value, sizeof(value), 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = storage_command(send.bytes, sizeof(send.bytes), cmd,\n                          key, strlen(key), &value, sizeof(value), 0, 0);\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_REPLACE) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response,\n                                     PROTOCOL_BINARY_CMD_REPLACE,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        }\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_REPLACEQ) {\n        test_binary_noop();\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_replace(void) {\n    return test_binary_replace_impl(\"test_binary_replace\",\n                                    PROTOCOL_BINARY_CMD_REPLACE);\n}\n\nstatic enum test_return test_binary_replaceq(void) {\n    return test_binary_replace_impl(\"test_binary_replaceq\",\n                                    PROTOCOL_BINARY_CMD_REPLACEQ);\n}\n\nstatic enum test_return test_binary_delete_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,\n                             key, strlen(key), NULL, 0);\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n    len = storage_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_ADD,\n                          key, strlen(key), NULL, 0, 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = raw_command(send.bytes, sizeof(send.bytes),\n                      cmd, key, strlen(key), NULL, 0);\n    safe_send(send.bytes, len, false);\n\n    if (cmd == PROTOCOL_BINARY_CMD_DELETE) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_DELETE,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_delete(void) {\n    return test_binary_delete_impl(\"test_binary_delete\",\n                                   PROTOCOL_BINARY_CMD_DELETE);\n}\n\nstatic enum test_return test_binary_deleteq(void) {\n    return test_binary_delete_impl(\"test_binary_deleteq\",\n                                   PROTOCOL_BINARY_CMD_DELETEQ);\n}\n\nstatic enum test_return test_binary_get_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,\n                             key, strlen(key), NULL, 0);\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n\n    len = storage_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_ADD,\n                          key, strlen(key), NULL, 0,\n                          0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    /* run a little pipeline test ;-) */\n    len = 0;\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        union {\n            protocol_binary_request_no_extras request;\n            char bytes[1024];\n        } temp;\n        size_t l = raw_command(temp.bytes, sizeof(temp.bytes),\n                               cmd, key, strlen(key), NULL, 0);\n        memcpy(send.bytes + len, temp.bytes, l);\n        len += l;\n    }\n\n    safe_send(send.bytes, len, false);\n    for (ii = 0; ii < 10; ++ii) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_get(void) {\n    return test_binary_get_impl(\"test_binary_get\", PROTOCOL_BINARY_CMD_GET);\n}\n\nstatic enum test_return test_binary_getk(void) {\n    return test_binary_get_impl(\"test_binary_getk\", PROTOCOL_BINARY_CMD_GETK);\n}\n\nstatic enum test_return test_binary_getq_impl(const char *key, uint8_t cmd) {\n    const char *missing = \"test_binary_getq_missing\";\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, temp, receive;\n    size_t len = storage_command(send.bytes, sizeof(send.bytes),\n                                 PROTOCOL_BINARY_CMD_ADD,\n                                 key, strlen(key), NULL, 0,\n                                 0, 0);\n    size_t len2 = raw_command(temp.bytes, sizeof(temp.bytes), cmd,\n                             missing, strlen(missing), NULL, 0);\n    /* I need to change the first opaque so that I can separate the two\n     * return packets */\n    temp.request.message.header.request.opaque = 0xfeedface;\n    memcpy(send.bytes + len, temp.bytes, len2);\n    len += len2;\n\n    len2 = raw_command(temp.bytes, sizeof(temp.bytes), cmd,\n                       key, strlen(key), NULL, 0);\n    memcpy(send.bytes + len, temp.bytes, len2);\n    len += len2;\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    /* The first GETQ shouldn't return anything */\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_getq(void) {\n    return test_binary_getq_impl(\"test_binary_getq\", PROTOCOL_BINARY_CMD_GETQ);\n}\n\nstatic enum test_return test_binary_getkq(void) {\n    return test_binary_getq_impl(\"test_binary_getkq\", PROTOCOL_BINARY_CMD_GETKQ);\n}\n\nstatic enum test_return test_binary_incr_impl(const char* key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response_header;\n        protocol_binary_response_incr response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,\n                                    key, strlen(key), 1, 0, 0);\n\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response_header, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n            assert(ntohll(receive.response.message.body.value) == ii);\n        }\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENTQ) {\n        test_binary_noop();\n    }\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_incr(void) {\n    return test_binary_incr_impl(\"test_binary_incr\",\n                                 PROTOCOL_BINARY_CMD_INCREMENT);\n}\n\nstatic enum test_return test_binary_incrq(void) {\n    return test_binary_incr_impl(\"test_binary_incrq\",\n                                 PROTOCOL_BINARY_CMD_INCREMENTQ);\n}\n\nstatic enum test_return test_binary_decr_impl(const char* key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response_header;\n        protocol_binary_response_decr response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,\n                                    key, strlen(key), 1, 9, 0);\n\n    int ii;\n    for (ii = 9; ii >= 0; --ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response_header, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n            assert(ntohll(receive.response.message.body.value) == ii);\n        }\n    }\n\n    /* decr on 0 should not wrap */\n    safe_send(send.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response_header, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        assert(ntohll(receive.response.message.body.value) == 0);\n    } else {\n        test_binary_noop();\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_decr(void) {\n    return test_binary_decr_impl(\"test_binary_decr\",\n                                 PROTOCOL_BINARY_CMD_DECREMENT);\n}\n\nstatic enum test_return test_binary_decrq(void) {\n    return test_binary_decr_impl(\"test_binary_decrq\",\n                                 PROTOCOL_BINARY_CMD_DECREMENTQ);\n}\n\nstatic enum test_return test_binary_version(void) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } buffer;\n\n    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                             PROTOCOL_BINARY_CMD_VERSION,\n                             NULL, 0, NULL, 0);\n\n    safe_send(buffer.bytes, len, false);\n    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_VERSION,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_flush_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n\n    size_t len = storage_command(send.bytes, sizeof(send.bytes),\n                                 PROTOCOL_BINARY_CMD_ADD,\n                                 key, strlen(key), NULL, 0, 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = flush_command(send.bytes, sizeof(send.bytes), cmd, 2, true);\n    safe_send(send.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    len = raw_command(send.bytes, sizeof(send.bytes), PROTOCOL_BINARY_CMD_GET,\n                      key, strlen(key), NULL, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    sleep(2);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n\n    int ii;\n    for (ii = 0; ii < 2; ++ii) {\n        len = storage_command(send.bytes, sizeof(send.bytes),\n                              PROTOCOL_BINARY_CMD_ADD,\n                              key, strlen(key), NULL, 0, 0, 0);\n        safe_send(send.bytes, len, false);\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n        len = flush_command(send.bytes, sizeof(send.bytes), cmd, 0, ii == 0);\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        }\n\n        len = raw_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_GET,\n                          key, strlen(key), NULL, 0);\n        safe_send(send.bytes, len, false);\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                                 PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_flush(void) {\n    return test_binary_flush_impl(\"test_binary_flush\",\n                                  PROTOCOL_BINARY_CMD_FLUSH);\n}\n\nstatic enum test_return test_binary_flushq(void) {\n    return test_binary_flush_impl(\"test_binary_flushq\",\n                                  PROTOCOL_BINARY_CMD_FLUSHQ);\n}\n\nstatic enum test_return test_binary_concat_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    const char *value = \"world\";\n\n    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,\n                              key, strlen(key), value, strlen(value));\n\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_NOT_STORED);\n\n    len = storage_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_ADD,\n                          key, strlen(key), value, strlen(value), 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = raw_command(send.bytes, sizeof(send.bytes), cmd,\n                      key, strlen(key), value, strlen(value));\n    safe_send(send.bytes, len, false);\n\n    if (cmd == PROTOCOL_BINARY_CMD_APPEND || cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    } else {\n        len = raw_command(send.bytes, sizeof(send.bytes), PROTOCOL_BINARY_CMD_NOOP,\n                          NULL, 0, NULL, 0);\n        safe_send(send.bytes, len, false);\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_NOOP,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    len = raw_command(send.bytes, sizeof(send.bytes), PROTOCOL_BINARY_CMD_GETK,\n                      key, strlen(key), NULL, 0);\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GETK,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    assert(receive.response.message.header.response.keylen == strlen(key));\n    assert(receive.response.message.header.response.bodylen == (strlen(key) + 2*strlen(value) + 4));\n\n    char *ptr = receive.bytes;\n    ptr += sizeof(receive.response);\n    ptr += 4;\n\n    assert(memcmp(ptr, key, strlen(key)) == 0);\n    ptr += strlen(key);\n    assert(memcmp(ptr, value, strlen(value)) == 0);\n    ptr += strlen(value);\n    assert(memcmp(ptr, value, strlen(value)) == 0);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_append(void) {\n    return test_binary_concat_impl(\"test_binary_append\",\n                                   PROTOCOL_BINARY_CMD_APPEND);\n}\n\nstatic enum test_return test_binary_prepend(void) {\n    return test_binary_concat_impl(\"test_binary_prepend\",\n                                   PROTOCOL_BINARY_CMD_PREPEND);\n}\n\nstatic enum test_return test_binary_appendq(void) {\n    return test_binary_concat_impl(\"test_binary_appendq\",\n                                   PROTOCOL_BINARY_CMD_APPENDQ);\n}\n\nstatic enum test_return test_binary_prependq(void) {\n    return test_binary_concat_impl(\"test_binary_prependq\",\n                                   PROTOCOL_BINARY_CMD_PREPENDQ);\n}\n\nstatic enum test_return test_binary_stat(void) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } buffer;\n\n    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                             PROTOCOL_BINARY_CMD_STAT,\n                             NULL, 0, NULL, 0);\n\n    safe_send(buffer.bytes, len, false);\n    do {\n        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_STAT,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    } while (buffer.response.message.header.response.keylen != 0);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_illegal(void) {\n    uint8_t cmd = 0x23;\n    while (cmd != 0x00) {\n        union {\n            protocol_binary_request_no_extras request;\n            protocol_binary_response_no_extras response;\n            char bytes[1024];\n        } buffer;\n        size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                                 cmd, NULL, 0, NULL, 0);\n        safe_send(buffer.bytes, len, false);\n        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n        validate_response_header(&buffer.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND);\n        ++cmd;\n    }\n\n    return TEST_PASS;\n}\n\nvolatile bool hickup_thread_running;\n\nstatic void *binary_hickup_recv_verification_thread(void *arg) {\n    protocol_binary_response_no_extras *response = malloc(65*1024);\n    if (response != NULL) {\n        while (safe_recv_packet(response, 65*1024)) {\n            /* Just validate the packet format */\n            validate_response_header(response,\n                                     response->message.header.response.opcode,\n                                     response->message.header.response.status);\n        }\n        free(response);\n    }\n    hickup_thread_running = false;\n    allow_closed_read = false;\n    return NULL;\n}\n\nstatic enum test_return test_binary_pipeline_hickup_chunk(void *buffer, size_t buffersize) {\n    off_t offset = 0;\n    char *key[256];\n    uint64_t value = 0xfeedfacedeadbeef;\n\n    while (hickup_thread_running &&\n           offset + sizeof(protocol_binary_request_no_extras) < buffersize) {\n        union {\n            protocol_binary_request_no_extras request;\n            char bytes[65 * 1024];\n        } command;\n        uint8_t cmd = (uint8_t)(rand() & 0xff);\n        size_t len;\n        size_t keylen = (rand() % 250) + 1;\n\n        switch (cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n        case PROTOCOL_BINARY_CMD_ADDQ:\n        case PROTOCOL_BINARY_CMD_REPLACE:\n        case PROTOCOL_BINARY_CMD_REPLACEQ:\n        case PROTOCOL_BINARY_CMD_SET:\n        case PROTOCOL_BINARY_CMD_SETQ:\n            len = storage_command(command.bytes, sizeof(command.bytes), cmd,\n                                  key, keylen , &value, sizeof(value),\n                                  0, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_APPENDQ:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n        case PROTOCOL_BINARY_CMD_PREPENDQ:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                              key, keylen, &value, sizeof(value));\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n        case PROTOCOL_BINARY_CMD_FLUSHQ:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                              NULL, 0, NULL, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                              NULL, 0, NULL, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n        case PROTOCOL_BINARY_CMD_DELETEQ:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                             key, keylen, NULL, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_INCREMENTQ:\n            len = arithmetic_command(command.bytes, sizeof(command.bytes), cmd,\n                                     key, keylen, 1, 0, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_VERSION:\n            len = raw_command(command.bytes, sizeof(command.bytes),\n                             PROTOCOL_BINARY_CMD_VERSION,\n                             NULL, 0, NULL, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_GET:\n        case PROTOCOL_BINARY_CMD_GETK:\n        case PROTOCOL_BINARY_CMD_GETKQ:\n        case PROTOCOL_BINARY_CMD_GETQ:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                             key, keylen, NULL, 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_STAT:\n            len = raw_command(command.bytes, sizeof(command.bytes),\n                              PROTOCOL_BINARY_CMD_STAT,\n                              NULL, 0, NULL, 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            /* Ignoring SASL */\n        case PROTOCOL_BINARY_CMD_QUITQ:\n        case PROTOCOL_BINARY_CMD_QUIT:\n            /* I don't want to pass on the quit commands ;-) */\n            cmd |= 0xf0;\n            /* FALLTHROUGH */\n        default:\n            len = raw_command(command.bytes, sizeof(command.bytes),\n                              cmd, NULL, 0, NULL, 0);\n        }\n\n        if ((len + offset) < buffersize) {\n            memcpy(((char*)buffer) + offset, command.bytes, len);\n            offset += len;\n        } else {\n            break;\n        }\n    }\n    safe_send(buffer, offset, true);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_pipeline_hickup(void)\n{\n    size_t buffersize = 65 * 1024;\n    void *buffer = malloc(buffersize);\n    int ii;\n\n    pthread_t tid;\n    int ret;\n    allow_closed_read = true;\n    hickup_thread_running = true;\n    if ((ret = pthread_create(&tid, NULL,\n                              binary_hickup_recv_verification_thread, NULL)) != 0) {\n        fprintf(stderr, \"Can't create thread: %s\\n\", strerror(ret));\n        return TEST_FAIL;\n    }\n\n    /* Allow the thread to start */\n    usleep(250);\n\n    srand((int)time(NULL));\n    for (ii = 0; ii < 2; ++ii) {\n        test_binary_pipeline_hickup_chunk(buffer, buffersize);\n    }\n\n    /* send quitq to shut down the read thread ;-) */\n    size_t len = raw_command(buffer, buffersize, PROTOCOL_BINARY_CMD_QUITQ,\n                             NULL, 0, NULL, 0);\n    safe_send(buffer, len, false);\n\n    pthread_join(tid, NULL);\n    free(buffer);\n    return TEST_PASS;\n}\n\ntypedef enum test_return (*TEST_FUNC)(void);\nstruct testcase {\n    const char *description;\n    TEST_FUNC function;\n};\n\nstruct testcase testcases[] = {\n    { \"cache_create\", cache_create_test },\n    { \"cache_constructor\", cache_constructor_test },\n    { \"cache_constructor_fail\", cache_fail_constructor_test },\n    { \"cache_destructor\", cache_destructor_test },\n    { \"cache_reuse\", cache_reuse_test },\n    { \"cache_redzone\", cache_redzone_test },\n    { \"strtol\", test_safe_strtol },\n    { \"strtoll\", test_safe_strtoll },\n    { \"strtoul\", test_safe_strtoul },\n    { \"strtoull\", test_safe_strtoull },\n    { \"issue_44\", test_issue_44 },\n    { \"vperror\", test_vperror },\n    /* The following tests all run towards the same server */\n    { \"start_server\", start_memcached_server },\n    { \"issue_92\", test_issue_92 },\n    { \"binary_noop\", test_binary_noop },\n    { \"binary_quit\", test_binary_quit },\n    { \"binary_quitq\", test_binary_quitq },\n    { \"binary_set\", test_binary_set },\n    { \"binary_setq\", test_binary_setq },\n    { \"binary_add\", test_binary_add },\n    { \"binary_addq\", test_binary_addq },\n    { \"binary_replace\", test_binary_replace },\n    { \"binary_replaceq\", test_binary_replaceq },\n    { \"binary_delete\", test_binary_delete },\n    { \"binary_deleteq\", test_binary_deleteq },\n    { \"binary_get\", test_binary_get },\n    { \"binary_getq\", test_binary_getq },\n    { \"binary_getk\", test_binary_getk },\n    { \"binary_getkq\", test_binary_getkq },\n    { \"binary_incr\", test_binary_incr },\n    { \"binary_incrq\", test_binary_incrq },\n    { \"binary_decr\", test_binary_decr },\n    { \"binary_decrq\", test_binary_decrq },\n    { \"binary_version\", test_binary_version },\n    { \"binary_flush\", test_binary_flush },\n    { \"binary_flushq\", test_binary_flushq },\n    { \"binary_append\", test_binary_append },\n    { \"binary_appendq\", test_binary_appendq },\n    { \"binary_prepend\", test_binary_prepend },\n    { \"binary_prependq\", test_binary_prependq },\n    { \"binary_stat\", test_binary_stat },\n    { \"binary_illegal\", test_binary_illegal },\n    { \"binary_pipeline_hickup\", test_binary_pipeline_hickup },\n    { \"stop_server\", stop_memcached_server },\n    { NULL, NULL }\n};\n\nint main(int argc, char **argv)\n{\n    int exitcode = 0;\n    int ii = 0, num_cases = 0;\n\n    for (num_cases = 0; testcases[num_cases].description; num_cases++) {\n        /* Just counting */\n    }\n\n    printf(\"1..%d\\n\", num_cases);\n\n    for (ii = 0; testcases[ii].description != NULL; ++ii) {\n        fflush(stdout);\n#ifndef DEBUG\n        /* the test program shouldn't run longer than 10 minutes... */\n        alarm(600);\n#endif\n        enum test_return ret = testcases[ii].function();\n        if (ret == TEST_SKIP) {\n            fprintf(stdout, \"ok # SKIP %d - %s\\n\", ii + 1, testcases[ii].description);\n        } else if (ret == TEST_PASS) {\n            fprintf(stdout, \"ok %d - %s\\n\", ii + 1, testcases[ii].description);\n        } else {\n            fprintf(stdout, \"not ok %d - %s\\n\", ii + 1, testcases[ii].description);\n            exitcode = 1;\n        }\n        fflush(stdout);\n    }\n\n    return exitcode;\n}\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       http://www.danga.com/memcached/\n *\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n */\n#include \"memcached.h\"\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <signal.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <ctype.h>\n#include <stdarg.h>\n\n/* some POSIX systems need the following definition\n * to get mlockall flags out of sys/mman.h.  */\n#ifndef _P1003_1B_VISIBLE\n#define _P1003_1B_VISIBLE\n#endif\n/* need this to get IOV_MAX on some platforms. */\n#ifndef __need_IOV_MAX\n#define __need_IOV_MAX\n#endif\n#include <pwd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n#include <sysexits.h>\n#include <stddef.h>\n\n/* FreeBSD 4.x doesn't have IOV_MAX exposed. */\n#ifndef IOV_MAX\n#if defined(__FreeBSD__) || defined(__APPLE__)\n# define IOV_MAX 1024\n#endif\n#endif\n\n/*\n * forward declarations\n */\nstatic void drive_machine(conn *c);\nstatic int new_socket(struct addrinfo *ai);\nstatic int try_read_command(conn *c);\n\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occured (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\nstatic void conn_set_state(conn *c, enum conn_states state);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\n\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void conn_close(conn *c);\nstatic void conn_init(void);\nstatic bool update_event(conn *c, const int new_flags);\nstatic void complete_nread(conn *c);\nstatic void process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic int ensure_iov_space(conn *c);\nstatic int add_iov(conn *c, const void *buf, int len);\nstatic int add_msghdr(conn *c);\n\n\n/* time handling */\nstatic void set_current_time(void);  /* update the global variable holding\n                              global 32-bit seconds-since-start time\n                              (to avoid 64 bit time_t) */\n\nstatic void conn_free(conn *c);\n\n/** exported globals **/\nstruct stats stats;\nstruct settings settings;\ntime_t process_started;     /* when the process was started */\n\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic struct event_base *main_base;\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\nstatic enum transmit_result transmit(conn *c);\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n/*\n * given time value that's either unix time or delta from current unix time, return\n * unix time. Use the fact that delta can't exceed one month (and real time value can't\n * be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\nstatic void stats_init(void) {\n    stats.curr_items = stats.total_items = stats.curr_conns = stats.total_conns = stats.conn_structs = 0;\n    stats.get_cmds = stats.set_cmds = stats.get_hits = stats.get_misses = stats.evictions = 0;\n    stats.curr_bytes = stats.listen_disabled_num = 0;\n    stats.accepting_conns = true; /* assuming we start in this state. */\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - 2;\n    stats_prefix_init();\n}\n\nstatic void stats_reset(void) {\n    STATS_LOCK();\n    stats.total_items = stats.total_conns = 0;\n    stats.evictions = 0;\n    stats.listen_disabled_num = 0;\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset();\n    item_stats_reset();\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n}\n\n/*\n * Adds a message header to a connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int add_msghdr(conn *c)\n{\n    struct msghdr *msg;\n\n    assert(c != NULL);\n\n    if (c->msgsize == c->msgused) {\n        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));\n        if (! msg)\n            return -1;\n        c->msglist = msg;\n        c->msgsize *= 2;\n    }\n\n    msg = c->msglist + c->msgused;\n\n    /* this wipes msg_iovlen, msg_control, msg_controllen, and\n       msg_flags, the last 3 of which aren't defined on solaris: */\n    memset(msg, 0, sizeof(struct msghdr));\n\n    msg->msg_iov = &c->iov[c->iovused];\n\n    if (c->request_addr_size > 0) {\n        msg->msg_name = &c->request_addr;\n        msg->msg_namelen = c->request_addr_size;\n    }\n\n    c->msgbytes = 0;\n    c->msgused++;\n\n    if (IS_UDP(c->transport)) {\n        /* Leave room for the UDP header, which we'll fill in later. */\n        return add_iov(c, NULL, UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\n/*\n * Free list management for connections.\n */\n\nstatic conn **freeconns;\nstatic int freetotal;\nstatic int freecurr;\n/* Lock for connection freelist */\nstatic pthread_mutex_t conn_lock = PTHREAD_MUTEX_INITIALIZER;\n\n\nstatic void conn_init(void) {\n    freetotal = 200;\n    freecurr = 0;\n    if ((freeconns = calloc(freetotal, sizeof(conn *))) == NULL) {\n        fprintf(stderr, \"Failed to allocate connection structures\\n\");\n    }\n    return;\n}\n\n/*\n * Returns a connection from the freelist, if any.\n */\nconn *conn_from_freelist() {\n    conn *c;\n\n    pthread_mutex_lock(&conn_lock);\n    if (freecurr > 0) {\n        c = freeconns[--freecurr];\n    } else {\n        c = NULL;\n    }\n    pthread_mutex_unlock(&conn_lock);\n\n    return c;\n}\n\n/*\n * Adds a connection to the freelist. 0 = success.\n */\nbool conn_add_to_freelist(conn *c) {\n    bool ret = true;\n    pthread_mutex_lock(&conn_lock);\n    if (freecurr < freetotal) {\n        freeconns[freecurr++] = c;\n        ret = false;\n    } else {\n        /* try to enlarge free connections array */\n        size_t newsize = freetotal * 2;\n        conn **new_freeconns = realloc(freeconns, sizeof(conn *) * newsize);\n        if (new_freeconns) {\n            freetotal = newsize;\n            freeconns = new_freeconns;\n            freeconns[freecurr++] = c;\n            ret = false;\n        }\n    }\n    pthread_mutex_unlock(&conn_lock);\n    return ret;\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nconn *conn_new(const int sfd, enum conn_states init_state,\n                const int event_flags,\n                const int read_buffer_size, enum network_transport transport,\n                struct event_base *base) {\n    conn *c = conn_from_freelist();\n\n    if (NULL == c) {\n        if (!(c = (conn *)calloc(1, sizeof(conn)))) {\n            fprintf(stderr, \"calloc()\\n\");\n            return NULL;\n        }\n        MEMCACHED_CONN_CREATE(c);\n\n        c->rbuf = c->wbuf = 0;\n        c->ilist = 0;\n        c->suffixlist = 0;\n        c->iov = 0;\n        c->msglist = 0;\n        c->hdrbuf = 0;\n\n        c->rsize = read_buffer_size;\n        c->wsize = DATA_BUFFER_SIZE;\n        c->isize = ITEM_LIST_INITIAL;\n        c->suffixsize = SUFFIX_LIST_INITIAL;\n        c->iovsize = IOV_LIST_INITIAL;\n        c->msgsize = MSG_LIST_INITIAL;\n        c->hdrsize = 0;\n\n        c->rbuf = (char *)malloc((size_t)c->rsize);\n        c->wbuf = (char *)malloc((size_t)c->wsize);\n        c->ilist = (item **)malloc(sizeof(item *) * c->isize);\n        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);\n        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);\n        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);\n\n        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||\n                c->msglist == 0 || c->suffixlist == 0) {\n            conn_free(c);\n            fprintf(stderr, \"malloc()\\n\");\n            return NULL;\n        }\n\n        STATS_LOCK();\n        stats.conn_structs++;\n        STATS_UNLOCK();\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    /* unix socket mode doesn't need this, so zeroed out.  but why\n     * is this done for every command?  presumably for UDP\n     * mode.  */\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            fprintf(stderr, \"<%d server listening (%s)\\n\", sfd,\n                prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            fprintf(stderr, \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            fprintf(stderr, \"<%d new auto-negotiating client connection\\n\",\n                    sfd);\n        } else if (c->protocol == ascii_prot) {\n            fprintf(stderr, \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            fprintf(stderr, \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            fprintf(stderr, \"<%d new unknown (%d) client connection\\n\",\n                sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (event_add(&c->event, 0) == -1) {\n        if (conn_add_to_freelist(c)) {\n            conn_free(c);\n        }\n        perror(\"event_add\");\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.curr_conns++;\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    return c;\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        item_remove(c->item);\n        c->item = 0;\n    }\n\n    if (c->ileft != 0) {\n        for (; c->ileft > 0; c->ileft--,c->icurr++) {\n            item_remove(*(c->icurr));\n        }\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n\n    if (c->write_and_free) {\n        free(c->write_and_free);\n        c->write_and_free = 0;\n    }\n\n    if (c->sasl_conn) {\n        assert(settings.sasl);\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n}\n\n/*\n * Frees a connection.\n */\nvoid conn_free(conn *c) {\n    if (c) {\n        MEMCACHED_CONN_DESTROY(c);\n        if (c->hdrbuf)\n            free(c->hdrbuf);\n        if (c->msglist)\n            free(c->msglist);\n        if (c->rbuf)\n            free(c->rbuf);\n        if (c->wbuf)\n            free(c->wbuf);\n        if (c->ilist)\n            free(c->ilist);\n        if (c->suffixlist)\n            free(c->suffixlist);\n        if (c->iov)\n            free(c->iov);\n        free(c);\n    }\n}\n\nstatic void conn_close(conn *c) {\n    assert(c != NULL);\n\n    /* delete the event, the socket and the conn */\n    event_del(&c->event);\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d connection closed.\\n\", c->sfd);\n\n    MEMCACHED_CONN_RELEASE(c->sfd);\n    close(c->sfd);\n    accept_new_conns(true);\n    conn_cleanup(c);\n\n    /* if the connection has big buffers, just free it */\n    if (c->rsize > READ_BUFFER_HIGHWAT || conn_add_to_freelist(c)) {\n        conn_free(c);\n    }\n\n    STATS_LOCK();\n    stats.curr_conns--;\n    STATS_UNLOCK();\n\n    return;\n}\n\n/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\nstatic void conn_shrink(conn *c) {\n    assert(c != NULL);\n\n    if (IS_UDP(c->transport))\n        return;\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nstatic const char *state_text(enum conn_states state) {\n    const char* const statenames[] = { \"conn_listening\",\n                                       \"conn_new_cmd\",\n                                       \"conn_waiting\",\n                                       \"conn_read\",\n                                       \"conn_parse_cmd\",\n                                       \"conn_write\",\n                                       \"conn_nread\",\n                                       \"conn_swallow\",\n                                       \"conn_closing\",\n                                       \"conn_mwrite\" };\n    return statenames[state];\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nstatic void conn_set_state(conn *c, enum conn_states state) {\n    assert(c != NULL);\n    assert(state >= conn_listening && state < conn_max_state);\n\n    if (state != c->state) {\n        if (settings.verbose > 2) {\n            fprintf(stderr, \"%d: going from %s to %s\\n\",\n                    c->sfd, state_text(c->state),\n                    state_text(state));\n        }\n\n        c->state = state;\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n    }\n}\n\n/*\n * Ensures that there is room for another struct iovec in a connection's\n * iov list.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int ensure_iov_space(conn *c) {\n    assert(c != NULL);\n\n    if (c->iovused >= c->iovsize) {\n        int i, iovnum;\n        struct iovec *new_iov = (struct iovec *)realloc(c->iov,\n                                (c->iovsize * 2) * sizeof(struct iovec));\n        if (! new_iov)\n            return -1;\n        c->iov = new_iov;\n        c->iovsize *= 2;\n\n        /* Point all the msghdr structures at the new list. */\n        for (i = 0, iovnum = 0; i < c->msgused; i++) {\n            c->msglist[i].msg_iov = &c->iov[iovnum];\n            iovnum += c->msglist[i].msg_iovlen;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n\nstatic int add_iov(conn *c, const void *buf, int len) {\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}\n\n\n/*\n * Constructs a set of UDP headers and attaches them to the outgoing messages.\n */\nstatic int build_udp_headers(conn *c) {\n    int i;\n    unsigned char *hdr;\n\n    assert(c != NULL);\n\n    if (c->msgused > c->hdrsize) {\n        void *new_hdrbuf;\n        if (c->hdrbuf)\n            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);\n        else\n            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);\n        if (! new_hdrbuf)\n            return -1;\n        c->hdrbuf = (unsigned char *)new_hdrbuf;\n        c->hdrsize = c->msgused * 2;\n    }\n\n    hdr = c->hdrbuf;\n    for (i = 0; i < c->msgused; i++) {\n        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;\n        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;\n        *hdr++ = c->request_id / 256;\n        *hdr++ = c->request_id % 256;\n        *hdr++ = i / 256;\n        *hdr++ = i % 256;\n        *hdr++ = c->msgused / 256;\n        *hdr++ = c->msgused % 256;\n        *hdr++ = 0;\n        *hdr++ = 0;\n        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n\n    assert(c != NULL);\n\n    if (c->noreply) {\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        c->noreply = false;\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n\n    len = strlen(str);\n    if ((len + 2) > c->wsize) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(c->wbuf, str, len);\n    memcpy(c->wbuf + len, \"\\r\\n\", 2);\n    c->wbytes = len + 2;\n    c->wcurr = c->wbuf;\n\n    conn_set_state(c, conn_write);\n    c->write_and_go = conn_new_cmd;\n    return;\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_nread_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    int comm = c->cmd;\n    enum store_item_type ret;\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.slab_stats[it->slabs_clsid].set_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    if (strncmp(ITEM_data(it) + it->nbytes - 2, \"\\r\\n\", 2) != 0) {\n        out_string(c, \"CLIENT_ERROR bad data chunk\");\n    } else {\n      ret = store_item(it, comm, c);\n\n#ifdef ENABLE_DTRACE\n      uint64_t cas = ITEM_get_cas(it);\n      switch (c->cmd) {\n      case NREAD_ADD:\n          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,\n                                (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_REPLACE:\n          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,\n                                    (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_APPEND:\n          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,\n                                   (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_PREPEND:\n          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,\n                                    (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_SET:\n          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,\n                                (ret == 1) ? it->nbytes : -1, cas);\n          break;\n      case NREAD_CAS:\n          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,\n                                cas);\n          break;\n      }\n#endif\n\n      switch (ret) {\n      case STORED:\n          out_string(c, \"STORED\");\n          break;\n      case EXISTS:\n          out_string(c, \"EXISTS\");\n          break;\n      case NOT_FOUND:\n          out_string(c, \"NOT_FOUND\");\n          break;\n      case NOT_STORED:\n          out_string(c, \"NOT_STORED\");\n          break;\n      default:\n          out_string(c, \"SERVER_ERROR Unhandled storage type.\");\n      }\n\n    }\n\n    item_remove(c->item);       /* release the c->item reference */\n    c->item = 0;\n}\n\n/**\n * get a pointer to the start of the request struct for the current command\n */\nstatic void* binary_get_request(conn *c) {\n    char *ret = c->rcurr;\n    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +\n            c->binary_header.request.extlen);\n\n    assert(ret >= c->rbuf);\n    return ret;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n\n    assert(c);\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        /* XXX:  out_string is inappropriate here */\n        out_string(c, \"SERVER_ERROR out of memory\");\n        return;\n    }\n\n    header = (protocol_binary_response_header *)c->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \">%d Writing bin response:\", c->sfd);\n        for (ii = 0; ii < sizeof(header->bytes); ++ii) {\n            if (ii % 4 == 0) {\n                fprintf(stderr, \"\\n>%d  \", c->sfd);\n            }\n            fprintf(stderr, \" 0x%02x\", header->bytes[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    add_iov(c, c->wbuf, sizeof(header->response));\n}\n\nstatic void write_bin_error(conn *c, protocol_binary_response_status err, int swallow) {\n    const char *errstr = \"Unknown error\";\n    size_t len;\n\n    switch (err) {\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n        errstr = \"Out of memory\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n        errstr = \"Unknown command\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n        errstr = \"Not found\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n        errstr = \"Invalid arguments\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n        errstr = \"Data exists for key.\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n        errstr = \"Too large.\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n        errstr = \"Non-numeric server-side value for incr or decr\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n        errstr = \"Not stored.\";\n        break;\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n        errstr = \"Auth failure.\";\n        break;\n    default:\n        assert(false);\n        errstr = \"UNHANDLED ERROR\";\n        fprintf(stderr, \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \">%d Writing an error: %s\\n\", c->sfd, errstr);\n    }\n\n    len = strlen(errstr);\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        add_iov(c, errstr, len);\n    }\n    conn_set_state(c, conn_mwrite);\n    if(swallow > 0) {\n        c->sbytes = swallow;\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}\n\nstatic void complete_incr_bin(conn *c) {\n    item *it;\n    char *key;\n    size_t nkey;\n\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;\n    protocol_binary_request_incr* req = binary_get_request(c);\n\n    assert(c != NULL);\n    assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    req->message.body.delta = ntohll(req->message.body.delta);\n    req->message.body.initial = ntohll(req->message.body.initial);\n    req->message.body.expiration = ntohl(req->message.body.expiration);\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int i;\n        fprintf(stderr, \"incr \");\n\n        for (i = 0; i < nkey; i++) {\n            fprintf(stderr, \"%c\", key[i]);\n        }\n        fprintf(stderr, \" %lld, %llu, %d\\n\",\n                (long long)req->message.body.delta,\n                (long long)req->message.body.initial,\n                req->message.body.expiration);\n    }\n\n    it = item_get(key, nkey);\n    if (it && (c->binary_header.request.cas == 0 ||\n               c->binary_header.request.cas == ITEM_get_cas(it))) {\n        /* Weird magic in add_delta forces me to pad here */\n        char tmpbuf[INCR_MAX_STORAGE_LEN];\n        protocol_binary_response_status st = PROTOCOL_BINARY_RESPONSE_SUCCESS;\n\n        switch(add_delta(c, it, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,\n                         req->message.body.delta, tmpbuf)) {\n        case OK:\n            break;\n        case NON_NUMERIC:\n            st = PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL;\n            break;\n        case EOM:\n            st = PROTOCOL_BINARY_RESPONSE_ENOMEM;\n            break;\n        }\n\n        if (st != PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n            write_bin_error(c, st, 0);\n        } else {\n            rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));\n            c->cas = ITEM_get_cas(it);\n            write_bin_response(c, &rsp->message.body, 0, 0,\n                               sizeof(rsp->message.body.value));\n        }\n\n        item_remove(it);         /* release our reference */\n    } else if (!it && req->message.body.expiration != 0xffffffff) {\n        /* Save some room for the response */\n        rsp->message.body.value = htonll(req->message.body.initial);\n        it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),\n                        INCR_MAX_STORAGE_LEN);\n\n        if (it != NULL) {\n            snprintf(ITEM_data(it), INCR_MAX_STORAGE_LEN, \"%llu\",\n                     (unsigned long long)req->message.body.initial);\n\n            if (store_item(it, NREAD_SET, c)) {\n                c->cas = ITEM_get_cas(it);\n                write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));\n            } else {\n                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);\n            }\n            item_remove(it);         /* release our reference */\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        }\n    } else if (it) {\n        /* incorrect CAS */\n        item_remove(it);         /* release our reference */\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n    } else {\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            c->thread->stats.incr_misses++;\n        } else {\n            c->thread->stats.decr_misses++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    enum store_item_type ret = NOT_STORED;\n    assert(c != NULL);\n\n    item *it = c->item;\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.slab_stats[it->slabs_clsid].set_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    /* We don't actually receive the trailing two characters in the bin\n     * protocol, so we're going to just set them here */\n    *(ITEM_data(it) + it->nbytes - 2) = '\\r';\n    *(ITEM_data(it) + it->nbytes - 1) = '\\n';\n\n    ret = store_item(it, c->cmd, c);\n\n#ifdef ENABLE_DTRACE\n    uint64_t cas = ITEM_get_cas(it);\n    switch (c->cmd) {\n    case NREAD_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,\n                              (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,\n                                  (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,\n                                 (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,\n                                 (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    case NREAD_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,\n                              (ret == STORED) ? it->nbytes : -1, cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case STORED:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case EXISTS:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case NOT_FOUND:\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case NOT_STORED:\n        if (c->cmd == NREAD_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->cmd == NREAD_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_error(c, eno, 0);\n    }\n\n    item_remove(c->item);       /* release the c->item reference */\n    c->item = 0;\n}\n\nstatic void process_bin_get(conn *c) {\n    item *it;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \"<%d GET \", c->sfd);\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", key[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    it = item_get(key, nkey);\n    if (it) {\n        /* the length has two unnecessary bytes (\"\\r\\n\") */\n        uint16_t keylen = 0;\n        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.get_cmds++;\n        c->thread->stats.slab_stats[it->slabs_clsid].get_hits++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                              it->nbytes, ITEM_get_cas(it));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));\n\n        // add the flags\n        rsp->message.body.flags = htonl(strtoul(ITEM_suffix(it), NULL, 10));\n        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            add_iov(c, ITEM_key(it), nkey);\n        }\n\n        /* Add the data minus the CRLF */\n        add_iov(c, ITEM_data(it), it->nbytes - 2);\n        conn_set_state(c, conn_mwrite);\n        /* Remember this command so we can garbage collect it later */\n        c->item = it;\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.get_cmds++;\n        c->thread->stats.get_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);\n                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                        0, nkey, nkey);\n                memcpy(ofs, key, nkey);\n                add_iov(c, ofs, nkey);\n                conn_set_state(c, conn_mwrite);\n            } else {\n                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_get(key, nkey, NULL != it);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->stats.buffer + c->stats.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->stats.offset += sizeof(header.response) + bodylen;\n}\n\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->stats.buffer + c->stats.offset;\n    uint32_t nbytes = 0;\n    int remaining = c->stats.size - c->stats.offset;\n    int room = remaining - 1;\n\n    if (klen == 0 && vlen == 0) {\n        nbytes = snprintf(pos, room, \"END\\r\\n\");\n    } else if (vlen == 0) {\n        nbytes = snprintf(pos, room, \"STAT %s\\r\\n\", key);\n    } else {\n        nbytes = snprintf(pos, room, \"STAT %s %s\\r\\n\", key, val);\n    }\n\n    c->stats.offset += nbytes;\n}\n\nstatic bool grow_stats_buf(conn *c, size_t needed) {\n    size_t nsize = c->stats.size;\n    size_t available = nsize - c->stats.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->stats.buffer == NULL) {\n        nsize = 1024;\n        available = c->stats.size = c->stats.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->stats.offset;\n    }\n\n    if (nsize != c->stats.size) {\n        char *ptr = realloc(c->stats.buffer, nsize);\n        if (ptr) {\n            c->stats.buffer = ptr;\n            c->stats.size = nsize;\n        } else {\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                  const char *val, const uint32_t vlen,\n                  const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return ;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_stats_buf(c, needed)) {\n            return ;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_stats_buf(c, needed)) {\n            return ;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->stats.offset <= c->stats.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        int ii;\n        fprintf(stderr, \"<%d STATS \", c->sfd);\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", subcommand[ii]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (nkey == 0) {\n        /* request all statistics */\n        server_stats(&append_stats, c);\n        (void)get_stats(NULL, 0, &append_stats, c);\n    } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n        stats_reset();\n    } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n        char *subcmd_pos = subcommand + 6;\n        if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n            int len;\n            char *dump_buf = stats_prefix_dump(&len);\n            if (dump_buf == NULL || len <= 0) {\n                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                return ;\n            } else {\n                append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                free(dump_buf);\n            }\n        } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n            settings.detail_enabled = 1;\n        } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n            settings.detail_enabled = 0;\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            return;\n        }\n    } else {\n        if (get_stats(subcommand, nkey, &append_stats, c)) {\n            if (c->stats.buffer == NULL) {\n                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n            } else {\n                write_and_free(c, c->stats.buffer, c->stats.offset);\n                c->stats.buffer = NULL;\n            }\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        }\n\n        return;\n    }\n\n    /* Append termination package and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n    if (c->stats.buffer == NULL) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n    } else {\n        write_and_free(c, c->stats.buffer, c->stats.offset);\n        c->stats.buffer = NULL;\n    }\n}\n\nstatic void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {\n    assert(c);\n    c->substate = next_substate;\n    c->rlbytes = c->keylen + extra;\n\n    /* Ok... do we have room for the extras and the key in the input buffer? */\n    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;\n    if (c->rlbytes > c->rsize - offset) {\n        size_t nsize = c->rsize;\n        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);\n\n        while (size > nsize) {\n            nsize *= 2;\n        }\n\n        if (nsize != c->rsize) {\n            if (settings.verbose > 1) {\n                fprintf(stderr, \"%d: Need to grow buffer from %lu to %lu\\n\",\n                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);\n            }\n            char *newm = realloc(c->rbuf, nsize);\n            if (newm == NULL) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"%d: Failed to grow buffer.. closing connection\\n\",\n                            c->sfd);\n                }\n                conn_set_state(c, conn_closing);\n                return;\n            }\n\n            c->rbuf= newm;\n            /* rcurr should point to the same offset in the packet */\n            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);\n            c->rsize = nsize;\n        }\n        if (c->rbuf != c->rcurr) {\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n            c->rcurr = c->rbuf;\n            if (settings.verbose > 1) {\n                fprintf(stderr, \"%d: Repack input buffer\\n\", c->sfd);\n            }\n        }\n    }\n\n    /* preserve the header in the buffer.. */\n    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);\n    conn_set_state(c, conn_nread);\n}\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        fprintf(stderr, \"Protocol error (opcode %02x), close connection %d\\n\",\n                c->binary_header.request.opcode, c->sfd);\n    }\n    c->write_and_go = conn_closing;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    /* should something else be returned? */\n    if (!settings.sasl)\n        return;\n\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL, NULL, NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                fprintf(stderr, \"Failed to initialize SASL conn.\\n\");\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void bin_list_sasl_mechs(conn *c) {\n    // Guard against a disabled SASL.\n    if (!settings.sasl) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                        c->binary_header.request.bodylen\n                        - c->binary_header.request.keylen);\n        return;\n    }\n\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            fprintf(stderr, \"Failed to list SASL mechanisms.\\n\");\n        }\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n\nstatic void process_bin_sasl_auth(conn *c) {\n    // Guard for handling disabled SASL on the server.\n    if (!settings.sasl) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                        c->binary_header.request.bodylen\n                        - c->binary_header.request.keylen);\n        return;\n    }\n\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    item *it = item_alloc(key, nkey, 0, 0, vlen);\n\n    if (it == 0) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    assert(settings.sasl);\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    char mech[nkey+1];\n    memcpy(mech, ITEM_key((item*)c->item), nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose)\n        fprintf(stderr, \"mech:  ``%s'' with %d bytes of data\\n\", mech, vlen);\n\n    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            fprintf(stderr, \"Unhandled command %d with challenge %s\\n\",\n                    c->cmd, challenge);\n        }\n        break;\n    }\n\n    item_unlink(c->item);\n\n    if (settings.verbose) {\n        fprintf(stderr, \"sasl result code:  %d\\n\", result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if(outlen > 0) {\n            add_iov(c, out, outlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n        break;\n    default:\n        if (settings.verbose)\n            fprintf(stderr, \"Unknown sasl response:  %d\\n\", result);\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    assert(settings.sasl);\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        if (c->sasl_conn) {\n            const void *uname = NULL;\n            sasl_getprop(c->sasl_conn, SASL_USERNAME, &uname);\n            rv = uname != NULL;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"authenticated() in cmd 0x%02x is %s\\n\",\n                c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic void dispatch_bin_command(conn *c) {\n    int protocol_error = 0;\n\n    int extlen = c->binary_header.request.extlen;\n    int keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (settings.sasl && !authenticated(c)) {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        c->write_and_go = conn_closing;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                bin_read_key(c, bin_read_flush_exptime, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                bin_read_key(c, bin_reading_set_header, 8);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                bin_read_key(c, bin_reading_get_key, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                bin_read_key(c, bin_reading_del_header, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                bin_read_key(c, bin_reading_incr_header, 20);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                bin_read_key(c, bin_reading_set_header, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                bin_read_key(c, bin_reading_stat, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                c->write_and_go = conn_closing;\n                if (c->noreply) {\n                    conn_set_state(c, conn_closing);\n                }\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                bin_read_key(c, bin_reading_sasl_auth, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, bodylen);\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n    protocol_binary_request_set* req = binary_get_request(c);\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = ntohl(req->message.body.flags);\n    req->message.body.expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        int ii;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            fprintf(stderr, \"<%d ADD \", c->sfd);\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            fprintf(stderr, \"<%d SET \", c->sfd);\n        } else {\n            fprintf(stderr, \"<%d REPLACE \", c->sfd);\n        }\n        for (ii = 0; ii < nkey; ++ii) {\n            fprintf(stderr, \"%c\", key[ii]);\n        }\n\n        fprintf(stderr, \" Value len is %d\", vlen);\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, req->message.body.flags,\n            realtime(req->message.body.expiration), vlen+2);\n\n    if (it == 0) {\n        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            it = item_get(key, nkey);\n            if (it) {\n                item_unlink(it);\n                item_remove(it);\n            }\n        }\n\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    ITEM_set_cas(it, c->binary_header.request.cas);\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->cmd = NREAD_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->cmd = NREAD_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->cmd = NREAD_REPLACE;\n            break;\n        default:\n            assert(0);\n    }\n\n    if (ITEM_get_cas(it) != 0) {\n        c->cmd = NREAD_CAS;\n    }\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_read_set_value;\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, 0, 0, vlen+2);\n\n    if (it == 0) {\n        if (! item_size_ok(nkey, 0, vlen + 2)) {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    ITEM_set_cas(it, c->binary_header.request.cas);\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->cmd = NREAD_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->cmd = NREAD_PREPEND;\n            break;\n        default:\n            assert(0);\n    }\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_read_set_value;\n}\n\nstatic void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    set_current_time();\n\n    if (exptime > 0) {\n        settings.oldest_live = realtime(exptime) - 1;\n    } else {\n        settings.oldest_live = current_time - 1;\n    }\n    item_flush_expired();\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.flush_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_delete(conn *c) {\n    item *it;\n\n    protocol_binary_request_delete* req = binary_get_request(c);\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        fprintf(stderr, \"Deleting %s\\n\", key);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n\n    it = item_get(key, nkey);\n    if (it) {\n        uint64_t cas = ntohll(req->message.header.request.cas);\n        if (cas == 0 || cas == ITEM_get_cas(it)) {\n            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n            item_unlink(it);\n            write_bin_response(c, NULL, 0, 0, 0);\n        } else {\n            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        }\n        item_remove(it);      /* release our reference */\n    } else {\n        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n    }\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_reading_set_header:\n        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||\n                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n            process_bin_append_prepend(c);\n        } else {\n            process_bin_update(c);\n        }\n        break;\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_get_key:\n        process_bin_get(c);\n        break;\n    case bin_reading_stat:\n        process_bin_stat(c);\n        break;\n    case bin_reading_del_header:\n        process_bin_delete(c);\n        break;\n    case bin_reading_incr_header:\n        complete_incr_bin(c);\n        break;\n    case bin_read_flush_exptime:\n        process_bin_flush(c);\n        break;\n    case bin_reading_sasl_auth:\n        process_bin_sasl_auth(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        break;\n    default:\n        fprintf(stderr, \"Not handling substate %d\\n\", c->substate);\n        assert(0);\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if(c->item != NULL) {\n        item_remove(c->item);\n        c->item = NULL;\n    }\n    conn_shrink(c);\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n/*\n * Stores an item in the cache according to the semantics of one of the set\n * commands. In threaded mode, this is protected by the cache lock.\n *\n * Returns the state of storage.\n */\nenum store_item_type do_store_item(item *it, int comm, conn *c) {\n    char *key = ITEM_key(it);\n    item *old_it = do_item_get(key, it->nkey);\n    enum store_item_type stored = NOT_STORED;\n\n    item *new_it = NULL;\n    int flags;\n\n    if (old_it != NULL && comm == NREAD_ADD) {\n        /* add only adds a nonexistent item, but promote to head of LRU */\n        do_item_update(old_it);\n    } else if (!old_it && (comm == NREAD_REPLACE\n        || comm == NREAD_APPEND || comm == NREAD_PREPEND))\n    {\n        /* replace only replaces an existing value; don't store */\n    } else if (comm == NREAD_CAS) {\n        /* validate cas operation */\n        if(old_it == NULL) {\n            // LRU expired\n            stored = NOT_FOUND;\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.cas_misses++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n        }\n        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {\n            // cas validates\n            // it and old_it may belong to different classes.\n            // I'm updating the stats for the one that's getting pushed out\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.slab_stats[old_it->slabs_clsid].cas_hits++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            item_replace(old_it, it);\n            stored = STORED;\n        } else {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.slab_stats[old_it->slabs_clsid].cas_badval++;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            if(settings.verbose > 1) {\n                fprintf(stderr, \"CAS:  failure: expected %llu, got %llu\\n\",\n                        (unsigned long long)ITEM_get_cas(old_it),\n                        (unsigned long long)ITEM_get_cas(it));\n            }\n            stored = EXISTS;\n        }\n    } else {\n        /*\n         * Append - combine new and old record into single one. Here it's\n         * atomic and thread-safe.\n         */\n        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {\n            /*\n             * Validate CAS\n             */\n            if (ITEM_get_cas(it) != 0) {\n                // CAS much be equal\n                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {\n                    stored = EXISTS;\n                }\n            }\n\n            if (stored == NOT_STORED) {\n                /* we have it and old_it here - alloc memory to hold both */\n                /* flags was already lost - so recover them from ITEM_suffix(it) */\n\n                flags = (int) strtol(ITEM_suffix(old_it), (char **) NULL, 10);\n\n                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);\n\n                if (new_it == NULL) {\n                    /* SERVER_ERROR out of memory */\n                    if (old_it != NULL)\n                        do_item_remove(old_it);\n\n                    return NOT_STORED;\n                }\n\n                /* copy data from it and old_it to new_it */\n\n                if (comm == NREAD_APPEND) {\n                    memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);\n                    memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(it), it->nbytes);\n                } else {\n                    /* NREAD_PREPEND */\n                    memcpy(ITEM_data(new_it), ITEM_data(it), it->nbytes);\n                    memcpy(ITEM_data(new_it) + it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);\n                }\n\n                it = new_it;\n            }\n        }\n\n        if (stored == NOT_STORED) {\n            if (old_it != NULL)\n                item_replace(old_it, it);\n            else\n                do_item_link(it);\n\n            c->cas = ITEM_get_cas(it);\n\n            stored = STORED;\n        }\n    }\n\n    if (old_it != NULL)\n        do_item_remove(old_it);         /* release our reference */\n    if (new_it != NULL)\n        do_item_remove(new_it);\n\n    if (stored == STORED) {\n        c->cas = ITEM_get_cas(it);\n    }\n\n    return stored;\n}\n\ntypedef struct token_s {\n    char *value;\n    size_t length;\n} token_t;\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 8\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    for (s = e = command; ntokens < max_tokens - 1; ++e) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n            }\n            s = e + 1;\n        }\n        else if (*e == '\\0') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n            }\n\n            break; /* string end */\n        }\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline void set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (strcmp(command, \"on\") == 0) {\n        settings.detail_enabled = 1;\n        out_string(c, \"OK\");\n    }\n    else if (strcmp(command, \"off\") == 0) {\n        settings.detail_enabled = 0;\n        out_string(c, \"OK\");\n    }\n    else if (strcmp(command, \"dump\") == 0) {\n        int len;\n        char *stats = stats_prefix_dump(&len);\n        write_and_free(c, stats, len);\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n    }\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_aggregate(&thread_stats);\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef WIN32\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif /* !WIN32 */\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef WIN32\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif /* !WIN32 */\n\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns - 1);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"cmd_get\", \"%llu\", (unsigned long long)thread_stats.get_cmds);\n    APPEND_STAT(\"cmd_set\", \"%llu\", (unsigned long long)slab_stats.set_cmds);\n    APPEND_STAT(\"cmd_flush\", \"%llu\", (unsigned long long)thread_stats.flush_cmds);\n    APPEND_STAT(\"get_hits\", \"%llu\", (unsigned long long)slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%llu\", (unsigned long long)thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%llu\", (unsigned long long)thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%llu\", (unsigned long long)slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%llu\", (unsigned long long)thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%llu\", (unsigned long long)slab_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%llu\", (unsigned long long)thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%llu\", (unsigned long long)slab_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%llu\", (unsigned long long)thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%llu\", (unsigned long long)slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%llu\", (unsigned long long)slab_stats.cas_badval);\n    APPEND_STAT(\"bytes_read\", \"%llu\", (unsigned long long)thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%llu\", (unsigned long long)thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%llu\", (unsigned long long)settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\", stats.accepting_conns);\n    APPEND_STAT(\"listen_disabled_num\", \"%llu\", (unsigned long long)stats.listen_disabled_num);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%llu\", (unsigned long long)thread_stats.conn_yields);\n    STATS_UNLOCK();\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n}\n\nstatic void process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    assert(c != NULL);\n\n    if (ntokens < 2) {\n        out_string(c, \"CLIENT_ERROR bad command line\");\n        return;\n    }\n\n    if (ntokens == 2) {\n        server_stats(&append_stats, c);\n        (void)get_stats(NULL, 0, &append_stats, c);\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset();\n        out_string(c, \"RESET\");\n        return ;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4)\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        else\n            process_stats_detail(c, tokens[2].value);\n        /* Output already generated */\n        return ;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf;\n        unsigned int bytes, id, limit = 0;\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n\n        if (id >= POWER_LARGEST) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return;\n        }\n\n        buf = item_cachedump(id, limit, &bytes);\n        write_and_free(c, buf, bytes);\n        return ;\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {\n            if (c->stats.buffer == NULL) {\n                out_string(c, \"SERVER_ERROR out of memory writing stats\");\n            } else {\n                write_and_free(c, c->stats.buffer, c->stats.offset);\n                c->stats.buffer = NULL;\n            }\n        } else {\n            out_string(c, \"ERROR\");\n        }\n        return ;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->stats.buffer == NULL) {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->stats.buffer, c->stats.offset);\n        c->stats.buffer = NULL;\n    }\n}\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return;\n            }\n\n            it = item_get(key, nkey);\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    item_remove(it);\n                    return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                            \" %llu\\r\\n\",\n                                            (unsigned long long)ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, ITEM_data(it), it->nbytes) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1)\n                    fprintf(stderr, \">%d sending key %s\\n\", c->sfd, ITEM_key(it));\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[it->slabs_clsid].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                item_update(it);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return;\n}\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    time_t exptime;\n    int vlen;\n    uint64_t req_cas_id=0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */\n    exptime = exptime_int;\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    vlen += 2;\n    if (vlen < 0 || vlen - 2 < 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);\n\n    if (it == 0) {\n        if (! item_size_ok(nkey, flags, vlen))\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n        else\n            out_string(c, \"SERVER_ERROR out of memory storing object\");\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        c->sbytes = vlen;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (comm == NREAD_SET) {\n            it = item_get(key, nkey);\n            if (it) {\n                item_unlink(it);\n                item_remove(it);\n            }\n        }\n\n        return;\n    }\n    ITEM_set_cas(it, req_cas_id);\n\n    c->item = it;\n    c->ritem = ITEM_data(it);\n    c->rlbytes = it->nbytes;\n    c->cmd = comm;\n    conn_set_state(c, conn_nread);\n}\n\nstatic void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n    char temp[INCR_MAX_STORAGE_LEN];\n    item *it;\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return;\n    }\n\n    it = item_get(key, nkey);\n    if (!it) {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        if (incr) {\n            c->thread->stats.incr_misses++;\n        } else {\n            c->thread->stats.decr_misses++;\n        }\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n        return;\n    }\n\n    switch(add_delta(c, it, incr, delta, temp)) {\n    case OK:\n        out_string(c, temp);\n        break;\n    case NON_NUMERIC:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case EOM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    }\n    item_remove(it);         /* release our reference */\n}\n\n/*\n * adds a delta value to a numeric item.\n *\n * c     connection requesting the operation\n * it    item to adjust\n * incr  true to increment value, false to decrement\n * delta amount to adjust value by\n * buf   buffer for response string\n *\n * returns a response string to send back to the client.\n */\nenum delta_result_type do_add_delta(conn *c, item *it, const bool incr,\n                                    const int64_t delta, char *buf) {\n    char *ptr;\n    uint64_t value;\n    int res;\n\n    ptr = ITEM_data(it);\n\n    if (!safe_strtoull(ptr, &value)) {\n        return NON_NUMERIC;\n    }\n\n    if (incr) {\n        value += delta;\n        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);\n    } else {\n        if(delta > value) {\n            value = 0;\n        } else {\n            value -= delta;\n        }\n        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);\n    }\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    if (incr) {\n        c->thread->stats.slab_stats[it->slabs_clsid].incr_hits++;\n    } else {\n        c->thread->stats.slab_stats[it->slabs_clsid].decr_hits++;\n    }\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    snprintf(buf, INCR_MAX_STORAGE_LEN, \"%llu\", (unsigned long long)value);\n    res = strlen(buf);\n    if (res + 2 > it->nbytes) { /* need to realloc */\n        item *new_it;\n        new_it = do_item_alloc(ITEM_key(it), it->nkey, atoi(ITEM_suffix(it) + 1), it->exptime, res + 2 );\n        if (new_it == 0) {\n            return EOM;\n        }\n        memcpy(ITEM_data(new_it), buf, res);\n        memcpy(ITEM_data(new_it) + res, \"\\r\\n\", 2);\n        item_replace(it, new_it);\n        do_item_remove(new_it);       /* release our reference */\n    } else { /* replace in-place */\n        /* When changing the value without replacing the item, we\n           need to update the CAS on the existing item. */\n        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);\n\n        memcpy(ITEM_data(it), buf, res);\n        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);\n    }\n\n    return OK;\n}\n\nstatic void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {\n    char *key;\n    size_t nkey;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if(nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n\n    it = item_get(key, nkey);\n    if (it) {\n        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.slab_stats[it->slabs_clsid].delete_hits++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        item_unlink(it);\n        item_remove(it);      /* release our reference */\n        out_string(c, \"DELETED\");\n    } else {\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.delete_misses++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        out_string(c, \"NOT_FOUND\");\n    }\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    level = strtoul(tokens[1].value, NULL, 10);\n    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n    out_string(c, \"OK\");\n    return;\n}\n\nstatic void process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d %s\\n\", c->sfd, command);\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        out_string(c, \"SERVER_ERROR out of memory preparing response\");\n        return;\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        process_get_command(c, tokens, ntokens, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = NREAD_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = NREAD_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = NREAD_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = NREAD_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = NREAD_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = NREAD_CAS))) {\n\n        process_update_command(c, tokens, ntokens, comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        process_get_command(c, tokens, ntokens, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        process_delete_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime = 0;\n        set_current_time();\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.flush_cmds++;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        if(ntokens == (c->noreply ? 3 : 2)) {\n            settings.oldest_live = current_time - 1;\n            item_flush_expired();\n            out_string(c, \"OK\");\n            return;\n        }\n\n        exptime = strtol(tokens[1].value, NULL, 10);\n        if(errno == ERANGE) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n\n        /*\n          If exptime is zero realtime() would return zero too, and\n          realtime(exptime) - 1 would overflow to the max unsigned\n          value.  So we process exptime == 0 the same way we do when\n          no delay is given at all.\n        */\n        if (exptime > 0)\n            settings.oldest_live = realtime(exptime) - 1;\n        else /* exptime == 0 */\n            settings.oldest_live = current_time - 1;\n        item_flush_expired();\n        out_string(c, \"OK\");\n        return;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_closing);\n\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else {\n        out_string(c, \"ERROR\");\n    }\n    return;\n}\n\n/*\n * if we have a complete line in the buffer, process it.\n */\nstatic int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, &c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        pthread_mutex_lock(&c->thread->stats.mutex);\n        c->thread->stats.bytes_read += res;\n        pthread_mutex_unlock(&c->thread->stats.mutex);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes += res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = read(c->sfd, c->rbuf + c->rbytes, avail);\n        if (res > 0) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.bytes_read += res;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nstatic bool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n    if (event_del(&c->event) == -1) return false;\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n    if (event_add(&c->event, 0) == -1) return false;\n    return true;\n}\n\n/*\n * Sets whether we are listening for new connections or not.\n */\nvoid do_accept_new_conns(const bool do_accept) {\n    conn *next;\n\n    for (next = listen_conn; next; next = next->next) {\n        if (do_accept) {\n            update_event(next, EV_READ | EV_PERSIST);\n            if (listen(next->sfd, settings.backlog) != 0) {\n                perror(\"listen\");\n            }\n        }\n        else {\n            update_event(next, 0);\n            if (listen(next->sfd, 0) != 0) {\n                perror(\"listen\");\n            }\n        }\n    }\n\n    if (do_accept) {\n        STATS_LOCK();\n        stats.accepting_conns = true;\n        STATS_UNLOCK();\n    } else {\n        STATS_LOCK();\n        stats.accepting_conns = false;\n        stats.listen_disabled_num++;\n        STATS_UNLOCK();\n    }\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            pthread_mutex_lock(&c->thread->stats.mutex);\n            c->thread->stats.bytes_written += res;\n            pthread_mutex_unlock(&c->thread->stats.mutex);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't update event\\n\");\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0)\n            perror(\"Failed to write, and not due to blocking\");\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}\n\nstatic void drive_machine(conn *c) {\n    bool stop = false;\n    int sfd, flags = 1;\n    socklen_t addrlen;\n    struct sockaddr_storage addr;\n    int nreqs = settings.reqs_per_event;\n    int res;\n\n    assert(c != NULL);\n\n    while (!stop) {\n\n        switch(c->state) {\n        case conn_listening:\n            addrlen = sizeof(addr);\n            if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                    /* these are transient, so don't log anything */\n                    stop = true;\n                } else if (errno == EMFILE) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Too many open connections\\n\");\n                    accept_new_conns(false);\n                    stop = true;\n                } else {\n                    perror(\"accept()\");\n                    stop = true;\n                }\n                break;\n            }\n            if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n                fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n                perror(\"setting O_NONBLOCK\");\n                close(sfd);\n                break;\n            }\n\n            dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                                     DATA_BUFFER_SIZE, tcp_transport);\n            stop = true;\n            break;\n\n        case conn_waiting:\n            if (!update_event(c, EV_READ | EV_PERSIST)) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't update event\\n\");\n                conn_set_state(c, conn_closing);\n                break;\n            }\n\n            conn_set_state(c, conn_read);\n            stop = true;\n            break;\n\n        case conn_read:\n            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);\n\n            switch (res) {\n            case READ_NO_DATA_RECEIVED:\n                conn_set_state(c, conn_waiting);\n                break;\n            case READ_DATA_RECEIVED:\n                conn_set_state(c, conn_parse_cmd);\n                break;\n            case READ_ERROR:\n                conn_set_state(c, conn_closing);\n                break;\n            case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n                /* State already set by try_read_network */\n                break;\n            }\n            break;\n\n        case conn_parse_cmd :\n            if (try_read_command(c) == 0) {\n                /* wee need more data! */\n                conn_set_state(c, conn_waiting);\n            }\n\n            break;\n\n        case conn_new_cmd:\n            /* Only process nreqs at a time to avoid starving other\n               connections */\n\n            --nreqs;\n            if (nreqs >= 0) {\n                reset_cmd_handler(c);\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.conn_yields++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                if (c->rbytes > 0) {\n                    /* We have already read in data into the input buffer,\n                       so libevent will most likely not signal read events\n                       on the socket (unless more data is available. As a\n                       hack we should just put in a request to write data,\n                       because that should be possible ;-)\n                    */\n                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                        if (settings.verbose > 0)\n                            fprintf(stderr, \"Couldn't update event\\n\");\n                        conn_set_state(c, conn_closing);\n                    }\n                }\n                stop = true;\n            }\n            break;\n\n        case conn_nread:\n            if (c->rlbytes == 0) {\n                complete_nread(c);\n                break;\n            }\n            /* first check if we have leftovers in the conn_read buffer */\n            if (c->rbytes > 0) {\n                int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n                if (c->ritem != c->rcurr) {\n                    memmove(c->ritem, c->rcurr, tocopy);\n                }\n                c->ritem += tocopy;\n                c->rlbytes -= tocopy;\n                c->rcurr += tocopy;\n                c->rbytes -= tocopy;\n                if (c->rlbytes == 0) {\n                    break;\n                }\n            }\n\n            /*  now try reading from the socket */\n            res = read(c->sfd, c->ritem, c->rlbytes);\n            if (res > 0) {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.bytes_read += res;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                if (c->rcurr == c->ritem) {\n                    c->rcurr += res;\n                }\n                c->ritem += res;\n                c->rlbytes -= res;\n                break;\n            }\n            if (res == 0) { /* end of stream */\n                conn_set_state(c, conn_closing);\n                break;\n            }\n            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n                if (!update_event(c, EV_READ | EV_PERSIST)) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't update event\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                stop = true;\n                break;\n            }\n            /* otherwise we have a real error, on which we close the connection */\n            if (settings.verbose > 0) {\n                fprintf(stderr, \"Failed to read, and not due to blocking:\\n\"\n                        \"errno: %d %s \\n\"\n                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                        errno, strerror(errno),\n                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                        (int)c->rlbytes, (int)c->rsize);\n            }\n            conn_set_state(c, conn_closing);\n            break;\n\n        case conn_swallow:\n            /* we are reading sbytes and throwing them away */\n            if (c->sbytes == 0) {\n                conn_set_state(c, conn_new_cmd);\n                break;\n            }\n\n            /* first check if we have leftovers in the conn_read buffer */\n            if (c->rbytes > 0) {\n                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n                c->sbytes -= tocopy;\n                c->rcurr += tocopy;\n                c->rbytes -= tocopy;\n                break;\n            }\n\n            /*  now try reading from the socket */\n            res = read(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);\n            if (res > 0) {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.bytes_read += res;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                c->sbytes -= res;\n                break;\n            }\n            if (res == 0) { /* end of stream */\n                conn_set_state(c, conn_closing);\n                break;\n            }\n            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n                if (!update_event(c, EV_READ | EV_PERSIST)) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't update event\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n                stop = true;\n                break;\n            }\n            /* otherwise we have a real error, on which we close the connection */\n            if (settings.verbose > 0)\n                fprintf(stderr, \"Failed to read, and not due to blocking\\n\");\n            conn_set_state(c, conn_closing);\n            break;\n\n        case conn_write:\n            /*\n             * We want to write out a simple response. If we haven't already,\n             * assemble it into a msgbuf list (this will be a single-entry\n             * list for TCP or a two-entry list for UDP).\n             */\n            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {\n                if (add_iov(c, c->wcurr, c->wbytes) != 0) {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Couldn't build response\\n\");\n                    conn_set_state(c, conn_closing);\n                    break;\n                }\n            }\n\n            /* fall through... */\n\n        case conn_mwrite:\n          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {\n            if (settings.verbose > 0)\n              fprintf(stderr, \"Failed to build UDP headers\\n\");\n            conn_set_state(c, conn_closing);\n            break;\n          }\n            switch (transmit(c)) {\n            case TRANSMIT_COMPLETE:\n                if (c->state == conn_mwrite) {\n                    while (c->ileft > 0) {\n                        item *it = *(c->icurr);\n                        assert((it->it_flags & ITEM_SLABBED) == 0);\n                        item_remove(it);\n                        c->icurr++;\n                        c->ileft--;\n                    }\n                    while (c->suffixleft > 0) {\n                        char *suffix = *(c->suffixcurr);\n                        cache_free(c->thread->suffix_cache, suffix);\n                        c->suffixcurr++;\n                        c->suffixleft--;\n                    }\n                    /* XXX:  I don't know why this wasn't the general case */\n                    if(c->protocol == binary_prot) {\n                        conn_set_state(c, c->write_and_go);\n                    } else {\n                        conn_set_state(c, conn_new_cmd);\n                    }\n                } else if (c->state == conn_write) {\n                    if (c->write_and_free) {\n                        free(c->write_and_free);\n                        c->write_and_free = 0;\n                    }\n                    conn_set_state(c, c->write_and_go);\n                } else {\n                    if (settings.verbose > 0)\n                        fprintf(stderr, \"Unexpected state %d\\n\", c->state);\n                    conn_set_state(c, conn_closing);\n                }\n                break;\n\n            case TRANSMIT_INCOMPLETE:\n            case TRANSMIT_HARD_ERROR:\n                break;                   /* Continue in state machine. */\n\n            case TRANSMIT_SOFT_ERROR:\n                stop = true;\n                break;\n            }\n            break;\n\n        case conn_closing:\n            if (IS_UDP(c->transport))\n                conn_cleanup(c);\n            else\n                conn_close(c);\n            stop = true;\n            break;\n\n        case conn_max_state:\n            assert(false);\n            break;\n        }\n    }\n\n    return;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (settings.verbose > 0)\n            fprintf(stderr, \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        conn_close(c);\n        return;\n    }\n\n    drive_machine(c);\n\n    /* wait for next event */\n    return;\n}\n\nstatic int new_socket(struct addrinfo *ai) {\n    int sfd;\n    int flags;\n\n    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {\n        return -1;\n    }\n\n    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n        perror(\"setting O_NONBLOCK\");\n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {\n        if (settings.verbose > 0)\n            perror(\"getsockopt(SO_SNDBUF)\");\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n}\n\n/**\n * Create a socket and bind it to a specific port number\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(int port, enum network_transport transport,\n                         FILE *portnumber_file) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(settings.inter, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM)\n          fprintf(stderr, \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        else\n          perror(\"getaddrinfo()\");\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == -1) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                perror(\"setsockopt\");\n                close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0)\n                perror(\"setsockopt\");\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0)\n                perror(\"setsockopt\");\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {\n            if (errno != EADDRINUSE) {\n                perror(\"bind()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {\n                perror(\"listen()\");\n                close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base))) {\n                fprintf(stderr, \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n    int flags;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n        perror(\"socket()\");\n        return -1;\n    }\n\n    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||\n        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {\n        perror(\"setting O_NONBLOCK\");\n        close(sfd);\n        return -1;\n    }\n    return sfd;\n}\n\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        perror(\"bind()\");\n        close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        perror(\"listen()\");\n        close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base))) {\n        fprintf(stderr, \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\nstatic struct event clockevent;\n\n/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\nstatic void set_current_time(void) {\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - process_started);\n}\n\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n    set_current_time();\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p <num>      TCP port number to listen on (default: 11211)\\n\"\n           \"-U <num>      UDP port number to listen on (default: 11211, 0 is off)\\n\"\n           \"-s <file>     UNIX socket path to listen on (disables network support)\\n\"\n           \"-a <mask>     access mask for UNIX socket, in octal (default: 0700)\\n\"\n           \"-l <ip_addr>  interface to listen on (default: INADDR_ANY, all addresses)\\n\"\n           \"-d            run as a daemon\\n\"\n           \"-r            maximize core file limit\\n\"\n           \"-u <username> assume identity of <username> (only when run as root)\\n\"\n           \"-m <num>      max memory to use for items in megabytes (default: 64 MB)\\n\"\n           \"-M            return error on memory exhausted (rather than removing items)\\n\"\n           \"-c <num>      max simultaneous connections (default: 1024)\\n\"\n           \"-k            lock down all paged memory.  Note that there is a\\n\"\n           \"              limit on how much memory you may lock.  Trying to\\n\"\n           \"              allocate more than that would fail, so be sure you\\n\"\n           \"              set the limit correctly for the user you started\\n\"\n           \"              the daemon with (not for -u <username> user;\\n\"\n           \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"\n           \"-v            verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv           very verbose (also print client commands/reponses)\\n\"\n           \"-vvv          extremely verbose (also print internal state transitions)\\n\"\n           \"-h            print this help and exit\\n\"\n           \"-i            print memcached and libevent license\\n\"\n           \"-P <file>     save PID in <file>, only used with -d option\\n\"\n           \"-f <factor>   chunk size growth factor (default: 1.25)\\n\"\n           \"-n <bytes>    minimum space allocated for key+value+flags (default: 48)\\n\");\n    printf(\"-L            Try to use large memory pages (if available). Increasing\\n\"\n           \"              the memory page size could reduce the number of TLB misses\\n\"\n           \"              and improve the performance. In order to get large pages\\n\"\n           \"              from the OS, memcached will allocate the total item-cache\\n\"\n           \"              in one large chunk.\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\":\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\");\n    printf(\"-t <num>      number of threads to use (default: 4)\\n\");\n    printf(\"-R            Maximum number of requests per event, limits the number of\\n\"\n           \"              requests process for a given connection to prevent \\n\"\n           \"              starvation (default: 20)\\n\");\n    printf(\"-C            Disable use of CAS\\n\");\n    printf(\"-b            Set the backlog queue limit (default: 1024)\\n\");\n    printf(\"-B            Binding protocol - one of ascii, binary, or auto (default)\\n\");\n    printf(\"-I            Override the size of each slab page. Adjusts max item size\\n\"\n           \"              (default: 1mb, min: 1k, max: 128m)\\n\");\n#ifdef ENABLE_SASL\n    printf(\"-S            Turn on Sasl authentication\\n\");\n#endif\n    return;\n}\n\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const pid_t pid, const char *pid_file) {\n    FILE *fp;\n    if (pid_file == NULL)\n        return;\n\n    if ((fp = fopen(pid_file, \"w\")) == NULL) {\n        fprintf(stderr, \"Could not open the pid file %s for writing\\n\", pid_file);\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)pid);\n    if (fclose(fp) == -1) {\n        fprintf(stderr, \"Could not close the pid file %s.\\n\", pid_file);\n        return;\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n  if (pid_file == NULL)\n      return;\n\n  if (unlink(pid_file) != 0) {\n      fprintf(stderr, \"Could not remove the pid file %s.\\n\", pid_file);\n  }\n\n}\n\nstatic void sig_handler(const int sig) {\n    printf(\"SIGINT handled.\\n\");\n    exit(EXIT_SUCCESS);\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif\n\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            fprintf(stderr, \"Failed to set large pages: %s\\n\",\n                    strerror(errno));\n            fprintf(stderr, \"Will use default page size\\n\");\n        } else {\n            ret = 0;\n        }\n    } else {\n        fprintf(stderr, \"Failed to get supported pagesizes: %s\\n\",\n                strerror(errno));\n        fprintf(stderr, \"Will use default page size\\n\");\n    }\n\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nint main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char unit = '\\0';\n    int size_max = 0;\n    /* listening sockets */\n    static int *l_socket = NULL;\n\n    /* udp socket */\n    static int *u_socket = NULL;\n    bool protocol_specified = false;\n\n    /* handle SIGINT */\n    signal(SIGINT, sig_handler);\n\n    /* init settings */\n    settings_init();\n\n    /* set stderr non-buffering (for running under, say, daemontools) */\n    setbuf(stderr, NULL);\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  /* access mask for unix socket */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hi\"  /* help, licence info */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n        ))) {\n        switch (c) {\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n            break;\n        case 'M':\n            settings.evict_to_free = 0;\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            break;\n        case 'l':\n            settings.inter= strdup(optarg);\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event == 0) {\n                fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                fprintf(stderr, \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n            break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                fprintf(stderr, \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                fprintf(stderr, \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                fprintf(stderr, \"WARNING: Setting a high number of worker\"\n                                \"threads is not recommended.\\n\"\n                                \" Set this value to the number of cores in\"\n                                \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            if (! optarg || ! optarg[0]) {\n                fprintf(stderr, \"No delimiter specified\\n\");\n                return 1;\n            }\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                fprintf(stderr, \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            unit = optarg[strlen(optarg)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                optarg[strlen(optarg)-1] = '\\0';\n                size_max = atoi(optarg);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(optarg);\n            }\n            if (settings.item_size_max < 1024) {\n                fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                fprintf(stderr, \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                fprintf(stderr, \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef ENABLE_SASL\n            fprintf(stderr, \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.sasl = true;\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    if (settings.sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol != binary_prot) {\n                fprintf(stderr, \"WARNING: You shouldn't allow the ASCII protocol while using SASL\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            fprintf(stderr, \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        fprintf(stderr, \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        int maxfiles = settings.maxconns;\n        if (rlim.rlim_cur < maxfiles)\n            rlim.rlim_cur = maxfiles;\n        if (rlim.rlim_max < rlim.rlim_cur)\n            rlim.rlim_max = rlim.rlim_cur;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            fprintf(stderr, \"failed to set rlimit for open files. Try running as root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            fprintf(stderr, \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            fprintf(stderr, \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            fprintf(stderr, \"failed to assume identity of user %s\\n\", username);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* Initialize Sasl if -S was specified */\n    if (settings.sasl) {\n        init_sasl();\n    }\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            perror(\"Failed to ignore SIGHUP\");\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n            fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            fprintf(stderr, \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n    main_base = event_init();\n\n    /* initialize other stuff */\n    stats_init();\n    assoc_init();\n    conn_init();\n    slabs_init(settings.maxbytes, settings.factor, preallocate);\n\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        perror(\"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n    /* start up worker threads if MT mode */\n    thread_init(settings.num_threads, main_base);\n    /* save the PID in if we're a daemon, do this after thread_init due to\n       a file descriptor handling bug somewhere in libevent */\n\n    if (start_assoc_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    if (do_daemonize)\n        save_pid(getpid(), pid_file);\n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        errno = 0;\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char temp_portnumber_filename[PATH_MAX];\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            snprintf(temp_portnumber_filename,\n                     sizeof(temp_portnumber_filename),\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        errno = 0;\n        if (settings.port && server_socket(settings.port, tcp_transport,\n                                           portnumber_file)) {\n            vperror(\"failed to listen on TCP port %d\", settings.port);\n            exit(EX_OSERR);\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        errno = 0;\n        if (settings.udpport && server_socket(settings.udpport, udp_transport,\n                                              portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n    }\n\n    /* Drop privileges no longer needed */\n    drop_privileges();\n\n    /* enter the event loop */\n    event_base_loop(main_base, 0);\n\n    stop_assoc_maintenance_thread();\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n    if (l_socket)\n      free(l_socket);\n    if (u_socket)\n      free(u_socket);\n\n    return EXIT_SUCCESS;\n}\n", "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#undef NDEBUG\n#include <pthread.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <fcntl.h>\n\n#include \"protocol_binary.h\"\n#include \"config.h\"\n#include \"cache.h\"\n#include \"util.h\"\n\n#define TMP_TEMPLATE \"/tmp/test_file.XXXXXXX\"\n\nenum test_return { TEST_SKIP, TEST_PASS, TEST_FAIL };\n\nstatic pid_t server_pid;\nstatic in_port_t port;\nstatic int sock;\nstatic bool allow_closed_read = false;\n\nstatic enum test_return cache_create_test(void)\n{\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, NULL);\n    assert(cache != NULL);\n    cache_destroy(cache);\n    return TEST_PASS;\n}\n\nconst uint64_t constructor_pattern = 0xdeadcafebabebeef;\n\nstatic int cache_constructor(void *buffer, void *notused1, int notused2) {\n    uint64_t *ptr = buffer;\n    *ptr = constructor_pattern;\n    return 0;\n}\n\nstatic enum test_return cache_constructor_test(void)\n{\n    cache_t *cache = cache_create(\"test\", sizeof(uint64_t), sizeof(uint64_t),\n                                  cache_constructor, NULL);\n    assert(cache != NULL);\n    uint64_t *ptr = cache_alloc(cache);\n    uint64_t pattern = *ptr;\n    cache_free(cache, ptr);\n    cache_destroy(cache);\n    return (pattern == constructor_pattern) ? TEST_PASS : TEST_FAIL;\n}\n\nstatic int cache_fail_constructor(void *buffer, void *notused1, int notused2) {\n    return 1;\n}\n\nstatic enum test_return cache_fail_constructor_test(void)\n{\n    enum test_return ret = TEST_PASS;\n\n    cache_t *cache = cache_create(\"test\", sizeof(uint64_t), sizeof(uint64_t),\n                                  cache_fail_constructor, NULL);\n    assert(cache != NULL);\n    uint64_t *ptr = cache_alloc(cache);\n    if (ptr != NULL) {\n        ret = TEST_FAIL;\n    }\n    cache_destroy(cache);\n    return ret;\n}\n\nstatic void *destruct_data = 0;\n\nstatic void cache_destructor(void *buffer, void *notused) {\n    destruct_data = buffer;\n}\n\nstatic enum test_return cache_destructor_test(void)\n{\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, cache_destructor);\n    assert(cache != NULL);\n    char *ptr = cache_alloc(cache);\n    cache_free(cache, ptr);\n    cache_destroy(cache);\n\n    return (ptr == destruct_data) ? TEST_PASS : TEST_FAIL;\n}\n\nstatic enum test_return cache_reuse_test(void)\n{\n    int ii;\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, NULL);\n    char *ptr = cache_alloc(cache);\n    cache_free(cache, ptr);\n    for (ii = 0; ii < 100; ++ii) {\n        char *p = cache_alloc(cache);\n        assert(p == ptr);\n        cache_free(cache, ptr);\n    }\n    cache_destroy(cache);\n    return TEST_PASS;\n}\n\nstatic enum test_return cache_redzone_test(void)\n{\n#ifndef HAVE_UMEM_H\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, NULL);\n\n    /* Ignore SIGABORT */\n    struct sigaction old_action;\n    struct sigaction action = { .sa_handler = SIG_IGN, .sa_flags = 0};\n    sigemptyset(&action.sa_mask);\n    sigaction(SIGABRT, &action, &old_action);\n\n    /* check memory debug.. */\n    char *p = cache_alloc(cache);\n    char old = *(p - 1);\n    *(p - 1) = 0;\n    cache_free(cache, p);\n    assert(cache_error == -1);\n    *(p - 1) = old;\n\n    p[sizeof(uint32_t)] = 0;\n    cache_free(cache, p);\n    assert(cache_error == 1);\n\n    /* restore signal handler */\n    sigaction(SIGABRT, &old_action, NULL);\n\n    cache_destroy(cache);\n\n    return TEST_PASS;\n#else\n    return TEST_SKIP;\n#endif\n}\n\nstatic enum test_return test_safe_strtoul(void) {\n    uint32_t val;\n    assert(safe_strtoul(\"123\", &val));\n    assert(val == 123);\n    assert(safe_strtoul(\"+123\", &val));\n    assert(val == 123);\n    assert(!safe_strtoul(\"\", &val));  // empty\n    assert(!safe_strtoul(\"123BOGUS\", &val));  // non-numeric\n    /* Not sure what it does, but this works with ICC :/\n       assert(!safe_strtoul(\"92837498237498237498029383\", &val)); // out of range\n    */\n\n    // extremes:\n    assert(safe_strtoul(\"4294967295\", &val)); // 2**32 - 1\n    assert(val == 4294967295L);\n    /* This actually works on 64-bit ubuntu\n       assert(!safe_strtoul(\"4294967296\", &val)); // 2**32\n    */\n    assert(!safe_strtoul(\"-1\", &val));  // negative\n    return TEST_PASS;\n}\n\n\nstatic enum test_return test_safe_strtoull(void) {\n    uint64_t val;\n    assert(safe_strtoull(\"123\", &val));\n    assert(val == 123);\n    assert(safe_strtoull(\"+123\", &val));\n    assert(val == 123);\n    assert(!safe_strtoull(\"\", &val));  // empty\n    assert(!safe_strtoull(\"123BOGUS\", &val));  // non-numeric\n    assert(!safe_strtoull(\"92837498237498237498029383\", &val)); // out of range\n\n    // extremes:\n    assert(safe_strtoull(\"18446744073709551615\", &val)); // 2**64 - 1\n    assert(val == 18446744073709551615ULL);\n    assert(!safe_strtoull(\"18446744073709551616\", &val)); // 2**64\n    assert(!safe_strtoull(\"-1\", &val));  // negative\n    return TEST_PASS;\n}\n\nstatic enum test_return test_safe_strtoll(void) {\n    int64_t val;\n    assert(safe_strtoll(\"123\", &val));\n    assert(val == 123);\n    assert(safe_strtoll(\"+123\", &val));\n    assert(val == 123);\n    assert(safe_strtoll(\"-123\", &val));\n    assert(val == -123);\n    assert(!safe_strtoll(\"\", &val));  // empty\n    assert(!safe_strtoll(\"123BOGUS\", &val));  // non-numeric\n    assert(!safe_strtoll(\"92837498237498237498029383\", &val)); // out of range\n\n    // extremes:\n    assert(!safe_strtoll(\"18446744073709551615\", &val)); // 2**64 - 1\n    assert(safe_strtoll(\"9223372036854775807\", &val)); // 2**63 - 1\n    assert(val == 9223372036854775807LL);\n    /*\n      assert(safe_strtoll(\"-9223372036854775808\", &val)); // -2**63\n      assert(val == -9223372036854775808LL);\n    */\n    assert(!safe_strtoll(\"-9223372036854775809\", &val)); // -2**63 - 1\n\n    // We'll allow space to terminate the string.  And leading space.\n    assert(safe_strtoll(\" 123 foo\", &val));\n    assert(val == 123);\n    return TEST_PASS;\n}\n\nstatic enum test_return test_safe_strtol(void) {\n    int32_t val;\n    assert(safe_strtol(\"123\", &val));\n    assert(val == 123);\n    assert(safe_strtol(\"+123\", &val));\n    assert(val == 123);\n    assert(safe_strtol(\"-123\", &val));\n    assert(val == -123);\n    assert(!safe_strtol(\"\", &val));  // empty\n    assert(!safe_strtol(\"123BOGUS\", &val));  // non-numeric\n    assert(!safe_strtol(\"92837498237498237498029383\", &val)); // out of range\n\n    // extremes:\n    /* This actually works on 64-bit ubuntu\n       assert(!safe_strtol(\"2147483648\", &val)); // (expt 2.0 31.0)\n    */\n    assert(safe_strtol(\"2147483647\", &val)); // (- (expt 2.0 31) 1)\n    assert(val == 2147483647L);\n    /* This actually works on 64-bit ubuntu\n       assert(!safe_strtol(\"-2147483649\", &val)); // (- (expt -2.0 31) 1)\n    */\n\n    // We'll allow space to terminate the string.  And leading space.\n    assert(safe_strtol(\" 123 foo\", &val));\n    assert(val == 123);\n    return TEST_PASS;\n}\n\n/**\n * Function to start the server and let it listen on a random port\n *\n * @param port_out where to store the TCP port number the server is\n *                 listening on\n * @param daemon set to true if you want to run the memcached server\n *               as a daemon process\n * @return the pid of the memcached server\n */\nstatic pid_t start_server(in_port_t *port_out, bool daemon, int timeout) {\n    char environment[80];\n    snprintf(environment, sizeof(environment),\n             \"MEMCACHED_PORT_FILENAME=/tmp/ports.%lu\", (long)getpid());\n    char *filename= environment + strlen(\"MEMCACHED_PORT_FILENAME=\");\n    char pid_file[80];\n    snprintf(pid_file, sizeof(pid_file), \"/tmp/pid.%lu\", (long)getpid());\n\n    remove(filename);\n    remove(pid_file);\n\n#ifdef __sun\n    /* I want to name the corefiles differently so that they don't\n       overwrite each other\n    */\n    char coreadm[128];\n    sprintf(coreadm, \"coreadm -p core.%%f.%%p %lu\", (unsigned long)getpid());\n    system(coreadm);\n#endif\n\n    pid_t pid = fork();\n    assert(pid != -1);\n\n    if (pid == 0) {\n        /* Child */\n        char *argv[20];\n        int arg = 0;\n        char tmo[24];\n        snprintf(tmo, sizeof(tmo), \"%u\", timeout);\n\n        putenv(environment);\n#ifdef __sun\n        putenv(\"LD_PRELOAD=watchmalloc.so.1\");\n        putenv(\"MALLOC_DEBUG=WATCH\");\n#endif\n\n        if (!daemon) {\n            argv[arg++] = \"./timedrun\";\n            argv[arg++] = tmo;\n        }\n        argv[arg++] = \"./memcached-debug\";\n        argv[arg++] = \"-p\";\n        argv[arg++] = \"-1\";\n        argv[arg++] = \"-U\";\n        argv[arg++] = \"0\";\n        /* Handle rpmbuild and the like doing this as root */\n        if (getuid() == 0) {\n            argv[arg++] = \"-u\";\n            argv[arg++] = \"root\";\n        }\n        if (daemon) {\n            argv[arg++] = \"-d\";\n            argv[arg++] = \"-P\";\n            argv[arg++] = pid_file;\n        }\n#ifdef MESSAGE_DEBUG\n         argv[arg++] = \"-vvv\";\n#endif\n        argv[arg++] = NULL;\n        assert(execv(argv[0], argv) != -1);\n    }\n\n    /* Yeah just let us \"busy-wait\" for the file to be created ;-) */\n    while (access(filename, F_OK) == -1) {\n        usleep(10);\n    }\n\n    FILE *fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        fprintf(stderr, \"Failed to open the file containing port numbers: %s\\n\",\n                strerror(errno));\n        assert(false);\n    }\n\n    *port_out = (in_port_t)-1;\n    char buffer[80];\n    while ((fgets(buffer, sizeof(buffer), fp)) != NULL) {\n        if (strncmp(buffer, \"TCP INET: \", 10) == 0) {\n            int32_t val;\n            assert(safe_strtol(buffer + 10, &val));\n            *port_out = (in_port_t)val;\n        }\n    }\n    fclose(fp);\n    assert(remove(filename) == 0);\n\n    if (daemon) {\n        /* loop and wait for the pid file.. There is a potential race\n         * condition that the server just created the file but isn't\n         * finished writing the content, but I'll take the chance....\n         */\n        while (access(pid_file, F_OK) == -1) {\n            usleep(10);\n        }\n\n        fp = fopen(pid_file, \"r\");\n        if (fp == NULL) {\n            fprintf(stderr, \"Failed to open pid file: %s\\n\",\n                    strerror(errno));\n            assert(false);\n        }\n        assert(fgets(buffer, sizeof(buffer), fp) != NULL);\n        fclose(fp);\n\n        int32_t val;\n        assert(safe_strtol(buffer, &val));\n        pid = (pid_t)val;\n    }\n\n    return pid;\n}\n\nstatic enum test_return test_issue_44(void) {\n    in_port_t port;\n    pid_t pid = start_server(&port, true, 15);\n    assert(kill(pid, SIGHUP) == 0);\n    sleep(1);\n    assert(kill(pid, SIGTERM) == 0);\n\n    return TEST_PASS;\n}\n\nstatic struct addrinfo *lookuphost(const char *hostname, in_port_t port)\n{\n    struct addrinfo *ai = 0;\n    struct addrinfo hints = { .ai_family = AF_UNSPEC,\n                              .ai_protocol = IPPROTO_TCP,\n                              .ai_socktype = SOCK_STREAM };\n    char service[NI_MAXSERV];\n    int error;\n\n    (void)snprintf(service, NI_MAXSERV, \"%d\", port);\n    if ((error = getaddrinfo(hostname, service, &hints, &ai)) != 0) {\n       if (error != EAI_SYSTEM) {\n          fprintf(stderr, \"getaddrinfo(): %s\\n\", gai_strerror(error));\n       } else {\n          perror(\"getaddrinfo()\");\n       }\n    }\n\n    return ai;\n}\n\nstatic int connect_server(const char *hostname, in_port_t port, bool nonblock)\n{\n    struct addrinfo *ai = lookuphost(hostname, port);\n    int sock = -1;\n    if (ai != NULL) {\n       if ((sock = socket(ai->ai_family, ai->ai_socktype,\n                          ai->ai_protocol)) != -1) {\n          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {\n             fprintf(stderr, \"Failed to connect socket: %s\\n\",\n                     strerror(errno));\n             close(sock);\n             sock = -1;\n          } else if (nonblock) {\n              int flags = fcntl(sock, F_GETFL, 0);\n              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {\n                  fprintf(stderr, \"Failed to enable nonblocking mode: %s\\n\",\n                          strerror(errno));\n                  close(sock);\n                  sock = -1;\n              }\n          }\n       } else {\n          fprintf(stderr, \"Failed to create socket: %s\\n\", strerror(errno));\n       }\n\n       freeaddrinfo(ai);\n    }\n    return sock;\n}\n\nstatic enum test_return test_vperror(void) {\n    int rv = 0;\n    int oldstderr = dup(STDERR_FILENO);\n    char tmpl[sizeof(TMP_TEMPLATE)+1];\n    strncpy(tmpl, TMP_TEMPLATE, sizeof(TMP_TEMPLATE)+1);\n\n    int newfile = mkstemp(tmpl);\n    assert(newfile > 0);\n    rv = dup2(newfile, STDERR_FILENO);\n    assert(rv == STDERR_FILENO);\n    rv = close(newfile);\n    assert(rv == 0);\n\n    errno = EIO;\n    vperror(\"Old McDonald had a farm.  %s\", \"EI EIO\");\n\n    /* Restore stderr */\n    rv = dup2(oldstderr, STDERR_FILENO);\n    assert(rv == STDERR_FILENO);\n\n\n    /* Go read the file */\n    char buf[80] = { 0 };\n    FILE *efile = fopen(tmpl, \"r\");\n    assert(efile);\n    char *prv = fgets(buf, sizeof(buf), efile);\n    assert(prv);\n    fclose(efile);\n\n    unlink(tmpl);\n\n    char expected[80] = { 0 };\n    snprintf(expected, sizeof(expected),\n             \"Old McDonald had a farm.  EI EIO: %s\\n\", strerror(EIO));\n\n    /*\n    fprintf(stderr,\n            \"\\nExpected:  ``%s''\"\n            \"\\nGot:       ``%s''\\n\", expected, buf);\n    */\n\n    return strcmp(expected, buf) == 0 ? TEST_PASS : TEST_FAIL;\n}\n\nstatic void send_ascii_command(const char *buf) {\n    off_t offset = 0;\n    const char* ptr = buf;\n    size_t len = strlen(buf);\n\n    do {\n        ssize_t nw = write(sock, ptr + offset, len - offset);\n        if (nw == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to write: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            offset += nw;\n        }\n    } while (offset < len);\n}\n\n/*\n * This is a dead slow single byte read, but it should only read out\n * _one_ response and I don't have an input buffer... The current\n * implementation only supports single-line responses, so if you want to use\n * it for get commands you need to implement that first ;-)\n */\nstatic void read_ascii_response(char *buffer, size_t size) {\n    off_t offset = 0;\n    bool need_more = true;\n    do {\n        ssize_t nr = read(sock, buffer + offset, 1);\n        if (nr == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to read: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            assert(nr == 1);\n            if (buffer[offset] == '\\n') {\n                need_more = false;\n                buffer[offset + 1] = '\\0';\n            }\n            offset += nr;\n            assert(offset + 1 < size);\n        }\n    } while (need_more);\n}\n\nstatic enum test_return test_issue_92(void) {\n    char buffer[1024];\n\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n\n    send_ascii_command(\"stats cachedump 1 0 0\\r\\n\");\n    read_ascii_response(buffer, sizeof(buffer));\n    assert(strncmp(buffer, \"END\", strlen(\"END\")) == 0);\n\n    send_ascii_command(\"stats cachedump 200 0 0\\r\\n\");\n    read_ascii_response(buffer, sizeof(buffer));\n    assert(strncmp(buffer, \"CLIENT_ERROR\", strlen(\"CLIENT_ERROR\")) == 0);\n\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n    return TEST_PASS;\n}\n\nstatic enum test_return test_issue_102(void) {\n    char buffer[4096];\n    memset(buffer, ' ', sizeof(buffer));\n    buffer[sizeof(buffer) - 1] = '\\0';\n\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n\n    send_ascii_command(buffer);\n    /* verify that the server closed the connection */\n    assert(read(sock, buffer, sizeof(buffer)) == 0);\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n    return TEST_PASS;\n}\n\nstatic enum test_return start_memcached_server(void) {\n    server_pid = start_server(&port, false, 600);\n    sock = connect_server(\"127.0.0.1\", port, false);\n    return TEST_PASS;\n}\n\nstatic enum test_return stop_memcached_server(void) {\n    close(sock);\n    assert(kill(server_pid, SIGTERM) == 0);\n    return TEST_PASS;\n}\n\nstatic void safe_send(const void* buf, size_t len, bool hickup)\n{\n    off_t offset = 0;\n    const char* ptr = buf;\n#ifdef MESSAGE_DEBUG\n    uint8_t val = *ptr;\n    assert(val == (uint8_t)0x80);\n    fprintf(stderr, \"About to send %lu bytes:\", (unsigned long)len);\n    for (int ii = 0; ii < len; ++ii) {\n        if (ii % 4 == 0) {\n            fprintf(stderr, \"\\n   \");\n        }\n        val = *(ptr + ii);\n        fprintf(stderr, \" 0x%02x\", val);\n    }\n    fprintf(stderr, \"\\n\");\n    usleep(500);\n#endif\n\n    do {\n        size_t num_bytes = len - offset;\n        if (hickup) {\n            if (num_bytes > 1024) {\n                num_bytes = (rand() % 1023) + 1;\n            }\n        }\n\n        ssize_t nw = write(sock, ptr + offset, num_bytes);\n        if (nw == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to write: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            if (hickup) {\n                usleep(100);\n            }\n            offset += nw;\n        }\n    } while (offset < len);\n}\n\nstatic bool safe_recv(void *buf, size_t len) {\n    if (len == 0) {\n        return true;\n    }\n    off_t offset = 0;\n    do {\n        ssize_t nr = read(sock, ((char*)buf) + offset, len - offset);\n        if (nr == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to read: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            if (nr == 0 && allow_closed_read) {\n                return false;\n            }\n            assert(nr != 0);\n            offset += nr;\n        }\n    } while (offset < len);\n\n    return true;\n}\n\nstatic bool safe_recv_packet(void *buf, size_t size) {\n    protocol_binary_response_no_extras *response = buf;\n    assert(size > sizeof(*response));\n    if (!safe_recv(response, sizeof(*response))) {\n        return false;\n    }\n    response->message.header.response.keylen = ntohs(response->message.header.response.keylen);\n    response->message.header.response.status = ntohs(response->message.header.response.status);\n    response->message.header.response.bodylen = ntohl(response->message.header.response.bodylen);\n\n    size_t len = sizeof(*response);\n\n    char *ptr = buf;\n    ptr += len;\n    if (!safe_recv(ptr, response->message.header.response.bodylen)) {\n        return false;\n    }\n\n#ifdef MESSAGE_DEBUG\n    usleep(500);\n    ptr = buf;\n    len += response->message.header.response.bodylen;\n    uint8_t val = *ptr;\n    assert(val == (uint8_t)0x81);\n    fprintf(stderr, \"Received %lu bytes:\", (unsigned long)len);\n    for (int ii = 0; ii < len; ++ii) {\n        if (ii % 4 == 0) {\n            fprintf(stderr, \"\\n   \");\n        }\n        val = *(ptr + ii);\n        fprintf(stderr, \" 0x%02x\", val);\n    }\n    fprintf(stderr, \"\\n\");\n#endif\n    return true;\n}\n\nstatic off_t storage_command(char*buf,\n                             size_t bufsz,\n                             uint8_t cmd,\n                             const void* key,\n                             size_t keylen,\n                             const void* dta,\n                             size_t dtalen,\n                             uint32_t flags,\n                             uint32_t exp) {\n    /* all of the storage commands use the same command layout */\n    protocol_binary_request_set *request = (void*)buf;\n    assert(bufsz > sizeof(*request) + keylen + dtalen);\n\n    memset(request, 0, sizeof(*request));\n    request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n    request->message.header.request.opcode = cmd;\n    request->message.header.request.keylen = htons(keylen);\n    request->message.header.request.extlen = 8;\n    request->message.header.request.bodylen = htonl(keylen + 8 + dtalen);\n    request->message.header.request.opaque = 0xdeadbeef;\n    request->message.body.flags = flags;\n    request->message.body.expiration = exp;\n\n    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;\n\n    memcpy(buf + key_offset, key, keylen);\n    if (dta != NULL) {\n        memcpy(buf + key_offset + keylen, dta, dtalen);\n    }\n\n    return key_offset + keylen + dtalen;\n}\n\nstatic off_t raw_command(char* buf,\n                         size_t bufsz,\n                         uint8_t cmd,\n                         const void* key,\n                         size_t keylen,\n                         const void* dta,\n                         size_t dtalen) {\n    /* all of the storage commands use the same command layout */\n    protocol_binary_request_no_extras *request = (void*)buf;\n    assert(bufsz > sizeof(*request) + keylen + dtalen);\n\n    memset(request, 0, sizeof(*request));\n    request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n    request->message.header.request.opcode = cmd;\n    request->message.header.request.keylen = htons(keylen);\n    request->message.header.request.bodylen = htonl(keylen + dtalen);\n    request->message.header.request.opaque = 0xdeadbeef;\n\n    off_t key_offset = sizeof(protocol_binary_request_no_extras);\n\n    if (key != NULL) {\n        memcpy(buf + key_offset, key, keylen);\n    }\n    if (dta != NULL) {\n        memcpy(buf + key_offset + keylen, dta, dtalen);\n    }\n\n    return sizeof(*request) + keylen + dtalen;\n}\n\nstatic off_t flush_command(char* buf, size_t bufsz, uint8_t cmd, uint32_t exptime, bool use_extra) {\n    protocol_binary_request_flush *request = (void*)buf;\n    assert(bufsz > sizeof(*request));\n\n    memset(request, 0, sizeof(*request));\n    request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n    request->message.header.request.opcode = cmd;\n\n    off_t size = sizeof(protocol_binary_request_no_extras);\n    if (use_extra) {\n        request->message.header.request.extlen = 4;\n        request->message.body.expiration = htonl(exptime);\n        request->message.header.request.bodylen = htonl(4);\n        size += 4;\n    }\n\n    request->message.header.request.opaque = 0xdeadbeef;\n\n    return size;\n}\n\nstatic off_t arithmetic_command(char* buf,\n                                size_t bufsz,\n                                uint8_t cmd,\n                                const void* key,\n                                size_t keylen,\n                                uint64_t delta,\n                                uint64_t initial,\n                                uint32_t exp) {\n    protocol_binary_request_incr *request = (void*)buf;\n    assert(bufsz > sizeof(*request) + keylen);\n\n    memset(request, 0, sizeof(*request));\n    request->message.header.request.magic = PROTOCOL_BINARY_REQ;\n    request->message.header.request.opcode = cmd;\n    request->message.header.request.keylen = htons(keylen);\n    request->message.header.request.extlen = 20;\n    request->message.header.request.bodylen = htonl(keylen + 20);\n    request->message.header.request.opaque = 0xdeadbeef;\n    request->message.body.delta = htonll(delta);\n    request->message.body.initial = htonll(initial);\n    request->message.body.expiration = htonl(exp);\n\n    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;\n\n    memcpy(buf + key_offset, key, keylen);\n    return key_offset + keylen;\n}\n\nstatic void validate_response_header(protocol_binary_response_no_extras *response,\n                                     uint8_t cmd, uint16_t status)\n{\n    assert(response->message.header.response.magic == PROTOCOL_BINARY_RES);\n    assert(response->message.header.response.opcode == cmd);\n    assert(response->message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);\n    assert(response->message.header.response.status == status);\n    assert(response->message.header.response.opaque == 0xdeadbeef);\n\n    if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {\n        switch (cmd) {\n        case PROTOCOL_BINARY_CMD_ADDQ:\n        case PROTOCOL_BINARY_CMD_APPENDQ:\n        case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        case PROTOCOL_BINARY_CMD_DELETEQ:\n        case PROTOCOL_BINARY_CMD_FLUSHQ:\n        case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        case PROTOCOL_BINARY_CMD_PREPENDQ:\n        case PROTOCOL_BINARY_CMD_QUITQ:\n        case PROTOCOL_BINARY_CMD_REPLACEQ:\n        case PROTOCOL_BINARY_CMD_SETQ:\n            assert(\"Quiet command shouldn't return on success\" == NULL);\n        default:\n            break;\n        }\n\n        switch (cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n        case PROTOCOL_BINARY_CMD_REPLACE:\n        case PROTOCOL_BINARY_CMD_SET:\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 0);\n            assert(response->message.header.response.bodylen == 0);\n            assert(response->message.header.response.cas != 0);\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n        case PROTOCOL_BINARY_CMD_NOOP:\n        case PROTOCOL_BINARY_CMD_QUIT:\n        case PROTOCOL_BINARY_CMD_DELETE:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 0);\n            assert(response->message.header.response.bodylen == 0);\n            assert(response->message.header.response.cas == 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 0);\n            assert(response->message.header.response.bodylen == 8);\n            assert(response->message.header.response.cas != 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_STAT:\n            assert(response->message.header.response.extlen == 0);\n            /* key and value exists in all packets except in the terminating */\n            assert(response->message.header.response.cas == 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_VERSION:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 0);\n            assert(response->message.header.response.bodylen != 0);\n            assert(response->message.header.response.cas == 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_GET:\n        case PROTOCOL_BINARY_CMD_GETQ:\n            assert(response->message.header.response.keylen == 0);\n            assert(response->message.header.response.extlen == 4);\n            assert(response->message.header.response.cas != 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_GETK:\n        case PROTOCOL_BINARY_CMD_GETKQ:\n            assert(response->message.header.response.keylen != 0);\n            assert(response->message.header.response.extlen == 4);\n            assert(response->message.header.response.cas != 0);\n            break;\n\n        default:\n            /* Undefined command code */\n            break;\n        }\n    } else {\n        assert(response->message.header.response.cas == 0);\n        assert(response->message.header.response.extlen == 0);\n        if (cmd != PROTOCOL_BINARY_CMD_GETK) {\n            assert(response->message.header.response.keylen == 0);\n        }\n    }\n}\n\nstatic enum test_return test_binary_noop(void) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } buffer;\n\n    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                             PROTOCOL_BINARY_CMD_NOOP,\n                             NULL, 0, NULL, 0);\n\n    safe_send(buffer.bytes, len, false);\n    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_NOOP,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_quit_impl(uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } buffer;\n    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                             cmd, NULL, 0, NULL, 0);\n\n    safe_send(buffer.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_QUIT) {\n        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_QUIT,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    /* Socket should be closed now, read should return 0 */\n    assert(read(sock, buffer.bytes, sizeof(buffer.bytes)) == 0);\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_quit(void) {\n    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUIT);\n}\n\nstatic enum test_return test_binary_quitq(void) {\n    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUITQ);\n}\n\nstatic enum test_return test_binary_set_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    uint64_t value = 0xdeadbeefdeadcafe;\n    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,\n                                 key, strlen(key), &value, sizeof(value),\n                                 0, 0);\n\n    /* Set should work over and over again */\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_SET) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        }\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_SETQ) {\n        return test_binary_noop();\n    }\n\n    send.request.message.header.request.cas = receive.response.message.header.response.cas;\n    safe_send(send.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_SET) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        assert(receive.response.message.header.response.cas != send.request.message.header.request.cas);\n    } else {\n        return test_binary_noop();\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_set(void) {\n    return test_binary_set_impl(\"test_binary_set\", PROTOCOL_BINARY_CMD_SET);\n}\n\nstatic enum test_return test_binary_setq(void) {\n    return test_binary_set_impl(\"test_binary_setq\", PROTOCOL_BINARY_CMD_SETQ);\n}\n\n\nstatic enum test_return test_binary_add_impl(const char *key, uint8_t cmd) {\n    uint64_t value = 0xdeadbeefdeadcafe;\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd, key,\n                                 strlen(key), &value, sizeof(value),\n                                 0, 0);\n\n    /* Add should only work the first time */\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (ii == 0) {\n            if (cmd == PROTOCOL_BINARY_CMD_ADD) {\n                safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n                validate_response_header(&receive.response, cmd,\n                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);\n            }\n        } else {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS);\n        }\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_add(void) {\n    return test_binary_add_impl(\"test_binary_add\", PROTOCOL_BINARY_CMD_ADD);\n}\n\nstatic enum test_return test_binary_addq(void) {\n    return test_binary_add_impl(\"test_binary_addq\", PROTOCOL_BINARY_CMD_ADDQ);\n}\n\nstatic enum test_return test_binary_replace_impl(const char* key, uint8_t cmd) {\n    uint64_t value = 0xdeadbeefdeadcafe;\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,\n                                 key, strlen(key), &value, sizeof(value),\n                                 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n    len = storage_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_ADD,\n                          key, strlen(key), &value, sizeof(value), 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = storage_command(send.bytes, sizeof(send.bytes), cmd,\n                          key, strlen(key), &value, sizeof(value), 0, 0);\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_REPLACE) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response,\n                                     PROTOCOL_BINARY_CMD_REPLACE,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        }\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_REPLACEQ) {\n        test_binary_noop();\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_replace(void) {\n    return test_binary_replace_impl(\"test_binary_replace\",\n                                    PROTOCOL_BINARY_CMD_REPLACE);\n}\n\nstatic enum test_return test_binary_replaceq(void) {\n    return test_binary_replace_impl(\"test_binary_replaceq\",\n                                    PROTOCOL_BINARY_CMD_REPLACEQ);\n}\n\nstatic enum test_return test_binary_delete_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,\n                             key, strlen(key), NULL, 0);\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n    len = storage_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_ADD,\n                          key, strlen(key), NULL, 0, 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = raw_command(send.bytes, sizeof(send.bytes),\n                      cmd, key, strlen(key), NULL, 0);\n    safe_send(send.bytes, len, false);\n\n    if (cmd == PROTOCOL_BINARY_CMD_DELETE) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_DELETE,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_delete(void) {\n    return test_binary_delete_impl(\"test_binary_delete\",\n                                   PROTOCOL_BINARY_CMD_DELETE);\n}\n\nstatic enum test_return test_binary_deleteq(void) {\n    return test_binary_delete_impl(\"test_binary_deleteq\",\n                                   PROTOCOL_BINARY_CMD_DELETEQ);\n}\n\nstatic enum test_return test_binary_get_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,\n                             key, strlen(key), NULL, 0);\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n\n    len = storage_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_ADD,\n                          key, strlen(key), NULL, 0,\n                          0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    /* run a little pipeline test ;-) */\n    len = 0;\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        union {\n            protocol_binary_request_no_extras request;\n            char bytes[1024];\n        } temp;\n        size_t l = raw_command(temp.bytes, sizeof(temp.bytes),\n                               cmd, key, strlen(key), NULL, 0);\n        memcpy(send.bytes + len, temp.bytes, l);\n        len += l;\n    }\n\n    safe_send(send.bytes, len, false);\n    for (ii = 0; ii < 10; ++ii) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_get(void) {\n    return test_binary_get_impl(\"test_binary_get\", PROTOCOL_BINARY_CMD_GET);\n}\n\nstatic enum test_return test_binary_getk(void) {\n    return test_binary_get_impl(\"test_binary_getk\", PROTOCOL_BINARY_CMD_GETK);\n}\n\nstatic enum test_return test_binary_getq_impl(const char *key, uint8_t cmd) {\n    const char *missing = \"test_binary_getq_missing\";\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, temp, receive;\n    size_t len = storage_command(send.bytes, sizeof(send.bytes),\n                                 PROTOCOL_BINARY_CMD_ADD,\n                                 key, strlen(key), NULL, 0,\n                                 0, 0);\n    size_t len2 = raw_command(temp.bytes, sizeof(temp.bytes), cmd,\n                             missing, strlen(missing), NULL, 0);\n    /* I need to change the first opaque so that I can separate the two\n     * return packets */\n    temp.request.message.header.request.opaque = 0xfeedface;\n    memcpy(send.bytes + len, temp.bytes, len2);\n    len += len2;\n\n    len2 = raw_command(temp.bytes, sizeof(temp.bytes), cmd,\n                       key, strlen(key), NULL, 0);\n    memcpy(send.bytes + len, temp.bytes, len2);\n    len += len2;\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    /* The first GETQ shouldn't return anything */\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_getq(void) {\n    return test_binary_getq_impl(\"test_binary_getq\", PROTOCOL_BINARY_CMD_GETQ);\n}\n\nstatic enum test_return test_binary_getkq(void) {\n    return test_binary_getq_impl(\"test_binary_getkq\", PROTOCOL_BINARY_CMD_GETKQ);\n}\n\nstatic enum test_return test_binary_incr_impl(const char* key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response_header;\n        protocol_binary_response_incr response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,\n                                    key, strlen(key), 1, 0, 0);\n\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response_header, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n            assert(ntohll(receive.response.message.body.value) == ii);\n        }\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENTQ) {\n        test_binary_noop();\n    }\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_incr(void) {\n    return test_binary_incr_impl(\"test_binary_incr\",\n                                 PROTOCOL_BINARY_CMD_INCREMENT);\n}\n\nstatic enum test_return test_binary_incrq(void) {\n    return test_binary_incr_impl(\"test_binary_incrq\",\n                                 PROTOCOL_BINARY_CMD_INCREMENTQ);\n}\n\nstatic enum test_return test_binary_decr_impl(const char* key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response_header;\n        protocol_binary_response_decr response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,\n                                    key, strlen(key), 1, 9, 0);\n\n    int ii;\n    for (ii = 9; ii >= 0; --ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response_header, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n            assert(ntohll(receive.response.message.body.value) == ii);\n        }\n    }\n\n    /* decr on 0 should not wrap */\n    safe_send(send.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response_header, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        assert(ntohll(receive.response.message.body.value) == 0);\n    } else {\n        test_binary_noop();\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_decr(void) {\n    return test_binary_decr_impl(\"test_binary_decr\",\n                                 PROTOCOL_BINARY_CMD_DECREMENT);\n}\n\nstatic enum test_return test_binary_decrq(void) {\n    return test_binary_decr_impl(\"test_binary_decrq\",\n                                 PROTOCOL_BINARY_CMD_DECREMENTQ);\n}\n\nstatic enum test_return test_binary_version(void) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } buffer;\n\n    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                             PROTOCOL_BINARY_CMD_VERSION,\n                             NULL, 0, NULL, 0);\n\n    safe_send(buffer.bytes, len, false);\n    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_VERSION,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_flush_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n\n    size_t len = storage_command(send.bytes, sizeof(send.bytes),\n                                 PROTOCOL_BINARY_CMD_ADD,\n                                 key, strlen(key), NULL, 0, 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = flush_command(send.bytes, sizeof(send.bytes), cmd, 2, true);\n    safe_send(send.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    len = raw_command(send.bytes, sizeof(send.bytes), PROTOCOL_BINARY_CMD_GET,\n                      key, strlen(key), NULL, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    sleep(2);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n\n    int ii;\n    for (ii = 0; ii < 2; ++ii) {\n        len = storage_command(send.bytes, sizeof(send.bytes),\n                              PROTOCOL_BINARY_CMD_ADD,\n                              key, strlen(key), NULL, 0, 0, 0);\n        safe_send(send.bytes, len, false);\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n        len = flush_command(send.bytes, sizeof(send.bytes), cmd, 0, ii == 0);\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        }\n\n        len = raw_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_GET,\n                          key, strlen(key), NULL, 0);\n        safe_send(send.bytes, len, false);\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                                 PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n    }\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_flush(void) {\n    return test_binary_flush_impl(\"test_binary_flush\",\n                                  PROTOCOL_BINARY_CMD_FLUSH);\n}\n\nstatic enum test_return test_binary_flushq(void) {\n    return test_binary_flush_impl(\"test_binary_flushq\",\n                                  PROTOCOL_BINARY_CMD_FLUSHQ);\n}\n\nstatic enum test_return test_binary_concat_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n    const char *value = \"world\";\n\n    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,\n                              key, strlen(key), value, strlen(value));\n\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, cmd,\n                             PROTOCOL_BINARY_RESPONSE_NOT_STORED);\n\n    len = storage_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_ADD,\n                          key, strlen(key), value, strlen(value), 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = raw_command(send.bytes, sizeof(send.bytes), cmd,\n                      key, strlen(key), value, strlen(value));\n    safe_send(send.bytes, len, false);\n\n    if (cmd == PROTOCOL_BINARY_CMD_APPEND || cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    } else {\n        len = raw_command(send.bytes, sizeof(send.bytes), PROTOCOL_BINARY_CMD_NOOP,\n                          NULL, 0, NULL, 0);\n        safe_send(send.bytes, len, false);\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_NOOP,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    len = raw_command(send.bytes, sizeof(send.bytes), PROTOCOL_BINARY_CMD_GETK,\n                      key, strlen(key), NULL, 0);\n\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GETK,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    assert(receive.response.message.header.response.keylen == strlen(key));\n    assert(receive.response.message.header.response.bodylen == (strlen(key) + 2*strlen(value) + 4));\n\n    char *ptr = receive.bytes;\n    ptr += sizeof(receive.response);\n    ptr += 4;\n\n    assert(memcmp(ptr, key, strlen(key)) == 0);\n    ptr += strlen(key);\n    assert(memcmp(ptr, value, strlen(value)) == 0);\n    ptr += strlen(value);\n    assert(memcmp(ptr, value, strlen(value)) == 0);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_append(void) {\n    return test_binary_concat_impl(\"test_binary_append\",\n                                   PROTOCOL_BINARY_CMD_APPEND);\n}\n\nstatic enum test_return test_binary_prepend(void) {\n    return test_binary_concat_impl(\"test_binary_prepend\",\n                                   PROTOCOL_BINARY_CMD_PREPEND);\n}\n\nstatic enum test_return test_binary_appendq(void) {\n    return test_binary_concat_impl(\"test_binary_appendq\",\n                                   PROTOCOL_BINARY_CMD_APPENDQ);\n}\n\nstatic enum test_return test_binary_prependq(void) {\n    return test_binary_concat_impl(\"test_binary_prependq\",\n                                   PROTOCOL_BINARY_CMD_PREPENDQ);\n}\n\nstatic enum test_return test_binary_stat(void) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } buffer;\n\n    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                             PROTOCOL_BINARY_CMD_STAT,\n                             NULL, 0, NULL, 0);\n\n    safe_send(buffer.bytes, len, false);\n    do {\n        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_STAT,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    } while (buffer.response.message.header.response.keylen != 0);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_illegal(void) {\n    uint8_t cmd = 0x23;\n    while (cmd != 0x00) {\n        union {\n            protocol_binary_request_no_extras request;\n            protocol_binary_response_no_extras response;\n            char bytes[1024];\n        } buffer;\n        size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),\n                                 cmd, NULL, 0, NULL, 0);\n        safe_send(buffer.bytes, len, false);\n        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));\n        validate_response_header(&buffer.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND);\n        ++cmd;\n    }\n\n    return TEST_PASS;\n}\n\nvolatile bool hickup_thread_running;\n\nstatic void *binary_hickup_recv_verification_thread(void *arg) {\n    protocol_binary_response_no_extras *response = malloc(65*1024);\n    if (response != NULL) {\n        while (safe_recv_packet(response, 65*1024)) {\n            /* Just validate the packet format */\n            validate_response_header(response,\n                                     response->message.header.response.opcode,\n                                     response->message.header.response.status);\n        }\n        free(response);\n    }\n    hickup_thread_running = false;\n    allow_closed_read = false;\n    return NULL;\n}\n\nstatic enum test_return test_binary_pipeline_hickup_chunk(void *buffer, size_t buffersize) {\n    off_t offset = 0;\n    char *key[256];\n    uint64_t value = 0xfeedfacedeadbeef;\n\n    while (hickup_thread_running &&\n           offset + sizeof(protocol_binary_request_no_extras) < buffersize) {\n        union {\n            protocol_binary_request_no_extras request;\n            char bytes[65 * 1024];\n        } command;\n        uint8_t cmd = (uint8_t)(rand() & 0xff);\n        size_t len;\n        size_t keylen = (rand() % 250) + 1;\n\n        switch (cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n        case PROTOCOL_BINARY_CMD_ADDQ:\n        case PROTOCOL_BINARY_CMD_REPLACE:\n        case PROTOCOL_BINARY_CMD_REPLACEQ:\n        case PROTOCOL_BINARY_CMD_SET:\n        case PROTOCOL_BINARY_CMD_SETQ:\n            len = storage_command(command.bytes, sizeof(command.bytes), cmd,\n                                  key, keylen , &value, sizeof(value),\n                                  0, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_APPENDQ:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n        case PROTOCOL_BINARY_CMD_PREPENDQ:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                              key, keylen, &value, sizeof(value));\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n        case PROTOCOL_BINARY_CMD_FLUSHQ:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                              NULL, 0, NULL, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                              NULL, 0, NULL, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n        case PROTOCOL_BINARY_CMD_DELETEQ:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                             key, keylen, NULL, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_INCREMENTQ:\n            len = arithmetic_command(command.bytes, sizeof(command.bytes), cmd,\n                                     key, keylen, 1, 0, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_VERSION:\n            len = raw_command(command.bytes, sizeof(command.bytes),\n                             PROTOCOL_BINARY_CMD_VERSION,\n                             NULL, 0, NULL, 0);\n            break;\n        case PROTOCOL_BINARY_CMD_GET:\n        case PROTOCOL_BINARY_CMD_GETK:\n        case PROTOCOL_BINARY_CMD_GETKQ:\n        case PROTOCOL_BINARY_CMD_GETQ:\n            len = raw_command(command.bytes, sizeof(command.bytes), cmd,\n                             key, keylen, NULL, 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_STAT:\n            len = raw_command(command.bytes, sizeof(command.bytes),\n                              PROTOCOL_BINARY_CMD_STAT,\n                              NULL, 0, NULL, 0);\n            break;\n\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            /* Ignoring SASL */\n        case PROTOCOL_BINARY_CMD_QUITQ:\n        case PROTOCOL_BINARY_CMD_QUIT:\n            /* I don't want to pass on the quit commands ;-) */\n            cmd |= 0xf0;\n            /* FALLTHROUGH */\n        default:\n            len = raw_command(command.bytes, sizeof(command.bytes),\n                              cmd, NULL, 0, NULL, 0);\n        }\n\n        if ((len + offset) < buffersize) {\n            memcpy(((char*)buffer) + offset, command.bytes, len);\n            offset += len;\n        } else {\n            break;\n        }\n    }\n    safe_send(buffer, offset, true);\n\n    return TEST_PASS;\n}\n\nstatic enum test_return test_binary_pipeline_hickup(void)\n{\n    size_t buffersize = 65 * 1024;\n    void *buffer = malloc(buffersize);\n    int ii;\n\n    pthread_t tid;\n    int ret;\n    allow_closed_read = true;\n    hickup_thread_running = true;\n    if ((ret = pthread_create(&tid, NULL,\n                              binary_hickup_recv_verification_thread, NULL)) != 0) {\n        fprintf(stderr, \"Can't create thread: %s\\n\", strerror(ret));\n        return TEST_FAIL;\n    }\n\n    /* Allow the thread to start */\n    usleep(250);\n\n    srand((int)time(NULL));\n    for (ii = 0; ii < 2; ++ii) {\n        test_binary_pipeline_hickup_chunk(buffer, buffersize);\n    }\n\n    /* send quitq to shut down the read thread ;-) */\n    size_t len = raw_command(buffer, buffersize, PROTOCOL_BINARY_CMD_QUITQ,\n                             NULL, 0, NULL, 0);\n    safe_send(buffer, len, false);\n\n    pthread_join(tid, NULL);\n    free(buffer);\n    return TEST_PASS;\n}\n\ntypedef enum test_return (*TEST_FUNC)(void);\nstruct testcase {\n    const char *description;\n    TEST_FUNC function;\n};\n\nstruct testcase testcases[] = {\n    { \"cache_create\", cache_create_test },\n    { \"cache_constructor\", cache_constructor_test },\n    { \"cache_constructor_fail\", cache_fail_constructor_test },\n    { \"cache_destructor\", cache_destructor_test },\n    { \"cache_reuse\", cache_reuse_test },\n    { \"cache_redzone\", cache_redzone_test },\n    { \"strtol\", test_safe_strtol },\n    { \"strtoll\", test_safe_strtoll },\n    { \"strtoul\", test_safe_strtoul },\n    { \"strtoull\", test_safe_strtoull },\n    { \"issue_44\", test_issue_44 },\n    { \"vperror\", test_vperror },\n    /* The following tests all run towards the same server */\n    { \"start_server\", start_memcached_server },\n    { \"issue_92\", test_issue_92 },\n    { \"issue_102\", test_issue_102 },\n    { \"binary_noop\", test_binary_noop },\n    { \"binary_quit\", test_binary_quit },\n    { \"binary_quitq\", test_binary_quitq },\n    { \"binary_set\", test_binary_set },\n    { \"binary_setq\", test_binary_setq },\n    { \"binary_add\", test_binary_add },\n    { \"binary_addq\", test_binary_addq },\n    { \"binary_replace\", test_binary_replace },\n    { \"binary_replaceq\", test_binary_replaceq },\n    { \"binary_delete\", test_binary_delete },\n    { \"binary_deleteq\", test_binary_deleteq },\n    { \"binary_get\", test_binary_get },\n    { \"binary_getq\", test_binary_getq },\n    { \"binary_getk\", test_binary_getk },\n    { \"binary_getkq\", test_binary_getkq },\n    { \"binary_incr\", test_binary_incr },\n    { \"binary_incrq\", test_binary_incrq },\n    { \"binary_decr\", test_binary_decr },\n    { \"binary_decrq\", test_binary_decrq },\n    { \"binary_version\", test_binary_version },\n    { \"binary_flush\", test_binary_flush },\n    { \"binary_flushq\", test_binary_flushq },\n    { \"binary_append\", test_binary_append },\n    { \"binary_appendq\", test_binary_appendq },\n    { \"binary_prepend\", test_binary_prepend },\n    { \"binary_prependq\", test_binary_prependq },\n    { \"binary_stat\", test_binary_stat },\n    { \"binary_illegal\", test_binary_illegal },\n    { \"binary_pipeline_hickup\", test_binary_pipeline_hickup },\n    { \"stop_server\", stop_memcached_server },\n    { NULL, NULL }\n};\n\nint main(int argc, char **argv)\n{\n    int exitcode = 0;\n    int ii = 0, num_cases = 0;\n\n    for (num_cases = 0; testcases[num_cases].description; num_cases++) {\n        /* Just counting */\n    }\n\n    printf(\"1..%d\\n\", num_cases);\n\n    for (ii = 0; testcases[ii].description != NULL; ++ii) {\n        fflush(stdout);\n#ifndef DEBUG\n        /* the test program shouldn't run longer than 10 minutes... */\n        alarm(600);\n#endif\n        enum test_return ret = testcases[ii].function();\n        if (ret == TEST_SKIP) {\n            fprintf(stdout, \"ok # SKIP %d - %s\\n\", ii + 1, testcases[ii].description);\n        } else if (ret == TEST_PASS) {\n            fprintf(stdout, \"ok %d - %s\\n\", ii + 1, testcases[ii].description);\n        } else {\n            fprintf(stdout, \"not ok %d - %s\\n\", ii + 1, testcases[ii].description);\n            exitcode = 1;\n        }\n        fflush(stdout);\n    }\n\n    return exitcode;\n}\n"], "filenames": ["memcached.c", "testapp.c"], "buggy_code_start_loc": [3129, 540], "buggy_code_end_loc": [3209, 1678], "fixing_code_start_loc": [3130, 541], "fixing_code_end_loc": [3237, 1696], "type": "CWE-20", "message": "memcached.c in memcached before 1.4.3 allows remote attackers to cause a denial of service (daemon hang or crash) via a long line that triggers excessive memory allocation. NOTE: some of these details are obtained from third party information.", "other": {"cve": {"id": "CVE-2010-1152", "sourceIdentifier": "secalert@redhat.com", "published": "2010-04-12T18:30:00.837", "lastModified": "2023-02-13T04:17:05.780", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "memcached.c in memcached before 1.4.3 allows remote attackers to cause a denial of service (daemon hang or crash) via a long line that triggers excessive memory allocation. NOTE: some of these details are obtained from third party information."}, {"lang": "es", "value": "memcached.c en memcached anterior a v1.4.3 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (fallo o bloqueo del demonio) a trav\u00e9s de una l\u00ednea larga que dispara la asignaci\u00f3n de memoria excesiva. NOTA: algunos de estos detalles han sido obtenidos de informaci\u00f3n de terceros."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.2", "matchCriteriaId": "A05D93F0-7569-4465-99B4-09BB7333F875"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:0.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "5F664659-721C-4387-A06C-AD30DD9AF762"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:0.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "18A83632-06E4-4978-909A-5E145F7A654F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:0.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "9A511459-F98A-4192-8E79-24766D296A47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:0.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "8DC3886A-4C1B-49B9-A334-E9A1C8CA5309"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:0.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "AD764B57-6985-4DD2-BA3C-09912715A56A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:0.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "E433DCE9-8C2E-47AC-907E-8306D322D0A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.0.0:beta:*:*:*:*:*:*", "matchCriteriaId": "8164AFC1-6320-44C1-8872-9C26A5E1C173"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.0.1:beta:*:*:*:*:*:*", "matchCriteriaId": "6397D3FD-EF1F-4B0C-BA6C-26131820A653"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.0.2:beta:*:*:*:*:*:*", "matchCriteriaId": "2616A383-92BE-4FD2-8A62-8A2CF1F69830"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "F500EE98-0AAA-4C9E-91DF-313E6812CC50"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "DF0C217E-B2E4-472A-AE6A-C95D73C8FE4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.1.0:beta:*:*:*:*:*:*", "matchCriteriaId": "07FCB8CB-1434-4486-858D-BC509246231D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.1.12:*:*:*:*:*:*:*", "matchCriteriaId": "84BF997C-79FB-41F3-A4F5-455652BB2015"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8932E944-B3D8-489C-89C2-0A870AF51428"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.2.0:beta:*:*:*:*:*:*", "matchCriteriaId": "6BE87DDD-FF8E-47B2-A30B-7C32ADA6C02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.2.1:beta:*:*:*:*:*:*", "matchCriteriaId": "A76FC002-9B7C-4F3D-A2E7-E416CD6C6336"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E8789BF3-CA97-4DA2-99C4-53350CEEBB62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "45A81180-5F55-4E8B-B4AF-8B646D694945"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "D286241F-9DAE-43A1-80CE-701C7369F41D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:memcachedb:memcached:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "431884EE-1F51-4BAF-931D-27BAB9AD3317"}]}]}], "references": [{"url": "http://blogs.sun.com/security/entry/input_validation_vulnerability_in_memcached", "source": "secalert@redhat.com"}, {"url": "http://code.google.com/p/memcached/issues/detail?id=102", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "http://github.com/memcached/memcached/commit/75cc83685e103bc8ba380a57468c8f04413033f9", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://github.com/memcached/memcached/commit/d9cd01ede97f4145af9781d448c62a3318952719", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2010-05/msg00002.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2010-06/msg00001.html", "source": "secalert@redhat.com"}, {"url": "http://marc.info/?l=oss-security&m=127074597129559&w=2", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://marc.info/?l=oss-security&m=127075341110616&w=2", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://marc.info/?l=oss-security&m=127075808518733&w=2", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://securitytracker.com/id?1023839", "source": "secalert@redhat.com"}, {"url": "http://www.vupen.com/english/advisories/2011/0442", "source": "secalert@redhat.com"}]}, "github_commit_url": "http://github.com/memcached/memcached/commit/75cc83685e103bc8ba380a57468c8f04413033f9"}}