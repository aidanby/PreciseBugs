{"buggy_code": ["/**\n * @module node-opcua-client-private\n */\nimport { EventEmitter } from \"events\";\nimport * as chalk from \"chalk\";\nimport { assert } from \"node-opcua-assert\";\nimport { AggregateFunction } from \"node-opcua-constants\";\nimport { DateTime } from \"node-opcua-basic-types\";\nimport {\n    ExtraDataTypeManager,\n    getExtensionObjectConstructor,\n    getExtraDataTypeManager,\n    promoteOpaqueStructure,\n} from \"node-opcua-client-dynamic-extension-object\";\nimport { Certificate, Nonce } from \"node-opcua-crypto\";\nimport { attributeNameById, BrowseDirection, LocalizedTextLike } from \"node-opcua-data-model\";\nimport { DataValue } from \"node-opcua-data-value\";\nimport { checkDebugFlag, make_debugLog, make_errorLog, make_warningLog } from \"node-opcua-debug\";\nimport { ExtensionObject } from \"node-opcua-extension-object\";\nimport { coerceNodeId, NodeId, NodeIdLike, resolveNodeId } from \"node-opcua-nodeid\";\nimport { getBuiltInDataType, getArgumentDefinitionHelper, IBasicSession } from \"node-opcua-pseudo-session\";\nimport { AnyConstructorFunc } from \"node-opcua-schemas\";\nimport { requestHandleNotSetValue, SignatureData } from \"node-opcua-secure-channel\";\nimport { BrowseDescription, BrowseRequest, BrowseResponse, BrowseResult } from \"node-opcua-service-browse\";\nimport { CallMethodRequest, CallMethodResult, CallRequest, CallResponse } from \"node-opcua-service-call\";\nimport { EndpointDescription } from \"node-opcua-service-endpoints\";\nimport {\n    HistoryReadRequest,\n    HistoryReadResponse,\n    HistoryReadResult,\n    ReadRawModifiedDetails,\n    ReadProcessedDetails\n} from \"node-opcua-service-history\";\nimport { QueryFirstRequest, QueryFirstResponse } from \"node-opcua-service-query\";\nimport {\n    AttributeIds,\n    ReadRequest,\n    ReadResponse,\n    ReadValueId,\n    ReadValueIdOptions,\n    TimestampsToReturn\n} from \"node-opcua-service-read\";\nimport {\n    RegisterNodesRequest,\n    RegisterNodesResponse,\n    UnregisterNodesRequest,\n    UnregisterNodesResponse\n} from \"node-opcua-service-register-node\";\nimport {\n    CreateMonitoredItemsRequest,\n    CreateMonitoredItemsResponse,\n    CreateSubscriptionRequest,\n    CreateSubscriptionResponse,\n    DeleteMonitoredItemsRequest,\n    DeleteMonitoredItemsResponse,\n    DeleteSubscriptionsRequest,\n    DeleteSubscriptionsResponse,\n    ModifyMonitoredItemsRequest,\n    ModifyMonitoredItemsResponse,\n    ModifySubscriptionRequest,\n    ModifySubscriptionResponse,\n    PublishRequest,\n    PublishResponse,\n    RepublishRequest,\n    RepublishResponse,\n    SetMonitoringModeRequest,\n    SetMonitoringModeResponse,\n    SetPublishingModeRequest,\n    SetPublishingModeResponse,\n    SetTriggeringRequestOptions,\n    SetTriggeringResponse,\n    SetTriggeringRequest,\n    TransferSubscriptionsRequest,\n    TransferSubscriptionsResponse\n} from \"node-opcua-service-subscription\";\nimport {\n    BrowsePath,\n    BrowsePathResult,\n    TranslateBrowsePathsToNodeIdsRequest,\n    TranslateBrowsePathsToNodeIdsResponse\n} from \"node-opcua-service-translate-browse-path\";\nimport { WriteRequest, WriteResponse, WriteValue } from \"node-opcua-service-write\";\nimport { StatusCode, StatusCodes, Callback, CallbackT } from \"node-opcua-status-code\";\nimport { ErrorCallback } from \"node-opcua-status-code\";\nimport { BrowseNextRequest, BrowseNextResponse, HistoryReadValueIdOptions, WriteValueOptions } from \"node-opcua-types\";\nimport { buffer_ellipsis, getFunctionParameterNames, isNullOrUndefined, lowerFirstLetter } from \"node-opcua-utils\";\nimport { DataType, Variant, VariantLike } from \"node-opcua-variant\";\n\nimport {\n    ArgumentDefinition,\n    BrowseDescriptionLike,\n    CallMethodRequestLike,\n    ClientSession,\n    CreateMonitoredItemsRequestLike,\n    CreateSubscriptionRequestLike,\n    DeleteMonitoredItemsRequestLike,\n    DeleteSubscriptionsRequestLike,\n    MethodId,\n    ModifyMonitoredItemsRequestLike,\n    ModifySubscriptionRequestLike,\n    MonitoredItemData,\n    NodeAttributes,\n    QueryFirstRequestLike,\n    SetMonitoringModeRequestLike,\n    SubscriptionId,\n    TransferSubscriptionsRequestLike,\n    HistoryReadValueIdOptions2,\n    ExtraReadHistoryValueParameters\n} from \"../client_session\";\nimport { ClientSessionKeepAliveManager } from \"../client_session_keepalive_manager\";\nimport { ClientSubscription } from \"../client_subscription\";\nimport { Request, Response } from \"../common\";\nimport { repair_client_session } from \"../reconnection\";\n\nimport { ClientSidePublishEngine } from \"./client_publish_engine\";\nimport { ClientSubscriptionImpl } from \"./client_subscription_impl\";\nimport { IClientBase } from \"./i_private_client\";\n\nexport type ResponseCallback<T> = (err: Error | null, response?: T) => void;\n\nconst helpAPIChange = process.env.DEBUG && process.env.DEBUG.match(/API/);\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\nconst warningLog = make_warningLog(__filename);\nconst errorLog = make_errorLog(__filename);\n\nlet pendingTransactionMessageDisplayed = false;\n\nfunction coerceBrowseDescription(data: any): BrowseDescription {\n    if (typeof data === \"string\" || data instanceof NodeId) {\n        return coerceBrowseDescription({\n            browseDirection: BrowseDirection.Forward,\n            includeSubtypes: true,\n            nodeClassMask: 0,\n            nodeId: data,\n            referenceTypeId: \"HierarchicalReferences\",\n            resultMask: 63\n        });\n    } else {\n        data.nodeId = resolveNodeId(data.nodeId);\n        data.referenceTypeId = data.referenceTypeId ? resolveNodeId(data.referenceTypeId) : null;\n        return new BrowseDescription(data);\n    }\n}\n\nfunction coerceReadValueId(node: any): ReadValueId {\n    if (typeof node === \"string\" || node instanceof NodeId) {\n        return new ReadValueId({\n            attributeId: AttributeIds.Value,\n            dataEncoding: undefined, // {namespaceIndex: 0, name: undefined}\n            indexRange: undefined,\n            nodeId: resolveNodeId(node)\n        });\n    } else {\n        assert(node instanceof Object);\n        return new ReadValueId(node);\n    }\n}\n\nconst keys = Object.keys(AttributeIds).filter((k: any) => (AttributeIds as any)[k] !== AttributeIds.INVALID);\n\nconst attributeNames: string[] = ((): string[] => {\n    const r: string[] = [];\n    for (let i = 1; i <= 22; i++) {\n        r.push(attributeNameById[i].toString());\n    }\n    return r;\n})();\n\nfunction composeResult(nodes: any[], nodesToRead: ReadValueIdOptions[], dataValues: DataValue[]): NodeAttributes[] {\n    assert(nodesToRead.length === dataValues.length);\n    let c = 0;\n    const results = [];\n    let dataValue;\n    let k;\n    let nodeToRead;\n\n    for (const node of nodes) {\n        const data: NodeAttributes = {\n            nodeId: resolveNodeId(node),\n            statusCode: StatusCodes.BadNodeIdUnknown\n        };\n\n        let addedProperty = 0;\n\n        for (const key of attributeNames) {\n            dataValue = dataValues[c];\n            nodeToRead = nodesToRead[c];\n            c++;\n            if (dataValue.statusCode.equals(StatusCodes.Good)) {\n                k = lowerFirstLetter(key);\n                data[k] = dataValue.value ? dataValue.value.value : null;\n                addedProperty += 1;\n            }\n        }\n\n        /* istanbul ignore if */\n        if (addedProperty > 0) {\n            data.statusCode = StatusCodes.Good;\n        } else {\n            data.statusCode = StatusCodes.BadNodeIdUnknown;\n        }\n        results.push(data);\n    }\n\n    return results;\n}\n\nconst emptyUint32Array = new Uint32Array(0);\n\ntype EmptyCallback = (err?: Error) => void;\n\nexport interface Reconnectable {\n    _reconnecting: {\n        reconnecting: boolean;\n        pendingCallbacks: EmptyCallback[];\n    };\n    pendingTransactions: any[];\n    pendingTransactionsCount: number;\n}\n/**\n * @class ClientSession\n * @param client {OPCUAClientImpl}\n * @constructor\n * @private\n */\nexport class ClientSessionImpl extends EventEmitter implements ClientSession {\n    public timeout: number;\n    public authenticationToken?: NodeId;\n    public requestedMaxReferencesPerNode: number;\n    public sessionId: NodeId;\n    public lastRequestSentTime: Date;\n    public lastResponseReceivedTime: Date;\n    public serverCertificate: Certificate;\n    public name = \"\";\n\n    public serverNonce?: Nonce;\n    public serverSignature?: SignatureData; // todo : remove ?\n    public serverEndpoints: any[] = [];\n    public _client: IClientBase | null;\n    public _closed: boolean;\n\n    private _reconnecting: {\n        reconnecting: boolean;\n        pendingCallbacks: EmptyCallback[];\n        pendingTransactions: any[];\n        pendingTransactionsCount: number;\n    };\n\n    /**\n     * @internal\n     */\n    public _closeEventHasBeenEmitted: boolean;\n    private _publishEngine: ClientSidePublishEngine | null;\n    private _keepAliveManager?: ClientSessionKeepAliveManager;\n    private _namespaceArray?: any;\n    private recursive_repair_detector = 0;\n\n    constructor(client: IClientBase) {\n        super();\n\n        this.serverCertificate = Buffer.alloc(0);\n\n        this.sessionId = new NodeId();\n\n        this._closeEventHasBeenEmitted = false;\n        this._client = client;\n        this._publishEngine = null;\n\n        this._closed = false;\n\n        this._reconnecting = {\n            reconnecting: false,\n            pendingCallbacks: [],\n            pendingTransactions: [],\n            pendingTransactionsCount: 0\n        };\n\n        this.requestedMaxReferencesPerNode = 10000;\n        this.lastRequestSentTime = new Date(1, 1, 1970);\n        this.lastResponseReceivedTime = new Date(1, 1, 1970);\n        this.timeout = 0;\n    }\n\n    /**\n     * the endpoint on which this session is operating\n     * @property endpoint\n     * @type {EndpointDescription}\n     */\n    get endpoint(): EndpointDescription {\n        return this._client!.endpoint!;\n    }\n\n    get subscriptionCount(): number {\n        return this._publishEngine ? this._publishEngine.subscriptionCount : 0;\n    }\n\n    get isReconnecting(): boolean {\n        return this._client ? this._client.isReconnecting || this._reconnecting?.reconnecting : false;\n    }\n\n    public getPublishEngine(): ClientSidePublishEngine {\n        if (!this._publishEngine) {\n            this._publishEngine = new ClientSidePublishEngine(this);\n        }\n        return this._publishEngine!;\n    }\n\n    /**\n     * @method browse\n     * @async\n     *\n     * @example\n     *\n     *    ```javascript\n     *    session.browse(\"RootFolder\",function(err,browseResult) {\n     *      if(err) return callback(err);\n     *      console.log(browseResult.toString());\n     *      callback();\n     *    } );\n     *    ```\n     *\n     *\n     * @example\n     *\n     *    ``` javascript\n     *    const browseDescription = {\n     *       nodeId: \"ObjectsFolder\",\n     *       referenceTypeId: \"Organizes\",\n     *       browseDirection: BrowseDirection.Inverse,\n     *       includeSubtypes: true,\n     *       nodeClassMask: 0,\n     *       resultMask: 63\n     *    }\n     *    session.browse(browseDescription,function(err, browseResult) {\n     *       if(err) return callback(err);\n     *       console.log(browseResult.toString());\n     *       callback();\n     *    });\n     *    ```\n     * @example\n     *\n     * ``` javascript\n     * session.browse([ \"RootFolder\", \"ObjectsFolder\"],function(err, browseResults) {\n     *       assert(browseResults.length === 2);\n     * });\n     * ```\n     *\n     * @example\n     * ``` javascript\n     * const browseDescriptions = [\n     * {\n     *   nodeId: \"ObjectsFolder\",\n     *   referenceTypeId: \"Organizes\",\n     *   browseDirection: BrowseDirection.Inverse,\n     *   includeSubtypes: true,\n     *   nodeClassMask: 0,\n     *   resultMask: 63\n     * },\n     * // {...}\n     * ]\n     *  session.browse(browseDescriptions,function(err, browseResults) {\n     *\n     *   });\n     * ```\n     *\n     *\n     */\n    public browse(nodeToBrowse: BrowseDescriptionLike, callback: ResponseCallback<BrowseResult>): void;\n\n    public browse(nodesToBrowse: BrowseDescriptionLike[], callback: ResponseCallback<BrowseResult[]>): void;\n\n    public async browse(nodeToBrowse: BrowseDescriptionLike): Promise<BrowseResult>;\n\n    public async browse(nodesToBrowse: BrowseDescriptionLike[]): Promise<BrowseResult[]>;\n    /**\n     * @internal\n     * @param args\n     */\n    public browse(...args: any[]): any {\n        const arg0 = args[0];\n        const isArray = Array.isArray(arg0);\n        const callback: ResponseCallback<BrowseResult[] | BrowseResult> = args[1];\n        assert(typeof callback === \"function\");\n\n        assert(isFinite(this.requestedMaxReferencesPerNode));\n\n        const nodesToBrowse: BrowseDescription[] = (isArray ? arg0 : [arg0 as BrowseDescription]).map(coerceBrowseDescription);\n\n        const request = new BrowseRequest({\n            nodesToBrowse,\n            requestedMaxReferencesPerNode: this.requestedMaxReferencesPerNode\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof BrowseResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            const results: BrowseResult[] = response.results ? response.results : [];\n\n            if (this.requestedMaxReferencesPerNode > 0) {\n                for (let i = 0; i < results.length; i++) {\n                    const r = results[i];\n\n                    /* istanbul ignore next */\n                    if (r.references && r.references.length > this.requestedMaxReferencesPerNode) {\n                        warningLog(\n                            chalk.yellow(\"warning\") +\n                                \" BrowseResponse : the server didn't take into\" +\n                                \" account our requestedMaxReferencesPerNode \"\n                        );\n                        warningLog(\"        this.requestedMaxReferencesPerNode= \" + this.requestedMaxReferencesPerNode);\n                        warningLog(\"        got \" + r.references.length + \"for \" + nodesToBrowse[i].nodeId.toString());\n                        warningLog(\"        continuationPoint \", r.continuationPoint);\n                    }\n                }\n            }\n            for (const r of results) {\n                r.references = r.references || /* istanbul ignore next */ [];\n            }\n            assert(results[0] instanceof BrowseResult);\n            return callback(null, isArray ? results : results[0]);\n        });\n    }\n\n    public browseNext(\n        continuationPoint: Buffer,\n        releaseContinuationPoints: boolean,\n        callback: ResponseCallback<BrowseResult>\n    ): void;\n\n    public browseNext(\n        continuationPoints: Buffer[],\n        releaseContinuationPoints: boolean,\n        callback: ResponseCallback<BrowseResult[]>\n    ): void;\n\n    public async browseNext(continuationPoint: Buffer, releaseContinuationPoints: boolean): Promise<BrowseResult>;\n    public async browseNext(continuationPoints: Buffer[], releaseContinuationPoints: boolean): Promise<BrowseResult[]>;\n    public browseNext(...args: any[]): any {\n        const arg0 = args[0];\n        const isArray = Array.isArray(arg0);\n        const releaseContinuationPoints = args[1] as boolean;\n        const callback: any = args[2];\n        assert(typeof callback === \"function\", \"expecting a callback function here\");\n\n        const continuationPoints: Buffer[] = isArray ? arg0 : [arg0 as Buffer];\n\n        const request = new BrowseNextRequest({\n            continuationPoints,\n            releaseContinuationPoints\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof BrowseNextResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            const results: BrowseResult[] = response.results ? response.results : [];\n\n            for (const r of results) {\n                r.references = r.references || [];\n            }\n            assert(results[0] instanceof BrowseResult);\n            return callback(null, isArray ? results : results[0]);\n        });\n    }\n\n    /**\n     * @method readVariableValue\n     * @async\n     *\n     * @example\n     *\n     * ```javascript\n     *     session.readVariableValue(\"ns=2;s=Furnace_1.Temperature\",function(err,dataValue) {\n     *        if(err) { return callback(err); }\n     *        if (dataValue.statusCode === opcua.StatusCodes.Good) {\n     *        }\n     *        console.log(dataValue.toString());\n     *        callback();\n     *     });\n     * ```\n     *\n     * @example\n     *\n     * ```javascript\n     *   session.readVariableValue([\"ns=0;i=2257\",\"ns=0;i=2258\"],function(err,dataValues) {\n     *      if (!err) {\n     *         console.log(dataValues[0].toString());\n     *         console.log(dataValues[1].toString());\n     *      }\n     *   });\n     * ```\n     *\n     * @example\n     * ```javascript\n     *     const dataValues = await session.readVariableValue([\"ns=1;s=Temperature\",\"ns=1;s=Pressure\"]);\n     * ```\n     */\n    public readVariableValue(nodeId: NodeIdLike, callback: ResponseCallback<DataValue>): void;\n\n    public readVariableValue(nodeIds: NodeIdLike[], callback: ResponseCallback<DataValue[]>): void;\n\n    public async readVariableValue(nodeId: NodeIdLike): Promise<DataValue>;\n\n    public async readVariableValue(nodeIds: NodeIdLike[]): Promise<DataValue[]>;\n    /**\n     * @internal\n     * @param args\n     */\n    public readVariableValue(...args: any[]): any {\n        const callback = args[1];\n        assert(typeof callback === \"function\");\n\n        const isArray = Array.isArray(args[0]);\n\n        const nodes = isArray ? args[0] : [args[0]];\n\n        const nodesToRead = nodes.map(coerceReadValueId);\n\n        const request = new ReadRequest({\n            nodesToRead,\n            timestampsToReturn: TimestampsToReturn.Neither\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!(response instanceof ReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            /* istanbul ignore next */\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                return callback(new Error(response.responseHeader.serviceResult.toString()));\n            }\n\n            /* istanbul ignore next */\n            if (!response.results) {\n                response.results = [];\n            }\n\n            assert(nodes.length === response.results.length);\n\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    /**\n     * @method readHistoryValue\n     * @async\n     *\n     * @example\n     *\n     * ```javascript\n     * //  es5\n     * session.readHistoryValue(\n     *   \"ns=5;s=Simulation Examples.Functions.Sine1\",\n     *   \"2015-06-10T09:00:00.000Z\",\n     *   \"2015-06-10T09:01:00.000Z\", function(err,dataValues) {\n     *\n     * });\n     * ```\n     *\n     * ```javascript\n     * //  es6\n     * const dataValues = await session.readHistoryValue(\n     *   \"ns=5;s=Simulation Examples.Functions.Sine1\",\n     *   \"2015-06-10T09:00:00.000Z\",\n     *   \"2015-06-10T09:01:00.000Z\");\n     * ```\n     * @param nodeToRead   the read value id\n     * @param start   the start time in UTC format\n     * @param end     the end time in UTC format\n     * @param callback\n     */\n    public readHistoryValue(\n        nodesToRead: NodeIdLike[] | HistoryReadValueIdOptions2[],\n        start: DateTime,\n        end: DateTime,\n        callback: (err: Error | null, results?: HistoryReadResult[]) => void\n    ): void;\n    public readHistoryValue(\n        nodesToRead: NodeIdLike[] | HistoryReadValueIdOptions2[],\n        start: DateTime,\n        end: DateTime,\n        options: ExtraReadHistoryValueParameters | undefined,\n        callback: (err: Error | null, results?: HistoryReadResult[]) => void\n    ): void;\n    public async readHistoryValue(\n        nodesToRead: NodeIdLike[] | HistoryReadValueIdOptions2[],\n        start: DateTime,\n        end: DateTime,\n        options?: ExtraReadHistoryValueParameters\n    ): Promise<HistoryReadResult[]>;\n    public readHistoryValue(\n        nodeToRead: NodeIdLike | HistoryReadValueIdOptions2,\n        start: DateTime,\n        end: DateTime,\n        callback: (err: Error | null, results?: HistoryReadResult) => void\n    ): void;\n    public readHistoryValue(\n        nodeToRead: NodeIdLike | HistoryReadValueIdOptions2,\n        start: DateTime,\n        end: DateTime,\n        options: ExtraReadHistoryValueParameters | undefined,\n        callback: (err: Error | null, results?: HistoryReadResult) => void\n    ): void;\n    public async readHistoryValue(\n        nodeToRead: NodeIdLike | HistoryReadValueIdOptions2,\n        start: DateTime,\n        end: DateTime,\n        parameters: ExtraReadHistoryValueParameters\n    ): Promise<HistoryReadResult>;\n    public readHistoryValue(...args: any[]): any {\n        const startTime = args[1];\n        const endTime = args[2];\n\n        let options: ExtraReadHistoryValueParameters = {};\n        let callback = args[3];\n        if (typeof callback !== \"function\") {\n            options = args[3];\n            callback = args[4];\n        }\n        assert(typeof callback === \"function\");\n\n        // adjust parameters\n        options.numValuesPerNode = options.numValuesPerNode || 0;\n        options.returnBounds = options.returnBounds || options.returnBounds === undefined ? true : false;\n        options.isReadModified = options.isReadModified || false;\n        options.timestampsToReturn = options.timestampsToReturn || TimestampsToReturn.Both;\n\n        const arg0 = args[0];\n        const isArray = Array.isArray(arg0);\n\n        const nodes = isArray ? arg0 : [arg0];\n\n        const nodesToRead: HistoryReadValueIdOptions[] = [];\n\n        for (const node of nodes) {\n            if (!node.nodeId) {\n                nodesToRead.push({\n                    continuationPoint: undefined,\n                    dataEncoding: undefined, // {namespaceIndex: 0, name: undefined},\n                    indexRange: undefined,\n                    nodeId: resolveNodeId(node as NodeIdLike)\n                });\n            } else {\n                nodesToRead.push(node as HistoryReadValueIdOptions);\n            }\n        }\n\n        const readRawModifiedDetails = new ReadRawModifiedDetails({\n            endTime,\n            isReadModified: false,\n            numValuesPerNode: options.numValuesPerNode,\n            returnBounds: options.returnBounds,\n            startTime\n        });\n\n        const request = new HistoryReadRequest({\n            historyReadDetails: readRawModifiedDetails,\n            nodesToRead,\n            releaseContinuationPoints: false,\n            timestampsToReturn: options.timestampsToReturn\n        });\n\n        request.nodesToRead = request.nodesToRead || [];\n\n        assert(nodes.length === request.nodesToRead.length);\n        this.historyRead(request, (err: Error | null, response?: HistoryReadResponse) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof HistoryReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            response.results = response.results || [];\n            assert(nodes.length === response.results.length);\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    public historyRead(request: HistoryReadRequest, callback: Callback<HistoryReadResponse>): void;\n    public historyRead(request: HistoryReadRequest): Promise<HistoryReadResponse>;\n    public historyRead(request: HistoryReadRequest, callback?: CallbackT<HistoryReadResponse>): any {\n        /* istanbul ignore next */\n        if (!callback) {\n            throw new Error(\"expecting a callback\");\n        }\n\n        this.performMessageTransaction(request, (err: Error | null, response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof HistoryReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                return callback(new Error(response.responseHeader.serviceResult.toString()));\n            }\n\n            response.results = response.results || /* istanbul ignore next */ [];\n            callback(null, response);\n        });\n    }\n\n    public readAggregateValue(\n        nodesToRead: HistoryReadValueIdOptions[],\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction[],\n        processingInterval: number,\n        callback: Callback<HistoryReadResult[]>\n    ): void;\n    public async readAggregateValue(\n        nodesToRead: HistoryReadValueIdOptions[],\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction[],\n        processingInterval: number\n    ): Promise<HistoryReadResult[]>;\n    public readAggregateValue(\n        nodeToRead: HistoryReadValueIdOptions,\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction,\n        processingInterval: number,\n        callback: Callback<HistoryReadResult>\n    ): void;\n    public async readAggregateValue(\n        nodeToRead: HistoryReadValueIdOptions,\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction,\n        processingInterval: number\n    ): Promise<HistoryReadResult>;\n\n    public readAggregateValue(\n        arg0: HistoryReadValueIdOptions[] | HistoryReadValueIdOptions,\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction[] | AggregateFunction,\n        processingInterval: number,\n        ...args: any[]\n    ): any {\n        const callback = args[0];\n        assert(typeof callback === \"function\");\n\n        const isArray = Array.isArray(arg0);\n\n        const nodesToRead: HistoryReadValueIdOptions[] = isArray\n            ? (arg0 as HistoryReadValueIdOptions[])\n            : [arg0 as HistoryReadValueIdOptions];\n\n        const aggregateFns: AggregateFunction[] = Array.isArray(aggregateFn)\n            ? (aggregateFn as AggregateFunction[])\n            : [aggregateFn as AggregateFunction];\n\n        assert(aggregateFns.length === nodesToRead.length);\n\n        const readProcessedDetails = new ReadProcessedDetails({\n            aggregateType: aggregateFns,\n            endTime,\n            processingInterval,\n            startTime\n        });\n\n        const request = new HistoryReadRequest({\n            historyReadDetails: readProcessedDetails,\n            nodesToRead,\n            releaseContinuationPoints: false,\n            timestampsToReturn: TimestampsToReturn.Both\n        });\n\n        assert(nodesToRead.length === request.nodesToRead!.length);\n        this.performMessageTransaction(request, (err: Error | null, response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof HistoryReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                return callback(new Error(response.responseHeader.serviceResult.toString()));\n            }\n\n            response.results = response.results || /* istanbul ignore next */ [];\n\n            assert(nodesToRead.length === response.results.length);\n\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    /**\n     *\n     * @method write\n     * @param nodesToWrite {WriteValue[]}  - the array of value to write. One or more elements.\n     * @param {Function} callback -   the callback function\n     * @param callback.err {object|null} the error if write has failed or null if OK\n     * @param callback.statusCodes {StatusCode[]} - an array of status code of each write\n     * @async\n     *\n     * @example\n     *\n     *     const nodesToWrite = [\n     *     {\n     *          nodeId: \"ns=1;s=SetPoint1\",\n     *          attributeId: opcua.AttributeIds.Value,\n     *          value: {\n     *             statusCode: Good,\n     *             value: {\n     *               dataType: opcua.DataType.Double,\n     *               value: 100.0\n     *             }\n     *          }\n     *     },\n     *     {\n     *          nodeId: \"ns=1;s=SetPoint2\",\n     *          attributeIds opcua.AttributeIds.Value,\n     *          value: {\n     *             statusCode: Good,\n     *             value: {\n     *               dataType: opcua.DataType.Double,\n     *               value: 45.0\n     *             }\n     *          }\n     *     }\n     *     ];\n     *     session.write(nodesToWrite,function (err,statusCodes) {\n     *       if(err) { return callback(err);}\n     *       //\n     *     });\n     *\n     * @method write\n     * @param nodeToWrite {WriteValue}  - the value to write\n     * @param callback -   the callback function\n     * @param callback.err {object|null} the error if write has failed or null if OK\n     * @param callback.statusCode {StatusCodes} - the status code of the write\n     * @async\n     *\n     * @example\n     *\n     *     const nodeToWrite = {\n     *          nodeId: \"ns=1;s=SetPoint\",\n     *          attributeId: opcua.AttributeIds.Value,\n     *          value: {\n     *             statusCode: Good,\n     *             value: {\n     *               dataType: opcua.DataType.Double,\n     *               value: 100.0\n     *             }\n     *          }\n     *     };\n     *     session.write(nodeToWrite,function (err,statusCode) {\n     *       if(err) { return callback(err);}\n     *       //\n     *     });\n     *\n     *\n     * @method write\n     * @param nodeToWrite {WriteValue}  - the value to write\n     * @return {Promise<StatusCode>}\n     * @async\n     *\n     * @example\n     *\n     * ```javascript\n     *   session.write(nodeToWrite).then(function(statusCode) { });\n     * ```\n     *\n     * @example\n     *\n     * ```javascript\n     *   const statusCode = await session.write(nodeToWrite);\n     * ```\n     *\n     * @method write\n     * @param nodesToWrite {Array<WriteValue>}  - the value to write\n     * @return {Promise<Array<StatusCode>>}\n     * @async\n     *\n     * @example\n     * ```javascript\n     * session.write(nodesToWrite).then(function(statusCodes) { });\n     * ```\n     *\n     * @example\n     * ```javascript\n     *   const statusCodes = await session.write(nodesToWrite);\n     * ```\n     */\n    public write(nodeToWrite: WriteValueOptions, callback: ResponseCallback<StatusCode>): void;\n\n    public write(nodesToWrite: WriteValueOptions[], callback: ResponseCallback<StatusCode[]>): void;\n\n    public async write(nodesToWrite: WriteValueOptions[]): Promise<StatusCode[]>;\n\n    public async write(nodeToWrite: WriteValueOptions): Promise<StatusCode>;\n\n    /**\n     * @internal\n     * @param args\n     */\n    public write(...args: any[]): any {\n        const arg0 = args[0];\n        const isArray = Array.isArray(arg0);\n        const nodesToWrite = isArray ? arg0 : [arg0];\n\n        const callback = args[1];\n        assert(typeof callback === \"function\");\n\n        const request = new WriteRequest({ nodesToWrite });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err, response);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof WriteResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            /* istanbul ignore next */\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                return callback(new Error(response.responseHeader.serviceResult.toString()));\n            }\n            response.results = response.results || /* istanbul ignore next */ [];\n            assert(nodesToWrite.length === response.results.length);\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    /**\n     *\n     * @method writeSingleNode\n     * @async\n     * @param nodeId  {NodeId}  - the node id of the node to write\n     * @param value   {Variant} - the value to write\n     * @param callback   {Function}\n     * @param callback.err {object|null} the error if write has failed or null if OK\n     * @param callback.statusCode {StatusCode} - the status code of the write\n     *\n     * @method writeSingleNode\n     * @async\n     * @param nodeId  {NodeId}  - the node id of the node to write\n     * @param value   {Variant} - the value to write\n     * @return {Promise<StatusCode>} - the status code of the write\n     *\n     * @deprecated\n     */\n    public writeSingleNode(nodeId: NodeIdLike, value: VariantLike, callback: ResponseCallback<StatusCode>): void;\n\n    public writeSingleNode(nodeId: NodeIdLike, value: VariantLike): Promise<StatusCode>;\n\n    public writeSingleNode(...args: any[]): any {\n        const nodeId = args[0] as NodeIdLike;\n        const value = args[1] as VariantLike;\n        const callback = args[2];\n\n        assert(typeof callback === \"function\");\n\n        const nodeToWrite = new WriteValue({\n            attributeId: AttributeIds.Value,\n            indexRange: undefined,\n            nodeId: resolveNodeId(nodeId),\n            value: new DataValue({ value })\n        });\n\n        this.write(nodeToWrite, (err, statusCode) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            assert(statusCode);\n            callback(null, statusCode);\n        });\n    }\n\n    /**\n     * @method readAllAttributes\n     *\n     * @example\n     *\n     *\n     *  ``` javascript\n     *  session.readAllAttributes(\"ns=2;s=Furnace_1.Temperature\",function(err,data) {\n     *    if(data.statusCode === StatusCodes.Good) {\n     *      console.log(\" nodeId      = \",data.nodeId.toString());\n     *      console.log(\" browseName  = \",data.browseName.toString());\n     *      console.log(\" description = \",data.description.toString());\n     *      console.log(\" value       = \",data.value.toString()));\n     *    }\n     *  });\n     *  ```\n     *\n     * @async\n     * @param nodes  array of nodeId to read\n     * @param node  nodeId to read\n     * @param callback\n     */\n    public readAllAttributes(node: NodeIdLike, callback: (err: Error | null, data?: NodeAttributes) => void): void;\n\n    public readAllAttributes(nodes: NodeIdLike[], callback: (err: Error | null, data?: NodeAttributes[]) => void): void;\n\n    public readAllAttributes(...args: any[]): void {\n        const arg0 = args[0];\n        const callback = args[1];\n        assert(typeof callback === \"function\");\n\n        const isArray = Array.isArray(arg0);\n\n        const nodes = isArray ? arg0 : [arg0];\n\n        const nodesToRead: ReadValueIdOptions[] = [];\n\n        for (const node of nodes) {\n            const nodeId = resolveNodeId(node);\n\n            /* istanbul ignore next */\n            if (!nodeId) {\n                throw new Error(\"cannot coerce \" + node + \" to a valid NodeId\");\n            }\n\n            for (let attributeId = 1; attributeId <= 22; attributeId++) {\n                nodesToRead.push({\n                    attributeId,\n                    dataEncoding: undefined,\n                    indexRange: undefined,\n                    nodeId\n                });\n            }\n        }\n\n        this.read(nodesToRead, (err: Error | null, dataValues?: DataValue[]) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!dataValues) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            const results = composeResult(nodes, nodesToRead, dataValues);\n            callback(err, isArray ? results : results[0]);\n        });\n    }\n\n    /**\n     * @method read (form1)\n     *\n     * @async\n     *\n     * @example\n     *\n     *     ```javascript\n     *     ```\n     *\n     *   form1: reading a single node\n     *\n     *  ``` javascript\n     *    const nodeToRead = {\n     *             nodeId:      \"ns=2;s=Furnace_1.Temperature\",\n     *             attributeId: AttributeIds.BrowseName\n     *    };\n     *\n     *    session.read(nodeToRead,function(err,dataValue) {\n     *        if (!err) {\n     *           console.log(dataValue.toString());\n     *        }\n     *    });\n     *    ```\n     *\n     *\n     * @method read (form2)\n     * @param nodesToRead               {Array<ReadValueId>} - an array of nodeId to read or a ReadValueId\n     * @param [maxAge]                 {Number}\n     * @param callback                 {Function}                - the callback function\n     * @param callback.err             {Error|null}              - the error or null if the transaction was OK}\n     * @param callback.dataValues       {Array<DataValue>}\n     * @async\n     *\n     * @example\n     *\n     *   ``` javascript\n     *   const nodesToRead = [\n     *        {\n     *             nodeId:      \"ns=2;s=Furnace_1.Temperature\",\n     *             attributeId: AttributeIds.BrowseName\n     *        }\n     *   ];\n     *   session.read(nodesToRead,function(err,dataValues) {\n     *     if (!err) {\n     *       dataValues.forEach(dataValue=>console.log(dataValue.toString()));\n     *     }\n     *   });\n     *   ```\n     *\n     */\n    public read(nodeToRead: ReadValueIdOptions, maxAge: number, callback: ResponseCallback<DataValue>): void;\n\n    public read(nodesToRead: ReadValueIdOptions[], maxAge: number, callback: ResponseCallback<DataValue[]>): void;\n\n    public read(nodeToRead: ReadValueIdOptions, callback: ResponseCallback<DataValue>): void;\n\n    public read(nodesToRead: ReadValueIdOptions[], callback: ResponseCallback<DataValue[]>): void;\n\n    public read(nodeToRead: ReadValueIdOptions, maxAge?: number): Promise<DataValue>;\n\n    public read(nodeToRead: ReadValueIdOptions[], maxAge?: number): Promise<DataValue[]>;\n\n    /**\n     * @internal\n     * @param args\n     */\n    public read(...args: any[]): any {\n        if (args.length === 2) {\n            return this.read(args[0], 0, args[1]);\n        }\n        assert(args.length === 3);\n\n        const isArray = Array.isArray(args[0]);\n\n        const nodesToRead = isArray ? args[0] : [args[0]];\n\n        assert(Array.isArray(nodesToRead));\n\n        const maxAge = args[1];\n\n        const callback = args[2];\n        assert(typeof callback === \"function\");\n\n        /* istanbul ignore next */\n        if (helpAPIChange) {\n            // the read method deprecation detection and warning\n            if (\n                !(getFunctionParameterNames(callback)[1] === \"dataValues\" || getFunctionParameterNames(callback)[1] === \"dataValue\")\n            ) {\n                warningLog(chalk.red(\"[NODE-OPCUA-E04] the ClientSession#read  API has changed !!, please fix the client code\"));\n                warningLog(chalk.red(\"   replace ..:\"));\n                warningLog(chalk.cyan(\"   session.read(nodesToRead,function(err,nodesToRead,results) {}\"));\n                warningLog(chalk.red(\"   with .... :\"));\n                warningLog(chalk.cyan(\"   session.read(nodesToRead,function(err,dataValues) {}\"));\n                warningLog(\"\");\n                warningLog(\n                    chalk.yellow(\n                        \"please make sure to refactor your code and check that \" +\n                            \"the second argument of your callback function is named\"\n                    ),\n                    chalk.cyan(\"dataValue\" + (isArray ? \"s\" : \"\"))\n                );\n                warningLog(chalk.cyan(\"to make this exception disappear\"));\n                throw new Error(\"ERROR ClientSession#read  API has changed !!, please fix the client code\");\n            }\n        }\n\n        // coerce nodeIds\n        for (const node of nodesToRead) {\n            node.nodeId = resolveNodeId(node.nodeId);\n        }\n\n        const request = new ReadRequest({\n            maxAge,\n            nodesToRead,\n            timestampsToReturn: TimestampsToReturn.Both\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err, response);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof ReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            // perform ExtensionObject resolution\n            promoteOpaqueStructureWithCallback(this, response.results!, () => {\n                response.results = response.results || /* istanbul ignore next */ [];\n                return callback(null, isArray ? response.results : response.results[0]);\n            });\n        });\n    }\n\n    public emitCloseEvent(statusCode: StatusCode): void {\n        if (!this._closeEventHasBeenEmitted) {\n            debugLog(\"ClientSession#emitCloseEvent\");\n            this._closeEventHasBeenEmitted = true;\n            this.emit(\"session_closed\", statusCode);\n        }\n    }\n\n    public createSubscription(\n        options: CreateSubscriptionRequestLike,\n        callback?: ResponseCallback<CreateSubscriptionResponse>\n    ): any {\n        this._defaultRequest(CreateSubscriptionRequest, CreateSubscriptionResponse, options, callback);\n    }\n\n    /**\n     * @method createSubscription2\n     * @param createSubscriptionRequest\n     * @param callback\n     *\n     *\n     * subscription.on(\"error',    function(err){ ... });\n     * subscription.on(\"terminate',function(err){ ... });\n     * const monitoredItem = await subscription.monitor(itemToMonitor,monitoringParameters,requestedParameters);\n     * monitoredItem.on(\"changed\",function( dataValue) {...});\n     *\n     */\n    public async createSubscription2(createSubscriptionRequest: CreateSubscriptionRequestLike): Promise<ClientSubscription>;\n    public createSubscription2(\n        createSubscriptionRequest: CreateSubscriptionRequestLike,\n        callback: (err: Error | null, subscription?: ClientSubscription) => void\n    ): void;\n    public createSubscription2(...args: any[]): any {\n        const createSubscriptionRequest = args[0] as CreateSubscriptionRequestLike;\n        let callback = args[1];\n        const subscription = new ClientSubscriptionImpl(this, createSubscriptionRequest);\n\n        // tslint:disable-next-line:no-empty\n        subscription.on(\"error\", (err) => {\n            if (callback) {\n                callback(err);\n                callback = null;\n            }\n        });\n        subscription.on(\"started\", () => {\n            assert(subscription.session === this, \"expecting a session here\");\n            if (callback) {\n                callback(null, subscription);\n                callback = null;\n            }\n        });\n    }\n\n    public deleteSubscriptions(\n        options: DeleteSubscriptionsRequestLike,\n        callback?: ResponseCallback<DeleteSubscriptionsResponse>\n    ): any {\n        this._defaultRequest(DeleteSubscriptionsRequest, DeleteSubscriptionsResponse, options, callback);\n    }\n\n    public setTriggering(request: SetTriggeringRequestOptions, callback?: ResponseCallback<SetTriggeringResponse>): any {\n        this._defaultRequest(SetTriggeringRequest, SetTriggeringResponse, request, callback);\n    }\n\n    /**\n     * @method transferSubscriptions\n     * @async\n     */\n    public transferSubscriptions(\n        options: TransferSubscriptionsRequestLike,\n        callback?: ResponseCallback<TransferSubscriptionsResponse>\n    ): any {\n        this._defaultRequest(TransferSubscriptionsRequest, TransferSubscriptionsResponse, options, callback);\n    }\n\n    public createMonitoredItems(\n        options: CreateMonitoredItemsRequestLike,\n        callback?: ResponseCallback<CreateMonitoredItemsResponse>\n    ): any {\n        this._defaultRequest(CreateMonitoredItemsRequest, CreateMonitoredItemsResponse, options, callback);\n    }\n\n    public modifyMonitoredItems(\n        options: ModifyMonitoredItemsRequestLike,\n        callback?: ResponseCallback<ModifyMonitoredItemsResponse>\n    ): any {\n        this._defaultRequest(ModifyMonitoredItemsRequest, ModifyMonitoredItemsResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method modifySubscription\n     * @async\n     * @param options {ModifySubscriptionRequest}\n     * @param callback {Function}\n     * @param callback.err {Error|null}   - the Error if the async method has failed\n     * @param callback.response {ModifySubscriptionResponse} - the response\n     */\n    public modifySubscription(\n        options: ModifySubscriptionRequestLike,\n        callback?: ResponseCallback<ModifySubscriptionResponse>\n    ): any {\n        this._defaultRequest(ModifySubscriptionRequest, ModifySubscriptionResponse, options, callback);\n    }\n\n    public setMonitoringMode(options: SetMonitoringModeRequestLike, callback?: ResponseCallback<SetMonitoringModeResponse>): any {\n        this._defaultRequest(SetMonitoringModeRequest, SetMonitoringModeResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method publish\n     * @async\n     * @param options  {PublishRequest}\n     * @param callback {Function}\n     * @param callback.err {Error|null}   - the Error if the async method has failed\n     * @param callback.response {PublishResponse} - the response\n     */\n    public publish(options: PublishRequest, callback: (err: Error | null, response?: PublishResponse) => void): void {\n        this._defaultRequest(PublishRequest, PublishResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method republish\n     * @async\n     * @param options  {RepublishRequest}\n     * @param callback the callback\n     */\n    public republish(options: RepublishRequest, callback: (err: Error | null, response?: RepublishResponse) => void): void {\n        this._defaultRequest(RepublishRequest, RepublishResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method deleteMonitoredItems\n     * @async\n     * @param options  {DeleteMonitoredItemsRequest}\n     * @param callback {Function}\n     * @param callback.err {Error|null}   - the Error if the async method has failed\n     */\n    public deleteMonitoredItems(\n        options: DeleteMonitoredItemsRequestLike,\n        callback: (err: Error | null, response?: DeleteMonitoredItemsResponse) => void\n    ): void {\n        this._defaultRequest(DeleteMonitoredItemsRequest, DeleteMonitoredItemsResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method setPublishingMode\n     * @async\n     */\n    public setPublishingMode(publishingEnabled: boolean, subscriptionId: SubscriptionId): Promise<StatusCode>;\n    public setPublishingMode(publishingEnabled: boolean, subscriptionIds: SubscriptionId[]): Promise<StatusCode[]>;\n    public setPublishingMode(\n        publishingEnabled: boolean,\n        subscriptionId: SubscriptionId,\n        callback: (err: Error | null, statusCode?: StatusCode) => void\n    ): void;\n    public setPublishingMode(\n        publishingEnabled: boolean,\n        subscriptionIds: SubscriptionId[],\n        callback: (err: Error | null, statusCodes?: StatusCode[]) => void\n    ): void;\n    /**\n     * @internal\n     */\n    public setPublishingMode(...args: any[]): any {\n        const publishingEnabled = args[0];\n        const isArray = Array.isArray(args[1]);\n        const subscriptionIds = isArray ? args[1] : [args[1]];\n        const callback = args[2];\n\n        assert(typeof callback === \"function\");\n        assert(publishingEnabled === true || publishingEnabled === false);\n\n        const options = new SetPublishingModeRequest({\n            publishingEnabled,\n            subscriptionIds\n        });\n\n        this._defaultRequest(\n            SetPublishingModeRequest,\n            SetPublishingModeResponse,\n            options,\n            (err: Error | null, response?: SetPublishingModeResponse) => {\n                /* istanbul ignore next */\n                if (err) {\n                    return callback(err);\n                }\n                /* istanbul ignore next */\n                if (!response) {\n                    return callback(new Error(\"Internal Error\"));\n                }\n                response.results = response.results || /* istanbul ignore next */ [];\n                callback(err, isArray ? response.results : response.results[0]);\n            }\n        );\n    }\n\n    /**\n     *\n     * @method translateBrowsePath\n     * @async\n     * @param browsePath {BrowsePath|Array<BrowsePath>}\n     * @param callback {Function}\n     * @param callback.err {Error|null}\n     * @param callback.response {BrowsePathResult|Array<BrowsePathResult>}\n     *\n     *\n     *\n     */\n    public translateBrowsePath(browsePath: BrowsePath, callback: ResponseCallback<BrowsePathResult>): void;\n    public translateBrowsePath(browsesPath: BrowsePath[], callback: ResponseCallback<BrowsePathResult[]>): void;\n    public async translateBrowsePath(browsePath: BrowsePath): Promise<BrowsePathResult>;\n    public async translateBrowsePath(browsePaths: BrowsePath[]): Promise<BrowsePathResult[]>;\n\n    /**\n     * @internal\n     * @param args\n     */\n    public translateBrowsePath(...args: any[]): any {\n        const isArray = Array.isArray(args[0]);\n        const browsePaths = isArray ? args[0] : [args[0]];\n\n        const callback = args[1];\n        assert(typeof callback === \"function\");\n\n        const request = new TranslateBrowsePathsToNodeIdsRequest({ browsePaths });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err, response);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof TranslateBrowsePathsToNodeIdsResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            response.results = response.results || /* istanbul ignore next */ [];\n\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    public channelId(): number {\n        return this._client !== null && this._client._secureChannel !== null && this._client._secureChannel.isOpened()\n            ? this._client._secureChannel!.channelId\n            : -1;\n    }\n    public isChannelValid(): boolean {\n        /* istanbul ignore next */\n        if (!this._client) {\n            debugLog(chalk.red(\"Warning SessionClient is null ?\"));\n        }\n\n        return this._client !== null && this._client._secureChannel !== null && this._client._secureChannel.isOpened();\n    }\n\n    public performMessageTransaction(request: Request, callback: (err: Error | null, response?: Response) => void): void {\n        if (!this._client) {\n            // session may have been closed by user ... but is still in used !!\n            return callback(new Error(\"Session has been closed and should not be used to perform a transaction anymore\"));\n        }\n\n        if (!this.isChannelValid()) {\n            // the secure channel is broken, may be the server has crashed or the network cable has been disconnected\n            // for a long time\n            // we may need to queue this transaction, as a secure token may be being reprocessed\n            debugLog(chalk.bgWhite.red(\"!!! Performing transaction on invalid channel !!! \", request.constructor.name));\n            return callback(new Error(\"Invalid Channel after performing transaction on \" + request.constructor.name));\n        }\n\n        this._reconnecting.pendingTransactions = this._reconnecting.pendingTransactions || [];\n        this._reconnecting.pendingTransactionsCount = this._reconnecting.pendingTransactionsCount || 0;\n\n        const isPublishRequest = request instanceof PublishRequest;\n        if (isPublishRequest) {\n            return this._performMessageTransaction(request, callback);\n        }\n\n        if (this._reconnecting.pendingTransactionsCount > 0) {\n            /* istanbul ignore next */\n            if (this._reconnecting.pendingTransactions.length > 10) {\n                if (!pendingTransactionMessageDisplayed) {\n                    pendingTransactionMessageDisplayed = true;\n                    warningLog(\n                        \"[NODE-OPCUA-W21]\",\n                        \"Pending transactions: \",\n                        this._reconnecting.pendingTransactions.map((a: any) => a.request.constructor.name).join(\" \")\n                    );\n                    warningLog(\n                        \"[NODE-OPCUA-W22]\",\n                        chalk.yellow(\n                            \"Warning : your opcua client is sending multiple requests simultaneously to the server\",\n                            request.constructor.name\n                        ),\n                        \"\\n\",\n                        chalk.yellow(\" please fix your application code\")\n                    );\n                }\n            } else if (this._reconnecting.pendingTransactions.length > 3) {\n                debugLog(\n                    chalk.yellow(\n                        \"Warning : your client is sending multiple requests simultaneously to the server\",\n                        request.constructor.name\n                    )\n                );\n            }\n            this._reconnecting.pendingTransactions.push({ request, callback });\n            return;\n        }\n        this.processTransactionQueue(request, callback);\n    }\n    public processTransactionQueue = (request: Request, callback: (err: Error | null, response?: Response) => void): void => {\n        this._reconnecting.pendingTransactionsCount = this._reconnecting.pendingTransactionsCount || 0;\n        this._reconnecting.pendingTransactionsCount++;\n\n        this._performMessageTransaction(request, (err: null | Error, response?: Response) => {\n            this._reconnecting.pendingTransactionsCount--;\n\n            if (err && err.message.match(/BadSessionIdInvalid/) && request.constructor.name !== \"ActivateSessionRequest\") {\n                debugLog(\"Transaction on Invalid Session \", request.constructor.name);\n                request.requestHeader.requestHandle = requestHandleNotSetValue;\n                this.recreate_session_and_reperform_transaction(request, callback);\n                return;\n            }\n            callback(err, response);\n            const length = this._reconnecting.pendingTransactions.length; // record length before callback is called !\n            if (length > 0) {\n                debugLog(\n                    \"processTransactionQueue => \",\n                    this._reconnecting.pendingTransactions.length,\n                    \" transaction(s) left in queue\"\n                );\n                // tslint:disable-next-line: no-shadowed-variable\n                const { request, callback } = this._reconnecting.pendingTransactions.shift();\n                this.processTransactionQueue(request, callback);\n            }\n        });\n    };\n\n    public _performMessageTransaction(request: Request, callback: (err: Error | null, response?: Response) => void): void {\n        assert(typeof callback === \"function\");\n\n        /* istanbul ignore next */\n        if (!this._client) {\n            // session may have been closed by user ... but is still in used !!\n            return callback(new Error(\"Session has been closed and should not be used to perform a transaction anymore\"));\n        }\n\n        if (!this.isChannelValid()) {\n            // the secure channel is broken, may be the server has crashed or the network cable has been disconnected\n            // for a long time\n            // we may need to queue this transaction, as a secure token may be being reprocessed\n            debugLog(chalk.bgWhite.red(\"!!! Performing transaction on invalid channel !!! \", request.constructor.name));\n            return callback(new Error(\"Invalid Channel BadConnectionClosed\"));\n        }\n\n        // is this stuff useful?\n        if (request.requestHeader) {\n            request.requestHeader.authenticationToken = this.authenticationToken!;\n        }\n\n        this.lastRequestSentTime = new Date();\n\n        this._client.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            this.lastResponseReceivedTime = new Date();\n\n            /* istanbul ignore next */\n            if (err) {\n                if (response && response.responseHeader.serviceDiagnostics) {\n                    (err as any).serviceDiagnostics = response.responseHeader.serviceDiagnostics;\n                }\n                if (response && (response as any).diagnosticInfos) {\n                    (err as any).diagnosticsInfo = (response as any).diagnosticInfos;\n                }\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response) {\n                return callback(new Error(\"internal Error\"));\n            }\n\n            /* istanbul ignore next */\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                err = new Error(\n                    \" ServiceResult is \" +\n                        response.responseHeader.serviceResult.toString() +\n                        \" request was \" +\n                        request.constructor.name\n                );\n\n                if (response && response.responseHeader.serviceDiagnostics) {\n                    (err as any).serviceDiagnostics = response.responseHeader.serviceDiagnostics;\n                }\n                if (response && (response as any).diagnosticInfos) {\n                    (err as any).diagnosticsInfo = (response as any).diagnosticInfos;\n                }\n                return callback(err, response);\n            }\n            return callback(null, response);\n        });\n    }\n\n    /**\n     *  evaluate the remaining time for the session\n     *\n     *\n     * evaluate the time in milliseconds that the session will live\n     * on the server end from now.\n     * The remaining live time is calculated based on when the last message was sent to the server\n     * and the session timeout.\n     *\n     * * In normal operation , when server and client communicates on a regular\n     *   basis, evaluateRemainingLifetime will return a number slightly below\n     *   session.timeout\n     *\n     * * when the client and server cannot communicate due to a network issue\n     *   (or a server crash), evaluateRemainingLifetime returns the estimated number\n     *   of milliseconds before the server (if not crash) will keep  the session alive\n     *   on its end to allow a automatic reconnection with session.\n     *\n     * * When evaluateRemainingLifetime returns zero , this mean that\n     *   the session has probably ended on the server side and will have to be recreated\n     *   from scratch in case of a reconnection.\n     *\n     * @return the number of milliseconds before session expires\n     */\n    public evaluateRemainingLifetime(): number {\n        const now = Date.now();\n        const expiryTime = this.lastRequestSentTime.getTime() + this.timeout;\n        return Math.max(0, expiryTime - now);\n    }\n\n    public _terminatePublishEngine(): void {\n        if (this._publishEngine) {\n            this._publishEngine.terminate();\n            this._publishEngine = null;\n        }\n    }\n\n    /**\n     *\n     * @method close\n     * @async\n     * @param [deleteSubscription=true] {Boolean}\n     * @param callback {Function}\n     */\n    public close(callback: ErrorCallback): void;\n\n    public close(deleteSubscription: boolean, callback: ErrorCallback): void;\n\n    public async close(deleteSubscription?: boolean): Promise<void>;\n\n    /**\n     * @internal\n     * @param args\n     */\n    public close(...args: any[]): any {\n        if (arguments.length === 1) {\n            return this.close(true, args[0]);\n        }\n\n        const deleteSubscription = args[0];\n        const callback = args[1];\n\n        assert(typeof callback === \"function\");\n        assert(typeof deleteSubscription === \"boolean\");\n\n        /* istanbul ignore next */\n        if (!this._client) {\n            debugLog(\"ClientSession#close : warning, client is already closed\");\n            return callback(); // already close ?\n        }\n        assert(this._client);\n\n        this._terminatePublishEngine();\n        this._client.closeSession(this, deleteSubscription, (err?: Error) => {\n            debugLog(\"session Close err \", err ? err.message : \"null\");\n            callback();\n        });\n    }\n\n    /**\n     * @method hasBeenClosed\n     * @return {Boolean}\n     */\n    public hasBeenClosed(): boolean {\n        return isNullOrUndefined(this._client) || this._closed || this._closeEventHasBeenEmitted;\n    }\n\n    public async call(methodToCall: CallMethodRequestLike): Promise<CallMethodResult>;\n    public async call(methodToCall: CallMethodRequestLike[]): Promise<CallMethodResult[]>;\n    public call(methodToCall: CallMethodRequestLike, callback: ResponseCallback<CallMethodResult>): void;\n    public call(methodsToCall: CallMethodRequestLike[], callback: ResponseCallback<CallMethodResult[]>): void;\n    /**\n     * @internal\n     * @param args\n     */\n    public call(...args: any[]): any {\n        const isArray = Array.isArray(args[0]);\n        const methodsToCall = isArray ? args[0] : [args[0]];\n        assert(Array.isArray(methodsToCall));\n\n        const callback = args[1];\n\n        // Note : The client has no explicit address space and therefore will struggle to\n        //        access the method arguments signature.\n        //        There are two methods that can be considered:\n        //           - get the object definition by querying the server\n        //           - load a fake address space to have some thing to query on our end\n        // const request = this._client.factory.constructObjectId(\"CallRequest\",{ methodsToCall: methodsToCall});\n        const request = new CallRequest({ methodsToCall });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof CallResponse)) {\n                return callback(new Error(\"internal error\"));\n            }\n            response.results = response.results || [];\n\n            promoteOpaqueStructure3WithCallback(this, response.results, () => {\n                callback(null, isArray ? response.results : response.results![0]);\n            });\n        });\n    }\n\n    /**\n     * @method getMonitoredItems\n     * @param subscriptionId {UInt32} the subscription Id to return\n     * @param callback {Function}\n     * @param callback.err {Error}\n     * @param callback.monitoredItems the monitored Items\n     * @param callback.monitoredItems the monitored Items\n     */\n\n    public async getMonitoredItems(subscriptionId: SubscriptionId): Promise<MonitoredItemData>;\n    public getMonitoredItems(subscriptionId: SubscriptionId, callback: ResponseCallback<MonitoredItemData>): void;\n    public getMonitoredItems(...args: any[]): any {\n        const subscriptionId = args[0] as SubscriptionId;\n        const callback = args[1];\n        // <UAObject NodeId=\"i=2253\"  BrowseName=\"Server\">\n        // <UAMethod NodeId=\"i=11492\" BrowseName=\"GetMonitoredItems\"\n        //                                         ParentNodeId=\"i=2253\" MethodDeclarationId=\"i=11489\">\n        // <UAMethod NodeId=\"i=11489\" BrowseName=\"GetMonitoredItems\" ParentNodeId=\"i=2004\">\n        const methodsToCall = new CallMethodRequest({\n            inputArguments: [\n                // BaseDataType\n                { dataType: DataType.UInt32, value: subscriptionId }\n            ],\n            methodId: coerceNodeId(\"ns=0;i=11492\"), // MethodIds.Server_GetMonitoredItems;\n            objectId: coerceNodeId(\"ns=0;i=2253\") // ObjectId.Server\n        });\n\n        this.call(methodsToCall, (err?: Error | null, result?: CallMethodResult) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!result) {\n                return callback(new Error(\"internal error\"));\n            }\n\n            /* istanbul ignore next */\n            if (result.statusCode.isNot(StatusCodes.Good)) {\n                callback(new Error(result.statusCode.toString()));\n            } else {\n                result.outputArguments = result.outputArguments || [];\n\n                assert(result.outputArguments.length === 2);\n                const data = {\n                    clientHandles: result.outputArguments[1].value,\n                    serverHandles: result.outputArguments[0].value //\n                };\n\n                // Note some server might return null array\n                // let make sure we have Uint32Array and not a null pointer\n                data.serverHandles = data.serverHandles || /* istanbul ignore next */ emptyUint32Array;\n                data.clientHandles = data.clientHandles || /* istanbul ignore next */ emptyUint32Array;\n\n                assert(data.serverHandles instanceof Uint32Array);\n                assert(data.clientHandles instanceof Uint32Array);\n                callback(null, data);\n            }\n        });\n    }\n\n    /**\n     * @method getArgumentDefinition\n     *    extract the argument definition of a method\n     * @param methodId the method nodeId to get argument definition from\n     * @async\n     *\n     */\n    public async getArgumentDefinition(methodId: MethodId): Promise<ArgumentDefinition>;\n    public getArgumentDefinition(methodId: MethodId, callback: ResponseCallback<ArgumentDefinition>): void;\n    /**\n     * @internal\n     */\n    public getArgumentDefinition(...args: any[]): any {\n        const methodId = args[0] as MethodId;\n        const callback = args[1] as ResponseCallback<ArgumentDefinition>;\n        assert(typeof callback === \"function\");\n        return getArgumentDefinitionHelper(this, methodId, callback);\n    }\n\n    public async registerNodes(nodesToRegister: NodeIdLike[]): Promise<NodeId[]>;\n    public registerNodes(nodesToRegister: NodeIdLike[], callback: (err: Error | null, registeredNodeIds?: NodeId[]) => void): void;\n    public registerNodes(...args: any[]): any {\n        const nodesToRegister = args[0] as NodeIdLike[];\n        const callback = args[1] as (err: Error | null, registeredNodeIds?: NodeId[]) => void;\n\n        assert(typeof callback === \"function\");\n        assert(Array.isArray(nodesToRegister));\n\n        const request = new RegisterNodesRequest({\n            nodesToRegister: nodesToRegister.map(resolveNodeId)\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof RegisterNodesResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            response.registeredNodeIds = response.registeredNodeIds || /* istanbul ignore next */ [];\n\n            callback(null, response.registeredNodeIds);\n        });\n    }\n\n    public async unregisterNodes(nodesToUnregister: NodeIdLike[]): Promise<void>;\n    public unregisterNodes(nodesToUnregister: NodeIdLike[], callback: (err?: Error) => void): void;\n    public unregisterNodes(...args: any[]): any {\n        const nodesToUnregister = args[0] as NodeIdLike[];\n        const callback = args[1] as (err?: Error) => void;\n\n        assert(typeof callback === \"function\");\n        assert(Array.isArray(nodesToUnregister));\n\n        const request = new UnregisterNodesRequest({\n            nodesToUnregister: nodesToUnregister.map(resolveNodeId)\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof UnregisterNodesResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            callback();\n        });\n    }\n\n    public async queryFirst(queryFirstRequest: QueryFirstRequestLike): Promise<QueryFirstResponse>;\n\n    public queryFirst(queryFirstRequest: QueryFirstRequestLike, callback: ResponseCallback<QueryFirstResponse>): void;\n    public queryFirst(...args: any[]): any {\n        const queryFirstRequest = args[0] as QueryFirstRequestLike;\n        const callback = args[1] as ResponseCallback<QueryFirstResponse>;\n\n        assert(typeof callback === \"function\");\n        const request = new QueryFirstRequest(queryFirstRequest);\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof QueryFirstResponse)) {\n                return callback(new Error(\"internal error\"));\n            }\n            callback(null, response);\n        });\n    }\n\n    public startKeepAliveManager(): void {\n        if (this._keepAliveManager) {\n            //  \"keepAliveManger already started\"\n            return;\n        }\n        this._keepAliveManager = new ClientSessionKeepAliveManager(this);\n\n        this._keepAliveManager.on(\"failure\", () => {\n            /**\n             * raised when a keep-alive request has failed on the session, may be the session has timeout\n             * unexpectedly on the server side, may be the connection is broken.\n             * @event keepalive_failure\n             */\n            this.emit(\"keepalive_failure\");\n        });\n        this._keepAliveManager.on(\"keepalive\", (state, count) => {\n            /**\n             * @event keepalive\n             */\n            this.emit(\"keepalive\", state, count);\n        });\n        this._keepAliveManager.start();\n    }\n\n    public stopKeepAliveManager(): void {\n        if (this._keepAliveManager) {\n            this._keepAliveManager.stop();\n            this._keepAliveManager = undefined;\n        }\n    }\n\n    public dispose(): void {\n        assert(this._closeEventHasBeenEmitted);\n        this._terminatePublishEngine();\n        this.stopKeepAliveManager();\n        this.removeAllListeners();\n        //\n        const privateThis = this as any;\n        if (!(!privateThis.pendingTransactions || privateThis.pendingTransactions.length === 0)) {\n            // tslint:disable-next-line: no-console\n            console.log(\"dispose when pendingTransactions is not empty \");\n        }\n    }\n\n    public toString(): string {\n        const now = Date.now();\n        const lap1 = now - this.lastRequestSentTime.getTime();\n        const lap2 = now - this.lastResponseReceivedTime.getTime();\n        const timeoutDelay = this.timeout - lap1;\n\n        const timeoutInfo =\n            timeoutDelay < 0\n                ? chalk.red(\" expired since \" + -timeoutDelay / 1000 + \" seconds\")\n                : chalk.green(\" timeout in \" + timeoutDelay / 1000 + \" seconds\");\n\n        let str = \"\";\n        str += \" name..................... \" + this.name;\n        str += \"\\n sessionId................ \" + this.sessionId.toString();\n        str += \"\\n authenticationToken...... \" + (this.authenticationToken ? this.authenticationToken!.toString() : \"\");\n        str += \"\\n timeout.................. \" + this.timeout + \"ms\" + timeoutInfo;\n        str += \"\\n serverNonce.............. \" + (this.serverNonce ? this.serverNonce!.toString(\"hex\") : \"\");\n        str += \"\\n serverCertificate........ \" + buffer_ellipsis(this.serverCertificate);\n        // xx console.log(\" serverSignature.......... \", this.serverSignature);\n        str += \"\\n lastRequestSentTime...... \" + new Date(this.lastRequestSentTime).toISOString() + \"  (\" + lap1 + \")\";\n        str += \"\\n lastResponseReceivedTime. \" + new Date(this.lastResponseReceivedTime).toISOString() + \" (\" + lap2 + \")\";\n        str += \"\\n isReconnecting........... \" + this.isReconnecting;\n        str += \"\\n isValidChannel........... \" + this.isChannelValid() + \" has been closed  \" + this.hasBeenClosed();\n        str += \"\\n channelId................ \" + this.channelId();\n        str += \"\\n remaining life time...... \" + this.evaluateRemainingLifetime();\n        str += \"\\n subscription count....... \" + this.subscriptionCount;\n        if (this._client && this._client._secureChannel) {\n            if (this._client._secureChannel.securityToken) {\n                str += \"\\n reviseTokenLifetime...... \" + this._client._secureChannel.securityToken.revisedLifetime;\n            }\n        }\n        return str;\n    }\n\n    public getBuiltInDataType(...args: any[]): any {\n        const nodeId = args[0];\n        const callback = args[1];\n        return getBuiltInDataType(this, nodeId, callback);\n    }\n\n    public resumePublishEngine(): void {\n        assert(this._publishEngine);\n        if (this._publishEngine && this._publishEngine.subscriptionCount > 0) {\n            this._publishEngine.replenish_publish_request_queue();\n        }\n    }\n\n    public async readNamespaceArray(): Promise<string[]>;\n    public readNamespaceArray(callback: (err: Error | null, namespaceArray?: string[]) => void): void;\n    public readNamespaceArray(...args: any[]): any {\n        const callback = args[0];\n\n        this.read(\n            {\n                attributeId: AttributeIds.Value,\n                nodeId: resolveNodeId(\"Server_NamespaceArray\")\n            },\n            (err: Error | null, dataValue?: DataValue) => {\n                /* istanbul ignore next */\n                if (err) {\n                    return callback(err);\n                }\n                /* istanbul ignore next */\n                if (!dataValue) {\n                    return callback(new Error(\"Internal Error\"));\n                }\n\n                /* istanbul ignore next */\n                if (dataValue.statusCode !== StatusCodes.Good) {\n                    return callback(new Error(\"readNamespaceArray : \" + dataValue.statusCode.toString()));\n                }\n                assert(dataValue.value.value instanceof Array);\n                this._namespaceArray = dataValue.value.value; // keep a cache\n                callback(null, this._namespaceArray);\n            }\n        );\n    }\n\n    public getNamespaceIndex(namespaceUri: string): number {\n        assert(this._namespaceArray, \"please make sure that readNamespaceArray has been called\");\n        return this._namespaceArray.indexOf(namespaceUri);\n    }\n\n    // tslint:disable:no-empty\n    // ---------------------------------------- Alarm & condition stub\n    public disableCondition(): void {\n        /** empty */\n    }\n\n    public enableCondition(): void {\n        /** empty */\n    }\n\n    public addCommentCondition(\n        _conditionId: NodeIdLike,\n        _eventId: Buffer,\n        _comment: LocalizedTextLike,\n        _callback?: Callback<StatusCode>\n    ): any {\n        /** empty */\n    }\n\n    public confirmCondition(\n        _conditionId: NodeIdLike,\n        _eventId: Buffer,\n        _comment: LocalizedTextLike,\n        _callback?: Callback<StatusCode>\n    ): any {\n        /** empty */\n    }\n\n    public acknowledgeCondition(\n        _conditionId: NodeId,\n        _eventId: Buffer,\n        _comment: LocalizedTextLike,\n        _callback?: Callback<StatusCode>\n    ): any {\n        /** empty */\n    }\n\n    public findMethodId(_nodeId: NodeIdLike, _methodName: string, _callback?: ResponseCallback<NodeId>): any {\n        /** empty */\n    }\n\n    public _callMethodCondition(\n        _methodName: string,\n        _conditionId: NodeIdLike,\n        _eventId: Buffer,\n        _comment: LocalizedTextLike,\n        _callback: Callback<StatusCode>\n    ): void {\n        /** empty */\n    }\n\n    public async extractNamespaceDataType(): Promise<ExtraDataTypeManager> {\n        return getExtraDataTypeManager(this);\n    }\n    public async getExtensionObjectConstructor(dataTypeNodeId: NodeId): Promise<AnyConstructorFunc> {\n        return getExtensionObjectConstructor(this, dataTypeNodeId);\n    }\n    /**\n     *\n     * @param dataType\n     * @param pojo\n     * @async\n     */\n    public async constructExtensionObject(dataType: NodeId, pojo: Record<string, any>): Promise<ExtensionObject> {\n        const Constructor = await this.getExtensionObjectConstructor(dataType);\n        return new Constructor(pojo);\n    }\n\n    private _defaultRequest(requestClass: any, _responseClass: any, options: any, callback: any) {\n        assert(typeof callback === \"function\");\n\n        const request = options instanceof requestClass ? options : new requestClass(options);\n\n        /* istanbul ignore next */\n        if (doDebug) {\n            request.trace = new Error(\"\").stack;\n        }\n\n        /* istanbul ignore next */\n        if (this._closeEventHasBeenEmitted) {\n            debugLog(\"ClientSession#_defaultRequest => session has been closed !!\", request.toString());\n            setImmediate(() => {\n                callback(new Error(\"ClientSession is closed !\"));\n            });\n            return;\n        }\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            if (this._closeEventHasBeenEmitted) {\n                debugLog(\n                    \"ClientSession#_defaultRequest ... err =\",\n                    err ? err.message : \"null\",\n                    response ? response.toString() : \" null\"\n                );\n            }\n            /* istanbul ignore next */\n            if (err) {\n                debugLog(\"Client session : performMessageTransaction error = \", err.message);\n                // let intercept interesting error message\n                if (err.message.match(/BadSessionClosed/)) {\n                    // the session has been closed by Server\n                    // probably due to timeout issue\n                    // let's print some statistics\n                    const now = Date.now();\n\n                    /* istanbul ignore next */\n                    if (doDebug) {\n                        debugLog(chalk.bgWhite.red(\" server send BadSessionClosed !\"));\n                        debugLog(chalk.bgWhite.red(\" request was               \"), request.toString());\n                        debugLog(\" timeout.................. \", this.timeout);\n                        debugLog(\n                            \" lastRequestSentTime...... \",\n                            new Date(this.lastRequestSentTime).toISOString(),\n                            now - this.lastRequestSentTime.getTime()\n                        );\n                        debugLog(\n                            \" lastResponseReceivedTime. \",\n                            new Date(this.lastResponseReceivedTime).toISOString(),\n                            now - this.lastResponseReceivedTime.getTime()\n                        );\n                    }\n\n                    //  DO NOT TERMINATE SESSION, as we will need a publishEngine when we\n                    //  reconnect this._terminatePublishEngine();\n\n                    if (false) {\n                        // ER 10.2019\n                        /**\n                         * send when the session has been closed by the server ( probably due to inactivity and timeout)\n                         * @event session_closed\n                         */\n                        this.emitCloseEvent(StatusCodes.BadSessionClosed);\n                    }\n                }\n                return callback(err, response);\n            }\n            callback(null, response);\n        });\n    }\n\n    private recreate_session_and_reperform_transaction(\n        request: Request,\n        callback: (err: Error | null, response?: Response) => void\n    ) {\n        if (this.recursive_repair_detector >= 1) {\n            // tslint:disable-next-line: no-console\n            console.log(\"recreate_session_and_reperform_transaction => Already in Progress\");\n            return callback(new Error(\"Cannot recreate session\"));\n        }\n        this.recursive_repair_detector += 1;\n        debugLog(chalk.red(\"----------------> Repairing Client Session as Server believes it is invalid now \"));\n        repair_client_session(this._client!, this, (err?: Error) => {\n            this.recursive_repair_detector -= 1;\n            if (err) {\n                debugLog(chalk.red(\"----------------> session Repaired has failed with error\", err.message));\n                return callback(err);\n            }\n            debugLog(chalk.red(\"----------------> session Repaired, now redoing original transaction \"));\n            this._performMessageTransaction(request, callback);\n        });\n    }\n}\n\ntype promoteOpaqueStructure3WithCallbackFunc = (\n    session: IBasicSession,\n    callMethodResults: CallMethodResult[],\n    callback: ErrorCallback\n) => void;\n\nasync function promoteOpaqueStructure2(session: IBasicSession, callMethodResult: CallMethodResult): Promise<void> {\n    if (!callMethodResult || !callMethodResult.outputArguments || callMethodResult.outputArguments.length === 0) {\n        return;\n    }\n    await promoteOpaqueStructure(\n        session,\n        callMethodResult.outputArguments.map((a) => ({ value: a }))\n    );\n}\n\nasync function promoteOpaqueStructure3(session: IBasicSession, callMethodResults: CallMethodResult[]): Promise<void> {\n    // construct dataTypeManager if not already present\n    const extraDataTypeManager = await getExtraDataTypeManager(session);\n\n    const promises: Promise<void>[] = callMethodResults.map(async (x: CallMethodResult) => promoteOpaqueStructure2(session, x));\n    await Promise.all(promises);\n}\n\n// tslint:disable:no-var-requires\n// tslint:disable:max-line-length\nconst thenify = require(\"thenify\");\nconst callbackify = require(\"callbackify\");\nconst opts = { multiArgs: false };\n\nconst promoteOpaqueStructureWithCallback = callbackify(promoteOpaqueStructure);\nconst promoteOpaqueStructure3WithCallback = callbackify(promoteOpaqueStructure3) as promoteOpaqueStructure3WithCallbackFunc;\n\nClientSessionImpl.prototype.browse = thenify.withCallback(ClientSessionImpl.prototype.browse, opts);\nClientSessionImpl.prototype.browseNext = thenify.withCallback(ClientSessionImpl.prototype.browseNext, opts);\nClientSessionImpl.prototype.readVariableValue = thenify.withCallback(ClientSessionImpl.prototype.readVariableValue, opts);\nClientSessionImpl.prototype.readHistoryValue = thenify.withCallback(ClientSessionImpl.prototype.readHistoryValue, opts);\nClientSessionImpl.prototype.readAggregateValue = thenify.withCallback(ClientSessionImpl.prototype.readAggregateValue, opts);\nClientSessionImpl.prototype.historyRead = thenify.withCallback(ClientSessionImpl.prototype.historyRead, opts);\nClientSessionImpl.prototype.write = thenify.withCallback(ClientSessionImpl.prototype.write, opts);\nClientSessionImpl.prototype.writeSingleNode = thenify.withCallback(ClientSessionImpl.prototype.writeSingleNode, opts);\nClientSessionImpl.prototype.readAllAttributes = thenify.withCallback(ClientSessionImpl.prototype.readAllAttributes, opts);\nClientSessionImpl.prototype.read = thenify.withCallback(ClientSessionImpl.prototype.read, opts);\nClientSessionImpl.prototype.createSubscription = thenify.withCallback(ClientSessionImpl.prototype.createSubscription, opts);\nClientSessionImpl.prototype.createSubscription2 = thenify.withCallback(ClientSessionImpl.prototype.createSubscription2, opts);\nClientSessionImpl.prototype.deleteSubscriptions = thenify.withCallback(ClientSessionImpl.prototype.deleteSubscriptions, opts);\nClientSessionImpl.prototype.transferSubscriptions = thenify.withCallback(ClientSessionImpl.prototype.transferSubscriptions, opts);\nClientSessionImpl.prototype.createMonitoredItems = thenify.withCallback(ClientSessionImpl.prototype.createMonitoredItems, opts);\nClientSessionImpl.prototype.modifyMonitoredItems = thenify.withCallback(ClientSessionImpl.prototype.modifyMonitoredItems, opts);\nClientSessionImpl.prototype.modifySubscription = thenify.withCallback(ClientSessionImpl.prototype.modifySubscription, opts);\nClientSessionImpl.prototype.setTriggering = thenify.withCallback(ClientSessionImpl.prototype.setTriggering, opts);\nClientSessionImpl.prototype.setMonitoringMode = thenify.withCallback(ClientSessionImpl.prototype.setMonitoringMode, opts);\nClientSessionImpl.prototype.publish = thenify.withCallback(ClientSessionImpl.prototype.publish, opts);\nClientSessionImpl.prototype.republish = thenify.withCallback(ClientSessionImpl.prototype.republish, opts);\nClientSessionImpl.prototype.deleteMonitoredItems = thenify.withCallback(ClientSessionImpl.prototype.deleteMonitoredItems, opts);\nClientSessionImpl.prototype.setPublishingMode = thenify.withCallback(ClientSessionImpl.prototype.setPublishingMode, opts);\nClientSessionImpl.prototype.translateBrowsePath = thenify.withCallback(ClientSessionImpl.prototype.translateBrowsePath, opts);\nClientSessionImpl.prototype.performMessageTransaction = thenify.withCallback(\n    ClientSessionImpl.prototype.performMessageTransaction,\n    opts\n);\nClientSessionImpl.prototype.close = thenify.withCallback(ClientSessionImpl.prototype.close, opts);\nClientSessionImpl.prototype.call = thenify.withCallback(ClientSessionImpl.prototype.call, opts);\nClientSessionImpl.prototype.getMonitoredItems = thenify.withCallback(ClientSessionImpl.prototype.getMonitoredItems, opts);\nClientSessionImpl.prototype.getArgumentDefinition = thenify.withCallback(ClientSessionImpl.prototype.getArgumentDefinition, opts);\nClientSessionImpl.prototype.queryFirst = thenify.withCallback(ClientSessionImpl.prototype.queryFirst, opts);\nClientSessionImpl.prototype.registerNodes = thenify.withCallback(ClientSessionImpl.prototype.registerNodes, opts);\nClientSessionImpl.prototype.unregisterNodes = thenify.withCallback(ClientSessionImpl.prototype.unregisterNodes, opts);\nClientSessionImpl.prototype.readNamespaceArray = thenify.withCallback(ClientSessionImpl.prototype.readNamespaceArray, opts);\nClientSessionImpl.prototype.getBuiltInDataType = thenify.withCallback(ClientSessionImpl.prototype.getBuiltInDataType, opts);\nClientSessionImpl.prototype.constructExtensionObject = callbackify(ClientSessionImpl.prototype.constructExtensionObject);\n", "/**\n * @module node-opcua-client-private\n */\n// tslint:disable:unified-signatures\nimport { EventEmitter } from \"events\";\nimport * as async from \"async\";\nimport * as chalk from \"chalk\";\n\nimport { assert } from \"node-opcua-assert\";\nimport { AttributeIds } from \"node-opcua-data-model\";\nimport { checkDebugFlag, make_debugLog, make_warningLog } from \"node-opcua-debug\";\nimport { resolveNodeId } from \"node-opcua-nodeid\";\n\nimport { ReadValueIdOptions, TimestampsToReturn } from \"node-opcua-service-read\";\nimport {\n    CreateMonitoredItemsRequest,\n    CreateMonitoredItemsResponse,\n    CreateSubscriptionRequest,\n    CreateSubscriptionResponse,\n    DataChangeNotification,\n    DeleteMonitoredItemsResponse,\n    DeleteSubscriptionsResponse,\n    MonitoredItemCreateRequestOptions,\n    MonitoringParametersOptions,\n    NotificationMessage,\n    StatusChangeNotification,\n    NotificationData,\n    EventNotificationList,\n    SetTriggeringResponse,\n    SetTriggeringRequest,\n    MonitoringMode,\n    ModifySubscriptionRequestOptions,\n    ModifySubscriptionResponse\n} from \"node-opcua-service-subscription\";\n\nimport { StatusCode, StatusCodes } from \"node-opcua-status-code\";\nimport { Callback, ErrorCallback } from \"node-opcua-status-code\";\nimport * as utils from \"node-opcua-utils\";\nimport { promoteOpaqueStructureInNotificationData } from \"node-opcua-client-dynamic-extension-object\";\nimport { createMonitoredItemsLimit, IBasicSession, readOperationLimits } from \"node-opcua-pseudo-session\";\n\nimport { IBasicSessionWithSubscription } from \"node-opcua-pseudo-session\";\nimport { ClientMonitoredItemBase } from \"../client_monitored_item_base\";\nimport { ClientMonitoredItemGroup } from \"../client_monitored_item_group\";\nimport { ClientSession, MonitoredItemData, SubscriptionId } from \"../client_session\";\nimport {\n    ClientHandle,\n    ClientMonitoredItemBaseMap,\n    ClientSubscription,\n    ClientSubscriptionOptions,\n    ModifySubscriptionOptions,\n    ModifySubscriptionResult\n} from \"../client_subscription\";\nimport { ClientMonitoredItem } from \"../client_monitored_item\";\nimport { ClientMonitoredItemToolbox } from \"../client_monitored_item_toolbox\";\nimport { ClientMonitoredItemGroupImpl } from \"./client_monitored_item_group_impl\";\nimport { ClientMonitoredItemImpl } from \"./client_monitored_item_impl\";\nimport { ClientSidePublishEngine } from \"./client_publish_engine\";\nimport { ClientSessionImpl } from \"./client_session_impl\";\n\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\nconst warningLog = make_warningLog(__filename);\n\nconst PENDING_SUBSCRIPTION_ID = 0xc0cac01a;\nconst TERMINATED_SUBSCRIPTION_ID = 0xc0cac01b;\nconst TERMINATING_SUBSCRIPTION_ID = 0xc0cac01c;\n\nconst minimumMaxKeepAliveCount = 3;\n\nfunction displayKeepAliveWarning(sessionTimeout: number, maxKeepAliveCount: number, publishingInterval: number): boolean {\n    const keepAliveInterval = maxKeepAliveCount * publishingInterval;\n\n    // istanbul ignore next\n    if (sessionTimeout < keepAliveInterval) {\n        warningLog(\n            chalk.yellowBright(\n                `[NODE-OPCUA-W09] The subscription parameters are not compatible with the session timeout !\n                  session timeout    = ${sessionTimeout}  milliseconds\n                  maxKeepAliveCount  = ${maxKeepAliveCount}\n                  publishingInterval = ${publishingInterval} milliseconds\"\n\n                  It is important that the session timeout    ( ${chalk.red(sessionTimeout)} ms) is largely greater than :\n                      (maxKeepAliveCount*publishingInterval  =  ${chalk.red(keepAliveInterval)} ms),\n                  otherwise you may experience unexpected disconnection from the server if your monitored items are not\n                  changing frequently.`\n            )\n        );\n\n        if (sessionTimeout < 3000 && publishingInterval <= 1000) {\n            warningLog(`[NODE-OPCUA-W10] You'll need to increase your sessionTimeout significantly.`);\n        }\n        if (\n            sessionTimeout >= 3000 &&\n            sessionTimeout < publishingInterval * minimumMaxKeepAliveCount &&\n            maxKeepAliveCount <= minimumMaxKeepAliveCount + 2\n        ) {\n            warningLog(`[NODE-OPCUA-W11] your publishingInterval interval is probably too large, consider reducing it.`);\n        }\n\n        const idealMaxKeepAliveCount = Math.max(4, Math.floor((sessionTimeout * 0.8) / publishingInterval - 0.5));\n        const idealPublishingInternal = Math.min(publishingInterval, sessionTimeout / (idealMaxKeepAliveCount + 3));\n        const idealKeepAliveInterval = idealMaxKeepAliveCount * publishingInterval;\n        warningLog(\n            `[NODE-OPCUA-W12]  An ideal value for maxKeepAliveCount could be ${idealMaxKeepAliveCount}.\n                  An ideal value for publishingInterval could be ${idealPublishingInternal} ms.\n                  This will make  your subscription emit a keep alive signal every ${idealKeepAliveInterval} ms\n                  if no monitored items are generating notifications.\n                  for instance:\n                    const  client = OPCUAClient.create({\n                        requestedSessionTimeout: 30* 60* 1000, // 30 minutes\n                    });\n`\n        );\n\n        if (!ClientSubscription.ignoreNextWarning) {\n            throw new Error(\"[NODE-OPCUA-W09] The subscription parameters are not compatible with the session timeout \");\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction createMonitoredItemsAndRespectOperationalLimits(\n    session: IBasicSession & IBasicSessionWithSubscription,\n    createMonitorItemsRequest: CreateMonitoredItemsRequest,\n    callback: (err: Error | null, response?: CreateMonitoredItemsResponse) => void\n) {\n    readOperationLimits(session)\n        .then((operationalLimits) => {\n            createMonitoredItemsLimit(operationalLimits.maxMonitoredItemsPerCall || 0, session, createMonitorItemsRequest)\n                .then((createMonitoredItemResponse) => callback(null, createMonitoredItemResponse))\n                .catch(callback);\n        })\n        .catch(callback);\n}\n\nexport class ClientSubscriptionImpl extends EventEmitter implements ClientSubscription {\n    /**\n     * the associated session\n     * @property session\n     * @type {ClientSession}\n     */\n    public get session(): ClientSessionImpl {\n        assert(this.publishEngine.session, \"expecting a valid session here\");\n        return this.publishEngine.session! as ClientSessionImpl;\n    }\n    public get hasSession(): boolean {\n        return !!this.publishEngine.session;\n    }\n    public get isActive(): boolean {\n        return !(\n            this.subscriptionId === PENDING_SUBSCRIPTION_ID ||\n            this.subscriptionId === TERMINATED_SUBSCRIPTION_ID ||\n            this.subscriptionId === TERMINATING_SUBSCRIPTION_ID\n        );\n    }\n\n    public subscriptionId: SubscriptionId;\n    public publishingInterval: number;\n    public lifetimeCount: number;\n    public maxKeepAliveCount: number;\n    public maxNotificationsPerPublish: number;\n    public publishingEnabled: boolean;\n    public priority: number;\n    public monitoredItems: ClientMonitoredItemBaseMap;\n    public monitoredItemGroups: ClientMonitoredItemGroup[] = [];\n\n    public timeoutHint = 0;\n    public publishEngine: ClientSidePublishEngine;\n\n    public lastSequenceNumber: number;\n    private lastRequestSentTime: Date;\n    private _nextClientHandle = 0;\n    private hasTimedOut: boolean;\n\n    constructor(session: ClientSession, options: ClientSubscriptionOptions) {\n        super();\n\n        const sessionImpl = session as ClientSessionImpl;\n        this.publishEngine = sessionImpl.getPublishEngine();\n\n        this.lastSequenceNumber = -1;\n\n        options = options || {};\n        options.requestedPublishingInterval = options.requestedPublishingInterval || 100;\n        options.requestedLifetimeCount = options.requestedLifetimeCount || 60;\n        options.requestedMaxKeepAliveCount = options.requestedMaxKeepAliveCount || 10;\n        options.requestedMaxKeepAliveCount = Math.max(options.requestedMaxKeepAliveCount, minimumMaxKeepAliveCount);\n\n        // perform some verification\n        const warningEmitted = displayKeepAliveWarning(\n            session.timeout,\n            options.requestedMaxKeepAliveCount,\n            options.requestedPublishingInterval\n        );\n        // istanbul ignore next\n        if (warningEmitted) {\n            warningLog(\n                JSON.stringify(\n                    {\n                        ...options\n                    },\n                    null,\n                    \" \"\n                )\n            );\n        }\n\n        options.maxNotificationsPerPublish = utils.isNullOrUndefined(options.maxNotificationsPerPublish)\n            ? 0\n            : options.maxNotificationsPerPublish;\n\n        options.publishingEnabled = !!options.publishingEnabled;\n        options.priority = options.priority || 1;\n\n        this.publishingInterval = options.requestedPublishingInterval;\n        this.lifetimeCount = options.requestedLifetimeCount;\n        this.maxKeepAliveCount = options.requestedMaxKeepAliveCount;\n        this.maxNotificationsPerPublish = options.maxNotificationsPerPublish || 0;\n        this.publishingEnabled = options.publishingEnabled;\n        this.priority = options.priority;\n\n        this.subscriptionId = PENDING_SUBSCRIPTION_ID;\n\n        this._nextClientHandle = 0;\n        this.monitoredItems = {};\n\n        this.lastRequestSentTime = new Date(1, 1, 1970);\n\n        /**\n         * set to True when the server has notified us that this subscription has timed out\n         * ( maxLifeCounter x published interval without being able to process a PublishRequest\n         * @property hasTimedOut\n         * @type {boolean}\n         */\n        this.hasTimedOut = false;\n\n        setImmediate(() => {\n            this.__create_subscription((err?: Error) => {\n                if (!err) {\n                    setImmediate(() => {\n                        /**\n                         * notify the observers that the subscription has now started\n                         * @event started\n                         */\n                        this.emit(\"started\", this.subscriptionId);\n                    });\n                } else {\n                    setImmediate(() => {\n                        /**\n                         * notify the observers that the subscription has now failed\n                         * @event failed\n                         */\n                        this.emit(\"error\", err);\n                    });\n                }\n            });\n        });\n    }\n\n    public terminate(...args: any[]): any {\n        debugLog(\"Terminating client subscription \", this.subscriptionId);\n        const callback = args[0];\n        assert(typeof callback === \"function\", \"expecting a callback function\");\n\n        if (this.subscriptionId === TERMINATED_SUBSCRIPTION_ID || this.subscriptionId === TERMINATING_SUBSCRIPTION_ID) {\n            // already terminated... just ignore\n            return callback(new Error(\"Already Terminated\"));\n        }\n\n        if (isFinite(this.subscriptionId)) {\n            const subscriptionId = this.subscriptionId;\n            this.subscriptionId = TERMINATING_SUBSCRIPTION_ID;\n            this.publishEngine.unregisterSubscription(subscriptionId);\n\n            if (!this.hasSession) {\n                return this._terminate_step2(callback);\n            }\n            const session = this.session;\n            if (!session) {\n                return callback(new Error(\"no session\"));\n            }\n            session.deleteSubscriptions(\n                {\n                    subscriptionIds: [subscriptionId]\n                },\n                (err: Error | null, response?: DeleteSubscriptionsResponse) => {\n                    if (response && response!.results![0] !== StatusCodes.Good) {\n                        debugLog(\"warning: deleteSubscription returned \", response.results);\n                    }\n                    if (err) {\n                        /**\n                         * notify the observers that an error has occurred\n                         * @event internal_error\n                         * @param err the error\n                         */\n                        this.emit(\"internal_error\", err);\n                    }\n                    this._terminate_step2(callback);\n                }\n            );\n        } else {\n            debugLog(\"subscriptionId is not value \", this.subscriptionId);\n            assert(this.subscriptionId === PENDING_SUBSCRIPTION_ID);\n            this._terminate_step2(callback);\n        }\n    }\n\n    /**\n     * @method nextClientHandle\n     */\n    public nextClientHandle(): number {\n        this._nextClientHandle += 1;\n        return this._nextClientHandle;\n    }\n\n    public async monitor(\n        itemToMonitor: ReadValueIdOptions,\n        requestedParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn,\n        monitoringMode: MonitoringMode\n    ): Promise<ClientMonitoredItemBase>;\n    public monitor(\n        itemToMonitor: ReadValueIdOptions,\n        requestedParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn,\n        monitoringMode: MonitoringMode,\n        done: Callback<ClientMonitoredItemBase>\n    ): void;\n    public monitor(...args: any[]): any {\n        const itemToMonitor = args[0] as ReadValueIdOptions;\n        const requestedParameters = args[1] as MonitoringParametersOptions;\n        const timestampsToReturn = args[2] as TimestampsToReturn;\n        const monitoringMode = typeof args[3] === \"function\" ? MonitoringMode.Reporting : (args[3] as MonitoringMode);\n        const done = (typeof args[3] === \"function\" ? args[3] : args[4]) as Callback<ClientMonitoredItemBase>;\n\n        assert(typeof done === \"function\", \"expecting a function here\");\n\n        itemToMonitor.nodeId = resolveNodeId(itemToMonitor.nodeId!);\n\n        const monitoredItem = ClientMonitoredItem_create(\n            this,\n            itemToMonitor,\n            requestedParameters,\n            timestampsToReturn,\n            monitoringMode,\n            (err1?: Error | null, monitoredItem2?: ClientMonitoredItem) => {\n                if (err1) {\n                    return done && done(err1);\n                }\n                done(err1 || null, monitoredItem);\n            }\n        );\n    }\n\n    public async monitorItems(\n        itemsToMonitor: ReadValueIdOptions[],\n        requestedParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn\n    ): Promise<ClientMonitoredItemGroup>;\n\n    public monitorItems(\n        itemsToMonitor: ReadValueIdOptions[],\n        requestedParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn,\n        done: Callback<ClientMonitoredItemGroup>\n    ): void;\n    public monitorItems(...args: any[]): any {\n        const itemsToMonitor = args[0] as ReadValueIdOptions[];\n        const requestedParameters = args[1] as MonitoringParametersOptions;\n        const timestampsToReturn = args[2] as TimestampsToReturn;\n        const done = args[3] as Callback<ClientMonitoredItemGroup>;\n\n        const monitoredItemGroup = new ClientMonitoredItemGroupImpl(this, itemsToMonitor, requestedParameters, timestampsToReturn);\n\n        this._wait_for_subscription_to_be_ready((err?: Error) => {\n            if (err) {\n                return done(err);\n            }\n            monitoredItemGroup._monitor((err1?: Error) => {\n                if (err1) {\n                    return done && done(err1);\n                }\n                done(err1!, monitoredItemGroup);\n            });\n        });\n    }\n\n    public _delete_monitored_items(monitoredItems: ClientMonitoredItemBase[], callback: ErrorCallback): void {\n        assert(typeof callback === \"function\");\n        assert(Array.isArray(monitoredItems));\n\n        assert(this.isActive);\n\n        for (const monitoredItem of monitoredItems) {\n            this._remove(monitoredItem);\n        }\n        const session = this.session as ClientSessionImpl;\n        session.deleteMonitoredItems(\n            {\n                monitoredItemIds: monitoredItems.map((monitoredItem) => monitoredItem.monitoredItemId),\n                subscriptionId: this.subscriptionId\n            },\n            (err: Error | null, response?: DeleteMonitoredItemsResponse) => {\n                callback(err!);\n            }\n        );\n    }\n\n    public async setPublishingMode(publishingEnabled: boolean): Promise<StatusCode>;\n    public setPublishingMode(publishingEnabled: boolean, callback: Callback<StatusCode>): void;\n    public setPublishingMode(...args: any[]): any {\n        const publishingEnabled = args[0] as boolean;\n        const callback = args[1] as Callback<StatusCode>;\n        assert(typeof callback === \"function\");\n\n        const session = this.session as ClientSessionImpl;\n        if (!session) {\n            return callback(new Error(\"no session\"));\n        }\n        const subscriptionId = this.subscriptionId as SubscriptionId;\n        session.setPublishingMode(publishingEnabled, subscriptionId, (err: Error | null, statusCode?: StatusCode) => {\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!statusCode) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            if (statusCode !== StatusCodes.Good) {\n                return callback(null, statusCode);\n            }\n            callback(null, StatusCodes.Good);\n        });\n    }\n\n    /**\n     *\n     */\n    public setTriggering(\n        triggeringItem: ClientMonitoredItemBase,\n        linksToAdd: ClientMonitoredItemBase[] | null,\n        linksToRemove?: ClientMonitoredItemBase[] | null\n    ): Promise<SetTriggeringResponse>;\n    public setTriggering(\n        triggeringItem: ClientMonitoredItemBase,\n        linksToAdd: ClientMonitoredItemBase[] | null,\n        linksToRemove: ClientMonitoredItemBase[] | null,\n        callback: Callback<SetTriggeringResponse>\n    ): void;\n    public setTriggering(...args: any[]): any {\n        const triggeringItem = args[0] as ClientMonitoredItemBase;\n        const linksToAdd = args[1] as ClientMonitoredItemBase[] | null;\n        const linksToRemove = args[2] as ClientMonitoredItemBase[] | null;\n        const callback = args[3] as Callback<SetTriggeringResponse>;\n        assert(typeof callback === \"function\");\n        const session = this.session as ClientSessionImpl;\n        if (!session) {\n            return callback(new Error(\"no session\"));\n        }\n        const subscriptionId = this.subscriptionId;\n\n        const triggeringItemId = triggeringItem.monitoredItemId!;\n\n        const setTriggeringRequest = new SetTriggeringRequest({\n            linksToAdd: linksToAdd ? linksToAdd.map((i) => i.monitoredItemId!) : null,\n            linksToRemove: linksToRemove ? linksToRemove.map((i) => i.monitoredItemId!) : null,\n            subscriptionId,\n            triggeringItemId\n        });\n        session.setTriggering(setTriggeringRequest, (err: Error | null, response?: SetTriggeringResponse) => {\n            if (err) {\n                // use soft error, no exceptions\n                return callback(null, response);\n            }\n            // istanbul ignore next\n            if (!response) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            callback(null, response);\n        });\n    }\n\n    // public subscription service\n    public modify(options: ModifySubscriptionOptions, callback: Callback<ModifySubscriptionResult>): void;\n    public modify(options: ModifySubscriptionOptions): Promise<ModifySubscriptionResult>;\n    public modify(...args: any[]): any {\n        const modifySubscriptionRequest = args[0] as ModifySubscriptionRequestOptions;\n        const callback = args[1] as Callback<ModifySubscriptionResult>;\n        const session = this.session as ClientSessionImpl;\n        if (!session) {\n            return callback(new Error(\"no session\"));\n        }\n\n        modifySubscriptionRequest.subscriptionId = this.subscriptionId;\n\n        modifySubscriptionRequest.priority =\n            modifySubscriptionRequest.priority === undefined ? this.priority : modifySubscriptionRequest.priority;\n        modifySubscriptionRequest.requestedLifetimeCount =\n            modifySubscriptionRequest.requestedLifetimeCount === undefined\n                ? this.lifetimeCount\n                : modifySubscriptionRequest.requestedLifetimeCount;\n        modifySubscriptionRequest.requestedMaxKeepAliveCount =\n            modifySubscriptionRequest.requestedMaxKeepAliveCount === undefined\n                ? this.maxKeepAliveCount\n                : modifySubscriptionRequest.requestedMaxKeepAliveCount;\n        modifySubscriptionRequest.requestedPublishingInterval =\n            modifySubscriptionRequest.requestedPublishingInterval === undefined\n                ? this.publishingInterval\n                : modifySubscriptionRequest.requestedPublishingInterval;\n        modifySubscriptionRequest.maxNotificationsPerPublish =\n            modifySubscriptionRequest.maxNotificationsPerPublish === undefined\n                ? this.maxNotificationsPerPublish\n                : modifySubscriptionRequest.maxNotificationsPerPublish;\n\n        session.modifySubscription(modifySubscriptionRequest, (err: Error | null, response?: ModifySubscriptionResponse) => {\n            if (err || !response) {\n                return callback(err);\n            }\n            this.publishingInterval = response.revisedPublishingInterval;\n            this.lifetimeCount = response.revisedLifetimeCount;\n            this.maxKeepAliveCount = response.revisedMaxKeepAliveCount;\n            callback(null, response);\n        });\n    }\n\n    public getMonitoredItems(): Promise<MonitoredItemData>;\n    public getMonitoredItems(callback: Callback<MonitoredItemData>): void;\n    public getMonitoredItems(...args: any[]): any {\n        this.session.getMonitoredItems(this.subscriptionId, args[0]);\n    }\n\n    /**\n     *  utility function to recreate new subscription\n     *  @method recreateSubscriptionAndMonitoredItem\n     */\n    public recreateSubscriptionAndMonitoredItem(callback: ErrorCallback): void {\n        debugLog(\"ClientSubscription#recreateSubscriptionAndMonitoredItem\");\n\n        if (this.subscriptionId === TERMINATED_SUBSCRIPTION_ID) {\n            debugLog(\"Subscription is not in a valid state\");\n            return callback();\n        }\n\n        const oldMonitoredItems = this.monitoredItems;\n\n        this.publishEngine.unregisterSubscription(this.subscriptionId);\n\n        async.series(\n            [\n                (innerCallback: ErrorCallback) => {\n                    this.__create_subscription(innerCallback);\n                },\n                (innerCallback: ErrorCallback) => {\n                    const test = this.publishEngine.getSubscription(this.subscriptionId);\n\n                    debugLog(\"recreating \", Object.keys(oldMonitoredItems).length, \" monitored Items\");\n                    // re-create monitored items\n                    const itemsToCreate: MonitoredItemCreateRequestOptions[] = [];\n\n                    for (const monitoredItem of Object.values(oldMonitoredItems)) {\n                        assert(monitoredItem.monitoringParameters.clientHandle > 0);\n                        itemsToCreate.push({\n                            itemToMonitor: monitoredItem.itemToMonitor,\n                            monitoringMode: monitoredItem.monitoringMode,\n                            requestedParameters: monitoredItem.monitoringParameters\n                        });\n                    }\n\n                    const createMonitorItemsRequest = new CreateMonitoredItemsRequest({\n                        itemsToCreate,\n                        subscriptionId: this.subscriptionId,\n                        timestampsToReturn: TimestampsToReturn.Both // this.timestampsToReturn,\n                    });\n\n                    const session = this.session;\n                    // istanbul ignore next\n                    if (!session) {\n                        return innerCallback(new Error(\"no session\"));\n                    }\n\n                    debugLog(\"Recreating \", itemsToCreate.length, \" monitored items\");\n\n                    createMonitoredItemsAndRespectOperationalLimits(\n                        session,\n                        createMonitorItemsRequest,\n                        (err: Error | null, response?: CreateMonitoredItemsResponse) => {\n                            if (err) {\n                                debugLog(\"Recreating monitored item has failed with \", err.message);\n                                return innerCallback(err);\n                            }\n                            /* istanbul ignore next */\n                            if (!response) {\n                                return innerCallback(new Error(\"Internal Error\"));\n                            }\n                            const monitoredItemResults = response.results || [];\n\n                            monitoredItemResults.forEach((monitoredItemResult, index) => {\n                                const itemToCreate = itemsToCreate[index];\n                                /* istanbul ignore next */\n                                if (!itemToCreate || !itemToCreate.requestedParameters) {\n                                    throw new Error(\"Internal Error\");\n                                }\n                                const clientHandle = itemToCreate.requestedParameters.clientHandle;\n                                /* istanbul ignore next */\n                                if (!clientHandle) {\n                                    throw new Error(\"Internal Error\");\n                                }\n                                const monitoredItem = this.monitoredItems[clientHandle] as ClientMonitoredItemImpl;\n                                if (monitoredItem) {\n                                    monitoredItem._applyResult(monitoredItemResult);\n                                } else {\n                                    warningLog(\"cannot find monitored item for clientHandle !:\", clientHandle);\n                                }\n                            });\n                            innerCallback();\n                        }\n                    );\n                }\n            ],\n            (err) => {\n                if (err) {\n                    warningLog(err.message);\n                }\n                callback(err!);\n            }\n        );\n    }\n\n    public toString(): string {\n        let str = \"\";\n        str += \"subscriptionId      : \" + this.subscriptionId + \"\\n\";\n        str += \"publishingInterval  : \" + this.publishingInterval + \"\\n\";\n        str += \"lifetimeCount       : \" + this.lifetimeCount + \"\\n\";\n        str += \"maxKeepAliveCount   : \" + this.maxKeepAliveCount + \"\\n\";\n        str += \"hasTimedOut         : \" + this.hasTimedOut + \"\\n\";\n\n        const timeToLive = this.lifetimeCount * this.publishingInterval;\n        str += \"timeToLive          : \" + timeToLive + \"\\n\";\n        str += \"lastRequestSentTime : \" + this.lastRequestSentTime.toString() + \"\\n\";\n        const duration = Date.now() - this.lastRequestSentTime.getTime();\n        const extra =\n            duration - timeToLive > 0\n                ? chalk.red(\" expired since \" + (duration - timeToLive) / 1000 + \" seconds\")\n                : chalk.green(\" valid for \" + -(duration - timeToLive) / 1000 + \" seconds\");\n\n        str += \"timeSinceLast PR    : \" + duration + \"ms\" + extra + \"\\n\";\n        str += \"has expired         : \" + (duration > timeToLive) + \"\\n\";\n\n        str += \"(session timeout    : \" + this.session.timeout + \" ms)\\n\";\n        str += \"(maxKeepAliveCount*publishingInterval: \" + this.publishingInterval * this.session.timeout + \" ms)\\n\";\n\n        return str;\n    }\n\n    /**\n     * returns the approximated remaining life time of this subscription in milliseconds\n     */\n    public evaluateRemainingLifetime(): number {\n        const now = Date.now();\n        const timeout = this.publishingInterval * this.lifetimeCount;\n        const expiryTime = this.lastRequestSentTime.getTime() + timeout;\n        return Math.max(0, expiryTime - now);\n    }\n\n    public _add_monitored_item(clientHandle: ClientHandle, monitoredItem: ClientMonitoredItemBase): void {\n        assert(this.isActive, \"subscription must be active and not terminated\");\n        assert(monitoredItem.monitoringParameters.clientHandle === clientHandle);\n        this.monitoredItems[clientHandle] = monitoredItem;\n\n        /**\n         * notify the observers that a new monitored item has been added to the subscription.\n         * @event item_added\n         * @param the monitored item.\n         */\n        this.emit(\"item_added\", monitoredItem);\n    }\n\n    public _add_monitored_items_group(monitoredItemGroup: ClientMonitoredItemGroupImpl): void {\n        this.monitoredItemGroups.push(monitoredItemGroup);\n    }\n\n    public _wait_for_subscription_to_be_ready(done: ErrorCallback): void {\n        let _watchDogCount = 0;\n\n        const waitForSubscriptionAndMonitor = () => {\n            _watchDogCount++;\n\n            if (this.subscriptionId === PENDING_SUBSCRIPTION_ID) {\n                // the subscriptionID is not yet known because the server hasn't replied yet\n                // let postpone this call, a little bit, to let things happen\n                setImmediate(waitForSubscriptionAndMonitor);\n            } else if (this.subscriptionId === TERMINATED_SUBSCRIPTION_ID) {\n                // the subscription has been terminated in the meantime\n                // this indicates a potential issue in the code using this api.\n                if (typeof done === \"function\") {\n                    done(new Error(\"subscription has been deleted\"));\n                }\n            } else {\n                done();\n            }\n        };\n\n        setImmediate(waitForSubscriptionAndMonitor);\n    }\n\n    private __create_subscription(callback: ErrorCallback) {\n        assert(typeof callback === \"function\");\n\n        // istanbul ignore next\n        if (!this.hasSession) {\n            return callback(new Error(\"No Session\"));\n        }\n        const session = this.session;\n\n        debugLog(chalk.yellow.bold(\"ClientSubscription created \"));\n\n        const request = new CreateSubscriptionRequest({\n            maxNotificationsPerPublish: this.maxNotificationsPerPublish,\n            priority: this.priority,\n            publishingEnabled: this.publishingEnabled,\n            requestedLifetimeCount: this.lifetimeCount,\n            requestedMaxKeepAliveCount: this.maxKeepAliveCount,\n            requestedPublishingInterval: this.publishingInterval\n        });\n\n        session.createSubscription(request, (err: Error | null, response?: CreateSubscriptionResponse) => {\n            if (err) {\n                /* istanbul ignore next */\n                this.emit(\"internal_error\", err);\n                if (callback) {\n                    return callback(err);\n                }\n                return;\n            }\n\n            /* istanbul ignore next */\n            if (!response) {\n                return callback(new Error(\"internal error\"));\n            }\n\n            if (!this.hasSession) {\n                return callback(new Error(\"createSubscription has failed = > no session\"));\n            }\n            assert(this.hasSession);\n\n            this.subscriptionId = response.subscriptionId;\n            this.publishingInterval = response.revisedPublishingInterval;\n            this.lifetimeCount = response.revisedLifetimeCount;\n            this.maxKeepAliveCount = response.revisedMaxKeepAliveCount;\n\n            this.timeoutHint = (this.maxKeepAliveCount + 10) * this.publishingInterval;\n\n            displayKeepAliveWarning(this.session.timeout, this.maxKeepAliveCount, this.publishingInterval);\n            ClientSubscription.ignoreNextWarning = false;\n\n            if (doDebug) {\n                debugLog(chalk.yellow.bold(\"registering callback\"));\n                debugLog(chalk.yellow.bold(\"publishingInterval               \"), this.publishingInterval);\n                debugLog(chalk.yellow.bold(\"lifetimeCount                    \"), this.lifetimeCount);\n                debugLog(chalk.yellow.bold(\"maxKeepAliveCount                \"), this.maxKeepAliveCount);\n                debugLog(chalk.yellow.bold(\"publish request timeout hint =   \"), this.timeoutHint);\n                debugLog(chalk.yellow.bold(\"hasTimedOut                      \"), this.hasTimedOut);\n                debugLog(chalk.yellow.bold(\"timeoutHint for publish request  \"), this.timeoutHint);\n            }\n\n            this.publishEngine.registerSubscription(this);\n\n            if (callback) {\n                callback();\n            }\n        });\n    }\n\n    private __on_publish_response_DataChangeNotification(notification: DataChangeNotification) {\n        assert(notification.schema.name === \"DataChangeNotification\");\n\n        const monitoredItems = notification.monitoredItems || [];\n\n        let repeated = 0;\n        for (const monitoredItem of monitoredItems) {\n            const monitorItemObj = this.monitoredItems[monitoredItem.clientHandle];\n            if (monitorItemObj) {\n                if (monitorItemObj.itemToMonitor.attributeId === AttributeIds.EventNotifier) {\n                    warningLog(\n                        chalk.yellow(\"Warning\"),\n                        chalk.cyan(\n                            \" Server send a DataChangeNotification for an EventNotifier.\" + \" EventNotificationList was expected\"\n                        )\n                    );\n                    warningLog(\n                        chalk.cyan(\"         the Server may not be fully OPCUA compliant\"),\n                        chalk.yellow(\". This notification will be ignored.\")\n                    );\n                } else {\n                    const monitoredItemImpl = monitorItemObj as ClientMonitoredItemImpl;\n                    monitoredItemImpl._notify_value_change(monitoredItem.value);\n                }\n            } else {\n                repeated += 1;\n                if (repeated === 1) {\n                    warningLog(\n                        \"Receiving a notification for a unknown monitoredItem with clientHandle \",\n                        monitoredItem.clientHandle\n                    );\n                }\n            }\n        }\n        // istanbul ignore next\n        if (repeated > 1) {\n            warningLog(\"previous message repeated\", repeated, \"times\");\n        }\n    }\n\n    private __on_publish_response_StatusChangeNotification(notification: StatusChangeNotification) {\n        assert(notification.schema.name === \"StatusChangeNotification\");\n\n        debugLog(\"Client has received a Status Change Notification \", notification.status.toString());\n\n        if (notification.status === StatusCodes.GoodSubscriptionTransferred) {\n            // OPCUA UA Spec 1.0.3 : part 3 - page 82 - 5.13.7 TransferSubscriptions:\n            // If the Server transfers the Subscription to the new Session, the Server shall issue\n            // a StatusChangeNotification  notificationMessage with the status code\n            // Good_SubscriptionTransferred to the old Session.\n            debugLog(\"ClientSubscription#__on_publish_response_StatusChangeNotification : GoodSubscriptionTransferred\");\n\n            // may be it has been transferred after a reconnection.... in this case should do nothing about it\n        }\n        if (notification.status === StatusCodes.BadTimeout) {\n            // the server tells use that the subscription has timed out ..\n            // this mean that this subscription has been closed on the server side and cannot process any\n            // new PublishRequest.\n            //\n            // from Spec OPCUA Version 1.03 Part 4 - 5.13.1.1 Description : Page 69:\n            //\n            // h. Subscriptions have a lifetime counter that counts the number of consecutive publishing cycles in\n            //    which there have been no Publish requests available to send a Publish response for the\n            //    Subscription. Any Service call that uses the SubscriptionId or the processing of a Publish\n            //    response resets the lifetime counter of this Subscription. When this counter reaches the value\n            //    calculated for the lifetime of a Subscription based on the MaxKeepAliveCount parameter in the\n            //    CreateSubscription Service (5.13.2), the Subscription is closed. Closing the Subscription causes\n            //    its MonitoredItems to be deleted. In addition the Server shall issue a StatusChangeNotification\n            //    notificationMessage with the status code BadTimeout.\n            //\n            this.hasTimedOut = true;\n            this.terminate(() => {\n                /* empty */\n            });\n        }\n        /**\n         * notify the observers that the server has send a status changed notification (such as BadTimeout )\n         * @event status_changed\n         */\n        this.emit(\"status_changed\", notification.status, notification.diagnosticInfo);\n    }\n\n    private __on_publish_response_EventNotificationList(notification: EventNotificationList) {\n        assert(notification.schema.name === \"EventNotificationList\");\n        const events = notification.events || [];\n        for (const event of events) {\n            const monitorItemObj = this.monitoredItems[event.clientHandle];\n            assert(monitorItemObj, \"Expecting a monitored item\");\n\n            const monitoredItemImpl = monitorItemObj as ClientMonitoredItemImpl;\n            monitoredItemImpl._notify_event(event.eventFields || []);\n        }\n    }\n\n    public onNotificationMessage(notificationMessage: NotificationMessage): void {\n        assert(Object.prototype.hasOwnProperty.call(notificationMessage, \"sequenceNumber\"));\n\n        this.lastSequenceNumber = notificationMessage.sequenceNumber;\n\n        this.emit(\"raw_notification\", notificationMessage);\n\n        const notificationData = (notificationMessage.notificationData || []) as NotificationData[];\n\n        if (notificationData.length === 0) {\n            // this is a keep alive message\n            debugLog(chalk.yellow(\"Client : received a keep alive notification from client\"));\n            /**\n             * notify the observers that a keep alive Publish Response has been received from the server.\n             * @event keepalive\n             */\n            this.emit(\"keepalive\");\n        } else {\n            /**\n             * notify the observers that some notifications has been received from the server in  a PublishResponse\n             * each modified monitored Item\n             * @event  received_notifications\n             */\n            this.emit(\"received_notifications\", notificationMessage);\n            // let publish a global event\n\n            promoteOpaqueStructureInNotificationData(this.session, notificationData).then(() => {\n                // now process all notifications\n                for (const notification of notificationData) {\n                    // istanbul ignore next\n                    if (!notification) {\n                        continue;\n                    }\n\n                    // DataChangeNotification / StatusChangeNotification / EventNotification\n                    switch (notification.schema.name) {\n                        case \"DataChangeNotification\":\n                            // now inform each individual monitored item\n                            this.__on_publish_response_DataChangeNotification(notification as DataChangeNotification);\n                            break;\n                        case \"StatusChangeNotification\":\n                            this.__on_publish_response_StatusChangeNotification(notification as StatusChangeNotification);\n                            break;\n                        case \"EventNotificationList\":\n                            this.__on_publish_response_EventNotificationList(notification as EventNotificationList);\n                            break;\n                        default:\n                            warningLog(\" Invalid notification :\", notification.toString());\n                    }\n                }\n            });\n        }\n    }\n\n    private _terminate_step2(callback: (err?: Error) => void) {\n        const monitoredItems = Object.values(this.monitoredItems);\n        for (const monitoredItem of monitoredItems) {\n            this._remove(monitoredItem);\n        }\n\n        const monitoredItemGroups = this.monitoredItemGroups;\n        for (const monitoredItemGroup of monitoredItemGroups) {\n            this._removeGroup(monitoredItemGroup);\n        }\n\n        assert(Object.values(this.monitoredItems).length === 0);\n\n        setImmediate(() => {\n            /**\n             * notify the observers that the client subscription has terminated\n             * @event  terminated\n             */\n            this.subscriptionId = TERMINATED_SUBSCRIPTION_ID;\n            this.emit(\"terminated\");\n            callback();\n        });\n    }\n\n    private _remove(monitoredItem: ClientMonitoredItemBase) {\n        const clientHandle = monitoredItem.monitoringParameters.clientHandle;\n        assert(clientHandle > 0);\n        if (!Object.prototype.hasOwnProperty.call(this.monitoredItems, clientHandle)) {\n            return; // may be monitoredItem failed to be created  ....\n        }\n        assert(Object.prototype.hasOwnProperty.call(this.monitoredItems, clientHandle));\n\n        const priv = monitoredItem as ClientMonitoredItemImpl;\n        priv._terminate_and_emit();\n    }\n\n    public _removeGroup(monitoredItemGroup: ClientMonitoredItemGroup): void {\n        (monitoredItemGroup as any)._terminate_and_emit();\n        this.monitoredItemGroups = this.monitoredItemGroups.filter((obj) => obj !== monitoredItemGroup);\n    }\n    /**\n     * @private\n     * @param itemToMonitor\n     * @param monitoringParameters\n     * @param timestampsToReturn\n     */\n    public _createMonitoredItem(\n        itemToMonitor: ReadValueIdOptions,\n        monitoringParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn,\n        monitoringMode: MonitoringMode = MonitoringMode.Reporting\n    ): ClientMonitoredItem {\n        /* istanbul ignore next*/\n        const monitoredItem = new ClientMonitoredItemImpl(\n            this,\n            itemToMonitor,\n            monitoringParameters,\n            timestampsToReturn,\n            monitoringMode\n        );\n        return monitoredItem;\n    }\n}\n\nexport function ClientMonitoredItem_create(\n    subscription: ClientSubscription,\n    itemToMonitor: ReadValueIdOptions,\n    monitoringParameters: MonitoringParametersOptions,\n    timestampsToReturn: TimestampsToReturn,\n    monitoringMode: MonitoringMode = MonitoringMode.Reporting,\n    callback?: (err3?: Error | null, monitoredItem?: ClientMonitoredItem) => void\n): ClientMonitoredItem {\n    const monitoredItem = new ClientMonitoredItemImpl(\n        subscription,\n        itemToMonitor,\n        monitoringParameters,\n        timestampsToReturn,\n        monitoringMode\n    );\n\n    setImmediate(() => {\n        (subscription as ClientSubscriptionImpl)._wait_for_subscription_to_be_ready((err?: Error) => {\n            if (err) {\n                if (callback) {\n                    callback(err);\n                }\n                return;\n            }\n            ClientMonitoredItemToolbox._toolbox_monitor(subscription, timestampsToReturn, [monitoredItem], (err1?: Error) => {\n                if (err1) {\n                    monitoredItem._terminate_and_emit(err1);\n                }\n                if (callback) {\n                    callback(err1, monitoredItem);\n                }\n            });\n        });\n    });\n    return monitoredItem;\n}\n// tslint:disable:no-var-requires\n// tslint:disable:max-line-length\nconst thenify = require(\"thenify\");\nconst opts = { multiArgs: false };\n\nClientSubscriptionImpl.prototype.setPublishingMode = thenify.withCallback(ClientSubscriptionImpl.prototype.setPublishingMode);\nClientSubscriptionImpl.prototype.monitor = thenify.withCallback(ClientSubscriptionImpl.prototype.monitor);\nClientSubscriptionImpl.prototype.monitorItems = thenify.withCallback(ClientSubscriptionImpl.prototype.monitorItems);\nClientSubscriptionImpl.prototype.setTriggering = thenify.withCallback(ClientSubscriptionImpl.prototype.setTriggering);\nClientSubscriptionImpl.prototype.modify = thenify.withCallback(ClientSubscriptionImpl.prototype.modify);\nClientSubscriptionImpl.prototype.recreateSubscriptionAndMonitoredItem = thenify.withCallback(\n    ClientSubscriptionImpl.prototype.recreateSubscriptionAndMonitoredItem\n);\nClientSubscriptionImpl.prototype.terminate = thenify.withCallback(ClientSubscriptionImpl.prototype.terminate);\nClientSubscriptionImpl.prototype.getMonitoredItems = thenify.withCallback(ClientSubscriptionImpl.prototype.getMonitoredItems);\n\nClientSubscription.create = (clientSession: ClientSession, options: ClientSubscriptionOptions) => {\n    return new ClientSubscriptionImpl(clientSession, options);\n};\n", "// tslint:disable: no-console\nimport * as fs from \"fs\";\nimport * as os from \"os\";\nimport { promisify } from \"util\";\nimport * as should from \"should\";\nimport * as async from \"async\";\n\nimport { assert } from \"node-opcua-assert\";\n\nimport {\n    OPCUAServer,\n    OPCUAClient,\n    ApplicationType,\n    findServers,\n    findServersOnNetwork,\n    RegisterServerResponse,\n    RegisterServerRequest,\n    StatusCodes,\n    RegisterServerMethod,\n    makeApplicationUrn,\n    OPCUADiscoveryServer\n} from \"node-opcua\";\nimport { readCertificate, exploreCertificate } from \"node-opcua-crypto\";\nimport { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\n\nimport { createServerCertificateManager } from \"../../test_helpers/createServerCertificateManager\";\nimport { createServerThatRegistersItselfToTheDiscoveryServer, ep, pause, startDiscovery } from \"./_helper\";\n\nconst debugLog = make_debugLog(\"TEST\");\nconst doDebug = checkDebugFlag(\"TEST\");\n\nconst port0 = 2500;\nconst port1 = 2501;\nconst port2 = 2502;\nconst port3 = 2503;\nconst port4 = 2504;\nconst port5 = 2505;\nconst port_discovery = 2516;\n// add the tcp/ip endpoint with no security\n\nprocess.on(\"uncaughtException\", (err) => {\n    console.log(err);\n});\n\n// tslint:disable-next-line: no-var-requires\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\nexport function t(test: any) {\n    describe(\"DISCO1 - DiscoveryServer1\", function (this: any) {\n        this.timeout(30 * 1000);\n\n        let discovery_server: OPCUADiscoveryServer | undefined;\n        let discoveryServerEndpointUrl: string;\n        let server: OPCUAServer | undefined;\n\n        before(async () => {\n            server = new OPCUAServer({\n                port: port0,\n                serverCertificateManager: this.serverCertificateManager\n            });\n\n            await server.initialize();\n            await server.initializeCM();\n        });\n\n        after(async () => {\n            await server!.shutdown();\n            server = undefined;\n        });\n\n        beforeEach(async () => {\n            discovery_server = new OPCUADiscoveryServer({\n                port: port_discovery,\n                serverCertificateManager: this.discoveryServerCertificateManager\n            });\n            await discovery_server.start();\n            discoveryServerEndpointUrl = discovery_server.getEndpointUrl();\n            debugLog(\" discovery_server_endpointUrl = \", discoveryServerEndpointUrl);\n        });\n\n        afterEach(async () => {\n            await discovery_server!.shutdown();\n            discovery_server = undefined;\n        });\n\n        async function send_registered_server_request(\n            discoveryServerEndpointUrl: string,\n            registerServerRequest: any,\n            externalFunc: any\n        ): Promise<void> {\n            const client = OPCUAClient.create({\n                endpointMustExist: false\n            });\n            client.on(\"backoff\", () => {\n                console.log(\"cannot connect to \" + discoveryServerEndpointUrl);\n            });\n\n            await client.connect(discoveryServerEndpointUrl);\n\n            await new Promise<void>((resolve) => {\n                (client as any).performMessageTransaction(\n                    registerServerRequest,\n                    (err: Error | null, response: RegisterServerResponse) => {\n                        if (!err) {\n                            // RegisterServerResponse\n                            assert(response instanceof RegisterServerResponse);\n                        }\n                        externalFunc(err, response);\n                        resolve();\n                    }\n                );\n            });\n            await client.disconnect();\n        }\n\n        it(\"DISCO1-1 should fail to register server if discovery url is not specified (Bad_DiscoveryUrlMissing)\", async () => {\n            const request = new RegisterServerRequest({\n                server: {\n                    // The globally unique identifier for the Server instance. The serverUri matches\n                    // the applicationUri from the ApplicationDescription defined in 7.1.\n                    serverUri: \"uri:MyServerURI\",\n\n                    // The globally unique identifier for the Server product.\n                    productUri: \"productUri\",\n\n                    serverNames: [{ text: \"some name\" }],\n\n                    serverType: ApplicationType.Server,\n                    gatewayServerUri: null,\n                    discoveryUrls: [], // INTENTIONALLY EMPTY\n                    semaphoreFilePath: null,\n                    isOnline: false\n                }\n            });\n\n            function check_response(err: Error | null, response: any): void {\n                should.not.exist(err);\n                //xx console.log(response.toString());\n                response.responseHeader.serviceResult.should.eql(StatusCodes.BadDiscoveryUrlMissing);\n            }\n\n            await send_registered_server_request(discoveryServerEndpointUrl, request, check_response);\n        });\n\n        it(\"DISCO1-2 should fail to register server to the discover server if server type is Client (BadInvalidArgument)\", async () => {\n            const request = new RegisterServerRequest({\n                server: {\n                    // The globally unique identifier for the Server instance. The serverUri matches\n                    // the applicationUri from the ApplicationDescription defined in 7.1.\n                    serverUri: \"uri:MyServerURI\",\n\n                    // The globally unique identifier for the Server product.\n                    productUri: \"productUri\",\n\n                    serverNames: [{ text: \"some name\" }],\n\n                    serverType: ApplicationType.Client, /// CLIENT HERE !!!\n                    gatewayServerUri: null,\n                    discoveryUrls: [],\n                    semaphoreFilePath: null,\n                    isOnline: false\n                }\n            });\n\n            function check_response(err: Error | null, response: any) {\n                should.not.exist(err);\n                //xx debugLog(response.toString());\n                response.responseHeader.serviceResult.should.eql(StatusCodes.BadInvalidArgument);\n            }\n\n            await send_registered_server_request(discoveryServerEndpointUrl, request, check_response);\n        });\n\n        it(\"DISCO1-3 should fail to register server to the discover server if server name array is empty (BadServerNameMissing)\", async () => {\n            const request = new RegisterServerRequest({\n                server: {\n                    // The globally unique identifier for the Server instance. The serverUri matches\n                    // the applicationUri from the ApplicationDescription defined in 7.1.\n                    serverUri: \"uri:MyServerURI\",\n\n                    // The globally unique identifier for the Server product.\n                    productUri: \"productUri\",\n\n                    serverNames: [], /// <<<<< INTENTIONALLY EMPTY\n\n                    serverType: ApplicationType.Server,\n                    gatewayServerUri: null,\n                    discoveryUrls: [],\n                    semaphoreFilePath: null,\n                    isOnline: false\n                }\n            });\n\n            function check_response(err: Error | null, response: any) {\n                should.not.exist(err);\n                response.responseHeader.serviceResult.should.eql(StatusCodes.BadServerNameMissing);\n            }\n\n            await send_registered_server_request(discoveryServerEndpointUrl, request, check_response);\n        });\n    });\n\n    describe(\"DISCO2 - DiscoveryServer2\", function (this: any) {\n        this.timeout(Math.max(40 * 1000, this.timeout()));\n\n        let discoveryServer: OPCUADiscoveryServer;\n        let discoveryServerEndpointUrl: string;\n        let server: OPCUAServer;\n\n        before(() => {\n            OPCUAServer.registry.count().should.eql(0);1162\n        });\n\n        after(() => {\n            OPCUAServer.registry.count().should.eql(0);\n        });\n        beforeEach(async () => {\n            discoveryServer = new OPCUADiscoveryServer({\n                port: port_discovery,\n                serverCertificateManager: this.discoveryServerCertificateManager\n            });\n            await discoveryServer.start();\n            discoveryServerEndpointUrl = discoveryServer.getEndpointUrl()!;\n            if (doDebug) {\n                console.log(discoveryServerEndpointUrl);\n            }\n        });\n\n        afterEach(async () => {\n            await discoveryServer.shutdown();\n        });\n\n        async function addServerCertificateToTrustedCertificateInDiscoveryServer(server: OPCUAServer) {\n            const filename = server.certificateFile;\n            fs.existsSync(filename).should.eql(true, \" the server certficate file \" + filename + \" should exist\");\n            const certificate = readCertificate(filename);\n            await discoveryServer.serverCertificateManager.trustCertificate(certificate);\n        }\n\n        it(\"DISCO2-1 should register server to the discover server 2\", async () => {\n            const applicationUri = makeApplicationUrn(os.hostname(), \"NodeOPCUA-Server\");\n\n            // there should be no endpoint exposed by an blank discovery server\n            discoveryServer.registeredServerCount.should.equal(0);\n            let initialServerCount = 0;\n\n            // ----------------------------------------------------------------------------\n            const data = await findServers(discoveryServerEndpointUrl);\n            debugLog(\"data = \", data);\n            const { servers, endpoints } = data;\n            initialServerCount = servers.length;\n            servers[0].discoveryUrls!.length.should.eql(1);\n\n            debugLog(\" initialServerCount = \", initialServerCount);\n            debugLog(\"servers[0].discoveryUrls\", servers[0].discoveryUrls!.join(\"\\n\"));\n\n            const serverCertificateManager = await createServerCertificateManager(port1);\n            // ----------------------------------------------------------------------------\n            server = new OPCUAServer({\n                port: port1,\n                registerServerMethod: RegisterServerMethod.LDS,\n                discoveryServerEndpointUrl,\n                serverCertificateManager,\n                serverInfo: {\n                    applicationName: { text: \"NodeOPCUA\", locale: \"en\" },\n                    applicationUri,\n                    productUri: \"NodeOPCUA-Server\",\n                    discoveryProfileUri: null,\n                    discoveryUrls: [],\n                    gatewayServerUri: null\n                }\n            });\n\n            await server.initialize();\n            await server.initializeCM();\n\n            await addServerCertificateToTrustedCertificateInDiscoveryServer(server);\n\n            await server.start();\n\n            // server registration takes place in parallel and should be checked independently\n            await new Promise<void>((resolve) => {\n                server.once(\"serverRegistered\", () => {\n                    resolve();\n                });\n            });\n\n            // ----------------------------------------------------------------------------\n            discoveryServer.registeredServerCount.should.equal(1);\n\n            {\n                const data = await findServers(discoveryServerEndpointUrl);\n                const { servers, endpoints } = data;\n                //xx debugLog(servers[0].toString());\n                servers.length.should.eql(initialServerCount + 1);\n                servers[1].applicationUri!.should.eql(applicationUri);\n            }\n\n            // ----------------------------------------------------------------------------\n            await server.shutdown();\n\n            // ----------------------------------------------------------------------------\n            {\n                const { servers, endpoints } = await findServers(discoveryServerEndpointUrl);\n                servers.length.should.eql(initialServerCount);\n            }\n        });\n    });\n\n    describe(\"DISCO3 - DiscoveryServer3 - many server\", function (this: any) {\n        this.timeout(200000);\n\n        let discoveryServer: OPCUADiscoveryServer;\n        let discoveryServerEndpointUrl: string;\n\n        let server1: OPCUAServer;\n        let server2: OPCUAServer;\n        let server3: OPCUAServer;\n        let server4: OPCUAServer;\n        let server5: OPCUAServer;\n\n        discoveryServerEndpointUrl = `opc.tcp://localhost:${port_discovery}`; // discovery_server.endpoint[0].endpointUrl;\n\n        before(async () => {\n            OPCUAServer.registry.count().should.eql(0);\n            server1 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port1, \"AA\");\n            server2 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port2, \"BB\");\n            server3 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port3, \"CC\");\n            server4 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port4, \"DD\");\n            server5 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port5, \"EE\");\n        });\n\n        after(() => {\n            OPCUAServer.registry.count().should.eql(0);\n        });\n\n        before(async () => {\n            discoveryServer = await startDiscovery(port_discovery);\n            discoveryServerEndpointUrl = ep(discoveryServer);\n        });\n\n        after(async () => {\n            await discoveryServer.shutdown();\n        });\n\n        let registeredServerCount = 0;\n\n        async function checkServerCertificateAgainsLDS(server: OPCUAServer) {\n            const certificate = await server.getCertificate();\n            const certificateInfo = await exploreCertificate(certificate);\n            if (doDebug) {\n                console.log(certificateInfo);\n            }\n            const statusBefore = await discoveryServer.serverCertificateManager.verifyCertificate(certificate);\n            if (doDebug) {\n                console.log(\"statusBefore = \", statusBefore);\n            }\n\n            await discoveryServer.serverCertificateManager.trustCertificate(certificate);\n\n            const statusAfter = await discoveryServer.serverCertificateManager.verifyCertificate(certificate);\n            if (doDebug) {\n                console.log(\"statusAfter = \", statusAfter);\n            }\n            statusAfter.should.eql(\"Good\");\n        }\n\n        function start_all_servers(done: () => void) {\n            registeredServerCount = 0;\n\n            async.parallel(\n                [\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server1\");\n                        server1.start(callback);\n                        server1.once(\"serverRegistered\", () => {\n                            debugLog(\"server1 registered\");\n                            registeredServerCount += 1;\n                        });\n                    },\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server2\");\n                        server2.start(callback);\n                        server2.once(\"serverRegistered\", () => {\n                            debugLog(\"server2 registered\");\n                            registeredServerCount += 1;\n                        });\n                    },\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server3\");\n                        server3.start(callback);\n                        server3.once(\"serverRegistered\", () => {\n                            debugLog(\"server3 registered\");\n                            registeredServerCount += 1;\n                        });\n                    },\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server4\");\n                        server4.start(callback);\n                        server4.once(\"serverRegistered\", () => {\n                            debugLog(\"server4 registered\");\n                            registeredServerCount += 1;\n                        });\n                    },\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server5\");\n                        server5.start(callback);\n                        server5.once(\"serverRegistered\", () => {\n                            debugLog(\"server5 registered\");\n                            registeredServerCount += 1;\n                        });\n                    }\n                ],\n                done\n            );\n        }\n\n        function stop_all_servers(done: () => void) {\n            async.parallel(\n                [\n                    function (callback: () => void) {\n                        server1.shutdown(callback);\n                    },\n                    function (callback: () => void) {\n                        server2.shutdown(callback);\n                    },\n                    function (callback: () => void) {\n                        server3.shutdown(callback);\n                    },\n                    function (callback: () => void) {\n                        server4.shutdown(callback);\n                    },\n                    function (callback: () => void) {\n                        server5.shutdown(callback);\n                    }\n                ],\n                done\n            );\n        }\n        const start_all_serversAsync = promisify(start_all_servers);\n        const stop_all_serversAsync = promisify(stop_all_servers);\n\n        it(\"DISCO3-1 checking certificates\", async () => {\n            await checkServerCertificateAgainsLDS(server1);\n            await checkServerCertificateAgainsLDS(server2);\n            await checkServerCertificateAgainsLDS(server3);\n            await checkServerCertificateAgainsLDS(server4);\n            console.log(\"done\");\n        });\n\n        function wait_until_all_servers_registered_iter(expectedCount: number, resolve: () => void) {\n            console.log(\"waiting for all servers to be registered \", registeredServerCount, \"expected\", expectedCount);\n            if (registeredServerCount === expectedCount) {\n                return resolve();\n            }\n            setTimeout(wait_until_all_servers_registered_iter, 500, expectedCount, resolve);\n        }\n\n        async function wait_until_all_servers_registered(expectedCount: number): Promise<void> {\n            return new Promise<void>((resolve) => {\n                wait_until_all_servers_registered_iter(expectedCount, resolve);\n            });\n        }\n\n        it(\"DISCO3-2 a discovery server shall be able to expose many registered servers\", async () => {\n            await start_all_serversAsync();\n\n            await wait_until_all_servers_registered(5);\n\n            discoveryServer.registeredServerCount.should.equal(5);\n\n            await pause(1000);\n\n            const { servers, endpoints } = await findServers(discoveryServerEndpointUrl);\n            if (doDebug) {\n                for (const s of servers) {\n                    debugLog(s.applicationUri, s.productUri, ApplicationType[s.applicationType], s.discoveryUrls![0]);\n                }\n            }\n            servers.length.should.eql(6); // 5 server + 1 discovery server\n\n            // servers[1].applicationUri.should.eql(\"urn:NodeOPCUA-Server\");\n            await pause(1000);\n            {\n                const servers = await findServersOnNetwork(discoveryServerEndpointUrl);\n                if (servers!.length !== 6) {\n                    for (const s of servers!) {\n                        console.log(s.toString());\n                    }\n                }\n                servers!.length.should.eql(\n                    6,\n                    \"found \" +\n                        servers!.length +\n                        \" server running instead of 6: may be you have a LDS running on your system. please make sure to shut it down before running the tests\"\n                ); // 5 server + 1 discovery server\n                // servers[1].applicationUri.should.eql(\"urn:NodeOPCUA-Server\");\n            }\n\n            await stop_all_serversAsync();\n        });\n    });\n}\n", "\nconst should = require(\"should\");\nconst { assert } = require(\"node-opcua-assert\");\nconst async = require(\"async\");\nconst util = require(\"util\");\n\nconst {\n    resolveNodeId,\n    OPCUAClient,\n    StatusCodes,\n    BrowseDirection,\n    BrowseRequest, \n    BrowseNextRequest, \n    BrowseDescription\n} = require(\"node-opcua\");\n\nconst { make_debugLog, checkDebugFlag } = require(\"node-opcua-debug\");\nconst debugLog = make_debugLog(\"TEST\");\nconst doDebug = checkDebugFlag(\"TEST\");\n\n\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\nmodule.exports = function(test) {\n\n    describe(\"Test Browse Request\", function() {\n\n        let client, endpointUrl;\n\n        let g_session = null;\n        beforeEach(function(done) {\n\n            endpointUrl = test.endpointUrl;\n\n            client = OPCUAClient.create();\n            client.connect(endpointUrl, function(err) {\n                if (err) {\n                    done(err);\n                }\n                else {\n                    client.createSession(function(err, session) {\n                        g_session = session;\n                        done(err);\n                    });\n                }\n            });\n\n        });\n\n        afterEach(function(done) {\n            g_session.close(function() {\n                client.disconnect(done);\n            });\n        });\n\n        it(\"T1 - #Browse should return BadNothingToDo if nodesToBrowse is empty \", function(done) {\n\n            const browseRequest = new BrowseRequest({\n                nodesToBrowse: []\n            });\n            g_session.performMessageTransaction(browseRequest, function(err, result) {\n                err.message.should.match(/BadNothingToDo/);\n                // todo\n                done();\n            });\n\n        });\n\n        it(\"T2 - #Browse should return BadViewIdInvalid if viewId is invalid\", function(done) {\n\n            const browseDesc = {\n                nodeId: resolveNodeId(\"RootFolder\"),\n                referenceTypeId: null,\n                browseDirection: BrowseDirection.Forward\n            };\n\n            const browseRequest = new BrowseRequest({\n                view: {\n                    viewId: 'ns=1256;i=1' //<< invalid viewId\n                },\n                nodesToBrowse: [browseDesc]\n            });\n            g_session.performMessageTransaction(browseRequest, function(err, result) {\n                err.message.should.match(/BadViewIdUnknown/);\n                done();\n            });\n        });\n\n        it(\"T3 - #Browse should return BadViewUnknown if object referenced by viewId is not a view\", function(done) {\n\n            const browseDesc = {\n                nodeId: resolveNodeId(\"RootFolder\"),\n                referenceTypeId: null,\n                browseDirection: BrowseDirection.Forward\n            };\n\n            const browseRequest = new BrowseRequest({\n                view: {\n                    viewId: 'ns=0;i=85',\n                },\n                nodesToBrowse: [browseDesc]\n            });\n            g_session.performMessageTransaction(browseRequest, function(err, result) {\n                // todo\n                err.message.should.match(/BadViewIdUnknown/);\n                done();\n            });\n        });\n\n        it(\"T4 - #Browse server should respect Browse maxReferencesPerNode \", function(done) {\n\n            const browseDesc = {\n                nodeId: resolveNodeId(\"RootFolder\"),\n                referenceTypeId: null,\n                includeSubtypes: true,\n                browseDirection: BrowseDirection.Both,\n                resultMask: 63\n            };\n\n            async.series([\n\n                function(callback) {\n                    const browseRequest1 = new BrowseRequest({\n                        view: null,//{ viewId: 'ns=0;i=85'},\n                        requestedMaxReferencesPerNode: 10,\n                        nodesToBrowse: [browseDesc]\n                    });\n                    g_session.performMessageTransaction(browseRequest1, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        // console.log(response.toString());\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.greaterThan(3);\n                        should(response.results[0].continuationPoint).eql(null);\n                        callback();\n                    });\n                },\n                function(callback) {\n                    const browseRequest2 = new BrowseRequest({\n                        view: null,//{ viewId: 'ns=0;i=85'},\n                        requestedMaxReferencesPerNode: 1,\n                        nodesToBrowse: [browseDesc]\n                    });\n                    g_session.performMessageTransaction(browseRequest2, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        //xx console.log(response.toString());\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.eql(1);\n                        should.exist(response.results[0].continuationPoint);\n                        callback();\n                    });\n                }\n            ], done);\n\n\n        });\n\n        it(\"T5 - #BrowseNext response should have serviceResult=BadNothingToDo if request have no continuationPoints\", function(done) {\n            async.series([\n\n                function(callback) {\n                    const browseNextRequest = new BrowseNextRequest({\n                        continuationPoints: null\n                    });\n                    g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                        err.message.should.match(/BadNothingToDo/);\n                        // console.log(response.toString());\n                        response.responseHeader.serviceResult.should.equal(StatusCodes.BadNothingToDo);\n                        callback();\n                    });\n                }\n            ], done);\n        });\n        it(\"T6 - #BrowseNext response \", function(done) {\n            const browseDesc = {\n                nodeId: resolveNodeId(\"RootFolder\"),\n                referenceTypeId: null,\n                includeSubtypes: true,\n                browseDirection: BrowseDirection.Both,\n                resultMask: 63\n            };\n\n            let allReferences;\n            let continuationPoint;\n            async.series([\n\n                function(callback) {\n                    const browseRequest1 = new BrowseRequest({\n                        view: null,//{ viewId: 'ns=0;i=85'},\n                        requestedMaxReferencesPerNode: 10,\n                        nodesToBrowse: [browseDesc]\n                    });\n                    g_session.performMessageTransaction(browseRequest1, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        // console.log(response.toString());\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.greaterThan(3); // want 4 at lest\n                        should.not.exist(response.results[0].continuationPoint);\n                        allReferences = response.results[0].references;\n                        callback();\n                    });\n                },\n\n                function(callback) {\n                    const browseRequest2 = new BrowseRequest({\n                        view: null,//{ viewId: 'ns=0;i=85'},\n                        requestedMaxReferencesPerNode: 2,\n                        nodesToBrowse: [browseDesc]\n                    });\n                    g_session.performMessageTransaction(browseRequest2, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        //xx console.log(response.toString());\n\n                        response.results.length.should.eql(1);\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.eql(2);\n                        should.exist(response.results[0].continuationPoint);\n                        response.results[0].references[0].should.eql(allReferences[0]);\n                        response.results[0].references[1].should.eql(allReferences[1]);\n\n                        continuationPoint = response.results[0].continuationPoint;\n\n                        callback();\n                    });\n                },\n\n                function(callback) {\n                    const browseNextRequest = new BrowseNextRequest({\n                        continuationPoints: [continuationPoint],\n                        //xx                    releaseContinuationPoints: true\n                    });\n                    g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        // console.log(response.toString());\n                        response.responseHeader.serviceResult.should.equal(StatusCodes.Good);\n\n                        response.results.length.should.eql(1);\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.eql(2);\n\n                        // this is last request\n                        should.not.exist(response.results[0].continuationPoint);\n\n                        response.results[0].references[0].should.eql(allReferences[2]);\n                        response.results[0].references[1].should.eql(allReferences[3]);\n\n                        callback();\n\n                    });\n\n                },\n\n                // we reach the end of the sequence. continuationPoint shall not be usable anymore\n                function(callback) {\n                    const browseNextRequest = new BrowseNextRequest({\n                        continuationPoints: [continuationPoint],\n                        releaseContinuationPoints: true\n                    });\n                    g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        // console.log(response.toString());\n                        response.responseHeader.serviceResult.should.equal(StatusCodes.Good);\n                        response.results.length.should.eql(1);\n                        response.results[0].statusCode.should.eql(StatusCodes.BadContinuationPointInvalid);\n                        callback();\n                    });\n                }\n\n\n            ], done);\n\n        });\n\n        const IT = test.server ? it : xit;\n        IT(\"T7 - #BrowseNext with releaseContinuousPoint set to false then set to true\", function(done) {\n            /*\n             * inspired by    Test 5.7.2-9 prepared by Dale Pope dale.pope@matrikon.com\n             * Description:\n             *   Given one node to browse\n             *     And the node exists\n             *     And the node has at least three references of the same ReferenceType's subtype\n             *     And RequestedMaxReferencesPerNode is 1\n             *     And ReferenceTypeId is set to a ReferenceType NodeId\n             *     And IncludeSubtypes is true\n             *     And Browse has been called\n             *  When BrowseNext is called\n             *     And ReleaseContinuationPoints is false\n             *  Then the server returns the second reference\n             *     And ContinuationPoint is not empty\n             *     Validation is accomplished by first browsing all references of a type\n             *     on a node, then performing the test and comparing the second\n             *     reference to the reference returned by the BrowseNext call. So this\n             *     test only validates that Browse two references is consistent with\n             *     Browse one reference followed by BrowseNext.\n             */\n\n            function test_5_7_2__9(nodeId, done) {\n\n                //     And RequestedMaxReferencesPerNode is 1\n                //     And ReferenceTypeId is set to a ReferenceType NodeId\n                //     And IncludeSubtypes is true\n                //     And Browse has been called\n\n                //  Given one node to browse\n                nodeId = resolveNodeId(nodeId);\n                //     And the node exists\n                const obj = test.server.engine.addressSpace.findNode(nodeId, BrowseDirection.Forward);\n                should.exist(obj);\n\n                const browseDesc = new BrowseDescription({\n                    nodeId: nodeId,\n                    referenceTypeId: \"i=47\", // HasComponents\n                    includeSubtypes: true,\n                    browseDirection: BrowseDirection.Forward,\n                    resultMask: 63\n                });\n\n\n                let continuationPoint;\n\n                let allReferences;\n\n                async.series([\n\n                    // browse all references\n                    function(callback) {\n                        const browseRequestAll = new BrowseRequest({\n                            view: null,//{ viewId: 'ns=0;i=85'},\n                            requestedMaxReferencesPerNode: 10,\n                            nodesToBrowse: [browseDesc]\n                        });\n                        g_session.performMessageTransaction(browseRequestAll, function(err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            // console.log(response.toString());\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].references.length.should.be.greaterThan(3); // want 4 at lest\n                            should.not.exist(response.results[0].continuationPoint);\n                            allReferences = response.results[0].references;\n                            callback();\n                        });\n                    },\n\n                    function(callback) {\n\n                        const browseRequest1 = new BrowseRequest({\n                            view: null,\n                            requestedMaxReferencesPerNode: 1,\n                            nodesToBrowse: [browseDesc]\n                        });\n\n                        g_session.performMessageTransaction(browseRequest1, function(err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            //xx console.log(response.toString());\n\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].references.length.should.be.eql(1);\n                            should.exist(response.results[0].continuationPoint);\n                            response.results[0].references[0].should.eql(allReferences[0]);\n                            continuationPoint = response.results[0].continuationPoint;\n                            callback();\n                        });\n                    },\n\n                    function(callback) {\n                        const browseNextRequest = new BrowseNextRequest({\n                            releaseContinuationPoints: false,\n                            continuationPoints: [continuationPoint]\n                        });\n                        g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            // console.log(response.toString());\n                            response.responseHeader.serviceResult.should.equal(StatusCodes.Good);\n\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].references.length.should.be.eql(1);\n\n                            // continuation point should not be null\n                            should.exist(response.results[0].continuationPoint);\n                            response.results[0].references[0].should.eql(allReferences[1]);\n                            callback();\n\n                        });\n\n                    },\n                    function(callback) {\n                        const browseNextRequest = new BrowseNextRequest({\n                            releaseContinuationPoints: true,\n                            continuationPoints: [continuationPoint]\n                        });\n                        g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            // console.log(response.toString());\n                            response.responseHeader.serviceResult.should.equal(StatusCodes.Good);\n\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].references.length.should.be.eql(0);\n\n                            should.not.exist(response.results[0].continuationPoint);\n                            callback();\n\n                        });\n\n                    },\n\n                ], done);\n\n            }\n\n            test_5_7_2__9(\"ns=0;i=2253\", done);\n\n        })\n\n    });\n};", "/* eslint-disable max-statements */\n\"use strict\";\n\nconst util = require(\"util\");\nconst chalk = require(\"chalk\");\nconst { assert } = require(\"node-opcua-assert\");\nconst async = require(\"async\");\nconst should = require(\"should\");\nconst sinon = require(\"sinon\");\n\nconst {\n    OPCUAClient,\n    ClientSession,\n    ClientSubscription,\n    AttributeIds,\n    resolveNodeId,\n    makeNodeId,\n    StatusCodes,\n    DataType,\n    TimestampsToReturn,\n    MonitoringMode,\n    VariantArrayType,\n    MonitoredItem,\n    ReadValueId,\n    ClientMonitoredItem,\n    CreateSubscriptionRequest,\n    CreateMonitoredItemsResponse,\n    CreateMonitoredItemsRequest,\n    SetMonitoringModeRequest,\n    ModifyMonitoredItemsRequest,\n    MonitoredItemModifyRequest,\n    DeleteMonitoredItemsRequest,\n    ClientMonitoredItemGroup,\n    PublishResponse,\n    PublishRequest,\n    RepublishRequest,\n    RepublishResponse,\n    VariableIds,\n    Variant,\n    Subscription,\n    SubscriptionState,\n    installSessionLogging\n} = require(\"node-opcua\");\n\n\nconst { make_debugLog, checkDebugFlag } = require(\"node-opcua-debug\");\n\nconst {\n    perform_operation_on_client_session,\n    perform_operation_on_subscription,\n    perform_operation_on_subscription_with_parameters,\n    perform_operation_on_monitoredItem,\n    perform_operation_on_subscription_async\n} = require(\"../../test_helpers/perform_operation_on_client_session\");\n\nconst debugLog = make_debugLog(\"TEST\");\nconst doDebug = checkDebugFlag(\"TEST\");\n\nconst f = require(\"../../test_helpers/display_function_name\").f.bind(null, doDebug);\n\nfunction trace_console_log() {\n    const log1 = global.console.log;\n    global.console.log = function () {\n        const t = new Error(\"\").stack.split(\"\\n\")[2];\n        if (t.match(/opcua/)) {\n            log1.call(console, chalk.cyan(t));\n        }\n        log1.apply(console, arguments);\n    };\n}\nconst tracelog = (...args) => {\n    const d = new Date();\n    const t = d.toTimeString().split(\" \")[0] + \".\" + d.getMilliseconds().toString().padStart(3, \"0\");\n    console.log.apply(console, [t, ...args]);\n};\n// eslint-disable-next-line import/order\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\nmodule.exports = function (test) {\n    describe(\"AZA1- testing Client-Server subscription use case, on a fake server exposing the temperature device\", function () {\n        let server, client, endpointUrl;\n\n        beforeEach(function (done) {\n            client = OPCUAClient.create({});\n            server = test.server;\n            endpointUrl = test.endpointUrl;\n            done();\n        });\n\n        afterEach(function (done) {\n            client = null;\n            done();\n        });\n\n        it(\"AZA1-A should create a ClientSubscription to manage a subscription\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 5,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        setTimeout(function () {\n                            subscription.terminate(function () {\n                                setTimeout(function () {\n                                    inner_done();\n                                }, 200);\n                            });\n                        }, 200);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA1-B should dump statistics \", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100, // ms\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 5,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        setTimeout(function () {\n                            subscription.terminate(done);\n                        }, 200);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA1-C a ClientSubscription should receive keep-alive events from the server\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    let nb_keep_alive_received = 0;\n\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 10,\n                        maxNotificationsPerPublish: 2,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    const timeout = subscription.publishingInterval * subscription.maxKeepAliveCount;\n\n                    subscription.on(\"started\", function () {\n                        setTimeout(function () {\n                            subscription.terminate(function () {\n                                nb_keep_alive_received.should.be.greaterThan(0);\n                                done();\n                            });\n                        }, timeout * 1.2);\n                    });\n                    subscription.on(\"keepalive\", function () {\n                        nb_keep_alive_received += 1;\n                    });\n                    subscription.on(\"terminated\", function () {\n                        //xx console.log(\" subscription has received \", nb_keep_alive_received, \" keep-alive event(s)\");\n                    });\n                },\n                done\n            );\n        });\n\n        xit(\"AZA1-D a ClientSubscription should survive longer than the life time\", function (done) {\n            // todo\n            done();\n        });\n\n        it(\"AZA1-E should be possible to monitor an nodeId value with a ClientSubscription\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 150,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 2,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    subscription.on(\"started\", () => {\n                        debugLog(\"subscription started\");\n                    });\n\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 50,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(() => {\n                            subscription.terminate(done);\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA1-F should be possible to monitor several nodeId value with a single client subscription\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, callback) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 50,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 2,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    let currentTime_changes = 0;\n                    const monitoredItemCurrentTime = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 20,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItemCurrentTime.on(\"changed\", function (dataValue) {\n                        should.exist(dataValue);\n                        //xx tracelog(\"xxxx current time\", dataValue.value.value);\n                        currentTime_changes++;\n                    });\n\n                    const pumpSpeedId = \"ns=1;b=0102030405060708090a0b0c0d0e0f10\";\n                    const monitoredItemPumpSpeed = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(pumpSpeedId),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 20,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    let pumpSpeed_changes = 0;\n                    monitoredItemPumpSpeed.on(\"changed\", function (dataValue) {\n                        should.exist(dataValue);\n                        // tracelog(\" pump speed \", dataValue.value.value);\n                        pumpSpeed_changes++;\n                    });\n\n                    setTimeout(() => {\n                        pumpSpeed_changes.should.be.greaterThan(1);\n                        currentTime_changes.should.be.greaterThan(1);\n                        subscription.terminate(() => {\n                            callback();\n                        });\n                    }, 2000);\n                },\n                done\n            );\n        });\n\n        it(\"AZA1-G should terminate any pending subscription when the client is disconnected\", function (done) {\n            let the_session;\n\n            async.series(\n                [\n                    // connect\n                    function (callback) {\n                        client.connect(endpointUrl, callback);\n                    },\n\n                    // create session\n                    function (callback) {\n                        client.createSession(function (err, session) {\n                            if (!err) {\n                                the_session = session;\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    // create subscription\n                    function (callback) {\n                        const subscription = ClientSubscription.create(the_session, {\n                            requestedPublishingInterval: 100,\n                            requestedLifetimeCount: 6000,\n                            requestedMaxKeepAliveCount: 100,\n                            maxNotificationsPerPublish: 5,\n                            publishingEnabled: true,\n                            priority: 6\n                        });\n                        subscription.on(\"started\", () => {\n                            const monitoredItem = ClientMonitoredItem.create(\n                                subscription,\n                                {\n                                    nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                                    attributeId: 13\n                                },\n                                {\n                                    samplingInterval: 100,\n                                    discardOldest: true,\n                                    queueSize: 1\n                                }\n                            );\n                            monitoredItem.on(\"initialized\", callback);\n                        });\n                    },\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(() => {\n                            // client.disconnect(done);\n                            callback();\n                        }, 100);\n                    },\n\n                    // now disconnect the client , without closing the subscription first\n                    function (callback) {\n                        client.disconnect(callback);\n                    }\n                ],\n                function (err) {\n                    done(err);\n                }\n            );\n        });\n\n        it(\"AZA1-H should terminate any pending subscription when the client is disconnected twice\", function (done) {\n            let the_session;\n\n            async.series(\n                [\n                    // connect\n                    function (callback) {\n                        client.connect(endpointUrl, callback);\n                    },\n\n                    // create session\n                    function (callback) {\n                        client.createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            the_session = session;\n                            callback();\n                        });\n                    },\n\n                    // create subscription\n                    function (callback) {\n                        const subscription = ClientSubscription.create(the_session, {\n                            requestedPublishingInterval: 100,\n                            requestedLifetimeCount: 6000,\n                            requestedMaxKeepAliveCount: 100,\n                            maxNotificationsPerPublish: 5,\n                            publishingEnabled: true,\n                            priority: 6\n                        });\n                        subscription.on(\"started\", () => {\n                            // monitor some\n                            const monitoredItem = ClientMonitoredItem.create(\n                                subscription,\n                                {\n                                    nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                                    attributeId: 13\n                                },\n                                {\n                                    samplingInterval: 100,\n                                    discardOldest: true,\n                                    queueSize: 1\n                                }\n                            );\n\n                            // note that at this point the monitoredItem has bee declared in the client\n                            // but not created yet on the server side ....\n                            monitoredItem.once(\"initialized\", () => {\n                                callback();\n                            });\n                        });\n                    },\n\n                    // wait a little bit and disconnect client\n                    function (callback) {\n                        setTimeout(() => {\n                            client.disconnect(callback);\n                        }, 600);\n                    },\n\n                    // connect the same client again !!!!\n                    function (callback) {\n                        client.connect(endpointUrl, callback);\n                    },\n\n                    // create session again\n                    function (callback) {\n                        client.createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n\n                            the_session = session;\n                            callback();\n                        });\n                    },\n\n                    // create subscription again\n                    function (callback) {\n                        should.exist(the_session);\n                        const subscription = ClientSubscription.create(the_session, {\n                            requestedPublishingInterval: 100,\n                            requestedLifetimeCount: 6000,\n                            requestedMaxKeepAliveCount: 100,\n                            maxNotificationsPerPublish: 5,\n                            publishingEnabled: true,\n                            priority: 6\n                        });\n                        subscription.on(\"started\", () => {\n                            // monitor some again\n                            const monitoredItem = ClientMonitoredItem.create(\n                                subscription,\n                                {\n                                    nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                                    attributeId: 13\n                                },\n                                {\n                                    samplingInterval: 100,\n                                    discardOldest: true,\n                                    queueSize: 1\n                                }\n                            );\n\n                            monitoredItem.once(\"initialized\", callback);\n                        });\n                    },\n\n                    // now disconnect the client, without terminating the subscription &\n                    // without closing the session first\n                    function (callback) {\n                        setTimeout(() => {\n                            client.disconnect(callback);\n                        }, 400);\n                    }\n                ],\n                function (err) {\n                    done(err);\n                }\n            );\n        });\n    });\n\n    describe(\"AZA2- testing server and subscription\", function () {\n        let server, client, endpointUrl;\n\n        beforeEach(function (done) {\n            server = test.server;\n            //xx server.restart(function() {\n\n            client = OPCUAClient.create();\n            endpointUrl = test.endpointUrl;\n            done();\n            //xx });\n        });\n\n        afterEach(function (done) {\n            client.disconnect(function (err) {\n                client = null;\n                done(err);\n            });\n        });\n\n        //function on_freshly_started_server(inner_func, done) {\n        //\n        //    async.series([\n        //        function (callback) {\n        //            tracelog(\" Restarting server;\")\n        //            server.restart(callback);\n        //        },\n        //        function (callback) {\n        //            try {\n        //                tracelog(chalk.bgWhite.black(\" ------------------------------------------------ INNER FUNC\"));\n        //                inner_func(callback);\n        //            }\n        //            catch (err) {\n        //                callback(err);\n        //            }\n        //        }\n        //    ], done);\n        //\n        //}\n\n        it(\"AZA2-A0 should return BadTooManySubscriptions if too many subscriptions are opened (maxSubscriptionsPerSession)\", function (done) {\n            const subscriptionIds = [];\n\n            function create_an_other_subscription(session, expected_error, callback) {\n                session.createSubscription(\n                    {\n                        requestedPublishingInterval: 100, // Duration\n                        requestedLifetimeCount: 10, // Counter\n                        requestedMaxKeepAliveCount: 10, // Counter\n                        maxNotificationsPerPublish: 10, // Counter\n                        publishingEnabled: true, // Boolean\n                        priority: 14 // Byte\n                    },\n                    function (err, response) {\n                        if (!expected_error) {\n                            should.not.exist(err);\n                            subscriptionIds.push(response.subscriptionId);\n                        } else {\n                            err.message.should.match(new RegExp(expected_error));\n                        }\n                        callback();\n                    }\n                );\n            }\n\n            const maxSessionBackup = server.engine.serverCapabilities.maxSessions;\n            server.engine.serverCapabilities.maxSessions = 100;\n            const maxSubsriptionsPerSessionBackup = server.engine.serverCapabilities.maxSubscriptionsPerSession;\n            server.engine.serverCapabilities.maxSubscriptionsPerSession = 5;\n            const maxSubsriptionsBackup = server.engine.serverCapabilities.maxSubscriptions;\n            server.engine.serverCapabilities.maxSubscriptions = 100;\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                const nbSessions = server.engine.currentSessionCount;\n                                server.engine.currentSessionCount.should.equal(nbSessions);\n                                callback();\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, \"BadTooManySubscriptions\", callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, \"BadTooManySubscriptions\", callback);\n                            },\n\n                            function (callback) {\n                                session.deleteSubscriptions(\n                                    {\n                                        subscriptionIds: subscriptionIds\n                                    },\n                                    function (err, response) {\n                                        should.exist(response);\n                                        callback(err);\n                                    }\n                                );\n                            }\n                        ],\n                        function (err) {\n                            server.engine.serverCapabilities.maxSubscriptionsPerSession = maxSubsriptionsPerSessionBackup;\n                            server.engine.serverCapabilities.maxSubscriptions = maxSubsriptionsBackup;\n                            server.engine.serverCapabilities.maxSessions = maxSessionBackup;\n\n                            done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-A1 should return BadTooManySubscriptions if too many subscriptions are opened (maxSubscriptions)\", async () => {\n            const subscriptionIds = [];\n            const clients = [];\n            const sessions = [];\n            const statusCodes = [];\n            async function create_client_and_2_subscriptions(expected_error) {\n                const client = OPCUAClient.create();\n\n                await client.connect(endpointUrl);\n                const session = await client.createSession();\n                clients.push(client);\n                sessions.push(session);\n\n                async function tryToCreateSubscription() {\n                    let _err;\n                    try {\n                        const subscription = await session.createSubscription2({\n                            requestedPublishingInterval: 100, // Duration\n                            requestedLifetimeCount: 10, // Counter\n                            requestedMaxKeepAliveCount: 10, // Counter\n                            maxNotificationsPerPublish: 10, // Counter\n                            publishingEnabled: true, // Boolean\n                            priority: 14 // Byte\n                        });\n\n                        subscriptionIds.push(subscription.subscriptionId);\n                        statusCodes.push(\"Good\");\n                    } catch (err) {\n                        tracelog(\"Create subscription has failed\");\n                        _err = err;\n                        statusCodes.push(\"Bad\");\n                    }\n                    return _err;\n                }\n                const _err = await tryToCreateSubscription();\n                if (expected_error) {\n                    if (!_err) {\n                        tracelog(\"maxSubscriptionsPerSession=\", server.engine.serverCapabilities.maxSubscriptionsPerSession);\n                        tracelog(\"maxSubscriptions          =\", server.engine.serverCapabilities.maxSubscriptions);\n                        tracelog(\"serverCapabilities        =\", server.engine.serverCapabilities);\n\n                        throw new Error(\"Expected error \" + expected_error + \" but got no error instead\");\n                    } else {\n                        _err.message.should.match(new RegExp(expected_error));\n                    }\n                } else {\n                    if (_err) {\n                        throw new Error(\"Expected no error but got \" + _err.message);\n                    }\n                }\n                await tryToCreateSubscription();\n                // tracelog(\"------------------------- !\");\n            }\n\n            const maxSessionBackup = server.engine.serverCapabilities.maxSessions;\n            server.engine.serverCapabilities.maxSessions = 100;\n            const maxSubsriptionsPerSessionBackup = server.engine.serverCapabilities.maxSubscriptionsPerSession;\n            server.engine.serverCapabilities.maxSubscriptionsPerSession = 10;\n            const maxSubsriptionsBackup = server.engine.serverCapabilities.maxSubscriptions;\n            server.engine.serverCapabilities.maxSubscriptions = 6;\n\n            try {\n                await create_client_and_2_subscriptions(null);\n                await create_client_and_2_subscriptions(null);\n                await create_client_and_2_subscriptions(null);\n                await create_client_and_2_subscriptions(\"BadTooManySubscriptions\");\n                await create_client_and_2_subscriptions(\"BadTooManySubscriptions\");\n            } finally {\n                server.engine.serverCapabilities.maxSubscriptionsPerSession = maxSubsriptionsPerSessionBackup;\n                server.engine.serverCapabilities.maxSubscriptions = maxSubsriptionsBackup;\n                server.engine.serverCapabilities.maxSessions = maxSessionBackup;\n                for (const session of sessions) {\n                    await session.close(true);\n                }\n                for (const client of clients) {\n                    await client.disconnect();\n                }\n            }\n        });\n\n        it(\n            \"AZA2-B a server should accept several Publish Requests from the client without sending notification immediately,\" +\n                \" and should still be able to reply to other requests\",\n            function (done) {\n                let subscriptionId;\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, done) {\n                        async.series(\n                            [\n                                function (callback) {\n                                    session.createSubscription(\n                                        {\n                                            requestedPublishingInterval: 1000, // Duration\n                                            requestedLifetimeCount: 1000, // Counter\n                                            requestedMaxKeepAliveCount: 100, // Counter\n                                            maxNotificationsPerPublish: 10, // Counter\n                                            publishingEnabled: true, // Boolean\n                                            priority: 14 // Byte\n                                        },\n                                        function (err, response) {\n                                            subscriptionId = response.subscriptionId;\n                                            callback(err);\n                                        }\n                                    );\n                                },\n                                function (callback) {\n                                    session.readVariableValue(\"RootFolder\", function (err, dataValue, diagnosticInfos) {\n                                        should.exist(dataValue);\n                                        callback(err);\n                                    });\n                                },\n                                function (callback) {\n                                    function publish_callback(err, response) {\n                                        should.exist(response);\n                                        should(err.message).match(/BadNoSubscription/);\n                                    }\n\n                                    // send many publish requests, in one go\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    callback();\n                                },\n                                function (callback) {\n                                    session.readVariableValue(\"RootFolder\", function (err, dataValue, diagnosticInfos) {\n                                        callback(err);\n                                    });\n                                },\n                                function (callback) {\n                                    session.deleteSubscriptions(\n                                        {\n                                            subscriptionIds: [subscriptionId]\n                                        },\n                                        function (err, response) {\n                                            should.exist(response);\n                                            callback(err);\n                                        }\n                                    );\n                                }\n                            ],\n                            function (err) {\n                                done(err);\n                            }\n                        );\n                    },\n                    done\n                );\n            }\n        );\n\n        it(\"AZA2-C A Subscription can be added and then deleted\", function (done) {\n            let subscriptionId;\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                session.createSubscription(\n                                    {\n                                        requestedPublishingInterval: 100, // Duration\n                                        requestedLifetimeCount: 10, // Counter\n                                        requestedMaxKeepAliveCount: 10, // Counter\n                                        maxNotificationsPerPublish: 10, // Counter\n                                        publishingEnabled: true, // Boolean\n                                        priority: 14 // Byte\n                                    },\n                                    function (err, response) {\n                                        subscriptionId = response.subscriptionId;\n                                        callback(err);\n                                    }\n                                );\n                            },\n\n                            function (callback) {\n                                session.deleteSubscriptions(\n                                    {\n                                        subscriptionIds: [subscriptionId]\n                                    },\n                                    function (err, response) {\n                                        should.exist(response);\n                                        callback(err);\n                                    }\n                                );\n                            }\n                        ],\n                        function (err) {\n                            done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-D #deleteSubscriptions -  should return serviceResult=BadNothingToDo if subscriptionIds is empty\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                session.deleteSubscriptions(\n                                    {\n                                        subscriptionIds: []\n                                    },\n                                    function (err, response) {\n                                        should.exist(response);\n                                        err.message.should.match(/BadNothingToDo/);\n                                        callback();\n                                    }\n                                );\n                            }\n                        ],\n                        function (err) {\n                            done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-E A MonitoredItem can be added to a subscription and then deleted\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(function () {\n                            callback();\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-F should return BadNodeIdUnknown  if the client tries to monitored an non-existent node\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const itemToMonitor = {\n                        nodeId: resolveNodeId(\"ns=0;s=**unknown**\"),\n                        attributeId: AttributeIds.Value\n                    };\n                    const parameters = {\n                        samplingInterval: 10,\n                        discardOldest: true,\n                        queueSize: 1\n                    };\n\n                    const monitoredItem = ClientMonitoredItem.create(subscription, itemToMonitor, parameters);\n\n                    monitoredItem.on(\"err\", function (statusMessage) {\n                        tracelog(\" ERR event received\");\n                        statusMessage.should.eql(StatusCodes.BadNodeIdUnknown.toString());\n                        callback();\n                    });\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(function () {\n                            callback(new Error(\"Should not have been initialized\"));\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-G should return BadAttributeIdInvalid if the client tries to monitored an invalid attribute\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.INVALID\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    monitoredItem.on(\"err\", function (statusMessage) {\n                        //xx tracelog(\" ERR event received\");\n\n                        statusMessage.should.eql(StatusCodes.BadAttributeIdInvalid.toString());\n                        callback();\n                    });\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(function () {\n                            callback(new Error(\"Should not have been initialized\"));\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-H should return BadIndexRangeInvalid if the client tries to monitored with an invalid index range\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value,\n                            indexRange: \"5:3\" // << INTENTIONAL : Invalid Range\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    monitoredItem.on(\"err\", function (statusMessage) {\n                        statusMessage.should.eql(StatusCodes.BadIndexRangeInvalid.toString());\n                        callback();\n                    });\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(function () {\n                            callback(new Error(\"monitoredItem.on('initialized') should not be called\"));\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-I should return BadIndexRangeNoData on first notification if the client tries to monitored with 2D index range when a 1D index range is required\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const notificationMessageSpy = new sinon.spy();\n                    subscription.on(\"raw_notification\", notificationMessageSpy);\n\n                    subscription.publishingInterval.should.eql(100);\n\n                    const nodeId = \"ns=2;s=Static_Array_Boolean\";\n\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            indexRange: \"0:1,0:1\" // << INTENTIONAL : 2D RANGE\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    monitoredItem.on(\"err\", function (statusMessage) {\n                        //xx tracelog(\"Monitored Item error\",statusMessage);\n                        statusMessage.should.eql(StatusCodes.BadIndexRangeInvalid.toString());\n                        callback();\n                    });\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        //xx tracelog(\"Monitored Item Initialized\")\n                    });\n\n                    const monitoredItemOnChangedSpy = new sinon.spy();\n                    monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n\n                    setTimeout(function () {\n                        //xx tracelog(notificationMessageSpy.getCall(0).args[0].toString());\n                        monitoredItemOnChangedSpy.getCall(0).args[0].statusCode.should.eql(StatusCodes.BadIndexRangeNoData);\n                        monitoredItemOnChangedSpy.callCount.should.eql(1, \"Only one reply\");\n                        callback();\n                    }, 500);\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-J should not report notification if a monitored value array changes outside the monitored indexRange - 1\", function (done) {\n            // based on CTT : createMonitoredItems591025 - 015.js\n            // Description:\n            //  - Specify an item of type array. Do this for all configured supported data types.\n            //  - Specify an IndexRange that equates to the last 3 elements of the array.\n            //  - Write values to each data-type within the index range specified and then\n            //    call Publish(). We expect to receive data in the Publish response.\n            //    Write to each data-type outside of the index range (e.g. elements 0 and 1) and then call Publish().\n            //    We do not expect to receive data in the Publish response.\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const notificationMessageSpy = new sinon.spy();\n                    subscription.on(\"raw_notification\", notificationMessageSpy);\n\n                    const monitoredItemOnChangedSpy = new sinon.spy();\n\n                    subscription.publishingInterval.should.eql(100);\n\n                    const nodeId = \"ns=2;s=Static_Array_Int32\";\n\n                    function wait(duration, callback) {\n                        setTimeout(callback, duration); // make sure we get inital data\n                    }\n\n                    function write(value, indexRange, callback) {\n                        assert(typeof callback === \"function\");\n                        assert(Array.isArray(value));\n\n                        const nodeToWrite = {\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            value: /*new DataValue(*/ {\n                                serverTimestamp: null,\n                                sourceTimestamp: null,\n                                value: {\n                                    /* Variant */\n                                    dataType: DataType.Int32,\n                                    arrayType: VariantArrayType.Array,\n                                    value: value\n                                }\n                            },\n                            indexRange: indexRange\n                        };\n\n                        session.write(nodeToWrite, function (err, statusCode) {\n                            if (!err) {\n                                statusCode.should.eql(StatusCodes.Good);\n                            }\n\n                            session.read(\n                                {\n                                    attributeId: AttributeIds.Value,\n                                    nodeId: nodeId\n                                },\n                                function (err, dataValue) {\n                                    should.not.exist(err);\n                                    should.exist(dataValue);\n                                    //xx tracelog(\" written \",dataValue.toString());\n                                    callback(err);\n                                }\n                            );\n                        });\n                    }\n\n                    function create_monitored_item(callback) {\n                        const monitoredItem = ClientMonitoredItem.create(\n                            subscription,\n                            {\n                                nodeId: nodeId,\n                                attributeId: AttributeIds.Value,\n                                indexRange: \"2:9\"\n                            },\n                            {\n                                samplingInterval: 0, // event based\n                                discardOldest: true,\n                                queueSize: 1\n                            },\n                            TimestampsToReturn.Both\n                        );\n\n                        monitoredItem.on(\"err\", function (statusMessage) {\n                            callback(new Error(statusMessage));\n                        });\n\n                        // subscription.on(\"item_added\",function(monitoredItem){\n                        monitoredItem.on(\"initialized\", function () {\n                            callback();\n                        });\n\n                        monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n                    }\n\n                    async.series(\n                        [\n                            write.bind(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], null),\n\n                            create_monitored_item.bind(null),\n\n                            wait.bind(null, 300),\n\n                            function (callback) {\n                                monitoredItemOnChangedSpy.callCount.should.eql(1);\n                                monitoredItemOnChangedSpy.getCall(0).args[0].statusCode.should.eql(StatusCodes.Good);\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(0).args[0].toString());\n                                monitoredItemOnChangedSpy\n                                    .getCall(0)\n                                    .args[0].value.value.should.eql(new Int32Array([2, 3, 4, 5, 6, 7, 8, 9]));\n                                callback();\n                            },\n                            write.bind(null, [100, 101], \"0:1\"),\n                            wait.bind(null, 300),\n\n                            write.bind(null, [200, 201], \"0:1\"),\n                            wait.bind(null, 300),\n                            function (callback) {\n                                // no change ! there is no overlap\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(1).args[0].value.toString());\n                                monitoredItemOnChangedSpy.callCount.should.eql(1);\n                                callback();\n                            },\n                            write.bind(null, [222, 333], \"2:3\"),\n                            wait.bind(null, 300),\n                            function (callback) {\n                                // there is a overlap ! we should receive a monitoredItem On Change event\n                                monitoredItemOnChangedSpy.callCount.should.eql(2);\n                                monitoredItemOnChangedSpy\n                                    .getCall(1)\n                                    .args[0].value.value.should.eql(new Int32Array([222, 333, 4, 5, 6, 7, 8, 9]));\n                                callback();\n                            }\n                        ],\n                        callback\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-K should not report notification if a monitored value array changes outside the monitored indexRange\", function (done) {\n            // based on CTT : createMonitoredItems591024 - 014.js\n            // Description:\n            //  - Specify an item of type array. Do this for all configured data types.\n            //  - Specify an IndexRange of \"2:4\".\n            //  - write values to each data-type within the index range specified\n            //  - call Publish()\n            //  - VERIFY that a notification is sent\n            //  - Write to each data-type outside of the index range (e.g. elements 0, 1 and 5) and then\n            //  - call Publish()\n            //  - VERIFY that no notification is sent.\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const notificationMessageSpy = new sinon.spy();\n                    subscription.on(\"raw_notification\", notificationMessageSpy);\n\n                    const monitoredItemOnChangedSpy = new sinon.spy();\n\n                    subscription.publishingInterval.should.eql(100);\n\n                    const nodeId = \"ns=2;s=Static_Array_Int32\";\n\n                    function create_monitored_item(callback) {\n                        const monitoredItem = ClientMonitoredItem.create(\n                            subscription,\n                            {\n                                nodeId: nodeId,\n                                attributeId: AttributeIds.Value,\n                                indexRange: \"2:4\"\n                            },\n                            {\n                                samplingInterval: 100,\n                                discardOldest: true,\n                                queueSize: 1\n                            },\n                            TimestampsToReturn.Both\n                        );\n\n                        monitoredItem.on(\"err\", function (statusMessage) {\n                            callback(new Error(statusMessage));\n                        });\n\n                        // subscription.on(\"item_added\",function(monitoredItem){\n                        monitoredItem.on(\"initialized\", function () {\n                            //xxtracelog(\"Monitored Item Initialized\")\n                            callback();\n                        });\n\n                        monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n                    }\n\n                    function wait(duration, callback) {\n                        setTimeout(callback, duration); // make sure we get inital data\n                    }\n\n                    function write(value, callback) {\n                        const nodeToWrite = {\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            value: /*new DataValue(*/ {\n                                value: {\n                                    /* Variant */\n                                    dataType: DataType.Int32,\n                                    arrayType: VariantArrayType.Array,\n                                    value: value\n                                }\n                            }\n                        };\n\n                        session.write(nodeToWrite, function (err, statusCode) {\n                            if (!err) {\n                                statusCode.should.eql(StatusCodes.Good);\n                            }\n                            session.read(\n                                {\n                                    attributeId: AttributeIds.Value,\n                                    nodeId: nodeId\n                                },\n                                function (err, dataValue) {\n                                    should.exist(dataValue);\n                                    ///xx tracelog(\" written \",dataValue.value.toString());\n                                    callback(err);\n                                }\n                            );\n                        });\n                    }\n\n                    async.series(\n                        [\n                            write.bind(null, [0, 0, 0, 0, 0, 0]),\n\n                            create_monitored_item.bind(null),\n\n                            wait.bind(null, 300),\n                            write.bind(null, [1, 2, 3, 4, 5]),\n                            wait.bind(null, 300),\n                            write.bind(null, [10, 20, 3, 4, 5, 60]),\n                            wait.bind(null, 300),\n                            write.bind(null, [10, 20, 13, 14, 15, 60]),\n                            wait.bind(null, 300),\n                            function (callback) {\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(0).args[0].toString());\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(1).args[0].toString());\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(2).args[0].toString());\n\n                                monitoredItemOnChangedSpy.getCall(0).args[0].statusCode.should.eql(StatusCodes.Good);\n                                monitoredItemOnChangedSpy.getCall(1).args[0].statusCode.should.eql(StatusCodes.Good);\n                                monitoredItemOnChangedSpy.getCall(2).args[0].statusCode.should.eql(StatusCodes.Good);\n\n                                monitoredItemOnChangedSpy.getCall(0).args[0].value.value.should.eql(new Int32Array([0, 0, 0]));\n                                monitoredItemOnChangedSpy.getCall(1).args[0].value.value.should.eql(new Int32Array([3, 4, 5]));\n                                monitoredItemOnChangedSpy.getCall(2).args[0].value.value.should.eql(new Int32Array([13, 14, 15]));\n\n                                monitoredItemOnChangedSpy.callCount.should.eql(3);\n                                callback();\n                            }\n                        ],\n                        callback\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-K1 should not report notification if a monitored value & status are written but did not change\", function (done) {\n            const subscriptionParameters = {\n                requestedPublishingInterval: 100,\n                requestedLifetimeCount: 6000,\n                requestedMaxKeepAliveCount: 10,\n                maxNotificationsPerPublish: 4,\n                publishingEnabled: true,\n                priority: 6\n            };\n            // based on CTT : createMonitoredItems591060 - 009.js\n            // Description:\n            //  - Create one monitored item.\n            //  - call Publish().\n            //  - Write a status code to the Value  attribute (don\u2019t change the value of the Value attribute).\n            //  - call Publish().\n            //  - Write the existing value and status code to the Value attribute.\n            //  - call Publish().\n            // Expected results:\n            //   - All service and operation level results are Good.\n            //   - The second Publish contains a DataChangeNotification with a value.statusCode matching\n            //     the written value (and value.value matching the value before the write).\n            //   - The third Publish contains no DataChangeNotifications.\n            //     (Did not expect a dataChange since the values written were the same, i.e. unchanged.)\n            perform_operation_on_subscription_with_parameters(\n                client,\n                endpointUrl,\n                subscriptionParameters,\n                function (session, subscription, callback) {\n                    const notificationMessageSpy = new sinon.spy();\n                    subscription.on(\"raw_notification\", notificationMessageSpy);\n                    subscription.on(\"raw_notification\", (notification) => {\n                        // tracelog(notification.toString());\n                    });\n\n                    const monitoredItemOnChangedSpy = new sinon.spy();\n                    const subscription_raw_notificationSpy = new sinon.spy();\n\n                    subscription.publishingInterval.should.eql(100);\n\n                    const nodeId = \"ns=2;s=Static_Scalar_Int32\";\n\n                    function create_monitored_item(callback) {\n                        const monitoredItem = ClientMonitoredItem.create(\n                            subscription,\n                            {\n                                nodeId,\n                                attributeId: AttributeIds.Value\n                            },\n                            {\n                                samplingInterval: 20,\n                                discardOldest: true,\n                                queueSize: 100\n                            },\n                            TimestampsToReturn.Both\n                        );\n\n                        monitoredItem.on(\"err\", function (statusMessage) {\n                            callback(new Error(statusMessage));\n                        });\n\n                        // subscription.on(\"item_added\",function(monitoredItem){\n                        monitoredItem.on(\"initialized\", function () {\n                            //xxtracelog(\"Monitored Item Initialized\")\n                            callback();\n                        });\n\n                        monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n\n                        subscription.on(\"raw_notification\", subscription_raw_notificationSpy);\n                    }\n\n                    function wait(duration, callback) {\n                        setTimeout(callback, duration);\n                    }\n\n                    function write(value, statusCode, callback) {\n                        if (doDebug) {\n                            tracelog(\"monitoredItemOnChanged count    = \", monitoredItemOnChangedSpy.callCount);\n                        }\n                        const nodeToWrite = {\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            value: /*new DataValue(*/ {\n                                statusCode,\n                                value: {\n                                    /* Variant */\n                                    dataType: DataType.Int32,\n                                    value: value\n                                },\n                                sourceTimestamp: null\n                            }\n                        };\n\n                        session.write(nodeToWrite, function (err, statusCode) {\n                            if (!err) {\n                                statusCode.should.eql(StatusCodes.Good);\n                            }\n                            session.read(\n                                {\n                                    attributeId: AttributeIds.Value,\n                                    nodeId: nodeId\n                                },\n                                function (err, dataValue) {\n                                    should.exist(dataValue);\n                                    // xx tracelog(\" written \",dataValue.toString());\n                                    callback(err);\n                                }\n                            );\n                        });\n                    }\n\n                    async.series(\n                        [\n                            write.bind(null, 1, StatusCodes.Good),\n                            wait.bind(null, 300),\n\n                            create_monitored_item.bind(null),\n                            wait.bind(null, 300),\n\n                            //  - Write a status code to the Value  attribute (don\u2019t change the value of the Value attribute).\n                            write.bind(null, 1, StatusCodes.GoodWithOverflowBit),\n                            wait.bind(null, 300),\n\n                            //  - Write the existing value and status code to the Value attribute.\n                            write.bind(null, 1, StatusCodes.GoodWithOverflowBit),\n                            wait.bind(null, 300),\n\n                            function (callback) {\n                                // wait until next notification received;\n                                const lambda = (response) => {\n                                    if (doDebug) {\n                                        tracelog(\n                                            \"response: \",\n                                            response.constructor.name,\n                                            \"notificationData.length\",\n                                            response.notificationMessage.notificationData.length\n                                        );\n                                    }\n                                    if (response.constructor.name === \"PublishResponse\") {\n                                        client.removeListener(\"receive_response\", lambda);\n                                        // tracelog(\" xxxx \", response.toString());\n                                        if (response.notificationMessage.notificationData.length !== 0) {\n                                            return callback(\n                                                new Error(\n                                                    \"Test has failed because PublishResponse has a unexpected notification data\"\n                                                )\n                                            );\n                                        }\n                                        callback();\n                                    }\n                                };\n                                client.on(\"receive_response\", lambda);\n                            },\n                            //xx wait.bind(null, subscription.publishingInterval * subscription.maxKeepAliveCount + 500),\n                            function (callback) {\n                                try {\n                                    if (doDebug) {\n                                        tracelog(\n                                            \"subscription_raw_notificiationSpy = \",\n                                            subscription_raw_notificationSpy.callCount\n                                        );\n                                        tracelog(\"monitoredItemOnChangedSpy         = \", monitoredItemOnChangedSpy.callCount);\n                                        for (let i = 0; i < monitoredItemOnChangedSpy.callCount; i++) {\n                                            tracelog(\"    \", monitoredItemOnChangedSpy.getCall(i).args[0].statusCode.toString());\n                                        }\n                                    }\n                                    monitoredItemOnChangedSpy.callCount.should.eql(2);\n                                    monitoredItemOnChangedSpy.getCall(0).args[0].statusCode.should.eql(StatusCodes.Good);\n                                    monitoredItemOnChangedSpy\n                                        .getCall(1)\n                                        .args[0].statusCode.should.eql(StatusCodes.GoodWithOverflowBit);\n                                    callback();\n                                } catch (err) {\n                                    tracelog(err);\n                                    callback(err);\n                                }\n                            }\n                        ],\n                        callback\n                    );\n                },\n                (err) => {\n                    done(err);\n                }\n            );\n        });\n\n        it(\"AZA2-L disabled monitored item\", async () => {\n            const nodeId = \"ns=2;s=Static_Scalar_Int32\";\n\n            const monitoredItemOnChangedSpy = new sinon.spy();\n            await perform_operation_on_subscription_async(client, endpointUrl, async (session, subscription) => {\n                // create a disabled monitored Item\n                const monitoredItem = await subscription.monitor(\n                    /* itemToMonitor:*/\n                    {\n                        nodeId,\n                        attributeId: AttributeIds.Value\n                    },\n                    /* requestedParameters:*/\n                    {\n                        samplingInterval: 100,\n                        discardOldest: true,\n                        queueSize: 1\n                    },\n                    TimestampsToReturn.Both\n                );\n                monitoredItem.monitoringMode = MonitoringMode.Reporting;\n                monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n\n                await monitoredItem.setMonitoringMode(MonitoringMode.Disabled);\n            });\n        });\n\n        it(\"AZA2-M #CreateMonitoredItemRequest should return BadNothingToDo if CreateMonitoredItemRequest has no nodes to monitored\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        timestampsToReturn: TimestampsToReturn.Neither,\n                        itemsToCreate: []\n                    });\n                    session.createMonitoredItems(createMonitoredItemsRequest, function (err, createMonitoredItemsResponse) {\n                        should(err.message).match(/BadNothingToDo/);\n                        createMonitoredItemsResponse.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-N #CreateMonitoredItemRequest should return BadIndexRangeInvalid if a invalid range is passed on CreateMonitoredItemRequest \", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const nodeId = makeNodeId(VariableIds.Server_ServerArray);\n                    const samplingInterval = 1000;\n                    const itemToMonitor = new ReadValueId({\n                        nodeId: nodeId,\n                        attributeId: AttributeIds.Value,\n                        indexRange: \"1:2,3:4\"\n                    });\n                    const parameters = {\n                        samplingInterval: samplingInterval,\n                        discardOldest: false,\n                        queueSize: 1\n                    };\n\n                    const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        timestampsToReturn: TimestampsToReturn.Neither,\n                        itemsToCreate: [\n                            {\n                                itemToMonitor: itemToMonitor,\n                                requestedParameters: parameters,\n                                monitoringMode: MonitoringMode.Reporting\n                            }\n                        ]\n                    });\n                    session.createMonitoredItems(createMonitoredItemsRequest, function (err, createMonitoredItemsResponse) {\n                        should.not.exist(err);\n                        createMonitoredItemsResponse.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n\n                        createMonitoredItemsResponse.results[0].statusCode.should.eql(StatusCodes.Good);\n                        callback();\n                    });\n\n                    // now publish and check that monitored item returns\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-O should return BadNothingToDo if ModifyMonitoredItemRequest has no nodes to monitored\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const modifyMonitoredItemsRequest = new ModifyMonitoredItemsRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        timestampsToReturn: TimestampsToReturn.Neither,\n                        itemsToModify: []\n                    });\n                    session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err, modifyMonitoredItemsResponse) {\n                        should(err.message).match(/BadNothingToDo/);\n                        modifyMonitoredItemsResponse.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-P should return BadNothingToDo if DeleteMonitoredItemsResponse has no nodes to delete\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const deleteMonitoredItemsRequest = new DeleteMonitoredItemsRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        monitoredItemIds: []\n                    });\n                    session.deleteMonitoredItems(deleteMonitoredItemsRequest, function (err, deleteMonitoredItemsResponse) {\n                        should(err.message).match(/BadNothingToDo/);\n                        deleteMonitoredItemsResponse.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-Q A MonitoredItem should received changed event\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, inner_callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    monitoredItem.on(\"initialized\", function () {\n                        debugLog(\"Initialized\");\n                    });\n                    monitoredItem.on(\"terminated\", function () {\n                        debugLog(\"monitored item terminated\");\n                    });\n\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        should.exist(dataValue);\n                        // the changed event has been received !\n                        // lets stop monitoring this item\n                        setImmediate(function () {\n                            monitoredItem.terminate(inner_callback);\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-R A Server should reject a CreateMonitoredItemRequest if timestamp is invalid ( catching error on monitored item )\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                (session, subscription, callback) => {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Invalid\n                    );\n\n                    let err_counter = 0;\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", () => {\n                        // eslint-disable-next-line no-debugger\n                        // debugger;\n                    });\n\n                    monitoredItem.on(\"changed\", (dataValue) => {\n                        should.exist(dataValue);\n                    });\n                    monitoredItem.on(\"err\", (err) => {\n                        should.exist(err);\n                        err_counter++;\n                        tracelog(\"err received => terminated event expected \", err.message);\n                    });\n                    monitoredItem.on(\"terminated\", () => {\n                        tracelog(\"terminated event received\");\n                        err_counter.should.eql(1);\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-SA A Server should reject a CreateMonitoredItemRequest if timestamp is invalid ( catching error on callback)\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: 13\n                        },\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Invalid // <= A invalid  TimestampsToReturn\n                    );\n                    monitoredItem.on(\"initialized\", () => {\n                        callback(new Error(\"Should not get there\"));\n                    });\n                    monitoredItem.on(\"err\", () => {\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-SB - GROUP - A Server should reject a CreateMonitoredItemRequest if timestamp is invalid ( catching error on callback)\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const group = ClientMonitoredItemGroup.create(\n                        subscription,\n                        [\n                            {\n                                nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                                attributeId: 13\n                            }\n                        ],\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Invalid // <= A invalid  TimestampsToReturn\n                    );\n                    group.on(\"initialized\", () => {\n                        callback(new Error(\"Should not get there\"));\n                    });\n                    group.on(\"err\", () => {\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n        it(\"AZA2-SB A Server should reject a CreateMonitoredItemRequest if timestamp is invalid ( catching error on callback)\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    subscription.monitor(\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: 13\n                        },\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Invalid, // <= A invalid  TimestampsToReturn\n                        function (err, monitoredItem) {\n                            if (!err) {\n                                callback(new Error(\"Should not get there\"));\n                            } else {\n                                callback();\n                            }\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-T A Server should be able to revise publish interval to avoid trashing if client specify a very small or zero requestedPublishingInterval\", function (done) {\n            // from spec OPCUA Version 1.02  Part 4 $5.13.2.2 : requestedPublishingInterval:\n            // The negotiated value for this parameter returned in the response is used as the\n            // default sampling interval for MonitoredItems assigned to this Subscription.\n            // If the requested value is 0 or negative, the server shall revise with the fastest\n            // supported publishing interval.\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    session.createSubscription(\n                        {\n                            requestedPublishingInterval: -1\n                        },\n                        function (err, createSubscriptionResponse) {\n                            createSubscriptionResponse.revisedPublishingInterval.should.be.greaterThan(10);\n\n                            inner_done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-U should handle PublishRequest to confirm closed subscriptions\", function (done) {\n            let subscriptionId;\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                session.createSubscription(\n                                    {\n                                        requestedPublishingInterval: 200, // Duration\n                                        requestedLifetimeCount: 30, // Counter\n                                        requestedMaxKeepAliveCount: 10, // Counter\n                                        maxNotificationsPerPublish: 10, // Counter\n                                        publishingEnabled: true, // Boolean\n                                        priority: 14 // Byte\n                                    },\n                                    function (err, response) {\n                                        subscriptionId = response.subscriptionId;\n                                        callback(err);\n                                    }\n                                );\n                            },\n\n                            // create a monitored item so we have pending notificiation\n                            function (callback) {\n                                const namespaceIndex = 2;\n                                const nodeId = \"s=\" + \"Static_Scalar_Int16\";\n\n                                const node = server.engine.addressSpace.findNode(nodeId);\n                                const parameters = {\n                                    samplingInterval: 0,\n                                    discardOldest: false,\n                                    queueSize: 1\n                                };\n                                const itemToMonitor = {\n                                    attributeId: 13,\n                                    nodeId: nodeId\n                                };\n                                const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                                    subscriptionId: subscriptionId,\n                                    timestampsToReturn: TimestampsToReturn.Both,\n                                    itemsToCreate: [\n                                        {\n                                            itemToMonitor: itemToMonitor,\n                                            requestedParameters: parameters,\n                                            monitoringMode: MonitoringMode.Reporting\n                                        }\n                                    ]\n                                });\n                                session.createMonitoredItems(createMonitoredItemsRequest, function (err, results) {\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                setTimeout(callback, 300);\n                            },\n                            function (callback) {\n                                session.deleteSubscriptions(\n                                    {\n                                        subscriptionIds: [subscriptionId]\n                                    },\n                                    function (err, response) {\n                                        callback(err);\n                                    }\n                                );\n                            },\n\n                            function (callback) {\n                                session.publish({}, function (err, publishResult) {\n                                    callback();\n                                });\n                            }\n                        ],\n                        function (err) {\n                            done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n    });\n\n    describe(\"AZA3- testing Client-Server subscription use case 2/2, on a fake server exposing the temperature device\", function () {\n        let server, client, temperatureVariableId, endpointUrl;\n\n        const nodeIdVariant = \"ns=1;s=SomeDouble\";\n        const nodeIdByteString = \"ns=1;s=ByteString\";\n        const nodeIdString = \"ns=1;s=String\";\n\n        let subscriptionId = null;\n        let samplingInterval = -1;\n\n        before(function (done) {\n            server = test.server;\n\n            installSessionLogging(server);\n\n\n            endpointUrl = test.endpointUrl;\n            temperatureVariableId = server.temperatureVariableId;\n\n            const namespace = server.engine.addressSpace.getOwnNamespace();\n\n            const rootFolder = server.engine.addressSpace.rootFolder;\n            const objectsFolder = rootFolder.objects;\n\n            // Variable with dataItem capable of sending data change notification events\n            // this type of variable can be continuously monitored.\n            const n1 = namespace.addVariable({\n                organizedBy: objectsFolder,\n                browseName: \"SomeDouble\",\n                nodeId: nodeIdVariant,\n                dataType: \"Double\",\n                value: {\n                    dataType: DataType.Double,\n                    value: 0.0\n                }\n            });\n            n1.minimumSamplingInterval.should.eql(0);\n\n            let changeDetected = 0;\n            n1.on(\"value_changed\", function (dataValue) {\n                changeDetected += 1;\n            });\n\n            n1.setValueFromSource({ dataType: DataType.Double, value: 3.14 }, StatusCodes.Good);\n            changeDetected.should.equal(1);\n\n            namespace.addVariable({\n                organizedBy: objectsFolder,\n                browseName: \"SomeByteString\",\n                nodeId: nodeIdByteString,\n                dataType: \"ByteString\",\n                value: {\n                    dataType: DataType.ByteString,\n                    value: Buffer.from(\"Lorem ipsum\", \"utf-8\")\n                }\n            });\n            namespace.addVariable({\n                organizedBy: objectsFolder,\n                browseName: \"Some String\",\n                nodeId: nodeIdString,\n                dataType: \"String\",\n                value: {\n                    dataType: DataType.String,\n                    value: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                }\n            });\n            done();\n        });\n\n        beforeEach(function (done) {\n            client = OPCUAClient.create({\n                keepSessionAlive: true,\n                requestedSessionTimeout: 4 * 60 * 1000 // 4 min ! make sure that session doesn't drop during test\n            });\n            done();\n        });\n\n        afterEach(function (done) {\n            client = null;\n            done();\n        });\n\n        /**\n         * async method to create a client subscription\n         * @param session\n         * @param subscriptionParameters\n         * @param callback\n         */\n        function my_CreateSubscription(session, subscriptionParameters, callback) {\n            const subscription = ClientSubscription.create(session, subscriptionParameters);\n\n            subscription.once(\"started\", function () {\n                callback(null, subscription);\n            });\n\n            // install a little keepalive counter\n            subscription.nb_keep_alive_received = 0;\n            subscription.on(\"keepalive\", function () {\n                subscription.nb_keep_alive_received += 1;\n            });\n\n            subscription.on(\"timeout\", function () {\n                tracelog(\"Subscription has timed out\");\n            });\n        }\n\n        it(\"AZA3-A A server should send a StatusChangeNotification (BadTimeout) if the client doesn't send PublishRequest within the expected interval\", function (done) {\n            if (process.platform === \"darwin\") {\n                return done(); // skipping on MacOS\n            }\n            //xx endpointUrl = \"opc.tcp://localhost:2200/OPCUA/SimulationServer\";\n\n            // from Spec OPCUA Version 1.03 Part 4 - 5.13.1.1 Description : Page 69\n            // h. Subscriptions have a lifetime counter that counts the number of consecutive publishing cycles in\n            //    which there have been no Publish requests available to send a Publish response for the\n            //    Subscription. Any Service call that uses the SubscriptionId or the processing of a Publish\n            //    response resets the lifetime counter of this Subscription. When this counter reaches the value\n            //    calculated for the lifetime of a Subscription based on the MaxKeepAliveCount parameter in the\n            //    CreateSubscription Service (5.13.2), the Subscription is closed. Closing the Subscription causes\n            //    its MonitoredItems to be deleted. In addition the Server shall issue a StatusChangeNotification\n            //    notificationMessage with the status code Bad_Timeout. The StatusChangeNotification\n            //    notificationMessage type is defined in 7.19.4.\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    function setUnpublishing(session) {\n                        // replace internalSendPublishRequest so that it doesn't do anything for a little while\n                        // The publish engine is shared amongst all subscriptions and belongs to the  session object\n                        session.getPublishEngine().internalSendPublishRequest.should.be.instanceOf(Function);\n                        sinon.stub(session.getPublishEngine(), \"internalSendPublishRequest\").returns();\n                    }\n\n                    /**\n                     * restore the publishing mechanism on a unpublishing subscription\n                     * @param session\n                     */\n                    function repairUnpublishing(session) {\n                        session.getPublishEngine().internalSendPublishRequest.callCount.should.be.greaterThan(1);\n                        session.getPublishEngine().internalSendPublishRequest.restore();\n                        session.getPublishEngine().internalSendPublishRequest();\n                    }\n\n                    setUnpublishing(session);\n\n                    // in this test we need two subscriptions\n                    //    - one subscription with a short live time\n                    //    - one subscription with a long life time,\n                    //\n                    // at the beginning, both subscriptions will not send PublishRequest\n\n                    let longLifeSubscription, shortLifeSubscription;\n                    async.series(\n                        [\n                            f(function create_long_life_subscription(callback) {\n                                const subscriptionParameters = {\n                                    requestedPublishingInterval: 100, // short publishing interval required here\n                                    requestedLifetimeCount: 1000, // long lifetimeCount needed here !\n                                    requestedMaxKeepAliveCount: 50,\n                                    maxNotificationsPerPublish: 30,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                };\n\n                                my_CreateSubscription(session, subscriptionParameters, function (err, subscription) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    longLifeSubscription = subscription;\n                                    setImmediate(callback);\n                                });\n                            }),\n\n                            f(function create_short_life_subscription(callback) {\n                                const subscriptionParameters = {\n                                    requestedPublishingInterval: 100, // short publishing interval required here\n                                    requestedLifetimeCount: 30, // short lifetimeCount needed here !\n                                    requestedMaxKeepAliveCount: 4,\n                                    maxNotificationsPerPublish: 30,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                };\n\n                                my_CreateSubscription(session, subscriptionParameters, function (err, subscription) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    shortLifeSubscription = subscription;\n                                    setImmediate(callback);\n                                });\n                            }),\n                            f(function wait_for_short_life_subscription_to_expire(callback) {\n                                // let's make sure that the subscription will expired\n                                const timeToWaitBeforeResendingPublishInterval =\n                                    shortLifeSubscription.publishingInterval *\n                                    (shortLifeSubscription.lifetimeCount + shortLifeSubscription.maxKeepAliveCount * 4 + 20);\n\n                                tracelog(\"timeToWaitBeforeResendingPublishInterval = \", timeToWaitBeforeResendingPublishInterval);\n                                if (doDebug) {\n                                    tracelog(shortLifeSubscription.toString());\n                                    tracelog(\n                                        \"timetoWaitBeforeResendingPublishInterval  :\",\n                                        timeToWaitBeforeResendingPublishInterval\n                                    );\n                                    tracelog(\n                                        \"Count To WaitBeforeResendingPublishInterval  :\",\n                                        timeToWaitBeforeResendingPublishInterval / shortLifeSubscription.publishingInterval\n                                    );\n                                }\n\n                                setTimeout(function () {\n                                    if (true || doDebug) {\n                                        tracelog(\" Restoring default Publishing behavior\");\n                                    }\n                                    repairUnpublishing(session);\n                                }, timeToWaitBeforeResendingPublishInterval);\n\n                                shortLifeSubscription.once(\"status_changed\", function (statusCode) {\n                                    statusCode.should.eql(StatusCodes.BadTimeout);\n                                    setImmediate(callback);\n                                });\n                            }),\n                            f(function terminate_short_life_subscription(callback) {\n                                const timeout =\n                                    shortLifeSubscription.publishingInterval * shortLifeSubscription.maxKeepAliveCount * 2;\n                                if (true || doDebug) {\n                                    tracelog(\"timeout = \", timeout);\n                                }\n                                const verif = shortLifeSubscription.nb_keep_alive_received;\n                                // let explicitly close the subscription by calling terminate\n                                // but delay a little bit so we can verify that internalSendPublishRequest\n                                // is not called\n                                setTimeout(function () {\n                                    tracelog(\"before shortLifeSubscription terminate\");\n                                    shortLifeSubscription.terminate(function (err) {\n                                        tracelog(\" shortLifeSubscription terminated\");\n                                        shortLifeSubscription.nb_keep_alive_received.should.be.equal(verif);\n                                        setImmediate(callback);\n                                    });\n                                }, timeout);\n                            }),\n                            f(function terminate_long_life_subscription(callback) {\n                                tracelog(\"before longLifeSubscription terminate\");\n                                longLifeSubscription.terminate((err) => {\n                                    tracelog(\" longLifeSubscription terminated\");\n                                    setImmediate(callback);\n                                });\n                            })\n                        ],\n                        (err) => {\n                            tracelog(\"inner\", err ? err.message: \"\");\n                            inner_done(err);\n                        }\n                    );\n                },\n                (err) => {\n                    tracelog(\"done\", err ? err.message: \"\");\n                    done(err);\n                }\n            );\n        });\n\n        it(\"AZA3-B A subscription without a monitored item should not dropped too early ( see #59)\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    function termination_is_a_failure() {\n                        inner_done(new Error(\"subscription has been terminated !!!!\"));\n                    }\n\n                    subscription.on(\"terminated\", termination_is_a_failure);\n\n                    setTimeout(function () {\n                        subscription.removeListener(\"terminated\", termination_is_a_failure);\n                        inner_done();\n                    }, 1000);\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-C #bytesRead #transactionsCount #bytesWritten\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    server.bytesRead.should.be.greaterThan(10);\n                    server.transactionsCount.should.be.greaterThan(3);\n                    server.bytesWritten.should.be.greaterThan(10);\n                    inner_done();\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-D #CreateMonitoredItemsRequest : A server should return statusCode === BadSubscriptionIdInvalid when appropriate  \", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const options = {\n                        subscriptionId: 999 // << invalide subscription id\n                    };\n                    session.createMonitoredItems(options, function (err, results) {\n                        err.message.should.match(/BadSubscriptionIdInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-E #SetPublishingModeRequest: A server should set status codes to BadSubscriptionIdInvalid when appropriate  \", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const publishingEnabled = true;\n                    const subscriptionIds = [999]; //<< invalid subscription ID\n                    session.setPublishingMode(publishingEnabled, subscriptionIds, function (err, results) {\n                        results.should.be.instanceOf(Array);\n                        results[0].should.eql(StatusCodes.BadSubscriptionIdInvalid);\n                        inner_done(err);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-F A server should suspend/resume publishing when client send a setPublishingMode Request \", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const parameters = {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    };\n\n                    const subscription = ClientSubscription.create(session, parameters);\n\n                    subscription.on(\"terminated\", function () {\n                        debugLog(\"subscription terminated\");\n                    });\n\n                    const itemToMonitor = {\n                        nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                        attributeId: AttributeIds.Value\n                    };\n                    const monitoringParameters = {\n                        samplingInterval: 10,\n                        discardOldest: true,\n                        queueSize: 1\n                    };\n                    const monitoredItem = ClientMonitoredItem.create(subscription, itemToMonitor, monitoringParameters);\n\n                    let change_count = 0;\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        change_count += 1;\n                        should.exist(dataValue);\n                        //xx tracelog(\"xxxxxxxxxxxx=> dataValue\",dataValue.toString());\n                    });\n\n                    async.series(\n                        [\n                            function (callback) {\n                                // wait 400 milliseconds and verify that the subscription is sending some notification\n                                setTimeout(function () {\n                                    change_count.should.be.greaterThan(2);\n                                    callback();\n                                }, 3600);\n                            },\n                            function (callback) {\n                                // suspend subscription\n                                subscription.setPublishingMode(false, function (err) {\n                                    change_count = 0;\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                // wait  400 milliseconds and verify that the subscription is  NOT sending any notification\n                                setTimeout(function () {\n                                    change_count.should.equal(0);\n                                    callback();\n                                }, 400);\n                            },\n\n                            function (callback) {\n                                // resume subscription\n                                subscription.setPublishingMode(true, function (err) {\n                                    change_count = 0;\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                // wait 600 milliseconds and verify that the subscription is sending some notification again\n                                setTimeout(function () {\n                                    change_count.should.be.greaterThan(2);\n                                    callback();\n                                }, 3600);\n                            },\n\n                            function (callback) {\n                                subscription.terminate(function (err) {\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-G A client should be able to create a subscription that have  publishingEnable=false\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: false,\n                        priority: 6\n                    });\n\n                    subscription.on(\"terminated\", function () {\n                        debugLog(\"subscription terminated\");\n                    });\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    let change_count = 0;\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        should.exist(dataValue);\n                        change_count += 1;\n                    });\n                    async.series(\n                        [\n                            function (callback) {\n                                // wait 400 ms and verify that the subscription is not sending notification.\n                                setTimeout(function () {\n                                    change_count.should.equal(0);\n                                    callback();\n                                }, 400);\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-H #ModifyMonitoredItemRequest : server should send BadSubscriptionIdInvalid if client send a wrong subscription id\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const modifyMonitoredItemsRequest = {\n                        subscriptionId: 999,\n                        timestampsToReturn: TimestampsToReturn.Neither,\n                        itemsToModify: [{}]\n                    };\n\n                    session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err) {\n                        err.message.should.match(/BadSubscriptionIdInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-I #ModifyMonitoredItemRequest : server should send BadSubscriptionIdInvalid if client send a wrong subscription id\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        const modifyMonitoredItemsRequest = {\n                            subscriptionId: subscription.subscriptionId,\n                            timestampsToReturn: TimestampsToReturn.Invalid\n                        };\n\n                        session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err, modifyMonitoredItemsResponse) {\n                            err.message.should.match(/BadTimestampsToReturnInvalid/);\n                            inner_done();\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-J #ModifyMonitoredItemRequest : server should send BadMonitoredItemIdInvalid  if client send a wrong monitored item id\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 200,\n                        requestedLifetimeCount: 60000,\n                        requestedMaxKeepAliveCount: 10,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        const modifyMonitoredItemsRequest = {\n                            subscriptionId: subscription.subscriptionId,\n                            timestampsToReturn: TimestampsToReturn.Neither,\n                            itemsToModify: [\n                                new MonitoredItemModifyRequest({\n                                    monitoredItemId: 999,\n                                    requestedParameters: {}\n                                })\n                            ]\n                        };\n\n                        session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err, modifyMonitoredItemsResponse) {\n                            if (err) {\n                                return inner_done(err);\n                            }\n                            modifyMonitoredItemsResponse.results.length.should.eql(1);\n                            modifyMonitoredItemsResponse.results[0].statusCode.should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n                            inner_done();\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        function test_modify_monitored_item(itemToMonitor, parameters, inner_func, done) {\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    let change_count = 0;\n                    subscription.publishingInterval.should.be.aboveOrEqual(100);\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        //xx tracelog(\"xx changed\",dataValue.value.toString());\n                        change_count += 1;\n                    });\n\n                    async.series(\n                        [\n                            function (callback) {\n                                setTimeout(callback, 1500);\n                            },\n                            function (callback) {\n                                // let's wait for first notification to be received\n                                monitoredItem.once(\"changed\", () => {\n                                    // we reset change count,\n                                    change_count = 0;\n                                    callback();\n                                });\n                            },\n                            function (callback) {\n                                // wait at least 2 x publishingInterval ms and verify that the subscription is not sending notification.\n                                setTimeout(() => {\n                                    change_count.should.equal(0);\n                                    callback();\n                                }, 800);\n                            },\n\n                            function (callback) {\n                                // let modify monitored item with new parameters.\n                                monitoredItem.modify(parameters, function (err, result) {\n                                    inner_func(err, result, callback);\n                                });\n                            },\n\n                            function (callback) {\n                                // wait 1.5 ms and verify that the subscription is now sending notification.\n                                setTimeout(() => {\n                                    change_count.should.be.greaterThan(1);\n                                    callback();\n                                }, 2000); // wait at least 2 seconds as date resolution is 1 sec.\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            ); //\n        }\n\n        it(\"AZA3-K #ModifyMonitoredItemRequest : server should handle samplingInterval === -1\", function (done) {\n            const itemToMonitor = \"ns=0;i=2258\";\n\n            /**\n             * The value - 1 indicates that the default sampling interval defined\n             * by the publishing interval of the Subscription is requested.A different\n             * sampling interval is used if the publishing interval is not a supported\n             * sampling interval.Any negative number is interpreted as -1. The sampling\n             * interval is not changed if the publishing interval is changed by a\n             * subsequent call to the ModifySubscription Service.\n             */\n\n            const parameters = {\n                samplingInterval: -1, // SAMPLING INTERVAL = -1\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item(\n                itemToMonitor,\n                parameters,\n                function (err, results, callback) {\n                    callback(err);\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-L #ModifyMonitoredItemRequest : server should handle samplingInterval === 0\", function (done) {\n            const itemToMonitor = \"ns=0;i=2258\";\n\n            const parameters = {\n                samplingInterval: 0, // SAMPLING INTERVAL = 0 => use fastest allowed by server\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item(\n                itemToMonitor,\n                parameters,\n                function (err, results, callback) {\n                    callback(err);\n                },\n                done\n            );\n        });\n        it(\"AZA3-M #ModifyMonitoredItemsRequest : a client should be able to modify a monitored item\", function (done) {\n            const itemToMonitor = \"ns=0;i=2258\";\n            const parameters = {\n                samplingInterval: 20,\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item(\n                itemToMonitor,\n                parameters,\n                function (err, results, callback) {\n                    if (!err) {\n                        results.revisedSamplingInterval.should.be.greaterThan(19);\n                    }\n                    callback(err);\n                },\n                done\n            );\n        });\n\n        function test_modify_monitored_item_on_noValue_attribute(parameters, done) {\n            const nodeId = \"ns=0;i=2258\";\n            const itemToMonitor = {\n                nodeId: resolveNodeId(nodeId),\n                attributeId: AttributeIds.BrowseName\n            };\n\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    let change_count = 0;\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        //xx tracelog(\"xx changed\",dataValue.value.toString());\n                        dataValue.value.toString().should.eql(\"Variant(Scalar<QualifiedName>, value: CurrentTime)\");\n                        change_count += 1;\n                    });\n                    async.series(\n                        [\n                            function (callback) {\n                                setTimeout(function () {\n                                    change_count.should.eql(1);\n                                    callback();\n                                }, 1000);\n                            },\n                            function (callback) {\n                                monitoredItem.modify(parameters, function (err, result) {\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                // modifying monitoredItem parameters shall not cause the monitored Item to resend a data notification\n                                setTimeout(function () {\n                                    change_count.should.eql(1);\n                                    callback();\n                                }, 1000);\n                            },\n\n                            // setting mode to disable\n                            function (callback) {\n                                monitoredItem.setMonitoringMode(MonitoringMode.Disabled, callback);\n                            },\n                            // setting mode to disable\n                            function (callback) {\n                                monitoredItem.setMonitoringMode(MonitoringMode.Reporting, callback);\n                            },\n                            function (callback) {\n                                // Changing mode from Disabled to Reporting shall cause the monitored Item to resend a data notification\n                                setTimeout(function () {\n                                    change_count.should.eql(2);\n                                    callback();\n                                }, 1000);\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        }\n\n        it(\"AZA3-N #ModifyMonitoredItemRequest on a non-Value attribute: server should handle samplingInterval === 0\", function (done) {\n            const parameters = {\n                samplingInterval: 0, // SAMPLING INTERVAL = 0 => use fastest allowed by server or event base\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item_on_noValue_attribute(parameters, done);\n        });\n\n        it(\"AZA3-O #ModifyMonitoredItemRequest on a non-Value attribute: server should handle samplingInterval > 0\", function (done) {\n            const parameters = {\n                samplingInterval: 20,\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item_on_noValue_attribute(parameters, done);\n        });\n\n        it(\"AZA3-P #ModifyMonitoredItemRequest on a non-Value attribute: server should handle samplingInterval === -1\", function (done) {\n            const parameters = {\n                samplingInterval: -1,\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item_on_noValue_attribute(parameters, done);\n        });\n\n        /**\n         * see CTT createMonitoredItems591064\n         * Description:\n         * Create a monitored item with the nodeId set to that of a non-Variable node and\n         * the attributeId set to a non-Value attribute. call Publish().\n         * Expected Results: All service and operation level results are Good. Publish response contains a DataChangeNotification.\n         */\n        it(\"AZA3-Q a monitored item with the nodeId set to that of a non-Variable node an  and the attributeId set to a non-Value attribute should send a DataChangeNotification\", function (done) {\n            // Attributes, other than the  Value  Attribute, are only monitored for a change in value.\n            // The filter is not used for these  Attributes. Any change in value for these  Attributes\n            // causes a  Notification  to be  generated.\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 10,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 10,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    subscription.on(\"terminated\", function () {\n                        //xx tracelog(chalk.yellow(\" subscription terminated \"));\n                        inner_done();\n                    });\n\n                    const readValue = {\n                        nodeId: resolveNodeId(\"Server\"),\n                        attributeId: AttributeIds.DisplayName\n                    };\n\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        readValue,\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Both\n                    );\n\n                    monitoredItem.on(\"err\", function (err) {\n                        should.not.exist(err);\n                    });\n\n                    let change_count = 0;\n\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        //xx tracelog(\"dataValue = \", dataValue.toString());\n                        change_count += 1;\n                    });\n\n                    async.series(\n                        [\n                            function (callback) {\n                                setTimeout(function () {\n                                    change_count.should.equal(1);\n                                    callback();\n                                }, 1000);\n                            },\n                            function (callback) {\n                                // on server side : modify displayName\n                                const node = server.engine.addressSpace.findNode(readValue.nodeId);\n                                node.setDisplayName(\"Changed Value\");\n                                callback();\n                            },\n\n                            function (callback) {\n                                setTimeout(function () {\n                                    change_count.should.equal(2);\n                                    callback();\n                                }, 1000);\n                            },\n\n                            function (callback) {\n                                subscription.terminate(callback);\n                            }\n                        ],\n                        function (err) {\n                            if (err) {\n                                done(err);\n                            }\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-R Server should revise publishingInterval to be at least server minimum publishing interval\", function (done) {\n            Subscription.minimumPublishingInterval.should.eql(50);\n            const too_small_PublishingInterval = 30;\n            const server_actualPublishingInterval = 100;\n\n            let subscriptionId = -1;\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                const createSubscriptionRequest = new CreateSubscriptionRequest({\n                                    requestedPublishingInterval: too_small_PublishingInterval,\n                                    requestedLifetimeCount: 60,\n                                    requestedMaxKeepAliveCount: 10,\n                                    maxNotificationsPerPublish: 10,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                });\n\n                                session.performMessageTransaction(createSubscriptionRequest, function (err, response) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n\n                                    if (doDebug) {\n                                        tracelog(\"response\", response.toString());\n                                    }\n\n                                    subscriptionId = response.subscriptionId;\n                                    response.revisedPublishingInterval.should.eql(Subscription.minimumPublishingInterval);\n\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        // If the Server specifies a value for the\n        // MinimumSamplingInterval Attribute it shall always return a revisedSamplingInterval that is equal or\n        // higher than the MinimumSamplingInterval if the Client subscribes to the Value Attribute.\n\n        function test_revised_sampling_interval(\n            requestedPublishingInterval,\n            requestedSamplingInterval,\n            revisedSamplingInterval,\n            done\n        ) {\n            const forcedMinimumInterval = 1;\n            const nodeId = \"ns=2;s=Static_Scalar_Int16\";\n\n            const node = server.engine.addressSpace.findNode(nodeId);\n            //xx tracelog(chalk.cyan(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"),node.toString());\n            const server_node = test.server.engine.addressSpace.rootFolder.objects.simulation.static[\"all Profiles\"].scalars.int16;\n            //xx tracelog(\"server_node.minimumSamplingInterval = \",server_node.minimumSamplingInterval);\n            server_node.minimumSamplingInterval = forcedMinimumInterval;\n\n            const itemToMonitor = new ReadValueId({\n                nodeId: nodeId,\n                attributeId: AttributeIds.Value\n            });\n            let subscriptionId = -1;\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function read_minimumSamplingInterval(callback) {\n                                let minimumSamplingIntervalOnNode;\n                                const nodeToRead = {\n                                    nodeId: nodeId,\n                                    attributeId: AttributeIds.MinimumSamplingInterval\n                                };\n                                session.read(nodeToRead, function (err, dataValue) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    dataValue.statusCode.should.eql(StatusCodes.Good);\n                                    minimumSamplingIntervalOnNode = dataValue.value.value;\n                                    //xx tracelog(\"minimumSamplingIntervalOnNode= =\",minimumSamplingIntervalOnNode);\n\n                                    minimumSamplingIntervalOnNode.should.eql(forcedMinimumInterval);\n\n                                    callback();\n                                });\n                            },\n                            function (callback) {\n                                const createSubscriptionRequest = new CreateSubscriptionRequest({\n                                    requestedPublishingInterval: requestedPublishingInterval,\n                                    requestedLifetimeCount: 60,\n                                    requestedMaxKeepAliveCount: 10,\n                                    maxNotificationsPerPublish: 10,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                });\n\n                                session.performMessageTransaction(createSubscriptionRequest, function (err, response) {\n                                    subscriptionId = response.subscriptionId;\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                const parameters = {\n                                    samplingInterval: requestedSamplingInterval,\n                                    discardOldest: false,\n                                    queueSize: 1\n                                };\n                                const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                                    subscriptionId: subscriptionId,\n                                    timestampsToReturn: TimestampsToReturn.Both,\n                                    itemsToCreate: [\n                                        {\n                                            itemToMonitor: itemToMonitor,\n                                            requestedParameters: parameters,\n                                            monitoringMode: MonitoringMode.Reporting\n                                        }\n                                    ]\n                                });\n\n                                //xx tracelog(\"createMonitoredItemsRequest = \", createMonitoredItemsRequest.toString());\n\n                                session.performMessageTransaction(createMonitoredItemsRequest, function (err, response) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    //xx tracelog(\"ERRR = \", err);\n                                    should.not.exist(err);\n                                    response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                                    //xx tracelog(response.results[0].toString());\n\n                                    response.results[0].statusCode.should.eql(StatusCodes.Good);\n                                    samplingInterval = response.results[0].revisedSamplingInterval;\n                                    samplingInterval.should.eql(\n                                        revisedSamplingInterval,\n                                        \"expected revisedSamplingInterval to be modified\"\n                                    );\n\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        }\n\n        const fastest_possible_sampling_rate = MonitoredItem.minimumSamplingInterval;\n        fastest_possible_sampling_rate.should.eql(50);\n\n        it(\"AZA3-S when createMonitored Item samplingInterval is Zero server shall return the fastest possible sampling rate\", function (done) {\n            // Spec : OpcUA 1.03 part 4 page 125 7.16 MonitoringParameters:\n            // The interval that defines the fastest rate at which the MonitoredItem(s) should be accessed and evaluated.\n            // This interval is defined in milliseconds.\n            // The value 0 indicates that the Server should use the fastest practical rate.\n            test_revised_sampling_interval(0, 0, fastest_possible_sampling_rate, done);\n        });\n\n        it(\"AZA3-T when createMonitored Item samplingInterval is -1 (minus one) server shall return the sampling rate of the subscription 1/2\", function (done) {\n            // Spec : OpcUA 1.03 part 4 page 125 7.16 MonitoringParameters:\n            // The value -1 indicates that the default sampling interval defined by the publishing interval of the\n            // Subscription is requested.\n            // A different sampling interval is used if the publishing interval is not a\n            // supported sampling interval.\n            // Any negative number is interpreted as -1. The sampling interval is not changed\n            // if the publishing interval is changed by a subsequent call to the ModifySubscription Service.\n            test_revised_sampling_interval(100, -1, 100, done);\n        });\n\n        it(\"AZA3-U when createMonitored Item samplingInterval is -1 (minus one) server shall return the sampling rate of the subscription 2/2\", function (done) {\n            test_revised_sampling_interval(200, -1, 200, done);\n        });\n\n        it(\"AZA3-V when createMonitored Item samplingInterval is too small, server shall return the sampling rate of the subscription\", function (done) {\n            // Spec : OpcUA 1.03 part 4 page 125 7.16 MonitoringParameters:\n            test_revised_sampling_interval(100, 10, fastest_possible_sampling_rate, done);\n        });\n\n        xit(\n            \"AZA3-W When a user adds a monitored item that the user is denied read access to, the add operation for the\" +\n                \" item shall succeed and the bad status  Bad_NotReadable  or  Bad_UserAccessDenied  shall be\" +\n                \" returned in the Publish response\",\n            function (done) {\n                done();\n            }\n        );\n\n        /**\n         * see CTT createMonitoredItems591014 ( -009.js)\n         */\n        function writeValue(nodeId, session, value, callback) {\n            const nodesToWrite = [\n                {\n                    nodeId: nodeId,\n                    attributeId: AttributeIds.Value,\n                    value: /*new DataValue(*/ {\n                        serverTimestamp: new Date(),\n                        sourceTimestamp: new Date(),\n                        value: {\n                            /* Variant */\n                            dataType: DataType.Double,\n                            value: value\n                        }\n                    }\n                }\n            ];\n\n            setTimeout(function () {\n                session.write(nodesToWrite, function (err, statusCodes) {\n                    statusCodes.length.should.eql(1);\n                    statusCodes[0].should.eql(StatusCodes.Good);\n                    setTimeout(function () {\n                        callback(err);\n                    }, 100);\n                });\n            }, 100);\n        }\n\n        function sendPublishRequest(session, callback) {\n            session.publish({}, function (err, response) {\n                try {\n                    callback(err, response);\n                } catch (err) {\n                    //xx tracelog('================> error =>'.red,err);\n                    callback(err, response);\n                }\n            });\n        }\n\n        function createSubscription2(session, createSubscriptionRequest, callback) {\n            createSubscriptionRequest = new CreateSubscriptionRequest(createSubscriptionRequest);\n\n            (typeof callback === \"function\").should.eql(true, \"expecting a function\");\n\n            session.performMessageTransaction(createSubscriptionRequest, function (err, response) {\n                response.subscriptionId.should.be.greaterThan(0);\n                subscriptionId = response.subscriptionId;\n                callback(err, response.subscriptionId, response);\n            });\n        }\n\n        const publishingInterval = 40;\n\n        function createSubscription(session, callback) {\n            (typeof callback === \"function\").should.eql(true, \"expecting a function\");\n            const createSubscriptionRequest = {\n                requestedPublishingInterval: publishingInterval,\n                requestedLifetimeCount: 600,\n                requestedMaxKeepAliveCount: 10,\n                maxNotificationsPerPublish: 10,\n                publishingEnabled: true,\n                priority: 6\n            };\n            createSubscription2(session, createSubscriptionRequest, callback);\n        }\n\n        function createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback) {\n            /* backdoor */\n            const node = server.engine.addressSpace.findNode(nodeId);\n            should.exist(node, \" \" + nodeId.toString() + \" must exist\");\n            node.minimumSamplingInterval.should.eql(0); // exception-based change notification\n\n            //xx parameters.samplingInterval.should.eql(0);\n\n            const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                subscriptionId: subscriptionId,\n                timestampsToReturn: TimestampsToReturn.Both,\n                itemsToCreate: [\n                    {\n                        itemToMonitor: itemToMonitor,\n                        requestedParameters: parameters,\n                        monitoringMode: MonitoringMode.Reporting\n                    }\n                ]\n            });\n\n            session.performMessageTransaction(createMonitoredItemsRequest, function (err, response) {\n                response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n\n                samplingInterval = response.results[0].revisedSamplingInterval;\n                //xx tracelog(\" revised Sampling interval \",samplingInterval);\n                callback(err);\n            });\n        }\n\n        function deleteSubscription(session, callback) {\n            session.deleteSubscriptions(\n                {\n                    subscriptionIds: [subscriptionId]\n                },\n                callback\n            );\n        }\n\n        function _test_with_queue_size_of_one(parameters, done) {\n            const nodeId = nodeIdVariant;\n\n            const itemToMonitor = new ReadValueId({\n                nodeId: nodeId,\n                attributeId: AttributeIds.Value\n            });\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                createSubscription(session, function (err, id) {\n                                    id.should.be.greaterThan(0);\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                            },\n\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    if (!err) {\n                                        //Xx var notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                    }\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                writeValue(nodeId, session, 1, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 2, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 3, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 4, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 5, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 6, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 7, callback);\n                            },\n\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    if (!err) {\n                                        response.notificationMessage.notificationData.length.should.eql(1);\n\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        notification.value.value.value.should.eql(7);\n\n                                        parameters.queueSize.should.eql(1);\n                                        notification.value.statusCode.should.eql(\n                                            StatusCodes.Good,\n                                            \"OverFlow bit shall not be set when queueSize =1\"\n                                        );\n                                    }\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        }\n\n        it(\"#CTT1 - should make sure that only the latest value is returned when queue size is one and discard oldest is false\", function (done) {\n            const samplingInterval = 0; // exception based\n            const parameters = {\n                samplingInterval: samplingInterval,\n                discardOldest: false,\n                queueSize: 1\n            };\n            _test_with_queue_size_of_one(parameters, done);\n        });\n        it(\"#CTT2 - should make sure that only the latest value is returned when queue size is one and discard oldest is true\", function (done) {\n            const samplingInterval = 0; // exception based\n            const parameters = {\n                samplingInterval: samplingInterval,\n                discardOldest: true,\n                queueSize: 1\n            };\n            _test_with_queue_size_of_one(parameters, done);\n        });\n\n        function _test_with_queue_size_of_two(parameters, expected_values, expected_statusCodes, done) {\n            const nodeId = nodeIdVariant;\n            const itemToMonitor = new ReadValueId({\n                nodeId: nodeId,\n                attributeId: AttributeIds.Value\n            });\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                createSubscription(session, callback);\n                            },\n\n                            function (callback) {\n                                createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                            },\n\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                writeValue(nodeId, session, 1, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 2, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 3, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 4, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 5, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 6, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 7, callback);\n                            },\n                            function wait_a_little_bit(callback) {\n                                setTimeout(callback, 1000);\n                            },\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    if (!err) {\n                                        should(!!response.notificationMessage.notificationData).eql(true);\n                                        response.notificationMessage.notificationData.length.should.eql(1);\n\n                                        // we should have 2 elements in queue\n                                        response.notificationMessage.notificationData[0].monitoredItems.length.should.eql(2);\n\n                                        let notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        //xx tracelog(notification.value.value.value);\n                                        notification.value.value.value.should.eql(expected_values[0]);\n                                        notification.value.statusCode.should.eql(expected_statusCodes[0]);\n\n                                        notification = response.notificationMessage.notificationData[0].monitoredItems[1];\n                                        //xx tracelog(notification.value.value.value);\n                                        notification.value.value.value.should.eql(expected_values[1]);\n                                        notification.value.statusCode.should.eql(expected_statusCodes[1]);\n                                        //xx parameters.queueSize.should.eql(2);\n                                        //xx notification.value.statusCode.should.eql(StatusCodes.GoodWithOverflowBit, \"OverFlow bit shall not be set when queueSize =2\");\n                                    }\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        }\n\n        it(\"#CTT3 - should make sure that only the last 2 values are returned when queue size is two and discard oldest is TRUE\", function (done) {\n            const samplingInterval = 0;\n            const parameters = {\n                samplingInterval: samplingInterval,\n                discardOldest: true,\n                queueSize: 2\n            };\n\n            _test_with_queue_size_of_two(parameters, [6, 7], [StatusCodes.GoodWithOverflowBit, StatusCodes.Good], done);\n        });\n\n        it(\"#CTT4 - should make sure that only the last 2 values are returned when queue size is two and discard oldest is false\", function (done) {\n            const samplingInterval = 0;\n            const parameters = {\n                samplingInterval: samplingInterval,\n                discardOldest: false,\n                queueSize: 2\n            };\n            _test_with_queue_size_of_two(parameters, [1, 7], [StatusCodes.Good, StatusCodes.GoodWithOverflowBit], done);\n        });\n\n        it(\"#CTT5 Monitoring a non-Variable node with delayed PublishRequest:\", function (done) {\n            // CTT Monitored Item Service / Monitor Basic / 001.js\n            // Description:\n            //     Create a monitored item with the nodeId set to that of a non-Variable node and\n            //     the attributeId set to a non-Value attribute. call Publish().\n            //  Expected Results:\n            //      All service and operation level results are Good. Publish response contains a DataChangeNotification.\n\n            const parameters = {\n                samplingInterval: 0,\n                discardOldest: true,\n                queueSize: 1\n            };\n\n            const nodeId = nodeIdVariant;\n\n            const itemToMonitor = new ReadValueId({\n                nodeId: nodeId,\n                attributeId: AttributeIds.Description\n            });\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                createSubscription(session, callback);\n                            },\n\n                            function (callback) {\n                                createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                            },\n\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    if (!err) {\n                                        response.notificationMessage.notificationData.length.should.eql(1);\n\n                                        //xx tracelog(\"xxxx \", response.notificationMessage.notificationData.toString());\n\n                                        //Xx var notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                    }\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"#CTT6 Late Publish should have data\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const nodeId = \"ns=2;s=Static_Scalar_Double\";\n                    const samplingInterval = 500;\n                    const parameters = {\n                        samplingInterval: samplingInterval,\n                        discardOldest: true,\n                        queueSize: 2\n                    };\n                    const itemToMonitor = new ReadValueId({\n                        nodeId: nodeId,\n                        attributeId: AttributeIds.Value\n                    });\n\n                    let time_to_wait = 0;\n\n                    async.series(\n                        [\n                            function (callback) {\n                                const publishingInterval = 100;\n                                const createSubscriptionRequest = new CreateSubscriptionRequest({\n                                    requestedPublishingInterval: publishingInterval,\n                                    requestedLifetimeCount: 30,\n                                    requestedMaxKeepAliveCount: 10,\n                                    maxNotificationsPerPublish: 10,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                });\n                                createSubscription2(session, createSubscriptionRequest, function (err, subscriptionId, response) {\n                                    time_to_wait = response.revisedPublishingInterval * response.revisedLifetimeCount;\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                //xx tracelog(\" SubscriptionId =\",subscriptionId);\n                                callback();\n                            },\n                            function (callback) {\n                                createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                            },\n                            function (callback) {\n                                setTimeout(callback, time_to_wait + 1500);\n                            },\n\n                            function (callback) {\n                                //xx tracelog(\"--------------\");\n                                // we should get notified immediately that the session has timed out\n                                sendPublishRequest(session, function (err, response) {\n                                    response.notificationMessage.notificationData.length.should.eql(1);\n                                    const notificationData = response.notificationMessage.notificationData[0];\n                                    //xx tracelog(notificationData.toString());\n                                    //.monitoredItems[0];\n                                    notificationData.constructor.name.should.eql(\"StatusChangeNotification\");\n                                    notificationData.status.should.eql(StatusCodes.BadTimeout);\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        describe(\"#CTT - Monitored Value Change\", function () {\n            it(\"should monitor a substring \", function (done) {\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, inner_done) {\n                        const nodeId = nodeIdString;\n                        const samplingInterval = 0;\n\n                        const parameters = {\n                            samplingInterval: samplingInterval,\n                            discardOldest: false,\n                            queueSize: 2\n                        };\n\n                        const itemToMonitor = new ReadValueId({\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            indexRange: \"4:10\"\n                        });\n\n                        async.series(\n                            [\n                                function (callback) {\n                                    createSubscription(session, callback);\n                                },\n\n                                function (callback) {\n                                    createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                                },\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        //xx tracelog(\"notification\", notification.toString());\n                                        notification.value.value.value.should.eql(\"EFGHIJK\");\n                                        callback(err);\n                                    });\n                                },\n\n                                function (callback) {\n                                    const nodesToWrite = [\n                                        {\n                                            nodeId: nodeId,\n                                            attributeId: AttributeIds.Value,\n                                            value: /*new DataValue(*/ {\n                                                value: {\n                                                    /* Variant */\n                                                    dataType: DataType.String,\n                                                    //      01234567890123456789012345\n                                                    value: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n                                                }\n                                            }\n                                        }\n                                    ];\n\n                                    session.write(nodesToWrite, function (err, statusCodes) {\n                                        statusCodes.length.should.eql(1);\n                                        statusCodes[0].should.eql(StatusCodes.Good);\n                                        callback(err);\n                                    });\n                                },\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        //xx tracelog(\"notification\", notification.toString());\n                                        notification.value.value.value.should.eql(\"VUTSRQP\");\n                                        callback(err);\n                                    });\n                                }\n                            ],\n                            inner_done\n                        );\n                    },\n                    done\n                );\n            });\n\n            it(\"ZZE it should return a publish Response with Bad_IndexRangeNoData , when the size of the monitored item change\", function (done) {\n                // as per CTT test 036.js (MonitoredItem Service/Monitored Value Changed\n                // Create a monitored item of an array with an IndexRange of \u201c2:4\u201d (the array must currently have at least five elements).\n                // call Publish(). Write to the array such that the size changes to two elements (0:1). call Publish().\n                // ExpectedResults:\n                // All service and operation level results are Good. Second Publish response contains a DataChangeNotification\n                // with a value.statusCode of Bad_IndexRangeNoData.\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, inner_done) {\n                        samplingInterval = 0; // exception based\n\n                        const nodeId = \"ns=2;s=Static_Array_Int32\";\n\n                        const parameters = {\n                            samplingInterval: 0, // exception based : whenever value changes\n                            discardOldest: false,\n                            queueSize: 2\n                        };\n\n                        const itemToMonitor = new ReadValueId({\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            indexRange: \"2:4\"\n                        });\n\n                        function write_node(value, callback) {\n                            assert(value instanceof Array);\n                            const nodeToWrite = {\n                                nodeId: nodeId,\n                                attributeId: AttributeIds.Value,\n                                value: /*new DataValue(*/ {\n                                    value: {\n                                        /* Variant */\n                                        arrayType: VariantArrayType.Array,\n                                        dataType: DataType.Int32,\n                                        value: new Int32Array(value)\n                                    }\n                                }\n                            };\n                            session.write(nodeToWrite, function (err, statusCode) {\n                                statusCode.should.eql(StatusCodes.Good);\n\n                                session.read(\n                                    {\n                                        attributeId: AttributeIds.Value,\n                                        nodeId: nodeId\n                                    },\n                                    function (err, dataValue) {\n                                        should.exist(dataValue);\n                                        //xxtracelog(\" written \",dataValue.value.toString());\n                                        callback(err);\n                                    }\n                                );\n                            });\n                        }\n\n                        async.series(\n                            [\n                                // write initial value => [1,2,3,4,5,6,7,8,9,10]\n                                write_node.bind(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n\n                                function (callback) {\n                                    createSubscription(session, callback);\n                                },\n\n                                function (callback) {\n                                    createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                                },\n                                function (callback) {\n                                    setTimeout(callback, 100);\n                                },\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        notification.value.statusCode.should.eql(StatusCodes.Good);\n                                        notification.value.value.value.should.eql(new Int32Array([2, 3, 4]));\n                                        callback(err);\n                                    });\n                                },\n\n                                write_node.bind(null, [-1, -2]),\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        notification.value.statusCode.should.eql(StatusCodes.BadIndexRangeNoData);\n                                        should(notification.value.value.value).eql(null);\n                                        callback(err);\n                                    });\n                                },\n\n                                write_node.bind(null, [-1, -2, -3]),\n                                function (callback) {\n                                    setTimeout(callback, 100);\n                                },\n\n                                write_node.bind(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n\n                                function (callback) {\n                                    setTimeout(callback, 100);\n                                },\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        if (!err) {\n                                            response.notificationMessage.notificationData[0].monitoredItems.length.should.be.aboveOrEqual(\n                                                2,\n                                                \"expecting two monitoredItem in  notification data\"\n                                            );\n                                            const notification1 =\n                                                response.notificationMessage.notificationData[0].monitoredItems[0];\n                                            notification1.value.statusCode.should.eql(StatusCodes.Good);\n                                            notification1.value.value.value.should.eql(new Int32Array([-3]));\n                                            const notification2 =\n                                                response.notificationMessage.notificationData[0].monitoredItems[1];\n                                            notification2.value.statusCode.should.eql(StatusCodes.Good);\n                                            notification2.value.value.value.should.eql(new Int32Array([2, 3, 4]));\n                                        }\n                                        callback(err);\n                                    });\n                                },\n\n                                write_node.bind(null, [0, 1, 2, 3]),\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        notification.value.statusCode.should.eql(StatusCodes.Good);\n                                        notification.value.value.value.should.eql(new Int32Array([2, 3]));\n                                        callback(err);\n                                    });\n                                },\n\n                                // restore orignal value\n                                write_node.bind(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n                            ],\n                            inner_done\n                        );\n                    },\n                    done\n                );\n            });\n        });\n\n        it(\"#ModifySubscriptionRequest: should return BadSubscriptionIdInvalid if client specifies a invalid subscriptionId\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const modifySubscriptionRequest = {\n                        subscriptionId: 999\n                    };\n\n                    session.modifySubscription(modifySubscriptionRequest, function (err) {\n                        err.message.should.match(/BadSubscriptionIdInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#ModifySubscriptionRequest: should return StatusGood\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 10,\n                        requestedLifetimeCount: 60000,\n                        requestedMaxKeepAliveCount: 10,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    subscription.on(\"terminated\", function () {\n                        //xx tracelog(chalk.yellow(\" subscription terminated \"));\n                    });\n                    subscription.on(\"started\", function () {\n                        async.series(\n                            [\n                                function (callback) {\n                                    const modifySubscriptionRequest = {\n                                        subscriptionId: subscription.subscriptionId,\n                                        requestedPublishingInterval: 200\n                                    };\n                                    session.modifySubscription(modifySubscriptionRequest, function (err, response) {\n                                        response.revisedPublishingInterval.should.eql(200);\n\n                                        callback(err);\n                                    });\n                                },\n                                function (callback) {\n                                    subscription.terminate(callback);\n                                }\n                            ],\n                            inner_done\n                        );\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return BadSubscriptionIdInvalid when subscriptionId is invalid\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const setMonitoringModeRequest = {\n                        subscriptionId: 999\n                    };\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err) {\n                        err.message.should.match(/BadSubscriptionIdInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return BadNothingToDo if monitoredItemId is empty\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, inner_done) {\n                    const setMonitoringModeRequest = {\n                        subscriptionId: subscription.subscriptionId,\n                        monitoredItemIds: []\n                    };\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err) {\n                        err.message.should.match(/BadNothingToDo/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return BadMonitoredItemIdInvalid is monitoringMode is invalid\", function (done) {\n            const itemToMonitor = \"ns=0;i=2254\"; // temperatureVariableId;\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    const setMonitoringModeRequest = new SetMonitoringModeRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        monitoringMode: MonitoringMode.Reporting,\n                        monitoredItemIds: [monitoredItem.monitoredItemId]\n                    });\n\n                    setMonitoringModeRequest.monitoringMode = 42;\n\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err) {\n                        should.exist(err);\n                        err.message.should.match(/BadMonitoringModeInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return BadMonitoredItemIdInvalid when monitoredItem is invalid\", function (done) {\n            const itemToMonitor = \"ns=0;i=2254\"; // temperatureVariableId;\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    const setMonitoringModeRequest = {\n                        subscriptionId: subscription.subscriptionId,\n                        monitoringMode: MonitoringMode.Sampling,\n                        monitoredItemIds: [monitoredItem.monitoredItemId + 9999]\n                    };\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err, response) {\n                        response.results.length.should.eql(1);\n                        response.results[0].should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n                        inner_done(err);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return Good when request is valid\", function (done) {\n            const itemToMonitor = \"ns=0;i=2254\"; // temperatureVariableId;\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    const setMonitoringModeRequest = {\n                        subscriptionId: subscription.subscriptionId,\n                        monitoringMode: MonitoringMode.Sampling,\n                        monitoredItemIds: [monitoredItem.monitoredItemId]\n                    };\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err, response) {\n                        response.results.length.should.eql(1);\n                        response.results[0].should.eql(StatusCodes.Good);\n                        inner_done(err);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#subscription operations should extend subscription lifetime\", function (done) {\n            this.timeout(Math.max(200000, this.timeout()));\n\n            // see CTT test063\n\n            let monitoredItem;\n\n            function step1(session, subscription, callback) {\n                monitoredItem = ClientMonitoredItem.create(\n                    subscription,\n                    {\n                        nodeId: resolveNodeId(\"ns=0;i=2254\"),\n                        attributeId: AttributeIds.Value\n                    },\n                    {\n                        samplingInterval: 100,\n                        discardOldest: true,\n                        queueSize: 1\n                    }\n                );\n\n                monitoredItem.on(\"initialized\", function () {\n                    callback();\n                });\n            }\n\n            function step2(session, subscription, callback) {\n                const setMonitoringModeRequest = {\n                    subscriptionId: subscription.subscriptionId,\n                    monitoringMode: MonitoringMode.Sampling,\n                    monitoredItemIds: [monitoredItem.monitoredItemId]\n                };\n                session.setMonitoringMode(setMonitoringModeRequest, function (err, response) {\n                    response.results[0].should.eql(StatusCodes.Good);\n                    callback(err);\n                });\n            }\n\n            function step3(session, subcription, callback) {\n                session.deleteSubscriptions(\n                    {\n                        subscriptionIds: [subcription.subscriptionId]\n                    },\n                    function (err, response) {\n                        should.exist(response);\n                        callback(err);\n                    }\n                );\n            }\n\n            const publishingInterval = 100;\n\n            function my_perform_operation_on_subscription(client, endpointUrl, do_func, done_func) {\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, done) {\n                        let subscription;\n                        async.series(\n                            [\n                                function (callback) {\n                                    subscription = ClientSubscription.create(session, {\n                                        requestedPublishingInterval: publishingInterval,\n                                        requestedLifetimeCount: 60,\n                                        requestedMaxKeepAliveCount: 10, // 10 requested here !\n                                        maxNotificationsPerPublish: 2,\n                                        publishingEnabled: true,\n                                        priority: 6\n                                    });\n                                    subscription.on(\"started\", function () {\n                                        callback();\n                                    });\n                                },\n\n                                function (callback) {\n                                    do_func(session, subscription, callback);\n                                },\n\n                                function (callback) {\n                                    subscription.terminate(callback);\n                                }\n                            ],\n                            function (err) {\n                                done(err);\n                            }\n                        );\n                    },\n                    done_func\n                );\n            }\n\n            my_perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, inner_done) {\n                    subscription.publishingInterval.should.eql(publishingInterval);\n                    subscription.maxKeepAliveCount.should.eql(10);\n\n                    const waitingTime = subscription.publishingInterval * (subscription.maxKeepAliveCount - 3) - 100;\n\n                    let nb_keep_alive_received = 0;\n                    subscription.on(\"keepalive\", function () {\n                        nb_keep_alive_received += 1;\n                    });\n\n                    async.series(\n                        [\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(0);\n                                callback();\n                            },\n                            function (callback) {\n                                setTimeout(callback, subscription.publishingInterval * (subscription.maxKeepAliveCount + 2));\n                            },\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(1);\n                                callback();\n                            },\n\n                            function (callback) {\n                                setTimeout(callback, waitingTime);\n                            },\n                            function (callback) {\n                                step1(session, subscription, callback);\n                            },\n\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(2);\n                                callback();\n                            },\n\n                            function (callback) {\n                                setTimeout(callback, waitingTime);\n                            },\n                            function (callback) {\n                                step2(session, subscription, callback);\n                            },\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(2);\n                                callback();\n                            },\n\n                            function (callback) {\n                                setTimeout(callback, waitingTime);\n                            },\n                            function (callback) {\n                                step3(session, subscription, callback);\n                            },\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(2);\n                                callback();\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        describe(\"#Republish\", function () {\n            let VALID_SUBSCRIPTION;\n            let VALID_RETRANSMIT_SEQNUM = 0;\n            const INVALID_SUBSCRIPTION = 1234;\n            const INVALID_RETRANSMIT_SEQNUM = 1234;\n\n            let g_session;\n            let client, fanSpeed;\n            before(function (done) {\n                VALID_RETRANSMIT_SEQNUM = 0;\n\n                client = OPCUAClient.create();\n                fanSpeed = server.engine.addressSpace.findNode(\"ns=1;s=FanSpeed\");\n                should.exist(fanSpeed);\n                //xxx tracelog(fanSpeed.toString());\n                done();\n            });\n\n            function inner_test(the_test_function, done) {\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, inner_done) {\n                        g_session = session;\n                        async.series(\n                            [\n                                function (callback) {\n                                    // CreateSubscriptionRequest\n                                    const request = new CreateSubscriptionRequest({\n                                        requestedPublishingInterval: 100,\n                                        requestedLifetimeCount: 60,\n                                        requestedMaxKeepAliveCount: 10,\n                                        maxNotificationsPerPublish: 2000,\n                                        publishingEnabled: true,\n                                        priority: 6\n                                    });\n                                    g_session.createSubscription(request, function (err, response) {\n                                        if (err) {\n                                            return callback(err);\n                                        }\n                                        VALID_SUBSCRIPTION = response.subscriptionId;\n                                        callback();\n                                    });\n                                },\n\n                                function (callback) {\n                                    // CreateMonitoredItemsRequest\n                                    const request = new CreateMonitoredItemsRequest({\n                                        subscriptionId: VALID_SUBSCRIPTION,\n                                        timestampsToReturn: TimestampsToReturn.Both,\n                                        itemsToCreate: [\n                                            {\n                                                itemToMonitor: {\n                                                    nodeId: fanSpeed.nodeId\n                                                    // nodeId: makeNodeId(VariableIds.Server_ServerStatus_CurrentTime)\n                                                },\n                                                monitoringMode: MonitoringMode.Reporting,\n                                                requestedParameters: {\n                                                    clientHandle: 26,\n                                                    samplingInterval: 10,\n                                                    filter: null,\n                                                    queueSize: 100,\n                                                    discardOldest: true\n                                                }\n                                            }\n                                        ]\n                                    });\n\n                                    g_session.createMonitoredItems(request, function (err, response) {\n                                        response.should.be.instanceof(CreateMonitoredItemsResponse);\n                                        response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                                        response.results.length.should.eql(1);\n                                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n\n                                        callback(err);\n                                    });\n                                },\n\n                                function (callback) {\n                                    fanSpeed.setValueFromSource(new Variant({ dataType: DataType.Double, value: 1 }));\n                                    setTimeout(callback, 50);\n                                    fanSpeed.setValueFromSource(new Variant({ dataType: DataType.Double, value: 2 }));\n                                    //tracelog(fanSpeed.toString());\n                                },\n\n                                //publish_republish,\n\n                                function (callback) {\n                                    // publish request now requires a subscriptions\n                                    const request = new PublishRequest({\n                                        subscriptionAcknowledgements: []\n                                    });\n                                    g_session.publish(request, function (err, response) {\n                                        assert(response instanceof PublishResponse);\n                                        assert(response.availableSequenceNumbers.length > 0);\n                                        VALID_RETRANSMIT_SEQNUM = response.availableSequenceNumbers[0];\n                                        VALID_RETRANSMIT_SEQNUM.should.not.eql(0);\n\n                                        callback(err);\n                                    });\n                                },\n\n                                the_test_function\n                            ],\n                            inner_done\n                        );\n                    },\n                    done\n                );\n            }\n\n            it(\"server should handle Republish request (BadMessageNotAvailable) \", function (done) {\n                inner_test(function (done) {\n                    const request = new RepublishRequest({\n                        subscriptionId: VALID_SUBSCRIPTION,\n                        retransmitSequenceNumber: INVALID_RETRANSMIT_SEQNUM\n                    });\n                    g_session.republish(request, function (err, response) {\n                        should.exist(err);\n                        response.should.be.instanceof(RepublishResponse);\n                        response.responseHeader.serviceResult.should.eql(StatusCodes.BadMessageNotAvailable);\n                        done();\n                    });\n                }, done);\n            });\n\n            it(\"server should handle Republish request (BadSubscriptionIdInvalid) \", function (done) {\n                inner_test(function (done) {\n                    VALID_RETRANSMIT_SEQNUM.should.not.eql(0);\n\n                    const request = new RepublishRequest({\n                        subscriptionId: INVALID_SUBSCRIPTION,\n                        retransmitSequenceNumber: VALID_RETRANSMIT_SEQNUM\n                    });\n                    g_session.republish(request, function (err, response) {\n                        should.exist(err);\n                        response.should.be.instanceof(RepublishResponse);\n                        response.responseHeader.serviceResult.should.eql(StatusCodes.BadSubscriptionIdInvalid);\n                        done();\n                    });\n                }, done);\n            });\n\n            it(\"server should handle Republish request (Good) \", function (done) {\n                inner_test(function (done) {\n                    VALID_RETRANSMIT_SEQNUM.should.not.eql(0);\n\n                    const request = new RepublishRequest({\n                        subscriptionId: VALID_SUBSCRIPTION,\n                        retransmitSequenceNumber: VALID_RETRANSMIT_SEQNUM\n                    });\n\n                    g_session.republish(request, function (err, response) {\n                        response.should.be.instanceof(RepublishResponse);\n                        response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                        done(err);\n                    });\n                }, done);\n            });\n        });\n    });\n};\n", "// Description: CloseSession while specifying DeleteSubscriptions=FALSE. Create a subscription with 1 monitored item.\n// When the session is closed, we are JUST going to close the Session. The subscription and monitoredItem will NOT be cleaned-up.\n// We'll then create another session. We'll try to TRANSFER the subscription to the new session. We're expecting the subscription to be present!\n// We ARE checking if TransferSubscription is Bad_NotImplemented. If so, then the test result is a Warning with a message of Inconclusive. \n\"use strict\";\nconst async = require(\"async\");\nconst should = require(\"should\");\nconst sinon = require(\"sinon\");\n\nconst opcua = require(\"node-opcua\");\nconst StatusCodes = opcua.StatusCodes;\nconst OPCUAClient = opcua.OPCUAClient;\nconst ClientSubscription = opcua.ClientSubscription;\n\n\nconst { perform_operation_on_client_session } = require(\"../../test_helpers/perform_operation_on_client_session\");\n\nconst { perform_operation_on_subscription_with_parameters } = require(\"../../test_helpers/perform_operation_on_client_session\");\n\nmodule.exports = function (test) {\n\n    describe(\"#TSS TransferSessionService\", function () {\n\n        let endpointUrl;\n        beforeEach(function (done) {\n            endpointUrl = test.endpointUrl;\n            done();\n        });\n        let subscription;\n\n        const spy_on_terminated = new sinon.spy();\n\n        function create_subscription_and_close_session(callback) {\n\n            const client = OPCUAClient.create();\n            let the_subscriptionId;\n\n            let the_session;\n\n            async.series([\n\n                function (callback) {\n                    client.connect(endpointUrl, function (err) {\n                        callback(err);\n                    });\n                },\n\n                // create session\n                function (callback) {\n                    client.createSession(function (err, session) {\n                        if (!err) {\n                            the_session = session;\n                        }\n                        callback(err);\n                    });\n                },\n\n                function (callback) {\n                    subscription = ClientSubscription.create(the_session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 10 * 60,\n                        requestedMaxKeepAliveCount: 5,\n                        maxNotificationsPerPublish: 2,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        the_subscriptionId = subscription.subscriptionId;\n                        subscription.on(\"terminated\", spy_on_terminated);\n                        callback();\n                    });\n                },\n\n                // closing session\n                function (callback) {\n                    the_session.close(/*deleteSubscription=*/false, function (err) {\n                        callback(err);\n                    });\n                },\n                function (callback) {\n                    client.disconnect(callback);\n                }\n            ], function (err) {\n                callback(err, the_subscriptionId);\n            });\n        }\n\n        it(\"TSS-1 should transfer a subscription\", function (done) {\n\n            let the_subscriptionId;\n            async.series([\n\n                function (callback) {\n                    create_subscription_and_close_session(function (err, subscriptionId) {\n                        the_subscriptionId = subscriptionId;\n                        callback(err);\n                    });\n                },\n                function (callback) {\n                    //xx console.log(\"SubscriptionId \", the_subscriptionId);\n                    callback();\n                },\n                function (callback) {\n                    const client2 = OPCUAClient.create();\n                    perform_operation_on_client_session(client2, endpointUrl, function (session, done) {\n\n                        session.transferSubscriptions({\n                            subscriptionIds: [the_subscriptionId],\n                            sendInitialValues: true\n                        }, function (err, response) {\n\n                            spy_on_terminated.callCount.should.eql(0);\n                            response.results.length.should.eql(1);\n                            //xx console.log(\" => \", response.results[0].toString());\n\n                            subscription.terminate(function (err1) { done(err); });\n\n                        });\n                    }, function (err) {\n\n                        if (!err) {\n                            spy_on_terminated.callCount.should.eql(1);\n                        }\n                        callback(err);\n                    });\n                }\n            ], done);\n        });\n\n        it(\"TSS-2 should transfer a subscription from a live session to an other\", async () => {\n\n            const client = OPCUAClient.create();\n\n            await client.connect(endpointUrl);\n\n            const the_session1 = await client.createSession();\n\n            subscription = await the_session1.createSubscription2({\n                requestedPublishingInterval: 100,\n                requestedLifetimeCount: 10 * 60,\n                requestedMaxKeepAliveCount: 5,\n                maxNotificationsPerPublish: 2,\n                publishingEnabled: true,\n                priority: 6\n            });\n            subscription.on(\"terminated\", spy_on_terminated);\n\n            const the_subscriptionId = subscription.subscriptionId;\n\n            const the_session2 = await client.createSession();\n\n            try {\n              \n                const response = await the_session2.transferSubscriptions({\n                    subscriptionIds: [the_subscriptionId],\n                    sendInitialValues: true\n                });\n\n                //xx console.log(\"response\",response.toString());\n                response.results.length.should.eql(1);\n                response.results[0].statusCode.should.eql(StatusCodes.Good);\n\n\n                // deleting subscription on session1 shall fail\n                const response1 = await the_session1.deleteSubscriptions({\n                    subscriptionIds: [the_subscriptionId]\n                });\n                response1.results.length.should.eql(1);\n                response1.results[0].should.eql(StatusCodes.BadSubscriptionIdInvalid);\n\n                // deleting subscription on session2 shall succeed\n                const response3 = await the_session2.deleteSubscriptions({\n                    subscriptionIds: [the_subscriptionId]\n                });\n                response3.results.length.should.eql(1);\n                response3.results[0].should.eql(StatusCodes.Good);\n            } finally {\n                // closing session 1\n                await the_session1.close(/*deleteSubscription=*/true);\n                await the_session2.close(/*deleteSubscription=*/true);\n                await client.disconnect();\n            }\n\n        });\n\n        it(\"TSS-3 should send a StatusChangeNotification to the old session with GoodSubscriptionTransferred\", function (done) {\n            const client = OPCUAClient.create();\n            const spy_status_changed = new sinon.spy();\n            let the_session2;\n            const spy_keepalive = new sinon.spy();\n\n            const subscriptionParameters = {\n                requestedPublishingInterval: 100,\n                requestedLifetimeCount: 6000,\n                requestedMaxKeepAliveCount: 10,\n                maxNotificationsPerPublish: 4,\n                publishingEnabled: true,\n                priority: 6\n            };\n            perform_operation_on_subscription_with_parameters(client, endpointUrl, subscriptionParameters,  function (session, subscription, inner_done) {\n\n                subscription.on(\"status_changed\", spy_status_changed);\n                subscription.on(\"keepalive\", spy_keepalive);\n                async.series([\n                    function (callback) {\n\n                        const timeout = subscription.publishingInterval * (subscription.maxKeepAliveCount + 2);\n                        setTimeout(function () {\n                            //xx console.log(\"StatusChange Count \", spy_status_changed.callCount, \" keepAlive count = \", spy_keepalive.callCount);\n                            spy_status_changed.callCount.should.eql(0);\n                            spy_keepalive.callCount.should.be.aboveOrEqual(1);\n                            callback();\n                        }, timeout);\n                    },\n                    function (callback) {\n                        client.createSession(function (err, session) {\n                            if (!err) {\n                                the_session2 = session;\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    function (callback) {\n                        setTimeout(callback, 500);\n                    },\n\n                    // session2.transferSubscriptions\n                    function (callback) {\n                        const options = {\n                            subscriptionIds: [subscription.subscriptionId],\n                            sendInitialValues: true\n                        };\n                        the_session2.transferSubscriptions(options, function (err, response) {\n                            //xx console.log(\"response\",response.toString());\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            if (!err) {\n                                /* */\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    function (callback) {\n                        setTimeout(function () {\n                            //xx console.log(\"StatusChange Count \", spy_status_changed.callCount, \" keepAlive count = \", spy_keepalive.callCount);\n                            spy_status_changed.callCount.should.eql(1);\n                            callback();\n                        }, 1000);\n                    },\n                    function (callback) {\n                        the_session2.close(callback);\n                    }\n\n                ], function (err) {\n                    //xx console.log(\"-------------------\", subscription.subscriptionId);\n                    inner_done(err);\n                });\n\n            }, done);\n\n        });\n\n        it(\"TSS-4 should resend initialValue on monitored Item\", function (done) {\n\n            const client = OPCUAClient.create();\n            let the_session2;\n\n            const itemToMonitor = new opcua.ReadValueId({\n                nodeId: \"ns=2;s=Static_Scalar_Double\",\n                attributeId: opcua.AttributeIds.Value\n            });\n\n            const parameters = {\n                clientHandle: 26,\n                samplingInterval: 250,\n                discardOldest: false,\n                queueSize: 10,\n                filter: null\n            };\n\n\n            const spy_publish_session1 = new sinon.spy();\n            const spy_publish_session2 = new sinon.spy();\n\n            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n\n                let subscriptionId;\n                async.series([\n\n                    // Create Subscription on session1\n                    function (callback) {\n                        const request = new opcua.CreateSubscriptionRequest({\n                            requestedPublishingInterval: 100,\n                            requestedLifetimeCount: 1000,\n                            requestedMaxKeepAliveCount: 30,\n                            maxNotificationsPerPublish: 2000,\n                            publishingEnabled: true,\n                            priority: 6\n                        });\n                        session.createSubscription(request, function (err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            subscriptionId = response.subscriptionId;\n                            callback();\n                        });\n                    },\n\n                    // Create MonitoredItem on session1 with many publish request in queue\n                    function (callback) {\n                        // CreateMonitoredItemsRequest\n                        const request = new opcua.CreateMonitoredItemsRequest({\n                            subscriptionId: subscriptionId,\n                            timestampsToReturn: opcua.TimestampsToReturn.Both,\n                            itemsToCreate: [\n                                {\n                                    itemToMonitor: itemToMonitor,\n                                    monitoringMode: opcua.MonitoringMode.Reporting,\n                                    requestedParameters: parameters\n                                }\n                            ]\n                        });\n\n                        session.createMonitoredItems(request, function (err, response) {\n\n                            response.should.be.instanceof(opcua.CreateMonitoredItemsResponse);\n                            response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].revisedSamplingInterval.should.eql(250);\n\n                            // send many publish requests, in one go\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n\n                            callback(err);\n                        });\n                    },\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(function () {\n                            callback();\n                        }, parameters.samplingInterval);\n                    },\n\n                    // create Session 2\n                    function (callback) {\n                        client.createSession(function (err, l_session) {\n                            if (!err) {\n                                the_session2 = l_session;\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    // session2.transferSubscriptions\n                    function (callback) {\n                        const options = {\n                            subscriptionIds: [subscriptionId],\n                            sendInitialValues: true\n                        };\n                        the_session2.transferSubscriptions(options, function (err, response) {\n                            //xx console.log(\"response\",response.toString());\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            if (!err) {\n                                /** */\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(function () {\n                            callback();\n                        }, parameters.samplingInterval);\n                    },\n\n                    // session 1 should receive StatusChangeNotification\n                    function (callback) {\n\n                        //xx console.log(\"count = \", spy_publish_session1.callCount);\n\n                        const response0 = spy_publish_session1.getCall(0).args[1];\n                        //xx console.log(\"response=\",response0.toString());\n                        response0.notificationMessage.notificationData.length.should.eql(1);\n                        response0.subscriptionId.should.eql(subscriptionId);\n                        const notification0 = response0.notificationMessage.notificationData[0];\n                        notification0.constructor.name.should.eql(\"DataChangeNotification\");\n\n                        const response1 = spy_publish_session1.getCall(1).args[1];\n                        //xx console.log(\"response=\",response1.toString());\n                        response1.notificationMessage.notificationData.length.should.eql(1);\n                        response1.subscriptionId.should.eql(subscriptionId);\n                        const notification1 = response1.notificationMessage.notificationData[0];\n                        notification1.constructor.name.should.eql(\"StatusChangeNotification\");\n\n                        callback();\n                    },\n\n\n                    function (callback) {\n                        the_session2.publish({}, spy_publish_session2);\n                        the_session2.publish({}, spy_publish_session2);\n                        the_session2.publish({}, spy_publish_session2);\n                        the_session2.publish({}, spy_publish_session2);\n                        callback();\n                    },\n\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(function () {\n                            callback();\n                        }, parameters.samplingInterval);\n                    },\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(function () {\n                            callback();\n                        }, parameters.samplingInterval);\n                    },\n\n                    function (callback) {\n                        //Xx console.log(\"count = \", spy_publish_session2.callCount);\n\n                        const response0 = spy_publish_session2.getCall(0).args[1];\n                        //xx console.log(\"response=\",response0.toString());\n                        response0.notificationMessage.notificationData.length.should.eql(1);\n                        response0.subscriptionId.should.eql(subscriptionId);\n                        const notification0 = response0.notificationMessage.notificationData[0];\n                        notification0.constructor.name.should.eql(\"DataChangeNotification\");\n\n                        callback();\n\n                    },\n\n                    // now delete subscription\n                    function (callback) {\n                        the_session2.deleteSubscriptions({ subscriptionIds: [subscriptionId] }, callback);\n                    },\n\n                    function (callback) {\n                        the_session2.close(callback);\n                    },\n                    function (callback) {\n                        //xx console.log(\"count = \", spy_publish_session2.callCount);\n                        spy_publish_session2.callCount.should.eql(4);\n\n                        const response1 = spy_publish_session2.getCall(1).args[1];\n                        const response2 = spy_publish_session2.getCall(2).args[1];\n                        const response3 = spy_publish_session2.getCall(3).args[1];\n\n                        response1.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n                        response2.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n                        response3.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n                        //xx console.log(response1.toString())\n                        //xx console.log(response2.toString())\n                        //xx console.log(response3.toString())\n                        callback();\n                    }\n                ], function (err) {\n                    //xx console.log(\"-------------------\", subscriptionId);\n                    inner_done(err);\n                });\n\n            }, done);\n\n        });\n\n    });\n\n};\n\n", "\"use strict\";\nconst should = require(\"should\");\nconst async = require(\"async\");\n\nconst {\n    BrowseDirection,\n    VariableIds,\n    AttributeIds,\n    StatusCodes,\n    Variant,\n    DataType,\n    DataValue,\n    ReferenceTypeIds,\n    makeNodeId,\n    VariantArrayType,\n    ReadRequest,\n    TimestampsToReturn,\n    OPCUAClient,\n    coerceNodeId\n} = require(\"node-opcua\");\n\nconst fail_fast_connectivity_strategy = {\n    maxRetry: 1,\n    initialDelay: 10,\n    maxDelay: 20,\n    randomisationFactor: 0\n};\n\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\nmodule.exports = function (test) {\n    describe(\"Browse-Read-Write Services\", function () {\n        let g_session = null;\n\n        // use fail fast connectionStrategy\n        const options = { connectionStrategy: fail_fast_connectivity_strategy };\n\n        let client;\n        let endpointUrl;\n        let temperatureVariableId;\n        beforeEach(function (done) {\n            endpointUrl = test.endpointUrl;\n            temperatureVariableId = test.server.temperatureVariableId;\n            client = OPCUAClient.create(options);\n\n            client.connect(endpointUrl, function (err) {\n                if (err) {\n                    done(err);\n                } else {\n                    client.createSession(function (err, session) {\n                        g_session = session;\n                        done(err);\n                    });\n                }\n            });\n        });\n\n        afterEach(function (done) {\n            if (!g_session) {\n                return client.disconnect(done);\n            }\n            g_session.close(function () {\n                client.disconnect(done);\n            });\n        });\n\n        it(\"T8-1 - should browse RootFolder\", function (done) {\n            g_session.browse(\"RootFolder\", function (err, browseResult) {\n                if (!err) {\n                    browseResult.schema.name.should.equal(\"BrowseResult\");\n                }\n\n                // xx console.log(browseResult.toString());//.length.should.eql(4);\n\n                browseResult.statusCode.should.eql(StatusCodes.Good);\n                browseResult.references.length.should.eql(3);\n                browseResult.references[0].browseName.toString().should.eql(\"Objects\");\n                browseResult.references[1].browseName.toString().should.eql(\"Types\");\n                browseResult.references[2].browseName.toString().should.eql(\"Views\");\n\n                done(err);\n            });\n        });\n\n        it(\"T8-2 - browse should return BadReferenceTypeIdInvalid if referenceTypeId is invalid\", function (done) {\n            const bad_referenceid_node = \"ns=3;i=3500\";\n            const nodeToBrowse = {\n                nodeId: \"ObjectsFolder\",\n                referenceTypeId: bad_referenceid_node,\n                browseDirection: BrowseDirection.Forward\n            };\n            g_session.browse(nodeToBrowse, function (err, browseResult /*, diagnosticInfos*/) {\n                browseResult.schema.name.should.equal(\"BrowseResult\");\n                browseResult.statusCode.should.eql(StatusCodes.BadReferenceTypeIdInvalid);\n                done(err);\n            });\n        });\n\n        it(\"T8-3 - should read a Variable\", function (done) {\n            g_session.readVariableValue([\"RootFolder\"], function (err, dataValues /*, diagnosticInfos*/) {\n                if (!err) {\n                    dataValues.length.should.equal(1);\n                    dataValues[0].schema.name.should.equal(\"DataValue\");\n                }\n                done(err);\n            });\n        });\n        it(\"T8-11 - #ReadRequest : server should return BadNothingToDo when nodesToRead is empty\", function (done) {\n            const request = new ReadRequest({\n                nodesToRead: [], //<< EMPTY\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Both\n            });\n\n            g_session.performMessageTransaction(request, function (err /*, response */) {\n                //\n                err.message.should.match(/BadNothingToDo/);\n                done();\n            });\n        });\n\n        it(\"T8-12 - #ReadRequest : server should return BadTimestampsToReturnInvalid when timestampsToReturn is Invalid\", function (done) {\n            const request = new ReadRequest({\n                nodesToRead: [{ nodeId: coerceNodeId(\"ns=0;i=2456\") }],\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Invalid\n            });\n\n            g_session.performMessageTransaction(request, function (err /*, response*/) {\n                //\n                err.message.should.match(/BadTimestampsToReturnInvalid/);\n                done();\n            });\n        });\n\n        it(\"T8-13 - should readAllAttributes - 1 element\", function (done) {\n            g_session.readAllAttributes(\"RootFolder\", function (err, data) {\n                should.not.exist(err);\n                data.nodeId.toString().should.eql(\"ns=0;i=84\");\n                data.statusCode.should.eql(StatusCodes.Good);\n                data.browseName.toString().should.eql(\"Root\");\n                done(err);\n            });\n        });\n\n        it(\"T8-13b - should readAllAttributes - 2 elements\", function (done) {\n            g_session.readAllAttributes([\"RootFolder\", \"ObjectsFolder\"], function (err, data) {\n                data.length.should.eql(2);\n                data[0].browseName.toString().should.eql(\"Root\");\n                data[1].browseName.toString().should.eql(\"Objects\");\n                done(err);\n            });\n        });\n\n        it(\"T8-14a - #readVariableValue should return a appropriate status code if nodeid to read doesn't exists\", function (done) {\n            g_session.readVariableValue(\"ns=1;s=this_node_id_does_not_exist\", function (err, dataValue) {\n                should.not.exist(err);\n                dataValue.statusCode.should.eql(StatusCodes.BadNodeIdUnknown);\n                done();\n            });\n        });\n        it(\"T8-14b - #readVariableValue should return a appropriate status code if nodeid to read doesn't exists\", function (done) {\n            g_session.readVariableValue([\"ns=1;s=this_node_id_does_not_exist\"], function (err, dataValues) {\n                should.not.exist(err);\n                dataValues[0].statusCode.should.eql(StatusCodes.BadNodeIdUnknown);\n                done();\n            });\n        });\n        it(\"T8-15 - #read should return BadNothingToDo when reading an empty nodeToRead array\", function (done) {\n            const nodesToRead = [];\n\n            g_session.read(nodesToRead, function (err, dataValues) {\n                if (err) {\n                    const response = dataValues;\n                    //dataValues.length.should.be(1);\n                    response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                    done();\n                } else {\n                    done(new Error(\"Expecting an error here\"));\n                }\n            });\n        });\n\n        it(\"T8-15b - #read :should return BadNothingToDo if nodesToRead is empty\", function (done) {\n            // CTT : Attribute ERR-011.js\n            const readRequest = new ReadRequest({\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Both,\n                nodesToRead: []\n            });\n\n            g_session.performMessageTransaction(readRequest, function (err /*, response*/) {\n                if (err) {\n                    err.message.should.match(/BadNothingToDo/);\n                    done();\n                } else {\n                    done(new Error(\"expecting BadNothingToDo\"));\n                }\n            });\n        });\n\n        it(\"T8-15c - #read :should return BadNothingToDo if nodesToRead is null\", function (done) {\n            // CTT : Attribute ERR-011.js\n            const readRequest = new ReadRequest({\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Both,\n                nodesToRead: null\n            });\n\n            // make sure nodesToRead is really null !\n            readRequest.nodesToRead = null;\n\n            g_session.performMessageTransaction(readRequest, function (err /*, response*/) {\n                if (err) {\n                    err.message.should.match(/BadNothingToDo/);\n                    done();\n                } else {\n                    done(new Error(\"expecting BadNothingToDo\"));\n                }\n            });\n        });\n\n        it(\"T8-16 - #read should return BadMaxAgeInvalid when Negative MaxAge parameter is specified\", function (done) {\n            const nodesToRead = {\n                nodeId: \"RootFolder\",\n                attributeId: 13\n            };\n\n            g_session.read(nodesToRead, -20000, function (err, dataValue) {\n                if (err) {\n                    //Xx console.log(err);\n                    err.message.should.match(/BadMaxAgeInvalid/);\n                    done();\n                } else {\n                    done(new Error(\"Expecting an error here\"));\n                }\n            });\n        });\n\n        it(\"T8-17 - #readVariableValue - should read the TemperatureTarget value\", function (done) {\n            g_session.readVariableValue([temperatureVariableId.nodeId], function (err, dataValues /*, diagnosticInfos*/) {\n                if (!err) {\n                    dataValues.length.should.equal(1);\n                    dataValues[0].schema.name.should.equal(\"DataValue\");\n                    dataValues[0].value.schema.name.should.equal(\"Variant\");\n                }\n\n                done(err);\n            });\n        });\n\n        it(\"T8-20 - #writeSingleNode -  should write the TemperatureTarget value\", function (done) {\n            // write a single value\n            g_session.write(\n                {\n                    nodeId: temperatureVariableId.nodeId,\n                    attributeId: AttributeIds.Value,\n                    value: {\n                        value: {\n                            dataType: DataType.Double,\n                            value: 37.5\n                        }\n                    }\n                },\n                function (err, statusCode /*,diagnosticInfo*/) {\n                    if (!err) {\n                        statusCode.should.eql(StatusCodes.Good);\n                    }\n                    done(err);\n                }\n            );\n        });\n\n        it(\"T9-1 - Server should expose a 'Server' object in the 'Objects' folder\", function (done) {\n            const Organizes = makeNodeId(ReferenceTypeIds.Organizes); // \"ns=0;i=35\";\n            const nodesToBrowse = [\n                {\n                    nodeId: \"ObjectsFolder\",\n                    referenceTypeId: Organizes,\n                    browseDirection: BrowseDirection.Forward,\n                    resultMask: 0x3f\n                }\n            ];\n\n            g_session.browse(nodesToBrowse, function (err, browseResults /*,diagnosticInfos*/) {\n                if (!err) {\n                    browseResults.length.should.equal(1);\n                    browseResults[0].schema.name.should.equal(\"BrowseResult\");\n\n                    //xx console.log(util.inspect(browseResults[0].references,{colors:true,depth:10}));\n\n                    const foundNode = browseResults[0].references.filter((result) => result.browseName.name === \"Server\");\n\n                    foundNode.length.should.equal(1);\n                    foundNode[0].browseName.name.should.equal(\"Server\");\n                    foundNode[0].nodeId.toString().should.equal(\"ns=0;i=2253\");\n                }\n                done(err);\n            });\n        });\n\n        it(\"T9-2 - Server should expose 'Server_NamespaceArray' variable \", function (done) {\n            const server_NamespaceArray_Id = makeNodeId(VariableIds.Server_NamespaceArray); // ns=0;i=2255\n            g_session.readVariableValue(server_NamespaceArray_Id, function (err, dataValue /*, diagnosticsInfo*/) {\n                if (err) {\n                    return done(err);\n                }\n                dataValue.should.be.instanceOf(DataValue);\n                dataValue.statusCode.should.eql(StatusCodes.Good);\n                dataValue.value.dataType.should.eql(DataType.String);\n                dataValue.value.arrayType.should.eql(VariantArrayType.Array);\n\n                // first namespace must be standard OPC namespace\n                dataValue.value.value[0].should.eql(\"http://opcfoundation.org/UA/\");\n\n                done(err);\n            });\n        });\n\n        it(\"T9-3 - ServerStatus object shall be accessible as a ExtensionObject\", function (done) {\n            const server_NamespaceArray_Id = makeNodeId(VariableIds.Server_ServerStatus); // ns=0;i=2255\n            g_session.readVariableValue(server_NamespaceArray_Id, function (err, dataValue /*, diagnosticsInfo*/) {\n                if (err) {\n                    return done(err);\n                }\n                dataValue.should.be.instanceOf(DataValue);\n                dataValue.statusCode.should.eql(StatusCodes.Good);\n                dataValue.value.dataType.should.eql(DataType.ExtensionObject);\n\n                done(err);\n            });\n        });\n    });\n};\n", "\"use strict\";\nconst should = require(\"should\");\nconst async = require(\"async\");\n\nconst { perform_operation_on_client_session } = require(\"../../test_helpers/perform_operation_on_client_session\");\n\nconst opcua = require(\"node-opcua\");\nconst StatusCodes = opcua.StatusCodes;\nconst OPCUAClient = opcua.OPCUAClient;\nconst UnregisterNodesRequest = opcua.UnregisterNodesRequest;\nconst RegisterNodesRequest = opcua.RegisterNodesRequest;\nconst AttributeIds = opcua.AttributeIds;\nconst DataType = opcua.DataType;\n\nmodule.exports = function (test) {\n\n    describe(\"end-to-end testing registerNodes\", function () {\n\n        let client, endpointUrl;\n\n        beforeEach(function (done) {\n            client = OPCUAClient.create({});\n            endpointUrl = test.endpointUrl;\n            done();\n        });\n\n        afterEach(function (done) {\n            client = null;\n            done();\n        });\n\n        it(\"should register nodes - BadNothingToDo\", function (done) {\n\n            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n\n                const request = new RegisterNodesRequest({\n                    nodesToRegister: []\n                });\n                session.performMessageTransaction(request, function (err/*, response*/) {\n                    err.message.should.match(/BadNothingToDo/);\n                    inner_done();\n                });\n\n            }, done);\n        });\n\n        it(\"should register nodes - Good\", function (done) {\n\n            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n\n                const request = new RegisterNodesRequest({\n                    nodesToRegister: [\n                        \"ns=0;i=1\"\n                    ]\n                });\n                session.performMessageTransaction(request, function (err, response) {\n                    should.not.exist(err);\n                    response.registeredNodeIds.length.should.eql(1);\n                    inner_done();\n                });\n\n            }, done);\n        });\n\n        it(\"should unregister nodes - BadNothingToDo\", function (done) {\n            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n\n                const request = new UnregisterNodesRequest({\n                    nodesToUnregister: []\n                });\n                session.performMessageTransaction(request, function (err, response) {\n                    should.exist(response);\n                    err.message.should.match(/BadNothingToDo/);\n                    inner_done();\n                });\n\n            }, done);\n        });\n\n        it(\"should unregister nodes - Good\", function (done) {\n            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n\n                const request = new UnregisterNodesRequest({\n                    nodesToUnregister: [\n                        \"ns=0;i=1\"\n                    ]\n                });\n                session.performMessageTransaction(request, function (err, response) {\n                    should.exist(response);\n                    should.not.exist(err);\n                    inner_done();\n                });\n\n            }, done);\n        });\n\n\n        it(\"should register nodes and provide a alias that can be used on all operations\", function (done) {\n            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n\n                const nodesToRegister = [\"ns=2;s=Static_Scalar_Double\"];\n                let registeredNodeIds = [];\n                let dataValue1, dataValue2;\n                async.series([\n                    function register_some_node(callback) {\n\n                        session.registerNodes(nodesToRegister, function (err, _registeredNodeIds) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            registeredNodeIds = _registeredNodeIds;\n                            callback();\n                        });\n                    },\n                    function (callback) {\n\n                        const nodeToWrite = {\n                            nodeId: registeredNodeIds[0],\n                            attributeId: AttributeIds.Value,\n                            value: {value: {dataType: DataType.Double, value: 1000}}\n                        };\n                        session.write(nodeToWrite, function (err, statusCode) {\n                            statusCode.should.eql(StatusCodes.Good);\n                            callback(err);\n                        });\n                    },\n                    function (callback) {\n                        const nodeToRead = {nodeId: nodesToRegister[0], attributeId: 13};\n                        session.read(nodeToRead, function (err, dataValue) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            dataValue.statusCode.should.eql(StatusCodes.Good);\n                            dataValue1 = dataValue;\n                            callback();\n                        });\n                    },\n                    function (callback) {\n                        const nodeToRead = {nodeId: registeredNodeIds[0], attributeId: 13};\n                        session.read(nodeToRead, function (err, dataValue) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            dataValue.statusCode.should.eql(StatusCodes.Good);\n                            dataValue2 = dataValue;\n                            callback();\n                        });\n                    },\n                    function (callback) {\n                        registeredNodeIds[0].toString().should.not.eql(nodesToRegister[0].toString());\n                        dataValue1.statusCode.toString().should.eql(dataValue2.statusCode.toString());\n\n                        //xx console.log(dataValue1.toString());\n                        //xx console.log(dataValue2.toString());\n\n                        dataValue1.value.toString().should.eql(dataValue2.value.toString());\n                        callback();\n                    }\n                ], inner_done);\n\n            }, done);\n        });\n    });\n};\n", "// tslint:disable: no-shadowed-variable\n// tslint:disable: no-console\nimport {\n    AddressSpace,\n    assert,\n    AttributeIds,\n    ClientMonitoredItem,\n    ClientSession,\n    ClientSessionRawSubscriptionService,\n    ClientSidePublishEngine,\n    ClientSubscription,\n    coerceNodeId,\n    DataChangeFilter,\n    DataChangeNotification,\n    DataChangeTrigger,\n    DataType,\n    DataValue,\n    DeadbandType,\n    ExtensionObject,\n    getCurrentClock,\n    makeBrowsePath,\n    MonitoredItem,\n    MonitoredItemNotification,\n    MonitoringMode,\n    MonitoringParametersOptions,\n    Namespace,\n    NodeIdLike,\n    NotificationMessage,\n    OPCUAClient,\n    Range,\n    ServerSidePublishEngine,\n    SetTriggeringRequestOptions,\n    StatusCode,\n    StatusCodes,\n    TimestampsToReturn,\n    UAVariable\n} from \"node-opcua\";\nimport * as sinon from \"sinon\";\nimport * as should from \"should\";\n\nimport { make_debugLog, checkDebugFlag } from \"node-opcua-debug\";\nconst debugLog = make_debugLog(\"TEST\");\nconst doDebug = checkDebugFlag(\"TEST\");\n\nasync function pause(delay: number): Promise<void> {\n    await new Promise((resolve) => setTimeout(resolve, delay));\n}\n\ninterface ClientSidePublishEnginePrivate extends ClientSidePublishEngine {\n    internalSendPublishRequest(): void;\n    suspend(suspend: boolean): void;\n}\nfunction getInternalPublishEngine(session: ClientSession): ClientSidePublishEnginePrivate {\n    const s: ClientSidePublishEnginePrivate = (session as any).getPublishEngine();\n    return s;\n}\nexport function t(test: any) {\n    const options = {};\n\n    async function createSession() {\n        const client = OPCUAClient.create(options);\n        const endpointUrl = test.endpointUrl;\n        await client.connect(endpointUrl);\n        const session = await client.createSession();\n\n        const publishEngine = getInternalPublishEngine(session);\n        publishEngine.timeoutHint = 100000000; // for debugging with ease !\n        // make sure we control how PublishRequest are send\n        publishEngine.suspend(true);\n\n        // create a subscriptions\n        const subscription = ClientSubscription.create(session, {\n            publishingEnabled: true,\n            requestedLifetimeCount: 20,\n            requestedMaxKeepAliveCount: 3,\n            requestedPublishingInterval: 100\n        });\n\n        return { client, session, subscription, publishEngine };\n    }\n    interface Connection {\n        client: OPCUAClient;\n        session: ClientSession;\n        subscription: ClientSubscription;\n        publishEngine: ClientSidePublishEnginePrivate;\n    }\n    let s: Connection;\n    async function waitForRawNotifications(): Promise<ExtensionObject[]> {\n        const { publishEngine, subscription } = s;\n        publishEngine.internalSendPublishRequest();\n        return await new Promise((resolve: (result: ExtensionObject[]) => void) => {\n            // wait for fist notification\n            subscription.once(\"raw_notification\", (notificationMessage: any) => {\n                // tslint:disable-next-line: no-console\n                debugLog(\"got notification message \", notificationMessage.toString());\n                resolve(notificationMessage.notificationData);\n            });\n        });\n    }\n    async function waitForNotificationsValues(): Promise<{ value: number; statusCode: StatusCode }[]> {\n        while (true) {\n            const notificationData1 = await waitForRawNotifications();\n            if (notificationData1.length > 0) {\n                const dcn = notificationData1[0] as DataChangeNotification;\n                const r = dcn.monitoredItems!.map((item: MonitoredItemNotification) => ({\n                    statusCode: item.value.statusCode,\n                    value: item.value.value.value\n                }));\n                return r;\n            }\n            // tslint:disable-next-line: no-console\n            debugLog(\" ------- skipping empty publish response\");\n            return [];\n        }\n    }\n    async function incrementValue(nodeId: NodeIdLike) {\n        const { session } = s;\n        const dataValue = await session.read({ nodeId, attributeId: AttributeIds.Value });\n\n        dataValue.value.value += 1;\n\n        {\n            const statusCode = await session.write({\n                attributeId: AttributeIds.Value,\n                nodeId,\n                value: dataValue\n            });\n            statusCode.should.eql(StatusCodes.Good);\n        }\n    }\n    async function waitUntilKeepAlive(publishEngine: ClientSidePublishEngine, subscription: ClientSubscription) {\n        publishEngine.internalSendPublishRequest();\n        publishEngine.internalSendPublishRequest();\n        publishEngine.internalSendPublishRequest();\n        // wait until next keep alive\n        await new Promise<void>((resolve) => {\n            subscription.once(\"keepalive\", () => resolve());\n        });\n    }\n\n    const valueTriggeringNodeId = \"ns=1;s=ValueTriggering\";\n    const linkedValue1NodeId = \"ns=1;s=LinkedValue1\";\n    const linkedValue2NodeId = \"ns=1;s=LinkedValue2\";\n\n    const describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n    describe(\"SetTriggering\", function (this: any) {\n        this.timeout(Math.max(200000, this.timeout()));\n\n        before(() => {\n            const addressSpace = test.server.engine.addressSpace as AddressSpace;\n            const namespace = test.server.engine.addressSpace.getOwnNamespace() as Namespace;\n\n            const n = namespace.addAnalogDataItem({\n                browseName: \"ValueTriggering\",\n                componentOf: addressSpace.rootFolder.objects.server,\n                dataType: \"Double\",\n                engineeringUnitsRange: { low: -100, high: 200 },\n                nodeId: \"s=ValueTriggering\"\n            });\n            valueTriggeringNodeId.should.eql(n.nodeId.toString());\n\n            const n2 = namespace.addVariable({\n                browseName: \"LinkedValue1\",\n                componentOf: addressSpace.rootFolder.objects.server,\n                dataType: \"Double\",\n                nodeId: \"s=LinkedValue1\"\n            });\n            linkedValue1NodeId.should.eql(n2.nodeId.toString());\n\n            const n3 = namespace.addVariable({\n                browseName: \"LinkedValue2\",\n                componentOf: addressSpace.rootFolder.objects.server,\n                dataType: \"Double\",\n                nodeId: \"s=LinkedValue2\"\n            });\n            linkedValue2NodeId.should.eql(n3.nodeId.toString());\n        });\n        beforeEach(async () => {\n            const addressSpace = test.server.engine.addressSpace as AddressSpace;\n            const n = addressSpace.findNode(valueTriggeringNodeId)! as UAVariable;\n            n.setValueFromSource({ dataType: DataType.Double, value: 1 }, StatusCodes.Good);\n\n            const n2 = addressSpace.findNode(linkedValue1NodeId)! as UAVariable;\n            n2.setValueFromSource({ dataType: DataType.Double, value: 1000 }, StatusCodes.Good);\n\n            const n3 = addressSpace.findNode(linkedValue2NodeId)! as UAVariable;\n            n3.setValueFromSource({ dataType: DataType.Double, value: 2000 }, StatusCodes.Good);\n\n            s = await createSession();\n        });\n        afterEach(async () => {\n            await s.subscription.terminate();\n            await s.session.close();\n            await s.client.disconnect();\n        });\n\n        const changeSpy = sinon.spy();\n        async function createMonitoredItem(nodeId: NodeIdLike, monitoringMode: MonitoringMode): Promise<ClientMonitoredItem> {\n            const { session, subscription, publishEngine } = s as Connection;\n\n            const readValue = {\n                attributeId: AttributeIds.Value,\n                nodeId\n            };\n            const requestedParameters: MonitoringParametersOptions = {\n                discardOldest: true,\n                queueSize: 1,\n                samplingInterval: 10\n            };\n            const monitoredItem = await subscription.monitor(\n                readValue,\n                requestedParameters,\n                TimestampsToReturn.Both,\n                monitoringMode\n            );\n\n            if (monitoringMode === MonitoringMode.Reporting) {\n                await new Promise((resolve: any) => {\n                    // wait for fist notification\n                    monitoredItem.once(\"changed\", (dataValue) => {\n                        // tslint:disable-next-line: no-console\n                        debugLog(\"got initial value !!! \", dataValue.value.value);\n                        resolve();\n                    });\n                    s.publishEngine.internalSendPublishRequest();\n                });\n            } else {\n                s.publishEngine.internalSendPublishRequest();\n            }\n            monitoredItem.on(\"changed\", changeSpy);\n            return monitoredItem;\n        }\n\n        it(\"SetTriggering-1 it should return BadNothingToDo if both linksToAdd and linksToRemove are empty\", async () => {\n            const { session, subscription, publishEngine } = s;\n            const t = await createMonitoredItem(valueTriggeringNodeId, MonitoringMode.Reporting);\n            const l1 = await createMonitoredItem(linkedValue1NodeId, MonitoringMode.Sampling);\n            const l2 = await createMonitoredItem(linkedValue2NodeId, MonitoringMode.Sampling);\n\n            let _err!: Error;\n\n            try {\n                const result = await subscription.setTriggering(t, [], []);\n\n                //  console.log(result.toString());\n\n                result.removeResults?.length.should.eql(0);\n                result.addResults?.length.should.eql(0);\n                result.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n            } catch (err) {\n                _err = err as Error;\n            }\n            should.not.exist(_err, \"not expecting any exception\");\n\n            /*\n             */\n        });\n        it(\"SetTriggering-2 it should return BadNothingToDo if both linksToAdd and linksToRemove are empty\", async () => {\n            const { session, subscription, publishEngine } = s;\n            const t = await createMonitoredItem(valueTriggeringNodeId, MonitoringMode.Reporting);\n\n            let _err!: Error;\n\n            try {\n                const request: SetTriggeringRequestOptions = {\n                    linksToAdd: [0xdeadbeef],\n                    linksToRemove: [0xc0cac01a],\n                    subscriptionId: subscription.subscriptionId,\n                    triggeringItemId: t.monitoredItemId\n                };\n                const session2 = (session as unknown) as ClientSessionRawSubscriptionService;\n                const result = await session2.setTriggering(request);\n                result.removeResults?.length.should.eql(1);\n                result.addResults?.length.should.eql(1);\n                result.removeResults![0].should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n                result.addResults![0].should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n                result.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                // console.log(result.toString());\n            } catch (err) {\n                console.log(err);\n                _err = err as Error;\n            }\n            should.not.exist(_err, \"not expecting any an exception\");\n        });\n\n        it(\"SetTriggering-3 it should return BadNothingToDo if both linksToAdd and linksToRemove are empty\", async () => {\n            const { session, subscription, publishEngine } = s;\n            const t = await createMonitoredItem(valueTriggeringNodeId, MonitoringMode.Reporting);\n            const l1 = await createMonitoredItem(linkedValue1NodeId, MonitoringMode.Sampling);\n            const l2 = await createMonitoredItem(linkedValue2NodeId, MonitoringMode.Sampling);\n\n            const raw_notification_spy = sinon.spy();\n            subscription.on(\"raw_notification\", raw_notification_spy);\n            raw_notification_spy.resetHistory();\n            await incrementValue(valueTriggeringNodeId);\n\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must have received a changed notification and one empty notif\");\n\n            raw_notification_spy.resetHistory();\n            await incrementValue(linkedValue1NodeId);\n            await incrementValue(linkedValue2NodeId);\n            await incrementValue(valueTriggeringNodeId);\n\n            await pause(100);\n\n            // wait until next keep alive\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(1);\n\n                monitoredItems[0].clientHandle.should.eql(t.monitoringParameters.clientHandle);\n            }\n            // ------------------------------ Now create triggering\n\n            await subscription.setTriggering(t, [l1, l2], null);\n\n            // ------------------------------ verify that triggers now happen\n            raw_notification_spy.resetHistory();\n            await incrementValue(linkedValue1NodeId);\n            await incrementValue(linkedValue2NodeId);\n            await incrementValue(valueTriggeringNodeId);\n\n            await pause(50);\n            // wait until next keep alive\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must  have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(3);\n\n                monitoredItems[0].clientHandle.should.eql(t.monitoringParameters.clientHandle);\n                monitoredItems[1].clientHandle.should.eql(l1.monitoringParameters.clientHandle);\n                monitoredItems[2].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n            }\n\n            /// ------------------------- Do it again\n            raw_notification_spy.resetHistory();\n            await incrementValue(linkedValue1NodeId);\n            await incrementValue(linkedValue2NodeId);\n            await incrementValue(valueTriggeringNodeId);\n\n            await pause(50);\n            // wait until next keep alive\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must  have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(3);\n\n                monitoredItems[0].clientHandle.should.eql(t.monitoringParameters.clientHandle);\n                monitoredItems[1].clientHandle.should.eql(l1.monitoringParameters.clientHandle);\n                monitoredItems[2].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n            }\n\n            // --------------------------- Now remove one element\n            await subscription.setTriggering(t, [], [l1]);\n            // ------------------------------ verify that triggers now happen\n            raw_notification_spy.resetHistory();\n            await incrementValue(linkedValue1NodeId);\n            await incrementValue(linkedValue2NodeId);\n            await incrementValue(valueTriggeringNodeId);\n\n            await pause(50);\n            // wait until next keep alive\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(2);\n\n                monitoredItems[0].clientHandle.should.eql(t.monitoringParameters.clientHandle);\n                monitoredItems[1].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n            }\n        });\n        it(\"SetTriggering-4: Deadband testing of Linked items.\", async () => {\n            // note: based on 020.js in CTT ( set)\n            const { session, subscription, publishEngine } = s;\n\n            const raw_notification_spy = sinon.spy();\n            subscription.on(\"raw_notification\", raw_notification_spy);\n\n            const namespaceArray = await session.readNamespaceArray();\n            const simulationNamespaceIndex = namespaceArray.indexOf(\"urn://node-opcua-simulator\");\n            console.log(\"simulationNamespaceIndex = \", simulationNamespaceIndex);\n\n            const triggerNodeId = coerceNodeId(`ns=${simulationNamespaceIndex};s=Static_Scalar_UInt16`);\n            const linkedNodeId1 = coerceNodeId(`ns=${simulationNamespaceIndex};s=Static_Scalar_Byte`);\n            const linkedNodeId2 = coerceNodeId(`ns=${simulationNamespaceIndex};s=Static_Scalar_Float`);\n\n            // create monitored items\n            let m1: ClientMonitoredItem;\n            let l1: ClientMonitoredItem;\n            let l2: ClientMonitoredItem;\n\n            {\n                m1 = await subscription.monitor(\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: 13\n                    },\n                    {\n                        discardOldest: true,\n                        queueSize: 1,\n                        samplingInterval: 0,\n                        filter: null\n                    },\n                    TimestampsToReturn.Both,\n                    MonitoringMode.Reporting\n                );\n                l1 = await subscription.monitor(\n                    {\n                        nodeId: linkedNodeId1,\n                        attributeId: 13\n                    },\n                    {\n                        discardOldest: true,\n                        queueSize: 1,\n                        samplingInterval: 0,\n                        filter: new DataChangeFilter({\n                            deadbandType: DeadbandType.Absolute,\n                            deadbandValue: 5,\n                            trigger: DataChangeTrigger.StatusValue,\n                        })\n                    },\n                    TimestampsToReturn.Both,\n                    MonitoringMode.Sampling\n                );\n                l2 = await subscription.monitor(\n                    {\n                        nodeId: linkedNodeId2,\n                        attributeId: 13\n                    },\n                    {\n                        discardOldest: true,\n                        queueSize: 1,\n                        samplingInterval: 0,\n                        filter: new DataChangeFilter({\n                            deadbandType: DeadbandType.Absolute,\n                            deadbandValue: 0.5,\n                            trigger: DataChangeTrigger.StatusValue\n                        })\n                    },\n                    TimestampsToReturn.Both,\n                    MonitoringMode.Sampling\n                );\n            }\n\n            let m1Value = 100;\n            let l1Value = 100;\n            let l2Value = 100;\n            // write initial values\n            {\n                const statusCodes = await session.write([\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.UInt16, value: m1Value } }\n                    },\n                    {\n                        nodeId: linkedNodeId1,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.Byte, value: l1Value } }\n                    },\n                    {\n                        nodeId: linkedNodeId2,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.Float, value: l2Value } }\n                    }\n                ]);\n                statusCodes.should.eql([StatusCodes.Good, StatusCodes.Good, StatusCodes.Good]);\n            }\n\n            // setLinks\n            const result = await subscription.setTriggering(m1, [l1, l2], []);\n            result.addResults!.should.eql([StatusCodes.Good, StatusCodes.Good]);\n\n            await waitUntilKeepAlive(publishEngine, subscription);\n            raw_notification_spy.resetHistory();\n\n            m1Value += 1;\n            {\n                const statusCodes = await session.write([\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.UInt16, value: m1Value } }\n                    }\n                ]);\n            }\n\n            await waitUntilKeepAlive(publishEngine, subscription);\n            raw_notification_spy.callCount.should.eql(2, \"must  have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(3);\n\n                monitoredItems[0].clientHandle.should.eql(m1.monitoringParameters.clientHandle);\n                monitoredItems[1].clientHandle.should.eql(l1.monitoringParameters.clientHandle);\n                monitoredItems[2].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n            }\n\n            const deadbandValuesInt = [0, 6, 7, 6, 20];\n            const deadbandValuesFloat = [0.0, 0.6, 0.5, 0.6, 1.5];\n            const successes = [true, true, false, false, true];\n\n            for (let i = 0; i < deadbandValuesInt.length; i++) {\n                // console.log(\"############################################### =>\", i);\n                raw_notification_spy.resetHistory();\n\n                m1Value += 1;\n                l1Value = deadbandValuesInt[i];\n                l2Value = deadbandValuesFloat[i];\n                await session.write([\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.UInt16, value: m1Value } }\n                    },\n                    {\n                        nodeId: linkedNodeId1,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.Byte, value: l1Value } }\n                    },\n                    {\n                        nodeId: linkedNodeId2,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.Float, value: l2Value } }\n                    }\n                ]);\n                const dataValuesVerif = await session.read([\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: AttributeIds.Value\n                    },\n                    {\n                        nodeId: linkedNodeId1,\n                        attributeId: AttributeIds.Value\n                    },\n                    {\n                        nodeId: linkedNodeId2,\n                        attributeId: AttributeIds.Value\n                    }\n                ]);\n                dataValuesVerif[0].value.value.should.eql(m1Value);\n                dataValuesVerif[1].value.value.should.eql(l1Value);\n               Math.abs(dataValuesVerif[2].value.value - l2Value).should.be.lessThan(1E-6);\n\n                await pause(10);\n                await waitUntilKeepAlive(publishEngine, subscription);\n\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                if (successes[i]) {\n                    monitoredItems.length.should.eql(3);\n\n                    monitoredItems[0].clientHandle.should.eql(m1.monitoringParameters.clientHandle);\n                    monitoredItems[1].clientHandle.should.eql(l1.monitoringParameters.clientHandle);\n                    monitoredItems[2].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n                } else {\n                    monitoredItems.length.should.eql(1);\n                    monitoredItems[0].clientHandle.should.eql(m1.monitoringParameters.clientHandle);\n                }\n            }\n        });\n    });\n}\n", "\"use strict\";\nconst async = require(\"async\");\n/* global describe,it,before,after,beforeEach,afterEach*/\n\nconst {\n    OPCUAClient,\n    ReadRequest,\n    TimestampsToReturn,\n    StatusCodes\n} = require(\"node-opcua\");\n\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n\nmodule.exports = function(test) {\n\n    let client;\n    describe(\"SNAC Testing client accessing service before session is activated \", function() {\n\n        beforeEach(function(done) {\n            client = OPCUAClient.create();\n            done();\n        });\n        afterEach(function(done) {\n            client = null;\n            done();\n        });\n\n        it(\"SNAC1- should return BadSessionNotActivated when service is called before session is activated\", (done) => {\n\n            let session1;\n            let last_response;\n            let activate_error;\n            async.series([\n\n                function(callback) {\n                    client.connect(test.endpointUrl, callback);\n                },\n                function(callback) {\n                    client._createSession(function(err, session) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        session1 = session;\n                        callback();\n                    });\n                },\n                // let verify that it is now possible to send a request on client1's session\n                function(callback) {\n                    // coerce nodeIds\n                    const request = new ReadRequest({\n                        nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n                        maxAge: 0,\n                        timestampsToReturn: TimestampsToReturn.Both\n                    });\n                    request.requestHeader.authenticationToken = session1.authenticationToken;\n\n                    client.performMessageTransaction(request, function(err, response) {\n                        console.log(err ? err.toString() : \"null\");\n                        console.log(response ? response.toString() : \"null\");\n                        last_response = response;\n                        callback();\n                    });\n                },\n                // verify the session can no longer be used\n                function(callback) {\n                    client._activateSession(session1,(err) => {\n                        activate_error = err;\n                        // BadSessionIdInvalid, BadSessionClosed\n                        callback();\n                    });\n                },\n\n                function(callback) {\n                    client.closeSession(session1, true, callback);\n                },\n                function(callback) {\n                    console.log(\"disconnecting\")\n                    client.disconnect(callback);\n                }\n            ], (err) => {\n                if (err) {\n                    return done(err);\n                }\n                last_response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionNotActivated);\n                should.exist(activate_error, \n                    \"Activate Session should return an error if there has been an attempt to use it before being activated\");\n                activate_error.message.should.match(/BadSessionIdInvalid|BadSessionClosed/);\n                done();\n            });\n        });\n\n    });\n}\n\n", "\"use strict\";\nconst should = require(\"should\");\nconst async = require(\"async\");\nconst _ = require(\"underscore\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\n\nconst { \n  OPCUAClient, \n  StatusCodes, \n  PublishRequest,\n  CreateSubscriptionRequest,\n  CloseSessionRequest,\n  ReadRequest,\n  TimestampsToReturn, \n  MessageSecurityMode,\n  SecurityPolicy,\n  UserNameIdentityToken\n} = require(\"node-opcua\");\nconst {\n  readCertificate,\n  readCertificateRevocationList\n} = require(\"node-opcua-crypto\");\n\nconst certificateFolder = path.join(__dirname, \"../../../node-opcua-samples/certificates\");\nfs.existsSync(certificateFolder).should.eql(true, \"expecting certificate store at \" + certificateFolder);\n\nfunction sendPublishRequest(session, callback) {\n  const publishRequest = new PublishRequest({});\n  session.performMessageTransaction(publishRequest, function(err, response) {\n    callback(err, response);\n  });\n}\n\nfunction createSubscription(session, callback) {\n  const publishingInterval = 1000;\n  const createSubscriptionRequest = new CreateSubscriptionRequest({\n    requestedPublishingInterval: publishingInterval,\n    requestedLifetimeCount: 60,\n    requestedMaxKeepAliveCount: 10,\n    maxNotificationsPerPublish: 10,\n    publishingEnabled: true,\n    priority: 6\n  });\n\n  session.performMessageTransaction(createSubscriptionRequest, function(err/*, response*/) {\n    callback(err);\n  });\n}\n\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n\nmodule.exports = function(test) {\n\n  describe(\"testing session  transfer to different channel\", function() {\n\n    it(\"RQC1 - It should be possible to close a session that has not be activated yet\", function(done) {\n      let client1;\n      let session1;\n      async.series([\n\n        function(callback) {\n          client1 = OPCUAClient.create({});\n          client1.connect(test.endpointUrl, callback);\n        },\n\n        // create a session using client1, without activating it\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          client1._createSession(function(err, session) {\n            if (err) {\n              return callback(err);\n            }\n            session1 = session;\n            callback();\n          });\n        },\n\n        function(callback) {\n\n          // Question: ? Should a unactivated session be accounted for\n          //             in the currentSessionCount ?\n          test.server.engine.currentSessionCount.should.eql(1);\n\n          // however client shall not record session yet\n          client1._sessions.length.should.eql(0);\n\n          // in fact, let make sure that close Session is not harmfull\n          client1.closeSession(session1, /* deleteSubscriptions =*/true, function(err) {\n            client1._sessions.length.should.eql(0);\n            if (err) {\n              // if treated as a Failure , close session expected to return BadSessionNotActivated\n              err.message.match(/BadSessionNotActivated/);\n            }\n            callback();\n          });\n\n        },\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          callback();\n        },\n        function(callback) {\n          client1.disconnect(callback);\n        }\n      ], done);\n\n    });\n\n    it(\"RQB1 - calling CreateSession and CloseSession &  CloseSession again should return BadSessionIdInvalid\", function(done) {\n      let client1;\n      let session1;\n      async.series([\n\n        function(callback) {\n          client1 = OPCUAClient.create();\n          client1.connect(test.endpointUrl, callback);\n        },\n        // create a session using client1\n        function(callback) {\n          client1._createSession(function(err, session) {\n            if (err) {\n              return callback(err);\n            }\n            session1 = session;\n            callback();\n          });\n        },\n\n        function(callback) {\n          session1.close(function() {\n            callback();\n          });\n        },\n        function(callback) {\n          session1.close(function(err) {\n            // now session close do not return error if session in invalid\n            // err.message.should.match(/SessionIdInvalid/);\n            should.not.exist(err);\n            callback();\n          });\n        },\n        //\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          client1.disconnect(callback);\n        }\n\n      ], done);\n\n    });\n\n    it(\"RQB2 - calling CloseSession without calling CreateSession first\", function(done) {\n      let client1;\n\n      async.series([\n\n        function(callback) {\n          client1 = OPCUAClient.create({});\n          client1.connect(test.endpointUrl, callback);\n        },\n        function(callback) {\n          const request = new CloseSessionRequest({\n            deleteSubscriptions: true\n          });\n          client1.performMessageTransaction(request, function(err, response) {\n            should.not.exist(err);\n            //err.message.should.match(/BadSessionIdInvalid/);\n            response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionIdInvalid);\n            callback();\n          });\n        },\n        function(callback) {\n          client1.disconnect(callback);\n        },\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          callback();\n        }\n      ], done);\n\n    });\n\n    it(\"RQB3 - calling CreateSession,  CloseSession  and CloseSession again\", function(done) {\n      let client1;\n      let session1;\n      async.series([\n\n        function(callback) {\n          client1 = OPCUAClient.create();\n          client1.connect(test.endpointUrl, callback);\n        },\n        // create a session using client1\n        function(callback) {\n          client1.createSession(function(err, session) {\n            if (err) {\n              return callback(err);\n            }\n            session1 = session;\n            callback();\n          });\n        },\n\n        // first call to close session should be OK\n        function(callback) {\n          client1.closeSession(session1, /* deleteSubscriptions =*/true, function(err) {\n            callback(err);\n          });\n        },\n\n        // second call to close session should raise an error\n        function(callback) {\n          const request = new CloseSessionRequest({\n            deleteSubscriptions: true\n          });\n          client1.performMessageTransaction(request, function(err, response) {\n            should.not.exist(err);\n            //err.message.should.match(/BadSessionIdInvalid/);\n            response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionIdInvalid);\n            callback();\n          });\n        },\n\n        function(callback) {\n          client1.disconnect(callback);\n        },\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          callback();\n        }\n\n      ], function final(err) {\n        client1.disconnect(function() {\n          done(err);\n        });\n      });\n\n    });\n\n    it(\"RQ0 - call ActiveSession on a session that has been transferred to a different channel\", function(done) {\n\n      // this test verifies that the following requirement can be met\n      // OpcUA 1.02 part 3 $5.5 Secure Channel Set page 20\n      // Once a  Client  has established a  Session  it may wish to access the  Session  from a different\n      // SecureChannel. The Client can do this by validating the new  SecureChannel  with the\n      // ActivateSession  Service  described in 5.6.3.\n      let client1, client2;\n      let session1;\n      async.series([\n\n        // create a first channel (client1)\n        function(callback) {\n          client1 = OPCUAClient.create();\n          client1.connect(test.endpointUrl, callback);\n        },\n        // create a session using client1\n        function(callback) {\n          client1._createSession(function(err, session) {\n            if (err) {\n              return callback(err);\n            }\n            session1 = session;\n            callback();\n          });\n        },\n        // activate the session as expected on same channel used to create it\n        function(callback) {\n          client1._activateSession(session1, function(err) {\n            callback(err);\n          });\n        },\n        // let verify that it is now possible to send a request on client1's session\n        function(callback) {\n          // coerce nodeIds\n          const request = new ReadRequest({\n            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n            maxAge: 0,\n            timestampsToReturn: TimestampsToReturn.Both\n          });\n          request.requestHeader.authenticationToken = session1.authenticationToken;\n          client1.performMessageTransaction(request, function(err, response) {\n            should.not.exist(err);\n            response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            callback();\n          });\n        },\n\n        // create a second channel (client2)\n        function(callback) {\n          client2 = OPCUAClient.create();\n          client2.connect(test.endpointUrl, callback);\n        },\n\n        // reactivate session on second channel\n        function(callback) {\n          client2.reactivateSession(session1, function(err) {\n            callback(err);\n          });\n        },\n\n        // now that session has been assigned to client 1,\n        // server shall refuse any requests on channel1\n        function(callback) {\n          // coerce nodeIds\n          const request = new ReadRequest({\n            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n            maxAge: 0,\n            timestampsToReturn: TimestampsToReturn.Both\n          });\n          request.requestHeader.authenticationToken = session1.authenticationToken;\n          client1.performMessageTransaction(request, function(err, response) {\n            if (!err) {\n              response.responseHeader.serviceResult.should.eql(StatusCodes.BadSecureChannelIdInvalid);\n            }\n            callback(err);\n          });\n        },\n        // but server shall access request on new channel\n        function(callback) {\n          // coerce nodeIds\n          const request = new ReadRequest({\n            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n            maxAge: 0,\n            timestampsToReturn: TimestampsToReturn.Both\n          });\n          request.requestHeader.authenticationToken = session1.authenticationToken;\n          client2.performMessageTransaction(request, function(err, response) {\n            if (!err) {\n              response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            }\n            callback(err);\n          });\n        },\n\n\n        // terminate\n        function(callback) {\n          client2.disconnect(callback);\n        },\n        function(callback) {\n          client1.disconnect(callback);\n        },\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          callback();\n        }\n\n      ], done);\n    });\n\n    // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n    // When the ActivateSession  Service  is called f or the first time then the Server shall reject the request\n    // if the  SecureChannel  is not same as the one associated with the CreateSession  request.\n    it(\"RQ1 - should reject if the channel used to activate the session for the first time is not the same as the channel used to create the session\", function(done) {\n\n      let client1, client2;\n      let session1;\n\n      let initialChannelCount = 0;\n      async.series([\n\n        // create a first channel (client1)\n        function(callback) {\n          initialChannelCount = test.server.getChannels().length;\n          test.server.getChannels().length.should.equal(initialChannelCount);\n          client1 = OPCUAClient.create();\n          client1.connect(test.endpointUrl, callback);\n        },\n\n        // create a session using client1\n        //   ( without activating it)\n        function(callback) {\n          client1._createSession(function(err, session) {\n            if (err) {\n              return callback(err);\n            }\n            session1 = session;\n            test.server.getChannels().length.should.equal(initialChannelCount + 1);\n            callback();\n          });\n        },\n        // create a second channel (client2)\n        function(callback) {\n          client2 = OPCUAClient.create();\n          client2.connect(test.endpointUrl, callback);\n        },\n\n        // activate the session created with client1 using client2 !!\n        // this should be detected by server and server shall return an error\n        function(callback) {\n          test.server.getChannels().length.should.equal(initialChannelCount + 2);\n          //xx console.log(\" ID1 =\", client1._secureChannel.channelId);\n          //xx console.log(\" ID2 =\", client2._secureChannel.channelId);\n\n          client2.reactivateSession(session1, function(err) {\n\n            if (!err) {\n              callback(new Error(\"_activateSession shall return an error \"));\n            }\n            err.message.should.match(/BadSessionNotActivated/);\n            callback();\n          });\n        },\n\n        // terminate\n        function(callback) {\n          client2.disconnect(callback);\n        },\n        // activate the session as expected on same channel used to create it\n        // so we can close it properly\n        function(callback) {\n          client1._activateSession(session1, function(err) {\n            should.not.exist(err);\n            session1.close(callback);\n          });\n        },\n        function(callback) {\n          client1.disconnect(callback);\n        },\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          callback();\n        }\n\n      ], done);\n    });\n\n\n    function m(file) {\n      const p = path.join(certificateFolder, file);\n      if (!fs.existsSync(p)) {\n        console.error(\" cannot find \", p);\n      }\n      return p;\n    }\n\n    // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n    // Subsequent calls to  ActivateSession  may be associated with different  SecureChannels.  If this is the\n    // case then  the  Server  shall verify that the  Certificate  the  Client  used to create the new\n    // SecureChannel  is the same as the  Certificate  used to create the original  SecureChannel.\n    it(\"RQ2 -server should raise an error if a existing session is reactivated from a channel that have different certificate than the original channel\", function(done) {\n\n      const serverCertificate = test.server.getCertificateChain();\n\n      let client1, client2;\n      let session1;\n      async.series([\n\n        // create a first channel (client1) with\n        function(callback) {\n          //xx console.log(\" creating initial channel with some certificate\");\n          const certificateFile1 = m(\"client_cert_2048.pem\");\n          const privateKeyFile1 = m(\"client_key_2048.pem\");\n          console.log(certificateFile1);\n\n          client1 = OPCUAClient.create({\n            certificateFile: certificateFile1,\n            privateKeyFile: privateKeyFile1,\n            securityMode: MessageSecurityMode.Sign,\n            securityPolicy: SecurityPolicy.Basic128Rsa15,\n            serverCertificate: serverCertificate\n          });\n\n   \n          const certificate = readCertificate(certificateFile1);\n\n          async function doIt() {\n            await test.server.serverCertificateManager.trustCertificate(certificate);\n            const issuerCertificateFile = m(\"CA/public/cacert.pem\");\n            const issuerCertificateRevocationListFile = m(\"CA/crl/revocation_list.der\");\n            const issuerCertificate = readCertificate(issuerCertificateFile);\n            const issuerCrl = await readCertificateRevocationList(issuerCertificateRevocationListFile);\n            await test.server.serverCertificateManager.addIssuer(issuerCertificate);\n            await test.server.serverCertificateManager.addRevocationList(issuerCrl);\n            callback();\n          }\n          doIt();\n        },\n        function(callback) {\n          client1.connect(test.endpointUrl, callback);\n        },\n        // create a session using client1\n        function(callback) {\n          //xx console.log(\" create session\");\n          client1._createSession(function(err, session) {\n            if (err) {\n              return callback(err);\n            }\n            session1 = session;\n            callback();\n          });\n        },\n        // activate the session as expected on same channel used to create it\n        function(callback) {\n          //xx console.log(\" activate session\");\n          client1._activateSession(session1, function(err) {\n            callback(err);\n          });\n        },\n\n        // create a second channel (client2)\n        // with a different certificate ....\n        function(callback) {\n\n          // creating second channel with different credential\n          console.log(\" creating second channel with different certificate\");\n          const certificateFile2 = m(\"client_cert_3072.pem\");\n          const privateKeyFile2 = m(\"client_key_3072.pem\");\n          client2 = OPCUAClient.create({\n            certificateFile: certificateFile2,\n            privateKeyFile: privateKeyFile2,\n            securityMode: MessageSecurityMode.Sign,\n            securityPolicy: SecurityPolicy.Basic256,\n            serverCertificate: serverCertificate\n          });\n          const certificate = readCertificate(certificateFile2);\n          test.server.serverCertificateManager.trustCertificate(certificate, callback);\n\n        },\n        function(callback) {\n          client2.connect(test.endpointUrl, callback);\n        },\n        function(callback) {\n          // reactivate session on second channel\n          // Reactivate should fail because certificate is not the same as the original one\n          client2.reactivateSession(session1, function(err) {\n            if (err) {\n              err.message.should.match(/BadNoValidCertificates/);\n              callback();\n            } else {\n              callback(new Error(\"expecting reactivateSession to fail\"));\n            }\n          });\n        },\n        // terminate\n        function(callback) {\n          client2.disconnect(callback);\n        },\n        function(callback) {\n          session1.close(callback);\n        },\n        function(callback) {\n          client1.disconnect(callback);\n        },\n\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          callback();\n        }\n\n      ], done);\n\n    });\n\n    // In addition,the Server shall verify that the  Client  supplied a  UserIdentityToken  that is   identical to the token\n    // currently associated with the  Session.\n    it(\"RQ3 - server should raise an error if a session is reactivated with different user identity tokens\", function(done) {\n      let client1, client2;\n      let session1;\n\n      const user1 = {\n        userName: \"user1\", password: \"password1\"\n      };\n      const user2 = new UserNameIdentityToken({\n        userName: \"user1\", password: \"password1\"\n      });\n      //xx console.log(\" user1 \", user1.toString());\n      async.series([\n\n        // given a established session with a subscription and some publish request\n\n        function(callback) {\n          client1 = OPCUAClient.create();\n          client1.connect(test.endpointUrl, callback);\n        },\n        // create a session using client1\n        function(callback) {\n\n          client1.createSession(user1, function(err, session) {\n            if (err) {\n              return callback(err);\n            }\n            session1 = session;\n            callback();\n          });\n        },\n        // when the session is transferred to a different channel\n        // create a second channel (client2)\n        function(callback) {\n          client2 = OPCUAClient.create();\n          client2.connect(test.endpointUrl, callback);\n        },\n        function(callback) {\n          // reactivate session on second channel\n          // alter session1.userIdentityInfo\n          session1.userIdentityInfo = user2;\n          session1.userIdentityInfo.userName.should.eql(\"user1\");\n\n          client2.reactivateSession(session1, function(err) {\n            err.message.should.match(/BadIdentityChangeNotSupported/);\n            _.contains(client1._sessions, session1).should.eql(true);// should have failed\n            callback();\n          });\n        },\n        // terminate\n        function(callback) {\n          client2.disconnect(callback);\n        },\n        function(callback) {\n          client1.disconnect(callback);\n        },\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          callback();\n        }\n\n      ], done);\n\n    });\n    // Once the Server accepts the new  SecureChannel  it shall reject requests sent via the old  SecureChannel.\n    xit(\"RQ4 - server should reject request send via old channel when session has been transferred to new channel\", function(done) {\n      async.series([], done);\n    });\n\n    // unprocessed pending Requests such as PublishRequest shall be be denied by the server\n    // Once the Server accepts the new  SecureChannel  it shall reject requests sent via the old  SecureChannel\n    it(\"RQ5 - server should reject pending requests send to old channel when session has been transferred to new channel\", function(done) {\n\n      const sinon = require(\"sinon\");\n\n      const collectPublishResponse = sinon.spy();\n\n      let client1, client2;\n      let session1;\n      async.series([\n\n        // given a established session with a subscription and some publish request\n\n        function(callback) {\n          client1 = OPCUAClient.create();\n          client1.connect(test.endpointUrl, callback);\n        },\n        // create a session using client1\n        function(callback) {\n          client1._createSession(function(err, session) {\n            if (err) {\n              return callback(err);\n            }\n            session1 = session;\n            callback();\n          });\n        },\n        // activate the session as expected on same channel used to create it\n        function(callback) {\n          client1._activateSession(session1, function(err) {\n            callback(err);\n          });\n        },\n\n        // creaet a subscription,\n        function(callback) {\n          createSubscription(session1, callback);\n        },\n\n\n        // when the session is transferred to a different channel\n        // create a second channel (client2)\n        function(callback) {\n          client2 = OPCUAClient.create();\n          client2.connect(test.endpointUrl, callback);\n          collectPublishResponse.callCount.should.eql(0);\n        },\n\n        // provision 3 publish requests and wait for the first keep alive\n        function(callback) {\n\n          sendPublishRequest(session1, function(err) {\n            should.not.exist(err);\n            collectPublishResponse.callCount.should.eql(0);\n            callback();\n          });\n          sendPublishRequest(session1, collectPublishResponse);\n          sendPublishRequest(session1, collectPublishResponse);\n        },\n\n\n        function(callback) {\n          // reactivate session on second channel\n          client2.reactivateSession(session1, function(err) {\n            callback(err);\n          });\n        },\n        function(callback) {\n          setTimeout(callback, 100);\n        },\n\n        function(callback) {\n\n          collectPublishResponse.callCount.should.eql(2);\n          collectPublishResponse.getCall(0).args[0].message.should.match(/BadSecureChannelClosed/);\n          collectPublishResponse.getCall(1).args[0].message.should.match(/BadSecureChannelClosed/);\n          callback();\n        },\n\n\n        // terminate\n        function(callback) {\n          client2.disconnect(callback);\n        },\n        function(callback) {\n          client1.disconnect(callback);\n        },\n        function(callback) {\n          test.server.engine.currentSessionCount.should.eql(0);\n          callback();\n        }\n\n      ], done);\n\n    });\n\n  });\n\n};\n", "/**\r\n * @module node-opcua-secure-channel\r\n */\r\n// tslint:disable:variable-name\r\n// tslint:disable:object-literal-shorthand\r\n// tslint:disable:no-console\r\nimport { randomBytes } from \"crypto\";\r\nimport { EventEmitter } from \"events\";\r\nimport * as chalk from \"chalk\";\r\nimport * as async from \"async\";\r\n\r\nimport { Certificate, extractPublicKeyFromCertificate, PrivateKeyPEM, PublicKeyPEM, rsa_length } from \"node-opcua-crypto\";\r\n\r\nimport { assert } from \"node-opcua-assert\";\r\n\r\nimport { BinaryStream } from \"node-opcua-binary-stream\";\r\nimport { get_clock_tick, timestamp } from \"node-opcua-utils\";\r\n\r\nimport { readMessageHeader, verify_message_chunk } from \"node-opcua-chunkmanager\";\r\nimport { checkDebugFlag, hexDump, make_debugLog, make_errorLog, make_warningLog } from \"node-opcua-debug\";\r\nimport { ChannelSecurityToken, coerceMessageSecurityMode, MessageSecurityMode } from \"node-opcua-service-secure-channel\";\r\nimport { CallbackT, StatusCode, StatusCodes } from \"node-opcua-status-code\";\r\nimport { ClientTCP_transport, TransportSettingsOptions } from \"node-opcua-transport\";\r\nimport { StatusCodes2 } from \"node-opcua-transport\";\r\nimport { ErrorCallback } from \"node-opcua-status-code\";\r\nimport { BaseUAObject } from \"node-opcua-factory\";\r\nimport { doTraceChunk } from \"node-opcua-transport\";\r\n\r\nimport { MessageBuilder } from \"../message_builder\";\r\nimport { ChunkMessageOptions, MessageChunker } from \"../message_chunker\";\r\nimport { messageHeaderToString } from \"../message_header_to_string\";\r\n\r\nimport {\r\n    coerceSecurityPolicy,\r\n    computeDerivedKeys,\r\n    DerivedKeys1,\r\n    getCryptoFactory,\r\n    getOptionsForSymmetricSignAndEncrypt,\r\n    SecurityPolicy,\r\n    toURI\r\n} from \"../security_policy\";\r\nimport {\r\n    AsymmetricAlgorithmSecurityHeader,\r\n    CloseSecureChannelRequest,\r\n    OpenSecureChannelRequest,\r\n    OpenSecureChannelResponse,\r\n    SecurityTokenRequestType,\r\n    ServiceFault\r\n} from \"../services\";\r\n\r\nconst debugLog = make_debugLog(__filename);\r\nconst errorLog = make_errorLog(__filename);\r\nconst doDebug = checkDebugFlag(__filename);\r\nconst warningLog = make_warningLog(__filename);\r\nconst checkChunks = doDebug && false;\r\nconst doDebug1 = false;\r\n\r\n// set checkTimeout to true to enable timeout trace checking\r\nconst checkTimeout = false;\r\n\r\nimport { extractFirstCertificateInChain, getThumbprint, ICertificateKeyPairProvider, Request, Response } from \"../common\";\r\nimport {\r\n    ClientTransactionStatistics,\r\n    doPerfMonitoring,\r\n    doTraceClientMessage,\r\n    doTraceClientRequestContent,\r\n    doTraceStatistics,\r\n    dumpSecurityHeader,\r\n    traceClientRequestMessage,\r\n    traceClientResponseMessage,\r\n    _dump_client_transaction_statistics\r\n} from \"../utils\";\r\n// import * as backoff from \"backoff\";\r\n// tslint:disable-next-line: no-var-requires\r\nconst backoff = require(\"backoff\");\r\n\r\nexport const requestHandleNotSetValue = 0xdeadbeef;\r\n\r\ntype PerformTransactionCallback = CallbackT<Response>;\r\n\r\ninterface TransactionData {\r\n    msgType: string;\r\n    request: Request;\r\n    callback: PerformTransactionCallback;\r\n}\r\n\r\ninterface RequestData {\r\n    msgType: string;\r\n    request: Request;\r\n    callback?: PerformTransactionCallback;\r\n\r\n    response?: Response;\r\n\r\n    _tick0: number;\r\n    _tick1: number;\r\n    _tick2: number;\r\n    _tick3: number;\r\n    _tick4: number;\r\n    bytesWritten_after: number;\r\n    bytesWritten_before: number;\r\n    bytesRead: number;\r\n    key: string;\r\n    chunk_count: number;\r\n}\r\n\r\nfunction process_request_callback(requestData: RequestData, err?: Error | null, response?: Response) {\r\n    assert(typeof requestData.callback === \"function\");\r\n\r\n    const request = requestData.request;\r\n\r\n    if (!response && !err && requestData.msgType !== \"CLO\") {\r\n        // this case happens when CLO is called and when some pending transactions\r\n        // remains in the queue...\r\n        err = new Error(\" Connection has been closed by client , but this transaction cannot be honored\");\r\n    }\r\n\r\n    if (response && response instanceof ServiceFault) {\r\n        response.responseHeader.stringTable = [...(response.responseHeader.stringTable || [])];\r\n        err = new Error(\" serviceResult = \" + response.responseHeader.serviceResult.toString());\r\n        //  \"  returned by server \\n response:\" + response.toString() + \"\\n  request: \" + request.toString());\r\n        (err as any).response = response;\r\n        ((err as any).request = request), (response = undefined);\r\n    }\r\n\r\n    const theCallbackFunction = requestData.callback;\r\n    /* istanbul ignore next */\r\n    if (!theCallbackFunction) {\r\n        throw new Error(\"Internal error\");\r\n    }\r\n    assert(requestData.msgType === \"CLO\" || (err && !response) || (!err && response));\r\n\r\n    // let set callback to undefined to prevent callback to be called again\r\n    requestData.callback = undefined;\r\n\r\n    theCallbackFunction(err || null, !err && response !== null ? response : undefined);\r\n}\r\n\r\nexport interface ConnectionStrategyOptions {\r\n    maxRetry?: number;\r\n    initialDelay?: number;\r\n    maxDelay?: number;\r\n    randomisationFactor?: number;\r\n}\r\n\r\nexport interface ConnectionStrategy {\r\n    maxRetry: number;\r\n    initialDelay: number;\r\n    maxDelay: number;\r\n    randomisationFactor: number;\r\n}\r\n\r\nexport function coerceConnectionStrategy(options: ConnectionStrategyOptions | null): ConnectionStrategy {\r\n    options = options || {};\r\n\r\n    const maxRetry: number = options.maxRetry === undefined ? 10 : options.maxRetry;\r\n    const initialDelay = options.initialDelay || 10;\r\n    const maxDelay = options.maxDelay || 10000;\r\n    const randomisationFactor = options.randomisationFactor === undefined ? 0 : options.randomisationFactor;\r\n\r\n    return {\r\n        initialDelay,\r\n        maxDelay,\r\n        maxRetry,\r\n        randomisationFactor\r\n    };\r\n}\r\n\r\nexport interface ClientSecureChannelParent extends ICertificateKeyPairProvider {\r\n    applicationName?: string;\r\n    clientName?: string;\r\n\r\n    getCertificate(): Certificate;\r\n\r\n    getCertificateChain(): Certificate;\r\n\r\n    getPrivateKey(): PrivateKeyPEM;\r\n}\r\n\r\n/***\r\n * @param [options.factory] an factory that provides a method createObjectId(id) for the message builder\r\n */\r\n\r\nexport interface ClientSecureChannelLayerOptions {\r\n    /**\r\n     * default secure token life time , if not specified  30 seconds will be used as default value\r\n     */\r\n    defaultSecureTokenLifetime?: number;\r\n    /**\r\n     * delay SecureTokenLifetime at which token renewal will be attempted.\r\n     *\r\n     * if 0 or not specify, the security token renewal will happen at 75% of defaultSecureTokenLifetime\r\n     */\r\n    tokenRenewalInterval?: number;\r\n    /**\r\n     *  message security mode\r\n     *  default value =MessageSecurityMode.None\r\n     */\r\n    securityMode?: MessageSecurityMode;\r\n    /**\r\n     * security policy\r\n     * default value = SecurityPolicy.None\r\n     */\r\n    securityPolicy?: SecurityPolicy;\r\n    /**\r\n     * the serverCertificate (required if securityMode!=None)\r\n     */\r\n    serverCertificate?: Certificate;\r\n\r\n    parent: ClientSecureChannelParent;\r\n\r\n    /* OPCUAClientBase */\r\n    /**\r\n     *   the transport timeout interval in ms ( default = 10 seconds)\r\n     */\r\n    transportTimeout?: number;\r\n    /**\r\n     * the connection strategy options\r\n     * @param [options.connectionStrategy.maxRetry      = 10]\r\n     * @param [options.connectionStrategy.initialDelay  = 10]\r\n     * @param [options.connectionStrategy.maxDelay      = 10000]\r\n     */\r\n    connectionStrategy: ConnectionStrategyOptions;\r\n\r\n    transportSettings: TransportSettingsOptions;\r\n}\r\n\r\nexport interface ClientSecureChannelLayer extends EventEmitter {\r\n    on(event: \"end_transaction\", eventHandler: (transactionStatistics: ClientTransactionStatistics) => void): this;\r\n    on(event: \"close\", eventHandler: (err?: Error | null) => void): this;\r\n    on(event: \"lifetime_75\", eventHandler: (securityToken: ChannelSecurityToken) => void): this;\r\n    on(event: \"receive_chunk\", eventHandler: (chunk: Buffer) => void): this;\r\n    on(event: \"send_chunk\", eventHandler: (chunk: Buffer) => void): this;\r\n    on(event: \"backoff\", eventHandler: (retryCount: number, delay: number) => void): this;\r\n    on(event: \"security_token_renewed\", eventHandler: () => void): this;\r\n    on(event: \"send_request\", eventHandler: (request: Request) => void): this;\r\n    on(event: \"receive_response\", eventHandler: (response: Response) => void): this;\r\n    on(event: \"timed_out_request\", eventHandler: (request: Request) => void): this;\r\n    on(event: \"abort\", eventHandler: () => void): this;\r\n\r\n    emit(event: \"end_transaction\", transactionStatistics: ClientTransactionStatistics): boolean;\r\n    /**\r\n     * notify the observers that the transport connection has ended.\r\n     * The error object is null or undefined if the disconnection was initiated by the ClientSecureChannelLayer.\r\n     * A Error object is provided if the disconnection has been initiated by an external cause.\r\n     *\r\n     * @event close\r\n     */\r\n    emit(event: \"close\", err?: Error | null): boolean;\r\n    /**\r\n     * notify the observer that the secure channel has now reach 75% of its allowed live time and\r\n     * that a new token is going to be requested.\r\n     * @event  lifetime_75\r\n     * @param  securityToken {Object} : the security token that is about to expire.\r\n     *\r\n     */\r\n    emit(event: \"lifetime_75\", securityToken: ChannelSecurityToken): boolean;\r\n\r\n    /**\r\n     * notify the observers that ClientSecureChannelLayer has received a message chunk\r\n     * @event receive_chunk\r\n     */\r\n    emit(event: \"receive_chunk\", chunk: Buffer): boolean;\r\n    /**\r\n     * notify the observer that a message chunk is about to be sent to the server\r\n     * @event send_chunk\r\n     */\r\n\r\n    emit(event: \"send_chunk\", chunk: Buffer): boolean;\r\n\r\n    emit(event: \"backoff\", retryCount: number, delay: number): boolean;\r\n    /**\r\n     * notify the observers that the security has been renewed\r\n     * @event security_token_renewed\r\n     */\r\n    emit(event: \"security_token_renewed\"): boolean;\r\n\r\n    /**\r\n     * notify the observer that a client request is being sent the server\r\n     * @event send_request\r\n     */\r\n    emit(event: \"send_request\", request: Request): boolean;\r\n    /**\r\n     * notify the observers that a server response has been received on the channel\r\n     * @event receive_response\r\n     */\r\n    emit(event: \"receive_response\", response: Response): boolean;\r\n    /**\r\n     * notify the observer that the response from the request has not been\r\n     * received within the timeoutHint specified\r\n     * @event timed_out_request\r\n     */\r\n    emit(event: \"timed_out_request\", request: Request): boolean;\r\n    emit(event: \"abort\"): boolean;\r\n}\r\n/**\r\n * a ClientSecureChannelLayer represents the client side of the OPCUA secure channel.\r\n */\r\nexport class ClientSecureChannelLayer extends EventEmitter {\r\n    private static g_counter = 0;\r\n    private _counter = ClientSecureChannelLayer.g_counter++;\r\n    private _bytesRead = 0;\r\n    private _bytesWritten = 0;\r\n\r\n    public static minTransactionTimeout = 10 * 1000; // 10 sec\r\n    public static defaultTransactionTimeout = 60 * 1000; // 1 minute\r\n\r\n    /**\r\n     * true if the secure channel is trying to establish the connection with the server. In this case, the client\r\n     * may be in the middle of the backoff connection process.\r\n     *\r\n     */\r\n    public get isConnecting(): boolean {\r\n        return !!this.__call;\r\n    }\r\n\r\n    get bytesRead(): number {\r\n        return this._bytesRead + (this._transport ? this._transport.bytesRead : 0);\r\n    }\r\n\r\n    get bytesWritten(): number {\r\n        return this._bytesWritten + (this._transport ? this._transport.bytesWritten : 0);\r\n    }\r\n\r\n    get transactionsPerformed(): number {\r\n        return this._lastRequestId;\r\n    }\r\n\r\n    get timedOutRequestCount(): number {\r\n        return this._timeout_request_count;\r\n    }\r\n\r\n    public static defaultTransportTimeout = 60 * 1000; // 1 minute\r\n    private transportSettings: TransportSettingsOptions;\r\n\r\n    public protocolVersion: number;\r\n    public readonly securityMode: MessageSecurityMode;\r\n    public readonly securityPolicy: SecurityPolicy;\r\n    public endpointUrl: string;\r\n    public channelId: number;\r\n    public securityToken: ChannelSecurityToken | null;\r\n\r\n    private _lastRequestId: number;\r\n    private _transport?: ClientTCP_transport;\r\n    private _pending_transport?: ClientTCP_transport;\r\n    private readonly parent: ClientSecureChannelParent;\r\n\r\n    private clientNonce: any;\r\n    private readonly messageChunker: MessageChunker;\r\n    private readonly defaultSecureTokenLifetime: number;\r\n    private readonly tokenRenewalInterval: number;\r\n    private readonly serverCertificate: Certificate | null;\r\n    private messageBuilder?: MessageBuilder;\r\n\r\n    private _requests: { [key: string]: RequestData };\r\n\r\n    private __in_normal_close_operation: boolean;\r\n    private _timeout_request_count: number;\r\n    private _securityTokenTimeoutId: NodeJS.Timer | null;\r\n    private readonly transportTimeout: number;\r\n    private readonly connectionStrategy: any;\r\n    private last_transaction_stats: any | ClientTransactionStatistics;\r\n    private derivedKeys: DerivedKeys1 | null;\r\n    private receiverPublicKey: PublicKeyPEM | null;\r\n    private __call: any;\r\n    private _isOpened: boolean;\r\n    private serverNonce: Buffer | null;\r\n    private receiverCertificate: Certificate | null;\r\n    private securityHeader: AsymmetricAlgorithmSecurityHeader | null;\r\n    private lastError?: Error;\r\n    private _tick2 = 0;\r\n    private _isDisconnecting = false;\r\n\r\n    constructor(options: ClientSecureChannelLayerOptions) {\r\n        super();\r\n\r\n        this.securityHeader = null;\r\n        this.receiverCertificate = null;\r\n        this.securityToken = null;\r\n        this.serverNonce = null;\r\n        this.derivedKeys = null;\r\n        this.receiverPublicKey = null;\r\n        this.endpointUrl = \"\";\r\n\r\n        if ((global as any).hasResourceLeakDetector && !(global as any).ResourceLeakDetectorStarted) {\r\n            throw new Error(\"ClientSecureChannelLayer not in ResourceLeakDetectorStarted\");\r\n        }\r\n\r\n        assert(this instanceof ClientSecureChannelLayer);\r\n\r\n        this._isOpened = false;\r\n        this._transport = undefined;\r\n        this._lastRequestId = 0;\r\n        this.parent = options.parent;\r\n        this.clientNonce = null; // will be created when needed\r\n\r\n        this.protocolVersion = 0;\r\n\r\n        this.messageChunker = new MessageChunker({\r\n            derivedKeys: null\r\n            // note maxMessageSize cannot be set at this stage, transport is not kown\r\n        });\r\n\r\n        this.defaultSecureTokenLifetime = options.defaultSecureTokenLifetime || 30000;\r\n        this.tokenRenewalInterval = options.tokenRenewalInterval || 0;\r\n\r\n        this.securityMode = coerceMessageSecurityMode(options.securityMode);\r\n\r\n        this.securityPolicy = coerceSecurityPolicy(options.securityPolicy);\r\n\r\n        this.serverCertificate = extractFirstCertificateInChain(options.serverCertificate);\r\n\r\n        if (this.securityMode !== MessageSecurityMode.None) {\r\n            assert(\r\n                (this.serverCertificate as any) instanceof Buffer,\r\n                \"Expecting a valid certificate when security mode is not None\"\r\n            );\r\n            assert(this.securityPolicy !== SecurityPolicy.None, \"Security Policy None is not a valid choice\");\r\n            // make sure that we do not have a chain here ...\r\n        }\r\n\r\n        this._requests = {};\r\n\r\n        this.__in_normal_close_operation = false;\r\n\r\n        this._timeout_request_count = 0;\r\n\r\n        this._securityTokenTimeoutId = null;\r\n\r\n        this.transportTimeout = options.transportTimeout || ClientSecureChannelLayer.defaultTransportTimeout;\r\n        this.transportSettings = options.transportSettings || {};\r\n\r\n        this.channelId = 0;\r\n\r\n        this.connectionStrategy = coerceConnectionStrategy(options.connectionStrategy);\r\n    }\r\n\r\n    private _install_message_builder() {\r\n        // istanbul ignore next\r\n        if (!this._transport || !this._transport.parameters) {\r\n            throw new Error(\"internal error\");\r\n        }\r\n        this.messageBuilder = new MessageBuilder({\r\n            name: \"client\",\r\n            privateKey: this.getPrivateKey() || undefined,\r\n            securityMode: this.securityMode,\r\n            maxChunkSize: this._transport.receiveBufferSize || 0,\r\n            maxChunkCount: this._transport.maxChunkCount || 0,\r\n            maxMessageSize: this._transport.maxMessageSize || 0\r\n        });\r\n\r\n        if (doTraceChunk) {\r\n            console.log(\r\n                chalk.cyan(timestamp()),\r\n                \"   MESSGAE BUILDER LIMITS\",\r\n                \"maxMessageSize = \",\r\n                this.messageBuilder.maxMessageSize,\r\n                \"maxChunkCount = \",\r\n                this.messageBuilder.maxChunkCount,\r\n                \"maxChunkSize = \",\r\n                this.messageBuilder.maxChunkSize,\r\n                \"(\",\r\n                this.messageBuilder.maxChunkSize * this.messageBuilder.maxChunkCount,\r\n                \")\"\r\n            );\r\n        }\r\n\r\n        this.messageBuilder\r\n            .on(\"message\", (response: BaseUAObject, msgType: string, requestId: number, channelId: number) => {\r\n                this._on_message_received(response as Response, msgType, requestId);\r\n            })\r\n            .on(\"startChunk\", () => {\r\n                //\r\n                if (doPerfMonitoring) {\r\n                    this._tick2 = get_clock_tick();\r\n                }\r\n            })\r\n            .on(\"abandon\", (requestId: number) => {\r\n                const requestData = this._requests[requestId];\r\n\r\n                if (doDebug) {\r\n                    debugLog(\"request id = \", requestId, \"message was \", requestData);\r\n                }\r\n\r\n                const err = new ServiceFault({\r\n                    responseHeader: {\r\n                        requestHandle: requestId,\r\n                        serviceResult: StatusCodes.BadOperationAbandoned\r\n                    }\r\n                });\r\n\r\n                const callback = requestData.callback;\r\n                delete this._requests[requestId];\r\n                callback && callback(null, err);\r\n            })\r\n            .on(\"error\", (err: Error, statusCode: StatusCode, requestId: number | null) => {\r\n                // istanbul ignore next\r\n                if (!requestId) {\r\n                    return;\r\n                }\r\n\r\n                let requestData = this._requests[requestId];\r\n\r\n                if (doDebug) {\r\n                    debugLog(\"request id = \", requestId, err, \"message was \", requestData);\r\n                }\r\n\r\n                if (!requestData) {\r\n                    warningLog(\"requestData not found for requestId = \", requestId, \"try with \", requestId + 1);\r\n                    requestId = requestId + 1;\r\n                    requestData = this._requests[requestId];\r\n                }\r\n                if (doTraceClientRequestContent) {\r\n                    errorLog(\" message was 2:\", requestData ? requestData.request.toString() : \"<null>\");\r\n                }\r\n\r\n                const callback = requestData.callback;\r\n                delete this._requests[requestId];\r\n                callback && callback(err, undefined);\r\n\r\n                this._closeWithError(err, statusCode);\r\n                return;\r\n            });\r\n    }\r\n\r\n    public getPrivateKey(): PrivateKeyPEM | null {\r\n        return this.parent ? this.parent.getPrivateKey() : null;\r\n    }\r\n\r\n    public getCertificateChain(): Certificate | null {\r\n        return this.parent ? this.parent.getCertificateChain() : null;\r\n    }\r\n\r\n    public getCertificate(): Certificate | null {\r\n        return this.parent ? this.parent.getCertificate() : null;\r\n    }\r\n\r\n    public toString(): string {\r\n        let str = \"\";\r\n        str += \"\\n securityMode ............. : \" + MessageSecurityMode[this.securityMode];\r\n        str += \"\\n securityPolicy............ : \" + this.securityPolicy;\r\n        str += \"\\n securityToken ............ : \" + (this.securityToken ? this.securityToken!.toString() : \"null\");\r\n        str += \"\\n serverNonce  ............. : \" + (this.serverNonce ? this.serverNonce.toString(\"hex\") : \"null\");\r\n        str += \"\\n clientNonce  ............. : \" + (this.clientNonce ? this.clientNonce.toString(\"hex\") : \"null\");\r\n        str += \"\\n transportTimeout ......... : \" + this.transportTimeout;\r\n        str += \"\\n maxMessageSize (to send..) : \" + (this._transport?.parameters?.maxMessageSize || \"<not set>\");\r\n        str += \"\\n maxChunkCount  (to send..) : \" + (this._transport?.parameters?.maxChunkCount || \"<not set>\");\r\n        str += \"\\n receiveBufferSize(server)  : \" + (this._transport?.parameters?.receiveBufferSize || \"<not set>\");\r\n        str += \"\\n\";\r\n        return str;\r\n    }\r\n\r\n    public isTransactionInProgress(): boolean {\r\n        return Object.keys(this._requests).length > 0;\r\n    }\r\n\r\n    public getClientNonce(): Buffer {\r\n        return this.clientNonce;\r\n    }\r\n\r\n    /**\r\n     * establish a secure channel with the provided server end point.\r\n     *\r\n     * @method create\r\n     * @async\r\n     * @param endpointUrl\r\n     * @param callback the async callback function\r\n     *\r\n     *\r\n     * @example\r\n     *\r\n     *    ```javascript\r\n     *\r\n     *    var secureChannel  = new ClientSecureChannelLayer({});\r\n     *\r\n     *    secureChannel.on(\"end\", function(err) {\r\n     *         console.log(\"secure channel has ended\",err);\r\n     *         if(err) {\r\n     *            console.log(\" the connection was closed by an external cause such as server shutdown\");\r\n     *        }\r\n     *    });\r\n     *    secureChannel.create(\"opc.tcp://localhost:1234/UA/Sample\", (err) => {\r\n     *         if(err) {\r\n     *              console.log(\" cannot establish secure channel\" , err);\r\n     *         } else {\r\n     *              console.log(\"secure channel has been established\");\r\n     *         }\r\n     *    });\r\n     *\r\n     *    ```\r\n     */\r\n    public create(endpointUrl: string, callback: ErrorCallback): void {\r\n        assert(typeof callback === \"function\");\r\n\r\n        if (this.securityMode !== MessageSecurityMode.None) {\r\n            // istanbul ignore next\r\n            if (!this.serverCertificate) {\r\n                return callback(\r\n                    new Error(\"ClientSecureChannelLayer#create : expecting a server certificate when securityMode is not None\")\r\n                );\r\n            }\r\n\r\n            // take the opportunity of this async method to perform some async pre-processing\r\n            if (!this.receiverPublicKey) {\r\n                extractPublicKeyFromCertificate(this.serverCertificate, (err: Error | null, publicKey?: PublicKeyPEM) => {\r\n                    /* istanbul ignore next */\r\n                    if (err) {\r\n                        return callback(err);\r\n                    }\r\n                    /* istanbul ignore next */\r\n                    if (!publicKey) {\r\n                        throw new Error(\"Internal Error\");\r\n                    }\r\n                    this.receiverPublicKey = publicKey;\r\n\r\n                    this.create(endpointUrl, callback);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.endpointUrl = endpointUrl;\r\n\r\n        const transport = new ClientTCP_transport(this.transportSettings);\r\n        transport.timeout = this.transportTimeout;\r\n\r\n        doDebug &&\r\n            debugLog(\"ClientSecureChannelLayer#create creating ClientTCP_transport with  transport.timeout = \", transport.timeout);\r\n        assert(!this._pending_transport);\r\n        this._pending_transport = transport;\r\n        this._establish_connection(transport, endpointUrl, (err?: Error | null) => {\r\n            if (err) {\r\n                doDebug && debugLog(chalk.red(\"cannot connect to server\"));\r\n                this._pending_transport = undefined;\r\n                transport.dispose();\r\n                return callback(err);\r\n            }\r\n\r\n            this._on_connection(transport, callback);\r\n        });\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._isDisconnecting = true;\r\n        this.abortConnection(() => {\r\n            /* empty */\r\n        });\r\n        this._cancel_security_token_watchdog();\r\n        if (this.__call) {\r\n            this.__call.abort();\r\n            this.__call = null;\r\n        }\r\n        if (this._transport) {\r\n            this._transport.dispose();\r\n            this._transport = undefined;\r\n        }\r\n        if (this._pending_transport) {\r\n            this._pending_transport.dispose();\r\n            this._pending_transport = undefined;\r\n        }\r\n    }\r\n\r\n    public abortConnection(callback: ErrorCallback): void {\r\n        this._isDisconnecting = true;\r\n        doDebug && debugLog(\"abortConnection \", !!this.__call);\r\n        assert(typeof callback === \"function\");\r\n\r\n        async.series(\r\n            [\r\n                (inner_callback: ErrorCallback) => {\r\n                    if (this.__call) {\r\n                        this.__call.once(\"abort\", () => inner_callback());\r\n                        this.__call._cancelBackoff = true;\r\n                        this.__call.abort();\r\n                        this.__call = null;\r\n                    } else {\r\n                        inner_callback();\r\n                    }\r\n                },\r\n                (inner_callback: ErrorCallback) => {\r\n                    if (!this._pending_transport) {\r\n                        return inner_callback();\r\n                    }\r\n                    this._pending_transport.disconnect(() => {\r\n                        inner_callback();\r\n                    });\r\n                },\r\n                (inner_callback: ErrorCallback) => {\r\n                    if (!this._transport) {\r\n                        return inner_callback();\r\n                    }\r\n                    this._transport.disconnect(() => {\r\n                        inner_callback();\r\n                    });\r\n                }\r\n            ],\r\n            () => {\r\n                callback();\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * perform a OPC-UA message transaction, asynchronously.\r\n     * During a transaction, the client sends a request to the server. The provided callback will be invoked\r\n     * at a later stage with the reply from the server, or the error.\r\n     *\r\n     * preconditions:\r\n     *   - the channel must be opened\r\n     *\r\n     * @example\r\n     *\r\n     *    ```javascript\r\n     *    let secure_channel ; // get a  ClientSecureChannelLayer somehow\r\n     *\r\n     *    const request = new BrowseRequest({...});\r\n     *    secure_channel.performMessageTransaction(request, (err,response) => {\r\n     *       if (err) {\r\n     *         // an error has occurred\r\n     *       } else {\r\n     *          assert(response instanceof BrowseResponse);\r\n     *         // do something with response.\r\n     *       }\r\n     *    });\r\n     *    ```\r\n     *\r\n     */\r\n    public performMessageTransaction(request: Request, callback: PerformTransactionCallback): void {\r\n        assert(typeof callback === \"function\");\r\n        this._performMessageTransaction(\"MSG\", request, callback);\r\n    }\r\n\r\n    public isValid(): boolean {\r\n        if (!this._transport) {\r\n            return false;\r\n        }\r\n        return this._transport.isValid();\r\n    }\r\n\r\n    public isOpened(): boolean {\r\n        return this.isValid() && this._isOpened;\r\n    }\r\n\r\n    public getDisplayName(): string {\r\n        if (!this.parent) {\r\n            return \"\";\r\n        }\r\n        return \"\" + (this.parent.applicationName ? this.parent.applicationName + \" \" : \"\") + this.parent.clientName;\r\n    }\r\n\r\n    public cancelPendingTransactions(callback: ErrorCallback): void {\r\n        assert(typeof callback === \"function\", \"expecting a callback function, but got \" + callback);\r\n\r\n        // istanbul ignore next\r\n        if (doDebug) {\r\n            debugLog(\r\n                \"cancelPendingTransactions \",\r\n                this.getDisplayName(),\r\n                \" = \",\r\n                Object.keys(this._requests)\r\n                    .map((k) => this._requests[k].request.constructor.name)\r\n                    .join(\" \")\r\n            );\r\n        }\r\n\r\n        for (const key of Object.keys(this._requests)) {\r\n            // kill timer id\r\n            const transaction = this._requests[key];\r\n            if (transaction.callback) {\r\n                transaction.callback(new Error(\"Transaction has been canceled because client channel  is being closed\"));\r\n            }\r\n        }\r\n        setImmediate(callback);\r\n    }\r\n\r\n    /**\r\n     * Close a client SecureChannel ,by sending a CloseSecureChannelRequest to the server.\r\n     *\r\n     *\r\n     * After this call, the connection is closed and no further transaction can be made.\r\n     *\r\n     * @method close\r\n     * @async\r\n     * @param callback\r\n     */\r\n    public close(callback: ErrorCallback): void {\r\n        assert(typeof callback === \"function\", \"expecting a callback function, but got \" + callback);\r\n\r\n        // cancel any pending transaction\r\n        this.cancelPendingTransactions((/* err?: Error */) => {\r\n            // what the specs says:\r\n            // --------------------\r\n            //   The client closes the connection by sending a CloseSecureChannelRequest and closing the\r\n            //   socket gracefully. When the server receives this message it shall release all resources\r\n            //   allocated for the channel. The server does not send a CloseSecureChannel response\r\n            //\r\n            // ( Note : some servers do  send a CloseSecureChannel though !)\r\n\r\n            // there is no need for the security token expiration event to trigger anymore\r\n            this._cancel_security_token_watchdog();\r\n\r\n            doDebug && debugLog(\"Sending CloseSecureChannelRequest to server\");\r\n            const request = new CloseSecureChannelRequest({});\r\n\r\n            this.__in_normal_close_operation = true;\r\n\r\n            if (!this._transport || this._transport.isDisconnecting) {\r\n                this.dispose();\r\n                return callback(new Error(\"Transport disconnected\"));\r\n            }\r\n            this._performMessageTransaction(\"CLO\", request, () => {\r\n                this.dispose();\r\n                callback();\r\n            });\r\n        });\r\n    }\r\n\r\n    private _closeWithError(err: Error, statusCode: StatusCode): void {\r\n        if (this._transport) {\r\n            this._transport.prematureTerminate(err, statusCode);\r\n            this._transport = undefined;\r\n        }\r\n        this.dispose();\r\n    }\r\n\r\n    private on_transaction_completed(transactionStatistics: ClientTransactionStatistics) {\r\n        /* istanbul ignore next */\r\n        if (doTraceStatistics) {\r\n            // dump some statistics about transaction ( time and sizes )\r\n            _dump_client_transaction_statistics(transactionStatistics);\r\n        }\r\n        this.emit(\"end_transaction\", transactionStatistics);\r\n    }\r\n\r\n    private _on_message_received(response: Response, msgType: string, requestId: number) {\r\n        //      assert(msgType !== \"ERR\");\r\n\r\n        /* istanbul ignore next */\r\n        if (response.responseHeader.requestHandle !== requestId) {\r\n            warningLog(response.toString());\r\n            errorLog(\r\n                chalk.red.bgWhite.bold(\"xxxxx  <<<<<< _on_message_received  ERROR\"),\r\n                \"requestId=\",\r\n                requestId,\r\n                this._requests[requestId]?.constructor.name,\r\n                \"response.responseHeader.requestHandle=\",\r\n                response.responseHeader.requestHandle,\r\n                response.schema.name.padStart(30)\r\n            );\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        if (doTraceClientMessage) {\r\n            traceClientResponseMessage(response, this.channelId, this._counter);\r\n        }\r\n\r\n        const requestData = this._requests[requestId];\r\n\r\n        /* istanbul ignore next */\r\n        if (!requestData) {\r\n            errorLog(\r\n                chalk.cyan.bold(\"xxxxx  <<<<<< _on_message_received for unknown or timeout request \"),\r\n                requestId,\r\n                response.schema.name.padStart(30),\r\n                response.responseHeader.serviceResult.toString(),\r\n                this.channelId\r\n            );\r\n            throw new Error(\" =>  invalid requestId =\" + requestId);\r\n        }\r\n\r\n        const request = requestData.request;\r\n\r\n        /* istanbul ignore next */\r\n        if (doPerfMonitoring) {\r\n            requestData._tick2 = this._tick2;\r\n        }\r\n\r\n        delete this._requests[requestId];\r\n\r\n        /* istanbul ignore next */\r\n        if (response.responseHeader.requestHandle !== request.requestHeader.requestHandle) {\r\n            const expected = request.requestHeader.requestHandle;\r\n            const actual = response.responseHeader.requestHandle;\r\n\r\n            if (actual !== 0x0) {\r\n                // note some old OPCUA Server, like siemens with OPCUA 1.2 may send 0x00 as a\r\n                // requestHandle, this is not harmful. THis happened with OpenSecureChannelRequest\r\n                // so we only display the warning message if we have a real random discrepancy between the two requestHandle.\r\n                const moreInfo = \"Request= \" + request.schema.name + \" Response = \" + response.schema.name;\r\n\r\n                const message =\r\n                    \" WARNING SERVER responseHeader.requestHandle is invalid\" +\r\n                    \": expecting 0x\" +\r\n                    expected.toString(16) +\r\n                    \"(\" +\r\n                    expected +\r\n                    \")\" +\r\n                    \"  but got 0x\" +\r\n                    actual.toString(16) +\r\n                    \"(\" +\r\n                    actual +\r\n                    \")\" +\r\n                    \" \";\r\n\r\n                debugLog(chalk.red.bold(message), chalk.yellow(moreInfo));\r\n                warningLog(chalk.red.bold(message), chalk.yellow(moreInfo));\r\n                warningLog(request.toString());\r\n            }\r\n        }\r\n\r\n        requestData.response = response;\r\n\r\n        if (doPerfMonitoring) {\r\n            // record tick2 : after response message has been received, before message processing\r\n            requestData._tick2 = this.messageBuilder!._tick1;\r\n        }\r\n        requestData.bytesRead = this.messageBuilder!.totalMessageSize;\r\n\r\n        if (doPerfMonitoring) {\r\n            // record tick3 : after response message has been received, before message processing\r\n            requestData._tick3 = get_clock_tick();\r\n        }\r\n\r\n        process_request_callback(requestData, null, response);\r\n\r\n        if (doPerfMonitoring) {\r\n            // record tick4 after callback\r\n            requestData._tick4 = get_clock_tick();\r\n        } // store some statistics\r\n        this._record_transaction_statistics(requestData);\r\n\r\n        // notify that transaction is completed\r\n        this.on_transaction_completed(this.last_transaction_stats);\r\n    }\r\n\r\n    private _record_transaction_statistics(requestData: RequestData) {\r\n        const request = requestData.request;\r\n        const response = requestData.response;\r\n        // ---------------------------------------------------------------------------------------------------------|-\r\n        //      _tick0                _tick1                         _tick2                       _tick3          _tick4\r\n        //          sending request\r\n        //        |---------------------|  waiting response\r\n        //                              |------------------------------|      receiving response\r\n        //                                                             |---------------------------| process.resp\r\n        //                                                                                  |---------------|\r\n        this.last_transaction_stats = {\r\n            bytesRead: requestData.bytesRead,\r\n            bytesWritten: requestData.bytesWritten_after - requestData.bytesWritten_before,\r\n            lap_processing_response: requestData._tick4 - requestData._tick3,\r\n            lap_receiving_response: requestData._tick3 - requestData._tick2,\r\n            lap_sending_request: requestData._tick1 - requestData._tick0,\r\n            lap_transaction: requestData._tick4 - requestData._tick0,\r\n            lap_waiting_response: requestData._tick2 - requestData._tick1,\r\n            request,\r\n            response\r\n        };\r\n\r\n        if (doTraceStatistics) {\r\n            _dump_client_transaction_statistics(this.last_transaction_stats);\r\n        }\r\n    }\r\n\r\n    private _cancel_pending_transactions(err?: Error | null) {\r\n        if (doDebug && this._requests) {\r\n            debugLog(\r\n                \"_cancel_pending_transactions  \",\r\n                Object.keys(this._requests),\r\n                this._transport ? this._transport.name : \"no transport\"\r\n            );\r\n        }\r\n\r\n        if (this._requests) {\r\n            for (const requestData of Object.values(this._requests)) {\r\n                if (requestData) {\r\n                    const request = requestData.request;\r\n                    doDebug &&\r\n                        debugLog(\"Cancelling pending transaction \", requestData.key, requestData.msgType, request?.schema.name);\r\n                    process_request_callback(requestData, err);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._requests = {};\r\n    }\r\n\r\n    private _on_transport_closed(err?: Error | null) {\r\n        doDebug && debugLog(\" =>ClientSecureChannelLayer#_on_transport_closed  err=\", err ? err.message : \"null\");\r\n\r\n        if (this.__in_normal_close_operation) {\r\n            err = undefined;\r\n        }\r\n        this.emit(\"close\", err);\r\n\r\n        //\r\n        this._bytesRead += this._transport?.bytesRead || 0;\r\n        this._bytesWritten += this._transport?.bytesWritten || 0;\r\n\r\n        this._transport?.dispose();\r\n        this._transport = undefined;\r\n        this._cancel_pending_transactions(err);\r\n        this._cancel_security_token_watchdog();\r\n        this.dispose();\r\n    }\r\n\r\n    private _on_security_token_about_to_expire() {\r\n        if (!this.securityToken) {\r\n            return;\r\n        }\r\n\r\n        doDebug &&\r\n            debugLog(\r\n                \" client: Security Token \",\r\n                this.securityToken.tokenId,\r\n                \" is about to expired, let's raise lifetime_75 event \"\r\n            );\r\n\r\n        this.emit(\"lifetime_75\", this.securityToken);\r\n        this._renew_security_token();\r\n    }\r\n\r\n    private _cancel_security_token_watchdog() {\r\n        if (this._securityTokenTimeoutId) {\r\n            clearTimeout(this._securityTokenTimeoutId);\r\n            this._securityTokenTimeoutId = null;\r\n        }\r\n    }\r\n\r\n    private _install_security_token_watchdog() {\r\n        if (!this.securityToken) {\r\n            errorLog(\"Failed to install security token watch dog before securityToken is null!\");\r\n            return;\r\n        }\r\n\r\n        // install timer event to raise a 'lifetime_75' when security token is about to expired\r\n        // so that client can request for a new security token\r\n        // note that, for speedup in test,\r\n        // it is possible to tweak this interval for test by specifying a tokenRenewalInterval value\r\n        //\r\n        const lifeTime = this.securityToken.revisedLifetime;\r\n        assert(lifeTime !== 0 && lifeTime > 20);\r\n        const percent = 75 / 100.0;\r\n        let timeout = this.tokenRenewalInterval || lifeTime * percent;\r\n        timeout = Math.min(timeout, (lifeTime * 75) / 100);\r\n        timeout = Math.max(timeout, 50); // at least one half second !\r\n\r\n        if (doDebug) {\r\n            debugLog(\r\n                chalk.red.bold(\" time until next security token renewal = \"),\r\n                timeout,\r\n                \"( lifetime = \",\r\n                lifeTime + \" -  tokenRenewalInterval =\" + this.tokenRenewalInterval\r\n            );\r\n        }\r\n        assert(this._securityTokenTimeoutId === null);\r\n        // security token renewal should happen without overlapping\r\n        this._securityTokenTimeoutId = setTimeout(() => {\r\n            this._securityTokenTimeoutId = null;\r\n            this._on_security_token_about_to_expire();\r\n        }, timeout);\r\n    }\r\n\r\n    private _build_client_nonce() {\r\n        if (this.securityMode === MessageSecurityMode.None) {\r\n            return null;\r\n        }\r\n        // create a client Nonce if secure mode is requested\r\n        // Release 1.02 page 23 OPC Unified Architecture, Part 4 Table 7 \u2013 OpenSecureChannel Service Parameters\r\n        // clientNonce\r\n        // \"This parameter shall have a length equal to key size used for the symmetric\r\n        //  encryption algorithm that is identified by the securityPolicyUri\"\r\n\r\n        const cryptoFactory = getCryptoFactory(this.securityPolicy);\r\n        if (!cryptoFactory) {\r\n            // this securityPolicy may not be support yet ... let's return null\r\n            return null;\r\n        }\r\n        assert(cryptoFactory !== null && typeof cryptoFactory === \"object\");\r\n        return randomBytes(cryptoFactory.symmetricKeyLength);\r\n    }\r\n\r\n    private _open_secure_channel_request(isInitial: boolean, callback: ErrorCallback) {\r\n        assert(this.securityMode !== MessageSecurityMode.Invalid, \"invalid security mode\");\r\n        // from the specs:\r\n        // The OpenSecureChannel Messages are not signed or encrypted if the SecurityMode is None. The\r\n        // nonces  are ignored and should be set to null. The SecureChannelId and the TokenId are still\r\n        // assigned but no security is applied to Messages exchanged via the channel.\r\n\r\n        const msgType = \"OPN\";\r\n        const requestType = isInitial ? SecurityTokenRequestType.Issue : SecurityTokenRequestType.Renew;\r\n\r\n        this.clientNonce = this._build_client_nonce();\r\n\r\n        this._isOpened = !isInitial;\r\n\r\n        // OpenSecureChannel\r\n        const msg = new OpenSecureChannelRequest({\r\n            clientNonce: this.clientNonce, //\r\n            clientProtocolVersion: this.protocolVersion,\r\n            requestHeader: {\r\n                auditEntryId: null\r\n            },\r\n            requestType: requestType,\r\n            requestedLifetime: this.defaultSecureTokenLifetime,\r\n            securityMode: this.securityMode\r\n        });\r\n\r\n        this._performMessageTransaction(msgType, msg, (err?: Error | null, response?: Response) => {\r\n            // istanbul ignore next\r\n            if (response && response.responseHeader && response.responseHeader.serviceResult !== StatusCodes.Good) {\r\n                warningLog(\r\n                    \"xxxxx => response.responseHeader.serviceResult \",\r\n                    response.constructor.name,\r\n                    response.responseHeader.serviceResult.toString()\r\n                );\r\n                err = new Error(response.responseHeader.serviceResult.toString());\r\n            }\r\n            if (!err && response) {\r\n                const openSecureChannelResponse = response as OpenSecureChannelResponse;\r\n\r\n                // record channelId for future transactions\r\n                this.channelId = openSecureChannelResponse.securityToken.channelId;\r\n\r\n                // todo : verify that server certificate is  valid\r\n                // A self-signed application instance certificate does not need to be verified with a CA.\r\n                // todo : verify that Certificate URI matches the ApplicationURI of the server\r\n\r\n                assert(\r\n                    openSecureChannelResponse.securityToken.tokenId > 0 || msgType === \"OPN\",\r\n                    \"_sendSecureOpcUARequest: invalid token Id \"\r\n                );\r\n                assert(Object.prototype.hasOwnProperty.call(openSecureChannelResponse, \"serverNonce\"));\r\n                this.securityToken = openSecureChannelResponse.securityToken;\r\n                this.serverNonce = openSecureChannelResponse.serverNonce;\r\n\r\n                if (this.securityMode !== MessageSecurityMode.None) {\r\n                    // verify that server nonce if provided is at least 32 bytes long\r\n\r\n                    /* istanbul ignore next */\r\n                    if (!openSecureChannelResponse.serverNonce) {\r\n                        warningLog(\" client : server nonce is missing !\");\r\n                        return callback(new Error(\" Invalid server nonce\"));\r\n                    }\r\n                    // This parameter shall have a length equal to key size used for the symmetric\r\n                    // encryption algorithm that is identified by the securityPolicyUri.\r\n                    if (openSecureChannelResponse.serverNonce.length !== this.clientNonce.length) {\r\n                        warningLog(\" client : server nonce is invalid  (invalid length)!\");\r\n                        return callback(new Error(\" Invalid server nonce length\"));\r\n                    }\r\n                }\r\n\r\n                const cryptoFactory = this.messageBuilder!.cryptoFactory;\r\n                if (cryptoFactory) {\r\n                    assert(this.serverNonce instanceof Buffer);\r\n                    /* istanbul ignore next */\r\n                    if (!this.serverNonce) {\r\n                        throw new Error(\"internal error\");\r\n                    }\r\n                    this.derivedKeys = computeDerivedKeys(cryptoFactory, this.serverNonce, this.clientNonce);\r\n                }\r\n\r\n                const derivedServerKeys = this.derivedKeys ? this.derivedKeys.derivedServerKeys : null;\r\n\r\n                // istanbul ignore next\r\n                if (doDebug) {\r\n                    debugLog(\"Server has send a new security Token\");\r\n                }\r\n\r\n                this.messageBuilder!.pushNewToken(this.securityToken, derivedServerKeys);\r\n\r\n                this._install_security_token_watchdog();\r\n\r\n                this._isOpened = true;\r\n            }\r\n            callback(err || undefined);\r\n        });\r\n    }\r\n\r\n    private _on_connection(transport: ClientTCP_transport, callback: ErrorCallback) {\r\n        assert(this._pending_transport === transport);\r\n        this._pending_transport = undefined;\r\n        this._transport = transport;\r\n\r\n        // install message chunker limits:\r\n        this.messageChunker.maxMessageSize = this._transport?.maxMessageSize || 0;\r\n        this.messageChunker.maxChunkCount = this._transport?.maxChunkCount || 0;\r\n\r\n        this._install_message_builder();\r\n\r\n        this._transport.on(\"chunk\", (messageChunk: Buffer) => {\r\n            this.emit(\"receive_chunk\", messageChunk);\r\n            this._on_receive_message_chunk(messageChunk);\r\n        });\r\n\r\n        this._transport.on(\"close\", (err: Error | null) => this._on_transport_closed(err));\r\n\r\n        this._transport.on(\"connection_break\", () => {\r\n            doDebug && debugLog(chalk.red(\"Client => CONNECTION BREAK  <=\"));\r\n            this._on_transport_closed(new Error(\"Connection Break\"));\r\n        });\r\n\r\n        setImmediate(() => {\r\n            doDebug && debugLog(chalk.red(\"Client now sending OpenSecureChannel\"));\r\n            const isInitial = true;\r\n            this._open_secure_channel_request(isInitial, callback);\r\n        });\r\n    }\r\n\r\n    private _backoff_completion(\r\n        err: Error | undefined,\r\n        lastError: Error | undefined,\r\n        transport: ClientTCP_transport,\r\n        callback: ErrorCallback\r\n    ) {\r\n        if (this.__call) {\r\n            // console log =\r\n            transport.numberOfRetry = transport.numberOfRetry || 0;\r\n            transport.numberOfRetry += this.__call.getNumRetries();\r\n            this.__call.removeAllListeners();\r\n            this.__call = null;\r\n\r\n            if (err) {\r\n                callback(lastError || err);\r\n            } else {\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _connect(transport: ClientTCP_transport, endpointUrl: string, _i_callback: ErrorCallback) {\r\n        if (this.__call && this.__call._cancelBackoff) {\r\n            return;\r\n        }\r\n\r\n        const on_connect = (err?: Error) => {\r\n            doDebug && debugLog(\"Connection => err\", err ? err.message : \"null\");\r\n            // force Backoff to fail if err is not ECONNRESET or ECONNREFUSED\r\n            // this mean that the connection to the server has succeeded but for some reason\r\n            // the server has denied the connection\r\n            // the cause could be:\r\n            //   - invalid protocol version specified by client\r\n            //   - server going to shutdown\r\n            //   - server too busy -\r\n            //   - server shielding itself from a DDOS attack\r\n            if (err) {\r\n                let should_abort = this._isDisconnecting;\r\n\r\n                if (err.message.match(/ECONNRESET/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadProtocolVersionUnsupported/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadTcpInternalError/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadTcpMessageTooLarge/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadTcpEndpointUriInvlid/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadTcpMessageTypeInvalid/)) {\r\n                    should_abort = true;\r\n                }\r\n\r\n                this.lastError = err;\r\n\r\n                if (this.__call) {\r\n                    // connection cannot be establish ? if not, abort the backoff process\r\n                    if (should_abort) {\r\n                        doDebug && debugLog(\" Aborting backoff process prematurely - err = \", err.message);\r\n                        this.__call.abort();\r\n                    } else {\r\n                        doDebug && debugLog(\" backoff - keep trying - err = \", err.message);\r\n                    }\r\n                }\r\n            }\r\n            _i_callback(err);\r\n        };\r\n\r\n        transport.connect(endpointUrl, on_connect);\r\n    }\r\n\r\n    private _establish_connection(transport: ClientTCP_transport, endpointUrl: string, callback: ErrorCallback) {\r\n        transport.protocolVersion = this.protocolVersion;\r\n\r\n        this.lastError = undefined;\r\n\r\n        if (this.connectionStrategy.maxRetry === 0) {\r\n            doDebug && debugLog(chalk.cyan(\"max Retry === 0 =>  No backoff required -> call the _connect function directly\"));\r\n            this.__call = 0;\r\n            return this._connect(transport, endpointUrl, callback);\r\n        }\r\n\r\n        const connectFunc = (callback2: ErrorCallback) => {\r\n            return this._connect(transport, endpointUrl, callback2);\r\n        };\r\n        const completionFunc = (err?: Error) => {\r\n            return this._backoff_completion(err, this.lastError, transport, callback);\r\n        };\r\n\r\n        this.__call = backoff.call(connectFunc, completionFunc);\r\n\r\n        if (this.connectionStrategy.maxRetry >= 0) {\r\n            const maxRetry = Math.max(this.connectionStrategy.maxRetry, 1);\r\n            doDebug && debugLog(chalk.cyan(\"backoff will failed after \"), maxRetry);\r\n            this.__call.failAfter(maxRetry);\r\n        } else {\r\n            // retry will be infinite\r\n            doDebug && debugLog(chalk.cyan(\"backoff => starting a infinite retry\"));\r\n        }\r\n\r\n        const onBackoffFunc = (retryCount: number, delay: number) => {\r\n            doDebug &&\r\n                debugLog(\r\n                    chalk.bgWhite.cyan(\" Backoff #\"),\r\n                    retryCount,\r\n                    \"delay = \",\r\n                    delay,\r\n                    \" ms\",\r\n                    \" maxRetry \",\r\n                    this.connectionStrategy.maxRetry\r\n                );\r\n            // Do something when backoff starts, e.g. show to the\r\n            // user the delay before next reconnection attempt.\r\n            this.emit(\"backoff\", retryCount, delay);\r\n        };\r\n\r\n        this.__call.on(\"backoff\", onBackoffFunc);\r\n\r\n        this.__call.on(\"abort\", () => {\r\n            doDebug && debugLog(chalk.bgWhite.cyan(` abort #   after ${this.__call.getNumRetries()} retries.`));\r\n            // Do something when backoff starts, e.g. show to the\r\n            // user the delay before next reconnection attempt.\r\n            this.emit(\"abort\");\r\n            setImmediate(() => {\r\n                this._backoff_completion(undefined, new Error(\"Connection abandoned\"), transport, callback);\r\n            });\r\n        });\r\n\r\n        this.__call.setStrategy(new backoff.ExponentialStrategy(this.connectionStrategy));\r\n        this.__call.start();\r\n    }\r\n\r\n    private _renew_security_token() {\r\n        doDebug && debugLog(\"ClientSecureChannelLayer#_renew_security_token\");\r\n\r\n        // istanbul ignore next\r\n        if (!this.isValid()) {\r\n            // this may happen if the communication has been closed by the client or the sever\r\n            warningLog(\"Invalid socket => Communication has been lost, cannot renew token\");\r\n            return;\r\n        }\r\n\r\n        const isInitial = false;\r\n        this._open_secure_channel_request(isInitial, (err?: Error | null) => {\r\n            /* istanbul ignore else */\r\n            if (!err) {\r\n                doDebug && debugLog(\" token renewed\");\r\n                this.emit(\"security_token_renewed\");\r\n            } else {\r\n                if (doDebug) {\r\n                    debugLog(\"ClientSecureChannelLayer: Warning: securityToken hasn't been renewed -> err \", err);\r\n                }\r\n                // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX CHECK ME !!!\r\n                this._closeWithError(\r\n                    new Error(\"Restarting because Request has timed out during OpenSecureChannel\"),\r\n                    StatusCodes2.BadRequestTimeout\r\n                );\r\n            }\r\n        });\r\n    }\r\n\r\n    private _on_receive_message_chunk(messageChunk: Buffer) {\r\n        /* istanbul ignore next */\r\n        if (doDebug1) {\r\n            const _stream = new BinaryStream(messageChunk);\r\n            const messageHeader = readMessageHeader(_stream);\r\n            debugLog(\"CLIENT RECEIVED \" + chalk.yellow(JSON.stringify(messageHeader) + \"\"));\r\n            debugLog(\"\\n\" + hexDump(messageChunk));\r\n            debugLog(messageHeaderToString(messageChunk));\r\n        }\r\n        this.messageBuilder!.feed(messageChunk);\r\n    }\r\n\r\n    /**\r\n     * @method makeRequestId\r\n     * @return  newly generated request id\r\n     * @private\r\n     */\r\n    private makeRequestId(): number {\r\n        this._lastRequestId += 1;\r\n        return this._lastRequestId;\r\n    }\r\n\r\n    /**\r\n     * internal version of _performMessageTransaction.\r\n     *\r\n     * @method _performMessageTransaction\r\n     * @private\r\n     *\r\n     * - this method takes a extra parameter : msgType\r\n     * TODO:\r\n     * - this method can be re-entrant, meaning that a new transaction can be started before any pending transaction\r\n     *   is fully completed.\r\n     * - Any error on transport will cause all pending transactions to be cancelled\r\n     *\r\n     * - the method returns a timeout Error if the server fails to return a response within the timeoutHint interval.\r\n     *\r\n     *\r\n     */\r\n\r\n    private _performMessageTransaction(msgType: string, request: Request, callback: PerformTransactionCallback) {\r\n        assert(typeof callback === \"function\");\r\n\r\n        if (!this.isValid()) {\r\n            return callback(\r\n                new Error(\"ClientSecureChannelLayer => Socket is closed ! while processing \" + request.constructor.name)\r\n            );\r\n        }\r\n\r\n        let localCallback: PerformTransactionCallback | null = callback;\r\n\r\n        let timeout = request.requestHeader.timeoutHint || ClientSecureChannelLayer.defaultTransactionTimeout;\r\n        timeout = Math.max(ClientSecureChannelLayer.minTransactionTimeout, timeout);\r\n\r\n        // adjust request timeout\r\n        request.requestHeader.timeoutHint = timeout;\r\n\r\n        /* istanbul ignore next */\r\n        if (doDebug) {\r\n            debugLog(\"Adjusted timeout = \", request.requestHeader.timeoutHint);\r\n        }\r\n        let timerId: any = null;\r\n\r\n        let hasTimedOut = false;\r\n\r\n        const modified_callback = (err?: Error | null, response?: Response) => {\r\n            /* istanbul ignore next */\r\n            if (doDebug) {\r\n                debugLog(\r\n                    chalk.cyan(\"------------------------------------- Client receiving response \"),\r\n                    request.constructor.name,\r\n                    request.requestHeader.requestHandle,\r\n                    response ? response.constructor.name : \"null\",\r\n                    \"err=\",\r\n                    err ? err.message : \"null\",\r\n                    \"securityTokenId=\",\r\n                    this.securityToken ? this.securityToken!.tokenId : \"x\"\r\n                );\r\n            }\r\n            if (response && doTraceClientRequestContent) {\r\n                warningLog(response.toString());\r\n            }\r\n\r\n            if (!localCallback) {\r\n                return; // already processed by time  out\r\n            }\r\n            // when response === null we are processing the timeout , therefore there is no need to clearTimeout\r\n            if (!hasTimedOut && timerId) {\r\n                clearTimeout(timerId);\r\n            }\r\n            timerId = null;\r\n\r\n            if (!err && response) {\r\n                this.emit(\"receive_response\", response);\r\n            }\r\n            assert(!err || err instanceof Error);\r\n\r\n            delete this._requests[request.requestHeader.requestHandle];\r\n            // invoke user callback if it has not been intercepted first ( by a abrupt disconnection for instance )\r\n            try {\r\n                localCallback.call(this, err || null, response);\r\n            } catch (err1) {\r\n                errorLog(\"ERROR !!! callback has thrown en error \", err1);\r\n                callback(err || null);\r\n            } finally {\r\n                localCallback = null;\r\n            }\r\n        };\r\n\r\n        const optionalTrace = !checkTimeout || new Error().stack;\r\n\r\n        timerId = setTimeout(() => {\r\n            timerId = null;\r\n            hasTimedOut = true;\r\n            if (checkTimeout) {\r\n                warningLog(\" Timeout .... waiting for response for \", request.constructor.name, request.requestHeader.toString());\r\n                warningLog(\" Timeout was \", timeout, \"ms\");\r\n                warningLog(request.toString());\r\n                warningLog(optionalTrace);\r\n            }\r\n            modified_callback(\r\n                new Error(\"Transaction has timed out ( timeout = \" + timeout + \" ms , request = \" + request.constructor.name + \")\")\r\n            );\r\n            this._timeout_request_count += 1;\r\n\r\n            this.emit(\"timed_out_request\", request);\r\n            // xx // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX CHECK ME !!!\r\n            // xx this.closeWithError(new Error(\"Restarting because Request has timed out (1)\"), () => { });\r\n        }, timeout);\r\n\r\n        const transaction_data = {\r\n            callback: modified_callback,\r\n            msgType: msgType,\r\n            request: request,\r\n            timerId: timerId\r\n        };\r\n\r\n        this._internal_perform_transaction(transaction_data);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param transactionData\r\n     * @param transactionData.msgType\r\n     * @param transactionData.request\r\n     * @param transactionData.callback\r\n     * @private\r\n     */\r\n\r\n    private _internal_perform_transaction(transactionData: TransactionData) {\r\n        assert(typeof transactionData.callback === \"function\");\r\n\r\n        if (!this._transport) {\r\n            setTimeout(() => {\r\n                transactionData.callback(new Error(\"Client not connected\"));\r\n            }, 100);\r\n            return;\r\n        }\r\n        assert(this._transport, \" must have a valid transport\");\r\n\r\n        const msgType = transactionData.msgType;\r\n        const request = transactionData.request;\r\n\r\n        assert(msgType.length === 3);\r\n        // get a new requestId\r\n        const requestHandle = this.makeRequestId();\r\n\r\n        /* istanbul ignore next */\r\n        if (request.requestHeader.requestHandle !== requestHandleNotSetValue) {\r\n            errorLog(\r\n                chalk.bgRed.white(\"xxxxx   >>>>>> request has already been set with a requestHandle\"),\r\n                requestHandle,\r\n                request.requestHeader.requestHandle,\r\n                request.constructor.name\r\n            );\r\n            errorLog(Object.keys(this._requests).join(\" \"));\r\n            errorLog(new Error(\"Investigate me\"));\r\n        }\r\n\r\n        request.requestHeader.requestHandle = requestHandle;\r\n\r\n        /* istanbul ignore next */\r\n        if (doTraceClientMessage) {\r\n            traceClientRequestMessage(request, this.channelId, this._counter);\r\n        }\r\n\r\n        const requestData: RequestData = {\r\n            callback: transactionData.callback,\r\n            msgType: msgType,\r\n            request: request,\r\n\r\n            bytesRead: 0,\r\n            bytesWritten_after: 0,\r\n            bytesWritten_before: this.bytesWritten,\r\n\r\n            _tick0: 0,\r\n            _tick1: 0,\r\n            _tick2: 0,\r\n            _tick3: 0,\r\n            _tick4: 0,\r\n            key: \"\",\r\n\r\n            chunk_count: 0\r\n        };\r\n\r\n        this._requests[requestHandle] = requestData;\r\n\r\n        /* istanbul ignore next */\r\n        if (doPerfMonitoring) {\r\n            const stats = requestData;\r\n            // record tick0 : befoe request is being sent to server\r\n            stats._tick0 = get_clock_tick();\r\n        }\r\n        // check that limits are OK\r\n        this._sendSecureOpcUARequest(msgType, request, requestHandle);\r\n    }\r\n\r\n    private _send_chunk(requestId: number, chunk: Buffer | null) {\r\n        const requestData = this._requests[requestId];\r\n\r\n        if (chunk) {\r\n            this.emit(\"send_chunk\", chunk);\r\n\r\n            /* istanbul ignore next */\r\n            if (checkChunks) {\r\n                verify_message_chunk(chunk);\r\n                debugLog(chalk.yellow(\"CLIENT SEND chunk \"));\r\n                debugLog(chalk.yellow(messageHeaderToString(chunk)));\r\n                debugLog(chalk.red(hexDump(chunk)));\r\n            }\r\n            assert(this._transport);\r\n            this._transport?.write(chunk);\r\n            requestData.chunk_count += 1;\r\n        } else {\r\n            // last chunk ....\r\n\r\n            /* istanbul ignore next */\r\n            if (checkChunks) {\r\n                debugLog(chalk.yellow(\"CLIENT SEND done.\"));\r\n            }\r\n            if (requestData) {\r\n                if (doPerfMonitoring) {\r\n                    requestData._tick1 = get_clock_tick();\r\n                }\r\n                requestData.bytesWritten_after = this.bytesWritten;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _construct_security_header() {\r\n        this.receiverCertificate = this.serverCertificate ? Buffer.from(this.serverCertificate) : null;\r\n        let securityHeader = null;\r\n        switch (this.securityMode) {\r\n            case MessageSecurityMode.Sign:\r\n            case MessageSecurityMode.SignAndEncrypt: {\r\n                assert(this.securityPolicy !== SecurityPolicy.None);\r\n                // get the thumbprint of the client certificate\r\n                const receiverCertificateThumbprint = getThumbprint(this.receiverCertificate);\r\n\r\n                securityHeader = new AsymmetricAlgorithmSecurityHeader({\r\n                    receiverCertificateThumbprint, // thumbprint of the public key used to encrypt the message\r\n                    securityPolicyUri: toURI(this.securityPolicy),\r\n\r\n                    /**\r\n                     * The X.509 v3 Certificate assigned to the sending application Instance.\r\n                     *  This is a DER encoded blob.\r\n                     * The structure of an X.509 v3 Certificate is defined in X.509 v3.\r\n                     * The DER format for a Certificate is defined in X690\r\n                     * This indicates what Private Key was used to sign the MessageChunk.\r\n                     * The Stack shall close the channel and report an error to the application if the SenderCertificate is too large for the buffer size supported by the transport layer.\r\n                     * This field shall be null if the Message is not signed.\r\n                     * If the Certificate is signed by a CA, the DER encoded CA Certificate may be\r\n                     * appended after the Certificate in the byte array. If the CA Certificate is also\r\n                     * signed by another CA this process is repeated until the entire Certificate chain\r\n                     *  is in the buffer or if MaxSenderCertificateSize limit is reached (the process\r\n                     * stops after the last whole Certificate that can be added without exceeding\r\n                     * the MaxSenderCertificateSize limit).\r\n                     * Receivers can extract the Certificates from the byte array by using the Certificate\r\n                     *  size contained in DER header (see X.509 v3).\r\n                     */\r\n                    senderCertificate: this.getCertificateChain() // certificate of the private key used to sign the message\r\n                });\r\n\r\n                if (dumpSecurityHeader) {\r\n                    warningLog(\"HEADER !!!! \", securityHeader.toString());\r\n                }\r\n                break;\r\n            }\r\n            default:\r\n                /* istanbul ignore next */\r\n                assert(false, \"invalid security mode\");\r\n        }\r\n        this.securityHeader = securityHeader;\r\n    }\r\n\r\n    private _get_security_options_for_OPN() {\r\n        if (this.securityMode === MessageSecurityMode.None) {\r\n            return null;\r\n        }\r\n\r\n        this._construct_security_header();\r\n        this.messageChunker.securityHeader = this.securityHeader;\r\n\r\n        const senderPrivateKey = this.getPrivateKey();\r\n\r\n        if (!senderPrivateKey) {\r\n            throw new Error(\"invalid senderPrivateKey\");\r\n        }\r\n\r\n        const cryptoFactory = getCryptoFactory(this.securityPolicy);\r\n\r\n        if (!cryptoFactory) {\r\n            return null; // may be a not yet supported security Policy\r\n        }\r\n\r\n        assert(cryptoFactory, \"expecting a cryptoFactory\");\r\n        assert(typeof cryptoFactory.asymmetricSign === \"function\");\r\n\r\n        const options: any = {};\r\n\r\n        options.signatureLength = rsa_length(senderPrivateKey);\r\n\r\n        options.signBufferFunc = (chunk: Buffer) => {\r\n            const s = cryptoFactory.asymmetricSign(chunk, senderPrivateKey);\r\n            assert(s.length === options.signatureLength);\r\n            return s;\r\n        };\r\n\r\n        // istanbul ignore next\r\n        if (!this.receiverPublicKey) {\r\n            throw new Error(\" invalid receiverPublicKey\");\r\n        }\r\n        const keyLength = rsa_length(this.receiverPublicKey);\r\n        options.plainBlockSize = keyLength - cryptoFactory.blockPaddingSize;\r\n        options.cipherBlockSize = keyLength;\r\n\r\n        const receiverPublicKey = this.receiverPublicKey;\r\n        options.encryptBufferFunc = (chunk: Buffer): Buffer => {\r\n            return cryptoFactory.asymmetricEncrypt(chunk, receiverPublicKey);\r\n        };\r\n\r\n        return options;\r\n    }\r\n\r\n    private _get_security_options_for_MSG() {\r\n        if (this.securityMode === MessageSecurityMode.None) {\r\n            return null;\r\n        }\r\n\r\n        // istanbul ignore next\r\n        if (!this.derivedKeys || !this.derivedKeys.derivedClientKeys) {\r\n            errorLog(\"derivedKeys not set but security mode = \", MessageSecurityMode[this.securityMode]);\r\n            return null; // \r\n            // throw new Error(\"internal error expecting valid derivedKeys while security mode is \" + MessageSecurityMode[this.securityMode]);\r\n        }\r\n\r\n        const derivedClientKeys = this.derivedKeys.derivedClientKeys;\r\n        assert(derivedClientKeys, \"expecting valid derivedClientKeys\");\r\n        return getOptionsForSymmetricSignAndEncrypt(this.securityMode, derivedClientKeys);\r\n    }\r\n\r\n    private _sendSecureOpcUARequest(msgType: string, request: Request, requestId: number) {\r\n        const tokenId = this.securityToken ? this.securityToken.tokenId : 0;\r\n\r\n        // assert(this.channelId !== 0 , \"channel Id cannot be null\");\r\n\r\n        let options: ChunkMessageOptions = {\r\n            channelId: this.channelId,\r\n            chunkSize: 0,\r\n            requestId,\r\n            tokenId,\r\n\r\n            cipherBlockSize: 0,\r\n            plainBlockSize: 0,\r\n            sequenceHeaderSize: 0,\r\n            signatureLength: 0\r\n        };\r\n\r\n        // use chunk size that has been negotiated by the transport layer\r\n        if (this._transport?.parameters && this._transport?.parameters.sendBufferSize) {\r\n            options.chunkSize = this._transport.parameters.sendBufferSize;\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        if (request.requestHeader.requestHandle !== options.requestId) {\r\n            doDebug &&\r\n                debugLog(\r\n                    chalk.red.bold(\"------------------------------------- Invalid request id\"),\r\n                    request.requestHeader.requestHandle,\r\n                    options.requestId\r\n                );\r\n        }\r\n\r\n        request.requestHeader.returnDiagnostics = 0x0;\r\n\r\n        /* istanbul ignore next */\r\n        if (doTraceClientRequestContent) {\r\n            warningLog(\r\n                chalk.yellow.bold(\"------------------------------------- Client Sending a request  \"),\r\n                request.constructor.name,\r\n                \"h=\",\r\n                request.requestHeader.requestHandle,\r\n                \" channel id \",\r\n                this.channelId,\r\n                \" securityToken=\",\r\n                this.securityToken! ? this.securityToken!.tokenId : \"x\"\r\n            );\r\n        }\r\n        if (doTraceClientRequestContent) {\r\n            warningLog(request.toString());\r\n        }\r\n\r\n        const security_options = msgType === \"OPN\" ? this._get_security_options_for_OPN() : this._get_security_options_for_MSG();\r\n        if (security_options) {\r\n            options = {\r\n                ...options,\r\n                ...security_options\r\n            };\r\n        }\r\n\r\n        this.emit(\"send_request\", request);\r\n\r\n        this.messageChunker.chunkSecureMessage(\r\n            msgType,\r\n            options,\r\n            request as BaseUAObject,\r\n            (err: Error | null, chunk: Buffer | null) => {\r\n                if (err) {\r\n                    // the messageChunk has not send anything due to an error detected in the chunker\r\n                    const response = new ServiceFault({\r\n                        responseHeader: {\r\n                            serviceResult: StatusCodes.BadInternalError,\r\n                            stringTable: [err.message]\r\n                        }\r\n                    });\r\n                    this._send_chunk(requestId, null);\r\n                    this._on_message_received(response, \"ERR\", request.requestHeader.requestHandle);\r\n                } else {\r\n                    this._send_chunk(requestId, chunk);\r\n                }\r\n            }\r\n        );\r\n    }\r\n}\r\n", "/**\n * @module node-opcua-server-discovery\n */\n\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport * as url from \"url\";\nimport { callbackify } from \"util\";\n\nimport * as chalk from \"chalk\";\nimport envPaths = require(\"env-paths\");\n\nimport { assert } from \"node-opcua-assert\";\nimport { UAString } from \"node-opcua-basic-types\";\nimport { makeApplicationUrn } from \"node-opcua-common\";\nimport { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\nimport { extractFullyQualifiedDomainName, resolveFullyQualifiedDomainName } from \"node-opcua-hostname\";\nimport { Message, Response, ServerSecureChannelLayer } from \"node-opcua-secure-channel\";\nimport { OPCUABaseServer, OPCUABaseServerOptions, OPCUAServerEndPoint } from \"node-opcua-server\";\n\nimport {\n    Announcement,\n    BonjourHolder,\n    FindServersOnNetworkRequest,\n    FindServersOnNetworkResponse,\n    MdnsDiscoveryConfiguration,\n    RegisteredServer,\n    RegisterServer2Request,\n    RegisterServer2Response,\n    RegisterServerRequest,\n    RegisterServerResponse,\n    sameService,\n    serviceToString,\n    announcementToServiceConfig,\n    ServerOnNetwork\n} from \"node-opcua-service-discovery\";\nimport { OPCUACertificateManager } from \"node-opcua-certificate-manager\";\nimport { ApplicationDescription } from \"node-opcua-service-endpoints\";\nimport { ApplicationDescriptionOptions, ApplicationType } from \"node-opcua-service-endpoints\";\nimport { ErrorCallback, StatusCode, StatusCodes } from \"node-opcua-status-code\";\n\nimport { MDNSResponder } from \"./mdns_responder\";\n\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\n\nfunction hasCapabilities(serverCapabilities: UAString[] | null, serverCapabilityFilter: string): boolean {\n    if (serverCapabilities == null) {\n        return true; // filter is empty => no filtering should take place\n    }\n    if (serverCapabilityFilter.length === 0) {\n        return true; // filter is empty => no filtering should take place\n    }\n    return !!serverCapabilities.join(\" \").match(serverCapabilityFilter);\n}\n\nexport interface OPCUADiscoveryServerOptions extends OPCUABaseServerOptions {\n    certificateFile?: string;\n    port?: number;\n}\n\ninterface RegisteredServerExtended extends RegisteredServer {\n    bonjourHolder: BonjourHolder;\n    serverInfo: ApplicationDescriptionOptions;\n    discoveryConfiguration?: MdnsDiscoveryConfiguration[];\n}\n\ninterface RegisterServerMap {\n    [key: string]: RegisteredServerExtended;\n}\n\nconst defaultProductUri = \"NodeOPCUA-LocalDiscoveryServer\";\nconst defaultApplicationUri = makeApplicationUrn(os.hostname(), defaultProductUri);\n\nfunction getDefaultCertificateManager(): OPCUACertificateManager {\n    const config = envPaths(defaultProductUri).config;\n    return new OPCUACertificateManager({\n        name: \"PKI\",\n        rootFolder: path.join(config, \"PKI\"),\n\n        automaticallyAcceptUnknownCertificate: true\n    });\n}\n\nexport class OPCUADiscoveryServer extends OPCUABaseServer {\n    private mDnsResponder?: MDNSResponder;\n    private readonly registeredServers: RegisterServerMap;\n    private bonjourHolder: BonjourHolder;\n    private _delayInit?: () => void;\n\n    constructor(options: OPCUADiscoveryServerOptions) {\n        options.serverInfo = options.serverInfo || {};\n        const serverInfo = options.serverInfo;\n\n        serverInfo.applicationType = ApplicationType.DiscoveryServer;\n\n        serverInfo.applicationUri = serverInfo.applicationUri || defaultApplicationUri;\n\n        serverInfo.productUri = serverInfo.productUri || defaultProductUri;\n\n        serverInfo.applicationName = serverInfo.applicationName || {\n            text: defaultProductUri,\n\n            locale: null\n        };\n\n        serverInfo.gatewayServerUri = serverInfo.gatewayServerUri || \"\";\n        serverInfo.discoveryProfileUri = serverInfo.discoveryProfileUri || \"\";\n        serverInfo.discoveryUrls = serverInfo.discoveryUrls || [];\n\n        options.serverCertificateManager = options.serverCertificateManager || getDefaultCertificateManager();\n\n        super(options);\n\n        this.bonjourHolder = new BonjourHolder();\n\n        // see OPC UA Spec 1.2 part 6 : 7.4 Well Known Addresses\n        // opc.tcp://localhost:4840/UADiscovery\n        const port = options.port || 4840;\n\n        this.capabilitiesForMDNS = [\"LDS\"];\n        this.registeredServers = {};\n\n        this.mDnsResponder = undefined;\n\n        this._delayInit = async (): Promise<void> => {\n            const endPoint = new OPCUAServerEndPoint({\n                port,\n\n                certificateChain: this.getCertificateChain(),\n\n                certificateManager: this.serverCertificateManager,\n\n                privateKey: this.getPrivateKey(),\n                serverInfo: this.serverInfo\n            });\n            endPoint.addStandardEndpointDescriptions();\n\n            this.endpoints.push(endPoint);\n\n            endPoint.on(\"message\", (message: Message, channel: ServerSecureChannelLayer) => {\n                this.on_request(message, channel);\n            });\n        };\n    }\n\n    public async start(): Promise<void>;\n    public start(callback: ErrorCallback): void;\n    public start(callback?: ErrorCallback): any {\n        assert(!this.mDnsResponder);\n        assert(Array.isArray(this.capabilitiesForMDNS));\n\n        this._preInitTask.push(async () => {\n            await this._delayInit!();\n        });\n\n        super.start((err?: Error | null) => {\n            if (err) {\n                return callback!(err);\n            }\n            this.mDnsResponder = new MDNSResponder();\n            // declare discovery server in bonjour\n            this.bonjourHolder.announcedOnMulticastSubnetWithCallback(\n                {\n                    capabilities: this.capabilitiesForMDNS,\n                    name: this.serverInfo.applicationUri!,\n                    path: \"/DiscoveryServer\",\n                    port: this.endpoints[0].port\n                },\n                (err2: Error | null) => {\n                    callback!(err2!);\n                }\n            );\n        });\n    }\n\n    public async shutdown(): Promise<void>;\n    public shutdown(callback: ErrorCallback): void;\n    public shutdown(callback?: ErrorCallback): any {\n        debugLog(\"stopping announcement of LDS on mDNS\");\n\n        if (this.mDnsResponder) {\n            this.mDnsResponder.dispose();\n            this.mDnsResponder = undefined;\n        }\n\n        this.bonjourHolder.stopAnnouncedOnMulticastSubnetWithCallback((err?: Error | null) => {\n            if (err) {\n                console.log(\"Error \", err.message);\n            }\n\n            debugLog(\"stopping announcement of LDS on mDNS - DONE\");\n            debugLog(\"Shutting down Discovery Server\");\n\n            super.shutdown(() => {\n                setTimeout(()=>{\n                    callback!();\n                },100);\n            });\n        });\n    }\n\n    /**\n     * returns the number of registered servers\n     */\n    public get registeredServerCount(): number {\n        return Object.keys(this.registeredServers).length;\n    }\n\n    public getServers(channel: ServerSecureChannelLayer): ApplicationDescription[] {\n        this.serverInfo.discoveryUrls = this.getDiscoveryUrls();\n\n        const servers: ApplicationDescription[] = [this.serverInfo];\n\n        for (const registered_server of Object.values(this.registeredServers)) {\n            const serverInfo: ApplicationDescription = new ApplicationDescription(registered_server.serverInfo);\n            servers.push(serverInfo);\n        }\n\n        return servers;\n    }\n\n    protected _on_RegisterServer2Request(message: Message, channel: ServerSecureChannelLayer) {\n        assert(message.request instanceof RegisterServer2Request);\n        const request = message.request as RegisterServer2Request;\n\n        assert(request.schema.name === \"RegisterServer2Request\");\n\n        request.discoveryConfiguration = request.discoveryConfiguration || [];\n        this.__internalRegisterServerWithCallback(\n            RegisterServer2Response,\n            request.server,\n            request.discoveryConfiguration as MdnsDiscoveryConfiguration[],\n            (err: Error | null, response?: Response) => {\n                // istanbul ignore next\n                if (err) {\n                    // tslint:disable-next-line: no-console\n                    console.log(\"What shall I do ?\", err.message);\n                    // tslint:disable-next-line: no-console\n                    console.log(err);\n                    let additional_messages = [];\n                    additional_messages.push(\"EXCEPTION CAUGHT WHILE PROCESSING REQUEST !!! \" + request.schema.name);\n                    additional_messages.push(err.message);\n                    if (err.stack) {\n                        additional_messages = additional_messages.concat(err.stack.split(\"\\n\"));\n                    }\n\n                    response = OPCUADiscoveryServer.makeServiceFault(StatusCodes.BadInternalError, additional_messages);\n                    channel.send_response(\"MSG\", response, message);\n                } else {\n                    channel.send_response(\"MSG\", response!, message);\n                }\n            }\n        );\n    }\n\n    protected _on_RegisterServerRequest(message: Message, channel: ServerSecureChannelLayer) {\n        assert(message.request instanceof RegisterServerRequest);\n        const request = message.request as RegisterServerRequest;\n        assert(request.schema.name === \"RegisterServerRequest\");\n        this.__internalRegisterServerWithCallback(\n            RegisterServerResponse,\n            request.server,\n            undefined,\n            (err: Error | null, response?: Response) => {\n                channel.send_response(\"MSG\", response!, message);\n            }\n        );\n    }\n\n    protected _on_FindServersOnNetworkRequest(message: Message, channel: ServerSecureChannelLayer) {\n        // from OPCUA 1.04 part 4\n        // This Service returns the Servers known to a Discovery Server. Unlike FindServer, this Service is\n        // only implemented by Discovery Servers.\n        // The Client may reduce the number of results returned by specifying filter criteria. An empty list is\n        // returned if no Server matches the criteria specified by the Client.\n        // This Service shall not require message security but it may require transport layer security.\n        // Each time the Discovery Server creates or updates a record in its cache it shall assign a\n        // monotonically increasing identifier to the record. This allows Clients to request records in batches\n        // by specifying the identifier for the last record received in the last call to FindServersOnNetwork.\n        // To support this the Discovery Server shall return records in numerical order starting from the\n        // lowest record identifier. The Discovery Server shall also return the last time the counter was reset\n        // for example due to a restart of the Discovery Server. If a Client detects that this time is more\n        // recent than the last time the Client called the Service it shall call the Service again with a\n        // startingRecordId of 0.\n        // This Service can be used without security and it is therefore vulnerable to Denial Of Service\n        // (DOS) attacks. A Server should minimize the amount of processing required to send the response\n        // for this Service. This can be achieved by preparing the result in advance\n\n        assert(message.request instanceof FindServersOnNetworkRequest);\n        const request = message.request as FindServersOnNetworkRequest;\n\n        assert(request.schema.name === \"FindServersOnNetworkRequest\");\n\n        function sendError(statusCode: StatusCode) {\n            const response1 = new FindServersOnNetworkResponse({ responseHeader: { serviceResult: statusCode } });\n            return channel.send_response(\"MSG\", response1, message);\n        }\n\n        //     startingRecordId         Counter Only records with an identifier greater than this number will be\n        //                              returned.\n        //                              Specify 0 to start with the first record in the cache.\n        //     maxRecordsToReturn       UInt32 The maximum number of records to return in the response.\n        //                              0 indicates that there is no limit.\n        //     serverCapabilityFilter[] String List of Server capability filters. The set of allowed server capabilities\n        //                              are defined in Part 12.\n        //                              Only records with all of the specified server capabilities are\n        //                              returned.\n        //                              The comparison is case insensitive.\n        //                              If this list is empty then no filtering is performed\n\n        // ------------------------\n\n        // The last time the counters were reset.\n        const lastCounterResetTime = new Date();\n\n        //  servers[] ServerOnNetwork List of DNS service records that meet criteria specified in the\n        // request. This list is empty if no Servers meet the criteria\n        const servers = [];\n\n        request.serverCapabilityFilter = request.serverCapabilityFilter || [];\n        const serverCapabilityFilter: string = request.serverCapabilityFilter\n            .map((x: UAString) => x!.toUpperCase())\n            .sort()\n            .join(\" \");\n\n        debugLog(\" startingRecordId = \", request.startingRecordId);\n\n        if (this.mDnsResponder) {\n            for (const server of this.mDnsResponder.registeredServers) {\n                debugLog(\"Exploring server \", server.serverName);\n\n                if (server.recordId <= request.startingRecordId) {\n                    continue;\n                }\n                if (!hasCapabilities(server.serverCapabilities, serverCapabilityFilter)) {\n                    // istanbul ignore next\n                    if (doDebug) {\n                        debugLog(\n                            \"   server \",\n                            server.serverName,\n                            server.serverCapabilities ? server.serverCapabilities.join(\",\") : [],\n                            \" does not match serverCapabilities \",\n                            serverCapabilityFilter\n                        );\n                    }\n                    continue;\n                }\n                debugLog(\"   server \", server.serverName, \" found\");\n                servers.push(server);\n                if (servers.length === request.maxRecordsToReturn) {\n                    debugLog(\"max records to return reached\", request.maxRecordsToReturn);\n                    break;\n                }\n            }\n        }\n        const response = new FindServersOnNetworkResponse({\n            lastCounterResetTime, //  UtcTime The last time the counters were reset\n            servers\n        });\n        channel.send_response(\"MSG\", response, message);\n    }\n\n    protected async __internalRegisterServerWithCallback(\n        RegisterServerXResponse: any /* RegisterServer2Response | RegisterServerResponse */,\n        rawServer: RegisteredServer,\n        discoveryConfigurations: MdnsDiscoveryConfiguration[] | undefined,\n        callback: (err: Error | null, response?: Response) => void\n    ) {\n        // istanbul ignore next\n        callback(new Error(\"internal Error\"));\n    }\n\n    // eslint-disable-next-line max-statements\n    protected async __internalRegisterServer(\n        RegisterServerXResponse: any /* RegisterServer2Response | RegisterServerResponse */,\n        rawServer: RegisteredServer,\n        discoveryConfigurations?: MdnsDiscoveryConfiguration[]\n    ): Promise<Response> {\n        const server = rawServer as any as RegisteredServerExtended;\n\n        if (!discoveryConfigurations) {\n            discoveryConfigurations = [\n                new MdnsDiscoveryConfiguration({\n                    mdnsServerName: undefined,\n                    serverCapabilities: [\"NA\"]\n                })\n            ];\n        }\n\n        function sendError(statusCode: StatusCode): Response {\n            debugLog(chalk.red(\"_on_RegisterServer(2)Request error\"), statusCode.toString());\n            const response1 = new RegisterServerXResponse({\n                responseHeader: { serviceResult: statusCode }\n            });\n            return response1;\n        }\n\n        async function _stop_announcedOnMulticastSubnet(conf: MdnsDiscoveryConfiguration): Promise<void> {\n            const b = (conf as any).bonjourHolder as BonjourHolder;\n            await b.stopAnnnouncedOnMulticastSubnet();\n            (conf as any).bonjourHolder = undefined;\n        }\n\n        async function _announcedOnMulticastSubnet(conf: MdnsDiscoveryConfiguration, announcement: Announcement): Promise<void> {\n            const serviceConfig = announcementToServiceConfig(announcement);\n\n            let b = (conf as any).bonjourHolder as BonjourHolder;\n            if (b && b.serviceConfig) {\n                if (sameService(b.serviceConfig, serviceConfig)) {\n                    debugLog(\"Configuration \", conf.mdnsServerName, \" has not changed !\");\n                    // nothing to do\n                    return;\n                } else {\n                    // istanbul ignore next\n                    if (doDebug) {\n                        debugLog(\"Configuration \", conf.mdnsServerName, \" HAS changed !\");\n                        debugLog(\" Was \", serviceToString(b.serviceConfig));\n                        debugLog(\" is  \", announcement);\n                    }\n                }\n                await _stop_announcedOnMulticastSubnet(conf);\n            }\n            b = new BonjourHolder();\n            (conf as any).bonjourHolder = b;\n            await b.announcedOnMulticastSubnet(announcement);\n        }\n\n        async function dealWithDiscoveryConfiguration(\n            previousConfMap: any,\n            server1: RegisteredServer,\n            serverInfo: ApplicationDescriptionOptions,\n            discoveryConfiguration: MdnsDiscoveryConfiguration\n        ): Promise<StatusCode> {\n            // mdnsServerName     String     The name of the Server when it is announced via mDNS.\n            //                               See Part 12 for the details about mDNS. This string shall be less than 64 bytes.\n            //                               If not specified the first element of the serverNames array is used\n            //                               (truncated to 63 bytes if necessary).\n            // serverCapabilities [] String  The set of Server capabilities supported by the Server.\n            //                               A Server capability is a short identifier for a feature\n            //                               The set of allowed Server capabilities are defined in Part 12.\n            discoveryConfiguration.mdnsServerName = discoveryConfiguration.mdnsServerName || server1.serverNames![0].text;\n\n            serverInfo.discoveryUrls = serverInfo.discoveryUrls || [];\n\n            const endpointUrl = serverInfo.discoveryUrls[0]!;\n            const parsedUrl = url.parse(endpointUrl);\n\n            discoveryConfiguration.serverCapabilities = discoveryConfiguration.serverCapabilities || [];\n            const announcement = {\n                capabilities: discoveryConfiguration.serverCapabilities.map((x: UAString) => x!) || [\"DA\"],\n                name: discoveryConfiguration.mdnsServerName!,\n                path: parsedUrl.pathname || \"/\",\n                port: parseInt(parsedUrl.port!, 10)\n            };\n\n            if (previousConfMap[discoveryConfiguration.mdnsServerName!]) {\n                // configuration already exists\n                debugLog(\"Configuration \", discoveryConfiguration.mdnsServerName, \" already exists !\");\n                const prevConf = previousConfMap[discoveryConfiguration.mdnsServerName!];\n                delete previousConfMap[discoveryConfiguration.mdnsServerName!];\n                (discoveryConfiguration as any).bonjourHolder = prevConf.bonjourHolder;\n            }\n\n            // let's announce the server on the  multicast DNS\n            await _announcedOnMulticastSubnet(discoveryConfiguration, announcement);\n            return StatusCodes.Good;\n        }\n\n        // check serverType is valid\n        if (!_isValidServerType(server.serverType)) {\n            debugLog(\"Invalid server Type\", ApplicationType[server.serverType]);\n            return sendError(StatusCodes.BadInvalidArgument);\n        }\n\n        if (!server.serverUri) {\n            debugLog(\"Missing serverURI\");\n            return sendError(StatusCodes.BadInvalidArgument);\n        }\n\n        // BadServerUriInvalid\n        // TODO\n        server.serverNames = server.serverNames || [];\n        // BadServerNameMissing\n        if (server.serverNames.length === 0 || !server.serverNames[0].text) {\n            return sendError(StatusCodes.BadServerNameMissing);\n        }\n\n        // BadDiscoveryUrlMissing\n        server.discoveryUrls = server.discoveryUrls || [];\n        if (server.discoveryUrls.length === 0 || !server.discoveryUrls[0]) {\n            return sendError(StatusCodes.BadDiscoveryUrlMissing);\n        }\n\n        const key = server.serverUri;\n        let configurationResults: StatusCode[] | null = null;\n\n        if (server.isOnline) {\n            debugLog(chalk.cyan(\" registering server : \"), chalk.yellow(server.serverUri));\n\n            // prepare serverInfo which will be used by FindServers\n            const serverInfo: ApplicationDescriptionOptions = {\n                applicationName: server.serverNames[0], // which one shall we use ?\n                applicationType: server.serverType,\n                applicationUri: server.serverUri,\n                discoveryUrls: server.discoveryUrls,\n                gatewayServerUri: server.gatewayServerUri,\n                productUri: server.productUri\n                // XXX ?????? serverInfo.discoveryProfileUri = serverInfo.discoveryProfileUri;\n            };\n\n            const previousConfMap: any = [];\n            if (this.registeredServers[key]) {\n                // server already exists and must only be updated\n                const previousServer = this.registeredServers[key];\n\n                for (const conf of previousServer.discoveryConfiguration!) {\n                    previousConfMap[conf.mdnsServerName!] = conf;\n                }\n            }\n            this.registeredServers[key] = server;\n\n            // xx server.semaphoreFilePath = server.semaphoreFilePath;\n            // xx server.serverNames = server.serverNames;\n            server.serverInfo = serverInfo;\n            server.discoveryConfiguration = discoveryConfigurations;\n\n            assert(discoveryConfigurations);\n\n            configurationResults = [];\n            for (const conf of discoveryConfigurations) {\n                const statusCode = await dealWithDiscoveryConfiguration(previousConfMap, server, serverInfo, conf);\n                configurationResults.push(statusCode);\n            }\n            // now also unregister unprocessed\n            if (Object.keys(previousConfMap).length !== 0) {\n                debugLog(\" Warning some conf need to be removed !\");\n            }\n        } else {\n            // server is announced offline\n            if (key in this.registeredServers) {\n                const server1 = this.registeredServers[key];\n                debugLog(chalk.cyan(\"unregistering server : \"), chalk.yellow(server1.serverUri!));\n                configurationResults = [];\n\n                discoveryConfigurations = server1.discoveryConfiguration || [];\n\n                for (const conf of discoveryConfigurations) {\n                    await _stop_announcedOnMulticastSubnet(conf);\n                    configurationResults.push(StatusCodes.Good);\n                }\n                delete this.registeredServers[key];\n            }\n        }\n\n        const response = new RegisterServerXResponse({\n            configurationResults\n        });\n        return response;\n    }\n}\n\n/*== private\n * returns true if the serverType can be added to a discovery server.\n * @param serverType\n * @return {boolean}\n * @private\n */\nfunction _isValidServerType(serverType: ApplicationType): boolean {\n    switch (serverType) {\n        case ApplicationType.Client:\n            return false;\n        case ApplicationType.Server:\n        case ApplicationType.ClientAndServer:\n        case ApplicationType.DiscoveryServer:\n            return true;\n    }\n    return false;\n}\n\n(OPCUADiscoveryServer as any).prototype.__internalRegisterServerWithCallback = callbackify(\n    (OPCUADiscoveryServer as any).prototype.__internalRegisterServer\n);\n\n// tslint:disable-next-line: no-var-requires\nconst thenify = require(\"thenify\");\nconst opts = { multiArgs: false };\nOPCUADiscoveryServer.prototype.start = thenify.withCallback(OPCUADiscoveryServer.prototype.start, opts);\nOPCUADiscoveryServer.prototype.shutdown = thenify.withCallback(OPCUADiscoveryServer.prototype.shutdown, opts);\n", "/**\n * @module node-opcua-server\n */\n// tslint:disable:no-console\n// tslint:disable:max-line-length\n// tslint:disable:unified-signatures\n\nimport * as crypto from \"crypto\";\nimport { EventEmitter } from \"events\";\nimport { callbackify } from \"util\";\n\nimport * as async from \"async\";\nimport * as chalk from \"chalk\";\n\nimport { extractFullyQualifiedDomainName, getFullyQualifiedDomainName } from \"node-opcua-hostname\";\n\nimport { assert } from \"node-opcua-assert\";\nimport * as utils from \"node-opcua-utils\";\n\nimport {\n    AddressSpace,\n    callMethodHelper,\n    ContinuationPoint,\n    IUserManager,\n    PseudoVariantBoolean,\n    PseudoVariantByteString,\n    PseudoVariantDateTime,\n    PseudoVariantDuration,\n    PseudoVariantExtensionObject,\n    PseudoVariantExtensionObjectArray,\n    PseudoVariantLocalizedText,\n    PseudoVariantNodeId,\n    PseudoVariantString,\n    RaiseEventData,\n    SessionContext,\n    UAObject,\n    UAVariable,\n    ISessionContext,\n    UAView,\n    EventTypeLike,\n    UAObjectType\n} from \"node-opcua-address-space\";\nimport { getDefaultCertificateManager, OPCUACertificateManager } from \"node-opcua-certificate-manager\";\nimport { ServerState } from \"node-opcua-common\";\nimport { Certificate, exploreCertificate, Nonce } from \"node-opcua-crypto\";\nimport {\n    AttributeIds,\n    filterDiagnosticOperationLevel,\n    filterDiagnosticServiceLevel,\n    NodeClass,\n    RESPONSE_DIAGNOSTICS_MASK_ALL\n} from \"node-opcua-data-model\";\nimport { DataValue } from \"node-opcua-data-value\";\nimport { dump, make_debugLog, make_errorLog, make_warningLog } from \"node-opcua-debug\";\nimport { NodeId } from \"node-opcua-nodeid\";\nimport { ObjectRegistry } from \"node-opcua-object-registry\";\nimport {\n    AsymmetricAlgorithmSecurityHeader,\n    computeSignature,\n    fromURI,\n    getCryptoFactory,\n    Message,\n    MessageSecurityMode,\n    nonceAlreadyBeenUsed,\n    Request,\n    Response,\n    SecurityPolicy,\n    ServerSecureChannelLayer,\n    SignatureData,\n    verifySignature\n} from \"node-opcua-secure-channel\";\nimport { BrowseNextRequest, BrowseNextResponse, BrowseRequest, BrowseResponse } from \"node-opcua-service-browse\";\nimport { CallRequest, CallResponse } from \"node-opcua-service-call\";\nimport { ApplicationType, UserTokenType } from \"node-opcua-service-endpoints\";\nimport { HistoryReadRequest, HistoryReadResponse, HistoryReadResult, HistoryUpdateResponse } from \"node-opcua-service-history\";\nimport {\n    AddNodesResponse,\n    AddReferencesResponse,\n    DeleteNodesResponse,\n    DeleteReferencesResponse\n} from \"node-opcua-service-node-management\";\nimport { QueryFirstResponse, QueryNextResponse } from \"node-opcua-service-query\";\nimport { ReadRequest, ReadResponse, ReadValueId, TimestampsToReturn } from \"node-opcua-service-read\";\nimport {\n    RegisterNodesRequest,\n    RegisterNodesResponse,\n    UnregisterNodesRequest,\n    UnregisterNodesResponse\n} from \"node-opcua-service-register-node\";\nimport {\n    ActivateSessionRequest,\n    ActivateSessionResponse,\n    AnonymousIdentityToken,\n    CloseSessionRequest,\n    CloseSessionResponse,\n    CreateSessionRequest,\n    CreateSessionResponse,\n    UserNameIdentityToken,\n    X509IdentityToken\n} from \"node-opcua-service-session\";\nimport {\n    CreateMonitoredItemsRequest,\n    CreateMonitoredItemsResponse,\n    CreateSubscriptionRequest,\n    CreateSubscriptionResponse,\n    DeleteMonitoredItemsRequest,\n    DeleteMonitoredItemsResponse,\n    DeleteSubscriptionsRequest,\n    DeleteSubscriptionsResponse,\n    ModifyMonitoredItemsRequest,\n    ModifyMonitoredItemsResponse,\n    ModifySubscriptionRequest,\n    ModifySubscriptionResponse,\n    MonitoredItemModifyResult,\n    PublishRequest,\n    PublishResponse,\n    RepublishRequest,\n    RepublishResponse,\n    SetMonitoringModeRequest,\n    SetMonitoringModeResponse,\n    SetPublishingModeRequest,\n    SetPublishingModeResponse,\n    SetTriggeringRequest,\n    SetTriggeringResponse,\n    TransferSubscriptionsRequest,\n    TransferSubscriptionsResponse\n} from \"node-opcua-service-subscription\";\nimport {\n    TranslateBrowsePathsToNodeIdsRequest,\n    TranslateBrowsePathsToNodeIdsResponse\n} from \"node-opcua-service-translate-browse-path\";\nimport { WriteRequest, WriteResponse } from \"node-opcua-service-write\";\nimport { ErrorCallback, StatusCode, StatusCodes } from \"node-opcua-status-code\";\nimport {\n    ApplicationDescriptionOptions,\n    BrowseResult,\n    BuildInfo,\n    CallMethodResultOptions,\n    CancelResponse,\n    EndpointDescription,\n    MonitoredItemModifyRequest,\n    MonitoringMode,\n    UserIdentityToken,\n    UserTokenPolicy,\n    BuildInfoOptions,\n    MonitoredItemCreateResult,\n    IssuedIdentityToken,\n    BrowseResultOptions\n} from \"node-opcua-types\";\nimport { DataType } from \"node-opcua-variant\";\nimport { VariantArrayType } from \"node-opcua-variant\";\nimport { matchUri } from \"node-opcua-utils\";\n\nimport { UAString } from \"node-opcua-basic-types\";\nimport { OPCUABaseServer, OPCUABaseServerOptions } from \"./base_server\";\nimport { Factory } from \"./factory\";\nimport { IRegisterServerManager } from \"./i_register_server_manager\";\nimport { MonitoredItem } from \"./monitored_item\";\nimport { RegisterServerManager } from \"./register_server_manager\";\nimport { RegisterServerManagerHidden } from \"./register_server_manager_hidden\";\nimport { RegisterServerManagerMDNSONLY } from \"./register_server_manager_mdns_only\";\nimport { ServerCapabilitiesOptions } from \"./server_capabilities\";\nimport { OPCUAServerEndPoint } from \"./server_end_point\";\nimport { ClosingReason, CreateSessionOption, ServerEngine } from \"./server_engine\";\nimport { ServerSession } from \"./server_session\";\nimport { CreateMonitoredItemHook, DeleteMonitoredItemHook, Subscription } from \"./server_subscription\";\nimport { ISocketData } from \"./i_socket_data\";\nimport { IChannelData } from \"./i_channel_data\";\nimport { UAUserManagerBase, makeUserManager, UserManagerOptions } from \"./user_manager\";\nimport { bindRoleSet } from \"./user_manager_ua\";\n\nfunction isSubscriptionIdInvalid(subscriptionId: number): boolean {\n    return subscriptionId < 0 || subscriptionId >= 0xffffffff;\n}\n\n// tslint:disable-next-line:no-var-requires\nconst thenify = require(\"thenify\");\n// tslint:disable-next-line:no-var-requires\nconst package_info = require(\"../package.json\");\nconst debugLog = make_debugLog(__filename);\nconst errorLog = make_errorLog(__filename);\nconst warningLog = make_warningLog(__filename);\n\nconst default_maxConnectionsPerEndpoint = 10;\n\nfunction g_sendError(channel: ServerSecureChannelLayer, message: Message, ResponseClass: any, statusCode: StatusCode): void {\n    const response = new ResponseClass({\n        responseHeader: { serviceResult: statusCode }\n    });\n    return channel.send_response(\"MSG\", response, message);\n}\n\nconst default_build_info: BuildInfoOptions = {\n    manufacturerName: \"NodeOPCUA : MIT Licence ( see http://node-opcua.github.io/)\",\n    productName: \"NodeOPCUA-Server\",\n    productUri: null, // << should be same as default_server_info.productUri?\n    softwareVersion: package_info.version,\n    buildNumber: \"0\",\n    buildDate: new Date(2020, 1, 1)\n    // xx buildDate: fs.statSync(package_json_file).mtime\n};\n\nconst minSessionTimeout = 100; // 100 milliseconds\nconst defaultSessionTimeout = 1000 * 30; // 30 seconds\nconst maxSessionTimeout = 1000 * 60 * 50; // 50 minutes\nlet unnamed_session_count = 0;\n\ntype ResponseClassType =\n    | typeof BrowseResponse\n    | typeof BrowseNextResponse\n    | typeof CallResponse\n    | typeof CreateMonitoredItemsResponse\n    | typeof CreateSubscriptionResponse\n    | typeof DeleteSubscriptionsResponse\n    | typeof HistoryReadResponse\n    | typeof ModifyMonitoredItemsResponse\n    | typeof ModifySubscriptionResponse\n    | typeof ReadResponse\n    | typeof RegisterNodesResponse\n    | typeof RepublishResponse\n    | typeof SetPublishingModeResponse\n    | typeof SetTriggeringResponse\n    | typeof TransferSubscriptionsResponse\n    | typeof TranslateBrowsePathsToNodeIdsResponse\n    | typeof UnregisterNodesResponse\n    | typeof WriteResponse;\n\nfunction _adjust_session_timeout(sessionTimeout: number) {\n    let revisedSessionTimeout = sessionTimeout || defaultSessionTimeout;\n    revisedSessionTimeout = Math.min(revisedSessionTimeout, maxSessionTimeout);\n    revisedSessionTimeout = Math.max(revisedSessionTimeout, minSessionTimeout);\n    return revisedSessionTimeout;\n}\n\nfunction channel_has_session(channel: ServerSecureChannelLayer, session: ServerSession): boolean {\n    if (session.channel === channel) {\n        assert(Object.prototype.hasOwnProperty.call(channel.sessionTokens, session.authenticationToken.toString()));\n        return true;\n    }\n    return false;\n}\n\nfunction moveSessionToChannel(session: ServerSession, channel: ServerSecureChannelLayer) {\n    debugLog(\"moveSessionToChannel sessionId\", session.nodeId, \" channelId=\", channel.channelId);\n    if (session.publishEngine) {\n        session.publishEngine.cancelPendingPublishRequestBeforeChannelChange();\n    }\n\n    session._detach_channel();\n    session._attach_channel(channel);\n\n    assert(session.channel!.channelId === channel.channelId);\n}\n\nasync function _attempt_to_close_some_old_unactivated_session(server: OPCUAServer) {\n    const session = server.engine!.getOldestInactiveSession();\n    if (session) {\n        await server.engine!.closeSession(session.authenticationToken, false, \"Forcing\");\n    }\n}\n\nfunction getRequiredEndpointInfo(endpoint: EndpointDescription) {\n    assert(endpoint instanceof EndpointDescription);\n    // It is recommended that Servers only include the server.applicationUri,  endpointUrl, securityMode,\n    // securityPolicyUri, userIdentityTokens, transportProfileUri and securityLevel with all\n    // other parameters set to null. Only the recommended parameters shall be verified by\n    // the client.\n\n    const e = new EndpointDescription({\n        endpointUrl: endpoint.endpointUrl,\n        securityLevel: endpoint.securityLevel,\n        securityMode: endpoint.securityMode,\n        securityPolicyUri: endpoint.securityPolicyUri,\n        server: {\n            applicationUri: endpoint.server.applicationUri,\n            applicationType: endpoint.server.applicationType,\n            applicationName: endpoint.server.applicationName\n            // ... to be continued after verifying what fields are actually needed\n        },\n        transportProfileUri: endpoint.transportProfileUri,\n        userIdentityTokens: endpoint.userIdentityTokens\n    });\n    // reduce even further by explicitly setting unwanted members to null\n    e.server.productUri = null;\n    e.server.applicationName = null as any;\n    // xx e.server.applicationType = null as any;\n    e.server.gatewayServerUri = null;\n    e.server.discoveryProfileUri = null;\n    e.server.discoveryUrls = null;\n    e.serverCertificate = null as any;\n    return e;\n}\n\n// serverUri  String This value is only specified if the EndpointDescription has a gatewayServerUri.\n//            This value is the applicationUri from the EndpointDescription which is the applicationUri for the\n//            underlying Server. The type EndpointDescription is defined in 7.10.\n\nfunction _serverEndpointsForCreateSessionResponse(server: OPCUAServer, endpointUrl: string | null, serverUri: string | null) {\n    serverUri = null; // unused then\n\n    // The Server shall return a set of EndpointDescriptions available for the serverUri specified in the request.\n    // It is recommended that Servers only include the endpointUrl, securityMode,\n    // securityPolicyUri, userIdentityTokens, transportProfileUri and securityLevel with all other parameters\n    // set to null. Only the recommended parameters shall be verified by the client.\n    return server\n        ._get_endpoints(endpointUrl)\n        .filter((e) => !(e as any).restricted) // remove restricted endpoints\n        .filter((e) => matchUri(e.endpointUrl, endpointUrl))\n        .map(getRequiredEndpointInfo);\n}\n\nfunction adjustSecurityPolicy(channel: ServerSecureChannelLayer, userTokenPolicy_securityPolicyUri: UAString): SecurityPolicy {\n    // check that userIdentityToken\n    let securityPolicy = fromURI(userTokenPolicy_securityPolicyUri);\n\n    // if the security policy is not specified we use the session security policy\n    if (securityPolicy === SecurityPolicy.Invalid) {\n        securityPolicy = fromURI((channel.clientSecurityHeader! as AsymmetricAlgorithmSecurityHeader).securityPolicyUri);\n        assert(securityPolicy !== SecurityPolicy.Invalid);\n    }\n    return securityPolicy;\n}\n\nfunction findUserTokenByPolicy(\n    endpoint_description: EndpointDescription,\n    userTokenType: UserTokenType,\n    policyId: SecurityPolicy | string | null\n): UserTokenPolicy | null {\n    assert(endpoint_description instanceof EndpointDescription);\n    const r = endpoint_description.userIdentityTokens!.filter(\n        (userIdentity: UserTokenPolicy) =>\n            userIdentity.tokenType === userTokenType && (!policyId || userIdentity.policyId === policyId)\n    );\n    return r.length === 0 ? null : r[0];\n}\n\nfunction findUserTokenPolicy(endpoint_description: EndpointDescription, userTokenType: UserTokenType): UserTokenPolicy | null {\n    assert(endpoint_description instanceof EndpointDescription);\n    const r = endpoint_description.userIdentityTokens!.filter((userIdentity: UserTokenPolicy) => {\n        assert(userIdentity.tokenType !== undefined);\n        return userIdentity.tokenType === userTokenType;\n    });\n    return r.length === 0 ? null : r[0];\n}\n\nfunction createAnonymousIdentityToken(endpoint_desc: EndpointDescription) {\n    assert(endpoint_desc instanceof EndpointDescription);\n    const userTokenPolicy = findUserTokenPolicy(endpoint_desc, UserTokenType.Anonymous);\n    if (!userTokenPolicy) {\n        throw new Error(\"Cannot find ANONYMOUS user token policy in end point description\");\n    }\n    return new AnonymousIdentityToken({ policyId: userTokenPolicy.policyId });\n}\n\nfunction sameIdentityToken(token1: UserIdentityToken, token2: UserIdentityToken): boolean {\n    if (token1 instanceof UserNameIdentityToken) {\n        if (!(token2 instanceof UserNameIdentityToken)) {\n            return false;\n        }\n        if (token1.userName !== token2.userName) {\n            return false;\n        }\n        if (token1.password.toString(\"hex\") !== token2.password.toString(\"hex\")) {\n            return false;\n        }\n    } else if (token1 instanceof AnonymousIdentityToken) {\n        if (!(token2 instanceof AnonymousIdentityToken)) {\n            return false;\n        }\n        if (token1.policyId !== token2.policyId) {\n            return false;\n        }\n        return true;\n    }\n    assert(false, \" Not implemented yet\");\n    return false;\n}\nfunction getTokenType(userIdentityToken: UserIdentityToken): UserTokenType {\n    if (userIdentityToken instanceof AnonymousIdentityToken) {\n        return UserTokenType.Anonymous;\n    } else if (userIdentityToken instanceof UserNameIdentityToken) {\n        return UserTokenType.UserName;\n    } else if (userIdentityToken instanceof IssuedIdentityToken) {\n        return UserTokenType.IssuedToken;\n    } else if (userIdentityToken instanceof X509IdentityToken) {\n        return UserTokenType.Certificate;\n    }\n    return UserTokenType.Invalid;\n}\nfunction thumbprint(certificate?: Certificate): string {\n    return certificate ? certificate.toString(\"base64\") : \"\";\n}\n\n/*=== private\n *\n * perform the read operation on a given node for a monitored item.\n * this method DOES NOT apply to Variable Values attribute\n *\n * @param self\n * @param oldValue\n * @param node\n * @param itemToMonitor\n * @private\n */\nfunction monitoredItem_read_and_record_value(\n    self: MonitoredItem,\n    context: ISessionContext | null,\n    oldValue: DataValue,\n    node: UAVariable,\n    itemToMonitor: any,\n    callback: (err: Error | null, dataValue?: DataValue) => void\n) {\n    assert(self instanceof MonitoredItem);\n    assert(oldValue instanceof DataValue);\n    assert(itemToMonitor.attributeId === AttributeIds.Value);\n\n    const dataValue = node.readAttribute(context, itemToMonitor.attributeId, itemToMonitor.indexRange, itemToMonitor.dataEncoding);\n\n    callback(null, dataValue);\n}\n\n/*== private\n * @method monitoredItem_read_and_record_value_async\n * this method applies to Variable Values attribute\n * @param self\n * @param oldValue\n * @param node\n * @param itemToMonitor\n * @private\n */\nfunction monitoredItem_read_and_record_value_async(\n    self: MonitoredItem,\n    context: ISessionContext,\n    oldValue: DataValue,\n    node: UAVariable,\n    itemToMonitor: any,\n    callback: (err: Error | null, dataValue?: DataValue) => void\n) {\n    assert(context instanceof SessionContext);\n    assert(itemToMonitor.attributeId === AttributeIds.Value);\n    assert(self instanceof MonitoredItem);\n    assert(oldValue instanceof DataValue);\n    // do it asynchronously ( this is only valid for value attributes )\n    assert(itemToMonitor.attributeId === AttributeIds.Value);\n\n    node.readValueAsync(context, (err: Error | null, dataValue?: DataValue) => {\n        callback(err, dataValue);\n    });\n}\n\nfunction build_scanning_node_function(\n    context: ISessionContext,\n    addressSpace: AddressSpace,\n    monitoredItem: MonitoredItem,\n    itemToMonitor: any\n): (dataValue: DataValue, callback: (err: Error | null, dataValue?: DataValue) => void) => void {\n    assert(context instanceof SessionContext);\n    assert(itemToMonitor instanceof ReadValueId);\n\n    const node = addressSpace.findNode(itemToMonitor.nodeId) as UAVariable;\n\n    /* istanbul ignore next */\n    if (!node) {\n        errorLog(\" INVALID NODE ID  , \", itemToMonitor.nodeId.toString());\n        dump(itemToMonitor);\n        return (oldData: DataValue, callback: (err: Error | null, dataValue?: DataValue) => void) => {\n            callback(\n                null,\n                new DataValue({\n                    statusCode: StatusCodes.BadNodeIdUnknown,\n                    value: { dataType: DataType.Null, value: 0 }\n                })\n            );\n        };\n    }\n\n    ///// !!monitoredItem.setNode(node);\n\n    if (itemToMonitor.attributeId === AttributeIds.Value) {\n        const monitoredItem_read_and_record_value_func =\n            itemToMonitor.attributeId === AttributeIds.Value && typeof node.readValueAsync === \"function\"\n                ? monitoredItem_read_and_record_value_async\n                : monitoredItem_read_and_record_value;\n\n        return function func(\n            this: MonitoredItem,\n            oldDataValue: DataValue,\n            callback: (err: Error | null, dataValue?: DataValue) => void\n        ) {\n            assert(this instanceof MonitoredItem);\n            assert(oldDataValue instanceof DataValue);\n            assert(typeof callback === \"function\");\n            monitoredItem_read_and_record_value_func(this, context, oldDataValue, node, itemToMonitor, callback);\n        };\n    } else {\n        // Attributes, other than the  Value  Attribute, are only monitored for a change in value.\n        // The filter is not used for these  Attributes. Any change in value for these  Attributes\n        // causes a  Notification  to be  generated.\n\n        // only record value when it has changed\n        return function func(\n            this: MonitoredItem,\n            oldDataValue: DataValue,\n            callback: (err: Error | null, dataValue?: DataValue) => void\n        ) {\n            assert(this instanceof MonitoredItem);\n            assert(oldDataValue instanceof DataValue);\n            assert(typeof callback === \"function\");\n            const newDataValue = node.readAttribute(null, itemToMonitor.attributeId);\n            callback(null, newDataValue);\n        };\n    }\n}\n\nfunction prepareMonitoredItem(context: ISessionContext, addressSpace: AddressSpace, monitoredItem: MonitoredItem) {\n    const itemToMonitor = monitoredItem.itemToMonitor;\n    const readNodeFunc = build_scanning_node_function(context, addressSpace, monitoredItem, itemToMonitor);\n    monitoredItem.samplingFunc = readNodeFunc;\n}\n\nfunction isMonitoringModeValid(monitoringMode: MonitoringMode): boolean {\n    assert(MonitoringMode.Invalid !== undefined);\n    return monitoringMode !== MonitoringMode.Invalid && monitoringMode <= MonitoringMode.Reporting;\n}\n\nfunction _installRegisterServerManager(self: OPCUAServer) {\n    assert(self instanceof OPCUAServer);\n    assert(!self.registerServerManager);\n\n    /* istanbul ignore next */\n    if (!self.registerServerMethod) {\n        throw new Error(\"Internal Error\");\n    }\n\n    switch (self.registerServerMethod) {\n        case RegisterServerMethod.HIDDEN:\n            self.registerServerManager = new RegisterServerManagerHidden({\n                server: self\n            });\n            break;\n        case RegisterServerMethod.MDNS:\n            self.registerServerManager = new RegisterServerManagerMDNSONLY({\n                server: self\n            });\n            break;\n        case RegisterServerMethod.LDS:\n            self.registerServerManager = new RegisterServerManager({\n                discoveryServerEndpointUrl: self.discoveryServerEndpointUrl,\n                server: self\n            });\n            break;\n        /* istanbul ignore next */\n        default:\n            throw new Error(\"Invalid switch\");\n    }\n\n    self.registerServerManager.on(\"serverRegistrationPending\", () => {\n        /**\n         * emitted when the server is trying to registered the LDS\n         * but when the connection to the lds has failed\n         * serverRegistrationPending is sent when the backoff signal of the\n         * connection process is raised\n         * @event serverRegistrationPending\n         */\n        debugLog(\"serverRegistrationPending\");\n        self.emit(\"serverRegistrationPending\");\n    });\n    self.registerServerManager.on(\"serverRegistered\", () => {\n        /**\n         * emitted when the server is successfully registered to the LDS\n         * @event serverRegistered\n         */\n        debugLog(\"serverRegistered\");\n        self.emit(\"serverRegistered\");\n    });\n    self.registerServerManager.on(\"serverRegistrationRenewed\", () => {\n        /**\n         * emitted when the server has successfully renewed its registration to the LDS\n         * @event serverRegistrationRenewed\n         */\n        debugLog(\"serverRegistrationRenewed\");\n        self.emit(\"serverRegistrationRenewed\");\n    });\n\n    self.registerServerManager.on(\"serverUnregistered\", () => {\n        debugLog(\"serverUnregistered\");\n        /**\n         * emitted when the server is successfully unregistered to the LDS\n         * ( for instance during shutdown)\n         * @event serverUnregistered\n         */\n        self.emit(\"serverUnregistered\");\n    });\n}\n\nfunction validate_applicationUri(channel: ServerSecureChannelLayer, request: CreateSessionRequest): boolean {\n    const applicationUri = request.clientDescription.applicationUri!;\n    const clientCertificate = request.clientCertificate;\n    // if session is insecure there is no need to check certificate information\n    if (channel.securityMode === MessageSecurityMode.None) {\n        return true; // assume correct\n    }\n    if (!clientCertificate || clientCertificate.length === 0) {\n        return true; // can't check\n    }\n    const e = exploreCertificate(clientCertificate);\n    const uniformResourceIdentifier = e.tbsCertificate.extensions!.subjectAltName?.uniformResourceIdentifier ?? null;\n    const applicationUriFromCert =\n        uniformResourceIdentifier && uniformResourceIdentifier.length > 0 ? uniformResourceIdentifier[0] : null;\n\n    /* istanbul ignore next */\n    if (applicationUriFromCert !== applicationUri) {\n        errorLog(\"BadCertificateUriInvalid!\");\n        errorLog(\"applicationUri           = \", applicationUri);\n        errorLog(\"applicationUriFromCert   = \", applicationUriFromCert);\n    }\n\n    return applicationUriFromCert === applicationUri;\n}\n\nfunction validate_security_endpoint(\n    server: OPCUAServer,\n    request: CreateSessionRequest,\n    channel: ServerSecureChannelLayer\n): {\n    errCode: StatusCode;\n    endpoint?: EndpointDescription;\n} {\n    debugLog(\"validate_security_endpoint = \", request.endpointUrl);\n    let endpoints = server._get_endpoints(request.endpointUrl);\n    // endpointUrl String The network address that the Client used to access the Session Endpoint.\n    //             The HostName portion of the URL should be one of the HostNames for the application that are\n    //             specified in the Server\u2019s ApplicationInstanceCertificate (see 7.2). The Server shall raise an\n    //             AuditUrlMismatchEventType event if the URL does not match the Server\u2019s HostNames.\n    //             AuditUrlMismatchEventType event type is defined in Part 5.\n    //             The Server uses this information for diagnostics and to determine the set of\n    //             EndpointDescriptions to return in the response.\n    // ToDo: check endpointUrl validity and emit an AuditUrlMismatchEventType event if not\n    if (endpoints.length === 0) {\n        // we have a UrlMismatch here\n        const ua_server = server.engine.addressSpace!.rootFolder.objects.server;\n        ua_server.raiseEvent(\"AuditUrlMismatchEventType\", {\n            endpointUrl: { dataType: DataType.String, value: request.endpointUrl }\n        });\n        debugLog(\"Cannot find endpoint  in available endpoints with endpointUri\", request.endpointUrl);\n        if (OPCUAServer.requestExactEndpointUrl) {\n            return { errCode: StatusCodes.BadServiceUnsupported };\n        } else {\n            endpoints = server._get_endpoints(null);\n        }\n    }\n    // ignore restricted endpoints\n    endpoints = endpoints.filter((e: EndpointDescription) => !(e as any).restricted);\n\n    const endpoints_matching_security_mode = endpoints.filter((e: EndpointDescription) => {\n        return e.securityMode === channel.securityMode;\n    });\n\n    if (endpoints_matching_security_mode.length === 0) {\n        return { errCode: StatusCodes.BadSecurityModeRejected };\n    }\n    const endpoints_matching_security_policy = endpoints_matching_security_mode.filter((e: EndpointDescription) => {\n        return e.securityPolicyUri === channel.securityHeader!.securityPolicyUri;\n    });\n\n    if (endpoints_matching_security_policy.length === 0) {\n        return { errCode: StatusCodes.BadSecurityPolicyRejected };\n    }\n    if (endpoints_matching_security_policy.length !== 1) {\n        debugLog(\"endpoints_matching_security_policy= \", endpoints_matching_security_policy.length);\n    }\n    return { errCode: StatusCodes.Good, endpoint: endpoints_matching_security_policy[0] };\n}\n\nexport function filterDiagnosticInfo(returnDiagnostics: number, response: CallResponse): void {\n    if (RESPONSE_DIAGNOSTICS_MASK_ALL & returnDiagnostics) {\n        response.responseHeader.serviceDiagnostics = filterDiagnosticServiceLevel(\n            returnDiagnostics,\n            response.responseHeader.serviceDiagnostics\n        );\n\n        if (response.diagnosticInfos && response.diagnosticInfos.length > 0) {\n            response.diagnosticInfos = response.diagnosticInfos.map((d) => filterDiagnosticOperationLevel(returnDiagnostics, d));\n        } else {\n            response.diagnosticInfos = [];\n        }\n\n        if (response.results) {\n            for (const entry of response.results) {\n                if (entry.inputArgumentDiagnosticInfos && entry.inputArgumentDiagnosticInfos.length > 0) {\n                    entry.inputArgumentDiagnosticInfos = entry.inputArgumentDiagnosticInfos.map((d) =>\n                        filterDiagnosticOperationLevel(returnDiagnostics, d)\n                    );\n                } else {\n                    entry.inputArgumentDiagnosticInfos = [];\n                }\n            }\n        }\n    }\n}\n\nexport enum RegisterServerMethod {\n    HIDDEN = 1, // the server doesn't expose itself to the external world\n    MDNS = 2, // the server publish itself to the mDNS Multicast network directly\n    LDS = 3 // the server registers itself to the LDS or LDS-ME (Local Discovery Server)\n}\n\nexport interface OPCUAServerEndpointOptions {\n    /**\n     * the primary hostname of the endpoint.\n     * @default getFullyQualifiedDomainName()\n     */\n    hostname?: string;\n\n    /**\n     * the TCP port to listen to.\n     * @default 26543\n     */\n    port?: number;\n    /**\n     * the possible security policies that the server will expose\n     * @default  [SecurityPolicy.None, SecurityPolicy.Basic128Rsa15, SecurityPolicy.Basic256Sha256, SecurityPolicy.Aes128_Sha256_RsaOaep, SecurityPolicy.Aes256_Sha256_RsaPss  ]\n     */\n    securityPolicies?: SecurityPolicy[];\n    /**\n     * the possible security mode that the server will expose\n     * @default [MessageSecurityMode.None, MessageSecurityMode.Sign, MessageSecurityMode.SignAndEncrypt]\n     */\n    securityModes?: MessageSecurityMode[];\n    /**\n     * tells if the server default endpoints should allow anonymous connection.\n     * @default true\n     */\n    allowAnonymous?: boolean;\n\n    /** alternate hostname  or IP to use */\n    alternateHostname?: string | string[];\n\n    /**\n     *  true, if discovery service on secure channel shall be disabled\n     */\n    disableDiscovery?: boolean;\n}\n\nexport interface OPCUAServerOptions extends OPCUABaseServerOptions, OPCUAServerEndpointOptions {\n    alternateEndpoints?: OPCUAServerEndpointOptions[];\n\n    /**\n     * the server certificate full path filename\n     *\n     * the certificate should be in PEM format\n     */\n    certificateFile?: string;\n    /**\n     * the server private key full path filename\n     *\n     * This file should contains the private key that has been used to generate\n     * the server certificate file.\n     *\n     * the private key should be in PEM format\n     *\n     */\n    privateKeyFile?: string;\n\n    /**\n     * the default secure token life time in ms.\n     */\n    defaultSecureTokenLifetime?: number;\n    /**\n     * the HEL/ACK transaction timeout in ms.\n     *\n     * Use a large value ( i.e 15000 ms) for slow connections or embedded devices.\n     * @default 10000\n     */\n    timeout?: number;\n\n    /**\n     * the maximum number of simultaneous sessions allowed.\n     * @default 10\n     * @deprecated use serverCapabilities: { maxSessions: } instead\n    \n     */\n    maxAllowedSessionNumber?: number;\n\n    /**\n     * the maximum number authorized simultaneous connections per endpoint\n     * @default 10\n     */\n    maxConnectionsPerEndpoint?: number;\n\n    /**\n     * the nodeset.xml file(s) to load\n     *\n     * node-opcua comes with pre-installed node-set files that can be used\n     *\n     * example:\n     *\n     * ``` javascript\n     *\n     * ```\n     */\n    nodeset_filename?: string[] | string;\n\n    /**\n     * the server Info\n     *\n     * this object contains the value that will populate the\n     * Root/ObjectS/Server/ServerInfo OPCUA object in the address space.\n     */\n    serverInfo?: ApplicationDescriptionOptions;\n    /*{\n          applicationUri?: string;\n          productUri?: string;\n          applicationName?: LocalizedTextLike | string;\n          gatewayServerUri?: string | null;\n          discoveryProfileUri?: string | null;\n          discoveryUrls?: string[];\n      };\n  */\n    buildInfo?: {\n        productName?: string;\n        productUri?: string | null; // << should be same as default_server_info.productUri?\n        manufacturerName?: string;\n        softwareVersion?: string;\n        buildNumber?: string;\n        buildDate?: Date;\n    };\n\n    /**\n     *  an object that implements user authentication methods\n     */\n    userManager?: UserManagerOptions;\n\n    /** resource Path is a string added at the end of the url such as \"/UA/Server\" */\n    resourcePath?: string;\n\n    /**\n     *\n     */\n    serverCapabilities?: ServerCapabilitiesOptions;\n    /**\n     * if server shall raise AuditingEvent\n     * @default true\n     */\n    isAuditing?: boolean;\n\n    /**\n     * strategy used by the server to declare itself to a discovery server\n     *\n     * - HIDDEN: the server doesn't expose itself to the external world\n     * - MDNS: the server publish itself to the mDNS Multicast network directly\n     * - LDS: the server registers itself to the LDS or LDS-ME (Local Discovery Server)\n     *\n     *  @default    .HIDDEN - by default the server\n     *            will not register itself to the local discovery server\n     *\n     */\n    registerServerMethod?: RegisterServerMethod;\n    /**\n     *\n     * @default \"opc.tcp://localhost:4840\"]\n     */\n    discoveryServerEndpointUrl?: string;\n    /**\n     *\n     *  supported server capabilities for the Multicast (mDNS)\n     *  @default [\"NA\"]\n     *  the possible values are any of node-opcua-discovery.serverCapabilities)\n     *\n     */\n    capabilitiesForMDNS?: string[];\n\n    /**\n     * user Certificate Manager\n     * this certificate manager holds the X509 certificates used\n     * by client that uses X509 certificate token to impersonate a user\n     */\n    userCertificateManager?: OPCUACertificateManager;\n    /**\n     * Server Certificate Manager\n     *\n     * this certificate manager will be used by the server to access\n     * and store certificates from the connecting clients\n     */\n    serverCertificateManager?: OPCUACertificateManager;\n\n    /**\n     *\n     */\n    onCreateMonitoredItem?: CreateMonitoredItemHook;\n    onDeleteMonitoredItem?: DeleteMonitoredItemHook;\n}\n\nexport interface OPCUAServer {\n    /**\n     *\n     */\n    engine: ServerEngine;\n    /**\n     *\n     */\n    registerServerMethod: RegisterServerMethod;\n    /**\n     *\n     */\n    discoveryServerEndpointUrl: string;\n    /**\n     *\n     */\n    registerServerManager?: IRegisterServerManager;\n    /**\n     *\n     */\n    capabilitiesForMDNS: string[];\n    /**\n     *\n     */\n    userCertificateManager: OPCUACertificateManager;\n}\n\nconst g_requestExactEndpointUrl = !!process.env.NODEOPCUA_SERVER_REQUEST_EXACT_ENDPOINT_URL;\n/**\n *\n */\nexport class OPCUAServer extends OPCUABaseServer {\n    static defaultShutdownTimeout = 100; // 250 ms\n    /**\n     * if requestExactEndpointUrl is set to true the server will only accept createSession that have a endpointUrl that strictly matches\n     * one of the provided endpoint.\n     * This mean that if the server expose a endpoint with url such as opc.tcp://MYHOSTNAME:1234, client will not be able to reach the server\n     * with the ip address of the server.\n     * requestExactEndpointUrl = true => emulates the Prosys Server behavior\n     * requestExactEndpointUrl = false => emulates the Unified Automation behavior.\n     */\n    static requestExactEndpointUrl: boolean = g_requestExactEndpointUrl;\n    /**\n     * total number of bytes written  by the server since startup\n     */\n    public get bytesWritten(): number {\n        return this.endpoints.reduce((accumulated: number, endpoint: OPCUAServerEndPoint) => {\n            return accumulated + endpoint.bytesWritten;\n        }, 0);\n    }\n\n    /**\n     * total number of bytes read  by the server since startup\n     */\n    public get bytesRead(): number {\n        return this.endpoints.reduce((accumulated: number, endpoint: OPCUAServerEndPoint) => {\n            return accumulated + endpoint.bytesRead;\n        }, 0);\n    }\n\n    /**\n     * Number of transactions processed by the server since startup\n     */\n    public get transactionsCount(): number {\n        return this.endpoints.reduce((accumulated: number, endpoint: OPCUAServerEndPoint) => {\n            return accumulated + endpoint.transactionsCount;\n        }, 0);\n    }\n\n    /**\n     * The server build info\n     */\n    public get buildInfo(): BuildInfo {\n        return this.engine.buildInfo;\n    }\n\n    /**\n     * the number of connected channel on all existing end points\n     */\n    public get currentChannelCount(): number {\n        // TODO : move to base\n        return this.endpoints.reduce((currentValue: number, endPoint: OPCUAServerEndPoint) => {\n            return currentValue + endPoint.currentChannelCount;\n        }, 0);\n    }\n\n    /**\n     * The number of active subscriptions from all sessions\n     */\n    public get currentSubscriptionCount(): number {\n        return this.engine ? this.engine.currentSubscriptionCount : 0;\n    }\n\n    /**\n     * the number of session activation requests that have been rejected\n     */\n    public get rejectedSessionCount(): number {\n        return this.engine ? this.engine.rejectedSessionCount : 0;\n    }\n\n    /**\n     * the number of request that have been rejected\n     */\n    public get rejectedRequestsCount(): number {\n        return this.engine ? this.engine.rejectedRequestsCount : 0;\n    }\n\n    /**\n     * the number of sessions that have been aborted\n     */\n    public get sessionAbortCount(): number {\n        return this.engine ? this.engine.sessionAbortCount : 0;\n    }\n\n    /**\n     * the publishing interval count\n     */\n    public get publishingIntervalCount(): number {\n        return this.engine ? this.engine.publishingIntervalCount : 0;\n    }\n\n    /**\n     * the number of sessions currently active\n     */\n    public get currentSessionCount(): number {\n        return this.engine ? this.engine.currentSessionCount : 0;\n    }\n\n    /**\n     * true if the server has been initialized\n     *\n     */\n    public get initialized(): boolean {\n        return this.engine && this.engine.addressSpace !== null;\n    }\n\n    /**\n     * is the server auditing ?\n     */\n    public get isAuditing(): boolean {\n        return this.engine ? this.engine.isAuditing : false;\n    }\n\n    public static registry = new ObjectRegistry();\n    public static fallbackSessionName = \"Client didn't provide a meaningful sessionName ...\";\n    /**\n     * the maximum number of subscription that can be created per server\n     * @deprecated\n     */\n    public static deprectated_MAX_SUBSCRIPTION = 50;\n\n    /**\n     * the maximum number of concurrent sessions allowed on the server\n     */\n    public get maxAllowedSessionNumber(): number {\n        return this.engine.serverCapabilities.maxSessions;\n    }\n\n    /**\n     * the maximum number for concurrent connection per end point\n     */\n    public maxConnectionsPerEndpoint: number;\n\n    /**\n     * false if anonymous connection are not allowed\n     */\n    public allowAnonymous = false;\n\n    /**\n     * the user manager\n     */\n    public userManager: UAUserManagerBase;\n\n    public readonly options: OPCUAServerOptions;\n\n    private objectFactory?: Factory;\n\n    private _delayInit?: () => Promise<void>;\n\n    constructor(options?: OPCUAServerOptions) {\n        super(options);\n\n        this.allowAnonymous = false;\n        options = options || {};\n\n        this.options = options;\n\n        if (options.maxAllowedSessionNumber !== undefined) {\n            warningLog(\n                \"[NODE-OPCUA-W21] maxAllowedSessionNumber property is now deprecated , please use serverCapabilities.maxSessions instead\"\n            );\n            options.serverCapabilities = options.serverCapabilities || {};\n            options.serverCapabilities.maxSessions = options.maxAllowedSessionNumber;\n        }\n\n        /**\n         * @property maxConnectionsPerEndpoint\n         */\n        this.maxConnectionsPerEndpoint = options.maxConnectionsPerEndpoint || default_maxConnectionsPerEndpoint;\n\n        // build Info\n        const buildInfo: BuildInfoOptions = {\n            ...default_build_info,\n            ...options.buildInfo\n        };\n\n        // repair product name\n        buildInfo.productUri = buildInfo.productUri || this.serverInfo.productUri;\n        this.serverInfo.productUri = this.serverInfo.productUri || buildInfo.productUri;\n\n        this.userManager = makeUserManager(options.userManager);\n\n        options.allowAnonymous = options.allowAnonymous === undefined ? true : !!options.allowAnonymous;\n        /**\n         * @property allowAnonymous\n         */\n        this.allowAnonymous = options.allowAnonymous;\n\n        this.discoveryServerEndpointUrl = options.discoveryServerEndpointUrl || \"opc.tcp://%FQDN%:4840\";\n        assert(typeof this.discoveryServerEndpointUrl === \"string\");\n\n        this.serverInfo.applicationType = ApplicationType.Server;\n        this.capabilitiesForMDNS = options.capabilitiesForMDNS || [\"NA\"];\n        this.registerServerMethod = options.registerServerMethod || RegisterServerMethod.HIDDEN;\n        _installRegisterServerManager(this);\n\n        if (!options.userCertificateManager) {\n            this.userCertificateManager = getDefaultCertificateManager(\"UserPKI\");\n        } else {\n            this.userCertificateManager = options.userCertificateManager;\n        }\n\n        // note: we need to delay initialization of endpoint as certain resources\n        // such as %FQDN% might not be ready yet at this stage\n        this._delayInit = async () => {\n            /* istanbul ignore next */\n            if (!options) {\n                throw new Error(\"Internal Error\");\n            }\n            // to check => this.serverInfo.applicationName = this.serverInfo.productName || buildInfo.productName;\n\n            // note: applicationUri is handled in a special way\n            this.engine = new ServerEngine({\n                applicationUri: () => this.serverInfo.applicationUri!,\n                buildInfo,\n                isAuditing: options.isAuditing,\n                serverCapabilities: options.serverCapabilities\n            });\n            this.objectFactory = new Factory(this.engine);\n\n            const endpointDefinitions = options.alternateEndpoints || [];\n            const hostname = getFullyQualifiedDomainName();\n\n            endpointDefinitions.push({\n                port: options.port || 26543,\n\n                allowAnonymous: options.allowAnonymous,\n                alternateHostname: options.alternateHostname,\n                disableDiscovery: options.disableDiscovery,\n                hostname: options.hostname || hostname,\n                securityModes: options.securityModes,\n                securityPolicies: options.securityPolicies\n            });\n\n            // todo  should self.serverInfo.productUri  match self.engine.buildInfo.productUri ?\n            for (const endpointOptions of endpointDefinitions) {\n                const endPoint = this.createEndpointDescriptions(options!, endpointOptions);\n                this.endpoints.push(endPoint);\n                endPoint.on(\"message\", (message: Message, channel: ServerSecureChannelLayer) => {\n                    this.on_request(message, channel);\n                });\n\n                endPoint.on(\"error\", (err: Error) => {\n                    errorLog(\"OPCUAServer endpoint error\", err);\n                    // set serverState to ServerState.Failed;\n                    this.engine.setServerState(ServerState.Failed);\n                    this.shutdown(() => {\n                        /* empty */\n                    });\n                });\n            }\n        };\n    }\n\n    /**\n     * Initialize the server by installing default node set.\n     *\n     * and instruct the server to listen to its endpoints.\n     *\n     * ```javascript\n     * const server = new OPCUAServer();\n     * await server.initialize();\n     *\n     * // default server namespace is now initialized\n     * // it is a good time to create life instance objects\n     * const namespace = server.engine.addressSpace.getOwnNamespace();\n     * namespace.addObject({\n     *     browseName: \"SomeObject\",\n     *     organizedBy: server.engine.addressSpace.rootFolder.objects\n     * });\n     *\n     * // the addressSpace is now complete\n     * // let's now start listening to clients\n     * await server.start();\n     * ```\n     */\n    public initialize(): Promise<void>;\n    public initialize(done: () => void): void;\n    public initialize(...args: [any?, ...any[]]): any {\n        const done = args[0] as (err?: Error) => void;\n        assert(!this.initialized, \"server is already initialized\"); // already initialized ?\n\n        this._preInitTask.push(async () => {\n            /* istanbul ignore else */\n            if (this._delayInit) {\n                await this._delayInit();\n                this._delayInit = undefined;\n            }\n        });\n\n        this.performPreInitialization()\n            .then(() => {\n                OPCUAServer.registry.register(this);\n                this.engine.initialize(this.options, () => {\n                    bindRoleSet(this.userManager, this.engine.addressSpace!);\n                    setImmediate(() => {\n                        this.emit(\"post_initialize\");\n                        done();\n                    });\n                });\n            })\n            .catch((err) => {\n                done(err);\n            });\n    }\n\n    /**\n     * Initiate the server by starting all its endpoints\n     * @async\n     */\n    public start(): Promise<void>;\n    public start(done: () => void): void;\n    public start(...args: [any?, ...any[]]): any {\n        const done = args[0] as () => void;\n        const tasks: any[] = [];\n\n        tasks.push(callbackify(extractFullyQualifiedDomainName));\n\n        if (!this.initialized) {\n            tasks.push((callback: ErrorCallback) => {\n                this.initialize(callback);\n            });\n        }\n        tasks.push((callback: ErrorCallback) => {\n            super.start((err?: Error | null) => {\n                if (err) {\n                    this.shutdown((/*err2*/ err2?: Error) => {\n                        callback(err);\n                    });\n                } else {\n                    // we start the registration process asynchronously\n                    // as we want to make server immediately available\n                    this.registerServerManager!.start(() => {\n                        /* empty */\n                    });\n\n                    setImmediate(callback);\n                }\n            });\n        });\n\n        async.series(tasks, done);\n    }\n\n    /**\n     * shutdown all server endpoints\n     * @method shutdown\n     * @async\n     * @param  timeout the timeout (in ms) before the server is actually shutdown\n     *\n     * @example\n     *\n     * ```javascript\n     *    // shutdown immediately\n     *    server.shutdown(function(err) {\n     *    });\n     * ```\n     * ```ts\n     *   // in typescript with promises\n     *   server.shutdown(10000).then(()=>{\n     *      console.log(\"Server has shutdown\");\n     *   });\n     * ```\n     * ```javascript\n     *    // shutdown within 10 seconds\n     *    server.engine.shutdownReason = coerceLocalizedText(\"Shutdown for maintenance\");\n     *    server.shutdown(10000,function(err) {\n     *    });\n     *   ```\n     */\n    public shutdown(timeout?: number): Promise<void>;\n    public shutdown(callback: (err?: Error) => void): void;\n    public shutdown(timeout: number, callback: (err?: Error) => void): void;\n    public shutdown(...args: [any?, ...any[]]): any {\n        const timeout = args.length === 1 ? OPCUAServer.defaultShutdownTimeout : (args[0] as number);\n        const callback = (args.length === 1 ? args[0] : args[1]) as (err?: Error) => void;\n        assert(typeof callback === \"function\");\n        debugLog(\"OPCUAServer#shutdown (timeout = \", timeout, \")\");\n\n        /* istanbul ignore next */\n        if (!this.engine) {\n            return callback();\n        }\n        assert(this.engine);\n        if (!this.engine.isStarted()) {\n            // server may have been shot down already  , or may have fail to start !!\n            const err = new Error(\"OPCUAServer#shutdown failure ! server doesn't seems to be started yet\");\n            return callback(err);\n        }\n\n        this.userCertificateManager.dispose();\n\n        this.engine.setServerState(ServerState.Shutdown);\n\n        const shutdownTime = new Date(Date.now() + timeout);\n        this.engine.setShutdownTime(shutdownTime);\n\n        debugLog(\"OPCUAServer is now unregistering itself from  the discovery server \" + this.buildInfo);\n        this.registerServerManager!.stop((err?: Error | null) => {\n            debugLog(\"OPCUAServer unregistered from discovery server\", err);\n            setTimeout(async () => {\n                await this.engine.shutdown();\n\n                debugLog(\"OPCUAServer#shutdown: started\");\n                OPCUABaseServer.prototype.shutdown.call(this, (err1?: Error) => {\n                    debugLog(\"OPCUAServer#shutdown: completed\");\n\n                    this.dispose();\n                    callback(err1);\n                });\n            }, timeout);\n        });\n    }\n\n    public dispose(): void {\n        for (const endpoint of this.endpoints) {\n            endpoint.dispose();\n        }\n        this.endpoints = [];\n\n        this.removeAllListeners();\n\n        if (this.registerServerManager) {\n            this.registerServerManager.dispose();\n            this.registerServerManager = undefined;\n        }\n        OPCUAServer.registry.unregister(this);\n\n        /* istanbul ignore next */\n        if (this.engine) {\n            this.engine.dispose();\n        }\n    }\n\n    public raiseEvent(eventType: EventTypeLike | UAObjectType, options: RaiseEventData): void {\n        /* istanbul ignore next */\n        if (!this.engine.addressSpace) {\n            errorLog(\"addressSpace missing\");\n            return;\n        }\n\n        const server = this.engine.addressSpace.findNode(\"Server\") as UAObject;\n\n        /* istanbul ignore next */\n        if (!server) {\n            // xx throw new Error(\"OPCUAServer#raiseEvent : cannot find Server object\");\n            return;\n        }\n\n        let eventTypeNode: EventTypeLike | UAObjectType | null = eventType;\n        if (typeof eventType === \"string\") {\n            eventTypeNode = this.engine.addressSpace.findEventType(eventType);\n            if (eventTypeNode) {\n                return server.raiseEvent(eventTypeNode, options);\n            } else {\n                console.warn(\" cannot find event type \", eventType);\n            }\n        } else {\n            return server.raiseEvent(eventTypeNode, options);\n        }\n    }\n\n    /**\n     * create and register a new session\n     * @internal\n     */\n    protected createSession(options: CreateSessionOption): ServerSession {\n        /* istanbul ignore next */\n        if (!this.engine) {\n            throw new Error(\"Internal Error\");\n        }\n        return this.engine.createSession(options);\n    }\n\n    /**\n     * retrieve a session by authentication token\n     * @internal\n     */\n    protected getSession(authenticationToken: NodeId, activeOnly?: boolean): ServerSession | null {\n        return this.engine ? this.engine.getSession(authenticationToken, activeOnly) : null;\n    }\n\n    /**\n     *\n     * @param channel\n     * @param clientCertificate\n     * @param clientNonce\n     * @internal\n     */\n    protected computeServerSignature(\n        channel: ServerSecureChannelLayer,\n        clientCertificate: Certificate,\n        clientNonce: Nonce\n    ): SignatureData | undefined {\n        return computeSignature(clientCertificate, clientNonce, this.getPrivateKey(), channel.messageBuilder!.securityPolicy);\n    }\n\n    /**\n     *\n     * @param session\n     * @param channel\n     * @param clientSignature\n     * @internal\n     */\n    protected verifyClientSignature(\n        session: ServerSession,\n        channel: ServerSecureChannelLayer,\n        clientSignature: SignatureData\n    ): boolean {\n        const clientCertificate = channel.receiverCertificate!;\n        const securityPolicy = channel.messageBuilder!.securityPolicy;\n        const serverCertificate = this.getCertificate();\n\n        const result = verifySignature(serverCertificate, session.nonce!, clientSignature, clientCertificate, securityPolicy);\n\n        return result;\n    }\n\n    protected isValidUserNameIdentityToken(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userTokenPolicy: UserTokenPolicy,\n        userIdentityToken: UserNameIdentityToken,\n        userTokenSignature: SignatureData,\n        callback: (err: Error | null, statusCode?: StatusCode) => void\n    ): void {\n        assert(userIdentityToken instanceof UserNameIdentityToken);\n\n        const securityPolicy = adjustSecurityPolicy(channel, userTokenPolicy.securityPolicyUri);\n        if (securityPolicy === SecurityPolicy.None) {\n            return callback(null, StatusCodes.Good);\n        }\n        const cryptoFactory = getCryptoFactory(securityPolicy);\n\n        /* istanbul ignore next */\n        if (!cryptoFactory) {\n            return callback(null, StatusCodes.BadSecurityPolicyRejected);\n        }\n\n        /* istanbul ignore next */\n        if (userIdentityToken.encryptionAlgorithm !== cryptoFactory.asymmetricEncryptionAlgorithm) {\n            errorLog(\"invalid encryptionAlgorithm\");\n            errorLog(\"userTokenPolicy\", userTokenPolicy.toString());\n            errorLog(\"userTokenPolicy\", userIdentityToken.toString());\n            return callback(null, StatusCodes.BadIdentityTokenInvalid);\n        }\n        const userName = userIdentityToken.userName;\n        const password = userIdentityToken.password;\n        if (!userName || !password) {\n            return callback(null, StatusCodes.BadIdentityTokenInvalid);\n        }\n        return callback(null, StatusCodes.Good);\n    }\n\n    protected isValidX509IdentityToken(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userTokenPolicy: UserTokenPolicy,\n        userIdentityToken: X509IdentityToken,\n        userTokenSignature: SignatureData,\n        callback: (err: Error | null, statusCode?: StatusCode) => void\n    ): void {\n        assert(userIdentityToken instanceof X509IdentityToken);\n        assert(typeof callback === \"function\");\n\n        const securityPolicy = adjustSecurityPolicy(channel, userTokenPolicy.securityPolicyUri);\n\n        const cryptoFactory = getCryptoFactory(securityPolicy);\n        /* istanbul ignore next */\n        if (!cryptoFactory) {\n            return callback(null, StatusCodes.BadSecurityPolicyRejected);\n        }\n\n        if (!userTokenSignature || !userTokenSignature.signature) {\n            return callback(null, StatusCodes.BadUserSignatureInvalid);\n        }\n\n        if (userIdentityToken.policyId !== userTokenPolicy.policyId) {\n            errorLog(\"invalid encryptionAlgorithm\");\n            errorLog(\"userTokenPolicy\", userTokenPolicy.toString());\n            errorLog(\"userTokenPolicy\", userIdentityToken.toString());\n            return callback(null, StatusCodes.BadSecurityPolicyRejected);\n        }\n        const certificate = userIdentityToken.certificateData; /* as Certificate*/\n        const nonce = session.nonce!;\n        const serverCertificate = this.getCertificate();\n\n        assert(serverCertificate instanceof Buffer);\n        assert(certificate instanceof Buffer, \"expecting certificate to be a Buffer\");\n        assert(nonce instanceof Buffer, \"expecting nonce to be a Buffer\");\n        assert(userTokenSignature.signature instanceof Buffer, \"expecting userTokenSignature to be a Buffer\");\n\n        // verify proof of possession by checking certificate signature & server nonce correctness\n        if (!verifySignature(serverCertificate, nonce, userTokenSignature, certificate, securityPolicy)) {\n            return callback(null, StatusCodes.BadUserSignatureInvalid);\n        }\n\n        // verify if certificate is Valid\n        this.userCertificateManager!.checkCertificate(certificate, (err, certificateStatus) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            if (\n                StatusCodes.BadCertificateUntrusted === certificateStatus ||\n                StatusCodes.BadCertificateTimeInvalid === certificateStatus ||\n                StatusCodes.BadCertificateIssuerTimeInvalid === certificateStatus ||\n                StatusCodes.BadCertificateIssuerUseNotAllowed === certificateStatus ||\n                StatusCodes.BadCertificateIssuerRevocationUnknown === certificateStatus ||\n                StatusCodes.BadCertificateRevocationUnknown === certificateStatus ||\n                StatusCodes.BadCertificateRevoked === certificateStatus ||\n                StatusCodes.BadCertificateUseNotAllowed === certificateStatus ||\n                StatusCodes.BadSecurityChecksFailed === certificateStatus ||\n                StatusCodes.Good !== certificateStatus\n            ) {\n                debugLog(\"isValidX509IdentityToken => certificateStatus = \", certificateStatus?.toString());\n                return callback(null, StatusCodes.BadIdentityTokenRejected);\n            }\n            if (StatusCodes.Good !== certificateStatus) {\n                assert(certificateStatus instanceof StatusCode);\n                return callback(null, certificateStatus);\n                // return callback(null, StatusCodes.BadIdentityTokenInvalid);\n            }\n\n            // verify if certificate is truster or rejected\n            // todo: StatusCodes.BadCertificateUntrusted\n\n            // store untrusted certificate to rejected folder\n            // todo:\n            return callback(null, StatusCodes.Good);\n        });\n    }\n\n    /**\n     * @internal\n     */\n    protected userNameIdentityTokenAuthenticateUser(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userTokenPolicy: UserTokenPolicy,\n        userIdentityToken: UserNameIdentityToken,\n        callback: (err: Error | null, isAuthorized?: boolean) => void\n    ): void {\n        assert(userIdentityToken instanceof UserNameIdentityToken);\n        // assert(this.isValidUserNameIdentityToken(channel, session, userTokenPolicy, userIdentityToken));\n\n        const securityPolicy = adjustSecurityPolicy(channel, userTokenPolicy.securityPolicyUri);\n\n        const userName = userIdentityToken.userName!;\n        let password: any = userIdentityToken.password;\n\n        // decrypt password if necessary\n        if (securityPolicy === SecurityPolicy.None) {\n            // not good, password was sent in clear text ...\n            password = password.toString();\n        } else {\n            const serverPrivateKey = this.getPrivateKey();\n\n            const serverNonce = session.nonce!;\n            assert(serverNonce instanceof Buffer);\n\n            const cryptoFactory = getCryptoFactory(securityPolicy);\n            /* istanbul ignore next */\n            if (!cryptoFactory) {\n                return callback(new Error(\" Unsupported security Policy\"));\n            }\n\n            const buff = cryptoFactory.asymmetricDecrypt(password, serverPrivateKey);\n\n            // server certificate may be invalid and asymmetricDecrypt may fail\n            if (!buff || buff.length < 4) {\n                async.setImmediate(() => callback(null, false));\n                return;\n            }\n\n            const length = buff.readUInt32LE(0) - serverNonce.length;\n            password = buff.slice(4, 4 + length).toString(\"utf-8\");\n        }\n\n        this.userManager\n            .isValidUser(session, userName, password)\n            .then((isValid) => callback(null, isValid))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * @internal\n     */\n    protected isValidUserIdentityToken(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userIdentityToken: UserIdentityToken,\n        userTokenSignature: SignatureData,\n        endpointDescription: EndpointDescription,\n        callback: (err: Error | null, statusCode?: StatusCode) => void\n    ): void {\n        assert(typeof callback === \"function\");\n        /* istanbul ignore next */\n        if (!userIdentityToken) {\n            throw new Error(\"Invalid token\");\n        }\n\n        const userTokenType = getTokenType(userIdentityToken);\n\n        const userTokenPolicy = findUserTokenByPolicy(endpointDescription, userTokenType, userIdentityToken.policyId!);\n        if (!userTokenPolicy) {\n            // cannot find token with this policyId\n            return callback(null, StatusCodes.BadIdentityTokenInvalid);\n        }\n        //\n        if (userIdentityToken instanceof UserNameIdentityToken) {\n            return this.isValidUserNameIdentityToken(\n                channel,\n                session,\n                userTokenPolicy,\n                userIdentityToken,\n                userTokenSignature,\n                callback\n            );\n        }\n        if (userIdentityToken instanceof X509IdentityToken) {\n            return this.isValidX509IdentityToken(\n                channel,\n                session,\n                userTokenPolicy,\n                userIdentityToken,\n                userTokenSignature,\n                callback\n            );\n        }\n\n        return callback(null, StatusCodes.Good);\n    }\n\n    /**\n     *\n     * @internal\n     * @param channel\n     * @param session\n     * @param userIdentityToken\n     * @param callback\n     * @returns {*}\n     */\n    protected isUserAuthorized(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userIdentityToken: UserIdentityToken,\n        callback: (err: Error | null, isAuthorized?: boolean) => void\n    ): void {\n        assert(userIdentityToken);\n        assert(typeof callback === \"function\");\n\n        const userTokenType = getTokenType(userIdentityToken);\n        const userTokenPolicy = findUserTokenByPolicy(session.getEndpointDescription(), userTokenType, userIdentityToken.policyId!);\n        /** istanbul ignore next */\n        if (!userTokenPolicy) {\n            return callback(null, false);\n        }\n        // find if a userToken exists\n        if (userIdentityToken instanceof UserNameIdentityToken) {\n            return this.userNameIdentityTokenAuthenticateUser(channel, session, userTokenPolicy, userIdentityToken, callback);\n        }\n        async.setImmediate(callback.bind(null, null, true));\n    }\n\n    protected makeServerNonce(): Nonce {\n        return crypto.randomBytes(32);\n    }\n\n    // session services\n    // eslint-disable-next-line max-statements\n    protected async _on_CreateSessionRequest(message: Message, channel: ServerSecureChannelLayer): Promise<void> {\n        const request = message.request as CreateSessionRequest;\n        assert(request instanceof CreateSessionRequest);\n\n        function rejectConnection(server: OPCUAServer, statusCode: StatusCode): void {\n            server.engine.incrementSecurityRejectedSessionCount();\n\n            const response1 = new CreateSessionResponse({\n                responseHeader: { serviceResult: statusCode }\n            });\n            channel.send_response(\"MSG\", response1, message);\n            // and close !\n        }\n\n        // From OPCUA V1.03 Part 4 5.6.2 CreateSession\n        // A Server application should limit the number of Sessions. To protect against misbehaving Clients and denial\n        // of service attacks, the Server shall close the oldest Session that is not activated before reaching the\n        // maximum number of supported Sessions\n        if (this.currentSessionCount >= this.engine.serverCapabilities.maxSessions) {\n            await _attempt_to_close_some_old_unactivated_session(this);\n        }\n\n        // check if session count hasn't reach the maximum allowed sessions\n        if (this.currentSessionCount >= this.engine.serverCapabilities.maxSessions) {\n            return rejectConnection(this, StatusCodes.BadTooManySessions);\n        }\n\n        // Release 1.03 OPC Unified Architecture, Part 4 page 24 - CreateSession Parameters\n        // client should prove a sessionName\n        // Session name is a Human readable string that identifies the Session. The Server makes this name and the\n        // sessionId visible in its AddressSpace for diagnostic purposes. The Client should provide a name that is\n        // unique for the instance of the Client.\n        // If this parameter is not specified the Server shall assign a value.\n\n        if (utils.isNullOrUndefined(request.sessionName)) {\n            // see also #198\n            // let's the server assign a sessionName for this lazy client.\n\n            debugLog(\n                \"assigning OPCUAServer.fallbackSessionName because client's sessionName is null \",\n                OPCUAServer.fallbackSessionName\n            );\n\n            request.sessionName = OPCUAServer.fallbackSessionName;\n        }\n\n        // Duration Requested maximum number of milliseconds that a Session should remain open without activity.\n        // If the Client fails to issue a Service request within this interval, then the Server shall automatically\n        // terminate the Client Session.\n        const revisedSessionTimeout = _adjust_session_timeout(request.requestedSessionTimeout);\n\n        // Release 1.02 page 27 OPC Unified Architecture, Part 4: CreateSession.clientNonce\n        // A random number that should never be used in any other request. This number shall have a minimum length of 32\n        // bytes. Profiles may increase the required length. The Server shall use this value to prove possession of\n        // its application instance Certificate in the response.\n        if (!request.clientNonce || request.clientNonce.length < 32) {\n            if (channel.securityMode !== MessageSecurityMode.None) {\n                errorLog(\n                    chalk.red(\"SERVER with secure connection: Missing or invalid client Nonce \"),\n                    request.clientNonce && request.clientNonce.toString(\"hex\")\n                );\n\n                return rejectConnection(this, StatusCodes.BadNonceInvalid);\n            }\n        }\n        if (nonceAlreadyBeenUsed(request.clientNonce)) {\n            errorLog(\n                chalk.red(\"SERVER with secure connection: None has already been used\"),\n                request.clientNonce && request.clientNonce.toString(\"hex\")\n            );\n\n            return rejectConnection(this, StatusCodes.BadNonceInvalid);\n        }\n        // check application spoofing\n        // check if applicationUri in createSessionRequest matches applicationUri in client Certificate\n        if (!validate_applicationUri(channel, request)) {\n            return rejectConnection(this, StatusCodes.BadCertificateUriInvalid);\n        }\n\n        const { errCode, endpoint } = validate_security_endpoint(this, request, channel);\n        if (errCode !== StatusCodes.Good) {\n            return rejectConnection(this, errCode);\n        }\n\n        // see Release 1.02  27  OPC Unified Architecture, Part 4\n        const session = this.createSession({\n            clientDescription: request.clientDescription,\n            sessionTimeout: revisedSessionTimeout\n        });\n        session.endpoint = endpoint;\n\n        assert(session);\n        assert(session.sessionTimeout === revisedSessionTimeout);\n\n        session.clientDescription = request.clientDescription;\n        session.sessionName = request.sessionName || `<unknown session name ${unnamed_session_count++}>`;\n\n        // Depending upon on the  SecurityPolicy  and the  SecurityMode  of the  SecureChannel,  the exchange of\n        // ApplicationInstanceCertificates   and  Nonces  may be optional and the signatures may be empty. See\n        // Part  7  for the definition of  SecurityPolicies  and the handling of these parameters\n\n        // serverNonce:\n        // A random number that should never be used in any other request.\n        // This number shall have a minimum length of 32 bytes.\n        // The Client shall use this value to prove possession of its application instance\n        // Certificate in the ActivateSession request.\n        // This value may also be used to prove possession of the userIdentityToken it\n        // specified in the ActivateSession request.\n        //\n        // ( this serverNonce will only be used up to the _on_ActivateSessionRequest\n        //   where a new nonce will be created)\n        session.nonce = this.makeServerNonce();\n        session.channelId = channel.channelId;\n\n        session._attach_channel(channel);\n\n        const serverCertificateChain = this.getCertificateChain();\n\n        const hasEncryption = true;\n        // If the securityPolicyUri is None and none of the UserTokenPolicies requires encryption\n        if (session.channel!.securityMode === MessageSecurityMode.None) {\n            // ToDo: Check that none of our insecure endpoint has a a UserTokenPolicy that require encryption\n            // and set hasEncryption = false under this condition\n        }\n\n        const response = new CreateSessionResponse({\n            // A identifier which uniquely identifies the session.\n            sessionId: session.nodeId,\n\n            // A unique identifier assigned by the Server to the Session.\n            // The token used to authenticate the client in subsequent requests.\n            authenticationToken: session.authenticationToken,\n\n            revisedSessionTimeout,\n\n            serverNonce: session.nonce,\n\n            // serverCertificate: type ApplicationServerCertificate\n            // The application instance Certificate issued to the Server.\n            // A Server shall prove possession by using the private key to sign the Nonce provided\n            // by the Client in the request. The Client shall verify that this Certificate is the same as\n            // the one it used to create the SecureChannel.\n            // The ApplicationInstanceCertificate type is defined in OpCUA 1.03 part 4 - $7.2 page 108\n            // If the securityPolicyUri is None and none of the UserTokenPolicies requires\n            // encryption, the Server shall not send an ApplicationInstanceCertificate and the Client\n            // shall ignore the ApplicationInstanceCertificate.\n            serverCertificate: hasEncryption ? serverCertificateChain : undefined,\n\n            // The endpoints provided by the server.\n            // The Server shall return a set of EndpointDescriptions available for the serverUri\n            // specified in the request.[...]\n            // The Client shall verify this list with the list from a Discovery Endpoint if it used a Discovery\n            // Endpoint to fetch the EndpointDescriptions.\n            // It is recommended that Servers only include the endpointUrl, securityMode,\n            // securityPolicyUri, userIdentityTokens, transportProfileUri and securityLevel with all\n            // other parameters set to null. Only the recommended parameters shall be verified by\n            // the client.\n            serverEndpoints: _serverEndpointsForCreateSessionResponse(this, session.endpoint!.endpointUrl, request.serverUri),\n\n            // This parameter is deprecated and the array shall be empty.\n            serverSoftwareCertificates: null,\n\n            // This is a signature generated with the private key associated with the\n            // serverCertificate. This parameter is calculated by appending the clientNonce to the\n            // clientCertificate and signing the resulting sequence of bytes.\n            // The SignatureAlgorithm shall be the AsymmetricSignatureAlgorithm specified in the\n            // SecurityPolicy for the Endpoint.\n            // The SignatureData type is defined in 7.30.\n            serverSignature: this.computeServerSignature(channel, request.clientCertificate, request.clientNonce),\n\n            // The maximum message size accepted by the server\n            // The Client Communication Stack should return a Bad_RequestTooLarge error to the\n            // application if a request message exceeds this limit.\n            // The value zero indicates that this parameter is not used.\n            maxRequestMessageSize: 0x4000000\n        });\n\n        this.emit(\"create_session\", session);\n\n        session.on(\"session_closed\", (session1: ServerSession, deleteSubscriptions: boolean, reason: string) => {\n            assert(typeof reason === \"string\");\n            if (this.isAuditing) {\n                assert(reason === \"Timeout\" || reason === \"Terminated\" || reason === \"CloseSession\" || reason === \"Forcing\");\n                const sourceName = \"Session/\" + reason;\n\n                this.raiseEvent(\"AuditSessionEventType\", {\n                    /* part 5 -  6.4.3 AuditEventType */\n                    actionTimeStamp: { dataType: \"DateTime\", value: new Date() },\n                    status: { dataType: \"Boolean\", value: true },\n\n                    serverId: { dataType: \"String\", value: \"\" },\n\n                    // ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.\n                    clientAuditEntryId: { dataType: \"String\", value: \"\" },\n\n                    // The ClientUserId identifies the user of the client requesting an action. The ClientUserId can be\n                    // obtained from the UserIdentityToken passed in the ActivateSession call.\n                    clientUserId: { dataType: \"String\", value: \"\" },\n\n                    sourceName: { dataType: \"String\", value: sourceName },\n\n                    /* part 5 - 6.4.7 AuditSessionEventType */\n                    sessionId: { dataType: \"NodeId\", value: session1.nodeId }\n                });\n            }\n\n            this.emit(\"session_closed\", session1, deleteSubscriptions);\n        });\n\n        if (this.isAuditing) {\n            // ------------------------------------------------------------------------------------------------------\n            this.raiseEvent(\"AuditCreateSessionEventType\", {\n                /* part 5 -  6.4.3 AuditEventType */\n                actionTimeStamp: { dataType: \"DateTime\", value: new Date() },\n                status: { dataType: \"Boolean\", value: true },\n\n                serverId: { dataType: \"String\", value: \"\" },\n\n                // ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.\n                clientAuditEntryId: { dataType: \"String\", value: \"\" },\n\n                // The ClientUserId identifies the user of the client requesting an action. The ClientUserId can be\n                // obtained from the UserIdentityToken passed in the ActivateSession call.\n                clientUserId: { dataType: \"String\", value: \"\" },\n\n                sourceName: { dataType: \"String\", value: \"Session/CreateSession\" },\n\n                /* part 5 - 6.4.7 AuditSessionEventType */\n                sessionId: { dataType: \"NodeId\", value: session.nodeId },\n\n                /* part 5 - 6.4.8 AuditCreateSessionEventType */\n                // SecureChannelId shall uniquely identify the SecureChannel. The application shall use the same\n                // identifier in all AuditEvents related to the Session Service Set (AuditCreateSessionEventType,\n                // AuditActivateSessionEventType and their subtypes) and the SecureChannel Service Set\n                // (AuditChannelEventType and its subtypes\n                secureChannelId: { dataType: \"String\", value: session.channel!.channelId!.toString() },\n\n                // Duration\n                revisedSessionTimeout: { dataType: \"Duration\", value: session.sessionTimeout },\n\n                // clientCertificate\n                clientCertificate: { dataType: \"ByteString\", value: session.channel!.clientCertificate },\n\n                // clientCertificateThumbprint\n                clientCertificateThumbprint: {\n                    dataType: \"String\",\n                    value: thumbprint(session.channel!.clientCertificate!)\n                }\n            });\n        }\n        // -----------------------------------------------------------------------------------------------------------\n\n        assert(response.authenticationToken);\n        channel.send_response(\"MSG\", response, message);\n    }\n\n    // TODO : implement this:\n    //\n    // When the ActivateSession Service is called for the first time then the Server shall reject the request\n    // if the SecureChannel is not same as the one associated with the CreateSession request.\n    // Subsequent calls to ActivateSession may be associated with different SecureChannels. If this is the\n    // case then the Server shall verify that the Certificate the Client used to create the new\n    // SecureChannel is the same as the Certificate used to create the original SecureChannel. In addition,\n    // the Server shall verify that the Client supplied a UserIdentityToken that is identical to the token\n    // currently associated with the Session. Once the Server accepts the new SecureChannel it shall\n    // reject requests sent via the old SecureChannel.\n    /**\n     *\n     * @method _on_ActivateSessionRequest\n     * @private\n     *\n     *\n     */\n    protected _on_ActivateSessionRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as ActivateSessionRequest;\n        assert(request instanceof ActivateSessionRequest);\n\n        // get session from authenticationToken\n        const authenticationToken = request.requestHeader.authenticationToken;\n\n        const session = this.getSession(authenticationToken);\n\n        function rejectConnection(server: OPCUAServer, statusCode: StatusCode): void {\n            if (statusCode === StatusCodes.BadSessionIdInvalid) {\n                server.engine.incrementRejectedSessionCount();\n            } else {\n                server.engine.incrementRejectedSessionCount();\n                server.engine.incrementSecurityRejectedSessionCount();\n            }\n\n            const response1 = new ActivateSessionResponse({ responseHeader: { serviceResult: statusCode } });\n\n            channel.send_response(\"MSG\", response1, message);\n            // and close !\n        }\n\n        let response;\n\n        /* istanbul ignore next */\n        if (!session) {\n            // this may happen when the server has been restarted and a client tries to reconnect, thinking\n            // that the previous session may still be active\n            debugLog(chalk.yellow.bold(\" Bad Session in  _on_ActivateSessionRequest\"), authenticationToken.toString());\n\n            return rejectConnection(this, StatusCodes.BadSessionIdInvalid);\n        }\n\n        // tslint:disable-next-line: no-unused-expression\n        session.keepAlive ? session.keepAlive() : void 0;\n\n        // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n        // When the ActivateSession  Service  is called f or the first time then the Server shall reject the request\n        // if the  SecureChannel  is not same as the one associated with the  CreateSession  request.\n        if (session.status === \"new\") {\n            // xx if (channel.session_nonce !== session.nonce) {\n            if (!channel_has_session(channel, session)) {\n                // it looks like session activation is being using a channel that is not the\n                // one that have been used to create the session\n                errorLog(\" channel.sessionTokens === \" + Object.keys(channel.sessionTokens).join(\" \"));\n                return rejectConnection(this, StatusCodes.BadSessionNotActivated);\n            }\n        }\n\n        // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n        // ... Subsequent calls to  ActivateSession  may be associated with different  SecureChannels.  If this is the\n        // case then  the  Server  shall verify that the  Certificate  the  Client  used to create the new\n        // SecureChannel  is the same as the  Certificate  used to create the original  SecureChannel.\n\n        if (session.status === \"active\") {\n            if (session.channel!.channelId !== channel.channelId) {\n                warningLog(\n                    \" Session \",\n                    session.sessionName,\n                    \" is being transferred from channel\",\n                    chalk.cyan(session.channel!.channelId!.toString()),\n                    \" to channel \",\n                    chalk.cyan(channel.channelId!.toString())\n                );\n\n                // session is being reassigned to a new Channel,\n                // we shall verify that the certificate used to create the Session is the same as the current\n                // channel certificate.\n                const old_channel_cert_thumbprint = thumbprint(session.channel!.clientCertificate!);\n                const new_channel_cert_thumbprint = thumbprint(channel.clientCertificate!);\n\n                if (old_channel_cert_thumbprint !== new_channel_cert_thumbprint) {\n                    return rejectConnection(this, StatusCodes.BadNoValidCertificates); // not sure about this code !\n                }\n\n                // ... In addition the Server shall verify that the  Client  supplied a  UserIdentityToken  that is\n                // identical to the token currently associated with the  Session reassign session to new channel.\n                if (!sameIdentityToken(session.userIdentityToken!, request.userIdentityToken as UserIdentityToken)) {\n                    return rejectConnection(this, StatusCodes.BadIdentityChangeNotSupported); // not sure about this code !\n                }\n            }\n\n            moveSessionToChannel(session, channel);\n        } else if (session.status === \"screwed\") {\n            // session has been used before being activated => this should be detected and session should be dismissed.\n            return rejectConnection(this, StatusCodes.BadSessionClosed);\n        } else if (session.status === \"closed\") {\n            warningLog(chalk.yellow.bold(\" Bad Session Closed in  _on_ActivateSessionRequest\"), authenticationToken.toString());\n            return rejectConnection(this, StatusCodes.BadSessionClosed);\n        }\n\n        // verify clientSignature provided by the client\n        if (!this.verifyClientSignature(session, channel, request.clientSignature)) {\n            return rejectConnection(this, StatusCodes.BadApplicationSignatureInvalid);\n        }\n\n        // userIdentityToken may be missing , assume anonymous access then\n        request.userIdentityToken = request.userIdentityToken || createAnonymousIdentityToken(session.endpoint!);\n\n        // check request.userIdentityToken is correct ( expected type and correctly formed)\n        this.isValidUserIdentityToken(\n            channel,\n            session,\n            request.userIdentityToken as UserIdentityToken,\n            request.userTokenSignature,\n            session.endpoint!,\n            (err: Error | null, statusCode?: StatusCode) => {\n                if (statusCode !== StatusCodes.Good) {\n                    /* istanbul ignore next */\n                    if (!(statusCode && statusCode instanceof StatusCode)) {\n                        return rejectConnection(this, StatusCodes.BadCertificateInvalid);\n                    }\n                    return rejectConnection(this, statusCode);\n                }\n                session.userIdentityToken = request.userIdentityToken as UserIdentityToken;\n\n                // check if user access is granted\n                this.isUserAuthorized(\n                    channel,\n                    session,\n                    request.userIdentityToken as UserIdentityToken,\n                    (err1: Error | null, authorized?: boolean) => {\n                        /* istanbul ignore next */\n                        if (err1) {\n                            return rejectConnection(this, StatusCodes.BadInternalError);\n                        }\n\n                        if (!authorized) {\n                            return rejectConnection(this, StatusCodes.BadUserAccessDenied);\n                        } else {\n                            // extract : OPC UA part 4 - 5.6.3\n                            // Once used, a serverNonce cannot be used again. For that reason, the Server returns a new\n                            // serverNonce each time the ActivateSession Service is called.\n                            session.nonce = this.makeServerNonce();\n\n                            session.status = \"active\";\n\n                            response = new ActivateSessionResponse({ serverNonce: session.nonce });\n                            channel.send_response(\"MSG\", response, message);\n\n                            const userIdentityTokenPasswordRemoved = (userIdentityToken: any) => {\n                                const a = userIdentityToken.clone();\n                                // remove password\n                                a.password = \"*************\";\n                                return a;\n                            };\n\n                            // send OPCUA Event Notification\n                            // see part 5 : 6.4.3 AuditEventType\n                            //              6.4.7 AuditSessionEventType\n                            //              6.4.10 AuditActivateSessionEventType\n                            assert(session.nodeId); // sessionId\n                            // xx assert(session.channel.clientCertificate instanceof Buffer);\n                            assert(session.sessionTimeout > 0);\n\n                            if (this.isAuditing) {\n                                this.raiseEvent(\"AuditActivateSessionEventType\", {\n                                    /* part 5 -  6.4.3 AuditEventType */\n                                    actionTimeStamp: { dataType: \"DateTime\", value: new Date() },\n                                    status: { dataType: \"Boolean\", value: true },\n\n                                    serverId: { dataType: \"String\", value: \"\" },\n\n                                    // ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.\n                                    clientAuditEntryId: { dataType: \"String\", value: \"\" },\n\n                                    // The ClientUserId identifies the user of the client requesting an action.\n                                    // The ClientUserId can be obtained from the UserIdentityToken passed in the\n                                    // ActivateSession call.\n                                    clientUserId: { dataType: \"String\", value: \"cc\" },\n\n                                    sourceName: { dataType: \"String\", value: \"Session/ActivateSession\" },\n\n                                    /* part 5 - 6.4.7 AuditSessionEventType */\n                                    sessionId: { dataType: \"NodeId\", value: session.nodeId },\n\n                                    /* part 5 - 6.4.10 AuditActivateSessionEventType */\n                                    clientSoftwareCertificates: {\n                                        arrayType: VariantArrayType.Array,\n                                        dataType: \"ExtensionObject\" /* SignedSoftwareCertificate */,\n                                        value: []\n                                    },\n                                    // UserIdentityToken reflects the userIdentityToken parameter of the ActivateSession\n                                    // Service call.\n                                    // For Username/Password tokens the password should NOT be included.\n                                    userIdentityToken: {\n                                        dataType: \"ExtensionObject\" /*  UserIdentityToken */,\n                                        value: userIdentityTokenPasswordRemoved(session.userIdentityToken)\n                                    },\n\n                                    // SecureChannelId shall uniquely identify the SecureChannel. The application shall\n                                    // use the same identifier in all AuditEvents related to the Session Service Set\n                                    // (AuditCreateSessionEventType, AuditActivateSessionEventType and their subtypes) and\n                                    // the SecureChannel Service Set (AuditChannelEventType and its subtypes).\n                                    secureChannelId: { dataType: \"String\", value: session.channel!.channelId!.toString() }\n                                });\n                            }\n                            this.emit(\"session_activated\", session, userIdentityTokenPasswordRemoved);\n                        }\n                    }\n                );\n            }\n        );\n    }\n\n    protected prepare(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request;\n\n        // --- check that session is correct\n        const authenticationToken = request.requestHeader.authenticationToken;\n        const session = this.getSession(authenticationToken, /*activeOnly*/ true);\n        if (!session) {\n            message.session_statusCode = StatusCodes.BadSessionIdInvalid;\n            return;\n        }\n        message.session = session;\n\n        // --- check that provided session matches session attached to channel\n        if (channel.channelId !== session.channelId) {\n            if (!(request instanceof ActivateSessionRequest)) {\n                errorLog(\n                    chalk.red.bgWhite(\n                        \"ERROR: channel.channelId !== session.channelId  on processing request \" + request.constructor.name\n                    ),\n                    channel.channelId,\n                    session.channelId\n                );\n            }\n            message.session_statusCode = StatusCodes.BadSecureChannelIdInvalid;\n        } else if (channel_has_session(channel, session)) {\n            message.session_statusCode = StatusCodes.Good;\n        } else {\n            // session ma y have been moved to a different channel\n            message.session_statusCode = StatusCodes.BadSecureChannelIdInvalid;\n        }\n    }\n\n    /**\n     * ensure that action is performed on a valid session object,\n     * @method _apply_on_SessionObject\n     * @param ResponseClass the constructor of the response Class\n     * @param message\n     * @param channel\n     * @param actionToPerform\n     * @param actionToPerform.session {ServerSession}\n     * @param actionToPerform.sendResponse\n     * @param actionToPerform.sendResponse.response\n     * @param actionToPerform.sendError\n     * @param actionToPerform.sendError.statusCode\n     * @param actionToPerform.sendError.diagnostics\n     *\n     * @private\n     */\n    protected async _apply_on_SessionObject(\n        ResponseClass: ResponseClassType,\n        message: Message,\n        channel: ServerSecureChannelLayer,\n        actionToPerform: (\n            session: ServerSession,\n            sendResponse: (response: Response) => void,\n            sendError: (statusCode: StatusCode) => void\n        ) => void | Promise<void>\n    ): Promise<void> {\n        assert(typeof actionToPerform === \"function\");\n\n        function sendResponse(response1: Response) {\n            try {\n                assert(response1 instanceof ResponseClass);\n                if (message.session) {\n                    const counterName = ResponseClass.name.replace(\"Response\", \"\");\n                    message.session.incrementRequestTotalCounter(counterName);\n                }\n                return channel.send_response(\"MSG\", response1, message);\n            } catch (err) {\n                warningLog(err);\n                // istanbul ignore next\n                if (err instanceof Error) {\n                    // istanbul ignore next\n                    errorLog(\n                        \"Internal error in issuing response\\nplease contact support@sterfive.com\",\n                        message.request.toString(),\n                        \"\\n\",\n                        response1.toString()\n                    );\n                }\n                // istanbul ignore next\n                throw err;\n            }\n        }\n\n        function sendError(statusCode: StatusCode) {\n            if (message.session) {\n                message.session.incrementRequestErrorCounter(ResponseClass.name.replace(\"Response\", \"\"));\n            }\n            return g_sendError(channel, message, ResponseClass, statusCode);\n        }\n\n        let response: any;\n        /* istanbul ignore next */\n        if (!message.session || message.session_statusCode !== StatusCodes.Good) {\n            const errMessage = \"INVALID SESSION  !! \";\n            response = new ResponseClass({ responseHeader: { serviceResult: message.session_statusCode } });\n            debugLog(chalk.red.bold(errMessage), chalk.yellow(message.session_statusCode!.toString()), response.constructor.name);\n            return sendResponse(response);\n        }\n\n        assert(message.session_statusCode === StatusCodes.Good);\n\n        // OPC UA Specification 1.02 part 4 page 26\n        // When a  Session  is terminated, all outstanding requests on the  Session  are aborted and\n        // Bad_SessionClosed  StatusCodes  are returned to the  Client. In addition,   the  Server  deletes the entry\n        // for the  Client  from its  SessionDiagnostics Array  Variable  and notifies any other  Clients  who were\n        // subscribed to this entry.\n        if (message.session.status === \"closed\") {\n            // note : use StatusCodes.BadSessionClosed , for pending message for this session\n            return sendError(StatusCodes.BadSessionIdInvalid);\n        }\n\n        if (message.session.status === \"new\") {\n            // mark session as being screwed ! so it cannot be activated anymore\n            message.session.status = \"screwed\";\n\n            return sendError(StatusCodes.BadSessionNotActivated);\n        }\n\n        if (message.session.status !== \"active\") {\n            // mark session as being screwed ! so it cannot be activated anymore\n            message.session.status = \"screwed\";\n\n            // note : use StatusCodes.BadSessionClosed , for pending message for this session\n            return sendError(StatusCodes.BadSessionIdInvalid);\n        }\n\n        // lets also reset the session watchdog so it doesn't\n        // (Sessions are terminated by the Server automatically if the Client fails to issue a Service\n        // request on the Session within the timeout period negotiated by the Server in the\n        // CreateSession Service response. )\n        if (message.session.keepAlive) {\n            assert(typeof message.session.keepAlive === \"function\");\n            message.session.keepAlive();\n        }\n        message.session.incrementTotalRequestCount();\n        await actionToPerform(message.session as ServerSession, sendResponse, sendError);\n    }\n\n    protected async _apply_on_Subscription(\n        ResponseClass: ResponseClassType,\n        message: Message,\n        channel: ServerSecureChannelLayer,\n        actionToPerform: (\n            session: ServerSession,\n            subscription: Subscription,\n            sendResponse: (response: Response) => void,\n            sendError: (statusCode: StatusCode) => void\n        ) => Promise<void>\n    ): Promise<void> {\n        assert(typeof actionToPerform === \"function\");\n        const request = message.request as unknown as { subscriptionId: number };\n        assert(Object.prototype.hasOwnProperty.call(request, \"subscriptionId\"));\n\n        this._apply_on_SessionObject(\n            ResponseClass,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                const subscription = session.getSubscription(request.subscriptionId);\n                if (!subscription) {\n                    return sendError(StatusCodes.BadSubscriptionIdInvalid);\n                }\n                subscription.resetLifeTimeAndKeepAliveCounters();\n                await actionToPerform(session, subscription, sendResponse, sendError);\n            }\n        );\n    }\n\n    protected _apply_on_SubscriptionIds<T>(\n        ResponseClass: typeof SetPublishingModeResponse | typeof TransferSubscriptionsResponse | typeof DeleteSubscriptionsResponse,\n        message: Message,\n        channel: ServerSecureChannelLayer,\n        actionToPerform: (session: ServerSession, subscriptionId: number) => Promise<T>\n    ): void {\n        assert(typeof actionToPerform === \"function\");\n        const request = message.request as unknown as { subscriptionIds: number[] };\n        assert(Object.prototype.hasOwnProperty.call(request, \"subscriptionIds\"));\n\n        this._apply_on_SessionObject(\n            ResponseClass,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                const subscriptionIds = request.subscriptionIds;\n\n                if (!request.subscriptionIds || request.subscriptionIds.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                const results: any[] = subscriptionIds.map((subscriptionId: number) => actionToPerform(session, subscriptionId));\n\n                // resolve potential pending promises ....\n                for (let i = 0; i < results.length; i++) {\n                    if (results[i].then) {\n                        results[i] = await results[i];\n                    }\n                }\n\n                const response = new ResponseClass({\n                    responseHeader: {\n                        serviceResult:\n                            request.subscriptionIds.length > this.engine.serverCapabilities.maxSubscriptionsPerSession\n                                ? StatusCodes.BadTooManyOperations\n                                : StatusCodes.Good\n                    },\n                    results\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _apply_on_Subscriptions(\n        ResponseClass: typeof SetPublishingModeResponse | typeof TransferSubscriptionsResponse | typeof DeleteSubscriptionsResponse,\n        message: Message,\n        channel: ServerSecureChannelLayer,\n        actionToPerform: (session: ServerSession, subscription: Subscription) => Promise<StatusCode>\n    ): void {\n        this._apply_on_SubscriptionIds<StatusCode>(\n            ResponseClass,\n            message,\n            channel,\n            async (session: ServerSession, subscriptionId: number) => {\n                /* istanbul ignore next */\n                if (isSubscriptionIdInvalid(subscriptionId)) {\n                    return StatusCodes.BadSubscriptionIdInvalid;\n                }\n                const subscription = session.getSubscription(subscriptionId);\n                if (!subscription) {\n                    return StatusCodes.BadSubscriptionIdInvalid;\n                }\n                return actionToPerform(session, subscription);\n            }\n        );\n    }\n\n    private async _closeSession(authenticationToken: NodeId, deleteSubscriptions: boolean, reason: ClosingReason): Promise<void> {\n        if (deleteSubscriptions && this.options.onDeleteMonitoredItem) {\n            const session = this.getSession(authenticationToken);\n            if (session) {\n                const subscriptions = session.publishEngine.subscriptions;\n                for (const subscription of subscriptions) {\n                    await subscription.applyOnMonitoredItem(this.options.onDeleteMonitoredItem.bind(null, subscription) as any);\n                }\n            }\n        }\n        await this.engine.closeSession(authenticationToken, deleteSubscriptions, reason);\n    }\n    /**\n     * @method _on_CloseSessionRequest\n     * @param message\n     * @param channel\n     * @private\n     */\n    protected _on_CloseSessionRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as CloseSessionRequest;\n        assert(request instanceof CloseSessionRequest);\n\n        let response;\n\n        message.session_statusCode = StatusCodes.Good;\n\n        function sendError(statusCode: StatusCode) {\n            return g_sendError(channel, message, CloseSessionResponse, statusCode);\n        }\n\n        function sendResponse(response1: CloseSessionResponse) {\n            channel.send_response(\"MSG\", response1, message);\n        }\n\n        // do not use _apply_on_SessionObject\n        // this._apply_on_SessionObject(CloseSessionResponse, message, channel, function (session) {\n        // });\n\n        const session = message.session;\n        if (!session) {\n            return sendError(StatusCodes.BadSessionIdInvalid);\n        }\n\n        // session has been created but not activated !\n        const wasNotActivated = session.status === \"new\";\n\n        (async () => {\n            await this._closeSession(request.requestHeader.authenticationToken, request.deleteSubscriptions, \"CloseSession\");\n\n            // if (false && wasNotActivated) {\n            //  return sendError(StatusCodes.BadSessionNotActivated);\n            // }\n\n            response = new CloseSessionResponse({});\n            sendResponse(response);\n        })();\n    }\n\n    // browse services\n    /**\n     * @method _on_BrowseRequest\n     * @param message\n     * @param channel\n     * @private\n     */\n    protected _on_BrowseRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as BrowseRequest;\n        assert(request instanceof BrowseRequest);\n        const diagnostic: any = {};\n\n        this._apply_on_SessionObject(\n            BrowseResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                let response: BrowseResponse;\n                // test view\n                if (request.view && !request.view.viewId.isEmpty()) {\n                    let theView: UAView | null = this.engine!.addressSpace!.findNode(request.view.viewId) as UAView;\n                    if (theView && theView.nodeClass !== NodeClass.View) {\n                        // Error: theView is not a View\n                        diagnostic.localizedText = { text: \"Expecting a view here\" };\n                        theView = null;\n                    }\n                    if (!theView) {\n                        return sendError(StatusCodes.BadViewIdUnknown);\n                    }\n                }\n\n                if (!request.nodesToBrowse || request.nodesToBrowse.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerBrowse > 0) {\n                    if (request.nodesToBrowse.length > this.engine.serverCapabilities.operationLimits.maxNodesPerBrowse) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                // limit results to requestedMaxReferencesPerNode further so it never exceed a too big number\n                const requestedMaxReferencesPerNode = Math.min(9876, request.requestedMaxReferencesPerNode);\n                assert(request.nodesToBrowse[0].schema.name === \"BrowseDescription\");\n\n                const context = new SessionContext({ session, server: this });\n\n                const f = callbackify(this.engine.browseWithAutomaticExpansion).bind(this.engine);\n                (f as any)(request.nodesToBrowse, context, (err?: Error | null, results?: BrowseResult[]) => {\n                    // istanbul ignore next\n                    if (!results) {\n                        throw new Error(\"internal error : \" + err?.message);\n                    }\n\n                    assert(results[0].schema.name === \"BrowseResult\");\n\n                    // handle continuation point and requestedMaxReferencesPerNode\n                    const maxBrowseContinuationPoints = this.engine.serverCapabilities.maxBrowseContinuationPoints;\n                    results = results.map((result: BrowseResult) => {\n                        assert(!result.continuationPoint);\n\n                        // istanbul ignore next\n                        if (!session.continuationPointManager) {\n                            return new BrowseResult({ statusCode: StatusCodes.BadNoContinuationPoints });\n                        }\n\n                        if (session.continuationPointManager.hasReachedMaximum(maxBrowseContinuationPoints)) {\n                            return new BrowseResult({ statusCode: StatusCodes.BadNoContinuationPoints });\n                        }\n                        const truncatedResult = session.continuationPointManager.registerReferences(\n                            requestedMaxReferencesPerNode,\n                            result.references || [],\n                            { continuationPoint: null }\n                        );\n                        let { statusCode } = truncatedResult;\n                        const { continuationPoint, values } = truncatedResult;\n                        statusCode = result.statusCode;\n                        return new BrowseResult({\n                            statusCode,\n                            continuationPoint,\n                            references: values\n                        });\n                    });\n\n                    response = new BrowseResponse({\n                        diagnosticInfos: undefined,\n                        results\n                    });\n                    sendResponse(response);\n                });\n            }\n        );\n    }\n\n    /**\n     * @method _on_BrowseNextRequest\n     * @param message\n     * @param channel\n     * @private\n     */\n    protected _on_BrowseNextRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as BrowseNextRequest;\n        assert(request instanceof BrowseNextRequest);\n        this._apply_on_SessionObject(\n            BrowseNextResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                if (!request.continuationPoints || request.continuationPoints.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n                const results = request.continuationPoints\n                    .map((continuationPoint: ContinuationPoint, index: number) =>\n                        session.continuationPointManager.getNextReferences(0, {\n                            continuationPoint,\n                            index,\n                            releaseContinuationPoints: request.releaseContinuationPoints\n                        })\n                    )\n                    .map(\n                        (r) =>\n                            <BrowseResultOptions>{\n                                continuationPoint: r.continuationPoint,\n                                references: r.values,\n                                statusCode: r.statusCode\n                            }\n                    );\n\n                const response = new BrowseNextResponse({\n                    diagnosticInfos: undefined,\n                    results\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    // read services\n    protected _on_ReadRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as ReadRequest;\n        assert(request instanceof ReadRequest);\n\n        this._apply_on_SessionObject(\n            ReadResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                const context = new SessionContext({ session, server: this });\n\n                let response;\n\n                let results = [];\n\n                const timestampsToReturn = request.timestampsToReturn;\n\n                if (timestampsToReturn === TimestampsToReturn.Invalid) {\n                    return sendError(StatusCodes.BadTimestampsToReturnInvalid);\n                }\n\n                if (request.maxAge < 0) {\n                    return sendError(StatusCodes.BadMaxAgeInvalid);\n                }\n\n                request.nodesToRead = request.nodesToRead || [];\n\n                if (!request.nodesToRead || request.nodesToRead.length <= 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                assert(request.nodesToRead[0].schema.name === \"ReadValueId\");\n\n                // limit size of nodesToRead array to maxNodesPerRead\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerRead > 0) {\n                    if (request.nodesToRead.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRead) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                // proceed with registered nodes alias resolution\n                for (const nodeToRead of request.nodesToRead) {\n                    nodeToRead.nodeId = session.resolveRegisteredNode(nodeToRead.nodeId);\n                }\n\n                // ask for a refresh of asynchronous variables\n                this.engine.refreshValues(request.nodesToRead, request.maxAge, (err?: Error | null) => {\n                    assert(!err, \" error not handled here , fix me\");\n                    results = this.engine.read(context, request);\n\n                    assert(results[0].schema.name === \"DataValue\");\n                    assert(results.length === request.nodesToRead!.length);\n\n                    response = new ReadResponse({\n                        diagnosticInfos: undefined,\n                        results: undefined\n                    });\n                    // set it here for performance\n                    response.results = results;\n                    assert(response.diagnosticInfos!.length === 0);\n                    sendResponse(response);\n                });\n            }\n        );\n    }\n\n    // read services\n    protected _on_HistoryReadRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as HistoryReadRequest;\n\n        assert(request instanceof HistoryReadRequest);\n\n        this._apply_on_SessionObject(\n            HistoryReadResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statsCode: StatusCode) => void) => {\n                let response;\n\n                const timestampsToReturn = request.timestampsToReturn;\n\n                if (timestampsToReturn === TimestampsToReturn.Invalid) {\n                    return sendError(StatusCodes.BadTimestampsToReturnInvalid);\n                }\n\n                request.nodesToRead = request.nodesToRead || [];\n\n                if (!request.nodesToRead || request.nodesToRead.length <= 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                assert(request.nodesToRead[0].schema.name === \"HistoryReadValueId\");\n\n                // limit size of nodesToRead array to maxNodesPerRead\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerRead > 0) {\n                    if (request.nodesToRead.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRead) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n                // todo : handle\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerHistoryReadData > 0) {\n                    if (request.nodesToRead.length > this.engine.serverCapabilities.operationLimits.maxNodesPerHistoryReadData) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerHistoryReadEvents > 0) {\n                    if (request.nodesToRead.length > this.engine.serverCapabilities.operationLimits.maxNodesPerHistoryReadEvents) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const context = new SessionContext({ session, server: this });\n\n                // ask for a refresh of asynchronous variables\n                this.engine.refreshValues(request.nodesToRead, 0, (err?: Error | null) => {\n                    assert(!err, \" error not handled here , fix me\"); // TODO\n\n                    this.engine.historyRead(context, request, (err1: Error | null, results?: HistoryReadResult[]) => {\n                        if (err1) {\n                            return sendError(StatusCodes.BadHistoryOperationInvalid);\n                        }\n                        if (!results) {\n                            return sendError(StatusCodes.BadHistoryOperationInvalid);\n                        }\n\n                        assert(results[0].schema.name === \"HistoryReadResult\");\n                        assert(results.length === request.nodesToRead!.length);\n\n                        response = new HistoryReadResponse({\n                            diagnosticInfos: undefined,\n                            results\n                        });\n\n                        assert(response.diagnosticInfos!.length === 0);\n                        sendResponse(response);\n                    });\n                });\n            }\n        );\n    }\n\n    /*\n   // write services\n   // OPCUA Specification 1.02 Part 3 : 5.10.4 Write\n   // This Service is used to write values to one or more Attributes of one or more Nodes. For constructed\n   // Attribute values whose elements are indexed, such as an array, this Service allows Clients to write\n   // the entire set of indexed values as a composite, to write individual elements or to write ranges of\n   // elements of the composite.\n   // The values are written to the data source, such as a device, and the Service does not return until it writes\n   // the values or determines that the value cannot be written. In certain cases, the Server will successfully\n   // to an intermediate system or Server, and will not know if the data source was updated properly. In these cases,\n   // the Server should report a success code that indicates that the write was not verified.\n   // In the cases where the Server is able to verify that it has successfully written to the data source,\n   // it reports an unconditional success.\n   */\n    protected _on_WriteRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as WriteRequest;\n        assert(request instanceof WriteRequest);\n        assert(!request.nodesToWrite || Array.isArray(request.nodesToWrite));\n\n        this._apply_on_SessionObject(\n            WriteResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                let response;\n\n                if (!request.nodesToWrite || request.nodesToWrite.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerWrite > 0) {\n                    if (request.nodesToWrite.length > this.engine.serverCapabilities.operationLimits.maxNodesPerWrite) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                // proceed with registered nodes alias resolution\n                for (const nodeToWrite of request.nodesToWrite) {\n                    nodeToWrite.nodeId = session.resolveRegisteredNode(nodeToWrite.nodeId);\n                }\n\n                const context = new SessionContext({ session, server: this });\n\n                assert(request.nodesToWrite[0].schema.name === \"WriteValue\");\n                this.engine.write(context, request.nodesToWrite, (err: Error | null, results?: StatusCode[]) => {\n                    if (err) {\n                        errorLog(err);\n                        return sendError(StatusCodes.BadInternalError);\n                    }\n                    assert(Array.isArray(results));\n                    assert(results!.length === request.nodesToWrite!.length);\n                    response = new WriteResponse({\n                        diagnosticInfos: undefined,\n                        results\n                    });\n                    sendResponse(response);\n                });\n            }\n        );\n    }\n\n    // subscription services\n    protected _on_CreateSubscriptionRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const engine = this.engine;\n        const addressSpace = engine.addressSpace!;\n\n        const request = message.request as CreateSubscriptionRequest;\n        assert(request instanceof CreateSubscriptionRequest);\n\n        this._apply_on_SessionObject(\n            CreateSubscriptionResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                const context = new SessionContext({ session, server: this });\n\n                if (session.currentSubscriptionCount >= this.engine.serverCapabilities.maxSubscriptionsPerSession) {\n                    return sendError(StatusCodes.BadTooManySubscriptions);\n                }\n\n                if (this.currentSubscriptionCount >= this.engine.serverCapabilities.maxSubscriptions) {\n                    return sendError(StatusCodes.BadTooManySubscriptions);\n                }\n\n                const subscription = session.createSubscription(request);\n\n                subscription.on(\"monitoredItem\", (monitoredItem: MonitoredItem) => {\n                    prepareMonitoredItem(context, addressSpace, monitoredItem);\n                });\n\n                const response = new CreateSubscriptionResponse({\n                    revisedLifetimeCount: subscription.lifeTimeCount,\n                    revisedMaxKeepAliveCount: subscription.maxKeepAliveCount,\n                    revisedPublishingInterval: subscription.publishingInterval,\n                    subscriptionId: subscription.id\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_DeleteSubscriptionsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as DeleteSubscriptionsRequest;\n        assert(request instanceof DeleteSubscriptionsRequest);\n        this._apply_on_SubscriptionIds(\n            DeleteSubscriptionsResponse,\n            message,\n            channel,\n            async (session: ServerSession, subscriptionId: number) => {\n                let subscription = this.engine.findOrphanSubscription(subscriptionId);\n                // istanbul ignore next\n                if (subscription) {\n                    warningLog(\"Deleting an orphan subscription\", subscriptionId);\n\n                    await this._beforeDeleteSubscription(subscription);\n                    return this.engine.deleteOrphanSubscription(subscription);\n                }\n\n                subscription = session.getSubscription(subscriptionId);\n                if (subscription) {\n                    await this._beforeDeleteSubscription(subscription);\n                }\n\n                return session.deleteSubscription(subscriptionId);\n            }\n        );\n    }\n\n    protected _on_TransferSubscriptionsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        //\n        // sendInitialValue Boolean\n        //    A Boolean parameter with the following values:\n        //    TRUE      the first Publish response(s) after the TransferSubscriptions call shall\n        //              contain the current values of all Monitored Items in the Subscription where\n        //              the Monitoring Mode is set to Reporting.\n        //    FALSE     the first Publish response after the TransferSubscriptions call shall contain only the value\n        //              changes since the last Publish response was sent.\n        //    This parameter only applies to MonitoredItems used for monitoring Attribute changes.\n        //\n\n        const engine = this.engine;\n\n        const request = message.request as TransferSubscriptionsRequest;\n        assert(request instanceof TransferSubscriptionsRequest);\n        this._apply_on_SubscriptionIds(\n            TransferSubscriptionsResponse,\n            message,\n            channel,\n            async (session: ServerSession, subscriptionId: number) =>\n                await engine.transferSubscription(session, subscriptionId, request.sendInitialValues)\n        );\n    }\n\n    protected _on_CreateMonitoredItemsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const engine = this.engine;\n        const addressSpace = engine.addressSpace!;\n\n        const request = message.request as CreateMonitoredItemsRequest;\n        assert(request instanceof CreateMonitoredItemsRequest);\n\n        this._apply_on_Subscription(\n            CreateMonitoredItemsResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ): Promise<void> => {\n                const timestampsToReturn = request.timestampsToReturn;\n                if (timestampsToReturn === TimestampsToReturn.Invalid) {\n                    return sendError(StatusCodes.BadTimestampsToReturnInvalid);\n                }\n\n                if (!request.itemsToCreate || request.itemsToCreate.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (request.itemsToCreate.length > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const options = this.options as OPCUAServerOptions;\n                let results: MonitoredItemCreateResult[] = [];\n                if (options.onCreateMonitoredItem) {\n                    const resultsPromise = request.itemsToCreate.map(async (monitoredItemCreateRequest) => {\n                        const { monitoredItem, createResult } = subscription.preCreateMonitoredItem(\n                            addressSpace,\n                            timestampsToReturn,\n                            monitoredItemCreateRequest\n                        );\n                        if (monitoredItem) {\n                            await options.onCreateMonitoredItem!(subscription, monitoredItem);\n                            subscription.postCreateMonitoredItem(monitoredItem, monitoredItemCreateRequest, createResult);\n                        }\n                        return createResult;\n                    });\n                    results = await Promise.all(resultsPromise);\n                } else {\n                    results = request.itemsToCreate.map((monitoredItemCreateRequest) => {\n                        const { monitoredItem, createResult } = subscription.preCreateMonitoredItem(\n                            addressSpace,\n                            timestampsToReturn,\n                            monitoredItemCreateRequest\n                        );\n                        if (monitoredItem) {\n                            subscription.postCreateMonitoredItem(monitoredItem, monitoredItemCreateRequest, createResult);\n                        }\n                        return createResult;\n                    });\n                }\n                const response = new CreateMonitoredItemsResponse({\n                    responseHeader: { serviceResult: StatusCodes.Good },\n                    results\n                    // ,diagnosticInfos: []\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_ModifySubscriptionRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as ModifySubscriptionRequest;\n        assert(request instanceof ModifySubscriptionRequest);\n\n        this._apply_on_Subscription(\n            ModifySubscriptionResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: ModifySubscriptionResponse) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                subscription.modify(request);\n\n                const response = new ModifySubscriptionResponse({\n                    revisedLifetimeCount: subscription.lifeTimeCount,\n                    revisedMaxKeepAliveCount: subscription.maxKeepAliveCount,\n                    revisedPublishingInterval: subscription.publishingInterval\n                });\n\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_ModifyMonitoredItemsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as ModifyMonitoredItemsRequest;\n\n        assert(request instanceof ModifyMonitoredItemsRequest);\n        this._apply_on_Subscription(\n            ModifyMonitoredItemsResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: ModifyMonitoredItemsResponse) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                const timestampsToReturn = request.timestampsToReturn;\n                if (timestampsToReturn === TimestampsToReturn.Invalid) {\n                    return sendError(StatusCodes.BadTimestampsToReturnInvalid);\n                }\n\n                if (!request.itemsToModify || request.itemsToModify.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                /* istanbul ignore next */\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (request.itemsToModify.length > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const itemsToModify = request.itemsToModify; // MonitoredItemModifyRequest\n\n                function modifyMonitoredItem(item: MonitoredItemModifyRequest) {\n                    const monitoredItemId = item.monitoredItemId;\n                    const monitoredItem = subscription.getMonitoredItem(monitoredItemId);\n                    if (!monitoredItem) {\n                        return new MonitoredItemModifyResult({ statusCode: StatusCodes.BadMonitoredItemIdInvalid });\n                    }\n\n                    // adjust samplingInterval if === -1\n                    if (item.requestedParameters.samplingInterval === -1) {\n                        item.requestedParameters.samplingInterval = subscription.publishingInterval;\n                    }\n                    return monitoredItem.modify(timestampsToReturn, item.requestedParameters);\n                }\n\n                const results = itemsToModify.map(modifyMonitoredItem);\n\n                const response = new ModifyMonitoredItemsResponse({\n                    results\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_PublishRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as PublishRequest;\n        assert(request instanceof PublishRequest);\n\n        this._apply_on_SessionObject(\n            PublishResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                assert(session);\n                assert(session.publishEngine); // server.publishEngine doesn't exists, OPCUAServer has probably shut down already\n                session.publishEngine._on_PublishRequest(request, (request1: PublishRequest, response: PublishResponse) => {\n                    sendResponse(response);\n                });\n            }\n        );\n    }\n\n    protected _on_SetPublishingModeRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as SetPublishingModeRequest;\n        assert(request instanceof SetPublishingModeRequest);\n        const publishingEnabled = request.publishingEnabled;\n        this._apply_on_Subscriptions(\n            SetPublishingModeResponse,\n            message,\n            channel,\n            async (session: ServerSession, subscription: Subscription) => {\n                return subscription.setPublishingMode(publishingEnabled);\n            }\n        );\n    }\n\n    protected _on_DeleteMonitoredItemsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as DeleteMonitoredItemsRequest;\n        assert(request instanceof DeleteMonitoredItemsRequest);\n\n        this._apply_on_Subscription(\n            DeleteMonitoredItemsResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                /* istanbul ignore next */\n                if (!request.monitoredItemIds || request.monitoredItemIds.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                /* istanbul ignore next */\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (request.monitoredItemIds.length > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const resultsPromises = request.monitoredItemIds.map(async (monitoredItemId: number) => {\n                    if (this.options.onDeleteMonitoredItem) {\n                        const monitoredItem = subscription.getMonitoredItem(monitoredItemId);\n                        if (monitoredItem) {\n                            await this.options.onDeleteMonitoredItem(subscription, monitoredItem);\n                        }\n                    }\n                    return subscription.removeMonitoredItem(monitoredItemId);\n                });\n\n                try {\n                    const results = await Promise.all(resultsPromises);\n\n                    const response = new DeleteMonitoredItemsResponse({\n                        diagnosticInfos: undefined,\n                        results\n                    });\n\n                    sendResponse(response);\n                } catch (err) {\n                    warningLog(err);\n                    return sendError(StatusCodes.BadInternalError);\n                }\n            }\n        );\n    }\n    protected _on_SetTriggeringRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as SetTriggeringRequest;\n        assert(request instanceof SetTriggeringRequest);\n\n        this._apply_on_Subscription(\n            SetTriggeringResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                /* */\n                const { triggeringItemId, linksToAdd, linksToRemove } = request;\n\n                /**\n                 * The MaxMonitoredItemsPerCall Property indicates\n                 * [...]\n                 *  \u2022 the maximum size of the sum of the linksToAdd and linksToRemove arrays when a\n                 *    Client calls the SetTriggering Service.\n                 *\n                 */\n                const maxElements = (linksToAdd ? linksToAdd.length : 0) + (linksToRemove ? linksToRemove.length : 0);\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (maxElements > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const { addResults, removeResults, statusCode } = subscription.setTriggering(\n                    triggeringItemId,\n                    linksToAdd,\n                    linksToRemove\n                );\n                const response = new SetTriggeringResponse({\n                    responseHeader: { serviceResult: statusCode },\n\n                    addResults,\n                    removeResults,\n                    addDiagnosticInfos: null,\n                    removeDiagnosticInfos: null\n                });\n\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected async _beforeDeleteSubscription(subscription: Subscription): Promise<void> {\n        if (!this.options.onDeleteMonitoredItem) {\n            return;\n        }\n        await subscription.applyOnMonitoredItem(this.options.onDeleteMonitoredItem.bind(null, subscription) as any);\n    }\n    protected _on_RepublishRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as RepublishRequest;\n        assert(request instanceof RepublishRequest);\n\n        this._apply_on_Subscription(\n            RepublishResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                // update diagnostic counter\n                subscription.subscriptionDiagnostics.republishRequestCount += 1;\n                subscription.subscriptionDiagnostics.republishMessageRequestCount += 1;\n\n                const retransmitSequenceNumber = request.retransmitSequenceNumber;\n                const notificationMessage = subscription.getMessageForSequenceNumber(retransmitSequenceNumber);\n\n                if (!notificationMessage) {\n                    return sendError(StatusCodes.BadMessageNotAvailable);\n                }\n                const response = new RepublishResponse({\n                    notificationMessage,\n                    responseHeader: {\n                        serviceResult: StatusCodes.Good\n                    }\n                });\n                // update diagnostic counter\n                subscription.subscriptionDiagnostics.republishMessageCount += 1;\n\n                sendResponse(response);\n            }\n        );\n    }\n\n    // Bad_NothingToDo\n    // Bad_TooManyOperations\n    // Bad_SubscriptionIdInvalid\n    // Bad_MonitoringModeInvalid\n    protected _on_SetMonitoringModeRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as SetMonitoringModeRequest;\n        assert(request instanceof SetMonitoringModeRequest);\n\n        this._apply_on_Subscription(\n            SetMonitoringModeResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                /* istanbul ignore next */\n                if (!request.monitoredItemIds || request.monitoredItemIds.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                /* istanbul ignore next */\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (request.monitoredItemIds.length > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n                const monitoringMode = request.monitoringMode;\n\n                if (!isMonitoringModeValid(monitoringMode)) {\n                    return sendError(StatusCodes.BadMonitoringModeInvalid);\n                }\n\n                const results = request.monitoredItemIds.map((monitoredItemId) => {\n                    const monitoredItem = subscription.getMonitoredItem(monitoredItemId);\n                    if (!monitoredItem) {\n                        return StatusCodes.BadMonitoredItemIdInvalid;\n                    }\n                    monitoredItem.setMonitoringMode(monitoringMode);\n                    return StatusCodes.Good;\n                });\n\n                const response = new SetMonitoringModeResponse({\n                    results\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    // _on_TranslateBrowsePathsToNodeIds service\n    protected _on_TranslateBrowsePathsToNodeIdsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as TranslateBrowsePathsToNodeIdsRequest;\n        assert(request instanceof TranslateBrowsePathsToNodeIdsRequest);\n\n        this._apply_on_SessionObject(\n            TranslateBrowsePathsToNodeIdsResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                if (!request.browsePaths || request.browsePaths.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerTranslateBrowsePathsToNodeIds > 0) {\n                    if (\n                        request.browsePaths.length >\n                        this.engine.serverCapabilities.operationLimits.maxNodesPerTranslateBrowsePathsToNodeIds\n                    ) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const browsePathsResults = request.browsePaths.map((browsePath) => this.engine.browsePath(browsePath));\n\n                const response = new TranslateBrowsePathsToNodeIdsResponse({\n                    diagnosticInfos: null,\n                    results: browsePathsResults\n                });\n\n                sendResponse(response);\n            }\n        );\n    }\n\n    // Call Service Result Codes\n    // Symbolic Id Description\n    // Bad_NothingToDo       See Table 165 for the description of this result code.\n    // Bad_TooManyOperations See Table 165 for the description of this result code.\n    //\n    protected _on_CallRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as CallRequest;\n        assert(request instanceof CallRequest);\n\n        this._apply_on_SessionObject(\n            CallResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                let response;\n\n                if (!request.methodsToCall || request.methodsToCall.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                // the MaxNodesPerMethodCall Property indicates the maximum size of the methodsToCall array when\n                // a Client calls the Call Service.\n                let maxNodesPerMethodCall = this.engine.serverCapabilities.operationLimits.maxNodesPerMethodCall;\n                maxNodesPerMethodCall = maxNodesPerMethodCall <= 0 ? 1000 : maxNodesPerMethodCall;\n                if (request.methodsToCall.length > maxNodesPerMethodCall) {\n                    return sendError(StatusCodes.BadTooManyOperations);\n                }\n\n                /* jshint validthis: true */\n                const addressSpace = this.engine.addressSpace!;\n\n                const context = new SessionContext({ session, server: this });\n\n                async.map(\n                    request.methodsToCall,\n                    callMethodHelper.bind(null, context, addressSpace),\n                    (err?: Error | null, results?: (CallMethodResultOptions | undefined)[]) => {\n                        /* istanbul ignore next */\n                        if (err) {\n                            errorLog(\"ERROR in method Call !! \", err);\n                        }\n                        assert(Array.isArray(results));\n                        response = new CallResponse({\n                            results: results as CallMethodResultOptions[]\n                        });\n                        filterDiagnosticInfo(request.requestHeader.returnDiagnostics, response);\n                        sendResponse(response);\n                    }\n                );\n            }\n        );\n    }\n\n    protected _on_RegisterNodesRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as RegisterNodesRequest;\n        assert(request instanceof RegisterNodesRequest);\n\n        this._apply_on_SessionObject(\n            RegisterNodesResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                let response;\n\n                if (!request.nodesToRegister || request.nodesToRegister.length === 0) {\n                    response = new RegisterNodesResponse({ responseHeader: { serviceResult: StatusCodes.BadNothingToDo } });\n                    return sendResponse(response);\n                }\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes > 0) {\n                    if (request.nodesToRegister.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n                // A list of NodeIds which the Client shall use for subsequent access operations. The\n                // size and order of this list matches the size and order of the nodesToRegister\n                // request parameter.\n                // The Server may return the NodeId from the request or a new (an alias) NodeId. It\n                // is recommended that the Server return a numeric NodeIds for aliasing.\n                // In case no optimization is supported for a Node, the Server shall return the\n                // NodeId from the request.\n                const registeredNodeIds = request.nodesToRegister.map((nodeId) => session.registerNode(nodeId));\n\n                response = new RegisterNodesResponse({\n                    registeredNodeIds\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_UnregisterNodesRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as UnregisterNodesRequest;\n        assert(request instanceof UnregisterNodesRequest);\n\n        this._apply_on_SessionObject(\n            UnregisterNodesResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                let response;\n\n                request.nodesToUnregister = request.nodesToUnregister || [];\n\n                if (!request.nodesToUnregister || request.nodesToUnregister.length === 0) {\n                    response = new UnregisterNodesResponse({ responseHeader: { serviceResult: StatusCodes.BadNothingToDo } });\n                    return sendResponse(response);\n                }\n\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes > 0) {\n                    if (\n                        request.nodesToUnregister.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes\n                    ) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                request.nodesToUnregister.map((nodeId: NodeId) => session.unRegisterNode(nodeId));\n\n                response = new UnregisterNodesResponse({});\n                sendResponse(response);\n            }\n        );\n    }\n\n    /* istanbul ignore next */\n    protected _on_Cancel(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, CancelResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    // NodeManagement Service Set Overview\n    // This Service Set defines Services to add and delete AddressSpace Nodes and References between them. All added\n    // Nodes continue to exist in the AddressSpace even if the Client that created them disconnects from the Server.\n    //\n    /* istanbul ignore next */\n    protected _on_AddNodes(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, AddNodesResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_AddReferences(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, AddReferencesResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_DeleteNodes(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, DeleteNodesResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_DeleteReferences(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, DeleteReferencesResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    // Query Service\n    /* istanbul ignore next */\n    protected _on_QueryFirst(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, QueryFirstResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_QueryNext(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, QueryNextResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_HistoryUpdate(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, HistoryUpdateResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    private createEndpoint(port1: number, serverOptions: OPCUAServerOptions): OPCUAServerEndPoint {\n        // add the tcp/ip endpoint with no security\n        const endPoint = new OPCUAServerEndPoint({\n            port: port1,\n\n            certificateManager: this.serverCertificateManager,\n\n            certificateChain: this.getCertificateChain(),\n            privateKey: this.getPrivateKey(),\n\n            defaultSecureTokenLifetime: serverOptions.defaultSecureTokenLifetime || 600000,\n            timeout: serverOptions.timeout || 3 * 60 * 1000,\n\n            maxConnections: this.maxConnectionsPerEndpoint,\n            objectFactory: this.objectFactory,\n            serverInfo: this.serverInfo\n        });\n        return endPoint;\n    }\n\n    private createEndpointDescriptions(\n        serverOption: OPCUAServerOptions,\n        endpointOptions: OPCUAServerEndpointOptions\n    ): OPCUAServerEndPoint {\n        /* istanbul ignore next */\n        if (!endpointOptions) {\n            throw new Error(\"internal error\");\n        }\n        const hostname = getFullyQualifiedDomainName();\n        endpointOptions.hostname = endpointOptions.hostname || hostname;\n        endpointOptions.port = endpointOptions.port || 26543;\n\n        /* istanbul ignore next */\n        if (\n            !Object.prototype.hasOwnProperty.call(endpointOptions, \"port\") ||\n            !isFinite(endpointOptions.port!) ||\n            typeof endpointOptions.port !== \"number\"\n        ) {\n            throw new Error(\"expecting a valid port (number)\");\n        }\n\n        const port = Number(endpointOptions.port || 0);\n\n        const endPoint = this.createEndpoint(port, serverOption);\n\n        endpointOptions.alternateHostname = endpointOptions.alternateHostname || [];\n        const alternateHostname =\n            endpointOptions.alternateHostname instanceof Array\n                ? endpointOptions.alternateHostname\n                : [endpointOptions.alternateHostname];\n        const allowAnonymous = endpointOptions.allowAnonymous === undefined ? true : !!endpointOptions.allowAnonymous;\n\n        endPoint.addStandardEndpointDescriptions({\n            allowAnonymous,\n            securityModes: endpointOptions.securityModes,\n            securityPolicies: endpointOptions.securityPolicies,\n\n            hostname: endpointOptions.hostname,\n\n            alternateHostname,\n\n            disableDiscovery: !!endpointOptions.disableDiscovery,\n            // xx                hostname,\n            resourcePath: serverOption.resourcePath || \"\"\n        });\n        return endPoint;\n    }\n\n    public async initializeCM(): Promise<void> {\n        await super.initializeCM();\n        await this.userCertificateManager.initialize();\n    }\n}\n\nexport interface RaiseEventAuditEventData extends RaiseEventData {\n    actionTimeStamp: PseudoVariantDateTime;\n    status: PseudoVariantBoolean;\n    serverId: PseudoVariantString;\n    /**\n     * ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.\n     */\n    clientAuditEntryId: PseudoVariantString;\n    /**\n     * The ClientUserId identifies the user of the client requesting an action. The ClientUserId can be\n     * obtained from the UserIdentityToken passed in the ActivateSession call.\n     */\n    clientUserId: PseudoVariantString;\n    sourceName: PseudoVariantString;\n}\n\nexport interface RaiseEventAuditUpdateMethodEventData extends RaiseEventAuditEventData {\n    methodId: PseudoVariantNodeId;\n    inputArguments: any;\n}\n\nexport interface RaiseEventAuditConditionCommentEventData extends RaiseEventAuditUpdateMethodEventData {\n    eventId: PseudoVariantByteString;\n    comment: PseudoVariantLocalizedText;\n}\n\nexport interface RaiseEventAuditSessionEventData extends RaiseEventAuditEventData {\n    /**\n     *  part 5 - 6.4.7 AuditSessionEventType\n     */\n    sessionId: PseudoVariantNodeId;\n}\n\nexport interface RaiseEventAuditCreateSessionEventData extends RaiseEventAuditSessionEventData {\n    /**\n     *  part 5 - 6.4.8 AuditCreateSessionEventType\n     *  SecureChannelId shall uniquely identify the SecureChannel.\n     *  The application shall use the same identifier in\n     *  all AuditEvents related to the Session Service Set (AuditCreateSessionEventType, AuditActivateSessionEventType\n     *  and their subtypes) and the SecureChannel Service Set (AuditChannelEventType and its subtype\n     */\n    secureChannelId: PseudoVariantString;\n    revisedSessionTimeout: PseudoVariantDuration;\n    clientCertificate: PseudoVariantByteString;\n    clientCertificateThumbprint: PseudoVariantString;\n}\n\nexport interface RaiseEventAuditActivateSessionEventData extends RaiseEventAuditSessionEventData {\n    /**\n     * part 5 - 6.4.10 AuditActivateSessionEventType\n     */\n    clientSoftwareCertificates: PseudoVariantExtensionObjectArray;\n    /**\n     * UserIdentityToken reflects the userIdentityToken parameter of the ActivateSession Service call.\n     * For Username/Password tokens the password should NOT be included.\n     */\n    userIdentityToken: PseudoVariantExtensionObject;\n    /**\n     * SecureChannelId shall uniquely identify the SecureChannel. The application shall use the same identifier\n     * in all AuditEvents related to the Session Service Set (AuditCreateSessionEventType,\n     * AuditActivateSessionEventType and their subtypes) and the SecureChannel Service Set\n     * (AuditChannelEventType and its subtypes).\n     */\n    secureChannelId: PseudoVariantString;\n}\n\n// tslint:disable:no-empty-interface\nexport interface RaiseEventTransitionEventData extends RaiseEventData {}\n\nexport interface RaiseEventAuditUrlMismatchEventTypeData extends RaiseEventData {\n    endpointUrl: PseudoVariantString;\n}\nexport interface OPCUAServer {\n    /**\n     * @internal\n     * @param eventType\n     * @param options\n     */\n    raiseEvent(eventType: \"AuditSessionEventType\", options: RaiseEventAuditSessionEventData): void;\n\n    raiseEvent(eventType: \"AuditCreateSessionEventType\", options: RaiseEventAuditCreateSessionEventData): void;\n\n    raiseEvent(eventType: \"AuditActivateSessionEventType\", options: RaiseEventAuditActivateSessionEventData): void;\n\n    raiseEvent(eventType: \"AuditCreateSessionEventType\", options: RaiseEventData): void;\n\n    raiseEvent(eventType: \"AuditConditionCommentEventType\", options: RaiseEventAuditConditionCommentEventData): void;\n\n    raiseEvent(eventType: \"AuditUrlMismatchEventType\", options: RaiseEventAuditUrlMismatchEventTypeData): void;\n\n    raiseEvent(eventType: \"TransitionEventType\", options: RaiseEventTransitionEventData): void;\n}\n\nexport interface OPCUAServer extends EventEmitter {\n    on(event: \"create_session\", eventHandler: (session: ServerSession) => void): this;\n\n    on(event: \"session_activated\", eventHandler: (session: ServerSession) => void): this;\n\n    on(event: \"session_closed\", eventHandler: (session: ServerSession, reason: string) => void): this;\n\n    on(event: \"post_initialize\", eventHandler: () => void): this;\n\n    /**\n     * emitted when the server is trying to registered the LDS\n     * but when the connection to the lds has failed\n     * serverRegistrationPending is sent when the backoff signal of the\n     * connection process is raised\n     * @event serverRegistrationPending\n     */\n    on(event: \"serverRegistrationPending\", eventHandler: () => void): this;\n\n    /**\n     * event raised when server  has been successfully registered on the local discovery server\n     * @event serverRegistered\n     */\n    on(event: \"serverRegistered\", eventHandler: () => void): this;\n\n    /**\n     * event raised when server registration has been successfully renewed on the local discovery server\n     * @event serverRegistered\n     */\n    on(event: \"serverRegistrationRenewed\", eventHandler: () => void): this;\n\n    /**\n     * event raised when server  has been successfully unregistered from the local discovery server\n     * @event serverUnregistered\n     */\n    on(event: \"serverUnregistered\", eventHandler: () => void): this;\n\n    /**\n     * event raised after the server has raised an OPCUA event toward a client\n     */\n    on(event: \"event\", eventHandler: (eventData: any) => void): this;\n\n    /**\n     * event raised when the server received a request from one of its connected client.\n     * useful for trace purpose.\n     */\n    on(event: \"request\", eventHandler: (request: Request, channel: ServerSecureChannelLayer) => void): this;\n\n    /**\n     * event raised when the server send an response to a request to one of its connected client.\n     * useful for trace purpose.\n     */\n    on(event: \"response\", eventHandler: (request: Response, channel: ServerSecureChannelLayer) => void): this;\n\n    /**\n     * event raised when a new secure channel is opened\n     */\n    on(event: \"newChannel\", eventHandler: (channel: ServerSecureChannelLayer, endpoint: OPCUAServerEndPoint) => void): this;\n\n    /**\n     * event raised when a new secure channel is closed\n     */\n    on(event: \"closeChannel\", eventHandler: (channel: ServerSecureChannelLayer, endpoint: OPCUAServerEndPoint) => void): this;\n\n    /**\n     * event raised when the server refused a tcp connection from a client. ( for instance because too any connections)\n     */\n    on(event: \"connectionRefused\", eventHandler: (socketData: ISocketData, endpoint: OPCUAServerEndPoint) => void): this;\n\n    /**\n     * event raised when a OpenSecureChannel has failed, it could be a invalid certificate or malformed message\n     */\n    on(\n        event: \"openSecureChannelFailure\",\n        eventHandler: (socketData: ISocketData, channelData: IChannelData, endpoint: OPCUAServerEndPoint) => void\n    ): this;\n\n    on(event: string, eventHandler: (...args: [any?, ...any[]]) => void): this;\n}\n\nconst opts = { multiArgs: false };\nOPCUAServer.prototype.start = thenify.withCallback(OPCUAServer.prototype.start, opts);\nOPCUAServer.prototype.initialize = thenify.withCallback(OPCUAServer.prototype.initialize, opts);\nOPCUAServer.prototype.shutdown = thenify.withCallback(OPCUAServer.prototype.shutdown, opts);\n", "/**\n * @module node-opcua-server\n */\n// tslint:disable:no-console\nimport { EventEmitter } from \"events\";\nimport * as chalk from \"chalk\";\nimport { partition, sortBy } from \"lodash\";\n\nimport { assert } from \"node-opcua-assert\";\nimport { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\nimport { ObjectRegistry } from \"node-opcua-object-registry\";\nimport { StatusCode, StatusCodes } from \"node-opcua-status-code\";\n\nimport { PublishRequest, PublishResponse, SubscriptionAcknowledgement } from \"node-opcua-types\";\nimport { Subscription } from \"./server_subscription\";\nimport { SubscriptionState } from \"./server_subscription\";\nimport { IServerSidePublishEngine, INotifMsg, IClosedOrTransferredSubscription } from \"./i_server_side_publish_engine\";\n\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\n\nfunction traceLog(...args: [any?, ...any[]]) {\n    if (!doDebug) {\n        return;\n    }\n    const a: string[] = args.map((x?: any) => x!);\n    a.unshift(chalk.yellow(\" TRACE \"));\n    debugLog(...a);\n}\n\nexport interface ServerSidePublishEngineOptions {\n    maxPublishRequestInQueue?: number;\n}\n\ninterface PublishData {\n    request: PublishRequest;\n    serverTimeWhenReceived: number;\n    results: StatusCode[];\n    callback: (request: PublishRequest, response: PublishResponse) => void;\n}\n\nfunction _assertValidPublishData(publishData: PublishData) {\n    assert(publishData.request instanceof PublishRequest);\n    assert(typeof publishData.serverTimeWhenReceived === \"number\");\n    assert(Array.isArray(publishData.results));\n    assert(typeof publishData.callback === \"function\");\n}\n\nfunction dummy_function() {\n    /* empty */\n}\n\nfunction addDate(date: Date, delta: number) {\n    return new Date(date.getTime() + delta);\n}\n\nfunction timeout_filter(publishData: PublishData): boolean {\n    const request = publishData.request;\n    const results = publishData.results;\n    if (!request.requestHeader.timeoutHint) {\n        // no limits\n        return false;\n    }\n    const serverTimeWhenReceived = publishData.serverTimeWhenReceived;\n    // remark : do not use request.requestHeader.timestamp! here as this is a client date and server and client clocks might differ\n    const expected_timeout_time = addDate(new Date(serverTimeWhenReceived), request.requestHeader.timeoutHint);\n    return expected_timeout_time.getTime() < Date.now();\n}\n\n/***\n *  a Publish Engine for a given session\n */\nexport class ServerSidePublishEngine extends EventEmitter implements IServerSidePublishEngine {\n    public static registry = new ObjectRegistry();\n\n    /**\n     * @private\n     */\n    public static transferSubscriptionsToOrphan(\n        srcPublishEngine: ServerSidePublishEngine,\n        destPublishEngine: ServerSidePublishEngine\n    ): void {\n        debugLog(\n            chalk.yellow(\n                \"ServerSidePublishEngine#transferSubscriptionsToOrphan! \" + \"start transferring long live subscriptions to orphan\"\n            )\n        );\n\n        for (const subscription of Object.values(srcPublishEngine._subscriptions)) {\n            assert((subscription.publishEngine as any) === srcPublishEngine);\n\n            if (subscription.$session) {\n                subscription.$session._unexposeSubscriptionDiagnostics(subscription);\n            } else {\n                console.warn(\"Warning:  subscription\", subscription.id, \" has no session attached!!!\");\n            }\n\n            ServerSidePublishEngine.transferSubscription(subscription, destPublishEngine, false);\n        }\n        assert(srcPublishEngine.subscriptionCount === 0);\n\n        debugLog(\n            chalk.yellow(\n                \"ServerSidePublishEngine#transferSubscriptionsToOrphan! \" + \"end transferring long lived subscriptions to orphan\"\n            )\n        );\n    }\n\n    /**\n     * @param subscription\n     * @param destPublishEngine\n     * @param sendInitialValues true if initial values should be sent\n     * @private\n     */\n    public static async transferSubscription(\n        subscription: Subscription,\n        destPublishEngine: ServerSidePublishEngine,\n        sendInitialValues: boolean\n    ): Promise<Subscription> {\n        const srcPublishEngine = subscription.publishEngine as any as ServerSidePublishEngine;\n\n        assert(!destPublishEngine.getSubscriptionById(subscription.id));\n        assert(srcPublishEngine.getSubscriptionById(subscription.id));\n\n        // remove pending StatusChangeNotification on the same session that may exist already\n        destPublishEngine._purge_dangling_subscription(subscription.id);\n\n        debugLog(chalk.cyan(\"ServerSidePublishEngine.transferSubscription live subscriptionId =\"), subscription.subscriptionId);\n\n        // xx const internalNotification = subscription._flushSentNotifications();\n        debugLog(chalk.cyan(\"ServerSidePublishEngine.transferSubscription with  = \"), subscription.getAvailableSequenceNumbers());\n\n        //  If the Server transfers the Subscription to the new Session, the Server shall issue a\n        //  StatusChangeNotification notificationMessage with the status code Good_SubscriptionTransferred\n        //  to the old Session.\n        subscription.notifyTransfer();\n\n        const tmp = srcPublishEngine.detach_subscription(subscription);\n        destPublishEngine.add_subscription(tmp);\n        \n        subscription.resetLifeTimeCounter();\n        if (sendInitialValues) {\n            /*  A Boolean parameter with the following values:\n                TRUE  the first Publish response(s) after the TransferSubscriptions call\n                      shall contain the current values of all Monitored Items in the\n                      Subscription where the Monitoring Mode is set to Reporting.\n                      If a value is queued for a data MonitoredItem, the next value in\n                      the queue is sent in the Publish response. If no value is queued\n                      for a data MonitoredItem, the last value sent is repeated in the\n                      Publish response.\n                FALSE the first Publish response after the TransferSubscriptions call\n                      shall contain only the value changes since the last Publish\n                      response was sent.\n                This parameter only applies to MonitoredItems used for monitoring Attribute\n                changes\n            */\n            debugLog(\"Resending initial values\");\n            await subscription.resendInitialValues();\n        }\n\n        assert(destPublishEngine.getSubscriptionById(subscription.id));\n        assert(!srcPublishEngine.getSubscriptionById(subscription.id));\n\n        return subscription;\n    }\n\n    public maxPublishRequestInQueue = 0;\n    public isSessionClosed = false;\n\n    private _publish_request_queue: PublishData[] = [];\n    private _subscriptions: { [key: string]: Subscription };\n    private _closed_subscriptions: IClosedOrTransferredSubscription[] = [];\n\n    constructor(options?: ServerSidePublishEngineOptions) {\n        super();\n\n        options = options || {};\n\n        ServerSidePublishEngine.registry.register(this);\n\n        // a queue of pending publish request send by the client\n        // waiting to be used by the server to send notification\n        this._publish_request_queue = []; // { request :/*PublishRequest*/{},\n\n        this._subscriptions = {};\n\n        // _closed_subscriptions contains a collection of Subscription that\n        // have  expired but that still need to send some pending notification\n        // to the client.\n        // Once publish requests will be received from the  client\n        // the notifications of those subscriptions will be processed so that\n        // they can be properly disposed.\n        this._closed_subscriptions = [];\n\n        this.maxPublishRequestInQueue = options.maxPublishRequestInQueue || 100;\n\n        this.isSessionClosed = false;\n    }\n\n    public toString(): string {\n        let str = \"\";\n        str += `maxPublishRequestInQueue ${this.maxPublishRequestInQueue}\\n`;\n        str += `subscriptions ${Object.keys(this._subscriptions).join()}\\n`;\n        str += `closed subscriptions ${this._closed_subscriptions.map((s) => s.id).join()}\\n`;\n        return str;\n    }\n    public dispose(): void {\n        debugLog(\"ServerSidePublishEngine#dispose\");\n\n        assert(Object.keys(this._subscriptions).length === 0, \"self._subscriptions count!=0\");\n        this._subscriptions = {};\n\n        assert(this._closed_subscriptions.length === 0, \"self._closed_subscriptions count!=0\");\n        this._closed_subscriptions = [];\n\n        ServerSidePublishEngine.registry.unregister(this);\n    }\n\n    public process_subscriptionAcknowledgements(subscriptionAcknowledgements: SubscriptionAcknowledgement[]): StatusCode[] {\n        // process acknowledgements\n        subscriptionAcknowledgements = subscriptionAcknowledgements || [];\n        debugLog(\"process_subscriptionAcknowledgements = \", subscriptionAcknowledgements);\n        const results = subscriptionAcknowledgements.map((subscriptionAcknowledgement: SubscriptionAcknowledgement) => {\n            const subscription = this.getSubscriptionById(subscriptionAcknowledgement.subscriptionId);\n            if (!subscription) {\n                // // try to find the session\n                // const transferredSubscription = this._transferred_subscriptions.find(\n                //   (s) => s.subscriptionId === subscriptionAcknowledgement.subscriptionId\n                // );\n                // if (transferredSubscription) {\n                //   debugLog(\"Subscription acknowledgeNotification done in transferred subscription \");\n                //   return transferredSubscription.acknowledgeNotification(subscriptionAcknowledgement.sequenceNumber);\n                // }\n                return StatusCodes.BadSubscriptionIdInvalid;\n            }\n            return subscription.acknowledgeNotification(subscriptionAcknowledgement.sequenceNumber);\n        });\n\n        return results;\n    }\n\n    /**\n     * get a array of subscription handled by the publish engine.\n     */\n    public get subscriptions(): Subscription[] {\n        return Object.values(this._subscriptions);\n    }\n\n    /**\n     */\n    public add_subscription(subscription: Subscription): Subscription {\n        assert(subscription instanceof Subscription);\n        assert(isFinite(subscription.id));\n        subscription.publishEngine = (subscription.publishEngine || this) as any;\n        assert((subscription.publishEngine as any) === this);\n        assert(!this._subscriptions[subscription.id]);\n\n        debugLog(\"ServerSidePublishEngine#add_subscription -  adding subscription with Id:\", subscription.id);\n        this._subscriptions[subscription.id] = subscription;\n        // xx subscription._flushSentNotifications();\n        return subscription;\n    }\n\n    public detach_subscription(subscription: Subscription): Subscription {\n        assert(subscription instanceof Subscription);\n        assert(isFinite(subscription.id));\n        assert((subscription.publishEngine as any) === this);\n        assert(this._subscriptions[subscription.id] === subscription);\n\n        delete this._subscriptions[subscription.id];\n        subscription.publishEngine = null as any;\n        debugLog(\"ServerSidePublishEngine#detach_subscription detaching subscription with Id:\", subscription.id);\n        return subscription;\n    }\n\n    /**\n     */\n    public shutdown(): void {\n        if (this.subscriptionCount !== 0) {\n            debugLog(chalk.red(\"Shutting down pending subscription\"));\n            this.subscriptions.map((subscription: Subscription) => subscription.terminate());\n        }\n\n        assert(this.subscriptionCount === 0, \"subscription shall be removed first before you can shutdown a publish engine\");\n\n        debugLog(\"ServerSidePublishEngine#shutdown\");\n\n        // purge _publish_request_queue\n        this._publish_request_queue = [];\n\n        // purge self._closed_subscriptions\n        this._closed_subscriptions.map((subscription) => subscription.dispose());\n        this._closed_subscriptions = [];\n    }\n\n    /**\n     * number of pending PublishRequest available in queue\n     */\n    public get pendingPublishRequestCount(): number {\n        return this._publish_request_queue.length;\n    }\n\n    /**\n     * number of subscriptions\n     */\n    public get subscriptionCount(): number {\n        return Object.keys(this._subscriptions).length;\n    }\n\n    public get pendingClosedSubscriptionCount(): number {\n        return this._closed_subscriptions.length;\n    }\n\n    public get currentMonitoredItemCount(): number {\n        const subscriptions = Object.values(this._subscriptions);\n        const result = subscriptions.reduce((cumul: number, subscription: Subscription) => {\n            return cumul + subscription.monitoredItemCount;\n        }, 0);\n        assert(isFinite(result));\n        return result;\n    }\n\n    public _purge_dangling_subscription(subscriptionId: number): void {\n        this._closed_subscriptions = this._closed_subscriptions.filter((s) => s.id !== subscriptionId);\n    }\n\n    public on_close_subscription(subscription: IClosedOrTransferredSubscription): void {\n        doDebug && debugLog(\"ServerSidePublishEngine#on_close_subscription\", subscription.id);\n        if (subscription.hasPendingNotifications) {\n            doDebug && debugLog(\n                \"ServerSidePublishEngine#on_close_subscription storing subscription\",\n                subscription.id,\n                \" to _closed_subscriptions because it has pending notification\"\n            );\n            this._closed_subscriptions.push(subscription);\n        } else {\n            doDebug && debugLog(\"ServerSidePublishEngine#on_close_subscription disposing subscription\", subscription.id);\n            // subscription is no longer needed\n            subscription.dispose();\n        }\n\n        delete this._subscriptions[subscription.id];\n\n        while (this._feed_closed_subscription()) {\n            /* keep looping */\n        }\n        if (this.subscriptionCount === 0 && this._closed_subscriptions.length === 0) {\n            this.cancelPendingPublishRequest();\n        }\n    }\n\n    /**\n     * retrieve a subscription by id.\n     * @param subscriptionId\n     * @return Subscription\n     */\n    public getSubscriptionById(subscriptionId: number | string): Subscription {\n        return this._subscriptions[subscriptionId.toString()];\n    }\n\n    public findLateSubscriptions(): Subscription[] {\n        const subscriptions = Object.values(this._subscriptions);\n        return subscriptions.filter((subscription: Subscription) => {\n            return (subscription.state === SubscriptionState.LATE || !subscription.messageSent) && subscription.publishingEnabled;\n        });\n    }\n\n    public get hasLateSubscriptions(): boolean {\n        return this.findLateSubscriptions().length > 0;\n    }\n\n    public findLateSubscriptionsSortedByAge(): Subscription[] {\n        let late_subscriptions = this.findLateSubscriptions();\n        late_subscriptions = sortBy(late_subscriptions, \"timeToExpiration\");\n\n        return late_subscriptions;\n    }\n\n    public cancelPendingPublishRequestBeforeChannelChange(): void {\n        this._cancelPendingPublishRequest(StatusCodes.BadSecureChannelClosed);\n    }\n\n    public onSessionClose(): void {\n        this.isSessionClosed = true;\n        this._cancelPendingPublishRequest(StatusCodes.BadSessionClosed);\n    }\n\n    /**\n     * @private\n     */\n    public cancelPendingPublishRequest(): void {\n        assert(this.subscriptionCount === 0);\n        this._cancelPendingPublishRequest(StatusCodes.BadNoSubscription);\n    }\n\n    /**\n     *\n     * @param request\n     * @param callback\n     * @private\n     * @internal\n     */\n    public _on_PublishRequest(\n        request: PublishRequest,\n        callback?: (request1: PublishRequest, response: PublishResponse) => void\n    ): void {\n        callback = callback || dummy_function;\n        assert(typeof callback === \"function\");\n\n        // istanbul ignore next\n        if (!(request instanceof PublishRequest)) {\n            throw new Error(\"Internal error : expecting a Publish Request here\");\n        }\n\n        const subscriptionAckResults = this.process_subscriptionAcknowledgements(request.subscriptionAcknowledgements || []);\n\n        const currentTime = Date.now();\n        const publishData: PublishData = {\n            callback,\n            request,\n            results: subscriptionAckResults,\n            serverTimeWhenReceived: currentTime\n        };\n\n        if (this.isSessionClosed) {\n            traceLog(\"server has received a PublishRequest but session is Closed\");\n            this._send_error_for_request(publishData, StatusCodes.BadSessionClosed);\n        } else if (this.subscriptionCount === 0) {\n            if (this._closed_subscriptions.length > 0 && this._closed_subscriptions[0].hasPendingNotifications) {\n                const verif = this._publish_request_queue.length;\n                // add the publish request to the queue for later processing\n                this._publish_request_queue.push(publishData);\n\n                const processed = this._feed_closed_subscription();\n                //xx ( may be subscription has expired by themselves) assert(verif === this._publish_request_queue.length);\n                //xx  ( may be subscription has expired by themselves) assert(processed);\n                return;\n            }\n            traceLog(\"server has received a PublishRequest but has no subscription opened\");\n            this._send_error_for_request(publishData, StatusCodes.BadNoSubscription);\n        } else {\n            // add the publish request to the queue for later processing\n            this._publish_request_queue.push(publishData);\n            assert(this.pendingPublishRequestCount > 0);\n\n            debugLog(chalk.bgWhite.red(\"Adding a PublishRequest to the queue \"), this._publish_request_queue.length);\n\n            this._feed_closed_subscription();\n\n            this._feed_late_subscription();\n\n            this._handle_too_many_requests();\n        }\n    }\n\n    private _find_starving_subscription(): Subscription | null {\n        const late_subscriptions = this.findLateSubscriptions();\n        function compare_subscriptions(s1: Subscription, s2: Subscription): number {\n            if (s1.priority === s2.priority) {\n                return s1.timeToExpiration < s2.timeToExpiration ? 1 : 0;\n            }\n            return s1.priority > s2.priority ? 1 : 0;\n        }\n        function findLateSubscriptionSortedByPriority() {\n            if (late_subscriptions.length === 0) {\n                return null;\n            }\n            late_subscriptions.sort(compare_subscriptions);\n\n            // istanbul ignore next\n            if (doDebug) {\n                debugLog(\n                    late_subscriptions\n                        .map(\n                            (s: Subscription) =>\n                                \"[ id = \" +\n                                s.id +\n                                \" prio=\" +\n                                s.priority +\n                                \" t=\" +\n                                s.timeToExpiration +\n                                \" ka=\" +\n                                s.timeToKeepAlive +\n                                \" m?=\" +\n                                s.hasUncollectedMonitoredItemNotifications +\n                                \" \" + \n                                SubscriptionState[s.state] +\n                                \" \" + s.messageSent + \n                                \"]\"\n                        )\n                        .join(\" \\n\")\n                );\n            }\n            return late_subscriptions[late_subscriptions.length - 1];\n        }\n\n        if (this._closed_subscriptions) {\n            /** */\n        }\n        const starving_subscription = /* this.findSubscriptionWaitingForFirstPublish() || */ findLateSubscriptionSortedByPriority();\n        return starving_subscription;\n    }\n\n    private _feed_late_subscription() {\n        setImmediate(() => {\n            if (!this.pendingPublishRequestCount) {\n                return;\n            }\n            const starving_subscription = this._find_starving_subscription();\n            if (starving_subscription) {\n                doDebug && debugLog(chalk.bgWhite.red(\"feeding most late subscription subscriptionId  = \"), starving_subscription.id);\n                starving_subscription.process_subscription();\n            }\n        });\n    }\n\n    private _feed_closed_subscription() {\n        if (!this.pendingPublishRequestCount) {\n            return false;\n        }\n\n        if (this._closed_subscriptions.length === 0) {\n            debugLog(\"ServerSidePublishEngine#_feed_closed_subscription  -> nothing to do\");\n            return false;\n        }\n        // process closed subscription\n        const closed_subscription = this._closed_subscriptions[0]!;\n        assert(closed_subscription.hasPendingNotifications);\n        debugLog(\"ServerSidePublishEngine#_feed_closed_subscription for closed_subscription \", closed_subscription.id);\n        closed_subscription?._publish_pending_notifications();\n        if (!closed_subscription?.hasPendingNotifications) {\n            closed_subscription.dispose();\n            this._closed_subscriptions.shift();\n        }\n        return true;\n    }\n\n    private _send_error_for_request(publishData: PublishData, statusCode: StatusCode): void {\n        _assertValidPublishData(publishData);\n        const publishResponse = new PublishResponse({\n            responseHeader: { serviceResult: statusCode }\n        });\n        this._send_response_for_request(publishData, publishResponse);\n    }\n\n    private _cancelPendingPublishRequest(statusCode: StatusCode): void {\n        if (this._publish_request_queue) {\n            debugLog(\n                chalk.red(\"Cancelling pending PublishRequest with statusCode  \"),\n                statusCode.toString(),\n                \" length =\",\n                this._publish_request_queue.length\n            );\n        } else {\n            debugLog(chalk.red(\"No pending PublishRequest to cancel\"));\n        }\n\n        for (const publishData of this._publish_request_queue) {\n            this._send_error_for_request(publishData, statusCode);\n        }\n        this._publish_request_queue = [];\n    }\n\n    private _handle_too_many_requests() {\n        if (this.pendingPublishRequestCount > this.maxPublishRequestInQueue) {\n            traceLog(\n                \"server has received too many PublishRequest\",\n                this.pendingPublishRequestCount,\n                \"/\",\n                this.maxPublishRequestInQueue\n            );\n            assert(this.pendingPublishRequestCount === this.maxPublishRequestInQueue + 1);\n            // When a Server receives a new Publish request that exceeds its limit it shall de-queue the oldest Publish\n            // request and return a response with the result set to Bad_TooManyPublishRequests.\n\n            // dequeue oldest request\n            const publishData = this._publish_request_queue.shift()!;\n            this._send_error_for_request(publishData, StatusCodes.BadTooManyPublishRequests);\n        }\n    }\n\n    /**\n     * call by a subscription when no notification message is available after the keep alive delay has\n     * expired.\n     *\n     * @method send_keep_alive_response\n     * @param subscriptionId\n     * @param future_sequence_number\n     * @return true if a publish response has been sent\n     */\n    public send_keep_alive_response(subscriptionId: number, future_sequence_number: number): boolean {\n        //  this keep-alive Message informs the Client that the Subscription is still active.\n        //  Each keep-alive Message is a response to a Publish request in which the  notification Message\n        //  parameter does not contain any Notifications and that contains the sequence number of the next\n        //  Notification Message that is to be sent.\n\n        const subscription = this.getSubscriptionById(subscriptionId);\n        /* istanbul ignore next */\n        if (!subscription) {\n            traceLog(\"send_keep_alive_response  => invalid subscriptionId = \", subscriptionId);\n            return false;\n        }\n        // let check if we have available PublishRequest to send the keep alive\n        if (this.pendingPublishRequestCount === 0 || subscription.hasPendingNotifications) {\n            // we cannot send the keep alive PublishResponse\n            traceLog(\n                \"send_keep_alive_response  => cannot send keep-alive  (no PublishRequest left) subscriptionId = \",\n                subscriptionId\n            );\n            return false;\n        }\n        debugLog(\n            `Sending keep alive response for subscription id ${subscription.id} ${subscription.publishingInterval} ${subscription.maxKeepAliveCount}`\n        );\n        this._send_response(\n            subscription,\n            new PublishResponse({\n                availableSequenceNumbers: subscription.getAvailableSequenceNumbers(),\n                moreNotifications: false,\n                notificationMessage: {\n                    sequenceNumber: future_sequence_number\n                },\n                subscriptionId\n            })\n        );\n        return true;\n    }\n    public _send_response(subscription: Subscription, response: PublishResponse): void {\n        assert(this.pendingPublishRequestCount > 0);\n        assert(response.subscriptionId !== 0xffffff);\n        const publishData = this._publish_request_queue.shift()!;\n        this._send_response_for_request(publishData, response);\n    }\n\n    public _on_tick(): void {\n        this._cancelTimeoutRequests();\n    }\n\n    private _cancelTimeoutRequests(): void {\n        if (this._publish_request_queue.length === 0) {\n            return;\n        }\n\n        // filter out timeout requests\n        const parts = partition(this._publish_request_queue, timeout_filter);\n\n        this._publish_request_queue = parts[1]; // still valid\n\n        const invalid_published_request = parts[0];\n        for (const publishData of invalid_published_request) {\n            if (doDebug) {\n                debugLog(chalk.cyan(\" CANCELING TIMEOUT PUBLISH REQUEST \"));\n            }\n            this._send_error_for_request(publishData, StatusCodes.BadTimeout);\n        }\n    }\n\n    public _send_response_for_request(publishData: PublishData, response: PublishResponse): void {\n        if (doDebug) {\n            debugLog(\"_send_response_for_request \", response.toString());\n        }\n        _assertValidPublishData(publishData);\n        // xx assert(response.responseHeader.requestHandle !== 0,\"expecting a valid requestHandle\");\n        response.results = publishData.results;\n        response.responseHeader.requestHandle = publishData.request.requestHeader.requestHandle;\n        publishData.callback(publishData.request, response);\n    }\n}\n", "\"use strict\";\nconst should = require(\"should\");\nconst sinon = require(\"sinon\");\n\nconst { MonitoringMode, PublishRequest } = require(\"node-opcua-service-subscription\");\nconst { StatusCodes, StatusCode } = require(\"node-opcua-status-code\");\nconst { TimestampsToReturn } = require(\"node-opcua-service-read\");\nconst { MonitoredItemCreateRequest } = require(\"node-opcua-service-subscription\");\n\nconst { get_mini_nodeset_filename } = require(\"node-opcua-address-space/testHelpers\");\n\nconst { ServerEngine, SubscriptionState } = require(\"..\");\nconst { with_fake_timer } = require(\"./helper_with_fake_timer\");\n\nconst mini_nodeset_filename = get_mini_nodeset_filename();\n\n// eslint-disable-next-line import/order\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\ndescribe(\"ServerEngine Subscriptions service\", function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const test = this;\n\n    /**\n     * @type {ServerEngine}\n     */\n    let engine;\n    /**\n     * @type {ServerSession}\n     */\n    let session;\n    /**\n     * @type {NodeId}\n     */\n    let FolderTypeId, BaseDataVariableTypeId;\n\n    beforeEach(function (done) {\n        engine = new ServerEngine();\n        engine.initialize({ nodeset_filename: mini_nodeset_filename }, function () {\n            FolderTypeId = engine.addressSpace.findNode(\"FolderType\").nodeId;\n            BaseDataVariableTypeId = engine.addressSpace.findNode(\"BaseDataVariableType\").nodeId;\n            done();\n        });\n    });\n\n    afterEach(async () => {\n        session = null;\n        should.exist(engine);\n        await engine.shutdown();\n        engine = null;\n    });\n\n    it(\"should return an error when trying to delete an non-existing subscription\", async () => {\n        session = engine.createSession();\n        const statusCode = await session.deleteSubscription(-6789);\n        statusCode.should.eql(StatusCodes.BadSubscriptionIdInvalid);\n    });\n\n    it(\"should check the subscription live cycle\", async () => {\n        session = engine.createSession();\n        session.currentSubscriptionCount.should.equal(0);\n        session.cumulatedSubscriptionCount.should.equal(0);\n\n        const subscription = session.createSubscription({\n            requestedPublishingInterval: 1000, // Duration\n            requestedLifetimeCount: 10, // Counter\n            requestedMaxKeepAliveCount: 10, // Counter\n            maxNotificationsPerPublish: 10, // Counter\n            publishingEnabled: true, // Boolean\n            priority: 14 // Byte\n        });\n        subscription.monitoredItemCount.should.eql(0);\n\n        session.currentSubscriptionCount.should.equal(1);\n        session.cumulatedSubscriptionCount.should.equal(1);\n\n        session.getSubscription(subscription.id).should.equal(subscription);\n\n        const statusCode = await session.deleteSubscription(subscription.id);\n        statusCode.should.eql(StatusCodes.Good);\n\n        session.currentSubscriptionCount.should.equal(0);\n        session.cumulatedSubscriptionCount.should.equal(1);\n\n        engine.currentSubscriptionCount.should.equal(0);\n        engine.cumulatedSubscriptionCount.should.equal(1);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"XCX session should emit a new_subscription and subscription_terminated event\", async () => {\n        session = engine.createSession();\n\n        session.currentSubscriptionCount.should.equal(0);\n        session.cumulatedSubscriptionCount.should.equal(0);\n\n        const spyNew = sinon.spy();\n        const spyTerminated = sinon.spy();\n\n        session.on(\"new_subscription\", spyNew);\n        session.on(\"subscription_terminated\", spyTerminated);\n\n        const subscription = session.createSubscription({\n            requestedPublishingInterval: 1000, // Duration\n            requestedLifetimeCount: 10, // Counter\n            requestedMaxKeepAliveCount: 10, // Counter\n            maxNotificationsPerPublish: 10, // Counter\n            publishingEnabled: true, // Boolean\n            priority: 14 // Byte\n        });\n\n        session.currentSubscriptionCount.should.equal(1);\n        session.cumulatedSubscriptionCount.should.equal(1);\n\n        spyNew.callCount.should.eql(1);\n        spyTerminated.callCount.should.eql(0);\n\n        const statusCode = await session.deleteSubscription(subscription.id);\n        statusCode.should.be.instanceOf(StatusCode);\n\n        spyNew.callCount.should.eql(1);\n        spyTerminated.callCount.should.eql(1);\n\n        session.removeListener(\"new_subscription\", spyNew);\n        session.removeListener(\"subscription_terminated\", spyTerminated);\n\n        session.currentSubscriptionCount.should.equal(0);\n        session.cumulatedSubscriptionCount.should.equal(1);\n    });\n\n    it(\"should maintain the correct number of cumulatedSubscriptionCount at the engine level\", async () => {\n        session = engine.createSession();\n        const subscription_parameters = {\n            requestedPublishingInterval: 1000, // Duration\n            requestedLifetimeCount: 10, // Counter\n            requestedMaxKeepAliveCount: 10, // Counter\n            maxNotificationsPerPublish: 10, // Counter\n            publishingEnabled: true, // Boolean\n            priority: 14 // Byte\n        };\n\n        engine.currentSubscriptionCount.should.equal(0);\n        engine.cumulatedSubscriptionCount.should.equal(0);\n\n        engine.currentSessionCount.should.equal(1);\n        engine.cumulatedSessionCount.should.equal(1);\n\n        const subscription1 = session.createSubscription(subscription_parameters);\n\n        engine.currentSubscriptionCount.should.equal(1);\n        engine.cumulatedSubscriptionCount.should.equal(1);\n\n        const subscription2 = session.createSubscription(subscription_parameters);\n        engine.currentSubscriptionCount.should.equal(2);\n        engine.cumulatedSubscriptionCount.should.equal(2);\n\n        await session.deleteSubscription(subscription2.id);\n        engine.currentSubscriptionCount.should.equal(1);\n        engine.cumulatedSubscriptionCount.should.equal(2);\n\n        // Create a new session\n        const session2 = engine.createSession();\n        engine.currentSessionCount.should.equal(2);\n        engine.cumulatedSessionCount.should.equal(2);\n        engine.currentSubscriptionCount.should.equal(1);\n\n        const subscription1_2 = session2.createSubscription(subscription_parameters);\n        const subscription2_2 = session2.createSubscription(subscription_parameters);\n        const subscription3_2 = session2.createSubscription(subscription_parameters);\n\n        engine.currentSubscriptionCount.should.equal(4);\n        engine.cumulatedSubscriptionCount.should.equal(5);\n\n        // close the session, asking to delete subscriptions\n        await engine.closeSession(session2.authenticationToken, /* deleteSubscriptions */ true);\n\n        engine.currentSessionCount.should.equal(1);\n        engine.cumulatedSessionCount.should.equal(2);\n        engine.currentSubscriptionCount.should.equal(1);\n        engine.cumulatedSubscriptionCount.should.equal(5);\n\n        await session.deleteSubscription(subscription1.id);\n\n        engine.currentSubscriptionCount.should.equal(0);\n        engine.cumulatedSubscriptionCount.should.equal(5);\n    });\n\n    it(\"DDD delete a subscription with 2 outstanding PublishRequest\", async () => {\n        session = engine.createSession();\n\n        // CTT : deleteSub5106004\n        const subscription_parameters = {\n            requestedPublishingInterval: 1000, // Duration\n            requestedLifetimeCount: 10, // Counter\n            requestedMaxKeepAliveCount: 10, // Counter\n            maxNotificationsPerPublish: 10, // Counter\n            publishingEnabled: true, // Boolean\n            priority: 14 // Byte\n        };\n\n        const subscription1 = session.createSubscription(subscription_parameters);\n\n        const publishSpy = sinon.spy();\n        const o1 = { requestHeader: { requestHandle: 100 } };\n        session.publishEngine._on_PublishRequest(new PublishRequest(o1), publishSpy);\n        const o2 = { requestHeader: { requestHandle: 101 } };\n        session.publishEngine._on_PublishRequest(new PublishRequest(o2), publishSpy);\n\n        publishSpy.callCount.should.eql(0);\n\n        await session.deleteSubscription(subscription1.id);\n        // after subscription has been deleted, the 2 outstanding publish request shall\n        // be completed\n        publishSpy.callCount.should.eql(2);\n        //xx console.log(publishSpy.getCall(0).args[0].toString());\n        //xx console.log(publishSpy.getCall(0).args[1].toString());\n        publishSpy.getCall(0).args[1].responseHeader.requestHandle.should.eql(100);\n        publishSpy.getCall(1).args[1].responseHeader.requestHandle.should.eql(101);\n        publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n        publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n    });\n\n    it(\"ZDZ-1 create and terminate 2 subscriptions , with 4 publish requests\", async () => {\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({ sessionTimeout: 100000000 });\n\n            // CTT : deleteSub5106004\n            const subscription_parameters = {\n                requestedPublishingInterval: 1000, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 10, // Counter\n                maxNotificationsPerPublish: 10, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription1 = session.createSubscription(subscription_parameters);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription1.publishingInterval);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n            subscription1.messageSent.should.eql(false);\n\n            await session.deleteSubscription(subscription1.id);\n            subscription1.state.should.eql(SubscriptionState.CLOSED);\n\n            const subscription2 = session.createSubscription(subscription_parameters);\n            subscription2.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription2.publishingInterval * subscription2.maxKeepAliveCount);\n            subscription2.state.should.eql(SubscriptionState.LATE);\n\n            const publishSpy = sinon.spy();\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 100 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 101 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 102 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 103 } }), publishSpy);\n\n            test.clock.tick(subscription2.publishingInterval);\n            subscription2.state.should.eql(SubscriptionState.KEEPALIVE);\n\n            await session.deleteSubscription(subscription2.id);\n            subscription2.state.should.eql(SubscriptionState.CLOSED);\n\n            publishSpy.callCount.should.eql(4);\n\n            publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(0).args[1].subscriptionId.should.eql(subscription2.id);\n            publishSpy.getCall(0).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n\n            await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n        });\n    });\n\n    it(\"ZDZ-2 LifetimeCount, the publish engine shall send a StatusChangeNotification to inform that a subscription has been closed because of lifetime timeout - with 2 subscriptions\", async () => {\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({\n                sessionTimeout: 100000000\n            });\n\n            // CTT : deleteSub5106004\n            const subscription_parameters = {\n                requestedPublishingInterval: 1000, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 10, // Counter\n                maxNotificationsPerPublish: 10, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription1 = session.createSubscription(subscription_parameters);\n            //xx console.log(\"subscription1\", subscription1.subscriptionId);\n            subscription1.publishingInterval.should.eql(1000);\n            subscription1.maxKeepAliveCount.should.eql(10);\n            subscription1.lifeTimeCount.should.eql(60);\n\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription1.publishingInterval);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription1.publishingInterval * subscription1.maxKeepAliveCount);\n            subscription1.state.should.eql(SubscriptionState.LATE);\n\n            // wait until subscription expires entirely\n            test.clock.tick(\n                subscription1.publishingInterval * subscription1.maxKeepAliveCount\n            );\n            subscription1.state.should.eql(SubscriptionState.LATE);\n\n            test.clock.tick(subscription1.publishingInterval * subscription1.lifeTimeCount);\n            subscription1.state.should.eql(SubscriptionState.CLOSED);\n\n            const subscription2 = session.createSubscription(subscription_parameters);\n            //xx console.log(\"subscription2\", subscription2.subscriptionId);\n            subscription2.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription2.publishingInterval * subscription2.maxKeepAliveCount);\n            subscription2.state.should.eql(SubscriptionState.LATE);\n\n            const publishSpy = sinon.spy();\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 101 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 102 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 103 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 104 } }), publishSpy);\n\n            test.clock.tick(subscription2.publishingInterval); //  * subscription2.maxKeepAliveCount);\n\n            await session.deleteSubscription(subscription2.id);\n            test.clock.tick(subscription2.publishingInterval);\n\n            publishSpy.callCount.should.eql(4);\n            // console.log(publishSpy.getCall(0).args[1].toString());\n            // console.log(publishSpy.getCall(1).args[1].toString());\n            // console.log(publishSpy.getCall(2).args[1].toString());\n            // console.log(publishSpy.getCall(3).args[1].toString());\n\n            publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(0).args[1].subscriptionId.should.eql(subscription1.id);\n            publishSpy.getCall(0).args[1].notificationMessage.notificationData[0].status.should.eql(StatusCodes.BadTimeout);\n\n            publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(1).args[1].subscriptionId.should.eql(subscription2.id);\n            publishSpy.getCall(1).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            publishSpy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n\n            await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n        });\n    });\n\n    it(\"AZQ should receive StatusChangeNotification from first subscription even if publishRequest arrives late\", async () => {\n        // given a subscription with monitored Item\n        // given that the client doesn't send Publish Request\n        // When the subscription times out and closed\n        // And  When the client send a PublishRequest notification\n        // Then the client shall receive the StatusChangeNotification\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({ sessionTimeout: 100000000 });\n\n            // CTT : deleteSub5106004\n            const subscription_parameters = {\n                requestedPublishingInterval: 1000, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 10, // Counter\n                maxNotificationsPerPublish: 10, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription1 = session.createSubscription(subscription_parameters);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            // wait until session expired by being late\n            test.clock.tick(subscription1.publishingInterval * subscription1.maxKeepAliveCount);\n            test.clock.tick(subscription1.publishingInterval * subscription1.lifeTimeCount);\n\n            subscription1.state.should.eql(SubscriptionState.CLOSED);\n            subscription1.messageSent.should.eql(false);\n\n            const publishSpy = sinon.spy();\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 101 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 102 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 103 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 104 } }), publishSpy);\n\n            test.clock.tick(subscription1.publishingInterval * 2);\n\n            publishSpy.getCall(0).args[1].subscriptionId.should.eql(subscription1.subscriptionId);\n            publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(0).args[1].notificationMessage.sequenceNumber.should.eql(1);\n            publishSpy\n                .getCall(0)\n                .args[1].notificationMessage.notificationData[0].constructor.name.should.eql(\"StatusChangeNotification\");\n            publishSpy.getCall(0).args[1].notificationMessage.notificationData[0].status.should.eql(StatusCodes.BadTimeout);\n\n            publishSpy.callCount.should.eql(4);\n\n            publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(1).args[1].subscriptionId.should.eql(0xffffffff);\n            publishSpy.getCall(1).args[1].notificationMessage.sequenceNumber.should.eql(0);\n            publishSpy.getCall(1).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            publishSpy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(2).args[1].subscriptionId.should.eql(0xffffffff);\n            publishSpy.getCall(2).args[1].notificationMessage.sequenceNumber.should.eql(0);\n            publishSpy.getCall(2).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            publishSpy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(3).args[1].subscriptionId.should.eql(0xffffffff);\n            publishSpy.getCall(3).args[1].notificationMessage.sequenceNumber.should.eql(0);\n            publishSpy.getCall(3).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n        });\n    });\n\n    it(\"AZW1 should receive StatusChangeNotification from first subscription even if publishRequest arrives late\", async () => {\n        // given a subscription with monitored Item\n        // given that the client doesn't send Publish Request\n        // When the subscription times out and closed\n        // And  When the client send a PublishRequest notification\n        // Then the client shall receive the StatusChangeNotification\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({ sessionTimeout: 100000000 });\n\n            // CTT : deleteSub5106004\n            const subscription_parameters = {\n                requestedPublishingInterval: 1000, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 10, // Counter\n                maxNotificationsPerPublish: 10, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription1 = session.createSubscription(subscription_parameters);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            // wait until session expired by being late\n            test.clock.tick(subscription1.publishingInterval * subscription1.maxKeepAliveCount);\n\n            // wait until session expired by timeout\n            test.clock.tick(subscription1.publishingInterval * subscription1.lifeTimeCount);\n\n            const subscription2 = session.createSubscription(subscription_parameters);\n            subscription2.state.should.eql(SubscriptionState.CREATING);\n\n            const publishSpy = sinon.spy();\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 101 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 102 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 103 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 104 } }), publishSpy);\n\n            publishSpy.callCount.should.eql(1);\n            publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(0).args[1].notificationMessage.sequenceNumber.should.eql(1);\n            publishSpy\n                .getCall(0)\n                .args[1].notificationMessage.notificationData[0].constructor.name.should.eql(\"StatusChangeNotification\");\n            publishSpy.getCall(0).args[1].notificationMessage.notificationData[0].status.should.eql(StatusCodes.BadTimeout);\n\n            await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n        });\n    });\n\n    it(\"AZW2 should terminate a orphan subscription containing monitored items\", async () => {\n        // given a client session\n        // given a subscription with monitored Item\n        // given that the client close the session without deleting the subscription\n        // When the orphan subscription times out\n        // Then subscription shall be disposed\n\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({ sessionTimeout: 100000000 });\n\n            const subscription_parameters = {\n                requestedPublishingInterval: 100, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 30, // Counter\n                maxNotificationsPerPublish: 1000, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription = session.createSubscription(subscription_parameters);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            subscription.on(\"monitoredItem\", function (monitoredItem) {\n                monitoredItem.samplingFunc = function () {\n                    /** */\n                };\n            });\n\n            const monitoredItemCreateRequest = new MonitoredItemCreateRequest({\n                itemToMonitor: { nodeId: \"ns=0;i=2258\" },\n                monitoringMode: MonitoringMode.Reporting,\n                requestedParameters: {\n                    clientHandle: 123,\n                    queueSize: 10,\n                    samplingInterval: 100\n                }\n            });\n\n            const createResult = subscription.createMonitoredItem(\n                engine.addressSpace,\n                TimestampsToReturn.Both,\n                monitoredItemCreateRequest\n            );\n            createResult.statusCode.should.eql(StatusCodes.Good);\n\n            const deleteSubscriptions = false;\n            engine.closeSession(session.authenticationToken, deleteSubscriptions, \"CloseSession\");\n\n            // wait until session expired by being late\n            test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n            // wait until subscription expired by timeout\n            test.clock.tick(subscription.publishingInterval * subscription.lifeTimeCount);\n        });\n    });\n});\n", "/* eslint-disable import/order */\n/**\n *\n *  OPCUA protocol defines a long-pooling mechanism for sending server-triggered events back to the client.\n *  Therefore the Publish service behalves slightly differently from other OPCUA services:\n *    - the client will send Publish requests to the server without expecting an immediate answer from the server.\n *    - The server will block the request until some subscriptions have some available data, or a time out\n *\n *\n *    - the Publish Request message is also used by the client to acknowledge processing of notification messages\n *\n *\n *    A good algorithm for a client is to send more publish request than live subscription.\n *\n *   - Publish Request are not tied to a particular subscription, the Server will use the oldest pending\n *     client Publish request to send some notification regarding the notifying subscription.\n *\n * preventing queue overflow\n * -------------------------\n *  - if the client send too many publish requests that the server can queue, the server may return a Service result\n *    of BadTooManyPublishRequests.\n *\n * Keep alive mechanism:\n * ---------------------\n *    Publish Request/Response are also use as a keep alive signal between the server and the client.\n *    Every publish request  is a live ping from the client to the server.\n *    Every publish response is a live ping from the server to the client.\n *\n *    If no notification are available after the keep-alive timeout interval, the server shall return an empty\n *    PublishResponse and therefore notifies the client about a valid connection.\n *    Similarly, the client shall send Publish Request\n *\n *\n */\n\nimport * as sinon from \"sinon\";\nimport * as should from \"should\";\nimport { property } from \"underscore\";\n\nimport { PublishRequest } from \"node-opcua-service-subscription\";\nimport { StatusCodes } from \"node-opcua-status-code\";\nimport { ServerSidePublishEngine, Subscription, SubscriptionState } from \"..\";\n\n// tslint:disable-next-line: no-var-requires\nconst { add_mock_monitored_item } = require(\"./helper\");\n\n// tslint:disable-next-line: no-var-requires\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\ndescribe(\"Testing the server publish engine\", function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const test = this;\n\n    beforeEach(() => {\n        test.clock = sinon.useFakeTimers();\n    });\n\n    afterEach(() => {\n        test.clock.restore();\n    });\n    function flushPending() {\n        test.clock.tick(0);\n    }\n    it(\"ZDZ-3 a server should send keep alive notifications\", () => {\n        function pulse(nbInterval: number) {\n            for (let i = 0; i < nbInterval; i++) {\n                test.clock.tick(subscription.publishingInterval);\n            }\n        }\n\n        const publish_server = new ServerSidePublishEngine({});\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10, maxMonitoredItemsPerSubscription: 10 }\n        });\n\n        publish_server.add_subscription(subscription);\n        subscription.state.should.equal(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        subscription.state.should.equal(SubscriptionState.LATE);\n\n        // client sends a PublishRequest to the server\n        const fakeRequest1 = new PublishRequest({ subscriptionAcknowledgements: [] });\n        publish_server._on_PublishRequest(fakeRequest1);\n        flushPending();\n\n        // publish request should be consumed immediately as subscription is late.\n        publish_server.pendingPublishRequestCount.should.equal(0);\n        subscription.state.should.equal(SubscriptionState.KEEPALIVE);\n\n        const fakeRequest2 = new PublishRequest({ subscriptionAcknowledgements: [] });\n        publish_server._on_PublishRequest(fakeRequest2);\n        flushPending();\n\n        publish_server.pendingPublishRequestCount.should.equal(1);\n\n        pulse(19);\n        publish_server.pendingPublishRequestCount.should.equal(1);\n        subscription.state.should.equal(SubscriptionState.KEEPALIVE);\n\n        pulse(5);\n        publish_server.pendingPublishRequestCount.should.equal(0);\n        subscription.state.should.equal(SubscriptionState.KEEPALIVE);\n\n        pulse(20);\n        publish_server.pendingPublishRequestCount.should.equal(0);\n        subscription.state.should.equal(SubscriptionState.LATE);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-4 a server should feed the availableSequenceNumbers in PublishResponse with sequence numbers that have not been acknowledged by the client\", () => {\n        const serverSidePublishEngine = new ServerSidePublishEngine({});\n        const send_response_for_request_spy = sinon.spy(serverSidePublishEngine, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: serverSidePublishEngine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        serverSidePublishEngine.add_subscription(subscription);\n        subscription.state.should.equal(SubscriptionState.CREATING);\n        send_response_for_request_spy.callCount.should.equal(0);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // client sends a PublishRequest to the server\n        const fakeRequest1 = new PublishRequest({ subscriptionAcknowledgements: [] });\n        serverSidePublishEngine._on_PublishRequest(fakeRequest1);\n\n        test.clock.tick(subscription.publishingInterval);\n        send_response_for_request_spy.callCount.should.equal(1); // initial still\n\n        test.clock.tick(subscription.publishingInterval * 1.2);\n\n        // server should send a response for the first publish request with the above notification\n        // in this response, there should be  one element in the availableSequenceNumbers.\n        send_response_for_request_spy.callCount.should.equal(1);\n\n        // console.log( send_response_for_request_spy.getCall(0).args[1].toString());\n\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].subscriptionId.should.eql(1234);\n        send_response_for_request_spy.getCall(0).args[1].availableSequenceNumbers!.should.eql([1]);\n\n        // client sends a PublishRequest to the server ( with no acknowledgement)\n        const fakeRequest2 = new PublishRequest({ subscriptionAcknowledgements: [] });\n        serverSidePublishEngine._on_PublishRequest(fakeRequest2);\n        flushPending();\n\n        // server has now some notification ready and send them to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        send_response_for_request_spy.callCount.should.equal(1);\n\n        test.clock.tick(subscription.publishingInterval);\n\n        // server should send an response for the second publish request with a notification\n        send_response_for_request_spy.callCount.should.equal(2);\n        send_response_for_request_spy.getCall(1).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(1).args[1].subscriptionId.should.eql(1234);\n        send_response_for_request_spy.getCall(1).args[1].availableSequenceNumbers!.should.eql([1, 2]);\n\n        // send_response_for_request_spy.\n        subscription.terminate();\n        subscription.dispose();\n        serverSidePublishEngine.shutdown();\n        serverSidePublishEngine.dispose();\n    });\n\n    it(\"ZDZ-5 a server should return BadNoSubscription as a response for a publish Request if there is no subscription available for this session. \", () => {\n        // create a server - server has no subscription\n        const publish_server = new ServerSidePublishEngine();\n\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        // client sends a PublishRequest to the server\n        const fakeRequest1 = new PublishRequest({\n            subscriptionAcknowledgements: []\n        });\n        publish_server._on_PublishRequest(fakeRequest1);\n        flushPending();\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-6 should be possible to find a subscription by id on a publish_server\", () => {\n        const publish_server = new ServerSidePublishEngine({});\n        publish_server.subscriptionCount.should.equal(0);\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000, // 1 second\n            lifeTimeCount: 100,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        publish_server.subscriptionCount.should.equal(1);\n        publish_server.getSubscriptionById(1234).should.equal(subscription);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.subscriptionCount.should.equal(0);\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-7 should be possible to remove a subscription from a publish_server\", () => {\n        const publish_server = new ServerSidePublishEngine({});\n        publish_server.subscriptionCount.should.equal(0);\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        publish_server.subscriptionCount.should.equal(1);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.subscriptionCount.should.equal(0);\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-8 when the client send too many publish requests that the server can queue, the server returns a Service result of BadTooManyPublishRequests\", () => {\n        // When a Server receives a new Publish request that exceeds its limit it shall de-queue the oldest Publish\n        // request and return a response with the result set to Bad_TooManyPublishRequests.\n\n        const publish_server = new ServerSidePublishEngine({\n            maxPublishRequestInQueue: 5\n        });\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1,\n            publishingInterval: 10000,\n            maxKeepAliveCount: 500,\n            lifeTimeCount: 2000,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n\n        // simulate client sending PublishRequest ,and server doing nothing\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 1 } }));\n        flushPending();\n\n        test.clock.tick(subscription.publishingInterval);\n        send_response_for_request_spy.callCount.should.be.equal(0);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount - 1));\n        send_response_for_request_spy.callCount.should.be.equal(1);\n\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.requestHandle.should.eql(1);\n        send_response_for_request_spy.getCall(0).args[1].results!.should.eql([]);\n\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 2 } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 3 } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 4 } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 5 } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 6 } }));\n        flushPending();\n\n        // en: the straw that broke the camel's back.\n        // cSpell:disable\n        // fr: la goute qui fait d\u00e9border le vase.\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 7 } }));\n        flushPending();\n\n        send_response_for_request_spy.callCount.should.be.equal(2);\n\n        // xx console.log(send_response_for_request_spy.getCall(0).args[1].responseHeader.toString());\n        // xx console.log(send_response_for_request_spy.getCall(1).args[1].responseHeader.toString());\n\n        send_response_for_request_spy.getCall(1).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy\n            .getCall(1)\n            .args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTooManyPublishRequests);\n        send_response_for_request_spy.getCall(1).args[1].responseHeader.requestHandle.should.eql(2);\n        send_response_for_request_spy.getCall(1).args[1].results!.should.eql([]);\n\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 8 } }));\n        flushPending();\n\n        send_response_for_request_spy.callCount.should.be.equal(3);\n        // xx console.log(send_response_for_request_spy.getCall(2).args[1].responseHeader.toString());\n        send_response_for_request_spy.getCall(2).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy\n            .getCall(2)\n            .args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTooManyPublishRequests);\n        send_response_for_request_spy.getCall(2).args[1].responseHeader.requestHandle.should.eql(3);\n        send_response_for_request_spy.getCall(2).args[1].results!.should.eql([]);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    // eslint-disable-next-line max-statements\n    it(\"ZDZ-9 the server shall process the client acknowledge sequence number\", () => {\n        const publish_server = new ServerSidePublishEngine();\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // --------------------------------\n        publish_server._on_PublishRequest(new PublishRequest());\n        flushPending();\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n\n        subscription.getAvailableSequenceNumbers().should.eql([1]);\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(0).args[1].results!.should.eql([]);\n\n        // --------------------------------\n        publish_server._on_PublishRequest(new PublishRequest());\n        flushPending();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n\n        subscription.getAvailableSequenceNumbers().should.eql([1, 2]);\n\n        send_response_for_request_spy.callCount.should.equal(2);\n        send_response_for_request_spy.getCall(1).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(1).args[1].results!.should.eql([]);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        flushPending();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.getAvailableSequenceNumbers().should.eql([1, 2, 3]);\n\n        send_response_for_request_spy.callCount.should.equal(3);\n        send_response_for_request_spy.getCall(2).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(2).args[1].results!.should.eql([]);\n\n        publish_server._on_PublishRequest(\n            new PublishRequest({\n                subscriptionAcknowledgements: [{ subscriptionId: 1234, sequenceNumber: 2 }]\n            })\n        );\n        flushPending();\n\n        subscription.getAvailableSequenceNumbers().should.eql([1, 3, 4]);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        send_response_for_request_spy.callCount.should.equal(4);\n        send_response_for_request_spy.getCall(3).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(3).args[1].results!.should.eql([StatusCodes.Good]);\n\n        publish_server._on_PublishRequest(\n            new PublishRequest({\n                subscriptionAcknowledgements: [\n                    { subscriptionId: 1234, sequenceNumber: 1 },\n                    { subscriptionId: 1234, sequenceNumber: 3 }\n                ]\n            })\n        );\n        flushPending();\n\n        subscription.getAvailableSequenceNumbers().should.eql([4, 5]);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n\n        send_response_for_request_spy.callCount.should.equal(5);\n        send_response_for_request_spy.getCall(4).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(4).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(4).args[1].results!.should.eql([StatusCodes.Good, StatusCodes.Good]);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-A the server shall return BadSequenceNumberInvalid if the client attempts to acknowledge a notification that is not in the queue\", () => {\n        const publishServer = new ServerSidePublishEngine();\n        const send_response_for_request_spy = sinon.spy(publishServer, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publishServer,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publishServer.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // simulate a client sending a PublishRequest to the server\n        // that acknowledge on a wrong sequenceNumber\n        publishServer._on_PublishRequest(\n            new PublishRequest({\n                subscriptionAcknowledgements: [\n                    {\n                        subscriptionId: 1234,\n                        sequenceNumber: 36 // <<< INVALID SEQUENCE NUMBER\n                    }\n                ]\n            })\n        );\n        flushPending();\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval * 1.2);\n\n        subscription.getAvailableSequenceNumbers().should.eql([1]);\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(0).args[1].results!.should.eql([StatusCodes.BadSequenceNumberUnknown]);\n\n        subscription.terminate();\n        subscription.dispose();\n        publishServer.shutdown();\n        publishServer.dispose();\n    });\n\n    it(\"ZDZ-B     a subscription shall send a keep-alive message at the end of the first publishing interval, if there are no Notifications ready.\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const send_keep_alive_response_spy = sinon.spy(publish_server, \"send_keep_alive_response\");\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 4,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n\n        // make sure we have at least 5 PublishRequest in queue\n        publish_server.maxPublishRequestInQueue.should.be.greaterThan(5);\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n\n        // Immediately  a keep Alive message shall be send\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n        subscription.publishIntervalCount.should.eql(subscription.maxKeepAliveCount);\n        send_keep_alive_response_spy.callCount.should.equal(1);\n        send_response_for_request_spy.callCount.should.eql(1);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.publishIntervalCount.should.eql(subscription.maxKeepAliveCount+1);\n        send_keep_alive_response_spy.callCount.should.equal(1);\n        send_response_for_request_spy.callCount.should.eql(1);\n\n        // after maxKeepAliveCount * publishingCycle a second keep Alive message shall be send\n        test.clock.tick(subscription.publishingInterval * 20);\n\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n        subscription.publishIntervalCount.should.eql(subscription.maxKeepAliveCount*2+1);\n        send_keep_alive_response_spy.callCount.should.equal(2);\n        send_response_for_request_spy.callCount.should.eql(2);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-C a Normal subscription that receives a notification shall wait for the next publish interval to send a PublishResponse \", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const send_keep_alive_response_spy = sinon.spy(publish_server, \"send_keep_alive_response\");\n        const send_notification_message_spy = sinon.spy(publish_server, \"_send_response\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 4,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            maxNotificationsPerPublish: 0, // no limits,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // make sure we have at least 5 PublishRequest in queue\n        publish_server.maxPublishRequestInQueue.should.be.greaterThan(5);\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n\n        test.clock.tick(2);\n        publish_server.pendingPublishRequestCount.should.eql(4);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n        subscription.publishIntervalCount.should.eql(1);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.publishIntervalCount.should.eql(2);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        send_keep_alive_response_spy.callCount.should.eql(0);\n        send_notification_message_spy.callCount.should.eql(1);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-D the subscription state shall be set to LATE, if it cannot process a notification after Publish Interval has been raised, due to a lack of PublishRequest\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        publish_server.maxPublishRequestInQueue.should.be.greaterThan(5);\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.equal(SubscriptionState.LATE);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval * 1.2);\n\n        subscription.state.should.equal(SubscriptionState.LATE);\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-E a subscription should provide its time to expiration so that publish engine could sort late subscriptions by order of priority\", () => {\n        const publish_server = new ServerSidePublishEngine();\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 2,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        subscription.lifeTimeCount.should.eql(60);\n        subscription.timeToExpiration.should.eql(1000 * 60);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.timeToExpiration.should.eql(1000 * 60);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.timeToExpiration.should.eql(1000 * 59);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.timeToExpiration.should.eql(1000 * 58);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    // eslint-disable-next-line max-statements\n    it(\"ZDZ-F a publish engine should be able to find out which are the most urgent late subscriptions to serve \", () => {\n        const publish_server = new ServerSidePublishEngine();\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        const subscription1 = new Subscription({\n            id: 1,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 20,\n            publishingEnabled: true,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription1.publishingInterval.should.eql(1000);\n        subscription1.lifeTimeCount.should.eql(60);\n        subscription1.maxKeepAliveCount.should.eql(20);\n\n        publish_server.add_subscription(subscription1);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n\n        const subscription2 = new Subscription({\n            id: 2,\n            publishingInterval: 100,\n            lifeTimeCount: 120,\n            maxKeepAliveCount: 20,\n            publishingEnabled: true,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription2.publishingInterval.should.eql(100);\n        subscription2.lifeTimeCount.should.eql(120);\n        subscription2.maxKeepAliveCount.should.eql(20);\n        publish_server.add_subscription(subscription2);\n\n        const subscription3 = new Subscription({\n            id: 3,\n            publishingInterval: 100,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            publishingEnabled: true,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription3.publishingInterval.should.eql(100); // !! Note that publishingInterval has been clamped in constructor\n        subscription3.lifeTimeCount.should.eql(1000);\n        subscription3.maxKeepAliveCount.should.eql(20);\n\n        publish_server.add_subscription(subscription3);\n\n        const monitoredItem1 = add_mock_monitored_item(subscription1);\n        const monitoredItem2 = add_mock_monitored_item(subscription2);\n        const monitoredItem3 = add_mock_monitored_item(subscription3);\n\n        subscription1.lifeTimeCount.should.eql(60);\n        subscription2.lifeTimeCount.should.eql(120);\n        subscription3.lifeTimeCount.should.eql(1000);\n\n        subscription1.timeToExpiration.should.eql(1000 * 60  );\n        subscription2.timeToExpiration.should.eql(100  * 120 );\n        subscription3.timeToExpiration.should.eql(100  * 1000);\n\n        // add some notification we want to process\n        monitoredItem1.simulateMonitoredItemAddingNotification();\n        monitoredItem2.simulateMonitoredItemAddingNotification();\n        monitoredItem3.simulateMonitoredItemAddingNotification();\n\n        // let move in time so that subscriptions starts\n        test.clock.tick(\n            Math.max(subscription1.publishingInterval, subscription2.publishingInterval, subscription3.publishingInterval)\n        );\n\n        subscription1.state.should.eql(SubscriptionState.NORMAL);\n        subscription2.state.should.eql(SubscriptionState.NORMAL);\n        subscription3.state.should.eql(SubscriptionState.NORMAL);\n\n        publish_server.findLateSubscriptionsSortedByAge().should.eql([]);\n\n        // let move in time so that all subscriptions get late (without expiring)\n        test.clock.tick(\n            Math.min(subscription1.timeToExpiration, subscription2.timeToExpiration, subscription3.timeToExpiration) - 10\n        );\n       \n        subscription1.state.should.eql(SubscriptionState.NORMAL);\n        subscription2.state.should.eql(SubscriptionState.LATE);\n        subscription3.state.should.eql(SubscriptionState.LATE);\n\n        publish_server.findLateSubscriptionsSortedByAge().map(property(\"id\")).should.eql([2, 3]);\n\n        test.clock.tick(1000 * 20);\n        subscription1.state.should.eql(SubscriptionState.LATE);\n        subscription2.state.should.eql(SubscriptionState.CLOSED);\n        subscription3.state.should.eql(SubscriptionState.LATE);\n\n        publish_server.findLateSubscriptionsSortedByAge().map(property(\"id\")).should.eql([1, 3]);\n\n        subscription1.terminate();\n        subscription1.dispose();\n\n        subscription2.terminate();\n        subscription2.dispose();\n\n        subscription3.terminate();\n        subscription3.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-G a LATE subscription that receives a notification shall send a PublishResponse immediately, without waiting for next publish interval\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.equal(SubscriptionState.LATE);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval * 1.2);\n\n        subscription.state.should.equal(SubscriptionState.LATE);\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        test.clock.tick(0);\n\n        publish_server.pendingPublishRequestCount.should.eql(\n            0,\n            \"starving subscription should have consumed this Request immediately\"\n        );\n\n        subscription.state.should.equal(SubscriptionState.NORMAL);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-H LifetimeCount, the server shall terminated the subscription if it has not received any PublishRequest after LifeTimeCount cycles\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        // given a subscription\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 0,\n            maxKeepAliveCount: 4,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.maxKeepAliveCount.should.eql(4);\n        subscription.lifeTimeCount.should.eql(12); // should be adjusted\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        test.clock.tick(subscription.publishingInterval);\n        subscription.publishIntervalCount.should.eql(1);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        subscription.publishIntervalCount.should.eql(1 + subscription.maxKeepAliveCount);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.publishIntervalCount.should.eql(6);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        test.clock.tick(subscription.publishingInterval * subscription.lifeTimeCount + 20);\n        subscription.publishIntervalCount.should.eql(subscription.lifeTimeCount + 6);\n        subscription.state.should.eql(SubscriptionState.CLOSED);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-I LifeTimeCount, the publish engine shall send a StatusChangeNotification to inform that a subscription has been closed because of lifetime timeout \", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        test.clock.tick(subscription.publishingInterval * subscription.lifeTimeCount + 20);\n        subscription.state.should.eql(SubscriptionState.CLOSED);\n\n        publish_server.pendingClosedSubscriptionCount.should.eql(1);\n\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        // now send a late PublishRequest\n        publish_server._on_PublishRequest(new PublishRequest());\n\n        // we expect this publish request to be immediately consumed\n        publish_server.pendingPublishRequestCount.should.eql(0);\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        send_response_for_request_spy.firstCall.args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.firstCall.args[1].subscriptionId.should.eql(1234);\n        send_response_for_request_spy.firstCall.args[1].notificationMessage.notificationData!.length.should.eql(1);\n        (send_response_for_request_spy.firstCall.args[1].notificationMessage.notificationData![0]! as any).status.should.eql(\n            StatusCodes.BadTimeout\n        );\n\n        subscription.state.should.eql(SubscriptionState.CLOSED);\n\n        publish_server.pendingClosedSubscriptionCount.should.eql(0);\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-J PublishRequest timeout, the publish engine shall return a publish response with serviceResult = BadTimeout when Publish requests have timed out\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 4,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.lifeTimeCount.should.eql(60);\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.publishingInterval.should.eql(1000);\n\n        publish_server.add_subscription(subscription);\n\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.lifeTimeCount.should.eql(60);\n        subscription.state.should.eql(SubscriptionState.CREATING);\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        const timeoutHint = subscription.publishingInterval * (subscription.maxKeepAliveCount + 2);\n\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server.pendingPublishRequestCount.should.eql(5);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        publish_server.pendingPublishRequestCount.should.eql(4); // one should have been consumed by subscription\n\n        test.clock.tick(subscription.publishingInterval);\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        publish_server.pendingPublishRequestCount.should.eql(4);\n        send_response_for_request_spy.firstCall.args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n\n        test.clock.tick(subscription.publishingInterval * 3);\n        // all remaining 4 publish request must have been detected a timeout now and answered as such.\n        send_response_for_request_spy.callCount.should.equal(5);\n        publish_server.pendingPublishRequestCount.should.eql(1);\n        send_response_for_request_spy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTimeout);\n        send_response_for_request_spy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTimeout);\n        send_response_for_request_spy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTimeout);\n        send_response_for_request_spy.getCall(4).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTimeout);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n});\n", "const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\");\nconst readline = require(\"readline\");\nconst os = require(\"os\");\nconst util = require(\"util\");\nconst { assert } = require(\"console\");\n\nconst CPU = process.env.CPU ? parseInt(process.env.CPU, 10) : 0;\n\nconst testWatchDogTimeout = process.env.PING ? parseInt(process.env.PING) : 10 * 60 * 1000;\n\nrequire(\"should\");\n\nconst chalk = require(\"chalk\");\n\nconst Mocha = require(\"mocha\");\nconst yargs = require(\"yargs\");\nconst { Argv } = require(\"yargs\");\n\nfunction durationToString(milliseconds) {\n    const seconds = Math.floor(milliseconds / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 3600);\n    const days = Math.floor(hours / 24);\n    const a = (n) => n.toString().padStart(2, \"0\");\n    const b = (n) => n.toString().padStart(3, \"0\");\n    return `${a(minutes % 60)}:${a(seconds % 60)}.${b(milliseconds % 1000)}`;\n}\n\nconst { extractAllTestFiles, extractPageTest } = require(\"./run_all_mocha_tests.js\");\n\nconst colorWheel = [\n    chalk.red,\n    chalk.green,\n    chalk.yellow,\n    chalk.blue,\n    chalk.magenta,\n    chalk.cyan,\n    chalk.white,\n    chalk.gray,\n    chalk.bgRed,\n    chalk.bgGreen,\n    chalk.bgYellow,\n    chalk.bgBlue,\n    chalk.bgMagenta,\n    chalk.bgCyan,\n    chalk.bgGray\n];\nconst pageCount = 1;\nconst pageSize = 1;\n\nconst TEST_FILE_STARTED = \"TEST_FILE_STARTED\";\nconst TEST_FILE_COMPLETED = \"TEST_FILE_COMPLETED\";\nconst TEST_FILE_COMPILATION_ERROR = \"TEST_FILE_COMPILATION_ERROR\";\nconst runningPages = new Set();\n\nconst failingTestFilename = [];\nconst failingTests = {};\nconst outputFor = {};\n\nconst durationsPerTestFile = {};\nlet testFiles = [];\n\nlet testCounter = 0;\nlet fileStarted = 0;\nlet fileCounter = 0;\nlet fileMax = 0;\nfunction collectDuration(test) {\n    testCounter++;\n    const { file } = test;\n    if (!durationsPerTestFile[file]) {\n        durationsPerTestFile[file] = test.duration || 0;\n    }\n    durationsPerTestFile[file] = durationsPerTestFile[file] + test.duration;\n}\n\nasync function runTest({ page, selectedTests, g }) {\n    function w(n, w) {\n        return n.toString().padStart(w, \" \");\n    }\n    function prefix() {\n        const a = [...runningPages].join(\", \").padEnd(40);\n        // const prefix = colorWheel[page % colorWheel.length](\"page \", page.toString().padEnd(4) + a);\n        const prefix = colorWheel[page % colorWheel.length](\n            `${w(fileCounter, 3)}+${w(fileStarted - fileCounter, 2)}/${w(fileMax, 3)} ${w(testCounter, 4)} -  ${w(\n                Math.ceil((fileCounter / fileMax) * 100),\n                3\n            )}% `\n        );\n        return prefix;\n    }\n    const result = new Promise((resolve, reject) => {\n        runningPages.add(page);\n        const worker = new Worker(__filename /*new URL(import.meta.url)*/, {\n            workerData: { page, selectedTests, g },\n            env: {\n                ...process.env\n            }\n        });\n        worker.on(\"message\", (message) => {\n            const { type, file, test, line } = message;\n            // args && console.log(prefix(), ...args);\n            switch (type) {\n                case \"LOG\":\n                    assert(typeof line === \"string\");\n                    outputFor[file].push(line); //util.format.apply(args));\n                    break;\n                case TEST_FILE_STARTED:\n                    outputFor[file] = outputFor[file] || [];\n                    fileStarted++;\n                    break;\n                case TEST_FILE_COMPLETED:\n                    fileCounter++;\n                    outputFor[file] = [];\n                    break;\n                case TEST_FILE_COMPILATION_ERROR:\n                    break;\n                case EVENT_TEST_BEGIN:\n                    break;\n                case EVENT_TEST_SKIPPED:\n                    collectDuration(test);\n                    break;\n                case EVENT_TEST_FAIL:\n                    {\n                        collectDuration(test);\n                        const { duration, title, file, error, timedOut, state, stats, output, titlePath } = test;\n                        failingTestFilename.push(file.replace(__dirname, \"\"));\n                        failingTests[file] = titlePath;\n\n                        const d = durationToString(duration);\n\n                        console.log(prefix(), d, chalk.red(title)); // JSON.stringify(test, null, \"\"));\n                        console.log(prefix(), file);\n                        console.log(error);\n\n                        console.log(\"-----------------------------------------------------------------------------\");\n                        if (outputFor[file])\n                            for (const l of outputFor[file]) {\n                                console.log(prefix(), chalk.grey(l));\n                            }\n                        console.log(\"-----------------------------------------------------------------------------\");\n                        for (const l of output) {\n                            for (const ll of l.split(\"\\n\")) {\n                                console.log(prefix(), chalk.redBright(ll));\n                            }\n                        }\n                        console.log(\"-----------------------------------------------------------------------------\");\n                        epilogue();\n                        process.exit(1);\n                    }\n                    break;\n                case EVENT_TEST_PASS:\n                    {\n                        collectDuration(test);\n                        const { duration, title, file, error, timedOut, state, stats } = test;\n\n                        if (false && outputFor[file])\n                            for (const l of outputFor[file]) {\n                                console.log(prefix(), chalk.grey(l));\n                            }\n\n                        const d = durationToString(duration);\n                        console.log(prefix(), d, chalk.green(title)); // JSON.stringify(test, null, \"\"));\n                    }\n                    break;\n            }\n        });\n\n        worker.on(\"error\", reject);\n        worker.on(\"exit\", (code) => {\n            runningPages.delete(page);\n            if (code !== 0) reject(new Error(`Worker ${page} stopped with exit code ${code}`));\n            resolve();\n        });\n    });\n\n    return result;\n}\n\nconst {\n    EVENT_RUN_BEGIN,\n    EVENT_RUN_END,\n    EVENT_TEST_BEGIN,\n    EVENT_TEST_FAIL,\n    EVENT_TEST_PASS,\n    EVENT_SUITE_BEGIN,\n    EVENT_SUITE_END,\n    EVENT_TEST_SKIPPED\n} = Mocha.Runner.constants;\n\nasync function runTestAndContinue(data) {\n    if (data.index >= data.testFiles.length) {\n        return;\n    }\n    try {\n        const page = data.index++;\n        const g = data.g;\n        const selectedTests = await extractPageTest(data.testFiles, { page, pageSize: 1, pageCount: 1 });\n        if (selectedTests.length === 0) {\n            data.pageCount = data.index;\n            return;\n        }\n        await runTest({ page, selectedTests, g });\n    } catch (err) {\n        // stop now\n        data.pageCount = data.index;\n        console.error(err);\n        return;\n    }\n    await runTestAndContinue(data);\n}\n\nconst t1 = Date.now();\nfunction epilogue() {\n    const t2 = Date.now();\n    console.log(\"Duration     : \", durationToString(t2 - t1));\n    console.log(\"test count   : \", testCounter);\n    console.log(\"Failing tests: \", failingTestFilename.length);\n    console.log(failingTestFilename.join(\"\\n\"));\n    for (const [key, value] of Object.entries(failingTests)) {\n        console.log(key);\n        console.log(value);\n    }\n\n    const testByDuration = [...Object.entries(durationsPerTestFile)].sort(\n        ([file1, duration1], [file2, duration2]) => duration2 - duration1\n    );\n    console.log(\"Longest tests:\");\n    console.log(\n        testByDuration\n            .slice(0, 30)\n            .map(([file, duration]) => `${durationToString(duration)}: ${file}`)\n            .join(\"\\n\")\n    );\n    console.log(\"-------------------------------------------------------------------------------\");\n    const runningTests = [...runningPages].map((i) => testFiles[i]);\n    console.log(`running tests: ${runningTests.length}`);\n    console.log(runningTests.join(\"\\n\"));\n}\n\nfunction dumpRunningTests() {\n    const runningTests = [...runningPages].map((i) => testFiles[i]);\n    console.log(`running tests: ${runningTests.length}`);\n    console.log(runningTests.join(\"\\n\"));\n}\n\nif (isMainThread) {\n    const argv = yargs\n        .option(\"fileFilter\", {\n            describe: \"file filter\",\n            default: null,\n            alias: \"f\"\n        })\n        .option(\"testFilter\", {\n            alias: \"t\",\n            default: null\n        })\n        .options(\"verbose\", {\n            alias: \"v\",\n            default: false\n        }).argv;\n\n    if (argv.verbose) {\n        console.info(\"Verbose mode on.\");\n    }\n    (async () => {\n        testFiles = await extractAllTestFiles();\n\n        if (argv.fileFilter) {\n            console.log(\"applying filter\", argv.fileFilter);\n            const f = new RegExp(argv.fileFilter);\n            testFiles = testFiles.filter((file) => file.match(f));\n            console.log(\"filtered test files\", testFiles.length);\n        }\n        if (process.stdin && process.stdin.setRawMode) {\n            const rl = readline.createInterface({\n                input: process.stdin,\n                output: process.stdout\n            });\n\n            rl.prompt(true);\n\n            rl.setPrompt(`\n              \n                help:\n                -----\n            \n                CTRL+C : gracefully shutdown the client    \n                l      : list running tests\n            \n                press a key to continue:\n            \n            `);\n\n            readline.emitKeypressEvents(process.stdin, rl);\n            process.stdin.setRawMode(true);\n            process.stdin.on(\"keypress\", async (str, key) => {\n                console.log(`You pressed the \"${str}\" key`);\n\n                if (key.ctrl && key.name === \"C\") {\n                    process.exit(0);\n                }\n                if (key.name === \"l\") {\n                    dumpRunningTests();\n                }\n            });\n        }\n\n        const data = {\n            index: 0,\n            pageCount: 200,\n            testFiles,\n            g: argv.testFilter\n        };\n\n        const infoTimer = setInterval(() => {\n            console.log(\"----------------------------------------------- RUNNING TESTS \");\n            dumpRunningTests();\n            const runningTests = [...runningPages].map((i) => testFiles[i]);\n            for (let file of runningTests) {\n                const outputs = outputFor[file];\n                if (outputs && outputs.length) {\n                    console.log(chalk.green(\"log for\", file));\n                    console.log(outputs.join(\"\\n\"));\n                }\n            }\n        }, testWatchDogTimeout);\n\n        fileMax = testFiles.length;\n        const promises = [];\n        const cpuCount = Math.max(CPU || os.cpus().length * 0.7, 2);\n        for (let i = 0; i < cpuCount; i++) {\n            promises.push(runTestAndContinue(data));\n        }\n        await Promise.all(promises);\n\n        clearInterval(infoTimer);\n        epilogue();\n\n        process.exit(0);\n    })();\n} else {\n    const { workerThread } = require(\"./parallel_test_worker\");\n    workerThread();\n}\n"], "fixing_code": ["/**\n * @module node-opcua-client-private\n */\nimport { EventEmitter } from \"events\";\nimport * as chalk from \"chalk\";\nimport { assert } from \"node-opcua-assert\";\nimport { AggregateFunction } from \"node-opcua-constants\";\nimport { DateTime } from \"node-opcua-basic-types\";\nimport {\n    ExtraDataTypeManager,\n    getExtensionObjectConstructor,\n    getExtraDataTypeManager,\n    promoteOpaqueStructure\n} from \"node-opcua-client-dynamic-extension-object\";\nimport { Certificate, Nonce } from \"node-opcua-crypto\";\nimport { attributeNameById, BrowseDirection, LocalizedTextLike } from \"node-opcua-data-model\";\nimport { DataValue } from \"node-opcua-data-value\";\nimport { checkDebugFlag, make_debugLog, make_errorLog, make_warningLog } from \"node-opcua-debug\";\nimport { ExtensionObject } from \"node-opcua-extension-object\";\nimport { coerceNodeId, NodeId, NodeIdLike, resolveNodeId } from \"node-opcua-nodeid\";\nimport { getBuiltInDataType, getArgumentDefinitionHelper, IBasicSession } from \"node-opcua-pseudo-session\";\nimport { AnyConstructorFunc } from \"node-opcua-schemas\";\nimport { requestHandleNotSetValue, SignatureData } from \"node-opcua-secure-channel\";\nimport { BrowseDescription, BrowseRequest, BrowseResponse, BrowseResult } from \"node-opcua-service-browse\";\nimport { CallMethodRequest, CallMethodResult, CallRequest, CallResponse } from \"node-opcua-service-call\";\nimport { EndpointDescription } from \"node-opcua-service-endpoints\";\nimport {\n    HistoryReadRequest,\n    HistoryReadResponse,\n    HistoryReadResult,\n    ReadRawModifiedDetails,\n    ReadProcessedDetails\n} from \"node-opcua-service-history\";\nimport { QueryFirstRequest, QueryFirstResponse } from \"node-opcua-service-query\";\nimport {\n    AttributeIds,\n    ReadRequest,\n    ReadResponse,\n    ReadValueId,\n    ReadValueIdOptions,\n    TimestampsToReturn\n} from \"node-opcua-service-read\";\nimport {\n    RegisterNodesRequest,\n    RegisterNodesResponse,\n    UnregisterNodesRequest,\n    UnregisterNodesResponse\n} from \"node-opcua-service-register-node\";\nimport {\n    CreateMonitoredItemsRequest,\n    CreateMonitoredItemsResponse,\n    CreateSubscriptionRequest,\n    CreateSubscriptionResponse,\n    DeleteMonitoredItemsRequest,\n    DeleteMonitoredItemsResponse,\n    DeleteSubscriptionsRequest,\n    DeleteSubscriptionsResponse,\n    ModifyMonitoredItemsRequest,\n    ModifyMonitoredItemsResponse,\n    ModifySubscriptionRequest,\n    ModifySubscriptionResponse,\n    PublishRequest,\n    PublishResponse,\n    RepublishRequest,\n    RepublishResponse,\n    SetMonitoringModeRequest,\n    SetMonitoringModeResponse,\n    SetPublishingModeRequest,\n    SetPublishingModeResponse,\n    SetTriggeringRequestOptions,\n    SetTriggeringResponse,\n    SetTriggeringRequest,\n    TransferSubscriptionsRequest,\n    TransferSubscriptionsResponse\n} from \"node-opcua-service-subscription\";\nimport {\n    BrowsePath,\n    BrowsePathResult,\n    TranslateBrowsePathsToNodeIdsRequest,\n    TranslateBrowsePathsToNodeIdsResponse\n} from \"node-opcua-service-translate-browse-path\";\nimport { WriteRequest, WriteResponse, WriteValue } from \"node-opcua-service-write\";\nimport { StatusCode, StatusCodes, Callback, CallbackT } from \"node-opcua-status-code\";\nimport { ErrorCallback } from \"node-opcua-status-code\";\nimport {\n    BrowseNextRequest,\n    BrowseNextResponse,\n    HistoryReadValueIdOptions,\n    ServiceFault,\n    WriteValueOptions\n} from \"node-opcua-types\";\nimport { buffer_ellipsis, getFunctionParameterNames, isNullOrUndefined, lowerFirstLetter } from \"node-opcua-utils\";\nimport { DataType, Variant, VariantLike } from \"node-opcua-variant\";\n\nimport {\n    ArgumentDefinition,\n    BrowseDescriptionLike,\n    CallMethodRequestLike,\n    ClientSession,\n    CreateMonitoredItemsRequestLike,\n    CreateSubscriptionRequestLike,\n    DeleteMonitoredItemsRequestLike,\n    DeleteSubscriptionsRequestLike,\n    MethodId,\n    ModifyMonitoredItemsRequestLike,\n    ModifySubscriptionRequestLike,\n    MonitoredItemData,\n    NodeAttributes,\n    QueryFirstRequestLike,\n    SetMonitoringModeRequestLike,\n    SubscriptionId,\n    TransferSubscriptionsRequestLike,\n    HistoryReadValueIdOptions2,\n    ExtraReadHistoryValueParameters\n} from \"../client_session\";\nimport { ClientSessionKeepAliveManager } from \"../client_session_keepalive_manager\";\nimport { ClientSubscription } from \"../client_subscription\";\nimport { Request, Response } from \"../common\";\nimport { repair_client_session } from \"../reconnection\";\n\nimport { ClientSidePublishEngine } from \"./client_publish_engine\";\nimport { ClientSubscriptionImpl } from \"./client_subscription_impl\";\nimport { IClientBase } from \"./i_private_client\";\n\nexport type ResponseCallback<T> = (err: Error | null, response?: T) => void;\n\nconst helpAPIChange = process.env.DEBUG && process.env.DEBUG.match(/API/);\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\nconst warningLog = make_warningLog(__filename);\nconst errorLog = make_errorLog(__filename);\n\nlet pendingTransactionMessageDisplayed = false;\n\nfunction coerceBrowseDescription(data: any): BrowseDescription {\n    if (typeof data === \"string\" || data instanceof NodeId) {\n        return coerceBrowseDescription({\n            browseDirection: BrowseDirection.Forward,\n            includeSubtypes: true,\n            nodeClassMask: 0,\n            nodeId: data,\n            referenceTypeId: \"HierarchicalReferences\",\n            resultMask: 63\n        });\n    } else {\n        data.nodeId = resolveNodeId(data.nodeId);\n        data.referenceTypeId = data.referenceTypeId ? resolveNodeId(data.referenceTypeId) : null;\n        return new BrowseDescription(data);\n    }\n}\n\nfunction coerceReadValueId(node: any): ReadValueId {\n    if (typeof node === \"string\" || node instanceof NodeId) {\n        return new ReadValueId({\n            attributeId: AttributeIds.Value,\n            dataEncoding: undefined, // {namespaceIndex: 0, name: undefined}\n            indexRange: undefined,\n            nodeId: resolveNodeId(node)\n        });\n    } else {\n        assert(node instanceof Object);\n        return new ReadValueId(node);\n    }\n}\n\nconst keys = Object.keys(AttributeIds).filter((k: any) => (AttributeIds as any)[k] !== AttributeIds.INVALID);\n\nconst attributeNames: string[] = ((): string[] => {\n    const r: string[] = [];\n    for (let i = 1; i <= 22; i++) {\n        r.push(attributeNameById[i].toString());\n    }\n    return r;\n})();\n\nfunction composeResult(nodes: any[], nodesToRead: ReadValueIdOptions[], dataValues: DataValue[]): NodeAttributes[] {\n    assert(nodesToRead.length === dataValues.length);\n    let c = 0;\n    const results = [];\n    let dataValue;\n    let k;\n    let nodeToRead;\n\n    for (const node of nodes) {\n        const data: NodeAttributes = {\n            nodeId: resolveNodeId(node),\n            statusCode: StatusCodes.BadNodeIdUnknown\n        };\n\n        let addedProperty = 0;\n\n        for (const key of attributeNames) {\n            dataValue = dataValues[c];\n            nodeToRead = nodesToRead[c];\n            c++;\n            if (dataValue.statusCode.equals(StatusCodes.Good)) {\n                k = lowerFirstLetter(key);\n                data[k] = dataValue.value ? dataValue.value.value : null;\n                addedProperty += 1;\n            }\n        }\n\n        /* istanbul ignore if */\n        if (addedProperty > 0) {\n            data.statusCode = StatusCodes.Good;\n        } else {\n            data.statusCode = StatusCodes.BadNodeIdUnknown;\n        }\n        results.push(data);\n    }\n\n    return results;\n}\n\nconst emptyUint32Array = new Uint32Array(0);\n\ntype EmptyCallback = (err?: Error) => void;\n\nexport interface Reconnectable {\n    _reconnecting: {\n        reconnecting: boolean;\n        pendingCallbacks: EmptyCallback[];\n    };\n    pendingTransactions: any[];\n    pendingTransactionsCount: number;\n}\n/**\n * @class ClientSession\n * @param client {OPCUAClientImpl}\n * @constructor\n * @private\n */\nexport class ClientSessionImpl extends EventEmitter implements ClientSession {\n    public timeout: number;\n    public authenticationToken?: NodeId;\n    public requestedMaxReferencesPerNode: number;\n    public sessionId: NodeId;\n    public lastRequestSentTime: Date;\n    public lastResponseReceivedTime: Date;\n    public serverCertificate: Certificate;\n    public name = \"\";\n\n    public serverNonce?: Nonce;\n    public serverSignature?: SignatureData; // todo : remove ?\n    public serverEndpoints: any[] = [];\n    public _client: IClientBase | null;\n    public _closed: boolean;\n\n    private _reconnecting: {\n        reconnecting: boolean;\n        pendingCallbacks: EmptyCallback[];\n        pendingTransactions: any[];\n        pendingTransactionsCount: number;\n    };\n\n    /**\n     * @internal\n     */\n    public _closeEventHasBeenEmitted: boolean;\n    private _publishEngine: ClientSidePublishEngine | null;\n    private _keepAliveManager?: ClientSessionKeepAliveManager;\n    private _namespaceArray?: any;\n    private recursive_repair_detector = 0;\n\n    constructor(client: IClientBase) {\n        super();\n\n        this.serverCertificate = Buffer.alloc(0);\n\n        this.sessionId = new NodeId();\n\n        this._closeEventHasBeenEmitted = false;\n        this._client = client;\n        this._publishEngine = null;\n\n        this._closed = false;\n\n        this._reconnecting = {\n            reconnecting: false,\n            pendingCallbacks: [],\n            pendingTransactions: [],\n            pendingTransactionsCount: 0\n        };\n\n        this.requestedMaxReferencesPerNode = 10000;\n        this.lastRequestSentTime = new Date(1, 1, 1970);\n        this.lastResponseReceivedTime = new Date(1, 1, 1970);\n        this.timeout = 0;\n    }\n\n    /**\n     * the endpoint on which this session is operating\n     * @property endpoint\n     * @type {EndpointDescription}\n     */\n    get endpoint(): EndpointDescription {\n        return this._client!.endpoint!;\n    }\n\n    get subscriptionCount(): number {\n        return this._publishEngine ? this._publishEngine.subscriptionCount : 0;\n    }\n\n    get isReconnecting(): boolean {\n        return this._client ? this._client.isReconnecting || this._reconnecting?.reconnecting : false;\n    }\n\n    public getPublishEngine(): ClientSidePublishEngine {\n        if (!this._publishEngine) {\n            this._publishEngine = new ClientSidePublishEngine(this);\n        }\n        return this._publishEngine!;\n    }\n\n    /**\n     * @method browse\n     * @async\n     *\n     * @example\n     *\n     *    ```javascript\n     *    session.browse(\"RootFolder\",function(err,browseResult) {\n     *      if(err) return callback(err);\n     *      console.log(browseResult.toString());\n     *      callback();\n     *    } );\n     *    ```\n     *\n     *\n     * @example\n     *\n     *    ``` javascript\n     *    const browseDescription = {\n     *       nodeId: \"ObjectsFolder\",\n     *       referenceTypeId: \"Organizes\",\n     *       browseDirection: BrowseDirection.Inverse,\n     *       includeSubtypes: true,\n     *       nodeClassMask: 0,\n     *       resultMask: 63\n     *    }\n     *    session.browse(browseDescription,function(err, browseResult) {\n     *       if(err) return callback(err);\n     *       console.log(browseResult.toString());\n     *       callback();\n     *    });\n     *    ```\n     * @example\n     *\n     * ``` javascript\n     * session.browse([ \"RootFolder\", \"ObjectsFolder\"],function(err, browseResults) {\n     *       assert(browseResults.length === 2);\n     * });\n     * ```\n     *\n     * @example\n     * ``` javascript\n     * const browseDescriptions = [\n     * {\n     *   nodeId: \"ObjectsFolder\",\n     *   referenceTypeId: \"Organizes\",\n     *   browseDirection: BrowseDirection.Inverse,\n     *   includeSubtypes: true,\n     *   nodeClassMask: 0,\n     *   resultMask: 63\n     * },\n     * // {...}\n     * ]\n     *  session.browse(browseDescriptions,function(err, browseResults) {\n     *\n     *   });\n     * ```\n     *\n     *\n     */\n    public browse(nodeToBrowse: BrowseDescriptionLike, callback: ResponseCallback<BrowseResult>): void;\n\n    public browse(nodesToBrowse: BrowseDescriptionLike[], callback: ResponseCallback<BrowseResult[]>): void;\n\n    public async browse(nodeToBrowse: BrowseDescriptionLike): Promise<BrowseResult>;\n\n    public async browse(nodesToBrowse: BrowseDescriptionLike[]): Promise<BrowseResult[]>;\n    /**\n     * @internal\n     * @param args\n     */\n    public browse(...args: any[]): any {\n        const arg0 = args[0];\n        const isArray = Array.isArray(arg0);\n        const callback: ResponseCallback<BrowseResult[] | BrowseResult> = args[1];\n        assert(typeof callback === \"function\");\n\n        assert(isFinite(this.requestedMaxReferencesPerNode));\n\n        const nodesToBrowse: BrowseDescription[] = (isArray ? arg0 : [arg0 as BrowseDescription]).map(coerceBrowseDescription);\n\n        const request = new BrowseRequest({\n            nodesToBrowse,\n            requestedMaxReferencesPerNode: this.requestedMaxReferencesPerNode\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof BrowseResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            const results: BrowseResult[] = response.results ? response.results : [];\n\n            if (this.requestedMaxReferencesPerNode > 0) {\n                for (let i = 0; i < results.length; i++) {\n                    const r = results[i];\n\n                    /* istanbul ignore next */\n                    if (r.references && r.references.length > this.requestedMaxReferencesPerNode) {\n                        warningLog(\n                            chalk.yellow(\"warning\") +\n                                \" BrowseResponse : the server didn't take into\" +\n                                \" account our requestedMaxReferencesPerNode \"\n                        );\n                        warningLog(\"        this.requestedMaxReferencesPerNode= \" + this.requestedMaxReferencesPerNode);\n                        warningLog(\"        got \" + r.references.length + \"for \" + nodesToBrowse[i].nodeId.toString());\n                        warningLog(\"        continuationPoint \", r.continuationPoint);\n                    }\n                }\n            }\n            for (const r of results) {\n                r.references = r.references || /* istanbul ignore next */ [];\n            }\n            assert(results[0] instanceof BrowseResult);\n            return callback(null, isArray ? results : results[0]);\n        });\n    }\n\n    public browseNext(\n        continuationPoint: Buffer,\n        releaseContinuationPoints: boolean,\n        callback: ResponseCallback<BrowseResult>\n    ): void;\n\n    public browseNext(\n        continuationPoints: Buffer[],\n        releaseContinuationPoints: boolean,\n        callback: ResponseCallback<BrowseResult[]>\n    ): void;\n\n    public async browseNext(continuationPoint: Buffer, releaseContinuationPoints: boolean): Promise<BrowseResult>;\n    public async browseNext(continuationPoints: Buffer[], releaseContinuationPoints: boolean): Promise<BrowseResult[]>;\n    public browseNext(...args: any[]): any {\n        const arg0 = args[0];\n        const isArray = Array.isArray(arg0);\n        const releaseContinuationPoints = args[1] as boolean;\n        const callback: any = args[2];\n        assert(typeof callback === \"function\", \"expecting a callback function here\");\n\n        const continuationPoints: Buffer[] = isArray ? arg0 : [arg0 as Buffer];\n\n        const request = new BrowseNextRequest({\n            continuationPoints,\n            releaseContinuationPoints\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof BrowseNextResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            const results: BrowseResult[] = response.results ? response.results : [];\n\n            for (const r of results) {\n                r.references = r.references || [];\n            }\n            assert(results[0] instanceof BrowseResult);\n            return callback(null, isArray ? results : results[0]);\n        });\n    }\n\n    /**\n     * @method readVariableValue\n     * @async\n     *\n     * @example\n     *\n     * ```javascript\n     *     session.readVariableValue(\"ns=2;s=Furnace_1.Temperature\",function(err,dataValue) {\n     *        if(err) { return callback(err); }\n     *        if (dataValue.statusCode === opcua.StatusCodes.Good) {\n     *        }\n     *        console.log(dataValue.toString());\n     *        callback();\n     *     });\n     * ```\n     *\n     * @example\n     *\n     * ```javascript\n     *   session.readVariableValue([\"ns=0;i=2257\",\"ns=0;i=2258\"],function(err,dataValues) {\n     *      if (!err) {\n     *         console.log(dataValues[0].toString());\n     *         console.log(dataValues[1].toString());\n     *      }\n     *   });\n     * ```\n     *\n     * @example\n     * ```javascript\n     *     const dataValues = await session.readVariableValue([\"ns=1;s=Temperature\",\"ns=1;s=Pressure\"]);\n     * ```\n     */\n    public readVariableValue(nodeId: NodeIdLike, callback: ResponseCallback<DataValue>): void;\n\n    public readVariableValue(nodeIds: NodeIdLike[], callback: ResponseCallback<DataValue[]>): void;\n\n    public async readVariableValue(nodeId: NodeIdLike): Promise<DataValue>;\n\n    public async readVariableValue(nodeIds: NodeIdLike[]): Promise<DataValue[]>;\n    /**\n     * @internal\n     * @param args\n     */\n    public readVariableValue(...args: any[]): any {\n        const callback = args[1];\n        assert(typeof callback === \"function\");\n\n        const isArray = Array.isArray(args[0]);\n\n        const nodes = isArray ? args[0] : [args[0]];\n\n        const nodesToRead = nodes.map(coerceReadValueId);\n\n        const request = new ReadRequest({\n            nodesToRead,\n            timestampsToReturn: TimestampsToReturn.Neither\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!(response instanceof ReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            /* istanbul ignore next */\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                return callback(new Error(response.responseHeader.serviceResult.toString()));\n            }\n\n            /* istanbul ignore next */\n            if (!response.results) {\n                response.results = [];\n            }\n\n            assert(nodes.length === response.results.length);\n\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    /**\n     * @method readHistoryValue\n     * @async\n     *\n     * @example\n     *\n     * ```javascript\n     * //  es5\n     * session.readHistoryValue(\n     *   \"ns=5;s=Simulation Examples.Functions.Sine1\",\n     *   \"2015-06-10T09:00:00.000Z\",\n     *   \"2015-06-10T09:01:00.000Z\", function(err,dataValues) {\n     *\n     * });\n     * ```\n     *\n     * ```javascript\n     * //  es6\n     * const dataValues = await session.readHistoryValue(\n     *   \"ns=5;s=Simulation Examples.Functions.Sine1\",\n     *   \"2015-06-10T09:00:00.000Z\",\n     *   \"2015-06-10T09:01:00.000Z\");\n     * ```\n     * @param nodeToRead   the read value id\n     * @param start   the start time in UTC format\n     * @param end     the end time in UTC format\n     * @param callback\n     */\n    public readHistoryValue(\n        nodesToRead: NodeIdLike[] | HistoryReadValueIdOptions2[],\n        start: DateTime,\n        end: DateTime,\n        callback: (err: Error | null, results?: HistoryReadResult[]) => void\n    ): void;\n    public readHistoryValue(\n        nodesToRead: NodeIdLike[] | HistoryReadValueIdOptions2[],\n        start: DateTime,\n        end: DateTime,\n        options: ExtraReadHistoryValueParameters | undefined,\n        callback: (err: Error | null, results?: HistoryReadResult[]) => void\n    ): void;\n    public async readHistoryValue(\n        nodesToRead: NodeIdLike[] | HistoryReadValueIdOptions2[],\n        start: DateTime,\n        end: DateTime,\n        options?: ExtraReadHistoryValueParameters\n    ): Promise<HistoryReadResult[]>;\n    public readHistoryValue(\n        nodeToRead: NodeIdLike | HistoryReadValueIdOptions2,\n        start: DateTime,\n        end: DateTime,\n        callback: (err: Error | null, results?: HistoryReadResult) => void\n    ): void;\n    public readHistoryValue(\n        nodeToRead: NodeIdLike | HistoryReadValueIdOptions2,\n        start: DateTime,\n        end: DateTime,\n        options: ExtraReadHistoryValueParameters | undefined,\n        callback: (err: Error | null, results?: HistoryReadResult) => void\n    ): void;\n    public async readHistoryValue(\n        nodeToRead: NodeIdLike | HistoryReadValueIdOptions2,\n        start: DateTime,\n        end: DateTime,\n        parameters: ExtraReadHistoryValueParameters\n    ): Promise<HistoryReadResult>;\n    public readHistoryValue(...args: any[]): any {\n        const startTime = args[1];\n        const endTime = args[2];\n\n        let options: ExtraReadHistoryValueParameters = {};\n        let callback = args[3];\n        if (typeof callback !== \"function\") {\n            options = args[3];\n            callback = args[4];\n        }\n        assert(typeof callback === \"function\");\n\n        // adjust parameters\n        options.numValuesPerNode = options.numValuesPerNode || 0;\n        options.returnBounds = options.returnBounds || options.returnBounds === undefined ? true : false;\n        options.isReadModified = options.isReadModified || false;\n        options.timestampsToReturn = options.timestampsToReturn || TimestampsToReturn.Both;\n\n        const arg0 = args[0];\n        const isArray = Array.isArray(arg0);\n\n        const nodes = isArray ? arg0 : [arg0];\n\n        const nodesToRead: HistoryReadValueIdOptions[] = [];\n\n        for (const node of nodes) {\n            if (!node.nodeId) {\n                nodesToRead.push({\n                    continuationPoint: undefined,\n                    dataEncoding: undefined, // {namespaceIndex: 0, name: undefined},\n                    indexRange: undefined,\n                    nodeId: resolveNodeId(node as NodeIdLike)\n                });\n            } else {\n                nodesToRead.push(node as HistoryReadValueIdOptions);\n            }\n        }\n\n        const readRawModifiedDetails = new ReadRawModifiedDetails({\n            endTime,\n            isReadModified: false,\n            numValuesPerNode: options.numValuesPerNode,\n            returnBounds: options.returnBounds,\n            startTime\n        });\n\n        const request = new HistoryReadRequest({\n            historyReadDetails: readRawModifiedDetails,\n            nodesToRead,\n            releaseContinuationPoints: false,\n            timestampsToReturn: options.timestampsToReturn\n        });\n\n        request.nodesToRead = request.nodesToRead || [];\n\n        assert(nodes.length === request.nodesToRead.length);\n        this.historyRead(request, (err: Error | null, response?: HistoryReadResponse) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof HistoryReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            response.results = response.results || [];\n            assert(nodes.length === response.results.length);\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    public historyRead(request: HistoryReadRequest, callback: Callback<HistoryReadResponse>): void;\n    public historyRead(request: HistoryReadRequest): Promise<HistoryReadResponse>;\n    public historyRead(request: HistoryReadRequest, callback?: CallbackT<HistoryReadResponse>): any {\n        /* istanbul ignore next */\n        if (!callback) {\n            throw new Error(\"expecting a callback\");\n        }\n\n        this.performMessageTransaction(request, (err: Error | null, response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof HistoryReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                return callback(new Error(response.responseHeader.serviceResult.toString()));\n            }\n\n            response.results = response.results || /* istanbul ignore next */ [];\n            callback(null, response);\n        });\n    }\n\n    public readAggregateValue(\n        nodesToRead: HistoryReadValueIdOptions[],\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction[],\n        processingInterval: number,\n        callback: Callback<HistoryReadResult[]>\n    ): void;\n    public async readAggregateValue(\n        nodesToRead: HistoryReadValueIdOptions[],\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction[],\n        processingInterval: number\n    ): Promise<HistoryReadResult[]>;\n    public readAggregateValue(\n        nodeToRead: HistoryReadValueIdOptions,\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction,\n        processingInterval: number,\n        callback: Callback<HistoryReadResult>\n    ): void;\n    public async readAggregateValue(\n        nodeToRead: HistoryReadValueIdOptions,\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction,\n        processingInterval: number\n    ): Promise<HistoryReadResult>;\n\n    public readAggregateValue(\n        arg0: HistoryReadValueIdOptions[] | HistoryReadValueIdOptions,\n        startTime: DateTime,\n        endTime: DateTime,\n        aggregateFn: AggregateFunction[] | AggregateFunction,\n        processingInterval: number,\n        ...args: any[]\n    ): any {\n        const callback = args[0];\n        assert(typeof callback === \"function\");\n\n        const isArray = Array.isArray(arg0);\n\n        const nodesToRead: HistoryReadValueIdOptions[] = isArray\n            ? (arg0 as HistoryReadValueIdOptions[])\n            : [arg0 as HistoryReadValueIdOptions];\n\n        const aggregateFns: AggregateFunction[] = Array.isArray(aggregateFn)\n            ? (aggregateFn as AggregateFunction[])\n            : [aggregateFn as AggregateFunction];\n\n        assert(aggregateFns.length === nodesToRead.length);\n\n        const readProcessedDetails = new ReadProcessedDetails({\n            aggregateType: aggregateFns,\n            endTime,\n            processingInterval,\n            startTime\n        });\n\n        const request = new HistoryReadRequest({\n            historyReadDetails: readProcessedDetails,\n            nodesToRead,\n            releaseContinuationPoints: false,\n            timestampsToReturn: TimestampsToReturn.Both\n        });\n\n        assert(nodesToRead.length === request.nodesToRead!.length);\n        this.performMessageTransaction(request, (err: Error | null, response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof HistoryReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                return callback(new Error(response.responseHeader.serviceResult.toString()));\n            }\n\n            response.results = response.results || /* istanbul ignore next */ [];\n\n            assert(nodesToRead.length === response.results.length);\n\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    /**\n     *\n     * @method write\n     * @param nodesToWrite {WriteValue[]}  - the array of value to write. One or more elements.\n     * @param {Function} callback -   the callback function\n     * @param callback.err {object|null} the error if write has failed or null if OK\n     * @param callback.statusCodes {StatusCode[]} - an array of status code of each write\n     * @async\n     *\n     * @example\n     *\n     *     const nodesToWrite = [\n     *     {\n     *          nodeId: \"ns=1;s=SetPoint1\",\n     *          attributeId: opcua.AttributeIds.Value,\n     *          value: {\n     *             statusCode: Good,\n     *             value: {\n     *               dataType: opcua.DataType.Double,\n     *               value: 100.0\n     *             }\n     *          }\n     *     },\n     *     {\n     *          nodeId: \"ns=1;s=SetPoint2\",\n     *          attributeIds opcua.AttributeIds.Value,\n     *          value: {\n     *             statusCode: Good,\n     *             value: {\n     *               dataType: opcua.DataType.Double,\n     *               value: 45.0\n     *             }\n     *          }\n     *     }\n     *     ];\n     *     session.write(nodesToWrite,function (err,statusCodes) {\n     *       if(err) { return callback(err);}\n     *       //\n     *     });\n     *\n     * @method write\n     * @param nodeToWrite {WriteValue}  - the value to write\n     * @param callback -   the callback function\n     * @param callback.err {object|null} the error if write has failed or null if OK\n     * @param callback.statusCode {StatusCodes} - the status code of the write\n     * @async\n     *\n     * @example\n     *\n     *     const nodeToWrite = {\n     *          nodeId: \"ns=1;s=SetPoint\",\n     *          attributeId: opcua.AttributeIds.Value,\n     *          value: {\n     *             statusCode: Good,\n     *             value: {\n     *               dataType: opcua.DataType.Double,\n     *               value: 100.0\n     *             }\n     *          }\n     *     };\n     *     session.write(nodeToWrite,function (err,statusCode) {\n     *       if(err) { return callback(err);}\n     *       //\n     *     });\n     *\n     *\n     * @method write\n     * @param nodeToWrite {WriteValue}  - the value to write\n     * @return {Promise<StatusCode>}\n     * @async\n     *\n     * @example\n     *\n     * ```javascript\n     *   session.write(nodeToWrite).then(function(statusCode) { });\n     * ```\n     *\n     * @example\n     *\n     * ```javascript\n     *   const statusCode = await session.write(nodeToWrite);\n     * ```\n     *\n     * @method write\n     * @param nodesToWrite {Array<WriteValue>}  - the value to write\n     * @return {Promise<Array<StatusCode>>}\n     * @async\n     *\n     * @example\n     * ```javascript\n     * session.write(nodesToWrite).then(function(statusCodes) { });\n     * ```\n     *\n     * @example\n     * ```javascript\n     *   const statusCodes = await session.write(nodesToWrite);\n     * ```\n     */\n    public write(nodeToWrite: WriteValueOptions, callback: ResponseCallback<StatusCode>): void;\n\n    public write(nodesToWrite: WriteValueOptions[], callback: ResponseCallback<StatusCode[]>): void;\n\n    public async write(nodesToWrite: WriteValueOptions[]): Promise<StatusCode[]>;\n\n    public async write(nodeToWrite: WriteValueOptions): Promise<StatusCode>;\n\n    /**\n     * @internal\n     * @param args\n     */\n    public write(...args: any[]): any {\n        const arg0 = args[0];\n        const isArray = Array.isArray(arg0);\n        const nodesToWrite = isArray ? arg0 : [arg0];\n\n        const callback = args[1];\n        assert(typeof callback === \"function\");\n\n        const request = new WriteRequest({ nodesToWrite });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err, response);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof WriteResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            /* istanbul ignore next */\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                return callback(new Error(response.responseHeader.serviceResult.toString()));\n            }\n            response.results = response.results || /* istanbul ignore next */ [];\n            assert(nodesToWrite.length === response.results.length);\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    /**\n     *\n     * @method writeSingleNode\n     * @async\n     * @param nodeId  {NodeId}  - the node id of the node to write\n     * @param value   {Variant} - the value to write\n     * @param callback   {Function}\n     * @param callback.err {object|null} the error if write has failed or null if OK\n     * @param callback.statusCode {StatusCode} - the status code of the write\n     *\n     * @method writeSingleNode\n     * @async\n     * @param nodeId  {NodeId}  - the node id of the node to write\n     * @param value   {Variant} - the value to write\n     * @return {Promise<StatusCode>} - the status code of the write\n     *\n     * @deprecated\n     */\n    public writeSingleNode(nodeId: NodeIdLike, value: VariantLike, callback: ResponseCallback<StatusCode>): void;\n\n    public writeSingleNode(nodeId: NodeIdLike, value: VariantLike): Promise<StatusCode>;\n\n    public writeSingleNode(...args: any[]): any {\n        const nodeId = args[0] as NodeIdLike;\n        const value = args[1] as VariantLike;\n        const callback = args[2];\n\n        assert(typeof callback === \"function\");\n\n        const nodeToWrite = new WriteValue({\n            attributeId: AttributeIds.Value,\n            indexRange: undefined,\n            nodeId: resolveNodeId(nodeId),\n            value: new DataValue({ value })\n        });\n\n        this.write(nodeToWrite, (err, statusCode) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            assert(statusCode);\n            callback(null, statusCode);\n        });\n    }\n\n    /**\n     * @method readAllAttributes\n     *\n     * @example\n     *\n     *\n     *  ``` javascript\n     *  session.readAllAttributes(\"ns=2;s=Furnace_1.Temperature\",function(err,data) {\n     *    if(data.statusCode === StatusCodes.Good) {\n     *      console.log(\" nodeId      = \",data.nodeId.toString());\n     *      console.log(\" browseName  = \",data.browseName.toString());\n     *      console.log(\" description = \",data.description.toString());\n     *      console.log(\" value       = \",data.value.toString()));\n     *    }\n     *  });\n     *  ```\n     *\n     * @async\n     * @param nodes  array of nodeId to read\n     * @param node  nodeId to read\n     * @param callback\n     */\n    public readAllAttributes(node: NodeIdLike, callback: (err: Error | null, data?: NodeAttributes) => void): void;\n\n    public readAllAttributes(nodes: NodeIdLike[], callback: (err: Error | null, data?: NodeAttributes[]) => void): void;\n\n    public readAllAttributes(...args: any[]): void {\n        const arg0 = args[0];\n        const callback = args[1];\n        assert(typeof callback === \"function\");\n\n        const isArray = Array.isArray(arg0);\n\n        const nodes = isArray ? arg0 : [arg0];\n\n        const nodesToRead: ReadValueIdOptions[] = [];\n\n        for (const node of nodes) {\n            const nodeId = resolveNodeId(node);\n\n            /* istanbul ignore next */\n            if (!nodeId) {\n                throw new Error(\"cannot coerce \" + node + \" to a valid NodeId\");\n            }\n\n            for (let attributeId = 1; attributeId <= 22; attributeId++) {\n                nodesToRead.push({\n                    attributeId,\n                    dataEncoding: undefined,\n                    indexRange: undefined,\n                    nodeId\n                });\n            }\n        }\n\n        this.read(nodesToRead, (err: Error | null, dataValues?: DataValue[]) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!dataValues) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            const results = composeResult(nodes, nodesToRead, dataValues);\n            callback(err, isArray ? results : results[0]);\n        });\n    }\n\n    /**\n     * @method read (form1)\n     *\n     * @async\n     *\n     * @example\n     *\n     *     ```javascript\n     *     ```\n     *\n     *   form1: reading a single node\n     *\n     *  ``` javascript\n     *    const nodeToRead = {\n     *             nodeId:      \"ns=2;s=Furnace_1.Temperature\",\n     *             attributeId: AttributeIds.BrowseName\n     *    };\n     *\n     *    session.read(nodeToRead,function(err,dataValue) {\n     *        if (!err) {\n     *           console.log(dataValue.toString());\n     *        }\n     *    });\n     *    ```\n     *\n     *\n     * @method read (form2)\n     * @param nodesToRead               {Array<ReadValueId>} - an array of nodeId to read or a ReadValueId\n     * @param [maxAge]                 {Number}\n     * @param callback                 {Function}                - the callback function\n     * @param callback.err             {Error|null}              - the error or null if the transaction was OK}\n     * @param callback.dataValues       {Array<DataValue>}\n     * @async\n     *\n     * @example\n     *\n     *   ``` javascript\n     *   const nodesToRead = [\n     *        {\n     *             nodeId:      \"ns=2;s=Furnace_1.Temperature\",\n     *             attributeId: AttributeIds.BrowseName\n     *        }\n     *   ];\n     *   session.read(nodesToRead,function(err,dataValues) {\n     *     if (!err) {\n     *       dataValues.forEach(dataValue=>console.log(dataValue.toString()));\n     *     }\n     *   });\n     *   ```\n     *\n     */\n    public read(nodeToRead: ReadValueIdOptions, maxAge: number, callback: ResponseCallback<DataValue>): void;\n\n    public read(nodesToRead: ReadValueIdOptions[], maxAge: number, callback: ResponseCallback<DataValue[]>): void;\n\n    public read(nodeToRead: ReadValueIdOptions, callback: ResponseCallback<DataValue>): void;\n\n    public read(nodesToRead: ReadValueIdOptions[], callback: ResponseCallback<DataValue[]>): void;\n\n    public read(nodeToRead: ReadValueIdOptions, maxAge?: number): Promise<DataValue>;\n\n    public read(nodeToRead: ReadValueIdOptions[], maxAge?: number): Promise<DataValue[]>;\n\n    /**\n     * @internal\n     * @param args\n     */\n    public read(...args: any[]): any {\n        if (args.length === 2) {\n            return this.read(args[0], 0, args[1]);\n        }\n        assert(args.length === 3);\n\n        const isArray = Array.isArray(args[0]);\n\n        const nodesToRead = isArray ? args[0] : [args[0]];\n\n        assert(Array.isArray(nodesToRead));\n\n        const maxAge = args[1];\n\n        const callback = args[2];\n        assert(typeof callback === \"function\");\n\n        /* istanbul ignore next */\n        if (helpAPIChange) {\n            // the read method deprecation detection and warning\n            if (\n                !(getFunctionParameterNames(callback)[1] === \"dataValues\" || getFunctionParameterNames(callback)[1] === \"dataValue\")\n            ) {\n                warningLog(chalk.red(\"[NODE-OPCUA-E04] the ClientSession#read  API has changed !!, please fix the client code\"));\n                warningLog(chalk.red(\"   replace ..:\"));\n                warningLog(chalk.cyan(\"   session.read(nodesToRead,function(err,nodesToRead,results) {}\"));\n                warningLog(chalk.red(\"   with .... :\"));\n                warningLog(chalk.cyan(\"   session.read(nodesToRead,function(err,dataValues) {}\"));\n                warningLog(\"\");\n                warningLog(\n                    chalk.yellow(\n                        \"please make sure to refactor your code and check that \" +\n                            \"the second argument of your callback function is named\"\n                    ),\n                    chalk.cyan(\"dataValue\" + (isArray ? \"s\" : \"\"))\n                );\n                warningLog(chalk.cyan(\"to make this exception disappear\"));\n                throw new Error(\"ERROR ClientSession#read  API has changed !!, please fix the client code\");\n            }\n        }\n\n        // coerce nodeIds\n        for (const node of nodesToRead) {\n            node.nodeId = resolveNodeId(node.nodeId);\n        }\n\n        const request = new ReadRequest({\n            maxAge,\n            nodesToRead,\n            timestampsToReturn: TimestampsToReturn.Both\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err, response);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof ReadResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            // perform ExtensionObject resolution\n            promoteOpaqueStructureWithCallback(this, response.results!, () => {\n                response.results = response.results || /* istanbul ignore next */ [];\n                return callback(null, isArray ? response.results : response.results[0]);\n            });\n        });\n    }\n\n    public emitCloseEvent(statusCode: StatusCode): void {\n        if (!this._closeEventHasBeenEmitted) {\n            debugLog(\"ClientSession#emitCloseEvent\");\n            this._closeEventHasBeenEmitted = true;\n            this.emit(\"session_closed\", statusCode);\n        }\n    }\n\n    public createSubscription(\n        options: CreateSubscriptionRequestLike,\n        callback?: ResponseCallback<CreateSubscriptionResponse>\n    ): any {\n        this._defaultRequest(CreateSubscriptionRequest, CreateSubscriptionResponse, options, callback);\n    }\n\n    /**\n     * @method createSubscription2\n     * @param createSubscriptionRequest\n     * @param callback\n     *\n     *\n     * subscription.on(\"error',    function(err){ ... });\n     * subscription.on(\"terminate',function(err){ ... });\n     * const monitoredItem = await subscription.monitor(itemToMonitor,monitoringParameters,requestedParameters);\n     * monitoredItem.on(\"changed\",function( dataValue) {...});\n     *\n     */\n    public async createSubscription2(createSubscriptionRequest: CreateSubscriptionRequestLike): Promise<ClientSubscription>;\n    public createSubscription2(\n        createSubscriptionRequest: CreateSubscriptionRequestLike,\n        callback: (err: Error | null, subscription?: ClientSubscription) => void\n    ): void;\n    public createSubscription2(...args: any[]): any {\n        const createSubscriptionRequest = args[0] as CreateSubscriptionRequestLike;\n        let callback = args[1];\n        const subscription = new ClientSubscriptionImpl(this, createSubscriptionRequest);\n\n        // tslint:disable-next-line:no-empty\n        subscription.on(\"error\", (err) => {\n            if (callback) {\n                callback(err);\n                callback = null;\n            }\n        });\n        subscription.on(\"started\", () => {\n            assert(subscription.session === this, \"expecting a session here\");\n            if (callback) {\n                callback(null, subscription);\n                callback = null;\n            }\n        });\n    }\n\n    public deleteSubscriptions(\n        options: DeleteSubscriptionsRequestLike,\n        callback?: ResponseCallback<DeleteSubscriptionsResponse>\n    ): any {\n        this._defaultRequest(DeleteSubscriptionsRequest, DeleteSubscriptionsResponse, options, callback);\n    }\n\n    public setTriggering(request: SetTriggeringRequestOptions, callback?: ResponseCallback<SetTriggeringResponse>): any {\n        this._defaultRequest(SetTriggeringRequest, SetTriggeringResponse, request, callback);\n    }\n\n    /**\n     * @method transferSubscriptions\n     * @async\n     */\n    public transferSubscriptions(\n        options: TransferSubscriptionsRequestLike,\n        callback?: ResponseCallback<TransferSubscriptionsResponse>\n    ): any {\n        this._defaultRequest(TransferSubscriptionsRequest, TransferSubscriptionsResponse, options, callback);\n    }\n\n    public createMonitoredItems(\n        options: CreateMonitoredItemsRequestLike,\n        callback?: ResponseCallback<CreateMonitoredItemsResponse>\n    ): any {\n        this._defaultRequest(CreateMonitoredItemsRequest, CreateMonitoredItemsResponse, options, callback);\n    }\n\n    public modifyMonitoredItems(\n        options: ModifyMonitoredItemsRequestLike,\n        callback?: ResponseCallback<ModifyMonitoredItemsResponse>\n    ): any {\n        this._defaultRequest(ModifyMonitoredItemsRequest, ModifyMonitoredItemsResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method modifySubscription\n     * @async\n     * @param options {ModifySubscriptionRequest}\n     * @param callback {Function}\n     * @param callback.err {Error|null}   - the Error if the async method has failed\n     * @param callback.response {ModifySubscriptionResponse} - the response\n     */\n    public modifySubscription(\n        options: ModifySubscriptionRequestLike,\n        callback?: ResponseCallback<ModifySubscriptionResponse>\n    ): any {\n        this._defaultRequest(ModifySubscriptionRequest, ModifySubscriptionResponse, options, callback);\n    }\n\n    public setMonitoringMode(options: SetMonitoringModeRequestLike, callback?: ResponseCallback<SetMonitoringModeResponse>): any {\n        this._defaultRequest(SetMonitoringModeRequest, SetMonitoringModeResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method publish\n     * @async\n     * @param options  {PublishRequest}\n     * @param callback {Function}\n     * @param callback.err {Error|null}   - the Error if the async method has failed\n     * @param callback.response {PublishResponse} - the response\n     */\n    public publish(options: PublishRequest, callback: (err: Error | null, response?: PublishResponse) => void): void {\n        this._defaultRequest(PublishRequest, PublishResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method republish\n     * @async\n     * @param options  {RepublishRequest}\n     * @param callback the callback\n     */\n    public republish(options: RepublishRequest, callback: (err: Error | null, response?: RepublishResponse) => void): void {\n        this._defaultRequest(RepublishRequest, RepublishResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method deleteMonitoredItems\n     * @async\n     * @param options  {DeleteMonitoredItemsRequest}\n     * @param callback {Function}\n     * @param callback.err {Error|null}   - the Error if the async method has failed\n     */\n    public deleteMonitoredItems(\n        options: DeleteMonitoredItemsRequestLike,\n        callback: (err: Error | null, response?: DeleteMonitoredItemsResponse) => void\n    ): void {\n        this._defaultRequest(DeleteMonitoredItemsRequest, DeleteMonitoredItemsResponse, options, callback);\n    }\n\n    /**\n     *\n     * @method setPublishingMode\n     * @async\n     */\n    public setPublishingMode(publishingEnabled: boolean, subscriptionId: SubscriptionId): Promise<StatusCode>;\n    public setPublishingMode(publishingEnabled: boolean, subscriptionIds: SubscriptionId[]): Promise<StatusCode[]>;\n    public setPublishingMode(\n        publishingEnabled: boolean,\n        subscriptionId: SubscriptionId,\n        callback: (err: Error | null, statusCode?: StatusCode) => void\n    ): void;\n    public setPublishingMode(\n        publishingEnabled: boolean,\n        subscriptionIds: SubscriptionId[],\n        callback: (err: Error | null, statusCodes?: StatusCode[]) => void\n    ): void;\n    /**\n     * @internal\n     */\n    public setPublishingMode(...args: any[]): any {\n        const publishingEnabled = args[0];\n        const isArray = Array.isArray(args[1]);\n        const subscriptionIds = isArray ? args[1] : [args[1]];\n        const callback = args[2];\n\n        assert(typeof callback === \"function\");\n        assert(publishingEnabled === true || publishingEnabled === false);\n\n        const options = new SetPublishingModeRequest({\n            publishingEnabled,\n            subscriptionIds\n        });\n\n        this._defaultRequest(\n            SetPublishingModeRequest,\n            SetPublishingModeResponse,\n            options,\n            (err: Error | null, response?: SetPublishingModeResponse) => {\n                /* istanbul ignore next */\n                if (err) {\n                    return callback(err);\n                }\n                /* istanbul ignore next */\n                if (!response) {\n                    return callback(new Error(\"Internal Error\"));\n                }\n                response.results = response.results || /* istanbul ignore next */ [];\n                callback(err, isArray ? response.results : response.results[0]);\n            }\n        );\n    }\n\n    /**\n     *\n     * @method translateBrowsePath\n     * @async\n     * @param browsePath {BrowsePath|Array<BrowsePath>}\n     * @param callback {Function}\n     * @param callback.err {Error|null}\n     * @param callback.response {BrowsePathResult|Array<BrowsePathResult>}\n     *\n     *\n     *\n     */\n    public translateBrowsePath(browsePath: BrowsePath, callback: ResponseCallback<BrowsePathResult>): void;\n    public translateBrowsePath(browsesPath: BrowsePath[], callback: ResponseCallback<BrowsePathResult[]>): void;\n    public async translateBrowsePath(browsePath: BrowsePath): Promise<BrowsePathResult>;\n    public async translateBrowsePath(browsePaths: BrowsePath[]): Promise<BrowsePathResult[]>;\n\n    /**\n     * @internal\n     * @param args\n     */\n    public translateBrowsePath(...args: any[]): any {\n        const isArray = Array.isArray(args[0]);\n        const browsePaths = isArray ? args[0] : [args[0]];\n\n        const callback = args[1];\n        assert(typeof callback === \"function\");\n\n        const request = new TranslateBrowsePathsToNodeIdsRequest({ browsePaths });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err, response);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof TranslateBrowsePathsToNodeIdsResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            response.results = response.results || /* istanbul ignore next */ [];\n\n            callback(null, isArray ? response.results : response.results[0]);\n        });\n    }\n\n    public channelId(): number {\n        return this._client !== null && this._client._secureChannel !== null && this._client._secureChannel.isOpened()\n            ? this._client._secureChannel!.channelId\n            : -1;\n    }\n    public isChannelValid(): boolean {\n        /* istanbul ignore next */\n        if (!this._client) {\n            debugLog(chalk.red(\"Warning SessionClient is null ?\"));\n        }\n\n        return this._client !== null && this._client._secureChannel !== null && this._client._secureChannel.isOpened();\n    }\n\n    public performMessageTransaction(request: Request, callback: (err: Error | null, response?: Response) => void): void {\n        if (!this._client) {\n            // session may have been closed by user ... but is still in used !!\n            return callback(new Error(\"Session has been closed and should not be used to perform a transaction anymore\"));\n        }\n\n        if (!this.isChannelValid()) {\n            // the secure channel is broken, may be the server has crashed or the network cable has been disconnected\n            // for a long time\n            // we may need to queue this transaction, as a secure token may be being reprocessed\n            debugLog(chalk.bgWhite.red(\"!!! Performing transaction on invalid channel !!! \", request.constructor.name));\n            return callback(new Error(\"Invalid Channel after performing transaction on \" + request.constructor.name));\n        }\n\n        this._reconnecting.pendingTransactions = this._reconnecting.pendingTransactions || [];\n        this._reconnecting.pendingTransactionsCount = this._reconnecting.pendingTransactionsCount || 0;\n\n        const isPublishRequest = request instanceof PublishRequest;\n        if (isPublishRequest) {\n            return this._performMessageTransaction(request, callback);\n        }\n\n        if (this._reconnecting.pendingTransactionsCount > 0) {\n            /* istanbul ignore next */\n            if (this._reconnecting.pendingTransactions.length > 10) {\n                if (!pendingTransactionMessageDisplayed) {\n                    pendingTransactionMessageDisplayed = true;\n                    warningLog(\n                        \"[NODE-OPCUA-W21]\",\n                        \"Pending transactions: \",\n                        this._reconnecting.pendingTransactions.map((a: any) => a.request.constructor.name).join(\" \")\n                    );\n                    warningLog(\n                        \"[NODE-OPCUA-W22]\",\n                        chalk.yellow(\n                            \"Warning : your opcua client is sending multiple requests simultaneously to the server\",\n                            request.constructor.name\n                        ),\n                        \"\\n\",\n                        chalk.yellow(\" please fix your application code\")\n                    );\n                }\n            } else if (this._reconnecting.pendingTransactions.length > 3) {\n                debugLog(\n                    chalk.yellow(\n                        \"Warning : your client is sending multiple requests simultaneously to the server\",\n                        request.constructor.name\n                    )\n                );\n            }\n            this._reconnecting.pendingTransactions.push({ request, callback });\n            return;\n        }\n        this.processTransactionQueue(request, callback);\n    }\n    public processTransactionQueue = (request: Request, callback: (err: Error | null, response?: Response) => void): void => {\n        this._reconnecting.pendingTransactionsCount = this._reconnecting.pendingTransactionsCount || 0;\n        this._reconnecting.pendingTransactionsCount++;\n\n        this._performMessageTransaction(request, (err: null | Error, response?: Response) => {\n            this._reconnecting.pendingTransactionsCount--;\n\n            if (err && err.message.match(/BadSessionIdInvalid/) && request.constructor.name !== \"ActivateSessionRequest\") {\n                debugLog(\"Transaction on Invalid Session \", request.constructor.name);\n                request.requestHeader.requestHandle = requestHandleNotSetValue;\n                warningLog(\"client is now attempting to recreate a session\");\n                this.recreate_session_and_reperform_transaction(request, callback);\n                return;\n            }\n            callback(err, response);\n            const length = this._reconnecting.pendingTransactions.length; // record length before callback is called !\n            if (length > 0) {\n                debugLog(\n                    \"processTransactionQueue => \",\n                    this._reconnecting.pendingTransactions.length,\n                    \" transaction(s) left in queue\"\n                );\n                // tslint:disable-next-line: no-shadowed-variable\n                const { request, callback } = this._reconnecting.pendingTransactions.shift();\n                this.processTransactionQueue(request, callback);\n            }\n        });\n    };\n\n    public _performMessageTransaction(request: Request, callback: (err: Error | null, response?: Response) => void): void {\n        assert(typeof callback === \"function\");\n\n        /* istanbul ignore next */\n        if (!this._client) {\n            // session may have been closed by user ... but is still in used !!\n            return callback(new Error(\"Session has been closed and should not be used to perform a transaction anymore\"));\n        }\n\n        if (!this.isChannelValid()) {\n            // the secure channel is broken, may be the server has crashed or the network cable has been disconnected\n            // for a long time\n            // we may need to queue this transaction, as a secure token may be being reprocessed\n            debugLog(chalk.bgWhite.red(\"!!! Performing transaction on invalid channel !!! \", request.constructor.name));\n            return callback(new Error(\"Invalid Channel BadConnectionClosed\"));\n        }\n\n        // is this stuff useful?\n        if (request.requestHeader) {\n            request.requestHeader.authenticationToken = this.authenticationToken!;\n        }\n\n        this.lastRequestSentTime = new Date();\n\n        this._client.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            this.lastResponseReceivedTime = new Date();\n\n            /* istanbul ignore next */\n            if (err) {\n                if (response && response.responseHeader.serviceDiagnostics) {\n                    (err as any).serviceDiagnostics = response.responseHeader.serviceDiagnostics;\n                }\n                if (response && (response as any).diagnosticInfos) {\n                    (err as any).diagnosticsInfo = (response as any).diagnosticInfos;\n                }\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response) {\n                return callback(new Error(\"internal Error\"));\n            }\n\n            /* istanbul ignore next */\n            if (response.responseHeader.serviceResult.isNot(StatusCodes.Good)) {\n                err = new Error(\n                    \" ServiceResult is \" +\n                        response.responseHeader.serviceResult.toString() +\n                        \" request was \" +\n                        request.constructor.name\n                );\n\n                if (response && response.responseHeader.serviceDiagnostics) {\n                    (err as any).serviceDiagnostics = response.responseHeader.serviceDiagnostics;\n                }\n                if (response && (response as any).diagnosticInfos) {\n                    (err as any).diagnosticsInfo = (response as any).diagnosticInfos;\n                }\n                return callback(err, response);\n            }\n            return callback(null, response);\n        });\n    }\n\n    /**\n     *  evaluate the remaining time for the session\n     *\n     *\n     * evaluate the time in milliseconds that the session will live\n     * on the server end from now.\n     * The remaining live time is calculated based on when the last message was sent to the server\n     * and the session timeout.\n     *\n     * * In normal operation , when server and client communicates on a regular\n     *   basis, evaluateRemainingLifetime will return a number slightly below\n     *   session.timeout\n     *\n     * * when the client and server cannot communicate due to a network issue\n     *   (or a server crash), evaluateRemainingLifetime returns the estimated number\n     *   of milliseconds before the server (if not crash) will keep  the session alive\n     *   on its end to allow a automatic reconnection with session.\n     *\n     * * When evaluateRemainingLifetime returns zero , this mean that\n     *   the session has probably ended on the server side and will have to be recreated\n     *   from scratch in case of a reconnection.\n     *\n     * @return the number of milliseconds before session expires\n     */\n    public evaluateRemainingLifetime(): number {\n        const now = Date.now();\n        const expiryTime = this.lastRequestSentTime.getTime() + this.timeout;\n        return Math.max(0, expiryTime - now);\n    }\n\n    public _terminatePublishEngine(): void {\n        if (this._publishEngine) {\n            this._publishEngine.terminate();\n            this._publishEngine = null;\n        }\n    }\n\n    /**\n     *\n     * @method close\n     * @async\n     * @param [deleteSubscription=true] {Boolean}\n     * @param callback {Function}\n     */\n    public close(callback: ErrorCallback): void;\n\n    public close(deleteSubscription: boolean, callback: ErrorCallback): void;\n\n    public async close(deleteSubscription?: boolean): Promise<void>;\n\n    /**\n     * @internal\n     * @param args\n     */\n    public close(...args: any[]): any {\n        if (arguments.length === 1) {\n            return this.close(true, args[0]);\n        }\n\n        const deleteSubscription = args[0];\n        const callback = args[1];\n\n        assert(typeof callback === \"function\");\n        assert(typeof deleteSubscription === \"boolean\");\n\n        /* istanbul ignore next */\n        if (!this._client) {\n            debugLog(\"ClientSession#close : warning, client is already closed\");\n            return callback(); // already close ?\n        }\n        assert(this._client);\n\n        this._terminatePublishEngine();\n        this._client.closeSession(this, deleteSubscription, (err?: Error) => {\n            debugLog(\"session Close err \", err ? err.message : \"null\");\n            callback();\n        });\n    }\n\n    /**\n     * @method hasBeenClosed\n     * @return {Boolean}\n     */\n    public hasBeenClosed(): boolean {\n        return isNullOrUndefined(this._client) || this._closed || this._closeEventHasBeenEmitted;\n    }\n\n    public async call(methodToCall: CallMethodRequestLike): Promise<CallMethodResult>;\n    public async call(methodToCall: CallMethodRequestLike[]): Promise<CallMethodResult[]>;\n    public call(methodToCall: CallMethodRequestLike, callback: ResponseCallback<CallMethodResult>): void;\n    public call(methodsToCall: CallMethodRequestLike[], callback: ResponseCallback<CallMethodResult[]>): void;\n    /**\n     * @internal\n     * @param args\n     */\n    public call(...args: any[]): any {\n        const isArray = Array.isArray(args[0]);\n        const methodsToCall = isArray ? args[0] : [args[0]];\n        assert(Array.isArray(methodsToCall));\n\n        const callback = args[1];\n\n        // Note : The client has no explicit address space and therefore will struggle to\n        //        access the method arguments signature.\n        //        There are two methods that can be considered:\n        //           - get the object definition by querying the server\n        //           - load a fake address space to have some thing to query on our end\n        // const request = this._client.factory.constructObjectId(\"CallRequest\",{ methodsToCall: methodsToCall});\n        const request = new CallRequest({ methodsToCall });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!response || !(response instanceof CallResponse)) {\n                return callback(new Error(\"internal error\"));\n            }\n            response.results = response.results || [];\n\n            promoteOpaqueStructure3WithCallback(this, response.results, () => {\n                callback(null, isArray ? response.results : response.results![0]);\n            });\n        });\n    }\n\n    /**\n     * @method getMonitoredItems\n     * @param subscriptionId {UInt32} the subscription Id to return\n     * @param callback {Function}\n     * @param callback.err {Error}\n     * @param callback.monitoredItems the monitored Items\n     * @param callback.monitoredItems the monitored Items\n     */\n\n    public async getMonitoredItems(subscriptionId: SubscriptionId): Promise<MonitoredItemData>;\n    public getMonitoredItems(subscriptionId: SubscriptionId, callback: ResponseCallback<MonitoredItemData>): void;\n    public getMonitoredItems(...args: any[]): any {\n        const subscriptionId = args[0] as SubscriptionId;\n        const callback = args[1];\n        // <UAObject NodeId=\"i=2253\"  BrowseName=\"Server\">\n        // <UAMethod NodeId=\"i=11492\" BrowseName=\"GetMonitoredItems\"\n        //                                         ParentNodeId=\"i=2253\" MethodDeclarationId=\"i=11489\">\n        // <UAMethod NodeId=\"i=11489\" BrowseName=\"GetMonitoredItems\" ParentNodeId=\"i=2004\">\n        const methodsToCall = new CallMethodRequest({\n            inputArguments: [\n                // BaseDataType\n                { dataType: DataType.UInt32, value: subscriptionId }\n            ],\n            methodId: coerceNodeId(\"ns=0;i=11492\"), // MethodIds.Server_GetMonitoredItems;\n            objectId: coerceNodeId(\"ns=0;i=2253\") // ObjectId.Server\n        });\n\n        this.call(methodsToCall, (err?: Error | null, result?: CallMethodResult) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n\n            /* istanbul ignore next */\n            if (!result) {\n                return callback(new Error(\"internal error\"));\n            }\n\n            /* istanbul ignore next */\n            if (result.statusCode.isNot(StatusCodes.Good)) {\n                callback(new Error(result.statusCode.toString()));\n            } else {\n                result.outputArguments = result.outputArguments || [];\n\n                assert(result.outputArguments.length === 2);\n                const data = {\n                    clientHandles: result.outputArguments[1].value,\n                    serverHandles: result.outputArguments[0].value //\n                };\n\n                // Note some server might return null array\n                // let make sure we have Uint32Array and not a null pointer\n                data.serverHandles = data.serverHandles || /* istanbul ignore next */ emptyUint32Array;\n                data.clientHandles = data.clientHandles || /* istanbul ignore next */ emptyUint32Array;\n\n                assert(data.serverHandles instanceof Uint32Array);\n                assert(data.clientHandles instanceof Uint32Array);\n                callback(null, data);\n            }\n        });\n    }\n\n    /**\n     * @method getArgumentDefinition\n     *    extract the argument definition of a method\n     * @param methodId the method nodeId to get argument definition from\n     * @async\n     *\n     */\n    public async getArgumentDefinition(methodId: MethodId): Promise<ArgumentDefinition>;\n    public getArgumentDefinition(methodId: MethodId, callback: ResponseCallback<ArgumentDefinition>): void;\n    /**\n     * @internal\n     */\n    public getArgumentDefinition(...args: any[]): any {\n        const methodId = args[0] as MethodId;\n        const callback = args[1] as ResponseCallback<ArgumentDefinition>;\n        assert(typeof callback === \"function\");\n        return getArgumentDefinitionHelper(this, methodId, callback);\n    }\n\n    public async registerNodes(nodesToRegister: NodeIdLike[]): Promise<NodeId[]>;\n    public registerNodes(nodesToRegister: NodeIdLike[], callback: (err: Error | null, registeredNodeIds?: NodeId[]) => void): void;\n    public registerNodes(...args: any[]): any {\n        const nodesToRegister = args[0] as NodeIdLike[];\n        const callback = args[1] as (err: Error | null, registeredNodeIds?: NodeId[]) => void;\n\n        assert(typeof callback === \"function\");\n        assert(Array.isArray(nodesToRegister));\n\n        const request = new RegisterNodesRequest({\n            nodesToRegister: nodesToRegister.map(resolveNodeId)\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof RegisterNodesResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n\n            response.registeredNodeIds = response.registeredNodeIds || /* istanbul ignore next */ [];\n\n            callback(null, response.registeredNodeIds);\n        });\n    }\n\n    public async unregisterNodes(nodesToUnregister: NodeIdLike[]): Promise<void>;\n    public unregisterNodes(nodesToUnregister: NodeIdLike[], callback: (err?: Error) => void): void;\n    public unregisterNodes(...args: any[]): any {\n        const nodesToUnregister = args[0] as NodeIdLike[];\n        const callback = args[1] as (err?: Error) => void;\n\n        assert(typeof callback === \"function\");\n        assert(Array.isArray(nodesToUnregister));\n\n        const request = new UnregisterNodesRequest({\n            nodesToUnregister: nodesToUnregister.map(resolveNodeId)\n        });\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof UnregisterNodesResponse)) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            callback();\n        });\n    }\n\n    public async queryFirst(queryFirstRequest: QueryFirstRequestLike): Promise<QueryFirstResponse>;\n\n    public queryFirst(queryFirstRequest: QueryFirstRequestLike, callback: ResponseCallback<QueryFirstResponse>): void;\n    public queryFirst(...args: any[]): any {\n        const queryFirstRequest = args[0] as QueryFirstRequestLike;\n        const callback = args[1] as ResponseCallback<QueryFirstResponse>;\n\n        assert(typeof callback === \"function\");\n        const request = new QueryFirstRequest(queryFirstRequest);\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!response || !(response instanceof QueryFirstResponse)) {\n                return callback(new Error(\"internal error\"));\n            }\n            callback(null, response);\n        });\n    }\n\n    public startKeepAliveManager(): void {\n        if (this._keepAliveManager) {\n            //  \"keepAliveManger already started\"\n            return;\n        }\n        this._keepAliveManager = new ClientSessionKeepAliveManager(this);\n\n        this._keepAliveManager.on(\"failure\", () => {\n            /**\n             * raised when a keep-alive request has failed on the session, may be the session has timeout\n             * unexpectedly on the server side, may be the connection is broken.\n             * @event keepalive_failure\n             */\n            this.emit(\"keepalive_failure\");\n        });\n        this._keepAliveManager.on(\"keepalive\", (state, count) => {\n            /**\n             * @event keepalive\n             */\n            this.emit(\"keepalive\", state, count);\n        });\n        this._keepAliveManager.start();\n    }\n\n    public stopKeepAliveManager(): void {\n        if (this._keepAliveManager) {\n            this._keepAliveManager.stop();\n            this._keepAliveManager = undefined;\n        }\n    }\n\n    public dispose(): void {\n        assert(this._closeEventHasBeenEmitted);\n        this._terminatePublishEngine();\n        this.stopKeepAliveManager();\n        this.removeAllListeners();\n        //\n        const privateThis = this as any;\n        if (!(!privateThis.pendingTransactions || privateThis.pendingTransactions.length === 0)) {\n            // tslint:disable-next-line: no-console\n            console.log(\"dispose when pendingTransactions is not empty \");\n        }\n    }\n\n    public toString(): string {\n        const now = Date.now();\n        const lap1 = now - this.lastRequestSentTime.getTime();\n        const lap2 = now - this.lastResponseReceivedTime.getTime();\n        const timeoutDelay = this.timeout - lap1;\n\n        const timeoutInfo =\n            timeoutDelay < 0\n                ? chalk.red(\" expired since \" + -timeoutDelay / 1000 + \" seconds\")\n                : chalk.green(\" timeout in \" + timeoutDelay / 1000 + \" seconds\");\n\n        let str = \"\";\n        str += \" name..................... \" + this.name;\n        str += \"\\n sessionId................ \" + this.sessionId.toString();\n        str += \"\\n authenticationToken...... \" + (this.authenticationToken ? this.authenticationToken!.toString() : \"\");\n        str += \"\\n timeout.................. \" + this.timeout + \"ms\" + timeoutInfo;\n        str += \"\\n serverNonce.............. \" + (this.serverNonce ? this.serverNonce!.toString(\"hex\") : \"\");\n        str += \"\\n serverCertificate........ \" + buffer_ellipsis(this.serverCertificate);\n        // xx console.log(\" serverSignature.......... \", this.serverSignature);\n        str += \"\\n lastRequestSentTime...... \" + new Date(this.lastRequestSentTime).toISOString() + \"  (\" + lap1 + \")\";\n        str += \"\\n lastResponseReceivedTime. \" + new Date(this.lastResponseReceivedTime).toISOString() + \" (\" + lap2 + \")\";\n        str += \"\\n isReconnecting........... \" + this.isReconnecting;\n        str += \"\\n isValidChannel........... \" + this.isChannelValid() + \" has been closed  \" + this.hasBeenClosed();\n        str += \"\\n channelId................ \" + this.channelId();\n        str += \"\\n remaining life time...... \" + this.evaluateRemainingLifetime();\n        str += \"\\n subscription count....... \" + this.subscriptionCount;\n        if (this._client && this._client._secureChannel) {\n            if (this._client._secureChannel.securityToken) {\n                str += \"\\n reviseTokenLifetime...... \" + this._client._secureChannel.securityToken.revisedLifetime;\n            }\n        }\n        return str;\n    }\n\n    public getBuiltInDataType(...args: any[]): any {\n        const nodeId = args[0];\n        const callback = args[1];\n        return getBuiltInDataType(this, nodeId, callback);\n    }\n\n    public resumePublishEngine(): void {\n        assert(this._publishEngine);\n        if (this._publishEngine && this._publishEngine.subscriptionCount > 0) {\n            this._publishEngine.replenish_publish_request_queue();\n        }\n    }\n\n    public async readNamespaceArray(): Promise<string[]>;\n    public readNamespaceArray(callback: (err: Error | null, namespaceArray?: string[]) => void): void;\n    public readNamespaceArray(...args: any[]): any {\n        const callback = args[0];\n\n        this.read(\n            {\n                attributeId: AttributeIds.Value,\n                nodeId: resolveNodeId(\"Server_NamespaceArray\")\n            },\n            (err: Error | null, dataValue?: DataValue) => {\n                /* istanbul ignore next */\n                if (err) {\n                    return callback(err);\n                }\n                /* istanbul ignore next */\n                if (!dataValue) {\n                    return callback(new Error(\"Internal Error\"));\n                }\n\n                /* istanbul ignore next */\n                if (dataValue.statusCode !== StatusCodes.Good) {\n                    return callback(new Error(\"readNamespaceArray : \" + dataValue.statusCode.toString()));\n                }\n                assert(dataValue.value.value instanceof Array);\n                this._namespaceArray = dataValue.value.value; // keep a cache\n                callback(null, this._namespaceArray);\n            }\n        );\n    }\n\n    public getNamespaceIndex(namespaceUri: string): number {\n        assert(this._namespaceArray, \"please make sure that readNamespaceArray has been called\");\n        return this._namespaceArray.indexOf(namespaceUri);\n    }\n\n    // tslint:disable:no-empty\n    // ---------------------------------------- Alarm & condition stub\n    public disableCondition(): void {\n        /** empty */\n    }\n\n    public enableCondition(): void {\n        /** empty */\n    }\n\n    public addCommentCondition(\n        _conditionId: NodeIdLike,\n        _eventId: Buffer,\n        _comment: LocalizedTextLike,\n        _callback?: Callback<StatusCode>\n    ): any {\n        /** empty */\n    }\n\n    public confirmCondition(\n        _conditionId: NodeIdLike,\n        _eventId: Buffer,\n        _comment: LocalizedTextLike,\n        _callback?: Callback<StatusCode>\n    ): any {\n        /** empty */\n    }\n\n    public acknowledgeCondition(\n        _conditionId: NodeId,\n        _eventId: Buffer,\n        _comment: LocalizedTextLike,\n        _callback?: Callback<StatusCode>\n    ): any {\n        /** empty */\n    }\n\n    public findMethodId(_nodeId: NodeIdLike, _methodName: string, _callback?: ResponseCallback<NodeId>): any {\n        /** empty */\n    }\n\n    public _callMethodCondition(\n        _methodName: string,\n        _conditionId: NodeIdLike,\n        _eventId: Buffer,\n        _comment: LocalizedTextLike,\n        _callback: Callback<StatusCode>\n    ): void {\n        /** empty */\n    }\n\n    public async extractNamespaceDataType(): Promise<ExtraDataTypeManager> {\n        return getExtraDataTypeManager(this);\n    }\n    public async getExtensionObjectConstructor(dataTypeNodeId: NodeId): Promise<AnyConstructorFunc> {\n        return getExtensionObjectConstructor(this, dataTypeNodeId);\n    }\n    /**\n     *\n     * @param dataType\n     * @param pojo\n     * @async\n     */\n    public async constructExtensionObject(dataType: NodeId, pojo: Record<string, any>): Promise<ExtensionObject> {\n        const Constructor = await this.getExtensionObjectConstructor(dataType);\n        return new Constructor(pojo);\n    }\n\n    private _defaultRequest(requestClass: any, _responseClass: any, options: any, callback: any) {\n        assert(typeof callback === \"function\");\n\n        const request = options instanceof requestClass ? options : new requestClass(options);\n\n        /* istanbul ignore next */\n        if (doDebug) {\n            request.trace = new Error(\"\").stack;\n        }\n\n        /* istanbul ignore next */\n        if (this._closeEventHasBeenEmitted) {\n            debugLog(\"ClientSession#_defaultRequest => session has been closed !!\", request.toString());\n            setImmediate(() => {\n                callback(new Error(\"ClientSession is closed !\"));\n            });\n            return;\n        }\n\n        this.performMessageTransaction(request, (err: Error | null, response?: Response) => {\n            if (this._closeEventHasBeenEmitted) {\n                debugLog(\n                    \"ClientSession#_defaultRequest ... err =\",\n                    err ? err.message : \"null\",\n                    response ? response.toString() : \" null\"\n                );\n            }\n            /* istanbul ignore next */\n            if (err) {\n                debugLog(\"Client session : performMessageTransaction error = \", err.message);\n                // let intercept interesting error message\n                if (err.message.match(/BadSessionClosed/)) {\n                    // the session has been closed by Server\n                    // probably due to timeout issue\n                    // let's print some statistics\n                    const now = Date.now();\n\n                    /* istanbul ignore next */\n                    if (doDebug) {\n                        debugLog(chalk.bgWhite.red(\" server send BadSessionClosed !\"));\n                        debugLog(chalk.bgWhite.red(\" request was               \"), request.toString());\n                        debugLog(\" timeout.................. \", this.timeout);\n                        debugLog(\n                            \" lastRequestSentTime...... \",\n                            new Date(this.lastRequestSentTime).toISOString(),\n                            now - this.lastRequestSentTime.getTime()\n                        );\n                        debugLog(\n                            \" lastResponseReceivedTime. \",\n                            new Date(this.lastResponseReceivedTime).toISOString(),\n                            now - this.lastResponseReceivedTime.getTime()\n                        );\n                    }\n\n                    //  DO NOT TERMINATE SESSION, as we will need a publishEngine when we\n                    //  reconnect this._terminatePublishEngine();\n\n                    if (false) {\n                        // ER 10.2019\n                        /**\n                         * send when the session has been closed by the server ( probably due to inactivity and timeout)\n                         * @event session_closed\n                         */\n                        this.emitCloseEvent(StatusCodes.BadSessionClosed);\n                    }\n                }\n                return callback(err, response);\n            }\n            callback(null, response);\n        });\n    }\n\n    private recreate_session_and_reperform_transaction(\n        request: Request,\n        callback: (err: Error | null, response?: Response) => void\n    ) {\n        if (this.recursive_repair_detector >= 1) {\n            // tslint:disable-next-line: no-console\n            console.log(\"recreate_session_and_reperform_transaction => Already in Progress\");\n            return callback(new Error(\"Cannot recreate session\"));\n        }\n        this.recursive_repair_detector += 1;\n        debugLog(chalk.red(\"----------------> Repairing Client Session as Server believes it is invalid now \"));\n        repair_client_session(this._client!, this, (err?: Error) => {\n            this.recursive_repair_detector -= 1;\n            if (err) {\n                debugLog(chalk.red(\"----------------> session Repaired has failed with error\", err.message));\n                return callback(err);\n            }\n            debugLog(chalk.red(\"----------------> session Repaired, now redoing original transaction \"));\n            this._performMessageTransaction(request, callback);\n        });\n    }\n}\n\ntype promoteOpaqueStructure3WithCallbackFunc = (\n    session: IBasicSession,\n    callMethodResults: CallMethodResult[],\n    callback: ErrorCallback\n) => void;\n\nasync function promoteOpaqueStructure2(session: IBasicSession, callMethodResult: CallMethodResult): Promise<void> {\n    if (!callMethodResult || !callMethodResult.outputArguments || callMethodResult.outputArguments.length === 0) {\n        return;\n    }\n    await promoteOpaqueStructure(\n        session,\n        callMethodResult.outputArguments.map((a) => ({ value: a }))\n    );\n}\n\nasync function promoteOpaqueStructure3(session: IBasicSession, callMethodResults: CallMethodResult[]): Promise<void> {\n    // construct dataTypeManager if not already present\n    const extraDataTypeManager = await getExtraDataTypeManager(session);\n\n    const promises: Promise<void>[] = callMethodResults.map(async (x: CallMethodResult) => promoteOpaqueStructure2(session, x));\n    await Promise.all(promises);\n}\n\n// tslint:disable:no-var-requires\n// tslint:disable:max-line-length\nconst thenify = require(\"thenify\");\nconst callbackify = require(\"callbackify\");\nconst opts = { multiArgs: false };\n\nconst promoteOpaqueStructureWithCallback = callbackify(promoteOpaqueStructure);\nconst promoteOpaqueStructure3WithCallback = callbackify(promoteOpaqueStructure3) as promoteOpaqueStructure3WithCallbackFunc;\n\nClientSessionImpl.prototype.browse = thenify.withCallback(ClientSessionImpl.prototype.browse, opts);\nClientSessionImpl.prototype.browseNext = thenify.withCallback(ClientSessionImpl.prototype.browseNext, opts);\nClientSessionImpl.prototype.readVariableValue = thenify.withCallback(ClientSessionImpl.prototype.readVariableValue, opts);\nClientSessionImpl.prototype.readHistoryValue = thenify.withCallback(ClientSessionImpl.prototype.readHistoryValue, opts);\nClientSessionImpl.prototype.readAggregateValue = thenify.withCallback(ClientSessionImpl.prototype.readAggregateValue, opts);\nClientSessionImpl.prototype.historyRead = thenify.withCallback(ClientSessionImpl.prototype.historyRead, opts);\nClientSessionImpl.prototype.write = thenify.withCallback(ClientSessionImpl.prototype.write, opts);\nClientSessionImpl.prototype.writeSingleNode = thenify.withCallback(ClientSessionImpl.prototype.writeSingleNode, opts);\nClientSessionImpl.prototype.readAllAttributes = thenify.withCallback(ClientSessionImpl.prototype.readAllAttributes, opts);\nClientSessionImpl.prototype.read = thenify.withCallback(ClientSessionImpl.prototype.read, opts);\nClientSessionImpl.prototype.createSubscription = thenify.withCallback(ClientSessionImpl.prototype.createSubscription, opts);\nClientSessionImpl.prototype.createSubscription2 = thenify.withCallback(ClientSessionImpl.prototype.createSubscription2, opts);\nClientSessionImpl.prototype.deleteSubscriptions = thenify.withCallback(ClientSessionImpl.prototype.deleteSubscriptions, opts);\nClientSessionImpl.prototype.transferSubscriptions = thenify.withCallback(ClientSessionImpl.prototype.transferSubscriptions, opts);\nClientSessionImpl.prototype.createMonitoredItems = thenify.withCallback(ClientSessionImpl.prototype.createMonitoredItems, opts);\nClientSessionImpl.prototype.modifyMonitoredItems = thenify.withCallback(ClientSessionImpl.prototype.modifyMonitoredItems, opts);\nClientSessionImpl.prototype.modifySubscription = thenify.withCallback(ClientSessionImpl.prototype.modifySubscription, opts);\nClientSessionImpl.prototype.setTriggering = thenify.withCallback(ClientSessionImpl.prototype.setTriggering, opts);\nClientSessionImpl.prototype.setMonitoringMode = thenify.withCallback(ClientSessionImpl.prototype.setMonitoringMode, opts);\nClientSessionImpl.prototype.publish = thenify.withCallback(ClientSessionImpl.prototype.publish, opts);\nClientSessionImpl.prototype.republish = thenify.withCallback(ClientSessionImpl.prototype.republish, opts);\nClientSessionImpl.prototype.deleteMonitoredItems = thenify.withCallback(ClientSessionImpl.prototype.deleteMonitoredItems, opts);\nClientSessionImpl.prototype.setPublishingMode = thenify.withCallback(ClientSessionImpl.prototype.setPublishingMode, opts);\nClientSessionImpl.prototype.translateBrowsePath = thenify.withCallback(ClientSessionImpl.prototype.translateBrowsePath, opts);\nClientSessionImpl.prototype.performMessageTransaction = thenify.withCallback(\n    ClientSessionImpl.prototype.performMessageTransaction,\n    opts\n);\nClientSessionImpl.prototype.close = thenify.withCallback(ClientSessionImpl.prototype.close, opts);\nClientSessionImpl.prototype.call = thenify.withCallback(ClientSessionImpl.prototype.call, opts);\nClientSessionImpl.prototype.getMonitoredItems = thenify.withCallback(ClientSessionImpl.prototype.getMonitoredItems, opts);\nClientSessionImpl.prototype.getArgumentDefinition = thenify.withCallback(ClientSessionImpl.prototype.getArgumentDefinition, opts);\nClientSessionImpl.prototype.queryFirst = thenify.withCallback(ClientSessionImpl.prototype.queryFirst, opts);\nClientSessionImpl.prototype.registerNodes = thenify.withCallback(ClientSessionImpl.prototype.registerNodes, opts);\nClientSessionImpl.prototype.unregisterNodes = thenify.withCallback(ClientSessionImpl.prototype.unregisterNodes, opts);\nClientSessionImpl.prototype.readNamespaceArray = thenify.withCallback(ClientSessionImpl.prototype.readNamespaceArray, opts);\nClientSessionImpl.prototype.getBuiltInDataType = thenify.withCallback(ClientSessionImpl.prototype.getBuiltInDataType, opts);\nClientSessionImpl.prototype.constructExtensionObject = callbackify(ClientSessionImpl.prototype.constructExtensionObject);\n", "/**\n * @module node-opcua-client-private\n */\n// tslint:disable:unified-signatures\nimport { EventEmitter } from \"events\";\nimport * as async from \"async\";\nimport * as chalk from \"chalk\";\n\nimport { assert } from \"node-opcua-assert\";\nimport { AttributeIds } from \"node-opcua-data-model\";\nimport { checkDebugFlag, make_debugLog, make_warningLog } from \"node-opcua-debug\";\nimport { resolveNodeId } from \"node-opcua-nodeid\";\n\nimport { ReadValueIdOptions, TimestampsToReturn } from \"node-opcua-service-read\";\nimport {\n    CreateMonitoredItemsRequest,\n    CreateMonitoredItemsResponse,\n    CreateSubscriptionRequest,\n    CreateSubscriptionResponse,\n    DataChangeNotification,\n    DeleteMonitoredItemsResponse,\n    DeleteSubscriptionsResponse,\n    MonitoredItemCreateRequestOptions,\n    MonitoringParametersOptions,\n    NotificationMessage,\n    StatusChangeNotification,\n    NotificationData,\n    EventNotificationList,\n    SetTriggeringResponse,\n    SetTriggeringRequest,\n    MonitoringMode,\n    ModifySubscriptionRequestOptions,\n    ModifySubscriptionResponse\n} from \"node-opcua-service-subscription\";\n\nimport { StatusCode, StatusCodes } from \"node-opcua-status-code\";\nimport { Callback, ErrorCallback } from \"node-opcua-status-code\";\nimport * as utils from \"node-opcua-utils\";\nimport { promoteOpaqueStructureInNotificationData } from \"node-opcua-client-dynamic-extension-object\";\nimport { createMonitoredItemsLimit, IBasicSession, readOperationLimits } from \"node-opcua-pseudo-session\";\n\nimport { IBasicSessionWithSubscription } from \"node-opcua-pseudo-session\";\nimport { ClientMonitoredItemBase } from \"../client_monitored_item_base\";\nimport { ClientMonitoredItemGroup } from \"../client_monitored_item_group\";\nimport { ClientSession, MonitoredItemData, SubscriptionId } from \"../client_session\";\nimport {\n    ClientHandle,\n    ClientMonitoredItemBaseMap,\n    ClientSubscription,\n    ClientSubscriptionOptions,\n    ModifySubscriptionOptions,\n    ModifySubscriptionResult\n} from \"../client_subscription\";\nimport { ClientMonitoredItem } from \"../client_monitored_item\";\nimport { ClientMonitoredItemToolbox } from \"../client_monitored_item_toolbox\";\nimport { ClientMonitoredItemGroupImpl } from \"./client_monitored_item_group_impl\";\nimport { ClientMonitoredItemImpl } from \"./client_monitored_item_impl\";\nimport { ClientSidePublishEngine } from \"./client_publish_engine\";\nimport { ClientSessionImpl } from \"./client_session_impl\";\n\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\nconst warningLog = make_warningLog(__filename);\n\nconst PENDING_SUBSCRIPTION_ID = 0xc0cac01a;\nconst TERMINATED_SUBSCRIPTION_ID = 0xc0cac01b;\nconst TERMINATING_SUBSCRIPTION_ID = 0xc0cac01c;\n\nconst minimumMaxKeepAliveCount = 3;\n\nfunction displayKeepAliveWarning(sessionTimeout: number, maxKeepAliveCount: number, publishingInterval: number): boolean {\n    const keepAliveInterval = maxKeepAliveCount * publishingInterval;\n\n    // istanbul ignore next\n    if (sessionTimeout < keepAliveInterval) {\n        warningLog(\n            chalk.yellowBright(\n                `[NODE-OPCUA-W09] The subscription parameters are not compatible with the session timeout !\n                  session timeout    = ${sessionTimeout}  milliseconds\n                  maxKeepAliveCount  = ${maxKeepAliveCount}\n                  publishingInterval = ${publishingInterval} milliseconds\"\n\n                  It is important that the session timeout    ( ${chalk.red(sessionTimeout)} ms) is largely greater than :\n                      (maxKeepAliveCount*publishingInterval  =  ${chalk.red(keepAliveInterval)} ms),\n                  otherwise you may experience unexpected disconnection from the server if your monitored items are not\n                  changing frequently.`\n            )\n        );\n\n        if (sessionTimeout < 3000 && publishingInterval <= 1000) {\n            warningLog(`[NODE-OPCUA-W10] You'll need to increase your sessionTimeout significantly.`);\n        }\n        if (\n            sessionTimeout >= 3000 &&\n            sessionTimeout < publishingInterval * minimumMaxKeepAliveCount &&\n            maxKeepAliveCount <= minimumMaxKeepAliveCount + 2\n        ) {\n            warningLog(`[NODE-OPCUA-W11] your publishingInterval interval is probably too large, consider reducing it.`);\n        }\n\n        const idealMaxKeepAliveCount = Math.max(4, Math.floor((sessionTimeout * 0.8) / publishingInterval - 0.5));\n        const idealPublishingInternal = Math.min(publishingInterval, sessionTimeout / (idealMaxKeepAliveCount + 3));\n        const idealKeepAliveInterval = idealMaxKeepAliveCount * publishingInterval;\n        warningLog(\n            `[NODE-OPCUA-W12]  An ideal value for maxKeepAliveCount could be ${idealMaxKeepAliveCount}.\n                  An ideal value for publishingInterval could be ${idealPublishingInternal} ms.\n                  This will make  your subscription emit a keep alive signal every ${idealKeepAliveInterval} ms\n                  if no monitored items are generating notifications.\n                  for instance:\n                    const  client = OPCUAClient.create({\n                        requestedSessionTimeout: 30* 60* 1000, // 30 minutes\n                    });\n`\n        );\n\n        if (!ClientSubscription.ignoreNextWarning) {\n            throw new Error(\"[NODE-OPCUA-W09] The subscription parameters are not compatible with the session timeout \");\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction createMonitoredItemsAndRespectOperationalLimits(\n    session: IBasicSession & IBasicSessionWithSubscription,\n    createMonitorItemsRequest: CreateMonitoredItemsRequest,\n    callback: (err: Error | null, response?: CreateMonitoredItemsResponse) => void\n) {\n    readOperationLimits(session)\n        .then((operationalLimits) => {\n            createMonitoredItemsLimit(operationalLimits.maxMonitoredItemsPerCall || 0, session, createMonitorItemsRequest)\n                .then((createMonitoredItemResponse) => callback(null, createMonitoredItemResponse))\n                .catch(callback);\n        })\n        .catch(callback);\n}\n\nexport class ClientSubscriptionImpl extends EventEmitter implements ClientSubscription {\n    /**\n     * the associated session\n     * @property session\n     * @type {ClientSession}\n     */\n    public get session(): ClientSessionImpl {\n        assert(this.publishEngine.session, \"expecting a valid session here\");\n        return this.publishEngine.session! as ClientSessionImpl;\n    }\n    public get hasSession(): boolean {\n        return !!this.publishEngine.session;\n    }\n    public get isActive(): boolean {\n        return !(\n            this.subscriptionId === PENDING_SUBSCRIPTION_ID ||\n            this.subscriptionId === TERMINATED_SUBSCRIPTION_ID ||\n            this.subscriptionId === TERMINATING_SUBSCRIPTION_ID\n        );\n    }\n\n    public subscriptionId: SubscriptionId;\n    public publishingInterval: number;\n    public lifetimeCount: number;\n    public maxKeepAliveCount: number;\n    public maxNotificationsPerPublish: number;\n    public publishingEnabled: boolean;\n    public priority: number;\n    public monitoredItems: ClientMonitoredItemBaseMap;\n    public monitoredItemGroups: ClientMonitoredItemGroup[] = [];\n\n    public timeoutHint = 0;\n    public publishEngine: ClientSidePublishEngine;\n\n    public lastSequenceNumber: number;\n    private lastRequestSentTime: Date;\n    private _nextClientHandle = 0;\n    private hasTimedOut: boolean;\n\n    constructor(session: ClientSession, options: ClientSubscriptionOptions) {\n        super();\n\n        const sessionImpl = session as ClientSessionImpl;\n        this.publishEngine = sessionImpl.getPublishEngine();\n\n        this.lastSequenceNumber = -1;\n\n        options = options || {};\n        options.requestedPublishingInterval = options.requestedPublishingInterval || 100;\n        options.requestedLifetimeCount = options.requestedLifetimeCount || 60;\n        options.requestedMaxKeepAliveCount = options.requestedMaxKeepAliveCount || 10;\n        options.requestedMaxKeepAliveCount = Math.max(options.requestedMaxKeepAliveCount, minimumMaxKeepAliveCount);\n\n        // perform some verification\n        const warningEmitted = displayKeepAliveWarning(\n            session.timeout,\n            options.requestedMaxKeepAliveCount,\n            options.requestedPublishingInterval\n        );\n        // istanbul ignore next\n        if (warningEmitted) {\n            warningLog(\n                JSON.stringify(\n                    {\n                        ...options\n                    },\n                    null,\n                    \" \"\n                )\n            );\n        }\n\n        options.maxNotificationsPerPublish = utils.isNullOrUndefined(options.maxNotificationsPerPublish)\n            ? 0\n            : options.maxNotificationsPerPublish;\n\n        options.publishingEnabled = !!options.publishingEnabled;\n        options.priority = options.priority || 1;\n\n        this.publishingInterval = options.requestedPublishingInterval;\n        this.lifetimeCount = options.requestedLifetimeCount;\n        this.maxKeepAliveCount = options.requestedMaxKeepAliveCount;\n        this.maxNotificationsPerPublish = options.maxNotificationsPerPublish || 0;\n        this.publishingEnabled = options.publishingEnabled;\n        this.priority = options.priority;\n\n        this.subscriptionId = PENDING_SUBSCRIPTION_ID;\n\n        this._nextClientHandle = 0;\n        this.monitoredItems = {};\n\n        this.lastRequestSentTime = new Date(1, 1, 1970);\n\n        /**\n         * set to True when the server has notified us that this subscription has timed out\n         * ( maxLifeCounter x published interval without being able to process a PublishRequest\n         * @property hasTimedOut\n         * @type {boolean}\n         */\n        this.hasTimedOut = false;\n\n        setImmediate(() => {\n            this.__create_subscription((err?: Error) => {\n                if (!err) {\n                    setImmediate(() => {\n                        /**\n                         * notify the observers that the subscription has now started\n                         * @event started\n                         */\n                        this.emit(\"started\", this.subscriptionId);\n                    });\n                } else {\n                    setImmediate(() => {\n                        /**\n                         * notify the observers that the subscription has now failed\n                         * @event failed\n                         */\n                        this.emit(\"error\", err);\n                    });\n                }\n            });\n        });\n    }\n\n    public terminate(...args: any[]): any {\n        debugLog(\"Terminating client subscription \", this.subscriptionId);\n        const callback = args[0];\n        assert(typeof callback === \"function\", \"expecting a callback function\");\n\n        if (this.subscriptionId === TERMINATED_SUBSCRIPTION_ID || this.subscriptionId === TERMINATING_SUBSCRIPTION_ID) {\n            // already terminated... just ignore\n            return callback(new Error(\"Already Terminated\"));\n        }\n\n        if (isFinite(this.subscriptionId)) {\n            const subscriptionId = this.subscriptionId;\n            this.subscriptionId = TERMINATING_SUBSCRIPTION_ID;\n            this.publishEngine.unregisterSubscription(subscriptionId);\n\n            if (!this.hasSession) {\n                return this._terminate_step2(callback);\n            }\n            const session = this.session;\n            if (!session) {\n                return callback(new Error(\"no session\"));\n            }\n            session.deleteSubscriptions(\n                {\n                    subscriptionIds: [subscriptionId]\n                },\n                (err: Error | null, response?: DeleteSubscriptionsResponse) => {\n                    if (response && response!.results![0] !== StatusCodes.Good) {\n                        debugLog(\"warning: deleteSubscription returned \", response.results);\n                    }\n                    if (err) {\n                        /**\n                         * notify the observers that an error has occurred\n                         * @event internal_error\n                         * @param err the error\n                         */\n                        this.emit(\"internal_error\", err);\n                    }\n                    this._terminate_step2(callback);\n                }\n            );\n        } else {\n            debugLog(\"subscriptionId is not value \", this.subscriptionId);\n            assert(this.subscriptionId === PENDING_SUBSCRIPTION_ID);\n            this._terminate_step2(callback);\n        }\n    }\n\n    /**\n     * @method nextClientHandle\n     */\n    public nextClientHandle(): number {\n        this._nextClientHandle += 1;\n        return this._nextClientHandle;\n    }\n\n    public async monitor(\n        itemToMonitor: ReadValueIdOptions,\n        requestedParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn,\n        monitoringMode: MonitoringMode\n    ): Promise<ClientMonitoredItemBase>;\n    public monitor(\n        itemToMonitor: ReadValueIdOptions,\n        requestedParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn,\n        monitoringMode: MonitoringMode,\n        done: Callback<ClientMonitoredItemBase>\n    ): void;\n    public monitor(...args: any[]): any {\n        const itemToMonitor = args[0] as ReadValueIdOptions;\n        const requestedParameters = args[1] as MonitoringParametersOptions;\n        const timestampsToReturn = args[2] as TimestampsToReturn;\n        const monitoringMode = typeof args[3] === \"function\" ? MonitoringMode.Reporting : (args[3] as MonitoringMode);\n        const done = (typeof args[3] === \"function\" ? args[3] : args[4]) as Callback<ClientMonitoredItemBase>;\n\n        assert(typeof done === \"function\", \"expecting a function here\");\n\n        itemToMonitor.nodeId = resolveNodeId(itemToMonitor.nodeId!);\n\n        const monitoredItem = ClientMonitoredItem_create(\n            this,\n            itemToMonitor,\n            requestedParameters,\n            timestampsToReturn,\n            monitoringMode,\n            (err1?: Error | null, monitoredItem2?: ClientMonitoredItem) => {\n                if (err1) {\n                    return done && done(err1);\n                }\n                done(err1 || null, monitoredItem);\n            }\n        );\n    }\n\n    public async monitorItems(\n        itemsToMonitor: ReadValueIdOptions[],\n        requestedParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn\n    ): Promise<ClientMonitoredItemGroup>;\n\n    public monitorItems(\n        itemsToMonitor: ReadValueIdOptions[],\n        requestedParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn,\n        done: Callback<ClientMonitoredItemGroup>\n    ): void;\n    public monitorItems(...args: any[]): any {\n        const itemsToMonitor = args[0] as ReadValueIdOptions[];\n        const requestedParameters = args[1] as MonitoringParametersOptions;\n        const timestampsToReturn = args[2] as TimestampsToReturn;\n        const done = args[3] as Callback<ClientMonitoredItemGroup>;\n\n        const monitoredItemGroup = new ClientMonitoredItemGroupImpl(this, itemsToMonitor, requestedParameters, timestampsToReturn);\n\n        this._wait_for_subscription_to_be_ready((err?: Error) => {\n            if (err) {\n                return done(err);\n            }\n            monitoredItemGroup._monitor((err1?: Error) => {\n                if (err1) {\n                    return done && done(err1);\n                }\n                done(err1!, monitoredItemGroup);\n            });\n        });\n    }\n\n    public _delete_monitored_items(monitoredItems: ClientMonitoredItemBase[], callback: ErrorCallback): void {\n        assert(typeof callback === \"function\");\n        assert(Array.isArray(monitoredItems));\n\n        assert(this.isActive);\n\n        for (const monitoredItem of monitoredItems) {\n            this._remove(monitoredItem);\n        }\n        const session = this.session as ClientSessionImpl;\n        session.deleteMonitoredItems(\n            {\n                monitoredItemIds: monitoredItems.map((monitoredItem) => monitoredItem.monitoredItemId),\n                subscriptionId: this.subscriptionId\n            },\n            (err: Error | null, response?: DeleteMonitoredItemsResponse) => {\n                callback(err!);\n            }\n        );\n    }\n\n    public async setPublishingMode(publishingEnabled: boolean): Promise<StatusCode>;\n    public setPublishingMode(publishingEnabled: boolean, callback: Callback<StatusCode>): void;\n    public setPublishingMode(...args: any[]): any {\n        const publishingEnabled = args[0] as boolean;\n        const callback = args[1] as Callback<StatusCode>;\n        assert(typeof callback === \"function\");\n\n        const session = this.session as ClientSessionImpl;\n        if (!session) {\n            return callback(new Error(\"no session\"));\n        }\n        const subscriptionId = this.subscriptionId as SubscriptionId;\n        session.setPublishingMode(publishingEnabled, subscriptionId, (err: Error | null, statusCode?: StatusCode) => {\n            if (err) {\n                return callback(err);\n            }\n            /* istanbul ignore next */\n            if (!statusCode) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            if (statusCode !== StatusCodes.Good) {\n                return callback(null, statusCode);\n            }\n            callback(null, StatusCodes.Good);\n        });\n    }\n\n    /**\n     *\n     */\n    public setTriggering(\n        triggeringItem: ClientMonitoredItemBase,\n        linksToAdd: ClientMonitoredItemBase[] | null,\n        linksToRemove?: ClientMonitoredItemBase[] | null\n    ): Promise<SetTriggeringResponse>;\n    public setTriggering(\n        triggeringItem: ClientMonitoredItemBase,\n        linksToAdd: ClientMonitoredItemBase[] | null,\n        linksToRemove: ClientMonitoredItemBase[] | null,\n        callback: Callback<SetTriggeringResponse>\n    ): void;\n    public setTriggering(...args: any[]): any {\n        const triggeringItem = args[0] as ClientMonitoredItemBase;\n        const linksToAdd = args[1] as ClientMonitoredItemBase[] | null;\n        const linksToRemove = args[2] as ClientMonitoredItemBase[] | null;\n        const callback = args[3] as Callback<SetTriggeringResponse>;\n        assert(typeof callback === \"function\");\n        const session = this.session as ClientSessionImpl;\n        if (!session) {\n            return callback(new Error(\"no session\"));\n        }\n        const subscriptionId = this.subscriptionId;\n\n        const triggeringItemId = triggeringItem.monitoredItemId!;\n\n        const setTriggeringRequest = new SetTriggeringRequest({\n            linksToAdd: linksToAdd ? linksToAdd.map((i) => i.monitoredItemId!) : null,\n            linksToRemove: linksToRemove ? linksToRemove.map((i) => i.monitoredItemId!) : null,\n            subscriptionId,\n            triggeringItemId\n        });\n        session.setTriggering(setTriggeringRequest, (err: Error | null, response?: SetTriggeringResponse) => {\n            if (err) {\n                if (response) {\n                    // use soft error, no exceptions\n                    return callback(null, response);\n                } else {\n                    return callback(err);\n                }\n            }\n            // istanbul ignore next\n            if (!response) {\n                return callback(new Error(\"Internal Error\"));\n            }\n            callback(null, response);\n        });\n    }\n\n    // public subscription service\n    public modify(options: ModifySubscriptionOptions, callback: Callback<ModifySubscriptionResult>): void;\n    public modify(options: ModifySubscriptionOptions): Promise<ModifySubscriptionResult>;\n    public modify(...args: any[]): any {\n        const modifySubscriptionRequest = args[0] as ModifySubscriptionRequestOptions;\n        const callback = args[1] as Callback<ModifySubscriptionResult>;\n        const session = this.session as ClientSessionImpl;\n        if (!session) {\n            return callback(new Error(\"no session\"));\n        }\n\n        modifySubscriptionRequest.subscriptionId = this.subscriptionId;\n\n        modifySubscriptionRequest.priority =\n            modifySubscriptionRequest.priority === undefined ? this.priority : modifySubscriptionRequest.priority;\n        modifySubscriptionRequest.requestedLifetimeCount =\n            modifySubscriptionRequest.requestedLifetimeCount === undefined\n                ? this.lifetimeCount\n                : modifySubscriptionRequest.requestedLifetimeCount;\n        modifySubscriptionRequest.requestedMaxKeepAliveCount =\n            modifySubscriptionRequest.requestedMaxKeepAliveCount === undefined\n                ? this.maxKeepAliveCount\n                : modifySubscriptionRequest.requestedMaxKeepAliveCount;\n        modifySubscriptionRequest.requestedPublishingInterval =\n            modifySubscriptionRequest.requestedPublishingInterval === undefined\n                ? this.publishingInterval\n                : modifySubscriptionRequest.requestedPublishingInterval;\n        modifySubscriptionRequest.maxNotificationsPerPublish =\n            modifySubscriptionRequest.maxNotificationsPerPublish === undefined\n                ? this.maxNotificationsPerPublish\n                : modifySubscriptionRequest.maxNotificationsPerPublish;\n\n        session.modifySubscription(modifySubscriptionRequest, (err: Error | null, response?: ModifySubscriptionResponse) => {\n            if (err || !response) {\n                return callback(err);\n            }\n            this.publishingInterval = response.revisedPublishingInterval;\n            this.lifetimeCount = response.revisedLifetimeCount;\n            this.maxKeepAliveCount = response.revisedMaxKeepAliveCount;\n            callback(null, response);\n        });\n    }\n\n    public getMonitoredItems(): Promise<MonitoredItemData>;\n    public getMonitoredItems(callback: Callback<MonitoredItemData>): void;\n    public getMonitoredItems(...args: any[]): any {\n        this.session.getMonitoredItems(this.subscriptionId, args[0]);\n    }\n\n    /**\n     *  utility function to recreate new subscription\n     *  @method recreateSubscriptionAndMonitoredItem\n     */\n    public recreateSubscriptionAndMonitoredItem(callback: ErrorCallback): void {\n        debugLog(\"ClientSubscription#recreateSubscriptionAndMonitoredItem\");\n\n        if (this.subscriptionId === TERMINATED_SUBSCRIPTION_ID) {\n            debugLog(\"Subscription is not in a valid state\");\n            return callback();\n        }\n\n        const oldMonitoredItems = this.monitoredItems;\n\n        this.publishEngine.unregisterSubscription(this.subscriptionId);\n\n        async.series(\n            [\n                (innerCallback: ErrorCallback) => {\n                    this.__create_subscription(innerCallback);\n                },\n                (innerCallback: ErrorCallback) => {\n                    const test = this.publishEngine.getSubscription(this.subscriptionId);\n\n                    debugLog(\"recreating \", Object.keys(oldMonitoredItems).length, \" monitored Items\");\n                    // re-create monitored items\n                    const itemsToCreate: MonitoredItemCreateRequestOptions[] = [];\n\n                    for (const monitoredItem of Object.values(oldMonitoredItems)) {\n                        assert(monitoredItem.monitoringParameters.clientHandle > 0);\n                        itemsToCreate.push({\n                            itemToMonitor: monitoredItem.itemToMonitor,\n                            monitoringMode: monitoredItem.monitoringMode,\n                            requestedParameters: monitoredItem.monitoringParameters\n                        });\n                    }\n\n                    const createMonitorItemsRequest = new CreateMonitoredItemsRequest({\n                        itemsToCreate,\n                        subscriptionId: this.subscriptionId,\n                        timestampsToReturn: TimestampsToReturn.Both // this.timestampsToReturn,\n                    });\n\n                    const session = this.session;\n                    // istanbul ignore next\n                    if (!session) {\n                        return innerCallback(new Error(\"no session\"));\n                    }\n\n                    debugLog(\"Recreating \", itemsToCreate.length, \" monitored items\");\n\n                    createMonitoredItemsAndRespectOperationalLimits(\n                        session,\n                        createMonitorItemsRequest,\n                        (err: Error | null, response?: CreateMonitoredItemsResponse) => {\n                            if (err) {\n                                debugLog(\"Recreating monitored item has failed with \", err.message);\n                                return innerCallback(err);\n                            }\n                            /* istanbul ignore next */\n                            if (!response) {\n                                return innerCallback(new Error(\"Internal Error\"));\n                            }\n                            const monitoredItemResults = response.results || [];\n\n                            monitoredItemResults.forEach((monitoredItemResult, index) => {\n                                const itemToCreate = itemsToCreate[index];\n                                /* istanbul ignore next */\n                                if (!itemToCreate || !itemToCreate.requestedParameters) {\n                                    throw new Error(\"Internal Error\");\n                                }\n                                const clientHandle = itemToCreate.requestedParameters.clientHandle;\n                                /* istanbul ignore next */\n                                if (!clientHandle) {\n                                    throw new Error(\"Internal Error\");\n                                }\n                                const monitoredItem = this.monitoredItems[clientHandle] as ClientMonitoredItemImpl;\n                                if (monitoredItem) {\n                                    monitoredItem._applyResult(monitoredItemResult);\n                                } else {\n                                    warningLog(\"cannot find monitored item for clientHandle !:\", clientHandle);\n                                }\n                            });\n                            innerCallback();\n                        }\n                    );\n                }\n            ],\n            (err) => {\n                if (err) {\n                    warningLog(err.message);\n                }\n                callback(err!);\n            }\n        );\n    }\n\n    public toString(): string {\n        let str = \"\";\n        str += \"subscriptionId      : \" + this.subscriptionId + \"\\n\";\n        str += \"publishingInterval  : \" + this.publishingInterval + \"\\n\";\n        str += \"lifetimeCount       : \" + this.lifetimeCount + \"\\n\";\n        str += \"maxKeepAliveCount   : \" + this.maxKeepAliveCount + \"\\n\";\n        str += \"hasTimedOut         : \" + this.hasTimedOut + \"\\n\";\n\n        const timeToLive = this.lifetimeCount * this.publishingInterval;\n        str += \"timeToLive          : \" + timeToLive + \"\\n\";\n        str += \"lastRequestSentTime : \" + this.lastRequestSentTime.toString() + \"\\n\";\n        const duration = Date.now() - this.lastRequestSentTime.getTime();\n        const extra =\n            duration - timeToLive > 0\n                ? chalk.red(\" expired since \" + (duration - timeToLive) / 1000 + \" seconds\")\n                : chalk.green(\" valid for \" + -(duration - timeToLive) / 1000 + \" seconds\");\n\n        str += \"timeSinceLast PR    : \" + duration + \"ms\" + extra + \"\\n\";\n        str += \"has expired         : \" + (duration > timeToLive) + \"\\n\";\n\n        str += \"(session timeout    : \" + this.session.timeout + \" ms)\\n\";\n        str += \"(maxKeepAliveCount*publishingInterval: \" + this.publishingInterval * this.session.timeout + \" ms)\\n\";\n\n        return str;\n    }\n\n    /**\n     * returns the approximated remaining life time of this subscription in milliseconds\n     */\n    public evaluateRemainingLifetime(): number {\n        const now = Date.now();\n        const timeout = this.publishingInterval * this.lifetimeCount;\n        const expiryTime = this.lastRequestSentTime.getTime() + timeout;\n        return Math.max(0, expiryTime - now);\n    }\n\n    public _add_monitored_item(clientHandle: ClientHandle, monitoredItem: ClientMonitoredItemBase): void {\n        assert(this.isActive, \"subscription must be active and not terminated\");\n        assert(monitoredItem.monitoringParameters.clientHandle === clientHandle);\n        this.monitoredItems[clientHandle] = monitoredItem;\n\n        /**\n         * notify the observers that a new monitored item has been added to the subscription.\n         * @event item_added\n         * @param the monitored item.\n         */\n        this.emit(\"item_added\", monitoredItem);\n    }\n\n    public _add_monitored_items_group(monitoredItemGroup: ClientMonitoredItemGroupImpl): void {\n        this.monitoredItemGroups.push(monitoredItemGroup);\n    }\n\n    public _wait_for_subscription_to_be_ready(done: ErrorCallback): void {\n        let _watchDogCount = 0;\n\n        const waitForSubscriptionAndMonitor = () => {\n            _watchDogCount++;\n\n            if (this.subscriptionId === PENDING_SUBSCRIPTION_ID) {\n                // the subscriptionID is not yet known because the server hasn't replied yet\n                // let postpone this call, a little bit, to let things happen\n                setImmediate(waitForSubscriptionAndMonitor);\n            } else if (this.subscriptionId === TERMINATED_SUBSCRIPTION_ID) {\n                // the subscription has been terminated in the meantime\n                // this indicates a potential issue in the code using this api.\n                if (typeof done === \"function\") {\n                    done(new Error(\"subscription has been deleted\"));\n                }\n            } else {\n                done();\n            }\n        };\n\n        setImmediate(waitForSubscriptionAndMonitor);\n    }\n\n    private __create_subscription(callback: ErrorCallback) {\n        assert(typeof callback === \"function\");\n\n        // istanbul ignore next\n        if (!this.hasSession) {\n            return callback(new Error(\"No Session\"));\n        }\n        const session = this.session;\n\n        debugLog(chalk.yellow.bold(\"ClientSubscription created \"));\n\n        const request = new CreateSubscriptionRequest({\n            maxNotificationsPerPublish: this.maxNotificationsPerPublish,\n            priority: this.priority,\n            publishingEnabled: this.publishingEnabled,\n            requestedLifetimeCount: this.lifetimeCount,\n            requestedMaxKeepAliveCount: this.maxKeepAliveCount,\n            requestedPublishingInterval: this.publishingInterval\n        });\n\n        session.createSubscription(request, (err: Error | null, response?: CreateSubscriptionResponse) => {\n            if (err) {\n                /* istanbul ignore next */\n                this.emit(\"internal_error\", err);\n                if (callback) {\n                    return callback(err);\n                }\n                return;\n            }\n\n            /* istanbul ignore next */\n            if (!response) {\n                return callback(new Error(\"internal error\"));\n            }\n\n            if (!this.hasSession) {\n                return callback(new Error(\"createSubscription has failed = > no session\"));\n            }\n            assert(this.hasSession);\n\n            this.subscriptionId = response.subscriptionId;\n            this.publishingInterval = response.revisedPublishingInterval;\n            this.lifetimeCount = response.revisedLifetimeCount;\n            this.maxKeepAliveCount = response.revisedMaxKeepAliveCount;\n\n            this.timeoutHint = (this.maxKeepAliveCount + 10) * this.publishingInterval;\n\n            displayKeepAliveWarning(this.session.timeout, this.maxKeepAliveCount, this.publishingInterval);\n            ClientSubscription.ignoreNextWarning = false;\n\n            if (doDebug) {\n                debugLog(chalk.yellow.bold(\"registering callback\"));\n                debugLog(chalk.yellow.bold(\"publishingInterval               \"), this.publishingInterval);\n                debugLog(chalk.yellow.bold(\"lifetimeCount                    \"), this.lifetimeCount);\n                debugLog(chalk.yellow.bold(\"maxKeepAliveCount                \"), this.maxKeepAliveCount);\n                debugLog(chalk.yellow.bold(\"publish request timeout hint =   \"), this.timeoutHint);\n                debugLog(chalk.yellow.bold(\"hasTimedOut                      \"), this.hasTimedOut);\n                debugLog(chalk.yellow.bold(\"timeoutHint for publish request  \"), this.timeoutHint);\n            }\n\n            this.publishEngine.registerSubscription(this);\n\n            if (callback) {\n                callback();\n            }\n        });\n    }\n\n    private __on_publish_response_DataChangeNotification(notification: DataChangeNotification) {\n        assert(notification.schema.name === \"DataChangeNotification\");\n\n        const monitoredItems = notification.monitoredItems || [];\n\n        let repeated = 0;\n        for (const monitoredItem of monitoredItems) {\n            const monitorItemObj = this.monitoredItems[monitoredItem.clientHandle];\n            if (monitorItemObj) {\n                if (monitorItemObj.itemToMonitor.attributeId === AttributeIds.EventNotifier) {\n                    warningLog(\n                        chalk.yellow(\"Warning\"),\n                        chalk.cyan(\n                            \" Server send a DataChangeNotification for an EventNotifier.\" + \" EventNotificationList was expected\"\n                        )\n                    );\n                    warningLog(\n                        chalk.cyan(\"         the Server may not be fully OPCUA compliant\"),\n                        chalk.yellow(\". This notification will be ignored.\")\n                    );\n                } else {\n                    const monitoredItemImpl = monitorItemObj as ClientMonitoredItemImpl;\n                    monitoredItemImpl._notify_value_change(monitoredItem.value);\n                }\n            } else {\n                repeated += 1;\n                if (repeated === 1) {\n                    warningLog(\n                        \"Receiving a notification for a unknown monitoredItem with clientHandle \",\n                        monitoredItem.clientHandle\n                    );\n                }\n            }\n        }\n        // istanbul ignore next\n        if (repeated > 1) {\n            warningLog(\"previous message repeated\", repeated, \"times\");\n        }\n    }\n\n    private __on_publish_response_StatusChangeNotification(notification: StatusChangeNotification) {\n        assert(notification.schema.name === \"StatusChangeNotification\");\n\n        debugLog(\"Client has received a Status Change Notification \", notification.status.toString());\n\n        if (notification.status === StatusCodes.GoodSubscriptionTransferred) {\n            // OPCUA UA Spec 1.0.3 : part 3 - page 82 - 5.13.7 TransferSubscriptions:\n            // If the Server transfers the Subscription to the new Session, the Server shall issue\n            // a StatusChangeNotification  notificationMessage with the status code\n            // Good_SubscriptionTransferred to the old Session.\n            debugLog(\"ClientSubscription#__on_publish_response_StatusChangeNotification : GoodSubscriptionTransferred\");\n\n            // may be it has been transferred after a reconnection.... in this case should do nothing about it\n        }\n        if (notification.status === StatusCodes.BadTimeout) {\n            // the server tells use that the subscription has timed out ..\n            // this mean that this subscription has been closed on the server side and cannot process any\n            // new PublishRequest.\n            //\n            // from Spec OPCUA Version 1.03 Part 4 - 5.13.1.1 Description : Page 69:\n            //\n            // h. Subscriptions have a lifetime counter that counts the number of consecutive publishing cycles in\n            //    which there have been no Publish requests available to send a Publish response for the\n            //    Subscription. Any Service call that uses the SubscriptionId or the processing of a Publish\n            //    response resets the lifetime counter of this Subscription. When this counter reaches the value\n            //    calculated for the lifetime of a Subscription based on the MaxKeepAliveCount parameter in the\n            //    CreateSubscription Service (5.13.2), the Subscription is closed. Closing the Subscription causes\n            //    its MonitoredItems to be deleted. In addition the Server shall issue a StatusChangeNotification\n            //    notificationMessage with the status code BadTimeout.\n            //\n            this.hasTimedOut = true;\n            this.terminate(() => {\n                /* empty */\n            });\n        }\n        /**\n         * notify the observers that the server has send a status changed notification (such as BadTimeout )\n         * @event status_changed\n         */\n        this.emit(\"status_changed\", notification.status, notification.diagnosticInfo);\n    }\n\n    private __on_publish_response_EventNotificationList(notification: EventNotificationList) {\n        assert(notification.schema.name === \"EventNotificationList\");\n        const events = notification.events || [];\n        for (const event of events) {\n            const monitorItemObj = this.monitoredItems[event.clientHandle];\n            assert(monitorItemObj, \"Expecting a monitored item\");\n\n            const monitoredItemImpl = monitorItemObj as ClientMonitoredItemImpl;\n            monitoredItemImpl._notify_event(event.eventFields || []);\n        }\n    }\n\n    public onNotificationMessage(notificationMessage: NotificationMessage): void {\n        assert(Object.prototype.hasOwnProperty.call(notificationMessage, \"sequenceNumber\"));\n\n        this.lastSequenceNumber = notificationMessage.sequenceNumber;\n\n        this.emit(\"raw_notification\", notificationMessage);\n\n        const notificationData = (notificationMessage.notificationData || []) as NotificationData[];\n\n        if (notificationData.length === 0) {\n            // this is a keep alive message\n            debugLog(chalk.yellow(\"Client : received a keep alive notification from client\"));\n            /**\n             * notify the observers that a keep alive Publish Response has been received from the server.\n             * @event keepalive\n             */\n            this.emit(\"keepalive\");\n        } else {\n            /**\n             * notify the observers that some notifications has been received from the server in  a PublishResponse\n             * each modified monitored Item\n             * @event  received_notifications\n             */\n            this.emit(\"received_notifications\", notificationMessage);\n            // let publish a global event\n\n            promoteOpaqueStructureInNotificationData(this.session, notificationData).then(() => {\n                // now process all notifications\n                for (const notification of notificationData) {\n                    // istanbul ignore next\n                    if (!notification) {\n                        continue;\n                    }\n\n                    // DataChangeNotification / StatusChangeNotification / EventNotification\n                    switch (notification.schema.name) {\n                        case \"DataChangeNotification\":\n                            // now inform each individual monitored item\n                            this.__on_publish_response_DataChangeNotification(notification as DataChangeNotification);\n                            break;\n                        case \"StatusChangeNotification\":\n                            this.__on_publish_response_StatusChangeNotification(notification as StatusChangeNotification);\n                            break;\n                        case \"EventNotificationList\":\n                            this.__on_publish_response_EventNotificationList(notification as EventNotificationList);\n                            break;\n                        default:\n                            warningLog(\" Invalid notification :\", notification.toString());\n                    }\n                }\n            });\n        }\n    }\n\n    private _terminate_step2(callback: (err?: Error) => void) {\n        const monitoredItems = Object.values(this.monitoredItems);\n        for (const monitoredItem of monitoredItems) {\n            this._remove(monitoredItem);\n        }\n\n        const monitoredItemGroups = this.monitoredItemGroups;\n        for (const monitoredItemGroup of monitoredItemGroups) {\n            this._removeGroup(monitoredItemGroup);\n        }\n\n        assert(Object.values(this.monitoredItems).length === 0);\n\n        setImmediate(() => {\n            /**\n             * notify the observers that the client subscription has terminated\n             * @event  terminated\n             */\n            this.subscriptionId = TERMINATED_SUBSCRIPTION_ID;\n            this.emit(\"terminated\");\n            callback();\n        });\n    }\n\n    private _remove(monitoredItem: ClientMonitoredItemBase) {\n        const clientHandle = monitoredItem.monitoringParameters.clientHandle;\n        assert(clientHandle > 0);\n        if (!Object.prototype.hasOwnProperty.call(this.monitoredItems, clientHandle)) {\n            return; // may be monitoredItem failed to be created  ....\n        }\n        assert(Object.prototype.hasOwnProperty.call(this.monitoredItems, clientHandle));\n\n        const priv = monitoredItem as ClientMonitoredItemImpl;\n        priv._terminate_and_emit();\n    }\n\n    public _removeGroup(monitoredItemGroup: ClientMonitoredItemGroup): void {\n        (monitoredItemGroup as any)._terminate_and_emit();\n        this.monitoredItemGroups = this.monitoredItemGroups.filter((obj) => obj !== monitoredItemGroup);\n    }\n    /**\n     * @private\n     * @param itemToMonitor\n     * @param monitoringParameters\n     * @param timestampsToReturn\n     */\n    public _createMonitoredItem(\n        itemToMonitor: ReadValueIdOptions,\n        monitoringParameters: MonitoringParametersOptions,\n        timestampsToReturn: TimestampsToReturn,\n        monitoringMode: MonitoringMode = MonitoringMode.Reporting\n    ): ClientMonitoredItem {\n        /* istanbul ignore next*/\n        const monitoredItem = new ClientMonitoredItemImpl(\n            this,\n            itemToMonitor,\n            monitoringParameters,\n            timestampsToReturn,\n            monitoringMode\n        );\n        return monitoredItem;\n    }\n}\n\nexport function ClientMonitoredItem_create(\n    subscription: ClientSubscription,\n    itemToMonitor: ReadValueIdOptions,\n    monitoringParameters: MonitoringParametersOptions,\n    timestampsToReturn: TimestampsToReturn,\n    monitoringMode: MonitoringMode = MonitoringMode.Reporting,\n    callback?: (err3?: Error | null, monitoredItem?: ClientMonitoredItem) => void\n): ClientMonitoredItem {\n    const monitoredItem = new ClientMonitoredItemImpl(\n        subscription,\n        itemToMonitor,\n        monitoringParameters,\n        timestampsToReturn,\n        monitoringMode\n    );\n\n    setImmediate(() => {\n        (subscription as ClientSubscriptionImpl)._wait_for_subscription_to_be_ready((err?: Error) => {\n            if (err) {\n                if (callback) {\n                    callback(err);\n                }\n                return;\n            }\n            ClientMonitoredItemToolbox._toolbox_monitor(subscription, timestampsToReturn, [monitoredItem], (err1?: Error) => {\n                if (err1) {\n                    monitoredItem._terminate_and_emit(err1);\n                }\n                if (callback) {\n                    callback(err1, monitoredItem);\n                }\n            });\n        });\n    });\n    return monitoredItem;\n}\n// tslint:disable:no-var-requires\n// tslint:disable:max-line-length\nconst thenify = require(\"thenify\");\nconst opts = { multiArgs: false };\n\nClientSubscriptionImpl.prototype.setPublishingMode = thenify.withCallback(ClientSubscriptionImpl.prototype.setPublishingMode);\nClientSubscriptionImpl.prototype.monitor = thenify.withCallback(ClientSubscriptionImpl.prototype.monitor);\nClientSubscriptionImpl.prototype.monitorItems = thenify.withCallback(ClientSubscriptionImpl.prototype.monitorItems);\nClientSubscriptionImpl.prototype.setTriggering = thenify.withCallback(ClientSubscriptionImpl.prototype.setTriggering);\nClientSubscriptionImpl.prototype.modify = thenify.withCallback(ClientSubscriptionImpl.prototype.modify);\nClientSubscriptionImpl.prototype.recreateSubscriptionAndMonitoredItem = thenify.withCallback(\n    ClientSubscriptionImpl.prototype.recreateSubscriptionAndMonitoredItem\n);\nClientSubscriptionImpl.prototype.terminate = thenify.withCallback(ClientSubscriptionImpl.prototype.terminate);\nClientSubscriptionImpl.prototype.getMonitoredItems = thenify.withCallback(ClientSubscriptionImpl.prototype.getMonitoredItems);\n\nClientSubscription.create = (clientSession: ClientSession, options: ClientSubscriptionOptions) => {\n    return new ClientSubscriptionImpl(clientSession, options);\n};\n", "// tslint:disable: no-console\nimport * as fs from \"fs\";\nimport * as os from \"os\";\nimport { promisify } from \"util\";\nimport * as should from \"should\";\nimport * as async from \"async\";\n\nimport { assert } from \"node-opcua-assert\";\n\nimport {\n    OPCUAServer,\n    OPCUAClient,\n    ApplicationType,\n    findServers,\n    findServersOnNetwork,\n    RegisterServerResponse,\n    RegisterServerRequest,\n    StatusCodes,\n    RegisterServerMethod,\n    makeApplicationUrn,\n    OPCUADiscoveryServer,\n    ServiceFault\n} from \"node-opcua\";\nimport { readCertificate, exploreCertificate } from \"node-opcua-crypto\";\nimport { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\n\nimport { createServerCertificateManager } from \"../../test_helpers/createServerCertificateManager\";\nimport { createServerThatRegistersItselfToTheDiscoveryServer, ep, pause, startDiscovery } from \"./_helper\";\n\nconst debugLog = make_debugLog(\"TEST\");\nconst doDebug = checkDebugFlag(\"TEST\");\n\nconst port0 = 2500;\nconst port1 = 2501;\nconst port2 = 2502;\nconst port3 = 2503;\nconst port4 = 2504;\nconst port5 = 2505;\nconst port_discovery = 2516;\n// add the tcp/ip endpoint with no security\n\nprocess.on(\"uncaughtException\", (err) => {\n    console.log(err);\n});\n\n// tslint:disable-next-line: no-var-requires\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\nexport function t(test: any) {\n    describe(\"DISCO1 - DiscoveryServer1\", function (this: any) {\n        this.timeout(30 * 1000);\n\n        let discovery_server: OPCUADiscoveryServer | undefined;\n        let discoveryServerEndpointUrl: string;\n        let server: OPCUAServer | undefined;\n\n        before(async () => {\n            server = new OPCUAServer({\n                port: port0,\n                serverCertificateManager: this.serverCertificateManager\n            });\n\n            await server.initialize();\n            await server.initializeCM();\n        });\n\n        after(async () => {\n            await server!.shutdown();\n            server = undefined;\n        });\n\n        beforeEach(async () => {\n            discovery_server = new OPCUADiscoveryServer({\n                port: port_discovery,\n                serverCertificateManager: this.discoveryServerCertificateManager\n            });\n            await discovery_server.start();\n            discoveryServerEndpointUrl = discovery_server.getEndpointUrl();\n            debugLog(\" discovery_server_endpointUrl = \", discoveryServerEndpointUrl);\n        });\n\n        afterEach(async () => {\n            await discovery_server!.shutdown();\n            discovery_server = undefined;\n        });\n\n        async function send_registered_server_request(\n            discoveryServerEndpointUrl: string,\n            registerServerRequest: any,\n            externalFunc: any\n        ): Promise<void> {\n            const client = OPCUAClient.create({\n                endpointMustExist: false\n            });\n            client.on(\"backoff\", () => {\n                console.log(\"cannot connect to \" + discoveryServerEndpointUrl);\n            });\n\n            await client.connect(discoveryServerEndpointUrl);\n\n            await new Promise<void>((resolve) => {\n                (client as any).performMessageTransaction(\n                    registerServerRequest,\n                    (err: Error | null, response: RegisterServerResponse) => {\n                        if (!err) {\n                            // RegisterServerResponse\n                            assert(response instanceof RegisterServerResponse);\n                        }\n                        externalFunc(err, response);\n                        resolve();\n                    }\n                );\n            });\n            await client.disconnect();\n        }\n\n        it(\"DISCO1-1 should fail to register server if discovery url is not specified (Bad_DiscoveryUrlMissing)\", async () => {\n            const request = new RegisterServerRequest({\n                server: {\n                    // The globally unique identifier for the Server instance. The serverUri matches\n                    // the applicationUri from the ApplicationDescription defined in 7.1.\n                    serverUri: \"uri:MyServerURI\",\n\n                    // The globally unique identifier for the Server product.\n                    productUri: \"productUri\",\n\n                    serverNames: [{ text: \"some name\" }],\n\n                    serverType: ApplicationType.Server,\n                    gatewayServerUri: null,\n                    discoveryUrls: [], // INTENTIONALLY EMPTY\n                    semaphoreFilePath: null,\n                    isOnline: false\n                }\n            });\n\n            function check_error_response(err: Error | null, response: any): void {\n                should.exist(err);\n                should.not.exist(response);\n                (err as any).response.should.be.instanceOf(ServiceFault);\n                //xx console.log(response.toString());\n                (err as any).response.responseHeader.serviceResult.should.eql(StatusCodes.BadDiscoveryUrlMissing);\n            }\n\n            await send_registered_server_request(discoveryServerEndpointUrl, request, check_error_response);\n        });\n\n        it(\"DISCO1-2 should fail to register server to the discover server if server type is Client (BadInvalidArgument)\", async () => {\n            const request = new RegisterServerRequest({\n                server: {\n                    // The globally unique identifier for the Server instance. The serverUri matches\n                    // the applicationUri from the ApplicationDescription defined in 7.1.\n                    serverUri: \"uri:MyServerURI\",\n\n                    // The globally unique identifier for the Server product.\n                    productUri: \"productUri\",\n\n                    serverNames: [{ text: \"some name\" }],\n\n                    serverType: ApplicationType.Client, /// CLIENT HERE !!!\n                    gatewayServerUri: null,\n                    discoveryUrls: [],\n                    semaphoreFilePath: null,\n                    isOnline: false\n                }\n            });\n\n            function check_error_response(err: Error | null, response: any) {\n                should.exist(err);\n                should.not.exist(response);\n                //xx debugLog(response.toString());\n                (err as any).response.should.be.instanceOf(ServiceFault);\n                (err as any).response.responseHeader.serviceResult.should.eql(StatusCodes.BadInvalidArgument);\n            }\n\n            await send_registered_server_request(discoveryServerEndpointUrl, request, check_error_response);\n        });\n\n        it(\"DISCO1-3 should fail to register server to the discover server if server name array is empty (BadServerNameMissing)\", async () => {\n            const request = new RegisterServerRequest({\n                server: {\n                    // The globally unique identifier for the Server instance. The serverUri matches\n                    // the applicationUri from the ApplicationDescription defined in 7.1.\n                    serverUri: \"uri:MyServerURI\",\n\n                    // The globally unique identifier for the Server product.\n                    productUri: \"productUri\",\n\n                    serverNames: [], /// <<<<< INTENTIONALLY EMPTY\n\n                    serverType: ApplicationType.Server,\n                    gatewayServerUri: null,\n                    discoveryUrls: [],\n                    semaphoreFilePath: null,\n                    isOnline: false\n                }\n            });\n\n            function check_error_response(err: Error | null, response: any) {\n                should.exist(err);\n                should.not.exist(response);\n                (err as any).response.should.be.instanceOf(ServiceFault);\n                (err as any).response.responseHeader.serviceResult.should.eql(StatusCodes.BadServerNameMissing);\n            }\n\n            await send_registered_server_request(discoveryServerEndpointUrl, request, check_error_response);\n        });\n    });\n\n    describe(\"DISCO2 - DiscoveryServer2\", function (this: any) {\n        this.timeout(Math.max(40 * 1000, this.timeout()));\n\n        let discoveryServer: OPCUADiscoveryServer;\n        let discoveryServerEndpointUrl: string;\n        let server: OPCUAServer;\n\n        before(() => {\n            OPCUAServer.registry.count().should.eql(0);\n            1162;\n        });\n\n        after(() => {\n            OPCUAServer.registry.count().should.eql(0);\n        });\n        beforeEach(async () => {\n            discoveryServer = new OPCUADiscoveryServer({\n                port: port_discovery,\n                serverCertificateManager: this.discoveryServerCertificateManager\n            });\n            await discoveryServer.start();\n            discoveryServerEndpointUrl = discoveryServer.getEndpointUrl()!;\n            if (doDebug) {\n                console.log(discoveryServerEndpointUrl);\n            }\n        });\n\n        afterEach(async () => {\n            await discoveryServer.shutdown();\n        });\n\n        async function addServerCertificateToTrustedCertificateInDiscoveryServer(server: OPCUAServer) {\n            const filename = server.certificateFile;\n            fs.existsSync(filename).should.eql(true, \" the server certficate file \" + filename + \" should exist\");\n            const certificate = readCertificate(filename);\n            await discoveryServer.serverCertificateManager.trustCertificate(certificate);\n        }\n\n        it(\"DISCO2-1 should register server to the discover server 2\", async () => {\n            const applicationUri = makeApplicationUrn(os.hostname(), \"NodeOPCUA-Server\");\n\n            // there should be no endpoint exposed by an blank discovery server\n            discoveryServer.registeredServerCount.should.equal(0);\n            let initialServerCount = 0;\n\n            // ----------------------------------------------------------------------------\n            const data = await findServers(discoveryServerEndpointUrl);\n            debugLog(\"data = \", data);\n            const { servers, endpoints } = data;\n            initialServerCount = servers.length;\n            servers[0].discoveryUrls!.length.should.eql(1);\n\n            debugLog(\" initialServerCount = \", initialServerCount);\n            debugLog(\"servers[0].discoveryUrls\", servers[0].discoveryUrls!.join(\"\\n\"));\n\n            const serverCertificateManager = await createServerCertificateManager(port1);\n            // ----------------------------------------------------------------------------\n            server = new OPCUAServer({\n                port: port1,\n                registerServerMethod: RegisterServerMethod.LDS,\n                discoveryServerEndpointUrl,\n                serverCertificateManager,\n                serverInfo: {\n                    applicationName: { text: \"NodeOPCUA\", locale: \"en\" },\n                    applicationUri,\n                    productUri: \"NodeOPCUA-Server\",\n                    discoveryProfileUri: null,\n                    discoveryUrls: [],\n                    gatewayServerUri: null\n                }\n            });\n\n            await server.initialize();\n            await server.initializeCM();\n\n            await addServerCertificateToTrustedCertificateInDiscoveryServer(server);\n\n            await server.start();\n\n            // server registration takes place in parallel and should be checked independently\n            await new Promise<void>((resolve) => {\n                server.once(\"serverRegistered\", () => {\n                    resolve();\n                });\n            });\n\n            // ----------------------------------------------------------------------------\n            discoveryServer.registeredServerCount.should.equal(1);\n\n            {\n                const data = await findServers(discoveryServerEndpointUrl);\n                const { servers, endpoints } = data;\n                //xx debugLog(servers[0].toString());\n                servers.length.should.eql(initialServerCount + 1);\n                servers[1].applicationUri!.should.eql(applicationUri);\n            }\n\n            // ----------------------------------------------------------------------------\n            await server.shutdown();\n\n            // ----------------------------------------------------------------------------\n            {\n                const { servers, endpoints } = await findServers(discoveryServerEndpointUrl);\n                servers.length.should.eql(initialServerCount);\n            }\n        });\n    });\n\n    describe(\"DISCO3 - DiscoveryServer3 - many server\", function (this: any) {\n        this.timeout(200000);\n\n        let discoveryServer: OPCUADiscoveryServer;\n        let discoveryServerEndpointUrl: string;\n\n        let server1: OPCUAServer;\n        let server2: OPCUAServer;\n        let server3: OPCUAServer;\n        let server4: OPCUAServer;\n        let server5: OPCUAServer;\n\n        discoveryServerEndpointUrl = `opc.tcp://localhost:${port_discovery}`; // discovery_server.endpoint[0].endpointUrl;\n\n        before(async () => {\n            OPCUAServer.registry.count().should.eql(0);\n            server1 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port1, \"AA\");\n            server2 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port2, \"BB\");\n            server3 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port3, \"CC\");\n            server4 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port4, \"DD\");\n            server5 = await createServerThatRegistersItselfToTheDiscoveryServer(discoveryServerEndpointUrl, port5, \"EE\");\n        });\n\n        after(() => {\n            OPCUAServer.registry.count().should.eql(0);\n        });\n\n        before(async () => {\n            discoveryServer = await startDiscovery(port_discovery);\n            discoveryServerEndpointUrl = ep(discoveryServer);\n        });\n\n        after(async () => {\n            await discoveryServer.shutdown();\n        });\n\n        let registeredServerCount = 0;\n\n        async function checkServerCertificateAgainsLDS(server: OPCUAServer) {\n            const certificate = await server.getCertificate();\n            const certificateInfo = await exploreCertificate(certificate);\n            if (doDebug) {\n                console.log(certificateInfo);\n            }\n            const statusBefore = await discoveryServer.serverCertificateManager.verifyCertificate(certificate);\n            if (doDebug) {\n                console.log(\"statusBefore = \", statusBefore);\n            }\n\n            await discoveryServer.serverCertificateManager.trustCertificate(certificate);\n\n            const statusAfter = await discoveryServer.serverCertificateManager.verifyCertificate(certificate);\n            if (doDebug) {\n                console.log(\"statusAfter = \", statusAfter);\n            }\n            statusAfter.should.eql(\"Good\");\n        }\n\n        function start_all_servers(done: () => void) {\n            registeredServerCount = 0;\n\n            async.parallel(\n                [\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server1\");\n                        server1.start(callback);\n                        server1.once(\"serverRegistered\", () => {\n                            debugLog(\"server1 registered\");\n                            registeredServerCount += 1;\n                        });\n                    },\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server2\");\n                        server2.start(callback);\n                        server2.once(\"serverRegistered\", () => {\n                            debugLog(\"server2 registered\");\n                            registeredServerCount += 1;\n                        });\n                    },\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server3\");\n                        server3.start(callback);\n                        server3.once(\"serverRegistered\", () => {\n                            debugLog(\"server3 registered\");\n                            registeredServerCount += 1;\n                        });\n                    },\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server4\");\n                        server4.start(callback);\n                        server4.once(\"serverRegistered\", () => {\n                            debugLog(\"server4 registered\");\n                            registeredServerCount += 1;\n                        });\n                    },\n                    function (callback: () => void) {\n                        debugLog(\"Starting  server5\");\n                        server5.start(callback);\n                        server5.once(\"serverRegistered\", () => {\n                            debugLog(\"server5 registered\");\n                            registeredServerCount += 1;\n                        });\n                    }\n                ],\n                done\n            );\n        }\n\n        function stop_all_servers(done: () => void) {\n            async.parallel(\n                [\n                    function (callback: () => void) {\n                        server1.shutdown(callback);\n                    },\n                    function (callback: () => void) {\n                        server2.shutdown(callback);\n                    },\n                    function (callback: () => void) {\n                        server3.shutdown(callback);\n                    },\n                    function (callback: () => void) {\n                        server4.shutdown(callback);\n                    },\n                    function (callback: () => void) {\n                        server5.shutdown(callback);\n                    }\n                ],\n                done\n            );\n        }\n        const start_all_serversAsync = promisify(start_all_servers);\n        const stop_all_serversAsync = promisify(stop_all_servers);\n\n        it(\"DISCO3-1 checking certificates\", async () => {\n            await checkServerCertificateAgainsLDS(server1);\n            await checkServerCertificateAgainsLDS(server2);\n            await checkServerCertificateAgainsLDS(server3);\n            await checkServerCertificateAgainsLDS(server4);\n            console.log(\"done\");\n        });\n\n        function wait_until_all_servers_registered_iter(expectedCount: number, resolve: () => void) {\n            console.log(\"waiting for all servers to be registered \", registeredServerCount, \"expected\", expectedCount);\n            if (registeredServerCount === expectedCount) {\n                return resolve();\n            }\n            setTimeout(wait_until_all_servers_registered_iter, 500, expectedCount, resolve);\n        }\n\n        async function wait_until_all_servers_registered(expectedCount: number): Promise<void> {\n            return new Promise<void>((resolve) => {\n                wait_until_all_servers_registered_iter(expectedCount, resolve);\n            });\n        }\n\n        it(\"DISCO3-2 a discovery server shall be able to expose many registered servers\", async () => {\n            await start_all_serversAsync();\n\n            await wait_until_all_servers_registered(5);\n\n            discoveryServer.registeredServerCount.should.equal(5);\n\n            await pause(1000);\n\n            const { servers, endpoints } = await findServers(discoveryServerEndpointUrl);\n            if (doDebug) {\n                for (const s of servers) {\n                    debugLog(s.applicationUri, s.productUri, ApplicationType[s.applicationType], s.discoveryUrls![0]);\n                }\n            }\n            servers.length.should.eql(6); // 5 server + 1 discovery server\n\n            // servers[1].applicationUri.should.eql(\"urn:NodeOPCUA-Server\");\n            await pause(1000);\n            {\n                const servers = await findServersOnNetwork(discoveryServerEndpointUrl);\n                if (servers!.length !== 6) {\n                    for (const s of servers!) {\n                        console.log(s.toString());\n                    }\n                }\n                servers!.length.should.eql(\n                    6,\n                    \"found \" +\n                        servers!.length +\n                        \" server running instead of 6: may be you have a LDS running on your system. please make sure to shut it down before running the tests\"\n                ); // 5 server + 1 discovery server\n                // servers[1].applicationUri.should.eql(\"urn:NodeOPCUA-Server\");\n            }\n\n            await stop_all_serversAsync();\n        });\n    });\n}\n", "\nconst should = require(\"should\");\nconst { assert } = require(\"node-opcua-assert\");\nconst async = require(\"async\");\nconst util = require(\"util\");\n\nconst {\n    resolveNodeId,\n    OPCUAClient,\n    StatusCodes,\n    BrowseDirection,\n    BrowseRequest, \n    BrowseNextRequest, \n    BrowseDescription\n} = require(\"node-opcua\");\n\nconst { make_debugLog, checkDebugFlag } = require(\"node-opcua-debug\");\nconst debugLog = make_debugLog(\"TEST\");\nconst doDebug = checkDebugFlag(\"TEST\");\n\n\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\nmodule.exports = function(test) {\n\n    describe(\"Test Browse Request\", function() {\n\n        let client, endpointUrl;\n\n        let g_session = null;\n        beforeEach(function(done) {\n\n            endpointUrl = test.endpointUrl;\n\n            client = OPCUAClient.create();\n            client.connect(endpointUrl, function(err) {\n                if (err) {\n                    done(err);\n                }\n                else {\n                    client.createSession(function(err, session) {\n                        g_session = session;\n                        done(err);\n                    });\n                }\n            });\n\n        });\n\n        afterEach(function(done) {\n            g_session.close(function() {\n                client.disconnect(done);\n            });\n        });\n\n        it(\"T1 - #Browse should return BadNothingToDo if nodesToBrowse is empty \", function(done) {\n\n            const browseRequest = new BrowseRequest({\n                nodesToBrowse: []\n            });\n            g_session.performMessageTransaction(browseRequest, function(err, result) {\n                err.message.should.match(/BadNothingToDo/);\n                // todo\n                done();\n            });\n\n        });\n\n        it(\"T2 - #Browse should return BadViewIdInvalid if viewId is invalid\", function(done) {\n\n            const browseDesc = {\n                nodeId: resolveNodeId(\"RootFolder\"),\n                referenceTypeId: null,\n                browseDirection: BrowseDirection.Forward\n            };\n\n            const browseRequest = new BrowseRequest({\n                view: {\n                    viewId: 'ns=1256;i=1' //<< invalid viewId\n                },\n                nodesToBrowse: [browseDesc]\n            });\n            g_session.performMessageTransaction(browseRequest, function(err, result) {\n                err.message.should.match(/BadViewIdUnknown/);\n                done();\n            });\n        });\n\n        it(\"T3 - #Browse should return BadViewUnknown if object referenced by viewId is not a view\", function(done) {\n\n            const browseDesc = {\n                nodeId: resolveNodeId(\"RootFolder\"),\n                referenceTypeId: null,\n                browseDirection: BrowseDirection.Forward\n            };\n\n            const browseRequest = new BrowseRequest({\n                view: {\n                    viewId: 'ns=0;i=85',\n                },\n                nodesToBrowse: [browseDesc]\n            });\n            g_session.performMessageTransaction(browseRequest, function(err, result) {\n                // todo\n                err.message.should.match(/BadViewIdUnknown/);\n                done();\n            });\n        });\n\n        it(\"T4 - #Browse server should respect Browse maxReferencesPerNode \", function(done) {\n\n            const browseDesc = {\n                nodeId: resolveNodeId(\"RootFolder\"),\n                referenceTypeId: null,\n                includeSubtypes: true,\n                browseDirection: BrowseDirection.Both,\n                resultMask: 63\n            };\n\n            async.series([\n\n                function(callback) {\n                    const browseRequest1 = new BrowseRequest({\n                        view: null,//{ viewId: 'ns=0;i=85'},\n                        requestedMaxReferencesPerNode: 10,\n                        nodesToBrowse: [browseDesc]\n                    });\n                    g_session.performMessageTransaction(browseRequest1, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        // console.log(response.toString());\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.greaterThan(3);\n                        should(response.results[0].continuationPoint).eql(null);\n                        callback();\n                    });\n                },\n                function(callback) {\n                    const browseRequest2 = new BrowseRequest({\n                        view: null,//{ viewId: 'ns=0;i=85'},\n                        requestedMaxReferencesPerNode: 1,\n                        nodesToBrowse: [browseDesc]\n                    });\n                    g_session.performMessageTransaction(browseRequest2, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        //xx console.log(response.toString());\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.eql(1);\n                        should.exist(response.results[0].continuationPoint);\n                        callback();\n                    });\n                }\n            ], done);\n\n\n        });\n\n        it(\"T5 - #BrowseNext response should have serviceResult=BadNothingToDo if request have no continuationPoints\", function(done) {\n            async.series([\n\n                function(callback) {\n                    const browseNextRequest = new BrowseNextRequest({\n                        continuationPoints: null\n                    });\n                    g_session.performMessageTransaction(browseNextRequest, function(err, _response) {\n                        err.message.should.match(/BadNothingToDo/);\n                        // console.log(response.toString());\n                        err.response.responseHeader.serviceResult.should.equal(StatusCodes.BadNothingToDo);\n                        callback();\n                    });\n                }\n            ], done);\n        });\n        it(\"T6 - #BrowseNext response \", function(done) {\n            const browseDesc = {\n                nodeId: resolveNodeId(\"RootFolder\"),\n                referenceTypeId: null,\n                includeSubtypes: true,\n                browseDirection: BrowseDirection.Both,\n                resultMask: 63\n            };\n\n            let allReferences;\n            let continuationPoint;\n            async.series([\n\n                function(callback) {\n                    const browseRequest1 = new BrowseRequest({\n                        view: null,//{ viewId: 'ns=0;i=85'},\n                        requestedMaxReferencesPerNode: 10,\n                        nodesToBrowse: [browseDesc]\n                    });\n                    g_session.performMessageTransaction(browseRequest1, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        // console.log(response.toString());\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.greaterThan(3); // want 4 at lest\n                        should.not.exist(response.results[0].continuationPoint);\n                        allReferences = response.results[0].references;\n                        callback();\n                    });\n                },\n\n                function(callback) {\n                    const browseRequest2 = new BrowseRequest({\n                        view: null,//{ viewId: 'ns=0;i=85'},\n                        requestedMaxReferencesPerNode: 2,\n                        nodesToBrowse: [browseDesc]\n                    });\n                    g_session.performMessageTransaction(browseRequest2, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        //xx console.log(response.toString());\n\n                        response.results.length.should.eql(1);\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.eql(2);\n                        should.exist(response.results[0].continuationPoint);\n                        response.results[0].references[0].should.eql(allReferences[0]);\n                        response.results[0].references[1].should.eql(allReferences[1]);\n\n                        continuationPoint = response.results[0].continuationPoint;\n\n                        callback();\n                    });\n                },\n\n                function(callback) {\n                    const browseNextRequest = new BrowseNextRequest({\n                        continuationPoints: [continuationPoint],\n                        //xx                    releaseContinuationPoints: true\n                    });\n                    g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        // console.log(response.toString());\n                        response.responseHeader.serviceResult.should.equal(StatusCodes.Good);\n\n                        response.results.length.should.eql(1);\n                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n                        response.results[0].references.length.should.be.eql(2);\n\n                        // this is last request\n                        should.not.exist(response.results[0].continuationPoint);\n\n                        response.results[0].references[0].should.eql(allReferences[2]);\n                        response.results[0].references[1].should.eql(allReferences[3]);\n\n                        callback();\n\n                    });\n\n                },\n\n                // we reach the end of the sequence. continuationPoint shall not be usable anymore\n                function(callback) {\n                    const browseNextRequest = new BrowseNextRequest({\n                        continuationPoints: [continuationPoint],\n                        releaseContinuationPoints: true\n                    });\n                    g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        // console.log(response.toString());\n                        response.responseHeader.serviceResult.should.equal(StatusCodes.Good);\n                        response.results.length.should.eql(1);\n                        response.results[0].statusCode.should.eql(StatusCodes.BadContinuationPointInvalid);\n                        callback();\n                    });\n                }\n\n\n            ], done);\n\n        });\n\n        const IT = test.server ? it : xit;\n        IT(\"T7 - #BrowseNext with releaseContinuousPoint set to false then set to true\", function(done) {\n            /*\n             * inspired by    Test 5.7.2-9 prepared by Dale Pope dale.pope@matrikon.com\n             * Description:\n             *   Given one node to browse\n             *     And the node exists\n             *     And the node has at least three references of the same ReferenceType's subtype\n             *     And RequestedMaxReferencesPerNode is 1\n             *     And ReferenceTypeId is set to a ReferenceType NodeId\n             *     And IncludeSubtypes is true\n             *     And Browse has been called\n             *  When BrowseNext is called\n             *     And ReleaseContinuationPoints is false\n             *  Then the server returns the second reference\n             *     And ContinuationPoint is not empty\n             *     Validation is accomplished by first browsing all references of a type\n             *     on a node, then performing the test and comparing the second\n             *     reference to the reference returned by the BrowseNext call. So this\n             *     test only validates that Browse two references is consistent with\n             *     Browse one reference followed by BrowseNext.\n             */\n\n            function test_5_7_2__9(nodeId, done) {\n\n                //     And RequestedMaxReferencesPerNode is 1\n                //     And ReferenceTypeId is set to a ReferenceType NodeId\n                //     And IncludeSubtypes is true\n                //     And Browse has been called\n\n                //  Given one node to browse\n                nodeId = resolveNodeId(nodeId);\n                //     And the node exists\n                const obj = test.server.engine.addressSpace.findNode(nodeId, BrowseDirection.Forward);\n                should.exist(obj);\n\n                const browseDesc = new BrowseDescription({\n                    nodeId: nodeId,\n                    referenceTypeId: \"i=47\", // HasComponents\n                    includeSubtypes: true,\n                    browseDirection: BrowseDirection.Forward,\n                    resultMask: 63\n                });\n\n\n                let continuationPoint;\n\n                let allReferences;\n\n                async.series([\n\n                    // browse all references\n                    function(callback) {\n                        const browseRequestAll = new BrowseRequest({\n                            view: null,//{ viewId: 'ns=0;i=85'},\n                            requestedMaxReferencesPerNode: 10,\n                            nodesToBrowse: [browseDesc]\n                        });\n                        g_session.performMessageTransaction(browseRequestAll, function(err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            // console.log(response.toString());\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].references.length.should.be.greaterThan(3); // want 4 at lest\n                            should.not.exist(response.results[0].continuationPoint);\n                            allReferences = response.results[0].references;\n                            callback();\n                        });\n                    },\n\n                    function(callback) {\n\n                        const browseRequest1 = new BrowseRequest({\n                            view: null,\n                            requestedMaxReferencesPerNode: 1,\n                            nodesToBrowse: [browseDesc]\n                        });\n\n                        g_session.performMessageTransaction(browseRequest1, function(err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            //xx console.log(response.toString());\n\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].references.length.should.be.eql(1);\n                            should.exist(response.results[0].continuationPoint);\n                            response.results[0].references[0].should.eql(allReferences[0]);\n                            continuationPoint = response.results[0].continuationPoint;\n                            callback();\n                        });\n                    },\n\n                    function(callback) {\n                        const browseNextRequest = new BrowseNextRequest({\n                            releaseContinuationPoints: false,\n                            continuationPoints: [continuationPoint]\n                        });\n                        g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            // console.log(response.toString());\n                            response.responseHeader.serviceResult.should.equal(StatusCodes.Good);\n\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].references.length.should.be.eql(1);\n\n                            // continuation point should not be null\n                            should.exist(response.results[0].continuationPoint);\n                            response.results[0].references[0].should.eql(allReferences[1]);\n                            callback();\n\n                        });\n\n                    },\n                    function(callback) {\n                        const browseNextRequest = new BrowseNextRequest({\n                            releaseContinuationPoints: true,\n                            continuationPoints: [continuationPoint]\n                        });\n                        g_session.performMessageTransaction(browseNextRequest, function(err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            // console.log(response.toString());\n                            response.responseHeader.serviceResult.should.equal(StatusCodes.Good);\n\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].references.length.should.be.eql(0);\n\n                            should.not.exist(response.results[0].continuationPoint);\n                            callback();\n\n                        });\n\n                    },\n\n                ], done);\n\n            }\n\n            test_5_7_2__9(\"ns=0;i=2253\", done);\n\n        })\n\n    });\n};", "/* eslint-disable max-statements */\n\"use strict\";\n\nconst util = require(\"util\");\nconst chalk = require(\"chalk\");\nconst { assert } = require(\"node-opcua-assert\");\nconst async = require(\"async\");\nconst should = require(\"should\");\nconst sinon = require(\"sinon\");\n\nconst {\n    OPCUAClient,\n    ClientSession,\n    ClientSubscription,\n    AttributeIds,\n    resolveNodeId,\n    makeNodeId,\n    StatusCodes,\n    DataType,\n    TimestampsToReturn,\n    MonitoringMode,\n    VariantArrayType,\n    MonitoredItem,\n    ReadValueId,\n    ClientMonitoredItem,\n    CreateSubscriptionRequest,\n    CreateMonitoredItemsResponse,\n    CreateMonitoredItemsRequest,\n    SetMonitoringModeRequest,\n    ModifyMonitoredItemsRequest,\n    MonitoredItemModifyRequest,\n    DeleteMonitoredItemsRequest,\n    ClientMonitoredItemGroup,\n    PublishResponse,\n    PublishRequest,\n    RepublishRequest,\n    RepublishResponse,\n    VariableIds,\n    Variant,\n    Subscription,\n    SubscriptionState,\n    installSessionLogging,\n    ServiceFault\n} = require(\"node-opcua\");\n\nconst { make_debugLog, checkDebugFlag } = require(\"node-opcua-debug\");\n\nconst {\n    perform_operation_on_client_session,\n    perform_operation_on_subscription,\n    perform_operation_on_subscription_with_parameters,\n    perform_operation_on_monitoredItem,\n    perform_operation_on_subscription_async\n} = require(\"../../test_helpers/perform_operation_on_client_session\");\n\nconst debugLog = make_debugLog(\"TEST\");\nconst doDebug = checkDebugFlag(\"TEST\");\n\nconst f = require(\"../../test_helpers/display_function_name\").f.bind(null, doDebug);\n\nfunction trace_console_log() {\n    const log1 = global.console.log;\n    global.console.log = function () {\n        const t = new Error(\"\").stack.split(\"\\n\")[2];\n        if (t.match(/opcua/)) {\n            log1.call(console, chalk.cyan(t));\n        }\n        log1.apply(console, arguments);\n    };\n}\nconst tracelog = (...args) => {\n    const d = new Date();\n    const t = d.toTimeString().split(\" \")[0] + \".\" + d.getMilliseconds().toString().padStart(3, \"0\");\n    console.log.apply(console, [t, ...args]);\n};\n// eslint-disable-next-line import/order\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\nmodule.exports = function (test) {\n    describe(\"AZA1- testing Client-Server subscription use case, on a fake server exposing the temperature device\", function () {\n        let server, client, endpointUrl;\n\n        beforeEach(function (done) {\n            client = OPCUAClient.create({});\n            server = test.server;\n            endpointUrl = test.endpointUrl;\n            done();\n        });\n\n        afterEach(function (done) {\n            client = null;\n            done();\n        });\n\n        it(\"AZA1-A should create a ClientSubscription to manage a subscription\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 5,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        setTimeout(function () {\n                            subscription.terminate(function () {\n                                setTimeout(function () {\n                                    inner_done();\n                                }, 200);\n                            });\n                        }, 200);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA1-B should dump statistics \", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100, // ms\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 5,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        setTimeout(function () {\n                            subscription.terminate(done);\n                        }, 200);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA1-C a ClientSubscription should receive keep-alive events from the server\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    let nb_keep_alive_received = 0;\n\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 10,\n                        maxNotificationsPerPublish: 2,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    const timeout = subscription.publishingInterval * subscription.maxKeepAliveCount;\n\n                    subscription.on(\"started\", function () {\n                        setTimeout(function () {\n                            subscription.terminate(function () {\n                                nb_keep_alive_received.should.be.greaterThan(0);\n                                done();\n                            });\n                        }, timeout * 1.2);\n                    });\n                    subscription.on(\"keepalive\", function () {\n                        nb_keep_alive_received += 1;\n                    });\n                    subscription.on(\"terminated\", function () {\n                        //xx console.log(\" subscription has received \", nb_keep_alive_received, \" keep-alive event(s)\");\n                    });\n                },\n                done\n            );\n        });\n\n        xit(\"AZA1-D a ClientSubscription should survive longer than the life time\", function (done) {\n            // todo\n            done();\n        });\n\n        it(\"AZA1-E should be possible to monitor an nodeId value with a ClientSubscription\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 150,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 2,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    subscription.on(\"started\", () => {\n                        debugLog(\"subscription started\");\n                    });\n\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 50,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(() => {\n                            subscription.terminate(done);\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA1-F should be possible to monitor several nodeId value with a single client subscription\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, callback) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 50,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 2,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    let currentTime_changes = 0;\n                    const monitoredItemCurrentTime = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 20,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItemCurrentTime.on(\"changed\", function (dataValue) {\n                        should.exist(dataValue);\n                        //xx tracelog(\"xxxx current time\", dataValue.value.value);\n                        currentTime_changes++;\n                    });\n\n                    const pumpSpeedId = \"ns=1;b=0102030405060708090a0b0c0d0e0f10\";\n                    const monitoredItemPumpSpeed = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(pumpSpeedId),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 20,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    let pumpSpeed_changes = 0;\n                    monitoredItemPumpSpeed.on(\"changed\", function (dataValue) {\n                        should.exist(dataValue);\n                        // tracelog(\" pump speed \", dataValue.value.value);\n                        pumpSpeed_changes++;\n                    });\n\n                    setTimeout(() => {\n                        pumpSpeed_changes.should.be.greaterThan(1);\n                        currentTime_changes.should.be.greaterThan(1);\n                        subscription.terminate(() => {\n                            callback();\n                        });\n                    }, 2000);\n                },\n                done\n            );\n        });\n\n        it(\"AZA1-G should terminate any pending subscription when the client is disconnected\", function (done) {\n            let the_session;\n\n            async.series(\n                [\n                    // connect\n                    function (callback) {\n                        client.connect(endpointUrl, callback);\n                    },\n\n                    // create session\n                    function (callback) {\n                        client.createSession(function (err, session) {\n                            if (!err) {\n                                the_session = session;\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    // create subscription\n                    function (callback) {\n                        const subscription = ClientSubscription.create(the_session, {\n                            requestedPublishingInterval: 100,\n                            requestedLifetimeCount: 6000,\n                            requestedMaxKeepAliveCount: 100,\n                            maxNotificationsPerPublish: 5,\n                            publishingEnabled: true,\n                            priority: 6\n                        });\n                        subscription.on(\"started\", () => {\n                            const monitoredItem = ClientMonitoredItem.create(\n                                subscription,\n                                {\n                                    nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                                    attributeId: 13\n                                },\n                                {\n                                    samplingInterval: 100,\n                                    discardOldest: true,\n                                    queueSize: 1\n                                }\n                            );\n                            monitoredItem.on(\"initialized\", callback);\n                        });\n                    },\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(() => {\n                            // client.disconnect(done);\n                            callback();\n                        }, 100);\n                    },\n\n                    // now disconnect the client , without closing the subscription first\n                    function (callback) {\n                        client.disconnect(callback);\n                    }\n                ],\n                function (err) {\n                    done(err);\n                }\n            );\n        });\n\n        it(\"AZA1-H should terminate any pending subscription when the client is disconnected twice\", function (done) {\n            let the_session;\n\n            async.series(\n                [\n                    // connect\n                    function (callback) {\n                        client.connect(endpointUrl, callback);\n                    },\n\n                    // create session\n                    function (callback) {\n                        client.createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            the_session = session;\n                            callback();\n                        });\n                    },\n\n                    // create subscription\n                    function (callback) {\n                        const subscription = ClientSubscription.create(the_session, {\n                            requestedPublishingInterval: 100,\n                            requestedLifetimeCount: 6000,\n                            requestedMaxKeepAliveCount: 100,\n                            maxNotificationsPerPublish: 5,\n                            publishingEnabled: true,\n                            priority: 6\n                        });\n                        subscription.on(\"started\", () => {\n                            // monitor some\n                            const monitoredItem = ClientMonitoredItem.create(\n                                subscription,\n                                {\n                                    nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                                    attributeId: 13\n                                },\n                                {\n                                    samplingInterval: 100,\n                                    discardOldest: true,\n                                    queueSize: 1\n                                }\n                            );\n\n                            // note that at this point the monitoredItem has bee declared in the client\n                            // but not created yet on the server side ....\n                            monitoredItem.once(\"initialized\", () => {\n                                callback();\n                            });\n                        });\n                    },\n\n                    // wait a little bit and disconnect client\n                    function (callback) {\n                        setTimeout(() => {\n                            client.disconnect(callback);\n                        }, 600);\n                    },\n\n                    // connect the same client again !!!!\n                    function (callback) {\n                        client.connect(endpointUrl, callback);\n                    },\n\n                    // create session again\n                    function (callback) {\n                        client.createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n\n                            the_session = session;\n                            callback();\n                        });\n                    },\n\n                    // create subscription again\n                    function (callback) {\n                        should.exist(the_session);\n                        const subscription = ClientSubscription.create(the_session, {\n                            requestedPublishingInterval: 100,\n                            requestedLifetimeCount: 6000,\n                            requestedMaxKeepAliveCount: 100,\n                            maxNotificationsPerPublish: 5,\n                            publishingEnabled: true,\n                            priority: 6\n                        });\n                        subscription.on(\"started\", () => {\n                            // monitor some again\n                            const monitoredItem = ClientMonitoredItem.create(\n                                subscription,\n                                {\n                                    nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                                    attributeId: 13\n                                },\n                                {\n                                    samplingInterval: 100,\n                                    discardOldest: true,\n                                    queueSize: 1\n                                }\n                            );\n\n                            monitoredItem.once(\"initialized\", callback);\n                        });\n                    },\n\n                    // now disconnect the client, without terminating the subscription &\n                    // without closing the session first\n                    function (callback) {\n                        setTimeout(() => {\n                            client.disconnect(callback);\n                        }, 400);\n                    }\n                ],\n                function (err) {\n                    done(err);\n                }\n            );\n        });\n    });\n\n    describe(\"AZA2- testing server and subscription\", function () {\n        let server, client, endpointUrl;\n\n        beforeEach(function (done) {\n            server = test.server;\n            //xx server.restart(function() {\n\n            client = OPCUAClient.create();\n            endpointUrl = test.endpointUrl;\n            done();\n            //xx });\n        });\n\n        afterEach(function (done) {\n            client.disconnect(function (err) {\n                client = null;\n                done(err);\n            });\n        });\n\n        //function on_freshly_started_server(inner_func, done) {\n        //\n        //    async.series([\n        //        function (callback) {\n        //            tracelog(\" Restarting server;\")\n        //            server.restart(callback);\n        //        },\n        //        function (callback) {\n        //            try {\n        //                tracelog(chalk.bgWhite.black(\" ------------------------------------------------ INNER FUNC\"));\n        //                inner_func(callback);\n        //            }\n        //            catch (err) {\n        //                callback(err);\n        //            }\n        //        }\n        //    ], done);\n        //\n        //}\n\n        it(\"AZA2-A0 should return BadTooManySubscriptions if too many subscriptions are opened (maxSubscriptionsPerSession)\", function (done) {\n            const subscriptionIds = [];\n\n            function create_an_other_subscription(session, expected_error, callback) {\n                session.createSubscription(\n                    {\n                        requestedPublishingInterval: 100, // Duration\n                        requestedLifetimeCount: 10, // Counter\n                        requestedMaxKeepAliveCount: 10, // Counter\n                        maxNotificationsPerPublish: 10, // Counter\n                        publishingEnabled: true, // Boolean\n                        priority: 14 // Byte\n                    },\n                    function (err, response) {\n                        if (!expected_error) {\n                            should.not.exist(err);\n                            subscriptionIds.push(response.subscriptionId);\n                        } else {\n                            err.message.should.match(new RegExp(expected_error));\n                        }\n                        callback();\n                    }\n                );\n            }\n\n            const maxSessionBackup = server.engine.serverCapabilities.maxSessions;\n            server.engine.serverCapabilities.maxSessions = 100;\n            const maxSubsriptionsPerSessionBackup = server.engine.serverCapabilities.maxSubscriptionsPerSession;\n            server.engine.serverCapabilities.maxSubscriptionsPerSession = 5;\n            const maxSubsriptionsBackup = server.engine.serverCapabilities.maxSubscriptions;\n            server.engine.serverCapabilities.maxSubscriptions = 100;\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                const nbSessions = server.engine.currentSessionCount;\n                                server.engine.currentSessionCount.should.equal(nbSessions);\n                                callback();\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, null, callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, \"BadTooManySubscriptions\", callback);\n                            },\n                            function (callback) {\n                                create_an_other_subscription(session, \"BadTooManySubscriptions\", callback);\n                            },\n\n                            function (callback) {\n                                session.deleteSubscriptions(\n                                    {\n                                        subscriptionIds: subscriptionIds\n                                    },\n                                    function (err, response) {\n                                        should.exist(response);\n                                        callback(err);\n                                    }\n                                );\n                            }\n                        ],\n                        function (err) {\n                            server.engine.serverCapabilities.maxSubscriptionsPerSession = maxSubsriptionsPerSessionBackup;\n                            server.engine.serverCapabilities.maxSubscriptions = maxSubsriptionsBackup;\n                            server.engine.serverCapabilities.maxSessions = maxSessionBackup;\n\n                            done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-A1 should return BadTooManySubscriptions if too many subscriptions are opened (maxSubscriptions)\", async () => {\n            const subscriptionIds = [];\n            const clients = [];\n            const sessions = [];\n            const statusCodes = [];\n            async function create_client_and_2_subscriptions(expected_error) {\n                const client = OPCUAClient.create();\n\n                await client.connect(endpointUrl);\n                const session = await client.createSession();\n                clients.push(client);\n                sessions.push(session);\n\n                async function tryToCreateSubscription() {\n                    let _err;\n                    try {\n                        const subscription = await session.createSubscription2({\n                            requestedPublishingInterval: 100, // Duration\n                            requestedLifetimeCount: 10, // Counter\n                            requestedMaxKeepAliveCount: 10, // Counter\n                            maxNotificationsPerPublish: 10, // Counter\n                            publishingEnabled: true, // Boolean\n                            priority: 14 // Byte\n                        });\n\n                        subscriptionIds.push(subscription.subscriptionId);\n                        statusCodes.push(\"Good\");\n                    } catch (err) {\n                        tracelog(\"Create subscription has failed\");\n                        _err = err;\n                        statusCodes.push(\"Bad\");\n                    }\n                    return _err;\n                }\n                const _err = await tryToCreateSubscription();\n                if (expected_error) {\n                    if (!_err) {\n                        tracelog(\"maxSubscriptionsPerSession=\", server.engine.serverCapabilities.maxSubscriptionsPerSession);\n                        tracelog(\"maxSubscriptions          =\", server.engine.serverCapabilities.maxSubscriptions);\n                        tracelog(\"serverCapabilities        =\", server.engine.serverCapabilities);\n\n                        throw new Error(\"Expected error \" + expected_error + \" but got no error instead\");\n                    } else {\n                        _err.message.should.match(new RegExp(expected_error));\n                    }\n                } else {\n                    if (_err) {\n                        throw new Error(\"Expected no error but got \" + _err.message);\n                    }\n                }\n                await tryToCreateSubscription();\n                // tracelog(\"------------------------- !\");\n            }\n\n            const maxSessionBackup = server.engine.serverCapabilities.maxSessions;\n            server.engine.serverCapabilities.maxSessions = 100;\n            const maxSubsriptionsPerSessionBackup = server.engine.serverCapabilities.maxSubscriptionsPerSession;\n            server.engine.serverCapabilities.maxSubscriptionsPerSession = 10;\n            const maxSubsriptionsBackup = server.engine.serverCapabilities.maxSubscriptions;\n            server.engine.serverCapabilities.maxSubscriptions = 6;\n\n            try {\n                await create_client_and_2_subscriptions(null);\n                await create_client_and_2_subscriptions(null);\n                await create_client_and_2_subscriptions(null);\n                await create_client_and_2_subscriptions(\"BadTooManySubscriptions\");\n                await create_client_and_2_subscriptions(\"BadTooManySubscriptions\");\n            } finally {\n                server.engine.serverCapabilities.maxSubscriptionsPerSession = maxSubsriptionsPerSessionBackup;\n                server.engine.serverCapabilities.maxSubscriptions = maxSubsriptionsBackup;\n                server.engine.serverCapabilities.maxSessions = maxSessionBackup;\n                for (const session of sessions) {\n                    await session.close(true);\n                }\n                for (const client of clients) {\n                    await client.disconnect();\n                }\n            }\n        });\n\n        it(\n            \"AZA2-B a server should accept several Publish Requests from the client without sending notification immediately,\" +\n                \" and should still be able to reply to other requests\",\n            function (done) {\n                let subscriptionId;\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, done) {\n                        async.series(\n                            [\n                                function (callback) {\n                                    session.createSubscription(\n                                        {\n                                            requestedPublishingInterval: 1000, // Duration\n                                            requestedLifetimeCount: 1000, // Counter\n                                            requestedMaxKeepAliveCount: 100, // Counter\n                                            maxNotificationsPerPublish: 10, // Counter\n                                            publishingEnabled: true, // Boolean\n                                            priority: 14 // Byte\n                                        },\n                                        function (err, response) {\n                                            subscriptionId = response.subscriptionId;\n                                            callback(err);\n                                        }\n                                    );\n                                },\n                                function (callback) {\n                                    session.readVariableValue(\"RootFolder\", function (err, dataValue, diagnosticInfos) {\n                                        should.exist(dataValue);\n                                        callback(err);\n                                    });\n                                },\n                                function (callback) {\n                                    function publish_callback(err, response) {\n                                        should.not.exist(response);\n                                        err.response.should.be.instanceOf(ServiceFault);\n                                        should(err.message).match(/BadNoSubscription/);\n                                    }\n\n                                    // send many publish requests, in one go\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    session.publish({}, publish_callback);\n                                    callback();\n                                },\n                                function (callback) {\n                                    session.readVariableValue(\"RootFolder\", function (err, dataValue, diagnosticInfos) {\n                                        callback(err);\n                                    });\n                                },\n                                function (callback) {\n                                    session.deleteSubscriptions(\n                                        {\n                                            subscriptionIds: [subscriptionId]\n                                        },\n                                        function (err, response) {\n                                            should.exist(response);\n                                            callback(err);\n                                        }\n                                    );\n                                }\n                            ],\n                            function (err) {\n                                done(err);\n                            }\n                        );\n                    },\n                    done\n                );\n            }\n        );\n\n        it(\"AZA2-C A Subscription can be added and then deleted\", function (done) {\n            let subscriptionId;\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                session.createSubscription(\n                                    {\n                                        requestedPublishingInterval: 100, // Duration\n                                        requestedLifetimeCount: 10, // Counter\n                                        requestedMaxKeepAliveCount: 10, // Counter\n                                        maxNotificationsPerPublish: 10, // Counter\n                                        publishingEnabled: true, // Boolean\n                                        priority: 14 // Byte\n                                    },\n                                    function (err, response) {\n                                        subscriptionId = response.subscriptionId;\n                                        callback(err);\n                                    }\n                                );\n                            },\n\n                            function (callback) {\n                                session.deleteSubscriptions(\n                                    {\n                                        subscriptionIds: [subscriptionId]\n                                    },\n                                    function (err, response) {\n                                        should.exist(response);\n                                        callback(err);\n                                    }\n                                );\n                            }\n                        ],\n                        function (err) {\n                            done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-D #deleteSubscriptions -  should return serviceResult=BadNothingToDo if subscriptionIds is empty\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                session.deleteSubscriptions(\n                                    {\n                                        subscriptionIds: []\n                                    },\n                                    function (err, response) {\n                                        should.not.exist(response);\n                                        should.exist(err);\n                                        err.message.should.match(/BadNothingToDo/);\n                                        callback();\n                                    }\n                                );\n                            }\n                        ],\n                        function (err) {\n                            done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-E A MonitoredItem can be added to a subscription and then deleted\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(function () {\n                            callback();\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-F should return BadNodeIdUnknown  if the client tries to monitored an non-existent node\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const itemToMonitor = {\n                        nodeId: resolveNodeId(\"ns=0;s=**unknown**\"),\n                        attributeId: AttributeIds.Value\n                    };\n                    const parameters = {\n                        samplingInterval: 10,\n                        discardOldest: true,\n                        queueSize: 1\n                    };\n\n                    const monitoredItem = ClientMonitoredItem.create(subscription, itemToMonitor, parameters);\n\n                    monitoredItem.on(\"err\", function (statusMessage) {\n                        tracelog(\" ERR event received\");\n                        statusMessage.should.eql(StatusCodes.BadNodeIdUnknown.toString());\n                        callback();\n                    });\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(function () {\n                            callback(new Error(\"Should not have been initialized\"));\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-G should return BadAttributeIdInvalid if the client tries to monitored an invalid attribute\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.INVALID\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    monitoredItem.on(\"err\", function (statusMessage) {\n                        //xx tracelog(\" ERR event received\");\n\n                        statusMessage.should.eql(StatusCodes.BadAttributeIdInvalid.toString());\n                        callback();\n                    });\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(function () {\n                            callback(new Error(\"Should not have been initialized\"));\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-H should return BadIndexRangeInvalid if the client tries to monitored with an invalid index range\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value,\n                            indexRange: \"5:3\" // << INTENTIONAL : Invalid Range\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    monitoredItem.on(\"err\", function (statusMessage) {\n                        statusMessage.should.eql(StatusCodes.BadIndexRangeInvalid.toString());\n                        callback();\n                    });\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        monitoredItem.terminate(function () {\n                            callback(new Error(\"monitoredItem.on('initialized') should not be called\"));\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-I should return BadIndexRangeNoData on first notification if the client tries to monitored with 2D index range when a 1D index range is required\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const notificationMessageSpy = new sinon.spy();\n                    subscription.on(\"raw_notification\", notificationMessageSpy);\n\n                    subscription.publishingInterval.should.eql(100);\n\n                    const nodeId = \"ns=2;s=Static_Array_Boolean\";\n\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            indexRange: \"0:1,0:1\" // << INTENTIONAL : 2D RANGE\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    monitoredItem.on(\"err\", function (statusMessage) {\n                        //xx tracelog(\"Monitored Item error\",statusMessage);\n                        statusMessage.should.eql(StatusCodes.BadIndexRangeInvalid.toString());\n                        callback();\n                    });\n\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", function () {\n                        //xx tracelog(\"Monitored Item Initialized\")\n                    });\n\n                    const monitoredItemOnChangedSpy = new sinon.spy();\n                    monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n\n                    setTimeout(function () {\n                        //xx tracelog(notificationMessageSpy.getCall(0).args[0].toString());\n                        monitoredItemOnChangedSpy.getCall(0).args[0].statusCode.should.eql(StatusCodes.BadIndexRangeNoData);\n                        monitoredItemOnChangedSpy.callCount.should.eql(1, \"Only one reply\");\n                        callback();\n                    }, 500);\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-J should not report notification if a monitored value array changes outside the monitored indexRange - 1\", function (done) {\n            // based on CTT : createMonitoredItems591025 - 015.js\n            // Description:\n            //  - Specify an item of type array. Do this for all configured supported data types.\n            //  - Specify an IndexRange that equates to the last 3 elements of the array.\n            //  - Write values to each data-type within the index range specified and then\n            //    call Publish(). We expect to receive data in the Publish response.\n            //    Write to each data-type outside of the index range (e.g. elements 0 and 1) and then call Publish().\n            //    We do not expect to receive data in the Publish response.\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const notificationMessageSpy = new sinon.spy();\n                    subscription.on(\"raw_notification\", notificationMessageSpy);\n\n                    const monitoredItemOnChangedSpy = new sinon.spy();\n\n                    subscription.publishingInterval.should.eql(100);\n\n                    const nodeId = \"ns=2;s=Static_Array_Int32\";\n\n                    function wait(duration, callback) {\n                        setTimeout(callback, duration); // make sure we get inital data\n                    }\n\n                    function write(value, indexRange, callback) {\n                        assert(typeof callback === \"function\");\n                        assert(Array.isArray(value));\n\n                        const nodeToWrite = {\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            value: /*new DataValue(*/ {\n                                serverTimestamp: null,\n                                sourceTimestamp: null,\n                                value: {\n                                    /* Variant */\n                                    dataType: DataType.Int32,\n                                    arrayType: VariantArrayType.Array,\n                                    value: value\n                                }\n                            },\n                            indexRange: indexRange\n                        };\n\n                        session.write(nodeToWrite, function (err, statusCode) {\n                            if (!err) {\n                                statusCode.should.eql(StatusCodes.Good);\n                            }\n\n                            session.read(\n                                {\n                                    attributeId: AttributeIds.Value,\n                                    nodeId: nodeId\n                                },\n                                function (err, dataValue) {\n                                    should.not.exist(err);\n                                    should.exist(dataValue);\n                                    //xx tracelog(\" written \",dataValue.toString());\n                                    callback(err);\n                                }\n                            );\n                        });\n                    }\n\n                    function create_monitored_item(callback) {\n                        const monitoredItem = ClientMonitoredItem.create(\n                            subscription,\n                            {\n                                nodeId: nodeId,\n                                attributeId: AttributeIds.Value,\n                                indexRange: \"2:9\"\n                            },\n                            {\n                                samplingInterval: 0, // event based\n                                discardOldest: true,\n                                queueSize: 1\n                            },\n                            TimestampsToReturn.Both\n                        );\n\n                        monitoredItem.on(\"err\", function (statusMessage) {\n                            callback(new Error(statusMessage));\n                        });\n\n                        // subscription.on(\"item_added\",function(monitoredItem){\n                        monitoredItem.on(\"initialized\", function () {\n                            callback();\n                        });\n\n                        monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n                    }\n\n                    async.series(\n                        [\n                            write.bind(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], null),\n\n                            create_monitored_item.bind(null),\n\n                            wait.bind(null, 300),\n\n                            function (callback) {\n                                monitoredItemOnChangedSpy.callCount.should.eql(1);\n                                monitoredItemOnChangedSpy.getCall(0).args[0].statusCode.should.eql(StatusCodes.Good);\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(0).args[0].toString());\n                                monitoredItemOnChangedSpy\n                                    .getCall(0)\n                                    .args[0].value.value.should.eql(new Int32Array([2, 3, 4, 5, 6, 7, 8, 9]));\n                                callback();\n                            },\n                            write.bind(null, [100, 101], \"0:1\"),\n                            wait.bind(null, 300),\n\n                            write.bind(null, [200, 201], \"0:1\"),\n                            wait.bind(null, 300),\n                            function (callback) {\n                                // no change ! there is no overlap\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(1).args[0].value.toString());\n                                monitoredItemOnChangedSpy.callCount.should.eql(1);\n                                callback();\n                            },\n                            write.bind(null, [222, 333], \"2:3\"),\n                            wait.bind(null, 300),\n                            function (callback) {\n                                // there is a overlap ! we should receive a monitoredItem On Change event\n                                monitoredItemOnChangedSpy.callCount.should.eql(2);\n                                monitoredItemOnChangedSpy\n                                    .getCall(1)\n                                    .args[0].value.value.should.eql(new Int32Array([222, 333, 4, 5, 6, 7, 8, 9]));\n                                callback();\n                            }\n                        ],\n                        callback\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-K should not report notification if a monitored value array changes outside the monitored indexRange\", function (done) {\n            // based on CTT : createMonitoredItems591024 - 014.js\n            // Description:\n            //  - Specify an item of type array. Do this for all configured data types.\n            //  - Specify an IndexRange of \"2:4\".\n            //  - write values to each data-type within the index range specified\n            //  - call Publish()\n            //  - VERIFY that a notification is sent\n            //  - Write to each data-type outside of the index range (e.g. elements 0, 1 and 5) and then\n            //  - call Publish()\n            //  - VERIFY that no notification is sent.\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const notificationMessageSpy = new sinon.spy();\n                    subscription.on(\"raw_notification\", notificationMessageSpy);\n\n                    const monitoredItemOnChangedSpy = new sinon.spy();\n\n                    subscription.publishingInterval.should.eql(100);\n\n                    const nodeId = \"ns=2;s=Static_Array_Int32\";\n\n                    function create_monitored_item(callback) {\n                        const monitoredItem = ClientMonitoredItem.create(\n                            subscription,\n                            {\n                                nodeId: nodeId,\n                                attributeId: AttributeIds.Value,\n                                indexRange: \"2:4\"\n                            },\n                            {\n                                samplingInterval: 100,\n                                discardOldest: true,\n                                queueSize: 1\n                            },\n                            TimestampsToReturn.Both\n                        );\n\n                        monitoredItem.on(\"err\", function (statusMessage) {\n                            callback(new Error(statusMessage));\n                        });\n\n                        // subscription.on(\"item_added\",function(monitoredItem){\n                        monitoredItem.on(\"initialized\", function () {\n                            //xxtracelog(\"Monitored Item Initialized\")\n                            callback();\n                        });\n\n                        monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n                    }\n\n                    function wait(duration, callback) {\n                        setTimeout(callback, duration); // make sure we get inital data\n                    }\n\n                    function write(value, callback) {\n                        const nodeToWrite = {\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            value: /*new DataValue(*/ {\n                                value: {\n                                    /* Variant */\n                                    dataType: DataType.Int32,\n                                    arrayType: VariantArrayType.Array,\n                                    value: value\n                                }\n                            }\n                        };\n\n                        session.write(nodeToWrite, function (err, statusCode) {\n                            if (!err) {\n                                statusCode.should.eql(StatusCodes.Good);\n                            }\n                            session.read(\n                                {\n                                    attributeId: AttributeIds.Value,\n                                    nodeId: nodeId\n                                },\n                                function (err, dataValue) {\n                                    should.exist(dataValue);\n                                    ///xx tracelog(\" written \",dataValue.value.toString());\n                                    callback(err);\n                                }\n                            );\n                        });\n                    }\n\n                    async.series(\n                        [\n                            write.bind(null, [0, 0, 0, 0, 0, 0]),\n\n                            create_monitored_item.bind(null),\n\n                            wait.bind(null, 300),\n                            write.bind(null, [1, 2, 3, 4, 5]),\n                            wait.bind(null, 300),\n                            write.bind(null, [10, 20, 3, 4, 5, 60]),\n                            wait.bind(null, 300),\n                            write.bind(null, [10, 20, 13, 14, 15, 60]),\n                            wait.bind(null, 300),\n                            function (callback) {\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(0).args[0].toString());\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(1).args[0].toString());\n                                //xx tracelog(monitoredItemOnChangedSpy.getCall(2).args[0].toString());\n\n                                monitoredItemOnChangedSpy.getCall(0).args[0].statusCode.should.eql(StatusCodes.Good);\n                                monitoredItemOnChangedSpy.getCall(1).args[0].statusCode.should.eql(StatusCodes.Good);\n                                monitoredItemOnChangedSpy.getCall(2).args[0].statusCode.should.eql(StatusCodes.Good);\n\n                                monitoredItemOnChangedSpy.getCall(0).args[0].value.value.should.eql(new Int32Array([0, 0, 0]));\n                                monitoredItemOnChangedSpy.getCall(1).args[0].value.value.should.eql(new Int32Array([3, 4, 5]));\n                                monitoredItemOnChangedSpy.getCall(2).args[0].value.value.should.eql(new Int32Array([13, 14, 15]));\n\n                                monitoredItemOnChangedSpy.callCount.should.eql(3);\n                                callback();\n                            }\n                        ],\n                        callback\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-K1 should not report notification if a monitored value & status are written but did not change\", function (done) {\n            const subscriptionParameters = {\n                requestedPublishingInterval: 100,\n                requestedLifetimeCount: 6000,\n                requestedMaxKeepAliveCount: 10,\n                maxNotificationsPerPublish: 4,\n                publishingEnabled: true,\n                priority: 6\n            };\n            // based on CTT : createMonitoredItems591060 - 009.js\n            // Description:\n            //  - Create one monitored item.\n            //  - call Publish().\n            //  - Write a status code to the Value  attribute (don\u2019t change the value of the Value attribute).\n            //  - call Publish().\n            //  - Write the existing value and status code to the Value attribute.\n            //  - call Publish().\n            // Expected results:\n            //   - All service and operation level results are Good.\n            //   - The second Publish contains a DataChangeNotification with a value.statusCode matching\n            //     the written value (and value.value matching the value before the write).\n            //   - The third Publish contains no DataChangeNotifications.\n            //     (Did not expect a dataChange since the values written were the same, i.e. unchanged.)\n            perform_operation_on_subscription_with_parameters(\n                client,\n                endpointUrl,\n                subscriptionParameters,\n                function (session, subscription, callback) {\n                    const notificationMessageSpy = new sinon.spy();\n                    subscription.on(\"raw_notification\", notificationMessageSpy);\n                    subscription.on(\"raw_notification\", (notification) => {\n                        // tracelog(notification.toString());\n                    });\n\n                    const monitoredItemOnChangedSpy = new sinon.spy();\n                    const subscription_raw_notificationSpy = new sinon.spy();\n\n                    subscription.publishingInterval.should.eql(100);\n\n                    const nodeId = \"ns=2;s=Static_Scalar_Int32\";\n\n                    function create_monitored_item(callback) {\n                        const monitoredItem = ClientMonitoredItem.create(\n                            subscription,\n                            {\n                                nodeId,\n                                attributeId: AttributeIds.Value\n                            },\n                            {\n                                samplingInterval: 20,\n                                discardOldest: true,\n                                queueSize: 100\n                            },\n                            TimestampsToReturn.Both\n                        );\n\n                        monitoredItem.on(\"err\", function (statusMessage) {\n                            callback(new Error(statusMessage));\n                        });\n\n                        // subscription.on(\"item_added\",function(monitoredItem){\n                        monitoredItem.on(\"initialized\", function () {\n                            //xxtracelog(\"Monitored Item Initialized\")\n                            callback();\n                        });\n\n                        monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n\n                        subscription.on(\"raw_notification\", subscription_raw_notificationSpy);\n                    }\n\n                    function wait(duration, callback) {\n                        setTimeout(callback, duration);\n                    }\n\n                    function write(value, statusCode, callback) {\n                        if (doDebug) {\n                            tracelog(\"monitoredItemOnChanged count    = \", monitoredItemOnChangedSpy.callCount);\n                        }\n                        const nodeToWrite = {\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            value: /*new DataValue(*/ {\n                                statusCode,\n                                value: {\n                                    /* Variant */\n                                    dataType: DataType.Int32,\n                                    value: value\n                                },\n                                sourceTimestamp: null\n                            }\n                        };\n\n                        session.write(nodeToWrite, function (err, statusCode) {\n                            if (!err) {\n                                statusCode.should.eql(StatusCodes.Good);\n                            }\n                            session.read(\n                                {\n                                    attributeId: AttributeIds.Value,\n                                    nodeId: nodeId\n                                },\n                                function (err, dataValue) {\n                                    should.exist(dataValue);\n                                    // xx tracelog(\" written \",dataValue.toString());\n                                    callback(err);\n                                }\n                            );\n                        });\n                    }\n\n                    async.series(\n                        [\n                            write.bind(null, 1, StatusCodes.Good),\n                            wait.bind(null, 300),\n\n                            create_monitored_item.bind(null),\n                            wait.bind(null, 300),\n\n                            //  - Write a status code to the Value  attribute (don\u2019t change the value of the Value attribute).\n                            write.bind(null, 1, StatusCodes.GoodWithOverflowBit),\n                            wait.bind(null, 300),\n\n                            //  - Write the existing value and status code to the Value attribute.\n                            write.bind(null, 1, StatusCodes.GoodWithOverflowBit),\n                            wait.bind(null, 300),\n\n                            function (callback) {\n                                // wait until next notification received;\n                                const lambda = (response) => {\n                                    if (doDebug) {\n                                        tracelog(\n                                            \"response: \",\n                                            response.constructor.name,\n                                            \"notificationData.length\",\n                                            response.notificationMessage.notificationData.length\n                                        );\n                                    }\n                                    if (response.constructor.name === \"PublishResponse\") {\n                                        client.removeListener(\"receive_response\", lambda);\n                                        // tracelog(\" xxxx \", response.toString());\n                                        if (response.notificationMessage.notificationData.length !== 0) {\n                                            return callback(\n                                                new Error(\n                                                    \"Test has failed because PublishResponse has a unexpected notification data\"\n                                                )\n                                            );\n                                        }\n                                        callback();\n                                    }\n                                };\n                                client.on(\"receive_response\", lambda);\n                            },\n                            //xx wait.bind(null, subscription.publishingInterval * subscription.maxKeepAliveCount + 500),\n                            function (callback) {\n                                try {\n                                    if (doDebug) {\n                                        tracelog(\n                                            \"subscription_raw_notificiationSpy = \",\n                                            subscription_raw_notificationSpy.callCount\n                                        );\n                                        tracelog(\"monitoredItemOnChangedSpy         = \", monitoredItemOnChangedSpy.callCount);\n                                        for (let i = 0; i < monitoredItemOnChangedSpy.callCount; i++) {\n                                            tracelog(\"    \", monitoredItemOnChangedSpy.getCall(i).args[0].statusCode.toString());\n                                        }\n                                    }\n                                    monitoredItemOnChangedSpy.callCount.should.eql(2);\n                                    monitoredItemOnChangedSpy.getCall(0).args[0].statusCode.should.eql(StatusCodes.Good);\n                                    monitoredItemOnChangedSpy\n                                        .getCall(1)\n                                        .args[0].statusCode.should.eql(StatusCodes.GoodWithOverflowBit);\n                                    callback();\n                                } catch (err) {\n                                    tracelog(err);\n                                    callback(err);\n                                }\n                            }\n                        ],\n                        callback\n                    );\n                },\n                (err) => {\n                    done(err);\n                }\n            );\n        });\n\n        it(\"AZA2-L disabled monitored item\", async () => {\n            const nodeId = \"ns=2;s=Static_Scalar_Int32\";\n\n            const monitoredItemOnChangedSpy = new sinon.spy();\n            await perform_operation_on_subscription_async(client, endpointUrl, async (session, subscription) => {\n                // create a disabled monitored Item\n                const monitoredItem = await subscription.monitor(\n                    /* itemToMonitor:*/\n                    {\n                        nodeId,\n                        attributeId: AttributeIds.Value\n                    },\n                    /* requestedParameters:*/\n                    {\n                        samplingInterval: 100,\n                        discardOldest: true,\n                        queueSize: 1\n                    },\n                    TimestampsToReturn.Both\n                );\n                monitoredItem.monitoringMode = MonitoringMode.Reporting;\n                monitoredItem.on(\"changed\", monitoredItemOnChangedSpy);\n\n                await monitoredItem.setMonitoringMode(MonitoringMode.Disabled);\n            });\n        });\n\n        it(\"AZA2-M #CreateMonitoredItemRequest should return BadNothingToDo if CreateMonitoredItemRequest has no nodes to monitored\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        timestampsToReturn: TimestampsToReturn.Neither,\n                        itemsToCreate: []\n                    });\n                    session.createMonitoredItems(createMonitoredItemsRequest, function (err, createMonitoredItemsResponse) {\n                        should(err.message).match(/BadNothingToDo/);\n                        should.not.exist(createMonitoredItemsResponse);\n                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-N #CreateMonitoredItemRequest should return BadIndexRangeInvalid if a invalid range is passed on CreateMonitoredItemRequest \", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const nodeId = makeNodeId(VariableIds.Server_ServerArray);\n                    const samplingInterval = 1000;\n                    const itemToMonitor = new ReadValueId({\n                        nodeId: nodeId,\n                        attributeId: AttributeIds.Value,\n                        indexRange: \"1:2,3:4\"\n                    });\n                    const parameters = {\n                        samplingInterval: samplingInterval,\n                        discardOldest: false,\n                        queueSize: 1\n                    };\n\n                    const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        timestampsToReturn: TimestampsToReturn.Neither,\n                        itemsToCreate: [\n                            {\n                                itemToMonitor: itemToMonitor,\n                                requestedParameters: parameters,\n                                monitoringMode: MonitoringMode.Reporting\n                            }\n                        ]\n                    });\n                    session.createMonitoredItems(createMonitoredItemsRequest, function (err, createMonitoredItemsResponse) {\n                        should.not.exist(err);\n                        createMonitoredItemsResponse.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n\n                        createMonitoredItemsResponse.results[0].statusCode.should.eql(StatusCodes.Good);\n                        callback();\n                    });\n\n                    // now publish and check that monitored item returns\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-O should return BadNothingToDo if ModifyMonitoredItemRequest has no nodes to monitored\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const modifyMonitoredItemsRequest = new ModifyMonitoredItemsRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        timestampsToReturn: TimestampsToReturn.Neither,\n                        itemsToModify: []\n                    });\n                    session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err, modifyMonitoredItemsResponse) {\n                        should(err.message).match(/BadNothingToDo/);\n                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                        should.not.exist(modifyMonitoredItemsResponse);\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-P should return BadNothingToDo if DeleteMonitoredItemsResponse has no nodes to delete\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const deleteMonitoredItemsRequest = new DeleteMonitoredItemsRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        monitoredItemIds: []\n                    });\n                    session.deleteMonitoredItems(deleteMonitoredItemsRequest, function (err, deleteMonitoredItemsResponse) {\n                        should(err.message).match(/BadNothingToDo/);\n                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                        should.not.exist(deleteMonitoredItemsResponse);\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-Q A MonitoredItem should received changed event\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, inner_callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    monitoredItem.on(\"initialized\", function () {\n                        debugLog(\"Initialized\");\n                    });\n                    monitoredItem.on(\"terminated\", function () {\n                        debugLog(\"monitored item terminated\");\n                    });\n\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        should.exist(dataValue);\n                        // the changed event has been received !\n                        // lets stop monitoring this item\n                        setImmediate(function () {\n                            monitoredItem.terminate(inner_callback);\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-R A Server should reject a CreateMonitoredItemRequest if timestamp is invalid ( catching error on monitored item )\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                (session, subscription, callback) => {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Invalid\n                    );\n\n                    let err_counter = 0;\n                    // subscription.on(\"item_added\",function(monitoredItem){\n                    monitoredItem.on(\"initialized\", () => {\n                        // eslint-disable-next-line no-debugger\n                        // debugger;\n                    });\n\n                    monitoredItem.on(\"changed\", (dataValue) => {\n                        should.exist(dataValue);\n                    });\n                    monitoredItem.on(\"err\", (err) => {\n                        should.exist(err);\n                        err_counter++;\n                        tracelog(\"err received => terminated event expected \", err.message);\n                    });\n                    monitoredItem.on(\"terminated\", () => {\n                        tracelog(\"terminated event received\");\n                        err_counter.should.eql(1);\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-SA A Server should reject a CreateMonitoredItemRequest if timestamp is invalid ( catching error on callback)\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: 13\n                        },\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Invalid // <= A invalid  TimestampsToReturn\n                    );\n                    monitoredItem.on(\"initialized\", () => {\n                        callback(new Error(\"Should not get there\"));\n                    });\n                    monitoredItem.on(\"err\", () => {\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-SB - GROUP - A Server should reject a CreateMonitoredItemRequest if timestamp is invalid ( catching error on callback)\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    const group = ClientMonitoredItemGroup.create(\n                        subscription,\n                        [\n                            {\n                                nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                                attributeId: 13\n                            }\n                        ],\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Invalid // <= A invalid  TimestampsToReturn\n                    );\n                    group.on(\"initialized\", () => {\n                        callback(new Error(\"Should not get there\"));\n                    });\n                    group.on(\"err\", () => {\n                        callback();\n                    });\n                },\n                done\n            );\n        });\n        it(\"AZA2-SB A Server should reject a CreateMonitoredItemRequest if timestamp is invalid ( catching error on callback)\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, callback) {\n                    subscription.monitor(\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: 13\n                        },\n                        {\n                            samplingInterval: 100,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Invalid, // <= A invalid  TimestampsToReturn\n                        function (err, monitoredItem) {\n                            if (!err) {\n                                callback(new Error(\"Should not get there\"));\n                            } else {\n                                callback();\n                            }\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-T A Server should be able to revise publish interval to avoid trashing if client specify a very small or zero requestedPublishingInterval\", function (done) {\n            // from spec OPCUA Version 1.02  Part 4 $5.13.2.2 : requestedPublishingInterval:\n            // The negotiated value for this parameter returned in the response is used as the\n            // default sampling interval for MonitoredItems assigned to this Subscription.\n            // If the requested value is 0 or negative, the server shall revise with the fastest\n            // supported publishing interval.\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    session.createSubscription(\n                        {\n                            requestedPublishingInterval: -1\n                        },\n                        function (err, createSubscriptionResponse) {\n                            should.not.exist(err);\n                            createSubscriptionResponse.revisedPublishingInterval.should.be.greaterThan(10);\n\n                            inner_done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA2-U should handle PublishRequest to confirm closed subscriptions\", function (done) {\n            let subscriptionId;\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                session.createSubscription(\n                                    {\n                                        requestedPublishingInterval: 200, // Duration\n                                        requestedLifetimeCount: 30, // Counter\n                                        requestedMaxKeepAliveCount: 10, // Counter\n                                        maxNotificationsPerPublish: 10, // Counter\n                                        publishingEnabled: true, // Boolean\n                                        priority: 14 // Byte\n                                    },\n                                    function (err, response) {\n                                        subscriptionId = response.subscriptionId;\n                                        callback(err);\n                                    }\n                                );\n                            },\n\n                            // create a monitored item so we have pending notificiation\n                            function (callback) {\n                                const namespaceIndex = 2;\n                                const nodeId = \"s=\" + \"Static_Scalar_Int16\";\n\n                                const node = server.engine.addressSpace.findNode(nodeId);\n                                const parameters = {\n                                    samplingInterval: 0,\n                                    discardOldest: false,\n                                    queueSize: 1\n                                };\n                                const itemToMonitor = {\n                                    attributeId: 13,\n                                    nodeId: nodeId\n                                };\n                                const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                                    subscriptionId: subscriptionId,\n                                    timestampsToReturn: TimestampsToReturn.Both,\n                                    itemsToCreate: [\n                                        {\n                                            itemToMonitor: itemToMonitor,\n                                            requestedParameters: parameters,\n                                            monitoringMode: MonitoringMode.Reporting\n                                        }\n                                    ]\n                                });\n                                session.createMonitoredItems(createMonitoredItemsRequest, function (err, results) {\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                setTimeout(callback, 300);\n                            },\n                            function (callback) {\n                                session.deleteSubscriptions(\n                                    {\n                                        subscriptionIds: [subscriptionId]\n                                    },\n                                    function (err, response) {\n                                        callback(err);\n                                    }\n                                );\n                            },\n\n                            function (callback) {\n                                session.publish({}, function (err, publishResult) {\n                                    callback();\n                                });\n                            }\n                        ],\n                        function (err) {\n                            done(err);\n                        }\n                    );\n                },\n                done\n            );\n        });\n    });\n\n    describe(\"AZA3- testing Client-Server subscription use case 2/2, on a fake server exposing the temperature device\", function () {\n        let server, client, temperatureVariableId, endpointUrl;\n\n        const nodeIdVariant = \"ns=1;s=SomeDouble\";\n        const nodeIdByteString = \"ns=1;s=ByteString\";\n        const nodeIdString = \"ns=1;s=String\";\n\n        let subscriptionId = null;\n        let samplingInterval = -1;\n\n        before(function (done) {\n            server = test.server;\n\n            installSessionLogging(server);\n\n            endpointUrl = test.endpointUrl;\n            temperatureVariableId = server.temperatureVariableId;\n\n            const namespace = server.engine.addressSpace.getOwnNamespace();\n\n            const rootFolder = server.engine.addressSpace.rootFolder;\n            const objectsFolder = rootFolder.objects;\n\n            // Variable with dataItem capable of sending data change notification events\n            // this type of variable can be continuously monitored.\n            const n1 = namespace.addVariable({\n                organizedBy: objectsFolder,\n                browseName: \"SomeDouble\",\n                nodeId: nodeIdVariant,\n                dataType: \"Double\",\n                value: {\n                    dataType: DataType.Double,\n                    value: 0.0\n                }\n            });\n            n1.minimumSamplingInterval.should.eql(0);\n\n            let changeDetected = 0;\n            n1.on(\"value_changed\", function (dataValue) {\n                changeDetected += 1;\n            });\n\n            n1.setValueFromSource({ dataType: DataType.Double, value: 3.14 }, StatusCodes.Good);\n            changeDetected.should.equal(1);\n\n            namespace.addVariable({\n                organizedBy: objectsFolder,\n                browseName: \"SomeByteString\",\n                nodeId: nodeIdByteString,\n                dataType: \"ByteString\",\n                value: {\n                    dataType: DataType.ByteString,\n                    value: Buffer.from(\"Lorem ipsum\", \"utf-8\")\n                }\n            });\n            namespace.addVariable({\n                organizedBy: objectsFolder,\n                browseName: \"Some String\",\n                nodeId: nodeIdString,\n                dataType: \"String\",\n                value: {\n                    dataType: DataType.String,\n                    value: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                }\n            });\n            done();\n        });\n\n        beforeEach(function (done) {\n            client = OPCUAClient.create({\n                keepSessionAlive: true,\n                requestedSessionTimeout: 4 * 60 * 1000 // 4 min ! make sure that session doesn't drop during test\n            });\n            done();\n        });\n\n        afterEach(function (done) {\n            client = null;\n            done();\n        });\n\n        /**\n         * async method to create a client subscription\n         * @param session\n         * @param subscriptionParameters\n         * @param callback\n         */\n        function my_CreateSubscription(session, subscriptionParameters, callback) {\n            const subscription = ClientSubscription.create(session, subscriptionParameters);\n\n            subscription.once(\"started\", function () {\n                callback(null, subscription);\n            });\n\n            // install a little keepalive counter\n            subscription.nb_keep_alive_received = 0;\n            subscription.on(\"keepalive\", function () {\n                subscription.nb_keep_alive_received += 1;\n            });\n\n            subscription.on(\"timeout\", function () {\n                tracelog(\"Subscription has timed out\");\n            });\n        }\n\n        it(\"AZA3-A A server should send a StatusChangeNotification (BadTimeout) if the client doesn't send PublishRequest within the expected interval\", function (done) {\n            if (process.platform === \"darwin\") {\n                return done(); // skipping on MacOS\n            }\n            //xx endpointUrl = \"opc.tcp://localhost:2200/OPCUA/SimulationServer\";\n\n            // from Spec OPCUA Version 1.03 Part 4 - 5.13.1.1 Description : Page 69\n            // h. Subscriptions have a lifetime counter that counts the number of consecutive publishing cycles in\n            //    which there have been no Publish requests available to send a Publish response for the\n            //    Subscription. Any Service call that uses the SubscriptionId or the processing of a Publish\n            //    response resets the lifetime counter of this Subscription. When this counter reaches the value\n            //    calculated for the lifetime of a Subscription based on the MaxKeepAliveCount parameter in the\n            //    CreateSubscription Service (5.13.2), the Subscription is closed. Closing the Subscription causes\n            //    its MonitoredItems to be deleted. In addition the Server shall issue a StatusChangeNotification\n            //    notificationMessage with the status code Bad_Timeout. The StatusChangeNotification\n            //    notificationMessage type is defined in 7.19.4.\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    function setUnpublishing(session) {\n                        // replace internalSendPublishRequest so that it doesn't do anything for a little while\n                        // The publish engine is shared amongst all subscriptions and belongs to the  session object\n                        session.getPublishEngine().internalSendPublishRequest.should.be.instanceOf(Function);\n                        sinon.stub(session.getPublishEngine(), \"internalSendPublishRequest\").returns();\n                    }\n\n                    /**\n                     * restore the publishing mechanism on a unpublishing subscription\n                     * @param session\n                     */\n                    function repairUnpublishing(session) {\n                        session.getPublishEngine().internalSendPublishRequest.callCount.should.be.greaterThan(1);\n                        session.getPublishEngine().internalSendPublishRequest.restore();\n                        session.getPublishEngine().internalSendPublishRequest();\n                    }\n\n                    setUnpublishing(session);\n\n                    // in this test we need two subscriptions\n                    //    - one subscription with a short live time\n                    //    - one subscription with a long life time,\n                    //\n                    // at the beginning, both subscriptions will not send PublishRequest\n\n                    let longLifeSubscription, shortLifeSubscription;\n                    async.series(\n                        [\n                            f(function create_long_life_subscription(callback) {\n                                const subscriptionParameters = {\n                                    requestedPublishingInterval: 100, // short publishing interval required here\n                                    requestedLifetimeCount: 1000, // long lifetimeCount needed here !\n                                    requestedMaxKeepAliveCount: 50,\n                                    maxNotificationsPerPublish: 30,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                };\n\n                                my_CreateSubscription(session, subscriptionParameters, function (err, subscription) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    longLifeSubscription = subscription;\n                                    setImmediate(callback);\n                                });\n                            }),\n\n                            f(function create_short_life_subscription(callback) {\n                                const subscriptionParameters = {\n                                    requestedPublishingInterval: 100, // short publishing interval required here\n                                    requestedLifetimeCount: 30, // short lifetimeCount needed here !\n                                    requestedMaxKeepAliveCount: 4,\n                                    maxNotificationsPerPublish: 30,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                };\n\n                                my_CreateSubscription(session, subscriptionParameters, function (err, subscription) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    shortLifeSubscription = subscription;\n                                    setImmediate(callback);\n                                });\n                            }),\n                            f(function wait_for_short_life_subscription_to_expire(callback) {\n                                // let's make sure that the subscription will expired\n                                const timeToWaitBeforeResendingPublishInterval =\n                                    shortLifeSubscription.publishingInterval *\n                                    (shortLifeSubscription.lifetimeCount + shortLifeSubscription.maxKeepAliveCount * 4 + 20);\n\n                                tracelog(\"timeToWaitBeforeResendingPublishInterval = \", timeToWaitBeforeResendingPublishInterval);\n                                if (doDebug) {\n                                    tracelog(shortLifeSubscription.toString());\n                                    tracelog(\n                                        \"timetoWaitBeforeResendingPublishInterval  :\",\n                                        timeToWaitBeforeResendingPublishInterval\n                                    );\n                                    tracelog(\n                                        \"Count To WaitBeforeResendingPublishInterval  :\",\n                                        timeToWaitBeforeResendingPublishInterval / shortLifeSubscription.publishingInterval\n                                    );\n                                }\n\n                                setTimeout(function () {\n                                    if (true || doDebug) {\n                                        tracelog(\" Restoring default Publishing behavior\");\n                                    }\n                                    repairUnpublishing(session);\n                                }, timeToWaitBeforeResendingPublishInterval);\n\n                                shortLifeSubscription.once(\"status_changed\", function (statusCode) {\n                                    statusCode.should.eql(StatusCodes.BadTimeout);\n                                    setImmediate(callback);\n                                });\n                            }),\n                            f(function terminate_short_life_subscription(callback) {\n                                const timeout =\n                                    shortLifeSubscription.publishingInterval * shortLifeSubscription.maxKeepAliveCount * 2;\n                                if (true || doDebug) {\n                                    tracelog(\"timeout = \", timeout);\n                                }\n                                const verif = shortLifeSubscription.nb_keep_alive_received;\n                                // let explicitly close the subscription by calling terminate\n                                // but delay a little bit so we can verify that internalSendPublishRequest\n                                // is not called\n                                setTimeout(function () {\n                                    tracelog(\"before shortLifeSubscription terminate\");\n                                    shortLifeSubscription.terminate(function (err) {\n                                        tracelog(\" shortLifeSubscription terminated\");\n                                        shortLifeSubscription.nb_keep_alive_received.should.be.equal(verif);\n                                        setImmediate(callback);\n                                    });\n                                }, timeout);\n                            }),\n                            f(function terminate_long_life_subscription(callback) {\n                                tracelog(\"before longLifeSubscription terminate\");\n                                longLifeSubscription.terminate((err) => {\n                                    tracelog(\" longLifeSubscription terminated\");\n                                    setImmediate(callback);\n                                });\n                            })\n                        ],\n                        (err) => {\n                            tracelog(\"inner\", err ? err.message : \"\");\n                            inner_done(err);\n                        }\n                    );\n                },\n                (err) => {\n                    tracelog(\"done\", err ? err.message : \"\");\n                    done(err);\n                }\n            );\n        });\n\n        it(\"AZA3-B A subscription without a monitored item should not dropped too early ( see #59)\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    function termination_is_a_failure() {\n                        inner_done(new Error(\"subscription has been terminated !!!!\"));\n                    }\n\n                    subscription.on(\"terminated\", termination_is_a_failure);\n\n                    setTimeout(function () {\n                        subscription.removeListener(\"terminated\", termination_is_a_failure);\n                        inner_done();\n                    }, 1000);\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-C #bytesRead #transactionsCount #bytesWritten\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    server.bytesRead.should.be.greaterThan(10);\n                    server.transactionsCount.should.be.greaterThan(3);\n                    server.bytesWritten.should.be.greaterThan(10);\n                    inner_done();\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-D #CreateMonitoredItemsRequest : A server should return statusCode === BadSubscriptionIdInvalid when appropriate  \", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const options = {\n                        subscriptionId: 999 // << invalide subscription id\n                    };\n                    session.createMonitoredItems(options, function (err, results) {\n                        err.message.should.match(/BadSubscriptionIdInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-E #SetPublishingModeRequest: A server should set status codes to BadSubscriptionIdInvalid when appropriate  \", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const publishingEnabled = true;\n                    const subscriptionIds = [999]; //<< invalid subscription ID\n                    session.setPublishingMode(publishingEnabled, subscriptionIds, function (err, results) {\n                        results.should.be.instanceOf(Array);\n                        results[0].should.eql(StatusCodes.BadSubscriptionIdInvalid);\n                        inner_done(err);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-F A server should suspend/resume publishing when client send a setPublishingMode Request \", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const parameters = {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    };\n\n                    const subscription = ClientSubscription.create(session, parameters);\n\n                    subscription.on(\"terminated\", function () {\n                        debugLog(\"subscription terminated\");\n                    });\n\n                    const itemToMonitor = {\n                        nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                        attributeId: AttributeIds.Value\n                    };\n                    const monitoringParameters = {\n                        samplingInterval: 10,\n                        discardOldest: true,\n                        queueSize: 1\n                    };\n                    const monitoredItem = ClientMonitoredItem.create(subscription, itemToMonitor, monitoringParameters);\n\n                    let change_count = 0;\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        change_count += 1;\n                        should.exist(dataValue);\n                        //xx tracelog(\"xxxxxxxxxxxx=> dataValue\",dataValue.toString());\n                    });\n\n                    async.series(\n                        [\n                            function (callback) {\n                                // wait 400 milliseconds and verify that the subscription is sending some notification\n                                setTimeout(function () {\n                                    change_count.should.be.greaterThan(2);\n                                    callback();\n                                }, 3600);\n                            },\n                            function (callback) {\n                                // suspend subscription\n                                subscription.setPublishingMode(false, function (err) {\n                                    change_count = 0;\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                // wait  400 milliseconds and verify that the subscription is  NOT sending any notification\n                                setTimeout(function () {\n                                    change_count.should.equal(0);\n                                    callback();\n                                }, 400);\n                            },\n\n                            function (callback) {\n                                // resume subscription\n                                subscription.setPublishingMode(true, function (err) {\n                                    change_count = 0;\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                // wait 600 milliseconds and verify that the subscription is sending some notification again\n                                setTimeout(function () {\n                                    change_count.should.be.greaterThan(2);\n                                    callback();\n                                }, 3600);\n                            },\n\n                            function (callback) {\n                                subscription.terminate(function (err) {\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-G A client should be able to create a subscription that have  publishingEnable=false\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: false,\n                        priority: 6\n                    });\n\n                    subscription.on(\"terminated\", function () {\n                        debugLog(\"subscription terminated\");\n                    });\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        {\n                            nodeId: resolveNodeId(\"ns=0;i=2258\"),\n                            attributeId: AttributeIds.Value\n                        },\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        }\n                    );\n\n                    let change_count = 0;\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        should.exist(dataValue);\n                        change_count += 1;\n                    });\n                    async.series(\n                        [\n                            function (callback) {\n                                // wait 400 ms and verify that the subscription is not sending notification.\n                                setTimeout(function () {\n                                    change_count.should.equal(0);\n                                    callback();\n                                }, 400);\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-H #ModifyMonitoredItemRequest : server should send BadSubscriptionIdInvalid if client send a wrong subscription id\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const modifyMonitoredItemsRequest = {\n                        subscriptionId: 999,\n                        timestampsToReturn: TimestampsToReturn.Neither,\n                        itemsToModify: [{}]\n                    };\n\n                    session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err) {\n                        err.message.should.match(/BadSubscriptionIdInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-I #ModifyMonitoredItemRequest : server should send BadSubscriptionIdInvalid if client send a wrong subscription id\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 100,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        const modifyMonitoredItemsRequest = {\n                            subscriptionId: subscription.subscriptionId,\n                            timestampsToReturn: TimestampsToReturn.Invalid\n                        };\n\n                        session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err, modifyMonitoredItemsResponse) {\n                            err.message.should.match(/BadTimestampsToReturnInvalid/);\n                            inner_done();\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-J #ModifyMonitoredItemRequest : server should send BadMonitoredItemIdInvalid  if client send a wrong monitored item id\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 200,\n                        requestedLifetimeCount: 60000,\n                        requestedMaxKeepAliveCount: 10,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        const modifyMonitoredItemsRequest = {\n                            subscriptionId: subscription.subscriptionId,\n                            timestampsToReturn: TimestampsToReturn.Neither,\n                            itemsToModify: [\n                                new MonitoredItemModifyRequest({\n                                    monitoredItemId: 999,\n                                    requestedParameters: {}\n                                })\n                            ]\n                        };\n\n                        session.modifyMonitoredItems(modifyMonitoredItemsRequest, function (err, modifyMonitoredItemsResponse) {\n                            if (err) {\n                                return inner_done(err);\n                            }\n                            modifyMonitoredItemsResponse.results.length.should.eql(1);\n                            modifyMonitoredItemsResponse.results[0].statusCode.should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n                            inner_done();\n                        });\n                    });\n                },\n                done\n            );\n        });\n\n        function test_modify_monitored_item(itemToMonitor, parameters, inner_func, done) {\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    let change_count = 0;\n                    subscription.publishingInterval.should.be.aboveOrEqual(100);\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        //xx tracelog(\"xx changed\",dataValue.value.toString());\n                        change_count += 1;\n                    });\n\n                    async.series(\n                        [\n                            function (callback) {\n                                setTimeout(callback, 1500);\n                            },\n                            function (callback) {\n                                // let's wait for first notification to be received\n                                monitoredItem.once(\"changed\", () => {\n                                    // we reset change count,\n                                    change_count = 0;\n                                    callback();\n                                });\n                            },\n                            function (callback) {\n                                // wait at least 2 x publishingInterval ms and verify that the subscription is not sending notification.\n                                setTimeout(() => {\n                                    change_count.should.equal(0);\n                                    callback();\n                                }, 800);\n                            },\n\n                            function (callback) {\n                                // let modify monitored item with new parameters.\n                                monitoredItem.modify(parameters, function (err, result) {\n                                    inner_func(err, result, callback);\n                                });\n                            },\n\n                            function (callback) {\n                                // wait 1.5 ms and verify that the subscription is now sending notification.\n                                setTimeout(() => {\n                                    change_count.should.be.greaterThan(1);\n                                    callback();\n                                }, 2000); // wait at least 2 seconds as date resolution is 1 sec.\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            ); //\n        }\n\n        it(\"AZA3-K #ModifyMonitoredItemRequest : server should handle samplingInterval === -1\", function (done) {\n            const itemToMonitor = \"ns=0;i=2258\";\n\n            /**\n             * The value - 1 indicates that the default sampling interval defined\n             * by the publishing interval of the Subscription is requested.A different\n             * sampling interval is used if the publishing interval is not a supported\n             * sampling interval.Any negative number is interpreted as -1. The sampling\n             * interval is not changed if the publishing interval is changed by a\n             * subsequent call to the ModifySubscription Service.\n             */\n\n            const parameters = {\n                samplingInterval: -1, // SAMPLING INTERVAL = -1\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item(\n                itemToMonitor,\n                parameters,\n                function (err, results, callback) {\n                    callback(err);\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-L #ModifyMonitoredItemRequest : server should handle samplingInterval === 0\", function (done) {\n            const itemToMonitor = \"ns=0;i=2258\";\n\n            const parameters = {\n                samplingInterval: 0, // SAMPLING INTERVAL = 0 => use fastest allowed by server\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item(\n                itemToMonitor,\n                parameters,\n                function (err, results, callback) {\n                    callback(err);\n                },\n                done\n            );\n        });\n        it(\"AZA3-M #ModifyMonitoredItemsRequest : a client should be able to modify a monitored item\", function (done) {\n            const itemToMonitor = \"ns=0;i=2258\";\n            const parameters = {\n                samplingInterval: 20,\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item(\n                itemToMonitor,\n                parameters,\n                function (err, results, callback) {\n                    if (!err) {\n                        results.revisedSamplingInterval.should.be.greaterThan(19);\n                    }\n                    callback(err);\n                },\n                done\n            );\n        });\n\n        function test_modify_monitored_item_on_noValue_attribute(parameters, done) {\n            const nodeId = \"ns=0;i=2258\";\n            const itemToMonitor = {\n                nodeId: resolveNodeId(nodeId),\n                attributeId: AttributeIds.BrowseName\n            };\n\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    let change_count = 0;\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        //xx tracelog(\"xx changed\",dataValue.value.toString());\n                        dataValue.value.toString().should.eql(\"Variant(Scalar<QualifiedName>, value: CurrentTime)\");\n                        change_count += 1;\n                    });\n                    async.series(\n                        [\n                            function (callback) {\n                                setTimeout(function () {\n                                    change_count.should.eql(1);\n                                    callback();\n                                }, 1000);\n                            },\n                            function (callback) {\n                                monitoredItem.modify(parameters, function (err, result) {\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                // modifying monitoredItem parameters shall not cause the monitored Item to resend a data notification\n                                setTimeout(function () {\n                                    change_count.should.eql(1);\n                                    callback();\n                                }, 1000);\n                            },\n\n                            // setting mode to disable\n                            function (callback) {\n                                monitoredItem.setMonitoringMode(MonitoringMode.Disabled, callback);\n                            },\n                            // setting mode to disable\n                            function (callback) {\n                                monitoredItem.setMonitoringMode(MonitoringMode.Reporting, callback);\n                            },\n                            function (callback) {\n                                // Changing mode from Disabled to Reporting shall cause the monitored Item to resend a data notification\n                                setTimeout(function () {\n                                    change_count.should.eql(2);\n                                    callback();\n                                }, 1000);\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        }\n\n        it(\"AZA3-N #ModifyMonitoredItemRequest on a non-Value attribute: server should handle samplingInterval === 0\", function (done) {\n            const parameters = {\n                samplingInterval: 0, // SAMPLING INTERVAL = 0 => use fastest allowed by server or event base\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item_on_noValue_attribute(parameters, done);\n        });\n\n        it(\"AZA3-O #ModifyMonitoredItemRequest on a non-Value attribute: server should handle samplingInterval > 0\", function (done) {\n            const parameters = {\n                samplingInterval: 20,\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item_on_noValue_attribute(parameters, done);\n        });\n\n        it(\"AZA3-P #ModifyMonitoredItemRequest on a non-Value attribute: server should handle samplingInterval === -1\", function (done) {\n            const parameters = {\n                samplingInterval: -1,\n                discardOldest: false,\n                queueSize: 1\n            };\n            test_modify_monitored_item_on_noValue_attribute(parameters, done);\n        });\n\n        /**\n         * see CTT createMonitoredItems591064\n         * Description:\n         * Create a monitored item with the nodeId set to that of a non-Variable node and\n         * the attributeId set to a non-Value attribute. call Publish().\n         * Expected Results: All service and operation level results are Good. Publish response contains a DataChangeNotification.\n         */\n        it(\"AZA3-Q a monitored item with the nodeId set to that of a non-Variable node an  and the attributeId set to a non-Value attribute should send a DataChangeNotification\", function (done) {\n            // Attributes, other than the  Value  Attribute, are only monitored for a change in value.\n            // The filter is not used for these  Attributes. Any change in value for these  Attributes\n            // causes a  Notification  to be  generated.\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 10,\n                        requestedLifetimeCount: 6000,\n                        requestedMaxKeepAliveCount: 10,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    subscription.on(\"terminated\", function () {\n                        //xx tracelog(chalk.yellow(\" subscription terminated \"));\n                        inner_done();\n                    });\n\n                    const readValue = {\n                        nodeId: resolveNodeId(\"Server\"),\n                        attributeId: AttributeIds.DisplayName\n                    };\n\n                    const monitoredItem = ClientMonitoredItem.create(\n                        subscription,\n                        readValue,\n                        {\n                            samplingInterval: 10,\n                            discardOldest: true,\n                            queueSize: 1\n                        },\n                        TimestampsToReturn.Both\n                    );\n\n                    monitoredItem.on(\"err\", function (err) {\n                        should.not.exist(err);\n                    });\n\n                    let change_count = 0;\n\n                    monitoredItem.on(\"changed\", function (dataValue) {\n                        //xx tracelog(\"dataValue = \", dataValue.toString());\n                        change_count += 1;\n                    });\n\n                    async.series(\n                        [\n                            function (callback) {\n                                setTimeout(function () {\n                                    change_count.should.equal(1);\n                                    callback();\n                                }, 1000);\n                            },\n                            function (callback) {\n                                // on server side : modify displayName\n                                const node = server.engine.addressSpace.findNode(readValue.nodeId);\n                                node.setDisplayName(\"Changed Value\");\n                                callback();\n                            },\n\n                            function (callback) {\n                                setTimeout(function () {\n                                    change_count.should.equal(2);\n                                    callback();\n                                }, 1000);\n                            },\n\n                            function (callback) {\n                                subscription.terminate(callback);\n                            }\n                        ],\n                        function (err) {\n                            if (err) {\n                                done(err);\n                            }\n                        }\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"AZA3-R Server should revise publishingInterval to be at least server minimum publishing interval\", function (done) {\n            Subscription.minimumPublishingInterval.should.eql(50);\n            const too_small_PublishingInterval = 30;\n            const server_actualPublishingInterval = 100;\n\n            let subscriptionId = -1;\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                const createSubscriptionRequest = new CreateSubscriptionRequest({\n                                    requestedPublishingInterval: too_small_PublishingInterval,\n                                    requestedLifetimeCount: 60,\n                                    requestedMaxKeepAliveCount: 10,\n                                    maxNotificationsPerPublish: 10,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                });\n\n                                session.performMessageTransaction(createSubscriptionRequest, function (err, response) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n\n                                    if (doDebug) {\n                                        tracelog(\"response\", response.toString());\n                                    }\n\n                                    subscriptionId = response.subscriptionId;\n                                    response.revisedPublishingInterval.should.eql(Subscription.minimumPublishingInterval);\n\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        // If the Server specifies a value for the\n        // MinimumSamplingInterval Attribute it shall always return a revisedSamplingInterval that is equal or\n        // higher than the MinimumSamplingInterval if the Client subscribes to the Value Attribute.\n\n        function test_revised_sampling_interval(\n            requestedPublishingInterval,\n            requestedSamplingInterval,\n            revisedSamplingInterval,\n            done\n        ) {\n            const forcedMinimumInterval = 1;\n            const nodeId = \"ns=2;s=Static_Scalar_Int16\";\n\n            const node = server.engine.addressSpace.findNode(nodeId);\n            //xx tracelog(chalk.cyan(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"),node.toString());\n            const server_node = test.server.engine.addressSpace.rootFolder.objects.simulation.static[\"all Profiles\"].scalars.int16;\n            //xx tracelog(\"server_node.minimumSamplingInterval = \",server_node.minimumSamplingInterval);\n            server_node.minimumSamplingInterval = forcedMinimumInterval;\n\n            const itemToMonitor = new ReadValueId({\n                nodeId: nodeId,\n                attributeId: AttributeIds.Value\n            });\n            let subscriptionId = -1;\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function read_minimumSamplingInterval(callback) {\n                                let minimumSamplingIntervalOnNode;\n                                const nodeToRead = {\n                                    nodeId: nodeId,\n                                    attributeId: AttributeIds.MinimumSamplingInterval\n                                };\n                                session.read(nodeToRead, function (err, dataValue) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    dataValue.statusCode.should.eql(StatusCodes.Good);\n                                    minimumSamplingIntervalOnNode = dataValue.value.value;\n                                    //xx tracelog(\"minimumSamplingIntervalOnNode= =\",minimumSamplingIntervalOnNode);\n\n                                    minimumSamplingIntervalOnNode.should.eql(forcedMinimumInterval);\n\n                                    callback();\n                                });\n                            },\n                            function (callback) {\n                                const createSubscriptionRequest = new CreateSubscriptionRequest({\n                                    requestedPublishingInterval: requestedPublishingInterval,\n                                    requestedLifetimeCount: 60,\n                                    requestedMaxKeepAliveCount: 10,\n                                    maxNotificationsPerPublish: 10,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                });\n\n                                session.performMessageTransaction(createSubscriptionRequest, function (err, response) {\n                                    subscriptionId = response.subscriptionId;\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                const parameters = {\n                                    samplingInterval: requestedSamplingInterval,\n                                    discardOldest: false,\n                                    queueSize: 1\n                                };\n                                const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                                    subscriptionId: subscriptionId,\n                                    timestampsToReturn: TimestampsToReturn.Both,\n                                    itemsToCreate: [\n                                        {\n                                            itemToMonitor: itemToMonitor,\n                                            requestedParameters: parameters,\n                                            monitoringMode: MonitoringMode.Reporting\n                                        }\n                                    ]\n                                });\n\n                                //xx tracelog(\"createMonitoredItemsRequest = \", createMonitoredItemsRequest.toString());\n\n                                session.performMessageTransaction(createMonitoredItemsRequest, function (err, response) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    //xx tracelog(\"ERRR = \", err);\n                                    should.not.exist(err);\n                                    response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                                    //xx tracelog(response.results[0].toString());\n\n                                    response.results[0].statusCode.should.eql(StatusCodes.Good);\n                                    samplingInterval = response.results[0].revisedSamplingInterval;\n                                    samplingInterval.should.eql(\n                                        revisedSamplingInterval,\n                                        \"expected revisedSamplingInterval to be modified\"\n                                    );\n\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        }\n\n        const fastest_possible_sampling_rate = MonitoredItem.minimumSamplingInterval;\n        fastest_possible_sampling_rate.should.eql(50);\n\n        it(\"AZA3-S when createMonitored Item samplingInterval is Zero server shall return the fastest possible sampling rate\", function (done) {\n            // Spec : OpcUA 1.03 part 4 page 125 7.16 MonitoringParameters:\n            // The interval that defines the fastest rate at which the MonitoredItem(s) should be accessed and evaluated.\n            // This interval is defined in milliseconds.\n            // The value 0 indicates that the Server should use the fastest practical rate.\n            test_revised_sampling_interval(0, 0, fastest_possible_sampling_rate, done);\n        });\n\n        it(\"AZA3-T when createMonitored Item samplingInterval is -1 (minus one) server shall return the sampling rate of the subscription 1/2\", function (done) {\n            // Spec : OpcUA 1.03 part 4 page 125 7.16 MonitoringParameters:\n            // The value -1 indicates that the default sampling interval defined by the publishing interval of the\n            // Subscription is requested.\n            // A different sampling interval is used if the publishing interval is not a\n            // supported sampling interval.\n            // Any negative number is interpreted as -1. The sampling interval is not changed\n            // if the publishing interval is changed by a subsequent call to the ModifySubscription Service.\n            test_revised_sampling_interval(100, -1, 100, done);\n        });\n\n        it(\"AZA3-U when createMonitored Item samplingInterval is -1 (minus one) server shall return the sampling rate of the subscription 2/2\", function (done) {\n            test_revised_sampling_interval(200, -1, 200, done);\n        });\n\n        it(\"AZA3-V when createMonitored Item samplingInterval is too small, server shall return the sampling rate of the subscription\", function (done) {\n            // Spec : OpcUA 1.03 part 4 page 125 7.16 MonitoringParameters:\n            test_revised_sampling_interval(100, 10, fastest_possible_sampling_rate, done);\n        });\n\n        xit(\n            \"AZA3-W When a user adds a monitored item that the user is denied read access to, the add operation for the\" +\n                \" item shall succeed and the bad status  Bad_NotReadable  or  Bad_UserAccessDenied  shall be\" +\n                \" returned in the Publish response\",\n            function (done) {\n                done();\n            }\n        );\n\n        /**\n         * see CTT createMonitoredItems591014 ( -009.js)\n         */\n        function writeValue(nodeId, session, value, callback) {\n            const nodesToWrite = [\n                {\n                    nodeId: nodeId,\n                    attributeId: AttributeIds.Value,\n                    value: /*new DataValue(*/ {\n                        serverTimestamp: new Date(),\n                        sourceTimestamp: new Date(),\n                        value: {\n                            /* Variant */\n                            dataType: DataType.Double,\n                            value: value\n                        }\n                    }\n                }\n            ];\n\n            setTimeout(function () {\n                session.write(nodesToWrite, function (err, statusCodes) {\n                    statusCodes.length.should.eql(1);\n                    statusCodes[0].should.eql(StatusCodes.Good);\n                    setTimeout(function () {\n                        callback(err);\n                    }, 100);\n                });\n            }, 100);\n        }\n\n        function sendPublishRequest(session, callback) {\n            session.publish({}, function (err, response) {\n                try {\n                    callback(err, response);\n                } catch (err) {\n                    //xx tracelog('================> error =>'.red,err);\n                    callback(err, response);\n                }\n            });\n        }\n\n        function createSubscription2(session, createSubscriptionRequest, callback) {\n            createSubscriptionRequest = new CreateSubscriptionRequest(createSubscriptionRequest);\n\n            (typeof callback === \"function\").should.eql(true, \"expecting a function\");\n\n            session.performMessageTransaction(createSubscriptionRequest, function (err, response) {\n                response.subscriptionId.should.be.greaterThan(0);\n                subscriptionId = response.subscriptionId;\n                callback(err, response.subscriptionId, response);\n            });\n        }\n\n        const publishingInterval = 40;\n\n        function createSubscription(session, callback) {\n            (typeof callback === \"function\").should.eql(true, \"expecting a function\");\n            const createSubscriptionRequest = {\n                requestedPublishingInterval: publishingInterval,\n                requestedLifetimeCount: 600,\n                requestedMaxKeepAliveCount: 10,\n                maxNotificationsPerPublish: 10,\n                publishingEnabled: true,\n                priority: 6\n            };\n            createSubscription2(session, createSubscriptionRequest, callback);\n        }\n\n        function createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback) {\n            /* backdoor */\n            const node = server.engine.addressSpace.findNode(nodeId);\n            should.exist(node, \" \" + nodeId.toString() + \" must exist\");\n            node.minimumSamplingInterval.should.eql(0); // exception-based change notification\n\n            //xx parameters.samplingInterval.should.eql(0);\n\n            const createMonitoredItemsRequest = new CreateMonitoredItemsRequest({\n                subscriptionId: subscriptionId,\n                timestampsToReturn: TimestampsToReturn.Both,\n                itemsToCreate: [\n                    {\n                        itemToMonitor: itemToMonitor,\n                        requestedParameters: parameters,\n                        monitoringMode: MonitoringMode.Reporting\n                    }\n                ]\n            });\n\n            session.performMessageTransaction(createMonitoredItemsRequest, function (err, response) {\n                response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n\n                samplingInterval = response.results[0].revisedSamplingInterval;\n                //xx tracelog(\" revised Sampling interval \",samplingInterval);\n                callback(err);\n            });\n        }\n\n        function deleteSubscription(session, callback) {\n            session.deleteSubscriptions(\n                {\n                    subscriptionIds: [subscriptionId]\n                },\n                callback\n            );\n        }\n\n        function _test_with_queue_size_of_one(parameters, done) {\n            const nodeId = nodeIdVariant;\n\n            const itemToMonitor = new ReadValueId({\n                nodeId: nodeId,\n                attributeId: AttributeIds.Value\n            });\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                createSubscription(session, function (err, id) {\n                                    id.should.be.greaterThan(0);\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                            },\n\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    if (!err) {\n                                        //Xx var notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                    }\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                writeValue(nodeId, session, 1, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 2, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 3, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 4, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 5, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 6, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 7, callback);\n                            },\n\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    if (!err) {\n                                        response.notificationMessage.notificationData.length.should.eql(1);\n\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        notification.value.value.value.should.eql(7);\n\n                                        parameters.queueSize.should.eql(1);\n                                        notification.value.statusCode.should.eql(\n                                            StatusCodes.Good,\n                                            \"OverFlow bit shall not be set when queueSize =1\"\n                                        );\n                                    }\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        }\n\n        it(\"#CTT1 - should make sure that only the latest value is returned when queue size is one and discard oldest is false\", function (done) {\n            const samplingInterval = 0; // exception based\n            const parameters = {\n                samplingInterval: samplingInterval,\n                discardOldest: false,\n                queueSize: 1\n            };\n            _test_with_queue_size_of_one(parameters, done);\n        });\n        it(\"#CTT2 - should make sure that only the latest value is returned when queue size is one and discard oldest is true\", function (done) {\n            const samplingInterval = 0; // exception based\n            const parameters = {\n                samplingInterval: samplingInterval,\n                discardOldest: true,\n                queueSize: 1\n            };\n            _test_with_queue_size_of_one(parameters, done);\n        });\n\n        function _test_with_queue_size_of_two(parameters, expected_values, expected_statusCodes, done) {\n            const nodeId = nodeIdVariant;\n            const itemToMonitor = new ReadValueId({\n                nodeId: nodeId,\n                attributeId: AttributeIds.Value\n            });\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                createSubscription(session, callback);\n                            },\n\n                            function (callback) {\n                                createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                            },\n\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                    callback(err);\n                                });\n                            },\n\n                            function (callback) {\n                                writeValue(nodeId, session, 1, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 2, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 3, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 4, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 5, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 6, callback);\n                            },\n                            function (callback) {\n                                writeValue(nodeId, session, 7, callback);\n                            },\n                            function wait_a_little_bit(callback) {\n                                setTimeout(callback, 1000);\n                            },\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    if (!err) {\n                                        should(!!response.notificationMessage.notificationData).eql(true);\n                                        response.notificationMessage.notificationData.length.should.eql(1);\n\n                                        // we should have 2 elements in queue\n                                        response.notificationMessage.notificationData[0].monitoredItems.length.should.eql(2);\n\n                                        let notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        //xx tracelog(notification.value.value.value);\n                                        notification.value.value.value.should.eql(expected_values[0]);\n                                        notification.value.statusCode.should.eql(expected_statusCodes[0]);\n\n                                        notification = response.notificationMessage.notificationData[0].monitoredItems[1];\n                                        //xx tracelog(notification.value.value.value);\n                                        notification.value.value.value.should.eql(expected_values[1]);\n                                        notification.value.statusCode.should.eql(expected_statusCodes[1]);\n                                        //xx parameters.queueSize.should.eql(2);\n                                        //xx notification.value.statusCode.should.eql(StatusCodes.GoodWithOverflowBit, \"OverFlow bit shall not be set when queueSize =2\");\n                                    }\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        }\n\n        it(\"#CTT3 - should make sure that only the last 2 values are returned when queue size is two and discard oldest is TRUE\", function (done) {\n            const samplingInterval = 0;\n            const parameters = {\n                samplingInterval: samplingInterval,\n                discardOldest: true,\n                queueSize: 2\n            };\n\n            _test_with_queue_size_of_two(parameters, [6, 7], [StatusCodes.GoodWithOverflowBit, StatusCodes.Good], done);\n        });\n\n        it(\"#CTT4 - should make sure that only the last 2 values are returned when queue size is two and discard oldest is false\", function (done) {\n            const samplingInterval = 0;\n            const parameters = {\n                samplingInterval: samplingInterval,\n                discardOldest: false,\n                queueSize: 2\n            };\n            _test_with_queue_size_of_two(parameters, [1, 7], [StatusCodes.Good, StatusCodes.GoodWithOverflowBit], done);\n        });\n\n        it(\"#CTT5 Monitoring a non-Variable node with delayed PublishRequest:\", function (done) {\n            // CTT Monitored Item Service / Monitor Basic / 001.js\n            // Description:\n            //     Create a monitored item with the nodeId set to that of a non-Variable node and\n            //     the attributeId set to a non-Value attribute. call Publish().\n            //  Expected Results:\n            //      All service and operation level results are Good. Publish response contains a DataChangeNotification.\n\n            const parameters = {\n                samplingInterval: 0,\n                discardOldest: true,\n                queueSize: 1\n            };\n\n            const nodeId = nodeIdVariant;\n\n            const itemToMonitor = new ReadValueId({\n                nodeId: nodeId,\n                attributeId: AttributeIds.Description\n            });\n\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    async.series(\n                        [\n                            function (callback) {\n                                createSubscription(session, callback);\n                            },\n\n                            function (callback) {\n                                createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                            },\n\n                            function (callback) {\n                                sendPublishRequest(session, function (err, response) {\n                                    if (!err) {\n                                        response.notificationMessage.notificationData.length.should.eql(1);\n\n                                        //xx tracelog(\"xxxx \", response.notificationMessage.notificationData.toString());\n\n                                        //Xx var notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                    }\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        it(\"#CTT6 Late Publish should have data\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const nodeId = \"ns=2;s=Static_Scalar_Double\";\n                    const samplingInterval = 500;\n                    const parameters = {\n                        samplingInterval: samplingInterval,\n                        discardOldest: true,\n                        queueSize: 2\n                    };\n                    const itemToMonitor = new ReadValueId({\n                        nodeId: nodeId,\n                        attributeId: AttributeIds.Value\n                    });\n\n                    let time_to_wait = 0;\n\n                    async.series(\n                        [\n                            function (callback) {\n                                const publishingInterval = 100;\n                                const createSubscriptionRequest = new CreateSubscriptionRequest({\n                                    requestedPublishingInterval: publishingInterval,\n                                    requestedLifetimeCount: 30,\n                                    requestedMaxKeepAliveCount: 10,\n                                    maxNotificationsPerPublish: 10,\n                                    publishingEnabled: true,\n                                    priority: 6\n                                });\n                                createSubscription2(session, createSubscriptionRequest, function (err, subscriptionId, response) {\n                                    time_to_wait = response.revisedPublishingInterval * response.revisedLifetimeCount;\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                //xx tracelog(\" SubscriptionId =\",subscriptionId);\n                                callback();\n                            },\n                            function (callback) {\n                                createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                            },\n                            function (callback) {\n                                setTimeout(callback, time_to_wait + 1500);\n                            },\n\n                            function (callback) {\n                                //xx tracelog(\"--------------\");\n                                // we should get notified immediately that the session has timed out\n                                sendPublishRequest(session, function (err, response) {\n                                    response.notificationMessage.notificationData.length.should.eql(1);\n                                    const notificationData = response.notificationMessage.notificationData[0];\n                                    //xx tracelog(notificationData.toString());\n                                    //.monitoredItems[0];\n                                    notificationData.constructor.name.should.eql(\"StatusChangeNotification\");\n                                    notificationData.status.should.eql(StatusCodes.BadTimeout);\n                                    callback(err);\n                                });\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        describe(\"#CTT - Monitored Value Change\", function () {\n            it(\"should monitor a substring \", function (done) {\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, inner_done) {\n                        const nodeId = nodeIdString;\n                        const samplingInterval = 0;\n\n                        const parameters = {\n                            samplingInterval: samplingInterval,\n                            discardOldest: false,\n                            queueSize: 2\n                        };\n\n                        const itemToMonitor = new ReadValueId({\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            indexRange: \"4:10\"\n                        });\n\n                        async.series(\n                            [\n                                function (callback) {\n                                    createSubscription(session, callback);\n                                },\n\n                                function (callback) {\n                                    createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                                },\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        //xx tracelog(\"notification\", notification.toString());\n                                        notification.value.value.value.should.eql(\"EFGHIJK\");\n                                        callback(err);\n                                    });\n                                },\n\n                                function (callback) {\n                                    const nodesToWrite = [\n                                        {\n                                            nodeId: nodeId,\n                                            attributeId: AttributeIds.Value,\n                                            value: /*new DataValue(*/ {\n                                                value: {\n                                                    /* Variant */\n                                                    dataType: DataType.String,\n                                                    //      01234567890123456789012345\n                                                    value: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n                                                }\n                                            }\n                                        }\n                                    ];\n\n                                    session.write(nodesToWrite, function (err, statusCodes) {\n                                        statusCodes.length.should.eql(1);\n                                        statusCodes[0].should.eql(StatusCodes.Good);\n                                        callback(err);\n                                    });\n                                },\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        //xx tracelog(\"notification\", notification.toString());\n                                        notification.value.value.value.should.eql(\"VUTSRQP\");\n                                        callback(err);\n                                    });\n                                }\n                            ],\n                            inner_done\n                        );\n                    },\n                    done\n                );\n            });\n\n            it(\"ZZE it should return a publish Response with Bad_IndexRangeNoData , when the size of the monitored item change\", function (done) {\n                // as per CTT test 036.js (MonitoredItem Service/Monitored Value Changed\n                // Create a monitored item of an array with an IndexRange of \u201c2:4\u201d (the array must currently have at least five elements).\n                // call Publish(). Write to the array such that the size changes to two elements (0:1). call Publish().\n                // ExpectedResults:\n                // All service and operation level results are Good. Second Publish response contains a DataChangeNotification\n                // with a value.statusCode of Bad_IndexRangeNoData.\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, inner_done) {\n                        samplingInterval = 0; // exception based\n\n                        const nodeId = \"ns=2;s=Static_Array_Int32\";\n\n                        const parameters = {\n                            samplingInterval: 0, // exception based : whenever value changes\n                            discardOldest: false,\n                            queueSize: 2\n                        };\n\n                        const itemToMonitor = new ReadValueId({\n                            nodeId: nodeId,\n                            attributeId: AttributeIds.Value,\n                            indexRange: \"2:4\"\n                        });\n\n                        function write_node(value, callback) {\n                            assert(value instanceof Array);\n                            const nodeToWrite = {\n                                nodeId: nodeId,\n                                attributeId: AttributeIds.Value,\n                                value: /*new DataValue(*/ {\n                                    value: {\n                                        /* Variant */\n                                        arrayType: VariantArrayType.Array,\n                                        dataType: DataType.Int32,\n                                        value: new Int32Array(value)\n                                    }\n                                }\n                            };\n                            session.write(nodeToWrite, function (err, statusCode) {\n                                statusCode.should.eql(StatusCodes.Good);\n\n                                session.read(\n                                    {\n                                        attributeId: AttributeIds.Value,\n                                        nodeId: nodeId\n                                    },\n                                    function (err, dataValue) {\n                                        should.exist(dataValue);\n                                        //xxtracelog(\" written \",dataValue.value.toString());\n                                        callback(err);\n                                    }\n                                );\n                            });\n                        }\n\n                        async.series(\n                            [\n                                // write initial value => [1,2,3,4,5,6,7,8,9,10]\n                                write_node.bind(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n\n                                function (callback) {\n                                    createSubscription(session, callback);\n                                },\n\n                                function (callback) {\n                                    createMonitoredItems(session, nodeId, parameters, itemToMonitor, callback);\n                                },\n                                function (callback) {\n                                    setTimeout(callback, 100);\n                                },\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        notification.value.statusCode.should.eql(StatusCodes.Good);\n                                        notification.value.value.value.should.eql(new Int32Array([2, 3, 4]));\n                                        callback(err);\n                                    });\n                                },\n\n                                write_node.bind(null, [-1, -2]),\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        notification.value.statusCode.should.eql(StatusCodes.BadIndexRangeNoData);\n                                        should(notification.value.value.value).eql(null);\n                                        callback(err);\n                                    });\n                                },\n\n                                write_node.bind(null, [-1, -2, -3]),\n                                function (callback) {\n                                    setTimeout(callback, 100);\n                                },\n\n                                write_node.bind(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n\n                                function (callback) {\n                                    setTimeout(callback, 100);\n                                },\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        if (!err) {\n                                            response.notificationMessage.notificationData[0].monitoredItems.length.should.be.aboveOrEqual(\n                                                2,\n                                                \"expecting two monitoredItem in  notification data\"\n                                            );\n                                            const notification1 =\n                                                response.notificationMessage.notificationData[0].monitoredItems[0];\n                                            notification1.value.statusCode.should.eql(StatusCodes.Good);\n                                            notification1.value.value.value.should.eql(new Int32Array([-3]));\n                                            const notification2 =\n                                                response.notificationMessage.notificationData[0].monitoredItems[1];\n                                            notification2.value.statusCode.should.eql(StatusCodes.Good);\n                                            notification2.value.value.value.should.eql(new Int32Array([2, 3, 4]));\n                                        }\n                                        callback(err);\n                                    });\n                                },\n\n                                write_node.bind(null, [0, 1, 2, 3]),\n\n                                function (callback) {\n                                    sendPublishRequest(session, function (err, response) {\n                                        const notification = response.notificationMessage.notificationData[0].monitoredItems[0];\n                                        notification.value.statusCode.should.eql(StatusCodes.Good);\n                                        notification.value.value.value.should.eql(new Int32Array([2, 3]));\n                                        callback(err);\n                                    });\n                                },\n\n                                // restore orignal value\n                                write_node.bind(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n                            ],\n                            inner_done\n                        );\n                    },\n                    done\n                );\n            });\n        });\n\n        it(\"#ModifySubscriptionRequest: should return BadSubscriptionIdInvalid if client specifies a invalid subscriptionId\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const modifySubscriptionRequest = {\n                        subscriptionId: 999\n                    };\n\n                    session.modifySubscription(modifySubscriptionRequest, function (err) {\n                        err.message.should.match(/BadSubscriptionIdInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#ModifySubscriptionRequest: should return StatusGood\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const subscription = ClientSubscription.create(session, {\n                        requestedPublishingInterval: 10,\n                        requestedLifetimeCount: 60000,\n                        requestedMaxKeepAliveCount: 10,\n                        maxNotificationsPerPublish: 10,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n\n                    subscription.on(\"terminated\", function () {\n                        //xx tracelog(chalk.yellow(\" subscription terminated \"));\n                    });\n                    subscription.on(\"started\", function () {\n                        async.series(\n                            [\n                                function (callback) {\n                                    const modifySubscriptionRequest = {\n                                        subscriptionId: subscription.subscriptionId,\n                                        requestedPublishingInterval: 200\n                                    };\n                                    session.modifySubscription(modifySubscriptionRequest, function (err, response) {\n                                        response.revisedPublishingInterval.should.eql(200);\n\n                                        callback(err);\n                                    });\n                                },\n                                function (callback) {\n                                    subscription.terminate(callback);\n                                }\n                            ],\n                            inner_done\n                        );\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return BadSubscriptionIdInvalid when subscriptionId is invalid\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const setMonitoringModeRequest = {\n                        subscriptionId: 999\n                    };\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err) {\n                        err.message.should.match(/BadSubscriptionIdInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return BadNothingToDo if monitoredItemId is empty\", function (done) {\n            perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, inner_done) {\n                    const setMonitoringModeRequest = {\n                        subscriptionId: subscription.subscriptionId,\n                        monitoredItemIds: []\n                    };\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err) {\n                        err.message.should.match(/BadNothingToDo/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return BadMonitoredItemIdInvalid is monitoringMode is invalid\", function (done) {\n            const itemToMonitor = \"ns=0;i=2254\"; // temperatureVariableId;\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    const setMonitoringModeRequest = new SetMonitoringModeRequest({\n                        subscriptionId: subscription.subscriptionId,\n                        monitoringMode: MonitoringMode.Reporting,\n                        monitoredItemIds: [monitoredItem.monitoredItemId]\n                    });\n\n                    setMonitoringModeRequest.monitoringMode = 42;\n\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err) {\n                        should.exist(err);\n                        err.message.should.match(/BadMonitoringModeInvalid/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return BadMonitoredItemIdInvalid when monitoredItem is invalid\", function (done) {\n            const itemToMonitor = \"ns=0;i=2254\"; // temperatureVariableId;\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    const setMonitoringModeRequest = {\n                        subscriptionId: subscription.subscriptionId,\n                        monitoringMode: MonitoringMode.Sampling,\n                        monitoredItemIds: [monitoredItem.monitoredItemId + 9999]\n                    };\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err, response) {\n                        response.results.length.should.eql(1);\n                        response.results[0].should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n                        inner_done(err);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#SetMonitoringMode, should return Good when request is valid\", function (done) {\n            const itemToMonitor = \"ns=0;i=2254\"; // temperatureVariableId;\n            perform_operation_on_monitoredItem(\n                client,\n                endpointUrl,\n                itemToMonitor,\n                function (session, subscription, monitoredItem, inner_done) {\n                    const setMonitoringModeRequest = {\n                        subscriptionId: subscription.subscriptionId,\n                        monitoringMode: MonitoringMode.Sampling,\n                        monitoredItemIds: [monitoredItem.monitoredItemId]\n                    };\n                    session.setMonitoringMode(setMonitoringModeRequest, function (err, response) {\n                        response.results.length.should.eql(1);\n                        response.results[0].should.eql(StatusCodes.Good);\n                        inner_done(err);\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"#subscription operations should extend subscription lifetime\", function (done) {\n            this.timeout(Math.max(200000, this.timeout()));\n\n            // see CTT test063\n\n            let monitoredItem;\n\n            function step1(session, subscription, callback) {\n                monitoredItem = ClientMonitoredItem.create(\n                    subscription,\n                    {\n                        nodeId: resolveNodeId(\"ns=0;i=2254\"),\n                        attributeId: AttributeIds.Value\n                    },\n                    {\n                        samplingInterval: 100,\n                        discardOldest: true,\n                        queueSize: 1\n                    }\n                );\n\n                monitoredItem.on(\"initialized\", function () {\n                    callback();\n                });\n            }\n\n            function step2(session, subscription, callback) {\n                const setMonitoringModeRequest = {\n                    subscriptionId: subscription.subscriptionId,\n                    monitoringMode: MonitoringMode.Sampling,\n                    monitoredItemIds: [monitoredItem.monitoredItemId]\n                };\n                session.setMonitoringMode(setMonitoringModeRequest, function (err, response) {\n                    response.results[0].should.eql(StatusCodes.Good);\n                    callback(err);\n                });\n            }\n\n            function step3(session, subcription, callback) {\n                session.deleteSubscriptions(\n                    {\n                        subscriptionIds: [subcription.subscriptionId]\n                    },\n                    function (err, response) {\n                        should.exist(response);\n                        callback(err);\n                    }\n                );\n            }\n\n            const publishingInterval = 100;\n\n            function my_perform_operation_on_subscription(client, endpointUrl, do_func, done_func) {\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, done) {\n                        let subscription;\n                        async.series(\n                            [\n                                function (callback) {\n                                    subscription = ClientSubscription.create(session, {\n                                        requestedPublishingInterval: publishingInterval,\n                                        requestedLifetimeCount: 60,\n                                        requestedMaxKeepAliveCount: 10, // 10 requested here !\n                                        maxNotificationsPerPublish: 2,\n                                        publishingEnabled: true,\n                                        priority: 6\n                                    });\n                                    subscription.on(\"started\", function () {\n                                        callback();\n                                    });\n                                },\n\n                                function (callback) {\n                                    do_func(session, subscription, callback);\n                                },\n\n                                function (callback) {\n                                    subscription.terminate(callback);\n                                }\n                            ],\n                            function (err) {\n                                done(err);\n                            }\n                        );\n                    },\n                    done_func\n                );\n            }\n\n            my_perform_operation_on_subscription(\n                client,\n                endpointUrl,\n                function (session, subscription, inner_done) {\n                    subscription.publishingInterval.should.eql(publishingInterval);\n                    subscription.maxKeepAliveCount.should.eql(10);\n\n                    const waitingTime = subscription.publishingInterval * (subscription.maxKeepAliveCount - 3) - 100;\n\n                    let nb_keep_alive_received = 0;\n                    subscription.on(\"keepalive\", function () {\n                        nb_keep_alive_received += 1;\n                    });\n\n                    async.series(\n                        [\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(0);\n                                callback();\n                            },\n                            function (callback) {\n                                setTimeout(callback, subscription.publishingInterval * (subscription.maxKeepAliveCount + 2));\n                            },\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(1);\n                                callback();\n                            },\n\n                            function (callback) {\n                                setTimeout(callback, waitingTime);\n                            },\n                            function (callback) {\n                                step1(session, subscription, callback);\n                            },\n\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(2);\n                                callback();\n                            },\n\n                            function (callback) {\n                                setTimeout(callback, waitingTime);\n                            },\n                            function (callback) {\n                                step2(session, subscription, callback);\n                            },\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(2);\n                                callback();\n                            },\n\n                            function (callback) {\n                                setTimeout(callback, waitingTime);\n                            },\n                            function (callback) {\n                                step3(session, subscription, callback);\n                            },\n                            function (callback) {\n                                nb_keep_alive_received.should.eql(2);\n                                callback();\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n\n        describe(\"#Republish\", function () {\n            let VALID_SUBSCRIPTION;\n            let VALID_RETRANSMIT_SEQNUM = 0;\n            const INVALID_SUBSCRIPTION = 1234;\n            const INVALID_RETRANSMIT_SEQNUM = 1234;\n\n            let g_session;\n            let client, fanSpeed;\n            before(function (done) {\n                VALID_RETRANSMIT_SEQNUM = 0;\n\n                client = OPCUAClient.create();\n                fanSpeed = server.engine.addressSpace.findNode(\"ns=1;s=FanSpeed\");\n                should.exist(fanSpeed);\n                //xxx tracelog(fanSpeed.toString());\n                done();\n            });\n\n            function inner_test(the_test_function, done) {\n                perform_operation_on_client_session(\n                    client,\n                    endpointUrl,\n                    function (session, inner_done) {\n                        g_session = session;\n                        async.series(\n                            [\n                                function (callback) {\n                                    // CreateSubscriptionRequest\n                                    const request = new CreateSubscriptionRequest({\n                                        requestedPublishingInterval: 100,\n                                        requestedLifetimeCount: 60,\n                                        requestedMaxKeepAliveCount: 10,\n                                        maxNotificationsPerPublish: 2000,\n                                        publishingEnabled: true,\n                                        priority: 6\n                                    });\n                                    g_session.createSubscription(request, function (err, response) {\n                                        if (err) {\n                                            return callback(err);\n                                        }\n                                        VALID_SUBSCRIPTION = response.subscriptionId;\n                                        callback();\n                                    });\n                                },\n\n                                function (callback) {\n                                    // CreateMonitoredItemsRequest\n                                    const request = new CreateMonitoredItemsRequest({\n                                        subscriptionId: VALID_SUBSCRIPTION,\n                                        timestampsToReturn: TimestampsToReturn.Both,\n                                        itemsToCreate: [\n                                            {\n                                                itemToMonitor: {\n                                                    nodeId: fanSpeed.nodeId\n                                                    // nodeId: makeNodeId(VariableIds.Server_ServerStatus_CurrentTime)\n                                                },\n                                                monitoringMode: MonitoringMode.Reporting,\n                                                requestedParameters: {\n                                                    clientHandle: 26,\n                                                    samplingInterval: 10,\n                                                    filter: null,\n                                                    queueSize: 100,\n                                                    discardOldest: true\n                                                }\n                                            }\n                                        ]\n                                    });\n\n                                    g_session.createMonitoredItems(request, function (err, response) {\n                                        response.should.be.instanceof(CreateMonitoredItemsResponse);\n                                        response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                                        response.results.length.should.eql(1);\n                                        response.results[0].statusCode.should.eql(StatusCodes.Good);\n\n                                        callback(err);\n                                    });\n                                },\n\n                                function (callback) {\n                                    fanSpeed.setValueFromSource(new Variant({ dataType: DataType.Double, value: 1 }));\n                                    setTimeout(callback, 50);\n                                    fanSpeed.setValueFromSource(new Variant({ dataType: DataType.Double, value: 2 }));\n                                    //tracelog(fanSpeed.toString());\n                                },\n\n                                //publish_republish,\n\n                                function (callback) {\n                                    // publish request now requires a subscriptions\n                                    const request = new PublishRequest({\n                                        subscriptionAcknowledgements: []\n                                    });\n                                    g_session.publish(request, function (err, response) {\n                                        assert(response instanceof PublishResponse);\n                                        assert(response.availableSequenceNumbers.length > 0);\n                                        VALID_RETRANSMIT_SEQNUM = response.availableSequenceNumbers[0];\n                                        VALID_RETRANSMIT_SEQNUM.should.not.eql(0);\n\n                                        callback(err);\n                                    });\n                                },\n\n                                the_test_function\n                            ],\n                            inner_done\n                        );\n                    },\n                    done\n                );\n            }\n\n            it(\"server should handle Republish request (BadMessageNotAvailable) \", function (done) {\n                inner_test(function (done) {\n                    const request = new RepublishRequest({\n                        subscriptionId: VALID_SUBSCRIPTION,\n                        retransmitSequenceNumber: INVALID_RETRANSMIT_SEQNUM\n                    });\n                    g_session.republish(request, function (err, response) {\n                        should.exist(err);\n                        should.not.exist(response);\n                        err.response.should.be.instanceof(ServiceFault);\n                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadMessageNotAvailable);\n                        done();\n                    });\n                }, done);\n            });\n\n            it(\"server should handle Republish request (BadSubscriptionIdInvalid) \", function (done) {\n                inner_test(function (done) {\n                    VALID_RETRANSMIT_SEQNUM.should.not.eql(0);\n\n                    const request = new RepublishRequest({\n                        subscriptionId: INVALID_SUBSCRIPTION,\n                        retransmitSequenceNumber: VALID_RETRANSMIT_SEQNUM\n                    });\n                    g_session.republish(request, function (err, response) {\n                        should.exist(err);\n                        should.not.exist(response);\n                        err.response.should.be.instanceof(ServiceFault);\n                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadSubscriptionIdInvalid);\n                        done();\n                    });\n                }, done);\n            });\n\n            it(\"server should handle Republish request (Good) \", function (done) {\n                inner_test(function (done) {\n                    VALID_RETRANSMIT_SEQNUM.should.not.eql(0);\n\n                    const request = new RepublishRequest({\n                        subscriptionId: VALID_SUBSCRIPTION,\n                        retransmitSequenceNumber: VALID_RETRANSMIT_SEQNUM\n                    });\n\n                    g_session.republish(request, function (err, response) {\n                        response.should.be.instanceof(RepublishResponse);\n                        response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                        done(err);\n                    });\n                }, done);\n            });\n        });\n    });\n};\n", "// Description: CloseSession while specifying DeleteSubscriptions=FALSE. Create a subscription with 1 monitored item.\n// When the session is closed, we are JUST going to close the Session. The subscription and monitoredItem will NOT be cleaned-up.\n// We'll then create another session. We'll try to TRANSFER the subscription to the new session. We're expecting the subscription to be present!\n// We ARE checking if TransferSubscription is Bad_NotImplemented. If so, then the test result is a Warning with a message of Inconclusive. \n\"use strict\";\nconst async = require(\"async\");\nconst should = require(\"should\");\nconst sinon = require(\"sinon\");\n\nconst opcua = require(\"node-opcua\");\nconst StatusCodes = opcua.StatusCodes;\nconst OPCUAClient = opcua.OPCUAClient;\nconst ClientSubscription = opcua.ClientSubscription;\n\n\nconst { perform_operation_on_client_session } = require(\"../../test_helpers/perform_operation_on_client_session\");\n\nconst { perform_operation_on_subscription_with_parameters } = require(\"../../test_helpers/perform_operation_on_client_session\");\n\nmodule.exports = function (test) {\n\n    describe(\"#TSS TransferSessionService\", function () {\n\n        let endpointUrl;\n        beforeEach(function (done) {\n            endpointUrl = test.endpointUrl;\n            done();\n        });\n        let subscription;\n\n        const spy_on_terminated = new sinon.spy();\n\n        function create_subscription_and_close_session(callback) {\n\n            const client = OPCUAClient.create();\n            let the_subscriptionId;\n\n            let the_session;\n\n            async.series([\n\n                function (callback) {\n                    client.connect(endpointUrl, function (err) {\n                        callback(err);\n                    });\n                },\n\n                // create session\n                function (callback) {\n                    client.createSession(function (err, session) {\n                        if (!err) {\n                            the_session = session;\n                        }\n                        callback(err);\n                    });\n                },\n\n                function (callback) {\n                    subscription = ClientSubscription.create(the_session, {\n                        requestedPublishingInterval: 100,\n                        requestedLifetimeCount: 10 * 60,\n                        requestedMaxKeepAliveCount: 5,\n                        maxNotificationsPerPublish: 2,\n                        publishingEnabled: true,\n                        priority: 6\n                    });\n                    subscription.on(\"started\", function () {\n                        the_subscriptionId = subscription.subscriptionId;\n                        subscription.on(\"terminated\", spy_on_terminated);\n                        callback();\n                    });\n                },\n\n                // closing session\n                function (callback) {\n                    the_session.close(/*deleteSubscription=*/false, function (err) {\n                        callback(err);\n                    });\n                },\n                function (callback) {\n                    client.disconnect(callback);\n                }\n            ], function (err) {\n                callback(err, the_subscriptionId);\n            });\n        }\n\n        it(\"TSS-1 should transfer a subscription\", function (done) {\n\n            let the_subscriptionId;\n            async.series([\n\n                function (callback) {\n                    create_subscription_and_close_session(function (err, subscriptionId) {\n                        the_subscriptionId = subscriptionId;\n                        callback(err);\n                    });\n                },\n                function (callback) {\n                    //xx console.log(\"SubscriptionId \", the_subscriptionId);\n                    callback();\n                },\n                function (callback) {\n                    const client2 = OPCUAClient.create();\n                    perform_operation_on_client_session(client2, endpointUrl, function (session, done) {\n\n                        session.transferSubscriptions({\n                            subscriptionIds: [the_subscriptionId],\n                            sendInitialValues: true\n                        }, function (err, response) {\n\n                            spy_on_terminated.callCount.should.eql(0);\n                            response.results.length.should.eql(1);\n                            //xx console.log(\" => \", response.results[0].toString());\n\n                            subscription.terminate(function (err1) { done(err); });\n\n                        });\n                    }, function (err) {\n\n                        if (!err) {\n                            spy_on_terminated.callCount.should.eql(1);\n                        }\n                        callback(err);\n                    });\n                }\n            ], done);\n        });\n\n        it(\"TSS-2 should transfer a subscription from a live session to an other\", async () => {\n\n            const client = OPCUAClient.create();\n\n            await client.connect(endpointUrl);\n\n            const the_session1 = await client.createSession();\n\n            subscription = await the_session1.createSubscription2({\n                requestedPublishingInterval: 100,\n                requestedLifetimeCount: 10 * 60,\n                requestedMaxKeepAliveCount: 5,\n                maxNotificationsPerPublish: 2,\n                publishingEnabled: true,\n                priority: 6\n            });\n            subscription.on(\"terminated\", spy_on_terminated);\n\n            const the_subscriptionId = subscription.subscriptionId;\n\n            const the_session2 = await client.createSession();\n\n            try {\n              \n                const response = await the_session2.transferSubscriptions({\n                    subscriptionIds: [the_subscriptionId],\n                    sendInitialValues: true\n                });\n\n                //xx console.log(\"response\",response.toString());\n                response.results.length.should.eql(1);\n                response.results[0].statusCode.should.eql(StatusCodes.Good);\n\n\n                // deleting subscription on session1 shall fail\n                const response1 = await the_session1.deleteSubscriptions({\n                    subscriptionIds: [the_subscriptionId]\n                });\n                response1.results.length.should.eql(1);\n                response1.results[0].should.eql(StatusCodes.BadSubscriptionIdInvalid);\n\n                // deleting subscription on session2 shall succeed\n                const response3 = await the_session2.deleteSubscriptions({\n                    subscriptionIds: [the_subscriptionId]\n                });\n                response3.results.length.should.eql(1);\n                response3.results[0].should.eql(StatusCodes.Good);\n            } finally {\n                // closing session 1\n                await the_session1.close(/*deleteSubscription=*/true);\n                await the_session2.close(/*deleteSubscription=*/true);\n                await client.disconnect();\n            }\n\n        });\n\n        it(\"TSS-3 should send a StatusChangeNotification to the old session with GoodSubscriptionTransferred\", function (done) {\n            const client = OPCUAClient.create();\n            const spy_status_changed = new sinon.spy();\n            let the_session2;\n            const spy_keepalive = new sinon.spy();\n\n            const subscriptionParameters = {\n                requestedPublishingInterval: 100,\n                requestedLifetimeCount: 6000,\n                requestedMaxKeepAliveCount: 10,\n                maxNotificationsPerPublish: 4,\n                publishingEnabled: true,\n                priority: 6\n            };\n            perform_operation_on_subscription_with_parameters(client, endpointUrl, subscriptionParameters,  function (session, subscription, inner_done) {\n\n                subscription.on(\"status_changed\", spy_status_changed);\n                subscription.on(\"keepalive\", spy_keepalive);\n                async.series([\n                    function (callback) {\n\n                        const timeout = subscription.publishingInterval * (subscription.maxKeepAliveCount + 2);\n                        setTimeout(function () {\n                            //xx console.log(\"StatusChange Count \", spy_status_changed.callCount, \" keepAlive count = \", spy_keepalive.callCount);\n                            spy_status_changed.callCount.should.eql(0);\n                            spy_keepalive.callCount.should.be.aboveOrEqual(1);\n                            callback();\n                        }, timeout);\n                    },\n                    function (callback) {\n                        client.createSession(function (err, session) {\n                            if (!err) {\n                                the_session2 = session;\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    function (callback) {\n                        setTimeout(callback, 500);\n                    },\n\n                    // session2.transferSubscriptions\n                    function (callback) {\n                        const options = {\n                            subscriptionIds: [subscription.subscriptionId],\n                            sendInitialValues: true\n                        };\n                        the_session2.transferSubscriptions(options, function (err, response) {\n                            //xx console.log(\"response\",response.toString());\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            if (!err) {\n                                /* */\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    function (callback) {\n                        setTimeout(function () {\n                            //xx console.log(\"StatusChange Count \", spy_status_changed.callCount, \" keepAlive count = \", spy_keepalive.callCount);\n                            spy_status_changed.callCount.should.eql(1);\n                            callback();\n                        }, 1000);\n                    },\n                    function (callback) {\n                        the_session2.close(callback);\n                    }\n\n                ], function (err) {\n                    //xx console.log(\"-------------------\", subscription.subscriptionId);\n                    inner_done(err);\n                });\n\n            }, done);\n\n        });\n\n        it(\"TSS-4 should resend initialValue on monitored Item\", function (done) {\n\n            const client = OPCUAClient.create();\n            let the_session2;\n\n            const itemToMonitor = new opcua.ReadValueId({\n                nodeId: \"ns=2;s=Static_Scalar_Double\",\n                attributeId: opcua.AttributeIds.Value\n            });\n\n            const parameters = {\n                clientHandle: 26,\n                samplingInterval: 250,\n                discardOldest: false,\n                queueSize: 10,\n                filter: null\n            };\n\n\n            const spy_publish_session1 = new sinon.spy();\n            const spy_publish_session2 = new sinon.spy();\n\n            perform_operation_on_client_session(client, endpointUrl, function (session, inner_done) {\n\n                let subscriptionId;\n                async.series([\n\n                    // Create Subscription on session1\n                    function (callback) {\n                        const request = new opcua.CreateSubscriptionRequest({\n                            requestedPublishingInterval: 100,\n                            requestedLifetimeCount: 1000,\n                            requestedMaxKeepAliveCount: 30,\n                            maxNotificationsPerPublish: 2000,\n                            publishingEnabled: true,\n                            priority: 6\n                        });\n                        session.createSubscription(request, function (err, response) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            subscriptionId = response.subscriptionId;\n                            callback();\n                        });\n                    },\n\n                    // Create MonitoredItem on session1 with many publish request in queue\n                    function (callback) {\n                        // CreateMonitoredItemsRequest\n                        const request = new opcua.CreateMonitoredItemsRequest({\n                            subscriptionId: subscriptionId,\n                            timestampsToReturn: opcua.TimestampsToReturn.Both,\n                            itemsToCreate: [\n                                {\n                                    itemToMonitor: itemToMonitor,\n                                    monitoringMode: opcua.MonitoringMode.Reporting,\n                                    requestedParameters: parameters\n                                }\n                            ]\n                        });\n\n                        session.createMonitoredItems(request, function (err, response) {\n\n                            response.should.be.instanceof(opcua.CreateMonitoredItemsResponse);\n                            response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            response.results[0].revisedSamplingInterval.should.eql(250);\n\n                            // send many publish requests, in one go\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n                            session.publish({}, spy_publish_session1);\n\n                            callback(err);\n                        });\n                    },\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(function () {\n                            callback();\n                        }, parameters.samplingInterval);\n                    },\n\n                    // create Session 2\n                    function (callback) {\n                        client.createSession(function (err, l_session) {\n                            if (!err) {\n                                the_session2 = l_session;\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    // session2.transferSubscriptions\n                    function (callback) {\n                        const options = {\n                            subscriptionIds: [subscriptionId],\n                            sendInitialValues: true\n                        };\n                        the_session2.transferSubscriptions(options, function (err, response) {\n                            //xx console.log(\"response\",response.toString());\n                            response.results.length.should.eql(1);\n                            response.results[0].statusCode.should.eql(StatusCodes.Good);\n                            if (!err) {\n                                /** */\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(function () {\n                            callback();\n                        }, parameters.samplingInterval);\n                    },\n\n                    // session 1 should receive StatusChangeNotification\n                    function (callback) {\n\n                        //xx console.log(\"count = \", spy_publish_session1.callCount);\n\n                        const response0 = spy_publish_session1.getCall(0).args[1];\n                        //xx console.log(\"response=\",response0.toString());\n                        response0.notificationMessage.notificationData.length.should.eql(1);\n                        response0.subscriptionId.should.eql(subscriptionId);\n                        const notification0 = response0.notificationMessage.notificationData[0];\n                        notification0.constructor.name.should.eql(\"DataChangeNotification\");\n\n                        const response1 = spy_publish_session1.getCall(1).args[1];\n                        //xx console.log(\"response=\",response1.toString());\n                        response1.notificationMessage.notificationData.length.should.eql(1);\n                        response1.subscriptionId.should.eql(subscriptionId);\n                        const notification1 = response1.notificationMessage.notificationData[0];\n                        notification1.constructor.name.should.eql(\"StatusChangeNotification\");\n\n                        callback();\n                    },\n\n\n                    function (callback) {\n                        the_session2.publish({}, spy_publish_session2);\n                        the_session2.publish({}, spy_publish_session2);\n                        the_session2.publish({}, spy_publish_session2);\n                        the_session2.publish({}, spy_publish_session2);\n                        callback();\n                    },\n\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(function () {\n                            callback();\n                        }, parameters.samplingInterval);\n                    },\n                    // wait a little bit\n                    function (callback) {\n                        setTimeout(function () {\n                            callback();\n                        }, parameters.samplingInterval);\n                    },\n\n                    function (callback) {\n                        //Xx console.log(\"count = \", spy_publish_session2.callCount);\n\n                        const response0 = spy_publish_session2.getCall(0).args[1];\n                        //xx console.log(\"response=\",response0.toString());\n                        response0.notificationMessage.notificationData.length.should.eql(1);\n                        response0.subscriptionId.should.eql(subscriptionId);\n                        const notification0 = response0.notificationMessage.notificationData[0];\n                        notification0.constructor.name.should.eql(\"DataChangeNotification\");\n\n                        callback();\n\n                    },\n\n                    // now delete subscription\n                    function (callback) {\n                        the_session2.deleteSubscriptions({ subscriptionIds: [subscriptionId] }, callback);\n                    },\n\n                    function (callback) {\n                        the_session2.close(callback);\n                    },\n                    function (callback) {\n                        //xx console.log(\"count = \", spy_publish_session2.callCount);\n                        spy_publish_session2.callCount.should.eql(4);\n\n                        const response1 = spy_publish_session2.getCall(1).args[1];\n                        const response2 = spy_publish_session2.getCall(2).args[1];\n                        const response3 = spy_publish_session2.getCall(3).args[1];\n                        should.not.exist(response1);\n                        should.not.exist(response2);\n                        should.not.exist(response3);\n\n                        const err1 = spy_publish_session2.getCall(1).args[0];\n                        const err2 = spy_publish_session2.getCall(2).args[0];\n                        const err3 = spy_publish_session2.getCall(3).args[0];\n                        \n                        err1.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n                        err2.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n                        err3.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n                        //xx console.log(response1.toString())\n                        //xx console.log(response2.toString())\n                        //xx console.log(response3.toString())\n                        callback();\n                    }\n                ], function (err) {\n                    //xx console.log(\"-------------------\", subscriptionId);\n                    inner_done(err);\n                });\n\n            }, done);\n\n        });\n\n    });\n\n};\n\n", "\"use strict\";\nconst should = require(\"should\");\nconst async = require(\"async\");\n\nconst {\n    BrowseDirection,\n    VariableIds,\n    AttributeIds,\n    StatusCodes,\n    Variant,\n    DataType,\n    DataValue,\n    ReferenceTypeIds,\n    makeNodeId,\n    VariantArrayType,\n    ReadRequest,\n    TimestampsToReturn,\n    OPCUAClient,\n    coerceNodeId\n} = require(\"node-opcua\");\n\nconst fail_fast_connectivity_strategy = {\n    maxRetry: 1,\n    initialDelay: 10,\n    maxDelay: 20,\n    randomisationFactor: 0\n};\n\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\nmodule.exports = function (test) {\n    describe(\"Browse-Read-Write Services\", function () {\n\n        /** @type {ClientSession} */\n        let g_session = null;\n\n        // use fail fast connectionStrategy\n        const options = { connectionStrategy: fail_fast_connectivity_strategy };\n\n        let client;\n        let endpointUrl;\n        let temperatureVariableId;\n        beforeEach(function (done) {\n            endpointUrl = test.endpointUrl;\n            temperatureVariableId = test.server.temperatureVariableId;\n            client = OPCUAClient.create(options);\n\n            client.connect(endpointUrl, function (err) {\n                if (err) {\n                    done(err);\n                } else {\n                    client.createSession(function (err, session) {\n                        g_session = session;\n                        done(err);\n                    });\n                }\n            });\n        });\n\n        afterEach(function (done) {\n            if (!g_session) {\n                return client.disconnect(done);\n            }\n            g_session.close(function () {\n                client.disconnect(done);\n            });\n        });\n\n        it(\"T8-1 - should browse RootFolder\", function (done) {\n            g_session.browse(\"RootFolder\", function (err, browseResult) {\n                if (!err) {\n                    browseResult.schema.name.should.equal(\"BrowseResult\");\n                }\n\n                // xx console.log(browseResult.toString());//.length.should.eql(4);\n\n                browseResult.statusCode.should.eql(StatusCodes.Good);\n                browseResult.references.length.should.eql(3);\n                browseResult.references[0].browseName.toString().should.eql(\"Objects\");\n                browseResult.references[1].browseName.toString().should.eql(\"Types\");\n                browseResult.references[2].browseName.toString().should.eql(\"Views\");\n\n                done(err);\n            });\n        });\n\n        it(\"T8-2 - browse should return BadReferenceTypeIdInvalid if referenceTypeId is invalid\", function (done) {\n            const bad_referenceid_node = \"ns=3;i=3500\";\n            const nodeToBrowse = {\n                nodeId: \"ObjectsFolder\",\n                referenceTypeId: bad_referenceid_node,\n                browseDirection: BrowseDirection.Forward\n            };\n            g_session.browse(nodeToBrowse, function (err, browseResult /*, diagnosticInfos*/) {\n                browseResult.schema.name.should.equal(\"BrowseResult\");\n                browseResult.statusCode.should.eql(StatusCodes.BadReferenceTypeIdInvalid);\n                done(err);\n            });\n        });\n\n        it(\"T8-3 - should read a Variable\", function (done) {\n            g_session.readVariableValue([\"RootFolder\"], function (err, dataValues /*, diagnosticInfos*/) {\n                if (!err) {\n                    dataValues.length.should.equal(1);\n                    dataValues[0].schema.name.should.equal(\"DataValue\");\n                }\n                done(err);\n            });\n        });\n        it(\"T8-11 - #ReadRequest : server should return BadNothingToDo when nodesToRead is empty\", function (done) {\n            const request = new ReadRequest({\n                nodesToRead: [], //<< EMPTY\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Both\n            });\n\n            g_session.performMessageTransaction(request, function (err /*, response */) {\n                //\n                err.message.should.match(/BadNothingToDo/);\n                done();\n            });\n        });\n\n        it(\"T8-12 - #ReadRequest : server should return BadTimestampsToReturnInvalid when timestampsToReturn is Invalid\", function (done) {\n            const request = new ReadRequest({\n                nodesToRead: [{ nodeId: coerceNodeId(\"ns=0;i=2456\") }],\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Invalid\n            });\n\n            g_session.performMessageTransaction(request, function (err /*, response*/) {\n                //\n                err.message.should.match(/BadTimestampsToReturnInvalid/);\n                done();\n            });\n        });\n\n        it(\"T8-13 - should readAllAttributes - 1 element\", function (done) {\n            g_session.readAllAttributes(\"RootFolder\", function (err, data) {\n                should.not.exist(err);\n                data.nodeId.toString().should.eql(\"ns=0;i=84\");\n                data.statusCode.should.eql(StatusCodes.Good);\n                data.browseName.toString().should.eql(\"Root\");\n                done(err);\n            });\n        });\n\n        it(\"T8-13b - should readAllAttributes - 2 elements\", function (done) {\n            g_session.readAllAttributes([\"RootFolder\", \"ObjectsFolder\"], function (err, data) {\n                data.length.should.eql(2);\n                data[0].browseName.toString().should.eql(\"Root\");\n                data[1].browseName.toString().should.eql(\"Objects\");\n                done(err);\n            });\n        });\n\n        it(\"T8-14a - #readVariableValue should return a appropriate status code if nodeid to read doesn't exists\", function (done) {\n            g_session.readVariableValue(\"ns=1;s=this_node_id_does_not_exist\", function (err, dataValue) {\n                should.not.exist(err);\n                dataValue.statusCode.should.eql(StatusCodes.BadNodeIdUnknown);\n                done();\n            });\n        });\n        it(\"T8-14b - #readVariableValue should return a appropriate status code if nodeid to read doesn't exists\", function (done) {\n            g_session.readVariableValue([\"ns=1;s=this_node_id_does_not_exist\"], function (err, dataValues) {\n                should.not.exist(err);\n                dataValues[0].statusCode.should.eql(StatusCodes.BadNodeIdUnknown);\n                done();\n            });\n        });\n        it(\"T8-15 - #read should return BadNothingToDo when reading an empty nodeToRead array\", function (done) {\n            const nodesToRead = [];\n\n            g_session.read(nodesToRead, function (err, dataValues) {\n                if (err) {\n                    const response = err.response;\n                    //dataValues.length.should.be(1);\n                    response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                    done();\n                } else {\n                    done(new Error(\"Expecting an error here\"));\n                }\n            });\n        });\n\n        it(\"T8-15b - #read :should return BadNothingToDo if nodesToRead is empty\", function (done) {\n            // CTT : Attribute ERR-011.js\n            const readRequest = new ReadRequest({\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Both,\n                nodesToRead: []\n            });\n\n            g_session.performMessageTransaction(readRequest, function (err /*, response*/) {\n                if (err) {\n                    err.message.should.match(/BadNothingToDo/);\n                    done();\n                } else {\n                    done(new Error(\"expecting BadNothingToDo\"));\n                }\n            });\n        });\n\n        it(\"T8-15c - #read :should return BadNothingToDo if nodesToRead is null\", function (done) {\n            // CTT : Attribute ERR-011.js\n            const readRequest = new ReadRequest({\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Both,\n                nodesToRead: null\n            });\n\n            // make sure nodesToRead is really null !\n            readRequest.nodesToRead = null;\n\n            g_session.performMessageTransaction(readRequest, function (err /*, response*/) {\n                if (err) {\n                    err.message.should.match(/BadNothingToDo/);\n                    done();\n                } else {\n                    done(new Error(\"expecting BadNothingToDo\"));\n                }\n            });\n        });\n\n        it(\"T8-16 - #read should return BadMaxAgeInvalid when Negative MaxAge parameter is specified\", function (done) {\n            const nodesToRead = {\n                nodeId: \"RootFolder\",\n                attributeId: 13\n            };\n\n            g_session.read(nodesToRead, -20000, function (err, dataValue) {\n                if (err) {\n                    //Xx console.log(err);\n                    err.message.should.match(/BadMaxAgeInvalid/);\n                    done();\n                } else {\n                    done(new Error(\"Expecting an error here\"));\n                }\n            });\n        });\n\n        it(\"T8-17 - #readVariableValue - should read the TemperatureTarget value\", function (done) {\n            g_session.readVariableValue([temperatureVariableId.nodeId], function (err, dataValues /*, diagnosticInfos*/) {\n                if (!err) {\n                    dataValues.length.should.equal(1);\n                    dataValues[0].schema.name.should.equal(\"DataValue\");\n                    dataValues[0].value.schema.name.should.equal(\"Variant\");\n                }\n\n                done(err);\n            });\n        });\n\n        it(\"T8-20 - #writeSingleNode -  should write the TemperatureTarget value\", function (done) {\n            // write a single value\n            g_session.write(\n                {\n                    nodeId: temperatureVariableId.nodeId,\n                    attributeId: AttributeIds.Value,\n                    value: {\n                        value: {\n                            dataType: DataType.Double,\n                            value: 37.5\n                        }\n                    }\n                },\n                function (err, statusCode /*,diagnosticInfo*/) {\n                    if (!err) {\n                        statusCode.should.eql(StatusCodes.Good);\n                    }\n                    done(err);\n                }\n            );\n        });\n\n        it(\"T9-1 - Server should expose a 'Server' object in the 'Objects' folder\", function (done) {\n            const Organizes = makeNodeId(ReferenceTypeIds.Organizes); // \"ns=0;i=35\";\n            const nodesToBrowse = [\n                {\n                    nodeId: \"ObjectsFolder\",\n                    referenceTypeId: Organizes,\n                    browseDirection: BrowseDirection.Forward,\n                    resultMask: 0x3f\n                }\n            ];\n\n            g_session.browse(nodesToBrowse, function (err, browseResults /*,diagnosticInfos*/) {\n                if (!err) {\n                    browseResults.length.should.equal(1);\n                    browseResults[0].schema.name.should.equal(\"BrowseResult\");\n\n                    //xx console.log(util.inspect(browseResults[0].references,{colors:true,depth:10}));\n\n                    const foundNode = browseResults[0].references.filter((result) => result.browseName.name === \"Server\");\n\n                    foundNode.length.should.equal(1);\n                    foundNode[0].browseName.name.should.equal(\"Server\");\n                    foundNode[0].nodeId.toString().should.equal(\"ns=0;i=2253\");\n                }\n                done(err);\n            });\n        });\n\n        it(\"T9-2 - Server should expose 'Server_NamespaceArray' variable \", function (done) {\n            const server_NamespaceArray_Id = makeNodeId(VariableIds.Server_NamespaceArray); // ns=0;i=2255\n            g_session.readVariableValue(server_NamespaceArray_Id, function (err, dataValue /*, diagnosticsInfo*/) {\n                if (err) {\n                    return done(err);\n                }\n                dataValue.should.be.instanceOf(DataValue);\n                dataValue.statusCode.should.eql(StatusCodes.Good);\n                dataValue.value.dataType.should.eql(DataType.String);\n                dataValue.value.arrayType.should.eql(VariantArrayType.Array);\n\n                // first namespace must be standard OPC namespace\n                dataValue.value.value[0].should.eql(\"http://opcfoundation.org/UA/\");\n\n                done(err);\n            });\n        });\n\n        it(\"T9-3 - ServerStatus object shall be accessible as a ExtensionObject\", function (done) {\n            const server_NamespaceArray_Id = makeNodeId(VariableIds.Server_ServerStatus); // ns=0;i=2255\n            g_session.readVariableValue(server_NamespaceArray_Id, function (err, dataValue /*, diagnosticsInfo*/) {\n                if (err) {\n                    return done(err);\n                }\n                dataValue.should.be.instanceOf(DataValue);\n                dataValue.statusCode.should.eql(StatusCodes.Good);\n                dataValue.value.dataType.should.eql(DataType.ExtensionObject);\n\n                done(err);\n            });\n        });\n    });\n};\n", "\"use strict\";\nconst should = require(\"should\");\nconst async = require(\"async\");\n\nconst { OPCUAClient, StatusCodes, UnregisterNodesRequest, RegisterNodesRequest, DataType, AttributeIds, ServiceFault } = require(\"node-opcua\");\nconst { perform_operation_on_client_session } = require(\"../../test_helpers/perform_operation_on_client_session\");\n\nmodule.exports = function (test) {\n    describe(\"end-to-end testing registerNodes\", function () {\n        let client, endpointUrl;\n\n        beforeEach(function (done) {\n            client = OPCUAClient.create({});\n            endpointUrl = test.endpointUrl;\n            done();\n        });\n\n        afterEach(function (done) {\n            client = null;\n            done();\n        });\n\n        it(\"should register nodes - BadNothingToDo\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const request = new RegisterNodesRequest({\n                        nodesToRegister: []\n                    });\n                    session.performMessageTransaction(request, function (err /*, response*/) {\n                        err.message.should.match(/BadNothingToDo/);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"should register nodes - Good\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const request = new RegisterNodesRequest({\n                        nodesToRegister: [\"ns=0;i=1\"]\n                    });\n                    session.performMessageTransaction(request, function (err, response) {\n                        should.not.exist(err);\n                        response.registeredNodeIds.length.should.eql(1);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"should unregister nodes - BadNothingToDo\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const request = new UnregisterNodesRequest({\n                        nodesToUnregister: []\n                    });\n                    session.performMessageTransaction(request, function (err, response) {\n                        should.not.exist(response);\n                        should.exist(err);\n                        err.response.should.be.instanceOf(ServiceFault);\n                        err.message.should.match(/BadNothingToDo/);\n                        err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"should unregister nodes - Good\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const request = new UnregisterNodesRequest({\n                        nodesToUnregister: [\"ns=0;i=1\"]\n                    });\n                    session.performMessageTransaction(request, function (err, response) {\n                        should.exist(response);\n                        should.not.exist(err);\n                        inner_done();\n                    });\n                },\n                done\n            );\n        });\n\n        it(\"should register nodes and provide a alias that can be used on all operations\", function (done) {\n            perform_operation_on_client_session(\n                client,\n                endpointUrl,\n                function (session, inner_done) {\n                    const nodesToRegister = [\"ns=2;s=Static_Scalar_Double\"];\n                    let registeredNodeIds = [];\n                    let dataValue1, dataValue2;\n                    async.series(\n                        [\n                            function register_some_node(callback) {\n                                session.registerNodes(nodesToRegister, function (err, _registeredNodeIds) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    registeredNodeIds = _registeredNodeIds;\n                                    callback();\n                                });\n                            },\n                            function (callback) {\n                                const nodeToWrite = {\n                                    nodeId: registeredNodeIds[0],\n                                    attributeId: AttributeIds.Value,\n                                    value: { value: { dataType: DataType.Double, value: 1000 } }\n                                };\n                                session.write(nodeToWrite, function (err, statusCode) {\n                                    statusCode.should.eql(StatusCodes.Good);\n                                    callback(err);\n                                });\n                            },\n                            function (callback) {\n                                const nodeToRead = { nodeId: nodesToRegister[0], attributeId: 13 };\n                                session.read(nodeToRead, function (err, dataValue) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    dataValue.statusCode.should.eql(StatusCodes.Good);\n                                    dataValue1 = dataValue;\n                                    callback();\n                                });\n                            },\n                            function (callback) {\n                                const nodeToRead = { nodeId: registeredNodeIds[0], attributeId: 13 };\n                                session.read(nodeToRead, function (err, dataValue) {\n                                    if (err) {\n                                        return callback(err);\n                                    }\n                                    dataValue.statusCode.should.eql(StatusCodes.Good);\n                                    dataValue2 = dataValue;\n                                    callback();\n                                });\n                            },\n                            function (callback) {\n                                registeredNodeIds[0].toString().should.not.eql(nodesToRegister[0].toString());\n                                dataValue1.statusCode.toString().should.eql(dataValue2.statusCode.toString());\n\n                                //xx console.log(dataValue1.toString());\n                                //xx console.log(dataValue2.toString());\n\n                                dataValue1.value.toString().should.eql(dataValue2.value.toString());\n                                callback();\n                            }\n                        ],\n                        inner_done\n                    );\n                },\n                done\n            );\n        });\n    });\n};\n", "/* eslint-disable max-statements */\n// tslint:disable: no-shadowed-variable\n// tslint:disable: no-console\nimport {\n    AddressSpace,\n    assert,\n    AttributeIds,\n    ClientMonitoredItem,\n    ClientSession,\n    ClientSessionRawSubscriptionService,\n    ClientSidePublishEngine,\n    ClientSubscription,\n    coerceNodeId,\n    DataChangeFilter,\n    DataChangeNotification,\n    DataChangeTrigger,\n    DataType,\n    DataValue,\n    DeadbandType,\n    ExtensionObject,\n    getCurrentClock,\n    makeBrowsePath,\n    MonitoredItem,\n    MonitoredItemNotification,\n    MonitoringMode,\n    MonitoringParametersOptions,\n    Namespace,\n    NodeIdLike,\n    NotificationMessage,\n    OPCUAClient,\n    Range,\n    ServerSidePublishEngine,\n    ServiceFault,\n    SetTriggeringRequestOptions,\n    StatusCode,\n    StatusCodes,\n    TimestampsToReturn,\n    UAVariable\n} from \"node-opcua\";\nimport * as sinon from \"sinon\";\nimport * as should from \"should\";\n\nimport { make_debugLog, checkDebugFlag } from \"node-opcua-debug\";\nconst debugLog = make_debugLog(\"TEST\");\nconst doDebug = checkDebugFlag(\"TEST\");\n\nasync function pause(delay: number): Promise<void> {\n    await new Promise((resolve) => setTimeout(resolve, delay));\n}\n\ninterface ClientSidePublishEnginePrivate extends ClientSidePublishEngine {\n    internalSendPublishRequest(): void;\n    suspend(suspend: boolean): void;\n}\nfunction getInternalPublishEngine(session: ClientSession): ClientSidePublishEnginePrivate {\n    const s: ClientSidePublishEnginePrivate = (session as any).getPublishEngine();\n    return s;\n}\nexport function t(test: any) {\n    const options = {};\n\n    async function createSession() {\n        const client = OPCUAClient.create(options);\n        const endpointUrl = test.endpointUrl;\n        await client.connect(endpointUrl);\n        const session = await client.createSession();\n\n        const publishEngine = getInternalPublishEngine(session);\n        publishEngine.timeoutHint = 100000000; // for debugging with ease !\n        // make sure we control how PublishRequest are send\n        publishEngine.suspend(true);\n\n        // create a subscriptions\n        const subscription = ClientSubscription.create(session, {\n            publishingEnabled: true,\n            requestedLifetimeCount: 20,\n            requestedMaxKeepAliveCount: 3,\n            requestedPublishingInterval: 100\n        });\n\n        return { client, session, subscription, publishEngine };\n    }\n    interface Connection {\n        client: OPCUAClient;\n        session: ClientSession;\n        subscription: ClientSubscription;\n        publishEngine: ClientSidePublishEnginePrivate;\n    }\n    let s: Connection;\n    async function waitForRawNotifications(): Promise<ExtensionObject[]> {\n        const { publishEngine, subscription } = s;\n        publishEngine.internalSendPublishRequest();\n        return await new Promise((resolve: (result: ExtensionObject[]) => void) => {\n            // wait for fist notification\n            subscription.once(\"raw_notification\", (notificationMessage: any) => {\n                // tslint:disable-next-line: no-console\n                debugLog(\"got notification message \", notificationMessage.toString());\n                resolve(notificationMessage.notificationData);\n            });\n        });\n    }\n    async function waitForNotificationsValues(): Promise<{ value: number; statusCode: StatusCode }[]> {\n        while (true) {\n            const notificationData1 = await waitForRawNotifications();\n            if (notificationData1.length > 0) {\n                const dcn = notificationData1[0] as DataChangeNotification;\n                const r = dcn.monitoredItems!.map((item: MonitoredItemNotification) => ({\n                    statusCode: item.value.statusCode,\n                    value: item.value.value.value\n                }));\n                return r;\n            }\n            // tslint:disable-next-line: no-console\n            debugLog(\" ------- skipping empty publish response\");\n            return [];\n        }\n    }\n    async function incrementValue(nodeId: NodeIdLike) {\n        const { session } = s;\n        const dataValue = await session.read({ nodeId, attributeId: AttributeIds.Value });\n\n        dataValue.value.value += 1;\n\n        {\n            const statusCode = await session.write({\n                attributeId: AttributeIds.Value,\n                nodeId,\n                value: dataValue\n            });\n            statusCode.should.eql(StatusCodes.Good);\n        }\n    }\n    async function waitUntilKeepAlive(publishEngine: ClientSidePublishEngine, subscription: ClientSubscription) {\n        publishEngine.internalSendPublishRequest();\n        publishEngine.internalSendPublishRequest();\n        publishEngine.internalSendPublishRequest();\n        // wait until next keep alive\n        await new Promise<void>((resolve) => {\n            subscription.once(\"keepalive\", () => resolve());\n        });\n    }\n\n    const valueTriggeringNodeId = \"ns=1;s=ValueTriggering\";\n    const linkedValue1NodeId = \"ns=1;s=LinkedValue1\";\n    const linkedValue2NodeId = \"ns=1;s=LinkedValue2\";\n\n    const describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n    describe(\"SetTriggering\", function (this: any) {\n        this.timeout(Math.max(200000, this.timeout()));\n\n        before(() => {\n            const addressSpace = test.server.engine.addressSpace as AddressSpace;\n            const namespace = test.server.engine.addressSpace.getOwnNamespace() as Namespace;\n\n            const n = namespace.addAnalogDataItem({\n                browseName: \"ValueTriggering\",\n                componentOf: addressSpace.rootFolder.objects.server,\n                dataType: \"Double\",\n                engineeringUnitsRange: { low: -100, high: 200 },\n                nodeId: \"s=ValueTriggering\"\n            });\n            valueTriggeringNodeId.should.eql(n.nodeId.toString());\n\n            const n2 = namespace.addVariable({\n                browseName: \"LinkedValue1\",\n                componentOf: addressSpace.rootFolder.objects.server,\n                dataType: \"Double\",\n                nodeId: \"s=LinkedValue1\"\n            });\n            linkedValue1NodeId.should.eql(n2.nodeId.toString());\n\n            const n3 = namespace.addVariable({\n                browseName: \"LinkedValue2\",\n                componentOf: addressSpace.rootFolder.objects.server,\n                dataType: \"Double\",\n                nodeId: \"s=LinkedValue2\"\n            });\n            linkedValue2NodeId.should.eql(n3.nodeId.toString());\n        });\n        beforeEach(async () => {\n            const addressSpace = test.server.engine.addressSpace as AddressSpace;\n            const n = addressSpace.findNode(valueTriggeringNodeId)! as UAVariable;\n            n.setValueFromSource({ dataType: DataType.Double, value: 1 }, StatusCodes.Good);\n\n            const n2 = addressSpace.findNode(linkedValue1NodeId)! as UAVariable;\n            n2.setValueFromSource({ dataType: DataType.Double, value: 1000 }, StatusCodes.Good);\n\n            const n3 = addressSpace.findNode(linkedValue2NodeId)! as UAVariable;\n            n3.setValueFromSource({ dataType: DataType.Double, value: 2000 }, StatusCodes.Good);\n\n            s = await createSession();\n        });\n        afterEach(async () => {\n            await s.subscription.terminate();\n            await s.session.close();\n            await s.client.disconnect();\n        });\n\n        const changeSpy = sinon.spy();\n        async function createMonitoredItem(nodeId: NodeIdLike, monitoringMode: MonitoringMode): Promise<ClientMonitoredItem> {\n            const { session, subscription, publishEngine } = s as Connection;\n\n            const readValue = {\n                attributeId: AttributeIds.Value,\n                nodeId\n            };\n            const requestedParameters: MonitoringParametersOptions = {\n                discardOldest: true,\n                queueSize: 1,\n                samplingInterval: 10\n            };\n            const monitoredItem = await subscription.monitor(\n                readValue,\n                requestedParameters,\n                TimestampsToReturn.Both,\n                monitoringMode\n            );\n\n            if (monitoringMode === MonitoringMode.Reporting) {\n                await new Promise((resolve: any) => {\n                    // wait for fist notification\n                    monitoredItem.once(\"changed\", (dataValue) => {\n                        // tslint:disable-next-line: no-console\n                        debugLog(\"got initial value !!! \", dataValue.value.value);\n                        resolve();\n                    });\n                    s.publishEngine.internalSendPublishRequest();\n                });\n            } else {\n                s.publishEngine.internalSendPublishRequest();\n            }\n            monitoredItem.on(\"changed\", changeSpy);\n            return monitoredItem;\n        }\n\n        it(\"SetTriggering-1 it should return BadNothingToDo if both linksToAdd and linksToRemove are empty\", async () => {\n            const { session, subscription, publishEngine } = s;\n            const t = await createMonitoredItem(valueTriggeringNodeId, MonitoringMode.Reporting);\n            const l1 = await createMonitoredItem(linkedValue1NodeId, MonitoringMode.Sampling);\n            const l2 = await createMonitoredItem(linkedValue2NodeId, MonitoringMode.Sampling);\n\n            let _err!: Error;\n\n            try {\n                const result = await subscription.setTriggering(t, [], []);\n                console.log(result.toString());\n            } catch (err) {\n                _err = err as Error;\n            }\n            should.exist(_err, \"expecting a ServiceFault exception\");\n            const response = (_err as any).response as ServiceFault;\n            response.should.be.instanceOf(ServiceFault);\n            response.responseHeader.serviceResult.should.eql(StatusCodes.BadNothingToDo);\n\n            /*\n             */\n        });\n        it(\"SetTriggering-2 it should return BadNothingToDo if both linksToAdd and linksToRemove are empty\", async () => {\n            const { session, subscription, publishEngine } = s;\n            const t = await createMonitoredItem(valueTriggeringNodeId, MonitoringMode.Reporting);\n\n            let _err!: Error;\n\n            try {\n                const request: SetTriggeringRequestOptions = {\n                    linksToAdd: [0xdeadbeef],\n                    linksToRemove: [0xc0cac01a],\n                    subscriptionId: subscription.subscriptionId,\n                    triggeringItemId: t.monitoredItemId\n                };\n                const session2 = (session as unknown) as ClientSessionRawSubscriptionService;\n                const result = await session2.setTriggering(request);\n                result.removeResults?.length.should.eql(1);\n                result.addResults?.length.should.eql(1);\n                result.removeResults![0].should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n                result.addResults![0].should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n                result.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                // console.log(result.toString());\n            } catch (err) {\n                console.log(err);\n                _err = err as Error;\n            }\n            should.not.exist(_err, \"not expecting any an exception\");\n        });\n\n        it(\"SetTriggering-3 it should return BadNothingToDo if both linksToAdd and linksToRemove are empty\", async () => {\n            const { session, subscription, publishEngine } = s;\n            const t = await createMonitoredItem(valueTriggeringNodeId, MonitoringMode.Reporting);\n            const l1 = await createMonitoredItem(linkedValue1NodeId, MonitoringMode.Sampling);\n            const l2 = await createMonitoredItem(linkedValue2NodeId, MonitoringMode.Sampling);\n\n            const raw_notification_spy = sinon.spy();\n            subscription.on(\"raw_notification\", raw_notification_spy);\n            raw_notification_spy.resetHistory();\n            await incrementValue(valueTriggeringNodeId);\n\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must have received a changed notification and one empty notif\");\n\n            raw_notification_spy.resetHistory();\n            await incrementValue(linkedValue1NodeId);\n            await incrementValue(linkedValue2NodeId);\n            await incrementValue(valueTriggeringNodeId);\n\n            await pause(100);\n\n            // wait until next keep alive\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(1);\n\n                monitoredItems[0].clientHandle.should.eql(t.monitoringParameters.clientHandle);\n            }\n            // ------------------------------ Now create triggering\n\n            await subscription.setTriggering(t, [l1, l2], null);\n\n            // ------------------------------ verify that triggers now happen\n            raw_notification_spy.resetHistory();\n            await incrementValue(linkedValue1NodeId);\n            await incrementValue(linkedValue2NodeId);\n            await incrementValue(valueTriggeringNodeId);\n\n            await pause(50);\n            // wait until next keep alive\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must  have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(3);\n\n                monitoredItems[0].clientHandle.should.eql(t.monitoringParameters.clientHandle);\n                monitoredItems[1].clientHandle.should.eql(l1.monitoringParameters.clientHandle);\n                monitoredItems[2].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n            }\n\n            /// ------------------------- Do it again\n            raw_notification_spy.resetHistory();\n            await incrementValue(linkedValue1NodeId);\n            await incrementValue(linkedValue2NodeId);\n            await incrementValue(valueTriggeringNodeId);\n\n            await pause(50);\n            // wait until next keep alive\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must  have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(3);\n\n                monitoredItems[0].clientHandle.should.eql(t.monitoringParameters.clientHandle);\n                monitoredItems[1].clientHandle.should.eql(l1.monitoringParameters.clientHandle);\n                monitoredItems[2].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n            }\n\n            // --------------------------- Now remove one element\n            await subscription.setTriggering(t, [], [l1]);\n            // ------------------------------ verify that triggers now happen\n            raw_notification_spy.resetHistory();\n            await incrementValue(linkedValue1NodeId);\n            await incrementValue(linkedValue2NodeId);\n            await incrementValue(valueTriggeringNodeId);\n\n            await pause(50);\n            // wait until next keep alive\n            await waitUntilKeepAlive(publishEngine, subscription);\n\n            raw_notification_spy.callCount.should.eql(2, \"must have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(2);\n\n                monitoredItems[0].clientHandle.should.eql(t.monitoringParameters.clientHandle);\n                monitoredItems[1].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n            }\n        });\n        it(\"SetTriggering-4: Deadband testing of Linked items.\", async () => {\n            // note: based on 020.js in CTT ( set)\n            const { session, subscription, publishEngine } = s;\n\n            const raw_notification_spy = sinon.spy();\n            subscription.on(\"raw_notification\", raw_notification_spy);\n\n            const namespaceArray = await session.readNamespaceArray();\n            const simulationNamespaceIndex = namespaceArray.indexOf(\"urn://node-opcua-simulator\");\n            console.log(\"simulationNamespaceIndex = \", simulationNamespaceIndex);\n\n            const triggerNodeId = coerceNodeId(`ns=${simulationNamespaceIndex};s=Static_Scalar_UInt16`);\n            const linkedNodeId1 = coerceNodeId(`ns=${simulationNamespaceIndex};s=Static_Scalar_Byte`);\n            const linkedNodeId2 = coerceNodeId(`ns=${simulationNamespaceIndex};s=Static_Scalar_Float`);\n\n            // create monitored items\n            let m1: ClientMonitoredItem;\n            let l1: ClientMonitoredItem;\n            let l2: ClientMonitoredItem;\n\n            {\n                m1 = await subscription.monitor(\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: 13\n                    },\n                    {\n                        discardOldest: true,\n                        queueSize: 1,\n                        samplingInterval: 0,\n                        filter: null\n                    },\n                    TimestampsToReturn.Both,\n                    MonitoringMode.Reporting\n                );\n                l1 = await subscription.monitor(\n                    {\n                        nodeId: linkedNodeId1,\n                        attributeId: 13\n                    },\n                    {\n                        discardOldest: true,\n                        queueSize: 1,\n                        samplingInterval: 0,\n                        filter: new DataChangeFilter({\n                            deadbandType: DeadbandType.Absolute,\n                            deadbandValue: 5,\n                            trigger: DataChangeTrigger.StatusValue,\n                        })\n                    },\n                    TimestampsToReturn.Both,\n                    MonitoringMode.Sampling\n                );\n                l2 = await subscription.monitor(\n                    {\n                        nodeId: linkedNodeId2,\n                        attributeId: 13\n                    },\n                    {\n                        discardOldest: true,\n                        queueSize: 1,\n                        samplingInterval: 0,\n                        filter: new DataChangeFilter({\n                            deadbandType: DeadbandType.Absolute,\n                            deadbandValue: 0.5,\n                            trigger: DataChangeTrigger.StatusValue\n                        })\n                    },\n                    TimestampsToReturn.Both,\n                    MonitoringMode.Sampling\n                );\n            }\n\n            let m1Value = 100;\n            let l1Value = 100;\n            let l2Value = 100;\n            // write initial values\n            {\n                const statusCodes = await session.write([\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.UInt16, value: m1Value } }\n                    },\n                    {\n                        nodeId: linkedNodeId1,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.Byte, value: l1Value } }\n                    },\n                    {\n                        nodeId: linkedNodeId2,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.Float, value: l2Value } }\n                    }\n                ]);\n                statusCodes.should.eql([StatusCodes.Good, StatusCodes.Good, StatusCodes.Good]);\n            }\n\n            // setLinks\n            const result = await subscription.setTriggering(m1, [l1, l2], []);\n            result.addResults!.should.eql([StatusCodes.Good, StatusCodes.Good]);\n\n            await waitUntilKeepAlive(publishEngine, subscription);\n            raw_notification_spy.resetHistory();\n\n            m1Value += 1;\n            {\n                const statusCodes = await session.write([\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.UInt16, value: m1Value } }\n                    }\n                ]);\n            }\n\n            await waitUntilKeepAlive(publishEngine, subscription);\n            raw_notification_spy.callCount.should.eql(2, \"must  have received a changed notification and one empty notif\");\n            {\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                monitoredItems.length.should.eql(3);\n\n                monitoredItems[0].clientHandle.should.eql(m1.monitoringParameters.clientHandle);\n                monitoredItems[1].clientHandle.should.eql(l1.monitoringParameters.clientHandle);\n                monitoredItems[2].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n            }\n\n            const deadbandValuesInt = [0, 6, 7, 6, 20];\n            const deadbandValuesFloat = [0.0, 0.6, 0.5, 0.6, 1.5];\n            const successes = [true, true, false, false, true];\n\n            for (let i = 0; i < deadbandValuesInt.length; i++) {\n                // console.log(\"############################################### =>\", i);\n                raw_notification_spy.resetHistory();\n\n                m1Value += 1;\n                l1Value = deadbandValuesInt[i];\n                l2Value = deadbandValuesFloat[i];\n                await session.write([\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.UInt16, value: m1Value } }\n                    },\n                    {\n                        nodeId: linkedNodeId1,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.Byte, value: l1Value } }\n                    },\n                    {\n                        nodeId: linkedNodeId2,\n                        attributeId: AttributeIds.Value,\n                        value: { value: { dataType: DataType.Float, value: l2Value } }\n                    }\n                ]);\n                const dataValuesVerif = await session.read([\n                    {\n                        nodeId: triggerNodeId,\n                        attributeId: AttributeIds.Value\n                    },\n                    {\n                        nodeId: linkedNodeId1,\n                        attributeId: AttributeIds.Value\n                    },\n                    {\n                        nodeId: linkedNodeId2,\n                        attributeId: AttributeIds.Value\n                    }\n                ]);\n                dataValuesVerif[0].value.value.should.eql(m1Value);\n                dataValuesVerif[1].value.value.should.eql(l1Value);\n               Math.abs(dataValuesVerif[2].value.value - l2Value).should.be.lessThan(1E-6);\n\n                await pause(10);\n                await waitUntilKeepAlive(publishEngine, subscription);\n\n                const notification = raw_notification_spy.getCall(0).args[0] as NotificationMessage;\n                // tslint:disable-next-line: no-unused-expression\n                doDebug && console.log(notification.toString());\n\n                const monitoredItems = (notification.notificationData![0] as DataChangeNotification).monitoredItems!;\n\n                if (successes[i]) {\n                    monitoredItems.length.should.eql(3);\n\n                    monitoredItems[0].clientHandle.should.eql(m1.monitoringParameters.clientHandle);\n                    monitoredItems[1].clientHandle.should.eql(l1.monitoringParameters.clientHandle);\n                    monitoredItems[2].clientHandle.should.eql(l2.monitoringParameters.clientHandle);\n                } else {\n                    monitoredItems.length.should.eql(1);\n                    monitoredItems[0].clientHandle.should.eql(m1.monitoringParameters.clientHandle);\n                }\n            }\n        });\n    });\n}\n", "\"use strict\";\nconst async = require(\"async\");\n/* global describe,it,before,after,beforeEach,afterEach*/\n\nconst {\n    OPCUAClient,\n    ReadRequest,\n    TimestampsToReturn,\n    StatusCodes\n} = require(\"node-opcua\");\n\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n\nmodule.exports = function(test) {\n\n    let client;\n    describe(\"SNAC Testing client accessing service before session is activated \", function() {\n\n        beforeEach(function(done) {\n            client = OPCUAClient.create();\n            done();\n        });\n        afterEach(function(done) {\n            client = null;\n            done();\n        });\n\n        it(\"SNAC1- should return BadSessionNotActivated when service is called before session is activated\", (done) => {\n\n            let session1;\n            let last_response;\n            let last_response_err;\n            let activate_error;\n            async.series([\n\n                function(callback) {\n                    client.connect(test.endpointUrl, callback);\n                },\n                function(callback) {\n                    client._createSession(function(err, session) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        session1 = session;\n                        callback();\n                    });\n                },\n                // let verify that it is now possible to send a request on client1's session\n                function(callback) {\n                    // coerce nodeIds\n                    const request = new ReadRequest({\n                        nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n                        maxAge: 0,\n                        timestampsToReturn: TimestampsToReturn.Both\n                    });\n                    request.requestHeader.authenticationToken = session1.authenticationToken;\n\n                    client.performMessageTransaction(request, function(err, response) {\n                        console.log(err ? err.toString() : \"null\");\n                        console.log(response ? response.toString() : \"null\");\n                        last_response = response;\n                        last_response_err = err;\n                        callback();\n                    });\n                },\n                // verify the session can no longer be used\n                function(callback) {\n                    client._activateSession(session1,(err) => {\n                        activate_error = err;\n                        // BadSessionIdInvalid, BadSessionClosed\n                        callback();\n                    });\n                },\n\n                function(callback) {\n                    client.closeSession(session1, true, callback);\n                },\n                function(callback) {\n                    console.log(\"disconnecting\")\n                    client.disconnect(callback);\n                }\n            ], (err) => {\n                if (err) {\n                    return done(err);\n                }\n                last_response_err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionNotActivated);\n                should.exist(activate_error, \n                    \"Activate Session should return an error if there has been an attempt to use it before being activated\");\n                activate_error.message.should.match(/BadSessionIdInvalid|BadSessionClosed/);\n                done();\n            });\n        });\n\n    });\n}\n\n", "\"use strict\";\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst should = require(\"should\");\nconst async = require(\"async\");\nconst _ = require(\"underscore\");\n\nconst {\n    OPCUAClient,\n    StatusCodes,\n    PublishRequest,\n    CreateSubscriptionRequest,\n    CloseSessionRequest,\n    ReadRequest,\n    TimestampsToReturn,\n    MessageSecurityMode,\n    SecurityPolicy,\n    UserNameIdentityToken,\n    ServiceFault,\n    ReadResponse\n} = require(\"node-opcua\");\nconst { readCertificate, readCertificateRevocationList } = require(\"node-opcua-crypto\");\n\nconst certificateFolder = path.join(__dirname, \"../../../node-opcua-samples/certificates\");\nfs.existsSync(certificateFolder).should.eql(true, \"expecting certificate store at \" + certificateFolder);\n\nfunction sendPublishRequest(session, callback) {\n    const publishRequest = new PublishRequest({});\n    session.performMessageTransaction(publishRequest, function (err, response) {\n        callback(err, response);\n    });\n}\n\nfunction createSubscription(session, callback) {\n    const publishingInterval = 1000;\n    const createSubscriptionRequest = new CreateSubscriptionRequest({\n        requestedPublishingInterval: publishingInterval,\n        requestedLifetimeCount: 60,\n        requestedMaxKeepAliveCount: 10,\n        maxNotificationsPerPublish: 10,\n        publishingEnabled: true,\n        priority: 6\n    });\n\n    session.performMessageTransaction(createSubscriptionRequest, function (err /*, response*/) {\n        callback(err);\n    });\n}\n\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\n\nmodule.exports = function (test) {\n    describe(\"testing session  transfer to different channel\", function () {\n        it(\"RQC1 - It should be possible to close a session that has not be activated yet\", function (done) {\n            let client1;\n            let session1;\n            async.series(\n                [\n                    function (callback) {\n                        client1 = OPCUAClient.create({});\n                        client1.connect(test.endpointUrl, callback);\n                    },\n\n                    // create a session using client1, without activating it\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        client1._createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            session1 = session;\n                            callback();\n                        });\n                    },\n\n                    function (callback) {\n                        // Question: ? Should a unactivated session be accounted for\n                        //             in the currentSessionCount ?\n                        test.server.engine.currentSessionCount.should.eql(1);\n\n                        // however client shall not record session yet\n                        client1._sessions.length.should.eql(0);\n\n                        // in fact, let make sure that close Session is not harmfull\n                        client1.closeSession(session1, /* deleteSubscriptions =*/ true, function (err) {\n                            client1._sessions.length.should.eql(0);\n                            if (err) {\n                                // if treated as a Failure , close session expected to return BadSessionNotActivated\n                                err.message.match(/BadSessionNotActivated/);\n                            }\n                            callback();\n                        });\n                    },\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        callback();\n                    },\n                    function (callback) {\n                        client1.disconnect(callback);\n                    }\n                ],\n                done\n            );\n        });\n\n        it(\"RQB1 - calling CreateSession and CloseSession &  CloseSession again should return BadSessionIdInvalid\", function (done) {\n            let client1;\n            let session1;\n            async.series(\n                [\n                    function (callback) {\n                        client1 = OPCUAClient.create();\n                        client1.connect(test.endpointUrl, callback);\n                    },\n                    // create a session using client1\n                    function (callback) {\n                        client1._createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            session1 = session;\n                            callback();\n                        });\n                    },\n\n                    function (callback) {\n                        session1.close(function () {\n                            callback();\n                        });\n                    },\n                    function (callback) {\n                        session1.close(function (err) {\n                            // now session close do not return error if session in invalid\n                            // err.message.should.match(/SessionIdInvalid/);\n                            should.not.exist(err);\n                            callback();\n                        });\n                    },\n                    //\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        client1.disconnect(callback);\n                    }\n                ],\n                done\n            );\n        });\n\n        it(\"RQB2 - calling CloseSession without calling CreateSession first\", function (done) {\n            let client1;\n\n            async.series(\n                [\n                    function (callback) {\n                        client1 = OPCUAClient.create({});\n                        client1.connect(test.endpointUrl, callback);\n                    },\n                    function (callback) {\n                        const request = new CloseSessionRequest({\n                            deleteSubscriptions: true\n                        });\n                        client1.performMessageTransaction(request, function (err, response) {\n                            should.exist(err);\n                            should.not.exist(response);\n                            err.response.should.be.instanceOf(ServiceFault);\n                            err.message.should.match(/BadSessionIdInvalid/);\n                            err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionIdInvalid);\n                            callback();\n                        });\n                    },\n                    function (callback) {\n                        client1.disconnect(callback);\n                    },\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        callback();\n                    }\n                ],\n                done\n            );\n        });\n\n        it(\"RQB3 - calling CreateSession,  CloseSession  and CloseSession again\", function (done) {\n            let client1;\n            let session1;\n            async.series(\n                [\n                    function (callback) {\n                        client1 = OPCUAClient.create();\n                        client1.connect(test.endpointUrl, callback);\n                    },\n                    // create a session using client1\n                    function (callback) {\n                        client1.createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            session1 = session;\n                            callback();\n                        });\n                    },\n\n                    // first call to close session should be OK\n                    function (callback) {\n                        client1.closeSession(session1, /* deleteSubscriptions =*/ true, function (err) {\n                            callback(err);\n                        });\n                    },\n\n                    // second call to close session should raise an error\n                    function (callback) {\n                        const request = new CloseSessionRequest({\n                            deleteSubscriptions: true\n                        });\n                        client1.performMessageTransaction(request, function (err, response) {\n                            should.exist(err);\n                            should.not.exist(response);\n                            err.message.should.match(/BadSessionIdInvalid/);\n                            err.response.should.be.instanceOf(ServiceFault);\n                            err.response.responseHeader.serviceResult.should.eql(StatusCodes.BadSessionIdInvalid);\n                            callback();\n                        });\n                    },\n\n                    function (callback) {\n                        client1.disconnect(callback);\n                    },\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        callback();\n                    }\n                ],\n                function final(err) {\n                    client1.disconnect(function () {\n                        done(err);\n                    });\n                }\n            );\n        });\n\n        it(\"RQ0 - call ActiveSession on a session that has been transferred to a different channel\", function (done) {\n            // this test verifies that the following requirement can be met\n            // OpcUA 1.02 part 3 $5.5 Secure Channel Set page 20\n            // Once a  Client  has established a  Session  it may wish to access the  Session  from a different\n            // SecureChannel. The Client can do this by validating the new  SecureChannel  with the\n            // ActivateSession  Service  described in 5.6.3.\n            let client1, client2;\n            let session1;\n            async.series(\n                [\n                    // create a first channel (client1)\n                    function (callback) {\n                        client1 = OPCUAClient.create();\n                        client1.connect(test.endpointUrl, callback);\n                    },\n                    // create a session using client1\n                    function (callback) {\n                        client1._createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            session1 = session;\n                            callback();\n                        });\n                    },\n                    // activate the session as expected on same channel used to create it\n                    function (callback) {\n                        client1._activateSession(session1, function (err) {\n                            callback(err);\n                        });\n                    },\n                    // let verify that it is now possible to send a request on client1's session\n                    function (callback) {\n                        // coerce nodeIds\n                        const request = new ReadRequest({\n                            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n                            maxAge: 0,\n                            timestampsToReturn: TimestampsToReturn.Both\n                        });\n                        request.requestHeader.authenticationToken = session1.authenticationToken;\n                        client1.performMessageTransaction(request, function (err, response) {\n                            should.not.exist(err);\n                            response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                            callback();\n                        });\n                    },\n\n                    // create a second channel (client2)\n                    function (callback) {\n                        client2 = OPCUAClient.create();\n                        client2.connect(test.endpointUrl, callback);\n                    },\n\n                    // reactivate session on second channel\n                    function (callback) {\n                        client2.reactivateSession(session1, function (err) {\n                            callback(err);\n                        });\n                    },\n\n                    // now that session has been assigned to client 1,\n                    // server shall refuse any requests on channel1\n                    function (callback) {\n                        // coerce nodeIds\n                        const request = new ReadRequest({\n                            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n                            maxAge: 0,\n                            timestampsToReturn: TimestampsToReturn.Both\n                        });\n                        request.requestHeader.authenticationToken = session1.authenticationToken;\n                        client1.performMessageTransaction(request, function (err, response) {\n                            should.not.exist(err);\n                            should.exist(response);\n                            response.should.be.instanceOf(ReadResponse);\n                            response.responseHeader.serviceResult.should.eql(StatusCodes.BadSecureChannelIdInvalid);\n                            callback();\n                        });\n                    },\n                    // but server shall access request on new channel\n                    function (callback) {\n                        // coerce nodeIds\n                        const request = new ReadRequest({\n                            nodesToRead: [{ nodeId: \"i=2255\", attributeId: 13 }],\n                            maxAge: 0,\n                            timestampsToReturn: TimestampsToReturn.Both\n                        });\n                        request.requestHeader.authenticationToken = session1.authenticationToken;\n                        client2.performMessageTransaction(request, function (err, response) {\n                            if (!err) {\n                                response.responseHeader.serviceResult.should.eql(StatusCodes.Good);\n                            }\n                            callback(err);\n                        });\n                    },\n\n                    // terminate\n                    function (callback) {\n                        client2.disconnect(callback);\n                    },\n                    function (callback) {\n                        client1.disconnect(callback);\n                    },\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        callback();\n                    }\n                ],\n                done\n            );\n        });\n\n        // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n        // When the ActivateSession  Service  is called f or the first time then the Server shall reject the request\n        // if the  SecureChannel  is not same as the one associated with the CreateSession  request.\n        it(\"RQ1 - should reject if the channel used to activate the session for the first time is not the same as the channel used to create the session\", function (done) {\n            let client1, client2;\n            let session1;\n\n            let initialChannelCount = 0;\n            async.series(\n                [\n                    // create a first channel (client1)\n                    function (callback) {\n                        initialChannelCount = test.server.getChannels().length;\n                        test.server.getChannels().length.should.equal(initialChannelCount);\n                        client1 = OPCUAClient.create();\n                        client1.connect(test.endpointUrl, callback);\n                    },\n\n                    // create a session using client1\n                    //   ( without activating it)\n                    function (callback) {\n                        client1._createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            session1 = session;\n                            test.server.getChannels().length.should.equal(initialChannelCount + 1);\n                            callback();\n                        });\n                    },\n                    // create a second channel (client2)\n                    function (callback) {\n                        client2 = OPCUAClient.create();\n                        client2.connect(test.endpointUrl, callback);\n                    },\n\n                    // activate the session created with client1 using client2 !!\n                    // this should be detected by server and server shall return an error\n                    function (callback) {\n                        test.server.getChannels().length.should.equal(initialChannelCount + 2);\n                        //xx console.log(\" ID1 =\", client1._secureChannel.channelId);\n                        //xx console.log(\" ID2 =\", client2._secureChannel.channelId);\n\n                        client2.reactivateSession(session1, function (err) {\n                            if (!err) {\n                                callback(new Error(\"_activateSession shall return an error \"));\n                            }\n                            err.message.should.match(/BadSessionNotActivated/);\n                            callback();\n                        });\n                    },\n\n                    // terminate\n                    function (callback) {\n                        client2.disconnect(callback);\n                    },\n                    // activate the session as expected on same channel used to create it\n                    // so we can close it properly\n                    function (callback) {\n                        client1._activateSession(session1, function (err) {\n                            should.not.exist(err);\n                            session1.close(callback);\n                        });\n                    },\n                    function (callback) {\n                        client1.disconnect(callback);\n                    },\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        callback();\n                    }\n                ],\n                done\n            );\n        });\n\n        function m(file) {\n            const p = path.join(certificateFolder, file);\n            if (!fs.existsSync(p)) {\n                console.error(\" cannot find \", p);\n            }\n            return p;\n        }\n\n        // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n        // Subsequent calls to  ActivateSession  may be associated with different  SecureChannels.  If this is the\n        // case then  the  Server  shall verify that the  Certificate  the  Client  used to create the new\n        // SecureChannel  is the same as the  Certificate  used to create the original  SecureChannel.\n        it(\"RQ2 -server should raise an error if a existing session is reactivated from a channel that have different certificate than the original channel\", function (done) {\n            const serverCertificate = test.server.getCertificateChain();\n\n            let client1, client2;\n            let session1;\n            async.series(\n                [\n                    // create a first channel (client1) with\n                    function (callback) {\n                        //xx console.log(\" creating initial channel with some certificate\");\n                        const certificateFile1 = m(\"client_cert_2048.pem\");\n                        const privateKeyFile1 = m(\"client_key_2048.pem\");\n                        console.log(certificateFile1);\n\n                        client1 = OPCUAClient.create({\n                            certificateFile: certificateFile1,\n                            privateKeyFile: privateKeyFile1,\n                            securityMode: MessageSecurityMode.Sign,\n                            securityPolicy: SecurityPolicy.Basic128Rsa15,\n                            serverCertificate: serverCertificate\n                        });\n\n                        const certificate = readCertificate(certificateFile1);\n\n                        async function doIt() {\n                            await test.server.serverCertificateManager.trustCertificate(certificate);\n                            const issuerCertificateFile = m(\"CA/public/cacert.pem\");\n                            const issuerCertificateRevocationListFile = m(\"CA/crl/revocation_list.der\");\n                            const issuerCertificate = readCertificate(issuerCertificateFile);\n                            const issuerCrl = await readCertificateRevocationList(issuerCertificateRevocationListFile);\n                            await test.server.serverCertificateManager.addIssuer(issuerCertificate);\n                            await test.server.serverCertificateManager.addRevocationList(issuerCrl);\n                            callback();\n                        }\n                        doIt();\n                    },\n                    function (callback) {\n                        client1.connect(test.endpointUrl, callback);\n                    },\n                    // create a session using client1\n                    function (callback) {\n                        //xx console.log(\" create session\");\n                        client1._createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            session1 = session;\n                            callback();\n                        });\n                    },\n                    // activate the session as expected on same channel used to create it\n                    function (callback) {\n                        //xx console.log(\" activate session\");\n                        client1._activateSession(session1, function (err) {\n                            callback(err);\n                        });\n                    },\n\n                    // create a second channel (client2)\n                    // with a different certificate ....\n                    function (callback) {\n                        // creating second channel with different credential\n                        console.log(\" creating second channel with different certificate\");\n                        const certificateFile2 = m(\"client_cert_3072.pem\");\n                        const privateKeyFile2 = m(\"client_key_3072.pem\");\n                        client2 = OPCUAClient.create({\n                            certificateFile: certificateFile2,\n                            privateKeyFile: privateKeyFile2,\n                            securityMode: MessageSecurityMode.Sign,\n                            securityPolicy: SecurityPolicy.Basic256,\n                            serverCertificate: serverCertificate\n                        });\n                        const certificate = readCertificate(certificateFile2);\n                        test.server.serverCertificateManager.trustCertificate(certificate, callback);\n                    },\n                    function (callback) {\n                        client2.connect(test.endpointUrl, callback);\n                    },\n                    function (callback) {\n                        // reactivate session on second channel\n                        // Reactivate should fail because certificate is not the same as the original one\n                        client2.reactivateSession(session1, function (err) {\n                            if (err) {\n                                err.message.should.match(/BadNoValidCertificates/);\n                                callback();\n                            } else {\n                                callback(new Error(\"expecting reactivateSession to fail\"));\n                            }\n                        });\n                    },\n                    // terminate\n                    function (callback) {\n                        client2.disconnect(callback);\n                    },\n                    function (callback) {\n                        session1.close(callback);\n                    },\n                    function (callback) {\n                        client1.disconnect(callback);\n                    },\n\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        callback();\n                    }\n                ],\n                done\n            );\n        });\n\n        // In addition,the Server shall verify that the  Client  supplied a  UserIdentityToken  that is   identical to the token\n        // currently associated with the  Session.\n        it(\"RQ3 - server should raise an error if a session is reactivated with different user identity tokens\", function (done) {\n            let client1, client2;\n            let session1;\n\n            const user1 = {\n                userName: \"user1\",\n                password: \"password1\"\n            };\n            const user2 = new UserNameIdentityToken({\n                userName: \"user1\",\n                password: \"password1\"\n            });\n            //xx console.log(\" user1 \", user1.toString());\n            async.series(\n                [\n                    // given a established session with a subscription and some publish request\n\n                    function (callback) {\n                        client1 = OPCUAClient.create();\n                        client1.connect(test.endpointUrl, callback);\n                    },\n                    // create a session using client1\n                    function (callback) {\n                        client1.createSession(user1, function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            session1 = session;\n                            callback();\n                        });\n                    },\n                    // when the session is transferred to a different channel\n                    // create a second channel (client2)\n                    function (callback) {\n                        client2 = OPCUAClient.create();\n                        client2.connect(test.endpointUrl, callback);\n                    },\n                    function (callback) {\n                        // reactivate session on second channel\n                        // alter session1.userIdentityInfo\n                        session1.userIdentityInfo = user2;\n                        session1.userIdentityInfo.userName.should.eql(\"user1\");\n\n                        client2.reactivateSession(session1, function (err) {\n                            err.message.should.match(/BadIdentityChangeNotSupported/);\n                            _.contains(client1._sessions, session1).should.eql(true); // should have failed\n                            callback();\n                        });\n                    },\n                    // terminate\n                    function (callback) {\n                        client2.disconnect(callback);\n                    },\n                    function (callback) {\n                        client1.disconnect(callback);\n                    },\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        callback();\n                    }\n                ],\n                done\n            );\n        });\n        // Once the Server accepts the new  SecureChannel  it shall reject requests sent via the old  SecureChannel.\n        xit(\"RQ4 - server should reject request send via old channel when session has been transferred to new channel\", function (done) {\n            async.series([], done);\n        });\n\n        // unprocessed pending Requests such as PublishRequest shall be be denied by the server\n        // Once the Server accepts the new  SecureChannel  it shall reject requests sent via the old  SecureChannel\n        it(\"RQ5 - server should reject pending requests send to old channel when session has been transferred to new channel\", function (done) {\n            const sinon = require(\"sinon\");\n\n            const collectPublishResponse = sinon.spy();\n\n            let client1, client2;\n            let session1;\n            async.series(\n                [\n                    // given a established session with a subscription and some publish request\n\n                    function (callback) {\n                        client1 = OPCUAClient.create();\n                        client1.connect(test.endpointUrl, callback);\n                    },\n                    // create a session using client1\n                    function (callback) {\n                        client1._createSession(function (err, session) {\n                            if (err) {\n                                return callback(err);\n                            }\n                            session1 = session;\n                            callback();\n                        });\n                    },\n                    // activate the session as expected on same channel used to create it\n                    function (callback) {\n                        client1._activateSession(session1, function (err) {\n                            callback(err);\n                        });\n                    },\n\n                    // creaet a subscription,\n                    function (callback) {\n                        createSubscription(session1, callback);\n                    },\n\n                    // when the session is transferred to a different channel\n                    // create a second channel (client2)\n                    function (callback) {\n                        client2 = OPCUAClient.create();\n                        client2.connect(test.endpointUrl, callback);\n                        collectPublishResponse.callCount.should.eql(0);\n                    },\n\n                    // provision 3 publish requests and wait for the first keep alive\n                    function (callback) {\n                        sendPublishRequest(session1, function (err) {\n                            should.not.exist(err);\n                            collectPublishResponse.callCount.should.eql(0);\n                            callback();\n                        });\n                        sendPublishRequest(session1, collectPublishResponse);\n                        sendPublishRequest(session1, collectPublishResponse);\n                    },\n\n                    function (callback) {\n                        // reactivate session on second channel\n                        client2.reactivateSession(session1, function (err) {\n                            callback(err);\n                        });\n                    },\n                    function (callback) {\n                        setTimeout(callback, 100);\n                    },\n\n                    function (callback) {\n                        collectPublishResponse.callCount.should.eql(2);\n                        collectPublishResponse.getCall(0).args[0].message.should.match(/BadSecureChannelClosed/);\n                        collectPublishResponse.getCall(1).args[0].message.should.match(/BadSecureChannelClosed/);\n                        callback();\n                    },\n\n                    // terminate\n                    function (callback) {\n                        client2.disconnect(callback);\n                    },\n                    function (callback) {\n                        client1.disconnect(callback);\n                    },\n                    function (callback) {\n                        test.server.engine.currentSessionCount.should.eql(0);\n                        callback();\n                    }\n                ],\n                done\n            );\n        });\n    });\n};\n", "/**\r\n * @module node-opcua-secure-channel\r\n */\r\n// tslint:disable:variable-name\r\n// tslint:disable:object-literal-shorthand\r\n// tslint:disable:no-console\r\nimport { randomBytes } from \"crypto\";\r\nimport { EventEmitter } from \"events\";\r\nimport * as chalk from \"chalk\";\r\nimport * as async from \"async\";\r\n\r\nimport { Certificate, extractPublicKeyFromCertificate, PrivateKeyPEM, PublicKeyPEM, rsa_length } from \"node-opcua-crypto\";\r\n\r\nimport { assert } from \"node-opcua-assert\";\r\n\r\nimport { BinaryStream } from \"node-opcua-binary-stream\";\r\nimport { get_clock_tick, timestamp } from \"node-opcua-utils\";\r\n\r\nimport { readMessageHeader, verify_message_chunk } from \"node-opcua-chunkmanager\";\r\nimport { checkDebugFlag, hexDump, make_debugLog, make_errorLog, make_warningLog } from \"node-opcua-debug\";\r\nimport { ChannelSecurityToken, coerceMessageSecurityMode, MessageSecurityMode } from \"node-opcua-service-secure-channel\";\r\nimport { CallbackT, StatusCode, StatusCodes } from \"node-opcua-status-code\";\r\nimport { ClientTCP_transport, TransportSettingsOptions } from \"node-opcua-transport\";\r\nimport { StatusCodes2 } from \"node-opcua-transport\";\r\nimport { ErrorCallback } from \"node-opcua-status-code\";\r\nimport { BaseUAObject } from \"node-opcua-factory\";\r\nimport { doTraceChunk } from \"node-opcua-transport\";\r\n\r\nimport { MessageBuilder } from \"../message_builder\";\r\nimport { ChunkMessageOptions, MessageChunker } from \"../message_chunker\";\r\nimport { messageHeaderToString } from \"../message_header_to_string\";\r\n\r\nimport {\r\n    coerceSecurityPolicy,\r\n    computeDerivedKeys,\r\n    DerivedKeys1,\r\n    getCryptoFactory,\r\n    getOptionsForSymmetricSignAndEncrypt,\r\n    SecurityPolicy,\r\n    toURI\r\n} from \"../security_policy\";\r\nimport {\r\n    AsymmetricAlgorithmSecurityHeader,\r\n    CloseSecureChannelRequest,\r\n    OpenSecureChannelRequest,\r\n    OpenSecureChannelResponse,\r\n    SecurityTokenRequestType,\r\n    ServiceFault\r\n} from \"../services\";\r\n\r\nconst debugLog = make_debugLog(__filename);\r\nconst errorLog = make_errorLog(__filename);\r\nconst doDebug = checkDebugFlag(__filename);\r\nconst warningLog = make_warningLog(__filename);\r\nconst checkChunks = doDebug && false;\r\nconst doDebug1 = false;\r\n\r\n// set checkTimeout to true to enable timeout trace checking\r\nconst checkTimeout = false;\r\n\r\nimport { extractFirstCertificateInChain, getThumbprint, ICertificateKeyPairProvider, Request, Response } from \"../common\";\r\nimport {\r\n    ClientTransactionStatistics,\r\n    doPerfMonitoring,\r\n    doTraceClientMessage,\r\n    doTraceClientRequestContent,\r\n    doTraceStatistics,\r\n    dumpSecurityHeader,\r\n    traceClientRequestMessage,\r\n    traceClientResponseMessage,\r\n    _dump_client_transaction_statistics\r\n} from \"../utils\";\r\n// import * as backoff from \"backoff\";\r\n// tslint:disable-next-line: no-var-requires\r\nconst backoff = require(\"backoff\");\r\n\r\nexport const requestHandleNotSetValue = 0xdeadbeef;\r\n\r\ntype PerformTransactionCallback = CallbackT<Response>;\r\n\r\ninterface TransactionData {\r\n    msgType: string;\r\n    request: Request;\r\n    callback: PerformTransactionCallback;\r\n}\r\n\r\ninterface RequestData {\r\n    msgType: string;\r\n    request: Request;\r\n    callback?: PerformTransactionCallback;\r\n\r\n    response?: Response;\r\n\r\n    _tick0: number;\r\n    _tick1: number;\r\n    _tick2: number;\r\n    _tick3: number;\r\n    _tick4: number;\r\n    bytesWritten_after: number;\r\n    bytesWritten_before: number;\r\n    bytesRead: number;\r\n    key: string;\r\n    chunk_count: number;\r\n}\r\n\r\nfunction process_request_callback(requestData: RequestData, err?: Error | null, response?: Response) {\r\n    assert(typeof requestData.callback === \"function\");\r\n\r\n    const request = requestData.request;\r\n\r\n    if (!response && !err && requestData.msgType !== \"CLO\") {\r\n        // this case happens when CLO is called and when some pending transactions\r\n        // remains in the queue...\r\n        err = new Error(\" Connection has been closed by client , but this transaction cannot be honored\");\r\n    }\r\n\r\n    if (response && response instanceof ServiceFault) {\r\n        response.responseHeader.stringTable = [...(response.responseHeader.stringTable || [])];\r\n        err = new Error(\" serviceResult = \" + response.responseHeader.serviceResult.toString());\r\n        //  \"  returned by server \\n response:\" + response.toString() + \"\\n  request: \" + request.toString());\r\n        (err as any).response = response;\r\n        (err as any).request = request;\r\n        response = undefined;\r\n    }\r\n\r\n    const theCallbackFunction = requestData.callback;\r\n    /* istanbul ignore next */\r\n    if (!theCallbackFunction) {\r\n        throw new Error(\"Internal error\");\r\n    }\r\n    assert(requestData.msgType === \"CLO\" || (err && !response) || (!err && response));\r\n\r\n    // let set callback to undefined to prevent callback to be called again\r\n    requestData.callback = undefined;\r\n\r\n    theCallbackFunction(err || null, !err && response !== null ? response : undefined);\r\n}\r\n\r\nexport interface ConnectionStrategyOptions {\r\n    maxRetry?: number;\r\n    initialDelay?: number;\r\n    maxDelay?: number;\r\n    randomisationFactor?: number;\r\n}\r\n\r\nexport interface ConnectionStrategy {\r\n    maxRetry: number;\r\n    initialDelay: number;\r\n    maxDelay: number;\r\n    randomisationFactor: number;\r\n}\r\n\r\nexport function coerceConnectionStrategy(options: ConnectionStrategyOptions | null): ConnectionStrategy {\r\n    options = options || {};\r\n\r\n    const maxRetry: number = options.maxRetry === undefined ? 10 : options.maxRetry;\r\n    const initialDelay = options.initialDelay || 10;\r\n    const maxDelay = options.maxDelay || 10000;\r\n    const randomisationFactor = options.randomisationFactor === undefined ? 0 : options.randomisationFactor;\r\n\r\n    return {\r\n        initialDelay,\r\n        maxDelay,\r\n        maxRetry,\r\n        randomisationFactor\r\n    };\r\n}\r\n\r\nexport interface ClientSecureChannelParent extends ICertificateKeyPairProvider {\r\n    applicationName?: string;\r\n    clientName?: string;\r\n\r\n    getCertificate(): Certificate;\r\n\r\n    getCertificateChain(): Certificate;\r\n\r\n    getPrivateKey(): PrivateKeyPEM;\r\n}\r\n\r\n/***\r\n * @param [options.factory] an factory that provides a method createObjectId(id) for the message builder\r\n */\r\n\r\nexport interface ClientSecureChannelLayerOptions {\r\n    /**\r\n     * default secure token life time , if not specified  30 seconds will be used as default value\r\n     */\r\n    defaultSecureTokenLifetime?: number;\r\n    /**\r\n     * delay SecureTokenLifetime at which token renewal will be attempted.\r\n     *\r\n     * if 0 or not specify, the security token renewal will happen at 75% of defaultSecureTokenLifetime\r\n     */\r\n    tokenRenewalInterval?: number;\r\n    /**\r\n     *  message security mode\r\n     *  default value =MessageSecurityMode.None\r\n     */\r\n    securityMode?: MessageSecurityMode;\r\n    /**\r\n     * security policy\r\n     * default value = SecurityPolicy.None\r\n     */\r\n    securityPolicy?: SecurityPolicy;\r\n    /**\r\n     * the serverCertificate (required if securityMode!=None)\r\n     */\r\n    serverCertificate?: Certificate;\r\n\r\n    parent: ClientSecureChannelParent;\r\n\r\n    /* OPCUAClientBase */\r\n    /**\r\n     *   the transport timeout interval in ms ( default = 10 seconds)\r\n     */\r\n    transportTimeout?: number;\r\n    /**\r\n     * the connection strategy options\r\n     * @param [options.connectionStrategy.maxRetry      = 10]\r\n     * @param [options.connectionStrategy.initialDelay  = 10]\r\n     * @param [options.connectionStrategy.maxDelay      = 10000]\r\n     */\r\n    connectionStrategy: ConnectionStrategyOptions;\r\n\r\n    transportSettings: TransportSettingsOptions;\r\n}\r\n\r\nexport interface ClientSecureChannelLayer extends EventEmitter {\r\n    on(event: \"end_transaction\", eventHandler: (transactionStatistics: ClientTransactionStatistics) => void): this;\r\n    on(event: \"close\", eventHandler: (err?: Error | null) => void): this;\r\n    on(event: \"lifetime_75\", eventHandler: (securityToken: ChannelSecurityToken) => void): this;\r\n    on(event: \"receive_chunk\", eventHandler: (chunk: Buffer) => void): this;\r\n    on(event: \"send_chunk\", eventHandler: (chunk: Buffer) => void): this;\r\n    on(event: \"backoff\", eventHandler: (retryCount: number, delay: number) => void): this;\r\n    on(event: \"security_token_renewed\", eventHandler: () => void): this;\r\n    on(event: \"send_request\", eventHandler: (request: Request) => void): this;\r\n    on(event: \"receive_response\", eventHandler: (response: Response) => void): this;\r\n    on(event: \"timed_out_request\", eventHandler: (request: Request) => void): this;\r\n    on(event: \"abort\", eventHandler: () => void): this;\r\n\r\n    emit(event: \"end_transaction\", transactionStatistics: ClientTransactionStatistics): boolean;\r\n    /**\r\n     * notify the observers that the transport connection has ended.\r\n     * The error object is null or undefined if the disconnection was initiated by the ClientSecureChannelLayer.\r\n     * A Error object is provided if the disconnection has been initiated by an external cause.\r\n     *\r\n     * @event close\r\n     */\r\n    emit(event: \"close\", err?: Error | null): boolean;\r\n    /**\r\n     * notify the observer that the secure channel has now reach 75% of its allowed live time and\r\n     * that a new token is going to be requested.\r\n     * @event  lifetime_75\r\n     * @param  securityToken {Object} : the security token that is about to expire.\r\n     *\r\n     */\r\n    emit(event: \"lifetime_75\", securityToken: ChannelSecurityToken): boolean;\r\n\r\n    /**\r\n     * notify the observers that ClientSecureChannelLayer has received a message chunk\r\n     * @event receive_chunk\r\n     */\r\n    emit(event: \"receive_chunk\", chunk: Buffer): boolean;\r\n    /**\r\n     * notify the observer that a message chunk is about to be sent to the server\r\n     * @event send_chunk\r\n     */\r\n\r\n    emit(event: \"send_chunk\", chunk: Buffer): boolean;\r\n\r\n    emit(event: \"backoff\", retryCount: number, delay: number): boolean;\r\n    /**\r\n     * notify the observers that the security has been renewed\r\n     * @event security_token_renewed\r\n     */\r\n    emit(event: \"security_token_renewed\"): boolean;\r\n\r\n    /**\r\n     * notify the observer that a client request is being sent the server\r\n     * @event send_request\r\n     */\r\n    emit(event: \"send_request\", request: Request): boolean;\r\n    /**\r\n     * notify the observers that a server response has been received on the channel\r\n     * @event receive_response\r\n     */\r\n    emit(event: \"receive_response\", response: Response): boolean;\r\n    /**\r\n     * notify the observer that the response from the request has not been\r\n     * received within the timeoutHint specified\r\n     * @event timed_out_request\r\n     */\r\n    emit(event: \"timed_out_request\", request: Request): boolean;\r\n    emit(event: \"abort\"): boolean;\r\n}\r\n/**\r\n * a ClientSecureChannelLayer represents the client side of the OPCUA secure channel.\r\n */\r\nexport class ClientSecureChannelLayer extends EventEmitter {\r\n    private static g_counter = 0;\r\n    private _counter = ClientSecureChannelLayer.g_counter++;\r\n    private _bytesRead = 0;\r\n    private _bytesWritten = 0;\r\n\r\n    public static minTransactionTimeout = 10 * 1000; // 10 sec\r\n    public static defaultTransactionTimeout = 60 * 1000; // 1 minute\r\n\r\n    /**\r\n     * true if the secure channel is trying to establish the connection with the server. In this case, the client\r\n     * may be in the middle of the backoff connection process.\r\n     *\r\n     */\r\n    public get isConnecting(): boolean {\r\n        return !!this.__call;\r\n    }\r\n\r\n    get bytesRead(): number {\r\n        return this._bytesRead + (this._transport ? this._transport.bytesRead : 0);\r\n    }\r\n\r\n    get bytesWritten(): number {\r\n        return this._bytesWritten + (this._transport ? this._transport.bytesWritten : 0);\r\n    }\r\n\r\n    get transactionsPerformed(): number {\r\n        return this._lastRequestId;\r\n    }\r\n\r\n    get timedOutRequestCount(): number {\r\n        return this._timeout_request_count;\r\n    }\r\n\r\n    public static defaultTransportTimeout = 60 * 1000; // 1 minute\r\n    private transportSettings: TransportSettingsOptions;\r\n\r\n    public protocolVersion: number;\r\n    public readonly securityMode: MessageSecurityMode;\r\n    public readonly securityPolicy: SecurityPolicy;\r\n    public endpointUrl: string;\r\n    public channelId: number;\r\n    public securityToken: ChannelSecurityToken | null;\r\n\r\n    private _lastRequestId: number;\r\n    private _transport?: ClientTCP_transport;\r\n    private _pending_transport?: ClientTCP_transport;\r\n    private readonly parent: ClientSecureChannelParent;\r\n\r\n    private clientNonce: any;\r\n    private readonly messageChunker: MessageChunker;\r\n    private readonly defaultSecureTokenLifetime: number;\r\n    private readonly tokenRenewalInterval: number;\r\n    private readonly serverCertificate: Certificate | null;\r\n    private messageBuilder?: MessageBuilder;\r\n\r\n    private _requests: { [key: string]: RequestData };\r\n\r\n    private __in_normal_close_operation: boolean;\r\n    private _timeout_request_count: number;\r\n    private _securityTokenTimeoutId: NodeJS.Timer | null;\r\n    private readonly transportTimeout: number;\r\n    private readonly connectionStrategy: any;\r\n    private last_transaction_stats: any | ClientTransactionStatistics;\r\n    private derivedKeys: DerivedKeys1 | null;\r\n    private receiverPublicKey: PublicKeyPEM | null;\r\n    private __call: any;\r\n    private _isOpened: boolean;\r\n    private serverNonce: Buffer | null;\r\n    private receiverCertificate: Certificate | null;\r\n    private securityHeader: AsymmetricAlgorithmSecurityHeader | null;\r\n    private lastError?: Error;\r\n    private _tick2 = 0;\r\n    private _isDisconnecting = false;\r\n\r\n    constructor(options: ClientSecureChannelLayerOptions) {\r\n        super();\r\n\r\n        this.securityHeader = null;\r\n        this.receiverCertificate = null;\r\n        this.securityToken = null;\r\n        this.serverNonce = null;\r\n        this.derivedKeys = null;\r\n        this.receiverPublicKey = null;\r\n        this.endpointUrl = \"\";\r\n\r\n        if ((global as any).hasResourceLeakDetector && !(global as any).ResourceLeakDetectorStarted) {\r\n            throw new Error(\"ClientSecureChannelLayer not in ResourceLeakDetectorStarted\");\r\n        }\r\n\r\n        assert(this instanceof ClientSecureChannelLayer);\r\n\r\n        this._isOpened = false;\r\n        this._transport = undefined;\r\n        this._lastRequestId = 0;\r\n        this.parent = options.parent;\r\n        this.clientNonce = null; // will be created when needed\r\n\r\n        this.protocolVersion = 0;\r\n\r\n        this.messageChunker = new MessageChunker({\r\n            derivedKeys: null\r\n            // note maxMessageSize cannot be set at this stage, transport is not kown\r\n        });\r\n\r\n        this.defaultSecureTokenLifetime = options.defaultSecureTokenLifetime || 30000;\r\n        this.tokenRenewalInterval = options.tokenRenewalInterval || 0;\r\n\r\n        this.securityMode = coerceMessageSecurityMode(options.securityMode);\r\n\r\n        this.securityPolicy = coerceSecurityPolicy(options.securityPolicy);\r\n\r\n        this.serverCertificate = extractFirstCertificateInChain(options.serverCertificate);\r\n\r\n        if (this.securityMode !== MessageSecurityMode.None) {\r\n            assert(\r\n                (this.serverCertificate as any) instanceof Buffer,\r\n                \"Expecting a valid certificate when security mode is not None\"\r\n            );\r\n            assert(this.securityPolicy !== SecurityPolicy.None, \"Security Policy None is not a valid choice\");\r\n            // make sure that we do not have a chain here ...\r\n        }\r\n\r\n        this._requests = {};\r\n\r\n        this.__in_normal_close_operation = false;\r\n\r\n        this._timeout_request_count = 0;\r\n\r\n        this._securityTokenTimeoutId = null;\r\n\r\n        this.transportTimeout = options.transportTimeout || ClientSecureChannelLayer.defaultTransportTimeout;\r\n        this.transportSettings = options.transportSettings || {};\r\n\r\n        this.channelId = 0;\r\n\r\n        this.connectionStrategy = coerceConnectionStrategy(options.connectionStrategy);\r\n    }\r\n\r\n    private _install_message_builder() {\r\n        // istanbul ignore next\r\n        if (!this._transport || !this._transport.parameters) {\r\n            throw new Error(\"internal error\");\r\n        }\r\n        this.messageBuilder = new MessageBuilder({\r\n            name: \"client\",\r\n            privateKey: this.getPrivateKey() || undefined,\r\n            securityMode: this.securityMode,\r\n            maxChunkSize: this._transport.receiveBufferSize || 0,\r\n            maxChunkCount: this._transport.maxChunkCount || 0,\r\n            maxMessageSize: this._transport.maxMessageSize || 0\r\n        });\r\n\r\n        if (doTraceChunk) {\r\n            console.log(\r\n                chalk.cyan(timestamp()),\r\n                \"   MESSGAE BUILDER LIMITS\",\r\n                \"maxMessageSize = \",\r\n                this.messageBuilder.maxMessageSize,\r\n                \"maxChunkCount = \",\r\n                this.messageBuilder.maxChunkCount,\r\n                \"maxChunkSize = \",\r\n                this.messageBuilder.maxChunkSize,\r\n                \"(\",\r\n                this.messageBuilder.maxChunkSize * this.messageBuilder.maxChunkCount,\r\n                \")\"\r\n            );\r\n        }\r\n\r\n        this.messageBuilder\r\n            .on(\"message\", (response: BaseUAObject, msgType: string, requestId: number, channelId: number) => {\r\n                this._on_message_received(response as Response, msgType, requestId);\r\n            })\r\n            .on(\"startChunk\", () => {\r\n                //\r\n                if (doPerfMonitoring) {\r\n                    this._tick2 = get_clock_tick();\r\n                }\r\n            })\r\n            .on(\"abandon\", (requestId: number) => {\r\n                const requestData = this._requests[requestId];\r\n\r\n                if (doDebug) {\r\n                    debugLog(\"request id = \", requestId, \"message was \", requestData);\r\n                }\r\n\r\n                const err = new ServiceFault({\r\n                    responseHeader: {\r\n                        requestHandle: requestId,\r\n                        serviceResult: StatusCodes.BadOperationAbandoned\r\n                    }\r\n                });\r\n\r\n                const callback = requestData.callback;\r\n                delete this._requests[requestId];\r\n                callback && callback(null, err);\r\n            })\r\n            .on(\"error\", (err: Error, statusCode: StatusCode, requestId: number | null) => {\r\n                // istanbul ignore next\r\n                if (!requestId) {\r\n                    return;\r\n                }\r\n\r\n                let requestData = this._requests[requestId];\r\n\r\n                if (doDebug) {\r\n                    debugLog(\"request id = \", requestId, err, \"message was \", requestData);\r\n                }\r\n\r\n                if (!requestData) {\r\n                    warningLog(\"requestData not found for requestId = \", requestId, \"try with \", requestId + 1);\r\n                    requestId = requestId + 1;\r\n                    requestData = this._requests[requestId];\r\n                }\r\n                if (doTraceClientRequestContent) {\r\n                    errorLog(\" message was 2:\", requestData ? requestData.request.toString() : \"<null>\");\r\n                }\r\n\r\n                const callback = requestData.callback;\r\n                delete this._requests[requestId];\r\n                callback && callback(err, undefined);\r\n\r\n                this._closeWithError(err, statusCode);\r\n                return;\r\n            });\r\n    }\r\n\r\n    public getPrivateKey(): PrivateKeyPEM | null {\r\n        return this.parent ? this.parent.getPrivateKey() : null;\r\n    }\r\n\r\n    public getCertificateChain(): Certificate | null {\r\n        return this.parent ? this.parent.getCertificateChain() : null;\r\n    }\r\n\r\n    public getCertificate(): Certificate | null {\r\n        return this.parent ? this.parent.getCertificate() : null;\r\n    }\r\n\r\n    public toString(): string {\r\n        let str = \"\";\r\n        str += \"\\n securityMode ............. : \" + MessageSecurityMode[this.securityMode];\r\n        str += \"\\n securityPolicy............ : \" + this.securityPolicy;\r\n        str += \"\\n securityToken ............ : \" + (this.securityToken ? this.securityToken!.toString() : \"null\");\r\n        str += \"\\n serverNonce  ............. : \" + (this.serverNonce ? this.serverNonce.toString(\"hex\") : \"null\");\r\n        str += \"\\n clientNonce  ............. : \" + (this.clientNonce ? this.clientNonce.toString(\"hex\") : \"null\");\r\n        str += \"\\n transportTimeout ......... : \" + this.transportTimeout;\r\n        str += \"\\n maxMessageSize (to send..) : \" + (this._transport?.parameters?.maxMessageSize || \"<not set>\");\r\n        str += \"\\n maxChunkCount  (to send..) : \" + (this._transport?.parameters?.maxChunkCount || \"<not set>\");\r\n        str += \"\\n receiveBufferSize(server)  : \" + (this._transport?.parameters?.receiveBufferSize || \"<not set>\");\r\n        str += \"\\n\";\r\n        return str;\r\n    }\r\n\r\n    public isTransactionInProgress(): boolean {\r\n        return Object.keys(this._requests).length > 0;\r\n    }\r\n\r\n    public getClientNonce(): Buffer {\r\n        return this.clientNonce;\r\n    }\r\n\r\n    /**\r\n     * establish a secure channel with the provided server end point.\r\n     *\r\n     * @method create\r\n     * @async\r\n     * @param endpointUrl\r\n     * @param callback the async callback function\r\n     *\r\n     *\r\n     * @example\r\n     *\r\n     *    ```javascript\r\n     *\r\n     *    var secureChannel  = new ClientSecureChannelLayer({});\r\n     *\r\n     *    secureChannel.on(\"end\", function(err) {\r\n     *         console.log(\"secure channel has ended\",err);\r\n     *         if(err) {\r\n     *            console.log(\" the connection was closed by an external cause such as server shutdown\");\r\n     *        }\r\n     *    });\r\n     *    secureChannel.create(\"opc.tcp://localhost:1234/UA/Sample\", (err) => {\r\n     *         if(err) {\r\n     *              console.log(\" cannot establish secure channel\" , err);\r\n     *         } else {\r\n     *              console.log(\"secure channel has been established\");\r\n     *         }\r\n     *    });\r\n     *\r\n     *    ```\r\n     */\r\n    public create(endpointUrl: string, callback: ErrorCallback): void {\r\n        assert(typeof callback === \"function\");\r\n\r\n        if (this.securityMode !== MessageSecurityMode.None) {\r\n            // istanbul ignore next\r\n            if (!this.serverCertificate) {\r\n                return callback(\r\n                    new Error(\"ClientSecureChannelLayer#create : expecting a server certificate when securityMode is not None\")\r\n                );\r\n            }\r\n\r\n            // take the opportunity of this async method to perform some async pre-processing\r\n            if (!this.receiverPublicKey) {\r\n                extractPublicKeyFromCertificate(this.serverCertificate, (err: Error | null, publicKey?: PublicKeyPEM) => {\r\n                    /* istanbul ignore next */\r\n                    if (err) {\r\n                        return callback(err);\r\n                    }\r\n                    /* istanbul ignore next */\r\n                    if (!publicKey) {\r\n                        throw new Error(\"Internal Error\");\r\n                    }\r\n                    this.receiverPublicKey = publicKey;\r\n\r\n                    this.create(endpointUrl, callback);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.endpointUrl = endpointUrl;\r\n\r\n        const transport = new ClientTCP_transport(this.transportSettings);\r\n        transport.timeout = this.transportTimeout;\r\n\r\n        doDebug &&\r\n            debugLog(\"ClientSecureChannelLayer#create creating ClientTCP_transport with  transport.timeout = \", transport.timeout);\r\n        assert(!this._pending_transport);\r\n        this._pending_transport = transport;\r\n        this._establish_connection(transport, endpointUrl, (err?: Error | null) => {\r\n            if (err) {\r\n                doDebug && debugLog(chalk.red(\"cannot connect to server\"));\r\n                this._pending_transport = undefined;\r\n                transport.dispose();\r\n                return callback(err);\r\n            }\r\n\r\n            this._on_connection(transport, callback);\r\n        });\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._isDisconnecting = true;\r\n        this.abortConnection(() => {\r\n            /* empty */\r\n        });\r\n        this._cancel_security_token_watchdog();\r\n        if (this.__call) {\r\n            this.__call.abort();\r\n            this.__call = null;\r\n        }\r\n        if (this._transport) {\r\n            this._transport.dispose();\r\n            this._transport = undefined;\r\n        }\r\n        if (this._pending_transport) {\r\n            this._pending_transport.dispose();\r\n            this._pending_transport = undefined;\r\n        }\r\n    }\r\n\r\n    public abortConnection(callback: ErrorCallback): void {\r\n        this._isDisconnecting = true;\r\n        doDebug && debugLog(\"abortConnection \", !!this.__call);\r\n        assert(typeof callback === \"function\");\r\n\r\n        async.series(\r\n            [\r\n                (inner_callback: ErrorCallback) => {\r\n                    if (this.__call) {\r\n                        this.__call.once(\"abort\", () => inner_callback());\r\n                        this.__call._cancelBackoff = true;\r\n                        this.__call.abort();\r\n                        this.__call = null;\r\n                    } else {\r\n                        inner_callback();\r\n                    }\r\n                },\r\n                (inner_callback: ErrorCallback) => {\r\n                    if (!this._pending_transport) {\r\n                        return inner_callback();\r\n                    }\r\n                    this._pending_transport.disconnect(() => {\r\n                        inner_callback();\r\n                    });\r\n                },\r\n                (inner_callback: ErrorCallback) => {\r\n                    if (!this._transport) {\r\n                        return inner_callback();\r\n                    }\r\n                    this._transport.disconnect(() => {\r\n                        inner_callback();\r\n                    });\r\n                }\r\n            ],\r\n            () => {\r\n                callback();\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * perform a OPC-UA message transaction, asynchronously.\r\n     * During a transaction, the client sends a request to the server. The provided callback will be invoked\r\n     * at a later stage with the reply from the server, or the error.\r\n     *\r\n     * preconditions:\r\n     *   - the channel must be opened\r\n     *\r\n     * @example\r\n     *\r\n     *    ```javascript\r\n     *    let secure_channel ; // get a  ClientSecureChannelLayer somehow\r\n     *\r\n     *    const request = new BrowseRequest({...});\r\n     *    secure_channel.performMessageTransaction(request, (err,response) => {\r\n     *       if (err) {\r\n     *         // an error has occurred\r\n     *       } else {\r\n     *          assert(response instanceof BrowseResponse);\r\n     *         // do something with response.\r\n     *       }\r\n     *    });\r\n     *    ```\r\n     *\r\n     */\r\n    public performMessageTransaction(request: Request, callback: PerformTransactionCallback): void {\r\n        assert(typeof callback === \"function\");\r\n        this._performMessageTransaction(\"MSG\", request, callback);\r\n    }\r\n\r\n    public isValid(): boolean {\r\n        if (!this._transport) {\r\n            return false;\r\n        }\r\n        return this._transport.isValid();\r\n    }\r\n\r\n    public isOpened(): boolean {\r\n        return this.isValid() && this._isOpened;\r\n    }\r\n\r\n    public getDisplayName(): string {\r\n        if (!this.parent) {\r\n            return \"\";\r\n        }\r\n        return \"\" + (this.parent.applicationName ? this.parent.applicationName + \" \" : \"\") + this.parent.clientName;\r\n    }\r\n\r\n    public cancelPendingTransactions(callback: ErrorCallback): void {\r\n        assert(typeof callback === \"function\", \"expecting a callback function, but got \" + callback);\r\n\r\n        // istanbul ignore next\r\n        if (doDebug) {\r\n            debugLog(\r\n                \"cancelPendingTransactions \",\r\n                this.getDisplayName(),\r\n                \" = \",\r\n                Object.keys(this._requests)\r\n                    .map((k) => this._requests[k].request.constructor.name)\r\n                    .join(\" \")\r\n            );\r\n        }\r\n\r\n        for (const key of Object.keys(this._requests)) {\r\n            // kill timer id\r\n            const transaction = this._requests[key];\r\n            if (transaction.callback) {\r\n                transaction.callback(new Error(\"Transaction has been canceled because client channel  is being closed\"));\r\n            }\r\n        }\r\n        setImmediate(callback);\r\n    }\r\n\r\n    /**\r\n     * Close a client SecureChannel ,by sending a CloseSecureChannelRequest to the server.\r\n     *\r\n     *\r\n     * After this call, the connection is closed and no further transaction can be made.\r\n     *\r\n     * @method close\r\n     * @async\r\n     * @param callback\r\n     */\r\n    public close(callback: ErrorCallback): void {\r\n        assert(typeof callback === \"function\", \"expecting a callback function, but got \" + callback);\r\n\r\n        // cancel any pending transaction\r\n        this.cancelPendingTransactions((/* err?: Error */) => {\r\n            // what the specs says:\r\n            // --------------------\r\n            //   The client closes the connection by sending a CloseSecureChannelRequest and closing the\r\n            //   socket gracefully. When the server receives this message it shall release all resources\r\n            //   allocated for the channel. The server does not send a CloseSecureChannel response\r\n            //\r\n            // ( Note : some servers do  send a CloseSecureChannel though !)\r\n\r\n            // there is no need for the security token expiration event to trigger anymore\r\n            this._cancel_security_token_watchdog();\r\n\r\n            doDebug && debugLog(\"Sending CloseSecureChannelRequest to server\");\r\n            const request = new CloseSecureChannelRequest({});\r\n\r\n            this.__in_normal_close_operation = true;\r\n\r\n            if (!this._transport || this._transport.isDisconnecting) {\r\n                this.dispose();\r\n                return callback(new Error(\"Transport disconnected\"));\r\n            }\r\n            this._performMessageTransaction(\"CLO\", request, () => {\r\n                this.dispose();\r\n                callback();\r\n            });\r\n        });\r\n    }\r\n\r\n    private _closeWithError(err: Error, statusCode: StatusCode): void {\r\n        if (this._transport) {\r\n            this._transport.prematureTerminate(err, statusCode);\r\n            this._transport = undefined;\r\n        }\r\n        this.dispose();\r\n    }\r\n\r\n    private on_transaction_completed(transactionStatistics: ClientTransactionStatistics) {\r\n        /* istanbul ignore next */\r\n        if (doTraceStatistics) {\r\n            // dump some statistics about transaction ( time and sizes )\r\n            _dump_client_transaction_statistics(transactionStatistics);\r\n        }\r\n        this.emit(\"end_transaction\", transactionStatistics);\r\n    }\r\n\r\n    private _on_message_received(response: Response, msgType: string, requestId: number) {\r\n        //      assert(msgType !== \"ERR\");\r\n\r\n        /* istanbul ignore next */\r\n        if (response.responseHeader.requestHandle !== requestId) {\r\n            warningLog(response.toString());\r\n            errorLog(\r\n                chalk.red.bgWhite.bold(\"xxxxx  <<<<<< _on_message_received  ERROR\"),\r\n                \"requestId=\",\r\n                requestId,\r\n                this._requests[requestId]?.constructor.name,\r\n                \"response.responseHeader.requestHandle=\",\r\n                response.responseHeader.requestHandle,\r\n                response.schema.name.padStart(30)\r\n            );\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        if (doTraceClientMessage) {\r\n            traceClientResponseMessage(response, this.channelId, this._counter);\r\n        }\r\n\r\n        const requestData = this._requests[requestId];\r\n\r\n        /* istanbul ignore next */\r\n        if (!requestData) {\r\n            errorLog(\r\n                chalk.cyan.bold(\"xxxxx  <<<<<< _on_message_received for unknown or timeout request \"),\r\n                requestId,\r\n                response.schema.name.padStart(30),\r\n                response.responseHeader.serviceResult.toString(),\r\n                this.channelId\r\n            );\r\n            throw new Error(\" =>  invalid requestId =\" + requestId);\r\n        }\r\n\r\n        const request = requestData.request;\r\n\r\n        /* istanbul ignore next */\r\n        if (doPerfMonitoring) {\r\n            requestData._tick2 = this._tick2;\r\n        }\r\n\r\n        delete this._requests[requestId];\r\n\r\n        /* istanbul ignore next */\r\n        if (response.responseHeader.requestHandle !== request.requestHeader.requestHandle) {\r\n            const expected = request.requestHeader.requestHandle;\r\n            const actual = response.responseHeader.requestHandle;\r\n\r\n            if (actual !== 0x0) {\r\n                // note some old OPCUA Server, like siemens with OPCUA 1.2 may send 0x00 as a\r\n                // requestHandle, this is not harmful. THis happened with OpenSecureChannelRequest\r\n                // so we only display the warning message if we have a real random discrepancy between the two requestHandle.\r\n                const moreInfo = \"Request= \" + request.schema.name + \" Response = \" + response.schema.name;\r\n\r\n                const message =\r\n                    \" WARNING SERVER responseHeader.requestHandle is invalid\" +\r\n                    \": expecting 0x\" +\r\n                    expected.toString(16) +\r\n                    \"(\" +\r\n                    expected +\r\n                    \")\" +\r\n                    \"  but got 0x\" +\r\n                    actual.toString(16) +\r\n                    \"(\" +\r\n                    actual +\r\n                    \")\" +\r\n                    \" \";\r\n\r\n                debugLog(chalk.red.bold(message), chalk.yellow(moreInfo));\r\n                warningLog(chalk.red.bold(message), chalk.yellow(moreInfo));\r\n                warningLog(request.toString());\r\n            }\r\n        }\r\n\r\n        requestData.response = response;\r\n\r\n        if (doPerfMonitoring) {\r\n            // record tick2 : after response message has been received, before message processing\r\n            requestData._tick2 = this.messageBuilder!._tick1;\r\n        }\r\n        requestData.bytesRead = this.messageBuilder!.totalMessageSize;\r\n\r\n        if (doPerfMonitoring) {\r\n            // record tick3 : after response message has been received, before message processing\r\n            requestData._tick3 = get_clock_tick();\r\n        }\r\n\r\n        process_request_callback(requestData, null, response);\r\n\r\n        if (doPerfMonitoring) {\r\n            // record tick4 after callback\r\n            requestData._tick4 = get_clock_tick();\r\n        } // store some statistics\r\n        this._record_transaction_statistics(requestData);\r\n\r\n        // notify that transaction is completed\r\n        this.on_transaction_completed(this.last_transaction_stats);\r\n    }\r\n\r\n    private _record_transaction_statistics(requestData: RequestData) {\r\n        const request = requestData.request;\r\n        const response = requestData.response;\r\n        // ---------------------------------------------------------------------------------------------------------|-\r\n        //      _tick0                _tick1                         _tick2                       _tick3          _tick4\r\n        //          sending request\r\n        //        |---------------------|  waiting response\r\n        //                              |------------------------------|      receiving response\r\n        //                                                             |---------------------------| process.resp\r\n        //                                                                                  |---------------|\r\n        this.last_transaction_stats = {\r\n            bytesRead: requestData.bytesRead,\r\n            bytesWritten: requestData.bytesWritten_after - requestData.bytesWritten_before,\r\n            lap_processing_response: requestData._tick4 - requestData._tick3,\r\n            lap_receiving_response: requestData._tick3 - requestData._tick2,\r\n            lap_sending_request: requestData._tick1 - requestData._tick0,\r\n            lap_transaction: requestData._tick4 - requestData._tick0,\r\n            lap_waiting_response: requestData._tick2 - requestData._tick1,\r\n            request,\r\n            response\r\n        };\r\n\r\n        if (doTraceStatistics) {\r\n            _dump_client_transaction_statistics(this.last_transaction_stats);\r\n        }\r\n    }\r\n\r\n    private _cancel_pending_transactions(err?: Error | null) {\r\n        if (doDebug && this._requests) {\r\n            debugLog(\r\n                \"_cancel_pending_transactions  \",\r\n                Object.keys(this._requests),\r\n                this._transport ? this._transport.name : \"no transport\"\r\n            );\r\n        }\r\n\r\n        if (this._requests) {\r\n            for (const requestData of Object.values(this._requests)) {\r\n                if (requestData) {\r\n                    const request = requestData.request;\r\n                    doDebug &&\r\n                        debugLog(\"Cancelling pending transaction \", requestData.key, requestData.msgType, request?.schema.name);\r\n                    process_request_callback(requestData, err);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._requests = {};\r\n    }\r\n\r\n    private _on_transport_closed(err?: Error | null) {\r\n        doDebug && debugLog(\" =>ClientSecureChannelLayer#_on_transport_closed  err=\", err ? err.message : \"null\");\r\n\r\n        if (this.__in_normal_close_operation) {\r\n            err = undefined;\r\n        }\r\n        this.emit(\"close\", err);\r\n\r\n        //\r\n        this._bytesRead += this._transport?.bytesRead || 0;\r\n        this._bytesWritten += this._transport?.bytesWritten || 0;\r\n\r\n        this._transport?.dispose();\r\n        this._transport = undefined;\r\n        this._cancel_pending_transactions(err);\r\n        this._cancel_security_token_watchdog();\r\n        this.dispose();\r\n    }\r\n\r\n    private _on_security_token_about_to_expire() {\r\n        if (!this.securityToken) {\r\n            return;\r\n        }\r\n\r\n        doDebug &&\r\n            debugLog(\r\n                \" client: Security Token \",\r\n                this.securityToken.tokenId,\r\n                \" is about to expired, let's raise lifetime_75 event \"\r\n            );\r\n\r\n        this.emit(\"lifetime_75\", this.securityToken);\r\n        this._renew_security_token();\r\n    }\r\n\r\n    private _cancel_security_token_watchdog() {\r\n        if (this._securityTokenTimeoutId) {\r\n            clearTimeout(this._securityTokenTimeoutId);\r\n            this._securityTokenTimeoutId = null;\r\n        }\r\n    }\r\n\r\n    private _install_security_token_watchdog() {\r\n        if (!this.securityToken) {\r\n            errorLog(\"Failed to install security token watch dog before securityToken is null!\");\r\n            return;\r\n        }\r\n\r\n        // install timer event to raise a 'lifetime_75' when security token is about to expired\r\n        // so that client can request for a new security token\r\n        // note that, for speedup in test,\r\n        // it is possible to tweak this interval for test by specifying a tokenRenewalInterval value\r\n        //\r\n        const lifeTime = this.securityToken.revisedLifetime;\r\n        assert(lifeTime !== 0 && lifeTime > 20);\r\n        const percent = 75 / 100.0;\r\n        let timeout = this.tokenRenewalInterval || lifeTime * percent;\r\n        timeout = Math.min(timeout, (lifeTime * 75) / 100);\r\n        timeout = Math.max(timeout, 50); // at least one half second !\r\n\r\n        if (doDebug) {\r\n            debugLog(\r\n                chalk.red.bold(\" time until next security token renewal = \"),\r\n                timeout,\r\n                \"( lifetime = \",\r\n                lifeTime + \" -  tokenRenewalInterval =\" + this.tokenRenewalInterval\r\n            );\r\n        }\r\n        assert(this._securityTokenTimeoutId === null);\r\n        // security token renewal should happen without overlapping\r\n        this._securityTokenTimeoutId = setTimeout(() => {\r\n            this._securityTokenTimeoutId = null;\r\n            this._on_security_token_about_to_expire();\r\n        }, timeout);\r\n    }\r\n\r\n    private _build_client_nonce() {\r\n        if (this.securityMode === MessageSecurityMode.None) {\r\n            return null;\r\n        }\r\n        // create a client Nonce if secure mode is requested\r\n        // Release 1.02 page 23 OPC Unified Architecture, Part 4 Table 7 \u2013 OpenSecureChannel Service Parameters\r\n        // clientNonce\r\n        // \"This parameter shall have a length equal to key size used for the symmetric\r\n        //  encryption algorithm that is identified by the securityPolicyUri\"\r\n\r\n        const cryptoFactory = getCryptoFactory(this.securityPolicy);\r\n        if (!cryptoFactory) {\r\n            // this securityPolicy may not be support yet ... let's return null\r\n            return null;\r\n        }\r\n        assert(cryptoFactory !== null && typeof cryptoFactory === \"object\");\r\n        return randomBytes(cryptoFactory.symmetricKeyLength);\r\n    }\r\n\r\n    private _open_secure_channel_request(isInitial: boolean, callback: ErrorCallback) {\r\n        assert(this.securityMode !== MessageSecurityMode.Invalid, \"invalid security mode\");\r\n        // from the specs:\r\n        // The OpenSecureChannel Messages are not signed or encrypted if the SecurityMode is None. The\r\n        // nonces  are ignored and should be set to null. The SecureChannelId and the TokenId are still\r\n        // assigned but no security is applied to Messages exchanged via the channel.\r\n\r\n        const msgType = \"OPN\";\r\n        const requestType = isInitial ? SecurityTokenRequestType.Issue : SecurityTokenRequestType.Renew;\r\n\r\n        this.clientNonce = this._build_client_nonce();\r\n\r\n        this._isOpened = !isInitial;\r\n\r\n        // OpenSecureChannel\r\n        const msg = new OpenSecureChannelRequest({\r\n            clientNonce: this.clientNonce, //\r\n            clientProtocolVersion: this.protocolVersion,\r\n            requestHeader: {\r\n                auditEntryId: null\r\n            },\r\n            requestType: requestType,\r\n            requestedLifetime: this.defaultSecureTokenLifetime,\r\n            securityMode: this.securityMode\r\n        });\r\n\r\n        this._performMessageTransaction(msgType, msg, (err?: Error | null, response?: Response) => {\r\n            // istanbul ignore next\r\n            if (response && response.responseHeader && response.responseHeader.serviceResult !== StatusCodes.Good) {\r\n                warningLog(\r\n                    \"xxxxx => response.responseHeader.serviceResult \",\r\n                    response.constructor.name,\r\n                    response.responseHeader.serviceResult.toString()\r\n                );\r\n                err = new Error(response.responseHeader.serviceResult.toString());\r\n            }\r\n            if (!err && response) {\r\n                const openSecureChannelResponse = response as OpenSecureChannelResponse;\r\n\r\n                // record channelId for future transactions\r\n                this.channelId = openSecureChannelResponse.securityToken.channelId;\r\n\r\n                // todo : verify that server certificate is  valid\r\n                // A self-signed application instance certificate does not need to be verified with a CA.\r\n                // todo : verify that Certificate URI matches the ApplicationURI of the server\r\n\r\n                assert(\r\n                    openSecureChannelResponse.securityToken.tokenId > 0 || msgType === \"OPN\",\r\n                    \"_sendSecureOpcUARequest: invalid token Id \"\r\n                );\r\n                assert(Object.prototype.hasOwnProperty.call(openSecureChannelResponse, \"serverNonce\"));\r\n                this.securityToken = openSecureChannelResponse.securityToken;\r\n                this.serverNonce = openSecureChannelResponse.serverNonce;\r\n\r\n                if (this.securityMode !== MessageSecurityMode.None) {\r\n                    // verify that server nonce if provided is at least 32 bytes long\r\n\r\n                    /* istanbul ignore next */\r\n                    if (!openSecureChannelResponse.serverNonce) {\r\n                        warningLog(\" client : server nonce is missing !\");\r\n                        return callback(new Error(\" Invalid server nonce\"));\r\n                    }\r\n                    // This parameter shall have a length equal to key size used for the symmetric\r\n                    // encryption algorithm that is identified by the securityPolicyUri.\r\n                    if (openSecureChannelResponse.serverNonce.length !== this.clientNonce.length) {\r\n                        warningLog(\" client : server nonce is invalid  (invalid length)!\");\r\n                        return callback(new Error(\" Invalid server nonce length\"));\r\n                    }\r\n                }\r\n\r\n                const cryptoFactory = this.messageBuilder!.cryptoFactory;\r\n                if (cryptoFactory) {\r\n                    assert(this.serverNonce instanceof Buffer);\r\n                    /* istanbul ignore next */\r\n                    if (!this.serverNonce) {\r\n                        throw new Error(\"internal error\");\r\n                    }\r\n                    this.derivedKeys = computeDerivedKeys(cryptoFactory, this.serverNonce, this.clientNonce);\r\n                }\r\n\r\n                const derivedServerKeys = this.derivedKeys ? this.derivedKeys.derivedServerKeys : null;\r\n\r\n                // istanbul ignore next\r\n                if (doDebug) {\r\n                    debugLog(\"Server has send a new security Token\");\r\n                }\r\n\r\n                this.messageBuilder!.pushNewToken(this.securityToken, derivedServerKeys);\r\n\r\n                this._install_security_token_watchdog();\r\n\r\n                this._isOpened = true;\r\n            }\r\n            callback(err || undefined);\r\n        });\r\n    }\r\n\r\n    private _on_connection(transport: ClientTCP_transport, callback: ErrorCallback) {\r\n        assert(this._pending_transport === transport);\r\n        this._pending_transport = undefined;\r\n        this._transport = transport;\r\n\r\n        // install message chunker limits:\r\n        this.messageChunker.maxMessageSize = this._transport?.maxMessageSize || 0;\r\n        this.messageChunker.maxChunkCount = this._transport?.maxChunkCount || 0;\r\n\r\n        this._install_message_builder();\r\n\r\n        this._transport.on(\"chunk\", (messageChunk: Buffer) => {\r\n            this.emit(\"receive_chunk\", messageChunk);\r\n            this._on_receive_message_chunk(messageChunk);\r\n        });\r\n\r\n        this._transport.on(\"close\", (err: Error | null) => this._on_transport_closed(err));\r\n\r\n        this._transport.on(\"connection_break\", () => {\r\n            doDebug && debugLog(chalk.red(\"Client => CONNECTION BREAK  <=\"));\r\n            this._on_transport_closed(new Error(\"Connection Break\"));\r\n        });\r\n\r\n        setImmediate(() => {\r\n            doDebug && debugLog(chalk.red(\"Client now sending OpenSecureChannel\"));\r\n            const isInitial = true;\r\n            this._open_secure_channel_request(isInitial, callback);\r\n        });\r\n    }\r\n\r\n    private _backoff_completion(\r\n        err: Error | undefined,\r\n        lastError: Error | undefined,\r\n        transport: ClientTCP_transport,\r\n        callback: ErrorCallback\r\n    ) {\r\n        if (this.__call) {\r\n            // console log =\r\n            transport.numberOfRetry = transport.numberOfRetry || 0;\r\n            transport.numberOfRetry += this.__call.getNumRetries();\r\n            this.__call.removeAllListeners();\r\n            this.__call = null;\r\n\r\n            if (err) {\r\n                callback(lastError || err);\r\n            } else {\r\n                callback();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _connect(transport: ClientTCP_transport, endpointUrl: string, _i_callback: ErrorCallback) {\r\n        if (this.__call && this.__call._cancelBackoff) {\r\n            return;\r\n        }\r\n\r\n        const on_connect = (err?: Error) => {\r\n            doDebug && debugLog(\"Connection => err\", err ? err.message : \"null\");\r\n            // force Backoff to fail if err is not ECONNRESET or ECONNREFUSED\r\n            // this mean that the connection to the server has succeeded but for some reason\r\n            // the server has denied the connection\r\n            // the cause could be:\r\n            //   - invalid protocol version specified by client\r\n            //   - server going to shutdown\r\n            //   - server too busy -\r\n            //   - server shielding itself from a DDOS attack\r\n            if (err) {\r\n                let should_abort = this._isDisconnecting;\r\n\r\n                if (err.message.match(/ECONNRESET/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadProtocolVersionUnsupported/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadTcpInternalError/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadTcpMessageTooLarge/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadTcpEndpointUriInvlid/)) {\r\n                    should_abort = true;\r\n                }\r\n                if (err.message.match(/BadTcpMessageTypeInvalid/)) {\r\n                    should_abort = true;\r\n                }\r\n\r\n                this.lastError = err;\r\n\r\n                if (this.__call) {\r\n                    // connection cannot be establish ? if not, abort the backoff process\r\n                    if (should_abort) {\r\n                        doDebug && debugLog(\" Aborting backoff process prematurely - err = \", err.message);\r\n                        this.__call.abort();\r\n                    } else {\r\n                        doDebug && debugLog(\" backoff - keep trying - err = \", err.message);\r\n                    }\r\n                }\r\n            }\r\n            _i_callback(err);\r\n        };\r\n\r\n        transport.connect(endpointUrl, on_connect);\r\n    }\r\n\r\n    private _establish_connection(transport: ClientTCP_transport, endpointUrl: string, callback: ErrorCallback) {\r\n        transport.protocolVersion = this.protocolVersion;\r\n\r\n        this.lastError = undefined;\r\n\r\n        if (this.connectionStrategy.maxRetry === 0) {\r\n            doDebug && debugLog(chalk.cyan(\"max Retry === 0 =>  No backoff required -> call the _connect function directly\"));\r\n            this.__call = 0;\r\n            return this._connect(transport, endpointUrl, callback);\r\n        }\r\n\r\n        const connectFunc = (callback2: ErrorCallback) => {\r\n            return this._connect(transport, endpointUrl, callback2);\r\n        };\r\n        const completionFunc = (err?: Error) => {\r\n            return this._backoff_completion(err, this.lastError, transport, callback);\r\n        };\r\n\r\n        this.__call = backoff.call(connectFunc, completionFunc);\r\n\r\n        if (this.connectionStrategy.maxRetry >= 0) {\r\n            const maxRetry = Math.max(this.connectionStrategy.maxRetry, 1);\r\n            doDebug && debugLog(chalk.cyan(\"backoff will failed after \"), maxRetry);\r\n            this.__call.failAfter(maxRetry);\r\n        } else {\r\n            // retry will be infinite\r\n            doDebug && debugLog(chalk.cyan(\"backoff => starting a infinite retry\"));\r\n        }\r\n\r\n        const onBackoffFunc = (retryCount: number, delay: number) => {\r\n            doDebug &&\r\n                debugLog(\r\n                    chalk.bgWhite.cyan(\" Backoff #\"),\r\n                    retryCount,\r\n                    \"delay = \",\r\n                    delay,\r\n                    \" ms\",\r\n                    \" maxRetry \",\r\n                    this.connectionStrategy.maxRetry\r\n                );\r\n            // Do something when backoff starts, e.g. show to the\r\n            // user the delay before next reconnection attempt.\r\n            this.emit(\"backoff\", retryCount, delay);\r\n        };\r\n\r\n        this.__call.on(\"backoff\", onBackoffFunc);\r\n\r\n        this.__call.on(\"abort\", () => {\r\n            doDebug && debugLog(chalk.bgWhite.cyan(` abort #   after ${this.__call.getNumRetries()} retries.`));\r\n            // Do something when backoff starts, e.g. show to the\r\n            // user the delay before next reconnection attempt.\r\n            this.emit(\"abort\");\r\n            setImmediate(() => {\r\n                this._backoff_completion(undefined, new Error(\"Connection abandoned\"), transport, callback);\r\n            });\r\n        });\r\n\r\n        this.__call.setStrategy(new backoff.ExponentialStrategy(this.connectionStrategy));\r\n        this.__call.start();\r\n    }\r\n\r\n    private _renew_security_token() {\r\n        doDebug && debugLog(\"ClientSecureChannelLayer#_renew_security_token\");\r\n\r\n        // istanbul ignore next\r\n        if (!this.isValid()) {\r\n            // this may happen if the communication has been closed by the client or the sever\r\n            warningLog(\"Invalid socket => Communication has been lost, cannot renew token\");\r\n            return;\r\n        }\r\n\r\n        const isInitial = false;\r\n        this._open_secure_channel_request(isInitial, (err?: Error | null) => {\r\n            /* istanbul ignore else */\r\n            if (!err) {\r\n                doDebug && debugLog(\" token renewed\");\r\n                this.emit(\"security_token_renewed\");\r\n            } else {\r\n                if (doDebug) {\r\n                    debugLog(\"ClientSecureChannelLayer: Warning: securityToken hasn't been renewed -> err \", err);\r\n                }\r\n                // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX CHECK ME !!!\r\n                this._closeWithError(\r\n                    new Error(\"Restarting because Request has timed out during OpenSecureChannel\"),\r\n                    StatusCodes2.BadRequestTimeout\r\n                );\r\n            }\r\n        });\r\n    }\r\n\r\n    private _on_receive_message_chunk(messageChunk: Buffer) {\r\n        /* istanbul ignore next */\r\n        if (doDebug1) {\r\n            const _stream = new BinaryStream(messageChunk);\r\n            const messageHeader = readMessageHeader(_stream);\r\n            debugLog(\"CLIENT RECEIVED \" + chalk.yellow(JSON.stringify(messageHeader) + \"\"));\r\n            debugLog(\"\\n\" + hexDump(messageChunk));\r\n            debugLog(messageHeaderToString(messageChunk));\r\n        }\r\n        this.messageBuilder!.feed(messageChunk);\r\n    }\r\n\r\n    /**\r\n     * @method makeRequestId\r\n     * @return  newly generated request id\r\n     * @private\r\n     */\r\n    private makeRequestId(): number {\r\n        this._lastRequestId += 1;\r\n        return this._lastRequestId;\r\n    }\r\n\r\n    /**\r\n     * internal version of _performMessageTransaction.\r\n     *\r\n     * @method _performMessageTransaction\r\n     * @private\r\n     *\r\n     * - this method takes a extra parameter : msgType\r\n     * TODO:\r\n     * - this method can be re-entrant, meaning that a new transaction can be started before any pending transaction\r\n     *   is fully completed.\r\n     * - Any error on transport will cause all pending transactions to be cancelled\r\n     *\r\n     * - the method returns a timeout Error if the server fails to return a response within the timeoutHint interval.\r\n     *\r\n     *\r\n     */\r\n\r\n    private _performMessageTransaction(msgType: string, request: Request, callback: PerformTransactionCallback) {\r\n        assert(typeof callback === \"function\");\r\n\r\n        if (!this.isValid()) {\r\n            return callback(\r\n                new Error(\"ClientSecureChannelLayer => Socket is closed ! while processing \" + request.constructor.name)\r\n            );\r\n        }\r\n\r\n        let localCallback: PerformTransactionCallback | null = callback;\r\n\r\n        let timeout = request.requestHeader.timeoutHint || ClientSecureChannelLayer.defaultTransactionTimeout;\r\n        timeout = Math.max(ClientSecureChannelLayer.minTransactionTimeout, timeout);\r\n\r\n        // adjust request timeout\r\n        request.requestHeader.timeoutHint = timeout;\r\n\r\n        /* istanbul ignore next */\r\n        if (doDebug) {\r\n            debugLog(\"Adjusted timeout = \", request.requestHeader.timeoutHint);\r\n        }\r\n        let timerId: any = null;\r\n\r\n        let hasTimedOut = false;\r\n\r\n        const modified_callback = (err?: Error | null, response?: Response) => {\r\n            /* istanbul ignore next */\r\n            if (doDebug) {\r\n                debugLog(\r\n                    chalk.cyan(\"------------------------------------- Client receiving response \"),\r\n                    request.constructor.name,\r\n                    request.requestHeader.requestHandle,\r\n                    response ? response.constructor.name : \"null\",\r\n                    \"err=\",\r\n                    err ? err.message : \"null\",\r\n                    \"securityTokenId=\",\r\n                    this.securityToken ? this.securityToken!.tokenId : \"x\"\r\n                );\r\n            }\r\n            if (response && doTraceClientRequestContent) {\r\n                warningLog(response.toString());\r\n            }\r\n\r\n            if (!localCallback) {\r\n                return; // already processed by time  out\r\n            }\r\n            // when response === null we are processing the timeout , therefore there is no need to clearTimeout\r\n            if (!hasTimedOut && timerId) {\r\n                clearTimeout(timerId);\r\n            }\r\n            timerId = null;\r\n\r\n            if (!err && response) {\r\n                this.emit(\"receive_response\", response);\r\n            }\r\n            assert(!err || err instanceof Error);\r\n\r\n            delete this._requests[request.requestHeader.requestHandle];\r\n            // invoke user callback if it has not been intercepted first ( by a abrupt disconnection for instance )\r\n            try {\r\n                localCallback.call(this, err || null, response);\r\n            } catch (err1) {\r\n                errorLog(\"ERROR !!! callback has thrown en error \", err1);\r\n                callback(err || null);\r\n            } finally {\r\n                localCallback = null;\r\n            }\r\n        };\r\n\r\n        const optionalTrace = !checkTimeout || new Error().stack;\r\n\r\n        timerId = setTimeout(() => {\r\n            timerId = null;\r\n            hasTimedOut = true;\r\n            if (checkTimeout) {\r\n                warningLog(\" Timeout .... waiting for response for \", request.constructor.name, request.requestHeader.toString());\r\n                warningLog(\" Timeout was \", timeout, \"ms\");\r\n                warningLog(request.toString());\r\n                warningLog(optionalTrace);\r\n            }\r\n            modified_callback(\r\n                new Error(\"Transaction has timed out ( timeout = \" + timeout + \" ms , request = \" + request.constructor.name + \")\")\r\n            );\r\n            this._timeout_request_count += 1;\r\n\r\n            this.emit(\"timed_out_request\", request);\r\n            // xx // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX CHECK ME !!!\r\n            // xx this.closeWithError(new Error(\"Restarting because Request has timed out (1)\"), () => { });\r\n        }, timeout);\r\n\r\n        const transaction_data = {\r\n            callback: modified_callback,\r\n            msgType: msgType,\r\n            request: request,\r\n            timerId: timerId\r\n        };\r\n\r\n        this._internal_perform_transaction(transaction_data);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param transactionData\r\n     * @param transactionData.msgType\r\n     * @param transactionData.request\r\n     * @param transactionData.callback\r\n     * @private\r\n     */\r\n\r\n    private _internal_perform_transaction(transactionData: TransactionData) {\r\n        assert(typeof transactionData.callback === \"function\");\r\n\r\n        if (!this._transport) {\r\n            setTimeout(() => {\r\n                transactionData.callback(new Error(\"Client not connected\"));\r\n            }, 100);\r\n            return;\r\n        }\r\n        assert(this._transport, \" must have a valid transport\");\r\n\r\n        const msgType = transactionData.msgType;\r\n        const request = transactionData.request;\r\n\r\n        assert(msgType.length === 3);\r\n        // get a new requestId\r\n        const requestHandle = this.makeRequestId();\r\n\r\n        /* istanbul ignore next */\r\n        if (request.requestHeader.requestHandle !== requestHandleNotSetValue) {\r\n            errorLog(\r\n                chalk.bgRed.white(\"xxxxx   >>>>>> request has already been set with a requestHandle\"),\r\n                requestHandle,\r\n                request.requestHeader.requestHandle,\r\n                request.constructor.name\r\n            );\r\n            errorLog(Object.keys(this._requests).join(\" \"));\r\n            errorLog(new Error(\"Investigate me\"));\r\n        }\r\n\r\n        request.requestHeader.requestHandle = requestHandle;\r\n\r\n        /* istanbul ignore next */\r\n        if (doTraceClientMessage) {\r\n            traceClientRequestMessage(request, this.channelId, this._counter);\r\n        }\r\n\r\n        const requestData: RequestData = {\r\n            callback: transactionData.callback,\r\n            msgType: msgType,\r\n            request: request,\r\n\r\n            bytesRead: 0,\r\n            bytesWritten_after: 0,\r\n            bytesWritten_before: this.bytesWritten,\r\n\r\n            _tick0: 0,\r\n            _tick1: 0,\r\n            _tick2: 0,\r\n            _tick3: 0,\r\n            _tick4: 0,\r\n            key: \"\",\r\n\r\n            chunk_count: 0\r\n        };\r\n\r\n        this._requests[requestHandle] = requestData;\r\n\r\n        /* istanbul ignore next */\r\n        if (doPerfMonitoring) {\r\n            const stats = requestData;\r\n            // record tick0 : befoe request is being sent to server\r\n            stats._tick0 = get_clock_tick();\r\n        }\r\n        // check that limits are OK\r\n        this._sendSecureOpcUARequest(msgType, request, requestHandle);\r\n    }\r\n\r\n    private _send_chunk(requestId: number, chunk: Buffer | null) {\r\n        const requestData = this._requests[requestId];\r\n\r\n        if (chunk) {\r\n            this.emit(\"send_chunk\", chunk);\r\n\r\n            /* istanbul ignore next */\r\n            if (checkChunks) {\r\n                verify_message_chunk(chunk);\r\n                debugLog(chalk.yellow(\"CLIENT SEND chunk \"));\r\n                debugLog(chalk.yellow(messageHeaderToString(chunk)));\r\n                debugLog(chalk.red(hexDump(chunk)));\r\n            }\r\n            assert(this._transport);\r\n            this._transport?.write(chunk);\r\n            requestData.chunk_count += 1;\r\n        } else {\r\n            // last chunk ....\r\n\r\n            /* istanbul ignore next */\r\n            if (checkChunks) {\r\n                debugLog(chalk.yellow(\"CLIENT SEND done.\"));\r\n            }\r\n            if (requestData) {\r\n                if (doPerfMonitoring) {\r\n                    requestData._tick1 = get_clock_tick();\r\n                }\r\n                requestData.bytesWritten_after = this.bytesWritten;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _construct_security_header() {\r\n        this.receiverCertificate = this.serverCertificate ? Buffer.from(this.serverCertificate) : null;\r\n        let securityHeader = null;\r\n        switch (this.securityMode) {\r\n            case MessageSecurityMode.Sign:\r\n            case MessageSecurityMode.SignAndEncrypt: {\r\n                assert(this.securityPolicy !== SecurityPolicy.None);\r\n                // get the thumbprint of the client certificate\r\n                const receiverCertificateThumbprint = getThumbprint(this.receiverCertificate);\r\n\r\n                securityHeader = new AsymmetricAlgorithmSecurityHeader({\r\n                    receiverCertificateThumbprint, // thumbprint of the public key used to encrypt the message\r\n                    securityPolicyUri: toURI(this.securityPolicy),\r\n\r\n                    /**\r\n                     * The X.509 v3 Certificate assigned to the sending application Instance.\r\n                     *  This is a DER encoded blob.\r\n                     * The structure of an X.509 v3 Certificate is defined in X.509 v3.\r\n                     * The DER format for a Certificate is defined in X690\r\n                     * This indicates what Private Key was used to sign the MessageChunk.\r\n                     * The Stack shall close the channel and report an error to the application if the SenderCertificate is too large for the buffer size supported by the transport layer.\r\n                     * This field shall be null if the Message is not signed.\r\n                     * If the Certificate is signed by a CA, the DER encoded CA Certificate may be\r\n                     * appended after the Certificate in the byte array. If the CA Certificate is also\r\n                     * signed by another CA this process is repeated until the entire Certificate chain\r\n                     *  is in the buffer or if MaxSenderCertificateSize limit is reached (the process\r\n                     * stops after the last whole Certificate that can be added without exceeding\r\n                     * the MaxSenderCertificateSize limit).\r\n                     * Receivers can extract the Certificates from the byte array by using the Certificate\r\n                     *  size contained in DER header (see X.509 v3).\r\n                     */\r\n                    senderCertificate: this.getCertificateChain() // certificate of the private key used to sign the message\r\n                });\r\n\r\n                if (dumpSecurityHeader) {\r\n                    warningLog(\"HEADER !!!! \", securityHeader.toString());\r\n                }\r\n                break;\r\n            }\r\n            default:\r\n                /* istanbul ignore next */\r\n                assert(false, \"invalid security mode\");\r\n        }\r\n        this.securityHeader = securityHeader;\r\n    }\r\n\r\n    private _get_security_options_for_OPN() {\r\n        if (this.securityMode === MessageSecurityMode.None) {\r\n            return null;\r\n        }\r\n\r\n        this._construct_security_header();\r\n        this.messageChunker.securityHeader = this.securityHeader;\r\n\r\n        const senderPrivateKey = this.getPrivateKey();\r\n\r\n        if (!senderPrivateKey) {\r\n            throw new Error(\"invalid senderPrivateKey\");\r\n        }\r\n\r\n        const cryptoFactory = getCryptoFactory(this.securityPolicy);\r\n\r\n        if (!cryptoFactory) {\r\n            return null; // may be a not yet supported security Policy\r\n        }\r\n\r\n        assert(cryptoFactory, \"expecting a cryptoFactory\");\r\n        assert(typeof cryptoFactory.asymmetricSign === \"function\");\r\n\r\n        const options: any = {};\r\n\r\n        options.signatureLength = rsa_length(senderPrivateKey);\r\n\r\n        options.signBufferFunc = (chunk: Buffer) => {\r\n            const s = cryptoFactory.asymmetricSign(chunk, senderPrivateKey);\r\n            assert(s.length === options.signatureLength);\r\n            return s;\r\n        };\r\n\r\n        // istanbul ignore next\r\n        if (!this.receiverPublicKey) {\r\n            throw new Error(\" invalid receiverPublicKey\");\r\n        }\r\n        const keyLength = rsa_length(this.receiverPublicKey);\r\n        options.plainBlockSize = keyLength - cryptoFactory.blockPaddingSize;\r\n        options.cipherBlockSize = keyLength;\r\n\r\n        const receiverPublicKey = this.receiverPublicKey;\r\n        options.encryptBufferFunc = (chunk: Buffer): Buffer => {\r\n            return cryptoFactory.asymmetricEncrypt(chunk, receiverPublicKey);\r\n        };\r\n\r\n        return options;\r\n    }\r\n\r\n    private _get_security_options_for_MSG() {\r\n        if (this.securityMode === MessageSecurityMode.None) {\r\n            return null;\r\n        }\r\n\r\n        // istanbul ignore next\r\n        if (!this.derivedKeys || !this.derivedKeys.derivedClientKeys) {\r\n            errorLog(\"derivedKeys not set but security mode = \", MessageSecurityMode[this.securityMode]);\r\n            return null; //\r\n            // throw new Error(\"internal error expecting valid derivedKeys while security mode is \" + MessageSecurityMode[this.securityMode]);\r\n        }\r\n\r\n        const derivedClientKeys = this.derivedKeys.derivedClientKeys;\r\n        assert(derivedClientKeys, \"expecting valid derivedClientKeys\");\r\n        return getOptionsForSymmetricSignAndEncrypt(this.securityMode, derivedClientKeys);\r\n    }\r\n\r\n    private _sendSecureOpcUARequest(msgType: string, request: Request, requestId: number) {\r\n        const tokenId = this.securityToken ? this.securityToken.tokenId : 0;\r\n\r\n        // assert(this.channelId !== 0 , \"channel Id cannot be null\");\r\n\r\n        let options: ChunkMessageOptions = {\r\n            channelId: this.channelId,\r\n            chunkSize: 0,\r\n            requestId,\r\n            tokenId,\r\n\r\n            cipherBlockSize: 0,\r\n            plainBlockSize: 0,\r\n            sequenceHeaderSize: 0,\r\n            signatureLength: 0\r\n        };\r\n\r\n        // use chunk size that has been negotiated by the transport layer\r\n        if (this._transport?.parameters && this._transport?.parameters.sendBufferSize) {\r\n            options.chunkSize = this._transport.parameters.sendBufferSize;\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        if (request.requestHeader.requestHandle !== options.requestId) {\r\n            doDebug &&\r\n                debugLog(\r\n                    chalk.red.bold(\"------------------------------------- Invalid request id\"),\r\n                    request.requestHeader.requestHandle,\r\n                    options.requestId\r\n                );\r\n        }\r\n\r\n        request.requestHeader.returnDiagnostics = 0x0;\r\n\r\n        /* istanbul ignore next */\r\n        if (doTraceClientRequestContent) {\r\n            warningLog(\r\n                chalk.yellow.bold(\"------------------------------------- Client Sending a request  \"),\r\n                request.constructor.name,\r\n                \"h=\",\r\n                request.requestHeader.requestHandle,\r\n                \" channel id \",\r\n                this.channelId,\r\n                \" securityToken=\",\r\n                this.securityToken! ? this.securityToken!.tokenId : \"x\"\r\n            );\r\n        }\r\n        if (doTraceClientRequestContent) {\r\n            warningLog(request.toString());\r\n        }\r\n\r\n        const security_options = msgType === \"OPN\" ? this._get_security_options_for_OPN() : this._get_security_options_for_MSG();\r\n        if (security_options) {\r\n            options = {\r\n                ...options,\r\n                ...security_options\r\n            };\r\n        }\r\n\r\n        this.emit(\"send_request\", request);\r\n\r\n        this.messageChunker.chunkSecureMessage(\r\n            msgType,\r\n            options,\r\n            request as BaseUAObject,\r\n            (err: Error | null, chunk: Buffer | null) => {\r\n                if (err) {\r\n                    // the messageChunk has not send anything due to an error detected in the chunker\r\n                    const response = new ServiceFault({\r\n                        responseHeader: {\r\n                            serviceResult: StatusCodes.BadInternalError,\r\n                            stringTable: [err.message]\r\n                        }\r\n                    });\r\n                    this._send_chunk(requestId, null);\r\n                    this._on_message_received(response, \"ERR\", request.requestHeader.requestHandle);\r\n                } else {\r\n                    this._send_chunk(requestId, chunk);\r\n                }\r\n            }\r\n        );\r\n    }\r\n}\r\n", "/**\n * @module node-opcua-server-discovery\n */\n\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport * as url from \"url\";\nimport { callbackify } from \"util\";\n\nimport * as chalk from \"chalk\";\nimport envPaths = require(\"env-paths\");\n\nimport { assert } from \"node-opcua-assert\";\nimport { UAString } from \"node-opcua-basic-types\";\nimport { makeApplicationUrn } from \"node-opcua-common\";\nimport { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\nimport { extractFullyQualifiedDomainName, resolveFullyQualifiedDomainName } from \"node-opcua-hostname\";\nimport { Message, Response, ServerSecureChannelLayer, ServiceFault } from \"node-opcua-secure-channel\";\nimport { OPCUABaseServer, OPCUABaseServerOptions, OPCUAServerEndPoint } from \"node-opcua-server\";\n\nimport {\n    Announcement,\n    BonjourHolder,\n    FindServersOnNetworkRequest,\n    FindServersOnNetworkResponse,\n    MdnsDiscoveryConfiguration,\n    RegisteredServer,\n    RegisterServer2Request,\n    RegisterServer2Response,\n    RegisterServerRequest,\n    RegisterServerResponse,\n    sameService,\n    serviceToString,\n    announcementToServiceConfig,\n    ServerOnNetwork\n} from \"node-opcua-service-discovery\";\nimport { OPCUACertificateManager } from \"node-opcua-certificate-manager\";\nimport { ApplicationDescription } from \"node-opcua-service-endpoints\";\nimport { ApplicationDescriptionOptions, ApplicationType } from \"node-opcua-service-endpoints\";\nimport { ErrorCallback, StatusCode, StatusCodes } from \"node-opcua-status-code\";\n\nimport { MDNSResponder } from \"./mdns_responder\";\n\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\n\nfunction hasCapabilities(serverCapabilities: UAString[] | null, serverCapabilityFilter: string): boolean {\n    if (serverCapabilities == null) {\n        return true; // filter is empty => no filtering should take place\n    }\n    if (serverCapabilityFilter.length === 0) {\n        return true; // filter is empty => no filtering should take place\n    }\n    return !!serverCapabilities.join(\" \").match(serverCapabilityFilter);\n}\n\nexport interface OPCUADiscoveryServerOptions extends OPCUABaseServerOptions {\n    certificateFile?: string;\n    port?: number;\n}\n\ninterface RegisteredServerExtended extends RegisteredServer {\n    bonjourHolder: BonjourHolder;\n    serverInfo: ApplicationDescriptionOptions;\n    discoveryConfiguration?: MdnsDiscoveryConfiguration[];\n}\n\ninterface RegisterServerMap {\n    [key: string]: RegisteredServerExtended;\n}\n\nconst defaultProductUri = \"NodeOPCUA-LocalDiscoveryServer\";\nconst defaultApplicationUri = makeApplicationUrn(os.hostname(), defaultProductUri);\n\nfunction getDefaultCertificateManager(): OPCUACertificateManager {\n    const config = envPaths(defaultProductUri).config;\n    return new OPCUACertificateManager({\n        name: \"PKI\",\n        rootFolder: path.join(config, \"PKI\"),\n\n        automaticallyAcceptUnknownCertificate: true\n    });\n}\n\nexport class OPCUADiscoveryServer extends OPCUABaseServer {\n    private mDnsResponder?: MDNSResponder;\n    private readonly registeredServers: RegisterServerMap;\n    private bonjourHolder: BonjourHolder;\n    private _delayInit?: () => void;\n\n    constructor(options: OPCUADiscoveryServerOptions) {\n        options.serverInfo = options.serverInfo || {};\n        const serverInfo = options.serverInfo;\n\n        serverInfo.applicationType = ApplicationType.DiscoveryServer;\n\n        serverInfo.applicationUri = serverInfo.applicationUri || defaultApplicationUri;\n\n        serverInfo.productUri = serverInfo.productUri || defaultProductUri;\n\n        serverInfo.applicationName = serverInfo.applicationName || {\n            text: defaultProductUri,\n\n            locale: null\n        };\n\n        serverInfo.gatewayServerUri = serverInfo.gatewayServerUri || \"\";\n        serverInfo.discoveryProfileUri = serverInfo.discoveryProfileUri || \"\";\n        serverInfo.discoveryUrls = serverInfo.discoveryUrls || [];\n\n        options.serverCertificateManager = options.serverCertificateManager || getDefaultCertificateManager();\n\n        super(options);\n\n        this.bonjourHolder = new BonjourHolder();\n\n        // see OPC UA Spec 1.2 part 6 : 7.4 Well Known Addresses\n        // opc.tcp://localhost:4840/UADiscovery\n        const port = options.port || 4840;\n\n        this.capabilitiesForMDNS = [\"LDS\"];\n        this.registeredServers = {};\n\n        this.mDnsResponder = undefined;\n\n        this._delayInit = async (): Promise<void> => {\n            const endPoint = new OPCUAServerEndPoint({\n                port,\n\n                certificateChain: this.getCertificateChain(),\n\n                certificateManager: this.serverCertificateManager,\n\n                privateKey: this.getPrivateKey(),\n                serverInfo: this.serverInfo\n            });\n            endPoint.addStandardEndpointDescriptions();\n\n            this.endpoints.push(endPoint);\n\n            endPoint.on(\"message\", (message: Message, channel: ServerSecureChannelLayer) => {\n                this.on_request(message, channel);\n            });\n        };\n    }\n\n    public async start(): Promise<void>;\n    public start(callback: ErrorCallback): void;\n    public start(callback?: ErrorCallback): any {\n        assert(!this.mDnsResponder);\n        assert(Array.isArray(this.capabilitiesForMDNS));\n\n        this._preInitTask.push(async () => {\n            await this._delayInit!();\n        });\n\n        super.start((err?: Error | null) => {\n            if (err) {\n                return callback!(err);\n            }\n            this.mDnsResponder = new MDNSResponder();\n            // declare discovery server in bonjour\n            this.bonjourHolder.announcedOnMulticastSubnetWithCallback(\n                {\n                    capabilities: this.capabilitiesForMDNS,\n                    name: this.serverInfo.applicationUri!,\n                    path: \"/DiscoveryServer\",\n                    port: this.endpoints[0].port\n                },\n                (err2: Error | null) => {\n                    callback!(err2!);\n                }\n            );\n        });\n    }\n\n    public async shutdown(): Promise<void>;\n    public shutdown(callback: ErrorCallback): void;\n    public shutdown(callback?: ErrorCallback): any {\n        debugLog(\"stopping announcement of LDS on mDNS\");\n\n        if (this.mDnsResponder) {\n            this.mDnsResponder.dispose();\n            this.mDnsResponder = undefined;\n        }\n\n        this.bonjourHolder.stopAnnouncedOnMulticastSubnetWithCallback((err?: Error | null) => {\n            if (err) {\n                console.log(\"Error \", err.message);\n            }\n\n            debugLog(\"stopping announcement of LDS on mDNS - DONE\");\n            debugLog(\"Shutting down Discovery Server\");\n\n            super.shutdown(() => {\n                setTimeout(()=>{\n                    callback!();\n                },100);\n            });\n        });\n    }\n\n    /**\n     * returns the number of registered servers\n     */\n    public get registeredServerCount(): number {\n        return Object.keys(this.registeredServers).length;\n    }\n\n    public getServers(channel: ServerSecureChannelLayer): ApplicationDescription[] {\n        this.serverInfo.discoveryUrls = this.getDiscoveryUrls();\n\n        const servers: ApplicationDescription[] = [this.serverInfo];\n\n        for (const registered_server of Object.values(this.registeredServers)) {\n            const serverInfo: ApplicationDescription = new ApplicationDescription(registered_server.serverInfo);\n            servers.push(serverInfo);\n        }\n\n        return servers;\n    }\n\n    protected _on_RegisterServer2Request(message: Message, channel: ServerSecureChannelLayer) {\n        assert(message.request instanceof RegisterServer2Request);\n        const request = message.request as RegisterServer2Request;\n\n        assert(request.schema.name === \"RegisterServer2Request\");\n\n        request.discoveryConfiguration = request.discoveryConfiguration || [];\n        this.__internalRegisterServerWithCallback(\n            RegisterServer2Response,\n            request.server,\n            request.discoveryConfiguration as MdnsDiscoveryConfiguration[],\n            (err: Error | null, response?: Response) => {\n                // istanbul ignore next\n                if (err) {\n                    // tslint:disable-next-line: no-console\n                    console.log(\"What shall I do ?\", err.message);\n                    // tslint:disable-next-line: no-console\n                    console.log(err);\n                    let additional_messages = [];\n                    additional_messages.push(\"EXCEPTION CAUGHT WHILE PROCESSING REQUEST !!! \" + request.schema.name);\n                    additional_messages.push(err.message);\n                    if (err.stack) {\n                        additional_messages = additional_messages.concat(err.stack.split(\"\\n\"));\n                    }\n\n                    response = OPCUADiscoveryServer.makeServiceFault(StatusCodes.BadInternalError, additional_messages);\n                    channel.send_response(\"MSG\", response, message);\n                } else {\n                    channel.send_response(\"MSG\", response!, message);\n                }\n            }\n        );\n    }\n\n    protected _on_RegisterServerRequest(message: Message, channel: ServerSecureChannelLayer) {\n        assert(message.request instanceof RegisterServerRequest);\n        const request = message.request as RegisterServerRequest;\n        assert(request.schema.name === \"RegisterServerRequest\");\n        this.__internalRegisterServerWithCallback(\n            RegisterServerResponse,\n            request.server,\n            undefined,\n            (err: Error | null, response?: Response) => {\n                channel.send_response(\"MSG\", response!, message);\n            }\n        );\n    }\n\n    protected _on_FindServersOnNetworkRequest(message: Message, channel: ServerSecureChannelLayer) {\n        // from OPCUA 1.04 part 4\n        // This Service returns the Servers known to a Discovery Server. Unlike FindServer, this Service is\n        // only implemented by Discovery Servers.\n        // The Client may reduce the number of results returned by specifying filter criteria. An empty list is\n        // returned if no Server matches the criteria specified by the Client.\n        // This Service shall not require message security but it may require transport layer security.\n        // Each time the Discovery Server creates or updates a record in its cache it shall assign a\n        // monotonically increasing identifier to the record. This allows Clients to request records in batches\n        // by specifying the identifier for the last record received in the last call to FindServersOnNetwork.\n        // To support this the Discovery Server shall return records in numerical order starting from the\n        // lowest record identifier. The Discovery Server shall also return the last time the counter was reset\n        // for example due to a restart of the Discovery Server. If a Client detects that this time is more\n        // recent than the last time the Client called the Service it shall call the Service again with a\n        // startingRecordId of 0.\n        // This Service can be used without security and it is therefore vulnerable to Denial Of Service\n        // (DOS) attacks. A Server should minimize the amount of processing required to send the response\n        // for this Service. This can be achieved by preparing the result in advance\n\n        assert(message.request instanceof FindServersOnNetworkRequest);\n        const request = message.request as FindServersOnNetworkRequest;\n\n        assert(request.schema.name === \"FindServersOnNetworkRequest\");\n\n        function sendError(statusCode: StatusCode) {\n            const response1 = new FindServersOnNetworkResponse({ responseHeader: { serviceResult: statusCode } });\n            return channel.send_response(\"MSG\", response1, message);\n        }\n\n        //     startingRecordId         Counter Only records with an identifier greater than this number will be\n        //                              returned.\n        //                              Specify 0 to start with the first record in the cache.\n        //     maxRecordsToReturn       UInt32 The maximum number of records to return in the response.\n        //                              0 indicates that there is no limit.\n        //     serverCapabilityFilter[] String List of Server capability filters. The set of allowed server capabilities\n        //                              are defined in Part 12.\n        //                              Only records with all of the specified server capabilities are\n        //                              returned.\n        //                              The comparison is case insensitive.\n        //                              If this list is empty then no filtering is performed\n\n        // ------------------------\n\n        // The last time the counters were reset.\n        const lastCounterResetTime = new Date();\n\n        //  servers[] ServerOnNetwork List of DNS service records that meet criteria specified in the\n        // request. This list is empty if no Servers meet the criteria\n        const servers = [];\n\n        request.serverCapabilityFilter = request.serverCapabilityFilter || [];\n        const serverCapabilityFilter: string = request.serverCapabilityFilter\n            .map((x: UAString) => x!.toUpperCase())\n            .sort()\n            .join(\" \");\n\n        debugLog(\" startingRecordId = \", request.startingRecordId);\n\n        if (this.mDnsResponder) {\n            for (const server of this.mDnsResponder.registeredServers) {\n                debugLog(\"Exploring server \", server.serverName);\n\n                if (server.recordId <= request.startingRecordId) {\n                    continue;\n                }\n                if (!hasCapabilities(server.serverCapabilities, serverCapabilityFilter)) {\n                    // istanbul ignore next\n                    if (doDebug) {\n                        debugLog(\n                            \"   server \",\n                            server.serverName,\n                            server.serverCapabilities ? server.serverCapabilities.join(\",\") : [],\n                            \" does not match serverCapabilities \",\n                            serverCapabilityFilter\n                        );\n                    }\n                    continue;\n                }\n                debugLog(\"   server \", server.serverName, \" found\");\n                servers.push(server);\n                if (servers.length === request.maxRecordsToReturn) {\n                    debugLog(\"max records to return reached\", request.maxRecordsToReturn);\n                    break;\n                }\n            }\n        }\n        const response = new FindServersOnNetworkResponse({\n            lastCounterResetTime, //  UtcTime The last time the counters were reset\n            servers\n        });\n        channel.send_response(\"MSG\", response, message);\n    }\n\n    protected async __internalRegisterServerWithCallback(\n        RegisterServerXResponse: any /* RegisterServer2Response | RegisterServerResponse */,\n        rawServer: RegisteredServer,\n        discoveryConfigurations: MdnsDiscoveryConfiguration[] | undefined,\n        callback: (err: Error | null, response?: Response) => void\n    ) {\n        // istanbul ignore next\n        callback(new Error(\"internal Error\"));\n    }\n\n    // eslint-disable-next-line max-statements\n    protected async __internalRegisterServer(\n        RegisterServerXResponse: any /* RegisterServer2Response | RegisterServerResponse */,\n        rawServer: RegisteredServer,\n        discoveryConfigurations?: MdnsDiscoveryConfiguration[]\n    ): Promise<Response> {\n        const server = rawServer as any as RegisteredServerExtended;\n\n        if (!discoveryConfigurations) {\n            discoveryConfigurations = [\n                new MdnsDiscoveryConfiguration({\n                    mdnsServerName: undefined,\n                    serverCapabilities: [\"NA\"]\n                })\n            ];\n        }\n\n        function sendError(statusCode: StatusCode): Response {\n            debugLog(chalk.red(\"_on_RegisterServer(2)Request error\"), statusCode.toString());\n            const response1 = new ServiceFault({\n                responseHeader: { serviceResult: statusCode }\n            });\n            return response1;\n        }\n\n        async function _stop_announcedOnMulticastSubnet(conf: MdnsDiscoveryConfiguration): Promise<void> {\n            const b = (conf as any).bonjourHolder as BonjourHolder;\n            await b.stopAnnnouncedOnMulticastSubnet();\n            (conf as any).bonjourHolder = undefined;\n        }\n\n        async function _announcedOnMulticastSubnet(conf: MdnsDiscoveryConfiguration, announcement: Announcement): Promise<void> {\n            const serviceConfig = announcementToServiceConfig(announcement);\n\n            let b = (conf as any).bonjourHolder as BonjourHolder;\n            if (b && b.serviceConfig) {\n                if (sameService(b.serviceConfig, serviceConfig)) {\n                    debugLog(\"Configuration \", conf.mdnsServerName, \" has not changed !\");\n                    // nothing to do\n                    return;\n                } else {\n                    // istanbul ignore next\n                    if (doDebug) {\n                        debugLog(\"Configuration \", conf.mdnsServerName, \" HAS changed !\");\n                        debugLog(\" Was \", serviceToString(b.serviceConfig));\n                        debugLog(\" is  \", announcement);\n                    }\n                }\n                await _stop_announcedOnMulticastSubnet(conf);\n            }\n            b = new BonjourHolder();\n            (conf as any).bonjourHolder = b;\n            await b.announcedOnMulticastSubnet(announcement);\n        }\n\n        async function dealWithDiscoveryConfiguration(\n            previousConfMap: any,\n            server1: RegisteredServer,\n            serverInfo: ApplicationDescriptionOptions,\n            discoveryConfiguration: MdnsDiscoveryConfiguration\n        ): Promise<StatusCode> {\n            // mdnsServerName     String     The name of the Server when it is announced via mDNS.\n            //                               See Part 12 for the details about mDNS. This string shall be less than 64 bytes.\n            //                               If not specified the first element of the serverNames array is used\n            //                               (truncated to 63 bytes if necessary).\n            // serverCapabilities [] String  The set of Server capabilities supported by the Server.\n            //                               A Server capability is a short identifier for a feature\n            //                               The set of allowed Server capabilities are defined in Part 12.\n            discoveryConfiguration.mdnsServerName = discoveryConfiguration.mdnsServerName || server1.serverNames![0].text;\n\n            serverInfo.discoveryUrls = serverInfo.discoveryUrls || [];\n\n            const endpointUrl = serverInfo.discoveryUrls[0]!;\n            const parsedUrl = url.parse(endpointUrl);\n\n            discoveryConfiguration.serverCapabilities = discoveryConfiguration.serverCapabilities || [];\n            const announcement = {\n                capabilities: discoveryConfiguration.serverCapabilities.map((x: UAString) => x!) || [\"DA\"],\n                name: discoveryConfiguration.mdnsServerName!,\n                path: parsedUrl.pathname || \"/\",\n                port: parseInt(parsedUrl.port!, 10)\n            };\n\n            if (previousConfMap[discoveryConfiguration.mdnsServerName!]) {\n                // configuration already exists\n                debugLog(\"Configuration \", discoveryConfiguration.mdnsServerName, \" already exists !\");\n                const prevConf = previousConfMap[discoveryConfiguration.mdnsServerName!];\n                delete previousConfMap[discoveryConfiguration.mdnsServerName!];\n                (discoveryConfiguration as any).bonjourHolder = prevConf.bonjourHolder;\n            }\n\n            // let's announce the server on the  multicast DNS\n            await _announcedOnMulticastSubnet(discoveryConfiguration, announcement);\n            return StatusCodes.Good;\n        }\n\n        // check serverType is valid\n        if (!_isValidServerType(server.serverType)) {\n            debugLog(\"Invalid server Type\", ApplicationType[server.serverType]);\n            return sendError(StatusCodes.BadInvalidArgument);\n        }\n\n        if (!server.serverUri) {\n            debugLog(\"Missing serverURI\");\n            return sendError(StatusCodes.BadInvalidArgument);\n        }\n\n        // BadServerUriInvalid\n        // TODO\n        server.serverNames = server.serverNames || [];\n        // BadServerNameMissing\n        if (server.serverNames.length === 0 || !server.serverNames[0].text) {\n            return sendError(StatusCodes.BadServerNameMissing);\n        }\n\n        // BadDiscoveryUrlMissing\n        server.discoveryUrls = server.discoveryUrls || [];\n        if (server.discoveryUrls.length === 0 || !server.discoveryUrls[0]) {\n            return sendError(StatusCodes.BadDiscoveryUrlMissing);\n        }\n\n        const key = server.serverUri;\n        let configurationResults: StatusCode[] | null = null;\n\n        if (server.isOnline) {\n            debugLog(chalk.cyan(\" registering server : \"), chalk.yellow(server.serverUri));\n\n            // prepare serverInfo which will be used by FindServers\n            const serverInfo: ApplicationDescriptionOptions = {\n                applicationName: server.serverNames[0], // which one shall we use ?\n                applicationType: server.serverType,\n                applicationUri: server.serverUri,\n                discoveryUrls: server.discoveryUrls,\n                gatewayServerUri: server.gatewayServerUri,\n                productUri: server.productUri\n                // XXX ?????? serverInfo.discoveryProfileUri = serverInfo.discoveryProfileUri;\n            };\n\n            const previousConfMap: any = [];\n            if (this.registeredServers[key]) {\n                // server already exists and must only be updated\n                const previousServer = this.registeredServers[key];\n\n                for (const conf of previousServer.discoveryConfiguration!) {\n                    previousConfMap[conf.mdnsServerName!] = conf;\n                }\n            }\n            this.registeredServers[key] = server;\n\n            // xx server.semaphoreFilePath = server.semaphoreFilePath;\n            // xx server.serverNames = server.serverNames;\n            server.serverInfo = serverInfo;\n            server.discoveryConfiguration = discoveryConfigurations;\n\n            assert(discoveryConfigurations);\n\n            configurationResults = [];\n            for (const conf of discoveryConfigurations) {\n                const statusCode = await dealWithDiscoveryConfiguration(previousConfMap, server, serverInfo, conf);\n                configurationResults.push(statusCode);\n            }\n            // now also unregister unprocessed\n            if (Object.keys(previousConfMap).length !== 0) {\n                debugLog(\" Warning some conf need to be removed !\");\n            }\n        } else {\n            // server is announced offline\n            if (key in this.registeredServers) {\n                const server1 = this.registeredServers[key];\n                debugLog(chalk.cyan(\"unregistering server : \"), chalk.yellow(server1.serverUri!));\n                configurationResults = [];\n\n                discoveryConfigurations = server1.discoveryConfiguration || [];\n\n                for (const conf of discoveryConfigurations) {\n                    await _stop_announcedOnMulticastSubnet(conf);\n                    configurationResults.push(StatusCodes.Good);\n                }\n                delete this.registeredServers[key];\n            }\n        }\n\n        const response = new RegisterServerXResponse({\n            configurationResults\n        });\n        return response;\n    }\n}\n\n/*== private\n * returns true if the serverType can be added to a discovery server.\n * @param serverType\n * @return {boolean}\n * @private\n */\nfunction _isValidServerType(serverType: ApplicationType): boolean {\n    switch (serverType) {\n        case ApplicationType.Client:\n            return false;\n        case ApplicationType.Server:\n        case ApplicationType.ClientAndServer:\n        case ApplicationType.DiscoveryServer:\n            return true;\n    }\n    return false;\n}\n\n(OPCUADiscoveryServer as any).prototype.__internalRegisterServerWithCallback = callbackify(\n    (OPCUADiscoveryServer as any).prototype.__internalRegisterServer\n);\n\n// tslint:disable-next-line: no-var-requires\nconst thenify = require(\"thenify\");\nconst opts = { multiArgs: false };\nOPCUADiscoveryServer.prototype.start = thenify.withCallback(OPCUADiscoveryServer.prototype.start, opts);\nOPCUADiscoveryServer.prototype.shutdown = thenify.withCallback(OPCUADiscoveryServer.prototype.shutdown, opts);\n", "/**\n * @module node-opcua-server\n */\n// tslint:disable:no-console\n// tslint:disable:max-line-length\n// tslint:disable:unified-signatures\n\nimport * as crypto from \"crypto\";\nimport { EventEmitter } from \"events\";\nimport { callbackify } from \"util\";\n\nimport * as async from \"async\";\nimport * as chalk from \"chalk\";\n\nimport { extractFullyQualifiedDomainName, getFullyQualifiedDomainName } from \"node-opcua-hostname\";\n\nimport { assert } from \"node-opcua-assert\";\nimport * as utils from \"node-opcua-utils\";\n\nimport {\n    AddressSpace,\n    callMethodHelper,\n    ContinuationPoint,\n    IUserManager,\n    PseudoVariantBoolean,\n    PseudoVariantByteString,\n    PseudoVariantDateTime,\n    PseudoVariantDuration,\n    PseudoVariantExtensionObject,\n    PseudoVariantExtensionObjectArray,\n    PseudoVariantLocalizedText,\n    PseudoVariantNodeId,\n    PseudoVariantString,\n    RaiseEventData,\n    SessionContext,\n    UAObject,\n    UAVariable,\n    ISessionContext,\n    UAView,\n    EventTypeLike,\n    UAObjectType\n} from \"node-opcua-address-space\";\nimport { getDefaultCertificateManager, OPCUACertificateManager } from \"node-opcua-certificate-manager\";\nimport { ServerState } from \"node-opcua-common\";\nimport { Certificate, exploreCertificate, Nonce } from \"node-opcua-crypto\";\nimport {\n    AttributeIds,\n    filterDiagnosticOperationLevel,\n    filterDiagnosticServiceLevel,\n    NodeClass,\n    RESPONSE_DIAGNOSTICS_MASK_ALL\n} from \"node-opcua-data-model\";\nimport { DataValue } from \"node-opcua-data-value\";\nimport { dump, make_debugLog, make_errorLog, make_warningLog } from \"node-opcua-debug\";\nimport { NodeId } from \"node-opcua-nodeid\";\nimport { ObjectRegistry } from \"node-opcua-object-registry\";\nimport {\n    AsymmetricAlgorithmSecurityHeader,\n    computeSignature,\n    fromURI,\n    getCryptoFactory,\n    Message,\n    MessageSecurityMode,\n    nonceAlreadyBeenUsed,\n    Request,\n    Response,\n    SecurityPolicy,\n    ServerSecureChannelLayer,\n    SignatureData,\n    verifySignature\n} from \"node-opcua-secure-channel\";\nimport { BrowseNextRequest, BrowseNextResponse, BrowseRequest, BrowseResponse } from \"node-opcua-service-browse\";\nimport { CallRequest, CallResponse } from \"node-opcua-service-call\";\nimport { ApplicationType, UserTokenType } from \"node-opcua-service-endpoints\";\nimport { HistoryReadRequest, HistoryReadResponse, HistoryReadResult, HistoryUpdateResponse } from \"node-opcua-service-history\";\nimport {\n    AddNodesResponse,\n    AddReferencesResponse,\n    DeleteNodesResponse,\n    DeleteReferencesResponse\n} from \"node-opcua-service-node-management\";\nimport { QueryFirstResponse, QueryNextResponse } from \"node-opcua-service-query\";\nimport { ReadRequest, ReadResponse, ReadValueId, TimestampsToReturn } from \"node-opcua-service-read\";\nimport {\n    RegisterNodesRequest,\n    RegisterNodesResponse,\n    UnregisterNodesRequest,\n    UnregisterNodesResponse\n} from \"node-opcua-service-register-node\";\nimport {\n    ActivateSessionRequest,\n    ActivateSessionResponse,\n    AnonymousIdentityToken,\n    CloseSessionRequest,\n    CloseSessionResponse,\n    CreateSessionRequest,\n    CreateSessionResponse,\n    UserNameIdentityToken,\n    X509IdentityToken\n} from \"node-opcua-service-session\";\nimport {\n    CreateMonitoredItemsRequest,\n    CreateMonitoredItemsResponse,\n    CreateSubscriptionRequest,\n    CreateSubscriptionResponse,\n    DeleteMonitoredItemsRequest,\n    DeleteMonitoredItemsResponse,\n    DeleteSubscriptionsRequest,\n    DeleteSubscriptionsResponse,\n    ModifyMonitoredItemsRequest,\n    ModifyMonitoredItemsResponse,\n    ModifySubscriptionRequest,\n    ModifySubscriptionResponse,\n    MonitoredItemModifyResult,\n    PublishRequest,\n    PublishResponse,\n    RepublishRequest,\n    RepublishResponse,\n    SetMonitoringModeRequest,\n    SetMonitoringModeResponse,\n    SetPublishingModeRequest,\n    SetPublishingModeResponse,\n    SetTriggeringRequest,\n    SetTriggeringResponse,\n    TransferSubscriptionsRequest,\n    TransferSubscriptionsResponse\n} from \"node-opcua-service-subscription\";\nimport {\n    TranslateBrowsePathsToNodeIdsRequest,\n    TranslateBrowsePathsToNodeIdsResponse\n} from \"node-opcua-service-translate-browse-path\";\nimport { WriteRequest, WriteResponse } from \"node-opcua-service-write\";\nimport { ErrorCallback, StatusCode, StatusCodes } from \"node-opcua-status-code\";\nimport {\n    ApplicationDescriptionOptions,\n    BrowseResult,\n    BuildInfo,\n    CallMethodResultOptions,\n    CancelResponse,\n    EndpointDescription,\n    MonitoredItemModifyRequest,\n    MonitoringMode,\n    UserIdentityToken,\n    UserTokenPolicy,\n    BuildInfoOptions,\n    MonitoredItemCreateResult,\n    IssuedIdentityToken,\n    BrowseResultOptions,\n    ServiceFault\n} from \"node-opcua-types\";\nimport { DataType } from \"node-opcua-variant\";\nimport { VariantArrayType } from \"node-opcua-variant\";\nimport { matchUri } from \"node-opcua-utils\";\n\nimport { UAString } from \"node-opcua-basic-types\";\nimport { OPCUABaseServer, OPCUABaseServerOptions } from \"./base_server\";\nimport { Factory } from \"./factory\";\nimport { IRegisterServerManager } from \"./i_register_server_manager\";\nimport { MonitoredItem } from \"./monitored_item\";\nimport { RegisterServerManager } from \"./register_server_manager\";\nimport { RegisterServerManagerHidden } from \"./register_server_manager_hidden\";\nimport { RegisterServerManagerMDNSONLY } from \"./register_server_manager_mdns_only\";\nimport { ServerCapabilitiesOptions } from \"./server_capabilities\";\nimport { OPCUAServerEndPoint } from \"./server_end_point\";\nimport { ClosingReason, CreateSessionOption, ServerEngine } from \"./server_engine\";\nimport { ServerSession } from \"./server_session\";\nimport { CreateMonitoredItemHook, DeleteMonitoredItemHook, Subscription } from \"./server_subscription\";\nimport { ISocketData } from \"./i_socket_data\";\nimport { IChannelData } from \"./i_channel_data\";\nimport { UAUserManagerBase, makeUserManager, UserManagerOptions } from \"./user_manager\";\nimport { bindRoleSet } from \"./user_manager_ua\";\n\nfunction isSubscriptionIdInvalid(subscriptionId: number): boolean {\n    return subscriptionId < 0 || subscriptionId >= 0xffffffff;\n}\n\n// tslint:disable-next-line:no-var-requires\nconst thenify = require(\"thenify\");\n// tslint:disable-next-line:no-var-requires\nconst package_info = require(\"../package.json\");\nconst debugLog = make_debugLog(__filename);\nconst errorLog = make_errorLog(__filename);\nconst warningLog = make_warningLog(__filename);\n\nconst default_maxConnectionsPerEndpoint = 10;\n\nfunction g_sendError(channel: ServerSecureChannelLayer, message: Message, ResponseClass: any, statusCode: StatusCode): void {\n    const response = new ServiceFault({\n        responseHeader: { serviceResult: statusCode }\n    });\n    return channel.send_response(\"MSG\", response, message);\n}\n\nconst default_build_info: BuildInfoOptions = {\n    manufacturerName: \"NodeOPCUA : MIT Licence ( see http://node-opcua.github.io/)\",\n    productName: \"NodeOPCUA-Server\",\n    productUri: null, // << should be same as default_server_info.productUri?\n    softwareVersion: package_info.version,\n    buildNumber: \"0\",\n    buildDate: new Date(2020, 1, 1)\n    // xx buildDate: fs.statSync(package_json_file).mtime\n};\n\nconst minSessionTimeout = 100; // 100 milliseconds\nconst defaultSessionTimeout = 1000 * 30; // 30 seconds\nconst maxSessionTimeout = 1000 * 60 * 50; // 50 minutes\nlet unnamed_session_count = 0;\n\ntype ResponseClassType =\n    | typeof BrowseResponse\n    | typeof BrowseNextResponse\n    | typeof CallResponse\n    | typeof CreateMonitoredItemsResponse\n    | typeof CreateSubscriptionResponse\n    | typeof DeleteSubscriptionsResponse\n    | typeof HistoryReadResponse\n    | typeof ModifyMonitoredItemsResponse\n    | typeof ModifySubscriptionResponse\n    | typeof ReadResponse\n    | typeof RegisterNodesResponse\n    | typeof RepublishResponse\n    | typeof SetPublishingModeResponse\n    | typeof SetTriggeringResponse\n    | typeof TransferSubscriptionsResponse\n    | typeof TranslateBrowsePathsToNodeIdsResponse\n    | typeof UnregisterNodesResponse\n    | typeof WriteResponse;\n\nfunction _adjust_session_timeout(sessionTimeout: number) {\n    let revisedSessionTimeout = sessionTimeout || defaultSessionTimeout;\n    revisedSessionTimeout = Math.min(revisedSessionTimeout, maxSessionTimeout);\n    revisedSessionTimeout = Math.max(revisedSessionTimeout, minSessionTimeout);\n    return revisedSessionTimeout;\n}\n\nfunction channel_has_session(channel: ServerSecureChannelLayer, session: ServerSession): boolean {\n    if (session.channel === channel) {\n        assert(Object.prototype.hasOwnProperty.call(channel.sessionTokens, session.authenticationToken.toString()));\n        return true;\n    }\n    return false;\n}\n\nfunction moveSessionToChannel(session: ServerSession, channel: ServerSecureChannelLayer) {\n    debugLog(\"moveSessionToChannel sessionId\", session.nodeId, \" channelId=\", channel.channelId);\n    if (session.publishEngine) {\n        session.publishEngine.cancelPendingPublishRequestBeforeChannelChange();\n    }\n\n    session._detach_channel();\n    session._attach_channel(channel);\n\n    assert(session.channel!.channelId === channel.channelId);\n}\n\nasync function _attempt_to_close_some_old_unactivated_session(server: OPCUAServer) {\n    const session = server.engine!.getOldestInactiveSession();\n    if (session) {\n        await server.engine!.closeSession(session.authenticationToken, false, \"Forcing\");\n    }\n}\n\nfunction getRequiredEndpointInfo(endpoint: EndpointDescription) {\n    assert(endpoint instanceof EndpointDescription);\n    // It is recommended that Servers only include the server.applicationUri,  endpointUrl, securityMode,\n    // securityPolicyUri, userIdentityTokens, transportProfileUri and securityLevel with all\n    // other parameters set to null. Only the recommended parameters shall be verified by\n    // the client.\n\n    const e = new EndpointDescription({\n        endpointUrl: endpoint.endpointUrl,\n        securityLevel: endpoint.securityLevel,\n        securityMode: endpoint.securityMode,\n        securityPolicyUri: endpoint.securityPolicyUri,\n        server: {\n            applicationUri: endpoint.server.applicationUri,\n            applicationType: endpoint.server.applicationType,\n            applicationName: endpoint.server.applicationName\n            // ... to be continued after verifying what fields are actually needed\n        },\n        transportProfileUri: endpoint.transportProfileUri,\n        userIdentityTokens: endpoint.userIdentityTokens\n    });\n    // reduce even further by explicitly setting unwanted members to null\n    e.server.productUri = null;\n    e.server.applicationName = null as any;\n    // xx e.server.applicationType = null as any;\n    e.server.gatewayServerUri = null;\n    e.server.discoveryProfileUri = null;\n    e.server.discoveryUrls = null;\n    e.serverCertificate = null as any;\n    return e;\n}\n\n// serverUri  String This value is only specified if the EndpointDescription has a gatewayServerUri.\n//            This value is the applicationUri from the EndpointDescription which is the applicationUri for the\n//            underlying Server. The type EndpointDescription is defined in 7.10.\n\nfunction _serverEndpointsForCreateSessionResponse(server: OPCUAServer, endpointUrl: string | null, serverUri: string | null) {\n    serverUri = null; // unused then\n\n    // The Server shall return a set of EndpointDescriptions available for the serverUri specified in the request.\n    // It is recommended that Servers only include the endpointUrl, securityMode,\n    // securityPolicyUri, userIdentityTokens, transportProfileUri and securityLevel with all other parameters\n    // set to null. Only the recommended parameters shall be verified by the client.\n    return server\n        ._get_endpoints(endpointUrl)\n        .filter((e) => !(e as any).restricted) // remove restricted endpoints\n        .filter((e) => matchUri(e.endpointUrl, endpointUrl))\n        .map(getRequiredEndpointInfo);\n}\n\nfunction adjustSecurityPolicy(channel: ServerSecureChannelLayer, userTokenPolicy_securityPolicyUri: UAString): SecurityPolicy {\n    // check that userIdentityToken\n    let securityPolicy = fromURI(userTokenPolicy_securityPolicyUri);\n\n    // if the security policy is not specified we use the session security policy\n    if (securityPolicy === SecurityPolicy.Invalid) {\n        securityPolicy = fromURI((channel.clientSecurityHeader! as AsymmetricAlgorithmSecurityHeader).securityPolicyUri);\n        assert(securityPolicy !== SecurityPolicy.Invalid);\n    }\n    return securityPolicy;\n}\n\nfunction findUserTokenByPolicy(\n    endpoint_description: EndpointDescription,\n    userTokenType: UserTokenType,\n    policyId: SecurityPolicy | string | null\n): UserTokenPolicy | null {\n    assert(endpoint_description instanceof EndpointDescription);\n    const r = endpoint_description.userIdentityTokens!.filter(\n        (userIdentity: UserTokenPolicy) =>\n            userIdentity.tokenType === userTokenType && (!policyId || userIdentity.policyId === policyId)\n    );\n    return r.length === 0 ? null : r[0];\n}\n\nfunction findUserTokenPolicy(endpoint_description: EndpointDescription, userTokenType: UserTokenType): UserTokenPolicy | null {\n    assert(endpoint_description instanceof EndpointDescription);\n    const r = endpoint_description.userIdentityTokens!.filter((userIdentity: UserTokenPolicy) => {\n        assert(userIdentity.tokenType !== undefined);\n        return userIdentity.tokenType === userTokenType;\n    });\n    return r.length === 0 ? null : r[0];\n}\n\nfunction createAnonymousIdentityToken(endpoint_desc: EndpointDescription) {\n    assert(endpoint_desc instanceof EndpointDescription);\n    const userTokenPolicy = findUserTokenPolicy(endpoint_desc, UserTokenType.Anonymous);\n    if (!userTokenPolicy) {\n        throw new Error(\"Cannot find ANONYMOUS user token policy in end point description\");\n    }\n    return new AnonymousIdentityToken({ policyId: userTokenPolicy.policyId });\n}\n\nfunction sameIdentityToken(token1: UserIdentityToken, token2: UserIdentityToken): boolean {\n    if (token1 instanceof UserNameIdentityToken) {\n        if (!(token2 instanceof UserNameIdentityToken)) {\n            return false;\n        }\n        if (token1.userName !== token2.userName) {\n            return false;\n        }\n        if (token1.password.toString(\"hex\") !== token2.password.toString(\"hex\")) {\n            return false;\n        }\n    } else if (token1 instanceof AnonymousIdentityToken) {\n        if (!(token2 instanceof AnonymousIdentityToken)) {\n            return false;\n        }\n        if (token1.policyId !== token2.policyId) {\n            return false;\n        }\n        return true;\n    }\n    assert(false, \" Not implemented yet\");\n    return false;\n}\nfunction getTokenType(userIdentityToken: UserIdentityToken): UserTokenType {\n    if (userIdentityToken instanceof AnonymousIdentityToken) {\n        return UserTokenType.Anonymous;\n    } else if (userIdentityToken instanceof UserNameIdentityToken) {\n        return UserTokenType.UserName;\n    } else if (userIdentityToken instanceof IssuedIdentityToken) {\n        return UserTokenType.IssuedToken;\n    } else if (userIdentityToken instanceof X509IdentityToken) {\n        return UserTokenType.Certificate;\n    }\n    return UserTokenType.Invalid;\n}\nfunction thumbprint(certificate?: Certificate): string {\n    return certificate ? certificate.toString(\"base64\") : \"\";\n}\n\n/*=== private\n *\n * perform the read operation on a given node for a monitored item.\n * this method DOES NOT apply to Variable Values attribute\n *\n * @param self\n * @param oldValue\n * @param node\n * @param itemToMonitor\n * @private\n */\nfunction monitoredItem_read_and_record_value(\n    self: MonitoredItem,\n    context: ISessionContext | null,\n    oldValue: DataValue,\n    node: UAVariable,\n    itemToMonitor: any,\n    callback: (err: Error | null, dataValue?: DataValue) => void\n) {\n    assert(self instanceof MonitoredItem);\n    assert(oldValue instanceof DataValue);\n    assert(itemToMonitor.attributeId === AttributeIds.Value);\n\n    const dataValue = node.readAttribute(context, itemToMonitor.attributeId, itemToMonitor.indexRange, itemToMonitor.dataEncoding);\n\n    callback(null, dataValue);\n}\n\n/*== private\n * @method monitoredItem_read_and_record_value_async\n * this method applies to Variable Values attribute\n * @param self\n * @param oldValue\n * @param node\n * @param itemToMonitor\n * @private\n */\nfunction monitoredItem_read_and_record_value_async(\n    self: MonitoredItem,\n    context: ISessionContext,\n    oldValue: DataValue,\n    node: UAVariable,\n    itemToMonitor: any,\n    callback: (err: Error | null, dataValue?: DataValue) => void\n) {\n    assert(context instanceof SessionContext);\n    assert(itemToMonitor.attributeId === AttributeIds.Value);\n    assert(self instanceof MonitoredItem);\n    assert(oldValue instanceof DataValue);\n    // do it asynchronously ( this is only valid for value attributes )\n    assert(itemToMonitor.attributeId === AttributeIds.Value);\n\n    node.readValueAsync(context, (err: Error | null, dataValue?: DataValue) => {\n        callback(err, dataValue);\n    });\n}\n\nfunction build_scanning_node_function(\n    context: ISessionContext,\n    addressSpace: AddressSpace,\n    monitoredItem: MonitoredItem,\n    itemToMonitor: any\n): (dataValue: DataValue, callback: (err: Error | null, dataValue?: DataValue) => void) => void {\n    assert(context instanceof SessionContext);\n    assert(itemToMonitor instanceof ReadValueId);\n\n    const node = addressSpace.findNode(itemToMonitor.nodeId) as UAVariable;\n\n    /* istanbul ignore next */\n    if (!node) {\n        errorLog(\" INVALID NODE ID  , \", itemToMonitor.nodeId.toString());\n        dump(itemToMonitor);\n        return (oldData: DataValue, callback: (err: Error | null, dataValue?: DataValue) => void) => {\n            callback(\n                null,\n                new DataValue({\n                    statusCode: StatusCodes.BadNodeIdUnknown,\n                    value: { dataType: DataType.Null, value: 0 }\n                })\n            );\n        };\n    }\n\n    ///// !!monitoredItem.setNode(node);\n\n    if (itemToMonitor.attributeId === AttributeIds.Value) {\n        const monitoredItem_read_and_record_value_func =\n            itemToMonitor.attributeId === AttributeIds.Value && typeof node.readValueAsync === \"function\"\n                ? monitoredItem_read_and_record_value_async\n                : monitoredItem_read_and_record_value;\n\n        return function func(\n            this: MonitoredItem,\n            oldDataValue: DataValue,\n            callback: (err: Error | null, dataValue?: DataValue) => void\n        ) {\n            assert(this instanceof MonitoredItem);\n            assert(oldDataValue instanceof DataValue);\n            assert(typeof callback === \"function\");\n            monitoredItem_read_and_record_value_func(this, context, oldDataValue, node, itemToMonitor, callback);\n        };\n    } else {\n        // Attributes, other than the  Value  Attribute, are only monitored for a change in value.\n        // The filter is not used for these  Attributes. Any change in value for these  Attributes\n        // causes a  Notification  to be  generated.\n\n        // only record value when it has changed\n        return function func(\n            this: MonitoredItem,\n            oldDataValue: DataValue,\n            callback: (err: Error | null, dataValue?: DataValue) => void\n        ) {\n            assert(this instanceof MonitoredItem);\n            assert(oldDataValue instanceof DataValue);\n            assert(typeof callback === \"function\");\n            const newDataValue = node.readAttribute(null, itemToMonitor.attributeId);\n            callback(null, newDataValue);\n        };\n    }\n}\n\nfunction prepareMonitoredItem(context: ISessionContext, addressSpace: AddressSpace, monitoredItem: MonitoredItem) {\n    const itemToMonitor = monitoredItem.itemToMonitor;\n    const readNodeFunc = build_scanning_node_function(context, addressSpace, monitoredItem, itemToMonitor);\n    monitoredItem.samplingFunc = readNodeFunc;\n}\n\nfunction isMonitoringModeValid(monitoringMode: MonitoringMode): boolean {\n    assert(MonitoringMode.Invalid !== undefined);\n    return monitoringMode !== MonitoringMode.Invalid && monitoringMode <= MonitoringMode.Reporting;\n}\n\nfunction _installRegisterServerManager(self: OPCUAServer) {\n    assert(self instanceof OPCUAServer);\n    assert(!self.registerServerManager);\n\n    /* istanbul ignore next */\n    if (!self.registerServerMethod) {\n        throw new Error(\"Internal Error\");\n    }\n\n    switch (self.registerServerMethod) {\n        case RegisterServerMethod.HIDDEN:\n            self.registerServerManager = new RegisterServerManagerHidden({\n                server: self\n            });\n            break;\n        case RegisterServerMethod.MDNS:\n            self.registerServerManager = new RegisterServerManagerMDNSONLY({\n                server: self\n            });\n            break;\n        case RegisterServerMethod.LDS:\n            self.registerServerManager = new RegisterServerManager({\n                discoveryServerEndpointUrl: self.discoveryServerEndpointUrl,\n                server: self\n            });\n            break;\n        /* istanbul ignore next */\n        default:\n            throw new Error(\"Invalid switch\");\n    }\n\n    self.registerServerManager.on(\"serverRegistrationPending\", () => {\n        /**\n         * emitted when the server is trying to registered the LDS\n         * but when the connection to the lds has failed\n         * serverRegistrationPending is sent when the backoff signal of the\n         * connection process is raised\n         * @event serverRegistrationPending\n         */\n        debugLog(\"serverRegistrationPending\");\n        self.emit(\"serverRegistrationPending\");\n    });\n    self.registerServerManager.on(\"serverRegistered\", () => {\n        /**\n         * emitted when the server is successfully registered to the LDS\n         * @event serverRegistered\n         */\n        debugLog(\"serverRegistered\");\n        self.emit(\"serverRegistered\");\n    });\n    self.registerServerManager.on(\"serverRegistrationRenewed\", () => {\n        /**\n         * emitted when the server has successfully renewed its registration to the LDS\n         * @event serverRegistrationRenewed\n         */\n        debugLog(\"serverRegistrationRenewed\");\n        self.emit(\"serverRegistrationRenewed\");\n    });\n\n    self.registerServerManager.on(\"serverUnregistered\", () => {\n        debugLog(\"serverUnregistered\");\n        /**\n         * emitted when the server is successfully unregistered to the LDS\n         * ( for instance during shutdown)\n         * @event serverUnregistered\n         */\n        self.emit(\"serverUnregistered\");\n    });\n}\n\nfunction validate_applicationUri(channel: ServerSecureChannelLayer, request: CreateSessionRequest): boolean {\n    const applicationUri = request.clientDescription.applicationUri!;\n    const clientCertificate = request.clientCertificate;\n    // if session is insecure there is no need to check certificate information\n    if (channel.securityMode === MessageSecurityMode.None) {\n        return true; // assume correct\n    }\n    if (!clientCertificate || clientCertificate.length === 0) {\n        return true; // can't check\n    }\n    const e = exploreCertificate(clientCertificate);\n    const uniformResourceIdentifier = e.tbsCertificate.extensions!.subjectAltName?.uniformResourceIdentifier ?? null;\n    const applicationUriFromCert =\n        uniformResourceIdentifier && uniformResourceIdentifier.length > 0 ? uniformResourceIdentifier[0] : null;\n\n    /* istanbul ignore next */\n    if (applicationUriFromCert !== applicationUri) {\n        errorLog(\"BadCertificateUriInvalid!\");\n        errorLog(\"applicationUri           = \", applicationUri);\n        errorLog(\"applicationUriFromCert   = \", applicationUriFromCert);\n    }\n\n    return applicationUriFromCert === applicationUri;\n}\n\nfunction validate_security_endpoint(\n    server: OPCUAServer,\n    request: CreateSessionRequest,\n    channel: ServerSecureChannelLayer\n): {\n    errCode: StatusCode;\n    endpoint?: EndpointDescription;\n} {\n    debugLog(\"validate_security_endpoint = \", request.endpointUrl);\n    let endpoints = server._get_endpoints(request.endpointUrl);\n    // endpointUrl String The network address that the Client used to access the Session Endpoint.\n    //             The HostName portion of the URL should be one of the HostNames for the application that are\n    //             specified in the Server\u2019s ApplicationInstanceCertificate (see 7.2). The Server shall raise an\n    //             AuditUrlMismatchEventType event if the URL does not match the Server\u2019s HostNames.\n    //             AuditUrlMismatchEventType event type is defined in Part 5.\n    //             The Server uses this information for diagnostics and to determine the set of\n    //             EndpointDescriptions to return in the response.\n    // ToDo: check endpointUrl validity and emit an AuditUrlMismatchEventType event if not\n    if (endpoints.length === 0) {\n        // we have a UrlMismatch here\n        const ua_server = server.engine.addressSpace!.rootFolder.objects.server;\n        ua_server.raiseEvent(\"AuditUrlMismatchEventType\", {\n            endpointUrl: { dataType: DataType.String, value: request.endpointUrl }\n        });\n        debugLog(\"Cannot find endpoint  in available endpoints with endpointUri\", request.endpointUrl);\n        if (OPCUAServer.requestExactEndpointUrl) {\n            return { errCode: StatusCodes.BadServiceUnsupported };\n        } else {\n            endpoints = server._get_endpoints(null);\n        }\n    }\n    // ignore restricted endpoints\n    endpoints = endpoints.filter((e: EndpointDescription) => !(e as any).restricted);\n\n    const endpoints_matching_security_mode = endpoints.filter((e: EndpointDescription) => {\n        return e.securityMode === channel.securityMode;\n    });\n\n    if (endpoints_matching_security_mode.length === 0) {\n        return { errCode: StatusCodes.BadSecurityModeRejected };\n    }\n    const endpoints_matching_security_policy = endpoints_matching_security_mode.filter((e: EndpointDescription) => {\n        return e.securityPolicyUri === channel.securityHeader!.securityPolicyUri;\n    });\n\n    if (endpoints_matching_security_policy.length === 0) {\n        return { errCode: StatusCodes.BadSecurityPolicyRejected };\n    }\n    if (endpoints_matching_security_policy.length !== 1) {\n        debugLog(\"endpoints_matching_security_policy= \", endpoints_matching_security_policy.length);\n    }\n    return { errCode: StatusCodes.Good, endpoint: endpoints_matching_security_policy[0] };\n}\n\nexport function filterDiagnosticInfo(returnDiagnostics: number, response: CallResponse): void {\n    if (RESPONSE_DIAGNOSTICS_MASK_ALL & returnDiagnostics) {\n        response.responseHeader.serviceDiagnostics = filterDiagnosticServiceLevel(\n            returnDiagnostics,\n            response.responseHeader.serviceDiagnostics\n        );\n\n        if (response.diagnosticInfos && response.diagnosticInfos.length > 0) {\n            response.diagnosticInfos = response.diagnosticInfos.map((d) => filterDiagnosticOperationLevel(returnDiagnostics, d));\n        } else {\n            response.diagnosticInfos = [];\n        }\n\n        if (response.results) {\n            for (const entry of response.results) {\n                if (entry.inputArgumentDiagnosticInfos && entry.inputArgumentDiagnosticInfos.length > 0) {\n                    entry.inputArgumentDiagnosticInfos = entry.inputArgumentDiagnosticInfos.map((d) =>\n                        filterDiagnosticOperationLevel(returnDiagnostics, d)\n                    );\n                } else {\n                    entry.inputArgumentDiagnosticInfos = [];\n                }\n            }\n        }\n    }\n}\n\nexport enum RegisterServerMethod {\n    HIDDEN = 1, // the server doesn't expose itself to the external world\n    MDNS = 2, // the server publish itself to the mDNS Multicast network directly\n    LDS = 3 // the server registers itself to the LDS or LDS-ME (Local Discovery Server)\n}\n\nexport interface OPCUAServerEndpointOptions {\n    /**\n     * the primary hostname of the endpoint.\n     * @default getFullyQualifiedDomainName()\n     */\n    hostname?: string;\n\n    /**\n     * the TCP port to listen to.\n     * @default 26543\n     */\n    port?: number;\n    /**\n     * the possible security policies that the server will expose\n     * @default  [SecurityPolicy.None, SecurityPolicy.Basic128Rsa15, SecurityPolicy.Basic256Sha256, SecurityPolicy.Aes128_Sha256_RsaOaep, SecurityPolicy.Aes256_Sha256_RsaPss  ]\n     */\n    securityPolicies?: SecurityPolicy[];\n    /**\n     * the possible security mode that the server will expose\n     * @default [MessageSecurityMode.None, MessageSecurityMode.Sign, MessageSecurityMode.SignAndEncrypt]\n     */\n    securityModes?: MessageSecurityMode[];\n    /**\n     * tells if the server default endpoints should allow anonymous connection.\n     * @default true\n     */\n    allowAnonymous?: boolean;\n\n    /** alternate hostname  or IP to use */\n    alternateHostname?: string | string[];\n\n    /**\n     *  true, if discovery service on secure channel shall be disabled\n     */\n    disableDiscovery?: boolean;\n}\n\nexport interface OPCUAServerOptions extends OPCUABaseServerOptions, OPCUAServerEndpointOptions {\n    alternateEndpoints?: OPCUAServerEndpointOptions[];\n\n    /**\n     * the server certificate full path filename\n     *\n     * the certificate should be in PEM format\n     */\n    certificateFile?: string;\n    /**\n     * the server private key full path filename\n     *\n     * This file should contains the private key that has been used to generate\n     * the server certificate file.\n     *\n     * the private key should be in PEM format\n     *\n     */\n    privateKeyFile?: string;\n\n    /**\n     * the default secure token life time in ms.\n     */\n    defaultSecureTokenLifetime?: number;\n    /**\n     * the HEL/ACK transaction timeout in ms.\n     *\n     * Use a large value ( i.e 15000 ms) for slow connections or embedded devices.\n     * @default 10000\n     */\n    timeout?: number;\n\n    /**\n     * the maximum number of simultaneous sessions allowed.\n     * @default 10\n     * @deprecated use serverCapabilities: { maxSessions: } instead\n    \n     */\n    maxAllowedSessionNumber?: number;\n\n    /**\n     * the maximum number authorized simultaneous connections per endpoint\n     * @default 10\n     */\n    maxConnectionsPerEndpoint?: number;\n\n    /**\n     * the nodeset.xml file(s) to load\n     *\n     * node-opcua comes with pre-installed node-set files that can be used\n     *\n     * example:\n     *\n     * ``` javascript\n     *\n     * ```\n     */\n    nodeset_filename?: string[] | string;\n\n    /**\n     * the server Info\n     *\n     * this object contains the value that will populate the\n     * Root/ObjectS/Server/ServerInfo OPCUA object in the address space.\n     */\n    serverInfo?: ApplicationDescriptionOptions;\n    /*{\n          applicationUri?: string;\n          productUri?: string;\n          applicationName?: LocalizedTextLike | string;\n          gatewayServerUri?: string | null;\n          discoveryProfileUri?: string | null;\n          discoveryUrls?: string[];\n      };\n  */\n    buildInfo?: {\n        productName?: string;\n        productUri?: string | null; // << should be same as default_server_info.productUri?\n        manufacturerName?: string;\n        softwareVersion?: string;\n        buildNumber?: string;\n        buildDate?: Date;\n    };\n\n    /**\n     *  an object that implements user authentication methods\n     */\n    userManager?: UserManagerOptions;\n\n    /** resource Path is a string added at the end of the url such as \"/UA/Server\" */\n    resourcePath?: string;\n\n    /**\n     *\n     */\n    serverCapabilities?: ServerCapabilitiesOptions;\n    /**\n     * if server shall raise AuditingEvent\n     * @default true\n     */\n    isAuditing?: boolean;\n\n    /**\n     * strategy used by the server to declare itself to a discovery server\n     *\n     * - HIDDEN: the server doesn't expose itself to the external world\n     * - MDNS: the server publish itself to the mDNS Multicast network directly\n     * - LDS: the server registers itself to the LDS or LDS-ME (Local Discovery Server)\n     *\n     *  @default    .HIDDEN - by default the server\n     *            will not register itself to the local discovery server\n     *\n     */\n    registerServerMethod?: RegisterServerMethod;\n    /**\n     *\n     * @default \"opc.tcp://localhost:4840\"]\n     */\n    discoveryServerEndpointUrl?: string;\n    /**\n     *\n     *  supported server capabilities for the Multicast (mDNS)\n     *  @default [\"NA\"]\n     *  the possible values are any of node-opcua-discovery.serverCapabilities)\n     *\n     */\n    capabilitiesForMDNS?: string[];\n\n    /**\n     * user Certificate Manager\n     * this certificate manager holds the X509 certificates used\n     * by client that uses X509 certificate token to impersonate a user\n     */\n    userCertificateManager?: OPCUACertificateManager;\n    /**\n     * Server Certificate Manager\n     *\n     * this certificate manager will be used by the server to access\n     * and store certificates from the connecting clients\n     */\n    serverCertificateManager?: OPCUACertificateManager;\n\n    /**\n     *\n     */\n    onCreateMonitoredItem?: CreateMonitoredItemHook;\n    onDeleteMonitoredItem?: DeleteMonitoredItemHook;\n}\n\nexport interface OPCUAServer {\n    /**\n     *\n     */\n    engine: ServerEngine;\n    /**\n     *\n     */\n    registerServerMethod: RegisterServerMethod;\n    /**\n     *\n     */\n    discoveryServerEndpointUrl: string;\n    /**\n     *\n     */\n    registerServerManager?: IRegisterServerManager;\n    /**\n     *\n     */\n    capabilitiesForMDNS: string[];\n    /**\n     *\n     */\n    userCertificateManager: OPCUACertificateManager;\n}\n\nconst g_requestExactEndpointUrl = !!process.env.NODEOPCUA_SERVER_REQUEST_EXACT_ENDPOINT_URL;\n/**\n *\n */\nexport class OPCUAServer extends OPCUABaseServer {\n    static defaultShutdownTimeout = 100; // 250 ms\n    /**\n     * if requestExactEndpointUrl is set to true the server will only accept createSession that have a endpointUrl that strictly matches\n     * one of the provided endpoint.\n     * This mean that if the server expose a endpoint with url such as opc.tcp://MYHOSTNAME:1234, client will not be able to reach the server\n     * with the ip address of the server.\n     * requestExactEndpointUrl = true => emulates the Prosys Server behavior\n     * requestExactEndpointUrl = false => emulates the Unified Automation behavior.\n     */\n    static requestExactEndpointUrl: boolean = g_requestExactEndpointUrl;\n    /**\n     * total number of bytes written  by the server since startup\n     */\n    public get bytesWritten(): number {\n        return this.endpoints.reduce((accumulated: number, endpoint: OPCUAServerEndPoint) => {\n            return accumulated + endpoint.bytesWritten;\n        }, 0);\n    }\n\n    /**\n     * total number of bytes read  by the server since startup\n     */\n    public get bytesRead(): number {\n        return this.endpoints.reduce((accumulated: number, endpoint: OPCUAServerEndPoint) => {\n            return accumulated + endpoint.bytesRead;\n        }, 0);\n    }\n\n    /**\n     * Number of transactions processed by the server since startup\n     */\n    public get transactionsCount(): number {\n        return this.endpoints.reduce((accumulated: number, endpoint: OPCUAServerEndPoint) => {\n            return accumulated + endpoint.transactionsCount;\n        }, 0);\n    }\n\n    /**\n     * The server build info\n     */\n    public get buildInfo(): BuildInfo {\n        return this.engine.buildInfo;\n    }\n\n    /**\n     * the number of connected channel on all existing end points\n     */\n    public get currentChannelCount(): number {\n        // TODO : move to base\n        return this.endpoints.reduce((currentValue: number, endPoint: OPCUAServerEndPoint) => {\n            return currentValue + endPoint.currentChannelCount;\n        }, 0);\n    }\n\n    /**\n     * The number of active subscriptions from all sessions\n     */\n    public get currentSubscriptionCount(): number {\n        return this.engine ? this.engine.currentSubscriptionCount : 0;\n    }\n\n    /**\n     * the number of session activation requests that have been rejected\n     */\n    public get rejectedSessionCount(): number {\n        return this.engine ? this.engine.rejectedSessionCount : 0;\n    }\n\n    /**\n     * the number of request that have been rejected\n     */\n    public get rejectedRequestsCount(): number {\n        return this.engine ? this.engine.rejectedRequestsCount : 0;\n    }\n\n    /**\n     * the number of sessions that have been aborted\n     */\n    public get sessionAbortCount(): number {\n        return this.engine ? this.engine.sessionAbortCount : 0;\n    }\n\n    /**\n     * the publishing interval count\n     */\n    public get publishingIntervalCount(): number {\n        return this.engine ? this.engine.publishingIntervalCount : 0;\n    }\n\n    /**\n     * the number of sessions currently active\n     */\n    public get currentSessionCount(): number {\n        return this.engine ? this.engine.currentSessionCount : 0;\n    }\n\n    /**\n     * true if the server has been initialized\n     *\n     */\n    public get initialized(): boolean {\n        return this.engine && this.engine.addressSpace !== null;\n    }\n\n    /**\n     * is the server auditing ?\n     */\n    public get isAuditing(): boolean {\n        return this.engine ? this.engine.isAuditing : false;\n    }\n\n    public static registry = new ObjectRegistry();\n    public static fallbackSessionName = \"Client didn't provide a meaningful sessionName ...\";\n    /**\n     * the maximum number of subscription that can be created per server\n     * @deprecated\n     */\n    public static deprectated_MAX_SUBSCRIPTION = 50;\n\n    /**\n     * the maximum number of concurrent sessions allowed on the server\n     */\n    public get maxAllowedSessionNumber(): number {\n        return this.engine.serverCapabilities.maxSessions;\n    }\n\n    /**\n     * the maximum number for concurrent connection per end point\n     */\n    public maxConnectionsPerEndpoint: number;\n\n    /**\n     * false if anonymous connection are not allowed\n     */\n    public allowAnonymous = false;\n\n    /**\n     * the user manager\n     */\n    public userManager: UAUserManagerBase;\n\n    public readonly options: OPCUAServerOptions;\n\n    private objectFactory?: Factory;\n\n    private _delayInit?: () => Promise<void>;\n\n    constructor(options?: OPCUAServerOptions) {\n        super(options);\n\n        this.allowAnonymous = false;\n        options = options || {};\n\n        this.options = options;\n\n        if (options.maxAllowedSessionNumber !== undefined) {\n            warningLog(\n                \"[NODE-OPCUA-W21] maxAllowedSessionNumber property is now deprecated , please use serverCapabilities.maxSessions instead\"\n            );\n            options.serverCapabilities = options.serverCapabilities || {};\n            options.serverCapabilities.maxSessions = options.maxAllowedSessionNumber;\n        }\n\n        /**\n         * @property maxConnectionsPerEndpoint\n         */\n        this.maxConnectionsPerEndpoint = options.maxConnectionsPerEndpoint || default_maxConnectionsPerEndpoint;\n\n        // build Info\n        const buildInfo: BuildInfoOptions = {\n            ...default_build_info,\n            ...options.buildInfo\n        };\n\n        // repair product name\n        buildInfo.productUri = buildInfo.productUri || this.serverInfo.productUri;\n        this.serverInfo.productUri = this.serverInfo.productUri || buildInfo.productUri;\n\n        this.userManager = makeUserManager(options.userManager);\n\n        options.allowAnonymous = options.allowAnonymous === undefined ? true : !!options.allowAnonymous;\n        /**\n         * @property allowAnonymous\n         */\n        this.allowAnonymous = options.allowAnonymous;\n\n        this.discoveryServerEndpointUrl = options.discoveryServerEndpointUrl || \"opc.tcp://%FQDN%:4840\";\n        assert(typeof this.discoveryServerEndpointUrl === \"string\");\n\n        this.serverInfo.applicationType = ApplicationType.Server;\n        this.capabilitiesForMDNS = options.capabilitiesForMDNS || [\"NA\"];\n        this.registerServerMethod = options.registerServerMethod || RegisterServerMethod.HIDDEN;\n        _installRegisterServerManager(this);\n\n        if (!options.userCertificateManager) {\n            this.userCertificateManager = getDefaultCertificateManager(\"UserPKI\");\n        } else {\n            this.userCertificateManager = options.userCertificateManager;\n        }\n\n        // note: we need to delay initialization of endpoint as certain resources\n        // such as %FQDN% might not be ready yet at this stage\n        this._delayInit = async () => {\n            /* istanbul ignore next */\n            if (!options) {\n                throw new Error(\"Internal Error\");\n            }\n            // to check => this.serverInfo.applicationName = this.serverInfo.productName || buildInfo.productName;\n\n            // note: applicationUri is handled in a special way\n            this.engine = new ServerEngine({\n                applicationUri: () => this.serverInfo.applicationUri!,\n                buildInfo,\n                isAuditing: options.isAuditing,\n                serverCapabilities: options.serverCapabilities\n            });\n            this.objectFactory = new Factory(this.engine);\n\n            const endpointDefinitions = options.alternateEndpoints || [];\n            const hostname = getFullyQualifiedDomainName();\n\n            endpointDefinitions.push({\n                port: options.port || 26543,\n\n                allowAnonymous: options.allowAnonymous,\n                alternateHostname: options.alternateHostname,\n                disableDiscovery: options.disableDiscovery,\n                hostname: options.hostname || hostname,\n                securityModes: options.securityModes,\n                securityPolicies: options.securityPolicies\n            });\n\n            // todo  should self.serverInfo.productUri  match self.engine.buildInfo.productUri ?\n            for (const endpointOptions of endpointDefinitions) {\n                const endPoint = this.createEndpointDescriptions(options!, endpointOptions);\n                this.endpoints.push(endPoint);\n                endPoint.on(\"message\", (message: Message, channel: ServerSecureChannelLayer) => {\n                    this.on_request(message, channel);\n                });\n\n                endPoint.on(\"error\", (err: Error) => {\n                    errorLog(\"OPCUAServer endpoint error\", err);\n                    // set serverState to ServerState.Failed;\n                    this.engine.setServerState(ServerState.Failed);\n                    this.shutdown(() => {\n                        /* empty */\n                    });\n                });\n            }\n        };\n    }\n\n    /**\n     * Initialize the server by installing default node set.\n     *\n     * and instruct the server to listen to its endpoints.\n     *\n     * ```javascript\n     * const server = new OPCUAServer();\n     * await server.initialize();\n     *\n     * // default server namespace is now initialized\n     * // it is a good time to create life instance objects\n     * const namespace = server.engine.addressSpace.getOwnNamespace();\n     * namespace.addObject({\n     *     browseName: \"SomeObject\",\n     *     organizedBy: server.engine.addressSpace.rootFolder.objects\n     * });\n     *\n     * // the addressSpace is now complete\n     * // let's now start listening to clients\n     * await server.start();\n     * ```\n     */\n    public initialize(): Promise<void>;\n    public initialize(done: () => void): void;\n    public initialize(...args: [any?, ...any[]]): any {\n        const done = args[0] as (err?: Error) => void;\n        assert(!this.initialized, \"server is already initialized\"); // already initialized ?\n\n        this._preInitTask.push(async () => {\n            /* istanbul ignore else */\n            if (this._delayInit) {\n                await this._delayInit();\n                this._delayInit = undefined;\n            }\n        });\n\n        this.performPreInitialization()\n            .then(() => {\n                OPCUAServer.registry.register(this);\n                this.engine.initialize(this.options, () => {\n                    bindRoleSet(this.userManager, this.engine.addressSpace!);\n                    setImmediate(() => {\n                        this.emit(\"post_initialize\");\n                        done();\n                    });\n                });\n            })\n            .catch((err) => {\n                done(err);\n            });\n    }\n\n    /**\n     * Initiate the server by starting all its endpoints\n     * @async\n     */\n    public start(): Promise<void>;\n    public start(done: () => void): void;\n    public start(...args: [any?, ...any[]]): any {\n        const done = args[0] as () => void;\n        const tasks: any[] = [];\n\n        tasks.push(callbackify(extractFullyQualifiedDomainName));\n\n        if (!this.initialized) {\n            tasks.push((callback: ErrorCallback) => {\n                this.initialize(callback);\n            });\n        }\n        tasks.push((callback: ErrorCallback) => {\n            super.start((err?: Error | null) => {\n                if (err) {\n                    this.shutdown((/*err2*/ err2?: Error) => {\n                        callback(err);\n                    });\n                } else {\n                    // we start the registration process asynchronously\n                    // as we want to make server immediately available\n                    this.registerServerManager!.start(() => {\n                        /* empty */\n                    });\n\n                    setImmediate(callback);\n                }\n            });\n        });\n\n        async.series(tasks, done);\n    }\n\n    /**\n     * shutdown all server endpoints\n     * @method shutdown\n     * @async\n     * @param  timeout the timeout (in ms) before the server is actually shutdown\n     *\n     * @example\n     *\n     * ```javascript\n     *    // shutdown immediately\n     *    server.shutdown(function(err) {\n     *    });\n     * ```\n     * ```ts\n     *   // in typescript with promises\n     *   server.shutdown(10000).then(()=>{\n     *      console.log(\"Server has shutdown\");\n     *   });\n     * ```\n     * ```javascript\n     *    // shutdown within 10 seconds\n     *    server.engine.shutdownReason = coerceLocalizedText(\"Shutdown for maintenance\");\n     *    server.shutdown(10000,function(err) {\n     *    });\n     *   ```\n     */\n    public shutdown(timeout?: number): Promise<void>;\n    public shutdown(callback: (err?: Error) => void): void;\n    public shutdown(timeout: number, callback: (err?: Error) => void): void;\n    public shutdown(...args: [any?, ...any[]]): any {\n        const timeout = args.length === 1 ? OPCUAServer.defaultShutdownTimeout : (args[0] as number);\n        const callback = (args.length === 1 ? args[0] : args[1]) as (err?: Error) => void;\n        assert(typeof callback === \"function\");\n        debugLog(\"OPCUAServer#shutdown (timeout = \", timeout, \")\");\n\n        /* istanbul ignore next */\n        if (!this.engine) {\n            return callback();\n        }\n        assert(this.engine);\n        if (!this.engine.isStarted()) {\n            // server may have been shot down already  , or may have fail to start !!\n            const err = new Error(\"OPCUAServer#shutdown failure ! server doesn't seems to be started yet\");\n            return callback(err);\n        }\n\n        this.userCertificateManager.dispose();\n\n        this.engine.setServerState(ServerState.Shutdown);\n\n        const shutdownTime = new Date(Date.now() + timeout);\n        this.engine.setShutdownTime(shutdownTime);\n\n        debugLog(\"OPCUAServer is now unregistering itself from  the discovery server \" + this.buildInfo);\n        this.registerServerManager!.stop((err?: Error | null) => {\n            debugLog(\"OPCUAServer unregistered from discovery server\", err);\n            setTimeout(async () => {\n                await this.engine.shutdown();\n\n                debugLog(\"OPCUAServer#shutdown: started\");\n                OPCUABaseServer.prototype.shutdown.call(this, (err1?: Error) => {\n                    debugLog(\"OPCUAServer#shutdown: completed\");\n\n                    this.dispose();\n                    callback(err1);\n                });\n            }, timeout);\n        });\n    }\n\n    public dispose(): void {\n        for (const endpoint of this.endpoints) {\n            endpoint.dispose();\n        }\n        this.endpoints = [];\n\n        this.removeAllListeners();\n\n        if (this.registerServerManager) {\n            this.registerServerManager.dispose();\n            this.registerServerManager = undefined;\n        }\n        OPCUAServer.registry.unregister(this);\n\n        /* istanbul ignore next */\n        if (this.engine) {\n            this.engine.dispose();\n        }\n    }\n\n    public raiseEvent(eventType: EventTypeLike | UAObjectType, options: RaiseEventData): void {\n        /* istanbul ignore next */\n        if (!this.engine.addressSpace) {\n            errorLog(\"addressSpace missing\");\n            return;\n        }\n\n        const server = this.engine.addressSpace.findNode(\"Server\") as UAObject;\n\n        /* istanbul ignore next */\n        if (!server) {\n            // xx throw new Error(\"OPCUAServer#raiseEvent : cannot find Server object\");\n            return;\n        }\n\n        let eventTypeNode: EventTypeLike | UAObjectType | null = eventType;\n        if (typeof eventType === \"string\") {\n            eventTypeNode = this.engine.addressSpace.findEventType(eventType);\n            if (eventTypeNode) {\n                return server.raiseEvent(eventTypeNode, options);\n            } else {\n                console.warn(\" cannot find event type \", eventType);\n            }\n        } else {\n            return server.raiseEvent(eventTypeNode, options);\n        }\n    }\n\n    /**\n     * create and register a new session\n     * @internal\n     */\n    protected createSession(options: CreateSessionOption): ServerSession {\n        /* istanbul ignore next */\n        if (!this.engine) {\n            throw new Error(\"Internal Error\");\n        }\n        return this.engine.createSession(options);\n    }\n\n    /**\n     * retrieve a session by authentication token\n     * @internal\n     */\n    protected getSession(authenticationToken: NodeId, activeOnly?: boolean): ServerSession | null {\n        return this.engine ? this.engine.getSession(authenticationToken, activeOnly) : null;\n    }\n\n    /**\n     *\n     * @param channel\n     * @param clientCertificate\n     * @param clientNonce\n     * @internal\n     */\n    protected computeServerSignature(\n        channel: ServerSecureChannelLayer,\n        clientCertificate: Certificate,\n        clientNonce: Nonce\n    ): SignatureData | undefined {\n        return computeSignature(clientCertificate, clientNonce, this.getPrivateKey(), channel.messageBuilder!.securityPolicy);\n    }\n\n    /**\n     *\n     * @param session\n     * @param channel\n     * @param clientSignature\n     * @internal\n     */\n    protected verifyClientSignature(\n        session: ServerSession,\n        channel: ServerSecureChannelLayer,\n        clientSignature: SignatureData\n    ): boolean {\n        const clientCertificate = channel.receiverCertificate!;\n        const securityPolicy = channel.messageBuilder!.securityPolicy;\n        const serverCertificate = this.getCertificate();\n\n        const result = verifySignature(serverCertificate, session.nonce!, clientSignature, clientCertificate, securityPolicy);\n\n        return result;\n    }\n\n    protected isValidUserNameIdentityToken(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userTokenPolicy: UserTokenPolicy,\n        userIdentityToken: UserNameIdentityToken,\n        userTokenSignature: SignatureData,\n        callback: (err: Error | null, statusCode?: StatusCode) => void\n    ): void {\n        assert(userIdentityToken instanceof UserNameIdentityToken);\n\n        const securityPolicy = adjustSecurityPolicy(channel, userTokenPolicy.securityPolicyUri);\n        if (securityPolicy === SecurityPolicy.None) {\n            return callback(null, StatusCodes.Good);\n        }\n        const cryptoFactory = getCryptoFactory(securityPolicy);\n\n        /* istanbul ignore next */\n        if (!cryptoFactory) {\n            return callback(null, StatusCodes.BadSecurityPolicyRejected);\n        }\n\n        /* istanbul ignore next */\n        if (userIdentityToken.encryptionAlgorithm !== cryptoFactory.asymmetricEncryptionAlgorithm) {\n            errorLog(\"invalid encryptionAlgorithm\");\n            errorLog(\"userTokenPolicy\", userTokenPolicy.toString());\n            errorLog(\"userTokenPolicy\", userIdentityToken.toString());\n            return callback(null, StatusCodes.BadIdentityTokenInvalid);\n        }\n        const userName = userIdentityToken.userName;\n        const password = userIdentityToken.password;\n        if (!userName || !password) {\n            return callback(null, StatusCodes.BadIdentityTokenInvalid);\n        }\n        return callback(null, StatusCodes.Good);\n    }\n\n    protected isValidX509IdentityToken(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userTokenPolicy: UserTokenPolicy,\n        userIdentityToken: X509IdentityToken,\n        userTokenSignature: SignatureData,\n        callback: (err: Error | null, statusCode?: StatusCode) => void\n    ): void {\n        assert(userIdentityToken instanceof X509IdentityToken);\n        assert(typeof callback === \"function\");\n\n        const securityPolicy = adjustSecurityPolicy(channel, userTokenPolicy.securityPolicyUri);\n\n        const cryptoFactory = getCryptoFactory(securityPolicy);\n        /* istanbul ignore next */\n        if (!cryptoFactory) {\n            return callback(null, StatusCodes.BadSecurityPolicyRejected);\n        }\n\n        if (!userTokenSignature || !userTokenSignature.signature) {\n            return callback(null, StatusCodes.BadUserSignatureInvalid);\n        }\n\n        if (userIdentityToken.policyId !== userTokenPolicy.policyId) {\n            errorLog(\"invalid encryptionAlgorithm\");\n            errorLog(\"userTokenPolicy\", userTokenPolicy.toString());\n            errorLog(\"userTokenPolicy\", userIdentityToken.toString());\n            return callback(null, StatusCodes.BadSecurityPolicyRejected);\n        }\n        const certificate = userIdentityToken.certificateData; /* as Certificate*/\n        const nonce = session.nonce!;\n        const serverCertificate = this.getCertificate();\n\n        assert(serverCertificate instanceof Buffer);\n        assert(certificate instanceof Buffer, \"expecting certificate to be a Buffer\");\n        assert(nonce instanceof Buffer, \"expecting nonce to be a Buffer\");\n        assert(userTokenSignature.signature instanceof Buffer, \"expecting userTokenSignature to be a Buffer\");\n\n        // verify proof of possession by checking certificate signature & server nonce correctness\n        if (!verifySignature(serverCertificate, nonce, userTokenSignature, certificate, securityPolicy)) {\n            return callback(null, StatusCodes.BadUserSignatureInvalid);\n        }\n\n        // verify if certificate is Valid\n        this.userCertificateManager!.checkCertificate(certificate, (err, certificateStatus) => {\n            /* istanbul ignore next */\n            if (err) {\n                return callback(err);\n            }\n            if (\n                StatusCodes.BadCertificateUntrusted === certificateStatus ||\n                StatusCodes.BadCertificateTimeInvalid === certificateStatus ||\n                StatusCodes.BadCertificateIssuerTimeInvalid === certificateStatus ||\n                StatusCodes.BadCertificateIssuerUseNotAllowed === certificateStatus ||\n                StatusCodes.BadCertificateIssuerRevocationUnknown === certificateStatus ||\n                StatusCodes.BadCertificateRevocationUnknown === certificateStatus ||\n                StatusCodes.BadCertificateRevoked === certificateStatus ||\n                StatusCodes.BadCertificateUseNotAllowed === certificateStatus ||\n                StatusCodes.BadSecurityChecksFailed === certificateStatus ||\n                StatusCodes.Good !== certificateStatus\n            ) {\n                debugLog(\"isValidX509IdentityToken => certificateStatus = \", certificateStatus?.toString());\n                return callback(null, StatusCodes.BadIdentityTokenRejected);\n            }\n            if (StatusCodes.Good !== certificateStatus) {\n                assert(certificateStatus instanceof StatusCode);\n                return callback(null, certificateStatus);\n                // return callback(null, StatusCodes.BadIdentityTokenInvalid);\n            }\n\n            // verify if certificate is truster or rejected\n            // todo: StatusCodes.BadCertificateUntrusted\n\n            // store untrusted certificate to rejected folder\n            // todo:\n            return callback(null, StatusCodes.Good);\n        });\n    }\n\n    /**\n     * @internal\n     */\n    protected userNameIdentityTokenAuthenticateUser(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userTokenPolicy: UserTokenPolicy,\n        userIdentityToken: UserNameIdentityToken,\n        callback: (err: Error | null, isAuthorized?: boolean) => void\n    ): void {\n        assert(userIdentityToken instanceof UserNameIdentityToken);\n        // assert(this.isValidUserNameIdentityToken(channel, session, userTokenPolicy, userIdentityToken));\n\n        const securityPolicy = adjustSecurityPolicy(channel, userTokenPolicy.securityPolicyUri);\n\n        const userName = userIdentityToken.userName!;\n        let password: any = userIdentityToken.password;\n\n        // decrypt password if necessary\n        if (securityPolicy === SecurityPolicy.None) {\n            // not good, password was sent in clear text ...\n            password = password.toString();\n        } else {\n            const serverPrivateKey = this.getPrivateKey();\n\n            const serverNonce = session.nonce!;\n            assert(serverNonce instanceof Buffer);\n\n            const cryptoFactory = getCryptoFactory(securityPolicy);\n            /* istanbul ignore next */\n            if (!cryptoFactory) {\n                return callback(new Error(\" Unsupported security Policy\"));\n            }\n\n            const buff = cryptoFactory.asymmetricDecrypt(password, serverPrivateKey);\n\n            // server certificate may be invalid and asymmetricDecrypt may fail\n            if (!buff || buff.length < 4) {\n                async.setImmediate(() => callback(null, false));\n                return;\n            }\n\n            const length = buff.readUInt32LE(0) - serverNonce.length;\n            password = buff.slice(4, 4 + length).toString(\"utf-8\");\n        }\n\n        this.userManager\n            .isValidUser(session, userName, password)\n            .then((isValid) => callback(null, isValid))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * @internal\n     */\n    protected isValidUserIdentityToken(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userIdentityToken: UserIdentityToken,\n        userTokenSignature: SignatureData,\n        endpointDescription: EndpointDescription,\n        callback: (err: Error | null, statusCode?: StatusCode) => void\n    ): void {\n        assert(typeof callback === \"function\");\n        /* istanbul ignore next */\n        if (!userIdentityToken) {\n            throw new Error(\"Invalid token\");\n        }\n\n        const userTokenType = getTokenType(userIdentityToken);\n\n        const userTokenPolicy = findUserTokenByPolicy(endpointDescription, userTokenType, userIdentityToken.policyId!);\n        if (!userTokenPolicy) {\n            // cannot find token with this policyId\n            return callback(null, StatusCodes.BadIdentityTokenInvalid);\n        }\n        //\n        if (userIdentityToken instanceof UserNameIdentityToken) {\n            return this.isValidUserNameIdentityToken(\n                channel,\n                session,\n                userTokenPolicy,\n                userIdentityToken,\n                userTokenSignature,\n                callback\n            );\n        }\n        if (userIdentityToken instanceof X509IdentityToken) {\n            return this.isValidX509IdentityToken(\n                channel,\n                session,\n                userTokenPolicy,\n                userIdentityToken,\n                userTokenSignature,\n                callback\n            );\n        }\n\n        return callback(null, StatusCodes.Good);\n    }\n\n    /**\n     *\n     * @internal\n     * @param channel\n     * @param session\n     * @param userIdentityToken\n     * @param callback\n     * @returns {*}\n     */\n    protected isUserAuthorized(\n        channel: ServerSecureChannelLayer,\n        session: ServerSession,\n        userIdentityToken: UserIdentityToken,\n        callback: (err: Error | null, isAuthorized?: boolean) => void\n    ): void {\n        assert(userIdentityToken);\n        assert(typeof callback === \"function\");\n\n        const userTokenType = getTokenType(userIdentityToken);\n        const userTokenPolicy = findUserTokenByPolicy(session.getEndpointDescription(), userTokenType, userIdentityToken.policyId!);\n        /** istanbul ignore next */\n        if (!userTokenPolicy) {\n            return callback(null, false);\n        }\n        // find if a userToken exists\n        if (userIdentityToken instanceof UserNameIdentityToken) {\n            return this.userNameIdentityTokenAuthenticateUser(channel, session, userTokenPolicy, userIdentityToken, callback);\n        }\n        async.setImmediate(callback.bind(null, null, true));\n    }\n\n    protected makeServerNonce(): Nonce {\n        return crypto.randomBytes(32);\n    }\n\n    // session services\n    // eslint-disable-next-line max-statements\n    protected async _on_CreateSessionRequest(message: Message, channel: ServerSecureChannelLayer): Promise<void> {\n        const request = message.request as CreateSessionRequest;\n        assert(request instanceof CreateSessionRequest);\n\n        function rejectConnection(server: OPCUAServer, statusCode: StatusCode): void {\n            server.engine.incrementSecurityRejectedSessionCount();\n\n            const response1 = new CreateSessionResponse({\n                responseHeader: { serviceResult: statusCode }\n            });\n            channel.send_response(\"MSG\", response1, message);\n            // and close !\n        }\n\n        // From OPCUA V1.03 Part 4 5.6.2 CreateSession\n        // A Server application should limit the number of Sessions. To protect against misbehaving Clients and denial\n        // of service attacks, the Server shall close the oldest Session that is not activated before reaching the\n        // maximum number of supported Sessions\n        if (this.currentSessionCount >= this.engine.serverCapabilities.maxSessions) {\n            await _attempt_to_close_some_old_unactivated_session(this);\n        }\n\n        // check if session count hasn't reach the maximum allowed sessions\n        if (this.currentSessionCount >= this.engine.serverCapabilities.maxSessions) {\n            return rejectConnection(this, StatusCodes.BadTooManySessions);\n        }\n\n        // Release 1.03 OPC Unified Architecture, Part 4 page 24 - CreateSession Parameters\n        // client should prove a sessionName\n        // Session name is a Human readable string that identifies the Session. The Server makes this name and the\n        // sessionId visible in its AddressSpace for diagnostic purposes. The Client should provide a name that is\n        // unique for the instance of the Client.\n        // If this parameter is not specified the Server shall assign a value.\n\n        if (utils.isNullOrUndefined(request.sessionName)) {\n            // see also #198\n            // let's the server assign a sessionName for this lazy client.\n\n            debugLog(\n                \"assigning OPCUAServer.fallbackSessionName because client's sessionName is null \",\n                OPCUAServer.fallbackSessionName\n            );\n\n            request.sessionName = OPCUAServer.fallbackSessionName;\n        }\n\n        // Duration Requested maximum number of milliseconds that a Session should remain open without activity.\n        // If the Client fails to issue a Service request within this interval, then the Server shall automatically\n        // terminate the Client Session.\n        const revisedSessionTimeout = _adjust_session_timeout(request.requestedSessionTimeout);\n\n        // Release 1.02 page 27 OPC Unified Architecture, Part 4: CreateSession.clientNonce\n        // A random number that should never be used in any other request. This number shall have a minimum length of 32\n        // bytes. Profiles may increase the required length. The Server shall use this value to prove possession of\n        // its application instance Certificate in the response.\n        if (!request.clientNonce || request.clientNonce.length < 32) {\n            if (channel.securityMode !== MessageSecurityMode.None) {\n                errorLog(\n                    chalk.red(\"SERVER with secure connection: Missing or invalid client Nonce \"),\n                    request.clientNonce && request.clientNonce.toString(\"hex\")\n                );\n\n                return rejectConnection(this, StatusCodes.BadNonceInvalid);\n            }\n        }\n        if (nonceAlreadyBeenUsed(request.clientNonce)) {\n            errorLog(\n                chalk.red(\"SERVER with secure connection: None has already been used\"),\n                request.clientNonce && request.clientNonce.toString(\"hex\")\n            );\n\n            return rejectConnection(this, StatusCodes.BadNonceInvalid);\n        }\n        // check application spoofing\n        // check if applicationUri in createSessionRequest matches applicationUri in client Certificate\n        if (!validate_applicationUri(channel, request)) {\n            return rejectConnection(this, StatusCodes.BadCertificateUriInvalid);\n        }\n\n        const { errCode, endpoint } = validate_security_endpoint(this, request, channel);\n        if (errCode !== StatusCodes.Good) {\n            return rejectConnection(this, errCode);\n        }\n\n        // see Release 1.02  27  OPC Unified Architecture, Part 4\n        const session = this.createSession({\n            clientDescription: request.clientDescription,\n            sessionTimeout: revisedSessionTimeout\n        });\n        session.endpoint = endpoint;\n\n        assert(session);\n        assert(session.sessionTimeout === revisedSessionTimeout);\n\n        session.clientDescription = request.clientDescription;\n        session.sessionName = request.sessionName || `<unknown session name ${unnamed_session_count++}>`;\n\n        // Depending upon on the  SecurityPolicy  and the  SecurityMode  of the  SecureChannel,  the exchange of\n        // ApplicationInstanceCertificates   and  Nonces  may be optional and the signatures may be empty. See\n        // Part  7  for the definition of  SecurityPolicies  and the handling of these parameters\n\n        // serverNonce:\n        // A random number that should never be used in any other request.\n        // This number shall have a minimum length of 32 bytes.\n        // The Client shall use this value to prove possession of its application instance\n        // Certificate in the ActivateSession request.\n        // This value may also be used to prove possession of the userIdentityToken it\n        // specified in the ActivateSession request.\n        //\n        // ( this serverNonce will only be used up to the _on_ActivateSessionRequest\n        //   where a new nonce will be created)\n        session.nonce = this.makeServerNonce();\n        session.channelId = channel.channelId;\n\n        session._attach_channel(channel);\n\n        const serverCertificateChain = this.getCertificateChain();\n\n        const hasEncryption = true;\n        // If the securityPolicyUri is None and none of the UserTokenPolicies requires encryption\n        if (session.channel!.securityMode === MessageSecurityMode.None) {\n            // ToDo: Check that none of our insecure endpoint has a a UserTokenPolicy that require encryption\n            // and set hasEncryption = false under this condition\n        }\n\n        const response = new CreateSessionResponse({\n            // A identifier which uniquely identifies the session.\n            sessionId: session.nodeId,\n\n            // A unique identifier assigned by the Server to the Session.\n            // The token used to authenticate the client in subsequent requests.\n            authenticationToken: session.authenticationToken,\n\n            revisedSessionTimeout,\n\n            serverNonce: session.nonce,\n\n            // serverCertificate: type ApplicationServerCertificate\n            // The application instance Certificate issued to the Server.\n            // A Server shall prove possession by using the private key to sign the Nonce provided\n            // by the Client in the request. The Client shall verify that this Certificate is the same as\n            // the one it used to create the SecureChannel.\n            // The ApplicationInstanceCertificate type is defined in OpCUA 1.03 part 4 - $7.2 page 108\n            // If the securityPolicyUri is None and none of the UserTokenPolicies requires\n            // encryption, the Server shall not send an ApplicationInstanceCertificate and the Client\n            // shall ignore the ApplicationInstanceCertificate.\n            serverCertificate: hasEncryption ? serverCertificateChain : undefined,\n\n            // The endpoints provided by the server.\n            // The Server shall return a set of EndpointDescriptions available for the serverUri\n            // specified in the request.[...]\n            // The Client shall verify this list with the list from a Discovery Endpoint if it used a Discovery\n            // Endpoint to fetch the EndpointDescriptions.\n            // It is recommended that Servers only include the endpointUrl, securityMode,\n            // securityPolicyUri, userIdentityTokens, transportProfileUri and securityLevel with all\n            // other parameters set to null. Only the recommended parameters shall be verified by\n            // the client.\n            serverEndpoints: _serverEndpointsForCreateSessionResponse(this, session.endpoint!.endpointUrl, request.serverUri),\n\n            // This parameter is deprecated and the array shall be empty.\n            serverSoftwareCertificates: null,\n\n            // This is a signature generated with the private key associated with the\n            // serverCertificate. This parameter is calculated by appending the clientNonce to the\n            // clientCertificate and signing the resulting sequence of bytes.\n            // The SignatureAlgorithm shall be the AsymmetricSignatureAlgorithm specified in the\n            // SecurityPolicy for the Endpoint.\n            // The SignatureData type is defined in 7.30.\n            serverSignature: this.computeServerSignature(channel, request.clientCertificate, request.clientNonce),\n\n            // The maximum message size accepted by the server\n            // The Client Communication Stack should return a Bad_RequestTooLarge error to the\n            // application if a request message exceeds this limit.\n            // The value zero indicates that this parameter is not used.\n            maxRequestMessageSize: 0x4000000\n        });\n\n        this.emit(\"create_session\", session);\n\n        session.on(\"session_closed\", (session1: ServerSession, deleteSubscriptions: boolean, reason: string) => {\n            assert(typeof reason === \"string\");\n            if (this.isAuditing) {\n                assert(reason === \"Timeout\" || reason === \"Terminated\" || reason === \"CloseSession\" || reason === \"Forcing\");\n                const sourceName = \"Session/\" + reason;\n\n                this.raiseEvent(\"AuditSessionEventType\", {\n                    /* part 5 -  6.4.3 AuditEventType */\n                    actionTimeStamp: { dataType: \"DateTime\", value: new Date() },\n                    status: { dataType: \"Boolean\", value: true },\n\n                    serverId: { dataType: \"String\", value: \"\" },\n\n                    // ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.\n                    clientAuditEntryId: { dataType: \"String\", value: \"\" },\n\n                    // The ClientUserId identifies the user of the client requesting an action. The ClientUserId can be\n                    // obtained from the UserIdentityToken passed in the ActivateSession call.\n                    clientUserId: { dataType: \"String\", value: \"\" },\n\n                    sourceName: { dataType: \"String\", value: sourceName },\n\n                    /* part 5 - 6.4.7 AuditSessionEventType */\n                    sessionId: { dataType: \"NodeId\", value: session1.nodeId }\n                });\n            }\n\n            this.emit(\"session_closed\", session1, deleteSubscriptions);\n        });\n\n        if (this.isAuditing) {\n            // ------------------------------------------------------------------------------------------------------\n            this.raiseEvent(\"AuditCreateSessionEventType\", {\n                /* part 5 -  6.4.3 AuditEventType */\n                actionTimeStamp: { dataType: \"DateTime\", value: new Date() },\n                status: { dataType: \"Boolean\", value: true },\n\n                serverId: { dataType: \"String\", value: \"\" },\n\n                // ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.\n                clientAuditEntryId: { dataType: \"String\", value: \"\" },\n\n                // The ClientUserId identifies the user of the client requesting an action. The ClientUserId can be\n                // obtained from the UserIdentityToken passed in the ActivateSession call.\n                clientUserId: { dataType: \"String\", value: \"\" },\n\n                sourceName: { dataType: \"String\", value: \"Session/CreateSession\" },\n\n                /* part 5 - 6.4.7 AuditSessionEventType */\n                sessionId: { dataType: \"NodeId\", value: session.nodeId },\n\n                /* part 5 - 6.4.8 AuditCreateSessionEventType */\n                // SecureChannelId shall uniquely identify the SecureChannel. The application shall use the same\n                // identifier in all AuditEvents related to the Session Service Set (AuditCreateSessionEventType,\n                // AuditActivateSessionEventType and their subtypes) and the SecureChannel Service Set\n                // (AuditChannelEventType and its subtypes\n                secureChannelId: { dataType: \"String\", value: session.channel!.channelId!.toString() },\n\n                // Duration\n                revisedSessionTimeout: { dataType: \"Duration\", value: session.sessionTimeout },\n\n                // clientCertificate\n                clientCertificate: { dataType: \"ByteString\", value: session.channel!.clientCertificate },\n\n                // clientCertificateThumbprint\n                clientCertificateThumbprint: {\n                    dataType: \"String\",\n                    value: thumbprint(session.channel!.clientCertificate!)\n                }\n            });\n        }\n        // -----------------------------------------------------------------------------------------------------------\n\n        assert(response.authenticationToken);\n        channel.send_response(\"MSG\", response, message);\n    }\n\n    // TODO : implement this:\n    //\n    // When the ActivateSession Service is called for the first time then the Server shall reject the request\n    // if the SecureChannel is not same as the one associated with the CreateSession request.\n    // Subsequent calls to ActivateSession may be associated with different SecureChannels. If this is the\n    // case then the Server shall verify that the Certificate the Client used to create the new\n    // SecureChannel is the same as the Certificate used to create the original SecureChannel. In addition,\n    // the Server shall verify that the Client supplied a UserIdentityToken that is identical to the token\n    // currently associated with the Session. Once the Server accepts the new SecureChannel it shall\n    // reject requests sent via the old SecureChannel.\n    /**\n     *\n     * @method _on_ActivateSessionRequest\n     * @private\n     *\n     *\n     */\n    protected _on_ActivateSessionRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as ActivateSessionRequest;\n        assert(request instanceof ActivateSessionRequest);\n\n        // get session from authenticationToken\n        const authenticationToken = request.requestHeader.authenticationToken;\n\n        const session = this.getSession(authenticationToken);\n\n        function rejectConnection(server: OPCUAServer, statusCode: StatusCode): void {\n            if (statusCode === StatusCodes.BadSessionIdInvalid) {\n                server.engine.incrementRejectedSessionCount();\n            } else {\n                server.engine.incrementRejectedSessionCount();\n                server.engine.incrementSecurityRejectedSessionCount();\n            }\n\n            const response1 = new ActivateSessionResponse({ responseHeader: { serviceResult: statusCode } });\n\n            channel.send_response(\"MSG\", response1, message);\n            // and close !\n        }\n\n        let response;\n\n        /* istanbul ignore next */\n        if (!session) {\n            // this may happen when the server has been restarted and a client tries to reconnect, thinking\n            // that the previous session may still be active\n            debugLog(chalk.yellow.bold(\" Bad Session in  _on_ActivateSessionRequest\"), authenticationToken.toString());\n\n            return rejectConnection(this, StatusCodes.BadSessionIdInvalid);\n        }\n\n        // tslint:disable-next-line: no-unused-expression\n        session.keepAlive ? session.keepAlive() : void 0;\n\n        // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n        // When the ActivateSession  Service  is called f or the first time then the Server shall reject the request\n        // if the  SecureChannel  is not same as the one associated with the  CreateSession  request.\n        if (session.status === \"new\") {\n            // xx if (channel.session_nonce !== session.nonce) {\n            if (!channel_has_session(channel, session)) {\n                // it looks like session activation is being using a channel that is not the\n                // one that have been used to create the session\n                errorLog(\" channel.sessionTokens === \" + Object.keys(channel.sessionTokens).join(\" \"));\n                return rejectConnection(this, StatusCodes.BadSessionNotActivated);\n            }\n        }\n\n        // OpcUA 1.02 part 3 $5.6.3.1 ActiveSession Set page 29\n        // ... Subsequent calls to  ActivateSession  may be associated with different  SecureChannels.  If this is the\n        // case then  the  Server  shall verify that the  Certificate  the  Client  used to create the new\n        // SecureChannel  is the same as the  Certificate  used to create the original  SecureChannel.\n\n        if (session.status === \"active\") {\n            if (session.channel!.channelId !== channel.channelId) {\n                warningLog(\n                    \" Session \",\n                    session.sessionName,\n                    \" is being transferred from channel\",\n                    chalk.cyan(session.channel!.channelId!.toString()),\n                    \" to channel \",\n                    chalk.cyan(channel.channelId!.toString())\n                );\n\n                // session is being reassigned to a new Channel,\n                // we shall verify that the certificate used to create the Session is the same as the current\n                // channel certificate.\n                const old_channel_cert_thumbprint = thumbprint(session.channel!.clientCertificate!);\n                const new_channel_cert_thumbprint = thumbprint(channel.clientCertificate!);\n\n                if (old_channel_cert_thumbprint !== new_channel_cert_thumbprint) {\n                    return rejectConnection(this, StatusCodes.BadNoValidCertificates); // not sure about this code !\n                }\n\n                // ... In addition the Server shall verify that the  Client  supplied a  UserIdentityToken  that is\n                // identical to the token currently associated with the  Session reassign session to new channel.\n                if (!sameIdentityToken(session.userIdentityToken!, request.userIdentityToken as UserIdentityToken)) {\n                    return rejectConnection(this, StatusCodes.BadIdentityChangeNotSupported); // not sure about this code !\n                }\n            }\n\n            moveSessionToChannel(session, channel);\n        } else if (session.status === \"screwed\") {\n            // session has been used before being activated => this should be detected and session should be dismissed.\n            return rejectConnection(this, StatusCodes.BadSessionClosed);\n        } else if (session.status === \"closed\") {\n            warningLog(chalk.yellow.bold(\" Bad Session Closed in  _on_ActivateSessionRequest\"), authenticationToken.toString());\n            return rejectConnection(this, StatusCodes.BadSessionClosed);\n        }\n\n        // verify clientSignature provided by the client\n        if (!this.verifyClientSignature(session, channel, request.clientSignature)) {\n            return rejectConnection(this, StatusCodes.BadApplicationSignatureInvalid);\n        }\n\n        // userIdentityToken may be missing , assume anonymous access then\n        request.userIdentityToken = request.userIdentityToken || createAnonymousIdentityToken(session.endpoint!);\n\n        // check request.userIdentityToken is correct ( expected type and correctly formed)\n        this.isValidUserIdentityToken(\n            channel,\n            session,\n            request.userIdentityToken as UserIdentityToken,\n            request.userTokenSignature,\n            session.endpoint!,\n            (err: Error | null, statusCode?: StatusCode) => {\n                if (statusCode !== StatusCodes.Good) {\n                    /* istanbul ignore next */\n                    if (!(statusCode && statusCode instanceof StatusCode)) {\n                        return rejectConnection(this, StatusCodes.BadCertificateInvalid);\n                    }\n                    return rejectConnection(this, statusCode);\n                }\n                session.userIdentityToken = request.userIdentityToken as UserIdentityToken;\n\n                // check if user access is granted\n                this.isUserAuthorized(\n                    channel,\n                    session,\n                    request.userIdentityToken as UserIdentityToken,\n                    (err1: Error | null, authorized?: boolean) => {\n                        /* istanbul ignore next */\n                        if (err1) {\n                            return rejectConnection(this, StatusCodes.BadInternalError);\n                        }\n\n                        if (!authorized) {\n                            return rejectConnection(this, StatusCodes.BadUserAccessDenied);\n                        } else {\n                            // extract : OPC UA part 4 - 5.6.3\n                            // Once used, a serverNonce cannot be used again. For that reason, the Server returns a new\n                            // serverNonce each time the ActivateSession Service is called.\n                            session.nonce = this.makeServerNonce();\n\n                            session.status = \"active\";\n\n                            response = new ActivateSessionResponse({ serverNonce: session.nonce });\n                            channel.send_response(\"MSG\", response, message);\n\n                            const userIdentityTokenPasswordRemoved = (userIdentityToken: any) => {\n                                const a = userIdentityToken.clone();\n                                // remove password\n                                a.password = \"*************\";\n                                return a;\n                            };\n\n                            // send OPCUA Event Notification\n                            // see part 5 : 6.4.3 AuditEventType\n                            //              6.4.7 AuditSessionEventType\n                            //              6.4.10 AuditActivateSessionEventType\n                            assert(session.nodeId); // sessionId\n                            // xx assert(session.channel.clientCertificate instanceof Buffer);\n                            assert(session.sessionTimeout > 0);\n\n                            if (this.isAuditing) {\n                                this.raiseEvent(\"AuditActivateSessionEventType\", {\n                                    /* part 5 -  6.4.3 AuditEventType */\n                                    actionTimeStamp: { dataType: \"DateTime\", value: new Date() },\n                                    status: { dataType: \"Boolean\", value: true },\n\n                                    serverId: { dataType: \"String\", value: \"\" },\n\n                                    // ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.\n                                    clientAuditEntryId: { dataType: \"String\", value: \"\" },\n\n                                    // The ClientUserId identifies the user of the client requesting an action.\n                                    // The ClientUserId can be obtained from the UserIdentityToken passed in the\n                                    // ActivateSession call.\n                                    clientUserId: { dataType: \"String\", value: \"cc\" },\n\n                                    sourceName: { dataType: \"String\", value: \"Session/ActivateSession\" },\n\n                                    /* part 5 - 6.4.7 AuditSessionEventType */\n                                    sessionId: { dataType: \"NodeId\", value: session.nodeId },\n\n                                    /* part 5 - 6.4.10 AuditActivateSessionEventType */\n                                    clientSoftwareCertificates: {\n                                        arrayType: VariantArrayType.Array,\n                                        dataType: \"ExtensionObject\" /* SignedSoftwareCertificate */,\n                                        value: []\n                                    },\n                                    // UserIdentityToken reflects the userIdentityToken parameter of the ActivateSession\n                                    // Service call.\n                                    // For Username/Password tokens the password should NOT be included.\n                                    userIdentityToken: {\n                                        dataType: \"ExtensionObject\" /*  UserIdentityToken */,\n                                        value: userIdentityTokenPasswordRemoved(session.userIdentityToken)\n                                    },\n\n                                    // SecureChannelId shall uniquely identify the SecureChannel. The application shall\n                                    // use the same identifier in all AuditEvents related to the Session Service Set\n                                    // (AuditCreateSessionEventType, AuditActivateSessionEventType and their subtypes) and\n                                    // the SecureChannel Service Set (AuditChannelEventType and its subtypes).\n                                    secureChannelId: { dataType: \"String\", value: session.channel!.channelId!.toString() }\n                                });\n                            }\n                            this.emit(\"session_activated\", session, userIdentityTokenPasswordRemoved);\n                        }\n                    }\n                );\n            }\n        );\n    }\n\n    protected prepare(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request;\n\n        // --- check that session is correct\n        const authenticationToken = request.requestHeader.authenticationToken;\n        const session = this.getSession(authenticationToken, /*activeOnly*/ true);\n        if (!session) {\n            message.session_statusCode = StatusCodes.BadSessionIdInvalid;\n            return;\n        }\n        message.session = session;\n\n        // --- check that provided session matches session attached to channel\n        if (channel.channelId !== session.channelId) {\n            if (!(request instanceof ActivateSessionRequest)) {\n                errorLog(\n                    chalk.red.bgWhite(\n                        \"ERROR: channel.channelId !== session.channelId  on processing request \" + request.constructor.name\n                    ),\n                    channel.channelId,\n                    session.channelId\n                );\n            }\n            message.session_statusCode = StatusCodes.BadSecureChannelIdInvalid;\n        } else if (channel_has_session(channel, session)) {\n            message.session_statusCode = StatusCodes.Good;\n        } else {\n            // session ma y have been moved to a different channel\n            message.session_statusCode = StatusCodes.BadSecureChannelIdInvalid;\n        }\n    }\n\n    /**\n     * ensure that action is performed on a valid session object,\n     * @method _apply_on_SessionObject\n     * @param ResponseClass the constructor of the response Class\n     * @param message\n     * @param channel\n     * @param actionToPerform\n     * @param actionToPerform.session {ServerSession}\n     * @param actionToPerform.sendResponse\n     * @param actionToPerform.sendResponse.response\n     * @param actionToPerform.sendError\n     * @param actionToPerform.sendError.statusCode\n     * @param actionToPerform.sendError.diagnostics\n     *\n     * @private\n     */\n    protected async _apply_on_SessionObject(\n        ResponseClass: ResponseClassType,\n        message: Message,\n        channel: ServerSecureChannelLayer,\n        actionToPerform: (\n            session: ServerSession,\n            sendResponse: (response: Response) => void,\n            sendError: (statusCode: StatusCode) => void\n        ) => void | Promise<void>\n    ): Promise<void> {\n        assert(typeof actionToPerform === \"function\");\n\n        function sendResponse(response1: Response) {\n            try {\n                assert(response1 instanceof ResponseClass || response1 instanceof ServiceFault);\n                if (message.session) {\n                    const counterName = ResponseClass.name.replace(\"Response\", \"\");\n                    message.session.incrementRequestTotalCounter(counterName);\n                }\n                return channel.send_response(\"MSG\", response1, message);\n            } catch (err) {\n                warningLog(err);\n                // istanbul ignore next\n                if (err instanceof Error) {\n                    // istanbul ignore next\n                    errorLog(\n                        \"Internal error in issuing response\\nplease contact support@sterfive.com\",\n                        message.request.toString(),\n                        \"\\n\",\n                        response1.toString()\n                    );\n                }\n                // istanbul ignore next\n                throw err;\n            }\n        }\n\n        function sendError(statusCode: StatusCode) {\n            if (message.session) {\n                message.session.incrementRequestErrorCounter(ResponseClass.name.replace(\"Response\", \"\"));\n            }\n            return g_sendError(channel, message, ResponseClass, statusCode);\n        }\n\n        let response: any;\n        /* istanbul ignore next */\n        if (!message.session || message.session_statusCode !== StatusCodes.Good) {\n            const errMessage = \"INVALID SESSION  !! \";\n            response = new ResponseClass({ responseHeader: { serviceResult: message.session_statusCode } });\n            debugLog(chalk.red.bold(errMessage), chalk.yellow(message.session_statusCode!.toString()), response.constructor.name);\n            return sendResponse(response);\n        }\n\n        assert(message.session_statusCode === StatusCodes.Good);\n\n        // OPC UA Specification 1.02 part 4 page 26\n        // When a  Session  is terminated, all outstanding requests on the  Session  are aborted and\n        // Bad_SessionClosed  StatusCodes  are returned to the  Client. In addition,   the  Server  deletes the entry\n        // for the  Client  from its  SessionDiagnostics Array  Variable  and notifies any other  Clients  who were\n        // subscribed to this entry.\n        if (message.session.status === \"closed\") {\n            // note : use StatusCodes.BadSessionClosed , for pending message for this session\n            return sendError(StatusCodes.BadSessionIdInvalid);\n        }\n\n        if (message.session.status === \"new\") {\n            // mark session as being screwed ! so it cannot be activated anymore\n            message.session.status = \"screwed\";\n\n            return sendError(StatusCodes.BadSessionNotActivated);\n        }\n\n        if (message.session.status !== \"active\") {\n            // mark session as being screwed ! so it cannot be activated anymore\n            message.session.status = \"screwed\";\n\n            // note : use StatusCodes.BadSessionClosed , for pending message for this session\n            return sendError(StatusCodes.BadSessionIdInvalid);\n        }\n\n        // lets also reset the session watchdog so it doesn't\n        // (Sessions are terminated by the Server automatically if the Client fails to issue a Service\n        // request on the Session within the timeout period negotiated by the Server in the\n        // CreateSession Service response. )\n        if (message.session.keepAlive) {\n            assert(typeof message.session.keepAlive === \"function\");\n            message.session.keepAlive();\n        }\n        message.session.incrementTotalRequestCount();\n        await actionToPerform(message.session as ServerSession, sendResponse, sendError);\n    }\n\n    protected async _apply_on_Subscription(\n        ResponseClass: ResponseClassType,\n        message: Message,\n        channel: ServerSecureChannelLayer,\n        actionToPerform: (\n            session: ServerSession,\n            subscription: Subscription,\n            sendResponse: (response: Response) => void,\n            sendError: (statusCode: StatusCode) => void\n        ) => Promise<void>\n    ): Promise<void> {\n        assert(typeof actionToPerform === \"function\");\n        const request = message.request as unknown as { subscriptionId: number };\n        assert(Object.prototype.hasOwnProperty.call(request, \"subscriptionId\"));\n\n        this._apply_on_SessionObject(\n            ResponseClass,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                const subscription = session.getSubscription(request.subscriptionId);\n                if (!subscription) {\n                    return sendError(StatusCodes.BadSubscriptionIdInvalid);\n                }\n                subscription.resetLifeTimeAndKeepAliveCounters();\n                await actionToPerform(session, subscription, sendResponse, sendError);\n            }\n        );\n    }\n\n    protected _apply_on_SubscriptionIds<T>(\n        ResponseClass: typeof SetPublishingModeResponse | typeof TransferSubscriptionsResponse | typeof DeleteSubscriptionsResponse,\n        message: Message,\n        channel: ServerSecureChannelLayer,\n        actionToPerform: (session: ServerSession, subscriptionId: number) => Promise<T>\n    ): void {\n        assert(typeof actionToPerform === \"function\");\n        const request = message.request as unknown as { subscriptionIds: number[] };\n        assert(Object.prototype.hasOwnProperty.call(request, \"subscriptionIds\"));\n\n        this._apply_on_SessionObject(\n            ResponseClass,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                const subscriptionIds = request.subscriptionIds;\n\n                if (!request.subscriptionIds || request.subscriptionIds.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                const results: any[] = subscriptionIds.map((subscriptionId: number) => actionToPerform(session, subscriptionId));\n\n                // resolve potential pending promises ....\n                for (let i = 0; i < results.length; i++) {\n                    if (results[i].then) {\n                        results[i] = await results[i];\n                    }\n                }\n\n                const response = new ResponseClass({\n                    responseHeader: {\n                        serviceResult:\n                            request.subscriptionIds.length > this.engine.serverCapabilities.maxSubscriptionsPerSession\n                                ? StatusCodes.BadTooManyOperations\n                                : StatusCodes.Good\n                    },\n                    results\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _apply_on_Subscriptions(\n        ResponseClass: typeof SetPublishingModeResponse | typeof TransferSubscriptionsResponse | typeof DeleteSubscriptionsResponse,\n        message: Message,\n        channel: ServerSecureChannelLayer,\n        actionToPerform: (session: ServerSession, subscription: Subscription) => Promise<StatusCode>\n    ): void {\n        this._apply_on_SubscriptionIds<StatusCode>(\n            ResponseClass,\n            message,\n            channel,\n            async (session: ServerSession, subscriptionId: number) => {\n                /* istanbul ignore next */\n                if (isSubscriptionIdInvalid(subscriptionId)) {\n                    return StatusCodes.BadSubscriptionIdInvalid;\n                }\n                const subscription = session.getSubscription(subscriptionId);\n                if (!subscription) {\n                    return StatusCodes.BadSubscriptionIdInvalid;\n                }\n                return actionToPerform(session, subscription);\n            }\n        );\n    }\n\n    private async _closeSession(authenticationToken: NodeId, deleteSubscriptions: boolean, reason: ClosingReason): Promise<void> {\n        if (deleteSubscriptions && this.options.onDeleteMonitoredItem) {\n            const session = this.getSession(authenticationToken);\n            if (session) {\n                const subscriptions = session.publishEngine.subscriptions;\n                for (const subscription of subscriptions) {\n                    await subscription.applyOnMonitoredItem(this.options.onDeleteMonitoredItem.bind(null, subscription) as any);\n                }\n            }\n        }\n        await this.engine.closeSession(authenticationToken, deleteSubscriptions, reason);\n    }\n    /**\n     * @method _on_CloseSessionRequest\n     * @param message\n     * @param channel\n     * @private\n     */\n    protected _on_CloseSessionRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as CloseSessionRequest;\n        assert(request instanceof CloseSessionRequest);\n\n        let response;\n\n        message.session_statusCode = StatusCodes.Good;\n\n        function sendError(statusCode: StatusCode) {\n            return g_sendError(channel, message, CloseSessionResponse, statusCode);\n        }\n\n        function sendResponse(response1: CloseSessionResponse) {\n            channel.send_response(\"MSG\", response1, message);\n        }\n\n        // do not use _apply_on_SessionObject\n        // this._apply_on_SessionObject(CloseSessionResponse, message, channel, function (session) {\n        // });\n\n        const session = message.session;\n        if (!session) {\n            return sendError(StatusCodes.BadSessionIdInvalid);\n        }\n\n        // session has been created but not activated !\n        const wasNotActivated = session.status === \"new\";\n\n        (async () => {\n            await this._closeSession(request.requestHeader.authenticationToken, request.deleteSubscriptions, \"CloseSession\");\n\n            // if (false && wasNotActivated) {\n            //  return sendError(StatusCodes.BadSessionNotActivated);\n            // }\n\n            response = new CloseSessionResponse({});\n            sendResponse(response);\n        })();\n    }\n\n    // browse services\n    /**\n     * @method _on_BrowseRequest\n     * @param message\n     * @param channel\n     * @private\n     */\n    protected _on_BrowseRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as BrowseRequest;\n        assert(request instanceof BrowseRequest);\n        const diagnostic: any = {};\n\n        this._apply_on_SessionObject(\n            BrowseResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                let response: BrowseResponse;\n                // test view\n                if (request.view && !request.view.viewId.isEmpty()) {\n                    let theView: UAView | null = this.engine!.addressSpace!.findNode(request.view.viewId) as UAView;\n                    if (theView && theView.nodeClass !== NodeClass.View) {\n                        // Error: theView is not a View\n                        diagnostic.localizedText = { text: \"Expecting a view here\" };\n                        theView = null;\n                    }\n                    if (!theView) {\n                        return sendError(StatusCodes.BadViewIdUnknown);\n                    }\n                }\n\n                if (!request.nodesToBrowse || request.nodesToBrowse.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerBrowse > 0) {\n                    if (request.nodesToBrowse.length > this.engine.serverCapabilities.operationLimits.maxNodesPerBrowse) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                // limit results to requestedMaxReferencesPerNode further so it never exceed a too big number\n                const requestedMaxReferencesPerNode = Math.min(9876, request.requestedMaxReferencesPerNode);\n                assert(request.nodesToBrowse[0].schema.name === \"BrowseDescription\");\n\n                const context = new SessionContext({ session, server: this });\n\n                const f = callbackify(this.engine.browseWithAutomaticExpansion).bind(this.engine);\n                (f as any)(request.nodesToBrowse, context, (err?: Error | null, results?: BrowseResult[]) => {\n                    // istanbul ignore next\n                    if (!results) {\n                        throw new Error(\"internal error : \" + err?.message);\n                    }\n\n                    assert(results[0].schema.name === \"BrowseResult\");\n\n                    // handle continuation point and requestedMaxReferencesPerNode\n                    const maxBrowseContinuationPoints = this.engine.serverCapabilities.maxBrowseContinuationPoints;\n                    results = results.map((result: BrowseResult) => {\n                        assert(!result.continuationPoint);\n\n                        // istanbul ignore next\n                        if (!session.continuationPointManager) {\n                            return new BrowseResult({ statusCode: StatusCodes.BadNoContinuationPoints });\n                        }\n\n                        if (session.continuationPointManager.hasReachedMaximum(maxBrowseContinuationPoints)) {\n                            return new BrowseResult({ statusCode: StatusCodes.BadNoContinuationPoints });\n                        }\n                        const truncatedResult = session.continuationPointManager.registerReferences(\n                            requestedMaxReferencesPerNode,\n                            result.references || [],\n                            { continuationPoint: null }\n                        );\n                        let { statusCode } = truncatedResult;\n                        const { continuationPoint, values } = truncatedResult;\n                        statusCode = result.statusCode;\n                        return new BrowseResult({\n                            statusCode,\n                            continuationPoint,\n                            references: values\n                        });\n                    });\n\n                    response = new BrowseResponse({\n                        diagnosticInfos: undefined,\n                        results\n                    });\n                    sendResponse(response);\n                });\n            }\n        );\n    }\n\n    /**\n     * @method _on_BrowseNextRequest\n     * @param message\n     * @param channel\n     * @private\n     */\n    protected _on_BrowseNextRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as BrowseNextRequest;\n        assert(request instanceof BrowseNextRequest);\n        this._apply_on_SessionObject(\n            BrowseNextResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                if (!request.continuationPoints || request.continuationPoints.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n                const results = request.continuationPoints\n                    .map((continuationPoint: ContinuationPoint, index: number) =>\n                        session.continuationPointManager.getNextReferences(0, {\n                            continuationPoint,\n                            index,\n                            releaseContinuationPoints: request.releaseContinuationPoints\n                        })\n                    )\n                    .map(\n                        (r) =>\n                            <BrowseResultOptions>{\n                                continuationPoint: r.continuationPoint,\n                                references: r.values,\n                                statusCode: r.statusCode\n                            }\n                    );\n\n                const response = new BrowseNextResponse({\n                    diagnosticInfos: undefined,\n                    results\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    // read services\n    protected _on_ReadRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as ReadRequest;\n        assert(request instanceof ReadRequest);\n\n        this._apply_on_SessionObject(\n            ReadResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                const context = new SessionContext({ session, server: this });\n\n                let response;\n\n                let results = [];\n\n                const timestampsToReturn = request.timestampsToReturn;\n\n                if (timestampsToReturn === TimestampsToReturn.Invalid) {\n                    return sendError(StatusCodes.BadTimestampsToReturnInvalid);\n                }\n\n                if (request.maxAge < 0) {\n                    return sendError(StatusCodes.BadMaxAgeInvalid);\n                }\n\n                request.nodesToRead = request.nodesToRead || [];\n\n                if (!request.nodesToRead || request.nodesToRead.length <= 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                assert(request.nodesToRead[0].schema.name === \"ReadValueId\");\n\n                // limit size of nodesToRead array to maxNodesPerRead\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerRead > 0) {\n                    if (request.nodesToRead.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRead) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                // proceed with registered nodes alias resolution\n                for (const nodeToRead of request.nodesToRead) {\n                    nodeToRead.nodeId = session.resolveRegisteredNode(nodeToRead.nodeId);\n                }\n\n                // ask for a refresh of asynchronous variables\n                this.engine.refreshValues(request.nodesToRead, request.maxAge, (err?: Error | null) => {\n                    assert(!err, \" error not handled here , fix me\");\n                    results = this.engine.read(context, request);\n\n                    assert(results[0].schema.name === \"DataValue\");\n                    assert(results.length === request.nodesToRead!.length);\n\n                    response = new ReadResponse({\n                        diagnosticInfos: undefined,\n                        results: undefined\n                    });\n                    // set it here for performance\n                    response.results = results;\n                    assert(response.diagnosticInfos!.length === 0);\n                    sendResponse(response);\n                });\n            }\n        );\n    }\n\n    // read services\n    protected _on_HistoryReadRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as HistoryReadRequest;\n\n        assert(request instanceof HistoryReadRequest);\n\n        this._apply_on_SessionObject(\n            HistoryReadResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statsCode: StatusCode) => void) => {\n                let response;\n\n                const timestampsToReturn = request.timestampsToReturn;\n\n                if (timestampsToReturn === TimestampsToReturn.Invalid) {\n                    return sendError(StatusCodes.BadTimestampsToReturnInvalid);\n                }\n\n                request.nodesToRead = request.nodesToRead || [];\n\n                if (!request.nodesToRead || request.nodesToRead.length <= 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                assert(request.nodesToRead[0].schema.name === \"HistoryReadValueId\");\n\n                // limit size of nodesToRead array to maxNodesPerRead\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerRead > 0) {\n                    if (request.nodesToRead.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRead) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n                // todo : handle\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerHistoryReadData > 0) {\n                    if (request.nodesToRead.length > this.engine.serverCapabilities.operationLimits.maxNodesPerHistoryReadData) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerHistoryReadEvents > 0) {\n                    if (request.nodesToRead.length > this.engine.serverCapabilities.operationLimits.maxNodesPerHistoryReadEvents) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const context = new SessionContext({ session, server: this });\n\n                // ask for a refresh of asynchronous variables\n                this.engine.refreshValues(request.nodesToRead, 0, (err?: Error | null) => {\n                    assert(!err, \" error not handled here , fix me\"); // TODO\n\n                    this.engine.historyRead(context, request, (err1: Error | null, results?: HistoryReadResult[]) => {\n                        if (err1) {\n                            return sendError(StatusCodes.BadHistoryOperationInvalid);\n                        }\n                        if (!results) {\n                            return sendError(StatusCodes.BadHistoryOperationInvalid);\n                        }\n\n                        assert(results[0].schema.name === \"HistoryReadResult\");\n                        assert(results.length === request.nodesToRead!.length);\n\n                        response = new HistoryReadResponse({\n                            diagnosticInfos: undefined,\n                            results\n                        });\n\n                        assert(response.diagnosticInfos!.length === 0);\n                        sendResponse(response);\n                    });\n                });\n            }\n        );\n    }\n\n    /*\n   // write services\n   // OPCUA Specification 1.02 Part 3 : 5.10.4 Write\n   // This Service is used to write values to one or more Attributes of one or more Nodes. For constructed\n   // Attribute values whose elements are indexed, such as an array, this Service allows Clients to write\n   // the entire set of indexed values as a composite, to write individual elements or to write ranges of\n   // elements of the composite.\n   // The values are written to the data source, such as a device, and the Service does not return until it writes\n   // the values or determines that the value cannot be written. In certain cases, the Server will successfully\n   // to an intermediate system or Server, and will not know if the data source was updated properly. In these cases,\n   // the Server should report a success code that indicates that the write was not verified.\n   // In the cases where the Server is able to verify that it has successfully written to the data source,\n   // it reports an unconditional success.\n   */\n    protected _on_WriteRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as WriteRequest;\n        assert(request instanceof WriteRequest);\n        assert(!request.nodesToWrite || Array.isArray(request.nodesToWrite));\n\n        this._apply_on_SessionObject(\n            WriteResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                let response;\n\n                if (!request.nodesToWrite || request.nodesToWrite.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerWrite > 0) {\n                    if (request.nodesToWrite.length > this.engine.serverCapabilities.operationLimits.maxNodesPerWrite) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                // proceed with registered nodes alias resolution\n                for (const nodeToWrite of request.nodesToWrite) {\n                    nodeToWrite.nodeId = session.resolveRegisteredNode(nodeToWrite.nodeId);\n                }\n\n                const context = new SessionContext({ session, server: this });\n\n                assert(request.nodesToWrite[0].schema.name === \"WriteValue\");\n                this.engine.write(context, request.nodesToWrite, (err: Error | null, results?: StatusCode[]) => {\n                    if (err) {\n                        errorLog(err);\n                        return sendError(StatusCodes.BadInternalError);\n                    }\n                    assert(Array.isArray(results));\n                    assert(results!.length === request.nodesToWrite!.length);\n                    response = new WriteResponse({\n                        diagnosticInfos: undefined,\n                        results\n                    });\n                    sendResponse(response);\n                });\n            }\n        );\n    }\n\n    // subscription services\n    protected _on_CreateSubscriptionRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const engine = this.engine;\n        const addressSpace = engine.addressSpace!;\n\n        const request = message.request as CreateSubscriptionRequest;\n        assert(request instanceof CreateSubscriptionRequest);\n\n        this._apply_on_SessionObject(\n            CreateSubscriptionResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                const context = new SessionContext({ session, server: this });\n\n                if (session.currentSubscriptionCount >= this.engine.serverCapabilities.maxSubscriptionsPerSession) {\n                    return sendError(StatusCodes.BadTooManySubscriptions);\n                }\n\n                if (this.currentSubscriptionCount >= this.engine.serverCapabilities.maxSubscriptions) {\n                    return sendError(StatusCodes.BadTooManySubscriptions);\n                }\n\n                const subscription = session.createSubscription(request);\n\n                subscription.on(\"monitoredItem\", (monitoredItem: MonitoredItem) => {\n                    prepareMonitoredItem(context, addressSpace, monitoredItem);\n                });\n\n                const response = new CreateSubscriptionResponse({\n                    revisedLifetimeCount: subscription.lifeTimeCount,\n                    revisedMaxKeepAliveCount: subscription.maxKeepAliveCount,\n                    revisedPublishingInterval: subscription.publishingInterval,\n                    subscriptionId: subscription.id\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_DeleteSubscriptionsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as DeleteSubscriptionsRequest;\n        assert(request instanceof DeleteSubscriptionsRequest);\n        this._apply_on_SubscriptionIds(\n            DeleteSubscriptionsResponse,\n            message,\n            channel,\n            async (session: ServerSession, subscriptionId: number) => {\n                let subscription = this.engine.findOrphanSubscription(subscriptionId);\n                // istanbul ignore next\n                if (subscription) {\n                    warningLog(\"Deleting an orphan subscription\", subscriptionId);\n\n                    await this._beforeDeleteSubscription(subscription);\n                    return this.engine.deleteOrphanSubscription(subscription);\n                }\n\n                subscription = session.getSubscription(subscriptionId);\n                if (subscription) {\n                    await this._beforeDeleteSubscription(subscription);\n                }\n\n                return session.deleteSubscription(subscriptionId);\n            }\n        );\n    }\n\n    protected _on_TransferSubscriptionsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        //\n        // sendInitialValue Boolean\n        //    A Boolean parameter with the following values:\n        //    TRUE      the first Publish response(s) after the TransferSubscriptions call shall\n        //              contain the current values of all Monitored Items in the Subscription where\n        //              the Monitoring Mode is set to Reporting.\n        //    FALSE     the first Publish response after the TransferSubscriptions call shall contain only the value\n        //              changes since the last Publish response was sent.\n        //    This parameter only applies to MonitoredItems used for monitoring Attribute changes.\n        //\n\n        const engine = this.engine;\n\n        const request = message.request as TransferSubscriptionsRequest;\n        assert(request instanceof TransferSubscriptionsRequest);\n        this._apply_on_SubscriptionIds(\n            TransferSubscriptionsResponse,\n            message,\n            channel,\n            async (session: ServerSession, subscriptionId: number) =>\n                await engine.transferSubscription(session, subscriptionId, request.sendInitialValues)\n        );\n    }\n\n    protected _on_CreateMonitoredItemsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const engine = this.engine;\n        const addressSpace = engine.addressSpace!;\n\n        const request = message.request as CreateMonitoredItemsRequest;\n        assert(request instanceof CreateMonitoredItemsRequest);\n\n        this._apply_on_Subscription(\n            CreateMonitoredItemsResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ): Promise<void> => {\n                const timestampsToReturn = request.timestampsToReturn;\n                if (timestampsToReturn === TimestampsToReturn.Invalid) {\n                    return sendError(StatusCodes.BadTimestampsToReturnInvalid);\n                }\n\n                if (!request.itemsToCreate || request.itemsToCreate.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (request.itemsToCreate.length > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const options = this.options as OPCUAServerOptions;\n                let results: MonitoredItemCreateResult[] = [];\n                if (options.onCreateMonitoredItem) {\n                    const resultsPromise = request.itemsToCreate.map(async (monitoredItemCreateRequest) => {\n                        const { monitoredItem, createResult } = subscription.preCreateMonitoredItem(\n                            addressSpace,\n                            timestampsToReturn,\n                            monitoredItemCreateRequest\n                        );\n                        if (monitoredItem) {\n                            await options.onCreateMonitoredItem!(subscription, monitoredItem);\n                            subscription.postCreateMonitoredItem(monitoredItem, monitoredItemCreateRequest, createResult);\n                        }\n                        return createResult;\n                    });\n                    results = await Promise.all(resultsPromise);\n                } else {\n                    results = request.itemsToCreate.map((monitoredItemCreateRequest) => {\n                        const { monitoredItem, createResult } = subscription.preCreateMonitoredItem(\n                            addressSpace,\n                            timestampsToReturn,\n                            monitoredItemCreateRequest\n                        );\n                        if (monitoredItem) {\n                            subscription.postCreateMonitoredItem(monitoredItem, monitoredItemCreateRequest, createResult);\n                        }\n                        return createResult;\n                    });\n                }\n                const response = new CreateMonitoredItemsResponse({\n                    responseHeader: { serviceResult: StatusCodes.Good },\n                    results\n                    // ,diagnosticInfos: []\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_ModifySubscriptionRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as ModifySubscriptionRequest;\n        assert(request instanceof ModifySubscriptionRequest);\n\n        this._apply_on_Subscription(\n            ModifySubscriptionResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: ModifySubscriptionResponse) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                subscription.modify(request);\n\n                const response = new ModifySubscriptionResponse({\n                    revisedLifetimeCount: subscription.lifeTimeCount,\n                    revisedMaxKeepAliveCount: subscription.maxKeepAliveCount,\n                    revisedPublishingInterval: subscription.publishingInterval\n                });\n\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_ModifyMonitoredItemsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as ModifyMonitoredItemsRequest;\n\n        assert(request instanceof ModifyMonitoredItemsRequest);\n        this._apply_on_Subscription(\n            ModifyMonitoredItemsResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: ModifyMonitoredItemsResponse) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                const timestampsToReturn = request.timestampsToReturn;\n                if (timestampsToReturn === TimestampsToReturn.Invalid) {\n                    return sendError(StatusCodes.BadTimestampsToReturnInvalid);\n                }\n\n                if (!request.itemsToModify || request.itemsToModify.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                /* istanbul ignore next */\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (request.itemsToModify.length > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const itemsToModify = request.itemsToModify; // MonitoredItemModifyRequest\n\n                function modifyMonitoredItem(item: MonitoredItemModifyRequest) {\n                    const monitoredItemId = item.monitoredItemId;\n                    const monitoredItem = subscription.getMonitoredItem(monitoredItemId);\n                    if (!monitoredItem) {\n                        return new MonitoredItemModifyResult({ statusCode: StatusCodes.BadMonitoredItemIdInvalid });\n                    }\n\n                    // adjust samplingInterval if === -1\n                    if (item.requestedParameters.samplingInterval === -1) {\n                        item.requestedParameters.samplingInterval = subscription.publishingInterval;\n                    }\n                    return monitoredItem.modify(timestampsToReturn, item.requestedParameters);\n                }\n\n                const results = itemsToModify.map(modifyMonitoredItem);\n\n                const response = new ModifyMonitoredItemsResponse({\n                    results\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_PublishRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as PublishRequest;\n        assert(request instanceof PublishRequest);\n\n        this._apply_on_SessionObject(\n            PublishResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                assert(session);\n                assert(session.publishEngine); // server.publishEngine doesn't exists, OPCUAServer has probably shut down already\n                session.publishEngine._on_PublishRequest(request, (_request1, response) => {\n                    sendResponse(response);\n                });\n            }\n        );\n    }\n\n    protected _on_SetPublishingModeRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as SetPublishingModeRequest;\n        assert(request instanceof SetPublishingModeRequest);\n        const publishingEnabled = request.publishingEnabled;\n        this._apply_on_Subscriptions(\n            SetPublishingModeResponse,\n            message,\n            channel,\n            async (session: ServerSession, subscription: Subscription) => {\n                return subscription.setPublishingMode(publishingEnabled);\n            }\n        );\n    }\n\n    protected _on_DeleteMonitoredItemsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as DeleteMonitoredItemsRequest;\n        assert(request instanceof DeleteMonitoredItemsRequest);\n\n        this._apply_on_Subscription(\n            DeleteMonitoredItemsResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                /* istanbul ignore next */\n                if (!request.monitoredItemIds || request.monitoredItemIds.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                /* istanbul ignore next */\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (request.monitoredItemIds.length > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const resultsPromises = request.monitoredItemIds.map(async (monitoredItemId: number) => {\n                    if (this.options.onDeleteMonitoredItem) {\n                        const monitoredItem = subscription.getMonitoredItem(monitoredItemId);\n                        if (monitoredItem) {\n                            await this.options.onDeleteMonitoredItem(subscription, monitoredItem);\n                        }\n                    }\n                    return subscription.removeMonitoredItem(monitoredItemId);\n                });\n\n                try {\n                    const results = await Promise.all(resultsPromises);\n\n                    const response = new DeleteMonitoredItemsResponse({\n                        diagnosticInfos: undefined,\n                        results\n                    });\n\n                    sendResponse(response);\n                } catch (err) {\n                    warningLog(err);\n                    return sendError(StatusCodes.BadInternalError);\n                }\n            }\n        );\n    }\n    protected _on_SetTriggeringRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as SetTriggeringRequest;\n        assert(request instanceof SetTriggeringRequest);\n\n        this._apply_on_Subscription(\n            SetTriggeringResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                /* */\n                const { triggeringItemId, linksToAdd, linksToRemove } = request;\n\n                /**\n                 * The MaxMonitoredItemsPerCall Property indicates\n                 * [...]\n                 *  \u2022 the maximum size of the sum of the linksToAdd and linksToRemove arrays when a\n                 *    Client calls the SetTriggering Service.\n                 *\n                 */\n                const maxElements = (linksToAdd ? linksToAdd.length : 0) + (linksToRemove ? linksToRemove.length : 0);\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (maxElements > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const { addResults, removeResults, statusCode } = subscription.setTriggering(\n                    triggeringItemId,\n                    linksToAdd,\n                    linksToRemove\n                );\n                if (statusCode !== StatusCodes.Good) {\n                    const response = new ServiceFault({ responseHeader: { serviceResult: statusCode } });\n                    sendResponse(response);\n                } else {\n                    const response = new SetTriggeringResponse({\n                        responseHeader: { serviceResult: statusCode },\n\n                        addResults,\n                        removeResults,\n                        addDiagnosticInfos: null,\n                        removeDiagnosticInfos: null\n                    });\n                    sendResponse(response);\n                }\n            }\n        );\n    }\n\n    protected async _beforeDeleteSubscription(subscription: Subscription): Promise<void> {\n        if (!this.options.onDeleteMonitoredItem) {\n            return;\n        }\n        await subscription.applyOnMonitoredItem(this.options.onDeleteMonitoredItem.bind(null, subscription) as any);\n    }\n    protected _on_RepublishRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as RepublishRequest;\n        assert(request instanceof RepublishRequest);\n\n        this._apply_on_Subscription(\n            RepublishResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                // update diagnostic counter\n                subscription.subscriptionDiagnostics.republishRequestCount += 1;\n                subscription.subscriptionDiagnostics.republishMessageRequestCount += 1;\n\n                const retransmitSequenceNumber = request.retransmitSequenceNumber;\n                const notificationMessage = subscription.getMessageForSequenceNumber(retransmitSequenceNumber);\n\n                if (!notificationMessage) {\n                    return sendError(StatusCodes.BadMessageNotAvailable);\n                }\n                const response = new RepublishResponse({\n                    notificationMessage,\n                    responseHeader: {\n                        serviceResult: StatusCodes.Good\n                    }\n                });\n                // update diagnostic counter\n                subscription.subscriptionDiagnostics.republishMessageCount += 1;\n\n                sendResponse(response);\n            }\n        );\n    }\n\n    // Bad_NothingToDo\n    // Bad_TooManyOperations\n    // Bad_SubscriptionIdInvalid\n    // Bad_MonitoringModeInvalid\n    protected _on_SetMonitoringModeRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as SetMonitoringModeRequest;\n        assert(request instanceof SetMonitoringModeRequest);\n\n        this._apply_on_Subscription(\n            SetMonitoringModeResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                subscription: Subscription,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                /* istanbul ignore next */\n                if (!request.monitoredItemIds || request.monitoredItemIds.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                /* istanbul ignore next */\n                if (this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall > 0) {\n                    if (request.monitoredItemIds.length > this.engine.serverCapabilities.operationLimits.maxMonitoredItemsPerCall) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n                const monitoringMode = request.monitoringMode;\n\n                if (!isMonitoringModeValid(monitoringMode)) {\n                    return sendError(StatusCodes.BadMonitoringModeInvalid);\n                }\n\n                const results = request.monitoredItemIds.map((monitoredItemId) => {\n                    const monitoredItem = subscription.getMonitoredItem(monitoredItemId);\n                    if (!monitoredItem) {\n                        return StatusCodes.BadMonitoredItemIdInvalid;\n                    }\n                    monitoredItem.setMonitoringMode(monitoringMode);\n                    return StatusCodes.Good;\n                });\n\n                const response = new SetMonitoringModeResponse({\n                    results\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    // _on_TranslateBrowsePathsToNodeIds service\n    protected _on_TranslateBrowsePathsToNodeIdsRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as TranslateBrowsePathsToNodeIdsRequest;\n        assert(request instanceof TranslateBrowsePathsToNodeIdsRequest);\n\n        this._apply_on_SessionObject(\n            TranslateBrowsePathsToNodeIdsResponse,\n            message,\n            channel,\n            async (\n                session: ServerSession,\n                sendResponse: (response: Response) => void,\n                sendError: (statusCode: StatusCode) => void\n            ) => {\n                if (!request.browsePaths || request.browsePaths.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerTranslateBrowsePathsToNodeIds > 0) {\n                    if (\n                        request.browsePaths.length >\n                        this.engine.serverCapabilities.operationLimits.maxNodesPerTranslateBrowsePathsToNodeIds\n                    ) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                const browsePathsResults = request.browsePaths.map((browsePath) => this.engine.browsePath(browsePath));\n\n                const response = new TranslateBrowsePathsToNodeIdsResponse({\n                    diagnosticInfos: null,\n                    results: browsePathsResults\n                });\n\n                sendResponse(response);\n            }\n        );\n    }\n\n    // Call Service Result Codes\n    // Symbolic Id Description\n    // Bad_NothingToDo       See Table 165 for the description of this result code.\n    // Bad_TooManyOperations See Table 165 for the description of this result code.\n    //\n    protected _on_CallRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as CallRequest;\n        assert(request instanceof CallRequest);\n\n        this._apply_on_SessionObject(\n            CallResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                let response;\n\n                if (!request.methodsToCall || request.methodsToCall.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                // the MaxNodesPerMethodCall Property indicates the maximum size of the methodsToCall array when\n                // a Client calls the Call Service.\n                let maxNodesPerMethodCall = this.engine.serverCapabilities.operationLimits.maxNodesPerMethodCall;\n                maxNodesPerMethodCall = maxNodesPerMethodCall <= 0 ? 1000 : maxNodesPerMethodCall;\n                if (request.methodsToCall.length > maxNodesPerMethodCall) {\n                    return sendError(StatusCodes.BadTooManyOperations);\n                }\n\n                /* jshint validthis: true */\n                const addressSpace = this.engine.addressSpace!;\n\n                const context = new SessionContext({ session, server: this });\n\n                async.map(\n                    request.methodsToCall,\n                    callMethodHelper.bind(null, context, addressSpace),\n                    (err?: Error | null, results?: (CallMethodResultOptions | undefined)[]) => {\n                        /* istanbul ignore next */\n                        if (err) {\n                            errorLog(\"ERROR in method Call !! \", err);\n                        }\n                        assert(Array.isArray(results));\n                        response = new CallResponse({\n                            results: results as CallMethodResultOptions[]\n                        });\n                        filterDiagnosticInfo(request.requestHeader.returnDiagnostics, response);\n                        sendResponse(response);\n                    }\n                );\n            }\n        );\n    }\n\n    protected _on_RegisterNodesRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as RegisterNodesRequest;\n        assert(request instanceof RegisterNodesRequest);\n\n        this._apply_on_SessionObject(\n            RegisterNodesResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                if (!request.nodesToRegister || request.nodesToRegister.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes > 0) {\n                    if (request.nodesToRegister.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n                // A list of NodeIds which the Client shall use for subsequent access operations. The\n                // size and order of this list matches the size and order of the nodesToRegister\n                // request parameter.\n                // The Server may return the NodeId from the request or a new (an alias) NodeId. It\n                // is recommended that the Server return a numeric NodeIds for aliasing.\n                // In case no optimization is supported for a Node, the Server shall return the\n                // NodeId from the request.\n                const registeredNodeIds = request.nodesToRegister.map((nodeId) => session.registerNode(nodeId));\n\n                const response = new RegisterNodesResponse({\n                    registeredNodeIds\n                });\n                sendResponse(response);\n            }\n        );\n    }\n\n    protected _on_UnregisterNodesRequest(message: Message, channel: ServerSecureChannelLayer): void {\n        const request = message.request as UnregisterNodesRequest;\n        assert(request instanceof UnregisterNodesRequest);\n\n        this._apply_on_SessionObject(\n            UnregisterNodesResponse,\n            message,\n            channel,\n            (session: ServerSession, sendResponse: (response: Response) => void, sendError: (statusCode: StatusCode) => void) => {\n                request.nodesToUnregister = request.nodesToUnregister || [];\n\n                if (!request.nodesToUnregister || request.nodesToUnregister.length === 0) {\n                    return sendError(StatusCodes.BadNothingToDo);\n                }\n\n                if (this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes > 0) {\n                    if (\n                        request.nodesToUnregister.length > this.engine.serverCapabilities.operationLimits.maxNodesPerRegisterNodes\n                    ) {\n                        return sendError(StatusCodes.BadTooManyOperations);\n                    }\n                }\n\n                request.nodesToUnregister.map((nodeId: NodeId) => session.unRegisterNode(nodeId));\n\n                const response = new UnregisterNodesResponse({});\n                sendResponse(response);\n            }\n        );\n    }\n\n    /* istanbul ignore next */\n    protected _on_Cancel(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, CancelResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    // NodeManagement Service Set Overview\n    // This Service Set defines Services to add and delete AddressSpace Nodes and References between them. All added\n    // Nodes continue to exist in the AddressSpace even if the Client that created them disconnects from the Server.\n    //\n    /* istanbul ignore next */\n    protected _on_AddNodes(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, AddNodesResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_AddReferences(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, AddReferencesResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_DeleteNodes(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, DeleteNodesResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_DeleteReferences(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, DeleteReferencesResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    // Query Service\n    /* istanbul ignore next */\n    protected _on_QueryFirst(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, QueryFirstResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_QueryNext(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, QueryNextResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    /* istanbul ignore next */\n    protected _on_HistoryUpdate(message: Message, channel: ServerSecureChannelLayer): void {\n        return g_sendError(channel, message, HistoryUpdateResponse, StatusCodes.BadServiceUnsupported);\n    }\n\n    private createEndpoint(port1: number, serverOptions: OPCUAServerOptions): OPCUAServerEndPoint {\n        // add the tcp/ip endpoint with no security\n        const endPoint = new OPCUAServerEndPoint({\n            port: port1,\n\n            certificateManager: this.serverCertificateManager,\n\n            certificateChain: this.getCertificateChain(),\n            privateKey: this.getPrivateKey(),\n\n            defaultSecureTokenLifetime: serverOptions.defaultSecureTokenLifetime || 600000,\n            timeout: serverOptions.timeout || 3 * 60 * 1000,\n\n            maxConnections: this.maxConnectionsPerEndpoint,\n            objectFactory: this.objectFactory,\n            serverInfo: this.serverInfo\n        });\n        return endPoint;\n    }\n\n    private createEndpointDescriptions(\n        serverOption: OPCUAServerOptions,\n        endpointOptions: OPCUAServerEndpointOptions\n    ): OPCUAServerEndPoint {\n        /* istanbul ignore next */\n        if (!endpointOptions) {\n            throw new Error(\"internal error\");\n        }\n        const hostname = getFullyQualifiedDomainName();\n        endpointOptions.hostname = endpointOptions.hostname || hostname;\n        endpointOptions.port = endpointOptions.port || 26543;\n\n        /* istanbul ignore next */\n        if (\n            !Object.prototype.hasOwnProperty.call(endpointOptions, \"port\") ||\n            !isFinite(endpointOptions.port!) ||\n            typeof endpointOptions.port !== \"number\"\n        ) {\n            throw new Error(\"expecting a valid port (number)\");\n        }\n\n        const port = Number(endpointOptions.port || 0);\n\n        const endPoint = this.createEndpoint(port, serverOption);\n\n        endpointOptions.alternateHostname = endpointOptions.alternateHostname || [];\n        const alternateHostname =\n            endpointOptions.alternateHostname instanceof Array\n                ? endpointOptions.alternateHostname\n                : [endpointOptions.alternateHostname];\n        const allowAnonymous = endpointOptions.allowAnonymous === undefined ? true : !!endpointOptions.allowAnonymous;\n\n        endPoint.addStandardEndpointDescriptions({\n            allowAnonymous,\n            securityModes: endpointOptions.securityModes,\n            securityPolicies: endpointOptions.securityPolicies,\n\n            hostname: endpointOptions.hostname,\n\n            alternateHostname,\n\n            disableDiscovery: !!endpointOptions.disableDiscovery,\n            // xx                hostname,\n            resourcePath: serverOption.resourcePath || \"\"\n        });\n        return endPoint;\n    }\n\n    public async initializeCM(): Promise<void> {\n        await super.initializeCM();\n        await this.userCertificateManager.initialize();\n    }\n}\n\nexport interface RaiseEventAuditEventData extends RaiseEventData {\n    actionTimeStamp: PseudoVariantDateTime;\n    status: PseudoVariantBoolean;\n    serverId: PseudoVariantString;\n    /**\n     * ClientAuditEntryId contains the human-readable AuditEntryId defined in Part 3.\n     */\n    clientAuditEntryId: PseudoVariantString;\n    /**\n     * The ClientUserId identifies the user of the client requesting an action. The ClientUserId can be\n     * obtained from the UserIdentityToken passed in the ActivateSession call.\n     */\n    clientUserId: PseudoVariantString;\n    sourceName: PseudoVariantString;\n}\n\nexport interface RaiseEventAuditUpdateMethodEventData extends RaiseEventAuditEventData {\n    methodId: PseudoVariantNodeId;\n    inputArguments: any;\n}\n\nexport interface RaiseEventAuditConditionCommentEventData extends RaiseEventAuditUpdateMethodEventData {\n    eventId: PseudoVariantByteString;\n    comment: PseudoVariantLocalizedText;\n}\n\nexport interface RaiseEventAuditSessionEventData extends RaiseEventAuditEventData {\n    /**\n     *  part 5 - 6.4.7 AuditSessionEventType\n     */\n    sessionId: PseudoVariantNodeId;\n}\n\nexport interface RaiseEventAuditCreateSessionEventData extends RaiseEventAuditSessionEventData {\n    /**\n     *  part 5 - 6.4.8 AuditCreateSessionEventType\n     *  SecureChannelId shall uniquely identify the SecureChannel.\n     *  The application shall use the same identifier in\n     *  all AuditEvents related to the Session Service Set (AuditCreateSessionEventType, AuditActivateSessionEventType\n     *  and their subtypes) and the SecureChannel Service Set (AuditChannelEventType and its subtype\n     */\n    secureChannelId: PseudoVariantString;\n    revisedSessionTimeout: PseudoVariantDuration;\n    clientCertificate: PseudoVariantByteString;\n    clientCertificateThumbprint: PseudoVariantString;\n}\n\nexport interface RaiseEventAuditActivateSessionEventData extends RaiseEventAuditSessionEventData {\n    /**\n     * part 5 - 6.4.10 AuditActivateSessionEventType\n     */\n    clientSoftwareCertificates: PseudoVariantExtensionObjectArray;\n    /**\n     * UserIdentityToken reflects the userIdentityToken parameter of the ActivateSession Service call.\n     * For Username/Password tokens the password should NOT be included.\n     */\n    userIdentityToken: PseudoVariantExtensionObject;\n    /**\n     * SecureChannelId shall uniquely identify the SecureChannel. The application shall use the same identifier\n     * in all AuditEvents related to the Session Service Set (AuditCreateSessionEventType,\n     * AuditActivateSessionEventType and their subtypes) and the SecureChannel Service Set\n     * (AuditChannelEventType and its subtypes).\n     */\n    secureChannelId: PseudoVariantString;\n}\n\n// tslint:disable:no-empty-interface\nexport interface RaiseEventTransitionEventData extends RaiseEventData {}\n\nexport interface RaiseEventAuditUrlMismatchEventTypeData extends RaiseEventData {\n    endpointUrl: PseudoVariantString;\n}\nexport interface OPCUAServer {\n    /**\n     * @internal\n     * @param eventType\n     * @param options\n     */\n    raiseEvent(eventType: \"AuditSessionEventType\", options: RaiseEventAuditSessionEventData): void;\n\n    raiseEvent(eventType: \"AuditCreateSessionEventType\", options: RaiseEventAuditCreateSessionEventData): void;\n\n    raiseEvent(eventType: \"AuditActivateSessionEventType\", options: RaiseEventAuditActivateSessionEventData): void;\n\n    raiseEvent(eventType: \"AuditCreateSessionEventType\", options: RaiseEventData): void;\n\n    raiseEvent(eventType: \"AuditConditionCommentEventType\", options: RaiseEventAuditConditionCommentEventData): void;\n\n    raiseEvent(eventType: \"AuditUrlMismatchEventType\", options: RaiseEventAuditUrlMismatchEventTypeData): void;\n\n    raiseEvent(eventType: \"TransitionEventType\", options: RaiseEventTransitionEventData): void;\n}\n\nexport interface OPCUAServer extends EventEmitter {\n    on(event: \"create_session\", eventHandler: (session: ServerSession) => void): this;\n\n    on(event: \"session_activated\", eventHandler: (session: ServerSession) => void): this;\n\n    on(event: \"session_closed\", eventHandler: (session: ServerSession, reason: string) => void): this;\n\n    on(event: \"post_initialize\", eventHandler: () => void): this;\n\n    /**\n     * emitted when the server is trying to registered the LDS\n     * but when the connection to the lds has failed\n     * serverRegistrationPending is sent when the backoff signal of the\n     * connection process is raised\n     * @event serverRegistrationPending\n     */\n    on(event: \"serverRegistrationPending\", eventHandler: () => void): this;\n\n    /**\n     * event raised when server  has been successfully registered on the local discovery server\n     * @event serverRegistered\n     */\n    on(event: \"serverRegistered\", eventHandler: () => void): this;\n\n    /**\n     * event raised when server registration has been successfully renewed on the local discovery server\n     * @event serverRegistered\n     */\n    on(event: \"serverRegistrationRenewed\", eventHandler: () => void): this;\n\n    /**\n     * event raised when server  has been successfully unregistered from the local discovery server\n     * @event serverUnregistered\n     */\n    on(event: \"serverUnregistered\", eventHandler: () => void): this;\n\n    /**\n     * event raised after the server has raised an OPCUA event toward a client\n     */\n    on(event: \"event\", eventHandler: (eventData: any) => void): this;\n\n    /**\n     * event raised when the server received a request from one of its connected client.\n     * useful for trace purpose.\n     */\n    on(event: \"request\", eventHandler: (request: Request, channel: ServerSecureChannelLayer) => void): this;\n\n    /**\n     * event raised when the server send an response to a request to one of its connected client.\n     * useful for trace purpose.\n     */\n    on(event: \"response\", eventHandler: (request: Response, channel: ServerSecureChannelLayer) => void): this;\n\n    /**\n     * event raised when a new secure channel is opened\n     */\n    on(event: \"newChannel\", eventHandler: (channel: ServerSecureChannelLayer, endpoint: OPCUAServerEndPoint) => void): this;\n\n    /**\n     * event raised when a new secure channel is closed\n     */\n    on(event: \"closeChannel\", eventHandler: (channel: ServerSecureChannelLayer, endpoint: OPCUAServerEndPoint) => void): this;\n\n    /**\n     * event raised when the server refused a tcp connection from a client. ( for instance because too any connections)\n     */\n    on(event: \"connectionRefused\", eventHandler: (socketData: ISocketData, endpoint: OPCUAServerEndPoint) => void): this;\n\n    /**\n     * event raised when a OpenSecureChannel has failed, it could be a invalid certificate or malformed message\n     */\n    on(\n        event: \"openSecureChannelFailure\",\n        eventHandler: (socketData: ISocketData, channelData: IChannelData, endpoint: OPCUAServerEndPoint) => void\n    ): this;\n\n    on(event: string, eventHandler: (...args: [any?, ...any[]]) => void): this;\n}\n\nconst opts = { multiArgs: false };\nOPCUAServer.prototype.start = thenify.withCallback(OPCUAServer.prototype.start, opts);\nOPCUAServer.prototype.initialize = thenify.withCallback(OPCUAServer.prototype.initialize, opts);\nOPCUAServer.prototype.shutdown = thenify.withCallback(OPCUAServer.prototype.shutdown, opts);\n", "/**\n * @module node-opcua-server\n */\n// tslint:disable:no-console\nimport { EventEmitter } from \"events\";\nimport * as chalk from \"chalk\";\nimport { partition, sortBy } from \"lodash\";\n\nimport { assert } from \"node-opcua-assert\";\nimport { checkDebugFlag, make_debugLog } from \"node-opcua-debug\";\nimport { ObjectRegistry } from \"node-opcua-object-registry\";\nimport { StatusCode, StatusCodes } from \"node-opcua-status-code\";\n\nimport { PublishRequest, PublishResponse, ServiceFault, SubscriptionAcknowledgement } from \"node-opcua-types\";\nimport { Subscription } from \"./server_subscription\";\nimport { SubscriptionState } from \"./server_subscription\";\nimport { IServerSidePublishEngine, INotifMsg, IClosedOrTransferredSubscription } from \"./i_server_side_publish_engine\";\n\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\n\nfunction traceLog(...args: [any?, ...any[]]) {\n    if (!doDebug) {\n        return;\n    }\n    const a: string[] = args.map((x?: any) => x!);\n    a.unshift(chalk.yellow(\" TRACE \"));\n    debugLog(...a);\n}\n\nexport interface ServerSidePublishEngineOptions {\n    maxPublishRequestInQueue?: number;\n}\n\ninterface PublishData {\n    request: PublishRequest;\n    serverTimeWhenReceived: number;\n    results: StatusCode[];\n    callback: (request: PublishRequest, response: PublishResponse | ServiceFault) => void;\n}\n\nfunction _assertValidPublishData(publishData: PublishData) {\n    assert(publishData.request instanceof PublishRequest);\n    assert(typeof publishData.serverTimeWhenReceived === \"number\");\n    assert(Array.isArray(publishData.results));\n    assert(typeof publishData.callback === \"function\");\n}\n\nfunction dummy_function() {\n    /* empty */\n}\n\nfunction addDate(date: Date, delta: number) {\n    return new Date(date.getTime() + delta);\n}\n\nfunction timeout_filter(publishData: PublishData): boolean {\n    const request = publishData.request;\n    const results = publishData.results;\n    if (!request.requestHeader.timeoutHint) {\n        // no limits\n        return false;\n    }\n    const serverTimeWhenReceived = publishData.serverTimeWhenReceived;\n    // remark : do not use request.requestHeader.timestamp! here as this is a client date and server and client clocks might differ\n    const expected_timeout_time = addDate(new Date(serverTimeWhenReceived), request.requestHeader.timeoutHint);\n    return expected_timeout_time.getTime() < Date.now();\n}\n\n/***\n *  a Publish Engine for a given session\n */\nexport class ServerSidePublishEngine extends EventEmitter implements IServerSidePublishEngine {\n    public static registry = new ObjectRegistry();\n\n    /**\n     * @private\n     */\n    public static transferSubscriptionsToOrphan(\n        srcPublishEngine: ServerSidePublishEngine,\n        destPublishEngine: ServerSidePublishEngine\n    ): void {\n        debugLog(\n            chalk.yellow(\n                \"ServerSidePublishEngine#transferSubscriptionsToOrphan! \" + \"start transferring long live subscriptions to orphan\"\n            )\n        );\n\n        for (const subscription of Object.values(srcPublishEngine._subscriptions)) {\n            assert((subscription.publishEngine as any) === srcPublishEngine);\n\n            if (subscription.$session) {\n                subscription.$session._unexposeSubscriptionDiagnostics(subscription);\n            } else {\n                console.warn(\"Warning:  subscription\", subscription.id, \" has no session attached!!!\");\n            }\n\n            ServerSidePublishEngine.transferSubscription(subscription, destPublishEngine, false);\n        }\n        assert(srcPublishEngine.subscriptionCount === 0);\n\n        debugLog(\n            chalk.yellow(\n                \"ServerSidePublishEngine#transferSubscriptionsToOrphan! \" + \"end transferring long lived subscriptions to orphan\"\n            )\n        );\n    }\n\n    /**\n     * @param subscription\n     * @param destPublishEngine\n     * @param sendInitialValues true if initial values should be sent\n     * @private\n     */\n    public static async transferSubscription(\n        subscription: Subscription,\n        destPublishEngine: ServerSidePublishEngine,\n        sendInitialValues: boolean\n    ): Promise<Subscription> {\n        const srcPublishEngine = subscription.publishEngine as any as ServerSidePublishEngine;\n\n        assert(!destPublishEngine.getSubscriptionById(subscription.id));\n        assert(srcPublishEngine.getSubscriptionById(subscription.id));\n\n        // remove pending StatusChangeNotification on the same session that may exist already\n        destPublishEngine._purge_dangling_subscription(subscription.id);\n\n        debugLog(chalk.cyan(\"ServerSidePublishEngine.transferSubscription live subscriptionId =\"), subscription.subscriptionId);\n\n        // xx const internalNotification = subscription._flushSentNotifications();\n        debugLog(chalk.cyan(\"ServerSidePublishEngine.transferSubscription with  = \"), subscription.getAvailableSequenceNumbers());\n\n        //  If the Server transfers the Subscription to the new Session, the Server shall issue a\n        //  StatusChangeNotification notificationMessage with the status code Good_SubscriptionTransferred\n        //  to the old Session.\n        subscription.notifyTransfer();\n\n        const tmp = srcPublishEngine.detach_subscription(subscription);\n        destPublishEngine.add_subscription(tmp);\n\n        subscription.resetLifeTimeCounter();\n        if (sendInitialValues) {\n            /*  A Boolean parameter with the following values:\n                TRUE  the first Publish response(s) after the TransferSubscriptions call\n                      shall contain the current values of all Monitored Items in the\n                      Subscription where the Monitoring Mode is set to Reporting.\n                      If a value is queued for a data MonitoredItem, the next value in\n                      the queue is sent in the Publish response. If no value is queued\n                      for a data MonitoredItem, the last value sent is repeated in the\n                      Publish response.\n                FALSE the first Publish response after the TransferSubscriptions call\n                      shall contain only the value changes since the last Publish\n                      response was sent.\n                This parameter only applies to MonitoredItems used for monitoring Attribute\n                changes\n            */\n            debugLog(\"Resending initial values\");\n            await subscription.resendInitialValues();\n        }\n\n        assert(destPublishEngine.getSubscriptionById(subscription.id));\n        assert(!srcPublishEngine.getSubscriptionById(subscription.id));\n\n        return subscription;\n    }\n\n    public maxPublishRequestInQueue = 0;\n    public isSessionClosed = false;\n\n    private _publish_request_queue: PublishData[] = [];\n    private _subscriptions: { [key: string]: Subscription };\n    private _closed_subscriptions: IClosedOrTransferredSubscription[] = [];\n\n    constructor(options?: ServerSidePublishEngineOptions) {\n        super();\n\n        options = options || {};\n\n        ServerSidePublishEngine.registry.register(this);\n\n        // a queue of pending publish request send by the client\n        // waiting to be used by the server to send notification\n        this._publish_request_queue = []; // { request :/*PublishRequest*/{},\n\n        this._subscriptions = {};\n\n        // _closed_subscriptions contains a collection of Subscription that\n        // have  expired but that still need to send some pending notification\n        // to the client.\n        // Once publish requests will be received from the  client\n        // the notifications of those subscriptions will be processed so that\n        // they can be properly disposed.\n        this._closed_subscriptions = [];\n\n        this.maxPublishRequestInQueue = options.maxPublishRequestInQueue || 100;\n\n        this.isSessionClosed = false;\n    }\n\n    public toString(): string {\n        let str = \"\";\n        str += `maxPublishRequestInQueue ${this.maxPublishRequestInQueue}\\n`;\n        str += `subscriptions ${Object.keys(this._subscriptions).join()}\\n`;\n        str += `closed subscriptions ${this._closed_subscriptions.map((s) => s.id).join()}\\n`;\n        return str;\n    }\n    public dispose(): void {\n        debugLog(\"ServerSidePublishEngine#dispose\");\n\n        assert(Object.keys(this._subscriptions).length === 0, \"self._subscriptions count!=0\");\n        this._subscriptions = {};\n\n        assert(this._closed_subscriptions.length === 0, \"self._closed_subscriptions count!=0\");\n        this._closed_subscriptions = [];\n\n        ServerSidePublishEngine.registry.unregister(this);\n    }\n\n    public process_subscriptionAcknowledgements(subscriptionAcknowledgements: SubscriptionAcknowledgement[]): StatusCode[] {\n        // process acknowledgements\n        subscriptionAcknowledgements = subscriptionAcknowledgements || [];\n        debugLog(\"process_subscriptionAcknowledgements = \", subscriptionAcknowledgements);\n        const results = subscriptionAcknowledgements.map((subscriptionAcknowledgement: SubscriptionAcknowledgement) => {\n            const subscription = this.getSubscriptionById(subscriptionAcknowledgement.subscriptionId);\n            if (!subscription) {\n                // // try to find the session\n                // const transferredSubscription = this._transferred_subscriptions.find(\n                //   (s) => s.subscriptionId === subscriptionAcknowledgement.subscriptionId\n                // );\n                // if (transferredSubscription) {\n                //   debugLog(\"Subscription acknowledgeNotification done in transferred subscription \");\n                //   return transferredSubscription.acknowledgeNotification(subscriptionAcknowledgement.sequenceNumber);\n                // }\n                return StatusCodes.BadSubscriptionIdInvalid;\n            }\n            return subscription.acknowledgeNotification(subscriptionAcknowledgement.sequenceNumber);\n        });\n\n        return results;\n    }\n\n    /**\n     * get a array of subscription handled by the publish engine.\n     */\n    public get subscriptions(): Subscription[] {\n        return Object.values(this._subscriptions);\n    }\n\n    /**\n     */\n    public add_subscription(subscription: Subscription): Subscription {\n        assert(subscription instanceof Subscription);\n        assert(isFinite(subscription.id));\n        subscription.publishEngine = (subscription.publishEngine || this) as any;\n        assert((subscription.publishEngine as any) === this);\n        assert(!this._subscriptions[subscription.id]);\n\n        debugLog(\"ServerSidePublishEngine#add_subscription -  adding subscription with Id:\", subscription.id);\n        this._subscriptions[subscription.id] = subscription;\n        // xx subscription._flushSentNotifications();\n        return subscription;\n    }\n\n    public detach_subscription(subscription: Subscription): Subscription {\n        assert(subscription instanceof Subscription);\n        assert(isFinite(subscription.id));\n        assert((subscription.publishEngine as any) === this);\n        assert(this._subscriptions[subscription.id] === subscription);\n\n        delete this._subscriptions[subscription.id];\n        subscription.publishEngine = null as any;\n        debugLog(\"ServerSidePublishEngine#detach_subscription detaching subscription with Id:\", subscription.id);\n        return subscription;\n    }\n\n    /**\n     */\n    public shutdown(): void {\n        if (this.subscriptionCount !== 0) {\n            debugLog(chalk.red(\"Shutting down pending subscription\"));\n            this.subscriptions.map((subscription: Subscription) => subscription.terminate());\n        }\n\n        assert(this.subscriptionCount === 0, \"subscription shall be removed first before you can shutdown a publish engine\");\n\n        debugLog(\"ServerSidePublishEngine#shutdown\");\n\n        // purge _publish_request_queue\n        this._publish_request_queue = [];\n\n        // purge self._closed_subscriptions\n        this._closed_subscriptions.map((subscription) => subscription.dispose());\n        this._closed_subscriptions = [];\n    }\n\n    /**\n     * number of pending PublishRequest available in queue\n     */\n    public get pendingPublishRequestCount(): number {\n        return this._publish_request_queue.length;\n    }\n\n    /**\n     * number of subscriptions\n     */\n    public get subscriptionCount(): number {\n        return Object.keys(this._subscriptions).length;\n    }\n\n    public get pendingClosedSubscriptionCount(): number {\n        return this._closed_subscriptions.length;\n    }\n\n    public get currentMonitoredItemCount(): number {\n        const subscriptions = Object.values(this._subscriptions);\n        const result = subscriptions.reduce((cumul: number, subscription: Subscription) => {\n            return cumul + subscription.monitoredItemCount;\n        }, 0);\n        assert(isFinite(result));\n        return result;\n    }\n\n    public _purge_dangling_subscription(subscriptionId: number): void {\n        this._closed_subscriptions = this._closed_subscriptions.filter((s) => s.id !== subscriptionId);\n    }\n\n    public on_close_subscription(subscription: IClosedOrTransferredSubscription): void {\n        doDebug && debugLog(\"ServerSidePublishEngine#on_close_subscription\", subscription.id);\n        if (subscription.hasPendingNotifications) {\n            doDebug &&\n                debugLog(\n                    \"ServerSidePublishEngine#on_close_subscription storing subscription\",\n                    subscription.id,\n                    \" to _closed_subscriptions because it has pending notification\"\n                );\n            this._closed_subscriptions.push(subscription);\n        } else {\n            doDebug && debugLog(\"ServerSidePublishEngine#on_close_subscription disposing subscription\", subscription.id);\n            // subscription is no longer needed\n            subscription.dispose();\n        }\n\n        delete this._subscriptions[subscription.id];\n\n        while (this._feed_closed_subscription()) {\n            /* keep looping */\n        }\n        if (this.subscriptionCount === 0 && this._closed_subscriptions.length === 0) {\n            this.cancelPendingPublishRequest();\n        }\n    }\n\n    /**\n     * retrieve a subscription by id.\n     * @param subscriptionId\n     * @return Subscription\n     */\n    public getSubscriptionById(subscriptionId: number | string): Subscription {\n        return this._subscriptions[subscriptionId.toString()];\n    }\n\n    public findLateSubscriptions(): Subscription[] {\n        const subscriptions = Object.values(this._subscriptions);\n        return subscriptions.filter((subscription: Subscription) => {\n            return (subscription.state === SubscriptionState.LATE || !subscription.messageSent) && subscription.publishingEnabled;\n        });\n    }\n\n    public get hasLateSubscriptions(): boolean {\n        return this.findLateSubscriptions().length > 0;\n    }\n\n    public findLateSubscriptionsSortedByAge(): Subscription[] {\n        let late_subscriptions = this.findLateSubscriptions();\n        late_subscriptions = sortBy(late_subscriptions, \"timeToExpiration\");\n\n        return late_subscriptions;\n    }\n\n    public cancelPendingPublishRequestBeforeChannelChange(): void {\n        this._cancelPendingPublishRequest(StatusCodes.BadSecureChannelClosed);\n    }\n\n    public onSessionClose(): void {\n        this.isSessionClosed = true;\n        this._cancelPendingPublishRequest(StatusCodes.BadSessionClosed);\n    }\n\n    /**\n     * @private\n     */\n    public cancelPendingPublishRequest(): void {\n        assert(this.subscriptionCount === 0);\n        this._cancelPendingPublishRequest(StatusCodes.BadNoSubscription);\n    }\n\n    /**\n     *\n     * @param request\n     * @param callback\n     * @private\n     * @internal\n     */\n    public _on_PublishRequest(\n        request: PublishRequest,\n        callback?: (request1: PublishRequest, response: PublishResponse| ServiceFault) => void\n    ): void {\n        callback = callback || dummy_function;\n        assert(typeof callback === \"function\");\n\n        // istanbul ignore next\n        if (!(request instanceof PublishRequest)) {\n            throw new Error(\"Internal error : expecting a Publish Request here\");\n        }\n\n        const subscriptionAckResults = this.process_subscriptionAcknowledgements(request.subscriptionAcknowledgements || []);\n\n        const currentTime = Date.now();\n        const publishData: PublishData = {\n            callback,\n            request,\n            results: subscriptionAckResults,\n            serverTimeWhenReceived: currentTime\n        };\n\n        if (this.isSessionClosed) {\n            traceLog(\"server has received a PublishRequest but session is Closed\");\n            this._send_error_for_request(publishData, StatusCodes.BadSessionClosed);\n        } else if (this.subscriptionCount === 0) {\n            if (this._closed_subscriptions.length > 0 && this._closed_subscriptions[0].hasPendingNotifications) {\n                const verif = this._publish_request_queue.length;\n                // add the publish request to the queue for later processing\n                this._publish_request_queue.push(publishData);\n\n                const processed = this._feed_closed_subscription();\n                //xx ( may be subscription has expired by themselves) assert(verif === this._publish_request_queue.length);\n                //xx  ( may be subscription has expired by themselves) assert(processed);\n                return;\n            }\n            traceLog(\"server has received a PublishRequest but has no subscription opened\");\n            this._send_error_for_request(publishData, StatusCodes.BadNoSubscription);\n        } else {\n            // add the publish request to the queue for later processing\n            this._publish_request_queue.push(publishData);\n            assert(this.pendingPublishRequestCount > 0);\n\n            debugLog(chalk.bgWhite.red(\"Adding a PublishRequest to the queue \"), this._publish_request_queue.length);\n\n            this._feed_closed_subscription();\n\n            this._feed_late_subscription();\n\n            this._handle_too_many_requests();\n        }\n    }\n\n    private _find_starving_subscription(): Subscription | null {\n        const late_subscriptions = this.findLateSubscriptions();\n        function compare_subscriptions(s1: Subscription, s2: Subscription): number {\n            if (s1.priority === s2.priority) {\n                return s1.timeToExpiration < s2.timeToExpiration ? 1 : 0;\n            }\n            return s1.priority > s2.priority ? 1 : 0;\n        }\n        function findLateSubscriptionSortedByPriority() {\n            if (late_subscriptions.length === 0) {\n                return null;\n            }\n            late_subscriptions.sort(compare_subscriptions);\n\n            // istanbul ignore next\n            if (doDebug) {\n                debugLog(\n                    late_subscriptions\n                        .map(\n                            (s: Subscription) =>\n                                \"[ id = \" +\n                                s.id +\n                                \" prio=\" +\n                                s.priority +\n                                \" t=\" +\n                                s.timeToExpiration +\n                                \" ka=\" +\n                                s.timeToKeepAlive +\n                                \" m?=\" +\n                                s.hasUncollectedMonitoredItemNotifications +\n                                \" \" +\n                                SubscriptionState[s.state] +\n                                \" \" +\n                                s.messageSent +\n                                \"]\"\n                        )\n                        .join(\" \\n\")\n                );\n            }\n            return late_subscriptions[late_subscriptions.length - 1];\n        }\n\n        if (this._closed_subscriptions) {\n            /** */\n        }\n        const starving_subscription = /* this.findSubscriptionWaitingForFirstPublish() || */ findLateSubscriptionSortedByPriority();\n        return starving_subscription;\n    }\n\n    private _feed_late_subscription() {\n        setImmediate(() => {\n            if (!this.pendingPublishRequestCount) {\n                return;\n            }\n            const starving_subscription = this._find_starving_subscription();\n            if (starving_subscription) {\n                doDebug &&\n                    debugLog(chalk.bgWhite.red(\"feeding most late subscription subscriptionId  = \"), starving_subscription.id);\n                starving_subscription.process_subscription();\n            }\n        });\n    }\n\n    private _feed_closed_subscription() {\n        if (!this.pendingPublishRequestCount) {\n            return false;\n        }\n\n        if (this._closed_subscriptions.length === 0) {\n            debugLog(\"ServerSidePublishEngine#_feed_closed_subscription  -> nothing to do\");\n            return false;\n        }\n        // process closed subscription\n        const closed_subscription = this._closed_subscriptions[0]!;\n        assert(closed_subscription.hasPendingNotifications);\n        debugLog(\"ServerSidePublishEngine#_feed_closed_subscription for closed_subscription \", closed_subscription.id);\n        closed_subscription?._publish_pending_notifications();\n        if (!closed_subscription?.hasPendingNotifications) {\n            closed_subscription.dispose();\n            this._closed_subscriptions.shift();\n        }\n        return true;\n    }\n\n    private _send_error_for_request(publishData: PublishData, statusCode: StatusCode): void {\n        _assertValidPublishData(publishData);\n        const response = new ServiceFault({\n            responseHeader: { serviceResult: statusCode }\n        });\n        this._send_response_for_request(publishData, response);\n    }\n\n    private _cancelPendingPublishRequest(statusCode: StatusCode): void {\n        if (this._publish_request_queue) {\n            debugLog(\n                chalk.red(\"Cancelling pending PublishRequest with statusCode  \"),\n                statusCode.toString(),\n                \" length =\",\n                this._publish_request_queue.length\n            );\n        } else {\n            debugLog(chalk.red(\"No pending PublishRequest to cancel\"));\n        }\n\n        for (const publishData of this._publish_request_queue) {\n            this._send_error_for_request(publishData, statusCode);\n        }\n        this._publish_request_queue = [];\n    }\n\n    private _handle_too_many_requests() {\n        if (this.pendingPublishRequestCount > this.maxPublishRequestInQueue) {\n            traceLog(\n                \"server has received too many PublishRequest\",\n                this.pendingPublishRequestCount,\n                \"/\",\n                this.maxPublishRequestInQueue\n            );\n            assert(this.pendingPublishRequestCount === this.maxPublishRequestInQueue + 1);\n            // When a Server receives a new Publish request that exceeds its limit it shall de-queue the oldest Publish\n            // request and return a response with the result set to Bad_TooManyPublishRequests.\n\n            // dequeue oldest request\n            const publishData = this._publish_request_queue.shift()!;\n            this._send_error_for_request(publishData, StatusCodes.BadTooManyPublishRequests);\n        }\n    }\n\n    /**\n     * call by a subscription when no notification message is available after the keep alive delay has\n     * expired.\n     *\n     * @method send_keep_alive_response\n     * @param subscriptionId\n     * @param future_sequence_number\n     * @return true if a publish response has been sent\n     */\n    public send_keep_alive_response(subscriptionId: number, future_sequence_number: number): boolean {\n        //  this keep-alive Message informs the Client that the Subscription is still active.\n        //  Each keep-alive Message is a response to a Publish request in which the  notification Message\n        //  parameter does not contain any Notifications and that contains the sequence number of the next\n        //  Notification Message that is to be sent.\n\n        const subscription = this.getSubscriptionById(subscriptionId);\n        /* istanbul ignore next */\n        if (!subscription) {\n            traceLog(\"send_keep_alive_response  => invalid subscriptionId = \", subscriptionId);\n            return false;\n        }\n        // let check if we have available PublishRequest to send the keep alive\n        if (this.pendingPublishRequestCount === 0 || subscription.hasPendingNotifications) {\n            // we cannot send the keep alive PublishResponse\n            traceLog(\n                \"send_keep_alive_response  => cannot send keep-alive  (no PublishRequest left) subscriptionId = \",\n                subscriptionId\n            );\n            return false;\n        }\n        debugLog(\n            `Sending keep alive response for subscription id ${subscription.id} ${subscription.publishingInterval} ${subscription.maxKeepAliveCount}`\n        );\n        this._send_response(\n            subscription,\n            new PublishResponse({\n                availableSequenceNumbers: subscription.getAvailableSequenceNumbers(),\n                moreNotifications: false,\n                notificationMessage: {\n                    sequenceNumber: future_sequence_number\n                },\n                subscriptionId\n            })\n        );\n        return true;\n    }\n    public _send_response(subscription: Subscription, response: PublishResponse): void {\n        assert(this.pendingPublishRequestCount > 0);\n        assert(response.subscriptionId !== 0xffffff);\n        const publishData = this._publish_request_queue.shift()!;\n        this._send_valid_response_for_request(publishData, response);\n    }\n\n    public _on_tick(): void {\n        this._cancelTimeoutRequests();\n    }\n\n    private _cancelTimeoutRequests(): void {\n        if (this._publish_request_queue.length === 0) {\n            return;\n        }\n\n        // filter out timeout requests\n        const parts = partition(this._publish_request_queue, timeout_filter);\n\n        this._publish_request_queue = parts[1]; // still valid\n\n        const invalid_published_request = parts[0];\n        for (const publishData of invalid_published_request) {\n            if (doDebug) {\n                debugLog(chalk.cyan(\" CANCELING TIMEOUT PUBLISH REQUEST \"));\n            }\n            this._send_error_for_request(publishData, StatusCodes.BadTimeout);\n        }\n    }\n    public _send_response_for_request(publishData: PublishData, response: PublishResponse | ServiceFault): void {\n        response.responseHeader.requestHandle = publishData.request.requestHeader.requestHandle;\n        publishData.callback(publishData.request, response);\n    }\n    public _send_valid_response_for_request(publishData: PublishData, response: PublishResponse): void {\n        if (doDebug) {\n            debugLog(\"_send_response_for_request \", response.toString());\n        }\n        _assertValidPublishData(publishData);\n        // xx assert(response.responseHeader.requestHandle !== 0,\"expecting a valid requestHandle\");\n        response.results = publishData.results;\n        this._send_response_for_request(publishData, response);\n    }\n}\n", "\"use strict\";\nconst should = require(\"should\");\nconst sinon = require(\"sinon\");\n\nconst { MonitoringMode, PublishRequest } = require(\"node-opcua-service-subscription\");\nconst { StatusCodes, StatusCode } = require(\"node-opcua-status-code\");\nconst { TimestampsToReturn } = require(\"node-opcua-service-read\");\nconst { MonitoredItemCreateRequest } = require(\"node-opcua-service-subscription\");\nconst { ServiceFault } = require(\"node-opcua-types\");\n\nconst { get_mini_nodeset_filename } = require(\"node-opcua-address-space/testHelpers\");\n\nconst { ServerEngine, SubscriptionState } = require(\"..\");\nconst { with_fake_timer } = require(\"./helper_with_fake_timer\");\n\nconst mini_nodeset_filename = get_mini_nodeset_filename();\n\n// eslint-disable-next-line import/order\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\ndescribe(\"ServerEngine Subscriptions service\", function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const test = this;\n\n    /**\n     * @type {ServerEngine}\n     */\n    let engine;\n    /**\n     * @type {ServerSession}\n     */\n    let session;\n    /**\n     * @type {NodeId}\n     */\n    let FolderTypeId, BaseDataVariableTypeId;\n\n    beforeEach(function (done) {\n        engine = new ServerEngine();\n        engine.initialize({ nodeset_filename: mini_nodeset_filename }, function () {\n            FolderTypeId = engine.addressSpace.findNode(\"FolderType\").nodeId;\n            BaseDataVariableTypeId = engine.addressSpace.findNode(\"BaseDataVariableType\").nodeId;\n            done();\n        });\n    });\n\n    afterEach(async () => {\n        session = null;\n        should.exist(engine);\n        await engine.shutdown();\n        engine = null;\n    });\n\n    it(\"should return an error when trying to delete an non-existing subscription\", async () => {\n        session = engine.createSession();\n        const statusCode = await session.deleteSubscription(-6789);\n        statusCode.should.eql(StatusCodes.BadSubscriptionIdInvalid);\n    });\n\n    it(\"should check the subscription live cycle\", async () => {\n        session = engine.createSession();\n        session.currentSubscriptionCount.should.equal(0);\n        session.cumulatedSubscriptionCount.should.equal(0);\n\n        const subscription = session.createSubscription({\n            requestedPublishingInterval: 1000, // Duration\n            requestedLifetimeCount: 10, // Counter\n            requestedMaxKeepAliveCount: 10, // Counter\n            maxNotificationsPerPublish: 10, // Counter\n            publishingEnabled: true, // Boolean\n            priority: 14 // Byte\n        });\n        subscription.monitoredItemCount.should.eql(0);\n\n        session.currentSubscriptionCount.should.equal(1);\n        session.cumulatedSubscriptionCount.should.equal(1);\n\n        session.getSubscription(subscription.id).should.equal(subscription);\n\n        const statusCode = await session.deleteSubscription(subscription.id);\n        statusCode.should.eql(StatusCodes.Good);\n\n        session.currentSubscriptionCount.should.equal(0);\n        session.cumulatedSubscriptionCount.should.equal(1);\n\n        engine.currentSubscriptionCount.should.equal(0);\n        engine.cumulatedSubscriptionCount.should.equal(1);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"XCX session should emit a new_subscription and subscription_terminated event\", async () => {\n        session = engine.createSession();\n\n        session.currentSubscriptionCount.should.equal(0);\n        session.cumulatedSubscriptionCount.should.equal(0);\n\n        const spyNew = sinon.spy();\n        const spyTerminated = sinon.spy();\n\n        session.on(\"new_subscription\", spyNew);\n        session.on(\"subscription_terminated\", spyTerminated);\n\n        const subscription = session.createSubscription({\n            requestedPublishingInterval: 1000, // Duration\n            requestedLifetimeCount: 10, // Counter\n            requestedMaxKeepAliveCount: 10, // Counter\n            maxNotificationsPerPublish: 10, // Counter\n            publishingEnabled: true, // Boolean\n            priority: 14 // Byte\n        });\n\n        session.currentSubscriptionCount.should.equal(1);\n        session.cumulatedSubscriptionCount.should.equal(1);\n\n        spyNew.callCount.should.eql(1);\n        spyTerminated.callCount.should.eql(0);\n\n        const statusCode = await session.deleteSubscription(subscription.id);\n        statusCode.should.be.instanceOf(StatusCode);\n\n        spyNew.callCount.should.eql(1);\n        spyTerminated.callCount.should.eql(1);\n\n        session.removeListener(\"new_subscription\", spyNew);\n        session.removeListener(\"subscription_terminated\", spyTerminated);\n\n        session.currentSubscriptionCount.should.equal(0);\n        session.cumulatedSubscriptionCount.should.equal(1);\n    });\n\n    it(\"should maintain the correct number of cumulatedSubscriptionCount at the engine level\", async () => {\n        session = engine.createSession();\n        const subscription_parameters = {\n            requestedPublishingInterval: 1000, // Duration\n            requestedLifetimeCount: 10, // Counter\n            requestedMaxKeepAliveCount: 10, // Counter\n            maxNotificationsPerPublish: 10, // Counter\n            publishingEnabled: true, // Boolean\n            priority: 14 // Byte\n        };\n\n        engine.currentSubscriptionCount.should.equal(0);\n        engine.cumulatedSubscriptionCount.should.equal(0);\n\n        engine.currentSessionCount.should.equal(1);\n        engine.cumulatedSessionCount.should.equal(1);\n\n        const subscription1 = session.createSubscription(subscription_parameters);\n\n        engine.currentSubscriptionCount.should.equal(1);\n        engine.cumulatedSubscriptionCount.should.equal(1);\n\n        const subscription2 = session.createSubscription(subscription_parameters);\n        engine.currentSubscriptionCount.should.equal(2);\n        engine.cumulatedSubscriptionCount.should.equal(2);\n\n        await session.deleteSubscription(subscription2.id);\n        engine.currentSubscriptionCount.should.equal(1);\n        engine.cumulatedSubscriptionCount.should.equal(2);\n\n        // Create a new session\n        const session2 = engine.createSession();\n        engine.currentSessionCount.should.equal(2);\n        engine.cumulatedSessionCount.should.equal(2);\n        engine.currentSubscriptionCount.should.equal(1);\n\n        const subscription1_2 = session2.createSubscription(subscription_parameters);\n        const subscription2_2 = session2.createSubscription(subscription_parameters);\n        const subscription3_2 = session2.createSubscription(subscription_parameters);\n\n        engine.currentSubscriptionCount.should.equal(4);\n        engine.cumulatedSubscriptionCount.should.equal(5);\n\n        // close the session, asking to delete subscriptions\n        await engine.closeSession(session2.authenticationToken, /* deleteSubscriptions */ true);\n\n        engine.currentSessionCount.should.equal(1);\n        engine.cumulatedSessionCount.should.equal(2);\n        engine.currentSubscriptionCount.should.equal(1);\n        engine.cumulatedSubscriptionCount.should.equal(5);\n\n        await session.deleteSubscription(subscription1.id);\n\n        engine.currentSubscriptionCount.should.equal(0);\n        engine.cumulatedSubscriptionCount.should.equal(5);\n    });\n\n    it(\"DDD delete a subscription with 2 outstanding PublishRequest\", async () => {\n        session = engine.createSession();\n\n        // CTT : deleteSub5106004\n        const subscription_parameters = {\n            requestedPublishingInterval: 1000, // Duration\n            requestedLifetimeCount: 10, // Counter\n            requestedMaxKeepAliveCount: 10, // Counter\n            maxNotificationsPerPublish: 10, // Counter\n            publishingEnabled: true, // Boolean\n            priority: 14 // Byte\n        };\n\n        const subscription1 = session.createSubscription(subscription_parameters);\n\n        const publishSpy = sinon.spy();\n        const o1 = { requestHeader: { requestHandle: 100 } };\n        session.publishEngine._on_PublishRequest(new PublishRequest(o1), publishSpy);\n        const o2 = { requestHeader: { requestHandle: 101 } };\n        session.publishEngine._on_PublishRequest(new PublishRequest(o2), publishSpy);\n\n        publishSpy.callCount.should.eql(0);\n\n        await session.deleteSubscription(subscription1.id);\n        // after subscription has been deleted, the 2 outstanding publish request shall\n        // be completed\n        publishSpy.callCount.should.eql(2);\n        //xx console.log(publishSpy.getCall(0).args[0].toString());\n        //xx console.log(publishSpy.getCall(0).args[1].toString());\n        publishSpy.getCall(0).args[1].responseHeader.requestHandle.should.eql(100);\n        publishSpy.getCall(1).args[1].responseHeader.requestHandle.should.eql(101);\n        publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n        publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n    });\n\n    it(\"ZDZ-1 create and terminate 2 subscriptions , with 4 publish requests\", async () => {\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({ sessionTimeout: 100000000 });\n\n            // CTT : deleteSub5106004\n            const subscription_parameters = {\n                requestedPublishingInterval: 1000, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 10, // Counter\n                maxNotificationsPerPublish: 10, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription1 = session.createSubscription(subscription_parameters);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription1.publishingInterval);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n            subscription1.messageSent.should.eql(false);\n\n            await session.deleteSubscription(subscription1.id);\n            subscription1.state.should.eql(SubscriptionState.CLOSED);\n\n            const subscription2 = session.createSubscription(subscription_parameters);\n            subscription2.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription2.publishingInterval * subscription2.maxKeepAliveCount);\n            subscription2.state.should.eql(SubscriptionState.LATE);\n\n            const publishSpy = sinon.spy();\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 100 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 101 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 102 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 103 } }), publishSpy);\n\n            test.clock.tick(subscription2.publishingInterval);\n            subscription2.state.should.eql(SubscriptionState.KEEPALIVE);\n\n            await session.deleteSubscription(subscription2.id);\n            subscription2.state.should.eql(SubscriptionState.CLOSED);\n\n            publishSpy.callCount.should.eql(4);\n\n            publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(0).args[1].subscriptionId.should.eql(subscription2.id);\n            publishSpy.getCall(0).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n\n            await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n        });\n    });\n\n    it(\"ZDZ-2 LifetimeCount, the publish engine shall send a StatusChangeNotification to inform that a subscription has been closed because of lifetime timeout - with 2 subscriptions\", async () => {\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({\n                sessionTimeout: 100000000\n            });\n\n            // CTT : deleteSub5106004\n            const subscription_parameters = {\n                requestedPublishingInterval: 1000, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 10, // Counter\n                maxNotificationsPerPublish: 10, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription1 = session.createSubscription(subscription_parameters);\n            //xx console.log(\"subscription1\", subscription1.subscriptionId);\n            subscription1.publishingInterval.should.eql(1000);\n            subscription1.maxKeepAliveCount.should.eql(10);\n            subscription1.lifeTimeCount.should.eql(60);\n\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription1.publishingInterval);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription1.publishingInterval * subscription1.maxKeepAliveCount);\n            subscription1.state.should.eql(SubscriptionState.LATE);\n\n            // wait until subscription expires entirely\n            test.clock.tick(\n                subscription1.publishingInterval * subscription1.maxKeepAliveCount\n            );\n            subscription1.state.should.eql(SubscriptionState.LATE);\n\n            test.clock.tick(subscription1.publishingInterval * subscription1.lifeTimeCount);\n            subscription1.state.should.eql(SubscriptionState.CLOSED);\n\n            const subscription2 = session.createSubscription(subscription_parameters);\n            //xx console.log(\"subscription2\", subscription2.subscriptionId);\n            subscription2.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription2.publishingInterval * subscription2.maxKeepAliveCount);\n            subscription2.state.should.eql(SubscriptionState.LATE);\n\n            const publishSpy = sinon.spy();\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 101 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 102 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 103 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 104 } }), publishSpy);\n\n            test.clock.tick(subscription2.publishingInterval); //  * subscription2.maxKeepAliveCount);\n\n            await session.deleteSubscription(subscription2.id);\n            test.clock.tick(subscription2.publishingInterval);\n\n            publishSpy.callCount.should.eql(4);\n            // console.log(publishSpy.getCall(0).args[1].toString());\n            // console.log(publishSpy.getCall(1).args[1].toString());\n            // console.log(publishSpy.getCall(2).args[1].toString());\n            // console.log(publishSpy.getCall(3).args[1].toString());\n\n            publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(0).args[1].subscriptionId.should.eql(subscription1.id);\n            publishSpy.getCall(0).args[1].notificationMessage.notificationData[0].status.should.eql(StatusCodes.BadTimeout);\n\n            publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(1).args[1].subscriptionId.should.eql(subscription2.id);\n            publishSpy.getCall(1).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            publishSpy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n\n            await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n        });\n    });\n\n    it(\"AZQ should receive StatusChangeNotification from first subscription even if publishRequest arrives late\", async () => {\n        // given a subscription with monitored Item\n        // given that the client doesn't send Publish Request\n        // When the subscription times out and closed\n        // And  When the client send a PublishRequest notification\n        // Then the client shall receive the StatusChangeNotification\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({ sessionTimeout: 100000000 });\n\n            // CTT : deleteSub5106004\n            const subscription_parameters = {\n                requestedPublishingInterval: 1000, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 10, // Counter\n                maxNotificationsPerPublish: 10, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription1 = session.createSubscription(subscription_parameters);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            // wait until session expired by being late\n            test.clock.tick(subscription1.publishingInterval * subscription1.maxKeepAliveCount);\n            test.clock.tick(subscription1.publishingInterval * subscription1.lifeTimeCount);\n\n            subscription1.state.should.eql(SubscriptionState.CLOSED);\n            subscription1.messageSent.should.eql(false);\n\n            const publishSpy = sinon.spy();\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 101 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 102 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 103 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 104 } }), publishSpy);\n\n            test.clock.tick(subscription1.publishingInterval * 2);\n\n            publishSpy.getCall(0).args[1].subscriptionId.should.eql(subscription1.subscriptionId);\n            publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(0).args[1].notificationMessage.sequenceNumber.should.eql(1);\n            publishSpy\n                .getCall(0)\n                .args[1].notificationMessage.notificationData[0].constructor.name.should.eql(\"StatusChangeNotification\");\n            publishSpy.getCall(0).args[1].notificationMessage.notificationData[0].status.should.eql(StatusCodes.BadTimeout);\n\n            publishSpy.callCount.should.eql(4);\n\n            publishSpy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(1).args[1].should.be.instanceOf(ServiceFault);\n            // publishSpy.getCall(1).args[1].subscriptionId.should.eql(0xffffffff);\n            // publishSpy.getCall(1).args[1].notificationMessage.sequenceNumber.should.eql(0);\n            // publishSpy.getCall(1).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            publishSpy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(2).args[1].should.be.instanceOf(ServiceFault);\n            // publishSpy.getCall(2).args[1].subscriptionId.should.eql(0xffffffff);\n            // publishSpy.getCall(2).args[1].notificationMessage.sequenceNumber.should.eql(0);\n            // publishSpy.getCall(2).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            publishSpy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n            publishSpy.getCall(3).args[1].should.be.instanceOf(ServiceFault);\n            // publishSpy.getCall(3).args[1].subscriptionId.should.eql(0xffffffff);\n            // publishSpy.getCall(3).args[1].notificationMessage.sequenceNumber.should.eql(0);\n            // publishSpy.getCall(3).args[1].notificationMessage.notificationData.length.should.eql(0);\n\n            await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n        });\n    });\n\n    it(\"AZW1 should receive StatusChangeNotification from first subscription even if publishRequest arrives late\", async () => {\n        // given a subscription with monitored Item\n        // given that the client doesn't send Publish Request\n        // When the subscription times out and closed\n        // And  When the client send a PublishRequest notification\n        // Then the client shall receive the StatusChangeNotification\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({ sessionTimeout: 100000000 });\n\n            // CTT : deleteSub5106004\n            const subscription_parameters = {\n                requestedPublishingInterval: 1000, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 10, // Counter\n                maxNotificationsPerPublish: 10, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription1 = session.createSubscription(subscription_parameters);\n            subscription1.state.should.eql(SubscriptionState.CREATING);\n\n            // wait until session expired by being late\n            test.clock.tick(subscription1.publishingInterval * subscription1.maxKeepAliveCount);\n\n            // wait until session expired by timeout\n            test.clock.tick(subscription1.publishingInterval * subscription1.lifeTimeCount);\n\n            const subscription2 = session.createSubscription(subscription_parameters);\n            subscription2.state.should.eql(SubscriptionState.CREATING);\n\n            const publishSpy = sinon.spy();\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 101 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 102 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 103 } }), publishSpy);\n            session.publishEngine._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 104 } }), publishSpy);\n\n            publishSpy.callCount.should.eql(1);\n            publishSpy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n            publishSpy.getCall(0).args[1].notificationMessage.sequenceNumber.should.eql(1);\n            publishSpy\n                .getCall(0)\n                .args[1].notificationMessage.notificationData[0].constructor.name.should.eql(\"StatusChangeNotification\");\n            publishSpy.getCall(0).args[1].notificationMessage.notificationData[0].status.should.eql(StatusCodes.BadTimeout);\n\n            await engine.closeSession(session.authenticationToken, true, \"CloseSession\");\n        });\n    });\n\n    it(\"AZW2 should terminate a orphan subscription containing monitored items\", async () => {\n        // given a client session\n        // given a subscription with monitored Item\n        // given that the client close the session without deleting the subscription\n        // When the orphan subscription times out\n        // Then subscription shall be disposed\n\n        await with_fake_timer.call(test, async () => {\n            session = engine.createSession({ sessionTimeout: 100000000 });\n\n            const subscription_parameters = {\n                requestedPublishingInterval: 100, // Duration\n                requestedLifetimeCount: 60, // Counter\n                requestedMaxKeepAliveCount: 30, // Counter\n                maxNotificationsPerPublish: 1000, // Counter\n                publishingEnabled: true, // Boolean\n                priority: 14 // Byte\n            };\n\n            const subscription = session.createSubscription(subscription_parameters);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            subscription.on(\"monitoredItem\", function (monitoredItem) {\n                monitoredItem.samplingFunc = function () {\n                    /** */\n                };\n            });\n\n            const monitoredItemCreateRequest = new MonitoredItemCreateRequest({\n                itemToMonitor: { nodeId: \"ns=0;i=2258\" },\n                monitoringMode: MonitoringMode.Reporting,\n                requestedParameters: {\n                    clientHandle: 123,\n                    queueSize: 10,\n                    samplingInterval: 100\n                }\n            });\n\n            const createResult = subscription.createMonitoredItem(\n                engine.addressSpace,\n                TimestampsToReturn.Both,\n                monitoredItemCreateRequest\n            );\n            createResult.statusCode.should.eql(StatusCodes.Good);\n\n            const deleteSubscriptions = false;\n            engine.closeSession(session.authenticationToken, deleteSubscriptions, \"CloseSession\");\n\n            // wait until session expired by being late\n            test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n            // wait until subscription expired by timeout\n            test.clock.tick(subscription.publishingInterval * subscription.lifeTimeCount);\n        });\n    });\n});\n", "/* eslint-disable import/order */\n/**\n *\n *  OPCUA protocol defines a long-pooling mechanism for sending server-triggered events back to the client.\n *  Therefore the Publish service behalves slightly differently from other OPCUA services:\n *    - the client will send Publish requests to the server without expecting an immediate answer from the server.\n *    - The server will block the request until some subscriptions have some available data, or a time out\n *\n *\n *    - the Publish Request message is also used by the client to acknowledge processing of notification messages\n *\n *\n *    A good algorithm for a client is to send more publish request than live subscription.\n *\n *   - Publish Request are not tied to a particular subscription, the Server will use the oldest pending\n *     client Publish request to send some notification regarding the notifying subscription.\n *\n * preventing queue overflow\n * -------------------------\n *  - if the client send too many publish requests that the server can queue, the server may return a Service result\n *    of BadTooManyPublishRequests.\n *\n * Keep alive mechanism:\n * ---------------------\n *    Publish Request/Response are also use as a keep alive signal between the server and the client.\n *    Every publish request  is a live ping from the client to the server.\n *    Every publish response is a live ping from the server to the client.\n *\n *    If no notification are available after the keep-alive timeout interval, the server shall return an empty\n *    PublishResponse and therefore notifies the client about a valid connection.\n *    Similarly, the client shall send Publish Request\n *\n *\n */\n\nimport * as sinon from \"sinon\";\nimport * as should from \"should\";\nimport { property } from \"underscore\";\n\nimport { PublishRequest } from \"node-opcua-service-subscription\";\nimport { StatusCodes } from \"node-opcua-status-code\";\nimport { ServerSidePublishEngine, Subscription, SubscriptionState } from \"..\";\n\n// tslint:disable-next-line: no-var-requires\nconst { add_mock_monitored_item } = require(\"./helper\");\n\n// tslint:disable-next-line: no-var-requires\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\ndescribe(\"Testing the server publish engine\", function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const test = this;\n\n    beforeEach(() => {\n        test.clock = sinon.useFakeTimers();\n    });\n\n    afterEach(() => {\n        test.clock.restore();\n    });\n    function flushPending() {\n        test.clock.tick(0);\n    }\n    it(\"ZDZ-3 a server should send keep alive notifications\", () => {\n        function pulse(nbInterval: number) {\n            for (let i = 0; i < nbInterval; i++) {\n                test.clock.tick(subscription.publishingInterval);\n            }\n        }\n\n        const publish_server = new ServerSidePublishEngine({});\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10, maxMonitoredItemsPerSubscription: 10 }\n        });\n\n        publish_server.add_subscription(subscription);\n        subscription.state.should.equal(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        subscription.state.should.equal(SubscriptionState.LATE);\n\n        // client sends a PublishRequest to the server\n        const fakeRequest1 = new PublishRequest({ subscriptionAcknowledgements: [] });\n        publish_server._on_PublishRequest(fakeRequest1);\n        flushPending();\n\n        // publish request should be consumed immediately as subscription is late.\n        publish_server.pendingPublishRequestCount.should.equal(0);\n        subscription.state.should.equal(SubscriptionState.KEEPALIVE);\n\n        const fakeRequest2 = new PublishRequest({ subscriptionAcknowledgements: [] });\n        publish_server._on_PublishRequest(fakeRequest2);\n        flushPending();\n\n        publish_server.pendingPublishRequestCount.should.equal(1);\n\n        pulse(19);\n        publish_server.pendingPublishRequestCount.should.equal(1);\n        subscription.state.should.equal(SubscriptionState.KEEPALIVE);\n\n        pulse(5);\n        publish_server.pendingPublishRequestCount.should.equal(0);\n        subscription.state.should.equal(SubscriptionState.KEEPALIVE);\n\n        pulse(20);\n        publish_server.pendingPublishRequestCount.should.equal(0);\n        subscription.state.should.equal(SubscriptionState.LATE);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-4 a server should feed the availableSequenceNumbers in PublishResponse with sequence numbers that have not been acknowledged by the client\", () => {\n        const serverSidePublishEngine = new ServerSidePublishEngine({});\n        const send_response_for_request_spy = sinon.spy(serverSidePublishEngine, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: serverSidePublishEngine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        serverSidePublishEngine.add_subscription(subscription);\n        subscription.state.should.equal(SubscriptionState.CREATING);\n        send_response_for_request_spy.callCount.should.equal(0);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // client sends a PublishRequest to the server\n        const fakeRequest1 = new PublishRequest({ subscriptionAcknowledgements: [] });\n        serverSidePublishEngine._on_PublishRequest(fakeRequest1);\n\n        test.clock.tick(subscription.publishingInterval);\n        send_response_for_request_spy.callCount.should.equal(1); // initial still\n\n        test.clock.tick(subscription.publishingInterval * 1.2);\n\n        // server should send a response for the first publish request with the above notification\n        // in this response, there should be  one element in the availableSequenceNumbers.\n        send_response_for_request_spy.callCount.should.equal(1);\n\n        // console.log( send_response_for_request_spy.getCall(0).args[1].toString());\n\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].subscriptionId.should.eql(1234);\n        send_response_for_request_spy.getCall(0).args[1].availableSequenceNumbers!.should.eql([1]);\n\n        // client sends a PublishRequest to the server ( with no acknowledgement)\n        const fakeRequest2 = new PublishRequest({ subscriptionAcknowledgements: [] });\n        serverSidePublishEngine._on_PublishRequest(fakeRequest2);\n        flushPending();\n\n        // server has now some notification ready and send them to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        send_response_for_request_spy.callCount.should.equal(1);\n\n        test.clock.tick(subscription.publishingInterval);\n\n        // server should send an response for the second publish request with a notification\n        send_response_for_request_spy.callCount.should.equal(2);\n        send_response_for_request_spy.getCall(1).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(1).args[1].subscriptionId.should.eql(1234);\n        send_response_for_request_spy.getCall(1).args[1].availableSequenceNumbers!.should.eql([1, 2]);\n\n        // send_response_for_request_spy.\n        subscription.terminate();\n        subscription.dispose();\n        serverSidePublishEngine.shutdown();\n        serverSidePublishEngine.dispose();\n    });\n\n    it(\"ZDZ-5 a server should return ServiceFault(BadNoSubscription) as a response for a publish Request if there is no subscription available for this session. \", () => {\n        // create a server - server has no subscription\n        const publish_server = new ServerSidePublishEngine();\n\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        // client sends a PublishRequest to the server\n        const fakeRequest1 = new PublishRequest({\n            subscriptionAcknowledgements: []\n        });\n        publish_server._on_PublishRequest(fakeRequest1);\n        flushPending();\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"ServiceFault\");\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadNoSubscription);\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-6 should be possible to find a subscription by id on a publish_server\", () => {\n        const publish_server = new ServerSidePublishEngine({});\n        publish_server.subscriptionCount.should.equal(0);\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000, // 1 second\n            lifeTimeCount: 100,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        publish_server.subscriptionCount.should.equal(1);\n        publish_server.getSubscriptionById(1234).should.equal(subscription);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.subscriptionCount.should.equal(0);\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-7 should be possible to remove a subscription from a publish_server\", () => {\n        const publish_server = new ServerSidePublishEngine({});\n        publish_server.subscriptionCount.should.equal(0);\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        publish_server.subscriptionCount.should.equal(1);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.subscriptionCount.should.equal(0);\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-8 when the client send too many publish requests that the server can queue, the server returns a Service result of BadTooManyPublishRequests\", () => {\n        // When a Server receives a new Publish request that exceeds its limit it shall de-queue the oldest Publish\n        // request and return a response with the result set to Bad_TooManyPublishRequests.\n\n        const publish_server = new ServerSidePublishEngine({\n            maxPublishRequestInQueue: 5\n        });\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1,\n            publishingInterval: 10000,\n            maxKeepAliveCount: 500,\n            lifeTimeCount: 2000,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n\n        // simulate client sending PublishRequest ,and server doing nothing\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 1 } }));\n        flushPending();\n\n        test.clock.tick(subscription.publishingInterval);\n        send_response_for_request_spy.callCount.should.be.equal(0);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount - 1));\n        send_response_for_request_spy.callCount.should.be.equal(1);\n\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.requestHandle.should.eql(1);\n        send_response_for_request_spy.getCall(0).args[1].results!.should.eql([]);\n\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 2 } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 3 } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 4 } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 5 } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 6 } }));\n        flushPending();\n\n        // en: the straw that broke the camel's back.\n        // cSpell:disable\n        // fr: la goute qui fait d\u00e9border le vase.\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 7 } }));\n        flushPending();\n\n        send_response_for_request_spy.callCount.should.be.equal(2);\n\n        // xx console.log(send_response_for_request_spy.getCall(0).args[1].responseHeader.toString());\n        // xx console.log(send_response_for_request_spy.getCall(1).args[1].responseHeader.toString());\n\n        send_response_for_request_spy.getCall(1).args[1].schema.name.should.equal(\"ServiceFault\");\n        send_response_for_request_spy\n            .getCall(1)\n            .args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTooManyPublishRequests);\n        send_response_for_request_spy.getCall(1).args[1].responseHeader.requestHandle.should.eql(2);\n       \n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { requestHandle: 8 } }));\n        flushPending();\n\n        send_response_for_request_spy.callCount.should.be.equal(3);\n        // xx console.log(send_response_for_request_spy.getCall(2).args[1].responseHeader.toString());\n        send_response_for_request_spy.getCall(2).args[1].schema.name.should.equal(\"ServiceFault\");\n        send_response_for_request_spy\n            .getCall(2)\n            .args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTooManyPublishRequests);\n        send_response_for_request_spy.getCall(2).args[1].responseHeader.requestHandle.should.eql(3);\n    \n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    // eslint-disable-next-line max-statements\n    it(\"ZDZ-9 the server shall process the client acknowledge sequence number\", () => {\n        const publish_server = new ServerSidePublishEngine();\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // --------------------------------\n        publish_server._on_PublishRequest(new PublishRequest());\n        flushPending();\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n\n        subscription.getAvailableSequenceNumbers().should.eql([1]);\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(0).args[1].results!.should.eql([]);\n\n        // --------------------------------\n        publish_server._on_PublishRequest(new PublishRequest());\n        flushPending();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n\n        subscription.getAvailableSequenceNumbers().should.eql([1, 2]);\n\n        send_response_for_request_spy.callCount.should.equal(2);\n        send_response_for_request_spy.getCall(1).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(1).args[1].results!.should.eql([]);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        flushPending();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.getAvailableSequenceNumbers().should.eql([1, 2, 3]);\n\n        send_response_for_request_spy.callCount.should.equal(3);\n        send_response_for_request_spy.getCall(2).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(2).args[1].results!.should.eql([]);\n\n        publish_server._on_PublishRequest(\n            new PublishRequest({\n                subscriptionAcknowledgements: [{ subscriptionId: 1234, sequenceNumber: 2 }]\n            })\n        );\n        flushPending();\n\n        subscription.getAvailableSequenceNumbers().should.eql([1, 3, 4]);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        send_response_for_request_spy.callCount.should.equal(4);\n        send_response_for_request_spy.getCall(3).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(3).args[1].results!.should.eql([StatusCodes.Good]);\n\n        publish_server._on_PublishRequest(\n            new PublishRequest({\n                subscriptionAcknowledgements: [\n                    { subscriptionId: 1234, sequenceNumber: 1 },\n                    { subscriptionId: 1234, sequenceNumber: 3 }\n                ]\n            })\n        );\n        flushPending();\n\n        subscription.getAvailableSequenceNumbers().should.eql([4, 5]);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n\n        send_response_for_request_spy.callCount.should.equal(5);\n        send_response_for_request_spy.getCall(4).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(4).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(4).args[1].results!.should.eql([StatusCodes.Good, StatusCodes.Good]);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-A the server shall return BadSequenceNumberInvalid if the client attempts to acknowledge a notification that is not in the queue\", () => {\n        const publishServer = new ServerSidePublishEngine();\n        const send_response_for_request_spy = sinon.spy(publishServer, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: publishServer,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publishServer.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // simulate a client sending a PublishRequest to the server\n        // that acknowledge on a wrong sequenceNumber\n        publishServer._on_PublishRequest(\n            new PublishRequest({\n                subscriptionAcknowledgements: [\n                    {\n                        subscriptionId: 1234,\n                        sequenceNumber: 36 // <<< INVALID SEQUENCE NUMBER\n                    }\n                ]\n            })\n        );\n        flushPending();\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval * 1.2);\n\n        subscription.getAvailableSequenceNumbers().should.eql([1]);\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        send_response_for_request_spy.getCall(0).args[1].schema.name.should.equal(\"PublishResponse\");\n        send_response_for_request_spy.getCall(0).args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.getCall(0).args[1].results!.should.eql([StatusCodes.BadSequenceNumberUnknown]);\n\n        subscription.terminate();\n        subscription.dispose();\n        publishServer.shutdown();\n        publishServer.dispose();\n    });\n\n    it(\"ZDZ-B     a subscription shall send a keep-alive message at the end of the first publishing interval, if there are no Notifications ready.\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const send_keep_alive_response_spy = sinon.spy(publish_server, \"send_keep_alive_response\");\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 4,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n\n        // make sure we have at least 5 PublishRequest in queue\n        publish_server.maxPublishRequestInQueue.should.be.greaterThan(5);\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n\n        // Immediately  a keep Alive message shall be send\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n        subscription.publishIntervalCount.should.eql(subscription.maxKeepAliveCount);\n        send_keep_alive_response_spy.callCount.should.equal(1);\n        send_response_for_request_spy.callCount.should.eql(1);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.publishIntervalCount.should.eql(subscription.maxKeepAliveCount+1);\n        send_keep_alive_response_spy.callCount.should.equal(1);\n        send_response_for_request_spy.callCount.should.eql(1);\n\n        // after maxKeepAliveCount * publishingCycle a second keep Alive message shall be send\n        test.clock.tick(subscription.publishingInterval * 20);\n\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n        subscription.publishIntervalCount.should.eql(subscription.maxKeepAliveCount*2+1);\n        send_keep_alive_response_spy.callCount.should.equal(2);\n        send_response_for_request_spy.callCount.should.eql(2);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-C a Normal subscription that receives a notification shall wait for the next publish interval to send a PublishResponse \", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const send_keep_alive_response_spy = sinon.spy(publish_server, \"send_keep_alive_response\");\n        const send_notification_message_spy = sinon.spy(publish_server, \"_send_response\");\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 4,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            maxNotificationsPerPublish: 0, // no limits,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // make sure we have at least 5 PublishRequest in queue\n        publish_server.maxPublishRequestInQueue.should.be.greaterThan(5);\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n\n        test.clock.tick(2);\n        publish_server.pendingPublishRequestCount.should.eql(4);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n        subscription.publishIntervalCount.should.eql(1);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.publishIntervalCount.should.eql(2);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        send_keep_alive_response_spy.callCount.should.eql(0);\n        send_notification_message_spy.callCount.should.eql(1);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-D the subscription state shall be set to LATE, if it cannot process a notification after Publish Interval has been raised, due to a lack of PublishRequest\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        publish_server.maxPublishRequestInQueue.should.be.greaterThan(5);\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.equal(SubscriptionState.LATE);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval * 1.2);\n\n        subscription.state.should.equal(SubscriptionState.LATE);\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-E a subscription should provide its time to expiration so that publish engine could sort late subscriptions by order of priority\", () => {\n        const publish_server = new ServerSidePublishEngine();\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 2,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        subscription.lifeTimeCount.should.eql(60);\n        subscription.timeToExpiration.should.eql(1000 * 60);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.timeToExpiration.should.eql(1000 * 60);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.timeToExpiration.should.eql(1000 * 59);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.timeToExpiration.should.eql(1000 * 58);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        subscription.terminate();\n        subscription.dispose();\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    // eslint-disable-next-line max-statements\n    it(\"ZDZ-F a publish engine should be able to find out which are the most urgent late subscriptions to serve \", () => {\n        const publish_server = new ServerSidePublishEngine();\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        const subscription1 = new Subscription({\n            id: 1,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 20,\n            publishingEnabled: true,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription1.publishingInterval.should.eql(1000);\n        subscription1.lifeTimeCount.should.eql(60);\n        subscription1.maxKeepAliveCount.should.eql(20);\n\n        publish_server.add_subscription(subscription1);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n        publish_server._on_PublishRequest(new PublishRequest());\n\n        const subscription2 = new Subscription({\n            id: 2,\n            publishingInterval: 100,\n            lifeTimeCount: 120,\n            maxKeepAliveCount: 20,\n            publishingEnabled: true,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription2.publishingInterval.should.eql(100);\n        subscription2.lifeTimeCount.should.eql(120);\n        subscription2.maxKeepAliveCount.should.eql(20);\n        publish_server.add_subscription(subscription2);\n\n        const subscription3 = new Subscription({\n            id: 3,\n            publishingInterval: 100,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            publishingEnabled: true,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription3.publishingInterval.should.eql(100); // !! Note that publishingInterval has been clamped in constructor\n        subscription3.lifeTimeCount.should.eql(1000);\n        subscription3.maxKeepAliveCount.should.eql(20);\n\n        publish_server.add_subscription(subscription3);\n\n        const monitoredItem1 = add_mock_monitored_item(subscription1);\n        const monitoredItem2 = add_mock_monitored_item(subscription2);\n        const monitoredItem3 = add_mock_monitored_item(subscription3);\n\n        subscription1.lifeTimeCount.should.eql(60);\n        subscription2.lifeTimeCount.should.eql(120);\n        subscription3.lifeTimeCount.should.eql(1000);\n\n        subscription1.timeToExpiration.should.eql(1000 * 60  );\n        subscription2.timeToExpiration.should.eql(100  * 120 );\n        subscription3.timeToExpiration.should.eql(100  * 1000);\n\n        // add some notification we want to process\n        monitoredItem1.simulateMonitoredItemAddingNotification();\n        monitoredItem2.simulateMonitoredItemAddingNotification();\n        monitoredItem3.simulateMonitoredItemAddingNotification();\n\n        // let move in time so that subscriptions starts\n        test.clock.tick(\n            Math.max(subscription1.publishingInterval, subscription2.publishingInterval, subscription3.publishingInterval)\n        );\n\n        subscription1.state.should.eql(SubscriptionState.NORMAL);\n        subscription2.state.should.eql(SubscriptionState.NORMAL);\n        subscription3.state.should.eql(SubscriptionState.NORMAL);\n\n        publish_server.findLateSubscriptionsSortedByAge().should.eql([]);\n\n        // let move in time so that all subscriptions get late (without expiring)\n        test.clock.tick(\n            Math.min(subscription1.timeToExpiration, subscription2.timeToExpiration, subscription3.timeToExpiration) - 10\n        );\n       \n        subscription1.state.should.eql(SubscriptionState.NORMAL);\n        subscription2.state.should.eql(SubscriptionState.LATE);\n        subscription3.state.should.eql(SubscriptionState.LATE);\n\n        publish_server.findLateSubscriptionsSortedByAge().map(property(\"id\")).should.eql([2, 3]);\n\n        test.clock.tick(1000 * 20);\n        subscription1.state.should.eql(SubscriptionState.LATE);\n        subscription2.state.should.eql(SubscriptionState.CLOSED);\n        subscription3.state.should.eql(SubscriptionState.LATE);\n\n        publish_server.findLateSubscriptionsSortedByAge().map(property(\"id\")).should.eql([1, 3]);\n\n        subscription1.terminate();\n        subscription1.dispose();\n\n        subscription2.terminate();\n        subscription2.dispose();\n\n        subscription3.terminate();\n        subscription3.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-G a LATE subscription that receives a notification shall send a PublishResponse immediately, without waiting for next publish interval\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.equal(SubscriptionState.LATE);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval * 1.2);\n\n        subscription.state.should.equal(SubscriptionState.LATE);\n        publish_server.pendingPublishRequestCount.should.eql(0, \" No PublishRequest in queue\");\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        test.clock.tick(0);\n\n        publish_server.pendingPublishRequestCount.should.eql(\n            0,\n            \"starving subscription should have consumed this Request immediately\"\n        );\n\n        subscription.state.should.equal(SubscriptionState.NORMAL);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-H LifetimeCount, the server shall terminated the subscription if it has not received any PublishRequest after LifeTimeCount cycles\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        // given a subscription\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 0,\n            maxKeepAliveCount: 4,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.maxKeepAliveCount.should.eql(4);\n        subscription.lifeTimeCount.should.eql(12); // should be adjusted\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        test.clock.tick(subscription.publishingInterval);\n        subscription.publishIntervalCount.should.eql(1);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        publish_server._on_PublishRequest(new PublishRequest());\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        subscription.publishIntervalCount.should.eql(1 + subscription.maxKeepAliveCount);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        // server send a notification to the client\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.publishIntervalCount.should.eql(6);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        test.clock.tick(subscription.publishingInterval * subscription.lifeTimeCount + 20);\n        subscription.publishIntervalCount.should.eql(subscription.lifeTimeCount + 6);\n        subscription.state.should.eql(SubscriptionState.CLOSED);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-I LifeTimeCount, the publish engine shall send a StatusChangeNotification to inform that a subscription has been closed because of lifetime timeout \", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 60,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        publish_server.add_subscription(subscription);\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        test.clock.tick(subscription.publishingInterval * subscription.lifeTimeCount + 20);\n        subscription.state.should.eql(SubscriptionState.CLOSED);\n\n        publish_server.pendingClosedSubscriptionCount.should.eql(1);\n\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        // now send a late PublishRequest\n        publish_server._on_PublishRequest(new PublishRequest());\n\n        // we expect this publish request to be immediately consumed\n        publish_server.pendingPublishRequestCount.should.eql(0);\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        send_response_for_request_spy.firstCall.args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        send_response_for_request_spy.firstCall.args[1].subscriptionId.should.eql(1234);\n        send_response_for_request_spy.firstCall.args[1].notificationMessage.notificationData!.length.should.eql(1);\n        (send_response_for_request_spy.firstCall.args[1].notificationMessage.notificationData![0]! as any).status.should.eql(\n            StatusCodes.BadTimeout\n        );\n\n        subscription.state.should.eql(SubscriptionState.CLOSED);\n\n        publish_server.pendingClosedSubscriptionCount.should.eql(0);\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n\n    it(\"ZDZ-J PublishRequest timeout, the publish engine shall return a publish response with serviceResult = BadTimeout when Publish requests have timed out\", () => {\n        const publish_server = new ServerSidePublishEngine();\n\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 4,\n            maxKeepAliveCount: 20,\n            publishEngine: publish_server,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.lifeTimeCount.should.eql(60);\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.publishingInterval.should.eql(1000);\n\n        publish_server.add_subscription(subscription);\n\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.lifeTimeCount.should.eql(60);\n        subscription.state.should.eql(SubscriptionState.CREATING);\n        const send_response_for_request_spy = sinon.spy(publish_server, \"_send_response_for_request\");\n\n        const timeoutHint = subscription.publishingInterval * (subscription.maxKeepAliveCount + 2);\n\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n        publish_server.pendingPublishRequestCount.should.eql(5);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        publish_server.pendingPublishRequestCount.should.eql(4); // one should have been consumed by subscription\n\n        test.clock.tick(subscription.publishingInterval);\n\n        send_response_for_request_spy.callCount.should.equal(1);\n        publish_server.pendingPublishRequestCount.should.eql(4);\n        send_response_for_request_spy.firstCall.args[1].responseHeader.serviceResult.should.eql(StatusCodes.Good);\n        publish_server._on_PublishRequest(new PublishRequest({ requestHeader: { timeoutHint } }));\n\n        test.clock.tick(subscription.publishingInterval * 3);\n        // all remaining 4 publish request must have been detected a timeout now and answered as such.\n        send_response_for_request_spy.callCount.should.equal(5);\n        publish_server.pendingPublishRequestCount.should.eql(1);\n        send_response_for_request_spy.getCall(1).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTimeout);\n        send_response_for_request_spy.getCall(2).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTimeout);\n        send_response_for_request_spy.getCall(3).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTimeout);\n        send_response_for_request_spy.getCall(4).args[1].responseHeader.serviceResult.should.eql(StatusCodes.BadTimeout);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        publish_server.shutdown();\n        publish_server.dispose();\n    });\n});\n", "const { Worker, isMainThread, parentPort, workerData } = require(\"worker_threads\");\nconst readline = require(\"readline\");\nconst os = require(\"os\");\nconst util = require(\"util\");\nconst { assert } = require(\"console\");\n\nconst CPU = process.env.CPU ? parseInt(process.env.CPU, 10) : 0;\n\nconst testWatchDogTimeout = process.env.PING ? parseInt(process.env.PING) : 10 * 60 * 1000;\n\nrequire(\"should\");\n\nconst chalk = require(\"chalk\");\n\nconst Mocha = require(\"mocha\");\nconst yargs = require(\"yargs\");\nconst { Argv } = require(\"yargs\");\n\nfunction durationToString(milliseconds) {\n    const seconds = Math.floor(milliseconds / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 3600);\n    const days = Math.floor(hours / 24);\n    const a = (n) => n.toString().padStart(2, \"0\");\n    const b = (n) => n.toString().padStart(3, \"0\");\n    return `${a(minutes % 60)}:${a(seconds % 60)}.${b(milliseconds % 1000)}`;\n}\n\nconst { extractAllTestFiles, extractPageTest } = require(\"./run_all_mocha_tests.js\");\n\nconst colorWheel = [\n    chalk.red,\n    chalk.green,\n    chalk.yellow,\n    chalk.blue,\n    chalk.magenta,\n    chalk.cyan,\n    chalk.white,\n    chalk.gray,\n    chalk.bgRed,\n    chalk.bgGreen,\n    chalk.bgYellow,\n    chalk.bgBlue,\n    chalk.bgMagenta,\n    chalk.bgCyan,\n    chalk.bgGray\n];\nconst pageCount = 1;\nconst pageSize = 1;\n\nconst TEST_FILE_STARTED = \"TEST_FILE_STARTED\";\nconst TEST_FILE_COMPLETED = \"TEST_FILE_COMPLETED\";\nconst TEST_FILE_COMPILATION_ERROR = \"TEST_FILE_COMPILATION_ERROR\";\nconst runningPages = new Set();\n\nconst failingTestFilename = [];\nconst failingTests = {};\nconst outputFor = {};\n\nconst durationsPerTestFile = {};\nlet testFiles = [];\n\nlet testCounter = 0;\nlet fileStarted = 0;\nlet fileCounter = 0;\nlet fileMax = 0;\nfunction collectDuration(test) {\n    testCounter++;\n    const { file } = test;\n    if (!durationsPerTestFile[file]) {\n        durationsPerTestFile[file] = test.duration || 0;\n    }\n    durationsPerTestFile[file] = durationsPerTestFile[file] + test.duration;\n}\n\nasync function runTest({ page, selectedTests, g }) {\n    function w(n, w) {\n        return n.toString().padStart(w, \" \");\n    }\n    function prefix() {\n        const a = [...runningPages].join(\", \").padEnd(40);\n        // const prefix = colorWheel[page % colorWheel.length](\"page \", page.toString().padEnd(4) + a);\n        const prefix = colorWheel[page % colorWheel.length](\n            `${w(fileCounter, 3)}+${w(fileStarted - fileCounter, 2)}/${w(fileMax, 3)} ${w(testCounter, 4)} -  ${w(\n                Math.ceil((fileCounter / fileMax) * 100),\n                3\n            )}% `\n        );\n        return prefix;\n    }\n    const result = new Promise((resolve, reject) => {\n        runningPages.add(page);\n        const worker = new Worker(__filename /*new URL(import.meta.url)*/, {\n            workerData: { page, selectedTests, g },\n            env: {\n                ...process.env\n            }\n        });\n        worker.on(\"message\", (message) => {\n            const { type, file, test, line } = message;\n            // args && console.log(prefix(), ...args);\n            switch (type) {\n                case \"LOG\":\n                    assert(typeof line === \"string\");\n                    outputFor[file].push(line); //util.format.apply(args));\n                    break;\n                case TEST_FILE_STARTED:\n                    outputFor[file] = outputFor[file] || [];\n                    fileStarted++;\n                    break;\n                case TEST_FILE_COMPLETED:\n                    fileCounter++;\n                    outputFor[file] = [];\n                    break;\n                case TEST_FILE_COMPILATION_ERROR:\n                    break;\n                case EVENT_TEST_BEGIN:\n                    break;\n                case EVENT_TEST_SKIPPED:\n                    collectDuration(test);\n                    break;\n                case EVENT_TEST_FAIL:\n                    {\n                        collectDuration(test);\n                        const { duration, title, file, error, timedOut, state, stats, output, titlePath } = test;\n                        failingTestFilename.push(file.replace(__dirname, \"\"));\n                        failingTests[file] = titlePath;\n\n                        const d = durationToString(duration);\n\n                        console.log(prefix(), d, chalk.red(title)); // JSON.stringify(test, null, \"\"));\n                        console.log(prefix(), file);\n                        console.log(error);\n\n                        console.log(\"-----------------------------------------------------------------------------\");\n                        if (outputFor[file])\n                            for (const l of outputFor[file]) {\n                                console.log(prefix(), chalk.grey(l));\n                            }\n                        console.log(\"-----------------------------------------------------------------------------\");\n                        for (const l of output) {\n                            for (const ll of l.split(\"\\n\")) {\n                                console.log(prefix(), chalk.redBright(ll));\n                            }\n                        }\n                        console.log(\"-----------------------------------------------------------------------------\");\n                        epilogue();\n                        process.exit(1);\n                    }\n                    break;\n                case EVENT_TEST_PASS:\n                    {\n                        collectDuration(test);\n                        const { duration, title, file, error, timedOut, state, stats } = test;\n\n                        if (false && outputFor[file])\n                            for (const l of outputFor[file]) {\n                                console.log(prefix(), chalk.grey(l));\n                            }\n\n                        const d = durationToString(duration);\n                        console.log(prefix(), d, chalk.green(title)); // JSON.stringify(test, null, \"\"));\n                    }\n                    break;\n            }\n        });\n\n        worker.on(\"error\", reject);\n        worker.on(\"exit\", (code) => {\n            runningPages.delete(page);\n            if (code !== 0) reject(new Error(`Worker ${page} stopped with exit code ${code}`));\n            resolve();\n        });\n    });\n\n    return result;\n}\n\nconst {\n    EVENT_RUN_BEGIN,\n    EVENT_RUN_END,\n    EVENT_TEST_BEGIN,\n    EVENT_TEST_FAIL,\n    EVENT_TEST_PASS,\n    EVENT_SUITE_BEGIN,\n    EVENT_SUITE_END,\n    EVENT_TEST_SKIPPED\n} = Mocha.Runner.constants;\n\nasync function runTestAndContinue(data) {\n    if (data.index >= data.testFiles.length) {\n        return;\n    }\n    try {\n        const page = data.index++;\n        const g = data.g;\n        const selectedTests = await extractPageTest(data.testFiles, { page, pageSize: 1, pageCount: 1 });\n        if (selectedTests.length === 0) {\n            data.pageCount = data.index;\n            return;\n        }\n        await runTest({ page, selectedTests, g });\n    } catch (err) {\n        // stop now\n        data.pageCount = data.index;\n        console.error(err);\n        return;\n    }\n    await runTestAndContinue(data);\n}\n\nconst t1 = Date.now();\nfunction epilogue() {\n    const t2 = Date.now();\n    console.log(\"Duration     : \", durationToString(t2 - t1));\n    console.log(\"test count   : \", testCounter);\n    console.log(\"Failing tests: \", failingTestFilename.length);\n    console.log(failingTestFilename.join(\"\\n\"));\n    for (const [key, value] of Object.entries(failingTests)) {\n        console.log(key);\n        console.log(value);\n    }\n\n    const testByDuration = [...Object.entries(durationsPerTestFile)].sort(\n        ([file1, duration1], [file2, duration2]) => duration2 - duration1\n    );\n    console.log(\"Longest tests:\");\n    console.log(\n        testByDuration\n            .slice(0, 30)\n            .map(([file, duration]) => `${durationToString(duration)}: ${file}`)\n            .join(\"\\n\")\n    );\n    console.log(\"-------------------------------------------------------------------------------\");\n    const runningTests = [...runningPages].map((i) => testFiles[i]);\n    console.log(`running tests: ${runningTests.length}`);\n    console.log(runningTests.join(\"\\n\"));\n}\n\nfunction dumpRunningTests() {\n    const runningTests = [...runningPages].map((i) => testFiles[i]);\n    console.log(`running tests: ${runningTests.length}`);\n    console.log(runningTests.join(\"\\n\"));\n}\n\nif (isMainThread) {\n    const argv = yargs\n        .option(\"fileFilter\", {\n            describe: \"file filter\",\n            default: null,\n            alias: \"f\"\n        })\n        .option(\"testFilter\", {\n            alias: \"t\",\n            default: null\n        })\n        .options(\"verbose\", {\n            alias: \"v\",\n            default: false\n        }).argv;\n\n    if (argv.verbose) {\n        console.info(\"Verbose mode on.\");\n    }\n    (async () => {\n        testFiles = await extractAllTestFiles();\n\n        if (argv.fileFilter) {\n            console.log(\"applying filter\", argv.fileFilter);\n            const f = new RegExp(argv.fileFilter);\n            testFiles = testFiles.filter((file) => file.match(f));\n            console.log(\"filtered test files\", testFiles.length);\n        }\n        if (process.stdin && process.stdin.setRawMode) {\n            const rl = readline.createInterface({\n                input: process.stdin,\n                output: process.stdout\n            });\n\n            rl.prompt(true);\n\n            rl.setPrompt(`\n              \n                help:\n                -----\n            \n                CTRL+C : gracefully shutdown the client    \n                l      : list running tests\n            \n                press a key to continue:\n            \n            `);\n\n            readline.emitKeypressEvents(process.stdin, rl);\n            process.stdin.setRawMode(true);\n            process.stdin.on(\"keypress\", async (str, key) => {\n                console.log(`You pressed the \"${str}\" key`);\n\n                if (key.ctrl && key.name === \"C\") {\n                    process.exit(0);\n                }\n                if (key.name === \"l\") {\n                    dumpRunningTests();\n                }\n                if (key.name === \"i\") {\n                    dumpRunningTests();\n                    dumpRunningTestsLogs();\n                }\n            });\n        }\n\n        const data = {\n            index: 0,\n            pageCount: 200,\n            testFiles,\n            g: argv.testFilter\n        };\n\n        const infoTimer = setInterval(() => {\n            console.log(\"----------------------------------------------- RUNNING TESTS \");\n            dumpRunningTests();\n            dumpRunningTestsLogs();\n        }, testWatchDogTimeout);\n\n        fileMax = testFiles.length;\n        const promises = [];\n        const cpuCount = Math.max(CPU || os.cpus().length * 0.7, 2);\n        for (let i = 0; i < cpuCount; i++) {\n            promises.push(runTestAndContinue(data));\n        }\n        await Promise.all(promises);\n\n        clearInterval(infoTimer);\n        epilogue();\n\n        process.exit(0);\n    })();\n} else {\n    const { workerThread } = require(\"./parallel_test_worker\");\n    workerThread();\n}\nfunction dumpRunningTestsLogs() {\n    const runningTests = [...runningPages].map((i) => testFiles[i]);\n    for (let file of runningTests) {\n        const outputs = outputFor[file];\n        if (outputs && outputs.length) {\n            console.log(chalk.green(\"log for\", file));\n            console.log(outputs.join(\"\\n\"));\n        }\n    }\n}\n"], "filenames": ["packages/node-opcua-client/source/private/client_session_impl.ts", "packages/node-opcua-client/source/private/client_subscription_impl.ts", "packages/node-opcua-end2end-test/test/discovery/u_test_discovery_server.ts", "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_BrowseRequest.js", "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_SubscriptionUseCase.js", "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_Subscription_Transfer.js", "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_browse_read.js", "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_registerNodes.js", "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_set_triggering.ts", "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_test_accessing_service_before_session_is_activated.js", "packages/node-opcua-end2end-test/test/end_to_end/u_test_e2e_transfer_session.js", "packages/node-opcua-secure-channel/source/client/client_secure_channel_layer.ts", "packages/node-opcua-server-discovery/source/opcua_discovery_server.ts", "packages/node-opcua-server/source/opcua_server.ts", "packages/node-opcua-server/source/server_publish_engine.ts", "packages/node-opcua-server/test/test_server_engine_subscription.js", "packages/node-opcua-server/test/test_server_publish_engine.ts", "packages/parallel_test.js"], "buggy_code_start_loc": [13, 474, 21, 167, 42, 459, 31, 4, 0, 31, 1, 122, 18, 148, 14, 8, 188, 304], "buggy_code_end_loc": [1597, 476, 211, 171, 4086, 463, 174, 162, 254, 85, 724, 1725, 394, 3450, 669, 418, 331, 344], "fixing_code_start_loc": [13, 474, 21, 167, 42, 459, 32, 5, 1, 32, 2, 122, 18, 148, 14, 9, 188, 305], "fixing_code_end_loc": [1606, 480, 219, 171, 4093, 470, 176, 165, 254, 87, 711, 1726, 394, 3449, 674, 422, 329, 352], "type": "CWE-770", "message": "The package node-opcua before 2.74.0 are vulnerable to Denial of Service (DoS) by sending a specifically crafted OPC UA message with a special OPC UA NodeID, when the requested memory allocation exceeds the v8\u2019s memory limit.", "other": {"cve": {"id": "CVE-2022-25231", "sourceIdentifier": "report@snyk.io", "published": "2022-08-23T05:15:07.873", "lastModified": "2022-08-26T13:01:18.860", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package node-opcua before 2.74.0 are vulnerable to Denial of Service (DoS) by sending a specifically crafted OPC UA message with a special OPC UA NodeID, when the requested memory allocation exceeds the v8\u2019s memory limit."}, {"lang": "es", "value": "El paquete node-opcua versiones anteriores a 2.74.0, es vulnerable a una Denegaci\u00f3n de Servicio (DoS) mediante el env\u00edo de un mensaje OPC UA espec\u00edficamente dise\u00f1ado con un NodeID OPC UA especial, cuando la asignaci\u00f3n de memoria solicitada excede el l\u00edmite de memoria de v8."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:node-opcua_project:node-opcua:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.74.0", "matchCriteriaId": "900AECE1-5AD5-4065-AE88-E02D6885B83C"}]}]}], "references": [{"url": "https://github.com/node-opcua/node-opcua/commit/7b5044b3f5866fbedc3efabd05e407352c07bd2f", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/node-opcua/node-opcua/pull/1182", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-NODEOPCUA-2988724", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/node-opcua/node-opcua/commit/7b5044b3f5866fbedc3efabd05e407352c07bd2f"}}