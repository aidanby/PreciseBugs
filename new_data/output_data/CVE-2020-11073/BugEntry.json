{"buggy_code": ["Changelog\n=========\n\n1.15.2\n------\n* Use absolute path for ``/usr/bin/stat`` to prevent conflicts with other ``stat`` binaries. Fixes #110\n\n1.15.1\n------\n* Fix detection of pipenv projects from subdirectories\n\n1.15.0\n------\n* Add AUTOSWITCH_FILE configuration option\n\n1.14.0\n------\n* Prevent pipenv from showing its courtesy because we activated its virtualenv\n\n1.13.0\n------\n* Clean up pipenv names when displaying them\n\n1.12.0\n------\n* Remove virtualenv requirement. This is now only needed for running mkvenv\n\n1.11.1\n------\n* Fix bug with pipenv detection where extra messages would be incorrectly displayed\n* Add zsh 5.7 to the CI testing process\n\n1.11.0\n------\n* Correct project detection behaviour when working with pipenv\n\n1.10.1\n------\n* Fix minor bug where variables would leak into user's environment\n\n1.10.0\n------\n* Scan for requirements files recursively when setting up a virtualenv (#88 - fix by @nrc)\n* Fix bug when `rm` was aliased to a different behaviour (#87 - fix by @rnc)\n* Invoke pip install in editable (i.e. development) mode. (#91 - fix by @rnc)\n\n1.9.0\n-----\n* Show message when deactivating virtual environments\n\n1.8.2\n-----\n* local variables will no longer sneak into shell environment variables (Thanks @rnc)\n\n1.8.1\n-----\n* Fixes a regression in Pipenv integration\n\n1.8.0\n-----\n* Prompt to install requirements.txt even if setup dependencies installed\n\n1.7.0\n-----\n* Add option to set default python binary to use when creating virtualenvs\n* Add option to set default requirements file to install when creating virtualenvs\n\n1.6.0\n-----\n* Display snake emoji by default when switching virtualenvs\n* Minor tweaks and changes\n\n1.5.0\n-----\n* Detect python projects with `setup.py`\n\n\n1.4.1\n-----\n* Show helpful error message when target virtualenv is not found\n\n\n1.3.1\n-----\n* Remove redundancy in directory checking logic\n* Display help message when python project is detected\n\n1.2.1\n-----\n* Improvements to coloring of output\n* Add enable/disable command\n* allow --verbose option with mkvenv\n* allow user to specify location of virtual env directories\n\n\n1.1.1\n-----\n* Hotfix: Fix conflict with you-should-use plugin default message\n\n1.1.0\n-----\n* Switch messages can now be customised with the AUTOSWITCH_MESSAGE_FORMAT environment variable\n* help text is now displayed when virtualenv is not installed\n\n1.0.0\n-----\n* Remove dependency on virtualenvwrapper. autoswitch-virtualenv now works directly with virtualenv\n\n0.7.0\n-----\n* Vastly improve the performance of switching environments\n\n0.6.0\n-----\n* Improve plugin performance when checking for virtualenvs\n\n0.5.1\n-----\n* Improve color output. Virtualenv name now displayed in purple\n\n\n0.5.0\n-----\n* Color python version output when switching virtualenvs\n\n0.4.0\n-----\n* Add support for detecting and auto activating with pipenv\n\n0.3.6\n-----\n* Fix bug where version was not in sync with git\n\n0.3.5\n-----\n* allow readable permissions for everyone and group\n* Fixes to README\n\n0.3.4\n-----\n* export autoswitch version\n\n0.3.3\n-----\n* Improve help message formatting when plugin is not setup correctly\n\n0.3.2\n-----\n* Fix bug #19 where MYOLDPWD would get set in window titles (zprezto).\n\n0.3.1\n-----\n* Make help message clearer if virutalenvwrapper is not setup correctly\n\n0.3.0\n-----\n* Disable plugin and print help message if virtualenvwrapper not setup correctly\n* Fix bug in rmvenv when no virtualenv was activated\n* Fix flaky tests\n\n0.2.1\n-----\n* Add tests for mkvenv and check_venv\n\n\n0.2.0\n-----\n* Introduce Changelog\n* Fix tests and CI process\n* use printf instead of echo for better system portability\n* Add ability to disable loading hooks and running initial check_venv using DISABLE_AUTOSWITCH_VENV\n* Introduce restructuredtext linter to CI\n* Test ZSH 5.4.2 in CI\n", "export AUTOSWITCH_VERSION=\"1.15.2\"\nexport AUTOSWITCH_FILE=\".venv\"\n\nRED=\"\\e[31m\"\nGREEN=\"\\e[32m\"\nPURPLE=\"\\e[35m\"\nBOLD=\"\\e[1m\"\nNORMAL=\"\\e[0m\"\n\n\nfunction _virtual_env_dir() {\n    local venv_name=\"$1\"\n    local VIRTUAL_ENV_DIR=\"${AUTOSWITCH_VIRTUAL_ENV_DIR:-$HOME/.virtualenvs}\"\n    mkdir -p \"$VIRTUAL_ENV_DIR\"\n    printf \"%s/%s\" \"$VIRTUAL_ENV_DIR\" \"$venv_name\"\n}\n\n\nfunction _python_version() {\n    local PYTHON_BIN=\"$1\"\n    if [[ -f \"$PYTHON_BIN\" ]] then\n        # For some reason python --version writes to stderr\n        printf \"%s\" \"$($PYTHON_BIN --version 2>&1)\"\n    else\n        printf \"unknown\"\n    fi\n}\n\n\nfunction _autoswitch_message() {\n    if [ -z \"$AUTOSWITCH_SILENT\" ]; then\n        printf \"$@\"\n    fi\n}\n\nfunction _get_venv_type() {\n    local venv_dir=\"$1\"\n    local venv_type=\"${2:-virtualenv}\"\n    if [[ -f \"$venv_dir/Pipfile\" ]]; then\n        venv_type=\"pipenv\"\n    elif [[ -f \"$venv_dir/requirements.txt\" || -f \"$venv_dir/setup.py\" ]]; then\n        venv_type=\"virtualenv\"\n    fi\n    printf \"%s\" \"$venv_type\"\n}\n\n\nfunction _get_venv_name() {\n    local venv_dir=\"$1\"\n    local venv_type=\"$2\"\n    local venv_name=\"$(basename \"$venv_dir\")\"\n\n    # clear pipenv from the extra identifiers at the end\n    if [[ \"$venv_type\" == \"pipenv\" ]]; then\n        venv_name=\"${venv_name%-*}\"\n    fi\n\n    printf \"%s\" \"$venv_name\"\n}\n\n\nfunction _maybeworkon() {\n    local venv_dir=\"$1\"\n    local venv_type=\"$2\"\n    local venv_name=\"$(_get_venv_name $venv_dir $venv_type)\"\n\n    local DEFAULT_MESSAGE_FORMAT=\"Switching %venv_type: ${BOLD}${PURPLE}%venv_name${NORMAL} ${GREEN}[\ud83d\udc0d%py_version]${NORMAL}\"\n    if [[ \"$LANG\" != *\".UTF-8\" ]]; then\n        # Remove multibyte characters if the terminal does not support utf-8\n        DEFAULT_MESSAGE_FORMAT=\"${DEFAULT_MESSAGE_FORMAT/\ud83d\udc0d/}\"\n    fi\n\n    # Don't reactivate an already activated virtual environment\n    if [[ -z \"$VIRTUAL_ENV\" || \"$venv_name\" != \"$(_get_venv_name $VIRTUAL_ENV $venv_type)\" ]]; then\n\n        if [[ ! -d \"$venv_dir\" ]]; then\n            printf \"Unable to find ${PURPLE}$venv_name${NORMAL} virtualenv\\n\"\n            printf \"If the issue persists run ${PURPLE}rmvenv && mkvenv${NORMAL} in this directory\\n\"\n            return\n        fi\n\n        local py_version=\"$(_python_version \"$venv_dir/bin/python\")\"\n        local message=\"${AUTOSWITCH_MESSAGE_FORMAT:-\"$DEFAULT_MESSAGE_FORMAT\"}\"\n        message=\"${message//\\%venv_type/$venv_type}\"\n        message=\"${message//\\%venv_name/$venv_name}\"\n        message=\"${message//\\%py_version/$py_version}\"\n        _autoswitch_message \"${message}\\n\"\n\n        # If we are using pipenv and activate its virtual environment - turn down its verbosity\n        # to prevent users seeing \" Pipenv found itself running within a virtual environment\" warning\n        if [[ \"$venv_type\" == \"pipenv\" && \"$PIPENV_VERBOSITY\" != -1 ]]; then\n            export PIPENV_VERBOSITY=-1\n        fi\n\n        # Much faster to source the activate file directly rather than use the `workon` command\n        source \"$venv_dir/bin/activate\"\n    fi\n}\n\n\n# Gives the path to the nearest target file\nfunction _check_path()\n{\n    local check_dir=\"$1\"\n    local check_file=\"$2\"\n\n    if [[ -f \"${check_dir}/$check_file\" ]]; then\n        printf \"${check_dir}/$check_file\"\n        return\n    else\n        # Abort search at file system root or HOME directory (latter is a performance optimisation).\n        if [[ \"$check_dir\" = \"/\" || \"$check_dir\" = \"$HOME\" ]]; then\n            return\n        fi\n        _check_path \"$(dirname \"$check_dir\")\" \"$check_file\"\n    fi\n}\n\n\n# Automatically switch virtualenv when $AUTOSWITCH_FILE file detected\nfunction check_venv()\n{\n    local file_owner\n    local file_permissions\n\n    # Get the $AUTOSWITCH_FILE, scanning parent directories\n    local venv_path=\"$(_check_path \"$PWD\" \"$AUTOSWITCH_FILE\")\"\n\n    if [[ -n \"$venv_path\" ]]; then\n\n        /usr/bin/stat --version &> /dev/null\n        if [[ $? -eq 0 ]]; then   # Linux, or GNU stat\n            file_owner=\"$(/usr/bin/stat -c %u \"$venv_path\")\"\n            file_permissions=\"$(/usr/bin/stat -c %a \"$venv_path\")\"\n        else                      # macOS, or FreeBSD stat\n            file_owner=\"$(/usr/bin/stat -f %u \"$venv_path\")\"\n            file_permissions=\"$(/usr/bin/stat -f %OLp \"$venv_path\")\"\n        fi\n\n        if [[ \"$file_owner\" != \"$(id -u)\" ]]; then\n            printf \"AUTOSWITCH WARNING: Virtualenv will not be activated\\n\\n\"\n            printf \"Reason: Found a $AUTOSWITCH_FILE file but it is not owned by the current user\\n\"\n            printf \"Change ownership of ${PURPLE}$venv_path${NORMAL} to ${PURPLE}'$USER'${NORMAL} to fix this\\n\"\n        elif ! [[ \"$file_permissions\" =~ ^[64][04][04]$ ]]; then\n            printf \"AUTOSWITCH WARNING: Virtualenv will not be activated\\n\\n\"\n            printf \"Reason: Found a $AUTOSWITCH_FILE file with weak permission settings ($file_permissions).\\n\"\n            printf \"Run the following command to fix this: ${PURPLE}\\\"chmod 600 $venv_path\\\"${NORMAL}\\n\"\n        else\n            local switch_to=\"$(<\"$venv_path\")\"\n            _maybeworkon \"$(_virtual_env_dir \"$switch_to\")\" \"virtualenv\"\n            return\n        fi\n    fi\n\n    # check if Pipfile exists rather than invoking pipenv as it is slow\n    local pipfile_path=\"$(_check_path \"$PWD\" \"Pipfile\")\"\n\n    if [[ -n \"$pipfile_path\" ]] && type \"pipenv\" > /dev/null; then\n        # unfortunately running pipenv each time we are in a pipenv project directory is slow :(\n        if venv_path=\"$(PIPENV_IGNORE_VIRTUALENVS=1 pipenv --venv 2>/dev/null)\"; then\n            _maybeworkon \"$venv_path\" \"pipenv\"\n            return\n        fi\n    fi\n\n    local venv_type=\"$(_get_venv_type \"$PWD\" \"unknown\")\"\n\n    # If we still haven't got anywhere, fallback to defaults\n    if [[ \"$venv_type\" == \"pipenv\" ]]; then\n        printf \"Python project detected. \"\n        printf \"Run ${PURPLE}pipenv install${NORMAL} to setup autoswitching\\n\"\n    elif [[ \"$venv_type\" == \"virtualenv\" ]]; then\n        printf \"Python project detected. \"\n        printf \"Run ${PURPLE}mkvenv${NORMAL} to setup autoswitching\\n\"\n    fi\n    _default_venv\n}\n\n# Switch to the default virtual environment\nfunction _default_venv()\n{\n    local venv_type=\"$(_get_venv_type \"$OLDPWD\")\"\n    if [[ -n \"$AUTOSWITCH_DEFAULTENV\" ]]; then\n        _maybeworkon \"$(_virtual_env_dir \"$AUTOSWITCH_DEFAULTENV\")\" \"$venv_type\"\n    elif [[ -n \"$VIRTUAL_ENV\" ]]; then\n        local venv_name=\"$(_get_venv_name \"$VIRTUAL_ENV\" \"$venv_type\")\"\n        _autoswitch_message \"Deactivating: ${BOLD}${PURPLE}%s${NORMAL}\\n\" \"$venv_name\"\n        deactivate\n    fi\n}\n\n\n# remove virtual environment for current directory\nfunction rmvenv()\n{\n    if [[ -f \"$AUTOSWITCH_FILE\" ]]; then\n        local venv_name=\"$(<$AUTOSWITCH_FILE)\"\n\n        # detect if we need to switch virtualenv first\n        if [[ -n \"$VIRTUAL_ENV\" ]]; then\n            local current_venv=\"$(basename $VIRTUAL_ENV)\"\n            if [[ \"$current_venv\" = \"$venv_name\" ]]; then\n                _default_venv\n            fi\n        fi\n\n        printf \"Removing ${PURPLE}%s${NORMAL}...\\n\" \"$venv_name\"\n        # Using explicit paths to avoid any alias/function interference.\n        # rm should always be found in this location according to\n        # https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s04.html\n        # https://www.freedesktop.org/wiki/Software/systemd/TheCaseForTheUsrMerge/\n        /bin/rm -rf \"$(_virtual_env_dir \"$venv_name\")\"\n        /bin/rm \"$AUTOSWITCH_FILE\"\n    else\n        printf \"No $AUTOSWITCH_FILE file in the current directory!\\n\"\n    fi\n}\n\n\n# helper function to create a virtual environment for the current directory\nfunction mkvenv()\n{\n    if ! type \"virtualenv\" > /dev/null; then\n        printf \"${BOLD}${RED}\"\n        printf \"zsh-autoswitch-virtualenv requires virtualenv to be installed!\\n\\n\"\n        printf \"${NORMAL}\"\n        printf \"If this is already installed but you are still seeing this message, \\n\"\n        printf \"then make sure the ${BOLD}virtualenv${NORMAL} command is in your PATH.\\n\"\n        printf \"\\n\"\n        return\n    fi\n\n    if [[ -f \"$AUTOSWITCH_FILE\" ]]; then\n        printf \"$AUTOSWITCH_FILE file already exists. If this is a mistake use the rmvenv command\\n\"\n    else\n        local venv_name=\"$(basename $PWD)\"\n\n        printf \"Creating ${PURPLE}%s${NONE} virtualenv\\n\" \"$venv_name\"\n\n        # Copy parameters variable so that we can mutate it\n        local params=(\"${@[@]}\")\n\n        if [[ -n \"$AUTOSWITCH_DEFAULT_PYTHON\" && ${params[(I)--python*]} -eq 0 ]]; then\n            params+=\"--python=$AUTOSWITCH_DEFAULT_PYTHON\"\n        fi\n\n        if [[ ${params[(I)--verbose]} -eq 0 ]]; then\n            virtualenv $params \"$(_virtual_env_dir \"$venv_name\")\"\n        else\n            virtualenv $params \"$(_virtual_env_dir \"$venv_name\")\" > /dev/null\n        fi\n\n        printf \"$venv_name\\n\" > \"$AUTOSWITCH_FILE\"\n        chmod 600 \"$AUTOSWITCH_FILE\"\n\n        _maybeworkon \"$(_virtual_env_dir \"$venv_name\")\" \"virtualenv\"\n\n        install_requirements\n    fi\n}\n\n\nfunction install_requirements() {\n    if [[ -f \"$AUTOSWITCH_DEFAULT_REQUIREMENTS\" ]]; then\n        printf \"Install default requirements? (${PURPLE}$AUTOSWITCH_DEFAULT_REQUIREMENTS${NORMAL}) [y/N]: \"\n        read ans\n\n        if [[ \"$ans\" = \"y\" || \"$ans\" == \"Y\" ]]; then\n            pip install -r \"$AUTOSWITCH_DEFAULT_REQUIREMENTS\"\n        fi\n    fi\n\n    if [[ -f \"$PWD/setup.py\" ]]; then\n        printf \"Found a ${PURPLE}setup.py${NORMAL} file. Install dependencies? [y/N]: \"\n        read ans\n\n        if [[ \"$ans\" = \"y\" || \"$ans\" = \"Y\" ]]; then\n            if [[ \"$AUTOSWITCH_PIPINSTALL\" = \"FULL\" ]]\n            then\n                pip install .\n            else\n                pip install -e .\n            fi\n        fi\n    fi\n\n    setopt nullglob\n    local requirements\n    for requirements in **/*requirements.txt\n    do\n        printf \"Found a ${PURPLE}%s${NORMAL} file. Install? [y/N]: \" \"$requirements\"\n        read ans\n\n        if [[ \"$ans\" = \"y\" || \"$ans\" = \"Y\" ]]; then\n            pip install -r \"$requirements\"\n        fi\n    done\n}\n\n\nfunction enable_autoswitch_virtualenv() {\n    autoload -Uz add-zsh-hook\n    disable_autoswitch_virtualenv\n    add-zsh-hook chpwd check_venv\n}\n\n\nfunction disable_autoswitch_virtualenv() {\n    add-zsh-hook -D chpwd check_venv\n}\n\n\nenable_autoswitch_virtualenv\ncheck_venv\n", "#!/usr/bin/env zunit\n\n\n@setup {\n    TEST_VIRTUALENV=\"$HOME/.virtualenvs/foobar/\"\n\n    if [[ ! -d \"$TEST_VIRTUALENV\" ]]; then\n        echo \"Creating test virtualenv\"\n        run python -m virtualenv \"$TEST_VIRTUALENV\" --python=python3\n    fi\n\n    unset AUTOSWITCH_MESSAGE_FORMAT\n    PYTHON_VERSION=\"$(python3 --version 2>&1)\"\n\n    export DISABLE_AUTOSWITCH_VENV=\"1\"\n    load \"../autoswitch_virtualenv.plugin.zsh\"\n    TARGET=\"$(mktemp -d)\"\n\n    LANG=\".UTF-8\"\n}\n\n@teardown {\n    rm -rf \"$TARGET\"\n}\n\n@test '_maybeworkon - error message if virtualenv can not be found' {\n    VIRTUAL_ENV=\"\"\n\n    run _maybeworkon $HOME/.virtualenvs/idontexist virtualenv\n\n    assert $state equals 0\n    assert \"${lines[1]}\" same_as \"Unable to find \\e[35midontexist\\e[0m virtualenv\"\n    assert \"${lines[2]}\" same_as \"If the issue persists run \\e[35mrmvenv && mkvenv\\e[0m in this directory\"\n}\n\n\n@test '_maybeworkon - switches virtualenv if nothing is activated' {\n    VIRTUAL_ENV=\"\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" virtualenv\n\n    assert $state equals 0\n    assert \"$output\" same_as \"Switching virtualenv: \\e[1m\\e[35mfoobar\\e[0m \\e[32m[\ud83d\udc0d$PYTHON_VERSION]\\e[0m\"\n}\n\n@test '_maybeworkon - custom message' {\n    VIRTUAL_ENV=\"\"\n    AUTOSWITCH_MESSAGE_FORMAT=\"Hello %venv_type - this is %venv_name (%py_version)\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" cheese\n\n    assert $state equals 0\n    assert \"$output\" same_as \"Hello cheese - this is foobar ($PYTHON_VERSION)\"\n}\n\n@test '_maybeworkon - no emoji on non utf-8 LANG' {\n    VIRTUAL_ENV=\"\"\n    LANG=\"ASCII\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" virtualenv\n\n    assert $state equals 0\n    assert \"$output\" same_as \"Switching virtualenv: \\e[1m\\e[35mfoobar\\e[0m \\e[32m[$PYTHON_VERSION]\\e[0m\"\n}\n\n@test '_maybeworkon - switches virtualenv if current virtualenv is different' {\n    VIRTUAL_ENV=\"$HOME/.virtualenvs/default_venv\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" virtualfoo\n\n    assert $state equals 0\n    assert \"$output\" contains \"Switching virtualfoo: \\e[1m\\e[35mfoobar\\e[0m \\e[32m[\ud83d\udc0d$PYTHON_VERSION]\\e[0m\"\n}\n\n@test '_maybeworkon - switches virtualenv if current virtualenv is different (silent)' {\n    VIRTUAL_ENV=\"$HOME/.virtualenvs/default_venv\"\n    AUTOSWITCH_SILENT=\"1\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" virtualenv\n\n    assert $state equals 0\n    assert \"$output\" is_empty\n}\n\n@test '_maybeworkon - does not switch to already activated virtualenv' {\n    VIRTUAL_ENV=\"$HOME/.virtualenvs/bwaaah\"\n\n    run _maybeworkon bwaaah virtualenv\n\n    assert $state equals 0\n    assert \"$output\" is_empty\n}\n\n@test '_maybeworkon - pipenv name cleaned' [\n    run _maybeworkon hello-world-foo-de31f pipenv\n\n    assert $state equals 0\n    assert \"$output\" same_as \"Switching pipenv: \\e[1m\\e[35mhello-world-foo\\e[0m \\e[32m[\ud83d\udc0d$PYTHON_VERSION]\\e[0m\"\n}\n"], "fixing_code": ["Changelog\n=========\n\n1.16.0\n------\n* Fix insecure activation of virtualenvs (#122)\n\n1.15.2\n------\n* Use absolute path for ``/usr/bin/stat`` to prevent conflicts with other ``stat`` binaries. Fixes #110\n\n1.15.1\n------\n* Fix detection of pipenv projects from subdirectories\n\n1.15.0\n------\n* Add AUTOSWITCH_FILE configuration option\n\n1.14.0\n------\n* Prevent pipenv from showing its courtesy because we activated its virtualenv\n\n1.13.0\n------\n* Clean up pipenv names when displaying them\n\n1.12.0\n------\n* Remove virtualenv requirement. This is now only needed for running mkvenv\n\n1.11.1\n------\n* Fix bug with pipenv detection where extra messages would be incorrectly displayed\n* Add zsh 5.7 to the CI testing process\n\n1.11.0\n------\n* Correct project detection behaviour when working with pipenv\n\n1.10.1\n------\n* Fix minor bug where variables would leak into user's environment\n\n1.10.0\n------\n* Scan for requirements files recursively when setting up a virtualenv (#88 - fix by @nrc)\n* Fix bug when `rm` was aliased to a different behaviour (#87 - fix by @rnc)\n* Invoke pip install in editable (i.e. development) mode. (#91 - fix by @rnc)\n\n1.9.0\n-----\n* Show message when deactivating virtual environments\n\n1.8.2\n-----\n* local variables will no longer sneak into shell environment variables (Thanks @rnc)\n\n1.8.1\n-----\n* Fixes a regression in Pipenv integration\n\n1.8.0\n-----\n* Prompt to install requirements.txt even if setup dependencies installed\n\n1.7.0\n-----\n* Add option to set default python binary to use when creating virtualenvs\n* Add option to set default requirements file to install when creating virtualenvs\n\n1.6.0\n-----\n* Display snake emoji by default when switching virtualenvs\n* Minor tweaks and changes\n\n1.5.0\n-----\n* Detect python projects with `setup.py`\n\n\n1.4.1\n-----\n* Show helpful error message when target virtualenv is not found\n\n\n1.3.1\n-----\n* Remove redundancy in directory checking logic\n* Display help message when python project is detected\n\n1.2.1\n-----\n* Improvements to coloring of output\n* Add enable/disable command\n* allow --verbose option with mkvenv\n* allow user to specify location of virtual env directories\n\n\n1.1.1\n-----\n* Hotfix: Fix conflict with you-should-use plugin default message\n\n1.1.0\n-----\n* Switch messages can now be customised with the AUTOSWITCH_MESSAGE_FORMAT environment variable\n* help text is now displayed when virtualenv is not installed\n\n1.0.0\n-----\n* Remove dependency on virtualenvwrapper. autoswitch-virtualenv now works directly with virtualenv\n\n0.7.0\n-----\n* Vastly improve the performance of switching environments\n\n0.6.0\n-----\n* Improve plugin performance when checking for virtualenvs\n\n0.5.1\n-----\n* Improve color output. Virtualenv name now displayed in purple\n\n\n0.5.0\n-----\n* Color python version output when switching virtualenvs\n\n0.4.0\n-----\n* Add support for detecting and auto activating with pipenv\n\n0.3.6\n-----\n* Fix bug where version was not in sync with git\n\n0.3.5\n-----\n* allow readable permissions for everyone and group\n* Fixes to README\n\n0.3.4\n-----\n* export autoswitch version\n\n0.3.3\n-----\n* Improve help message formatting when plugin is not setup correctly\n\n0.3.2\n-----\n* Fix bug #19 where MYOLDPWD would get set in window titles (zprezto).\n\n0.3.1\n-----\n* Make help message clearer if virutalenvwrapper is not setup correctly\n\n0.3.0\n-----\n* Disable plugin and print help message if virtualenvwrapper not setup correctly\n* Fix bug in rmvenv when no virtualenv was activated\n* Fix flaky tests\n\n0.2.1\n-----\n* Add tests for mkvenv and check_venv\n\n\n0.2.0\n-----\n* Introduce Changelog\n* Fix tests and CI process\n* use printf instead of echo for better system portability\n* Add ability to disable loading hooks and running initial check_venv using DISABLE_AUTOSWITCH_VENV\n* Introduce restructuredtext linter to CI\n* Test ZSH 5.4.2 in CI\n", "export AUTOSWITCH_VERSION=\"1.16.0\"\nexport AUTOSWITCH_FILE=\".venv\"\n\nRED=\"\\e[31m\"\nGREEN=\"\\e[32m\"\nPURPLE=\"\\e[35m\"\nBOLD=\"\\e[1m\"\nNORMAL=\"\\e[0m\"\n\n\nfunction _validated_source() {\n    local target_path=\"$1\"\n\n    if [[ \"$target_path\" == *'..'* ]]; then\n        printf \"AUTOSWITCH WARNING: \"\n        printf \"target virtualenv contains invalid characters\\n\"\n        printf \"virtualenv activation cancelled\\n\"\n        return\n    else\n        source \"$target_path\"\n    fi\n}\n\n\nfunction _virtual_env_dir() {\n    local venv_name=\"$1\"\n    local VIRTUAL_ENV_DIR=\"${AUTOSWITCH_VIRTUAL_ENV_DIR:-$HOME/.virtualenvs}\"\n    mkdir -p \"$VIRTUAL_ENV_DIR\"\n    printf \"%s/%s\" \"$VIRTUAL_ENV_DIR\" \"$venv_name\"\n}\n\n\nfunction _python_version() {\n    local PYTHON_BIN=\"$1\"\n    if [[ -f \"$PYTHON_BIN\" ]] then\n        # For some reason python --version writes to stderr\n        printf \"%s\" \"$($PYTHON_BIN --version 2>&1)\"\n    else\n        printf \"unknown\"\n    fi\n}\n\n\nfunction _autoswitch_message() {\n    if [ -z \"$AUTOSWITCH_SILENT\" ]; then\n        printf \"$@\"\n    fi\n}\n\nfunction _get_venv_type() {\n    local venv_dir=\"$1\"\n    local venv_type=\"${2:-virtualenv}\"\n    if [[ -f \"$venv_dir/Pipfile\" ]]; then\n        venv_type=\"pipenv\"\n    elif [[ -f \"$venv_dir/requirements.txt\" || -f \"$venv_dir/setup.py\" ]]; then\n        venv_type=\"virtualenv\"\n    fi\n    printf \"%s\" \"$venv_type\"\n}\n\n\nfunction _get_venv_name() {\n    local venv_dir=\"$1\"\n    local venv_type=\"$2\"\n    local venv_name=\"$(basename \"$venv_dir\")\"\n\n    # clear pipenv from the extra identifiers at the end\n    if [[ \"$venv_type\" == \"pipenv\" ]]; then\n        venv_name=\"${venv_name%-*}\"\n    fi\n\n    printf \"%s\" \"$venv_name\"\n}\n\n\nfunction _maybeworkon() {\n    local venv_dir=\"$1\"\n    local venv_type=\"$2\"\n    local venv_name=\"$(_get_venv_name $venv_dir $venv_type)\"\n\n    local DEFAULT_MESSAGE_FORMAT=\"Switching %venv_type: ${BOLD}${PURPLE}%venv_name${NORMAL} ${GREEN}[\ud83d\udc0d%py_version]${NORMAL}\"\n    if [[ \"$LANG\" != *\".UTF-8\" ]]; then\n        # Remove multibyte characters if the terminal does not support utf-8\n        DEFAULT_MESSAGE_FORMAT=\"${DEFAULT_MESSAGE_FORMAT/\ud83d\udc0d/}\"\n    fi\n\n    # Don't reactivate an already activated virtual environment\n    if [[ -z \"$VIRTUAL_ENV\" || \"$venv_name\" != \"$(_get_venv_name $VIRTUAL_ENV $venv_type)\" ]]; then\n\n        if [[ ! -d \"$venv_dir\" ]]; then\n            printf \"Unable to find ${PURPLE}$venv_name${NORMAL} virtualenv\\n\"\n            printf \"If the issue persists run ${PURPLE}rmvenv && mkvenv${NORMAL} in this directory\\n\"\n            return\n        fi\n\n        local py_version=\"$(_python_version \"$venv_dir/bin/python\")\"\n        local message=\"${AUTOSWITCH_MESSAGE_FORMAT:-\"$DEFAULT_MESSAGE_FORMAT\"}\"\n        message=\"${message//\\%venv_type/$venv_type}\"\n        message=\"${message//\\%venv_name/$venv_name}\"\n        message=\"${message//\\%py_version/$py_version}\"\n        _autoswitch_message \"${message}\\n\"\n\n        # If we are using pipenv and activate its virtual environment - turn down its verbosity\n        # to prevent users seeing \" Pipenv found itself running within a virtual environment\" warning\n        if [[ \"$venv_type\" == \"pipenv\" && \"$PIPENV_VERBOSITY\" != -1 ]]; then\n            export PIPENV_VERBOSITY=-1\n        fi\n\n        # Much faster to source the activate file directly rather than use the `workon` command\n        local activate_script=\"$venv_dir/bin/activate\"\n\n        _validated_source \"$activate_script\"\n    fi\n}\n\n\n# Gives the path to the nearest target file\nfunction _check_path()\n{\n    local check_dir=\"$1\"\n    local check_file=\"$2\"\n\n    if [[ -f \"${check_dir}/$check_file\" ]]; then\n        printf \"${check_dir}/$check_file\"\n        return\n    else\n        # Abort search at file system root or HOME directory (latter is a performance optimisation).\n        if [[ \"$check_dir\" = \"/\" || \"$check_dir\" = \"$HOME\" ]]; then\n            return\n        fi\n        _check_path \"$(dirname \"$check_dir\")\" \"$check_file\"\n    fi\n}\n\n\n# Automatically switch virtualenv when $AUTOSWITCH_FILE file detected\nfunction check_venv()\n{\n    local file_owner\n    local file_permissions\n\n    # Get the $AUTOSWITCH_FILE, scanning parent directories\n    local venv_path=\"$(_check_path \"$PWD\" \"$AUTOSWITCH_FILE\")\"\n\n    if [[ -n \"$venv_path\" ]]; then\n\n        /usr/bin/stat --version &> /dev/null\n        if [[ $? -eq 0 ]]; then   # Linux, or GNU stat\n            file_owner=\"$(/usr/bin/stat -c %u \"$venv_path\")\"\n            file_permissions=\"$(/usr/bin/stat -c %a \"$venv_path\")\"\n        else                      # macOS, or FreeBSD stat\n            file_owner=\"$(/usr/bin/stat -f %u \"$venv_path\")\"\n            file_permissions=\"$(/usr/bin/stat -f %OLp \"$venv_path\")\"\n        fi\n\n        if [[ \"$file_owner\" != \"$(id -u)\" ]]; then\n            printf \"AUTOSWITCH WARNING: Virtualenv will not be activated\\n\\n\"\n            printf \"Reason: Found a $AUTOSWITCH_FILE file but it is not owned by the current user\\n\"\n            printf \"Change ownership of ${PURPLE}$venv_path${NORMAL} to ${PURPLE}'$USER'${NORMAL} to fix this\\n\"\n        elif ! [[ \"$file_permissions\" =~ ^[64][04][04]$ ]]; then\n            printf \"AUTOSWITCH WARNING: Virtualenv will not be activated\\n\\n\"\n            printf \"Reason: Found a $AUTOSWITCH_FILE file with weak permission settings ($file_permissions).\\n\"\n            printf \"Run the following command to fix this: ${PURPLE}\\\"chmod 600 $venv_path\\\"${NORMAL}\\n\"\n        else\n            local switch_to=\"$(<\"$venv_path\")\"\n            _maybeworkon \"$(_virtual_env_dir \"$switch_to\")\" \"virtualenv\"\n            return\n        fi\n    fi\n\n    # check if Pipfile exists rather than invoking pipenv as it is slow\n    local pipfile_path=\"$(_check_path \"$PWD\" \"Pipfile\")\"\n\n    if [[ -n \"$pipfile_path\" ]] && type \"pipenv\" > /dev/null; then\n        # unfortunately running pipenv each time we are in a pipenv project directory is slow :(\n        if venv_path=\"$(PIPENV_IGNORE_VIRTUALENVS=1 pipenv --venv 2>/dev/null)\"; then\n            _maybeworkon \"$venv_path\" \"pipenv\"\n            return\n        fi\n    fi\n\n    local venv_type=\"$(_get_venv_type \"$PWD\" \"unknown\")\"\n\n    # If we still haven't got anywhere, fallback to defaults\n    if [[ \"$venv_type\" == \"pipenv\" ]]; then\n        printf \"Python project detected. \"\n        printf \"Run ${PURPLE}pipenv install${NORMAL} to setup autoswitching\\n\"\n    elif [[ \"$venv_type\" == \"virtualenv\" ]]; then\n        printf \"Python project detected. \"\n        printf \"Run ${PURPLE}mkvenv${NORMAL} to setup autoswitching\\n\"\n    fi\n    _default_venv\n}\n\n# Switch to the default virtual environment\nfunction _default_venv()\n{\n    local venv_type=\"$(_get_venv_type \"$OLDPWD\")\"\n    if [[ -n \"$AUTOSWITCH_DEFAULTENV\" ]]; then\n        _maybeworkon \"$(_virtual_env_dir \"$AUTOSWITCH_DEFAULTENV\")\" \"$venv_type\"\n    elif [[ -n \"$VIRTUAL_ENV\" ]]; then\n        local venv_name=\"$(_get_venv_name \"$VIRTUAL_ENV\" \"$venv_type\")\"\n        _autoswitch_message \"Deactivating: ${BOLD}${PURPLE}%s${NORMAL}\\n\" \"$venv_name\"\n        deactivate\n    fi\n}\n\n\n# remove virtual environment for current directory\nfunction rmvenv()\n{\n    if [[ -f \"$AUTOSWITCH_FILE\" ]]; then\n        local venv_name=\"$(<$AUTOSWITCH_FILE)\"\n\n        # detect if we need to switch virtualenv first\n        if [[ -n \"$VIRTUAL_ENV\" ]]; then\n            local current_venv=\"$(basename $VIRTUAL_ENV)\"\n            if [[ \"$current_venv\" = \"$venv_name\" ]]; then\n                _default_venv\n            fi\n        fi\n\n        printf \"Removing ${PURPLE}%s${NORMAL}...\\n\" \"$venv_name\"\n        # Using explicit paths to avoid any alias/function interference.\n        # rm should always be found in this location according to\n        # https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s04.html\n        # https://www.freedesktop.org/wiki/Software/systemd/TheCaseForTheUsrMerge/\n        /bin/rm -rf \"$(_virtual_env_dir \"$venv_name\")\"\n        /bin/rm \"$AUTOSWITCH_FILE\"\n    else\n        printf \"No $AUTOSWITCH_FILE file in the current directory!\\n\"\n    fi\n}\n\n\n# helper function to create a virtual environment for the current directory\nfunction mkvenv()\n{\n    if ! type \"virtualenv\" > /dev/null; then\n        printf \"${BOLD}${RED}\"\n        printf \"zsh-autoswitch-virtualenv requires virtualenv to be installed!\\n\\n\"\n        printf \"${NORMAL}\"\n        printf \"If this is already installed but you are still seeing this message, \\n\"\n        printf \"then make sure the ${BOLD}virtualenv${NORMAL} command is in your PATH.\\n\"\n        printf \"\\n\"\n        return\n    fi\n\n    if [[ -f \"$AUTOSWITCH_FILE\" ]]; then\n        printf \"$AUTOSWITCH_FILE file already exists. If this is a mistake use the rmvenv command\\n\"\n    else\n        local venv_name=\"$(basename $PWD)\"\n\n        printf \"Creating ${PURPLE}%s${NONE} virtualenv\\n\" \"$venv_name\"\n\n        # Copy parameters variable so that we can mutate it\n        local params=(\"${@[@]}\")\n\n        if [[ -n \"$AUTOSWITCH_DEFAULT_PYTHON\" && ${params[(I)--python*]} -eq 0 ]]; then\n            params+=\"--python=$AUTOSWITCH_DEFAULT_PYTHON\"\n        fi\n\n        if [[ ${params[(I)--verbose]} -eq 0 ]]; then\n            virtualenv $params \"$(_virtual_env_dir \"$venv_name\")\"\n        else\n            virtualenv $params \"$(_virtual_env_dir \"$venv_name\")\" > /dev/null\n        fi\n\n        printf \"$venv_name\\n\" > \"$AUTOSWITCH_FILE\"\n        chmod 600 \"$AUTOSWITCH_FILE\"\n\n        _maybeworkon \"$(_virtual_env_dir \"$venv_name\")\" \"virtualenv\"\n\n        install_requirements\n    fi\n}\n\n\nfunction install_requirements() {\n    if [[ -f \"$AUTOSWITCH_DEFAULT_REQUIREMENTS\" ]]; then\n        printf \"Install default requirements? (${PURPLE}$AUTOSWITCH_DEFAULT_REQUIREMENTS${NORMAL}) [y/N]: \"\n        read ans\n\n        if [[ \"$ans\" = \"y\" || \"$ans\" == \"Y\" ]]; then\n            pip install -r \"$AUTOSWITCH_DEFAULT_REQUIREMENTS\"\n        fi\n    fi\n\n    if [[ -f \"$PWD/setup.py\" ]]; then\n        printf \"Found a ${PURPLE}setup.py${NORMAL} file. Install dependencies? [y/N]: \"\n        read ans\n\n        if [[ \"$ans\" = \"y\" || \"$ans\" = \"Y\" ]]; then\n            if [[ \"$AUTOSWITCH_PIPINSTALL\" = \"FULL\" ]]\n            then\n                pip install .\n            else\n                pip install -e .\n            fi\n        fi\n    fi\n\n    setopt nullglob\n    local requirements\n    for requirements in **/*requirements.txt\n    do\n        printf \"Found a ${PURPLE}%s${NORMAL} file. Install? [y/N]: \" \"$requirements\"\n        read ans\n\n        if [[ \"$ans\" = \"y\" || \"$ans\" = \"Y\" ]]; then\n            pip install -r \"$requirements\"\n        fi\n    done\n}\n\n\nfunction enable_autoswitch_virtualenv() {\n    autoload -Uz add-zsh-hook\n    disable_autoswitch_virtualenv\n    add-zsh-hook chpwd check_venv\n}\n\n\nfunction disable_autoswitch_virtualenv() {\n    add-zsh-hook -D chpwd check_venv\n}\n\n\nenable_autoswitch_virtualenv\ncheck_venv\n", "#!/usr/bin/env zunit\n\n\n@setup {\n    TEST_VIRTUALENV=\"$HOME/.virtualenvs/foobar/\"\n\n    if [[ ! -d \"$TEST_VIRTUALENV\" ]]; then\n        echo \"Creating test virtualenv\"\n        run python -m virtualenv \"$TEST_VIRTUALENV\" --python=python3\n    fi\n\n    unset AUTOSWITCH_MESSAGE_FORMAT\n    PYTHON_VERSION=\"$(python3 --version 2>&1)\"\n\n    export DISABLE_AUTOSWITCH_VENV=\"1\"\n    load \"../autoswitch_virtualenv.plugin.zsh\"\n    TARGET=\"$(mktemp -d)\"\n\n    LANG=\".UTF-8\"\n}\n\n@teardown {\n    rm -rf \"$TARGET\"\n}\n\n@test '_maybeworkon - do not activate paths which are potentially inscure' {\n    VIRTUAL_ENV=\"\"\n\n    run _maybeworkon \"$TARGET/../../../\" virtualenv\n\n    assert $state equals 0\n\n    # first line would be the \"switching virtualenv: ....\"\n    assert \"${lines[2]}\" same_as \"AUTOSWITCH WARNING: target virtualenv contains invalid characters\"\n    assert \"${lines[3]}\" same_as \"virtualenv activation cancelled\"\n}\n\n@test '_maybeworkon - error message if virtualenv can not be found' {\n    VIRTUAL_ENV=\"\"\n\n    run _maybeworkon $HOME/.virtualenvs/idontexist virtualenv\n\n    assert $state equals 0\n    assert \"${lines[1]}\" same_as \"Unable to find \\e[35midontexist\\e[0m virtualenv\"\n    assert \"${lines[2]}\" same_as \"If the issue persists run \\e[35mrmvenv && mkvenv\\e[0m in this directory\"\n}\n\n\n@test '_maybeworkon - switches virtualenv if nothing is activated' {\n    VIRTUAL_ENV=\"\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" virtualenv\n\n    assert $state equals 0\n    assert \"$output\" same_as \"Switching virtualenv: \\e[1m\\e[35mfoobar\\e[0m \\e[32m[\ud83d\udc0d$PYTHON_VERSION]\\e[0m\"\n}\n\n@test '_maybeworkon - custom message' {\n    VIRTUAL_ENV=\"\"\n    AUTOSWITCH_MESSAGE_FORMAT=\"Hello %venv_type - this is %venv_name (%py_version)\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" cheese\n\n    assert $state equals 0\n    assert \"$output\" same_as \"Hello cheese - this is foobar ($PYTHON_VERSION)\"\n}\n\n@test '_maybeworkon - no emoji on non utf-8 LANG' {\n    VIRTUAL_ENV=\"\"\n    LANG=\"ASCII\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" virtualenv\n\n    assert $state equals 0\n    assert \"$output\" same_as \"Switching virtualenv: \\e[1m\\e[35mfoobar\\e[0m \\e[32m[$PYTHON_VERSION]\\e[0m\"\n}\n\n@test '_maybeworkon - switches virtualenv if current virtualenv is different' {\n    VIRTUAL_ENV=\"$HOME/.virtualenvs/default_venv\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" virtualfoo\n\n    assert $state equals 0\n    assert \"$output\" contains \"Switching virtualfoo: \\e[1m\\e[35mfoobar\\e[0m \\e[32m[\ud83d\udc0d$PYTHON_VERSION]\\e[0m\"\n}\n\n@test '_maybeworkon - switches virtualenv if current virtualenv is different (silent)' {\n    VIRTUAL_ENV=\"$HOME/.virtualenvs/default_venv\"\n    AUTOSWITCH_SILENT=\"1\"\n\n    run _maybeworkon \"$TEST_VIRTUALENV\" virtualenv\n\n    assert $state equals 0\n    assert \"$output\" is_empty\n}\n\n@test '_maybeworkon - does not switch to already activated virtualenv' {\n    VIRTUAL_ENV=\"$HOME/.virtualenvs/bwaaah\"\n\n    run _maybeworkon bwaaah virtualenv\n\n    assert $state equals 0\n    assert \"$output\" is_empty\n}\n\n@test '_maybeworkon - pipenv name cleaned' [\n    run _maybeworkon hello-world-foo-de31f pipenv\n\n    assert $state equals 0\n    assert \"$output\" same_as \"Switching pipenv: \\e[1m\\e[35mhello-world-foo\\e[0m \\e[32m[\ud83d\udc0d$PYTHON_VERSION]\\e[0m\"\n}\n"], "filenames": ["CHANGELOG.rst", "autoswitch_virtualenv.plugin.zsh", "tests/test_maybeworkon.zunit"], "buggy_code_start_loc": [2, 1, 23], "buggy_code_end_loc": [2, 97, 23], "fixing_code_start_loc": [3, 1, 24], "fixing_code_end_loc": [7, 113, 36], "type": "CWE-22", "message": "In Autoswitch Python Virtualenv before version 0.16.0, a user who enters a directory with a malicious `.venv` file could run arbitrary code without any user interaction. This is fixed in version: 1.16.0", "other": {"cve": {"id": "CVE-2020-11073", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-13T19:15:11.863", "lastModified": "2021-11-04T17:51:43.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Autoswitch Python Virtualenv before version 0.16.0, a user who enters a directory with a malicious `.venv` file could run arbitrary code without any user interaction. This is fixed in version: 1.16.0"}, {"lang": "es", "value": "En Autoswitch Python Virtualenv versiones anteriores a 0.16.0, un usuario que ingresa a un directorio con un archivo malicioso \".venv\" podr\u00eda ejecutar c\u00f3digo arbitrario sin interacci\u00f3n del usuario. Esto es corregido en la versi\u00f3n: 1.16.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:autoswitch_python_virtualenv_project:autoswitch_python_virtualenv:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.0", "matchCriteriaId": "FBFC8718-42EA-4765-B37C-9F5840333015"}]}]}], "references": [{"url": "https://github.com/MichaelAquilina/zsh-autoswitch-virtualenv/commit/30c77db7c83eca2bc5f6134fccbdc117b49a6a05", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/MichaelAquilina/zsh-autoswitch-virtualenv/issues/122", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/MichaelAquilina/zsh-autoswitch-virtualenv/pull/123", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/MichaelAquilina/zsh-autoswitch-virtualenv/security/advisories/GHSA-h8wm-cqq6-957q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MichaelAquilina/zsh-autoswitch-virtualenv/commit/30c77db7c83eca2bc5f6134fccbdc117b49a6a05"}}