{"buggy_code": ["/* Crop support\n * manual crop using a gdRect or automatic crop using a background\n * color (automatic detections or using either the transparent color,\n * black or white).\n * An alternative method allows to crop using a given color and a\n * threshold. It works relatively well but it can be improved.\n * Maybe L*a*b* and Delta-E will give better results (and a better\n * granularity).\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gd_color.h\"\n\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color);\n\nBGD_DECLARE(gdImagePtr) gdImageCrop(gdImagePtr src, const gdRect *crop)\n{\n\tgdImagePtr dst;\n\n\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\tif (!dst) return NULL;\n\tgdImageCopy(dst, src, 0, 0, crop->x, crop->y, crop->width, crop->height);\n\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCropAuto(gdImagePtr im, const unsigned int mode)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint color, match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\tswitch (mode) {\n\tcase GD_CROP_TRANSPARENT:\n\t\tcolor = gdImageGetTransparent(im);\n\t\tbreak;\n\n\tcase GD_CROP_BLACK:\n\t\tcolor = gdImageColorClosestAlpha(im, 0, 0, 0, 0);\n\t\tbreak;\n\n\tcase GD_CROP_WHITE:\n\t\tcolor = gdImageColorClosestAlpha(im, 255, 255, 255, 0);\n\t\tbreak;\n\n\tcase GD_CROP_SIDES:\n\t\tgdGuessBackgroundColorFromCorners(im, &color);\n\t\tbreak;\n\n\tcase GD_CROP_DEFAULT:\n\tdefault:\n\t\tcolor = gdImageGetTransparent(im);\n\t\tbreak;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\n\t/* Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n\n/* This algorithm comes from pnmcrop (http://netpbm.sourceforge.net/)\n * Three steps:\n *  - if 3 corners are equal.\n *  - if two are equal.\n *  - Last solution: average the colors\n */\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color)\n{\n\tconst int tl = gdImageGetPixel(im, 0, 0);\n\tconst int tr = gdImageGetPixel(im, gdImageSX(im) - 1, 0);\n\tconst int bl = gdImageGetPixel(im, 0, gdImageSY(im) -1);\n\tconst int br = gdImageGetPixel(im, gdImageSX(im) - 1, gdImageSY(im) -1);\n\n\tif (tr == bl && tr == br) {\n\t\t*color = tr;\n\t\treturn 3;\n\t} else if (tl == bl && tl == br) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr &&  tl == br) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr &&  tl == bl) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr  || tl == bl || tl == br) {\n\t\t*color = tl;\n\t\treturn 2;\n\t} else if (tr == bl) {\n\t\t*color = tr;\n\t\treturn 2;\n\t} else if (br == bl) {\n\t\t*color = bl;\n\t\treturn 2;\n\t} else {\n\t\tregister int r,b,g,a;\n\n\t\tr = (int)(0.5f + (gdImageRed(im, tl) + gdImageRed(im, tr) + gdImageRed(im, bl) + gdImageRed(im, br)) / 4);\n\t\tg = (int)(0.5f + (gdImageGreen(im, tl) + gdImageGreen(im, tr) + gdImageGreen(im, bl) + gdImageGreen(im, br)) / 4);\n\t\tb = (int)(0.5f + (gdImageBlue(im, tl) + gdImageBlue(im, tr) + gdImageBlue(im, bl) + gdImageBlue(im, br)) / 4);\n\t\ta = (int)(0.5f + (gdImageAlpha(im, tl) + gdImageAlpha(im, tr) + gdImageAlpha(im, bl) + gdImageAlpha(im, br)) / 4);\n\t\t*color = gdImageColorClosestAlpha(im, r, g, b, a);\n\t\treturn 0;\n\t}\n}\n", "\nif (BUILD_TEST)\n\tSET(DART_TESTING_TIMEOUT 5)\n\n\tINCLUDE(Dart)\n\n\tset(GDTEST_SOURCE_DIR ${GD_SOURCE_DIR}/tests/gdtest)\n\n\tIF (ENABLE_GCOV AND CMAKE_COMPILER_IS_GNUCC)\n\t\tSET(CMAKE_BUILD_TYPE TESTINGGCOV)\n\t\tSET(CMAKE_CXX_FLAGS_TESTINGGCOV \"-g3 -O0\")\n\t\tSET(CMAKE_C_FLAGS_TESTINGGCOV \"-g3 -O0\")\n\tendif (ENABLE_GCOV AND CMAKE_COMPILER_IS_GNUCC)\n\n\tmessage(STATUS \"gd include dir: ${GD_INCLUDE_DIR}\" )\n\tmessage(STATUS \"gd libs dir: ${GD_LIBS_DIR}\" )\n\n\tinclude_directories (BEFORE ${GD_INCLUDE_DIR} \"${GDTEST_SOURCE_DIR}\" \"${CMAKE_BINARY_DIR}\" \"${CMAKE_BINARY_DIR}/tests/gdtest\")\n\n\tSET(TESTS_DIRS\n\t\tbmp\n\t\tfreetype\n\t\tgd\n\t\tgd2\n\t\tgdimagearc\n\t\tgdimagecolorclosest\n\t\tgdimagecolordeallocate\n\t\tgdimagecolorexact\n\t\tgdimagecolorreplace\n\t\tgdimagecolorresolve\n\t\tgdimagecolortransparent\n\t\tgdimagecopy\n\t\tgdimagecopyrotated\n\t\tgdimagefile\n\t\tgdimagefill\n\t\tgdimagefilledellipse\n\t\tgdimagefilledpolygon\n\t\tgdimagefilledrectangle\n\t\tgdimagefilltoborder\n\t\tgdimagefilter\n\t\tgdimageline\n\t\tgdimageopenpolygon\n\t\tgdimagepixelate\n\t\tgdimagepolygon\n\t\tgdimagerectangle\n\t\tgdimagerotate\n\t\tgdimagescale\n\t\tgdimagescatterex\n\t\tgdimagesetpixel\n\t\tgdimagestringft\n\t\tgdimagestringftex\n\t\tgdinterpolatedscale\n\t\tgdnewfilectx\n\t\tgdtest\n\t\tgdtiled\n\t\tgdtransformaffineboundingbox\n\t\tgif\n\t\tjpeg\n\t\tpng\n\t\ttga\n\t\ttiff\n\t\twbmp\n\t\twebp\n\t\txbm\n\t\txpm\n\t)\n\n\tFOREACH(test_dir ${TESTS_DIRS})\n\t\tadd_subdirectory (${test_dir})\n\tENDFOREACH(test_dir)\n\nendif (BUILD_TEST)\n", "check_LIBRARIES = libgdtest.a\n\nlibgdtest_a_SOURCES = \\\n\tgdtest/gdtest.c \\\n\tgdtest/gdtest.h \\\n\tgdhelpers.c\n\n# Setup vars that subdirs will increment.\nlibgd_test_programs =\nlibgd_helper_programs =\nCLEANFILES =\nEXTRA_DIST =\nTESTS =\n\ninclude bmp/Makemodule.am\ninclude freetype/Makemodule.am\ninclude gd/Makemodule.am\ninclude gd2/Makemodule.am\ninclude gdimagearc/Makemodule.am\ninclude gdimagecolorclosest/Makemodule.am\ninclude gdimagecolordeallocate/Makemodule.am\ninclude gdimagecolorexact/Makemodule.am\ninclude gdimagecolorreplace/Makemodule.am\ninclude gdimagecolorresolve/Makemodule.am\ninclude gdimagecolortransparent/Makemodule.am\ninclude gdimagecopy/Makemodule.am\ninclude gdimagecopyrotated/Makemodule.am\ninclude gdimagefile/Makemodule.am\ninclude gdimagefill/Makemodule.am\ninclude gdimagefilledellipse/Makemodule.am\ninclude gdimagefilledpolygon/Makemodule.am\ninclude gdimagefilledrectangle/Makemodule.am\ninclude gdimagefilltoborder/Makemodule.am\ninclude gdimagefilter/Makemodule.am\ninclude gdimageline/Makemodule.am\ninclude gdimageopenpolygon/Makemodule.am\ninclude gdimagepixelate/Makemodule.am\ninclude gdimagepolygon/Makemodule.am\ninclude gdimagerectangle/Makemodule.am\ninclude gdimagerotate/Makemodule.am\ninclude gdimagescale/Makemodule.am\ninclude gdimagescatterex/Makemodule.am\ninclude gdimagesetpixel/Makemodule.am\ninclude gdimagestringft/Makemodule.am\ninclude gdimagestringftex/Makemodule.am\ninclude gdinterpolatedscale/Makemodule.am\ninclude gdnewfilectx/Makemodule.am\ninclude gdtest/Makemodule.am\ninclude gdtiled/Makemodule.am\ninclude gdtransformaffineboundingbox/Makemodule.am\ninclude gif/Makemodule.am\ninclude jpeg/Makemodule.am\ninclude png/Makemodule.am\ninclude tga/Makemodule.am\ninclude tiff/Makemodule.am\ninclude wbmp/Makemodule.am\ninclude webp/Makemodule.am\ninclude xbm/Makemodule.am\ninclude xpm/Makemodule.am\n\nLDADD = libgdtest.a ../src/libgd.la\nAM_CPPFLAGS = -I$(top_srcdir)/src -I $(top_srcdir)/tests/gdtest\n\ncheck_PROGRAMS = $(libgd_test_programs) $(libgd_helper_programs)\nTESTS += $(libgd_test_programs)\n\nEXTRA_DIST += \\\n\tCMakeLists.txt\n\n# We don't keep any media files in the top dir ... just generated outputs.\nCLEANFILES += \\\n\t*.bmp \\\n\t*.gd \\\n\t*.gd2 \\\n\t*.gif \\\n\t*.jpeg \\\n\t*.jpg \\\n\t*.png \\\n\t*.tga \\\n\t*.tiff \\\n\t*.ttf \\\n\t*.wbmp \\\n\t*.webp \\\n\t*.xbm \\\n\t*.xpm\n"], "fixing_code": ["/* Crop support\n * manual crop using a gdRect or automatic crop using a background\n * color (automatic detections or using either the transparent color,\n * black or white).\n * An alternative method allows to crop using a given color and a\n * threshold. It works relatively well but it can be improved.\n * Maybe L*a*b* and Delta-E will give better results (and a better\n * granularity).\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gd_color.h\"\n\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color);\n\nBGD_DECLARE(gdImagePtr) gdImageCrop(gdImagePtr src, const gdRect *crop)\n{\n\tgdImagePtr dst;\n\n\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\tif (!dst) return NULL;\n\tgdImageCopy(dst, src, 0, 0, crop->x, crop->y, crop->width, crop->height);\n\n\treturn dst;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCropAuto(gdImagePtr im, const unsigned int mode)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint color, match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\tswitch (mode) {\n\tcase GD_CROP_TRANSPARENT:\n\t\tcolor = gdImageGetTransparent(im);\n\t\tbreak;\n\n\tcase GD_CROP_BLACK:\n\t\tcolor = gdImageColorClosestAlpha(im, 0, 0, 0, 0);\n\t\tbreak;\n\n\tcase GD_CROP_WHITE:\n\t\tcolor = gdImageColorClosestAlpha(im, 255, 255, 255, 0);\n\t\tbreak;\n\n\tcase GD_CROP_SIDES:\n\t\tgdGuessBackgroundColorFromCorners(im, &color);\n\t\tbreak;\n\n\tcase GD_CROP_DEFAULT:\n\tdefault:\n\t\tcolor = gdImageGetTransparent(im);\n\t\tbreak;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\n\t/* Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (color == gdImageGetPixel(im, x,y));\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n\n/* This algorithm comes from pnmcrop (http://netpbm.sourceforge.net/)\n * Three steps:\n *  - if 3 corners are equal.\n *  - if two are equal.\n *  - Last solution: average the colors\n */\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color)\n{\n\tconst int tl = gdImageGetPixel(im, 0, 0);\n\tconst int tr = gdImageGetPixel(im, gdImageSX(im) - 1, 0);\n\tconst int bl = gdImageGetPixel(im, 0, gdImageSY(im) -1);\n\tconst int br = gdImageGetPixel(im, gdImageSX(im) - 1, gdImageSY(im) -1);\n\n\tif (tr == bl && tr == br) {\n\t\t*color = tr;\n\t\treturn 3;\n\t} else if (tl == bl && tl == br) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr &&  tl == br) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr &&  tl == bl) {\n\t\t*color = tl;\n\t\treturn 3;\n\t} else if (tl == tr  || tl == bl || tl == br) {\n\t\t*color = tl;\n\t\treturn 2;\n\t} else if (tr == bl) {\n\t\t*color = tr;\n\t\treturn 2;\n\t} else if (br == bl) {\n\t\t*color = bl;\n\t\treturn 2;\n\t} else {\n\t\tregister int r,b,g,a;\n\n\t\tr = (int)(0.5f + (gdImageRed(im, tl) + gdImageRed(im, tr) + gdImageRed(im, bl) + gdImageRed(im, br)) / 4);\n\t\tg = (int)(0.5f + (gdImageGreen(im, tl) + gdImageGreen(im, tr) + gdImageGreen(im, bl) + gdImageGreen(im, br)) / 4);\n\t\tb = (int)(0.5f + (gdImageBlue(im, tl) + gdImageBlue(im, tr) + gdImageBlue(im, bl) + gdImageBlue(im, br)) / 4);\n\t\ta = (int)(0.5f + (gdImageAlpha(im, tl) + gdImageAlpha(im, tr) + gdImageAlpha(im, bl) + gdImageAlpha(im, br)) / 4);\n\t\t*color = gdImageColorClosestAlpha(im, r, g, b, a);\n\t\treturn 0;\n\t}\n}\n", "\nif (BUILD_TEST)\n\tSET(DART_TESTING_TIMEOUT 5)\n\n\tINCLUDE(Dart)\n\n\tset(GDTEST_SOURCE_DIR ${GD_SOURCE_DIR}/tests/gdtest)\n\n\tIF (ENABLE_GCOV AND CMAKE_COMPILER_IS_GNUCC)\n\t\tSET(CMAKE_BUILD_TYPE TESTINGGCOV)\n\t\tSET(CMAKE_CXX_FLAGS_TESTINGGCOV \"-g3 -O0\")\n\t\tSET(CMAKE_C_FLAGS_TESTINGGCOV \"-g3 -O0\")\n\tendif (ENABLE_GCOV AND CMAKE_COMPILER_IS_GNUCC)\n\n\tmessage(STATUS \"gd include dir: ${GD_INCLUDE_DIR}\" )\n\tmessage(STATUS \"gd libs dir: ${GD_LIBS_DIR}\" )\n\n\tinclude_directories (BEFORE ${GD_INCLUDE_DIR} \"${GDTEST_SOURCE_DIR}\" \"${CMAKE_BINARY_DIR}\" \"${CMAKE_BINARY_DIR}/tests/gdtest\")\n\n\tSET(TESTS_DIRS\n\t\tbmp\n\t\tfreetype\n\t\tgd\n\t\tgd2\n\t\tgdimagearc\n\t\tgdimagecolorclosest\n\t\tgdimagecolordeallocate\n\t\tgdimagecolorexact\n\t\tgdimagecolorreplace\n\t\tgdimagecolorresolve\n\t\tgdimagecolortransparent\n\t\tgdimagecopy\n\t\tgdimagecopyrotated\n        gdimagecrop\n\t\tgdimagefile\n\t\tgdimagefill\n\t\tgdimagefilledellipse\n\t\tgdimagefilledpolygon\n\t\tgdimagefilledrectangle\n\t\tgdimagefilltoborder\n\t\tgdimagefilter\n\t\tgdimageline\n\t\tgdimageopenpolygon\n\t\tgdimagepixelate\n\t\tgdimagepolygon\n\t\tgdimagerectangle\n\t\tgdimagerotate\n\t\tgdimagescale\n\t\tgdimagescatterex\n\t\tgdimagesetpixel\n\t\tgdimagestringft\n\t\tgdimagestringftex\n\t\tgdinterpolatedscale\n\t\tgdnewfilectx\n\t\tgdtest\n\t\tgdtiled\n\t\tgdtransformaffineboundingbox\n\t\tgif\n\t\tjpeg\n\t\tpng\n\t\ttga\n\t\ttiff\n\t\twbmp\n\t\twebp\n\t\txbm\n\t\txpm\n\t)\n\n\tFOREACH(test_dir ${TESTS_DIRS})\n\t\tadd_subdirectory (${test_dir})\n\tENDFOREACH(test_dir)\n\nendif (BUILD_TEST)\n", "check_LIBRARIES = libgdtest.a\n\nlibgdtest_a_SOURCES = \\\n\tgdtest/gdtest.c \\\n\tgdtest/gdtest.h \\\n\tgdhelpers.c\n\n# Setup vars that subdirs will increment.\nlibgd_test_programs =\nlibgd_helper_programs =\nCLEANFILES =\nEXTRA_DIST =\nTESTS =\n\ninclude bmp/Makemodule.am\ninclude freetype/Makemodule.am\ninclude gd/Makemodule.am\ninclude gd2/Makemodule.am\ninclude gdimagearc/Makemodule.am\ninclude gdimagecolorclosest/Makemodule.am\ninclude gdimagecolordeallocate/Makemodule.am\ninclude gdimagecolorexact/Makemodule.am\ninclude gdimagecolorreplace/Makemodule.am\ninclude gdimagecolorresolve/Makemodule.am\ninclude gdimagecolortransparent/Makemodule.am\ninclude gdimagecopy/Makemodule.am\ninclude gdimagecopyrotated/Makemodule.am\ninclude gdimagecrop/Makemodule.am\ninclude gdimagefile/Makemodule.am\ninclude gdimagefill/Makemodule.am\ninclude gdimagefilledellipse/Makemodule.am\ninclude gdimagefilledpolygon/Makemodule.am\ninclude gdimagefilledrectangle/Makemodule.am\ninclude gdimagefilltoborder/Makemodule.am\ninclude gdimagefilter/Makemodule.am\ninclude gdimageline/Makemodule.am\ninclude gdimageopenpolygon/Makemodule.am\ninclude gdimagepixelate/Makemodule.am\ninclude gdimagepolygon/Makemodule.am\ninclude gdimagerectangle/Makemodule.am\ninclude gdimagerotate/Makemodule.am\ninclude gdimagescale/Makemodule.am\ninclude gdimagescatterex/Makemodule.am\ninclude gdimagesetpixel/Makemodule.am\ninclude gdimagestringft/Makemodule.am\ninclude gdimagestringftex/Makemodule.am\ninclude gdinterpolatedscale/Makemodule.am\ninclude gdnewfilectx/Makemodule.am\ninclude gdtest/Makemodule.am\ninclude gdtiled/Makemodule.am\ninclude gdtransformaffineboundingbox/Makemodule.am\ninclude gif/Makemodule.am\ninclude jpeg/Makemodule.am\ninclude png/Makemodule.am\ninclude tga/Makemodule.am\ninclude tiff/Makemodule.am\ninclude wbmp/Makemodule.am\ninclude webp/Makemodule.am\ninclude xbm/Makemodule.am\ninclude xpm/Makemodule.am\n\nLDADD = libgdtest.a ../src/libgd.la\nAM_CPPFLAGS = -I$(top_srcdir)/src -I $(top_srcdir)/tests/gdtest\n\ncheck_PROGRAMS = $(libgd_test_programs) $(libgd_helper_programs)\nTESTS += $(libgd_test_programs)\n\nEXTRA_DIST += \\\n\tCMakeLists.txt\n\n# We don't keep any media files in the top dir ... just generated outputs.\nCLEANFILES += \\\n\t*.bmp \\\n\t*.gd \\\n\t*.gd2 \\\n\t*.gif \\\n\t*.jpeg \\\n\t*.jpg \\\n\t*.png \\\n\t*.tga \\\n\t*.tiff \\\n\t*.ttf \\\n\t*.wbmp \\\n\t*.webp \\\n\t*.xbm \\\n\t*.xpm\n"], "filenames": ["src/gd_crop.c", "tests/CMakeLists.txt", "tests/Makefile.am"], "buggy_code_start_loc": [138, 33, 27], "buggy_code_end_loc": [138, 33, 27], "fixing_code_start_loc": [139, 34, 28], "fixing_code_end_loc": [143, 35, 29], "type": "CWE-20", "message": "The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index.", "other": {"cve": {"id": "CVE-2016-6128", "sourceIdentifier": "security@debian.org", "published": "2016-08-07T10:59:22.650", "lastModified": "2020-11-16T19:24:49.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index."}, {"lang": "es", "value": "La funci\u00f3n gdImageCropThreshold en gd_crop.c en la GD Graphics Library (tambi\u00e9n conocido como libgd) en versiones anteriores a 2.2.3, como se utiliza en PHP en versiones anteriores a 7.0.9, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de un \u00edndice de color invalido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgd:libgd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.2", "matchCriteriaId": "CABE614C-FFD3-4B02-B5DF-658185F8D874"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6.0", "versionEndIncluding": "5.6.24", "matchCriteriaId": "7006DF7F-F0B3-419F-A78C-9424D62520BA"}, {"vulnerable": false, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.9", "matchCriteriaId": "E03A748C-D25C-4E3F-B636-F6E45A9A92CC"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00086.html", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-09/msg00078.html", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2750.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3619", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/06/30/1", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91509", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1036276", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-3030-1", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.php.net/72494", "source": "security@debian.org", "tags": ["Issue Tracking", "Permissions Required"]}, {"url": "https://github.com/libgd/libgd/commit/1ccfe21e14c4d18336f9da8515cd17db88c3de61", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgd/libgd/commit/6ff72ae40c7c20ece939afb362d98cc37f4a1c96", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://libgd.github.io/release-2.2.3.html", "source": "security@debian.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201612-09", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libgd/libgd/commit/1ccfe21e14c4d18336f9da8515cd17db88c3de61"}}