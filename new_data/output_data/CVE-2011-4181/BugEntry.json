{"buggy_code": ["class BuildController < ApplicationController\n\n  def index\n    valid_http_methods :get, :post, :put\n\n    # for permission check\n    if params[:package] and not [\"_repository\", \"_jobhistory\"].include?(params[:package])\n      pkg = DbPackage.get_by_project_and_name( params[:project], params[:package], use_source=false )\n    else\n      prj = DbProject.get_by_name params[:project]\n    end\n\n    pass_to_backend \n  end\n\n  def project_index\n    valid_http_methods :get, :post, :put\n\n    prj = nil\n    unless params[:project] == \"_dispatchprios\"\n      prj = DbProject.get_by_name params[:project]\n    end\n\n    if request.get?\n      pass_to_backend\n      return\n    elsif request.post?\n      #check if user has project modify rights\n      allowed = false\n      allowed = true if permissions.global_project_change\n      allowed = true if permissions.project_change? prj\n\n      #check for cmd parameter\n      if params[:cmd].nil?\n        render_error :status => 400, :errorcode => \"missing_parameter\",\n          :message => \"Missing parameter 'cmd'\"\n        return\n      end\n\n      unless [\"wipe\", \"restartbuild\", \"killbuild\", \"abortbuild\", \"rebuild\"].include? params[:cmd]\n        render_error :status => 400, :errorcode => \"illegal_request\",\n          :message => \"unsupported POST command #{params[:cmd]} to #{request.request_uri}\"\n        return\n      end\n\n      unless prj.class == DbProject\n        render_error :status => 403, :errorcode => \"readonly_error\",\n          :message => \"The project #{params[:project]} is a remote project and therefore readonly.\"\n        return\n      end\n\n      if not allowed and not params[:package].nil?\n        package_names = nil\n        if params[:package].kind_of? Array\n          package_names = params[:package]\n        else\n          package_names = [params[:package]]\n        end\n        package_names.each do |pack_name|\n          pkg = DbPackage.find_by_project_and_name( prj.name, pack_name ) \n          if pkg.nil?\n            allowed = permissions.project_change? prj\n            if not allowed\n              render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n                :message => \"No permission to execute command on package #{pack_name} in project #{prj.name}\"\n              return\n            end\n          else\n            allowed = permissions.package_change? pkg\n            if not allowed\n              render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n                :message => \"No permission to execute command on package #{pack_name}\"\n              return\n            end\n          end\n        end\n      end\n\n      if not allowed\n        render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n          :message => \"No permission to execute command on project #{params[:project]}\"\n        return\n      end\n\n      pass_to_backend\n      return\n    elsif request.put? \n      if @http_user.is_admin?\n        pass_to_backend\n      else\n        render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n          :message => \"No permission to execute command on project #{params[:project]}\"\n      end\n      return\n    else\n      render_error :status => 400, :errorcode => 'illegal_request',\n        :message => \"Illegal request: #{request.method.to_s.upcase} #{request.path}\"\n      return\n    end\n  end\n\n  def buildinfo\n    valid_http_methods :get, :post\n    required_parameters :project, :repository, :arch, :package\n    # just for permission checking\n    if request.post? and params[:package] == \"_repository\"\n      # for osc local package build in this repository\n      DbProject.get_by_name params[:project]\n    else\n      DbPackage.get_by_project_and_name params[:project], params[:package], use_source=false\n    end\n\n    path = \"/build/#{params[:project]}/#{params[:repository]}/#{params[:arch]}/#{params[:package]}/_buildinfo\"\n    unless request.query_string.empty?\n      path += '?' + request.query_string\n    end\n\n    pass_to_backend path\n  end\n\n  def builddepinfo\n    valid_http_methods :get\n    required_parameters :project, :repository, :arch\n\n    # just for permission checking\n    DbProject.get_by_name params[:project]\n\n    pass_to_backend\n  end\n\n  # /build/:prj/:repo/:arch/:pkg\n  def package_index\n    valid_http_methods :get\n    required_parameters :project, :repository, :arch, :package\n\n    # read access permission check\n    if params[:package] == \"_repository\"\n      prj = DbProject.get_by_name params[:project], use_source=false\n    else\n      pkg = DbPackage.get_by_project_and_name params[:project], params[:package], use_source=false\n    end\n\n    pass_to_backend\n  end\n\n  # /build/:project/:repository/:arch/:package/:filename\n  def file\n    valid_http_methods :get, :delete\n    required_parameters :project, :repository, :arch, :package, :filename\n\n    # read access permission check\n    prj = nil\n    if params[:package] == \"_repository\"\n      prj = DbProject.get_by_name params[:project]\n    else\n      pkg = DbPackage.get_by_project_and_name params[:project], params[:package], use_source=false\n      prj = pkg.db_project if pkg.class == DbPackage\n    end\n\n    if prj.class == DbProject and prj.disabled_for?('binarydownload', params[:repository], params[:arch]) and not @http_user.can_download_binaries?(prj)\n      render_error :status => 403, :errorcode => \"download_binary_no_permission\",\n      :message => \"No permission to download binaries from package #{params[:package]}, project #{params[:project]}\"\n      return\n    end\n\n    path = request.path+\"?\"+request.query_string\n\n    if request.delete?\n      unless permissions.project_change? params[:project]\n        render_error :status => 403, :errorcode => \"delete_binary_no_permission\",\n          :message => \"No permission to delete binaries from project #{params[:project]}\"\n        return\n      end\n\n      if params[:package] == \"_repository\"\n        pass_to_backend\n      else\n        render_error :status => 400, :errorcode => \"invalid_operation\",\n          :message => \"Delete operation of build results is not allowed\"\n      end\n\n      return\n    end\n\n    regexp = nil\n    # if there is a query, we can't assume it's a simple download, so better leave out the logic (e.g. view=fileinfo)\n    unless request.query_string\n      #check if binary exists and for size\n      fpath = \"/build/\"+[:project,:repository,:arch,:package].map {|x| params[x]}.join(\"/\")\n      file_list = Suse::Backend.get(fpath)\n      regexp = file_list.body.match(/name=[\"']#{Regexp.quote params[:filename]}[\"'].*size=[\"']([^\"']*)[\"']/)\n    end\n    if regexp\n      fsize = regexp[1]\n      logger.info \"streaming #{path}\"\n\n      c_type = case params[:filename].split(/\\./)[-1]\n               when \"rpm\"\n                 \"application/x-rpm\"\n               when \"deb\"\n                 \"application/x-deb\"\n               when \"iso\"\n                 \"application/x-cd-image\"\n               else\n                 \"application/octet-stream\"\n               end\n\n      headers.update(\n        'Content-Disposition' => %(attachment; filename=\"#{params[:filename]}\"),\n        'Content-Type' => c_type,\n        'Transfer-Encoding' => 'binary',\n        'Content-Length' => fsize\n      )\n      \n      render :status => 200, :text => Proc.new {|request,output|\n        backend_request = Net::HTTP::Get.new(path)\n        Net::HTTP.start(SOURCE_HOST,SOURCE_PORT) do |http|\n          http.request(backend_request) do |response|\n            response.read_body do |chunk|\n              output.write(chunk)\n            end\n          end\n        end\n      }\n    else\n      pass_to_backend path\n    end\n  end\n\n  def logfile\n    valid_http_methods :get\n\n    # for permission check\n    pkg = DbPackage.get_by_project_and_name params[:project], params[:package]\n\n    if pkg.class == DbPackage and pkg.db_project.disabled_for?('binarydownload', params[:repository], params[:arch]) and not @http_user.can_download_binaries?(pkg.db_project)\n      render_error :status => 403, :errorcode => \"download_binary_no_permission\",\n      :message => \"No permission to download binaries from package #{params[:package]}, project #{params[:project]}\"\n      return\n    end\n\n    pass_to_backend\n  end\n\n  def result\n    valid_http_methods :get\n    # for permission check\n    prj = DbProject.get_by_name params[:project]\n\n    pass_to_backend\n  end\n\nend\n", "# encoding: UTF-8\n\nrequire File.expand_path(File.dirname(__FILE__) + \"/..\") + \"/test_helper\"\n\nrequire 'rexml/document'\ninclude REXML\n\nclass BuildControllerTest < ActionController::IntegrationTest \n\n  fixtures :all\n\n  def setup\n    prepare_request_valid_user\n  end\n\n  def test_index\n    get \"/build\"\n    assert_response :success\n    assert_match(/entry name=\"home:Iggy\"/, @response.body)\n    get \"/build/home:Iggy\"\n    assert_response :success\n    assert_match(/entry name=\"10.2\"/, @response.body)\n    get \"/build/home:Iggy/10.2\"\n    assert_response :success\n    assert_match(/entry name=\"i586\"/, @response.body)\n    get \"/build/home:Iggy/10.2/i586\"\n    assert_response :success\n    assert_match(/entry name=\"TestPack\"/, @response.body)\n    get \"/build/home:Iggy/10.2/i586/TestPack\"\n    assert_response :success\n    assert_match(/binary filename=\"package-1.0-1.i586.rpm\"/, @response.body)\n\n    # FIXME: hope this is not 400 because its another hidden OBS interconnect case\n    get \"/build/blabla\"\n    assert_response 404\n    get \"/build/home:Iggy/blabla\"\n    assert_response 404\n    get \"/build/home:Iggy/10.2/blabla\"\n    assert_response 404\n  end\n\n  def test_dispatchprios\n    ActionController::IntegrationTest::reset_auth\n    get \"/build/_dispatchprios\"\n    assert_response 401\n\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/_dispatchprios\"\n    assert_response :success\n    put \"/build/_dispatchprios\", ' <dispatchprios> <prio project=\"KDE:Distro:Factory\" repository=\"openSUSE_Factory\" adjust=\"7\" /> </dispatchprios>'\n    assert_response 403\n\n    prepare_request_with_user \"king\", \"sunflower\"\n    put \"/build/_dispatchprios\", ' <dispatchprios> <prio project=\"KDE:Distro:Factory\" repository=\"openSUSE_Factory\" adjust=\"7\" /> </dispatchprios>'\n    assert_response :success\n  end\n\n  def test_read_from_repository\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/home:Iggy/10.2/i586/_repository/not_existing.rpm\"\n    assert_response 404\n    get \"/build/home:Iggy/10.2/i586/TestPack/package-1.0-1.i586.rpm\"\n    assert_response :success\n    get \"/build/home:Iggy/10.2/i586/_repository\"\n    assert_response :success\n    assert_tag :tag => \"binarylist\", :child => { :tag => \"binary\" }\n    assert_tag :tag => \"binary\", :attributes => { :filename => \"package.rpm\" }\n    get \"/build/home:Iggy/10.2/i586/_repository/package.rpm\"\n    assert_response :success\n    get \"/build/home:Iggy/10.2/i586/_repository?binary=rpm&binary=package&view=cpio\"\n    assert_response :success\n    ret = IO.popen(\"cpio -t 2>/dev/null\", \"r+\") { |f| f.puts @response.body; f.close_write; f.gets }\n    assert_match(/package.rpm/, ret)\n  end\n\n  def test_delete_from_repository\n    ActionController::IntegrationTest::reset_auth\n    delete \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response 401\n\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    delete \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response 403\n    delete \"/build/home:Iggy/10.2/i586/_repository/not_existing.rpm\"\n    assert_response 403\n    get \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response :success\n\n    prepare_request_with_user \"Iggy\", \"asdfasdf\"\n    delete \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response :success\n    delete \"/build/home:Iggy/10.2/i586/_repository/not_existing.rpm\"\n    assert_response 404\n    get \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response 404\n\n    delete \"/build/home:Iggy/10.2/i586/TestPack/package-1.0-1.i586.rpm\"\n    assert_response 400\n    assert_match(/invalid_operation/, @response.body)\n    assert_match(/Delete operation of build results is not allowed/, @response.body)\n  end\n\n  def test_read_access_hidden_project_index\n    # Test if hidden projects appear for the right users\n    # testing build_controller project_index \n    # currently this test shows that there's an information leak.\n    get \"/build\"\n    assert_response :success\n    assert_no_match(/entry name=\"HiddenProject\"/, @response.body)\n    # retry with maintainer\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build\"\n    assert_response :success\n    assert_match(/entry name=\"HiddenProject\"/, @response.body)\n    prepare_request_valid_user\n  end\n\n  def test_buildinfo\n    # just testing routing\n    get \"/build/buildinfo\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    # get source info to compare with\n    get \"/source/home:Iggy/TestPack\"\n    assert_response :success\n    assert_no_tag :tag => \"xsrcmd5\" # is no link, srcmd5 is valid\n    node = ActiveXML::XMLNode.new(@response.body)\n    srcmd5 = node.srcmd5\n\n    # osc local package build call\n    get \"/source/home:Iggy/TestPack/TestPack.spec\"\n    post \"/build/home:Iggy/10.2/i586/_repository/_buildinfo\", @response.body\n    assert_response :success\n\n    # this is only testing the rep server buildinfo, not the one generated by scheduler\n    get \"/build/home:Iggy/10.2/i586/TestPack/_buildinfo\"\n    assert_response :success\n    rev=\"2\"\n    b_cnt=\"2\"\n    ci_cnt=\"42\"\n    assert_tag :tag => \"buildinfo\"\n    assert_tag :tag => \"arch\", :content => \"i586\"\n    assert_tag :tag => \"srcmd5\", :content => srcmd5\n    assert_tag :tag => \"file\", :content => \"TestPack.spec\"\n    assert_tag :tag => \"debuginfo\", :content => \"0\"\n    assert_tag :tag => \"release\", :content => \"#{ci_cnt}.#{b_cnt}\"\n    assert_tag :tag => \"versrel\", :content => \"1.0-#{ci_cnt}\"\n    assert_tag :tag => \"rev\", :content => rev\n    assert_tag :tag => \"path\", :attributes => { :project => \"home:Iggy\", :repository => \"10.2\" }\n    buildinfo = ActiveXML::XMLNode.new(@response.body)\n\n    # find scheduler job and compare it with buildinfo\n    jobfile=File.new(\"#{RAILS_ROOT}/tmp/backend_data/jobs/i586/home:Iggy::10.2::TestPack-#{srcmd5}\")\n    schedulerjob = Document.new(jobfile).root\n# FIXME: to be implemented, compare scheduler job with rep server job\n#    schedulerjob.elements.each do |jobnode|\n#      puts \"test\", jobnode.inspect\n#    end\n    \n  end\n\n  def test_builddepinfo\n    get \"/build/home:Iggy/10.2/i586/_builddepinfo\"\n    assert_response :success\n    assert_tag :parent => { :tag => \"package\", :attributes => { :name => \"TestPack\" } }, :tag => \"source\", :content => \"TestPack\"\n    assert_tag :parent => { :tag => \"package\", :attributes => { :name => \"TestPack\" } }, :tag => \"subpkg\", :content => \"TestPack\"\n\n    get \"/build/HiddenProject/nada/i586/_builddepinfo\"\n    assert_response 404\n    assert_tag( :tag => \"status\", :attributes => { :code => \"unknown_project\" } ) \n\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/_builddepinfo\"\n    assert_response :success\n\n    # the webui is calling this with invalid package name to get the cycles only\n    get \"/build/home:Iggy/10.2/i586/_builddepinfo?package=-\"\n    assert_response :success\n    assert_no_tag :parent => { :tag => \"package\", :attributes => { :name => \"TestPack\" } }, :tag => \"source\"\n    assert_no_tag :parent => { :tag => \"package\", :attributes => { :name => \"TestPack\" } }, :tag => \"subpkg\"\n  end\n\n  def test_package_index\n    get \"/build/home:Iggy/10.2/i586/TestPack\"\n    assert_response :success\n    assert_tag( :tag => \"binarylist\" ) \n  end\n\n  def test_read_access_hidden_package_index\n    get \"/build/HiddenProject/nada/i586/pack\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n    # retry with maintainer\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/pack\"\n    assert_response :success\n    assert_tag( :tag => \"binarylist\" ) \n    prepare_request_valid_user\n  end\n\n  def test_logfile\n    get \"/build/home:Iggy/10.2/i586/TestPack/_log\"\n    assert_response :success\n    get \"/build/home:Iggy/10.2/i586/notthere/_log\"\n    assert_response 404\n    assert_match(/unknown_package/, @response.body)\n  end\n\n  def test_read_sourceaccess_protected_logfile\n    prepare_request_valid_user\n    get \"/build/SourceprotectedProject/repo/i586/pack/_log\"\n    assert_response 403\n    assert_tag( :tag => \"status\", :attributes => { :code => \"source_access_no_permission\" } ) \n    # retry with maintainer\n    prepare_request_with_user \"sourceaccess_homer\", \"homer\"\n    get \"/build/SourceprotectedProject/repo/i586/pack/_log\"\n    assert_response :success\n  end\n\n  def test_read_access_hidden_logfile\n    prepare_request_valid_user\n    get \"/build/HiddenProject/nada/i586/pack/_log\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n    # retry with maintainer\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/pack/_log\"\n    assert_response :success\n  end\n\n  def test_read_access_binarydownload_logfile\n    prepare_request_valid_user\n    # Download is not protecting binaries for real, but it disallows download via api\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/_log\"\n    assert_response 403\n    assert_match(/download_binary_no_permission/, @response.body)\n    # retry with maintainer\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"binary_homer\", \"homer\"\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/_log\"\n    assert_response :success\n  end\n\n  def test_result\n    get \"/build/home:Iggy/_result\"\n    assert_response :success\n    assert_tag :tag => \"resultlist\", :children =>  { :count => 2 }\n  end\n\n  def test_read_access_hidden_result_prj\n    get \"/build/HiddenProject/_result\"\n    assert_response 404\n    # retry with maintainer\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/_result\"\n    assert_response :success\n    assert_tag :tag => \"resultlist\"\n    prepare_request_valid_user\n  end\n\n  def test_read_access_hidden_result_pkg\n    get \"/build/HiddenProject/_result?package=pack\"\n    assert_response 404\n    # retry with maintainer\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/_result?package=pack\"\n    assert_response :success\n    assert_tag :tag => \"resultlist\"\n    prepare_request_valid_user\n\n  end\n\n  def test_binary_view\n    get \"/build/home:Iggy/10.2/i586/TestPack/file?view=fileinfo\"\n    assert_response 404\n    assert_match(/file: No such file or directory/, @response.body)\n\n    get \"/build/home:Iggy/10.2/i586/TestPack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response :success\n    #FIXME validate xml content\n  end\n  \n  def test_read_access_hidden_binary_view\n    # 404 on invalid\n    get \"/build/HiddenProject/nada/i586/pack/package?view=fileinfo\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    get \"/build/HiddenProject/nada/i586/pack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    # success on valid\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/pack/package?view=fileinfo\"\n    assert_response 404\n    assert_match(/No such file or directory/, @response.body)\n    get \"/build/HiddenProject/nada/i586/pack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response :success\n    prepare_request_valid_user\n  end\n\n  def test_read_access_binarydownload_binary_view\n    # 404 on invalid\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/package?view=fileinfo\"\n    assert_response 403\n    assert_match(/download_binary_no_permission/, @response.body)\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response 403\n    assert_match(/download_binary_no_permission/, @response.body)\n    # success on valid\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"binary_homer\", \"homer\"\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/package?view=fileinfo\"\n    assert_response 404\n    assert_match(/No such file or directory/, @response.body)\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response :success\n    prepare_request_valid_user\n  end\n\n  def test_file\n    get \"/build/home:Iggy/10.2/i586/TestPack\"\n    assert_response 200\n    get \"/build/home:Iggy/10.2/i586/TestPack/package-1.0-1.i586.rpm\"\n    assert_response 200\n    get \"/build/home:Iggy/10.2/i586/TestPack/NOT_EXISTING\"\n    assert_response 404\n    assert_match(/NOT_EXISTING: No such file or directory/, @response.body)\n  end\n\n  def test_read_access_hidden_file\n    get \"/build/HiddenProject/nada/i586/pack/\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    get \"/build/HiddenProject/nada/i586/pack/package-1.0-1.i586.rpm\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    get \"/build/HiddenProject/nada/i586/pack/NOT_EXISTING\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    # success on valid\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/pack/\"\n    assert_response :success\n    assert_match(/binarylist/, @response.body)\n    get \"/build/HiddenProject/nada/i586/pack/package-1.0-1.i586.rpm\"\n    assert_response :success\n    get \"/build/HiddenProject/nada/i586/pack/NOT_EXISTING\"\n    assert_match(/NOT_EXISTING: No such file or directory/, @response.body)\n    prepare_request_valid_user\n  end\n\n  def test_project_index\n    get \"/build/home:Iggy\"\n    assert_response :success\n    assert_tag :tag => \"directory\", :children =>  { :count => 1 }\n\n    put \"/build/home:Iggy\", :cmd => 'say_hallo'\n    assert_response 403\n    assert_match(/No permission to execute command on project/, @response.body)\n\n    post \"/build/home:Iggy\", :cmd => 'say_hallo'\n    assert_response 400\n    assert_match(/unsupported POST command/, @response.body)\n\n    prepare_request_with_user \"Iggy\", \"asdfasdf\" \n    post \"/build/home:Iggy\"\n    assert_response 400\n    post \"/build/home:Iggy?cmd=say_hallo\"\n    assert_response 400\n    post \"/build/home:NotExisting?cmd=wipe\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n    post \"/build/home:Iggy?cmd=wipe&package=DoesNotExist\"\n    assert_response 404\n    assert_match(/unknown package: DoesNotExist/, @response.body)\n  \n    post \"/build/Apache?cmd=wipe\"\n    assert_response 403\n    assert_match(/No permission to execute command on project/, @response.body)\n    post \"/build/Apache?cmd=wipe&package=apache2\"\n    assert_response 403\n    assert_match(/No permission to execute command on package/, @response.body)\n\n    post \"/build/Apache?cmd=abortbuild\"\n    assert_response 403\n    assert_match(/No permission to execute command on project/, @response.body)\n    post \"/build/Apache?cmd=abortbuild&package=apache2\"\n    assert_response 403\n    assert_match(/No permission to execute command on package/, @response.body)\n\n    prepare_request_with_user \"fred\", \"ger\u00f6llheimer\" \n    post \"/build/Apache?cmd=wipe\"\n    assert_response :success\n    post \"/build/Apache?cmd=wipe&package=apache2\"\n    assert_response :success\n\n    post \"/build/Apache?cmd=abortbuild\"\n    assert_response :success\n    post \"/build/Apache?cmd=abortbuild&package=apache2\"\n    assert_response :success\n  end\n\n  def test_read_access_hidden_project_index\n    #invalid\n    get \"/build/HiddenProject\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    put \"/build/HiddenProject\", :cmd => 'say_hallo'\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    post \"/build/HiddenProject\", :cmd => 'say_hallo'\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    post \"/build/HiddenProject?cmd=wipe\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    post \"/build/HiddenProject?cmd=wipe&package=TestPack\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    #valid\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\" \n    get \"/build/HiddenProject\"\n    assert_response :success\n    assert_tag :tag => \"directory\", :children =>  { :count => 1 }\n\n    put \"/build/HiddenProject\", :cmd => 'say_hallo'\n    assert_response 403\n    assert_match(/No permission to execute command on project/, @response.body)\n\n    post \"/build/HiddenProject\", :cmd => 'say_hallo'\n    assert_response 400\n    assert_match(/illegal_request/, @response.body)\n\n    post \"/build/HiddenProject?cmd=wipe&package=DoesNotExist\"\n    assert_response 404\n    assert_match(/unknown package: DoesNotExist/, @response.body)\n\n    post \"/build/HiddenProject?cmd=wipe\"\n    assert_response :success\n    post \"/build/HiddenProject?cmd=wipe&package=pack\"\n    assert_response :success\n  end\n\n  def test_remoteinstance\n    # check that we handle this correctly - the remoteinstance is only in the database\n    get \"/build/RemoteInstance:BaseDistro/_result?view=summary\"\n    assert_response 404\n  end\n \n  # FIXME: remoteinstance\n\n  def test_jobhistory\n    get \"/build/home:Iggy/10.2/i586/_jobhistory\"\n    assert_response :success\n    get \"/build/home:Iggy/10.2/i586/_jobhistory?package=TestPack\"\n    assert_response :success\n  end\n\n  def test_read_access_hidden_jobhistory\n    get \"/build/HiddenProject/nada/i586/_jobhistory\"\n    assert_response 404\n    get \"/build/HiddenProject/nada/i586/_jobhistory?package=pack\"\n    assert_response 404\n    # retry with maintainer\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/_jobhistory\"\n    assert_response :success\n    get \"/build/HiddenProject/nada/i586/_jobhistory?package=pack\"\n    assert_response :success\n    prepare_request_valid_user\n  end\nend\n"], "fixing_code": ["class BuildController < ApplicationController\n\n  def index\n    valid_http_methods :get, :post\n\n    # for permission check\n    if params[:package] and not [\"_repository\", \"_jobhistory\"].include?(params[:package])\n      pkg = DbPackage.get_by_project_and_name( params[:project], params[:package], use_source=false )\n    else\n      prj = DbProject.get_by_name params[:project]\n    end\n\n    if request.get?\n      pass_to_backend \n      return\n    end\n\n    if @http_user.is_admin?\n      # check for a local package instance\n      DbPackage.get_by_project_and_name( params[:project], params[:package], follow_project_links=false )\n      pass_to_backend\n    else\n      render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n        :message => \"Upload of binaries is only permitted for administrators\"\n    end\n  end\n\n  def project_index\n    valid_http_methods :get, :post, :put\n\n    prj = nil\n    unless params[:project] == \"_dispatchprios\"\n      prj = DbProject.get_by_name params[:project]\n    end\n\n    if request.get?\n      pass_to_backend\n      return\n    elsif request.post?\n      #check if user has project modify rights\n      allowed = false\n      allowed = true if permissions.global_project_change\n      allowed = true if permissions.project_change? prj\n\n      #check for cmd parameter\n      if params[:cmd].nil?\n        render_error :status => 400, :errorcode => \"missing_parameter\",\n          :message => \"Missing parameter 'cmd'\"\n        return\n      end\n\n      unless [\"wipe\", \"restartbuild\", \"killbuild\", \"abortbuild\", \"rebuild\"].include? params[:cmd]\n        render_error :status => 400, :errorcode => \"illegal_request\",\n          :message => \"unsupported POST command #{params[:cmd]} to #{request.request_uri}\"\n        return\n      end\n\n      unless prj.class == DbProject\n        render_error :status => 403, :errorcode => \"readonly_error\",\n          :message => \"The project #{params[:project]} is a remote project and therefore readonly.\"\n        return\n      end\n\n      if not allowed and not params[:package].nil?\n        package_names = nil\n        if params[:package].kind_of? Array\n          package_names = params[:package]\n        else\n          package_names = [params[:package]]\n        end\n        package_names.each do |pack_name|\n          pkg = DbPackage.find_by_project_and_name( prj.name, pack_name ) \n          if pkg.nil?\n            allowed = permissions.project_change? prj\n            if not allowed\n              render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n                :message => \"No permission to execute command on package #{pack_name} in project #{prj.name}\"\n              return\n            end\n          else\n            allowed = permissions.package_change? pkg\n            if not allowed\n              render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n                :message => \"No permission to execute command on package #{pack_name}\"\n              return\n            end\n          end\n        end\n      end\n\n      if not allowed\n        render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n          :message => \"No permission to execute command on project #{params[:project]}\"\n        return\n      end\n\n      pass_to_backend\n      return\n    elsif request.put? \n      if @http_user.is_admin?\n        pass_to_backend\n      else\n        render_error :status => 403, :errorcode => \"execute_cmd_no_permission\",\n          :message => \"No permission to execute command on project #{params[:project]}\"\n      end\n      return\n    else\n      render_error :status => 400, :errorcode => 'illegal_request',\n        :message => \"Illegal request: #{request.method.to_s.upcase} #{request.path}\"\n      return\n    end\n  end\n\n  def buildinfo\n    valid_http_methods :get, :post\n    required_parameters :project, :repository, :arch, :package\n    # just for permission checking\n    if request.post? and params[:package] == \"_repository\"\n      # for osc local package build in this repository\n      DbProject.get_by_name params[:project]\n    else\n      DbPackage.get_by_project_and_name params[:project], params[:package], use_source=false\n    end\n\n    path = \"/build/#{params[:project]}/#{params[:repository]}/#{params[:arch]}/#{params[:package]}/_buildinfo\"\n    unless request.query_string.empty?\n      path += '?' + request.query_string\n    end\n\n    pass_to_backend path\n  end\n\n  def builddepinfo\n    valid_http_methods :get\n    required_parameters :project, :repository, :arch\n\n    # just for permission checking\n    DbProject.get_by_name params[:project]\n\n    pass_to_backend\n  end\n\n  # /build/:project/:repository/:arch/:package/:filename\n  def file\n    valid_http_methods :get, :delete\n    required_parameters :project, :repository, :arch, :package, :filename\n\n    # read access permission check\n    prj = nil\n    if params[:package] == \"_repository\"\n      prj = DbProject.get_by_name params[:project]\n    else\n      pkg = DbPackage.get_by_project_and_name params[:project], params[:package], use_source=false\n      prj = pkg.db_project if pkg.class == DbPackage\n    end\n\n    if prj.class == DbProject and prj.disabled_for?('binarydownload', params[:repository], params[:arch]) and not @http_user.can_download_binaries?(prj)\n      render_error :status => 403, :errorcode => \"download_binary_no_permission\",\n      :message => \"No permission to download binaries from package #{params[:package]}, project #{params[:project]}\"\n      return\n    end\n\n    path = request.path+\"?\"+request.query_string\n\n    if request.delete?\n      unless permissions.project_change? params[:project]\n        render_error :status => 403, :errorcode => \"delete_binary_no_permission\",\n          :message => \"No permission to delete binaries from project #{params[:project]}\"\n        return\n      end\n\n      if params[:package] == \"_repository\"\n        pass_to_backend\n      else\n        render_error :status => 400, :errorcode => \"invalid_operation\",\n          :message => \"Delete operation of build results is not allowed\"\n      end\n\n      return\n    end\n\n    regexp = nil\n    # if there is a query, we can't assume it's a simple download, so better leave out the logic (e.g. view=fileinfo)\n    unless request.query_string\n      #check if binary exists and for size\n      fpath = \"/build/\"+[:project,:repository,:arch,:package].map {|x| params[x]}.join(\"/\")\n      file_list = Suse::Backend.get(fpath)\n      regexp = file_list.body.match(/name=[\"']#{Regexp.quote params[:filename]}[\"'].*size=[\"']([^\"']*)[\"']/)\n    end\n    if regexp\n      fsize = regexp[1]\n      logger.info \"streaming #{path}\"\n\n      c_type = case params[:filename].split(/\\./)[-1]\n               when \"rpm\"\n                 \"application/x-rpm\"\n               when \"deb\"\n                 \"application/x-deb\"\n               when \"iso\"\n                 \"application/x-cd-image\"\n               else\n                 \"application/octet-stream\"\n               end\n\n      headers.update(\n        'Content-Disposition' => %(attachment; filename=\"#{params[:filename]}\"),\n        'Content-Type' => c_type,\n        'Transfer-Encoding' => 'binary',\n        'Content-Length' => fsize\n      )\n      \n      render :status => 200, :text => Proc.new {|request,output|\n        backend_request = Net::HTTP::Get.new(path)\n        Net::HTTP.start(SOURCE_HOST,SOURCE_PORT) do |http|\n          http.request(backend_request) do |response|\n            response.read_body do |chunk|\n              output.write(chunk)\n            end\n          end\n        end\n      }\n    else\n      pass_to_backend path\n    end\n  end\n\n  def logfile\n    valid_http_methods :get\n\n    # for permission check\n    pkg = DbPackage.get_by_project_and_name params[:project], params[:package]\n\n    if pkg.class == DbPackage and pkg.db_project.disabled_for?('binarydownload', params[:repository], params[:arch]) and not @http_user.can_download_binaries?(pkg.db_project)\n      render_error :status => 403, :errorcode => \"download_binary_no_permission\",\n      :message => \"No permission to download binaries from package #{params[:package]}, project #{params[:project]}\"\n      return\n    end\n\n    pass_to_backend\n  end\n\n  def result\n    valid_http_methods :get\n    # for permission check\n    prj = DbProject.get_by_name params[:project]\n\n    pass_to_backend\n  end\n\nend\n", "# encoding: UTF-8\n\nrequire File.expand_path(File.dirname(__FILE__) + \"/..\") + \"/test_helper\"\n\nrequire 'rexml/document'\ninclude REXML\n\nclass BuildControllerTest < ActionController::IntegrationTest \n\n  fixtures :all\n\n  def setup\n    prepare_request_valid_user\n  end\n\n  def test_index\n    get \"/build\"\n    assert_response :success\n    assert_match(/entry name=\"home:Iggy\"/, @response.body)\n    get \"/build/home:Iggy\"\n    assert_response :success\n    assert_match(/entry name=\"10.2\"/, @response.body)\n    get \"/build/home:Iggy/10.2\"\n    assert_response :success\n    assert_match(/entry name=\"i586\"/, @response.body)\n    get \"/build/home:Iggy/10.2/i586\"\n    assert_response :success\n    assert_match(/entry name=\"TestPack\"/, @response.body)\n    get \"/build/home:Iggy/10.2/i586/TestPack\"\n    assert_response :success\n    assert_match(/binary filename=\"package-1.0-1.i586.rpm\"/, @response.body)\n\n    # FIXME: hope this is not 400 because its another hidden OBS interconnect case\n    get \"/build/blabla\"\n    assert_response 404\n    get \"/build/home:Iggy/blabla\"\n    assert_response 404\n    get \"/build/home:Iggy/10.2/blabla\"\n    assert_response 404\n  end\n\n  def test_upload_binaries\n    ActionController::IntegrationTest::reset_auth\n    post \"/build/home:Iggy/10.2/i586/TestPack\", nil\n    assert_response 401\n\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    post \"/build/home:Iggy/10.2/i586/TestPack\", nil\n    assert_response 403\n\n    prepare_request_with_user \"king\", \"sunflower\"\n    post \"/build/home:Iggy/10.2/i586/TestPack\", nil\n    assert_response 400 # actually a success, it reached the backend\n    assert_tag :tag => \"status\", :attributes => { :code => \"400\", :origin => \"backend\" }\n\n    # check not supported methods\n    post \"/build/home:Iggy/10.2/i586/_repository\", nil\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_package\" }\n    put \"/build/home:Iggy/10.2/i586/TestPack\", nil\n    assert_response 400\n    assert_tag :tag => \"status\", :attributes => { :code => \"invalid_http_method\" }\n    delete \"/build/home:Iggy/10.2/i586/TestPack\"\n    assert_response 400\n    assert_tag :tag => \"status\", :attributes => { :code => \"invalid_http_method\" }\n  end\n\n  def test_dispatchprios\n    ActionController::IntegrationTest::reset_auth\n    get \"/build/_dispatchprios\"\n    assert_response 401\n\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/_dispatchprios\"\n    assert_response :success\n    put \"/build/_dispatchprios\", ' <dispatchprios> <prio project=\"KDE:Distro:Factory\" repository=\"openSUSE_Factory\" adjust=\"7\" /> </dispatchprios>'\n    assert_response 403\n\n    prepare_request_with_user \"king\", \"sunflower\"\n    put \"/build/_dispatchprios\", ' <dispatchprios> <prio project=\"KDE:Distro:Factory\" repository=\"openSUSE_Factory\" adjust=\"7\" /> </dispatchprios>'\n    assert_response :success\n  end\n\n  def test_read_from_repository\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/home:Iggy/10.2/i586/_repository/not_existing.rpm\"\n    assert_response 404\n    get \"/build/home:Iggy/10.2/i586/TestPack/package-1.0-1.i586.rpm\"\n    assert_response :success\n    get \"/build/home:Iggy/10.2/i586/_repository\"\n    assert_response :success\n    assert_tag :tag => \"binarylist\", :child => { :tag => \"binary\" }\n    assert_tag :tag => \"binary\", :attributes => { :filename => \"package.rpm\" }\n    get \"/build/home:Iggy/10.2/i586/_repository/package.rpm\"\n    assert_response :success\n    get \"/build/home:Iggy/10.2/i586/_repository?binary=rpm&binary=package&view=cpio\"\n    assert_response :success\n    ret = IO.popen(\"cpio -t 2>/dev/null\", \"r+\") { |f| f.puts @response.body; f.close_write; f.gets }\n    assert_match(/package.rpm/, ret)\n  end\n\n  def test_delete_from_repository\n    ActionController::IntegrationTest::reset_auth\n    delete \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response 401\n\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    delete \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response 403\n    delete \"/build/home:Iggy/10.2/i586/_repository/not_existing.rpm\"\n    assert_response 403\n    get \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response :success\n\n    prepare_request_with_user \"Iggy\", \"asdfasdf\"\n    delete \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response :success\n    delete \"/build/home:Iggy/10.2/i586/_repository/not_existing.rpm\"\n    assert_response 404\n    get \"/build/home:Iggy/10.2/i586/_repository/delete_me.rpm\"\n    assert_response 404\n\n    delete \"/build/home:Iggy/10.2/i586/TestPack/package-1.0-1.i586.rpm\"\n    assert_response 400\n    assert_match(/invalid_operation/, @response.body)\n    assert_match(/Delete operation of build results is not allowed/, @response.body)\n  end\n\n  def test_read_access_hidden_project_index\n    # Test if hidden projects appear for the right users\n    # testing build_controller project_index \n    # currently this test shows that there's an information leak.\n    get \"/build\"\n    assert_response :success\n    assert_no_match(/entry name=\"HiddenProject\"/, @response.body)\n    # retry with maintainer\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build\"\n    assert_response :success\n    assert_match(/entry name=\"HiddenProject\"/, @response.body)\n    prepare_request_valid_user\n  end\n\n  def test_buildinfo\n    # just testing routing\n    get \"/build/buildinfo\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    # get source info to compare with\n    get \"/source/home:Iggy/TestPack\"\n    assert_response :success\n    assert_no_tag :tag => \"xsrcmd5\" # is no link, srcmd5 is valid\n    node = ActiveXML::XMLNode.new(@response.body)\n    srcmd5 = node.srcmd5\n\n    # osc local package build call\n    get \"/source/home:Iggy/TestPack/TestPack.spec\"\n    post \"/build/home:Iggy/10.2/i586/_repository/_buildinfo\", @response.body\n    assert_response :success\n\n    # this is only testing the rep server buildinfo, not the one generated by scheduler\n    get \"/build/home:Iggy/10.2/i586/TestPack/_buildinfo\"\n    assert_response :success\n    rev=\"2\"\n    b_cnt=\"2\"\n    ci_cnt=\"42\"\n    assert_tag :tag => \"buildinfo\"\n    assert_tag :tag => \"arch\", :content => \"i586\"\n    assert_tag :tag => \"srcmd5\", :content => srcmd5\n    assert_tag :tag => \"file\", :content => \"TestPack.spec\"\n    assert_tag :tag => \"debuginfo\", :content => \"0\"\n    assert_tag :tag => \"release\", :content => \"#{ci_cnt}.#{b_cnt}\"\n    assert_tag :tag => \"versrel\", :content => \"1.0-#{ci_cnt}\"\n    assert_tag :tag => \"rev\", :content => rev\n    assert_tag :tag => \"path\", :attributes => { :project => \"home:Iggy\", :repository => \"10.2\" }\n    buildinfo = ActiveXML::XMLNode.new(@response.body)\n\n    # find scheduler job and compare it with buildinfo\n    jobfile=File.new(\"#{RAILS_ROOT}/tmp/backend_data/jobs/i586/home:Iggy::10.2::TestPack-#{srcmd5}\")\n    schedulerjob = Document.new(jobfile).root\n# FIXME: to be implemented, compare scheduler job with rep server job\n#    schedulerjob.elements.each do |jobnode|\n#      puts \"test\", jobnode.inspect\n#    end\n    \n  end\n\n  def test_builddepinfo\n    get \"/build/home:Iggy/10.2/i586/_builddepinfo\"\n    assert_response :success\n    assert_tag :parent => { :tag => \"package\", :attributes => { :name => \"TestPack\" } }, :tag => \"source\", :content => \"TestPack\"\n    assert_tag :parent => { :tag => \"package\", :attributes => { :name => \"TestPack\" } }, :tag => \"subpkg\", :content => \"TestPack\"\n\n    get \"/build/HiddenProject/nada/i586/_builddepinfo\"\n    assert_response 404\n    assert_tag( :tag => \"status\", :attributes => { :code => \"unknown_project\" } ) \n\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/_builddepinfo\"\n    assert_response :success\n\n    # the webui is calling this with invalid package name to get the cycles only\n    get \"/build/home:Iggy/10.2/i586/_builddepinfo?package=-\"\n    assert_response :success\n    assert_no_tag :parent => { :tag => \"package\", :attributes => { :name => \"TestPack\" } }, :tag => \"source\"\n    assert_no_tag :parent => { :tag => \"package\", :attributes => { :name => \"TestPack\" } }, :tag => \"subpkg\"\n  end\n\n  def test_package_index\n    get \"/build/home:Iggy/10.2/i586/TestPack\"\n    assert_response :success\n    assert_tag( :tag => \"binarylist\" ) \n  end\n\n  def test_read_access_hidden_package_index\n    get \"/build/HiddenProject/nada/i586/pack\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n    # retry with maintainer\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/pack\"\n    assert_response :success\n    assert_tag( :tag => \"binarylist\" ) \n    prepare_request_valid_user\n  end\n\n  def test_logfile\n    get \"/build/home:Iggy/10.2/i586/TestPack/_log\"\n    assert_response :success\n    get \"/build/home:Iggy/10.2/i586/notthere/_log\"\n    assert_response 404\n    assert_match(/unknown_package/, @response.body)\n  end\n\n  def test_read_sourceaccess_protected_logfile\n    prepare_request_valid_user\n    get \"/build/SourceprotectedProject/repo/i586/pack/_log\"\n    assert_response 403\n    assert_tag( :tag => \"status\", :attributes => { :code => \"source_access_no_permission\" } ) \n    # retry with maintainer\n    prepare_request_with_user \"sourceaccess_homer\", \"homer\"\n    get \"/build/SourceprotectedProject/repo/i586/pack/_log\"\n    assert_response :success\n  end\n\n  def test_read_access_hidden_logfile\n    prepare_request_valid_user\n    get \"/build/HiddenProject/nada/i586/pack/_log\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n    # retry with maintainer\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/pack/_log\"\n    assert_response :success\n  end\n\n  def test_read_access_binarydownload_logfile\n    prepare_request_valid_user\n    # Download is not protecting binaries for real, but it disallows download via api\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/_log\"\n    assert_response 403\n    assert_match(/download_binary_no_permission/, @response.body)\n    # retry with maintainer\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"binary_homer\", \"homer\"\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/_log\"\n    assert_response :success\n  end\n\n  def test_result\n    get \"/build/home:Iggy/_result\"\n    assert_response :success\n    assert_tag :tag => \"resultlist\", :children =>  { :count => 2 }\n  end\n\n  def test_read_access_hidden_result_prj\n    get \"/build/HiddenProject/_result\"\n    assert_response 404\n    # retry with maintainer\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/_result\"\n    assert_response :success\n    assert_tag :tag => \"resultlist\"\n    prepare_request_valid_user\n  end\n\n  def test_read_access_hidden_result_pkg\n    get \"/build/HiddenProject/_result?package=pack\"\n    assert_response 404\n    # retry with maintainer\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/_result?package=pack\"\n    assert_response :success\n    assert_tag :tag => \"resultlist\"\n    prepare_request_valid_user\n\n  end\n\n  def test_binary_view\n    get \"/build/home:Iggy/10.2/i586/TestPack/file?view=fileinfo\"\n    assert_response 404\n    assert_match(/file: No such file or directory/, @response.body)\n\n    get \"/build/home:Iggy/10.2/i586/TestPack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response :success\n    #FIXME validate xml content\n  end\n  \n  def test_read_access_hidden_binary_view\n    # 404 on invalid\n    get \"/build/HiddenProject/nada/i586/pack/package?view=fileinfo\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    get \"/build/HiddenProject/nada/i586/pack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    # success on valid\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/pack/package?view=fileinfo\"\n    assert_response 404\n    assert_match(/No such file or directory/, @response.body)\n    get \"/build/HiddenProject/nada/i586/pack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response :success\n    prepare_request_valid_user\n  end\n\n  def test_read_access_binarydownload_binary_view\n    # 404 on invalid\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/package?view=fileinfo\"\n    assert_response 403\n    assert_match(/download_binary_no_permission/, @response.body)\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response 403\n    assert_match(/download_binary_no_permission/, @response.body)\n    # success on valid\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"binary_homer\", \"homer\"\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/package?view=fileinfo\"\n    assert_response 404\n    assert_match(/No such file or directory/, @response.body)\n    get \"/build/BinaryprotectedProject/nada/i586/bdpack/package-1.0-1.i586.rpm?view=fileinfo\"\n    assert_response :success\n    prepare_request_valid_user\n  end\n\n  def test_file\n    get \"/build/home:Iggy/10.2/i586/TestPack\"\n    assert_response 200\n    get \"/build/home:Iggy/10.2/i586/TestPack/package-1.0-1.i586.rpm\"\n    assert_response 200\n    get \"/build/home:Iggy/10.2/i586/TestPack/NOT_EXISTING\"\n    assert_response 404\n    assert_match(/NOT_EXISTING: No such file or directory/, @response.body)\n  end\n\n  def test_read_access_hidden_file\n    get \"/build/HiddenProject/nada/i586/pack/\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    get \"/build/HiddenProject/nada/i586/pack/package-1.0-1.i586.rpm\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    get \"/build/HiddenProject/nada/i586/pack/NOT_EXISTING\"\n    assert_response 404\n    assert_tag :tag => \"status\", :attributes => { :code => \"unknown_project\" }\n    # success on valid\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/pack/\"\n    assert_response :success\n    assert_match(/binarylist/, @response.body)\n    get \"/build/HiddenProject/nada/i586/pack/package-1.0-1.i586.rpm\"\n    assert_response :success\n    get \"/build/HiddenProject/nada/i586/pack/NOT_EXISTING\"\n    assert_match(/NOT_EXISTING: No such file or directory/, @response.body)\n    prepare_request_valid_user\n  end\n\n  def test_project_index\n    get \"/build/home:Iggy\"\n    assert_response :success\n    assert_tag :tag => \"directory\", :children =>  { :count => 1 }\n\n    put \"/build/home:Iggy\", :cmd => 'say_hallo'\n    assert_response 403\n    assert_match(/No permission to execute command on project/, @response.body)\n\n    post \"/build/home:Iggy\", :cmd => 'say_hallo'\n    assert_response 400\n    assert_match(/unsupported POST command/, @response.body)\n\n    prepare_request_with_user \"Iggy\", \"asdfasdf\" \n    post \"/build/home:Iggy\"\n    assert_response 400\n    post \"/build/home:Iggy?cmd=say_hallo\"\n    assert_response 400\n    post \"/build/home:NotExisting?cmd=wipe\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n    post \"/build/home:Iggy?cmd=wipe&package=DoesNotExist\"\n    assert_response 404\n    assert_match(/unknown package: DoesNotExist/, @response.body)\n  \n    post \"/build/Apache?cmd=wipe\"\n    assert_response 403\n    assert_match(/No permission to execute command on project/, @response.body)\n    post \"/build/Apache?cmd=wipe&package=apache2\"\n    assert_response 403\n    assert_match(/No permission to execute command on package/, @response.body)\n\n    post \"/build/Apache?cmd=abortbuild\"\n    assert_response 403\n    assert_match(/No permission to execute command on project/, @response.body)\n    post \"/build/Apache?cmd=abortbuild&package=apache2\"\n    assert_response 403\n    assert_match(/No permission to execute command on package/, @response.body)\n\n    prepare_request_with_user \"fred\", \"ger\u00f6llheimer\" \n    post \"/build/Apache?cmd=wipe\"\n    assert_response :success\n    post \"/build/Apache?cmd=wipe&package=apache2\"\n    assert_response :success\n\n    post \"/build/Apache?cmd=abortbuild\"\n    assert_response :success\n    post \"/build/Apache?cmd=abortbuild&package=apache2\"\n    assert_response :success\n  end\n\n  def test_read_access_hidden_project_index\n    #invalid\n    get \"/build/HiddenProject\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    put \"/build/HiddenProject\", :cmd => 'say_hallo'\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    post \"/build/HiddenProject\", :cmd => 'say_hallo'\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    post \"/build/HiddenProject?cmd=wipe\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    post \"/build/HiddenProject?cmd=wipe&package=TestPack\"\n    assert_response 404\n    assert_match(/unknown_project/, @response.body)\n\n    #valid\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\" \n    get \"/build/HiddenProject\"\n    assert_response :success\n    assert_tag :tag => \"directory\", :children =>  { :count => 1 }\n\n    put \"/build/HiddenProject\", :cmd => 'say_hallo'\n    assert_response 403\n    assert_match(/No permission to execute command on project/, @response.body)\n\n    post \"/build/HiddenProject\", :cmd => 'say_hallo'\n    assert_response 400\n    assert_match(/illegal_request/, @response.body)\n\n    post \"/build/HiddenProject?cmd=wipe&package=DoesNotExist\"\n    assert_response 404\n    assert_match(/unknown package: DoesNotExist/, @response.body)\n\n    post \"/build/HiddenProject?cmd=wipe\"\n    assert_response :success\n    post \"/build/HiddenProject?cmd=wipe&package=pack\"\n    assert_response :success\n  end\n\n  def test_remoteinstance\n    # check that we handle this correctly - the remoteinstance is only in the database\n    get \"/build/RemoteInstance:BaseDistro/_result?view=summary\"\n    assert_response 404\n  end\n \n  # FIXME: remoteinstance\n\n  def test_jobhistory\n    get \"/build/home:Iggy/10.2/i586/_jobhistory\"\n    assert_response :success\n    get \"/build/home:Iggy/10.2/i586/_jobhistory?package=TestPack\"\n    assert_response :success\n  end\n\n  def test_read_access_hidden_jobhistory\n    get \"/build/HiddenProject/nada/i586/_jobhistory\"\n    assert_response 404\n    get \"/build/HiddenProject/nada/i586/_jobhistory?package=pack\"\n    assert_response 404\n    # retry with maintainer\n    ActionController::IntegrationTest::reset_auth\n    prepare_request_with_user \"adrian\", \"so_alone\"\n    get \"/build/HiddenProject/nada/i586/_jobhistory\"\n    assert_response :success\n    get \"/build/HiddenProject/nada/i586/_jobhistory?package=pack\"\n    assert_response :success\n    prepare_request_valid_user\n  end\nend\n"], "filenames": ["src/api/app/controllers/build_controller.rb", "src/api/test/functional/build_controller_test.rb"], "buggy_code_start_loc": [4, 39], "buggy_code_end_loc": [146, 39], "fixing_code_start_loc": [4, 40], "fixing_code_end_loc": [142, 66], "type": "CWE-20", "message": "A vulnerability in open build service allows remote attackers to gain access to source files even though source access is disabled. Affected releases are SUSE open build service up to and including version 2.1.15 (for 2.1) and before version 2.3.", "other": {"cve": {"id": "CVE-2011-4181", "sourceIdentifier": "meissner@suse.de", "published": "2018-06-11T15:29:00.217", "lastModified": "2019-10-09T23:03:46.710", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability in open build service allows remote attackers to gain access to source files even though source access is disabled. Affected releases are SUSE open build service up to and including version 2.1.15 (for 2.1) and before version 2.3."}, {"lang": "es", "value": "Una vulnerabilidad en open build service permite que atacantes remotos obtengan acceso a archivos de origen aunque el acceso a origen est\u00e9 deshabilitado. Las versiones afectadas son SUSE open build service hasta (e incluyendo) la versi\u00f3n 2.1.15 (para 2.1) y las anteriores a la 2.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "meissner@suse.de", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "meissner@suse.de", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:open_build_service:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.1.16", "matchCriteriaId": "2D556532-380F-4702-AABB-321459EB5E97"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=734003", "source": "meissner@suse.de", "tags": ["Issue Tracking"]}, {"url": "https://github.com/openSUSE/open-build-service/commit/5281e4bff9df31f1f91e22a0d1e9086b93b23d7e", "source": "meissner@suse.de", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openSUSE/open-build-service/commit/5281e4bff9df31f1f91e22a0d1e9086b93b23d7e"}}