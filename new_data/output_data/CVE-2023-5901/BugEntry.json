{"buggy_code": ["<?php\n/**\n * @file api/v1/contexts/PKPUploadPublicFileHandler.inc.php\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * @class PKPUploadPublicFileHandler\n * @ingroup api_v1_uploadPublicFile\n *\n * @brief Handle API requests to upload a file to a user's public directory.\n */\nimport('lib.pkp.classes.handler.APIHandler');\n\nclass PKPUploadPublicFileHandler extends APIHandler {\n\t/**\n\t * @copydoc APIHandler::__construct()\n\t */\n\tpublic function __construct() {\n\t\t$this->_handlerPath = '_uploadPublicFile';\n\t\t$roles = [ROLE_ID_SITE_ADMIN, ROLE_ID_MANAGER, ROLE_ID_SUB_EDITOR, ROLE_ID_REVIEWER, ROLE_ID_AUTHOR, ROLE_ID_ASSISTANT, ROLE_ID_READER];\n\t\t$this->_endpoints = array(\n\t\t\t'OPTIONS' => array(\n\t\t\t\tarray(\n\t\t\t\t\t'pattern' => $this->getEndpointPattern(),\n\t\t\t\t\t'handler' => array($this, 'getOptions'),\n\t\t\t\t\t'roles' => $roles,\n\t\t\t\t),\n\t\t\t),\n\t\t\t'POST' => array(\n\t\t\t\tarray(\n\t\t\t\t\t'pattern' => $this->getEndpointPattern(),\n\t\t\t\t\t'handler' => array($this, 'uploadFile'),\n\t\t\t\t\t'roles' => $roles,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tparent::__construct();\n\t}\n\n\t/**\n\t * @copydoc PKPHandler::authorize\n\t */\n\tpublic function authorize($request, &$args, $roleAssignments) {\n\t\timport('lib.pkp.classes.security.authorization.PolicySet');\n\t\t$rolePolicy = new PolicySet(COMBINING_PERMIT_OVERRIDES);\n\n\t\timport('lib.pkp.classes.security.authorization.RoleBasedHandlerOperationPolicy');\n\t\tforeach($roleAssignments as $role => $operations) {\n\t\t\t$rolePolicy->addPolicy(new RoleBasedHandlerOperationPolicy($request, $role, $operations));\n\t\t}\n\t\t$this->addPolicy($rolePolicy);\n\n\t\treturn parent::authorize($request, $args, $roleAssignments);\n\t}\n\n\t/**\n\t * A helper method which adds the necessary response headers to allow\n\t * file uploads\n\t *\n\t * @param $response Response object\n\t * @return Response\n\t */\n\tprivate function getResponse($response) {\n\t\treturn $response->withHeader('Access-Control-Allow-Headers', 'Content-Type, X-Requested-With, X-PINGOTHER, X-File-Name, Cache-Control');\n\t}\n\n\t/**\n\t * Upload a requested file\n\t *\n\t * @param $slimRequest Request Slim request object\n\t * @param $response Response object\n\t * @param $args array arguments\n\t * @return Response\n\t */\n\tpublic function uploadFile($slimRequest, $response, $args) {\n\t\t$request = $this->getRequest();\n\n\t\tif (empty($_FILES) || empty($_FILES['file'])) {\n\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.noUpload');\n\t\t}\n\n\t\t$siteDir = Core::getBaseDir() . '/' . Config::getVar('files', 'public_files_dir') . '/site';\n\n\t\tif (!file_exists($siteDir) || !is_writeable($siteDir)) {\n\t\t\treturn $response->withStatus(500)->withJsonError('api.publicFiles.500.badFilesDir');\n\t\t}\n\t\t$userDir = $siteDir . '/images/' . $request->getUser()->getUsername();\n\t\t$isUserAllowed = true;\n\t\t$allowedDirSize = Config::getVar('files', 'public_user_dir_size', 5000) * 1024;\n\t\t$allowedFileTypes = ['gif', 'jpg', 'png', 'webp', 'svg'];\n\n\t\tHookRegistry::call('API::uploadPublicFile::permissions', [\n\t\t\t&$userDir,\n\t\t\t&$isUserAllowed,\n\t\t\t&$allowedDirSize,\n\t\t\t&$allowedFileTypes,\n\t\t\t$request,\n\t\t\t$this->getAuthorizedContextObject(ASSOC_TYPE_USER_ROLES),\n\t\t]);\n\n\t\t// Allow plugins to control who can upload files\n\t\tif (!$isUserAllowed) {\n\t\t\treturn $response->withStatus(403)->withJsonError('api.publicFiles.403.unauthorized');\n\t\t}\n\n\t\t// Don't allow user to exceed the alotted space in their public directory\n\t\t$currentSize = 0;\n\t\tif ($allowedDirSize > 0 && file_exists($userDir)) {\n\t\t\tforeach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($userDir, FilesystemIterator::SKIP_DOTS)) as $object) {\n\t\t\t\t$currentSize += $object->getSize();\n\t\t\t}\n\t\t}\n\t\tif (($currentSize + $_FILES['file']['size']) > $allowedDirSize) {\n\t\t\treturn $response->withStatus(413)->withJsonError('api.publicFiles.413.noDirSpace', [\n\t\t\t\t'fileUploadSize' => ceil($_FILES['file']['size']/1024),\n\t\t\t\t'dirSizeLeft' => ceil(($allowedDirSize - $currentSize)/1024),\n\t\t\t]);\n\t\t}\n\n\t\timport('lib.pkp.classes.file.FileManager');\n\t\t$fileManager = new FileManager();\n\t\t$filename = $fileManager->getUploadedFileName('file');\n\t\t$filename = trim(\n\t\t\tpreg_replace(\n\t\t\t\t\"/[^a-z0-9\\.\\-]+/\",\n\t\t\t\t\"\",\n\t\t\t\tstr_replace(\n\t\t\t\t\t[' ', '_', ':'],\n\t\t\t\t\t'-',\n\t\t\t\t\tstrtolower($filename)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\t$extension = pathinfo(strtolower(trim($filename)), PATHINFO_EXTENSION);\n\n\t\t// Only allow permitted file types\n\t\tif (!in_array($extension, $allowedFileTypes)) {\n\t\t\treturn $response->withStatus(400)->withJsonError('api.publicFiles.400.extensionNotSupported', [\n\t\t\t\t'fileTypes' => join(__('common.commaListSeparator'), $allowedFileTypes)\n\t\t\t]);\n\t\t}\n\n\t\t// Perform additional checks on images\n\t\tif (in_array($extension, ['gif', 'jpg', 'jpeg', 'png', 'jpe', 'webp', 'svg'])) {\n\t\t\tif (getimagesize($_FILES['file']['tmp_name']) === false) {\n\t\t\t\treturn $response->withStatus(400)->withJsonError('api.publicFiles.400.invalidImage');\n\t\t\t}\n\t\t\t$extensionFromMimeType = $fileManager->getImageExtension(PKPString::mime_content_type($_FILES['file']['tmp_name']));\n\t\t\tif ($extensionFromMimeType !== '.' . $extension) {\n\t\t\t\treturn $response->withStatus(400)->withJsonError('api.publicFiles.400.mimeTypeNotMatched');\n\t\t\t}\n\t\t}\n\n\t\t// Save the file\n\t\t$destinationPath = $this->_getFilename($siteDir . '/images/' . $request->getUser()->getUsername() . '/' . $filename, $fileManager);\n\t\t$success = $fileManager->uploadFile('file', $destinationPath);\n\n\t\tif ($success === false) {\n\t\t\tif ($fileManager->uploadError($filename)) {\n\t\t\t\tswitch ($fileManager->getUploadErrorCode($filename)) {\n\t\t\t\t\tcase UPLOAD_ERR_INI_SIZE:\n\t\t\t\t\tcase UPLOAD_ERR_FORM_SIZE:\n\t\t\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.fileSize', ['maxSize' => Application::getReadableMaxFileSize()]);\n\t\t\t\t\tcase UPLOAD_ERR_PARTIAL:\n\t\t\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.uploadFailed');\n\t\t\t\t\tcase UPLOAD_ERR_NO_FILE:\n\t\t\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.noUpload');\n\t\t\t\t\tcase UPLOAD_ERR_NO_TMP_DIR:\n\t\t\t\t\tcase UPLOAD_ERR_CANT_WRITE:\n\t\t\t\t\tcase UPLOAD_ERR_EXTENSION:\n\t\t\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.config');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.uploadFailed');\n\t\t}\n\n\t\treturn $this->getResponse($response->withJson([\n\t\t\t'url' => $request->getBaseUrl() . '/' .\n\t\t\t\t\tConfig::getVar('files', 'public_files_dir') . '/site/images/' .\n\t\t\t\t\t$request->getUser()->getUsername() . '/' .\n\t\t\t\t\tpathinfo($destinationPath, PATHINFO_BASENAME),\n\t\t]));\n\t}\n\n\t/**\n\t * Respond affirmatively to a HTTP OPTIONS request with headers which allow\n\t * file uploads\n\t *\n\t * @param $slimRequest Request Slim request object\n\t * @param $response Response object\n\t * @param $args array arguments\n\t * @return Response\n\t */\n\tpublic function getOptions($slimRequest, $response, $args) {\n\t\treturn $this->getResponse($response);\n\t}\n\n\t/**\n\t * A recursive function to get a filename that will not overwrite an\n\t * existing file\n\t *\n\t * @param string $path Preferred filename\n\t * @param FileManager $fileManager\n\t * @return string\n\t */\n\tprivate function _getFilename($path, $fileManager) {\n\t\tif ($fileManager->fileExists($path)) {\n\t\t\t$pathParts = pathinfo($path);\n\t\t\t$filename = $pathParts['filename'] . '-' . md5(microtime()) . '.' . $pathParts['extension'];\n\t\t\tif (strlen($filename > 255)) {\n\t\t\t\t$filename = substr($filename, -255, 255);\n\t\t\t}\n\t\t\treturn $this->_getFilename($pathParts['dirname'] . '/' . $filename, $fileManager);\n\t\t}\n\t\treturn $path;\n\t}\n}\n", "<?php\n\n/**\n * @defgroup file File\n * Implements file management tools, including a database-backed list of files\n * associated with submissions.\n */\n\n/**\n * @file classes/file/FileManager.inc.php\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n * ePUB mime type added  Leah M Root (rootl) SUNY Geneseo\n * @class FileManager\n * @ingroup file\n *\n * @brief Class defining basic operations for file management.\n */\n\n\ndefine('FILE_MODE_MASK', 0666);\ndefine('DIRECTORY_MODE_MASK', 0777);\n\ndefine('DOCUMENT_TYPE_DEFAULT', 'default');\ndefine('DOCUMENT_TYPE_AUDIO', 'audio');\ndefine('DOCUMENT_TYPE_EXCEL', 'excel');\ndefine('DOCUMENT_TYPE_HTML', 'html');\ndefine('DOCUMENT_TYPE_IMAGE', 'image');\ndefine('DOCUMENT_TYPE_PDF', 'pdf');\ndefine('DOCUMENT_TYPE_WORD', 'word');\ndefine('DOCUMENT_TYPE_EPUB', 'epub');\ndefine('DOCUMENT_TYPE_VIDEO', 'video');\ndefine('DOCUMENT_TYPE_ZIP', 'zip');\n\nclass FileManager {\n\t/**\n\t * Constructor\n\t */\n\tfunction __construct() {\n\t}\n\n\t/**\n\t * Return true if an uploaded file exists.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return boolean\n\t */\n\tfunction uploadedFileExists($fileName) {\n\t\tif (isset($_FILES[$fileName]) && isset($_FILES[$fileName]['tmp_name'])\n\t\t\t\t&& is_uploaded_file($_FILES[$fileName]['tmp_name'])) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return true iff an error occurred when trying to upload a file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return boolean\n\t */\n\tfunction uploadError($fileName) {\n\t\treturn (isset($_FILES[$fileName]) && $_FILES[$fileName]['error'] != UPLOAD_ERR_OK);\n\t}\n\n\t/**\n\t * Get the error code of a file upload\n\t * @see http://php.net/manual/en/features.file-upload.errors.php\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return integer\n\t */\n\tfunction getUploadErrorCode($fileName) {\n\t\treturn $_FILES[$fileName]['error'];\n\t}\n\n\t/**\n\t * Get the filename of the first uploaded file in the $_FILES array. The\n\t * returned filename is the value used in the form that submitted the request.\n\t * @return string\n\t */\n\tfunction getFirstUploadedPostName() {\n\t\treturn key($_FILES);\n\t}\n\n\t/**\n\t * Return the (temporary) path to an uploaded file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return string (boolean false if no such file)\n\t */\n\tfunction getUploadedFilePath($fileName) {\n\t\tif (isset($_FILES[$fileName]['tmp_name']) && is_uploaded_file($_FILES[$fileName]['tmp_name'])) {\n\t\t\treturn $_FILES[$fileName]['tmp_name'];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return the user-specific (not temporary) filename of an uploaded file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return string (boolean false if no such file)\n\t */\n\tfunction getUploadedFileName($fileName) {\n\t\tif (isset($_FILES[$fileName]['name'])) {\n\t\t\treturn $_FILES[$fileName]['name'];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return the type of an uploaded file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return string\n\t */\n\tfunction getUploadedFileType($fileName) {\n\t\tif (isset($_FILES[$fileName])) {\n\t\t\t// The result of \"explode\" can't be passed directly to \"array_pop\" in PHP 7.\n\t\t\t$exploded = explode('.',$_FILES[$fileName]['name']);\n\n\t\t\t$type = PKPString::mime_content_type(\n\t\t\t\t$_FILES[$fileName]['tmp_name'], // Location on server\n\t\t\t\tarray_pop($exploded) // Extension on client machine\n\t\t\t);\n\n\t\t\tif (!empty($type)) return $type;\n\t\t\treturn $_FILES[$fileName]['type'];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Upload a file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @param $dest string the path where the file is to be saved\n\t * @return boolean returns true if successful\n\t */\n\tfunction uploadFile($fileName, $destFileName) {\n\t\t$destDir = dirname($destFileName);\n\t\tif (!$this->fileExists($destDir, 'dir')) {\n\t\t\t// Try to create the destination directory\n\t\t\t$this->mkdirtree($destDir);\n\t\t}\n\t\tif (!isset($_FILES[$fileName])) return false;\n\t\tif (move_uploaded_file($_FILES[$fileName]['tmp_name'], $destFileName))\n\t\t\treturn $this->setMode($destFileName, FILE_MODE_MASK);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Write a file.\n\t * @param $dest string the path where the file is to be saved\n\t * @param $contents string the contents to write to the file\n\t * @return boolean returns true if successful\n\t */\n\tfunction writeFile($dest, &$contents) {\n\t\t$success = true;\n\t\t$destDir = dirname($dest);\n\t\tif (!$this->fileExists($destDir, 'dir')) {\n\t\t\t// Try to create the destination directory\n\t\t\t$this->mkdirtree($destDir);\n\t\t}\n\t\tif (($f = fopen($dest, 'wb'))===false) $success = false;\n\t\tif ($success && fwrite($f, $contents)===false) $success = false;\n\t\t@fclose($f);\n\n\t\tif ($success)\n\t\t\treturn $this->setMode($dest, FILE_MODE_MASK);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Copy a file.\n\t * @param $source string the source URL for the file\n\t * @param $dest string the path where the file is to be saved\n\t * @return boolean returns true if successful\n\t */\n\tfunction copyFile($source, $dest) {\n\t\t$destDir = dirname($dest);\n\t\tif (!$this->fileExists($destDir, 'dir')) {\n\t\t\t// Try to create the destination directory\n\t\t\t$this->mkdirtree($destDir);\n\t\t}\n\t\tif (copy($source, $dest))\n\t\t\treturn $this->setMode($dest, FILE_MODE_MASK);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Copy a directory.\n\t * Adapted from code by gimmicklessgpt at gmail dot com, at http://php.net/manual/en/function.copy.php\n\t * @param $source string the path to the source directory\n\t * @param $dest string the path where the directory is to be saved\n\t * @return boolean returns true if successful\n\t */\n\tfunction copyDir($source, $dest) {\n\t\tif (is_dir($source)) {\n\t\t\t$this->mkdir($dest);\n\t\t\t$destDir = dir($source);\n\n\t\t\twhile (($entry = $destDir->read()) !== false) {\n\t\t\t\tif ($entry == '.' || $entry == '..') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$Entry = $source . DIRECTORY_SEPARATOR . $entry;\n\t\t\t\tif (is_dir($Entry) ) {\n\t\t\t\t\t$this->copyDir($Entry, $dest . DIRECTORY_SEPARATOR . $entry );\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$this->copyFile($Entry, $dest . DIRECTORY_SEPARATOR . $entry );\n\t\t\t}\n\n\t\t\t$destDir->close();\n\t\t} else {\n\t\t\t$this->copyFile($source, $dest);\n\t\t}\n\n\t\tif ($this->fileExists($dest, 'dir')) {\n\t\t\treturn true;\n\t\t} else return false;\n\t}\n\n\n\t/**\n\t * Read a file's contents.\n\t * @param $filePath string the location of the file to be read\n\t * @param $output boolean output the file's contents instead of returning a string\n\t * @return string|boolean\n\t */\n\tfunction readFileFromPath($filePath, $output = false) {\n\t\tif (is_readable($filePath)) {\n\t\t\t$f = fopen($filePath, 'rb');\n\t\t\tif (!$f) return false;\n\t\t\t$data = '';\n\t\t\twhile (!feof($f)) {\n\t\t\t\t$data .= fread($f, 4096);\n\t\t\t\tif ($output) {\n\t\t\t\t\techo $data;\n\t\t\t\t\t$data = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose($f);\n\n\t\t\tif ($output) return true;\n\t\t\treturn $data;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Download a file.\n\t * Outputs HTTP headers and file content for download\n\t * @param $filePath string the location of the file to be sent\n\t * @param $mediaType string the MIME type of the file, optional\n\t * @param $inline boolean print file as inline instead of attachment, optional\n\t * @param $fileName string Optional filename to use on the client side\n\t * @return boolean\n\t */\n\tfunction downloadByPath($filePath, $mediaType = null, $inline = false, $fileName = null) {\n\t\t$result = null;\n\t\tif (HookRegistry::call('FileManager::downloadFile', array(&$filePath, &$mediaType, &$inline, &$result, &$fileName))) return $result;\n\t\tif (is_readable($filePath)) {\n\t\t\tif ($mediaType === null) {\n\t\t\t\t// If the media type wasn't specified, try to detect.\n\t\t\t\t$mediaType = PKPString::mime_content_type($filePath);\n\t\t\t\tif (empty($mediaType)) $mediaType = 'application/octet-stream';\n\t\t\t}\n\t\t\tif ($fileName === null) {\n\t\t\t\t// If the filename wasn't specified, use the server-side.\n\t\t\t\t$fileName = basename($filePath);\n\t\t\t}\n\n\t\t\t// Stream the file to the end user.\n\t\t\theader(\"Content-Type: $mediaType\");\n\t\t\theader('Content-Length: ' . filesize($filePath));\n\t\t\theader('Accept-Ranges: none');\n\t\t\theader('Content-Disposition: ' . ($inline ? 'inline' : 'attachment') . \"; filename=\\\"$fileName\\\"\");\n\t\t\theader('Cache-Control: private'); // Workarounds for IE weirdness\n\t\t\theader('Pragma: public');\n\t\t\t$this->readFileFromPath($filePath, true);\n\t\t\t$returner = true;\n\t\t} else {\n\t\t\t$returner = false;\n\t\t}\n\t\tHookRegistry::call('FileManager::downloadFileFinished', array(&$returner));\n\t\treturn $returner;\n\t}\n\n\t/**\n\t * Delete a file.\n\t * @param $filePath string the location of the file to be deleted\n\t * @return boolean returns true if successful\n\t */\n\tfunction deleteByPath($filePath) {\n\t\tif ($this->fileExists($filePath)) {\n\t\t\t$result = null;\n\t\t\tif (HookRegistry::call('FileManager::deleteFile', array($filePath, &$result))) return $result;\n\t\t\treturn unlink($filePath);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create a new directory.\n\t * @param $dirPath string the full path of the directory to be created\n\t * @param $perms string the permissions level of the directory (optional)\n\t * @return boolean returns true if successful\n\t */\n\tfunction mkdir($dirPath, $perms = null) {\n\t\tif ($perms !== null) {\n\t\t\treturn mkdir($dirPath, $perms);\n\t\t} else {\n\t\t\tif (mkdir($dirPath))\n\t\t\t\treturn $this->setMode($dirPath, DIRECTORY_MODE_MASK);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Remove a directory.\n\t * @param $dirPath string the full path of the directory to be delete\n\t * @return boolean returns true if successful\n\t */\n\tfunction rmdir($dirPath) {\n\t\treturn rmdir($dirPath);\n\t}\n\n\t/**\n\t * Delete all contents including directory (equivalent to \"rm -r\")\n\t * @param $file string the full path of the directory to be removed\n\t * @return boolean true iff success, otherwise false\n\t */\n\tfunction rmtree($file) {\n\t\tif (file_exists($file)) {\n\t\t\tif (is_dir($file)) {\n\t\t\t\t$handle = opendir($file);\n\t\t\t\twhile (($filename = readdir($handle)) !== false) {\n\t\t\t\t\tif ($filename != '.' && $filename != '..') {\n\t\t\t\t\t\tif (!$this->rmtree($file . '/' . $filename)) return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclosedir($handle);\n\t\t\t\tif (!rmdir($file)) return false;\n\n\t\t\t} else {\n\t\t\t\tif (!unlink($file)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Create a new directory, including all intermediate directories if required (equivalent to \"mkdir -p\")\n\t * @param $dirPath string the full path of the directory to be created\n\t * @param $perms string the permissions level of the directory (optional)\n\t * @return boolean returns true if successful\n\t */\n\tfunction mkdirtree($dirPath, $perms = null) {\n\t\tif (!file_exists($dirPath)) {\n\t\t\t//Avoid infinite recursion when file_exists reports false for root directory\n\t\t\tif ($dirPath == dirname($dirPath)) {\n\t\t\t\tfatalError('There are no readable files in this directory tree. Are safe mode or open_basedir active?');\n\t\t\t\treturn false;\n\t\t\t} else if ($this->mkdirtree(dirname($dirPath), $perms)) {\n\t\t\t\treturn $this->mkdir($dirPath, $perms);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check if a file path is valid;\n\t * @param $filePath string the file/directory to check\n\t * @param $type string (file|dir) the type of path\n\t */\n\tfunction fileExists($filePath, $type = 'file') {\n\t\tswitch ($type) {\n\t\t\tcase 'file':\n\t\t\t\treturn file_exists($filePath);\n\t\t\tcase 'dir':\n\t\t\t\treturn file_exists($filePath) && is_dir($filePath);\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a file type, based on generic categories defined above\n\t * @param $type String\n\t * @return string (Enuemrated DOCUMENT_TYPEs)\n\t */\n\tfunction getDocumentType($type) {\n\t\tif ($this->getImageExtension($type))\n\t\t\treturn DOCUMENT_TYPE_IMAGE;\n\n\t\tswitch ($type) {\n\t\t\tcase 'application/pdf':\n\t\t\tcase 'application/x-pdf':\n\t\t\tcase 'text/pdf':\n\t\t\tcase 'text/x-pdf':\n\t\t\t\treturn DOCUMENT_TYPE_PDF;\n\t\t\tcase 'application/msword':\n\t\t\tcase 'application/word':\n\t\t\t\treturn DOCUMENT_TYPE_WORD;\n\t\t\tcase 'application/excel':\n\t\t\t\treturn DOCUMENT_TYPE_EXCEL;\n\t\t\tcase 'text/html':\n\t\t\t\treturn DOCUMENT_TYPE_HTML;\n\t\t\tcase 'application/zip':\n\t\t\tcase 'application/x-zip':\n\t\t\tcase 'application/x-zip-compressed':\n\t\t\tcase 'application/x-compress':\n\t\t\tcase 'application/x-compressed':\n\t\t\tcase 'multipart/x-zip':\n\t\t\t\treturn DOCUMENT_TYPE_ZIP;\n\t\t\tcase 'application/epub':\n\t\t\tcase 'application/epub+zip':\n\t\t\t\treturn DOCUMENT_TYPE_EPUB;\n\t\t\tdefault:\n\t\t\t\treturn DOCUMENT_TYPE_DEFAULT;\n\t\t}\n\t}\n\n\t/**\n\t * Returns file extension associated with the given document type,\n\t * or false if the type does not belong to a recognized document type.\n\t * @param $type string\n\t */\n\tfunction getDocumentExtension($type) {\n\t\tswitch ($type) {\n\t\t\tcase 'application/pdf':\n\t\t\t\treturn '.pdf';\n\t\t\tcase 'application/word':\n\t\t\t\treturn '.doc';\n\t\t\tcase 'text/css':\n\t\t\t\treturn '.css';\n\t\t\tcase 'text/html':\n\t\t\t\treturn '.html';\n\t\t\tcase 'application/epub+zip':\n\t\t\t\treturn '.epub';\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns file extension associated with the given image type,\n\t * or false if the type does not belong to a recognized image type.\n\t * @param $type string\n\t */\n\tfunction getImageExtension($type) {\n\t\tswitch ($type) {\n\t\t\tcase 'image/gif':\n\t\t\t\treturn '.gif';\n\t\t\tcase 'image/jpeg':\n\t\t\tcase 'image/pjpeg':\n\t\t\t\treturn '.jpg';\n\t\t\tcase 'image/png':\n\t\t\tcase 'image/x-png':\n\t\t\t\treturn '.png';\n\t\t\tcase 'image/vnd.microsoft.icon':\n\t\t\tcase 'image/x-icon':\n\t\t\tcase 'image/x-ico':\n\t\t\tcase 'image/ico':\n\t\t\t\treturn '.ico';\n\t\t\tcase 'image/svg+xml':\n\t\t\tcase 'image/svg':\n\t\t\t\treturn '.svg';\n\t\t\tcase 'application/x-shockwave-flash':\n\t\t\t\treturn '.swf';\n\t\t\tcase 'video/x-flv':\n\t\t\tcase 'application/x-flash-video':\n\t\t\tcase 'flv-application/octet-stream':\n\t\t\t\treturn '.flv';\n\t\t\tcase 'audio/mpeg':\n\t\t\t\treturn '.mp3';\n\t\t\tcase 'audio/x-aiff':\n\t\t\t\treturn '.aiff';\n\t\t\tcase 'audio/x-wav':\n\t\t\t\treturn '.wav';\n\t\t\tcase 'video/mpeg':\n\t\t\t\treturn '.mpg';\n\t\t\tcase 'video/quicktime':\n\t\t\t\treturn '.mov';\n\t\t\tcase 'video/mp4':\n\t\t\t\treturn '.mp4';\n\t\t\tcase 'text/javascript':\n\t\t\t\treturn '.js';\n\t\t\tcase 'image/webp':\n\t\t\t\treturn '.webp';\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse file extension from file name.\n\t * @param string a valid file name\n\t * @return string extension\n\t */\n\tfunction getExtension($fileName) {\n\t\t$extension = '';\n\t\t$fileParts = explode('.', $fileName);\n\t\tif (is_array($fileParts)) {\n\t\t\t$extension = $fileParts[count($fileParts) - 1];\n\t\t}\n\t\treturn $extension;\n\t}\n\n\t/**\n\t * Truncate a filename to fit in the specified length.\n\t */\n\tfunction truncateFileName($fileName, $length = 127) {\n\t\tif (PKPString::strlen($fileName) <= $length) return $fileName;\n\t\t$ext = $this->getExtension($fileName);\n\t\t$truncated = PKPString::substr($fileName, 0, $length - 1 - PKPString::strlen($ext)) . '.' . $ext;\n\t\treturn PKPString::substr($truncated, 0, $length);\n\t}\n\n\t/**\n\t * Return pretty file size string (in B, KB, MB, or GB units).\n\t * @param $size int file size in bytes\n\t * @return string\n\t */\n\tfunction getNiceFileSize($size) {\n\t\t$niceFileSizeUnits = array('B', 'KB', 'MB', 'GB');\n\t\tfor($i = 0; $i < 4 && $size > 1024; $i++) {\n\t\t\t$size >>= 10;\n\t\t}\n\t\treturn $size . $niceFileSizeUnits[$i];\n\t}\n\n\t/**\n\t * Set file/directory mode based on the 'umask' config setting.\n\t * @param $path string\n\t * @param $mask int\n\t * @return boolean\n\t */\n\tfunction setMode($path, $mask) {\n\t\t$umask = Config::getVar('files', 'umask');\n\t\tif (!$umask)\n\t\t\treturn true;\n\t\treturn chmod($path, $mask & ~$umask);\n\t}\n\n\t/**\n\t * Parse the file extension from a filename/path.\n\t * @param $fileName string\n\t * @return string\n\t */\n\tfunction parseFileExtension($fileName) {\n\t\t$fileParts = explode('.', $fileName);\n\t\tif (is_array($fileParts) && count($fileParts) > 1) {\n\t\t\t$fileExtension = $fileParts[count($fileParts) - 1];\n\t\t}\n\n\t\t// FIXME Check for evil\n\t\tif (!isset($fileExtension) || stristr($fileExtension, 'php') || strlen($fileExtension) > 6 || !preg_match('/^\\w+$/', $fileExtension)) {\n\t\t\t$fileExtension = 'txt';\n\t\t}\n\n\t\t// consider .tar.gz extension\n\t\tif (strtolower(substr($fileName, -7)) == '.tar.gz') {\n\t\t\t$fileExtension = substr($fileName, -6);\n\t\t}\n\n\t\treturn $fileExtension;\n\t}\n\n\t/**\n\t * Decompress passed gziped file.\n\t * @param $filePath string\n\t * @return string The file path that was created.\n\t */\n\tfunction decompressFile($filePath) {\n\t\treturn $this->_executeGzip($filePath, true);\n\t}\n\n\t/**\n\t * Compress passed file.\n\t * @param $filePath string The file to be compressed.\n\t * @return string The file path that was created.\n\t */\n\tfunction compressFile($filePath) {\n\t\treturn $this->_executeGzip($filePath, false);\n\t}\n\n\n\t//\n\t// Private helper methods.\n\t//\n\t/**\n\t * Execute gzip to compress or extract files.\n\t * @param $filePath string file to be compressed or uncompressed.\n\t * @param $decompress boolean optional Set true if the passed file\n\t * needs to be decompressed.\n\t * @return string The file path that was created with the operation\n\t */\n\tprivate function _executeGzip($filePath, $decompress = false) {\n\t\tPKPLocale::requireComponents(LOCALE_COMPONENT_PKP_ADMIN);\n\t\t$gzipPath = Config::getVar('cli', 'gzip');\n\t\tif (!is_executable($gzipPath)) {\n\t\t\tthrow new Exception(__('admin.error.executingUtil', array('utilPath' => $gzipPath, 'utilVar' => 'gzip')));\n\t\t}\n\t\t$gzipCmd = escapeshellarg($gzipPath);\n\t\tif ($decompress) $gzipCmd .= ' -d';\n\t\t// Make sure any output message will mention the file path.\n\t\t$output = array($filePath);\n\t\t$returnValue = 0;\n\t\t$gzipCmd .= ' ' . escapeshellarg($filePath);\n\t\tif (!Core::isWindows()) {\n\t\t\t// Get the output, redirecting stderr to stdout.\n\t\t\t$gzipCmd .= ' 2>&1';\n\t\t}\n\t\texec($gzipCmd, $output, $returnValue);\n\t\tif ($returnValue > 0) {\n\t\t\tthrow new Exception(__('admin.error.utilExecutionProblem', array('utilPath' => $gzipPath, 'output' => implode(PHP_EOL, $output))));\n\t\t}\n\t\tif ($decompress) {\n\t\t\treturn substr($filePath, 0, -3);\n\t\t} else {\n\t\t\treturn $filePath . '.gz';\n\t\t}\n\t}\n}\n", "<?php\n/**\n * @file classes/services/PKPFileService.php\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * @class PKPFileService\n * @ingroup services\n *\n * @brief Helper class that encapsulates business logic for publications\n */\n\nnamespace PKP\\Services;\n\nuse \\Application;\nuse \\Config;\nuse \\Exception;\nuse \\HookRegistry;\nuse League\\Flysystem\\Adapter\\Local;\nuse League\\Flysystem\\Filesystem;\nuse Illuminate\\Database\\Capsule\\Manager as Capsule;\n\nclass PKPFileService {\n\n\t/** @var Filesystem */\n\tpublic $fs;\n\n\t/**\n\t * Initialize and configure flysystem\n\t */\n\tpublic function __construct() {\n\t\t$umask = Config::getVar('files', 'umask', 0022);\n\t\t$adapter = new Local(\n\t\t\tConfig::getVar('files', 'files_dir'),\n\t\t\tLOCK_EX,\n\t\t\tLocal::DISALLOW_LINKS,\n\t\t\t[\n\t\t\t\t'file' => [\n\t\t\t\t\t'public' => FILE_MODE_MASK & ~$umask,\n\t\t\t\t\t'private' => FILE_MODE_MASK  & ~$umask,\n\t\t\t\t],\n\t\t\t\t'dir' => [\n\t\t\t\t\t'public' => DIRECTORY_MODE_MASK & ~$umask,\n\t\t\t\t\t'private' => DIRECTORY_MODE_MASK & ~$umask,\n\t\t\t\t]\n\t\t\t]\n\t\t);\n\n\t\tHookRegistry::call('File::adapter', [&$adapter, $this]);\n\n\t\t$this->fs = new Filesystem($adapter);\n\t}\n\n\t/**\n\t * Get a file by its id\n\t *\n\t * @param int $id\n\t * @return stdObject\n\t */\n\tpublic function get($id) {\n\t\t$file = Capsule::table('files')\n\t\t\t->where('file_id', '=', $id)\n\t\t\t->select(['file_id as id', 'path', 'mimetype'])\n\t\t\t->first();\n\t\treturn $file;\n\t}\n\n\t/**\n\t * Add a file\n\t *\n\t * @param string $from absolute path to file\n\t * @param string $to relative path in file dir\n\t * @return int file id\n\t */\n\tpublic function add($from, $to) {\n\t\t$stream = fopen($from, 'r+');\n\t\tif (!$stream) {\n\t\t\tthrow new Exception(\"Unable to copy $from to $to.\");\n\t\t}\n\t\tif (!$this->fs->writeStream($to, $stream)) {\n\t\t\tthrow new Exception(\"Unable to write file at $to.\");\n\t\t}\n\t\tif (is_resource($stream)) {\n\t\t\tfclose($stream);\n\t\t}\n\t\t$mimetype = $this->fs->getMimetype($to);\n\n\t\t// Check and override ambiguous mime types based on file extension\n\t\tif ($extension = pathinfo($to, PATHINFO_EXTENSION)) {\n\t\t\t$checkAmbiguous = strtolower($extension . ':' . $mimetype);\n\t\t\tif (array_key_exists($checkAmbiguous, $extensionsMap = \\PKPString::getAmbiguousExtensionsMap())) {\n\t\t\t\t$mimetype = $extensionsMap[$checkAmbiguous];\n\t\t\t}\n\t\t}\n\n\t\treturn Capsule::table('files')->insertGetId([\n\t\t\t'path' => $to,\n\t\t\t'mimetype' => $mimetype,\n\t\t], 'file_id');\n\t}\n\n\t/**\n\t * Delete an uploaded file\n\t *\n\t * @param int $id\n\t * @return File\n\t */\n\tpublic function delete($id) {\n\t\t$file = $this->get($id);\n\t\tif (!$file) {\n\t\t\tthrow new Exception(\"Unable to locate file $id.\");\n\t\t}\n\t\t$path = $file->path;\n\t\tif ($this->fs->has($path) && !$this->fs->delete($path)) {\n\t\t\tthrow new Exception(\"Unable to delete file $id at $path.\");\n\t\t}\n\t\tCapsule::table('files')\n\t\t\t->where('file_id', '=', $file->id)\n\t\t\t->delete();\n\t}\n\n\t/**\n\t * Download a file\n\t *\n\t * This method sends a HTTP response and ends the request handling.\n\t * No code will run after this method is called.\n\t *\n\t * @param string|int $pathOrFileId The path to the file or file ID\n\t * @param string $filename Filename to give to the downloaded file\n\t * @param boolean $inline Whether to stream the file to the browser\n\t */\n\tpublic function download($pathOrFileId, $filename, $inline = false) {\n\n\t\t$dispatcher = Application::get()->getRequest()->getDispatcher();\n\n\t\tif (is_int($pathOrFileId)) {\n\t\t\t// Is the file ID\n\t\t\t$fileId = $pathOrFileId;\n\t\t\t$file = $this->get($fileId);\n\t\t\tif (!$file) $dispatcher->handle404();\n\t\t\t$path = $file->path;\n\t\t} else {\n\t\t\t// Is the path to the file; compatibility fix, see pkp/pkp-lib#6663\n\t\t\t$path = $pathOrFileId;\n\t\t}\n\n\t\tif (!$this->fs->has($path)) {\n\t\t\t$dispatcher->handle404();\n\t\t}\n\n\t\tif (HookRegistry::call('File::download', [$path, &$filename, $inline])) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stream the file to the end user.\n\t\t$mimetype = $file->mimetype ?? $this->fs->getMimetype($path) ?? 'application/octet-stream';\n\t\t$filesize = $this->fs->getSize($path);\n\t\t$encodedFilename = urlencode($filename);\n\t\theader(\"Content-Type: $mimetype\");\n\t\theader(\"Content-Length: $filesize\");\n\t\theader('Accept-Ranges: none');\n\t\theader('Content-Disposition: ' . ($inline ? 'inline' : 'attachment') . \";filename=\\\"$encodedFilename\\\";filename*=UTF-8''$encodedFilename\");\n\t\theader('Cache-Control: private'); // Workarounds for IE weirdness\n\t\theader('Pragma: public');\n\n\t\tfpassthru($this->fs->readStream($path));\n\t\texit();\n\t}\n\n\t/**\n\t * Convert a filename into a consistent format with the correct extension\n\t *\n\t * @param string $path Path to the file\n\t * @param string $filename Source filename to sanitize\n\t * @return string\n\t */\n\tpublic function formatFilename($path, $filename) {\n\t\t$extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));\n\t\t$newFilename = $filename;\n\t\tif (!empty($extension) && substr($newFilename, (strlen($extension) * -1)) != $extension) {\n\t\t\t$newFilename .= '.' . $extension;\n\t\t}\n\n\t\tHookRegistry::call('File::formatFilename', [&$newFilename, $path, $filename]);\n\n\t\treturn $newFilename;\n\t}\n\n\t/**\n\t * Get document type based on the mimetype\n\t *\n\t * @param string $mimetype\n\t * @return string One of the DOCUMENT_TYPE_ constants\n\t */\n\tpublic function getDocumentType($mimetype) {\n\t\tswitch ($mimetype) {\n\t\t\tcase 'application/pdf':\n\t\t\tcase 'application/x-pdf':\n\t\t\tcase 'text/pdf':\n\t\t\tcase 'text/x-pdf':\n\t\t\t\treturn DOCUMENT_TYPE_PDF;\n\t\t\tcase 'application/msword':\n\t\t\tcase 'application/word':\n\t\t\tcase 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':\n\t\t\t\treturn DOCUMENT_TYPE_WORD;\n\t\t\tcase 'application/excel':\n\t\t\tcase 'application/vnd.ms-excel':\n\t\t\tcase 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':\n\t\t\t\treturn DOCUMENT_TYPE_EXCEL;\n\t\t\tcase 'text/html':\n\t\t\t\treturn DOCUMENT_TYPE_HTML;\n\t\t\tcase 'application/zip':\n\t\t\tcase 'application/x-zip':\n\t\t\tcase 'application/x-zip-compressed':\n\t\t\tcase 'application/x-compress':\n\t\t\tcase 'application/x-compressed':\n\t\t\tcase 'multipart/x-zip':\n\t\t\t\treturn DOCUMENT_TYPE_ZIP;\n\t\t\tcase 'application/epub':\n\t\t\tcase 'application/epub+zip':\n\t\t\t\treturn DOCUMENT_TYPE_EPUB;\n\t\t\tcase 'image/gif':\n\t\t\tcase 'image/jpeg':\n\t\t\tcase 'image/pjpeg':\n\t\t\tcase 'image/png':\n\t\t\tcase 'image/x-png':\n\t\t\tcase 'image/vnd.microsoft.icon':\n\t\t\tcase 'image/x-icon':\n\t\t\tcase 'image/x-ico':\n\t\t\tcase 'image/ico':\n\t\t\tcase 'image/svg+xml':\n\t\t\tcase 'image/svg':\n\t\t\t\treturn DOCUMENT_TYPE_IMAGE;\n\t\t\tcase 'application/x-shockwave-flash':\n\t\t\tcase 'video/x-flv':\n\t\t\tcase 'application/x-flash-video':\n\t\t\tcase 'flv-application/octet-stream':\n\t\t\tcase 'video/mpeg':\n\t\t\tcase 'video/quicktime':\n\t\t\tcase 'video/mp4':\n\t\t\t\treturn DOCUMENT_TYPE_VIDEO;\n\t\t\tcase 'audio/mpeg':\n\t\t\tcase 'audio/x-aiff':\n\t\t\tcase 'audio/x-wav':\n\t\t\t\treturn DOCUMENT_TYPE_AUDIO;\n\t\t\tdefault:\n\t\t\t\treturn DOCUMENT_TYPE_DEFAULT;\n\t\t}\n\t}\n\n\t/**\n\t * Get a pretty file size string\n\t *\n\t * Examples: 82B, 12KB, 2MB, 2GB\n\t *\n\t * @param integer $size File size in bytes\n\t * @return string\n\t */\n\tfunction getNiceFileSize($size) {\n\t\t$niceFileSizeUnits = array('B', 'KB', 'MB', 'GB');\n\t\tfor($i = 0; $i < 4 && $size > 1024; $i++) {\n\t\t\t$size >>= 10;\n\t\t}\n\t\treturn $size . $niceFileSizeUnits[$i];\n\t}\n}\n", "{**\n * lib/pkp/templates/controllers/grid/settings/category/form/categoryForm.tpl\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2003-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * Form to edit or create a category\n *}\n\n<script type=\"text/javascript\">\n\t$(function() {ldelim}\n\t\t// Attach the form handler.\n\t\t$('#categoryForm').pkpHandler(\n\t\t\t'$.pkp.controllers.form.FileUploadFormHandler',\n\t\t\t{ldelim}\n\t\t\t\tpublishChangeEvents: ['updateSidebar'],\n\t\t\t\t$uploader: $('#plupload'),\n\t\t\t\tuploaderOptions: {ldelim}\n\t\t\t\t\tuploadUrl: {url|json_encode op=\"uploadImage\" escape=false},\n\t\t\t\t\tbaseUrl: {$baseUrl|json_encode},\n\t\t\t\t\tfilters: {ldelim}\n\t\t\t\t\t\tmime_types : [\n\t\t\t\t\t\t\t{ldelim} title : \"Image files\", extensions : \"jpg,jpeg,png,svg\" {rdelim}\n\t\t\t\t\t\t]\n\t\t\t\t\t{rdelim}\n\t\t\t\t{rdelim}\n\t\t\t{rdelim}\n\t\t);\n\t{rdelim});\n</script>\n\n<form class=\"pkp_form\" id=\"categoryForm\" method=\"post\" action=\"{url router=$smarty.const.ROUTE_COMPONENT component=\"grid.settings.category.CategoryCategoryGridHandler\" op=\"updateCategory\" categoryId=$categoryId}\">\n\t{csrf}\n\t{include file=\"controllers/notification/inPlaceNotification.tpl\" notificationId=\"categoryFormNotification\"}\n\n\t{fbvFormArea id=\"categoryDetails\"}\n\n\t\t<h3>{translate key=\"grid.category.categoryDetails\"}</h3>\n\n\t\t{fbvFormSection title=\"grid.category.name\" for=\"name\" required=\"true\"}\n\t\t\t{fbvElement type=\"text\" multilingual=\"true\" name=\"name\" value=$name id=\"name\" required=\"true\"}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection title=\"grid.category.parentCategory\" for=\"context\"}\n\t\t\t{fbvElement type=\"select\" id=\"parentId\" from=$rootCategories selected=$parentId translate=false disabled=$cannotSelectChild}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection title=\"grid.category.path\" required=true for=\"path\"}\n\t\t\t{capture assign=\"instruct\"}\n\t\t\t\t{url router=$smarty.const.ROUTE_PAGE page=\"catalog\" op=\"category\" path=\"path\"}\n\t\t\t\t{translate key=\"grid.category.urlWillBe\" sampleUrl=$sampleUrl}\n\t\t\t{/capture}\n\t\t\t{fbvElement type=\"text\" id=\"path\" value=$path maxlength=\"32\" label=$instruct subLabelTranslate=false}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection title=\"grid.category.description\" for=\"context\"}\n\t\t\t{fbvElement type=\"textarea\" multilingual=\"true\" id=\"description\" value=$description rich=true}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection label=\"catalog.sortBy\" description=\"catalog.sortBy.categoryDescription\" for=\"sortOption\"}\n\t\t\t{fbvElement type=\"select\" id=\"sortOption\" from=$sortOptions selected=$sortOption translate=false}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection title=\"category.coverImage\"}\n\t\t\t{include file=\"controllers/fileUploadContainer.tpl\" id=\"plupload\"}\n\t\t\t<input type=\"hidden\" name=\"temporaryFileId\" id=\"temporaryFileId\" value=\"\" />\n\t\t{/fbvFormSection}\n\n\t\t{if $image}\n\t\t\t{fbvFormSection}\n\t\t\t\t{capture assign=\"altTitle\"}{translate key=\"submission.currentCoverImage\"}{/capture}\n\t\t\t\t<img class=\"pkp_helpers_container_center\" height=\"{$image.thumbnailHeight}\" width=\"{$image.thumbnailWidth}\" src=\"{url router=$smarty.const.ROUTE_PAGE page=\"catalog\" op=\"thumbnail\" type=\"category\" id=$categoryId}\" alt=\"{$altTitle|escape}\" />\n\t\t\t{/fbvFormSection}\n\t\t{/if}\n\n\t\t{if count($availableSubeditors)}\n\t\t\t{fbvFormSection list=true title=\"submissionGroup.assignedSubEditors\"}\n\t\t\t\t{foreach from=$availableSubeditors item=\"subEditor\" key=\"id\"}\n\t\t\t\t\t{fbvElement type=\"checkbox\" id=\"subEditors[]\" value=$id checked=in_array($id, $assignedToCategory) label=$subEditor|escape translate=false}\n\t\t\t\t{/foreach}\n\t\t\t{/fbvFormSection}\n\t\t{/if}\n\n\t\t<p><span class=\"formRequired\">{translate key=\"common.requiredField\"}</span></p>\n\t\t{fbvFormButtons}\n\n\t{/fbvFormArea}\n</form>\n", "{**\n * templates/user/publicProfileForm.tpl\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2003-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * Public user profile form.\n *}\n\n{* Help Link *}\n{help file=\"user-profile\" class=\"pkp_help_tab\"}\n\n<script type=\"text/javascript\">\n\t$(function() {ldelim}\n\t\t// Attach the form handler.\n\t\t$('#publicProfileForm').pkpHandler(\n\t\t\t'$.pkp.controllers.form.FileUploadFormHandler',\n\t\t\t{ldelim}\n\t\t\t\t$uploader: $('#plupload'),\n\t\t\t\tuploaderOptions: {ldelim}\n\t\t\t\t\tuploadUrl: {url|json_encode op=\"uploadProfileImage\" escape=false},\n\t\t\t\t\tbaseUrl: {$baseUrl|json_encode},\n\t\t\t\t\tfilters: {ldelim}\n\t\t\t\t\t\tmime_types : [\n\t\t\t\t\t\t\t{ldelim} title : \"Image files\", extensions : \"jpg,jpeg,png,svg,gif\" {rdelim}\n\t\t\t\t\t\t]\n\t\t\t\t\t{rdelim},\n\t\t\t\t\tmultipart_params: {ldelim}\n\t\t\t\t\t\tcsrfToken: {csrf type=\"json\"}\n\t\t\t\t\t{rdelim},\n\t\t\t\t\tresize: {ldelim}\n\t\t\t\t\t\twidth: {$profileImageMaxWidth|intval},\n\t\t\t\t\t\theight: {$profileImageMaxHeight|intval},\n\t\t\t\t\t\tcrop: true,\n\t\t\t\t\t{rdelim}\n\t\t\t\t{rdelim}\n\t\t\t{rdelim}\n\t\t);\n\t{rdelim});\n</script>\n\n<form class=\"pkp_form\" id=\"publicProfileForm\" method=\"post\" action=\"{url op=\"savePublicProfile\"}\" enctype=\"multipart/form-data\">\n\t{csrf}\n\n\t{include file=\"controllers/notification/inPlaceNotification.tpl\" notificationId=\"publicProfileNotification\"}\n\n\t{fbvFormSection title=\"user.profile.form.profileImage\"}\n\t\t{if $profileImage}\n\t\t\t{* Add a unique ID to prevent caching *}\n\t\t\t<img src=\"{$baseUrl}/{$publicSiteFilesPath}/{$profileImage.uploadName}?{\"\"|uniqid}\" alt=\"{translate key=\"user.profile.form.profileImage\"}\" />\n\t\t\t<div>\n\t\t\t\t<a class=\"pkp_button pkp_button_offset\" href=\"{url op=\"deleteProfileImage\"}\">{translate key=\"common.delete\"}</a>\n\t\t\t</div>\n\t\t{/if}\n\t{/fbvFormSection}\n\t{fbvFormSection}\n\t\t{include file=\"controllers/fileUploadContainer.tpl\" id=\"plupload\"}\n\t{/fbvFormSection}\n\n\t{fbvFormSection}\n\t\t{fbvElement type=\"textarea\" label=\"user.biography\" multilingual=\"true\" name=\"biography\" id=\"biography\" rich=true value=$biography}\n\t{/fbvFormSection}\n\t{fbvFormSection}\n\t\t{fbvElement type=\"text\" label=\"user.url\" name=\"userUrl\" id=\"userUrl\" value=$userUrl maxlength=\"255\"}\n\t{/fbvFormSection}\n\t{fbvFormSection}\n\t\t{fbvElement type=\"text\" label=\"user.orcid\" name=\"orcid\" id=\"orcid\" value=$orcid maxlength=\"37\"}\n\t{/fbvFormSection}\n\n\t{call_hook name=\"User::PublicProfile::AdditionalItems\"}\n\n\t<p>\n\t\t{capture assign=\"privacyUrl\"}{url router=$smarty.const.ROUTE_PAGE page=\"about\" op=\"privacy\"}{/capture}\n\t\t{translate key=\"user.privacyLink\" privacyUrl=$privacyUrl}\n\t</p>\n\n\t<p><span class=\"formRequired\">{translate key=\"common.requiredField\"}</span></p>\n\n\t{fbvFormButtons hideCancel=true submitText=\"common.save\"}\n</form>\n"], "fixing_code": ["<?php\n/**\n * @file api/v1/contexts/PKPUploadPublicFileHandler.inc.php\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * @class PKPUploadPublicFileHandler\n * @ingroup api_v1_uploadPublicFile\n *\n * @brief Handle API requests to upload a file to a user's public directory.\n */\nimport('lib.pkp.classes.handler.APIHandler');\n\nclass PKPUploadPublicFileHandler extends APIHandler {\n\t/**\n\t * @copydoc APIHandler::__construct()\n\t */\n\tpublic function __construct() {\n\t\t$this->_handlerPath = '_uploadPublicFile';\n\t\t$roles = [ROLE_ID_SITE_ADMIN, ROLE_ID_MANAGER, ROLE_ID_SUB_EDITOR, ROLE_ID_REVIEWER, ROLE_ID_AUTHOR, ROLE_ID_ASSISTANT, ROLE_ID_READER];\n\t\t$this->_endpoints = array(\n\t\t\t'OPTIONS' => array(\n\t\t\t\tarray(\n\t\t\t\t\t'pattern' => $this->getEndpointPattern(),\n\t\t\t\t\t'handler' => array($this, 'getOptions'),\n\t\t\t\t\t'roles' => $roles,\n\t\t\t\t),\n\t\t\t),\n\t\t\t'POST' => array(\n\t\t\t\tarray(\n\t\t\t\t\t'pattern' => $this->getEndpointPattern(),\n\t\t\t\t\t'handler' => array($this, 'uploadFile'),\n\t\t\t\t\t'roles' => $roles,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tparent::__construct();\n\t}\n\n\t/**\n\t * @copydoc PKPHandler::authorize\n\t */\n\tpublic function authorize($request, &$args, $roleAssignments) {\n\t\timport('lib.pkp.classes.security.authorization.PolicySet');\n\t\t$rolePolicy = new PolicySet(COMBINING_PERMIT_OVERRIDES);\n\n\t\timport('lib.pkp.classes.security.authorization.RoleBasedHandlerOperationPolicy');\n\t\tforeach($roleAssignments as $role => $operations) {\n\t\t\t$rolePolicy->addPolicy(new RoleBasedHandlerOperationPolicy($request, $role, $operations));\n\t\t}\n\t\t$this->addPolicy($rolePolicy);\n\n\t\treturn parent::authorize($request, $args, $roleAssignments);\n\t}\n\n\t/**\n\t * A helper method which adds the necessary response headers to allow\n\t * file uploads\n\t *\n\t * @param $response Response object\n\t * @return Response\n\t */\n\tprivate function getResponse($response) {\n\t\treturn $response->withHeader('Access-Control-Allow-Headers', 'Content-Type, X-Requested-With, X-PINGOTHER, X-File-Name, Cache-Control');\n\t}\n\n\t/**\n\t * Upload a requested file\n\t *\n\t * @param $slimRequest Request Slim request object\n\t * @param $response Response object\n\t * @param $args array arguments\n\t * @return Response\n\t */\n\tpublic function uploadFile($slimRequest, $response, $args) {\n\t\t$request = $this->getRequest();\n\n\t\tif (empty($_FILES) || empty($_FILES['file'])) {\n\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.noUpload');\n\t\t}\n\n\t\t$siteDir = Core::getBaseDir() . '/' . Config::getVar('files', 'public_files_dir') . '/site';\n\n\t\tif (!file_exists($siteDir) || !is_writeable($siteDir)) {\n\t\t\treturn $response->withStatus(500)->withJsonError('api.publicFiles.500.badFilesDir');\n\t\t}\n\t\t$userDir = $siteDir . '/images/' . $request->getUser()->getUsername();\n\t\t$isUserAllowed = true;\n\t\t$allowedDirSize = Config::getVar('files', 'public_user_dir_size', 5000) * 1024;\n\t\t$allowedFileTypes = ['gif', 'jpg', 'png', 'webp'];\n\n\t\tHookRegistry::call('API::uploadPublicFile::permissions', [\n\t\t\t&$userDir,\n\t\t\t&$isUserAllowed,\n\t\t\t&$allowedDirSize,\n\t\t\t&$allowedFileTypes,\n\t\t\t$request,\n\t\t\t$this->getAuthorizedContextObject(ASSOC_TYPE_USER_ROLES),\n\t\t]);\n\n\t\t// Allow plugins to control who can upload files\n\t\tif (!$isUserAllowed) {\n\t\t\treturn $response->withStatus(403)->withJsonError('api.publicFiles.403.unauthorized');\n\t\t}\n\n\t\t// Don't allow user to exceed the alotted space in their public directory\n\t\t$currentSize = 0;\n\t\tif ($allowedDirSize > 0 && file_exists($userDir)) {\n\t\t\tforeach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($userDir, FilesystemIterator::SKIP_DOTS)) as $object) {\n\t\t\t\t$currentSize += $object->getSize();\n\t\t\t}\n\t\t}\n\t\tif (($currentSize + $_FILES['file']['size']) > $allowedDirSize) {\n\t\t\treturn $response->withStatus(413)->withJsonError('api.publicFiles.413.noDirSpace', [\n\t\t\t\t'fileUploadSize' => ceil($_FILES['file']['size']/1024),\n\t\t\t\t'dirSizeLeft' => ceil(($allowedDirSize - $currentSize)/1024),\n\t\t\t]);\n\t\t}\n\n\t\timport('lib.pkp.classes.file.FileManager');\n\t\t$fileManager = new FileManager();\n\t\t$filename = $fileManager->getUploadedFileName('file');\n\t\t$filename = trim(\n\t\t\tpreg_replace(\n\t\t\t\t\"/[^a-z0-9\\.\\-]+/\",\n\t\t\t\t\"\",\n\t\t\t\tstr_replace(\n\t\t\t\t\t[' ', '_', ':'],\n\t\t\t\t\t'-',\n\t\t\t\t\tstrtolower($filename)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t\t$extension = pathinfo(strtolower(trim($filename)), PATHINFO_EXTENSION);\n\n\t\t// Only allow permitted file types\n\t\tif (!in_array($extension, $allowedFileTypes)) {\n\t\t\treturn $response->withStatus(400)->withJsonError('api.publicFiles.400.extensionNotSupported', [\n\t\t\t\t'fileTypes' => join(__('common.commaListSeparator'), $allowedFileTypes)\n\t\t\t]);\n\t\t}\n\n\t\t// Perform additional checks on images\n\t\tif (in_array($extension, ['gif', 'jpg', 'jpeg', 'png', 'jpe', 'webp'])) {\n\t\t\tif (getimagesize($_FILES['file']['tmp_name']) === false) {\n\t\t\t\treturn $response->withStatus(400)->withJsonError('api.publicFiles.400.invalidImage');\n\t\t\t}\n\t\t\t$extensionFromMimeType = $fileManager->getImageExtension(PKPString::mime_content_type($_FILES['file']['tmp_name']));\n\t\t\tif ($extensionFromMimeType !== '.' . $extension) {\n\t\t\t\treturn $response->withStatus(400)->withJsonError('api.publicFiles.400.mimeTypeNotMatched');\n\t\t\t}\n\t\t}\n\n\t\t// Save the file\n\t\t$destinationPath = $this->_getFilename($siteDir . '/images/' . $request->getUser()->getUsername() . '/' . $filename, $fileManager);\n\t\t$success = $fileManager->uploadFile('file', $destinationPath);\n\n\t\tif ($success === false) {\n\t\t\tif ($fileManager->uploadError($filename)) {\n\t\t\t\tswitch ($fileManager->getUploadErrorCode($filename)) {\n\t\t\t\t\tcase UPLOAD_ERR_INI_SIZE:\n\t\t\t\t\tcase UPLOAD_ERR_FORM_SIZE:\n\t\t\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.fileSize', ['maxSize' => Application::getReadableMaxFileSize()]);\n\t\t\t\t\tcase UPLOAD_ERR_PARTIAL:\n\t\t\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.uploadFailed');\n\t\t\t\t\tcase UPLOAD_ERR_NO_FILE:\n\t\t\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.noUpload');\n\t\t\t\t\tcase UPLOAD_ERR_NO_TMP_DIR:\n\t\t\t\t\tcase UPLOAD_ERR_CANT_WRITE:\n\t\t\t\t\tcase UPLOAD_ERR_EXTENSION:\n\t\t\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.config');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $response->withStatus(400)->withJsonError('api.files.400.uploadFailed');\n\t\t}\n\n\t\treturn $this->getResponse($response->withJson([\n\t\t\t'url' => $request->getBaseUrl() . '/' .\n\t\t\t\t\tConfig::getVar('files', 'public_files_dir') . '/site/images/' .\n\t\t\t\t\t$request->getUser()->getUsername() . '/' .\n\t\t\t\t\tpathinfo($destinationPath, PATHINFO_BASENAME),\n\t\t]));\n\t}\n\n\t/**\n\t * Respond affirmatively to a HTTP OPTIONS request with headers which allow\n\t * file uploads\n\t *\n\t * @param $slimRequest Request Slim request object\n\t * @param $response Response object\n\t * @param $args array arguments\n\t * @return Response\n\t */\n\tpublic function getOptions($slimRequest, $response, $args) {\n\t\treturn $this->getResponse($response);\n\t}\n\n\t/**\n\t * A recursive function to get a filename that will not overwrite an\n\t * existing file\n\t *\n\t * @param string $path Preferred filename\n\t * @param FileManager $fileManager\n\t * @return string\n\t */\n\tprivate function _getFilename($path, $fileManager) {\n\t\tif ($fileManager->fileExists($path)) {\n\t\t\t$pathParts = pathinfo($path);\n\t\t\t$filename = $pathParts['filename'] . '-' . md5(microtime()) . '.' . $pathParts['extension'];\n\t\t\tif (strlen($filename > 255)) {\n\t\t\t\t$filename = substr($filename, -255, 255);\n\t\t\t}\n\t\t\treturn $this->_getFilename($pathParts['dirname'] . '/' . $filename, $fileManager);\n\t\t}\n\t\treturn $path;\n\t}\n}\n", "<?php\n\n/**\n * @defgroup file File\n * Implements file management tools, including a database-backed list of files\n * associated with submissions.\n */\n\n/**\n * @file classes/file/FileManager.inc.php\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n * ePUB mime type added  Leah M Root (rootl) SUNY Geneseo\n * @class FileManager\n * @ingroup file\n *\n * @brief Class defining basic operations for file management.\n */\n\n\ndefine('FILE_MODE_MASK', 0666);\ndefine('DIRECTORY_MODE_MASK', 0777);\n\ndefine('DOCUMENT_TYPE_DEFAULT', 'default');\ndefine('DOCUMENT_TYPE_AUDIO', 'audio');\ndefine('DOCUMENT_TYPE_EXCEL', 'excel');\ndefine('DOCUMENT_TYPE_HTML', 'html');\ndefine('DOCUMENT_TYPE_IMAGE', 'image');\ndefine('DOCUMENT_TYPE_PDF', 'pdf');\ndefine('DOCUMENT_TYPE_WORD', 'word');\ndefine('DOCUMENT_TYPE_EPUB', 'epub');\ndefine('DOCUMENT_TYPE_VIDEO', 'video');\ndefine('DOCUMENT_TYPE_ZIP', 'zip');\n\nclass FileManager {\n\t/**\n\t * Constructor\n\t */\n\tfunction __construct() {\n\t}\n\n\t/**\n\t * Return true if an uploaded file exists.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return boolean\n\t */\n\tfunction uploadedFileExists($fileName) {\n\t\tif (isset($_FILES[$fileName]) && isset($_FILES[$fileName]['tmp_name'])\n\t\t\t\t&& is_uploaded_file($_FILES[$fileName]['tmp_name'])) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return true iff an error occurred when trying to upload a file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return boolean\n\t */\n\tfunction uploadError($fileName) {\n\t\treturn (isset($_FILES[$fileName]) && $_FILES[$fileName]['error'] != UPLOAD_ERR_OK);\n\t}\n\n\t/**\n\t * Get the error code of a file upload\n\t * @see http://php.net/manual/en/features.file-upload.errors.php\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return integer\n\t */\n\tfunction getUploadErrorCode($fileName) {\n\t\treturn $_FILES[$fileName]['error'];\n\t}\n\n\t/**\n\t * Get the filename of the first uploaded file in the $_FILES array. The\n\t * returned filename is the value used in the form that submitted the request.\n\t * @return string\n\t */\n\tfunction getFirstUploadedPostName() {\n\t\treturn key($_FILES);\n\t}\n\n\t/**\n\t * Return the (temporary) path to an uploaded file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return string (boolean false if no such file)\n\t */\n\tfunction getUploadedFilePath($fileName) {\n\t\tif (isset($_FILES[$fileName]['tmp_name']) && is_uploaded_file($_FILES[$fileName]['tmp_name'])) {\n\t\t\treturn $_FILES[$fileName]['tmp_name'];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return the user-specific (not temporary) filename of an uploaded file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return string (boolean false if no such file)\n\t */\n\tfunction getUploadedFileName($fileName) {\n\t\tif (isset($_FILES[$fileName]['name'])) {\n\t\t\treturn $_FILES[$fileName]['name'];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return the type of an uploaded file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @return string\n\t */\n\tfunction getUploadedFileType($fileName) {\n\t\tif (isset($_FILES[$fileName])) {\n\t\t\t// The result of \"explode\" can't be passed directly to \"array_pop\" in PHP 7.\n\t\t\t$exploded = explode('.',$_FILES[$fileName]['name']);\n\n\t\t\t$type = PKPString::mime_content_type(\n\t\t\t\t$_FILES[$fileName]['tmp_name'], // Location on server\n\t\t\t\tarray_pop($exploded) // Extension on client machine\n\t\t\t);\n\n\t\t\tif (!empty($type)) return $type;\n\t\t\treturn $_FILES[$fileName]['type'];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Upload a file.\n\t * @param $fileName string the name of the file used in the POST form\n\t * @param $dest string the path where the file is to be saved\n\t * @return boolean returns true if successful\n\t */\n\tfunction uploadFile($fileName, $destFileName) {\n\t\t$destDir = dirname($destFileName);\n\t\tif (!$this->fileExists($destDir, 'dir')) {\n\t\t\t// Try to create the destination directory\n\t\t\t$this->mkdirtree($destDir);\n\t\t}\n\t\tif (!isset($_FILES[$fileName])) return false;\n\t\tif (move_uploaded_file($_FILES[$fileName]['tmp_name'], $destFileName))\n\t\t\treturn $this->setMode($destFileName, FILE_MODE_MASK);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Write a file.\n\t * @param $dest string the path where the file is to be saved\n\t * @param $contents string the contents to write to the file\n\t * @return boolean returns true if successful\n\t */\n\tfunction writeFile($dest, &$contents) {\n\t\t$success = true;\n\t\t$destDir = dirname($dest);\n\t\tif (!$this->fileExists($destDir, 'dir')) {\n\t\t\t// Try to create the destination directory\n\t\t\t$this->mkdirtree($destDir);\n\t\t}\n\t\tif (($f = fopen($dest, 'wb'))===false) $success = false;\n\t\tif ($success && fwrite($f, $contents)===false) $success = false;\n\t\t@fclose($f);\n\n\t\tif ($success)\n\t\t\treturn $this->setMode($dest, FILE_MODE_MASK);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Copy a file.\n\t * @param $source string the source URL for the file\n\t * @param $dest string the path where the file is to be saved\n\t * @return boolean returns true if successful\n\t */\n\tfunction copyFile($source, $dest) {\n\t\t$destDir = dirname($dest);\n\t\tif (!$this->fileExists($destDir, 'dir')) {\n\t\t\t// Try to create the destination directory\n\t\t\t$this->mkdirtree($destDir);\n\t\t}\n\t\tif (copy($source, $dest))\n\t\t\treturn $this->setMode($dest, FILE_MODE_MASK);\n\t\treturn false;\n\t}\n\n\t/**\n\t * Copy a directory.\n\t * Adapted from code by gimmicklessgpt at gmail dot com, at http://php.net/manual/en/function.copy.php\n\t * @param $source string the path to the source directory\n\t * @param $dest string the path where the directory is to be saved\n\t * @return boolean returns true if successful\n\t */\n\tfunction copyDir($source, $dest) {\n\t\tif (is_dir($source)) {\n\t\t\t$this->mkdir($dest);\n\t\t\t$destDir = dir($source);\n\n\t\t\twhile (($entry = $destDir->read()) !== false) {\n\t\t\t\tif ($entry == '.' || $entry == '..') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$Entry = $source . DIRECTORY_SEPARATOR . $entry;\n\t\t\t\tif (is_dir($Entry) ) {\n\t\t\t\t\t$this->copyDir($Entry, $dest . DIRECTORY_SEPARATOR . $entry );\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$this->copyFile($Entry, $dest . DIRECTORY_SEPARATOR . $entry );\n\t\t\t}\n\n\t\t\t$destDir->close();\n\t\t} else {\n\t\t\t$this->copyFile($source, $dest);\n\t\t}\n\n\t\tif ($this->fileExists($dest, 'dir')) {\n\t\t\treturn true;\n\t\t} else return false;\n\t}\n\n\n\t/**\n\t * Read a file's contents.\n\t * @param $filePath string the location of the file to be read\n\t * @param $output boolean output the file's contents instead of returning a string\n\t * @return string|boolean\n\t */\n\tfunction readFileFromPath($filePath, $output = false) {\n\t\tif (is_readable($filePath)) {\n\t\t\t$f = fopen($filePath, 'rb');\n\t\t\tif (!$f) return false;\n\t\t\t$data = '';\n\t\t\twhile (!feof($f)) {\n\t\t\t\t$data .= fread($f, 4096);\n\t\t\t\tif ($output) {\n\t\t\t\t\techo $data;\n\t\t\t\t\t$data = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose($f);\n\n\t\t\tif ($output) return true;\n\t\t\treturn $data;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Download a file.\n\t * Outputs HTTP headers and file content for download\n\t * @param $filePath string the location of the file to be sent\n\t * @param $mediaType string the MIME type of the file, optional\n\t * @param $inline boolean print file as inline instead of attachment, optional\n\t * @param $fileName string Optional filename to use on the client side\n\t * @return boolean\n\t */\n\tfunction downloadByPath($filePath, $mediaType = null, $inline = false, $fileName = null) {\n\t\t$result = null;\n\t\tif (HookRegistry::call('FileManager::downloadFile', array(&$filePath, &$mediaType, &$inline, &$result, &$fileName))) return $result;\n\t\tif (is_readable($filePath)) {\n\t\t\tif ($mediaType === null) {\n\t\t\t\t// If the media type wasn't specified, try to detect.\n\t\t\t\t$mediaType = PKPString::mime_content_type($filePath);\n\t\t\t\tif (empty($mediaType)) $mediaType = 'application/octet-stream';\n\t\t\t}\n\t\t\tif ($fileName === null) {\n\t\t\t\t// If the filename wasn't specified, use the server-side.\n\t\t\t\t$fileName = basename($filePath);\n\t\t\t}\n\n\t\t\t// Stream the file to the end user.\n\t\t\theader(\"Content-Type: $mediaType\");\n\t\t\theader('Content-Length: ' . filesize($filePath));\n\t\t\theader('Accept-Ranges: none');\n\t\t\theader('Content-Disposition: ' . ($inline ? 'inline' : 'attachment') . \"; filename=\\\"$fileName\\\"\");\n\t\t\theader('Cache-Control: private'); // Workarounds for IE weirdness\n\t\t\theader('Pragma: public');\n\t\t\t$this->readFileFromPath($filePath, true);\n\t\t\t$returner = true;\n\t\t} else {\n\t\t\t$returner = false;\n\t\t}\n\t\tHookRegistry::call('FileManager::downloadFileFinished', array(&$returner));\n\t\treturn $returner;\n\t}\n\n\t/**\n\t * Delete a file.\n\t * @param $filePath string the location of the file to be deleted\n\t * @return boolean returns true if successful\n\t */\n\tfunction deleteByPath($filePath) {\n\t\tif ($this->fileExists($filePath)) {\n\t\t\t$result = null;\n\t\t\tif (HookRegistry::call('FileManager::deleteFile', array($filePath, &$result))) return $result;\n\t\t\treturn unlink($filePath);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create a new directory.\n\t * @param $dirPath string the full path of the directory to be created\n\t * @param $perms string the permissions level of the directory (optional)\n\t * @return boolean returns true if successful\n\t */\n\tfunction mkdir($dirPath, $perms = null) {\n\t\tif ($perms !== null) {\n\t\t\treturn mkdir($dirPath, $perms);\n\t\t} else {\n\t\t\tif (mkdir($dirPath))\n\t\t\t\treturn $this->setMode($dirPath, DIRECTORY_MODE_MASK);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Remove a directory.\n\t * @param $dirPath string the full path of the directory to be delete\n\t * @return boolean returns true if successful\n\t */\n\tfunction rmdir($dirPath) {\n\t\treturn rmdir($dirPath);\n\t}\n\n\t/**\n\t * Delete all contents including directory (equivalent to \"rm -r\")\n\t * @param $file string the full path of the directory to be removed\n\t * @return boolean true iff success, otherwise false\n\t */\n\tfunction rmtree($file) {\n\t\tif (file_exists($file)) {\n\t\t\tif (is_dir($file)) {\n\t\t\t\t$handle = opendir($file);\n\t\t\t\twhile (($filename = readdir($handle)) !== false) {\n\t\t\t\t\tif ($filename != '.' && $filename != '..') {\n\t\t\t\t\t\tif (!$this->rmtree($file . '/' . $filename)) return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclosedir($handle);\n\t\t\t\tif (!rmdir($file)) return false;\n\n\t\t\t} else {\n\t\t\t\tif (!unlink($file)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Create a new directory, including all intermediate directories if required (equivalent to \"mkdir -p\")\n\t * @param $dirPath string the full path of the directory to be created\n\t * @param $perms string the permissions level of the directory (optional)\n\t * @return boolean returns true if successful\n\t */\n\tfunction mkdirtree($dirPath, $perms = null) {\n\t\tif (!file_exists($dirPath)) {\n\t\t\t//Avoid infinite recursion when file_exists reports false for root directory\n\t\t\tif ($dirPath == dirname($dirPath)) {\n\t\t\t\tfatalError('There are no readable files in this directory tree. Are safe mode or open_basedir active?');\n\t\t\t\treturn false;\n\t\t\t} else if ($this->mkdirtree(dirname($dirPath), $perms)) {\n\t\t\t\treturn $this->mkdir($dirPath, $perms);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check if a file path is valid;\n\t * @param $filePath string the file/directory to check\n\t * @param $type string (file|dir) the type of path\n\t */\n\tfunction fileExists($filePath, $type = 'file') {\n\t\tswitch ($type) {\n\t\t\tcase 'file':\n\t\t\t\treturn file_exists($filePath);\n\t\t\tcase 'dir':\n\t\t\t\treturn file_exists($filePath) && is_dir($filePath);\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a file type, based on generic categories defined above\n\t * @param $type String\n\t * @return string (Enuemrated DOCUMENT_TYPEs)\n\t */\n\tfunction getDocumentType($type) {\n\t\tif ($this->getImageExtension($type))\n\t\t\treturn DOCUMENT_TYPE_IMAGE;\n\n\t\tswitch ($type) {\n\t\t\tcase 'application/pdf':\n\t\t\tcase 'application/x-pdf':\n\t\t\tcase 'text/pdf':\n\t\t\tcase 'text/x-pdf':\n\t\t\t\treturn DOCUMENT_TYPE_PDF;\n\t\t\tcase 'application/msword':\n\t\t\tcase 'application/word':\n\t\t\t\treturn DOCUMENT_TYPE_WORD;\n\t\t\tcase 'application/excel':\n\t\t\t\treturn DOCUMENT_TYPE_EXCEL;\n\t\t\tcase 'text/html':\n\t\t\t\treturn DOCUMENT_TYPE_HTML;\n\t\t\tcase 'application/zip':\n\t\t\tcase 'application/x-zip':\n\t\t\tcase 'application/x-zip-compressed':\n\t\t\tcase 'application/x-compress':\n\t\t\tcase 'application/x-compressed':\n\t\t\tcase 'multipart/x-zip':\n\t\t\t\treturn DOCUMENT_TYPE_ZIP;\n\t\t\tcase 'application/epub':\n\t\t\tcase 'application/epub+zip':\n\t\t\t\treturn DOCUMENT_TYPE_EPUB;\n\t\t\tdefault:\n\t\t\t\treturn DOCUMENT_TYPE_DEFAULT;\n\t\t}\n\t}\n\n\t/**\n\t * Returns file extension associated with the given document type,\n\t * or false if the type does not belong to a recognized document type.\n\t * @param $type string\n\t */\n\tfunction getDocumentExtension($type) {\n\t\tswitch ($type) {\n\t\t\tcase 'application/pdf':\n\t\t\t\treturn '.pdf';\n\t\t\tcase 'application/word':\n\t\t\t\treturn '.doc';\n\t\t\tcase 'text/css':\n\t\t\t\treturn '.css';\n\t\t\tcase 'text/html':\n\t\t\t\treturn '.html';\n\t\t\tcase 'application/epub+zip':\n\t\t\t\treturn '.epub';\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns file extension associated with the given image type,\n\t * or false if the type does not belong to a recognized image type.\n\t * @param $type string\n\t */\n\tfunction getImageExtension($type) {\n\t\tswitch ($type) {\n\t\t\tcase 'image/gif':\n\t\t\t\treturn '.gif';\n\t\t\tcase 'image/jpeg':\n\t\t\tcase 'image/pjpeg':\n\t\t\t\treturn '.jpg';\n\t\t\tcase 'image/png':\n\t\t\tcase 'image/x-png':\n\t\t\t\treturn '.png';\n\t\t\tcase 'image/vnd.microsoft.icon':\n\t\t\tcase 'image/x-icon':\n\t\t\tcase 'image/x-ico':\n\t\t\tcase 'image/ico':\n\t\t\t\treturn '.ico';\n\t\t\tcase 'application/x-shockwave-flash':\n\t\t\t\treturn '.swf';\n\t\t\tcase 'video/x-flv':\n\t\t\tcase 'application/x-flash-video':\n\t\t\tcase 'flv-application/octet-stream':\n\t\t\t\treturn '.flv';\n\t\t\tcase 'audio/mpeg':\n\t\t\t\treturn '.mp3';\n\t\t\tcase 'audio/x-aiff':\n\t\t\t\treturn '.aiff';\n\t\t\tcase 'audio/x-wav':\n\t\t\t\treturn '.wav';\n\t\t\tcase 'video/mpeg':\n\t\t\t\treturn '.mpg';\n\t\t\tcase 'video/quicktime':\n\t\t\t\treturn '.mov';\n\t\t\tcase 'video/mp4':\n\t\t\t\treturn '.mp4';\n\t\t\tcase 'text/javascript':\n\t\t\t\treturn '.js';\n\t\t\tcase 'image/webp':\n\t\t\t\treturn '.webp';\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse file extension from file name.\n\t * @param string a valid file name\n\t * @return string extension\n\t */\n\tfunction getExtension($fileName) {\n\t\t$extension = '';\n\t\t$fileParts = explode('.', $fileName);\n\t\tif (is_array($fileParts)) {\n\t\t\t$extension = $fileParts[count($fileParts) - 1];\n\t\t}\n\t\treturn $extension;\n\t}\n\n\t/**\n\t * Truncate a filename to fit in the specified length.\n\t */\n\tfunction truncateFileName($fileName, $length = 127) {\n\t\tif (PKPString::strlen($fileName) <= $length) return $fileName;\n\t\t$ext = $this->getExtension($fileName);\n\t\t$truncated = PKPString::substr($fileName, 0, $length - 1 - PKPString::strlen($ext)) . '.' . $ext;\n\t\treturn PKPString::substr($truncated, 0, $length);\n\t}\n\n\t/**\n\t * Return pretty file size string (in B, KB, MB, or GB units).\n\t * @param $size int file size in bytes\n\t * @return string\n\t */\n\tfunction getNiceFileSize($size) {\n\t\t$niceFileSizeUnits = array('B', 'KB', 'MB', 'GB');\n\t\tfor($i = 0; $i < 4 && $size > 1024; $i++) {\n\t\t\t$size >>= 10;\n\t\t}\n\t\treturn $size . $niceFileSizeUnits[$i];\n\t}\n\n\t/**\n\t * Set file/directory mode based on the 'umask' config setting.\n\t * @param $path string\n\t * @param $mask int\n\t * @return boolean\n\t */\n\tfunction setMode($path, $mask) {\n\t\t$umask = Config::getVar('files', 'umask');\n\t\tif (!$umask)\n\t\t\treturn true;\n\t\treturn chmod($path, $mask & ~$umask);\n\t}\n\n\t/**\n\t * Parse the file extension from a filename/path.\n\t * @param $fileName string\n\t * @return string\n\t */\n\tfunction parseFileExtension($fileName) {\n\t\t$fileParts = explode('.', $fileName);\n\t\tif (is_array($fileParts) && count($fileParts) > 1) {\n\t\t\t$fileExtension = $fileParts[count($fileParts) - 1];\n\t\t}\n\n\t\t// FIXME Check for evil\n\t\tif (!isset($fileExtension) || stristr($fileExtension, 'php') || strlen($fileExtension) > 6 || !preg_match('/^\\w+$/', $fileExtension)) {\n\t\t\t$fileExtension = 'txt';\n\t\t}\n\n\t\t// consider .tar.gz extension\n\t\tif (strtolower(substr($fileName, -7)) == '.tar.gz') {\n\t\t\t$fileExtension = substr($fileName, -6);\n\t\t}\n\n\t\treturn $fileExtension;\n\t}\n\n\t/**\n\t * Decompress passed gziped file.\n\t * @param $filePath string\n\t * @return string The file path that was created.\n\t */\n\tfunction decompressFile($filePath) {\n\t\treturn $this->_executeGzip($filePath, true);\n\t}\n\n\t/**\n\t * Compress passed file.\n\t * @param $filePath string The file to be compressed.\n\t * @return string The file path that was created.\n\t */\n\tfunction compressFile($filePath) {\n\t\treturn $this->_executeGzip($filePath, false);\n\t}\n\n\n\t//\n\t// Private helper methods.\n\t//\n\t/**\n\t * Execute gzip to compress or extract files.\n\t * @param $filePath string file to be compressed or uncompressed.\n\t * @param $decompress boolean optional Set true if the passed file\n\t * needs to be decompressed.\n\t * @return string The file path that was created with the operation\n\t */\n\tprivate function _executeGzip($filePath, $decompress = false) {\n\t\tPKPLocale::requireComponents(LOCALE_COMPONENT_PKP_ADMIN);\n\t\t$gzipPath = Config::getVar('cli', 'gzip');\n\t\tif (!is_executable($gzipPath)) {\n\t\t\tthrow new Exception(__('admin.error.executingUtil', array('utilPath' => $gzipPath, 'utilVar' => 'gzip')));\n\t\t}\n\t\t$gzipCmd = escapeshellarg($gzipPath);\n\t\tif ($decompress) $gzipCmd .= ' -d';\n\t\t// Make sure any output message will mention the file path.\n\t\t$output = array($filePath);\n\t\t$returnValue = 0;\n\t\t$gzipCmd .= ' ' . escapeshellarg($filePath);\n\t\tif (!Core::isWindows()) {\n\t\t\t// Get the output, redirecting stderr to stdout.\n\t\t\t$gzipCmd .= ' 2>&1';\n\t\t}\n\t\texec($gzipCmd, $output, $returnValue);\n\t\tif ($returnValue > 0) {\n\t\t\tthrow new Exception(__('admin.error.utilExecutionProblem', array('utilPath' => $gzipPath, 'output' => implode(PHP_EOL, $output))));\n\t\t}\n\t\tif ($decompress) {\n\t\t\treturn substr($filePath, 0, -3);\n\t\t} else {\n\t\t\treturn $filePath . '.gz';\n\t\t}\n\t}\n}\n", "<?php\n/**\n * @file classes/services/PKPFileService.php\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * @class PKPFileService\n * @ingroup services\n *\n * @brief Helper class that encapsulates business logic for publications\n */\n\nnamespace PKP\\Services;\n\nuse \\Application;\nuse \\Config;\nuse \\Exception;\nuse \\HookRegistry;\nuse League\\Flysystem\\Adapter\\Local;\nuse League\\Flysystem\\Filesystem;\nuse Illuminate\\Database\\Capsule\\Manager as Capsule;\n\nclass PKPFileService {\n\n\t/** @var Filesystem */\n\tpublic $fs;\n\n\t/**\n\t * Initialize and configure flysystem\n\t */\n\tpublic function __construct() {\n\t\t$umask = Config::getVar('files', 'umask', 0022);\n\t\t$adapter = new Local(\n\t\t\tConfig::getVar('files', 'files_dir'),\n\t\t\tLOCK_EX,\n\t\t\tLocal::DISALLOW_LINKS,\n\t\t\t[\n\t\t\t\t'file' => [\n\t\t\t\t\t'public' => FILE_MODE_MASK & ~$umask,\n\t\t\t\t\t'private' => FILE_MODE_MASK  & ~$umask,\n\t\t\t\t],\n\t\t\t\t'dir' => [\n\t\t\t\t\t'public' => DIRECTORY_MODE_MASK & ~$umask,\n\t\t\t\t\t'private' => DIRECTORY_MODE_MASK & ~$umask,\n\t\t\t\t]\n\t\t\t]\n\t\t);\n\n\t\tHookRegistry::call('File::adapter', [&$adapter, $this]);\n\n\t\t$this->fs = new Filesystem($adapter);\n\t}\n\n\t/**\n\t * Get a file by its id\n\t *\n\t * @param int $id\n\t * @return stdObject\n\t */\n\tpublic function get($id) {\n\t\t$file = Capsule::table('files')\n\t\t\t->where('file_id', '=', $id)\n\t\t\t->select(['file_id as id', 'path', 'mimetype'])\n\t\t\t->first();\n\t\treturn $file;\n\t}\n\n\t/**\n\t * Add a file\n\t *\n\t * @param string $from absolute path to file\n\t * @param string $to relative path in file dir\n\t * @return int file id\n\t */\n\tpublic function add($from, $to) {\n\t\t$stream = fopen($from, 'r+');\n\t\tif (!$stream) {\n\t\t\tthrow new Exception(\"Unable to copy $from to $to.\");\n\t\t}\n\t\tif (!$this->fs->writeStream($to, $stream)) {\n\t\t\tthrow new Exception(\"Unable to write file at $to.\");\n\t\t}\n\t\tif (is_resource($stream)) {\n\t\t\tfclose($stream);\n\t\t}\n\t\t$mimetype = $this->fs->getMimetype($to);\n\n\t\t// Check and override ambiguous mime types based on file extension\n\t\tif ($extension = pathinfo($to, PATHINFO_EXTENSION)) {\n\t\t\t$checkAmbiguous = strtolower($extension . ':' . $mimetype);\n\t\t\tif (array_key_exists($checkAmbiguous, $extensionsMap = \\PKPString::getAmbiguousExtensionsMap())) {\n\t\t\t\t$mimetype = $extensionsMap[$checkAmbiguous];\n\t\t\t}\n\t\t}\n\n\t\treturn Capsule::table('files')->insertGetId([\n\t\t\t'path' => $to,\n\t\t\t'mimetype' => $mimetype,\n\t\t], 'file_id');\n\t}\n\n\t/**\n\t * Delete an uploaded file\n\t *\n\t * @param int $id\n\t * @return File\n\t */\n\tpublic function delete($id) {\n\t\t$file = $this->get($id);\n\t\tif (!$file) {\n\t\t\tthrow new Exception(\"Unable to locate file $id.\");\n\t\t}\n\t\t$path = $file->path;\n\t\tif ($this->fs->has($path) && !$this->fs->delete($path)) {\n\t\t\tthrow new Exception(\"Unable to delete file $id at $path.\");\n\t\t}\n\t\tCapsule::table('files')\n\t\t\t->where('file_id', '=', $file->id)\n\t\t\t->delete();\n\t}\n\n\t/**\n\t * Download a file\n\t *\n\t * This method sends a HTTP response and ends the request handling.\n\t * No code will run after this method is called.\n\t *\n\t * @param string|int $pathOrFileId The path to the file or file ID\n\t * @param string $filename Filename to give to the downloaded file\n\t * @param boolean $inline Whether to stream the file to the browser\n\t */\n\tpublic function download($pathOrFileId, $filename, $inline = false) {\n\n\t\t$dispatcher = Application::get()->getRequest()->getDispatcher();\n\n\t\tif (is_int($pathOrFileId)) {\n\t\t\t// Is the file ID\n\t\t\t$fileId = $pathOrFileId;\n\t\t\t$file = $this->get($fileId);\n\t\t\tif (!$file) $dispatcher->handle404();\n\t\t\t$path = $file->path;\n\t\t} else {\n\t\t\t// Is the path to the file; compatibility fix, see pkp/pkp-lib#6663\n\t\t\t$path = $pathOrFileId;\n\t\t}\n\n\t\tif (!$this->fs->has($path)) {\n\t\t\t$dispatcher->handle404();\n\t\t}\n\n\t\tif (HookRegistry::call('File::download', [$path, &$filename, $inline])) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stream the file to the end user.\n\t\t$mimetype = $file->mimetype ?? $this->fs->getMimetype($path) ?? 'application/octet-stream';\n\t\t$filesize = $this->fs->getSize($path);\n\t\t$encodedFilename = urlencode($filename);\n\t\theader(\"Content-Type: $mimetype\");\n\t\theader(\"Content-Length: $filesize\");\n\t\theader('Accept-Ranges: none');\n\t\theader('Content-Disposition: ' . ($inline ? 'inline' : 'attachment') . \";filename=\\\"$encodedFilename\\\";filename*=UTF-8''$encodedFilename\");\n\t\theader('Cache-Control: private'); // Workarounds for IE weirdness\n\t\theader('Pragma: public');\n\n\t\tfpassthru($this->fs->readStream($path));\n\t\texit();\n\t}\n\n\t/**\n\t * Convert a filename into a consistent format with the correct extension\n\t *\n\t * @param string $path Path to the file\n\t * @param string $filename Source filename to sanitize\n\t * @return string\n\t */\n\tpublic function formatFilename($path, $filename) {\n\t\t$extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));\n\t\t$newFilename = $filename;\n\t\tif (!empty($extension) && substr($newFilename, (strlen($extension) * -1)) != $extension) {\n\t\t\t$newFilename .= '.' . $extension;\n\t\t}\n\n\t\tHookRegistry::call('File::formatFilename', [&$newFilename, $path, $filename]);\n\n\t\treturn $newFilename;\n\t}\n\n\t/**\n\t * Get document type based on the mimetype\n\t *\n\t * @param string $mimetype\n\t * @return string One of the DOCUMENT_TYPE_ constants\n\t */\n\tpublic function getDocumentType($mimetype) {\n\t\tswitch ($mimetype) {\n\t\t\tcase 'application/pdf':\n\t\t\tcase 'application/x-pdf':\n\t\t\tcase 'text/pdf':\n\t\t\tcase 'text/x-pdf':\n\t\t\t\treturn DOCUMENT_TYPE_PDF;\n\t\t\tcase 'application/msword':\n\t\t\tcase 'application/word':\n\t\t\tcase 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':\n\t\t\t\treturn DOCUMENT_TYPE_WORD;\n\t\t\tcase 'application/excel':\n\t\t\tcase 'application/vnd.ms-excel':\n\t\t\tcase 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':\n\t\t\t\treturn DOCUMENT_TYPE_EXCEL;\n\t\t\tcase 'text/html':\n\t\t\t\treturn DOCUMENT_TYPE_HTML;\n\t\t\tcase 'application/zip':\n\t\t\tcase 'application/x-zip':\n\t\t\tcase 'application/x-zip-compressed':\n\t\t\tcase 'application/x-compress':\n\t\t\tcase 'application/x-compressed':\n\t\t\tcase 'multipart/x-zip':\n\t\t\t\treturn DOCUMENT_TYPE_ZIP;\n\t\t\tcase 'application/epub':\n\t\t\tcase 'application/epub+zip':\n\t\t\t\treturn DOCUMENT_TYPE_EPUB;\n\t\t\tcase 'image/gif':\n\t\t\tcase 'image/jpeg':\n\t\t\tcase 'image/pjpeg':\n\t\t\tcase 'image/png':\n\t\t\tcase 'image/x-png':\n\t\t\tcase 'image/vnd.microsoft.icon':\n\t\t\tcase 'image/x-icon':\n\t\t\tcase 'image/x-ico':\n\t\t\tcase 'image/ico':\n\t\t\t\treturn DOCUMENT_TYPE_IMAGE;\n\t\t\tcase 'application/x-shockwave-flash':\n\t\t\tcase 'video/x-flv':\n\t\t\tcase 'application/x-flash-video':\n\t\t\tcase 'flv-application/octet-stream':\n\t\t\tcase 'video/mpeg':\n\t\t\tcase 'video/quicktime':\n\t\t\tcase 'video/mp4':\n\t\t\t\treturn DOCUMENT_TYPE_VIDEO;\n\t\t\tcase 'audio/mpeg':\n\t\t\tcase 'audio/x-aiff':\n\t\t\tcase 'audio/x-wav':\n\t\t\t\treturn DOCUMENT_TYPE_AUDIO;\n\t\t\tdefault:\n\t\t\t\treturn DOCUMENT_TYPE_DEFAULT;\n\t\t}\n\t}\n\n\t/**\n\t * Get a pretty file size string\n\t *\n\t * Examples: 82B, 12KB, 2MB, 2GB\n\t *\n\t * @param integer $size File size in bytes\n\t * @return string\n\t */\n\tfunction getNiceFileSize($size) {\n\t\t$niceFileSizeUnits = array('B', 'KB', 'MB', 'GB');\n\t\tfor($i = 0; $i < 4 && $size > 1024; $i++) {\n\t\t\t$size >>= 10;\n\t\t}\n\t\treturn $size . $niceFileSizeUnits[$i];\n\t}\n}\n", "{**\n * lib/pkp/templates/controllers/grid/settings/category/form/categoryForm.tpl\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2003-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * Form to edit or create a category\n *}\n\n<script type=\"text/javascript\">\n\t$(function() {ldelim}\n\t\t// Attach the form handler.\n\t\t$('#categoryForm').pkpHandler(\n\t\t\t'$.pkp.controllers.form.FileUploadFormHandler',\n\t\t\t{ldelim}\n\t\t\t\tpublishChangeEvents: ['updateSidebar'],\n\t\t\t\t$uploader: $('#plupload'),\n\t\t\t\tuploaderOptions: {ldelim}\n\t\t\t\t\tuploadUrl: {url|json_encode op=\"uploadImage\" escape=false},\n\t\t\t\t\tbaseUrl: {$baseUrl|json_encode},\n\t\t\t\t\tfilters: {ldelim}\n\t\t\t\t\t\tmime_types : [\n\t\t\t\t\t\t\t{ldelim} title : \"Image files\", extensions : \"jpg,jpeg,png\" {rdelim}\n\t\t\t\t\t\t]\n\t\t\t\t\t{rdelim}\n\t\t\t\t{rdelim}\n\t\t\t{rdelim}\n\t\t);\n\t{rdelim});\n</script>\n\n<form class=\"pkp_form\" id=\"categoryForm\" method=\"post\" action=\"{url router=$smarty.const.ROUTE_COMPONENT component=\"grid.settings.category.CategoryCategoryGridHandler\" op=\"updateCategory\" categoryId=$categoryId}\">\n\t{csrf}\n\t{include file=\"controllers/notification/inPlaceNotification.tpl\" notificationId=\"categoryFormNotification\"}\n\n\t{fbvFormArea id=\"categoryDetails\"}\n\n\t\t<h3>{translate key=\"grid.category.categoryDetails\"}</h3>\n\n\t\t{fbvFormSection title=\"grid.category.name\" for=\"name\" required=\"true\"}\n\t\t\t{fbvElement type=\"text\" multilingual=\"true\" name=\"name\" value=$name id=\"name\" required=\"true\"}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection title=\"grid.category.parentCategory\" for=\"context\"}\n\t\t\t{fbvElement type=\"select\" id=\"parentId\" from=$rootCategories selected=$parentId translate=false disabled=$cannotSelectChild}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection title=\"grid.category.path\" required=true for=\"path\"}\n\t\t\t{capture assign=\"instruct\"}\n\t\t\t\t{url router=$smarty.const.ROUTE_PAGE page=\"catalog\" op=\"category\" path=\"path\"}\n\t\t\t\t{translate key=\"grid.category.urlWillBe\" sampleUrl=$sampleUrl}\n\t\t\t{/capture}\n\t\t\t{fbvElement type=\"text\" id=\"path\" value=$path maxlength=\"32\" label=$instruct subLabelTranslate=false}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection title=\"grid.category.description\" for=\"context\"}\n\t\t\t{fbvElement type=\"textarea\" multilingual=\"true\" id=\"description\" value=$description rich=true}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection label=\"catalog.sortBy\" description=\"catalog.sortBy.categoryDescription\" for=\"sortOption\"}\n\t\t\t{fbvElement type=\"select\" id=\"sortOption\" from=$sortOptions selected=$sortOption translate=false}\n\t\t{/fbvFormSection}\n\n\t\t{fbvFormSection title=\"category.coverImage\"}\n\t\t\t{include file=\"controllers/fileUploadContainer.tpl\" id=\"plupload\"}\n\t\t\t<input type=\"hidden\" name=\"temporaryFileId\" id=\"temporaryFileId\" value=\"\" />\n\t\t{/fbvFormSection}\n\n\t\t{if $image}\n\t\t\t{fbvFormSection}\n\t\t\t\t{capture assign=\"altTitle\"}{translate key=\"submission.currentCoverImage\"}{/capture}\n\t\t\t\t<img class=\"pkp_helpers_container_center\" height=\"{$image.thumbnailHeight}\" width=\"{$image.thumbnailWidth}\" src=\"{url router=$smarty.const.ROUTE_PAGE page=\"catalog\" op=\"thumbnail\" type=\"category\" id=$categoryId}\" alt=\"{$altTitle|escape}\" />\n\t\t\t{/fbvFormSection}\n\t\t{/if}\n\n\t\t{if count($availableSubeditors)}\n\t\t\t{fbvFormSection list=true title=\"submissionGroup.assignedSubEditors\"}\n\t\t\t\t{foreach from=$availableSubeditors item=\"subEditor\" key=\"id\"}\n\t\t\t\t\t{fbvElement type=\"checkbox\" id=\"subEditors[]\" value=$id checked=in_array($id, $assignedToCategory) label=$subEditor|escape translate=false}\n\t\t\t\t{/foreach}\n\t\t\t{/fbvFormSection}\n\t\t{/if}\n\n\t\t<p><span class=\"formRequired\">{translate key=\"common.requiredField\"}</span></p>\n\t\t{fbvFormButtons}\n\n\t{/fbvFormArea}\n</form>\n", "{**\n * templates/user/publicProfileForm.tpl\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2003-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * Public user profile form.\n *}\n\n{* Help Link *}\n{help file=\"user-profile\" class=\"pkp_help_tab\"}\n\n<script type=\"text/javascript\">\n\t$(function() {ldelim}\n\t\t// Attach the form handler.\n\t\t$('#publicProfileForm').pkpHandler(\n\t\t\t'$.pkp.controllers.form.FileUploadFormHandler',\n\t\t\t{ldelim}\n\t\t\t\t$uploader: $('#plupload'),\n\t\t\t\tuploaderOptions: {ldelim}\n\t\t\t\t\tuploadUrl: {url|json_encode op=\"uploadProfileImage\" escape=false},\n\t\t\t\t\tbaseUrl: {$baseUrl|json_encode},\n\t\t\t\t\tfilters: {ldelim}\n\t\t\t\t\t\tmime_types : [\n\t\t\t\t\t\t\t{ldelim} title : \"Image files\", extensions : \"jpg,jpeg,png,gif\" {rdelim}\n\t\t\t\t\t\t]\n\t\t\t\t\t{rdelim},\n\t\t\t\t\tmultipart_params: {ldelim}\n\t\t\t\t\t\tcsrfToken: {csrf type=\"json\"}\n\t\t\t\t\t{rdelim},\n\t\t\t\t\tresize: {ldelim}\n\t\t\t\t\t\twidth: {$profileImageMaxWidth|intval},\n\t\t\t\t\t\theight: {$profileImageMaxHeight|intval},\n\t\t\t\t\t\tcrop: true,\n\t\t\t\t\t{rdelim}\n\t\t\t\t{rdelim}\n\t\t\t{rdelim}\n\t\t);\n\t{rdelim});\n</script>\n\n<form class=\"pkp_form\" id=\"publicProfileForm\" method=\"post\" action=\"{url op=\"savePublicProfile\"}\" enctype=\"multipart/form-data\">\n\t{csrf}\n\n\t{include file=\"controllers/notification/inPlaceNotification.tpl\" notificationId=\"publicProfileNotification\"}\n\n\t{fbvFormSection title=\"user.profile.form.profileImage\"}\n\t\t{if $profileImage}\n\t\t\t{* Add a unique ID to prevent caching *}\n\t\t\t<img src=\"{$baseUrl}/{$publicSiteFilesPath}/{$profileImage.uploadName}?{\"\"|uniqid}\" alt=\"{translate key=\"user.profile.form.profileImage\"}\" />\n\t\t\t<div>\n\t\t\t\t<a class=\"pkp_button pkp_button_offset\" href=\"{url op=\"deleteProfileImage\"}\">{translate key=\"common.delete\"}</a>\n\t\t\t</div>\n\t\t{/if}\n\t{/fbvFormSection}\n\t{fbvFormSection}\n\t\t{include file=\"controllers/fileUploadContainer.tpl\" id=\"plupload\"}\n\t{/fbvFormSection}\n\n\t{fbvFormSection}\n\t\t{fbvElement type=\"textarea\" label=\"user.biography\" multilingual=\"true\" name=\"biography\" id=\"biography\" rich=true value=$biography}\n\t{/fbvFormSection}\n\t{fbvFormSection}\n\t\t{fbvElement type=\"text\" label=\"user.url\" name=\"userUrl\" id=\"userUrl\" value=$userUrl maxlength=\"255\"}\n\t{/fbvFormSection}\n\t{fbvFormSection}\n\t\t{fbvElement type=\"text\" label=\"user.orcid\" name=\"orcid\" id=\"orcid\" value=$orcid maxlength=\"37\"}\n\t{/fbvFormSection}\n\n\t{call_hook name=\"User::PublicProfile::AdditionalItems\"}\n\n\t<p>\n\t\t{capture assign=\"privacyUrl\"}{url router=$smarty.const.ROUTE_PAGE page=\"about\" op=\"privacy\"}{/capture}\n\t\t{translate key=\"user.privacyLink\" privacyUrl=$privacyUrl}\n\t</p>\n\n\t<p><span class=\"formRequired\">{translate key=\"common.requiredField\"}</span></p>\n\n\t{fbvFormButtons hideCancel=true submitText=\"common.save\"}\n</form>\n"], "filenames": ["api/v1/_uploadPublicFile/PKPUploadPublicFileHandler.inc.php", "classes/file/FileManager.inc.php", "classes/services/PKPFileService.inc.php", "templates/controllers/grid/settings/category/form/categoryForm.tpl", "templates/user/publicProfileForm.tpl"], "buggy_code_start_loc": [93, 467, 233, 24, 26], "buggy_code_end_loc": [148, 470, 235, 25, 27], "fixing_code_start_loc": [93, 466, 232, 24, 26], "fixing_code_end_loc": [148, 466, 232, 25, 27], "type": "CWE-79", "message": "Cross-site Scripting in GitHub repository pkp/pkp-lib prior to 3.3.0-16.\n\n", "other": {"cve": {"id": "CVE-2023-5901", "sourceIdentifier": "security@huntr.dev", "published": "2023-11-07T04:24:31.807", "lastModified": "2024-01-21T03:06:11.610", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting in GitHub repository pkp/pkp-lib prior to 3.3.0-16.\n\n"}, {"lang": "es", "value": "Carga sin restricciones de archivos con tipo peligroso en el repositorio de GitHub pkp/pkp-lib anterior a 3.3.0-16."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}, {"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 0.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sfu:pkp_web_application_library:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.0-16", "matchCriteriaId": "60CE0E67-FCF5-4A26-A91E-514946B97D99"}]}]}], "references": [{"url": "https://github.com/pkp/pkp-lib/commit/44d8bde60eb2575fd4087b76540aec9b49389e23", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/8fb9b06b-cadd-469e-862d-5ce026019597", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pkp/pkp-lib/commit/44d8bde60eb2575fd4087b76540aec9b49389e23"}}