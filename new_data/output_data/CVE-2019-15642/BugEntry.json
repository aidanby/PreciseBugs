{"buggy_code": ["=head1 web-lib-funcs.pl\n\nCommon functions for Webmin CGI scripts. This file gets in-directly included\nby all scripts that use web-lib.pl.\nExample code:\n\n  use WebminCore;\n  init_config();\n  ui_print_header(undef, 'My Module', '');\n  print 'This is Webmin version ',get_webmin_version(),'<p>\\n';\n  ui_print_footer();\n\n=cut\n\n##use warnings;\nuse Socket;\nuse POSIX;\neval \"use Socket6\";\n$ipv6_module_error = $@;\nour $error_handler_funcs = [ ];\n\nuse vars qw($user_risk_level $loaded_theme_library $wait_for_input\n\t    $done_webmin_header $trust_unknown_referers $unsafe_index_cgi\n\t    %done_foreign_require $webmin_feedback_address\n\t    $user_skill_level $pragma_no_cache $foreign_args);\n# Globals\nuse vars qw($module_index_name $number_to_month_map $month_to_number_map\n\t    $umask_already $default_charset $licence_status $os_type\n\t    $licence_message $script_name $loaded_theme_oo_library\n\t    $done_web_lib_funcs $os_version $module_index_link\n\t    $called_from_webmin_core $ipv6_module_error);\n\n=head2 read_file(file, &hash, [&order], [lowercase], [split-char])\n\nFill the given hash reference with name=value pairs from a file. The required\nparameters are :\n\n=item file - The file to head, which must be text with each line like name=value\n\n=item hash - The hash reference to add values read from the file to.\n\n=item order - If given, an array reference to add names to in the order they were read\n\n=item lowercase - If set to 1, names are converted to lower case\n\n=item split-char - If set, names and values are split on this character instead of =\n\n=cut\nsub read_file\n{\nlocal $_;\nmy $split = defined($_[4]) ? $_[4] : \"=\";\nmy $realfile = &translate_filename($_[0]);\n&open_readfile(ARFILE, $_[0]) || return 0;\nwhile(<ARFILE>) {\n\tchomp;\n\tmy $hash = index($_, \"#\");\n\tmy $eq = index($_, $split);\n\tif ($hash != 0 && $eq >= 0) {\n\t\tmy $n = substr($_, 0, $eq);\n\t\tmy $v = substr($_, $eq+1);\n\t\tchomp($v);\n\t\t$_[1]->{$_[3] ? lc($n) : $n} = $v;\n\t\tpush(@{$_[2]}, $n) if ($_[2]);\n        \t}\n        }\nclose(ARFILE);\n$main::read_file_missing{$realfile} = 0;\t# It exists now\nif (defined($main::read_file_cache{$realfile})) {\n\t%{$main::read_file_cache{$realfile}} = %{$_[1]};\n\t}\nreturn 1;\n}\n\n=head2 read_file_cached(file, &hash, [&order], [lowercase], [split-char])\n\nLike read_file, but reads from an in-memory cache if the file has already been\nread in this Webmin script. Recommended, as it behaves exactly the same as\nread_file, but can be much faster.\n\n=cut\nsub read_file_cached\n{\nmy $realfile = &translate_filename($_[0]);\nif (defined($main::read_file_cache{$realfile})) {\n\t# Use cached data\n\t%{$_[1]} = ( %{$_[1]}, %{$main::read_file_cache{$realfile}} );\n\treturn 1;\n\t}\nelsif ($main::read_file_missing{$realfile}) {\n\t# Doesn't exist, so don't re-try read\n\treturn 0;\n\t}\nelse {\n\t# Actually read the file\n\tmy %d;\n\tif (&read_file($_[0], \\%d, $_[2], $_[3], $_[4])) {\n\t\t%{$main::read_file_cache{$realfile}} = %d;\n\t\t%{$_[1]} = ( %{$_[1]}, %d );\n\t\treturn 1;\n\t\t}\n\telse {\n\t\t# Flag as non-existant\n\t\t$main::read_file_missing{$realfile} = 1;\n\t\treturn 0;\n\t\t}\n\t}\n}\n\n=head2 read_file_cached_with_stat(file, &hash, [&order], [lowercase], [split-char])\n\nLike read_file, but reads from an in-memory cache if the file has already been\nread in this Webmin script AND has not changed.\n\n=cut\nsub read_file_cached_with_stat\n{\nmy $realfile = &translate_filename($_[0]);\nmy $t = $main::read_file_cache_time{$realfile};\nmy @st = stat($realfile);\nif ($t && $st[9] != $t) {\n\t# Changed, invalidate cache\n\tdelete($main::read_file_cache{$realfile});\n\t}\nmy $rv = &read_file_cached(@_);\n$main::read_file_cache_time{$realfile} = $st[9];\nreturn $rv;\n}\n\n=head2 write_file(file, &hash, [join-char])\n\nWrite out the contents of a hash as name=value lines. The parameters are :\n\n=item file - Full path to write to\n\n=item hash - A hash reference containing names and values to output\n\n=item join-char - If given, names and values are separated by this instead of =\n\n=cut\nsub write_file\n{\nmy (%old, @order);\nmy $join = defined($_[2]) ? $_[2] : \"=\";\nmy $realfile = &translate_filename($_[0]);\n&read_file($_[0], \\%old, \\@order);\n&open_tempfile(ARFILE, \">$_[0]\");\nforeach $k (@order) {\n\tif (exists($_[1]->{$k})) {\n\t\t(print ARFILE $k,$join,$_[1]->{$k},\"\\n\") ||\n\t\t\t&error(&text(\"efilewrite\", $realfile, $!));\n\t\t}\n\t}\nforeach $k (keys %{$_[1]}) {\n\tif (!exists($old{$k})) {\n\t\t(print ARFILE $k,$join,$_[1]->{$k},\"\\n\") ||\n\t\t\t&error(&text(\"efilewrite\", $realfile, $!));\n\t\t}\n        }\n&close_tempfile(ARFILE);\nif (defined($main::read_file_cache{$realfile})) {\n\t%{$main::read_file_cache{$realfile}} = %{$_[1]};\n\t}\nif (defined($main::read_file_missing{$realfile})) {\n\t$main::read_file_missing{$realfile} = 0;\n\t}\n}\n\n=head2 html_escape(string)\n\nConverts &, < and > codes in text to HTML entities, and returns the new string.\nThis should be used when including data read from other sources in HTML pages.\n\n=cut\nsub html_escape\n{\nmy ($tmp) = @_;\nif (!defined $tmp) {\n    return ''; # empty string\n};\n$tmp =~ s/&/&amp;/g;\n$tmp =~ s/</&lt;/g;\n$tmp =~ s/>/&gt;/g;\n$tmp =~ s/\\\"/&quot;/g;\n$tmp =~ s/\\'/&#39;/g;\n$tmp =~ s/=/&#61;/g;\nreturn $tmp;\n}\n\n=head2 quote_escape(string, [only-quote])\n\nConverts ' and \" characters in a string into HTML entities, and returns it.\nUseful for outputing HTML tag values.\n\n=cut\nsub quote_escape\n{\nmy ($tmp, $only) = @_;\nif (!defined $tmp) {\n    return ''; # empty string\n};\nif ($tmp !~ /\\&[a-zA-Z]+;/ && $tmp !~ /\\&#/) {\n\t# convert &, unless it is part of &#nnn; or &foo;\n\t$tmp =~ s/&([^#])/&amp;$1/g;\n\t}\n$tmp =~ s/&$/&amp;/g;\n$tmp =~ s/\\\"/&quot;/g if (!$only || $only eq '\"');\n$tmp =~ s/\\'/&#39;/g if (!$only || $only eq \"'\");\nreturn $tmp;\n}\n\n=head2 quote_javascript(string)\n\nQuote all characters that are unsafe for inclusion in javascript strings in HTML\n\n=cut\nsub quote_javascript\n{\nmy ($str) = @_;\n$str =~ s/[\"'<>&\\\\]/sprintf('\\x%02x', ord $&)/ge;\nreturn $str;\n}\n\n=head2 tempname_dir()\n\nReturns the base directory under which temp files can be created.\n\n=cut\nsub tempname_dir\n{\nmy $tmp_base = $gconfig{'tempdir_'.&get_module_name()} ?\n\t\t\t$gconfig{'tempdir_'.&get_module_name()} :\n\t\t  $gconfig{'tempdir'} ? $gconfig{'tempdir'} :\n\t\t  $ENV{'TEMP'} && $ENV{'TEMP'} ne \"/tmp\" ? $ENV{'TEMP'} :\n\t\t  $ENV{'TMP'} && $ENV{'TMP'} ne \"/tmp\" ? $ENV{'TMP'} :\n\t\t  -d \"c:/temp\" ? \"c:/temp\" : \"/tmp/.webmin\";\nmy $tmp_dir;\nif (-d $remote_user_info[7] && !$gconfig{'nohometemp'}) {\n\t$tmp_dir = \"$remote_user_info[7]/.tmp\";\n\t}\nelsif (@remote_user_info) {\n\t$tmp_dir = $tmp_base.\"-\".$remote_user_info[2].\"-\".$remote_user;\n\t}\nelsif ($< != 0) {\n\tmy $u = getpwuid($<);\n\tif ($u) {\n\t\t$tmp_dir = $tmp_base.\"-\".$<.\"-\".$u;\n\t\t}\n\telse {\n\t\t$tmp_dir = $tmp_base.\"-\".$<;\n\t\t}\n\t}\nelse {\n\t$tmp_dir = $tmp_base;\n\t}\nreturn $tmp_dir;\n}\n\n=head2 tempname([filename])\n\nReturns a mostly random temporary file name, typically under the /tmp/.webmin\ndirectory. If filename is given, this will be the base name used. Otherwise\na unique name is selected randomly.\n\n=cut\nsub tempname\n{\nmy ($filename) = @_;\nmy $tmp_dir = &tempname_dir();\nif ($gconfig{'os_type'} eq 'windows' || $tmp_dir =~ /^[a-z]:/i) {\n\t# On Windows system, just create temp dir if missing\n\tif (!-d $tmp_dir) {\n\t\tmkdir($tmp_dir, 0755) ||\n\t\t\t&error(\"Failed to create temp directory $tmp_dir : $!\");\n\t\t}\n\t}\nelse {\n\t# On Unix systems, need to make sure temp dir is valid\n\tmy $tries = 0;\n\twhile($tries++ < 10) {\n\t\tmy @st = lstat($tmp_dir);\n\t\tlast if ($st[4] == $< && (-d _) && ($st[2] & 0777) == 0755);\n\t\tif (@st) {\n\t\t\tunlink($tmp_dir) || rmdir($tmp_dir) ||\n\t\t\t\tsystem(\"/bin/rm -rf \".quotemeta($tmp_dir));\n\t\t\t}\n\t\tmkdir($tmp_dir, 0755) || next;\n\t\tchown($<, $(, $tmp_dir);\n\t\tchmod(0755, $tmp_dir);\n\t\t}\n\tif ($tries >= 10) {\n\t\tmy @st = lstat($tmp_dir);\n\t\t&error(\"Failed to create temp directory $tmp_dir\");\n\t\t}\n\t# If running as root, check parent dir (usually /tmp) to make sure it's\n\t# world-writable and owned by root\n\tmy $tmp_parent = $tmp_dir;\n\t$tmp_parent =~ s/\\/[^\\/]+$//;\n\tif ($tmp_parent eq \"/tmp\") {\n\t\tmy @st = stat($tmp_parent);\n\t\tif (($st[2] & 0555) != 0555) {\n\t\t\t&error(\"Base temp directory $tmp_parent is not world readable and listable\");\n\t\t\t}\n\t\t}\n\t}\nmy $rv;\nif (defined($filename) && $filename !~ /\\.\\./) {\n\t$rv = \"$tmp_dir/$filename\";\n\t}\nelse {\n\t$main::tempfilecount++;\n\t&seed_random();\n\t$rv = $tmp_dir.\"/\".int(rand(1000000)).\"_\".$$.\"_\".\n\t       $main::tempfilecount.\"_\".$scriptname;\n\t}\nreturn $rv;\n}\n\n=head2 transname([filename])\n\nBehaves exactly like tempname, but records the temp file for deletion when the\ncurrent Webmin script process exits.\n\n=cut\nsub transname\n{\nmy $rv = &tempname(@_);\npush(@main::temporary_files, $rv);\nreturn $rv;\n}\n\n=head2 trunc(string, maxlen)\n\nTruncates a string to the shortest whole word less than or equal to the\ngiven width. Useful for word wrapping.\n\n=cut\nsub trunc\n{\nif (length($_[0]) <= $_[1]) {\n\treturn $_[0];\n\t}\nmy $str = substr($_[0],0,$_[1]);\nmy $c;\ndo {\n\t$c = chop($str);\n\t} while($c !~ /\\S/);\n$str =~ s/\\s+$//;\nreturn $str;\n}\n\n=head2 indexof(string, value, ...)\n\nReturns the index of some value in an array of values, or -1 if it was not\nfound.\n\n=cut\nsub indexof\n{\nfor(my $i=1; $i <= $#_; $i++) {\n\tif ($_[$i] eq $_[0]) { return $i - 1; }\n\t}\nreturn -1;\n}\n\n=head2 indexoflc(string, value, ...)\n\nLike indexof, but does a case-insensitive match\n\n=cut\nsub indexoflc\n{\nmy $str = lc(shift(@_));\nmy @arr = map { lc($_) } @_;\nreturn &indexof($str, @arr);\n}\n\n=head2 sysprint(handle, [string]+)\n\nOutputs some strings to a file handle, but bypassing IO buffering. Can be used\nas a replacement for print when writing to pipes or sockets.\n\n=cut\nsub sysprint\n{\nmy $fh = &callers_package($_[0]);\nmy $str = join('', @_[1..$#_]);\nsyswrite $fh, $str, length($str);\n}\n\n=head2 check_ipaddress(ip)\n\nCheck if some IPv4 address is properly formatted, returning 1 if so or 0 if not.\n\n=cut\nsub check_ipaddress\n{\nreturn $_[0] =~ /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/ &&\n\t$1 >= 0 && $1 <= 255 &&\n\t$2 >= 0 && $2 <= 255 &&\n\t$3 >= 0 && $3 <= 255 &&\n\t$4 >= 0 && $4 <= 255;\n}\n\n=head2 check_ip6address(ip)\n\nCheck if some IPv6 address is properly formatted, and returns 1 if so.\n\n=cut\nsub check_ip6address\n{\n  my @blocks = split(/:/, $_[0]);\n  return 0 if (@blocks == 0 || @blocks > 8);\n\n  # The address/netmask format is accepted. So we're looking for a \"/\" to isolate a possible netmask.\n  # After that, we delete the netmask to control the address only format, but we verify whether the netmask\n  # value is in [0;128].\n  my $ib = $#blocks;\n  my $where = index($blocks[$ib],\"/\");\n  my $m = 0;\n  if ($where != -1) {\n    my $b = substr($blocks[$ib],0,$where);\n    $m = substr($blocks[$ib],$where+1,length($blocks[$ib])-($where+1));\n    $blocks[$ib]=$b;\n  }\n\n  # The netmask must take its value in [0;128]\n  return 0 if ($m <0 || $m >128);\n\n  # Check the different blocks of the address : 16 bits block in hexa notation.\n  # Possibility of 1 empty block or 2 if the address begins with \"::\".\n  my $b;\n  my $empty = 0;\n  foreach $b (@blocks) {\n\t  return 0 if ($b ne \"\" && $b !~ /^[0-9a-f]{1,4}$/i);\n\t  $empty++ if ($b eq \"\");\n\t  }\n  return 0 if ($empty > 1 && !($_[0] =~ /^::/ && $empty == 2));\n  return 1;\n}\n\n\n\n=head2 generate_icon(image, title, link, [href], [width], [height], [before-title], [after-title])\n\nPrints HTML for an icon image. The parameters are :\n\n=item image - URL for the image, like images/foo.gif\n\n=item title - Text to appear under the icon\n\n=item link - Optional destination for the icon's link\n\n=item href - Other HTML attributes to be added to the <a href> for the link\n\n=item width - Optional width of the icon\n\n=item height - Optional height of the icon\n\n=item before-title - HTML to appear before the title link, but which is not actually in the link\n\n=item after-title - HTML to appear after the title link, but which is not actually in the link\n\n=cut\nsub generate_icon\n{\n&load_theme_library();\nif (defined(&theme_generate_icon)) {\n\t&theme_generate_icon(@_);\n\treturn;\n\t}\nmy $w = !defined($_[4]) ? \"width='48'\" : $_[4] ? \"width='$_[4]'\" : \"\";\nmy $h = !defined($_[5]) ? \"height='48'\" : $_[5] ? \"height='$_[5]'\" : \"\";\nif ($tconfig{'noicons'}) {\n\tif ($_[2]) {\n\t\tprint \"$_[6]<a href=\\\"$_[2]\\\" $_[3]>$_[1]</a>$_[7]\\n\";\n\t\t}\n\telse {\n\t\tprint \"$_[6]$_[1]$_[7]\\n\";\n\t\t}\n\t}\nelsif ($_[2]) {\n\tprint \"<table border><tr><td width='48' height='48'>\\n\",\n\t      \"<a href=\\\"$_[2]\\\" $_[3]><img src=\\\"$_[0]\\\" alt=\\\"\\\" border='0' \",\n\t      \"$w $h></a></td></tr></table>\\n\";\n\tprint \"$_[6]<a href=\\\"$_[2]\\\" $_[3]>$_[1]</a>$_[7]\\n\";\n\t}\nelse {\n\tprint \"<table border><tr><td width='48' height='48'>\\n\",\n\t      \"<img src=\\\"$_[0]\\\" alt=\\\"\\\" border='0' $w $h>\",\n\t      \"</td></tr></table>\\n$_[6]$_[1]$_[7]\\n\";\n\t}\n}\n\n=head2 urlize\n\nConverts a string to a form ok for putting in a URL, using % escaping.\n\n=cut\nsub urlize\n{\nmy ($rv) = @_;\n$rv =~ s/([^A-Za-z0-9])/sprintf(\"%%%2.2X\", ord($1))/ge;\nreturn $rv;\n}\n\n=head2 un_urlize(string)\n\nConverts a URL-encoded string to it's original contents - the reverse of the\nurlize function.\n\n=cut\nsub un_urlize\n{\nmy ($rv) = @_;\n$rv =~ s/\\+/ /g;\n$rv =~ s/%(..)/pack(\"c\",hex($1))/ge;\nreturn $rv;\n}\n\n=head2 include(filename)\n\nRead and output the contents of the given file.\n\n=cut\nsub include\n{\nlocal $_;\nopen(INCLUDE, &translate_filename($_[0])) || return 0;\nwhile(<INCLUDE>) {\n\tprint;\n\t}\nclose(INCLUDE);\nreturn 1;\n}\n\n=head2 copydata(in-handle, out-handle)\n\nRead from one file handle and write to another, until there is no more to read.\n\n=cut\nsub copydata\n{\nmy ($in, $out) = @_;\n$in = &callers_package($in);\n$out = &callers_package($out);\nmy $buf;\nwhile(read($in, $buf, 32768) > 0) {\n\t(print $out $buf) || return 0;\n\t}\nreturn 1;\n}\n\n=head2 ReadParseMime([maximum], [&cbfunc, &cbargs], [array-mode])\n\nRead data submitted via a POST request using the multipart/form-data coding,\nand store it in the global %in hash. The optional parameters are :\n\n=item maximum - If the number of bytes of input exceeds this number, stop reading and call error.\n\n=item cbfunc - A function reference to call after reading each block of data.\n\n=item cbargs - Additional parameters to the callback function.\n\n=item array-mode - If set to 1, values in %in are arrays. If set to 0, multiple values are joined with \\0. If set to 2, only the first value is used.\n\n=cut\nsub ReadParseMime\n{\nmy ($max, $cbfunc, $cbargs, $arrays) = @_;\nmy ($boundary, $line, $name, $got, $file, $count_lines, $max_lines);\nmy $err = &text('readparse_max', $max);\n$ENV{'CONTENT_TYPE'} =~ /boundary=(.*)$/ || &error($text{'readparse_enc'});\nif ($ENV{'CONTENT_LENGTH'} && $max && $ENV{'CONTENT_LENGTH'} > $max) {\n\t&error($err);\n\t}\n&$cbfunc(0, $ENV{'CONTENT_LENGTH'}, $file, @$cbargs) if ($cbfunc);\n$boundary = $1;\n$count_lines = 0;\n$max_lines = 1000;\n<STDIN>;\t# skip first boundary\nwhile(1) {\n\t$name = \"\";\n\t# Read section headers\n\tmy $lastheader;\n\twhile(1) {\n\t\t$line = <STDIN>;\n\t\t$got += length($line);\n\t\t&$cbfunc($got, $ENV{'CONTENT_LENGTH'}, @$cbargs) if ($cbfunc);\n\t\tif ($max && $got > $max) {\n\t\t\t&error($err)\n\t\t\t}\n\t\t$line =~ tr/\\r\\n//d;\n\t\tlast if (!$line);\n\t\tif ($line =~ /^(\\S+):\\s*(.*)$/) {\n\t\t\t$header{$lastheader = lc($1)} = $2;\n\t\t\t}\n\t\telsif ($line =~ /^\\s+(.*)$/) {\n\t\t\t$header{$lastheader} .= $line;\n\t\t\t}\n\t\t}\n\n\t# Parse out filename and type\n\tmy $file;\n\tif ($header{'content-disposition'} =~ /^form-data(.*)/) {\n\t\t$rest = $1;\n\t\twhile ($rest =~ /([a-zA-Z]*)=\\\"([^\\\"]*)\\\"(.*)/) {\n\t\t\tif ($1 eq 'name') {\n\t\t\t\t$name = $2;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tmy $foo = $name.\"_\".$1;\n\t\t\t\tif ($1 eq \"filename\") {\n\t\t\t\t\t$file = $2;\n\t\t\t\t\t}\n\t\t\t\tif ($arrays == 1) {\n\t\t\t\t\t$in{$foo} ||= [];\n\t\t\t\t\tpush(@{$in{$foo}}, $2);\n\t\t\t\t\t}\n\t\t\t\telsif ($arrays == 2) {\n\t\t\t\t\t$in{$foo} ||= $2;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$in{$foo} .= \"\\0\"\n\t\t\t\t\t\tif (defined($in{$foo}));\n\t\t\t\t\t$in{$foo} .= $2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t$rest = $3;\n\t\t\t}\n\t\t}\n\telse {\n\t\t&error($text{'readparse_cdheader'});\n\t\t}\n\n\t# Save content type separately\n\tif ($header{'content-type'} =~ /^([^\\s;]+)/) {\n\t\tmy $foo = $name.\"_content_type\";\n\t\tif ($arrays == 1) {\n\t\t\t$in{$foo} ||= [];\n\t\t\tpush(@{$in{$foo}}, $1);\n\t\t\t}\n\t\telsif ($arrays == 2) {\n\t\t\t$in{$foo} ||= $1;\n\t\t\t}\n\t\telse {\n\t\t\t$in{$foo} .= \"\\0\" if (defined($in{$foo}));\n\t\t\t$in{$foo} .= $1;\n\t\t\t}\n\t\t}\n\n\t# Read data\n\tmy $data = \"\";\n\twhile(1) {\n\t\t$line = <STDIN>;\n\t\t$got += length($line);\n\t\t$count_lines++;\n\t\tif ($count_lines == $max_lines) {\n\t\t\t&$cbfunc($got, $ENV{'CONTENT_LENGTH'}, $file, @$cbargs)\n\t\t\t\tif ($cbfunc);\n\t\t\t$count_lines = 0;\n\t\t\t}\n\t\tif ($max && $got > $max) {\n\t\t\t#print STDERR \"over limit of $max\\n\";\n\t\t\t#&error($err);\n\t\t\t}\n\t\tif (!$line) {\n\t\t\t# Unexpected EOF?\n\t\t\t&$cbfunc(-1, $ENV{'CONTENT_LENGTH'}, $file, @$cbargs)\n\t\t\t\tif ($cbfunc);\n\t\t\treturn;\n\t\t\t}\n\t\tif (index($line, $boundary) != -1) { last; }\n\t\t$data .= $line;\n\t\t}\n\tchop($data); chop($data);\n\tif ($arrays == 1) {\n\t\t$in{$name} ||= [];\n\t\tpush(@{$in{$name}}, $data);\n\t\t}\n\telsif ($arrays == 2) {\n\t\t$in{$name} ||= $data;\n\t\t}\n\telse {\n\t\t$in{$name} .= \"\\0\" if (defined($in{$name}));\n\t\t$in{$name} .= $data;\n\t\t}\n\tif (index($line,\"$boundary--\") != -1) { last; }\n\t}\n&$cbfunc(-1, $ENV{'CONTENT_LENGTH'}, $file, @$cbargs) if ($cbfunc);\n}\n\n=head2 ReadParse([&hash], [method], [noplus], [array-mode])\n\nFills the given hash reference with CGI parameters, or uses the global hash\n%in if none is given. Also sets the global variables $in and @in. The other\nparameters are :\n\n=item method - For use of this HTTP method, such as GET\n\n=item noplus - Don't convert + in parameters to spaces.\n\n=item array-mode - If set to 1, values in %in are arrays. If set to 0, multiple values are joined with \\0. If set to 2, only the first value is used.\n\n=cut\nsub ReadParse\n{\nmy $a = $_[0] || \\%in;\n%$a = ( );\nmy $meth = $_[1] ? $_[1] : $ENV{'REQUEST_METHOD'};\nundef($in);\nif ($meth eq 'POST') {\n\tmy $clen = $ENV{'CONTENT_LENGTH'};\n\t&read_fully(STDIN, \\$in, $clen) == $clen ||\n\t\t&error(\"Failed to read POST input : $!\");\n\t}\nif ($ENV{'QUERY_STRING'}) {\n\tif ($in) { $in .= \"&\".$ENV{'QUERY_STRING'}; }\n\telse { $in = $ENV{'QUERY_STRING'}; }\n\t}\n@in = split(/\\&/, $in);\nforeach my $i (@in) {\n\t$i =~ /\\0/ && &error(\"Null byte in query string\");\n\tmy ($k, $v) = split(/=/, $i, 2);\n\tif (!$_[2]) {\n\t\t$k =~ tr/\\+/ /;\n\t\t$v =~ tr/\\+/ /;\n\t\t}\n\t$k =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t$v =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\tif ($_[3] == 1) {\n\t\t$a->{$k} ||= [];\n\t\tpush(@{$a->{$k}}, $v);\n\t\t}\n\telsif ($_[3] == 2) {\n\t\t$a->{$k} ||= $v;\n\t\t}\n\telse {\n\t\t$a->{$k} = defined($a->{$k}) ? $a->{$k}.\"\\0\".$v : $v;\n\t\t}\n\t}\n}\n\n=head2 read_fully(fh, &buffer, length)\n\nRead data from some file handle up to the given length, even in the face\nof partial reads. Reads the number of bytes read. Stores received data in the\nstring pointed to be the buffer reference.\n\n=cut\nsub read_fully\n{\nmy ($fh, $buf, $len) = @_;\n$fh = &callers_package($fh);\nmy $got = 0;\nwhile($got < $len) {\n\tmy $r = read(STDIN, $$buf, $len-$got, $got);\n\tlast if ($r <= 0);\n\t$got += $r;\n\t}\nreturn $got;\n}\n\n=head2 read_parse_mime_callback(size, totalsize, upload-id)\n\nCalled by ReadParseMime as new data arrives from a form-data POST. Only updates\nthe file on every 1% change though. For internal use by the upload progress\ntracker.\n\n=cut\nsub read_parse_mime_callback\n{\nmy ($size, $totalsize, $filename, $id) = @_;\nreturn if ($gconfig{'no_upload_tracker'});\nreturn if (!$id);\n\n# Create the upload tracking directory - if running as non-root, this has to\n# be under the user's home\nmy $vardir;\nif ($<) {\n\tmy @uinfo = @remote_user_info ? @remote_user_info : getpwuid($<);\n\t$vardir = \"$uinfo[7]/.tmp\";\n\t}\nelse {\n\t$vardir = $ENV{'WEBMIN_VAR'};\n\t}\nif (!-d $vardir) {\n\t&make_dir($vardir, 0755);\n\t}\n\n# Remove any upload.* files more than 1 hour old\nif (!$main::read_parse_mime_callback_flushed) {\n\tmy $now = time();\n\topendir(UPDIR, $vardir);\n\tforeach my $f (readdir(UPDIR)) {\n\t\tnext if ($f !~ /^upload\\./);\n\t\tmy @st = stat(\"$vardir/$f\");\n\t\tif ($st[9] < $now-3600) {\n\t\t\tunlink(\"$vardir/$f\");\n\t\t\t}\n\t\t}\n\tclosedir(UPDIR);\n\t$main::read_parse_mime_callback_flushed++;\n\t}\n\n# Only update file once per percent\nmy $upfile = \"$vardir/upload.$id\";\nif ($totalsize && $size >= 0) {\n\tmy $pc = int(100 * $size / $totalsize);\n\tif ($pc <= $main::read_parse_mime_callback_pc{$upfile}) {\n\t\treturn;\n\t\t}\n\t$main::read_parse_mime_callback_pc{$upfile} = $pc;\n\t}\n\n# Write to the file\n&open_tempfile(UPFILE, \">$upfile\");\nprint UPFILE $size,\"\\n\";\nprint UPFILE $totalsize,\"\\n\";\nprint UPFILE $filename,\"\\n\";\n&close_tempfile(UPFILE);\n}\n\n=head2 read_parse_mime_javascript(upload-id, [&fields])\n\nReturns an onSubmit= Javascript statement to popup a window for tracking\nan upload with the given ID. For internal use by the upload progress tracker.\n\n=cut\nsub read_parse_mime_javascript\n{\nmy ($id, $fields) = @_;\nreturn \"\" if ($gconfig{'no_upload_tracker'});\nmy $opener = \"window.open(\\\"$gconfig{'webprefix'}/uptracker.cgi?id=$id&uid=$<\\\", \\\"uptracker\\\", \\\"toolbar=no,menubar=no,scrollbars=no,width=500,height=128\\\");\";\nif ($fields) {\n\tmy $if = join(\" || \", map { \"typeof($_) != \\\"undefined\\\" && $_.value != \\\"\\\"\" } @$fields);\n\treturn \"onSubmit='if ($if) { $opener }'\";\n\t}\nelse {\n\treturn \"onSubmit='$opener'\";\n\t}\n}\n\n=head2 PrintHeader(charset, [mime-type])\n\nOutputs the HTTP headers for an HTML page. The optional charset parameter\ncan be used to set a character set. Normally this function is not called\ndirectly, but is rather called by ui_print_header or header.\n\n=cut\nsub PrintHeader\n{\nmy ($cs, $mt) = @_;\n$mt ||= \"text/html\";\nif ($pragma_no_cache || $gconfig{'pragma_no_cache'}) {\n\tprint \"pragma: no-cache\\n\";\n\tprint \"Expires: Thu, 1 Jan 1970 00:00:00 GMT\\n\";\n\tprint \"Cache-Control: no-store, no-cache, must-revalidate\\n\";\n\tprint \"Cache-Control: post-check=0, pre-check=0\\n\";\n\t}\nif ($gconfig{'extra_headers'}) {\n\tforeach my $l (split(/\\t+/, $gconfig{'extra_headers'})) {\n\t\tprint $l.\"\\n\";\n\t\t}\n\t}\nif (!$gconfig{'no_frame_options'}) {\n\tprint \"X-Frame-Options: SAMEORIGIN\\n\";\n\t}\nif (!$gconfig{'no_content_security_policy'}) {\n\tprint \"Content-Security-Policy: script-src 'self' 'unsafe-inline' 'unsafe-eval'; frame-src 'self'; child-src 'self'\\n\";\n\t}\nif (defined($cs)) {\n\tprint \"Content-type: $mt; Charset=$cs\\n\\n\";\n\t}\nelse {\n\tprint \"Content-type: $mt\\n\\n\";\n\t}\n$main::header_content_type = $mt;\n}\n\n=head2 header(title, image, [help], [config], [nomodule], [nowebmin], [rightside], [head-stuff], [body-stuff], [below])\n\nOutputs a Webmin HTML page header with a title, including HTTP headers. The\nparameters are :\n\n=item title - The text to show at the top of the page\n\n=item image - An image to show instead of the title text. This is typically left blank.\n\n=item help - If set, this is the name of a help page that will be linked to in the title.\n\n=item config - If set to 1, the title will contain a link to the module's config page.\n\n=item nomodule - If set to 1, there will be no link in the title section to the module's index.\n\n=item nowebmin - If set to 1, there will be no link in the title section to the Webmin index.\n\n=item rightside - HTML to be shown on the right-hand side of the title. Can contain multiple lines, separated by <br>. Typically this is used for links to stop, start or restart servers.\n\n=item head-stuff - HTML to be included in the <head> section of the page.\n\n=item body-stuff - HTML attributes to be include in the <body> tag.\n\n=item below - HTML to be displayed below the title. Typically this is used for application or server version information.\n\n=cut\nsub header\n{\nreturn if ($main::done_webmin_header++);\nmy $ll;\nmy $charset = defined($main::force_charset) ? $main::force_charset\n\t\t\t\t\t    : &get_charset();\n&PrintHeader($charset);\n&load_theme_library();\nif (defined(&theme_header)) {\n\t$module_name = &get_module_name();\n\t&theme_header(@_);\n\t$miniserv::page_capture = 1;\n\treturn;\n\t}\nprint \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\";\nprint \"<html style=\\\"height:100%\\\">\\n\";\nprint \"<head>\\n\";\nif (defined(&theme_prehead)) {\n\t&theme_prehead(@_);\n\t}\nif ($charset) {\n\tprint \"<meta http-equiv=\\\"Content-Type\\\" \",\n\t      \"content=\\\"text/html; Charset=\".&quote_escape($charset).\"\\\">\\n\";\n\t}\nif (@_ > 0) {\n\tmy $title = &get_html_title($_[0]);\n        print \"<title>$title</title>\\n\" if ($_[7] !~ /<title>/i);\n\tprint $_[7] if ($_[7]);\n\tprint &get_html_status_line(0);\n\t}\nprint \"$tconfig{'headhtml'}\\n\" if ($tconfig{'headhtml'});\nif ($tconfig{'headinclude'}) {\n  my ($theme, $overlay) = split(' ', $gconfig{'theme'});\n  my $file_contents = read_file_contents(\"$root_directory/$overlay/$tconfig{'headinclude'}\");;\n  $file_contents = replace_meta($file_contents);\n  print $file_contents;\n  }\nprint \"</head>\\n\";\nmy $bgcolor = defined($tconfig{'cs_page'}) ? $tconfig{'cs_page'} :\n\t\t defined($gconfig{'cs_page'}) ? $gconfig{'cs_page'} : \"ffffff\";\nmy $link = defined($tconfig{'cs_link'}) ? $tconfig{'cs_link'} :\n\t      defined($gconfig{'cs_link'}) ? $gconfig{'cs_link'} : \"0000ee\";\nmy $text = defined($tconfig{'cs_text'}) ? $tconfig{'cs_text'} :\n\t      defined($gconfig{'cs_text'}) ? $gconfig{'cs_text'} : \"000000\";\nmy $bgimage = defined($tconfig{'bgimage'}) ? \"background=$tconfig{'bgimage'}\" : \"\";\nmy $dir = $current_lang_info->{'dir'} ? \"dir=\\\"$current_lang_info->{'dir'}\\\"\" : \"\";\nmy $html_body = \"<body bgcolor=\\\"#$bgcolor\\\" link=\\\"#$link\\\" vlink=\\\"#$link\\\" text=\\\"#$text\\\" style=\\\"height:100%\\\" $bgimage $tconfig{'inbody'} $dir $_[8]>\\n\";\n$html_body =~ s/\\s+\\>/>/g;\nprint $html_body;\n\nif (defined(&theme_prebody)) {\n\t&theme_prebody(@_);\n\t}\n\nmy $prebody = $tconfig{'prebody'};\nif ($prebody) {\n\t$prebody = replace_meta($prebody);\n\tprint \"$prebody\\n\";\n\t}\n\tif ($tconfig{'prebodyinclude'}) {\n    my ($theme, $overlay) = split(' ', $gconfig{'theme'});\n    my $file_contents = read_file_contents(\"$root_directory/$overlay/$tconfig{'prebodyinclude'}\");\n    $file_contents = replace_meta($file_contents);\n    print $file_contents;\n\t\t}\nif (@_ > 1) {\n\tprint $tconfig{'preheader'};\n\tmy %this_module_info = &get_module_info(&get_module_name());\n\tprint \"<table class='header' width='100%'><tr>\\n\";\n\tif ($gconfig{'sysinfo'} == 2 && $remote_user) {\n\t\tprint \"<td id='headln1' colspan='3' align='center'>\\n\";\n\t\tprint &get_html_status_line(1);\n\t\tprint \"</td></tr> <tr>\\n\";\n\t\t}\n\tprint \"<td id='headln2l' width='15%' valign='top' align='left'>\";\n\tif ($ENV{'HTTP_WEBMIN_SERVERS'} && !$tconfig{'framed'}) {\n\t\tprint \"<a href='$ENV{'HTTP_WEBMIN_SERVERS'}'>\",\n\t\t      \"$text{'header_servers'}</a><br>\\n\";\n\t\t}\n\tif (!$_[5] && !$tconfig{'noindex'}) {\n\t\tmy @avail = &get_available_module_infos(1);\n\t\tmy $nolo = $ENV{'ANONYMOUS_USER'} ||\n\t\t\t      $ENV{'SSL_USER'} || $ENV{'LOCAL_USER'} ||\n\t\t\t      $ENV{'HTTP_USER_AGENT'} =~ /webmin/i;\n\t\tif ($gconfig{'gotoone'} && $main::session_id && @avail == 1 &&\n\t\t    !$nolo) {\n\t\t\tprint \"<a href='$gconfig{'webprefix'}/session_login.cgi?logout=1'>\",\n\t\t\t      \"$text{'main_logout'}</a><br>\";\n\t\t\t}\n\t\telsif ($gconfig{'gotoone'} && @avail == 1 && !$nolo) {\n\t\t\tprint \"<a href=$gconfig{'webprefix'}/switch_user.cgi>\",\n\t\t\t      \"$text{'main_switch'}</a><br>\";\n\t\t\t}\n\t\telsif (!$gconfig{'gotoone'} || @avail > 1) {\n\t\t\tprint \"<a href='$gconfig{'webprefix'}/?cat=\",\n\t\t\t      $this_module_info{'category'},\n\t\t\t      \"'>$text{'header_webmin'}</a><br>\\n\";\n\t\t\t}\n\t\t}\n\tif (!$_[4] && !$tconfig{'nomoduleindex'}) {\n\t\tmy $idx = $this_module_info{'index_link'};\n\t\tmy $mi = $module_index_link || \"/\".&get_module_name().\"/$idx\";\n\t\tmy $mt = $module_index_name || $text{'header_module'};\n\t\tprint \"<a href=\\\"$gconfig{'webprefix'}$mi\\\">$mt</a><br>\\n\";\n\t\t}\n\tif (ref($_[2]) eq \"ARRAY\" && !$ENV{'ANONYMOUS_USER'} &&\n\t    !$tconfig{'nohelp'}) {\n\t\tprint &hlink($text{'header_help'}, $_[2]->[0], $_[2]->[1]),\n\t\t      \"<br>\\n\";\n\t\t}\n\telsif (defined($_[2]) && !$ENV{'ANONYMOUS_USER'} &&\n\t       !$tconfig{'nohelp'}) {\n\t\tprint &hlink($text{'header_help'}, $_[2]),\"<br>\\n\";\n\t\t}\n\tif ($_[3]) {\n\t\tmy %access = &get_module_acl();\n\t\tif (!$access{'noconfig'} && !$config{'noprefs'}) {\n\t\t\tmy $cprog = $user_module_config_directory ?\n\t\t\t\t\t\"uconfig.cgi\" : \"config.cgi\";\n\t\t\tprint \"<a href=\\\"$gconfig{'webprefix'}/$cprog?\",\n\t\t\t      &get_module_name().\"\\\">\",\n\t\t\t      $text{'header_config'},\"</a><br>\\n\";\n\t\t\t}\n\t\t}\n\tprint \"</td>\\n\";\n\tif ($_[1]) {\n\t\t# Title is a single image\n\t\tprint \"<td id='headln2c' align='center' width='70%'>\",\n\t\t      \"<img alt=\\\"$_[0]\\\" src=\\\"$_[1]\\\"></td>\\n\";\n\t\t}\n\telse {\n\t\t# Title is just text\n\t\tmy $ts = defined($tconfig{'titlesize'}) ?\n\t\t\t\t$tconfig{'titlesize'} : \"+2\";\n\t\tprint \"<td id='headln2c' align='center' width='70%'>\",\n\t\t      ($ts ? \"<font size='$ts'>\" : \"\"),$_[0],\n\t\t      ($ts ? \"</font>\" : \"\");\n\t\tprint \"<br>$_[9]\\n\" if ($_[9]);\n\t\tprint \"</td>\\n\";\n\t\t}\n\tprint \"<td id='headln2r' width='15%' valign='top' align='right'>\";\n\tprint $_[6];\n\tprint \"</td></tr></table>\\n\";\n\tprint $tconfig{'postheader'};\n\t}\n$miniserv::page_capture = 1;\n}\n\n=head2 get_html_title(title)\n\nReturns the full string to appear in the HTML <title> block.\n\n=cut\nsub get_html_title\n{\nmy ($msg) = @_;\nmy $title;\nmy $os_type = $gconfig{'real_os_type'} || $gconfig{'os_type'};\nmy $os_version = $gconfig{'real_os_version'} || $gconfig{'os_version'};\nmy $host = &get_display_hostname();\nif ($gconfig{'sysinfo'} == 1 && $remote_user) {\n\t$title = sprintf \"%s : %s on %s (%s %s)\\n\",\n\t\t$msg, $remote_user, $host,\n\t\t$os_type, $os_version;\n\t}\nelsif ($gconfig{'sysinfo'} == 4 && $remote_user) {\n\t$title = sprintf \"%s on %s (%s %s)\\n\",\n\t\t$remote_user, $host,\n\t\t$os_type, $os_version;\n\t}\nelse {\n\t$title = $msg;\n\t}\nif ($gconfig{'showlogin'} && $remote_user) {\n\t$title = $remote_user.($title ? \" : \".$title : \"\");\n\t}\nif ($gconfig{'showhost'}) {\n\t$title = $host.($title ? \" : \".$title : \"\");\n\t}\nreturn $title;\n}\n\n=head2 get_html_framed_title\n\nReturns the title text for a framed theme main page.\n\n=cut\nsub get_html_framed_title\n{\nmy $ostr;\nmy $os_type = $gconfig{'real_os_type'} || $gconfig{'os_type'};\nmy $os_version = $gconfig{'real_os_version'} || $gconfig{'os_version'};\nmy $title;\nif (($gconfig{'sysinfo'} == 4 || $gconfig{'sysinfo'} == 1) && $remote_user) {\n\t# Alternate title mode requested\n\t$title = sprintf \"%s on %s (%s %s)\\n\",\n\t\t$remote_user, &get_display_hostname(),\n\t\t$os_type, $os_version;\n\t}\nelse {\n\t# Title like 'Webmin x.yy on hostname (Linux 6)'\n\tif ($os_version eq \"*\") {\n\t\t$ostr = $os_type;\n\t\t}\n\telse {\n\t\t$ostr = \"$os_type $os_version\";\n\t\t}\n\tmy $host = &get_display_hostname();\n\tmy $ver = &get_webmin_version();\n\t$title = $gconfig{'nohostname'} ? $text{'main_title2'} :\n\t\t $gconfig{'showhost'} ? &text('main_title3', $ver, $ostr) :\n\t\t\t\t\t&text('main_title', $ver, $host, $ostr);\n\tif ($gconfig{'showlogin'}) {\n\t\t$title = $remote_user.($title ? \" : \".$title : \"\");\n\t\t}\n\tif ($gconfig{'showhost'}) {\n\t\t$title = $host.($title ? \" : \".$title : \"\");\n\t\t}\n\t}\nreturn $title;\n}\n\n=head2 get_html_status_line(text-only)\n\nReturns HTML for a script block that sets the status line, or if text-only\nis set to 1, just return the status line text.\n\n=cut\nsub get_html_status_line\n{\nmy ($textonly) = @_;\nif (($gconfig{'sysinfo'} != 0 || !$remote_user) && !$textonly) {\n\t# Disabled in this mode\n\treturn undef;\n\t}\nmy $os_type = $gconfig{'real_os_type'} || $gconfig{'os_type'};\nmy $os_version = $gconfig{'real_os_version'} || $gconfig{'os_version'};\nmy $line = &text('header_statusmsg',\n\t\t ($ENV{'ANONYMOUS_USER'} ? \"Anonymous user\"\n\t\t\t\t\t   : $remote_user).\n\t\t ($ENV{'SSL_USER'} ? \" (SSL certified)\" :\n\t\t  $ENV{'LOCAL_USER'} ? \" (Local user)\" : \"\"),\n\t\t $text{'programname'},\n\t\t &get_webmin_version(),\n\t\t &get_display_hostname(),\n\t\t $os_type.($os_version eq \"*\" ? \"\" :\" $os_version\"));\nif ($textonly) {\n\treturn $line;\n\t}\nelse {\n\t$line =~ s/\\r|\\n//g;\n\treturn \"<script type='text/javascript'>\\n\".\n\t       \"window.defaultStatus=\\\"\".&quote_escape($line).\"\\\";\\n\".\n\t       \"</script>\\n\";\n\t}\n}\n\n=head2 popup_header([title], [head-stuff], [body-stuff], [no-body])\n\nOutputs a page header, suitable for a popup window. If no title is given,\nabsolutely no decorations are output. Also useful in framesets. The parameters\nare :\n\n=item title - Title text for the popup window.\n\n=item head-stuff - HTML to appear in the <head> section.\n\n=item body-stuff - HTML attributes to be include in the <body> tag.\n\n=item no-body - If set to 1, don't generate a body tag\n\n=cut\nsub popup_header\n{\nreturn if ($main::done_webmin_header++);\nmy $ll;\nmy $charset = defined($main::force_charset) ? $main::force_charset\n\t\t\t\t\t    : &get_charset();\n&PrintHeader($charset);\n&load_theme_library();\nif (defined(&theme_popup_header)) {\n\t&theme_popup_header(@_);\n\t$miniserv::page_capture = 1;\n\treturn;\n\t}\nprint \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\";\nprint \"<html>\\n\";\nprint \"<head>\\n\";\nif (defined(&theme_popup_prehead)) {\n\t&theme_popup_prehead(@_);\n\t}\nprint \"<title>$_[0]</title>\\n\";\nprint $_[1];\nprint \"$tconfig{'headhtml'}\\n\" if ($tconfig{'headhtml'});\nif ($tconfig{'headinclude'}) {\n\tprint &read_file_contents(\n\t\t\"$theme_root_directory/$tconfig{'headinclude'}\");\n\t}\nprint \"</head>\\n\";\nmy $bgcolor = defined($tconfig{'cs_page'}) ? $tconfig{'cs_page'} :\n\t\t defined($gconfig{'cs_page'}) ? $gconfig{'cs_page'} : \"ffffff\";\nmy $link = defined($tconfig{'cs_link'}) ? $tconfig{'cs_link'} :\n\t      defined($gconfig{'cs_link'}) ? $gconfig{'cs_link'} : \"0000ee\";\nmy $text = defined($tconfig{'cs_text'}) ? $tconfig{'cs_text'} :\n\t      defined($gconfig{'cs_text'}) ? $gconfig{'cs_text'} : \"000000\";\nmy $bgimage = defined($tconfig{'bgimage'}) ? \"background='$tconfig{'bgimage'}'\"\n\t\t\t\t\t      : \"\";\nif (!$_[3]) {\n\tprint \"<body id='popup' bgcolor='#$bgcolor' link='#$link' vlink='#$link' \",\n\t      \"text='#$text' $bgimage $tconfig{'inbody'} $_[2]>\\n\";\n\tif (defined(&theme_popup_prebody)) {\n\t\t&theme_popup_prebody(@_);\n\t\t}\n\t}\n$miniserv::page_capture = 1;\n}\n\n=head2 footer([page, name]+, [noendbody])\n\nOutputs the footer for a Webmin HTML page, possibly with links back to other\npages. The links are specified by pairs of parameters, the first of which is\na link destination, and the second the link text. For example :\n\n footer('/', 'Webmin index', '', 'Module menu');\n\n=cut\nsub footer\n{\n$miniserv::page_capture = 0;\n&load_theme_library();\nmy %this_module_info = &get_module_info(&get_module_name());\nif (defined(&theme_footer)) {\n\t$module_name = &get_module_name();\t# Old themes use these\n\t%module_info = %this_module_info;\n\t&theme_footer(@_);\n\treturn;\n\t}\nfor(my $i=0; $i+1<@_; $i+=2) {\n\tmy $url = $_[$i];\n\tif ($url ne '/' || !$tconfig{'noindex'}) {\n\t\tif ($url eq '/') {\n\t\t\t$url = \"/?cat=$this_module_info{'category'}\";\n\t\t\t}\n\t\telsif ($url eq '' && &get_module_name()) {\n\t\t\t$url = \"/\".&get_module_name().\"/\".\n\t\t\t       $this_module_info{'index_link'};\n\t\t\t}\n\t\telsif ($url =~ /^\\?/ && &get_module_name()) {\n\t\t\t$url = \"/\".&get_module_name().\"/$url\";\n\t\t\t}\n\t\t$url = \"$gconfig{'webprefix'}$url\" if ($url =~ /^\\//);\n\t\tif ($i == 0) {\n\t\t\tprint \"<a href=\\\"$url\\\"><img alt=\\\"<-\\\" align='middle' border='0' src='$gconfig{'webprefix'}/images/left.gif'></a>\\n\";\n\t\t\t}\n\t\telse {\n\t\t\tprint \"&nbsp;|\\n\";\n\t\t\t}\n\t\tprint \"&nbsp;<a href=\\\"$url\\\">\",&text('main_return', $_[$i+1]),\"</a>\\n\";\n\t\t}\n\t}\nprint \"<br>\\n\";\nif (!$_[$i]) {\n\tmy $postbody = $tconfig{'postbody'};\n\tif ($postbody) {\n\t\t$postbody = replace_meta($postbody);\n\t\tprint \"$postbody\\n\";\n\t\t}\n\tif ($tconfig{'postbodyinclude'}) {\n    my ($theme, $overlay) = split(' ', $gconfig{'theme'});\n    my $file_contents = read_file_contents(\"$root_directory/$overlay/$tconfig{'postbodyinclude'}\");\n    $file_contents = replace_meta($file_contents);\n    print $file_contents;\n    }\n\tif (defined(&theme_postbody)) {\n\t\t&theme_postbody(@_);\n\t\t}\n\tprint \"</body></html>\\n\";\n\t}\n}\n\n=head2 popup_footer([no-body])\n\nOutputs html for a footer for a popup window, started by popup_header.\n\n=cut\nsub popup_footer\n{\n$miniserv::page_capture = 0;\n&load_theme_library();\nif (defined(&theme_popup_footer)) {\n\t&theme_popup_footer(@_);\n\treturn;\n\t}\nif (!$_[0]) {\n\tprint \"</body>\\n\";\n\t}\nprint \"</html>\\n\";\n}\n\n=head2 load_theme_library\n\nImmediately loads the current theme's theme.pl file. Not generally useful for\nmost module developers, as this is called automatically by the header function.\n\n=cut\nsub load_theme_library\n{\nreturn if (!$current_theme || $loaded_theme_library++);\nfor(my $i=0; $i<@theme_root_directories; $i++) {\n\tif ($theme_configs[$i]->{'functions'}) {\n\t\tdo $theme_root_directories[$i].\"/\".\n\t\t   $theme_configs[$i]->{'functions'};\n\t\t}\n\t}\n}\n\n=head2 redirect(url)\n\nOutput HTTP headers to redirect the browser to some page. The url parameter is\ntypically a relative URL like index.cgi or list_users.cgi.\n\n=cut\nsub redirect\n{\nmy $port = $ENV{'SERVER_PORT'} == 443 && uc($ENV{'HTTPS'}) eq \"ON\" ? \"\" :\n\t   $ENV{'SERVER_PORT'} == 80 && uc($ENV{'HTTPS'}) ne \"ON\" ? \"\" :\n\t\t\":$ENV{'SERVER_PORT'}\";\nmy $prot = uc($ENV{'HTTPS'}) eq \"ON\" ? \"https\" : \"http\";\nmy $wp = $gconfig{'webprefixnoredir'} ? undef : $gconfig{'webprefix'};\nmy $url;\nif ($_[0] =~ /^(http|https|ftp|gopher):/) {\n\t# Absolute URL (like http://...)\n\t$url = $_[0];\n\t}\nelsif ($_[0] =~ /^\\//) {\n\t# Absolute path (like /foo/bar.cgi)\n\tif ($gconfig{'relative_redir'}) {\n\t\t$url = \"$wp$_[0]\";\n\t\t}\n\telse {\n\t\t$url = \"$prot://$ENV{'SERVER_NAME'}$port$wp$_[0]\";\n\t\t}\n\t}\nelsif ($ENV{'SCRIPT_NAME'} =~ /^(.*)\\/[^\\/]*$/) {\n\t# Relative URL (like foo.cgi)\n\tif ($gconfig{'relative_redir'}) {\n\t\t$url = \"$wp$1/$_[0]\";\n\t\t}\n\telse {\n\t\t$url = \"$prot://$ENV{'SERVER_NAME'}$port$wp$1/$_[0]\";\n\t\t}\n\t}\nelse {\n\tif ($gconfig{'relative_redir'}) {\n\t\t$url = \"$wp$_[0]\";\n\t\t}\n\telse {\n\t\t$url = \"$prot://$ENV{'SERVER_NAME'}$port/$wp$_[0]\";\n\t\t}\n\t}\n&load_theme_library();\nif (defined(&theme_redirect)) {\n\t$module_name = &get_module_name();\t# Old themes use these\n\t%module_info = &get_module_info($module_name);\n\t&theme_redirect($_[0], $url);\n\t}\nelse {\n\tprint \"Location: $url\\n\\n\";\n\t}\n}\n\n=head2 kill_byname(name, signal)\n\nFinds a process whose command line contains the given name (such as httpd), and\nsends some signal to it. The signal can be numeric (like 9) or named\n(like KILL).\n\n=cut\nsub kill_byname\n{\nmy @pids = &find_byname($_[0]);\nreturn scalar(@pids) if (&is_readonly_mode());\n&webmin_debug_log('KILL', \"signal=$_[1] name=$_[0]\")\n\tif ($gconfig{'debug_what_procs'});\nif (@pids) { kill($_[1], @pids); return scalar(@pids); }\nelse { return 0; }\n}\n\n=head2 kill_byname_logged(name, signal)\n\nLike kill_byname, but also logs the killing.\n\n=cut\nsub kill_byname_logged\n{\nmy @pids = &find_byname($_[0]);\nreturn scalar(@pids) if (&is_readonly_mode());\nif (@pids) { &kill_logged($_[1], @pids); return scalar(@pids); }\nelse { return 0; }\n}\n\n=head2 find_byname(name)\n\nFinds processes searching for the given name in their command lines, and\nreturns a list of matching PIDs.\n\n=cut\nsub find_byname\n{\nif ($gconfig{'os_type'} =~ /-linux$/ && -r \"/proc/$$/cmdline\") {\n\t# Linux with /proc filesystem .. use cmdline files, as this is\n\t# faster than forking\n\tmy @pids;\n\topendir(PROCDIR, \"/proc\");\n\tforeach my $f (readdir(PROCDIR)) {\n\t\tif ($f eq int($f) && $f != $$) {\n\t\t\tmy $line = &read_file_contents(\"/proc/$f/cmdline\");\n\t\t\tif ($line =~ /$_[0]/) {\n\t\t\t\tpush(@pids, $f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclosedir(PROCDIR);\n\treturn @pids;\n\t}\n\nif (&foreign_check(\"proc\")) {\n\t# Call the proc module\n\t&foreign_require(\"proc\", \"proc-lib.pl\");\n\tif (defined(&proc::list_processes)) {\n\t\tmy @procs = &proc::list_processes();\n\t\tmy @pids;\n\t\tforeach my $p (@procs) {\n\t\t\tif ($p->{'args'} =~ /$_[0]/) {\n\t\t\t\tpush(@pids, $p->{'pid'});\n\t\t\t\t}\n\t\t\t}\n\t\t@pids = grep { $_ != $$ } @pids;\n\t\treturn @pids;\n\t\t}\n\t}\n\n# Fall back to running a command\nmy ($cmd, @pids);\n$cmd = $gconfig{'find_pid_command'};\n$cmd =~ s/NAME/\"$_[0]\"/g;\n$cmd = &translate_command($cmd);\n@pids = split(/\\n/, `($cmd) <$null_file 2>$null_file`);\n@pids = grep { $_ != $$ } @pids;\nreturn @pids;\n}\n\n=head2 error([message]+)\n\nDisplay an error message and exit. This should be used by CGI scripts that\nencounter a fatal error or invalid user input to notify users of the problem.\nIf error_setup has been called, the displayed error message will be prefixed\nby the message setup using that function.\n\n=cut\nsub error\n{\n$main::no_miniserv_userdb = 1;\nmy $msg = join(\"\", @_);\n$msg =~ s/<[^>]*>//g;\nif (!$main::error_must_die) {\n\tprint STDERR \"Error: \",$msg,\"\\n\";\n\t}\n&load_theme_library();\nif ($main::error_must_die) {\n\tdie @_;\n\t}\n&call_error_handlers();\nif (!$ENV{'REQUEST_METHOD'}) {\n\t# Show text-only error\n\tprint STDERR \"$text{'error'}\\n\";\n\tprint STDERR \"-----\\n\";\n\tprint STDERR ($main::whatfailed ? \"$main::whatfailed : \" : \"\"),\n\t\t     $msg,\"\\n\";\n\tprint STDERR \"-----\\n\";\n\tif ($gconfig{'error_stack'}) {\n\t\t# Show call stack\n\t\tprint STDERR $text{'error_stack'},\"\\n\";\n\t\tfor(my $i=0; my @stack = caller($i); $i++) {\n\t\t\tprint STDERR &text('error_stackline',\n\t\t\t\t$stack[1], $stack[2], $stack[3]),\"\\n\";\n\t\t\t}\n\t\t}\n\n\t}\nelsif (defined(&theme_error)) {\n\t&theme_error(@_);\n\t}\nelsif ($in{'json-error'} eq '1') {\n\tmy %jerror;\n\tmy $error_what = ($main::whatfailed ? \"$main::whatfailed: \" : \"\");\n\tmy $error_message = join(\",\", @_);\n\tmy $error = ($error_what . $error_message);\n\t%jerror = (error => $error,\n\t\t   error_fatal => 1, \n\t\t   error_what => $error_what, \n\t\t   error_message => $error_message\n\t\t  );\n\tprint_json(\\%jerror);\n\t}\nelse {\n\t&header($text{'error'}, \"\");\n\tprint \"<hr>\\n\";\n\tprint \"<h3>\",($main::whatfailed ? \"$main::whatfailed : \" : \"\"),\n\t\t     @_,\"</h3>\\n\";\n\tif ($gconfig{'error_stack'}) {\n\t\t# Show call stack\n\t\tprint \"<h3>$text{'error_stack'}</h3>\\n\";\n\t\tprint \"<table>\\n\";\n\t\tprint \"<tr> <td><b>$text{'error_file'}</b></td> \",\n\t\t      \"<td><b>$text{'error_line'}</b></td> \",\n\t\t      \"<td><b>$text{'error_sub'}</b></td> </tr>\\n\";\n\t\tfor($i=0; my @stack = caller($i); $i++) {\n\t\t\tprint \"<tr>\\n\";\n\t\t\tprint \"<td>$stack[1]</td>\\n\";\n\t\t\tprint \"<td>$stack[2]</td>\\n\";\n\t\t\tprint \"<td>$stack[3]</td>\\n\";\n\t\t\tprint \"</tr>\\n\";\n\t\t\t}\n\t\tprint \"</table>\\n\";\n\t\t}\n\tprint \"<hr>\\n\";\n\tif ($ENV{'HTTP_REFERER'} && $main::completed_referers_check) {\n\t\t&footer(\"javascript:history.back()\", $text{'error_previous'});\n\t\t}\n\telse {\n\t\t&footer();\n\t\t}\n\t}\n&unlock_all_files();\n&cleanup_tempnames();\nexit(1);\n}\n\n=head2 popup_error([message]+)\n\nThis function is almost identical to error, but displays the message with HTML\nheaders suitable for a popup window.\n\n=cut\nsub popup_error\n{\n$main::no_miniserv_userdb = 1;\n&load_theme_library();\nif ($main::error_must_die) {\n\tdie @_;\n\t}\n&call_error_handlers();\nif (defined(&theme_popup_error)) {\n\t&theme_popup_error(@_);\n\t}\nelse {\n\t&popup_header($text{'error'}, \"\");\n\tprint \"<h3>\",($main::whatfailed ? \"$main::whatfailed : \" : \"\"),@_,\"</h3>\\n\";\n\t&popup_footer();\n\t}\n&unlock_all_files();\n&cleanup_tempnames();\nexit;\n}\n\n=head2 register_error_handler(&func, arg, ...)\n\nRegister a function that will be called when this process exits, such as by\ncalling &error\n\n=cut\nsub register_error_handler\n{\nmy ($f, @args) = @_;\npush(@$error_handler_funcs, [ $f, @args ]);\n}\n\n\n=head2 call_error_handlers()\n\nInternal function to call all registered error handlers\n\n=cut\nsub call_error_handlers\n{\nmy @funcs = @$error_handler_funcs;\n$error_handler_funcs = [ ];\nforeach my $e (@funcs) {\n\tmy ($f, @args) = @$e;\n\t&$f(@args);\n\t}\n}\n\n=head2 error_setup(message)\n\nRegisters a message to be prepended to all error messages displayed by the\nerror function.\n\n=cut\nsub error_setup\n{\n$main::whatfailed = $_[0];\n}\n\n=head2 wait_for(handle, regexp, regexp, ...)\n\nReads from the input stream until one of the regexps matches, and returns the\nindex of the matching regexp, or -1 if input ended before any matched. This is\nvery useful for parsing the output of interactive programs, and can be used with\na two-way pipe to feed input to a program in response to output matched by\nthis function.\n\nIf the matching regexp contains bracketed sub-expressions, their values will\nbe placed in the global array @matches, indexed starting from 1. You cannot\nuse the Perl variables $1, $2 and so on to capture matches.\n\nExample code:\n\n $rv = wait_for($loginfh, \"username:\");\n if ($rv == -1) {\n   error(\"Didn't get username prompt\");\n }\n print $loginfh \"joe\\n\";\n $rv = wait_for($loginfh, \"password:\");\n if ($rv == -1) {\n   error(\"Didn't get password prompt\");\n }\n print $loginfh \"smeg\\n\";\n\n=cut\nsub wait_for\n{\nmy ($c, $i, $sw, $rv, $ha);\nundef($wait_for_input);\nif ($wait_for_debug) {\n\tprint STDERR \"wait_for(\",join(\",\", @_),\")\\n\";\n\t}\n$ha = &callers_package($_[0]);\nif ($wait_for_debug) {\n\tprint STDERR \"File handle=$ha fd=\",fileno($ha),\"\\n\";\n\t}\n$codes =\n\"my \\$hit;\\n\".\n\"while(1) {\\n\".\n\" if ((\\$c = getc(\\$ha)) eq \\\"\\\") { return -1; }\\n\".\n\" \\$wait_for_input .= \\$c;\\n\";\nif ($wait_for_debug) {\n\t$codes .= \"print STDERR \\$wait_for_input,\\\"\\\\n\\\";\";\n\t}\nfor($i=1; $i<@_; $i++) {\n        $sw = $i>1 ? \"elsif\" : \"if\";\n        $codes .= \" $sw (\\$wait_for_input =~ /$_[$i]/i) { \\$hit = $i-1; }\\n\";\n        }\n$codes .=\n\" if (defined(\\$hit)) {\\n\".\n\"  \\@matches = (-1, \\$1, \\$2, \\$3, \\$4, \\$5, \\$6, \\$7, \\$8, \\$9);\\n\".\n\"  return \\$hit;\\n\".\n\"  }\\n\".\n\" }\\n\";\n$rv = eval $codes;\nif ($@) {\n\t&error(\"wait_for error : $@\\n\");\n\t}\nreturn $rv;\n}\n\n=head2 fast_wait_for(handle, string, string, ...)\n\nThis function behaves very similar to wait_for (documented above), but instead\nof taking regular expressions as parameters, it takes strings. As soon as the\ninput contains one of them, it will return the index of the matching string.\nIf the input ends before any match, it returns -1.\n\n=cut\nsub fast_wait_for\n{\nmy ($inp, $maxlen, $ha, $i, $c, $inpl);\nfor($i=1; $i<@_; $i++) {\n\t$maxlen = length($_[$i]) > $maxlen ? length($_[$i]) : $maxlen;\n\t}\n$ha = $_[0];\nwhile(1) {\n\tif (($c = getc($ha)) eq \"\") {\n\t\t&error(\"fast_wait_for read error : $!\");\n\t\t}\n\t$inp .= $c;\n\tif (length($inp) > $maxlen) {\n\t\t$inp = substr($inp, length($inp)-$maxlen);\n\t\t}\n\t$inpl = length($inp);\n\tfor($i=1; $i<@_; $i++) {\n\t\tif ($_[$i] eq substr($inp, $inpl-length($_[$i]))) {\n\t\t\treturn $i-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n=head2 has_command(command)\n\nReturns the full path to the executable if some command is in the path, or\nundef if not found. If the given command is already an absolute path and\nexists, then the same path will be returned.\n\n=cut\nsub has_command\n{\nif (!$_[0]) { return undef; }\nif (exists($main::has_command_cache{$_[0]})) {\n\treturn $main::has_command_cache{$_[0]};\n\t}\nmy $rv = undef;\nmy $slash = $gconfig{'os_type'} eq 'windows' ? '\\\\' : '/';\nif ($_[0] =~ /^\\// || $_[0] =~ /^[a-z]:[\\\\\\/]/i) {\n\t# Absolute path given - just use it\n\tmy $t = &translate_filename($_[0]);\n\t$rv = (-x $t && !-d _) ? $_[0] : undef;\n\t}\nelse {\n\t# Check each directory in the path\n\tmy %donedir;\n\tforeach my $d (split($path_separator, $ENV{'PATH'})) {\n\t\tnext if ($donedir{$d}++);\n\t\t$d =~ s/$slash$// if ($d ne $slash);\n\t\tmy $t = &translate_filename(\"$d/$_[0]\");\n\t\tif (-x $t && !-d _) {\n\t\t\t$rv = $d.$slash.$_[0];\n\t\t\tlast;\n\t\t\t}\n\t\tif ($gconfig{'os_type'} eq 'windows') {\n\t\t\tforeach my $sfx (\".exe\", \".com\", \".bat\") {\n\t\t\t\tmy $t = &translate_filename(\"$d/$_[0]\").$sfx;\n\t\t\t\tif (-r $t && !-d _) {\n\t\t\t\t\t$rv = $d.$slash.$_[0].$sfx;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n$main::has_command_cache{$_[0]} = $rv;\nreturn $rv;\n}\n\n=head2 make_date(seconds, [date-only], [fmt])\n\nConverts a Unix date/time in seconds to a human-readable form, by default\nformatted like dd/mmm/yyyy hh:mm:ss. Parameters are :\n\n=item seconds - Unix time is seconds to convert.\n\n=item date-only - If set to 1, exclude the time from the returned string.\n\n=item fmt - Optional, one of dd/mon/yyyy, dd/mm/yyyy, mm/dd/yyyy or yyyy/mm/dd\n\n=cut\nsub make_date\n{\n&load_theme_library();\nif (defined(&theme_make_date) &&\n    $main::header_content_type eq \"text/html\" &&\n    $main::webmin_script_type eq \"web\") {\n\treturn &theme_make_date(@_);\n\t}\nmy ($secs, $only, $fmt) = @_;\nmy @tm = localtime($secs);\nmy $date;\nif (!$fmt) {\n\t$fmt = $gconfig{'dateformat'} || 'dd/mon/yyyy';\n\t}\nif ($fmt eq 'dd/mon/yyyy') {\n\t$date = sprintf \"%2.2d/%s/%4.4d\",\n\t\t\t$tm[3], $text{\"smonth_\".($tm[4]+1)}, $tm[5]+1900;\n\t}\nelsif ($fmt eq 'dd/mm/yyyy') {\n\t$date = sprintf \"%2.2d/%2.2d/%4.4d\", $tm[3], $tm[4]+1, $tm[5]+1900;\n\t}\nelsif ($fmt eq 'mm/dd/yyyy') {\n\t$date = sprintf \"%2.2d/%2.2d/%4.4d\", $tm[4]+1, $tm[3], $tm[5]+1900;\n\t}\nelsif ($fmt eq 'yyyy/mm/dd') {\n\t$date = sprintf \"%4.4d/%2.2d/%2.2d\", $tm[5]+1900, $tm[4]+1, $tm[3];\n\t}\nelsif ($fmt eq 'd. mon yyyy') {\n\t$date = sprintf \"%d. %s %4.4d\",\n\t\t\t$tm[3], $text{\"smonth_\".($tm[4]+1)}, $tm[5]+1900;\n\t}\nelsif ($fmt eq 'dd.mm.yyyy') {\n\t$date = sprintf \"%2.2d.%2.2d.%4.4d\", $tm[3], $tm[4]+1, $tm[5]+1900;\n\t}\nelsif ($fmt eq 'yyyy-mm-dd') {\n\t$date = sprintf \"%4.4d-%2.2d-%2.2d\", $tm[5]+1900, $tm[4]+1, $tm[3];\n\t}\nif (!$only) {\n\t$date .= sprintf \" %2.2d:%2.2d\", $tm[2], $tm[1];\n\t}\nreturn $date;\n}\n\n=head2 file_chooser_button(input, type, [form], [chroot], [addmode])\n\nReturn HTML for a button that pops up a file chooser when clicked, and places\nthe selected filename into another HTML field. The parameters are :\n\n=item input - Name of the form field to store the filename in.\n\n=item type - 0 for file or directory chooser, or 1 for directory only.\n\n=item form - Index of the form containing the button.\n\n=item chroot - If set to 1, the chooser will be limited to this directory.\n\n=item addmode - If set to 1, the selected filename will be appended to the text box instead of replacing it's contents.\n\n=cut\nsub file_chooser_button\n{\nreturn &theme_file_chooser_button(@_)\n\tif (defined(&theme_file_chooser_button));\nmy $form = defined($_[2]) ? $_[2] : 0;\nmy $chroot = defined($_[3]) ? $_[3] : \"/\";\nmy $add = int($_[4]);\nmy ($w, $h) = (400, 300);\nif ($gconfig{'db_sizefile'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizefile'});\n\t}\nreturn \"<input type=button onClick='ifield = form.$_[0]; chooser = window.open(\\\"$gconfig{'webprefix'}/chooser.cgi?add=$add&type=$_[1]&chroot=$chroot&file=\\\"+encodeURIComponent(ifield.value), \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=no,resizable=yes,width=$w,height=$h\\\"); chooser.ifield = ifield; window.ifield = ifield' value=\\\"...\\\">\\n\";\n}\n\n=head2 popup_window_button(url, width, height, scrollbars?, &field-mappings)\n\nReturns HTML for a button that will popup a chooser window of some kind. The\nparameters are :\n\n=item url - Base URL of the popup window's contents\n\n=item width - Width of the window in pixels\n\n=item height - Height in pixels\n\n=item scrollbars - Set to 1 if the window should have scrollbars\n\n=item fields - See below\n\n=item disabled - The button is disabled if non-zero\n\nThe field-mappings parameter is an array ref of array refs containing\n\n=item - Attribute to assign field to in the popup window\n\n=item - Form field name\n\n=item - CGI parameter to URL for value, if any\n\n=cut\nsub popup_window_button\n{\nreturn &theme_popup_window_button(@_) if (defined(&theme_popup_window_button));\nmy ($url, $w, $h, $scroll, $fields, $disabled) = @_;\nmy $scrollyn = $scroll ? \"yes\" : \"no\";\nmy $rv = \"<input type=button onClick='\";\nforeach my $m (@$fields) {\n\t$rv .= \"$m->[0] = form.$m->[1]; \";\n\t}\nmy $sep = $url =~ /\\?/ ? \"&\" : \"?\";\n$rv .= \"chooser = window.open(\\\"$url\\\"\";\nforeach my $m (@$fields) {\n\tif ($m->[2]) {\n\t\t$rv .= \"+\\\"$sep$m->[2]=\\\"+escape($m->[0].value)\";\n\t\t$sep = \"&\";\n\t\t}\n\t}\n$rv .= \", \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=$scrollyn,resizable=yes,width=$w,height=$h\\\"); \";\nforeach my $m (@$fields) {\n\t$rv .= \"chooser.$m->[0] = $m->[0]; \";\n\t$rv .= \"window.$m->[0] = $m->[0]; \";\n\t}\n$rv .= \"' value=\\\"...\\\"\";\nif ($disabled) {\n\t$rv .= \" disabled\";\n\t}\n$rv .= \">\";\nreturn $rv;\n}\n\n=head2 popup_window_link(url, title, width, height, scrollbar, &field-mappings)\n\nReturns HTML for a link that will popup a chooser window of some kind. The\nparameters are :\n\n=item url - Base URL of the popup window's contents\n\n=item title - Text of the link\n\n=item width - Width of the window in pixels\n\n=item height - Height in pixels\n\n=item scrollbars - Set to 1 if the window should have scrollbars\n\n=item fields - See below\n\nThe field-mappings parameter is an array ref of array refs containing\n\n=item - Attribute to assign field to in the popup window\n\n=item - Form field name\n\n=item - CGI parameter to URL for value, if any\n\n=cut\nsub popup_window_link\n{\nreturn &theme_popup_window_link(@_) if (defined(&theme_popup_window_link));\nmy ($url, $title, $w, $h, $scrollyn, $fields) = @_;\nmy $scrollyn = $scroll ? \"yes\" : \"no\";\nmy $rv = \"onClick='\";\nforeach my $m (@$fields) {\n\t$rv .= \"$m->[0] = form.$m->[1]; \";\n\t}\nmy $sep = $url =~ /\\?/ ? \"&\" : \"?\";\n$rv .= \"chooser = window.open(\\\"$url\\\"\";\nforeach my $m (@$fields) {\n\tif ($m->[2]) {\n\t\t$rv .= \"+\\\"$sep$m->[2]=\\\"+escape($m->[0].value)\";\n\t\t$sep = \"&\";\n\t\t}\n\t}\n$rv .= \", \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=$scrollyn,resizable=yes,width=$w,height=$h\\\"); \";\nforeach my $m (@$fields) {\n\t$rv .= \"chooser.$m->[0] = $m->[0]; \";\n\t$rv .= \"window.$m->[0] = $m->[0]; \";\n\t}\n$rv .= \"return false;'\";\nreturn &ui_link($url, $title, undef, $rv);\n}\n\n=head2 read_acl(&user-module-hash, &user-list-hash, [&only-users])\n\nReads the Webmin acl file into the given hash references. The first is indexed\nby a combined key of username,module , with the value being set to 1 when\nthe user has access to that module. The second is indexed by username, with\nthe value being an array ref of allowed modules.\n\nThis function is deprecated in favour of foreign_available, which performs a\nmore comprehensive check of module availability.\n\nIf the only-users array ref parameter is given, the results may be limited to\nusers in that list of names.\n\n=cut\nsub read_acl\n{\nmy ($usermod, $userlist, $only) = @_;\nif (!%main::acl_hash_cache) {\n\t# Read from local files\n\tlocal $_;\n\topen(ACL, &acl_filename());\n\twhile(<ACL>) {\n\t\tif (/^([^:]+):\\s*(.*)/) {\n\t\t\tmy $user = $1;\n\t\t\tmy @mods = split(/\\s+/, $2);\n\t\t\tforeach my $m (@mods) {\n\t\t\t\t$main::acl_hash_cache{$user,$m}++;\n\t\t\t\t}\n\t\t\t$main::acl_array_cache{$user} = \\@mods;\n\t\t\t}\n\t\t}\n\tclose(ACL);\n\t}\n%$usermod = %main::acl_hash_cache if ($usermod);\n%$userlist = %main::acl_array_cache if ($userlist);\n\n# Read from user DB\nmy $userdb = &get_userdb_string();\nmy ($dbh, $proto, $prefix, $args) =\n\t$userdb ? &connect_userdb($userdb) : ( );\nif (ref($dbh)) {\n\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Select usernames and modules from SQL DB\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select webmin_user.name,webmin_user_attr.value \".\n\t\t\t\"from webmin_user,webmin_user_attr \".\n\t\t\t\"where webmin_user.id = webmin_user_attr.id \".\n\t\t\t\"and webmin_user_attr.attr = 'modules' \".\n\t\t\t($only ? \" and webmin_user.name in (\".\n\t\t\t\t join(\",\", map { \"'$_'\" } @$only).\")\" : \"\"));\n\t\tif ($cmd && $cmd->execute()) {\n\t\t\twhile(my ($user, $mods) = $cmd->fetchrow()) {\n\t\t\t\tmy @mods = split(/\\s+/, $mods);\n\t\t\t\tforeach my $m (@mods) {\n\t\t\t\t\t$usermod->{$user,$m}++ if ($usermod);\n\t\t\t\t\t}\n\t\t\t\t$userlist->{$user} = \\@mods if ($userlist);\n\t\t\t\t}\n\t\t\t}\n\t\t$cmd->finish() if ($cmd);\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Find users in LDAP\n\t\tmy $filter = '(objectClass='.$args->{'userclass'}.')';\n\t\tif ($only) {\n\t\t\tmy $ufilter =\n\t\t\t\t\"(|\".join(\"\", map { \"(cn=$_)\" } @$only).\")\";\n\t\t\t$filter = \"(&\".$filter.$ufilter.\")\";\n\t\t\t}\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => $filter,\n\t\t\tscope => 'sub',\n\t\t\tattrs => [ 'cn', 'webminModule' ]);\n\t\tif ($rv && !$rv->code) {\n\t\t\tforeach my $u ($rv->all_entries) {\n\t\t\t\tmy $user = $u->get_value('cn');\n\t\t\t\tmy @mods =$u->get_value('webminModule');\n\t\t\t\tforeach my $m (@mods) {\n\t\t\t\t\t$usermod->{$user,$m}++ if ($usermod);\n\t\t\t\t\t}\n\t\t\t\t$userlist->{$user} = \\@mods if ($userlist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($userdb, $dbh);\n\t}\n}\n\n=head2 acl_filename\n\nReturns the file containing the webmin ACL, which is usually\n/etc/webmin/webmin.acl.\n\n=cut\nsub acl_filename\n{\nreturn \"$config_directory/webmin.acl\";\n}\n\n=head2 acl_check\n\nDoes nothing, but kept around for compatibility.\n\n=cut\nsub acl_check\n{\n}\n\n=head2 get_miniserv_config(&hash)\n\nReads the Webmin webserver's (miniserv.pl) configuration file, usually located\nat /etc/webmin/miniserv.conf, and stores its names and values in the given\nhash reference.\n\n=cut\nsub get_miniserv_config\n{\nreturn &read_file_cached(\n\t$ENV{'MINISERV_CONFIG'} || \"$config_directory/miniserv.conf\", $_[0]);\n}\n\n=head2 put_miniserv_config(&hash)\n\nWrites out the Webmin webserver configuration file from the contents of\nthe given hash ref. This should be initially populated by get_miniserv_config,\nlike so :\n\n get_miniserv_config(\\%miniserv);\n $miniserv{'port'} = 10005;\n put_miniserv_config(\\%miniserv);\n restart_miniserv();\n\n=cut\nsub put_miniserv_config\n{\n&write_file($ENV{'MINISERV_CONFIG'} || \"$config_directory/miniserv.conf\",\n\t    $_[0]);\n}\n\n=head2 restart_miniserv([nowait], [ignore-errors])\n\nKill the old miniserv process and re-start it, then optionally waits for\nit to restart. This will apply all configuration settings.\n\n=cut\nsub restart_miniserv\n{\nmy ($nowait, $ignore) = @_;\nreturn undef if (&is_readonly_mode());\nmy %miniserv;\n&get_miniserv_config(\\%miniserv) || return;\nif ($main::webmin_script_type eq 'web' && !$ENV{\"MINISERV_CONFIG\"} &&\n    !$ENV{'MINISERV_PID'}) {\n\t# Running under some web server other than miniserv, so do nothing\n\treturn;\n\t}\n\nmy $i;\nif ($gconfig{'os_type'} ne 'windows') {\n\t# On Unix systems, we can restart with a signal\n\tmy ($pid, $addr, $i);\n\t$miniserv{'inetd'} && return;\n\tmy @oldst = stat($miniserv{'pidfile'});\n\t$pid = $ENV{'MINISERV_PID'};\n\tif (!$pid || !kill(0, $pid)) {\n\t\tif (!open(PID, $miniserv{'pidfile'})) {\n\t\t\tprint STDERR \"PID file $miniserv{'pidfile'} does \",\n\t\t\t\t     \"not exist\\n\" if (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\tchop($pid = <PID>);\n\t\tclose(PID);\n\t\tif (!$pid) {\n\t\t\tprint STDERR \"Invalid PID file $miniserv{'pidfile'}\\n\"\n\t\t\t\tif (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\tif (!kill(0, $pid)) {\n\t\t\tprint STDERR \"PID $pid from file $miniserv{'pidfile'} \",\n\t\t\t             \"is not valid\\n\" if (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t# Just signal miniserv to restart\n\tif (!&kill_logged('HUP', $pid)) {\n\t\t&error(\"Incorrect Webmin PID $pid\") if (!$ignore);\n\t\t}\n\n\t# Wait till new PID is written, indicating a restart\n\tfor($i=0; $i<60; $i++) {\n\t\tsleep(1);\n\t\tmy @newst = stat($miniserv{'pidfile'});\n\t\tlast if ($newst[9] != $oldst[9]);\n\t\t}\n\t$i < 60 || $ignore || &error(\"Webmin server did not write new PID file\");\n\n\t## Totally kill the process and re-run it\n\t#$SIG{'TERM'} = 'IGNORE';\n\t#&kill_logged('TERM', $pid);\n\t#&system_logged(\"$config_directory/start >/dev/null 2>&1 </dev/null\");\n\t}\nelse {\n\t# On Windows, we need to use the flag file\n\topen(TOUCH, \">$miniserv{'restartflag'}\");\n\tclose(TOUCH);\n\t}\n\nif (!$nowait) {\n\t# Wait for miniserv to come back up\n\tmy $addr = $miniserv{'bind'} || \"127.0.0.1\";\n\tmy $ok = 0;\n\tfor($i=0; $i<20; $i++) {\n\t\tmy $err;\n\t\tsleep(1);\n\t\t&open_socket($addr, $miniserv{'port'}, STEST, \\$err);\n\t\tclose(STEST);\n\t\tlast if (!$err && ++$ok >= 2);\n\t\t}\n\t$i < 20 || $ignore || &error(\"Failed to restart Webmin server!\");\n\t}\n}\n\n=head2 reload_miniserv([ignore-errors])\n\nSends a USR1 signal to the miniserv process, telling it to read-read it's\nconfiguration files. Not all changes will be applied though, such as the\nIP addresses and ports to accept connections on.\n\n=cut\nsub reload_miniserv\n{\nmy ($ignore) = @_;\nreturn undef if (&is_readonly_mode());\nmy %miniserv;\n&get_miniserv_config(\\%miniserv) || return;\nif ($main::webmin_script_type eq 'web' && !$ENV{\"MINISERV_CONFIG\"} &&\n    !$ENV{'MINISERV_PID'}) {\n\t# Running under some web server other than miniserv, so do nothing\n\treturn;\n\t}\n\nif ($gconfig{'os_type'} ne 'windows') {\n\t# Send a USR1 signal to re-read the config\n\tmy ($pid, $addr, $i);\n\t$miniserv{'inetd'} && return;\n\t$pid = $ENV{'MINISERV_PID'};\n\tif (!$pid || !kill(0, $pid)) {\n\t\tif (!open(PID, $miniserv{'pidfile'})) {\n\t\t\tprint STDERR \"PID file $miniserv{'pidfile'} does \",\n\t\t\t\t     \"not exist\\n\" if (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\tchop($pid = <PID>);\n\t\tclose(PID);\n\t\tif (!$pid) {\n\t\t\tprint STDERR \"Invalid PID file $miniserv{'pidfile'}\\n\"\n\t\t\t\tif (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\tif (!kill(0, $pid)) {\n\t\t\tprint STDERR \"PID $pid from file $miniserv{'pidfile'} \",\n\t\t\t             \"is not valid\\n\" if (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\tif (!&kill_logged('USR1', $pid)) {\n\t\t&error(\"Incorrect Webmin PID $pid\") if (!$ignore);\n\t\t}\n\n\t# Make sure this didn't kill Webmin!\n\tsleep(1);\n\tif (!kill(0, $pid)) {\n\t\tprint STDERR \"USR1 signal killed Webmin - restarting\\n\"\n\t\t\tif (!$ignore);\n\t\t&system_logged(\"$config_directory/start >/dev/null 2>&1 </dev/null\");\n\t\t}\n\t}\nelse {\n\t# On Windows, we need to use the flag file\n\topen(TOUCH, \">$miniserv{'reloadflag'}\");\n\tclose(TOUCH);\n\t}\n}\n\n=head2 check_os_support(&minfo, [os-type, os-version], [api-only])\n\nReturns 1 if some module is supported on the current operating system, or the\nOS supplies as parameters. The parameters are :\n\n=item minfo - A hash ref of module information, as returned by get_module_info\n\n=item os-type - The Webmin OS code to use instead of the system's real OS, such as redhat-linux\n\n=item os-version - The Webmin OS version to use, such as 13.0\n\n=item api-only - If set to 1, considers a module supported if it provides an API to other modules on this OS, even if the majority of its functionality is not supported.\n\n=cut\nsub check_os_support\n{\nmy $oss = $_[0]->{'os_support'};\nif ($_[3] && $oss && $_[0]->{'api_os_support'}) {\n\t# May provide usable API\n\t$oss .= \" \".$_[0]->{'api_os_support'};\n\t}\nif ($_[0]->{'nozone'} && &running_in_zone()) {\n\t# Not supported in a Solaris Zone\n\treturn 0;\n\t}\nif ($_[0]->{'novserver'} && &running_in_vserver()) {\n\t# Not supported in a Linux Vserver\n\treturn 0;\n\t}\nif ($_[0]->{'noopenvz'} && &running_in_openvz()) {\n\t# Not supported in an OpenVZ container\n\treturn 0;\n\t}\nreturn 1 if (!$oss || $oss eq '*');\nmy $osver = $_[2] || $gconfig{'os_version'};\nmy $ostype = $_[1] || $gconfig{'os_type'};\nmy $anyneg = 0;\nwhile(1) {\n\tmy ($os, $ver, $codes);\n\tmy ($neg) = ($oss =~ s/^!//);\t# starts with !\n\t$anyneg++ if ($neg);\n\tif ($oss =~ /^([^\\/\\s]+)\\/([^\\{\\s]+)\\{([^\\}]*)\\}\\s*(.*)$/) {\n\t\t# OS/version{code}\n\t\t$os = $1; $ver = $2; $codes = $3; $oss = $4;\n\t\t}\n\telsif ($oss =~ /^([^\\/\\s]+)\\/([^\\/\\s]+)\\s*(.*)$/) {\n\t\t# OS/version\n\t\t$os = $1; $ver = $2; $oss = $3;\n\t\t}\n\telsif ($oss =~ /^([^\\{\\s]+)\\{([^\\}]*)\\}\\s*(.*)$/) {\n\t\t# OS/{code}\n\t\t$os = $1; $codes = $2; $oss = $3;\n\t\t}\n\telsif ($oss =~ /^\\{([^\\}]*)\\}\\s*(.*)$/) {\n\t\t# {code}\n\t\t$codes = $1; $oss = $2;\n\t\t}\n\telsif ($oss =~ /^(\\S+)\\s*(.*)$/) {\n\t\t# OS\n\t\t$os = $1; $oss = $2;\n\t\t}\n\telse { last; }\n\tnext if ($os && !($os eq $ostype ||\n\t\t\t  $ostype =~ /^(\\S+)-(\\S+)$/ && $os eq \"*-$2\"));\n\tif ($ver =~ /^([0-9\\.]+)\\-([0-9\\.]+)$/) {\n\t\tnext if ($osver < $1 || $osver > $2);\n\t\t}\n\telsif ($ver =~ /^([0-9\\.]+)\\-\\*$/) {\n\t\tnext if ($osver < $1);\n\t\t}\n\telsif ($ver =~ /^\\*\\-([0-9\\.]+)$/) {\n\t\tnext if ($osver > $1);\n\t\t}\n\telsif ($ver) {\n\t\tnext if ($ver ne $osver);\n\t\t}\n\tnext if ($codes && !eval $codes);\n\treturn !$neg;\n\t}\nreturn $anyneg;\n}\n\n=head2 http_download(host, port, page, destfile, [&error], [&callback], [sslmode], [user], [pass], [timeout], [osdn-convert], [no-cache], [&headers])\n\nDownloads data from a HTTP url to a local file or string. The parameters are :\n\n=item host - The hostname part of the URL, such as www.google.com\n\n=item port - The HTTP port number, such as 80\n\n=item page - The filename part of the URL, like /index.html\n\n=item destfile - The local file to save the URL data to, like /tmp/index.html. This can also be a scalar reference, in which case the data will be appended to that scalar.\n\n=item error - If set to a scalar ref, the function will store any error message in this scalar and return 0 on failure, or 1 on success. If not set, it will simply call the error function if the download fails.\n\n=item callback - If set to a function ref, it will be called after each block of data is received. This is typically set to \\&progress_callback, for printing download progress.\n\n=item sslmode - If set to 1, an HTTPS connection is used instead of HTTP.\n\n=item user - If set, HTTP authentication is done with this username.\n\n=item pass - The HTTP password to use with the username above.\n\n=item timeout - A timeout in seconds to wait for the TCP connection to be established before failing.\n\n=item osdn-convert - If set to 1, URL for downloads from sourceforge are converted to use an appropriate mirror site.\n\n=item no-cache - If set to 1, Webmin's internal caching for this URL is disabled.\n\n=item headers - If set to a hash ref of additional HTTP headers, they will be added to the request.\n\n=cut\nsub http_download\n{\nmy ($host, $port, $page, $dest, $error, $cbfunc, $ssl, $user, $pass,\n    $timeout, $osdn, $nocache, $headers) = @_;\nif ($gconfig{'debug_what_net'}) {\n\t&webmin_debug_log('HTTP', \"host=$host port=$port page=$page ssl=$ssl\".\n\t\t\t\t  ($user ? \" user=$user pass=$pass\" : \"\").\n\t\t\t\t  (ref($dest) ? \"\" : \" dest=$dest\"));\n\t}\nif ($osdn) {\n\t# Convert OSDN URL first\n\tmy $prot = $ssl ? \"https://\" : \"http://\";\n\tmy $portstr = $ssl && $port == 443 ||\n\t\t\t !$ssl && $port == 80 ? \"\" : \":$port\";\n\t($host, $port, $page, $ssl) = &parse_http_url(\n\t\t&convert_osdn_url($prot.$host.$portstr.$page));\n\t}\n\n# Check if we already have cached the URL\nmy $url = ($ssl ? \"https://\" : \"http://\").$host.\":\".$port.$page;\nmy $cfile = &check_in_http_cache($url);\nif ($cfile && !$nocache) {\n\t# Yes! Copy to dest file or variable\n\t&$cbfunc(6, $url) if ($cbfunc);\n\tif (ref($dest)) {\n\t\t&open_readfile(CACHEFILE, $cfile);\n\t\tlocal $/ = undef;\n\t\t$$dest = <CACHEFILE>;\n\t\tclose(CACHEFILE);\n\t\t}\n\telse {\n\t\t&copy_source_dest($cfile, $dest);\n\t\t}\n\treturn;\n\t}\n\n# Build headers\nmy @headers;\npush(@headers, [ \"Host\", $host ]);\npush(@headers, [ \"User-agent\", \"Webmin\" ]);\npush(@headers, [ \"Accept-language\", \"en\" ]);\nif ($user) {\n\tmy $auth = &encode_base64(\"$user:$pass\");\n\t$auth =~ tr/\\r\\n//d;\n\tpush(@headers, [ \"Authorization\", \"Basic $auth\" ]);\n\t}\nforeach my $hname (keys %$headers) {\n\tpush(@headers, [ $hname, $headers->{$hname} ]);\n\t}\n\n# Actually download it\n$main::download_timed_out = undef;\nlocal $SIG{ALRM} = \\&download_timeout;\n$timeout = 60 if (!defined($timeout));\nalarm($timeout) if ($timeout);\nmy $h = &make_http_connection($host, $port, $ssl, \"GET\", $page, \\@headers);\nalarm(0) if ($timeout);\n$h = $main::download_timed_out if ($main::download_timed_out);\nif (!ref($h)) {\n\tif ($error) { $$error = $h; return; }\n\telse { &error(&html_escape($h)); }\n\t}\n&complete_http_download($h, $dest, $error, $cbfunc, $osdn, $host, $port,\n\t\t\t$headers, $ssl, $nocache, $timeout);\nif ((!$error || !$$error) && !$nocache) {\n\t&write_to_http_cache($url, $dest);\n\t}\n}\n\n=head2 complete_http_download(handle, destfile, [&error], [&callback], [osdn], [oldhost], [oldport], [&send-headers], [old-ssl], [no-cache], [timeout])\n\nDo a HTTP download, after the headers have been sent. For internal use only,\ntypically called by http_download.\n\n=cut\nsub complete_http_download\n{\nmy ($h, $destfile, $error, $cbfunc, $osdn, $oldhost, $oldport, $headers,\n    $oldssl, $nocache, $timeout) = @_;\nlocal ($line, %header, @headers, $s);  # Kept local so that callback funcs\n\t\t\t\t       # can access them.\n\n# read headers\n$timeout = 60 if (!defined($timeout));\nalarm($timeout) if ($timeout);\n($line = &read_http_connection($h)) =~ tr/\\r\\n//d;\nif ($line !~ /^HTTP\\/1\\..\\s+(200|30[0-9]|400)(\\s+|$)/) {\n\talarm(0) if ($timeout);\n\t&close_http_connection($h);\n\tif ($error) { ${$error} = $line; return; }\n\telse { &error(\"Download failed : \".&html_escape($line)); }\n\t}\nmy $rcode = $1;\n&$cbfunc(1, $rcode >= 300 && $rcode < 400 ? 1 : 0)\n\tif ($cbfunc);\nwhile(1) {\n\t$line = &read_http_connection($h);\n\t$line =~ tr/\\r\\n//d;\n\t$line =~ /^(\\S+):\\s*(.*)$/ || last;\n\t$header{lc($1)} = $2;\n\tpush(@headers, [ lc($1), $2 ]);\n\t}\nalarm(0) if ($timeout);\nif ($main::download_timed_out) {\n\t&close_http_connection($h);\n\tif ($error) { ${$error} = $main::download_timed_out; return 0; }\n\telse { &error($main::download_timed_out); }\n\t}\n&$cbfunc(2, $header{'content-length'}) if ($cbfunc);\nif ($rcode >= 300 && $rcode < 400) {\n\t# follow the redirect\n\t&$cbfunc(5, $header{'location'}) if ($cbfunc);\n\tmy ($host, $port, $page, $ssl);\n\tif ($header{'location'} =~ /^(http|https):\\/\\/([^:]+):(\\d+)(\\/.*)?$/) {\n\t\t$ssl = $1 eq 'https' ? 1 : 0;\n\t\t$host = $2;\n\t\t$port = $3;\n\t\t$page = $4 || \"/\";\n\t\t}\n\telsif ($header{'location'} =~ /^(http|https):\\/\\/([^:\\/]+)(\\/.*)?$/) {\n\t\t$ssl = $1 eq 'https' ? 1 : 0;\n\t\t$host = $2;\n\t\t$port = $ssl ? 443 : 80;\n\t\t$page = $3 || \"/\";\n\t\t}\n\telsif ($header{'location'} =~ /^\\// && $_[5]) {\n\t\t# Relative to same server\n\t\t$host = $_[5];\n\t\t$port = $_[6];\n\t\t$ssl = $_[8];\n\t\t$page = $header{'location'};\n\t\t}\n\telsif ($header{'location'}) {\n\t\t# Assume relative to same dir .. not handled\n\t\t&close_http_connection($h);\n\t\tif ($error) { ${$error} = \"Invalid Location header $header{'location'}\"; return; }\n\t\telse { &error(\"Invalid Location header \".\n\t\t\t      &html_escape($header{'location'})); }\n\t\t}\n\telse {\n\t\t&close_http_connection($h);\n\t\tif ($error) { ${$error} = \"Missing Location header\"; return; }\n\t\telse { &error(\"Missing Location header\"); }\n\t\t}\n\tmy $params;\n\t($page, $params) = split(/\\?/, $page);\n\t$page =~ s/ /%20/g;\n\t$page .= \"?\".$params if (defined($params));\n\t&http_download($host, $port, $page, $destfile, $error, $cbfunc, $ssl,\n\t\t       undef, undef, undef, $_[4], $_[9], $_[7]);\n\t}\nelse {\n\t# read data\n\tif (ref($destfile)) {\n\t\t# Append to a variable\n\t\twhile(defined($buf = &read_http_connection($h, 1024))) {\n\t\t\t${$destfile} .= $buf;\n\t\t\t&$cbfunc(3, length(${$destfile})) if ($cbfunc);\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Write to a file\n\t\tmy $got = 0;\n\t\tif (!&open_tempfile(PFILE, \">$destfile\", 1)) {\n\t\t\t&close_http_connection($h);\n\t\t\tif ($error) { ${$error} = \"Failed to write to $destfile : $!\"; return; }\n\t\t\telse { &error(\"Failed to write to \".&html_escape($destfile).\" : \".&html_escape(\"$!\")); }\n\t\t\t}\n\t\tbinmode(PFILE);\t\t# For windows\n\t\twhile(defined($buf = &read_http_connection($h, 1024))) {\n\t\t\t&print_tempfile(PFILE, $buf);\n\t\t\t$got += length($buf);\n\t\t\t&$cbfunc(3, $got) if ($cbfunc);\n\t\t\t}\n\t\t&close_tempfile(PFILE);\n\t\tif ($header{'content-length'} &&\n\t\t    $got != $header{'content-length'}) {\n\t\t\t&close_http_connection($h);\n\t\t\tif ($error) { ${$error} = \"Download incomplete\"; return; }\n\t\t\telse { &error(\"Download incomplete\"); }\n\t\t\t}\n\t\t}\n\t&$cbfunc(4) if ($cbfunc);\n\t}\n&close_http_connection($h);\n}\n\n\n=head2 http_post(host, port, page, content, destfile, [&error], [&callback], [sslmode], [user, pass], [timeout], [osdn-convert], [no-cache], [&headers])\n\nPosts data to an HTTP url and downloads the response to a local file or string. The parameters are :\n\n=item host - The hostname part of the URL, such as www.google.com\n\n=item port - The HTTP port number, such as 80\n\n=item page - The filename part of the URL, like /index.html\n\n=item content - The data to post\n\n=item destfile - The local file to save the URL data to, like /tmp/index.html. This can also be a scalar reference, in which case the data will be appended to that scalar.\n\n=item error - If set to a scalar ref, the function will store any error message in this scalar and return 0 on failure, or 1 on success. If not set, it will simply call the error function if the download fails.\n\n=item callback - If set to a function ref, it will be called after each block of data is received. This is typically set to \\&progress_callback, for printing download progress.\n\n=item sslmode - If set to 1, an HTTPS connection is used instead of HTTP.\n\n=item user - If set, HTTP authentication is done with this username.\n\n=item pass - The HTTP password to use with the username above.\n\n=item timeout - A timeout in seconds to wait for the TCP connection to be established before failing.\n\n=item osdn-convert - If set to 1, URL for downloads from sourceforge are converted to use an appropriate mirror site.\n\n=item no-cache - If set to 1, Webmin's internal caching for this URL is disabled.\n\n=item headers - If set to a hash ref of additional HTTP headers, they will be added to the request.\n\n=cut\nsub http_post\n{\nmy ($host, $port, $page, $content, $dest, $error, $cbfunc, $ssl, $user, $pass,\n    $timeout, $osdn, $nocache, $headers) = @_;\nif ($gconfig{'debug_what_net'}) {\n\t&webmin_debug_log('HTTP', \"host=$host port=$port page=$page ssl=$ssl\".\n\t\t\t\t  ($user ? \" user=$user pass=$pass\" : \"\").\n\t\t\t\t  (ref($dest) ? \"\" : \" dest=$dest\"));\n\t}\nif ($osdn) {\n\t# Convert OSDN URL first\n\tmy $prot = $ssl ? \"https://\" : \"http://\";\n\tmy $portstr = $ssl && $port == 443 ||\n\t\t\t !$ssl && $port == 80 ? \"\" : \":$port\";\n\t($host, $port, $page, $ssl) = &parse_http_url(\n\t\t&convert_osdn_url($prot.$host.$portstr.$page));\n\t}\n\n# Build headers\nmy @headers;\npush(@headers, [ \"Host\", $host ]);\npush(@headers, [ \"User-agent\", \"Webmin\" ]);\npush(@headers, [ \"Accept-language\", \"en\" ]);\npush(@headers, [ \"Content-type\", \"application/x-www-form-urlencoded\" ]);\nif (defined($content)) {\n\tpush(@headers, [ \"Content-length\", length($content) ]);\n\t}\nif ($user) {\n\tmy $auth = &encode_base64(\"$user:$pass\");\n\t$auth =~ tr/\\r\\n//d;\n\tpush(@headers, [ \"Authorization\", \"Basic $auth\" ]);\n\t}\nforeach my $hname (keys %$headers) {\n\tpush(@headers, [ $hname, $headers->{$hname} ]);\n\t}\n\n# Actually download it\n$main::download_timed_out = undef;\nlocal $SIG{ALRM} = \\&download_timeout;\n$timeout = 60 if (!defined($timeout));\nalarm($timeout) if ($timeout);\nmy $h = &make_http_connection($host, $port, $ssl, \"POST\", $page, \\@headers);\nalarm(0) if ($timeout);\n$h = $main::download_timed_out if ($main::download_timed_out);\nif (!ref($h)) {\n\tif ($error) { $$error = $h; return; }\n\telse { &error($h); }\n\t}\n&write_http_connection($h, $content.\"\\r\\n\");\n&complete_http_download($h, $dest, $error, $cbfunc, $osdn, $host, $port,\n\t\t\t$headers, $ssl, $nocache);\n}\n\n=head2 ftp_download(host, file, destfile, [&error], [&callback], [user, pass], [port], [no-cache])\n\nDownload data from an FTP site to a local file. The parameters are :\n\n=item host - FTP server hostname\n\n=item file - File on the FTP server to download\n\n=item destfile - File on the Webmin system to download data to\n\n=item error - If set to a string ref, any error message is written into this string and the function returns 0 on failure, 1 on success. Otherwise, error is called on failure.\n\n=item callback - If set to a function ref, it will be called after each block of data is received. This is typically set to \\&progress_callback, for printing download progress.\n\n=item user - Username to login to the FTP server as. If missing, Webmin will login as anonymous.\n\n=item pass - Password for the username above.\n\n=item port - FTP server port number, which defaults to 21 if not set.\n\n=item no-cache - If set to 1, Webmin's internal caching for this URL is disabled.\n\n=item timeout - Timeout for connections, defaults to 60s\n\n=cut\nsub ftp_download\n{\nmy ($host, $file, $dest, $error, $cbfunc, $user, $pass, $port, $nocache, $timeout) = @_;\n$port ||= 21;\n$timeout = 60 if (!defined($timeout));\nif ($gconfig{'debug_what_net'}) {\n\t&webmin_debug_log('FTP', \"host=$host port=$port file=$file\".\n\t\t\t\t ($user ? \" user=$user pass=$pass\" : \"\").\n\t\t\t\t (ref($dest) ? \"\" : \" dest=$dest\"));\n\t}\nmy ($buf, @n);\nif (&is_readonly_mode()) {\n\tif ($error) {\n\t\t$$error = \"FTP connections not allowed in readonly mode\";\n\t\treturn 0;\n\t\t}\n\telse {\n\t\t&error(\"FTP connections not allowed in readonly mode\");\n\t\t}\n\t}\n\n# Check if we already have cached the URL\nmy $url = \"ftp://\".$host.$file;\nmy $cfile = &check_in_http_cache($url);\nif ($cfile && !$nocache) {\n\t# Yes! Copy to dest file or variable\n\t&$cbfunc(6, $url) if ($cbfunc);\n\tif (ref($dest)) {\n\t\t&open_readfile(CACHEFILE, $cfile);\n\t\tlocal $/ = undef;\n\t\t$$dest = <CACHEFILE>;\n\t\tclose(CACHEFILE);\n\t\t}\n\telse {\n\t\t&copy_source_dest($cfile, $dest);\n\t\t}\n\treturn;\n\t}\n\n# Actually download it\n$main::download_timed_out = undef;\nlocal $SIG{ALRM} = \\&download_timeout;\nalarm($timeout) if ($timeout);\nmy $connected;\nif ($gconfig{'ftp_proxy'} =~ /^http:\\/\\/(\\S+):(\\d+)/ && !&no_proxy($_[0])) {\n\t# download through http-style proxy\n\tmy $error;\n\tif (&open_socket($1, $2, \"SOCK\", \\$error)) {\n\t\t# Connected OK\n\t\tif ($main::download_timed_out) {\n\t\t\talarm(0) if ($timeout);\n\t\t\tif ($error) {\n\t\t\t\t$$error = $main::download_timed_out;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&error($main::download_timed_out);\n\t\t\t\t}\n\t\t\t}\n\t\tmy $esc = $file; $esc =~ s/ /%20/g;\n\t\tmy $up = \"${user}:${pass}\\@\" if ($user);\n\t\tmy $portstr = $port == 21 ? \"\" : \":$port\";\n\t\tprint SOCK \"GET ftp://${up}${host}${portstr}${esc} HTTP/1.0\\r\\n\";\n\t\tprint SOCK \"User-agent: Webmin\\r\\n\";\n\t\tif ($gconfig{'proxy_user'}) {\n\t\t\tmy $auth = &encode_base64(\n\t\t\t   \"$gconfig{'proxy_user'}:$gconfig{'proxy_pass'}\");\n\t\t\t$auth =~ tr/\\r\\n//d;\n\t\t\tprint SOCK \"Proxy-Authorization: Basic $auth\\r\\n\";\n\t\t\t}\n\t\tprint SOCK \"\\r\\n\";\n\t\t&complete_http_download(\n\t\t\t{ 'fh' => \"SOCK\" }, $dest, $error, $cbfunc,\n\t\t\tundef, undef, undef, undef, 0, $nocache);\n\t\t$connected = 1;\n\t\t}\n\telsif (!$gconfig{'proxy_fallback'}) {\n\t\talarm(0) if ($timeout);\n\t\tif ($error) {\n\t\t\t$$error = $main::download_timed_out;\n\t\t\treturn 0;\n\t\t\t}\n\t\telse {\n\t\t\t&error($main::download_timed_out);\n\t\t\t}\n\t\t}\n\t}\n\nif (!$connected) {\n\t# connect to host and login with real FTP protocol\n\t&open_socket($host, $port, \"SOCK\", $_[3]) || return 0;\n\talarm(0) if ($timeout);\n\tif ($main::download_timed_out) {\n\t\tif ($error) {\n\t\t\t$$error = $main::download_timed_out;\n\t\t\treturn 0;\n\t\t\t}\n\t\telse {\n\t\t\t&error($main::download_timed_out);\n\t\t\t}\n\t\t}\n\t&ftp_command(\"\", 2, $error) || return 0;\n\tif ($user) {\n\t\t# Login as supplied user\n\t\tmy @urv = &ftp_command(\"USER $user\", [ 2, 3 ], $error);\n\t\t@urv || return 0;\n\t\tif (int($urv[1]/100) == 3) {\n\t\t\t&ftp_command(\"PASS $pass\", 2, $error) || return 0;\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Login as anonymous\n\t\tmy @urv = &ftp_command(\"USER anonymous\", [ 2, 3 ], $error);\n\t\t@urv || return 0;\n\t\tif (int($urv[1]/100) == 3) {\n\t\t\t&ftp_command(\"PASS root\\@\".&get_system_hostname(), 2,\n\t\t\t\t     $error) || return 0;\n\t\t\t}\n\t\t}\n\t&$cbfunc(1, 0) if ($cbfunc);\n\n\tif ($file) {\n\t\t# get the file size and tell the callback\n\t\t&ftp_command(\"TYPE I\", 2, $error) || return 0;\n\t\tmy $size = &ftp_command(\"SIZE $file\", 2, $error);\n\t\tdefined($size) || return 0;\n\t\tif ($cbfunc) {\n\t\t\t&$cbfunc(2, int($size));\n\t\t\t}\n\n\t\t# are we using IPv6?\n\t\tmy $v6 = !&to_ipaddress($host) &&\n\t\t\t &to_ip6address($host);\n\n\t\tif ($v6) {\n\t\t\t# request the file over a EPSV port\n\t\t\tmy $epsv = &ftp_command(\"EPSV\", 2, $error);\n\t\t\tdefined($epsv) || return 0;\n\t\t\t$epsv =~ /\\|(\\d+)\\|/ || return 0;\n\t\t\tmy $epsvport = $1;\n\t\t\t&open_socket($host, $epsvport, CON, $error) || return 0;\n\t\t\t}\n\t\telse {\n\t\t\t# request the file over a PASV connection\n\t\t\tmy $pasv = &ftp_command(\"PASV\", 2, $error);\n\t\t\tdefined($pasv) || return 0;\n\t\t\t$pasv =~ /\\(([0-9,]+)\\)/ || return 0;\n\t\t\t@n = split(/,/ , $1);\n\t\t\t&open_socket(\"$n[0].$n[1].$n[2].$n[3]\",\n\t\t\t\t$n[4]*256 + $n[5], \"CON\", $_[3]) || return 0;\n\t\t\t}\n\t\t&ftp_command(\"RETR $file\", 1, $error) || return 0;\n\n\t\t# transfer data\n\t\tmy $got = 0;\n\t\t&open_tempfile(PFILE, \">$dest\", 1);\n\t\twhile(read(CON, $buf, 1024) > 0) {\n\t\t\t&print_tempfile(PFILE, $buf);\n\t\t\t$got += length($buf);\n\t\t\t&$cbfunc(3, $got) if ($cbfunc);\n\t\t\t}\n\t\t&close_tempfile(PFILE);\n\t\tclose(CON);\n\t\tif ($got != $size) {\n\t\t\tif ($error) {\n\t\t\t\t$$error = \"Download incomplete\";\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&error(\"Download incomplete\");\n\t\t\t\t}\n\t\t\t}\n\t\t&$cbfunc(4) if ($cbfunc);\n\n\t\t&ftp_command(\"\", 2, $error) || return 0;\n\t\t}\n\n\t# finish off..\n\t&ftp_command(\"QUIT\", 2, $error) || return 0;\n\tclose(SOCK);\n\t}\n\n&write_to_http_cache($url, $dest);\nreturn 1;\n}\n\n=head2 ftp_upload(host, file, srcfile, [&error], [&callback], [user, pass], [port])\n\nUpload data from a local file to an FTP site. The parameters are :\n\n=item host - FTP server hostname\n\n=item file - File on the FTP server to write to\n\n=item srcfile - File on the Webmin system to upload data from\n\n=item error - If set to a string ref, any error message is written into this string and the function returns 0 on failure, 1 on success. Otherwise, error is called on failure.\n\n=item callback - If set to a function ref, it will be called after each block of data is received. This is typically set to \\&progress_callback, for printing upload progress.\n\n=item user - Username to login to the FTP server as. If missing, Webmin will login as anonymous.\n\n=item pass - Password for the username above.\n\n=item port - FTP server port number, which defaults to 21 if not set.\n\n=cut\nsub ftp_upload\n{\nmy ($buf, @n);\nmy $cbfunc = $_[4];\nif (&is_readonly_mode()) {\n\tif ($_[3]) { ${$_[3]} = \"FTP connections not allowed in readonly mode\";\n\t\t     return 0; }\n\telse { &error(\"FTP connections not allowed in readonly mode\"); }\n\t}\n\n$main::download_timed_out = undef;\nlocal $SIG{ALRM} = \\&download_timeout;\nalarm(60);\n\n# connect to host and login\n&open_socket($_[0], $_[7] || 21, \"SOCK\", $_[3]) || return 0;\nalarm(0);\nif ($main::download_timed_out) {\n\tif ($_[3]) { ${$_[3]} = $main::download_timed_out; return 0; }\n\telse { &error($main::download_timed_out); }\n\t}\n&ftp_command(\"\", 2, $_[3]) || return 0;\nif ($_[5]) {\n\t# Login as supplied user\n\tmy @urv = &ftp_command(\"USER $_[5]\", [ 2, 3 ], $_[3]);\n\t@urv || return 0;\n\tif (int($urv[1]/100) == 3) {\n\t\tif (!&ftp_command(\"PASS $_[6]\", 2, $_[3])) {\n\t\t\t${$_[3]} =~ s/PASS\\s+\\S+/PASS \\*\\*\\*\\*\\*/ if ($_[3]);\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t# Login as anonymous\n\tmy @urv = &ftp_command(\"USER anonymous\", [ 2, 3 ], $_[3]);\n\t@urv || return 0;\n\tif (int($urv[1]/100) == 3) {\n\t\tif (!&ftp_command(\"PASS root\\@\".&get_system_hostname(), 2,\n\t\t\t\t  $_[3])) {\n\t\t\t${$_[3]} =~ s/PASS\\s+\\S+/PASS \\*\\*\\*\\*\\*/ if ($_[3]);\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n&$cbfunc(1, 0) if ($cbfunc);\n\n&ftp_command(\"TYPE I\", 2, $_[3]) || return 0;\n\n# get the file size and tell the callback\nmy @st = stat($_[2]);\nif ($cbfunc) {\n\t&$cbfunc(2, $st[7]);\n\t}\n\n# are we using IPv6?\nmy $v6 = !&to_ipaddress($_[0]) && &to_ip6address($_[0]);\n\nif ($v6) {\n\t# send the file over a EPSV port\n\tmy $epsv = &ftp_command(\"EPSV\", 2, $_[3]);\n\tdefined($epsv) || return 0;\n\t$epsv =~ /\\|(\\d+)\\|/ || return 0;\n\tmy $epsvport = $1;\n\t&open_socket($_[0], $epsvport, \"CON\", $_[3]) || return 0;\n\t}\nelse {\n\t# send the file over a PASV connection\n\tmy $pasv = &ftp_command(\"PASV\", 2, $_[3]);\n\tdefined($pasv) || return 0;\n\t$pasv =~ /\\(([0-9,]+)\\)/ || return 0;\n\t@n = split(/,/ , $1);\n\t&open_socket(\"$n[0].$n[1].$n[2].$n[3]\", $n[4]*256 + $n[5], \"CON\", $_[3]) || return 0;\n\t}\n&ftp_command(\"STOR $_[1]\", 1, $_[3]) || return 0;\n\n# transfer data\nmy $got;\nopen(PFILE, $_[2]);\nwhile(read(PFILE, $buf, 1024) > 0) {\n\tprint CON $buf;\n\t$got += length($buf);\n\t&$cbfunc(3, $got) if ($cbfunc);\n\t}\nclose(PFILE);\nclose(CON);\nif ($got != $st[7]) {\n\tif ($_[3]) { ${$_[3]} = \"Upload incomplete\"; return 0; }\n\telse { &error(\"Upload incomplete\"); }\n\t}\n&$cbfunc(4) if ($cbfunc);\n\n# finish off..\n&ftp_command(\"\", 2, $_[3]) || return 0;\n&ftp_command(\"QUIT\", 2, $_[3]) || return 0;\nclose(SOCK);\n\nreturn 1;\n}\n\n=head2 no_proxy(host)\n\nChecks if some host is on the no proxy list. For internal use by the\nhttp_download and ftp_download functions.\n\n=cut\nsub no_proxy\n{\nmy $ip = &to_ipaddress($_[0]);\nforeach my $n (split(/\\s+/, $gconfig{'noproxy'})) {\n\treturn 1 if ($_[0] =~ /\\Q$n\\E/ ||\n\t\t     $ip =~ /\\Q$n\\E/);\n\t}\nreturn 0;\n}\n\n=head2 open_socket(host, port, handle, [&error])\n\nOpen a TCP connection to some host and port, using a file handle. The\nparameters are :\n\n=item host - Hostname or IP address to connect to.\n\n=item port - TCP port number.\n\n=item handle - A file handle name to use for the connection.\n\n=item error - A string reference to write any error message into. If not set, the error function is called on failure.\n\n=item bindip - Local IP address to bind to for outgoing connections\n\n=cut\nsub open_socket\n{\nmy ($host, $port, $fh, $err, $bindip) = @_;\n$fh = &callers_package($fh);\n$bindip ||= $gconfig{'bind_proxy'};\n\nif ($gconfig{'debug_what_net'}) {\n\t&webmin_debug_log('TCP', \"host=$host port=$port\");\n\t}\n\n# Lookup IP address for the host. Try v4 first, and failing that v6\nmy $ip;\nmy $proto = getprotobyname(\"tcp\");\nif ($ip = &to_ipaddress($host)) {\n\t# Create IPv4 socket and connection\n\tif (!socket($fh, PF_INET(), SOCK_STREAM, $proto)) {\n\t\tmy $msg = \"Failed to create socket : $!\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\tmy $addr = inet_aton($ip);\n\tif ($gconfig{'bind_proxy'}) {\n\t\t# BIND to outgoing IP\n\t\tif (!bind($fh, pack_sockaddr_in(0, inet_aton($bindip)))) {\n\t\t\tmy $msg = \"Failed to bind to source address : $!\";\n\t\t\tif ($err) { $$err = $msg; return 0; }\n\t\t\telse { &error($msg); }\n\t\t\t}\n\t\t}\n\tif (!connect($fh, pack_sockaddr_in($port, $addr))) {\n\t\tmy $msg = \"Failed to connect to $host:$port : $!\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\t}\nelsif ($ip = &to_ip6address($host)) {\n\t# Create IPv6 socket and connection\n\tif (!&supports_ipv6()) {\n\t\t$msg = \"IPv6 connections are not supported\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\tif (!socket($fh, PF_INET6(), SOCK_STREAM, $proto)) {\n\t\tmy $msg = \"Failed to create IPv6 socket : $!\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\tmy $addr = inet_pton(AF_INET6(), $ip);\n\tif (!connect($fh, pack_sockaddr_in6($port, $addr))) {\n\t\tmy $msg = \"Failed to IPv6 connect to $host:$port : $!\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\t}\nelse {\n\t# Resolution failed\n\tmy $msg = \"Failed to lookup IP address for $host\";\n\tif ($err) { $$err = $msg; return 0; }\n\telse { &error($msg); }\n\t}\n\n# Disable buffering\nmy $old = select($fh);\n$| = 1;\nselect($old);\nreturn 1;\n}\n\n=head2 download_timeout\n\nCalled when a download times out. For internal use only.\n\n=cut\nsub download_timeout\n{\n$main::download_timed_out = \"Download timed out\";\n}\n\n=head2 ftp_command(command, expected, [&error], [filehandle])\n\nSend an FTP command, and die if the reply is not what was expected. Mainly\nfor internal use by the ftp_download and ftp_upload functions.\n\n=cut\nsub ftp_command\n{\nmy ($cmd, $expect, $err, $fh) = @_;\n$fh ||= \"SOCK\";\n$fh = &callers_package($fh);\n\nmy $line;\nmy $what = $cmd ne \"\" ? \"<i>$cmd</i>\" : \"initial connection\";\nif ($cmd ne \"\") {\n        print $fh \"$cmd\\r\\n\";\n        }\nalarm(60);\nif (!($line = <$fh>)) {\n\talarm(0);\n\tif ($err) { $$err = \"Failed to read reply to $what\"; return undef; }\n\telse { &error(\"Failed to read reply to $what\"); }\n        }\n$line =~ /^(...)(.)(.*)$/;\nmy $found = 0;\nif (ref($expect)) {\n\tforeach my $c (@$expect) {\n\t\t$found++ if (int($1/100) == $c);\n\t\t}\n\t}\nelse {\n\t$found++ if (int($1/100) == $_[1]);\n\t}\nif (!$found) {\n\talarm(0);\n\tif ($err) { $$err = \"$what failed : $3\"; return undef; }\n\telse { &error(\"$what failed : $3\"); }\n\t}\nmy $rcode = $1;\nmy $reply = $3;\nif ($2 eq \"-\") {\n        # Need to skip extra stuff..\n        while(1) {\n                if (!($line = <$fh>)) {\n\t\t\talarm(0);\n\t\t\tif ($err) { $$err = \"Failed to read reply to $what\";\n\t\t\t\t     return undef; }\n\t\t\telse { &error(\"Failed to read reply to $what\"); }\n                        }\n                $line =~ /^(....)(.*)$/; $reply .= $2;\n\t\tif ($1 eq \"$rcode \") { last; }\n                }\n        }\nalarm(0);\nreturn wantarray ? ($reply, $rcode) : $reply;\n}\n\n=head2 to_ipaddress(hostname)\n\nConverts a hostname to an a.b.c.d format IP address, or returns undef if\nit cannot be resolved.\n\n=cut\nsub to_ipaddress\n{\nif (&check_ipaddress($_[0])) {\n\treturn $_[0];\t# Already in v4 format\n\t}\nelsif (&check_ip6address($_[0])) {\n\treturn undef;\t# A v6 address cannot be converted to v4\n\t}\nelse {\n\tmy $hn = gethostbyname($_[0]);\n\treturn undef if (!$hn);\n\tlocal @ip = unpack(\"CCCC\", $hn);\n\treturn join(\".\" , @ip);\n\t}\n}\n\n=head2 to_ip6address(hostname)\n\nConverts a hostname to IPv6 address, or returns undef if it cannot be resolved.\n\n=cut\nsub to_ip6address\n{\nif (&check_ip6address($_[0])) {\n\treturn $_[0];\t# Already in v6 format\n\t}\nelsif (&check_ipaddress($_[0])) {\n\treturn undef;\t# A v4 address cannot be v6\n\t}\nelsif (!&supports_ipv6()) {\n\treturn undef;\t# Cannot lookup\n\t}\nelse {\n\t# Perform IPv6 DNS lookup\n\tmy $inaddr;\n\t(undef, undef, undef, $inaddr) =\n\t    getaddrinfo($_[0], undef, AF_INET6(), SOCK_STREAM);\n\treturn undef if (!$inaddr);\n\tmy $addr;\n\t(undef, $addr) = unpack_sockaddr_in6($inaddr);\n\treturn inet_ntop(AF_INET6(), $addr);\n\t}\n}\n\n=head2 to_hostname(ipv4|ipv6-address)\n\nReverse-resolves an IPv4 or 6 address to a hostname\n\n=cut\nsub to_hostname\n{\nmy ($addr) = @_;\nif (&check_ip6address($addr) && &supports_ipv6()) {\n\treturn gethostbyaddr(inet_pton(AF_INET6(), $addr), AF_INET6());\n\t}\nelse {\n\treturn gethostbyaddr(inet_aton($addr), AF_INET);\n\t}\n}\n\n=head2 icons_table(&links, &titles, &icons, [columns], [href], [width], [height], &befores, &afters)\n\nRenders a 4-column table of icons. The useful parameters are :\n\n=item links - An array ref of link destination URLs for the icons.\n\n=item titles - An array ref of titles to appear under the icons.\n\n=item icons - An array ref of URLs for icon images.\n\n=item columns - Number of columns to layout the icons with. Defaults to 4.\n\n=cut\nsub icons_table\n{\n&load_theme_library();\nif (defined(&theme_icons_table)) {\n\t&theme_icons_table(@_);\n\treturn;\n\t}\nmy $need_tr;\nmy $cols = $_[3] ? $_[3] : 4;\nmy $per = int(100.0 / $cols);\nprint \"<table class='icons_table' width='100%' cellpadding='5'>\\n\";\nfor(my $i=0; $i<@{$_[0]}; $i++) {\n\tif ($i%$cols == 0) { print \"<tr>\\n\"; }\n\tprint \"<td width='$per%' align='center' valign='top'>\\n\";\n\t&generate_icon($_[2]->[$i], $_[1]->[$i], $_[0]->[$i],\n\t\t       ref($_[4]) ? $_[4]->[$i] : $_[4], $_[5], $_[6],\n\t\t       $_[7]->[$i], $_[8]->[$i]);\n\tprint \"</td>\\n\";\n        if ($i%$cols == $cols-1) { print \"</tr>\\n\"; }\n        }\nwhile($i++%$cols) { print \"<td width='$per%'></td>\\n\"; $need_tr++; }\nprint \"</tr>\\n\" if ($need_tr);\nprint \"</table>\\n\";\n}\n\n=head2 replace_meta($string)\n\nReplaces all occurrences of meta words\n\n=item string - String value to search/replace in\n\n=cut\nsub replace_meta\n{\n  my ($string) = @_;\n\n  my $hostname   = &get_display_hostname();\n  my $version    = &get_webmin_version();\n  my $os_type    = $gconfig{'real_os_type'} || $gconfig{'os_type'};\n  my $os_version = $gconfig{'real_os_version'} || $gconfig{'os_version'};\n  $string =~ s/%HOSTNAME%/$hostname/g;\n  $string =~ s/%VERSION%/$version/g;\n  $string =~ s/%USER%/$remote_user/g;\n  $string =~ s/%OS%/$os_type $os_version/g;\n\n  return $string;\n}\n\n=head2 replace_file_line(file, line, [newline]*)\n\nReplaces one line in some file with 0 or more new lines. The parameters are :\n\n=item file - Full path to some file, like /etc/hosts.\n\n=item line - Line number to replace, starting from 0.\n\n=item newline - Zero or more lines to put into the file at the given line number. These must be newline-terminated strings.\n\n=cut\nsub replace_file_line\n{\nmy @lines;\nmy $realfile = &translate_filename($_[0]);\nopen(FILE, $realfile);\n@lines = <FILE>;\nclose(FILE);\nif (@_ > 2) { splice(@lines, $_[1], 1, @_[2..$#_]); }\nelse { splice(@lines, $_[1], 1); }\n&open_tempfile(FILE, \">$realfile\");\n&print_tempfile(FILE, @lines);\n&close_tempfile(FILE);\n}\n\n=head2 read_file_lines(file, [readonly])\n\nReturns a reference to an array containing the lines from some file. This\narray can be modified, and will be written out when flush_file_lines()\nis called. The parameters are :\n\n=item file - Full path to the file to read.\n\n=item readonly - Should be set 1 if the caller is only going to read the lines, and never write it out.\n\nExample code :\n\n $lref = read_file_lines(\"/etc/hosts\");\n push(@$lref, \"127.0.0.1 localhost\");\n flush_file_lines(\"/etc/hosts\");\n\n=cut\nsub read_file_lines\n{\nmy ($file, $readonly) = @_;\nif (!$file) {\n\tmy ($package, $filename, $line) = caller;\n\t&error(\"Missing file to read at ${package}::${filename} line $line\");\n\t}\nmy $realfile = &translate_filename($file);\nif (!$main::file_cache{$realfile}) {\n        my (@lines, $eol);\n\tlocal $_;\n\t&webmin_debug_log('READ', $file) if ($gconfig{'debug_what_read'});\n        open(READFILE, $realfile);\n        while(<READFILE>) {\n\t\tif (!$eol) {\n\t\t\t$eol = /\\r\\n$/ ? \"\\r\\n\" : \"\\n\";\n\t\t\t}\n                tr/\\r\\n//d;\n                push(@lines, $_);\n                }\n        close(READFILE);\n        $main::file_cache{$realfile} = \\@lines;\n\t$main::file_cache_noflush{$realfile} = $readonly;\n\t$main::file_cache_eol{$realfile} = $eol || \"\\n\";\n        }\nelse {\n\t# Make read-write if currently readonly\n\tif (!$readonly) {\n\t\t$main::file_cache_noflush{$realfile} = 0;\n\t\t}\n\t}\nreturn $main::file_cache{$realfile};\n}\n\n=head2 flush_file_lines([file], [eol], [ignore-unloaded])\n\nWrite out to a file previously read by read_file_lines to disk (except\nfor those marked readonly). The parameters are :\n\n=item file - The file to flush out.\n\n=item eof - End-of-line character for each line. Defaults to \\n.\n\n=item ignore-unloaded - Don't fail if the file isn't loaded\n\n=cut\nsub flush_file_lines\n{\nmy ($file, $eof, $ignore) = @_;\nmy @files;\nif ($file) {\n\tlocal $trans = &translate_filename($file);\n\tif (!$main::file_cache{$trans}) {\n\t\tif ($ignore) {\n\t\t\treturn 0;\n\t\t\t}\n\t\telse {\n\t\t\t&error(\"flush_file_lines called on non-loaded file $trans\");\n\t\t\t}\n\t\t}\n\tpush(@files, $trans);\n\t}\nelse {\n\t@files = ( keys %main::file_cache );\n\t}\nforeach my $f (@files) {\n\tmy $eol = $eof || $main::file_cache_eol{$f} || \"\\n\";\n\tif (!$main::file_cache_noflush{$f}) {\n\t\tno warnings; # XXX Bareword file handles should go away\n\t\t&open_tempfile(FLUSHFILE, \">$f\");\n\t\tforeach my $line (@{$main::file_cache{$f}}) {\n\t\t\t(print FLUSHFILE $line,$eol) ||\n\t\t\t\t&error(&text(\"efilewrite\", $f, $!));\n\t\t\t}\n\t\t&close_tempfile(FLUSHFILE);\n\t\t}\n\tdelete($main::file_cache{$f});\n\tdelete($main::file_cache_noflush{$f});\n        }\nreturn scalar(@files);\n}\n\n=head2 unflush_file_lines(file)\n\nClear the internal cache of some given file, previously read by read_file_lines.\n\n=cut\nsub unflush_file_lines\n{\nmy $realfile = &translate_filename($_[0]);\ndelete($main::file_cache{$realfile});\ndelete($main::file_cache_noflush{$realfile});\n}\n\n=head2 unix_user_input(fieldname, user, [form])\n\nReturns HTML for an input to select a Unix user. By default this is a text\nbox with a user popup button next to it.\n\n=cut\nsub unix_user_input\n{\nif (defined(&theme_unix_user_input)) {\n\treturn &theme_unix_user_input(@_);\n\t}\nreturn \"<input name=$_[0] size=13 value=\\\"$_[1]\\\"> \".\n       &user_chooser_button($_[0], 0, $_[2] || 0).\"\\n\";\n}\n\n=head2 unix_group_input(fieldname, user, [form])\n\nReturns HTML for an input to select a Unix group. By default this is a text\nbox with a group popup button next to it.\n\n=cut\nsub unix_group_input\n{\nif (defined(&theme_unix_group_input)) {\n\treturn &theme_unix_group_input(@_);\n\t}\nreturn \"<input name='$_[0]' size=13 value=\\\"$_[1]\\\"> \".\n       &group_chooser_button($_[0], 0, $_[2] || 0).\"\\n\";\n}\n\n=head2 hlink(text, page, [module], [width], [height])\n\nReturns HTML for a link that when clicked on pops up a window for a Webmin\nhelp page. The parameters are :\n\n=item text - Text for the link.\n\n=item page - Help page code, such as 'intro'.\n\n=item module - Module the help page is in. Defaults to the current module.\n\n=item width - Width of the help popup window. Defaults to 600 pixels.\n\n=item height - Height of the help popup window. Defaults to 400 pixels.\n\nThe actual help pages are in each module's help sub-directory, in files with\n.html extensions.\n\n=cut\nsub hlink\n{\nif (defined(&theme_hlink)) {\n\treturn &theme_hlink(@_);\n\t}\nmy $mod = $_[2] ? $_[2] : &get_module_name();\nmy $width = $_[3] || $tconfig{'help_width'} || $gconfig{'help_width'} || 600;\nmy $height = $_[4] || $tconfig{'help_height'} || $gconfig{'help_height'} || 400;\nreturn \"<a onClick='window.open(\\\"$gconfig{'webprefix'}/help.cgi/$mod/$_[1]\\\", \\\"help\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,width=$width,height=$height,resizable=yes\\\"); return false' href=\\\"$gconfig{'webprefix'}/help.cgi/$mod/$_[1]\\\">$_[0]</a>\";\n}\n\n=head2 user_chooser_button(field, multiple, [form])\n\nReturns HTML for a javascript button for choosing a Unix user or users.\nThe parameters are :\n\n=item field - Name of the HTML field to place the username into.\n\n=item multiple - Set to 1 if multiple users can be selected.\n\n=item form - Index of the form on the page.\n\n=cut\nsub user_chooser_button\n{\nreturn undef if (!&supports_users());\nreturn &theme_user_chooser_button(@_)\n\tif (defined(&theme_user_chooser_button));\nmy $form = defined($_[2]) ? $_[2] : 0;\nmy $w = $_[1] ? 500 : 300;\nmy $h = 200;\nif ($_[1] && $gconfig{'db_sizeusers'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizeusers'});\n\t}\nelsif (!$_[1] && $gconfig{'db_sizeuser'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizeuser'});\n\t}\nreturn \"<input type=button onClick='ifield = form.$_[0]; chooser = window.open(\\\"$gconfig{'webprefix'}/user_chooser.cgi?multi=$_[1]&user=\\\"+escape(ifield.value), \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,resizable=yes,width=$w,height=$h\\\"); chooser.ifield = ifield; window.ifield = ifield' value=\\\"...\\\">\\n\";\n}\n\n=head2 group_chooser_button(field, multiple, [form])\n\nReturns HTML for a javascript button for choosing a Unix group or groups\nThe parameters are :\n\n=item field - Name of the HTML field to place the group name into.\n\n=item multiple - Set to 1 if multiple groups can be selected.\n\n=item form - Index of the form on the page.\n\n=cut\nsub group_chooser_button\n{\nreturn undef if (!&supports_users());\nreturn &theme_group_chooser_button(@_)\n\tif (defined(&theme_group_chooser_button));\nmy $form = defined($_[2]) ? $_[2] : 0;\nmy $w = $_[1] ? 500 : 300;\nmy $h = 200;\nif ($_[1] && $gconfig{'db_sizeusers'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizeusers'});\n\t}\nelsif (!$_[1] && $gconfig{'db_sizeuser'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizeuser'});\n\t}\nreturn \"<input type=button onClick='ifield = form.$_[0]; chooser = window.open(\\\"$gconfig{'webprefix'}/group_chooser.cgi?multi=$_[1]&group=\\\"+escape(ifield.value), \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,resizable=yes,width=$w,height=$h\\\"); chooser.ifield = ifield; window.ifield = ifield' value=\\\"...\\\">\\n\";\n}\n\n=head2 foreign_check(module, [api-only])\n\nChecks if some other module exists and is supported on this OS. The parameters\nare :\n\n=item module - Name of the module to check.\n\n=item api-only - Set to 1 if you just want to check if the module provides an API that others can call, instead of the full web UI.\n\n=cut\nsub foreign_check\n{\nmy ($mod, $api) = @_;\nmy %minfo;\nmy $mdir = &module_root_directory($mod);\n&read_file_cached(\"$mdir/module.info\", \\%minfo) || return 0;\nreturn &check_os_support(\\%minfo, undef, undef, $api);\n}\n\n=head2 foreign_exists(module)\n\nChecks if some other module exists. The module parameter is the short module\nname.\n\n=cut\nsub foreign_exists\n{\nmy $mdir = &module_root_directory($_[0]);\nreturn -r \"$mdir/module.info\";\n}\n\n=head2 foreign_available(module)\n\nReturns 1 if some module is installed, and acessible to the current user. The\nmodule parameter is the module directory name.\n\n=cut\nsub foreign_available\n{\nreturn 0 if (!&foreign_check($_[0]) &&\n\t     !$gconfig{'available_even_if_no_support'});\nmy %foreign_module_info = &get_module_info($_[0]);\n\n# Check list of allowed modules\nmy %acl;\n&read_acl(\\%acl, undef, [ $base_remote_user ]);\nreturn 0 if (!$acl{$base_remote_user,$_[0]} &&\n\t     !$acl{$base_remote_user,'*'});\n\n# Check for usermod restrictions\nmy @usermods = &list_usermods();\nreturn 0 if (!&available_usermods( [ \\%foreign_module_info ], \\@usermods));\n\nif (&get_product_name() eq \"webmin\") {\n\t# Check if the user has any RBAC privileges in this module\n\tif (&supports_rbac($_[0]) &&\n\t    &use_rbac_module_acl(undef, $_[0])) {\n\t\t# RBAC is enabled for this user and module - check if he\n\t\t# has any rights\n\t\tmy $rbacs = &get_rbac_module_acl($remote_user, $_[0]);\n\t\treturn 0 if (!$rbacs);\n\t\t}\n\telsif ($gconfig{'rbacdeny_'.$base_remote_user}) {\n\t\t# If denying access to modules not specifically allowed by\n\t\t# RBAC, then prevent access\n\t\treturn 0;\n\t\t}\n\t}\n\n# Check readonly support\nif (&is_readonly_mode()) {\n\treturn 0 if (!$foreign_module_info{'readonly'});\n\t}\n\n# Check if theme vetos\nif (defined(&theme_foreign_available)) {\n\treturn 0 if (!&theme_foreign_available($_[0]));\n\t}\n\n# Check if licence module vetos\nif ($main::licence_module) {\n\treturn 0 if (!&foreign_call($main::licence_module,\n\t\t\t\t    \"check_module_licence\", $_[0]));\n\t}\n\nreturn 1;\n}\n\n=head2 foreign_require(module, [file], [package])\n\nBrings in functions from another module, and places them in the Perl namespace\nwith the same name as the module. The parameters are :\n\n=item module - The source module's directory name, like sendmail.\n\n=item file - The API file in that module, like sendmail-lib.pl. If missing, all API files are loaded.\n\n=item package - Perl package to place the module's functions and global variables in.\n\nIf the original module name contains dashes, they will be replaced with _ in\nthe package name.\n\n=cut\nsub foreign_require\n{\nmy ($mod, $file, $pkg) = @_;\n$pkg ||= $mod || \"global\";\n$pkg =~ s/[^A-Za-z0-9]/_/g;\nmy @files;\nif ($file) {\n\tpush(@files, $file);\n\t}\nelse {\n\t# Auto-detect files\n\tmy %minfo = &get_module_info($mod);\n\tif ($minfo{'library'}) {\n\t\t@files = split(/\\s+/, $minfo{'library'});\n\t\t}\n\telse {\n\t\t@files = ( ($minfo{'cloneof'} || $mod).\"-lib.pl\" );\n\t\t}\n\t}\n@files = grep { !$main::done_foreign_require{$pkg,$_} } @files;\nreturn 1 if (!@files);\nforeach my $f (@files) {\n\t$main::done_foreign_require{$pkg,$f}++;\n\t}\nmy @OLDINC = @INC;\nmy $mdir = &module_root_directory($mod);\n$mdir =~ /^(.*)$/; # untaint, part 1\n$mdir = $1; \t   # untaint, part 2\n@INC = &unique($mdir, @INC);\n-d $mdir || &error(\"Module $mod does not exist\");\nif (!&get_module_name() && $mod) {\n\tchdir($mdir);\n\t}\nmy $old_fmn = $ENV{'FOREIGN_MODULE_NAME'};\nmy $old_frd = $ENV{'FOREIGN_ROOT_DIRECTORY'};\nmy $code = \"package $pkg; \".\n\t   \"\\$ENV{'FOREIGN_MODULE_NAME'} = '$mod'; \".\n\t   \"\\$ENV{'FOREIGN_ROOT_DIRECTORY'} = '$root_directory'; \";\nforeach my $f (@files) {\n\t$code .= \"do '$mdir/$f' || die \\$@; \";\n\t}\neval $code;\nif (defined($old_fmn)) {\n\t$ENV{'FOREIGN_MODULE_NAME'} = $old_fmn;\n\t}\nelse {\n\tdelete($ENV{'FOREIGN_MODULE_NAME'});\n\t}\nif (defined($old_frd)) {\n\t$ENV{'FOREIGN_ROOT_DIRECTORY'} = $old_frd;\n\t}\nelse {\n\tdelete($ENV{'FOREIGN_ROOT_DIRECTORY'});\n\t}\n@INC = @OLDINC;\nif ($@) { &error(\"Require $mod/$files[0] failed : <pre>$@</pre>\"); }\nreturn 1;\n}\n\n=head2 foreign_call(module, function, [arg]*)\n\nCall a function in another module. The module parameter is the target module\ndirectory name, function is the perl sub to call, and the remaining parameters\nare the arguments. However, unless you need to call a function whose name\nis dynamic, it is better to use Perl's cross-module function call syntax\nlike module::function(args).\n\n=cut\nsub foreign_call\n{\nmy $pkg = $_[0] || \"global\";\n$pkg =~ s/[^A-Za-z0-9]/_/g;\nmy @args = @_[2 .. @_-1];\n$main::foreign_args = \\@args;\nmy @rv = eval <<EOF;\npackage $pkg;\n&$_[1](\\@{\\$main::foreign_args});\nEOF\nif ($@) { &error(\"$_[0]::$_[1] failed : $@\"); }\nreturn wantarray ? @rv : $rv[0];\n}\n\n=head2 foreign_config(module, [user-config])\n\nGet the configuration from another module, and return it as a hash. If the\nuser-config parameter is set to 1, returns the Usermin user-level preferences\nfor the current user instead.\n\n=cut\nsub foreign_config\n{\nmy ($mod, $uc) = @_;\nmy %fconfig;\nif ($uc) {\n\t&read_file_cached(\"$root_directory/$mod/defaultuconfig\", \\%fconfig);\n\t&read_file_cached(\"$config_directory/$mod/uconfig\", \\%fconfig);\n\t&read_file_cached(\"$user_config_directory/$mod/config\", \\%fconfig);\n\t}\nelse {\n\t&read_file_cached(\"$config_directory/$mod/config\", \\%fconfig);\n\t}\nreturn %fconfig;\n}\n\n=head2 foreign_installed(module, mode)\n\nChecks if the server for some module is installed, and possibly also checks\nif the module has been configured by Webmin.\nFor mode 1, returns 2 if the server is installed and configured for use by\nWebmin, 1 if installed but not configured, or 0 otherwise.\nFor mode 0, returns 1 if installed, 0 if not.\nIf the module does not provide an install_check.pl script, assumes that\nthe server is installed.\n\n=cut\nsub foreign_installed\n{\nmy ($mod, $configured) = @_;\nif (defined($main::foreign_installed_cache{$mod,$configured})) {\n\t# Already cached..\n\treturn $main::foreign_installed_cache{$mod,$configured};\n\t}\nelse {\n\tmy $rv;\n\tif (!&foreign_check($mod)) {\n\t\t# Module is missing\n\t\t$rv = 0;\n\t\t}\n\telse {\n\t\tmy $mdir = &module_root_directory($mod);\n\t\tif (!-r \"$mdir/install_check.pl\") {\n\t\t\t# Not known, assume OK\n\t\t\t$rv = $configured ? 2 : 1;\n\t\t\t}\n\t\telse {\n\t\t\t# Call function to check\n\t\t\t&foreign_require($mod, \"install_check.pl\");\n\t\t\t$rv = &foreign_call($mod, \"is_installed\", $configured);\n\t\t\t}\n\t\t}\n\t$main::foreign_installed_cache{$mod,$configured} = $rv;\n\treturn $rv;\n\t}\n}\n\n=head2 foreign_defined(module, function)\n\nReturns 1 if some function is defined in another module. In general, it is\nsimpler to use the syntax &defined(module::function) instead.\n\n=cut\nsub foreign_defined\n{\nmy ($pkg) = @_;\n$pkg =~ s/[^A-Za-z0-9]/_/g;\nmy $func = \"${pkg}::$_[1]\";\nreturn defined(&$func);\n}\n\n=head2 get_system_hostname([short], [skip-file])\n\nReturns the hostname of this system. If the short parameter is set to 1,\nthen the domain name is not prepended - otherwise, Webmin will attempt to get\nthe fully qualified hostname, like foo.example.com.\n\n=cut\nsub get_system_hostname\n{\nmy $m = int($_[0]);\nmy $skipfile = $_[1];\nif (!$main::get_system_hostname[$m]) {\n\tif ($gconfig{'os_type'} ne 'windows') {\n\t\t# Try some common Linux hostname files first\n\t\tmy $fromfile;\n\t\tif ($skipfile) {\n\t\t\t# Never get from file\n\t\t\t}\n\t\telsif ($gconfig{'os_type'} eq 'redhat-linux') {\n\t\t\tmy %nc;\n\t\t\t&read_env_file(\"/etc/sysconfig/network\", \\%nc);\n\t\t\tif ($nc{'HOSTNAME'}) {\n\t\t\t\t$fromfile = $nc{'HOSTNAME'};\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tmy $hn = &read_file_contents(\"/etc/hostname\");\n\t\t\t\tif ($hn) {\n\t\t\t\t\t$hn =~ s/\\r|\\n//g;\n\t\t\t\t\t$fromfile = $hn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($gconfig{'os_type'} eq 'debian-linux') {\n\t\t\tmy $hn = &read_file_contents(\"/etc/hostname\");\n\t\t\tif ($hn) {\n\t\t\t\t$hn =~ s/\\r|\\n//g;\n\t\t\t\t$fromfile = $hn;\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($gconfig{'os_type'} eq 'open-linux') {\n\t\t\tmy $hn = &read_file_contents(\"/etc/HOSTNAME\");\n\t\t\tif ($hn) {\n\t\t\t\t$hn =~ s/\\r|\\n//g;\n\t\t\t\t$fromfile = $hn;\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($gconfig{'os_type'} eq 'solaris') {\n\t\t\tmy $hn = &read_file_contents(\"/etc/nodename\");\n\t\t\tif ($hn) {\n\t\t\t\t$hn =~ s/\\r|\\n//g;\n\t\t\t\t$fromfile = $hn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t# Append domain name from DNS config if needed\n\t\tif ($fromfile && $fromfile !~ /\\./) {\n\t\t\tmy $lref = &read_file_lines(\"/etc/resolv.conf\", 1);\n\t\t\tforeach my $l (@$lref) {\n\t\t\t\tif ($l =~ /^(search|domain)\\s+(\\S+)/) {\n\t\t\t\t\t$dname = $2;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t$fromfile .= \".\".$dname;\n\t\t\t}\n\n\t\t# If we found a hostname in a file, use it\n\t\tif ($fromfile && ($m || $fromfile =~ /\\./)) {\n\t\t\tif ($m) {\n\t\t\t\t$fromfile =~ s/\\..*$//;\n\t\t\t\t}\n\t\t\t$main::get_system_hostname[$m] = $fromfile;\n\t\t\treturn $fromfile;\n\t\t\t}\n\n\t\t# Can use hostname command on Unix\n\t\t&execute_command(\"hostname\", undef,\n\t\t\t\t \\$main::get_system_hostname[$m], undef, 0, 1);\n\t\tchop($main::get_system_hostname[$m]);\n\t\tif ($?) {\n\t\t\teval \"use Sys::Hostname\";\n\t\t\tif (!$@) {\n\t\t\t\t$main::get_system_hostname[$m] = eval \"hostname()\";\n\t\t\t\t}\n\t\t\tif ($@ || !$main::get_system_hostname[$m]) {\n\t\t\t\t$main::get_system_hostname[$m] = \"UNKNOWN\";\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($main::get_system_hostname[$m] !~ /\\./ &&\n\t\t       $gconfig{'os_type'} =~ /linux$/ &&\n\t\t       !$gconfig{'no_hostname_f'} && !$_[0]) {\n\t\t\t# Try with -f flag to get fully qualified name\n\t\t\tmy $flag;\n\t\t\tmy $ex = &execute_command(\"hostname -f\", undef, \\$flag,\n\t\t\t\t\t\t  undef, 0, 1);\n\t\t\tchop($flag);\n\t\t\tif ($ex || $flag eq \"\") {\n\t\t\t\t# -f not supported! We have probably set the\n\t\t\t\t# hostname to just '-f'. Fix the problem\n\t\t\t\t# (if we are root)\n\t\t\t\tif ($< == 0) {\n\t\t\t\t\t&execute_command(\"hostname \".\n\t\t\t\t\t\tquotemeta($main::get_system_hostname[$m]),\n\t\t\t\t\t\tundef, undef, undef, 0, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t$main::get_system_hostname[$m] = $flag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse {\n\t\t# On Windows, try computername environment variable\n\t\treturn $ENV{'computername'} if ($ENV{'computername'});\n\t\treturn $ENV{'COMPUTERNAME'} if ($ENV{'COMPUTERNAME'});\n\n\t\t# Fall back to net name command\n\t\tmy $out = `net name 2>&1`;\n\t\tif ($out =~ /\\-+\\r?\\n(\\S+)/) {\n\t\t\t$main::get_system_hostname[$m] = $1;\n\t\t\t}\n\t\telse {\n\t\t\t$main::get_system_hostname[$m] = \"windows\";\n\t\t\t}\n\t\t}\n\t}\nreturn $main::get_system_hostname[$m];\n}\n\n=head2 get_webmin_version\n\nReturns the version of Webmin currently being run, such as 1.450.\n\n=cut\nsub get_webmin_version\n{\nif (!$get_webmin_version) {\n\topen(VERSION, \"$root_directory/version\") || return 0;\n\t($get_webmin_version = <VERSION>) =~ tr/\\r|\\n//d;\n\tclose(VERSION);\n\tif (length($get_webmin_version) > 6) {\n\t\t$get_webmin_version_ui = substr($get_webmin_version, 0, 5) . \".\" . substr($get_webmin_version, 5, 5 - 1) . \".\" . substr($get_webmin_version, 5 * 2 - 1);\n\t\t}\n\t}\nif ($main::webmin_script_type eq 'web' && $get_webmin_version_ui) {\n\treturn $get_webmin_version_ui;\n\t}\nelse {\n\treturn $get_webmin_version;\n\t}\n}\n\n=head2 get_module_acl([user], [module], [no-rbac], [no-default])\n\nReturns a hash containing access control options for the given user and module.\nBy default the current username and module name are used. If the no-rbac flag\nis given, the permissions will not be updated based on the user's RBAC role\n(as seen on Solaris). If the no-default flag is given, default permissions for\nthe module will not be included.\n\n=cut\nsub get_module_acl\n{\nmy $u = defined($_[0]) ? $_[0] : $base_remote_user;\nmy $m = defined($_[1]) ? $_[1] : &get_module_name();\n$m ||= \"\";\nmy $mdir = &module_root_directory($m);\nmy %rv;\nif (!$_[3]) {\n\t# Read default ACL first, to be overridden by per-user settings\n\t&read_file_cached(\"$mdir/defaultacl\", \\%rv);\n\n\t# If this isn't a master admin user, apply the negative permissions\n\t# so that he doesn't un-expectedly gain access to new features\n\tmy %gacccess;\n\t&read_file_cached(\"$config_directory/$u.acl\", \\%gaccess);\n\tif ($gaccess{'negative'}) {\n\t\t&read_file_cached(\"$mdir/negativeacl\", \\%rv);\n\t\t}\n\t}\nmy %usersacl;\nif (!$_[2] && &supports_rbac($m) && &use_rbac_module_acl($u, $m)) {\n\t# RBAC overrides exist for this user in this module\n\tmy $rbac = &get_rbac_module_acl(\n\t\t\tdefined($_[0]) ? $_[0] : $remote_user, $m);\n\tforeach my $r (keys %$rbac) {\n\t\t$rv{$r} = $rbac->{$r};\n\t\t}\n\t}\nelsif ($gconfig{\"risk_$u\"} && $m) {\n\t# ACL is defined by user's risk level\n\tmy $rf = $gconfig{\"risk_$u\"}.'.risk';\n\t&read_file_cached(\"$mdir/$rf\", \\%rv);\n\n\tmy $sf = $gconfig{\"skill_$u\"}.'.skill';\n\t&read_file_cached(\"$mdir/$sf\", \\%rv);\n\t}\nelsif ($u ne '') {\n\t# Use normal Webmin ACL, if a user is set\n\tmy $userdb = &get_userdb_string();\n\tmy $foundindb = 0;\n\tif ($userdb && ($u ne $base_remote_user || $remote_user_proto)) {\n\t\t# Look for this user in the user/group DB, if one is defined\n\t\t# and if the user might be in the DB\n\t\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($userdb);\n\t\tif (!ref($dbh)) {\n\t\t\tprint STDERR \"Failed to connect to user database : \".\n\t\t\t\t     $dbh.\"\\n\";\n\t\t\t}\n\t\telsif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t\t# Find the user in the SQL DB\n\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t\t\"select id from webmin_user where name = ?\");\n\t\t\t$cmd && $cmd->execute($u) ||\n\t\t\t\t&error(&text('euserdbacl', $dbh->errstr));\n\t\t\tmy ($id) = $cmd->fetchrow();\n\t\t\t$foundindb = 1 if (defined($id));\n\t\t\t$cmd->finish();\n\n\t\t\t# Fetch ACLs with SQL\n\t\t\tif ($foundindb) {\n\t\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t\t    \"select attr,value from webmin_user_acl \".\n\t\t\t\t    \"where id = ? and module = ?\");\n\t\t\t\t$cmd && $cmd->execute($id, $m) ||\n\t\t\t\t    &error(&text('euserdbacl', $dbh->errstr));\n\t\t\t\twhile(my ($a, $v) = $cmd->fetchrow()) {\n\t\t\t\t\t$rv{$a} = $v;\n\t\t\t\t\t}\n\t\t\t\t$cmd->finish();\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($proto eq \"ldap\") {\n\t\t\t# Find user in LDAP\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $prefix,\n\t\t\t\tfilter => '(&(cn='.$u.')(objectClass='.\n\t\t\t\t\t  $args->{'userclass'}.'))',\n\t\t\t\tscope => 'sub');\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('euserdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\tmy ($user) = $rv->all_entries;\n\n\t\t\t# Find ACL sub-object for the module\n\t\t\tmy $ldapm = $m || \"global\";\n\t\t\tif ($user) {\n\t\t\t\tmy $rv = $dbh->search(\n\t\t\t\t\tbase => $user->dn(),\n\t\t\t\t\tfilter => '(cn='.$ldapm.')',\n\t\t\t\t\tscope => 'one');\n\t\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t\t&error(&text('euserdbacl',\n\t\t\t\t\t   $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t\t}\n\t\t\t\tmy ($acl) = $rv->all_entries;\n\t\t\t\tif ($acl) {\n\t\t\t\t\tforeach my $av ($acl->get_value(\n\t\t\t\t\t\t\t'webminAclEntry')) {\n\t\t\t\t\t\tmy ($a, $v) = split(/=/, $av,2);\n\t\t\t\t\t\t$rv{$a} = $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (ref($dbh)) {\n\t\t\t&disconnect_userdb($userdb, $dbh);\n\t\t\t}\n\t\t}\n\n\tif (!$foundindb) {\n\t\t# Read from local files\n\t\t&read_file_cached(\"$config_directory/$m/$u.acl\", \\%rv);\n\t\tif ($remote_user ne $base_remote_user && !defined($_[0])) {\n\t\t\t&read_file_cached(\n\t\t\t\t\"$config_directory/$m/$remote_user.acl\",\\%rv);\n\t\t\t}\n\t\t}\n\t}\nif ($tconfig{'preload_functions'}) {\n\t&load_theme_library();\n\t}\nif (defined(&theme_get_module_acl)) {\n\t%rv = &theme_get_module_acl($u, $m, \\%rv);\n\t}\nreturn %rv;\n}\n\n=head2 get_group_module_acl(group, [module], [no-default])\n\nReturns the ACL for a Webmin group, in an optional module (which defaults to\nthe current module).\n\n=cut\nsub get_group_module_acl\n{\nmy $g = $_[0];\nmy $m = defined($_[1]) ? $_[1] : &get_module_name();\nmy $mdir = &module_root_directory($m);\nmy %rv;\nif (!$_[2]) {\n\t&read_file_cached(\"$mdir/defaultacl\", \\%rv);\n\t}\n\nmy $userdb = &get_userdb_string();\nmy $foundindb = 0;\nif ($userdb) {\n\t# Look for this group in the user/group DB\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($userdb);\n\tref($dbh) || &error(&text('egroupdbacl', $dbh));\n\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Find the group in the SQL DB\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select id from webmin_group where name = ?\");\n\t\t$cmd && $cmd->execute($g) ||\n\t\t\t&error(&text('egroupdbacl', $dbh->errstr));\n\t\tmy ($id) = $cmd->fetchrow();\n\t\t$foundindb = 1 if (defined($id));\n\t\t$cmd->finish();\n\n\t\t# Fetch ACLs with SQL\n\t\tif ($foundindb) {\n\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t    \"select attr,value from webmin_group_acl \".\n\t\t\t    \"where id = ? and module = ?\");\n\t\t\t$cmd && $cmd->execute($id, $m) ||\n\t\t\t    &error(&text('egroupdbacl', $dbh->errstr));\n\t\t\twhile(my ($a, $v) = $cmd->fetchrow()) {\n\t\t\t\t$rv{$a} = $v;\n\t\t\t\t}\n\t\t\t$cmd->finish();\n\t\t\t}\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Find group in LDAP\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(&(cn='.$g.')(objectClass='.\n                                  $args->{'groupclass'}.'))',\n\t\t\tscope => 'sub');\n\t\tif (!$rv || $rv->code) {\n\t\t\t&error(&text('egroupdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t}\n\t\tmy ($group) = $rv->all_entries;\n\n\t\t# Find ACL sub-object for the module\n\t\tmy $ldapm = $m || \"global\";\n\t\tif ($group) {\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $group->dn(),\n\t\t\t\tfilter => '(cn='.$ldapm.')',\n\t\t\t\tscope => 'one');\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('egroupdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\tmy ($acl) = $rv->all_entries;\n\t\t\tif ($acl) {\n\t\t\t\tforeach my $av ($acl->get_value(\n\t\t\t\t\t\t'webminAclEntry')) {\n\t\t\t\t\tmy ($a, $v) = split(/=/, $av, 2);\n\t\t\t\t\t$rv{$a} = $v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($userdb, $dbh);\n\t}\nif (!$foundindb) {\n\t# Read from local files\n\t&read_file_cached(\"$config_directory/$m/$g.gacl\", \\%rv);\n\t}\nif (defined(&theme_get_module_acl)) {\n\t%rv = &theme_get_module_acl($g, $m, \\%rv);\n\t}\nreturn %rv;\n}\n\n=head2 save_module_acl(&acl, [user], [module], [never-update-group])\n\nUpdates the acl hash for some user and module. The parameters are :\n\n=item acl - Hash reference for the new access control options, or undef to clear\n\n=item user - User to update, defaulting to the current user.\n\n=item module - Module to update, defaulting to the caller.\n\n=item never-update-group - Never update the user's group's ACL\n\n=cut\nsub save_module_acl\n{\nmy $u = defined($_[1]) ? $_[1] : $base_remote_user;\nmy $m = defined($_[2]) ? $_[2] : &get_module_name();\n$u eq \"webmin\" && &error(\"Invalid username webmin for ACL\");\nif (!$_[3] && &foreign_check(\"acl\")) {\n\t# Check if this user is a member of a group, and if he gets the\n\t# module from a group. If so, update its ACL as well\n\t&foreign_require(\"acl\", \"acl-lib.pl\");\n\tmy $group;\n\tforeach my $g (&acl::list_groups()) {\n\t\tif (&indexof($u, @{$g->{'members'}}) >= 0 &&\n\t\t    &indexof($m, @{$g->{'modules'}}) >= 0) {\n\t\t\t$group = $g;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\tif ($group) {\n\t\t&save_group_module_acl($_[0], $group->{'name'}, $m);\n\t\t}\n\t}\n\nmy $userdb = &get_userdb_string();\nmy $foundindb = 0;\nif ($userdb && ($u ne $base_remote_user || $remote_user_proto)) {\n\t# Look for this user in the user/group DB\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($userdb);\n\tref($dbh) || &error(&text('euserdbacl', $dbh));\n\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Find the user in the SQL DB\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select id from webmin_user where name = ?\");\n\t\t$cmd && $cmd->execute($u) ||\n\t\t\t&error(&text('euserdbacl2', $dbh->errstr));\n\t\tmy ($id) = $cmd->fetchrow();\n\t\t$foundindb = 1 if (defined($id));\n\t\t$cmd->finish();\n\n\t\t# Replace ACLs for user\n\t\tif ($foundindb) {\n\t\t\tmy $cmd = $dbh->prepare(\"delete from webmin_user_acl \".\n\t\t\t\t\t\t\"where id = ? and module = ?\");\n\t\t\t$cmd && $cmd->execute($id, $m) ||\n\t\t\t    &error(&text('euserdbacl', $dbh->errstr));\n\t\t\t$cmd->finish();\n\t\t\tif ($_[0]) {\n\t\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t\t    \"insert into webmin_user_acl \".\n\t\t\t\t    \"(id,module,attr,value) values (?,?,?,?)\");\n\t\t\t\t$cmd || &error(&text('euserdbacl2',\n\t\t\t\t\t\t     $dbh->errstr));\n\t\t\t\tforeach my $a (keys %{$_[0]}) {\n\t\t\t\t\t$cmd->execute($id,$m,$a,$_[0]->{$a}) ||\n\t\t\t\t\t    &error(&text('euserdbacl2',\n\t\t\t\t\t\t\t $dbh->errstr));\n\t\t\t\t\t$cmd->finish();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Find the user in LDAP\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(&(cn='.$u.')(objectClass='.\n                                  $args->{'userclass'}.'))',\n\t\t\tscope => 'sub');\n\t\tif (!$rv || $rv->code) {\n\t\t\t&error(&text('euserdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t}\n\t\tmy ($user) = $rv->all_entries;\n\n\t\tif ($user) {\n\t\t\t# Find the ACL sub-object for the module\n\t\t\t$foundindb = 1;\n\t\t\tmy $ldapm = $m || \"global\";\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $user->dn(),\n\t\t\t\tfilter => '(cn='.$ldapm.')',\n\t\t\t\tscope => 'one');\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('euserdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\tmy ($acl) = $rv->all_entries;\n\n\t\t\tmy @al;\n\t\t\tforeach my $a (keys %{$_[0]}) {\n\t\t\t\tpush(@al, $a.\"=\".$_[0]->{$a});\n\t\t\t\t}\n\t\t\tif ($acl) {\n\t\t\t\t# Update attributes\n\t\t\t\t$rv = $dbh->modify($acl->dn(),\n\t\t\t\t  replace => { \"webminAclEntry\", \\@al });\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# Add a sub-object\n\t\t\t\tmy @attrs = ( \"cn\", $ldapm,\n\t\t\t\t\t      \"objectClass\", \"webminAcl\",\n\t\t\t\t\t      \"webminAclEntry\", \\@al );\n\t\t\t\t$rv = $dbh->add(\"cn=\".$ldapm.\",\".$user->dn(),\n\t\t\t\t\t\tattr => \\@attrs);\n\t\t\t\t}\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('euserdbacl2',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($userdb, $dbh);\n\t}\n\nif (!$foundindb) {\n\t# Save ACL to local file\n\tif (!-d \"$config_directory/$m\") {\n\t\tmkdir(\"$config_directory/$m\", 0755);\n\t\t}\n\tif ($_[0]) {\n\t\t&write_file(\"$config_directory/$m/$u.acl\", $_[0]);\n\t\t}\n\telse {\n\t\t&unlink_file(\"$config_directory/$m/$u.acl\");\n\t\t}\n\t}\n}\n\n=head2 save_group_module_acl(&acl, group, [module], [never-update-group])\n\nUpdates the acl hash for some group and module. The parameters are :\n\n=item acl - Hash reference for the new access control options.\n\n=item group - Group name to update.\n\n=item module - Module to update, defaulting to the caller.\n\n=item never-update-group - Never update the parent group's ACL\n\n=cut\nsub save_group_module_acl\n{\nmy $g = $_[1];\nmy $m = defined($_[2]) ? $_[2] : &get_module_name();\nif (!$_[3] && &foreign_check(\"acl\")) {\n\t# Check if this group is a member of a group, and if it gets the\n\t# module from a group. If so, update the parent ACL as well\n\t&foreign_require(\"acl\", \"acl-lib.pl\");\n\tmy $group;\n\tforeach my $pg (&acl::list_groups()) {\n\t\tif (&indexof('@'.$g, @{$pg->{'members'}}) >= 0 &&\n\t\t    &indexof($m, @{$pg->{'modules'}}) >= 0) {\n\t\t\t$group = $g;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\tif ($group) {\n\t\t&save_group_module_acl($_[0], $group->{'name'}, $m);\n\t\t}\n\t}\n\nmy $userdb = &get_userdb_string();\nmy $foundindb = 0;\nif ($userdb) {\n\t# Look for this group in the user/group DB\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($userdb);\n\tref($dbh) || &error(&text('egroupdbacl', $dbh));\n\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Find the group in the SQL DB\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select id from webmin_group where name = ?\");\n\t\t$cmd && $cmd->execute($g) ||\n\t\t\t&error(&text('egroupdbacl2', $dbh->errstr));\n\t\tmy ($id) = $cmd->fetchrow();\n\t\t$foundindb = 1 if (defined($id));\n\t\t$cmd->finish();\n\n\t\t# Replace ACLs for group\n\t\tif ($foundindb) {\n\t\t\tmy $cmd = $dbh->prepare(\"delete from webmin_group_acl \".\n\t\t\t\t\t\t\"where id = ? and module = ?\");\n\t\t\t$cmd && $cmd->execute($id, $m) ||\n\t\t\t    &error(&text('egroupdbacl', $dbh->errstr));\n\t\t\t$cmd->finish();\n\t\t\tif ($_[0]) {\n\t\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t\t    \"insert into webmin_group_acl \".\n\t\t\t\t    \"(id,module,attr,value) values (?,?,?,?)\");\n\t\t\t\t$cmd || &error(&text('egroupdbacl2',\n\t\t\t\t\t\t     $dbh->errstr));\n\t\t\t\tforeach my $a (keys %{$_[0]}) {\n\t\t\t\t\t$cmd->execute($id,$m,$a,$_[0]->{$a}) ||\n\t\t\t\t\t    &error(&text('egroupdbacl2',\n\t\t\t\t\t\t\t $dbh->errstr));\n\t\t\t\t\t$cmd->finish();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Find the group in LDAP\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(&(cn='.$g.')(objectClass='.\n                                  $args->{'groupclass'}.'))',\n\t\t\tscope => 'sub');\n\t\tif (!$rv || $rv->code) {\n\t\t\t&error(&text('egroupdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t}\n\t\tmy ($group) = $rv->all_entries;\n\n\t\tmy $ldapm = $m || \"global\";\n\t\tif ($group) {\n\t\t\t# Find the ACL sub-object for the module\n\t\t\t$foundindb = 1;\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $group->dn(),\n\t\t\t\tfilter => '(cn='.$ldapm.')',\n\t\t\t\tscope => 'one');\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('egroupdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\tmy ($acl) = $rv->all_entries;\n\n\t\t\tmy @al;\n\t\t\tforeach my $a (keys %{$_[0]}) {\n\t\t\t\tpush(@al, $a.\"=\".$_[0]->{$a});\n\t\t\t\t}\n\t\t\tif ($acl) {\n\t\t\t\t# Update attributes\n\t\t\t\t$rv = $dbh->modify($acl->dn(),\n\t\t\t   \t\treplace => { \"webminAclEntry\", \\@al });\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# Add a sub-object\n\t\t\t\tmy @attrs = ( \"cn\", $ldapm,\n\t\t\t\t\t      \"objectClass\", \"webminAcl\",\n\t\t\t\t\t      \"webminAclEntry\", \\@al );\n\t\t\t\t$rv = $dbh->add(\"cn=\".$ldapm.\",\".$group->dn(),\n\t\t\t\t\t\tattr => \\@attrs);\n\t\t\t\t}\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('egroupdbacl2',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($userdb, $dbh);\n\t}\n\nif (!$foundindb) {\n\t# Save ACL to local file\n\tif (!-d \"$config_directory/$m\") {\n\t\tmkdir(\"$config_directory/$m\", 0755);\n\t\t}\n\tif ($_[0]) {\n\t\t&write_file(\"$config_directory/$m/$g.gacl\", $_[0]);\n\t\t}\n\telse {\n\t\t&unlink_file(\"$config_directory/$m/$g.gacl\");\n\t\t}\n\t}\n}\n\n=head2 init_config\n\nThis function must be called by all Webmin CGI scripts, either directly or\nindirectly via a per-module lib.pl file. It performs a number of initialization\nand housekeeping tasks, such as working out the module name, checking that the\ncurrent user has access to the module, and populating global variables. Some\nof the variables set include :\n\n=item $config_directory - Base Webmin config directory, typically /etc/webmin\n\n=item $var_directory - Base logs directory, typically /var/webmin\n\n=item %config - Per-module configuration.\n\n=item %gconfig - Global configuration.\n\n=item $scriptname - Base name of the current perl script.\n\n=item $module_name - The name of the current module.\n\n=item $module_config_directory - The config directory for this module.\n\n=item $module_config_file - The config file for this module.\n\n=item $module_var_directory - The data directory for this module.\n\n=item $module_root_directory - This module's code directory.\n\n=item $webmin_logfile - The detailed logfile for webmin.\n\n=item $remote_user - The actual username used to login to webmin.\n\n=item $base_remote_user - The username whose permissions are in effect.\n\n=item $current_theme - The theme currently in use.\n\n=item $root_directory - The first root directory of this webmin install.\n\n=item @root_directories - All root directories for this webmin install.\n\n=cut\nsub init_config\n{\n# Record first process ID that called this, so we know when it exited to clean\n# up temp files\n$main::initial_process_id ||= $$;\n\n# Configuration and spool directories\nif (!defined($ENV{'WEBMIN_CONFIG'})) {\n\tdie \"WEBMIN_CONFIG not set\";\n\t}\n$config_directory = $ENV{'WEBMIN_CONFIG'};\nif (!defined($ENV{'WEBMIN_VAR'})) {\n\topen(VARPATH, \"$config_directory/var-path\");\n\tchop($var_directory = <VARPATH>);\n\tclose(VARPATH);\n\t}\nelse {\n\t$var_directory = $ENV{'WEBMIN_VAR'};\n\t}\n$main::http_cache_directory = $ENV{'WEBMIN_VAR'}.\"/cache\";\n$main::default_debug_log_file = $ENV{'WEBMIN_VAR'}.\"/webmin.debug\";\n\nif ($ENV{'SESSION_ID'}) {\n\t# Hide this variable from called programs, but keep it for internal use\n\t$main::session_id = $ENV{'SESSION_ID'};\n\tdelete($ENV{'SESSION_ID'});\n\t}\nif ($ENV{'REMOTE_PASS'}) {\n\t# Hide the password too\n\t$main::remote_pass = $ENV{'REMOTE_PASS'};\n\tdelete($ENV{'REMOTE_PASS'});\n\t}\n\nif ($> == 0 && $< != 0 && !$ENV{'FOREIGN_MODULE_NAME'}) {\n\t# Looks like we are running setuid, but the real UID hasn't been set.\n\t# Do so now, so that executed programs don't get confused\n\t$( = $);\n\t$< = $>;\n\t}\n\n# Read the webmin global config file. This contains the OS type and version,\n# OS specific configuration and global options such as proxy servers\n$config_file = \"$config_directory/config\";\n%gconfig = ( );\n&read_file_cached($config_file, \\%gconfig);\n$gconfig{'webprefix'} = '' if (!exists($gconfig{'webprefix'}));\n$null_file = $gconfig{'os_type'} eq 'windows' ? \"NUL\" : \"/dev/null\";\n$path_separator = $gconfig{'os_type'} eq 'windows' ? ';' : ':';\n\n# Work out of this is a web, command line or cron job\nif (!$main::webmin_script_type) {\n\tif ($ENV{'SCRIPT_NAME'}) {\n\t\t# Run via a CGI\n\t\t$main::webmin_script_type = 'web';\n\t\t}\n\telse {\n\t\t# Cron jobs have no TTY\n\t\tif ($gconfig{'os_type'} eq 'windows' ||\n\t\t    open(DEVTTY, \">/dev/tty\")) {\n\t\t\t$main::webmin_script_type = 'cmd';\n\t\t\tclose(DEVTTY);\n\t\t\t}\n\t\telse {\n\t\t\t$main::webmin_script_type = 'cron';\n\t\t\t}\n\t\t}\n\t}\n\n# If this is a cron job, suppress STDERR warnings\nif ($main::webmin_script_type eq 'cron') {\n\t$SIG{__WARN__} = sub { };\n\t}\n\n# If debugging is enabled, open the debug log\nif (($ENV{'WEBMIN_DEBUG'} || $gconfig{'debug_enabled'}) &&\n    !$main::opened_debug_log++) {\n\tmy $dlog = $gconfig{'debug_file'} || $main::default_debug_log_file;\n\tmy $dsize = $gconfig{'debug_size'} || $main::default_debug_log_size;\n\tmy @st = stat($dlog);\n\tif ($dsize && $st[7] > $dsize) {\n\t\trename($dlog, $dlog.\".0\");\n\t\t}\n\n\topen(main::DEBUGLOG, \">>$dlog\");\n\t$main::opened_debug_log = 1;\n\n\tif ($gconfig{'debug_what_start'}) {\n\t\tmy $script_name = $0 =~ /([^\\/]+)$/ ? $1 : '-';\n\t\t$main::debug_log_start_time = time();\n\t\t&webmin_debug_log(\"START\", \"script=$script_name\");\n\t\t}\n\t}\n\n# Set PATH and LD_LIBRARY_PATH\nif ($gconfig{'path'}) {\n\tif ($gconfig{'syspath'}) {\n\t\t# Webmin only\n\t\t$ENV{'PATH'} = $gconfig{'path'};\n\t\t}\n\telse {\n\t\t# Include OS too\n\t\t$ENV{'PATH'} = $gconfig{'path'}.$path_separator.$ENV{'PATH'};\n\t\t}\n\t}\n$ENV{$gconfig{'ld_env'}} = $gconfig{'ld_path'} if ($gconfig{'ld_env'});\n\n# Set http_proxy and ftp_proxy environment variables, based on Webmin settings\nif ($gconfig{'http_proxy'}) {\n\t$ENV{'http_proxy'} = $gconfig{'http_proxy'};\n\t}\nif ($gconfig{'ftp_proxy'}) {\n\t$ENV{'ftp_proxy'} = $gconfig{'ftp_proxy'};\n\t}\nif ($gconfig{'noproxy'}) {\n\t$ENV{'no_proxy'} = $gconfig{'noproxy'};\n\t}\n\n# Find all root directories\nmy %miniserv;\nif (&get_miniserv_config(\\%miniserv)) {\n\t@root_directories = ( $miniserv{'root'} );\n\tfor($i=0; defined($miniserv{\"extraroot_$i\"}); $i++) {\n\t\tpush(@root_directories, $miniserv{\"extraroot_$i\"});\n\t\t}\n\t}\n\n# Work out which module we are in, and read the per-module config file\n$0 =~ s/\\\\/\\//g;\t# Force consistent path on Windows\nif (defined($ENV{'FOREIGN_MODULE_NAME'}) && $ENV{'FOREIGN_ROOT_DIRECTORY'}) {\n\t# In a foreign call - use the module name given\n\t$root_directory = $ENV{'FOREIGN_ROOT_DIRECTORY'};\n\t$module_name = $ENV{'FOREIGN_MODULE_NAME'};\n\t@root_directories = ( $root_directory ) if (!@root_directories);\n\t}\nelsif ($ENV{'SCRIPT_NAME'}) {\n\tmy $sn = $ENV{'SCRIPT_NAME'};\n\t$sn =~ s/^$gconfig{'webprefix'}\\//\\//\n\t\tif (!$gconfig{'webprefixnoredir'});\n\tif ($sn =~ /^\\/([^\\/]+)\\//) {\n\t\t# Get module name from CGI path\n\t\t$module_name = $1;\n\t\t}\n\tif ($ENV{'SERVER_ROOT'}) {\n\t\t$root_directory = $ENV{'SERVER_ROOT'};\n\t\t}\n\telsif ($ENV{'SCRIPT_FILENAME'}) {\n\t\t$root_directory = $ENV{'SCRIPT_FILENAME'};\n\t\t$root_directory =~ s/$sn$//;\n\t\t}\n\t@root_directories = ( $root_directory ) if (!@root_directories);\n\t}\nelse {\n\t# Get root directory from miniserv.conf, and deduce module name from $0\n\t$root_directory = $root_directories[0];\n\tmy $rok = 0;\n\tforeach my $r (@root_directories) {\n\t\tif ($0 =~ /^$r\\/([^\\/]+)\\/[^\\/]+$/i) {\n\t\t\t# Under a module directory\n\t\t\t$module_name = $1;\n\t\t\t$rok = 1;\n\t\t\tlast;\n\t\t\t}\n\t\telsif ($0 =~ /^$root_directory\\/[^\\/]+$/i) {\n\t\t\t# At the top level\n\t\t\t$rok = 1;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t&error(\"Script was not run with full path (failed to find $0 under $root_directory)\") if (!$rok);\n\t}\n\n# Set the umask based on config\nif ($gconfig{'umask'} ne '' && !$main::umask_already++) {\n\tumask(oct($gconfig{'umask'}));\n\t}\n\n# If this is a cron job or other background task, set the nice level\nif (!$main::nice_already && $main::webmin_script_type eq 'cron') {\n\t# Set nice level\n\tif ($gconfig{'nice'}) {\n\t\teval 'POSIX::nice($gconfig{\\'nice\\'});';\n\t\t}\n\n\t# Set IO scheduling class and priority\n\tif ($gconfig{'sclass'} ne '' || $gconfig{'sprio'} ne '') {\n\t\tmy $cmd = \"ionice\";\n\t\t$cmd .= \" -c \".quotemeta($gconfig{'sclass'})\n\t\t\tif ($gconfig{'sclass'} ne '');\n\t\t$cmd .= \" -n \".quotemeta($gconfig{'sprio'})\n\t\t\tif ($gconfig{'sprio'} ne '');\n\t\t$cmd .= \" -p $$\";\n\t\t&execute_command(\"$cmd >/dev/null 2>&1\");\n\t\t}\n\t}\n$main::nice_already++;\n\n# Get the username\nmy $u = $ENV{'BASE_REMOTE_USER'} || $ENV{'REMOTE_USER'};\n$base_remote_user = $u;\n$remote_user = $ENV{'REMOTE_USER'};\n\n# Work out if user is definitely in the DB, and if so get his attrs\n$remote_user_proto = $ENV{\"REMOTE_USER_PROTO\"};\n%remote_user_attrs = ( );\nif ($remote_user_proto) {\n\tmy $userdb = &get_userdb_string();\n\tmy ($dbh, $proto, $prefix, $args) =\n\t\t$userdb ? &connect_userdb($userdb) : ( );\n\tif (ref($dbh)) {\n\t\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t\t# Read attrs from SQL\n\t\t\tmy $cmd = $dbh->prepare(\"select webmin_user_attr.attr,webmin_user_attr.value from webmin_user_attr,webmin_user where webmin_user_attr.id = webmin_user.id and webmin_user.name = ?\");\n\t\t\tif ($cmd && $cmd->execute($base_remote_user)) {\n\t\t\t\twhile(my ($attr, $value) = $cmd->fetchrow()) {\n\t\t\t\t\t$remote_user_attrs{$attr} = $value;\n\t\t\t\t\t}\n\t\t\t\t$cmd->finish();\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($proto eq \"ldap\") {\n\t\t\t# Read attrs from LDAP\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $prefix,\n\t\t\t\tfilter => '(&(cn='.$base_remote_user.')'.\n\t\t\t\t\t  '(objectClass='.\n\t\t\t\t\t  $args->{'userclass'}.'))',\n\t\t\t\tscope => 'sub');\n\t\t\tmy ($u) = $rv && !$rv->code ? $rv->all_entries : ( );\n\t\t\tif ($u) {\n\t\t\t\tforeach $la ($u->get_value('webminAttr')) {\n\t\t\t\t\tmy ($attr, $value) = split(/=/, $la, 2);\n\t\t\t\t\t$remote_user_attrs{$attr} = $value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t&disconnect_userdb($userdb, $dbh);\n\t\t}\n\t}\n\nif ($module_name) {\n\t# Find and load the configuration file for this module\n\tmy (@ruinfo, $rgroup);\n\t$module_config_directory = \"$config_directory/$module_name\";\n\tif (&get_product_name() eq \"usermin\" &&\n\t    -r \"$module_config_directory/config.$remote_user\") {\n\t\t# Based on username\n\t\t$module_config_file = \"$module_config_directory/config.$remote_user\";\n\t\t}\n\telsif (&get_product_name() eq \"usermin\" &&\n\t    (@ruinfo = getpwnam($remote_user)) &&\n\t    ($rgroup = getgrgid($ruinfo[3])) &&\n\t    -r \"$module_config_directory/config.\\@$rgroup\") {\n\t\t# Based on group name\n\t\t$module_config_file = \"$module_config_directory/config.\\@$rgroup\";\n\t\t}\n\telse {\n\t\t# Global config\n\t\t$module_config_file = \"$module_config_directory/config\";\n\t\t}\n\t%config = ( );\n\t&read_file_cached($module_config_file, \\%config);\n\n\t# Create a module-specific var directory\n\tmy $var_base = \"$var_directory/modules\";\n\tif (!-d $var_base) {\n\t\t&make_dir($var_base, 0700);\n\t\t}\n\t$module_var_directory = \"$var_base/$module_name\";\n\tif (!-d $module_var_directory) {\n\t\t&make_dir($module_var_directory, 0700);\n\t\t}\n\n\t# Fix up windows-specific substitutions in values\n\tforeach my $k (keys %config) {\n\t\tif ($config{$k} =~ /\\$\\{systemroot\\}/) {\n\t\t\tmy $root = &get_windows_root();\n\t\t\t$config{$k} =~ s/\\$\\{systemroot\\}/$root/g;\n\t\t\t}\n\t\t}\n\t}\n\n# Record the initial module\n$main::initial_module_name ||= $module_name;\n\n# Set some useful variables\nmy $current_themes;\n$current_themes = $ENV{'MOBILE_DEVICE'} && defined($gconfig{'mobile_theme'}) ?\n\t\t    $gconfig{'mobile_theme'} :\n\t\t  defined($remote_user_attrs{'theme'}) ?\n\t\t    $remote_user_attrs{'theme'} :\n\t\t  defined($gconfig{'theme_'.$remote_user}) ?\n\t\t    $gconfig{'theme_'.$remote_user} :\n\t\t  defined($gconfig{'theme_'.$base_remote_user}) ?\n\t\t    $gconfig{'theme_'.$base_remote_user} :\n\t\t    $gconfig{'theme'};\n@current_themes = split(/\\s+/, $current_themes);\n$current_theme = $current_themes[0];\n@theme_root_directories = map { \"$root_directory/$_\" } @current_themes;\n$theme_root_directory = $theme_root_directories[0];\n@theme_configs = ( );\nforeach my $troot (@theme_root_directories) {\n\tmy %onetconfig;\n\t&read_file_cached(\"$troot/config\", \\%onetconfig);\n\t&read_file_cached(\"$troot/config\", \\%tconfig);\n\tpush(@theme_configs, \\%onetconfig);\n\t}\n$tb = defined($tconfig{'cs_header'}) ? \"bgcolor=\\\"#$tconfig{'cs_header'}\\\"\" :\n      defined($gconfig{'cs_header'}) ? \"bgcolor=\\\"#$gconfig{'cs_header'}\\\"\" :\n\t\t\t\t       \"bgcolor=\\\"#9999ff\\\"\";\n$cb = defined($tconfig{'cs_table'}) ? \"bgcolor=\\\"#$tconfig{'cs_table'}\\\"\" :\n      defined($gconfig{'cs_table'}) ? \"bgcolor=\\\"#$gconfig{'cs_table'}\\\"\" :\n\t\t\t\t      \"bgcolor=\\\"#cccccc\\\"\";\n$tb .= ' '.$tconfig{'tb'} if ($tconfig{'tb'});\n$cb .= ' '.$tconfig{'cb'} if ($tconfig{'cb'});\nif ($tconfig{'preload_functions'}) {\n\t# Force load of theme functions right now, if requested\n\t&load_theme_library();\n\t}\nif ($tconfig{'oofunctions'} && !$main::loaded_theme_oo_library++) {\n\t# Load the theme's Webmin:: package classes\n\tdo \"$theme_root_directory/$tconfig{'oofunctions'}\";\n\t}\n\n$0 =~ /([^\\/]+)$/;\n$scriptname = $1;\n$webmin_logfile = $gconfig{'webmin_log'} ? $gconfig{'webmin_log'}\n\t\t\t\t\t : \"$var_directory/webmin.log\";\n\n# Load language strings into %text\nmy @langs = &list_languages();\nmy $accepted_lang;\nif ($gconfig{'acceptlang'}) {\n\tforeach my $a (split(/,/, $ENV{'HTTP_ACCEPT_LANGUAGE'})) {\n\t\t$a =~ s/;.*//;\t# Remove ;q=0.5 or similar\n\t\tmy ($al) = grep { $_->{'lang'} eq $a } @langs;\n\t\tif ($al) {\n\t\t\t$accepted_lang = $al->{'lang'};\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\n$current_lang = $force_lang ? $force_lang :\n    $accepted_lang ? $accepted_lang :\n    $remote_user_attrs{'lang'} ? $remote_user_attrs{'lang'} :\n    $gconfig{\"lang_$remote_user\"} ? $gconfig{\"lang_$remote_user\"} :\n    $gconfig{\"lang_$base_remote_user\"} ? $gconfig{\"lang_$base_remote_user\"} :\n    $gconfig{\"lang\"} ? $gconfig{\"lang\"} : $default_lang;\nforeach my $l (@langs) {\n\t$current_lang_info = $l if ($l->{'lang'} eq $current_lang);\n\t}\n@lang_order_list = &unique($default_lang,\n\t\t     \t   split(/:/, $current_lang_info->{'fallback'}),\n\t\t\t   $current_lang);\n%text = &load_language($module_name);\n%text || &error(\"Failed to determine Webmin root from SERVER_ROOT, SCRIPT_FILENAME or the full command line\");\n\n# Get the %module_info for this module\nif ($module_name) {\n\tmy ($mi) = grep { $_->{'dir'} eq $module_name }\n\t\t\t &get_all_module_infos(2);\n\t%module_info = %$mi;\n\t$module_root_directory = &module_root_directory($module_name);\n\t}\n\nif ($module_name && !$main::no_acl_check &&\n    !defined($ENV{'FOREIGN_MODULE_NAME'}) &&\n    $main::webmin_script_type eq 'web') {\n\t# Check if the HTTP user can access this module\n\tif (!&foreign_available($module_name)) {\n\t\tif (!&foreign_check($module_name)) {\n\t\t\t&error(&text('emodulecheck',\n\t\t\t\t     \"<i>$module_info{'desc'}</i>\"));\n\t\t\t}\n\t\telse {\n\t\t\t&error(&text('emodule', \"<i>$u</i>\",\n\t\t\t\t     \"<i>$module_info{'desc'}</i>\"));\n\t\t\t}\n\t\t}\n\t$main::no_acl_check++;\n\t}\n\n# Check the Referer: header for nasty redirects\nmy @referers = split(/\\s+/, $gconfig{'referers'});\nmy $referer_site;\nmy $r = $ENV{'HTTP_REFERER'};\nmy $referer_port = $r =~ /^https:/ ? 443 : 80;\nif ($r =~ /^(http|https|ftp):\\/\\/([^:\\/]+:[^@\\/]+@)?\\[([^\\]]+)\\](:(\\d+))?/ ||\n    $r =~ /^(http|https|ftp):\\/\\/([^:\\/]+:[^@\\/]+@)?([^\\/:@]+)(:(\\d+))?/) {\n\t$referer_site = $3;\n\t$referer_port = $5 if ($5);\n\t}\nmy $http_host = $ENV{'HTTP_HOST'};\nmy $http_port = $ENV{'SERVER_PORT'} || 80;\nif ($http_host =~ s/:(\\d+)$//) {\n\t$http_port = $1;\n\t}\n$http_host =~ s/^\\[(\\S+)\\]$/$1/;\nmy $unsafe_index = $unsafe_index_cgi ||\n\t\t   &get_module_variable('$unsafe_index_cgi');\nmy $trustvar = $trust_unknown_referers ||\n\t       &get_module_variable('$trust_unknown_referers');\nmy $trust = 0;\nif (!$0) {\n\t# Script name not known\n\t$trust = 1;\n\t}\nelsif ($trustvar == 1) {\n\t# Module doesn't want referer checking at all\n\t$trust = 1;\n\t}\nelsif ($ENV{'DISABLE_REFERERS_CHECK'}) {\n\t# Check disabled by environment, perhaps due to cross-module call\n\t$trust = 1;\n\t}\nelsif (($ENV{'SCRIPT_NAME'} =~ /^\\/(index.cgi)?$/ ||\n\t$ENV{'SCRIPT_NAME'} =~ /^\\/([a-z0-9\\_\\-]+)\\/(index.cgi)?$/i) &&\n       !$unsafe_index) {\n\t# Script is a module's index.cgi, which is normally safe\n\t$trust = 1;\n\t}\nelsif ($0 =~ /(session_login|pam_login)\\.cgi$/) {\n\t# Webmin login page, which doesn't get a referer\n\t$trust = 1;\n\t}\nelsif ($gconfig{'referer'}) {\n\t# Referer checking disabled completely\n\t$trust = 1;\n\t}\nelsif (!$ENV{'MINISERV_CONFIG'}) {\n\t# Not a CGI script\n\t$trust = 1;\n\t}\nelsif ($main::no_referers_check) {\n\t# Caller requested disabling of checks completely\n\t$trust = 1;\n\t}\nelsif ($ENV{'HTTP_USER_AGENT'} =~ /^Webmin/i) {\n\t# Remote call from Webmin itself\n\t$trust = 1;\n\t}\nelsif (!$referer_site) {\n\t# No referer set in URL\n\tif (!$gconfig{'referers_none'}) {\n\t\t# Known referers are allowed\n\t\t$trust = 1;\n\t\t}\n\telsif ($trustvar == 2) {\n\t\t# Module wants to trust unknown referers\n\t\t$trust = 1;\n\t\t}\n\telse {\n\t\t$trust = 0;\n\t\t}\n\t}\nelsif (&indexof($referer_site, @referers) >= 0) {\n\t# Site is on the trusted list\n\t$trust = 1;\n\t}\nelsif ($referer_site eq $http_host &&\n       (!$referer_port || !$http_port || $referer_port == $http_port)) {\n\t# Link came from this website\n\t$trust = 1;\n\t}\nelse {\n\t# Unknown link source\n\t$trust = 0;\n\t}\n# Check for trigger URL to simply redirect to root: required for Authentic Theme 19.00+\nif ($ENV{'HTTP_X_REQUESTED_WITH'} ne \"XMLHttpRequest\" &&\n    $ENV{'REQUEST_URI'} !~ /xhr/  &&\n    $ENV{'REQUEST_URI'} !~ /pjax/ &&\n    $ENV{'REQUEST_URI'} !~ /link.cgi\\/\\d+/ &&\n    $ENV{'REQUEST_URI'} =~ /xnavigation=1/) {\n\t\t# Store requested URI if safe\n\t\tif ($main::session_id && $remote_user) {\n\t\t    my %var;\n\t\t    my $key  = 'goto';\n\t\t    my $xnav = \"xnavigation=1\";\n\t\t    my $url  = \"$gconfig{'webprefix'}$ENV{'REQUEST_URI'}\";\n\t\t    my $salt = substr(encode_base64($main::session_id), 0, 16);\n\t\t    $url =~ s/[?|&]$xnav//g;\n\t\t    $salt =~ tr/A-Za-z0-9//cd;\n\n\t\t    if (!$trust) {\n\t\t        my @parent_dir = split('/', $url);\n\t\t        $url = $gconfig{'webprefix'} ? $parent_dir[2] : $parent_dir[1];\n\t\t        if ($url =~ /.cgi/) {\n\t\t            $url = \"/\";\n\t\t        \t}\n\t\t        \telse {\n\t\t            $url = \"/\" . $url . \"/\";\n\t\t        \t}\n\t\t    \t}\n\t\t    # Append random string to stored file name, to process multiple, simultaneous requests\n\t\t    my $url_salt  = int(rand() * 10000000);\n\t\t    $var{$key} = $url;\n\n\t\t    # Write follow URL only once\n\t\t    if (!$main::redirect_built) {\n\t\t    \twrite_file(tempname('.theme_' . $salt . '_' . $url_salt . '_' . get_product_name() . '_' . $key . '_' . $remote_user), \\%var);\n\t\t    \t}\n\t\t    $main::redirect_built++\n\t\t}\n  &redirect(\"/\");\n\t}\nif (!$trust) {\n\t# Looks like a link from elsewhere .. show an error\n\t&header($text{'referer_title'}, \"\", undef, 0, 1, 1);\n\n\t$prot = lc($ENV{'HTTPS'}) eq 'on' ? \"https\" : \"http\";\n\tmy $url = \"<tt>\".&html_escape(\"$prot://$ENV{'HTTP_HOST'}$ENV{'REQUEST_URI'}\").\"</tt>\";\n\tif ($referer_site) {\n\t\t# From a known host\n\t\tprint &text('referer_warn',\n\t\t\t    \"<tt>\".&html_escape($r).\"</tt>\", $url);\n\t\tprint \"<p>\\n\";\n\t\tprint &text('referer_fix1', &html_escape($http_host)),\"<p>\\n\";\n\t\tprint &text('referer_fix2', &html_escape($http_host)),\"<p>\\n\";\n\t\t}\n\telse {\n\t\t# No referer info given\n\t\tprint &text('referer_warn_unknown', $url),\"<p>\\n\";\n\t\tprint &text('referer_fix3u'),\"<p>\\n\";\n\t\tprint &text('referer_fix2u'),\"<p>\\n\";\n\t\t}\n\tprint \"<p>\\n\";\n\n\texit;\n\t}\n$main::no_referers_check++;\n$main::completed_referers_check++;\n\n# Call theme post-init\nif (defined(&theme_post_init_config)) {\n\t&theme_post_init_config(@_);\n\t}\n\n# Record that we have done the calling library in this package\nmy ($callpkg, $lib) = caller();\n$lib =~ s/^.*\\///;\n$main::done_foreign_require{$callpkg,$lib} = 1;\n\n# If a licence checking is enabled, do it now\nif ($gconfig{'licence_module'} && !$main::done_licence_module_check &&\n    &foreign_check($gconfig{'licence_module'}) &&\n    -r \"$root_directory/$gconfig{'licence_module'}/licence_check.pl\") {\n\tmy $oldpwd = &get_current_dir();\n\t$main::done_licence_module_check++;\n\t$main::licence_module = $gconfig{'licence_module'};\n\t&foreign_require($main::licence_module, \"licence_check.pl\");\n\t($main::licence_status, $main::licence_message) =\n\t\t&foreign_call($main::licence_module, \"check_licence\");\n\tchdir($oldpwd);\n\t}\n\n# Export global variables to caller\nif ($main::export_to_caller) {\n\tforeach my $v ('$config_file', '%gconfig', '$null_file',\n\t\t       '$path_separator', '@root_directories',\n\t\t       '$root_directory', '$module_name',\n\t\t       '$base_remote_user', '$remote_user',\n\t\t       '$remote_user_proto', '%remote_user_attrs',\n\t\t       '$module_config_directory', '$module_config_file',\n\t\t       '%config', '@current_themes', '$current_theme',\n\t\t       '@theme_root_directories', '$theme_root_directory',\n\t\t       '%tconfig','@theme_configs', '$tb', '$cb', '$scriptname',\n\t\t       '$webmin_logfile', '$current_lang',\n\t\t       '$current_lang_info', '@lang_order_list', '%text',\n\t\t       '%module_info', '$module_root_directory',\n\t\t       '$module_var_directory') {\n\t\tmy ($vt, $vn) = split('', $v, 2);\n\t\teval \"${vt}${callpkg}::${vn} = ${vt}${vn}\";\n\t\t}\n\t}\n\nreturn 1;\n}\n\n=head2 load_language([module], [directory])\n\nReturns a hashtable mapping text codes to strings in the appropriate language,\nbased on the $current_lang global variable, which is in turn set based on\nthe Webmin user's selection. The optional module parameter tells the function\nwhich module to load strings for, and defaults to the calling module. The\noptional directory parameter can be used to load strings from a directory\nother than lang.\n\nIn regular module development you will never need to call this function\ndirectly, as init_config calls it for you, and places the module's strings\ninto the %text hash.\n\n=cut\nsub load_language\n{\nmy %text;\nmy $root = $root_directory;\nmy $ol = $gconfig{'overlang'};\nmy ($dir) = ($_[1] || \"lang\");\n\n# Read global lang files\nforeach my $o (@lang_order_list) {\n\tmy $ok = &read_file_cached_with_stat(\"$root/$dir/$o\", \\%text);\n\treturn () if (!$ok && $o eq $default_lang);\n\t}\nif ($ol) {\n\tforeach my $o (@lang_order_list) {\n\t\t&read_file_cached(\"$root/$ol/$o\", \\%text);\n\t\t}\n\t}\n&read_file_cached(\"$config_directory/custom-lang\", \\%text);\nforeach my $o (@lang_order_list) {\n\tnext if ($o eq \"en\");\n\t&read_file_cached(\"$config_directory/custom-lang.$o\", \\%text);\n\t}\nmy $norefs = $text{'__norefs'};\n\nif ($_[0]) {\n\t# Read module's lang files\n\tdelete($text{'__norefs'});\n\tmy $mdir = &module_root_directory($_[0]);\n\tforeach my $o (@lang_order_list) {\n\t\t&read_file_cached_with_stat(\"$mdir/$dir/$o\", \\%text);\n\t\t}\n\tif ($ol) {\n\t\tforeach my $o (@lang_order_list) {\n\t\t\t&read_file_cached(\"$mdir/$ol/$o\", \\%text);\n\t\t\t}\n\t\t}\n\t&read_file_cached(\"$config_directory/$_[0]/custom-lang\", \\%text);\n\tforeach my $o (@lang_order_list) {\n\t\tnext if ($o eq \"en\");\n\t\t&read_file_cached(\"$config_directory/$_[0]/custom-lang.$o\",\n\t\t\t\t  \\%text);\n\t\t}\n\t$norefs = $text{'__norefs'} if ($norefs);\n\t}\n\n# Replace references to other strings\nif (!$norefs) {\n\tforeach $k (keys %text) {\n\t\t$text{$k} =~ s/\\$(\\{([^\\}]+)\\}|([A-Za-z0-9\\.\\-\\_]+))/text_subs($2 || $3,\\%text)/ge;\n\t\t}\n\t}\n\nif (defined(&theme_load_language)) {\n\t&theme_load_language(\\%text, $_[0]);\n\t}\nreturn %text;\n}\n\n=head2 text_subs(string)\n\nUsed internally by load_language to expand $code substitutions in language\nfiles.\n\n=cut\nsub text_subs\n{\nif (substr($_[0], 0, 8) eq \"include:\") {\n\tlocal $_;\n\tmy $rv;\n\topen(INCLUDE, substr($_[0], 8));\n\twhile(<INCLUDE>) {\n\t\t$rv .= $_;\n\t\t}\n\tclose(INCLUDE);\n\treturn $rv;\n\t}\nelse {\n\tmy $t = $_[1]->{$_[0]};\n\treturn defined($t) ? $t : '$'.$_[0];\n\t}\n}\n\n=head2 text(message, [substitute]+)\n\nReturns a translated message from %text, but with $1, $2, etc.. replaced with\nthe substitute parameters. This makes it easy to use strings with placeholders\nthat get replaced with programmatically generated text. For example :\n\n print &text('index_hello', $remote_user),\"<p>\\n\";\n\n=cut\nsub text\n{\nmy $t = &get_module_variable('%text', 1);\nmy $rv = exists($t->{$_[0]}) ? $t->{$_[0]} : $text{$_[0]};\n$rv =~ s/\\$(\\d+)/$1 < @_ ? $_[$1] : '$'.$1/ge;\nreturn $rv;\n}\n\n=head2 encode_base64(string)\n\nEncodes a string into base64 format, for use in MIME email or HTTP\nauthorization headers.\n\n=cut\nsub encode_base64\n{\neval \"use MIME::Base64 ()\";\nif (!$@) {\n\treturn MIME::Base64::encode($_[0]);\n\t}\nmy $res;\npos($_[0]) = 0;                          # ensure start at the beginning\nwhile ($_[0] =~ /(.{1,57})/gs) {\n\t$res .= substr(pack('u57', $1), 1).\"\\n\";\n\tchop($res);\n\t}\n$res =~ tr|\\` -_|AA-Za-z0-9+/|;\nmy $padding = (3 - length($_[0]) % 3) % 3;\n$res =~ s/.{$padding}$/'=' x $padding/e if ($padding);\nreturn $res;\n}\n\n=head2 decode_base64(string)\n\nConverts a base64-encoded string into plain text. The opposite of encode_base64.\n\n=cut\nsub decode_base64\n{\neval \"use MIME::Base64 ()\";\nif (!$@) {\n\treturn MIME::Base64::decode($_[0]);\n\t}\nmy ($str) = @_;\nmy $res;\n$str =~ tr|A-Za-z0-9+=/||cd;            # remove non-base64 chars\nif (length($str) % 4) {\n\treturn undef;\n}\n$str =~ s/=+$//;                        # remove padding\n$str =~ tr|A-Za-z0-9+/| -_|;            # convert to uuencoded format\nwhile ($str =~ /(.{1,60})/gs) {\n        my $len = chr(32 + length($1)*3/4); # compute length byte\n        $res .= unpack(\"u\", $len . $1 );    # uudecode\n\t}\nreturn $res;\n}\n\n=head2 encode_base32(string)\n\nEncodes a string into base32 format.\n\n=cut\nsub encode_base32\n{\n$_ = shift @_;\nmy ($buffer, $l, $e);\n$_ = unpack('B*', $_);\ns/(.....)/000$1/g;\n$l = length;\nif ($l & 7) {\n\t$e = substr($_, $l & ~7);\n\t$_ = substr($_, 0, $l & ~7);\n\t$_ .= \"000$e\" . '0' x (5 - length $e);\n\t}\n$_ = pack('B*', $_);\ntr|\\0-\\37|A-Z2-7|;\n$_;\n}\n\n=head2 decode_base32(string)\n\nConverts a base32-encoded string into plain text. The opposite of encode_base32.\n\n=cut\nsub decode_base32\n{\n$_ = shift;\nmy ($l);\ntr|A-Z2-7|\\0-\\37|;\n$_ = unpack('B*', $_);\ns/000(.....)/$1/g;\n$l = length;\n$_ = substr($_, 0, $l & ~7) if $l & 7;\n$_ = pack('B*', $_);\nreturn $_;\n}\n\n=head2 get_module_info(module, [noclone], [forcache])\n\nReturns a hash containg details of the given module. Some useful keys are :\n\n=item dir - The module directory, like sendmail.\n\n=item desc - Human-readable description, in the current users' language.\n\n=item version - Optional module version number.\n\n=item os_support - List of supported operating systems and versions.\n\n=item category - Category on Webmin's left menu, like net.\n\n=cut\nsub get_module_info\n{\nreturn () if ($_[0] =~ /^\\./);\nmy (%rv, $clone, $o);\nmy $mdir = &module_root_directory($_[0]);\n&read_file_cached(\"$mdir/module.info\", \\%rv) || return ();\nif (-l $mdir) {\n\t# A clone is a module that links to another directory under the root\n\tforeach my $r (@root_directories) {\n\t\tif (&is_under_directory($r, $mdir)) {\n\t\t\t$clone = readlink($mdir);\n\t\t\t$clone =~ s/^.*\\///;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\n\n# Apply language-specific override files\nforeach $o (@lang_order_list) {\n\tnext if ($o eq \"en\");\n\t&read_file_cached(\"$mdir/module.info.$o\", \\%rv);\n\t}\n\n# Apply desc_$LANG overrides\nforeach $o (@lang_order_list) {\n\t$rv{\"desc\"} = $rv{\"desc_$o\"} if ($rv{\"desc_$o\"});\n\t$rv{\"longdesc\"} = $rv{\"longdesc_$o\"} if ($rv{\"longdesc_$o\"});\n\t}\n\n# Apply overrides if this is a cloned module\nif ($clone && !$_[1] && $config_directory) {\n\t$rv{'clone'} = $rv{'desc'};\n\t$rv{'cloneof'} = $clone;\n\t&read_file(\"$config_directory/$_[0]/clone\", \\%rv);\n\t}\n$rv{'dir'} = $_[0];\nmy %module_categories;\n&read_file_cached(\"$config_directory/webmin.cats\", \\%module_categories);\nmy $pn = &get_product_name();\nif (defined($rv{'category_'.$pn})) {\n\t# Can override category for webmin/usermin\n\t$rv{'category'} = $rv{'category_'.$pn};\n\t}\n$rv{'realcategory'} = $rv{'category'};\n$rv{'category'} = $module_categories{$_[0]}\n\tif (defined($module_categories{$_[0]}));\n\n# Apply site-specific description overrides\n$rv{'realdesc'} = $rv{'desc'};\nmy %descs;\n&read_file_cached(\"$config_directory/webmin.descs\", \\%descs);\nif ($descs{$_[0]}) {\n\t$rv{'desc'} = $descs{$_[0]};\n\t}\nforeach my $o (@lang_order_list) {\n\tmy $ov = $descs{$_[0].\" \".$o} || $descs{$_[0].\"_\".$o};\n\t$rv{'desc'} = $ov if ($ov);\n\t}\n\nif (!$_[2]) {\n\t# Apply per-user description override\n\tmy %gaccess = &get_module_acl(undef, \"\");\n\tif ($gaccess{'desc_'.$_[0]}) {\n\t\t$rv{'desc'} = $gaccess{'desc_'.$_[0]};\n\t\t}\n\t}\n\nif ($rv{'longdesc'}) {\n\t# All standard modules have an index.cgi\n\t$rv{'index_link'} = 'index.cgi';\n\t}\n\n# Call theme-specific override function\nif (defined(&theme_get_module_info)) {\n\t%rv = &theme_get_module_info(\\%rv, $_[0], $_[1], $_[2]);\n\t}\n\nreturn %rv;\n}\n\n=head2 get_all_module_infos(cachemode)\n\nReturns a list contains the information on all modules in this webmin\ninstall, including clones. Uses caching to reduce the number of module.info\nfiles that need to be read. Each element of the array is a hash reference\nin the same format as returned by get_module_info. The cache mode flag can be :\n0 = read and write, 1 = don't read or write, 2 = read only\n\n=cut\nsub get_all_module_infos\n{\nmy (%cache, @rv);\n\n# Is the cache out of date? (ie. have any of the root's changed?)\nmy $cache_file = \"$config_directory/module.infos.cache\";\nif (!-r $cache_file) {\n\t$cache_file = \"$var_directory/module.infos.cache\";\n\t}\nmy $changed = 0;\nif (&read_file_cached($cache_file, \\%cache)) {\n\tforeach my $r (@root_directories) {\n\t\tmy @st = stat($r);\n\t\tif ($st[9] != $cache{'mtime_'.$r}) {\n\t\t\t$changed = 2;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t$changed = 1;\n\t}\n\nif ($_[0] != 1 && !$changed && $cache{'lang'} eq $current_lang) {\n\t# Can use existing module.info cache\n\tmy %mods;\n\tforeach my $k (keys %cache) {\n\t\tif ($k =~ /^(\\S+) (\\S+)$/) {\n\t\t\t$mods{$1}->{$2} = $cache{$k};\n\t\t\t}\n\t\t}\n\t@rv = map { $mods{$_} } (keys %mods) if (%mods);\n\t}\nelse {\n\t# Need to rebuild cache\n\t%cache = ( );\n\tforeach my $r (@root_directories) {\n\t\topendir(DIR, $r);\n\t\tforeach my $m (readdir(DIR)) {\n\t\t\tnext if ($m =~ /^(config-|\\.)/ || $m =~ /\\.(cgi|pl)$/);\n\t\t\tmy %minfo = &get_module_info($m, 0, 1);\n\t\t\tnext if (!%minfo || !$minfo{'dir'});\n\t\t\tpush(@rv, \\%minfo);\n\t\t\tforeach $k (keys %minfo) {\n\t\t\t\t$cache{\"${m} ${k}\"} = $minfo{$k};\n\t\t\t\t}\n\t\t\t}\n\t\tclosedir(DIR);\n\t\tmy @st = stat($r);\n\t\t$cache{'mtime_'.$r} = $st[9];\n\t\t}\n\t$cache{'lang'} = $current_lang;\n\tif (!$_[0] && $< == 0 && $> == 0) {\n\t\teval {\n\t\t\t# Don't fail if cache write fails\n\t\t\tlocal $main::error_must_die = 1;\n\t\t\t&write_file($cache_file, \\%cache);\n\t\t\t}\n\t\t}\n\t}\n\n# Override descriptions for modules for current user\nmy %gaccess = &get_module_acl(undef, \"\");\nforeach my $m (@rv) {\n\tif ($gaccess{\"desc_\".$m->{'dir'}}) {\n\t\t$m->{'desc'} = $gaccess{\"desc_\".$m->{'dir'}};\n\t\t}\n\t}\n\n# Apply installed flags\nmy %installed;\n&read_file_cached(\"$config_directory/installed.cache\", \\%installed);\nforeach my $m (@rv) {\n\t$m->{'installed'} = $installed{$m->{'dir'}};\n\t}\n\nreturn @rv;\n}\n\n=head2 list_themes\n\nReturns an array of all installed themes, each of which is a hash ref\ncorresponding to the theme.info file.\n\n=cut\nsub list_themes\n{\nmy @rv;\nopendir(DIR, $root_directory);\nforeach my $m (readdir(DIR)) {\n\tmy %tinfo;\n\tnext if ($m =~ /^\\./);\n\tnext if (!&read_file_cached(\"$root_directory/$m/theme.info\", \\%tinfo));\n\tnext if (!&check_os_support(\\%tinfo));\n\tforeach my $o (@lang_order_list) {\n\t\tif ($tinfo{'desc_'.$o}) {\n\t\t\t$tinfo{'desc'} = $tinfo{'desc_'.$o};\n\t\t\t}\n\t\t}\n\t$tinfo{'dir'} = $m;\n\tpush(@rv, \\%tinfo);\n\t}\nclosedir(DIR);\nreturn sort { lc($a->{'desc'}) cmp lc($b->{'desc'}) } @rv;\n}\n\n=head2 get_theme_info(theme)\n\nReturns a hash containing a theme's details, taken from it's theme.info file.\nSome useful keys are :\n\n=item dir - The theme directory, like blue-theme.\n\n=item desc - Human-readable description, in the current users' language.\n\n=item version - Optional module version number.\n\n=item os_support - List of supported operating systems and versions.\n\n=cut\nsub get_theme_info\n{\nreturn () if ($_[0] =~ /^\\./);\nmy %rv;\nmy $tdir = &module_root_directory($_[0]);\n&read_file(\"$tdir/theme.info\", \\%rv) || return ();\nforeach my $o (@lang_order_list) {\n\t$rv{\"desc\"} = $rv{\"desc_$o\"} if ($rv{\"desc_$o\"});\n\t}\n$rv{\"dir\"} = $_[0];\nreturn %rv;\n}\n\n=head2 list_languages(current-lang)\n\nReturns an array of supported languages, taken from Webmin's os_list.txt file.\nEach is a hash reference with the following keys :\n\n=item lang - The short language code, like es for Spanish.\n\n=item desc - A human-readable description, in English.\n\n=item charset - An optional character set to use when displaying the language.\n\n=item titles - Set to 1 only if Webmin has title images for the language.\n\n=item fallback - The code for another language to use if a string does not exist in this one. For all languages, English is the ultimate fallback.\n\n=cut\nsub list_languages\n{\nmy ($current) = @_;\nif (!@main::list_languages_cache) {\n\tmy $o;\n\tlocal $_;\n\topen(LANG, \"$root_directory/lang_list.txt\");\n\twhile(<LANG>) {\n\t\tif (/^(\\S+)\\s+(.*)/) {\n\t\t\tmy $l = { 'desc' => $2 };\n\t\t\tforeach $o (split(/,/, $1)) {\n\t\t\t\tif ($o =~ /^([^=]+)=(.*)$/) {\n\t\t\t\t\t$l->{$1} = $2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t$l->{'index'} = scalar(@main::list_languages_cache);\n\t\t\tpush(@main::list_languages_cache, $l);\n\t\t\tmy $utf8lang = $l->{'lang'};\n\t\t\t$utf8lang =~ s/\\.(\\S+)$//;\n\t\t\t$utf8lang =~ s/_RU$//;\n\t\t\t$utf8lang .= \".UTF-8\";\n\t\t\tif ($l->{'charset'} ne 'UTF-8' &&\n\t\t\t    ($l->{'charset'} eq 'iso-8859-1' ||\n\t\t             $l->{'charset'} eq 'iso-8859-2' ||\n\t\t\t     -r \"$root_directory/lang/$utf8lang\")) {\n\t\t\t\t# Add UTF-8 variant\n\t\t\t\tmy $ul = { %$l };\n\t\t\t\t$ul->{'charset'} = 'UTF-8';\n\t\t\t\t$ul->{'lang'} = $utf8lang;\n\t\t\t\t$ul->{'index'} =\n\t\t\t\t\tscalar(@main::list_languages_cache);\n\t\t\t\t$l->{'utf8_variant'} = $ul;\n\t\t\t\tpush(@main::list_languages_cache, $ul);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(LANG);\n\t@main::list_languages_cache = sort { $a->{'desc'} cmp $b->{'desc'} }\n\t\t\t\t     @main::list_languages_cache;\n\t}\nif ($current && $current =~ /\\.UTF-8$/) {\n\t# If the user is already using a UTF-8 language encoding, filter out\n\t# languages that have a UTF-8 variant\n\treturn grep { $_->{'charset'} eq 'UTF-8' ||\n\t\t      !$_->{'utf8_variant'} } @main::list_languages_cache;\n\t}\nreturn @main::list_languages_cache;\n}\n\n=head2 read_env_file(file, &hash, [include-commented])\n\nSimilar to Webmin's read_file function, but handles files containing shell\nenvironment variables formatted like :\n\n  export FOO=bar\n  SMEG=\"spod\"\n\nThe file parameter is the full path to the file to read, and hash a Perl hash\nref to read names and values into.\n\n=cut\nsub read_env_file\n{\nlocal $_;\n&open_readfile(FILE, $_[0]) || return 0;\nwhile(<FILE>) {\n\tif ($_[2]) {\n\t\t# Remove start of line comments\n\t\ts/^\\s*#+\\s*//;\n\t\t}\n\ts/#.*$//g;\n\tif (/^\\s*(export\\s*)?([A-Za-z0-9_\\.]+)\\s*=\\s*\"(.*)\"/i ||\n\t    /^\\s*(export\\s*)?([A-Za-z0-9_\\.]+)\\s*=\\s*'(.*)'/i ||\n\t    /^\\s*(export\\s*)?([A-Za-z0-9_\\.]+)\\s*=\\s*(.*)/i) {\n\t\t$_[1]->{$2} = $3;\n\t\t}\n\t}\nclose(FILE);\nreturn 1;\n}\n\n=head2 write_env_file(file, &hash, [export])\n\nWrites out a hash to a file in name='value' format, suitable for use in a shell\nscript. The parameters are :\n\n=item file - Full path for a file to write to\n\n=item hash - Hash reference of names and values to write.\n\n=item export - If set to 1, prepend each variable setting with the word 'export'.\n\n=cut\nsub write_env_file\n{\nmy $exp = $_[2] ? \"export \" : \"\";\n&open_tempfile(FILE, \">$_[0]\");\nforeach my $k (keys %{$_[1]}) {\n\tmy $v = $_[1]->{$k};\n\tif ($v =~ /^\\S+$/) {\n\t\t&print_tempfile(FILE, \"$exp$k=$v\\n\");\n\t\t}\n\telse {\n\t\t&print_tempfile(FILE, \"$exp$k=\\\"$v\\\"\\n\");\n\t\t}\n\t}\n&close_tempfile(FILE);\n}\n\n=head2 lock_file(filename, [readonly], [forcefile])\n\nLock a file for exclusive access. If the file is already locked, spin\nuntil it is freed. Uses a .lock file, which is not 100% reliable, but seems\nto work OK. The parameters are :\n\n=item filename - File or directory to lock.\n\n=item readonly - If set, the lock is for reading the file only. More than one script can have a readonly lock, but only one can hold a write lock.\n\n=item forcefile - Force the file to be considered as a real file and not a symlink for Webmin actions logging purposes.\n\n=cut\nsub lock_file\n{\nmy ($file, $readonly, $forcefile) = @_;\nif ($file =~ /\\r|\\n|\\0/) {\n\t&error(\"Lock filename contains invalid characters\");\n\t}\nmy $realfile = &translate_filename($file);\nreturn 0 if (!$file || defined($main::locked_file_list{$realfile}));\nmy $no_lock = !&can_lock_file($realfile);\nmy $lock_tries_count = 0;\nmy $last_lock_err;\nwhile(1) {\n\tmy $pid;\n\tif (!$no_lock && open(LOCKING, \"$realfile.lock\")) {\n\t\t$pid = <LOCKING>;\n\t\t$pid = int($pid);\n\t\tclose(LOCKING);\n\t\t}\n\tif ($no_lock || !$pid || !kill(0, $pid) || $pid == $$) {\n\t\t# Got the lock!\n\t\tif (!$no_lock) {\n\t\t\t# Create the .lock file\n\t\t\tmy $lockfile = $realfile.\".lock\";\n\t\t\tunlink($lockfile);\n\t\t\topen(LOCKING, \">$lockfile\") || return 0;\n\t\t\tmy $lck = eval \"flock(LOCKING, 2+4)\";\n\t\t\tmy $err = $!;\n\t\t\tif (!$lck && !$@) {\n\t\t\t\t# Lock of lock file failed! Wait till later\n\t\t\t\tclose(LOCKING);\n\t\t\t\tunlink($lockfile);\n\t\t\t\t$last_lock_err = \"Flock failed : \".($@ || $err);\n\t\t\t\tgoto tryagain;\n\t\t\t\t}\n\t\t\tmy $ok = (print LOCKING $$,\"\\n\");\n\t\t\t$err = $!;\n\t\t\tif (!$ok) {\n\t\t\t\t# Failed to write to .lock file ..\n\t\t\t\tclose(LOCKING);\n\t\t\t\tunlink($lockfile);\n\t\t\t\t$last_lock_err = \"Lock write failed : \".$err;\n\t\t\t\tgoto tryagain;\n\t\t\t\t}\n\t\t\teval \"flock(LOCKING, 8)\";\n\t\t\t$ok = close(LOCKING);\n\t\t\t$err = $!;\n\t\t\tif (!$ok) {\n\t\t\t\t# Failed to close lock file\n\t\t\t\tunlink($lockfile);\n\t\t\t\t$last_lock_err = \"Lock close failed : \".$err;\n\t\t\t\tgoto tryagain;\n\t\t\t\t}\n\t\t\t}\n\t\t$main::locked_file_list{$realfile} = int($readonly);\n\t\tpush(@main::temporary_files, $lockfile);\n\t\tif (($gconfig{'logfiles'} || $gconfig{'logfullfiles'}) &&\n\t\t    !&get_module_variable('$no_log_file_changes') &&\n\t\t    !$readonly) {\n\t\t\t# Grab a copy of this file for later diffing\n\t\t\tmy $lnk;\n\t\t\t$main::locked_file_data{$realfile} = undef;\n\t\t\tif (-d $realfile) {\n\t\t\t\t$main::locked_file_type{$realfile} = 1;\n\t\t\t\t$main::locked_file_data{$realfile} = '';\n\t\t\t\t}\n\t\t\telsif (!$forcefile && ($lnk = readlink($realfile))) {\n\t\t\t\t$main::locked_file_type{$realfile} = 2;\n\t\t\t\t$main::locked_file_data{$realfile} = $lnk;\n\t\t\t\t}\n\t\t\telsif (open(ORIGFILE, $realfile)) {\n\t\t\t\t$main::locked_file_type{$realfile} = 0;\n\t\t\t\t$main::locked_file_data{$realfile} = '';\n\t\t\t\tlocal $_;\n\t\t\t\twhile(<ORIGFILE>) {\n\t\t\t\t\t$main::locked_file_data{$realfile} .=$_;\n\t\t\t\t\t}\n\t\t\t\tclose(ORIGFILE);\n\t\t\t\t}\n\t\t\t}\n\t\tlast;\n\t\t}\n\telsif ($pid) {\n\t\t$last_lock_err = \"Locked by PID $pid\";\n\t\t}\n\telsif (!$pid) {\n\t\t$last_lock_err = \"Lock file contains no PID\";\n\t\t}\ntryagain:\n\tsleep(1);\n\tif ($lock_tries_count++ > 5*60) {\n\t\t# Give up after 5 minutes\n\t\t&error(&text('elock_tries2', \"<tt>$realfile</tt>\", 5,\n\t\t\t     $last_lock_err));\n\t\t}\n\t}\nreturn 1;\n}\n\n=head2 unlock_file(filename)\n\nRelease a lock on a file taken out by lock_file. If Webmin actions logging of\nfile changes is enabled, then at unlock file a diff will be taken between the\nold and new contents, and stored under /var/webmin/diffs when webmin_log is\ncalled. This can then be viewed in the Webmin Actions Log module.\n\n=cut\nsub unlock_file\n{\nmy ($file) = @_;\nmy $realfile = &translate_filename($file);\nreturn if (!$file || !defined($main::locked_file_list{$realfile}));\nunlink(\"$realfile.lock\") if (&can_lock_file($realfile));\ndelete($main::locked_file_list{$realfile});\nif (exists($main::locked_file_data{$realfile})) {\n\t# Diff the new file with the old\n\tstat($realfile);\n\tmy $lnk = readlink($realfile);\n\tmy $type = -d _ ? 1 : $lnk ? 2 : 0;\n\tmy $oldtype = $main::locked_file_type{$realfile};\n\tmy $new = !defined($main::locked_file_data{$realfile});\n\tif ($new && !-e _) {\n\t\t# file doesn't exist, and never did! do nothing ..\n\t\t}\n\telsif ($new && $type == 1 || !$new && $oldtype == 1) {\n\t\t# is (or was) a directory ..\n\t\tif (-d _ && !defined($main::locked_file_data{$realfile})) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'mkdir', 'object' => $realfile });\n\t\t\t}\n\t\telsif (!-d _ && defined($main::locked_file_data{$realfile})) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'rmdir', 'object' => $realfile });\n\t\t\t}\n\t\t}\n\telsif ($new && $type == 2 || !$new && $oldtype == 2) {\n\t\t# is (or was) a symlink ..\n\t\tif ($lnk && !defined($main::locked_file_data{$realfile})) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'symlink', 'object' => $realfile,\n\t\t\t       'data' => $lnk });\n\t\t\t}\n\t\telsif (!$lnk && defined($main::locked_file_data{$realfile})) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'unsymlink', 'object' => $realfile,\n\t\t\t       'data' => $main::locked_file_data{$realfile} });\n\t\t\t}\n\t\telsif ($lnk ne $main::locked_file_data{$realfile}) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'resymlink', 'object' => $realfile,\n\t\t\t       'data' => $lnk });\n\t\t\t}\n\t\t}\n\telse {\n\t\t# is a file, or has changed type?!\n\t\tmy ($diff, $delete_file);\n\t\tmy $type = \"modify\";\n\t\tif (!-r _) {\n\t\t\topen(NEWFILE, \">$realfile\");\n\t\t\tclose(NEWFILE);\n\t\t\t$delete_file++;\n\t\t\t$type = \"delete\";\n\t\t\t}\n\t\tif (!defined($main::locked_file_data{$realfile})) {\n\t\t\t$type = \"create\";\n\t\t\t}\n\t\topen(ORIGFILE, \">$realfile.webminorig\");\n\t\tprint ORIGFILE $main::locked_file_data{$realfile};\n\t\tclose(ORIGFILE);\n\t\t$diff = &backquote_command(\n\t\t\t\"diff \".quotemeta(\"$realfile.webminorig\").\" \".\n\t\t\t\tquotemeta($realfile).\" 2>/dev/null\");\n\t\tpush(@main::locked_file_diff,\n\t\t     { 'type' => $type, 'object' => $realfile,\n\t\t       'data' => $diff } ) if ($diff);\n\t\tunlink(\"$realfile.webminorig\");\n\t\tunlink($realfile) if ($delete_file);\n\t\t}\n\n\tif ($gconfig{'logfullfiles'}) {\n\t\t# Add file details to list of those to fully log\n\t\t$main::orig_file_data{$realfile} ||=\n\t\t\t$main::locked_file_data{$realfile};\n\t\t$main::orig_file_type{$realfile} ||=\n\t\t\t$main::locked_file_type{$realfile};\n\t\t}\n\n\tdelete($main::locked_file_data{$realfile});\n\tdelete($main::locked_file_type{$realfile});\n\t}\n}\n\n=head2 test_lock(file)\n\nReturns the PID if some file is currently locked, 0 if not.\n\n=cut\nsub test_lock\n{\nmy ($file) = @_;\nmy $realfile = &translate_filename($file);\nreturn 0 if (!$file);\nreturn $$ if (defined($main::locked_file_list{$realfile}));\nreturn 0 if (!&can_lock_file($realfile));\nmy $pid;\nif (open(LOCKING, \"$realfile.lock\")) {\n\t$pid = <LOCKING>;\n\t$pid = int($pid);\n\tclose(LOCKING);\n\t}\nreturn $pid && kill(0, $pid) ? $pid : undef;\n}\n\n=head2 unlock_all_files\n\nUnlocks all files locked by the current script.\n\n=cut\nsub unlock_all_files\n{\nforeach $f (keys %main::locked_file_list) {\n\t&unlock_file($f);\n\t}\n}\n\n=head2 can_lock_file(file)\n\nReturns 1 if some file should be locked, based on the settings in the\nWebmin Configuration module. For internal use by lock_file only.\n\n=cut\nsub can_lock_file\n{\nif (&is_readonly_mode()) {\n\treturn 0;\t# never lock in read-only mode\n\t}\nelsif ($gconfig{'lockmode'} == 0) {\n\treturn 1;\t# always\n\t}\nelsif ($gconfig{'lockmode'} == 1) {\n\treturn 0;\t# never\n\t}\nelse {\n\t# Check if under any of the directories\n\tmy $match;\n\tforeach my $d (split(/\\t+/, $gconfig{'lockdirs'})) {\n\t\tif (&same_file($d, $_[0]) ||\n\t\t    &is_under_directory($d, $_[0])) {\n\t\t\t$match = 1;\n\t\t\t}\n\t\t}\n\treturn $gconfig{'lockmode'} == 2 ? $match : !$match;\n\t}\n}\n\n=head2 webmin_log(action, type, object, &params, [module], [host, script-on-host, client-ip])\n\nLog some action taken by a user. This is typically called at the end of a\nscript, once all file changes are complete and all commands run. The\nparameters are :\n\n=item action - A short code for the action being performed, like 'create'.\n\n=item type - A code for the type of object the action is performed to, like 'user'.\n\n=item object - A short name for the object, like 'joe' if the Unix user 'joe' was just created.\n\n=item params - A hash ref of additional information about the action.\n\n=item module - Name of the module in which the action was performed, which defaults to the current module.\n\n=item host - Remote host on which the action was performed. You should never need to set this (or the following two parameters), as they are used only for remote Webmin logging.\n\n=item script-on-host - Script name like create_user.cgi on the host the action was performed on.\n\n=item client-ip - IP address of the browser that performed the action.\n\n=cut\nsub webmin_log\n{\nreturn if (!$gconfig{'log'} || &is_readonly_mode());\nmy $m = $_[4] ? $_[4] : &get_module_name();\n\nif ($gconfig{'logclear'}) {\n\t# check if it is time to clear the log\n\tmy @st = stat(\"$webmin_logfile.time\");\n\tmy $write_logtime = 0;\n\tif (@st) {\n\t\tif ($st[9]+$gconfig{'logtime'}*60*60 < time()) {\n\t\t\t# clear logfile and all diff files\n\t\t\t&unlink_file(\"$ENV{'WEBMIN_VAR'}/diffs\");\n\t\t\t&unlink_file(\"$ENV{'WEBMIN_VAR'}/files\");\n\t\t\t&unlink_file(\"$ENV{'WEBMIN_VAR'}/annotations\");\n\t\t\tunlink($webmin_logfile);\n\t\t\t$write_logtime = 1;\n\t\t\t}\n\t\t}\n\telse {\n\t\t$write_logtime = 1;\n\t\t}\n\tif ($write_logtime) {\n\t\topen(LOGTIME, \">$webmin_logfile.time\");\n\t\tprint LOGTIME time(),\"\\n\";\n\t\tclose(LOGTIME);\n\t\t}\n\t}\n\n# If an action script directory is defined, call the appropriate scripts\nif ($gconfig{'action_script_dir'}) {\n\tmy ($action, $type, $object) = ($_[0], $_[1], $_[2]);\n\tmy ($basedir) = $gconfig{'action_script_dir'};\n\tfor my $dir (\"$basedir/$type/$action\", \"$basedir/$type\", $basedir) {\n\t\tnext if (!-d $dir);\n\t\tmy ($file);\n\t\topendir(DIR, $dir) or die \"Can't open $dir: $!\";\n\t\twhile (defined($file = readdir(DIR))) {\n\t\t\tnext if ($file =~ /^\\.\\.?$/); # skip . and ..\n\t\t\tnext if (!-x \"$dir/$file\");\n\t\t\tmy %OLDENV = %ENV;\n\t\t\t$ENV{'ACTION_MODULE'} = &get_module_name();\n\t\t\t$ENV{'ACTION_ACTION'} = $_[0];\n\t\t\t$ENV{'ACTION_TYPE'} = $_[1];\n\t\t\t$ENV{'ACTION_OBJECT'} = $_[2];\n\t\t\t$ENV{'ACTION_SCRIPT'} = $script_name;\n\t\t\tforeach my $p (keys %param) {\n\t\t\t    $ENV{'ACTION_PARAM_'.uc($p)} = $param{$p};\n\t\t\t    }\n\t\t\tsystem(\"$dir/$file\", @_,\n\t\t\t   \"<$null_file\", \">$null_file\", \"2>&1\");\n\t\t\t%ENV = %OLDENV;\n\t\t\t}\n\t\t}\n\t}\n\n# should logging be done at all?\nreturn if ($gconfig{'logusers'} && &indexof($base_remote_user,\n\t   split(/\\s+/, $gconfig{'logusers'})) < 0);\nreturn if ($gconfig{'logmodules'} && &indexof($m,\n\t   split(/\\s+/, $gconfig{'logmodules'})) < 0);\n\n# log the action\nmy $now = time();\nmy @tm = localtime($now);\nmy $script_name = $0 =~ /([^\\/]+)$/ ? $1 : '-';\nmy $id = sprintf \"%d.%d.%d\", $now, $$, $main::action_id_count;\nmy $idprefix = substr($now, 0, 5);\n$main::action_id_count++;\nmy $line = sprintf \"%s [%2.2d/%s/%4.4d %2.2d:%2.2d:%2.2d] %s %s %s %s %s \\\"%s\\\" \\\"%s\\\" \\\"%s\\\"\",\n\t$id, $tm[3], ucfirst($number_to_month_map{$tm[4]}), $tm[5]+1900,\n\t$tm[2], $tm[1], $tm[0],\n\t$remote_user || '-',\n\t$main::session_id || '-',\n\t$_[7] || $ENV{'REMOTE_HOST'} || '-',\n\t$m, $_[5] ? \"$_[5]:$_[6]\" : $script_name,\n\t$_[0], $_[1] ne '' ? $_[1] : '-', $_[2] ne '' ? $_[2] : '-';\nmy %param;\nforeach my $k (sort { $a cmp $b } keys %{$_[3]}) {\n\tmy $v = $_[3]->{$k};\n\tmy @pv;\n\tif ($v eq '') {\n\t\t$line .= \" $k=''\";\n\t\t@rv = ( \"\" );\n\t\t}\n\telsif (ref($v) eq 'ARRAY') {\n\t\tforeach $vv (@$v) {\n\t\t\tnext if (ref($vv));\n\t\t\tpush(@pv, $vv);\n\t\t\t$vv =~ s/(['\"\\\\\\r\\n\\t\\%])/sprintf(\"%%%2.2X\",ord($1))/ge;\n\t\t\t$line .= \" $k='$vv'\";\n\t\t\t}\n\t\t}\n\telsif (!ref($v)) {\n\t\tforeach $vv (split(/\\0/, $v)) {\n\t\t\tpush(@pv, $vv);\n\t\t\t$vv =~ s/(['\"\\\\\\r\\n\\t\\%])/sprintf(\"%%%2.2X\",ord($1))/ge;\n\t\t\t$line .= \" $k='$vv'\";\n\t\t\t}\n\t\t}\n\t$param{$k} = join(\" \", @pv);\n\t}\nopen(WEBMINLOG, \">>$webmin_logfile\");\nprint WEBMINLOG $line,\"\\n\";\nclose(WEBMINLOG);\nif ($gconfig{'logperms'}) {\n\tchmod(oct($gconfig{'logperms'}), $webmin_logfile);\n\t}\nelse {\n\tchmod(0600, $webmin_logfile);\n\t}\n\nif ($gconfig{'logfiles'} && !&get_module_variable('$no_log_file_changes')) {\n\t# Find and record the changes made to any locked files, or commands run\n\tmy $i = 0;\n\tmkdir(\"$ENV{'WEBMIN_VAR'}/diffs\", 0700);\n\tforeach my $d (@main::locked_file_diff) {\n\t\tmkdir(\"$ENV{'WEBMIN_VAR'}/diffs/$idprefix\", 0700);\n\t\tmkdir(\"$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id\", 0700);\n\t\topen(DIFFLOG, \">$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id/$i\");\n\t\tprint DIFFLOG \"$d->{'type'} $d->{'object'}\\n\";\n\t\tprint DIFFLOG $d->{'data'};\n\t\tclose(DIFFLOG);\n\t\tif ($d->{'input'}) {\n\t\t\topen(DIFFLOG,\n\t\t\t  \">$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id/$i.input\");\n\t\t\tprint DIFFLOG $d->{'input'};\n\t\t\tclose(DIFFLOG);\n\t\t\t}\n\t\tif ($gconfig{'logperms'}) {\n\t\t\tchmod(oct($gconfig{'logperms'}),\n\t\t\t     \"$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id/$i\",\n\t\t\t     \"$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id/$i.input\");\n\t\t\t}\n\t\t$i++;\n\t\t}\n\t@main::locked_file_diff = undef;\n\t}\n\nif ($gconfig{'logfullfiles'}) {\n\t# Save the original contents of any modified files\n\tmy $i = 0;\n\tmkdir(\"$ENV{'WEBMIN_VAR'}/files\", 0700);\n\tforeach my $f (keys %main::orig_file_data) {\n\t\tmkdir(\"$ENV{'WEBMIN_VAR'}/files/$idprefix\", 0700);\n\t\tmkdir(\"$ENV{'WEBMIN_VAR'}/files/$idprefix/$id\", 0700);\n\t\topen(ORIGLOG, \">$ENV{'WEBMIN_VAR'}/files/$idprefix/$id/$i\");\n\t\tif (!defined($main::orig_file_type{$f})) {\n\t\t\tprint ORIGLOG -1,\" \",$f,\"\\n\";\n\t\t\t}\n\t\telse {\n\t\t\tprint ORIGLOG $main::orig_file_type{$f},\" \",$f,\"\\n\";\n\t\t\t}\n\t\tprint ORIGLOG $main::orig_file_data{$f};\n\t\tclose(ORIGLOG);\n\t\tif ($gconfig{'logperms'}) {\n\t\t\tchmod(oct($gconfig{'logperms'}),\n\t\t\t      \"$ENV{'WEBMIN_VAR'}/files/$idprefix/$id.$i\");\n\t\t\t}\n\t\t$i++;\n\t\t}\n\t%main::orig_file_data = undef;\n\t%main::orig_file_type = undef;\n\t}\n\nif ($miniserv::page_capture_out) {\n\t# Save the whole page output\n\tmkdir(\"$ENV{'WEBMIN_VAR'}/output\", 0700);\n\tmkdir(\"$ENV{'WEBMIN_VAR'}/output/$idprefix\", 0700);\n\topen(PAGEOUT, \">$ENV{'WEBMIN_VAR'}/output/$idprefix/$id\");\n\tprint PAGEOUT $miniserv::page_capture_out;\n\tclose(PAGEOUT);\n\tif ($gconfig{'logperms'}) {\n\t\tchmod(oct($gconfig{'logperms'}),\n\t\t      \"$ENV{'WEBMIN_VAR'}/output/$idprefix/$id\");\n\t\t}\n\t$miniserv::page_capture_out = undef;\n\t}\n\n# Convert params to a format usable by parse_webmin_log\nmy %params;\nforeach my $k (keys %{$_[3]}) {\n\tmy $v = $_[3]->{$k};\n\tif (ref($v) eq 'ARRAY') {\n\t\t$params{$k} = join(\"\\0\", @$v);\n\t\t}\n\telse {\n\t\t$params{$k} = $v;\n\t\t}\n\t}\n\n# Construct description if one is needed\nmy $logemail = $gconfig{'logemail'} &&\n\t       (!$gconfig{'logmodulesemail'} ||\n\t        &indexof($m, split(/\\s+/, $gconfig{'logmodulesemail'})) >= 0) &&\n\t       &foreign_check(\"mailboxes\");\nmy $msg = undef;\nmy %minfo = &get_module_info($m);\nif ($logemail || $gconfig{'logsyslog'}) {\n\tmy $mod = &get_module_name();\n\tmy $mdir = module_root_directory($mod);\n\tif (&foreign_check(\"webminlog\")) {\n\t\t&foreign_require(\"webminlog\");\n\t\tmy $act = &webminlog::parse_logline($line);\n\t\t$msg = &webminlog::get_action_description($act, 0);\n\t\t$msg =~ s/<[^>]*>//g;\t# Remove tags\n\t\t}\n\t$msg ||= \"$_[0] $_[1] $_[2]\";\n\t}\n\n# Log to syslog too\nif ($gconfig{'logsyslog'}) {\n\teval 'use Sys::Syslog qw(:DEFAULT setlogsock);\n\t      openlog(&get_product_name(), \"cons,pid,ndelay\", \"daemon\");\n\t      setlogsock(\"inet\");';\n\tif (!$@) {\n\t\teval { syslog(\"info\", \"%s\", \"[$minfo{'desc'}] $msg\"); };\n\t\t}\n\t}\n\n# Log to email, if enabled and for this module\nif ($logemail) {\n\t# Construct an email message\n\t&foreign_require(\"mailboxes\");\n\tmy $mdesc;\n\tif ($m && $m ne \"global\") {\n\t\t$mdesc = $minfo{'desc'} || $m;\n\t\t}\n\tmy $body = $text{'log_email_desc'}.\"\\n\\n\";\n\t$body .= &text('log_email_mod', $m || \"global\").\"\\n\";\n\tif ($mdesc) {\n\t\t$body .= &text('log_email_moddesc', $mdesc).\"\\n\";\n\t\t}\n\t$body .= &text('log_email_time', &make_date(time())).\"\\n\";\n\t$body .= &text('log_email_system', &get_display_hostname()).\"\\n\";\n\t$body .= &text('log_email_user', $remote_user).\"\\n\";\n\t$body .= &text('log_email_remote', $_[7] || $ENV{'REMOTE_HOST'}).\"\\n\";\n\t$body .= &text('log_email_script', $script_name).\"\\n\";\n\tif ($main::session_id) {\n\t\t$body .= &text('log_email_session', $main::session_id).\"\\n\";\n\t\t}\n\t$body .= \"\\n\";\n\t$body .= $msg.\"\\n\";\n\t&mailboxes::send_text_mail(\n\t\t&mailboxes::get_from_address(),\n\t\t$gconfig{'logemail'},\n\t\tundef,\n\t\t$mdesc ? &text('log_email_subject', $mdesc)\n\t\t       : $text{'log_email_global'},\n\t\t$body);\n\t}\n}\n\n=head2 additional_log(type, object, data, [input])\n\nRecords additional log data for an upcoming call to webmin_log, such\nas a command that was run or SQL that was executed. Typically you will never\nneed to call this function directory.\n\n=cut\nsub additional_log\n{\nif ($gconfig{'logfiles'} && !&get_module_variable('$no_log_file_changes')) {\n\tpush(@main::locked_file_diff,\n\t     { 'type' => $_[0], 'object' => $_[1], 'data' => $_[2],\n\t       'input' => $_[3] } );\n\t}\n}\n\n=head2 webmin_debug_log(type, message)\n\nWrite something to the Webmin debug log. For internal use only.\n\n=cut\nsub webmin_debug_log\n{\nmy ($type, $msg) = @_;\nreturn 0 if (!$main::opened_debug_log);\nreturn 0 if ($gconfig{'debug_no'.$main::webmin_script_type});\nif ($gconfig{'debug_modules'}) {\n\tmy @dmods = split(/\\s+/, $gconfig{'debug_modules'});\n\treturn 0 if (&indexof($main::initial_module_name, @dmods) < 0);\n\t}\nmy $now;\neval 'use Time::HiRes qw(gettimeofday); ($now, $ms) = gettimeofday';\n$now ||= time();\nmy @tm = localtime($now);\nmy $line = sprintf\n\t\"%s [%2.2d/%s/%4.4d %2.2d:%2.2d:%2.2d.%6.6d] %s %s %s %s \\\"%s\\\"\",\n        $$, $tm[3], ucfirst($number_to_month_map{$tm[4]}), $tm[5]+1900,\n        $tm[2], $tm[1], $tm[0], $ms,\n\t$remote_user || \"-\",\n\t$ENV{'REMOTE_HOST'} || \"-\",\n\t&get_module_name() || \"-\",\n\t$type,\n\t$msg;\nseek(main::DEBUGLOG, 0, 2);\nprint main::DEBUGLOG $line.\"\\n\";\nreturn 1;\n}\n\n=head2 system_logged(command)\n\nJust calls the Perl system() function, but also logs the command run.\n\n=cut\nsub system_logged\n{\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing command $_[0]\\n\";\n\treturn 0;\n\t}\nmy @realcmd = ( &translate_command($_[0]), @_[1..$#_] );\nmy $cmd = join(\" \", @realcmd);\nmy $and;\nif ($cmd =~ s/(\\s*&\\s*)$//) {\n\t$and = $1;\n\t}\nwhile($cmd =~ s/(\\d*)(<|>)((\\/(tmp|dev)\\S+)|&\\d+)\\s*$//) { }\n$cmd =~ s/^\\((.*)\\)\\s*$/$1/;\n$cmd .= $and;\n&additional_log('exec', undef, $cmd);\nreturn system(@realcmd);\n}\n\n=head2 backquote_logged(command)\n\nExecutes a command and returns the output (like `command`), but also logs it.\n\n=cut\nsub backquote_logged\n{\nif (&is_readonly_mode()) {\n\t$? = 0;\n\tprint STDERR \"Vetoing command $_[0]\\n\";\n\treturn undef;\n\t}\nmy $realcmd = &translate_command($_[0]);\nmy $cmd = $realcmd;\nmy $and;\nif ($cmd =~ s/(\\s*&\\s*)$//) {\n\t$and = $1;\n\t}\nwhile($cmd =~ s/(\\d*)(<|>)((\\/(tmp\\/.webmin|dev)\\S+)|&\\d+)\\s*$//) { }\n$cmd =~ s/^\\((.*)\\)\\s*$/$1/;\n$cmd .= $and;\n&additional_log('exec', undef, $cmd);\n&webmin_debug_log('CMD', \"cmd=$cmd\") if ($gconfig{'debug_what_cmd'});\nif ($realcmd !~ /;|\\&\\&|\\|/ && $realcmd !~ /^\\s*\\(/) {\n\t# Force run in shell, to get useful output if command doesn't exist\n\t$realcmd = \"($realcmd)\";\n\t}\nreturn `$realcmd`;\n}\n\n=head2 backquote_with_timeout(command, timeout, safe?, [maxlines])\n\nRuns some command, waiting at most the given number of seconds for it to\ncomplete, and returns the output. The maxlines parameter sets the number\nof lines of output to capture. The safe parameter should be set to 1 if the\ncommand is safe for read-only mode users to run.\n\n=cut\nsub backquote_with_timeout\n{\nmy $realcmd = &translate_command($_[0]);\nmy $out;\nmy $pid = &open_execute_command(OUT, \"($realcmd) <$null_file\", 1, $_[2]);\nmy $start = time();\nmy $timed_out = 0;\nmy $linecount = 0;\nwhile(1) {\n\tmy $elapsed = time() - $start;\n\tlast if ($elapsed > $_[1]);\n\tmy $rmask;\n\tvec($rmask, fileno(OUT), 1) = 1;\n\tmy $sel = select($rmask, undef, undef, $_[1] - $elapsed);\n\tlast if (!$sel || $sel < 0);\n\tmy $line = <OUT>;\n\tlast if (!defined($line));\n\t$out .= $line;\n\t$linecount++;\n\tif ($_[3] && $linecount >= $_[3]) {\n\t\t# Got enough lines\n\t\tlast;\n\t\t}\n\t}\nif (kill('TERM', $pid) && time() - $start >= $_[1]) {\n\t$timed_out = 1;\n\t}\nclose(OUT);\nreturn wantarray ? ($out, $timed_out) : $out;\n}\n\n=head2 backquote_command(command, safe?)\n\nExecutes a command and returns the output (like `command`), subject to\ncommand translation. The safe parameter should be set to 1 if the command\nis safe for read-only mode users to run.\n\n=cut\nsub backquote_command\n{\nif (&is_readonly_mode() && !$_[1]) {\n\tprint STDERR \"Vetoing command $_[0]\\n\";\n\t$? = 0;\n\treturn undef;\n\t}\nmy $realcmd = &translate_command($_[0]);\n&webmin_debug_log('CMD', \"cmd=$realcmd\") if ($gconfig{'debug_what_cmd'});\nif ($realcmd !~ /;|\\&\\&|\\|/ && $realcmd !~ /^\\s*\\(/) {\n\t# Force run in shell, to get useful output if command doesn't exist\n\t$realcmd = \"($realcmd)\";\n\t}\nreturn `$realcmd`;\n}\n\n=head2 kill_logged(signal, pid, ...)\n\nLike Perl's built-in kill function, but also logs the fact that some process\nwas killed. On Windows, falls back to calling process.exe to terminate a\nprocess.\n\n=cut\nsub kill_logged\n{\nreturn scalar(@_)-1 if (&is_readonly_mode());\n&webmin_debug_log('KILL', \"signal=$_[0] pids=\".join(\" \", @_[1..@_-1]))\n\tif ($gconfig{'debug_what_procs'});\n&additional_log('kill', $_[0], join(\" \", @_[1..@_-1])) if (@_ > 1);\nif ($gconfig{'os_type'} eq 'windows') {\n\t# Emulate some kills with process.exe\n\tmy $arg = $_[0] eq \"KILL\" ? \"-k\" :\n\t\t  $_[0] eq \"TERM\" ? \"-q\" :\n\t\t  $_[0] eq \"STOP\" ? \"-s\" :\n\t\t  $_[0] eq \"CONT\" ? \"-r\" : undef;\n\tmy $ok = 0;\n\tforeach my $p (@_[1..@_-1]) {\n\t\tif ($p < 0) {\n\t\t\t$ok ||= kill($_[0], $p);\n\t\t\t}\n\t\telsif ($arg) {\n\t\t\t&execute_command(\"process $arg $p\");\n\t\t\t$ok = 1;\n\t\t\t}\n\t\t}\n\treturn $ok;\n\t}\nelse {\n\t# Normal Unix kill\n\treturn kill(@_);\n\t}\n}\n\n=head2 rename_logged(old, new)\n\nRe-names a file and logs the rename. If the old and new files are on different\nfilesystems, calls mv or the Windows rename function to do the job.\n\n=cut\nsub rename_logged\n{\n&additional_log('rename', $_[0], $_[1]) if ($_[0] ne $_[1]);\nreturn &rename_file($_[0], $_[1]);\n}\n\n=head2 rename_file(old, new)\n\nRenames a file or directory. If the old and new files are on different\nfilesystems, calls mv or the Windows rename function to do the job.\n\n=cut\nsub rename_file\n{\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing rename from $_[0] to $_[1]\\n\";\n\treturn 1;\n\t}\nmy $src = &translate_filename($_[0]);\nmy $dst = &translate_filename($_[1]);\n&webmin_debug_log('RENAME', \"src=$src dst=$dst\")\n\tif ($gconfig{'debug_what_ops'});\nmy $ok = rename($src, $dst);\nif (!$ok && $! !~ /permission/i) {\n\t# Try the mv command, in case this is a cross-filesystem rename\n\tif ($gconfig{'os_type'} eq 'windows') {\n\t\t# Need to use rename\n\t\tmy $out = &backquote_command(\"rename \".quotemeta($_[0]).\n\t\t\t\t\t     \" \".quotemeta($_[1]).\" 2>&1\");\n\t\t$ok = !$?;\n\t\t$! = $out if (!$ok);\n\t\t}\n\telse {\n\t\t# Can use mv\n\t\tmy $out = &backquote_command(\"mv \".quotemeta($_[0]).\n\t\t\t\t\t     \" \".quotemeta($_[1]).\" 2>&1\");\n\t\t$ok = !$?;\n\t\t$! = $out if (!$ok);\n\t\t}\n\t}\nreturn $ok;\n}\n\n=head2 symlink_logged(src, dest)\n\nCreate a symlink, and logs it. Effectively does the same thing as the Perl\nsymlink function.\n\n=cut\nsub symlink_logged\n{\n&lock_file($_[1]);\nmy $rv = &symlink_file($_[0], $_[1]);\n&unlock_file($_[1]);\nreturn $rv;\n}\n\n=head2 symlink_file(src, dest)\n\nCreates a soft link, unless in read-only mode. Effectively does the same thing\nas the Perl symlink function.\n\n=cut\nsub symlink_file\n{\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing symlink from $_[0] to $_[1]\\n\";\n\treturn 1;\n\t}\nmy $src = &translate_filename($_[0]);\nmy $dst = &translate_filename($_[1]);\n&webmin_debug_log('SYMLINK', \"src=$src dst=$dst\")\n\tif ($gconfig{'debug_what_ops'});\nreturn symlink($src, $dst);\n}\n\n=head2 link_file(src, dest)\n\nCreates a hard link, unless in read-only mode. The existing new link file\nwill be deleted if necessary. Effectively the same as Perl's link function.\n\n=cut\nsub link_file\n{\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing link from $_[0] to $_[1]\\n\";\n\treturn 1;\n\t}\nmy $src = &translate_filename($_[0]);\nmy $dst = &translate_filename($_[1]);\n&webmin_debug_log('LINK', \"src=$src dst=$dst\")\n\tif ($gconfig{'debug_what_ops'});\nunlink($dst);\t\t\t# make sure link works\nreturn link($src, $dst);\n}\n\n=head2 make_dir(dir, perms, recursive)\n\nCreates a directory and sets permissions on it, unless in read-only mode.\nThe perms parameter sets the octal permissions to apply, which unlike Perl's\nmkdir will really get set. The recursive flag can be set to 1 to have the\nfunction create parent directories too.\n\n=cut\nsub make_dir\n{\nmy ($dir, $perms, $recur) = @_;\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing directory $dir\\n\";\n\treturn 1;\n\t}\n$dir = &translate_filename($dir);\nmy $exists = -d $dir ? 1 : 0;\nreturn 1 if ($exists && $recur);\t# already exists\n&webmin_debug_log('MKDIR', $dir) if ($gconfig{'debug_what_ops'});\nmy $rv = mkdir($dir, $perms);\nif (!$rv && $recur) {\n\t# Failed .. try mkdir -p\n\tmy $param = $gconfig{'os_type'} eq 'windows' ? \"\" : \"-p\";\n\tmy $ex = &execute_command(\"mkdir $param \".&quote_path($dir));\n\tif ($ex) {\n\t\treturn 0;\n\t\t}\n\t}\nif (!$exists) {\n\tchmod($perms, $dir);\n\t}\nreturn 1;\n}\n\n=head2 set_ownership_permissions(user, group, perms, file, ...)\n\nSets the user, group owner and permissions on some files. The parameters are :\n\n=item user - UID or username to change the file owner to. If undef, then the owner is not changed.\n\n=item group - GID or group name to change the file group to. If undef, then the group is set to the user's primary group.\n\n=item perms - Octal permissions set to set on the file. If undef, they are left alone.\n\n=item file - One or more files or directories to modify.\n\n=cut\nsub set_ownership_permissions\n{\nmy ($user, $group, $perms, @files) = @_;\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing permission changes on \",join(\" \", @files),\"\\n\";\n\treturn 1;\n\t}\n@files = map { &translate_filename($_) } @files;\nif ($gconfig{'debug_what_ops'}) {\n\tforeach my $f (@files) {\n\t\t&webmin_debug_log('PERMS',\n\t\t\t\"file=$f user=$user group=$group perms=$perms\");\n\t\t}\n\t}\nmy $rv = 1;\nif (defined($user)) {\n\tmy $uid = $user !~ /^\\d+$/ ? getpwnam($user) : $user;\n\tmy $gid;\n\tif (defined($group)) {\n\t\t$gid = $group !~ /^\\d+$/ ? getgrnam($group) : $group;\n\t\t}\n\telse {\n\t\tmy @uinfo = getpwuid($uid);\n\t\t$gid = $uinfo[3];\n\t\t}\n\t$rv = chown($uid, $gid, @files);\n\t}\nif ($rv && defined($perms)) {\n\t$rv = chmod($perms, @files);\n\t}\nreturn $rv;\n}\n\n=head2 unlink_logged(file, ...)\n\nLike Perl's unlink function, but locks the files beforehand and un-locks them\nafter so that the deletion is logged by Webmin.\n\n=cut\nsub unlink_logged\n{\nmy %locked;\nforeach my $f (@_) {\n\tif (!&test_lock($f)) {\n\t\t&lock_file($f);\n\t\t$locked{$f} = 1;\n\t\t}\n\t}\nmy @rv = &unlink_file(@_);\nforeach my $f (@_) {\n\tif ($locked{$f}) {\n\t\t&unlock_file($f);\n\t\t}\n\t}\nreturn wantarray ? @rv : $rv[0];\n}\n\n=head2 unlink_file(file, ...)\n\nDeletes some files or directories. Like Perl's unlink function, but also\nrecursively deletes directories with the rm command if needed.\n\n=cut\nsub unlink_file\n{\nreturn 1 if (&is_readonly_mode());\nmy $rv = 1;\nmy $err;\nforeach my $f (@_) {\n\t&unflush_file_lines($f);\n\tmy $realf = &translate_filename($f);\n\t&webmin_debug_log('UNLINK', $realf) if ($gconfig{'debug_what_ops'});\n\tif (-d $realf) {\n\t\tif (!rmdir($realf)) {\n\t\t\tmy $out;\n\t\t\tif ($gconfig{'os_type'} eq 'windows') {\n\t\t\t\t# Call del and rmdir commands\n\t\t\t\tmy $qm = $realf;\n\t\t\t\t$qm =~ s/\\//\\\\/g;\n\t\t\t\tmy $out = `del /q \"$qm\" 2>&1`;\n\t\t\t\tif (!$?) {\n\t\t\t\t\t$out = `rmdir \"$qm\" 2>&1`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# Use rm command\n\t\t\t\tmy $qm = quotemeta($realf);\n\t\t\t\t$out = `rm -rf $qm 2>&1`;\n\t\t\t\t}\n\t\t\tif ($?) {\n\t\t\t\t$rv = 0;\n\t\t\t\t$err = $out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse {\n\t\tif (!unlink($realf)) {\n\t\t\t$rv = 0;\n\t\t\t$err = $!;\n\t\t\t}\n\t\t}\n\t}\nreturn wantarray ? ($rv, $err) : $rv;\n}\n\n=head2 copy_source_dest(source, dest, [copy-link-target])\n\nCopy some file or directory to a new location. Returns 1 on success, or 0\non failure - also sets $! on failure. If the source is a directory, uses\npiped tar commands to copy a whole directory structure including permissions\nand special files.\n\n=cut\nsub copy_source_dest\n{\nreturn (1, undef) if (&is_readonly_mode());\nmy ($src, $dst, $copylink) = @_;\nmy $ok = 1;\nmy ($err, $out);\n&webmin_debug_log('COPY', \"src=$src dst=$dst\")\n\tif ($gconfig{'debug_what_ops'});\nif ($gconfig{'os_type'} eq 'windows') {\n\t# No tar or cp on windows, so need to use copy command\n\t$src =~ s/\\//\\\\/g;\n\t$dst =~ s/\\//\\\\/g;\n\tif (-d $src) {\n\t\t$out = &backquote_logged(\"xcopy \\\"$src\\\" \\\"$dst\\\" /Y /E /I 2>&1\");\n\t\t}\n\telse {\n\t\t$out = &backquote_logged(\"copy /Y \\\"$src\\\" \\\"$dst\\\" 2>&1\");\n\t\t}\n\tif ($?) {\n\t\t$ok = 0;\n\t\t$err = $out;\n\t\t}\n\t}\nelsif (-d $src) {\n\t# A directory .. need to copy with tar command\n\tmy @st = stat($src);\n\tunlink($dst);\n\tmkdir($dst, 0755);\n\t&set_ownership_permissions($st[4], $st[5], $st[2], $dst);\n\t$out = &backquote_logged(\"(cd \".quotemeta($src).\" ; tar cf - . | (cd \".quotemeta($dst).\" ; tar xf -)) 2>&1\");\n\tif ($?) {\n\t\t$ok = 0;\n\t\t$err = $out;\n\t\t}\n\t}\nelsif (-l $src && !$copylink) {\n\t# A link .. re-create\n\tmy $linkdst = readlink($src);\n\t$ok = &symlink_logged($linkdst, $dst);\n\t$err = $ok ? undef : $!;\n\t}\nelse {\n\t# Can just copy with cp\n\tmy $out = &backquote_logged(\"cp -p \".quotemeta($src).\n\t\t\t\t    \" \".quotemeta($dst).\" 2>&1\");\n\tif ($?) {\n\t\t$ok = 0;\n\t\t$err = $out;\n\t\t}\n\t}\nreturn wantarray ? ($ok, $err) : $ok;\n}\n\n=head2 remote_session_name(host|&server)\n\nGenerates a session ID for some server. For this server, this will always\nbe an empty string. For a server object it will include the hostname and\nport and PID. For a server name, it will include the hostname and PID. For\ninternal use only.\n\n=cut\nsub remote_session_name\n{\nreturn ref($_[0]) && $_[0]->{'host'} && $_[0]->{'port'} ?\n\t\t\"$_[0]->{'host'}:$_[0]->{'port'}.$$\" :\n       $_[0] eq \"\" || ref($_[0]) && $_[0]->{'id'} == 0 ? \"\" :\n       ref($_[0]) ? \"\" : \"$_[0].$$\";\n}\n\n=head2 remote_foreign_require(server, module, file)\n\nConnects to rpc.cgi on a remote webmin server and have it open a session\nto a process that will actually do the require and run functions. This is the\nequivalent for foreign_require, but for a remote Webmin system. The server\nparameter can either be a hostname of a system registered in the Webmin\nServers Index module, or a hash reference for a system from that module.\n\n=cut\nsub remote_foreign_require\n{\nmy $call = { 'action' => 'require',\n\t     'module' => $_[1],\n\t     'file' => $_[2] };\nmy $sn = &remote_session_name($_[0]);\nif ($remote_session{$sn}) {\n\t$call->{'session'} = $remote_session{$sn};\n\t}\nelse {\n\t$call->{'newsession'} = 1;\n\t}\nmy $rv = &remote_rpc_call($_[0], $call);\nif ($rv->{'session'}) {\n\t$remote_session{$sn} = $rv->{'session'};\n\t$remote_session_server{$sn} = $_[0];\n\t}\n}\n\n=head2 remote_foreign_call(server, module, function, [arg]*)\n\nCall a function on a remote server. Must have been setup first with\nremote_foreign_require for the same server and module. Equivalent to\nforeign_call, but with the extra server parameter to specify the remote\nsystem's hostname.\n\n=cut\nsub remote_foreign_call\n{\nreturn undef if (&is_readonly_mode());\nmy $sn = &remote_session_name($_[0]);\nreturn &remote_rpc_call($_[0], { 'action' => 'call',\n\t\t\t\t 'module' => $_[1],\n\t\t\t\t 'func' => $_[2],\n\t\t\t\t 'session' => $remote_session{$sn},\n\t\t\t\t 'args' => [ @_[3 .. $#_] ] } );\n}\n\n=head2 remote_foreign_check(server, module, [api-only])\n\nChecks if some module is installed and supported on a remote server. Equivalent\nto foreign_check, but for the remote Webmin system specified by the server\nparameter.\n\n=cut\nsub remote_foreign_check\n{\nreturn &remote_rpc_call($_[0], { 'action' => 'check',\n\t\t\t\t 'module' => $_[1],\n\t\t\t\t 'api' => $_[2] });\n}\n\n=head2 remote_foreign_config(server, module)\n\nGets the configuration for some module from a remote server, as a hash ref.\nEquivalent to foreign_config, but for a remote system.\n\n=cut\nsub remote_foreign_config\n{\nreturn &remote_rpc_call($_[0], { 'action' => 'config',\n\t\t\t\t 'module' => $_[1] });\n}\n\n=head2 remote_eval(server, module, code)\n\nEvaluates some perl code in the context of a module on a remote webmin server.\nThe server parameter must be the hostname of a remote system, module must\nbe a module directory name, and code a string of Perl code to run. This can\nonly be called after remote_foreign_require for the same server and module.\n\n=cut\nsub remote_eval\n{\nreturn undef if (&is_readonly_mode());\nmy $sn = &remote_session_name($_[0]);\nreturn &remote_rpc_call($_[0], { 'action' => 'eval',\n\t\t\t\t 'module' => $_[1],\n\t\t\t\t 'code' => $_[2],\n\t\t\t\t 'session' => $remote_session{$sn} });\n}\n\n=head2 remote_write(server, localfile, [remotefile], [remotebasename])\n\nTransfers some local file to another server via Webmin's RPC protocol, and\nreturns the resulting remote filename. If the remotefile parameter is given,\nthat is the destination filename which will be used. Otherwise a randomly\nselected temporary filename will be used, and returned by the function.\n\n=cut\nsub remote_write\n{\nmy ($host, $localfile, $remotefile, $remotebase) = @_;\nreturn undef if (&is_readonly_mode());\nmy ($data, $got);\nmy $rv = &remote_rpc_call($host, { 'action' => 'tcpwrite',\n\t\t\t\t   'file' => $remotefile,\n\t\t\t\t   'name' => $remotebase } );\nmy $error;\nmy $serv = ref($host) ? $host->{'host'} : $host;\n&open_socket($serv || \"localhost\", $rv->[1], TWRITE, \\$error);\nreturn &$main::remote_error_handler(\"Failed to transfer file : $error\")\n\tif ($error);\nopen(FILE, $localfile) ||\n\treturn &$main::remote_error_handler(\"Failed to open $localfile : $!\");\nwhile(read(FILE, $got, 1024) > 0) {\n\tprint TWRITE $got;\n\t}\nclose(FILE);\nshutdown(TWRITE, 1);\n$error = <TWRITE>;\nif ($error && $error !~ /^OK/) {\n\t# Got back an error!\n\treturn &$main::remote_error_handler(\"Failed to transfer file : $error\");\n\t}\nclose(TWRITE);\nreturn $rv->[0];\n}\n\n=head2 remote_read(server, localfile, remotefile)\n\nTransfers a file from a remote server to this system, using Webmin's RPC\nprotocol. The server parameter must be the hostname of a system registered\nin the Webmin Servers Index module, localfile is the destination path on this\nsystem, and remotefile is the file to fetch from the remote server.\n\n=cut\nsub remote_read\n{\nmy ($host, $localfile, $remotefile) = @_;\nmy $rv = &remote_rpc_call($host, { 'action' => 'tcpread',\n\t\t\t\t   'file' => $remotefile } );\nif (!$rv->[0]) {\n\treturn &$main::remote_error_handler(\"Failed to transfer file : $rv->[1]\");\n\t}\nmy $error;\nmy $serv = ref($host) ? $host->{'host'} : $host;\n&open_socket($serv || \"localhost\", $rv->[1], TREAD, \\$error);\nreturn &$main::remote_error_handler(\"Failed to transfer file : $error\")\n\tif ($error);\nmy $got;\nopen(FILE, \">$localfile\") ||\n\treturn &$main::remote_error_handler(\"Failed to open $localfile : $!\");\nwhile(read(TREAD, $got, 1024) > 0) {\n\tprint FILE $got;\n\t}\nclose(FILE);\nclose(TREAD);\n}\n\n=head2 remote_finished\n\nClose all remote sessions. This happens automatically after a while\nanyway, but this function should be called to clean things up faster.\n\n=cut\nsub remote_finished\n{\nforeach my $sn (keys %remote_session) {\n\tmy $server = $remote_session_server{$sn};\n\t&remote_rpc_call($server, { 'action' => 'quit',\n\t\t\t            'session' => $remote_session{$sn} } );\n\tdelete($remote_session{$sn});\n\tdelete($remote_session_server{$sn});\n\t}\nforeach my $fh (keys %fast_fh_cache) {\n\tclose($fh);\n\tdelete($fast_fh_cache{$fh});\n\t}\n}\n\n=head2 remote_error_setup(&function)\n\nSets a function to be called instead of &error when a remote RPC operation\nfails. Useful if you want to have more control over your remote operations.\n\n=cut\nsub remote_error_setup\n{\n$main::remote_error_handler = $_[0] || \\&error;\n}\n\n=head2 remote_rpc_call(server, &structure)\n\nCalls rpc.cgi on some server and passes it a perl structure (hash,array,etc)\nand then reads back a reply structure. This is mainly for internal use only,\nand is called by the other remote_* functions.\n\n=cut\nsub remote_rpc_call\n{\nmy $serv;\nmy $sn = &remote_session_name($_[0]);\t# Will be undef for local connection\nif (ref($_[0])) {\n\t# Server structure was given\n\t$serv = $_[0];\n\t$serv->{'user'} || $serv->{'id'} == 0 ||\n\t\treturn &$main::remote_error_handler(\n\t\t\t\"No Webmin login set for server\");\n\t}\nelsif ($_[0]) {\n\t# lookup the server in the webmin servers module if needed\n\tif (!%main::remote_servers_cache) {\n\t\t&foreign_require(\"servers\");\n\t\tforeach $s (&foreign_call(\"servers\", \"list_servers\")) {\n\t\t\t$main::remote_servers_cache{$s->{'host'}} = $s;\n\t\t\t$main::remote_servers_cache{$s->{'host'}.\":\".$s->{'port'}} = $s;\n\t\t\t}\n\t\t}\n\t$serv = $main::remote_servers_cache{$_[0]};\n\t$serv || return &$main::remote_error_handler(\n\t\t\t\t\"No Webmin Servers entry for $_[0]\");\n\t$serv->{'user'} || return &$main::remote_error_handler(\n\t\t\t\t\"No login set for server $_[0]\");\n\t}\nmy $ip = $serv->{'ip'} || $serv->{'host'};\n\n# Work out the username and password\nmy ($user, $pass);\nif ($serv->{'sameuser'}) {\n\t$user = $remote_user;\n\tdefined($main::remote_pass) || return &$main::remote_error_handler(\n\t\t\t\t   \"Password for this server is not available\");\n\t$pass = $main::remote_pass;\n\t}\nelse {\n\t$user = $serv->{'user'};\n\t$pass = $serv->{'pass'};\n\t}\n\nif ($serv->{'fast'} || !$sn) {\n\t# Make TCP connection call to fastrpc.cgi\n\tif (!$fast_fh_cache{$sn} && $sn) {\n\t\t# Need to open the connection\n\t\tmy $reqs;\n\t\tif ($serv->{'checkssl'}) {\n\t\t\t$reqs = { 'host' => 1,\n\t\t\t\t  'checkhost' => $serv->{'host'},\n\t\t\t\t  'self' => 1 };\n\t\t\tmy %sconfig = &foreign_config(\"servers\");\n\t\t\tif ($sconfig{'capath'}) {\n\t\t\t\t$reqs->{'capath'} = $sconfig{'capath'};\n\t\t\t\t}\n\t\t\t}\n\t\tmy $con = &make_http_connection(\n\t\t\t$ip, $serv->{'port'}, $serv->{'ssl'},\n\t\t\t\"POST\", \"/fastrpc.cgi\", undef, undef, $reqs);\n\t\treturn &$main::remote_error_handler(\n\t\t    \"Failed to connect to $serv->{'host'} : $con\")\n\t\t\tif (!ref($con));\n\t\t&write_http_connection($con, \"Host: $serv->{'host'}\\r\\n\");\n\t\t&write_http_connection($con, \"User-agent: Webmin\\r\\n\");\n\t\tmy $auth = &encode_base64(\"$user:$pass\");\n\t\t$auth =~ tr/\\n//d;\n\t\t&write_http_connection($con, \"Authorization: basic $auth\\r\\n\");\n\t\t&write_http_connection($con, \"Content-length: \",\n\t\t\t\t\t     length($tostr),\"\\r\\n\");\n\t\t&write_http_connection($con, \"\\r\\n\");\n\t\t&write_http_connection($con, $tostr);\n\n\t\t# read back the response\n\t\tmy $line = &read_http_connection($con);\n\t\t$line =~ tr/\\r\\n//d;\n\t\tif ($line =~ /^HTTP\\/1\\..\\s+40[13]\\s+/) {\n\t\t\treturn &$main::remote_error_handler(\"Login to RPC server as $user rejected\");\n\t\t\t}\n\t\t$line =~ /^HTTP\\/1\\..\\s+200\\s+/ ||\n\t\t\treturn &$main::remote_error_handler(\"HTTP error : $line\");\n\t\tdo {\n\t\t\t$line = &read_http_connection($con);\n\t\t\t$line =~ tr/\\r\\n//d;\n\t\t\t} while($line);\n\t\t$line = &read_http_connection($con);\n\t\tif ($line =~ /^0\\s+(.*)/) {\n\t\t\treturn &$main::remote_error_handler(\"RPC error : $1\");\n\t\t\t}\n\t\telsif ($line =~ /^1\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/ ||\n\t\t       $line =~ /^1\\s+(\\S+)\\s+(\\S+)/) {\n\t\t\t# Started ok .. connect and save SID\n\t\t\t&close_http_connection($con);\n\t\t\tmy ($port, $sid, $version, $error) = ($1, $2, $3);\n\t\t\t&open_socket($ip, $port, $sid, \\$error);\n\t\t\treturn &$main::remote_error_handler(\"Failed to connect to fastrpc.cgi : $error\")\n\t\t\t\tif ($error);\n\t\t\t$fast_fh_cache{$sn} = $sid;\n\t\t\t$remote_server_version{$sn} = $version;\n\t\t\t}\n\t\telse {\n\t\t\twhile($stuff = &read_http_connection($con)) {\n\t\t\t\t$line .= $stuff;\n\t\t\t\t}\n\t\t\treturn &$main::remote_error_handler(\n\t\t\t\t\"Bad response from fastrpc.cgi : $line\");\n\t\t\t}\n\t\t}\n\telsif (!$fast_fh_cache{$sn}) {\n\t\t# Open the connection by running fastrpc.cgi locally\n\t\tpipe(RPCOUTr, RPCOUTw);\n\t\tif (!fork()) {\n\t\t\tuntie(*STDIN);\n\t\t\tuntie(*STDOUT);\n\t\t\topen(STDOUT, \">&RPCOUTw\");\n\t\t\tclose(STDIN);\n\t\t\tclose(RPCOUTr);\n\t\t\t$| = 1;\n\t\t\t$ENV{'REQUEST_METHOD'} = 'GET';\n\t\t\t$ENV{'SCRIPT_NAME'} = '/fastrpc.cgi';\n\t\t\t$ENV{'SERVER_ROOT'} ||= $root_directory;\n\t\t\tmy %acl;\n\t\t\tif ($base_remote_user ne 'root' &&\n\t\t\t    $base_remote_user ne 'admin') {\n\t\t\t\t# Need to fake up a login for the CGI!\n\t\t\t\t&read_acl(undef, \\%acl, [ 'root' ]);\n\t\t\t\t$ENV{'BASE_REMOTE_USER'} =\n\t\t\t\t\t$ENV{'REMOTE_USER'} =\n\t\t\t\t\t\t$acl{'root'} ? 'root' : 'admin';\n\t\t\t\t}\n\t\t\tdelete($ENV{'FOREIGN_MODULE_NAME'});\n\t\t\tdelete($ENV{'FOREIGN_ROOT_DIRECTORY'});\n\t\t\t$ENV{'DISABLE_REFERERS_CHECK'} = 1;\n\t\t\tchdir($root_directory);\n\t\t\tif (!exec(\"$root_directory/fastrpc.cgi\")) {\n\t\t\t\tprint \"exec failed : $!\\n\";\n\t\t\t\texit 1;\n\t\t\t\t}\n\t\t\t}\n\t\tclose(RPCOUTw);\n\t\tmy $line;\n\t\tdo {\n\t\t\t($line = <RPCOUTr>) =~ tr/\\r\\n//d;\n\t\t\t} while($line);\n\t\t$line = <RPCOUTr>;\n\t\tif ($line =~ /^0\\s+(.*)/) {\n\t\t\tclose(RPCOUTr);\n\t\t\treturn &$main::remote_error_handler(\"RPC error : $2\");\n\t\t\t}\n\t\telsif ($line =~ /^1\\s+(\\S+)\\s+(\\S+)/) {\n\t\t\t# Started ok .. connect and save SID\n\t\t\tclose(SOCK);\n\t\t\tclose(RPCOUTr);\n\t\t\tmy ($port, $sid, $error) = ($1, $2, undef);\n\t\t\t&open_socket(\"localhost\", $port, $sid, \\$error);\n\t\t\treturn &$main::remote_error_handler(\"Failed to connect to fastrpc.cgi : $error\") if ($error);\n\t\t\t$fast_fh_cache{$sn} = $sid;\n\t\t\t}\n\t\telse {\n\t\t\t# Unexpected response\n\t\t\tlocal $_;\n\t\t\twhile(<RPCOUTr>) {\n\t\t\t\t$line .= $_;\n\t\t\t\t}\n\t\t\tclose(RPCOUTr);\n\t\t\treturn &$main::remote_error_handler(\n\t\t\t\t\"Bad response from fastrpc.cgi : $line\");\n\t\t\t}\n\t\t}\n\t# Got a connection .. send off the request\n\tmy $fh = $fast_fh_cache{$sn};\n\tmy $tostr = &serialise_variable($_[1]);\n\tprint $fh length($tostr),\" $fh\\n\";\n\tprint $fh $tostr;\n\tmy $rstr = <$fh>;\n\tif ($rstr eq '') {\n\t\treturn &$main::remote_error_handler(\n\t\t\t\"Error reading response length from fastrpc.cgi : $!\")\n\t\t}\n\tmy $rlen = int($rstr);\n\tmy ($fromstr, $got);\n\twhile(length($fromstr) < $rlen) {\n\t\tmy $want = $rlen - length($fromstr);\n\t\tmy $readrv = read($fh, $got, $want);\n\t\tif (!defined($readrv) && $! == EINTR) {\n\t\t\t# Interrupted read .. re-try\n\t\t\tnext;\n\t\t\t}\n\t\telsif ($readrv < 0 || !defined($readrv)) {\n\t\t\treturn &$main::remote_error_handler(\n\t\t\t\t\"Failed to read from fastrpc.cgi : $!\")\n\t\t\t}\n\t\telsif ($readrv == 0) {\n\t\t\treturn &$main::remote_error_handler(\n\t\t\t\t\"Read of $want bytes from fastrpc.cgi failed\")\n\t\t\t}\n\t\t$fromstr .= $got;\n\t\t}\n\tmy $from = &unserialise_variable($fromstr);\n\tif (!$from) {\n\t\t# No response at all\n\t\treturn &$main::remote_error_handler(\"Remote Webmin error\");\n\t\t}\n\telsif (ref($from) ne 'HASH') {\n\t\t# Not a hash?!\n\t\treturn &$main::remote_error_handler(\n\t\t\t\"Invalid remote Webmin response : $from\");\n\t\t}\n\telsif (!$from->{'status'}) {\n\t\t# Call failed\n\t\t$from->{'rv'} =~ s/\\s+at\\s+(\\S+)\\s+line\\s+(\\d+)(,\\s+<\\S+>\\s+line\\s+(\\d+))?//;\n\t\treturn &$main::remote_error_handler($from->{'rv'});\n\t\t}\n\tif (defined($from->{'arv'})) {\n\t\treturn @{$from->{'arv'}};\n\t\t}\n\telse {\n\t\treturn $from->{'rv'};\n\t\t}\n\t}\nelse {\n\t# Call rpc.cgi on remote server\n\tmy $tostr = &serialise_variable($_[1]);\n\tmy $error = 0;\n\tmy $con = &make_http_connection($ip, $serv->{'port'},\n\t\t\t\t\t$serv->{'ssl'}, \"POST\", \"/rpc.cgi\");\n\treturn &$main::remote_error_handler(\"Failed to connect to $serv->{'host'} : $con\") if (!ref($con));\n\n\t&write_http_connection($con, \"Host: $serv->{'host'}\\r\\n\");\n\t&write_http_connection($con, \"User-agent: Webmin\\r\\n\");\n\tmy $auth = &encode_base64(\"$user:$pass\");\n\t$auth =~ tr/\\n//d;\n\t&write_http_connection($con, \"Authorization: basic $auth\\r\\n\");\n\t&write_http_connection($con, \"Content-length: \",length($tostr),\"\\r\\n\");\n\t&write_http_connection($con, \"\\r\\n\");\n\t&write_http_connection($con, $tostr);\n\n\t# read back the response\n\tmy $line = &read_http_connection($con);\n\t$line =~ tr/\\r\\n//d;\n\tif ($line =~ /^HTTP\\/1\\..\\s+401\\s+/) {\n\t\treturn &$main::remote_error_handler(\"Login to RPC server as $user rejected\");\n\t\t}\n\t$line =~ /^HTTP\\/1\\..\\s+200\\s+/ || return &$main::remote_error_handler(\"RPC HTTP error : $line\");\n\tdo {\n\t\t$line = &read_http_connection($con);\n\t\t$line =~ tr/\\r\\n//d;\n\t\t} while($line);\n\tmy $fromstr;\n\twhile($line = &read_http_connection($con)) {\n\t\t$fromstr .= $line;\n\t\t}\n\tclose(SOCK);\n\tmy $from = &unserialise_variable($fromstr);\n\treturn &$main::remote_error_handler(\"Invalid RPC login to $serv->{'host'}\") if (!$from->{'status'});\n\tif (defined($from->{'arv'})) {\n\t\treturn @{$from->{'arv'}};\n\t\t}\n\telse {\n\t\treturn $from->{'rv'};\n\t\t}\n\t}\n}\n\n=head2 remote_multi_callback(&servers, parallel, &function, arg|&args, &returns, &errors, [module, library])\n\nExecutes some function in parallel on multiple servers at once. Fills in\nthe returns and errors arrays respectively. If the module and library\nparameters are given, that module is remotely required on the server first,\nto check if it is connectable. The parameters are :\n\n=item servers - A list of Webmin system hash references.\n\n=item parallel - Number of parallel operations to perform.\n\n=item function - Reference to function to call for each system.\n\n=item args - Additional parameters to the function.\n\n=item returns - Array ref to place return values into, in same order as servers.\n\n=item errors - Array ref to place error messages into.\n\n=item module - Optional module to require on the remote system first.\n\n=item library - Optional library to require in the module.\n\n=cut\nsub remote_multi_callback\n{\nmy ($servs, $parallel, $func, $args, $rets, $errs, $mod, $lib) = @_;\n&remote_error_setup(\\&remote_multi_callback_error);\n\n# Call the functions\nmy $p = 0;\nforeach my $g (@$servs) {\n\tmy $rh = \"READ$p\";\n\tmy $wh = \"WRITE$p\";\n\tpipe($rh, $wh);\n\tif (!fork()) {\n\t\tclose($rh);\n\t\t$remote_multi_callback_err = undef;\n\t\tif ($mod) {\n\t\t\t# Require the remote lib\n\t\t\t&remote_foreign_require($g->{'host'}, $mod, $lib);\n\t\t\tif ($remote_multi_callback_err) {\n\t\t\t\t# Failed .. return error\n\t\t\t\tprint $wh &serialise_variable(\n\t\t\t\t\t[ undef, $remote_multi_callback_err ]);\n\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t# Call the function\n\t\tmy $a = ref($args) ? $args->[$p] : $args;\n\t\tmy $rv = &$func($g, $a);\n\n\t\t# Return the result\n\t\tprint $wh &serialise_variable(\n\t\t\t[ $rv, $remote_multi_callback_err ]);\n\t\tclose($wh);\n\t\texit(0);\n\t\t}\n\tclose($wh);\n\t$p++;\n\t}\n\n# Read back the results\n$p = 0;\nforeach my $g (@$servs) {\n\tmy $rh = \"READ$p\";\n\tmy $line = <$rh>;\n\tif (!$line) {\n\t\t$errs->[$p] = \"Failed to read response from $g->{'host'}\";\n\t\t}\n\telse {\n\t\tmy $rv = &unserialise_variable($line);\n\t\tclose($rh);\n\t\t$rets->[$p] = $rv->[0];\n\t\t$errs->[$p] = $rv->[1];\n\t\t}\n\t$p++;\n\t}\n\n&remote_error_setup(undef);\n}\n\nsub remote_multi_callback_error\n{\n$remote_multi_callback_err = $_[0];\n}\n\n=head2 serialise_variable(variable)\n\nConverts some variable (maybe a scalar, hash ref, array ref or scalar ref)\ninto a url-encoded string. In the cases of arrays and hashes, it is recursively\ncalled on each member to serialize the entire object.\n\n=cut\nsub serialise_variable\n{\nif (!defined($_[0])) {\n\treturn 'UNDEF';\n\t}\nmy $r = ref($_[0]);\nmy $rv;\nif (!$r) {\n\t$rv = &urlize($_[0]);\n\t}\nelsif ($r eq 'SCALAR') {\n\t$rv = &urlize(${$_[0]});\n\t}\nelsif ($r eq 'ARRAY') {\n\t$rv = join(\",\", map { &urlize(&serialise_variable($_)) } @{$_[0]});\n\t}\nelsif ($r eq 'HASH') {\n\t$rv = join(\",\", map { &urlize(&serialise_variable($_)).\",\".\n\t\t\t      &urlize(&serialise_variable($_[0]->{$_})) }\n\t\t            keys %{$_[0]});\n\t}\nelsif ($r eq 'REF') {\n\t$rv = &serialise_variable(${$_[0]});\n\t}\nelsif ($r eq 'CODE') {\n\t# Code not handled\n\t$rv = undef;\n\t}\nelsif ($r) {\n\t# An object - treat as a hash\n\t$r = \"OBJECT \".&urlize($r);\n\t$rv = join(\",\", map { &urlize(&serialise_variable($_)).\",\".\n\t\t\t      &urlize(&serialise_variable($_[0]->{$_})) }\n\t\t            keys %{$_[0]});\n\t}\nreturn ($r ? $r : 'VAL').\",\".$rv;\n}\n\n=head2 unserialise_variable(string)\n\nConverts a string created by serialise_variable() back into the original\nscalar, hash ref, array ref or scalar ref. If the original variable was a Perl\nobject, the same class is used on this system, if available.\n\n=cut\nsub unserialise_variable\n{\nmy @v = split(/,/, $_[0]);\nmy $rv;\nif ($v[0] eq 'VAL') {\n\t@v = split(/,/, $_[0], -1);\n\t$rv = &un_urlize($v[1]);\n\t}\nelsif ($v[0] eq 'SCALAR') {\n\tlocal $r = &un_urlize($v[1]);\n\t$rv = \\$r;\n\t}\nelsif ($v[0] eq 'ARRAY') {\n\t$rv = [ ];\n\tfor(my $i=1; $i<@v; $i++) {\n\t\tpush(@$rv, &unserialise_variable(&un_urlize($v[$i])));\n\t\t}\n\t}\nelsif ($v[0] eq 'HASH') {\n\t$rv = { };\n\tfor(my $i=1; $i<@v; $i+=2) {\n\t\t$rv->{&unserialise_variable(&un_urlize($v[$i]))} =\n\t\t\t&unserialise_variable(&un_urlize($v[$i+1]));\n\t\t}\n\t}\nelsif ($v[0] eq 'REF') {\n\tlocal $r = &unserialise_variable($v[1]);\n\t$rv = \\$r;\n\t}\nelsif ($v[0] eq 'UNDEF') {\n\t$rv = undef;\n\t}\nelsif ($v[0] =~ /^OBJECT\\s+(.*)$/) {\n\t# An object hash that we have to re-bless\n\tmy $cls = $1;\n\t$rv = { };\n\tfor(my $i=1; $i<@v; $i+=2) {\n\t\t$rv->{&unserialise_variable(&un_urlize($v[$i]))} =\n\t\t\t&unserialise_variable(&un_urlize($v[$i+1]));\n\t\t}\n\teval \"use $cls\";\n\tbless $rv, $cls;\n\t}\nreturn $rv;\n}\n\n=head2 other_groups(user)\n\nReturns a list of secondary groups a user is a member of, as a list of\ngroup IDs.\n\n=cut\nsub other_groups\n{\nmy ($user) = @_;\nmy @rv;\nsetgrent();\nwhile(my @g = getgrent()) {\n\tmy @m = split(/\\s+/, $g[3]);\n\tpush(@rv, $g[2]) if (&indexof($user, @m) >= 0);\n\t}\nendgrent() if ($gconfig{'os_type'} ne 'hpux');\nreturn @rv;\n}\n\n=head2 date_chooser_button(dayfield, monthfield, yearfield)\n\nReturns HTML for a button that pops up a data chooser window. The parameters\nare :\n\n=item dayfield - Name of the text field to place the day of the month into.\n\n=item monthfield - Name of the select field to select the month of the year in, indexed from 1.\n\n=item yearfield - Name of the text field to place the year into.\n\n=cut\nsub date_chooser_button\n{\nreturn &theme_date_chooser_button(@_)\n\tif (defined(&theme_date_chooser_button));\nmy ($w, $h) = (250, 225);\nif ($gconfig{'db_sizedate'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizedate'});\n\t}\nreturn \"<input type=button onClick='window.dfield = form.$_[0]; window.mfield = form.$_[1]; window.yfield = form.$_[2]; window.open(\\\"$gconfig{'webprefix'}/date_chooser.cgi?day=\\\"+escape(dfield.value)+\\\"&month=\\\"+escape(mfield.selectedIndex)+\\\"&year=\\\"+yfield.value, \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,width=$w,height=$h\\\")' value=\\\"...\\\">\\n\";\n}\n\n=head2 help_file(module, file)\n\nReturns the path to a module's help file of some name, typically under the\nhelp directory with a .html extension.\n\n=cut\nsub help_file\n{\nmy $mdir = &module_root_directory($_[0]);\nmy $dir = \"$mdir/help\";\nforeach my $o (@lang_order_list) {\n\tmy $lang = \"$dir/$_[1].$o.html\";\n\treturn $lang if (-r $lang);\n\t}\nreturn \"$dir/$_[1].html\";\n}\n\n=head2 seed_random\n\nSeeds the random number generator, if not already done in this script. On Linux\nthis makes use of the current time, process ID and a read from /dev/urandom.\nOn other systems, only the current time and process ID are used.\n\n=cut\nsub seed_random\n{\nif (!$main::done_seed_random) {\n\tif (open(RANDOM, \"/dev/urandom\")) {\n\t\tmy $buf;\n\t\tread(RANDOM, $buf, 4);\n\t\tclose(RANDOM);\n\t\tsrand(time() ^ $$ ^ $buf);\n\t\t}\n\telse {\n\t\tsrand(time() ^ $$);\n\t\t}\n\t$main::done_seed_random = 1;\n\t}\n}\n\n=head2 disk_usage_kb(directory)\n\nReturns the number of kB used by some directory and all subdirs. Implemented\nby calling the C<du -k> command.\n\n=cut\nsub disk_usage_kb\n{\nmy $dir = &translate_filename($_[0]);\nmy $out;\nmy $ex = &execute_command(\"du -sk \".quotemeta($dir), undef, \\$out, undef, 0, 1);\nif ($ex) {\n\t&execute_command(\"du -s \".quotemeta($dir), undef, \\$out, undef, 0, 1);\n\t}\nreturn $out =~ /^([0-9]+)/ ? $1 : \"???\";\n}\n\n=head2 recursive_disk_usage(directory, [skip-regexp], [only-regexp])\n\nReturns the number of bytes taken up by all files in some directory and all\nsub-directories, by summing up their lengths. The disk_usage_kb is more\nreflective of reality, as the filesystem typically pads file sizes to 1k or\n4k blocks.\n\n=cut\nsub recursive_disk_usage\n{\nmy $dir = &translate_filename($_[0]);\nmy $skip = $_[1];\nmy $only = $_[2];\nif (-l $dir) {\n\treturn 0;\n\t}\nelsif (!-d $dir) {\n\tmy @st = stat($dir);\n\treturn $st[7];\n\t}\nelse {\n\tmy $rv = 0;\n\topendir(DIR, $dir);\n\tmy @files = readdir(DIR);\n\tclosedir(DIR);\n\tforeach my $f (@files) {\n\t\tnext if ($f eq \".\" || $f eq \"..\");\n\t\tnext if ($skip && $f =~ /$skip/);\n\t\tnext if ($only && $f !~ /$only/);\n\t\t$rv += &recursive_disk_usage(\"$dir/$f\", $skip, $only);\n\t\t}\n\treturn $rv;\n\t}\n}\n\n=head2 help_search_link(term, [ section, ... ] )\n\nReturns HTML for a link to the man module for searching local and online\ndocs for various search terms. The term parameter can either be a single\nword like 'bind', or a space-separated list of words. This function is typically\nused by modules that want to refer users to additional documentation in man\npages or local system doc files.\n\n=cut\nsub help_search_link\n{\nif (&foreign_available(\"man\") && !$tconfig{'nosearch'}) {\n\tmy $for = &urlize(shift(@_));\n\treturn \"<a href='$gconfig{'webprefix'}/man/search.cgi?\".\n\t       join(\"&\", map { \"section=$_\" } @_).\"&\".\n\t       \"for=$for&exact=1&check=\".&get_module_name().\"'>\".\n\t       $text{'helpsearch'}.\"</a>\\n\";\n\t}\nelse {\n\treturn \"\";\n\t}\n}\n\n=head2 make_http_connection(host, port, ssl, method, page, [&headers])\n\nOpens a connection to some HTTP server, maybe through a proxy, and returns\na handle object. The handle can then be used to send additional headers\nand read back a response. If anything goes wrong, returns an error string.\nThe parameters are :\n\n=item host - Hostname or IP address of the webserver to connect to.\n\n=item port - HTTP port number to connect to.\n\n=item ssl - Set to 1 to connect in SSL mode.\n\n=item method - HTTP method, like GET or POST.\n\n=item page - Page to request on the webserver, like /foo/index.html\n\n=item headers - Array ref of additional HTTP headers, each of which is a 2-element array ref.\n\n=item bindip - IP address to bind to for outgoing HTTP connection\n\n=item certreqs - A hash ref containing options for remote cert verification\n\n=cut\nsub make_http_connection\n{\nmy ($host, $port, $ssl, $method, $page, $headers, $bindip, $certreqs) = @_;\nmy $htxt;\nif ($headers) {\n\tforeach my $h (@$headers) {\n\t\t$htxt .= $h->[0].\": \".$h->[1].\"\\r\\n\";\n\t\t}\n\t$htxt .= \"\\r\\n\";\n\t}\nif (&is_readonly_mode()) {\n\treturn \"HTTP connections not allowed in readonly mode\";\n\t}\nmy $rv = { 'fh' => time().$$ };\nif ($ssl) {\n\t# Connect using SSL\n\teval \"use Net::SSLeay\";\n\t$@ && return $text{'link_essl'};\n\teval \"Net::SSLeay::SSLeay_add_ssl_algorithms()\";\n\teval \"Net::SSLeay::OpenSSL_add_all_algorithms()\";\n\teval \"Net::SSLeay::load_error_strings()\";\n\t$rv->{'ssl_ctx'} = Net::SSLeay::CTX_new() ||\n\t\treturn \"Failed to create SSL context\";\n\tif ($certreqs && $certreqs->{'capath'}) {\n\t\t# Require that remote cert be signed by a valid CA\n\t\t$main::last_set_verify_err = undef;\n\t\tif (-d $certreqs->{'capath'}) {\n\t\t\tNet::SSLeay::CTX_load_verify_locations(\n\t\t\t\t$rv->{'ssl_ctx'}, \"\", $certreqs->{'capath'});\n\t\t\t}\n\t\telse {\n\t\t\tNet::SSLeay::CTX_load_verify_locations(\n\t\t\t\t$rv->{'ssl_ctx'}, $certreqs->{'capath'}, \"\");\n\t\t\t}\n\t\tNet::SSLeay::CTX_set_verify(\n\t\t\t$rv->{'ssl_ctx'}, &Net::SSLeay::VERIFY_PEER,\n\t\t\tsub\n\t\t\t{\n\t\t\tmy $cert = Net::SSLeay::X509_STORE_CTX_get_current_cert($_[1]);\n\t\t\tif ($cert) {\n\t\t\t\tmy $subject = Net::SSLeay::X509_NAME_oneline(\n\t\t\t\t    Net::SSLeay::X509_get_subject_name($cert));\n\t\t\t\tmy $issuer = Net::SSLeay::X509_NAME_oneline(\n\t\t\t\t    Net::SSLeay::X509_get_issuer_name($cert));\n\t\t\t\tmy $errnum = Net::SSLeay::X509_STORE_CTX_get_error($_[1]);\n\t\t\t\tif ($errnum) {\n\t\t\t\t\t$main::last_set_verify_err =\n\t\t\t\t\t  \"Certificate is signed by an \".\n\t\t\t\t\t  \"unknown CA : $issuer (code $errnum)\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$main::last_set_verify_err = undef;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t$main::last_set_verify_err =\n\t\t\t\t  \"Could not fetch CA certificate from server\";\n\t\t\t\t}\n\t\t\treturn 1;\n\t\t\t});\n\t\t}\n\t$rv->{'ssl_con'} = Net::SSLeay::new($rv->{'ssl_ctx'}) ||\n\t\treturn \"Failed to create SSL connection\";\n\tmy $connected;\n\tif ($gconfig{'http_proxy'} =~ /^http:\\/\\/(\\S+):(\\d+)/ &&\n\t    !&no_proxy($host)) {\n\t\t# Via proxy\n\t\tmy $error;\n\t\t&open_socket($1, $2, $rv->{'fh'}, \\$error, $bindip);\n\t\tif (!$error) {\n\t\t\t# Connected OK\n\t\t\tmy $fh = $rv->{'fh'};\n\t\t\tprint $fh \"CONNECT $host:$port HTTP/1.0\\r\\n\";\n\t\t\tif ($gconfig{'proxy_user'}) {\n\t\t\t\tmy $auth = &encode_base64(\n\t\t\t\t   \"$gconfig{'proxy_user'}:\".\n\t\t\t\t   \"$gconfig{'proxy_pass'}\");\n\t\t\t\t$auth =~ tr/\\r\\n//d;\n\t\t\t\tprint $fh \"Proxy-Authorization: Basic $auth\\r\\n\";\n\t\t\t\t}\n\t\t\tprint $fh \"\\r\\n\";\n\t\t\tmy $line = <$fh>;\n\t\t\tif ($line =~ /^HTTP(\\S+)\\s+(\\d+)\\s+(.*)/) {\n\t\t\t\treturn \"Proxy error : $3\" if ($2 != 200);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"Proxy error : $line\";\n\t\t\t\t}\n\t\t\t$line = <$fh>;\n\t\t\t$connected = 1;\n\t\t\t}\n\t\telsif (!$gconfig{'proxy_fallback'}) {\n\t\t\t# Connection to proxy failed - give up\n\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\tif (!$connected) {\n\t\t# Direct connection\n\t\tmy $error;\n\t\t&open_socket($host, $port, $rv->{'fh'}, \\$error, $bindip);\n\t\treturn $error if ($error);\n\t\t}\n\tNet::SSLeay::set_fd($rv->{'ssl_con'}, fileno($rv->{'fh'}));\n\teval {\n\t\tmy $snihost = $certreqs && $certreqs->{'host'};\n\t\t$snihost ||= $host;\n\t\tNet::SSLeay::set_tlsext_host_name($rv->{'ssl_con'}, $snihost);\n\t\t};\n\tNet::SSLeay::connect($rv->{'ssl_con'}) ||\n\t\treturn \"SSL connect() failed\";\n\tif ($certreqs && !$certreqs->{'nocheckhost'}) {\n\t\tmy $err = &validate_ssl_connection(\n\t\t\t$rv->{'ssl_con'},\n\t\t\t$certreqs->{'checkhost'} ||\n\t\t\t  $certreqs->{'host'} || $host,\n\t\t\t$certreqs);\n\t\treturn \"Invalid SSL certificate : $err\" if ($err);\n\t\t}\n\tmy $rtxt = \"$method $page HTTP/1.0\\r\\n\".$htxt;\n\tNet::SSLeay::write($rv->{'ssl_con'}, $rtxt);\n\t}\nelse {\n\t# Plain HTTP request\n\tmy $connected;\n\tif ($gconfig{'http_proxy'} =~ /^http:\\/\\/(\\S+):(\\d+)/ &&\n\t    !&no_proxy($host)) {\n\t\t# Via a proxy\n\t\tmy $error;\n\t\t&open_socket($1, $2, $rv->{'fh'}, \\$error, $bindip);\n\t\tif (!$error) {\n\t\t\t# Connected OK\n\t\t\t$connected = 1;\n\t\t\tmy $fh = $rv->{'fh'};\n\t\t\tmy $rtxt = $method.\" \".\n\t\t\t\t   \"http://$host:$port$page HTTP/1.0\\r\\n\";\n\t\t\tif ($gconfig{'proxy_user'}) {\n\t\t\t\tmy $auth = &encode_base64(\n\t\t\t\t   \"$gconfig{'proxy_user'}:\".\n\t\t\t\t   \"$gconfig{'proxy_pass'}\");\n\t\t\t\t$auth =~ tr/\\r\\n//d;\n\t\t\t\t$rtxt .= \"Proxy-Authorization: Basic $auth\\r\\n\";\n\t\t\t\t}\n\t\t\t$rtxt .= $htxt;\n\t\t\tprint $fh $rtxt;\n\t\t\t}\n\t\telsif (!$gconfig{'proxy_fallback'}) {\n\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\tif (!$connected) {\n\t\t# Connecting directly\n\t\tmy $error;\n\t\t&open_socket($host, $port, $rv->{'fh'}, \\$error, $bindip);\n\t\treturn $error if ($error);\n\t\tmy $fh = $rv->{'fh'};\n\t\tmy $rtxt = \"$method $page HTTP/1.0\\r\\n\".$htxt;\n\t\tprint $fh $rtxt;\n\t\t}\n\t}\nreturn $rv;\n}\n\n=head2 validate_ssl_connection(&ssl-handle, hostname, &requirements)\n\nValidates the SSL certificate presented by a remote server, and returns an\nerror message if any requirements were not met.\n\n=cut\nsub validate_ssl_connection\n{\nmy ($ssl, $host, $reqs) = @_;\n$host = lc($host);\nmy $x509 = Net::SSLeay::get_peer_certificate($ssl);\n$x509 || return \"Could not fetch peer certificate\";\nif ($reqs->{'host'} || $reqs->{'checkhost'}) {\n\t# Check for sensible hostname\n\tmy @subjects;\n\tmy $subject = Net::SSLeay::X509_NAME_oneline(\n\t\tNet::SSLeay::X509_get_subject_name($x509));\n\t$subject =~ /CN=([a-z0-9\\-\\_\\.\\*]+)/i ||\n\t\treturn \"No CN found in subject $subject\";\n\tpush(@subjects, lc($1));\n\tmy @altlist = Net::SSLeay::X509_get_subjectAltNames($x509);\n\tfor(my $i=1; $i<@altlist; $i+=2) {\n\t\tpush(@subjects, lc($altlist[$i]));\n\t\t}\n\tmy @errs;\n\tforeach my $cn (@subjects) {\n\t\tif ($cn =~ /^\\*\\.(.*)$/) {\n\t\t\t# For a sub-domain\n\t\t\tmy $subcn = $1;\n\t\t\t$host eq $subcn || $host =~ /\\.\\Q$subcn\\E$/ ||\n\t\t\t    push(@errs, \"Certificate is for $cn, not $host.\");\n\t\t\t}\n\t\telsif ($cn eq \"*\") {\n\t\t\t# Matches anything .. but this may fail the\n\t\t\t# self-signed check\n\t\t\t}\n\t\telse {\n\t\t\t# For an exact domain\n\t\t\t$host eq $cn ||\n\t\t\t    push(@errs, \"Certificate is for $cn, not $host.\");\n\t\t\t}\n\t\t}\n\tif (scalar(@errs) == scalar(@subjects)) {\n\t\t# All subjects were bad\n\t\treturn join(\" \", @errs);\n\t\t}\n\t}\nif ($reqs->{'self'}) {\n\t# Check if self-signed\n\tmy $subject = Net::SSLeay::X509_NAME_oneline(\n\t\tNet::SSLeay::X509_get_subject_name($x509));\n\tmy $issuer = Net::SSLeay::X509_NAME_oneline(\n\t\tNet::SSLeay::X509_get_issuer_name($x509));\n\tif ($subject eq $issuer) {\n\t\treturn \"Certificate is self-signed by $subject\";\n\t\t}\n\t}\nif ($reqs->{'capath'}) {\n\t# Check if CA is signed by a valid authority (set in a callback)\n\treturn $main::last_set_verify_err if ($main::last_set_verify_err);\n\t}\nreturn undef;\n}\n\n=head2 read_http_connection(&handle, [bytes])\n\nReads either one line or up to the specified number of bytes from the handle,\noriginally supplied by make_http_connection.\n\n=cut\nsub read_http_connection\n{\nmy ($h, $want) = @_;\nmy $rv;\nif ($h->{'ssl_con'}) {\n\tif (!$want) {\n\t\tmy ($idx, $more);\n\t\twhile(($idx = index($h->{'buffer'}, \"\\n\")) < 0) {\n\t\t\t# need to read more..\n\t\t\tif (!($more = Net::SSLeay::read($h->{'ssl_con'}))) {\n\t\t\t\t# end of the data\n\t\t\t\t$rv = $h->{'buffer'};\n\t\t\t\tdelete($h->{'buffer'});\n\t\t\t\treturn $rv;\n\t\t\t\t}\n\t\t\t$h->{'buffer'} .= $more;\n\t\t\t}\n\t\t$rv = substr($h->{'buffer'}, 0, $idx+1);\n\t\t$h->{'buffer'} = substr($h->{'buffer'}, $idx+1);\n\t\t}\n\telse {\n\t\tif (length($h->{'buffer'})) {\n\t\t\t$rv = $h->{'buffer'};\n\t\t\tdelete($h->{'buffer'});\n\t\t\t}\n\t\telse {\n\t\t\t$rv = Net::SSLeay::read($h->{'ssl_con'}, $want);\n\t\t\t}\n\t\t}\n\t}\nelse {\n\tif ($want) {\n\t\tread($h->{'fh'}, $rv, $want) > 0 || return undef;\n\t\t}\n\telse {\n\t\tmy $fh = $h->{'fh'};\n\t\t$rv = <$fh>;\n\t\t}\n\t}\n$rv = undef if ($rv eq \"\");\nreturn $rv;\n}\n\n=head2 write_http_connection(&handle, [data+])\n\nWrites the given data to the given HTTP connection handle.\n\n=cut\nsub write_http_connection\n{\nmy $h = shift(@_);\nmy $fh = $h->{'fh'};\nmy $allok = 1;\nif ($h->{'ssl_ctx'}) {\n\tforeach my $s (@_) {\n\t\tmy $ok = Net::SSLeay::write($h->{'ssl_con'}, $s);\n\t\t$allok = 0 if (!$ok);\n\t\t}\n\t}\nelse {\n\tmy $ok = (print $fh @_);\n\t$allok = 0 if (!$ok);\n\t}\nreturn $allok;\n}\n\n=head2 close_http_connection(&handle)\n\nCloses a connection to an HTTP server, identified by the given handle.\n\n=cut\nsub close_http_connection\n{\nmy ($h) = @_;\nreturn close($h->{'fh'});\n}\n\n=head2 clean_environment\n\nDeletes any environment variables inherited from miniserv so that they\nwon't be passed to programs started by webmin. This is useful when calling\nprograms that check for CGI-related environment variables and modify their\nbehaviour, and to avoid passing sensitive variables to un-trusted programs.\n\n=cut\nsub clean_environment\n{\n%UNCLEAN_ENV = %ENV;\nforeach my $k (keys %ENV) {\n\tif ($k =~ /^(HTTP|VIRTUALSERVER|QUOTA|USERADMIN)_/) {\n\t\tdelete($ENV{$k});\n\t\t}\n\t}\nforeach my $e ('WEBMIN_CONFIG', 'SERVER_NAME', 'CONTENT_TYPE', 'REQUEST_URI',\n\t    'PATH_INFO', 'WEBMIN_VAR', 'REQUEST_METHOD', 'GATEWAY_INTERFACE',\n\t    'QUERY_STRING', 'REMOTE_USER', 'SERVER_SOFTWARE', 'SERVER_PROTOCOL',\n\t    'REMOTE_HOST', 'SERVER_PORT', 'DOCUMENT_ROOT', 'SERVER_ROOT',\n\t    'MINISERV_CONFIG', 'SCRIPT_NAME', 'SERVER_ADMIN', 'CONTENT_LENGTH',\n\t    'HTTPS', 'FOREIGN_MODULE_NAME', 'FOREIGN_ROOT_DIRECTORY',\n\t    'SCRIPT_FILENAME', 'PATH_TRANSLATED', 'BASE_REMOTE_USER',\n\t    'DOCUMENT_REALROOT', 'MINISERV_CONFIG', 'MYSQL_PWD',\n\t    'MINISERV_PID') {\n\tdelete($ENV{$e});\n\t}\n}\n\n=head2 reset_environment\n\nPuts the environment back how it was before clean_environment was callled.\n\n=cut\nsub reset_environment\n{\nif (%UNCLEAN_ENV) {\n\tforeach my $k (keys %UNCLEAN_ENV) {\n\t\t$ENV{$k} = $UNCLEAN_ENV{$k};\n\t\t}\n\tundef(%UNCLEAN_ENV);\n\t}\n}\n\n=head2 clean_language\n\nSets all language and locale-related environment variables to US english, to\nensure that commands run output in the expected language. Can be reverted by\nreset_environment.\n\n=cut\nsub clean_language\n{\nif (!%UNCLEAN_ENV) {\n\t%UNCLEAN_ENV = %ENV;\n\t}\n$ENV{'LANG'} = '';\n$ENV{'LANGUAGE'} = '';\n$ENV{'LC_ALL'} = '';\n$ENV{'LOCALE'} = '';\n}\n\n=head2 progress_callback\n\nNever called directly, but useful for passing to &http_download to print\nout progress of an HTTP request.\n\n=cut\nsub progress_callback\n{\nif (defined(&theme_progress_callback)) {\n\t# Call the theme override\n\treturn &theme_progress_callback(@_);\n\t}\nif ($_[0] == 2) {\n\t# Got size\n\tprint $progress_callback_prefix;\n\tif ($_[1]) {\n\t\t$progress_size = $_[1];\n\t\t$progress_step = int($_[1] / 10);\n\t\tprint &text('progress_size2', $progress_callback_url,\n\t\t\t    &nice_size($progress_size)),\"<br>\\n\";\n\t\t}\n\telse {\n\t\t$progress_size = undef;\n\t\tprint &text('progress_nosize', $progress_callback_url),\"<br>\\n\";\n\t\t}\n\t$last_progress_time = $last_progress_size = undef;\n\t}\nelsif ($_[0] == 3) {\n\t# Got data update\n\tmy $sp = $progress_callback_prefix.(\"&nbsp;\" x 5);\n\tif ($progress_size) {\n\t\t# And we have a size to compare against\n\t\tmy $st = int(($_[1] * 10) / $progress_size);\n\t\tmy $time_now = time();\n\t\tif ($st != $progress_step ||\n\t\t    $time_now - $last_progress_time > 60) {\n\t\t\t# Show progress every 10% or 60 seconds\n\t\t\tprint $sp,&text('progress_datan', &nice_size($_[1]),\n\t\t\t\t        int($_[1]*100/$progress_size)),\"<br>\\n\";\n\t\t\t$last_progress_time = $time_now;\n\t\t\t}\n\t\t$progress_step = $st;\n\t\t}\n\telse {\n\t\t# No total size .. so only show in 1M jumps\n\t\tif ($_[1] > $last_progress_size+1024*1024) {\n\t\t\tprint $sp,&text('progress_data2n',\n\t\t\t\t\t&nice_size($_[1])),\"<br>\\n\";\n\t\t\t$last_progress_size = $_[1];\n\t\t\t}\n\t\t}\n\t}\nelsif ($_[0] == 4) {\n\t# All done downloading\n\tprint $progress_callback_prefix,&text('progress_done'),\"<br>\\n\";\n\t}\nelsif ($_[0] == 5) {\n\t# Got new location after redirect\n\t$progress_callback_url = $_[1];\n\t}\nelsif ($_[0] == 6) {\n\t# URL is in cache\n\t$progress_callback_url = $_[1];\n\tprint &text('progress_incache', $progress_callback_url),\"<br>\\n\";\n\t}\n}\n\n=head2 switch_to_remote_user\n\nChanges the user and group of the current process to that of the unix user\nwith the same name as the current webmin login, or fails if there is none.\nThis should be called by Usermin module scripts that only need to run with\nlimited permissions.\n\n=cut\nsub switch_to_remote_user\n{\n@remote_user_info = $remote_user ? getpwnam($remote_user) :\n\t\t    \t\t   getpwuid($<);\n@remote_user_info || &error(&text('switch_remote_euser', $remote_user));\n&create_missing_homedir(\\@remote_user_info);\nif ($< == 0) {\n\t&switch_to_unix_user(\\@remote_user_info);\n\t$ENV{'USER'} = $ENV{'LOGNAME'} = $remote_user;\n\t$ENV{'HOME'} = $remote_user_info[7];\n\t}\n# Export global variables to caller\nif ($main::export_to_caller) {\n\tmy ($callpkg) = caller();\n\teval \"\\@${callpkg}::remote_user_info = \\@remote_user_info\";\n\t}\n}\n\n=head2 switch_to_unix_user(&user-details)\n\nSwitches the current process to the UID and group ID from the given list\nof user details, which must be in the format returned by getpwnam.\n\n=cut\nsub switch_to_unix_user\n{\nmy ($uinfo) = @_;\nif (!defined($uinfo->[0])) {\n\t# No username given, so just use given GID\n\t($(, $)) = ( $uinfo->[3], \"$uinfo->[3] $uinfo->[3]\" );\n\t}\nelse {\n\t# Use all groups from user\n\t($(, $)) = ( $uinfo->[3],\n\t\t     \"$uinfo->[3] \".join(\" \", $uinfo->[3],\n\t\t\t\t\t &other_groups($uinfo->[0])) );\n\t}\neval {\n\tPOSIX::setuid($uinfo->[2]);\n\t};\nif ($< != $uinfo->[2] || $> != $uinfo->[2]) {\n\t($>, $<) = ( $uinfo->[2], $uinfo->[2] );\n\t}\n}\n\n=head2 eval_as_unix_user(username, &code)\n\nRuns some code fragment with the effective UID and GID switch to that\nof the given Unix user, so that file IO takes place with his permissions.\n\n=cut\n\nsub eval_as_unix_user\n{\nmy ($user, $code) = @_;\nmy @uinfo = getpwnam($user);\nif (!scalar(@uinfo)) {\n\t&error(\"eval_as_unix_user called with invalid user $user\");\n\t}\n$) = $uinfo[3].\" \".join(\" \", $uinfo[3], &other_groups($user));\n$> = $uinfo[2];\nmy @rv;\neval {\n\tlocal $main::error_must_die = 1;\n\t@rv = &$code();\n\t};\nmy $err = $@;\n$) = 0;\n$> = 0;\nif ($err) {\n\t$err =~ s/\\s+at\\s+(\\/\\S+)\\s+line\\s+(\\d+)\\.?//;\n\t&error($err);\n\t}\nreturn wantarray ? @rv : $rv[0];\n}\n\n=head2 create_user_config_dirs\n\nCreates per-user config directories and sets $user_config_directory and\n$user_module_config_directory to them. Also reads per-user module configs\ninto %userconfig. This should be called by Usermin module scripts that need\nto store per-user preferences or other settings.\n\n=cut\nsub create_user_config_dirs\n{\nreturn if (!$gconfig{'userconfig'});\nmy @uinfo = @remote_user_info ? @remote_user_info : getpwnam($remote_user);\nreturn if (!@uinfo || !$uinfo[7]);\n&create_missing_homedir(\\@uinfo);\n$user_config_directory = \"$uinfo[7]/$gconfig{'userconfig'}\";\nif (!-d $user_config_directory) {\n\tmkdir($user_config_directory, 0700) ||\n\t\t&error(\"Failed to create $user_config_directory : $!\");\n\tif ($< == 0 && $uinfo[2]) {\n\t\tchown($uinfo[2], $uinfo[3], $user_config_directory);\n\t\t}\n\t}\nif (&get_module_name()) {\n\t$user_module_config_directory = $user_config_directory.\"/\".\n\t\t\t\t\t&get_module_name();\n\tif (!-d $user_module_config_directory) {\n\t\tmkdir($user_module_config_directory, 0700) ||\n\t\t\t&error(\"Failed to create $user_module_config_directory : $!\");\n\t\tif ($< == 0 && $uinfo[2]) {\n\t\t\tchown($uinfo[2], $uinfo[3], $user_config_directory);\n\t\t\t}\n\t\t}\n\tundef(%userconfig);\n\t&read_file_cached(\"$module_root_directory/defaultuconfig\",\n\t\t\t  \\%userconfig);\n\t&read_file_cached(\"$module_config_directory/uconfig\", \\%userconfig);\n\t&read_file_cached(\"$user_module_config_directory/config\",\n\t\t\t  \\%userconfig);\n\t}\n\n# Export global variables to caller\nif ($main::export_to_caller) {\n\tmy ($callpkg) = caller();\n\tforeach my $v ('$user_config_directory',\n\t\t       '$user_module_config_directory', '%userconfig') {\n\t\tmy ($vt, $vn) = split('', $v, 2);\n\t\teval \"${vt}${callpkg}::${vn} = ${vt}${vn}\";\n\t\t}\n\t}\n}\n\n=head2 create_missing_homedir(&uinfo)\n\nIf auto homedir creation is enabled, create one for this user if needed.\nFor internal use only.\n\n=cut\nsub create_missing_homedir\n{\nmy ($uinfo) = @_;\nif (!-e $uinfo->[7] && $gconfig{'create_homedir'}) {\n\t# Use has no home dir .. make one\n\tsystem(\"mkdir -p \".quotemeta($uinfo->[7]));\n\tchown($uinfo->[2], $uinfo->[3], $uinfo->[7]);\n\tif ($gconfig{'create_homedir_perms'} ne '') {\n\t\tchmod(oct($gconfig{'create_homedir_perms'}), $uinfo->[7]);\n\t\t}\n\t}\n}\n\n=head2 filter_javascript(text)\n\nDisables all javascript <script>, onClick= and so on tags in the given HTML,\nand returns the new HTML. Useful for displaying HTML from an un-trusted source.\n\n=cut\nsub filter_javascript\n{\nmy ($rv) = @_;\n$rv =~ s/<\\s*script[^>]*>([\\000-\\377]*?)<\\s*\\/script\\s*>//gi;\n$rv =~ s/(on(Abort|BeforeUnload|Blur|Change|Click|ContextMenu|Copy|Cut|DblClick|Drag|DragEnd|DragEnter|DragLeave|DragOver|DragStart|DragDrop|Drop|Error|Focus|FocusIn|FocusOut|HashChange|Input|Invalid|KeyDown|KeyPress|KeyUp|Load|MouseDown|MouseEnter|MouseLeave|MouseMove|MouseOut|MouseOver|MouseUp|Move|Paste|PageShow|PageHide|Reset|Resize|Scroll|Search|Select|Submit|Toggle|Unload)=)/x$1/gi;\n$rv =~ s/(javascript:)/x$1/gi;\n$rv =~ s/(vbscript:)/x$1/gi;\n$rv =~ s/<([^>]*\\s|)(on\\S+=)(.*)>/<$1x$2$3>/gi;\nreturn $rv;\n}\n\n=head2 resolve_links(path)\n\nGiven a path that may contain symbolic links, returns the real path.\n\n=cut\nsub resolve_links\n{\nmy ($path) = @_;\n$path =~ s/\\/+/\\//g;\n$path =~ s/\\/$// if ($path ne \"/\");\nmy @p = split(/\\/+/, $path);\nshift(@p);\nfor(my $i=0; $i<@p; $i++) {\n\tmy $sofar = \"/\".join(\"/\", @p[0..$i]);\n\tmy $lnk = readlink($sofar);\n\tif ($lnk eq $sofar) {\n\t\t# Link to itself! Cannot do anything more really ..\n\t\tlast;\n\t\t}\n\telsif ($lnk =~ /^\\//) {\n\t\t# Link is absolute..\n\t\treturn &resolve_links($lnk.\"/\".join(\"/\", @p[$i+1 .. $#p]));\n\t\t}\n\telsif ($lnk) {\n\t\t# Link is relative\n\t\treturn &resolve_links(\"/\".join(\"/\", @p[0..$i-1]).\"/\".$lnk.\"/\".join(\"/\", @p[$i+1 .. $#p]));\n\t\t}\n\t}\nreturn $path;\n}\n\n=head2 simplify_path(path, bogus)\n\nGiven a path, maybe containing elements \"..\" and \".\" , convert it to a\nclean, absolute form. Returns undef if this is not possible.\n\n=cut\nsub simplify_path\n{\nmy ($dir) = @_;\n$dir =~ s/^\\/+//g;\n$dir =~ s/\\/+$//g;\nmy @bits = split(/\\/+/, $dir);\nmy @fixedbits = ();\n$_[1] = 0;\nforeach my $b (@bits) {\n        if ($b eq \".\") {\n                # Do nothing..\n                }\n        elsif ($b eq \"..\") {\n                # Remove last dir\n                if (scalar(@fixedbits) == 0) {\n\t\t\t# Cannot! Already at root!\n\t\t\treturn undef;\n                        }\n                pop(@fixedbits);\n                }\n        else {\n                # Add dir to list\n                push(@fixedbits, $b);\n                }\n        }\nreturn \"/\".join('/', @fixedbits);\n}\n\n=head2 same_file(file1, file2)\n\nReturns 1 if two files are actually the same\n\n=cut\nsub same_file\n{\nreturn 1 if ($_[0] eq $_[1]);\nreturn 0 if ($_[0] !~ /^\\// || $_[1] !~ /^\\//);\nmy @stat1 = $stat_cache{$_[0]} ? @{$stat_cache{$_[0]}}\n\t\t\t       : (@{$stat_cache{$_[0]}} = stat($_[0]));\nmy @stat2 = $stat_cache{$_[1]} ? @{$stat_cache{$_[1]}}\n\t\t\t       : (@{$stat_cache{$_[1]}} = stat($_[1]));\nreturn 0 if (!@stat1 || !@stat2);\nreturn $stat1[0] == $stat2[0] && $stat1[1] == $stat2[1];\n}\n\n=head2 flush_webmin_caches\n\nClears all in-memory and on-disk caches used by Webmin.\n\n=cut\nsub flush_webmin_caches\n{\nundef(%main::read_file_cache);\nundef(%main::acl_hash_cache);\nundef(%main::acl_array_cache);\nundef(%main::has_command_cache);\nundef(@main::list_languages_cache);\nundef($main::got_list_usermods_cache);\nundef(@main::list_usermods_cache);\nundef(%main::foreign_installed_cache);\nunlink(\"$config_directory/module.infos.cache\");\nunlink(\"$var_directory/module.infos.cache\");\n&get_all_module_infos();\n}\n\n=head2 list_usermods\n\nReturns a list of additional module restrictions. For internal use in\nUsermin only.\n\n=cut\nsub list_usermods\n{\nif (!$main::got_list_usermods_cache) {\n\t@main::list_usermods_cache = ( );\n\tlocal $_;\n\topen(USERMODS, \"$config_directory/usermin.mods\");\n\twhile(<USERMODS>) {\n\t\tif (/^([^:]+):(\\+|-|):(.*)/) {\n\t\t\tpush(@main::list_usermods_cache,\n\t\t\t     [ $1, $2, [ split(/\\s+/, $3) ] ]);\n\t\t\t}\n\t\t}\n\tclose(USERMODS);\n\t$main::got_list_usermods_cache = 1;\n\t}\nreturn @main::list_usermods_cache;\n}\n\n=head2 available_usermods(&allmods, &usermods)\n\nReturns a list of modules that are available to the given user, based\non usermod additional/subtractions. For internal use by Usermin only.\n\n=cut\nsub available_usermods\n{\nreturn @{$_[0]} if (!@{$_[1]});\n\nmy %mods = map { $_->{'dir'}, 1 } @{$_[0]};\nmy @uinfo = @remote_user_info;\n@uinfo = getpwnam($remote_user) if (!@uinfo);\nforeach my $u (@{$_[1]}) {\n\tmy $applies;\n\tif ($u->[0] eq \"*\" || $u->[0] eq $remote_user) {\n\t\t$applies++;\n\t\t}\n\telsif ($u->[0] =~ /^\\@(.*)$/) {\n\t\t# Check for group membership\n\t\tmy @ginfo = getgrnam($1);\n\t\t$applies++ if (@ginfo && ($ginfo[2] == $uinfo[3] ||\n\t\t\t&indexof($remote_user, split(/\\s+/, $ginfo[3])) >= 0));\n\t\t}\n\telsif ($u->[0] =~ /^\\//) {\n\t\t# Check users and groups in file\n\t\tlocal $_;\n\t\topen(USERFILE, $u->[0]);\n\t\twhile(<USERFILE>) {\n\t\t\ttr/\\r\\n//d;\n\t\t\tif ($_ eq $remote_user) {\n\t\t\t\t$applies++;\n\t\t\t\t}\n\t\t\telsif (/^\\@(.*)$/) {\n\t\t\t\tmy @ginfo = getgrnam($1);\n\t\t\t\t$applies++\n\t\t\t\t  if (@ginfo && ($ginfo[2] == $uinfo[3] ||\n\t\t\t\t      &indexof($remote_user,\n\t\t\t\t\t       split(/\\s+/, $ginfo[3])) >= 0));\n\t\t\t\t}\n\t\t\tlast if ($applies);\n\t\t\t}\n\t\tclose(USERFILE);\n\t\t}\n\tif ($applies) {\n\t\tif ($u->[1] eq \"+\") {\n\t\t\tmap { $mods{$_}++ } @{$u->[2]};\n\t\t\t}\n\t\telsif ($u->[1] eq \"-\") {\n\t\t\tmap { delete($mods{$_}) } @{$u->[2]};\n\t\t\t}\n\t\telse {\n\t\t\tundef(%mods);\n\t\t\tmap { $mods{$_}++ } @{$u->[2]};\n\t\t\t}\n\t\t}\n\t}\nreturn grep { $mods{$_->{'dir'}} } @{$_[0]};\n}\n\n=head2 get_available_module_infos(nocache)\n\nReturns a list of modules available to the current user, based on\noperating system support, access control and usermod restrictions. Useful\nin themes that need to display a list of modules the user can use.\nEach element of the returned array is a hash reference in the same format as\nreturned by get_module_info.\n\n=cut\nsub get_available_module_infos\n{\nmy (%acl, %uacl);\n&read_acl(\\%acl, \\%uacl, [ $base_remote_user ]);\nmy $risk = $gconfig{'risk_'.$base_remote_user};\nmy @rv;\nforeach my $minfo (&get_all_module_infos($_[0])) {\n\tnext if (!&check_os_support($minfo));\n\tif ($risk) {\n\t\t# Check module risk level\n\t\tnext if ($risk ne 'high' && $minfo->{'risk'} &&\n\t\t\t $minfo->{'risk'} !~ /$risk/);\n\t\t}\n\telse {\n\t\t# Check user's ACL\n\t\tnext if (!$acl{$base_remote_user,$minfo->{'dir'}} &&\n\t\t\t !$acl{$base_remote_user,\"*\"});\n\t\t}\n\tnext if (&is_readonly_mode() && !$minfo->{'readonly'});\n\tpush(@rv, $minfo);\n\t}\n\n# Check usermod restrictions\nmy @usermods = &list_usermods();\n@rv = sort { lc($a->{'desc'}) cmp lc($b->{'desc'}) }\n\t    &available_usermods(\\@rv, \\@usermods);\n\n# Check RBAC restrictions\nmy @rbacrv;\nforeach my $m (@rv) {\n\tif (&supports_rbac($m->{'dir'}) &&\n\t    &use_rbac_module_acl(undef, $m->{'dir'})) {\n\t\tlocal $rbacs = &get_rbac_module_acl($remote_user,\n\t\t\t\t\t\t    $m->{'dir'});\n\t\tif ($rbacs) {\n\t\t\t# RBAC allows\n\t\t\tpush(@rbacrv, $m);\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Module or system doesn't support RBAC\n\t\tpush(@rbacrv, $m) if (!$gconfig{'rbacdeny_'.$base_remote_user});\n\t\t}\n\t}\n\n# Check theme vetos\nmy @themerv;\nif (defined(&theme_foreign_available)) {\n\tforeach my $m (@rbacrv) {\n\t\tif (&theme_foreign_available($m->{'dir'})) {\n\t\t\tpush(@themerv, $m);\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t@themerv = @rbacrv;\n\t}\n\n# Check licence module vetos\nmy @licrv;\nif ($main::licence_module) {\n\tforeach my $m (@themerv) {\n\t\tif (&foreign_call($main::licence_module,\n\t\t\t\t  \"check_module_licence\", $m->{'dir'})) {\n\t\t\tpush(@licrv, $m);\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t@licrv = @themerv;\n\t}\n\nreturn @licrv;\n}\n\n=head2 get_visible_module_infos(nocache)\n\nLike get_available_module_infos, but excludes hidden modules from the list.\nEach element of the returned array is a hash reference in the same format as\nreturned by get_module_info.\n\n=cut\nsub get_visible_module_infos\n{\nmy ($nocache) = @_;\nmy $pn = &get_product_name();\nreturn grep { !$_->{'hidden'} &&\n\t      !$_->{$pn.'_hidden'} } &get_available_module_infos($nocache);\n}\n\n=head2 get_visible_modules_categories(nocache)\n\nReturns a list of Webmin module categories, each of which is a hash ref\nwith 'code', 'desc' and 'modules' keys. The modules value is an array ref\nof modules in the category, in the format returned by get_module_info.\nUn-used modules are automatically assigned to the 'unused' category, and\nthose with no category are put into 'others'.\n\n=cut\nsub get_visible_modules_categories\n{\nmy ($nocache) = @_;\nmy @mods = &get_visible_module_infos($nocache);\nmy @unmods;\nif (&get_product_name() eq 'webmin') {\n\t@unmods = grep { $_->{'installed'} eq '0' } @mods;\n\t@mods = grep { $_->{'installed'} ne '0' } @mods;\n\t}\nmy %cats = &list_categories(\\@mods);\nmy @rv;\nforeach my $c (keys %cats) {\n\tmy $cat = { 'code' => $c || 'other',\n\t\t    'desc' => $cats{$c} };\n\t$cat->{'modules'} = [ grep { $_->{'category'} eq $c } @mods ];\n\tpush(@rv, $cat);\n\t}\n@rv = sort { ($b->{'code'} eq \"others\" ? \"\" : $b->{'code'}) cmp\n\t     ($a->{'code'} eq \"others\" ? \"\" : $a->{'code'}) } @rv;\nif (@unmods) {\n\t# Add un-installed modules in magic category\n\tmy $cat = { 'code' => 'unused',\n\t\t    'desc' => $text{'main_unused'},\n\t\t    'unused' => 1,\n\t\t    'modules' => \\@unmods };\n\tpush(@rv, $cat);\n\t}\nreturn @rv;\n}\n\n=head2 is_under_directory(directory, file)\n\nReturns 1 if the given file is under the specified directory, 0 if not.\nSymlinks are taken into account in the file to find it's 'real' location.\n\n=cut\nsub is_under_directory\n{\nmy ($dir, $file) = @_;\nreturn 1 if ($dir eq \"/\");\nreturn 0 if ($file =~ /\\.\\./);\nmy $ld = &resolve_links($dir);\nif ($ld ne $dir) {\n\treturn &is_under_directory($ld, $file);\n\t}\nmy $lp = &resolve_links($file);\nif ($lp ne $file) {\n\treturn &is_under_directory($dir, $lp);\n\t}\nreturn 0 if (length($file) < length($dir));\nreturn 1 if ($dir eq $file);\n$dir =~ s/\\/*$/\\//;\nreturn substr($file, 0, length($dir)) eq $dir;\n}\n\n=head2 parse_http_url(url, [basehost, baseport, basepage, basessl])\n\nGiven an absolute URL, returns the host, port, page and ssl flag components.\nIf a username and password are given before the hostname, return those too.\nRelative URLs can also be parsed, if the base information is provided.\nSSL mode 0 = HTTP, 1 = HTTPS, 2 = FTP.\n\n=cut\nsub parse_http_url\n{\nif ($_[0] =~ /^(http|https|ftp):\\/\\/([^\\@]+\\@)?\\[([^\\]]+)\\](:(\\d+))?(\\/\\S*)?$/ ||\n    $_[0] =~ /^(http|https|ftp):\\/\\/([^\\@]+\\@)?([^:\\/]+)(:(\\d+))?(\\/\\S*)?$/) {\n\t# An absolute URL\n\tmy $ssl = $1 eq 'https' ? 1 : $1 eq 'ftp' ? 2 : 0;\n\tmy @rv = ($3,\n\t\t  $4 ? $5 : $ssl == 1 ? 443 : $ssl == 2 ? 21 : 80,\n\t\t  $6 || \"/\",\n\t\t  $ssl,\n\t\t );\n\tif ($2 =~ /^([^:]+):(\\S+)\\@/) {\n\t\tpush(@rv, $1, $2);\n\t\t}\n\treturn @rv;\n\t}\nelsif (!$_[1]) {\n\t# Could not parse\n\treturn undef;\n\t}\nelsif ($_[0] =~ /^\\/\\S*$/) {\n\t# A relative to the server URL\n\treturn ($_[1], $_[2], $_[0], $_[4], $_[5], $_[6]);\n\t}\nelse {\n\t# A relative to the directory URL\n\tmy $page = $_[3];\n\t$page =~ s/[^\\/]+$//;\n\treturn ($_[1], $_[2], $page.$_[0], $_[4], $_[5], $_[6]);\n\t}\n}\n\n=head2 check_clicks_function\n\nReturns HTML for a JavaScript function called check_clicks that returns\ntrue when first called, but false subsequently. Useful on onClick for\ncritical buttons. Deprecated, as this method of preventing duplicate actions\nis un-reliable.\n\n=cut\nsub check_clicks_function\n{\nreturn <<EOF;\n<script type='text/javascript'>\nclicks = 0;\nfunction check_clicks(form)\n{\nclicks++;\nif (clicks == 1)\n\treturn true;\nelse {\n\tif (form != null) {\n\t\tfor(i=0; i<form.length; i++)\n\t\t\tform.elements[i].disabled = true;\n\t\t}\n\treturn false;\n\t}\n}\n</script>\nEOF\n}\n\n=head2 load_entities_map\n\nReturns a hash ref containing mappings between HTML entities (like ouml) and\nascii values (like 246). Mainly for internal use.\n\n=cut\nsub load_entities_map\n{\nif (!%entities_map_cache) {\n\tlocal $_;\n\topen(EMAP, \"$root_directory/entities_map.txt\");\n\twhile(<EMAP>) {\n\t\tif (/^(\\d+)\\s+(\\S+)/) {\n\t\t\t$entities_map_cache{$2} = $1;\n\t\t\t}\n\t\t}\n\tclose(EMAP);\n\t}\nreturn \\%entities_map_cache;\n}\n\n=head2 entities_to_ascii(string)\n\nGiven a string containing HTML entities like &ouml; and &#55;, replace them\nwith their ASCII equivalents.\n\n=cut\nsub entities_to_ascii\n{\nmy ($str) = @_;\nmy $emap = &load_entities_map();\n$str =~ s/&([a-z]+);/chr($emap->{$1})/ge;\n$str =~ s/&#(\\d+);/chr($1)/ge;\nreturn $str;\n}\n\n=head2 get_product_name\n\nReturns either 'webmin' or 'usermin', depending on which program the current\nmodule is in. Useful for modules that can be installed into either.\n\n=cut\nsub get_product_name\n{\nreturn $gconfig{'product'} if (defined($gconfig{'product'}));\nreturn defined($gconfig{'userconfig'}) ? 'usermin' : 'webmin';\n}\n\n=head2 get_charset\n\nReturns the character set for the current language, such as iso-8859-1.\n\n=cut\nsub get_charset\n{\nmy $charset = defined($gconfig{'charset'}) ? $gconfig{'charset'} :\n\t\t $current_lang_info->{'charset'} ?\n\t\t $current_lang_info->{'charset'} : $default_charset;\nreturn $charset;\n}\n\n=head2 get_display_hostname\n\nReturns the system's hostname for UI display purposes. This may be different\nfrom the actual hostname if you administrator has configured it so in the\nWebmin Configuration module.\n\n=cut\nsub get_display_hostname\n{\nif ($gconfig{'hostnamemode'} == 0) {\n\treturn &get_system_hostname();\n\t}\nelsif ($gconfig{'hostnamemode'} == 3) {\n\treturn $gconfig{'hostnamedisplay'};\n\t}\nelse {\n\tmy $h = $ENV{'HTTP_HOST'};\n\treturn &get_system_hostname() if (!$h);\n\t$h =~ s/:\\d+//g;\n\tif ($gconfig{'hostnamemode'} == 2) {\n\t\t$h =~ s/^(www|ftp|mail)\\.//i;\n\t\t}\n\treturn $h;\n\t}\n}\n\n=head2 save_module_config([&config], [modulename])\n\nSaves the configuration for some module. The config parameter is an optional\nhash reference of names and values to save, which defaults to the global\n%config hash. The modulename parameter is the module to update the config\nfile, which defaults to the current module.\n\n=cut\nsub save_module_config\n{\nmy $c = $_[0] || { &get_module_variable('%config') };\nmy $m;\nif (defined($_[1])) {\n\t$m = $_[1];\n\t}\nelse {\n\t$m = &get_module_name();\n\t$m || &error(\"could not compute current module in save_module_config\");\n\t}\n&write_file(\"$config_directory/$m/config\", $c);\n}\n\n=head2 save_user_module_config([&config], [modulename])\n\nSaves the user's Usermin preferences for some module. The config parameter is\nan optional hash reference of names and values to save, which defaults to the\nglobal %userconfig hash. The modulename parameter is the module to update the\nconfig file, which defaults to the current module.\n\n=cut\nsub save_user_module_config\n{\nmy $c = $_[0] || { &get_module_variable('%userconfig') };\nmy $m = $_[1] || &get_module_name();\nmy $ucd = $user_config_directory;\nif (!$ucd) {\n\tmy @uinfo = @remote_user_info ? @remote_user_info\n\t\t\t\t      : getpwnam($remote_user);\n\treturn if (!@uinfo || !$uinfo[7]);\n\t$ucd = \"$uinfo[7]/$gconfig{'userconfig'}\";\n\t}\n&write_file(\"$ucd/$m/config\", $c);\n}\n\n=head2 nice_size(bytes, [min])\n\nConverts a number of bytes into a number followed by a suffix like GB, MB\nor kB. Rounding is to two decimal digits. The optional min parameter sets the\nsmallest units to use - so you could pass 1024*1024 to never show bytes or kB.\n\n=cut\nsub nice_size\n{\nmy ($units, $uname);\n&load_theme_library();\nif (defined(&theme_nice_size) &&\n    $main::header_content_type eq \"text/html\" &&\n    $main::webmin_script_type eq \"web\") {\n\treturn &theme_nice_size(@_);\n\t}\nif (abs($_[0]) > 1024*1024*1024*1024 || $_[1] >= 1024*1024*1024*1024) {\n\t$units = 1024*1024*1024*1024;\n\t$uname = \"TB\";\n\t}\nelsif (abs($_[0]) > 1024*1024*1024 || $_[1] >= 1024*1024*1024) {\n\t$units = 1024*1024*1024;\n\t$uname = \"GB\";\n\t}\nelsif (abs($_[0]) > 1024*1024 || $_[1] >= 1024*1024) {\n\t$units = 1024*1024;\n\t$uname = \"MB\";\n\t}\nelsif (abs($_[0]) > 1024 || $_[1] >= 1024) {\n\t$units = 1024;\n\t$uname = \"kB\";\n\t}\nelse {\n\t$units = 1;\n\t$uname = \"bytes\";\n\t}\nmy $sz = sprintf(\"%.2f\", ($_[0]*1.0 / $units));\n$sz =~ s/\\.00$//;\nreturn $sz.\" \".$uname;\n}\n\n=head2 get_perl_path\n\nReturns the path to Perl currently in use, such as /usr/bin/perl.\n\n=cut\nsub get_perl_path\n{\nif (open(PERL, \"$config_directory/perl-path\")) {\n\tmy $rv;\n\tchop($rv = <PERL>);\n\tclose(PERL);\n\treturn $rv;\n\t}\nreturn $^X if (-x $^X);\nreturn &has_command(\"perl\");\n}\n\n=head2 get_goto_module([&mods])\n\nReturns the details of a module that the current user should be re-directed\nto after logging in, or undef if none. Useful for themes.\n\n=cut\nsub get_goto_module\n{\nmy @mods = $_[0] ? @{$_[0]} : &get_visible_module_infos();\nif ($gconfig{'gotomodule'}) {\n\tmy ($goto) = grep { $_->{'dir'} eq $gconfig{'gotomodule'} } @mods;\n\treturn $goto if ($goto);\n\t}\nif (@mods == 1 && $gconfig{'gotoone'}) {\n\treturn $mods[0];\n\t}\nreturn undef;\n}\n\n=head2 select_all_link(field, form, [text])\n\nReturns HTML for a 'Select all' link that uses Javascript to select\nmultiple checkboxes with the same name. The parameters are :\n\n=item field - Name of the checkbox inputs.\n\n=item form - Index of the form on the page.\n\n=item text - Message for the link, defaulting to 'Select all'.\n\n=cut\nsub select_all_link\n{\nreturn &theme_select_all_link(@_) if (defined(&theme_select_all_link));\nmy ($field, $form, $text) = @_;\n$form = int($form);\n$text ||= $text{'ui_selall'};\nreturn \"<a class='select_all' href='#' onClick='var ff = document.forms[$form].$field; ff.checked = true; for(i=0; i<ff.length; i++) { if (!ff[i].disabled) { ff[i].checked = true; } } return false'>$text</a>\";\n}\n\n=head2 select_invert_link(field, form, text)\n\nReturns HTML for an 'Invert selection' link that uses Javascript to invert the\nselection on multiple checkboxes with the same name. The parameters are :\n\n=item field - Name of the checkbox inputs.\n\n=item form - Index of the form on the page.\n\n=item text - Message for the link, defaulting to 'Invert selection'.\n\n=cut\nsub select_invert_link\n{\nreturn &theme_select_invert_link(@_) if (defined(&theme_select_invert_link));\nmy ($field, $form, $text) = @_;\n$form = int($form);\n$text ||= $text{'ui_selinv'};\nreturn \"<a class='select_invert' href='#' onClick='var ff = document.forms[$form].$field; ff.checked = !ff.checked; for(i=0; i<ff.length; i++) { if (!ff[i].disabled) { ff[i].checked = !ff[i].checked; } } return false'>$text</a>\";\n}\n\n=head2 select_rows_link(field, form, text, &rows)\n\nReturns HTML for a link that uses Javascript to select rows with particular\nvalues for their checkboxes. The parameters are :\n\n=item field - Name of the checkbox inputs.\n\n=item form - Index of the form on the page.\n\n=item text - Message for the link, de\n\n=item rows - Reference to an array of 1 or 0 values, indicating which rows to check.\n\n=cut\nsub select_rows_link\n{\nreturn &theme_select_rows_link(@_) if (defined(&theme_select_rows_link));\nmy ($field, $form, $text, $rows) = @_;\n$form = int($form);\nmy $js = \"var sel = { \".join(\",\", map { \"\\\"\".&quote_escape($_).\"\\\":1\" } @$rows).\" }; \";\n$js .= \"for(var i=0; i<document.forms[$form].${field}.length; i++) { var r = document.forms[$form].${field}[i]; r.checked = sel[r.value]; } \";\n$js .= \"return false;\";\nreturn \"<a href='#' onClick='$js'>$text</a>\";\n}\n\n=head2 check_pid_file(file)\n\nGiven a pid file, returns the PID it contains if the process is running.\n\n=cut\nsub check_pid_file\n{\nopen(PIDFILE, $_[0]) || return undef;\nmy $pid = <PIDFILE>;\nclose(PIDFILE);\n$pid =~ /^\\s*(\\d+)/ || return undef;\nkill(0, $1) || return undef;\nreturn $1;\n}\n\n=head2 get_mod_lib\n\nReturn the local os-specific library name to this module. For internal use only.\n\n=cut\nsub get_mod_lib\n{\nmy $mn = &get_module_name();\nmy $md = &module_root_directory($mn);\nif (-r \"$md/$mn-$gconfig{'os_type'}-$gconfig{'os_version'}-lib.pl\") {\n        return \"$mn-$gconfig{'os_type'}-$gconfig{'os_version'}-lib.pl\";\n        }\nelsif (-r \"$md/$mn-$gconfig{'os_type'}-lib.pl\") {\n        return \"$mn-$gconfig{'os_type'}-lib.pl\";\n        }\nelsif (-r \"$md/$mn-generic-lib.pl\") {\n        return \"$mn-generic-lib.pl\";\n        }\nelse {\n\treturn \"\";\n\t}\n}\n\n=head2 module_root_directory(module)\n\nGiven a module name, returns its root directory. On a typical Webmin install,\nall modules are under the same directory - but it is theoretically possible to\nhave more than one.\n\n=cut\nsub module_root_directory\n{\nmy $d = ref($_[0]) ? $_[0]->{'dir'} : $_[0];\nif (@root_directories > 1) {\n\tforeach my $r (@root_directories) {\n\t\tif (-d \"$r/$d\") {\n\t\t\treturn \"$r/$d\";\n\t\t\t}\n\t\t}\n\t}\nreturn \"$root_directories[0]/$d\";\n}\n\n=head2 list_mime_types\n\nReturns a list of all known MIME types and their extensions, as a list of hash\nreferences with keys :\n\n=item type - The MIME type, like text/plain.\n\n=item exts - A list of extensions, like .doc and .avi.\n\n=item desc - A human-readable description for the MIME type.\n\n=cut\nsub list_mime_types\n{\nif (!@list_mime_types_cache) {\n\tlocal $_;\n\topen(MIME, \"$root_directory/mime.types\");\n\twhile(<MIME>) {\n\t\tmy $cmt;\n\t\ts/\\r|\\n//g;\n\t\tif (s/#\\s*(.*)$//g) {\n\t\t\t$cmt = $1;\n\t\t\t}\n\t\tmy ($type, @exts) = split(/\\s+/);\n\t\tif ($type) {\n\t\t\tpush(@list_mime_types_cache, { 'type' => $type,\n\t\t\t\t\t\t       'exts' => \\@exts,\n\t\t\t\t\t\t       'desc' => $cmt });\n\t\t\t}\n\t\t}\n\tclose(MIME);\n\t}\nreturn @list_mime_types_cache;\n}\n\n=head2 guess_mime_type(filename, [default])\n\nGiven a file name like xxx.gif or foo.html, returns a guessed MIME type.\nThe optional default parameter sets a default type of use if none is found,\nwhich defaults to application/octet-stream.\n\n=cut\nsub guess_mime_type\n{\nif ($_[0] =~ /\\.([A-Za-z0-9\\-]+)$/) {\n\tmy $ext = $1;\n\tforeach my $t (&list_mime_types()) {\n\t\tforeach my $e (@{$t->{'exts'}}) {\n\t\t\treturn $t->{'type'} if (lc($e) eq lc($ext));\n\t\t\t}\n\t\t}\n\t}\nreturn @_ > 1 ? $_[1] : \"application/octet-stream\";\n}\n\n=head2 open_tempfile([handle], file, [no-error], [no-tempfile], [safe?])\n\nOpens a file handle for writing to a temporary file, which will only be\nrenamed over the real file when the handle is closed. This allows critical\nfiles like /etc/shadow to be updated safely, even if writing fails part way\nthrough due to lack of disk space. The parameters are :\n\n=item handle - File handle to open, as you would use in Perl's open function.\n\n=item file - Full path to the file to write, prefixed by > or >> to indicate over-writing or appending. In append mode, no temp file is used.\n\n=item no-error - By default, this function will call error if the open fails. Setting this parameter to 1 causes it to return 0 on failure, and set $! with the error code.\n\n=item no-tempfile - If set to 1, writing will be direct to the file instead of using a temporary file.\n\n=item safe - Indicates to users in read-only mode that this write is safe and non-destructive.\n\n=cut\nsub open_tempfile\n{\nif (@_ == 1) {\n\t# Just getting a temp file\n\tif (!defined($main::open_tempfiles{$_[0]})) {\n\t\t$_[0] =~ /^(.*)\\/(.*)$/ || return $_[0];\n\t\tmy $dir = $1 || \"/\";\n\t\tmy $tmp = \"$dir/$2.webmintmp.$$\";\n\t\t$main::open_tempfiles{$_[0]} = $tmp;\n\t\tpush(@main::temporary_files, $tmp);\n\t\t}\n\treturn $main::open_tempfiles{$_[0]};\n\t}\nelse {\n\t# Actually opening\n\tmy ($fh, $file, $noerror, $notemp, $safe) = @_;\n\t$fh = &callers_package($fh);\n\t$main::open_tempfiles_noerror{$file} = $noerror;\n\n\tmy %gaccess = &get_module_acl(undef, \"\");\n\tmy $db = $gconfig{'debug_what_write'};\n\tif ($file =~ /\\r|\\n|\\0/) {\n\t\tif ($noerror) { return 0; }\n\t\telse { &error(\"Filename contains invalid characters\"); }\n\t\t}\n\tif (&is_readonly_mode() && $file =~ />/ && !$safe) {\n\t\t# Read-only mode .. veto all writes\n\t\tprint STDERR \"vetoing write to $file\\n\";\n\t\treturn open($fh, \">$null_file\");\n\t\t}\n\telsif ($file =~ /^(>|>>|)nul$/i) {\n\t\t# Write to Windows null device\n\t\t&webmin_debug_log($1 eq \">\" ? \"WRITE\" :\n\t\t\t  $1 eq \">>\" ? \"APPEND\" : \"READ\", \"nul\") if ($db);\n\t\t}\n\telsif ($file =~ /^(>|>>)(\\/dev\\/.*)/ || lc($file) eq \"nul\") {\n\t\t# Writes to /dev/null or TTYs don't need to be handled\n\t\t&webmin_debug_log($1 eq \">\" ? \"WRITE\" : \"APPEND\", $2) if ($db);\n\t\treturn open($fh, $file);\n\t\t}\n\telsif ($file =~ /^>\\s*(([a-zA-Z]:)?\\/.*)$/ && !$notemp) {\n\t\t&webmin_debug_log(\"WRITE\", $1) if ($db);\n\t\t# Over-writing a file, via a temp file\n\t\t$file = $1;\n\t\t$file = &translate_filename($file);\n\t\twhile(-l $file) {\n\t\t\t# Open the link target instead\n\t\t\t$file = &resolve_links($file);\n\t\t\t}\n\t\tif (-d $file) {\n\t\t\t# Cannot open a directory!\n\t\t\tif ($noerror) { return 0; }\n\t\t\telse { &error(\"Cannot write to directory $file\"); }\n\t\t\t}\n\t\tmy @oldst = stat($file);\n\t\tmy $directopen = 0;\n\t\tmy $tmp = &open_tempfile($file);\n\t\tmy $ex = open($fh, \">$tmp\");\n\t\tif (!$ex && $! =~ /permission/i) {\n\t\t\t# Could not open temp file .. try opening actual file\n\t\t\t# instead directly\n\t\t\t$ex = open($fh, \">$file\");\n\t\t\tdelete($main::open_tempfiles{$file});\n\t\t\t$directopen = 1;\n\t\t\t}\n\t\telse {\n\t\t\t$main::open_temphandles{$fh} = $file;\n\t\t\t}\n\t\tif (!$ex && !$noerror) {\n\t\t\t&error(&text(\"efileopen\", $file, $!));\n\t\t\t}\n\t\tbinmode($fh);\n\t\tif (@oldst && !$directopen) {\n\t\t\t# Use same permissions as the file being overwritten\n\t\t\tchmod($oldst[2], $tmp);\n\t\t\t}\n\t\treturn $ex;\n\t\t}\n\telsif ($file =~ /^>\\s*(([a-zA-Z]:)?\\/.*)$/ && $notemp) {\n\t\t# Just writing direct to a file\n\t\t&webmin_debug_log(\"WRITE\", $1) if ($db);\n\t\t$file = $1;\n\t\t$file = &translate_filename($file);\n\t\tmy @old_attributes = &get_clear_file_attributes($file);\n\t\tmy $ex = open($fh, \">$file\");\n\t\t&reset_file_attributes($file, \\@old_attributes);\n\t\t$main::open_temphandles{$fh} = $file;\n\t\tif (!$ex && !$noerror) {\n\t\t\t&error(&text(\"efileopen\", $file, $!));\n\t\t\t}\n\t\tbinmode($fh);\n\t\treturn $ex;\n\t\t}\n\telsif ($file =~ /^>>\\s*(([a-zA-Z]:)?\\/.*)$/) {\n\t\t# Appending to a file .. nothing special to do\n\t\t&webmin_debug_log(\"APPEND\", $1) if ($db);\n\t\t$file = $1;\n\t\t$file = &translate_filename($file);\n\t\tmy @old_attributes = &get_clear_file_attributes($file);\n\t\tmy $ex = open($fh, \">>$file\");\n\t\t&reset_file_attributes($file, \\@old_attributes);\n\t\t$main::open_temphandles{$fh} = $file;\n\t\tif (!$ex && !$noerror) {\n\t\t\t&error(&text(\"efileopen\", $file, $!));\n\t\t\t}\n\t\tbinmode($fh);\n\t\treturn $ex;\n\t\t}\n\telsif ($file =~ /^([a-zA-Z]:)?\\//) {\n\t\t# Read mode .. nothing to do here\n\t\t&webmin_debug_log(\"READ\", $file) if ($db);\n\t\t$file = &translate_filename($file);\n\t\treturn open($fh, $file);\n\t\t}\n\telsif ($file eq \">\" || $file eq \">>\") {\n\t\tmy ($package, $filename, $line) = caller;\n\t\tif ($noerror) { return 0; }\n\t\telse { &error(\"Missing file to open at ${package}::${filename} line $line\"); }\n\t\t}\n\telse {\n\t\tmy ($package, $filename, $line) = caller;\n\t\t&error(\"Unsupported file or mode $file at ${package}::${filename} line $line\");\n\t\t}\n\t}\n}\n\n=head2 close_tempfile(file|handle)\n\nCopies a temp file to the actual file, assuming that all writes were\nsuccessful. The handle must have been one passed to open_tempfile.\n\n=cut\nsub close_tempfile\n{\nmy $file;\nmy $fh = &callers_package($_[0]);\n\nif (defined($file = $main::open_temphandles{$fh})) {\n\t# Closing a handle\n\tmy $noerror = $main::open_tempfiles_noerror{$file};\n\tif (!close($fh)) {\n\t\tif ($noerror) { return 0; }\n\t\telse { &error(&text(\"efileclose\", $file, $!)); }\n\t\t}\n\tdelete($main::open_temphandles{$fh});\n\treturn &close_tempfile($file);\n\t}\nelsif (defined($main::open_tempfiles{$_[0]})) {\n\t# Closing a file\n\tmy $noerror = $main::open_tempfiles_noerror{$_[0]};\n\t&webmin_debug_log(\"CLOSE\", $_[0]) if ($gconfig{'debug_what_write'});\n\tmy @st = stat($_[0]);\n\tif (&is_selinux_enabled() && &has_command(\"chcon\")) {\n\t\t# Set original security context\n\t\tsystem(\"chcon --reference=\".quotemeta($_[0]).\n\t\t       \" \".quotemeta($main::open_tempfiles{$_[0]}).\n\t\t       \" >/dev/null 2>&1\");\n\t\t}\n\tmy @old_attributes = &get_clear_file_attributes($_[0]);\n\tif (!rename($main::open_tempfiles{$_[0]}, $_[0])) {\n\t\tif ($noerror) { return 0; }\n\t\telse { &error(\"Failed to replace $_[0] with $main::open_tempfiles{$_[0]} : $!\"); }\n\t\t}\n\tif (@st) {\n\t\t# Set original permissions and ownership\n\t\tchmod($st[2], $_[0]);\n\t\tchown($st[4], $st[5], $_[0]);\n\t\t}\n\t&reset_file_attributes($_[0], \\@old_attributes);\n\tdelete($main::open_tempfiles{$_[0]});\n\tdelete($main::open_tempfiles_noerror{$_[0]});\n\t@main::temporary_files = grep { $_ ne $main::open_tempfiles{$_[0]} } @main::temporary_files;\n\tif ($main::open_templocks{$_[0]}) {\n\t\t&unlock_file($_[0]);\n\t\tdelete($main::open_templocks{$_[0]});\n\t\t}\n\treturn 1;\n\t}\nelse {\n\t# Must be closing a handle not associated with a file\n\tclose($_[0]);\n\treturn 1;\n\t}\n}\n\n=head2 print_tempfile(handle, text, ...)\n\nLike the normal print function, but calls &error on failure. Useful when\ncombined with open_tempfile, to ensure that a criticial file is never\nonly partially written.\n\n=cut\nsub print_tempfile\n{\nmy ($fh, @args) = @_;\n$fh = &callers_package($fh);\n(print $fh @args) || &error(&text(\"efilewrite\",\n\t\t\t    $main::open_temphandles{$fh} || $fh, $!));\n}\n\n=head2 is_selinux_enabled\n\nReturns 1 if SElinux is supported on this system and enabled, 0 if not.\n\n=cut\nsub is_selinux_enabled\n{\nif (!defined($main::selinux_enabled_cache)) {\n\tmy %seconfig;\n\tif ($gconfig{'os_type'} !~ /-linux$/) {\n\t\t# Not on linux, so no way\n\t\t$main::selinux_enabled_cache = 0;\n\t\t}\n\telsif (&read_env_file(\"/etc/selinux/config\", \\%seconfig)) {\n\t\t# Use global config file\n\t\t$main::selinux_enabled_cache =\n\t\t\t$seconfig{'SELINUX'} eq 'disabled' ||\n\t\t\t!$seconfig{'SELINUX'} ? 0 : 1;\n\t\t}\n\telse {\n\t\t# Use selinuxenabled command\n\t\t#$selinux_enabled_cache =\n\t\t#\tsystem(\"selinuxenabled >/dev/null 2>&1\") ? 0 : 1;\n\t\t$main::selinux_enabled_cache = 0;\n\t\t}\n\t}\nreturn $main::selinux_enabled_cache;\n}\n\n=head2 get_clear_file_attributes(file)\n\nFinds file attributes that may prevent writing, clears them and returns them\nas a list. May call error. Mainly for internal use by open_tempfile and\nclose_tempfile.\n\n=cut\nsub get_clear_file_attributes\n{\nmy ($file) = @_;\nmy @old_attributes;\nif ($gconfig{'chattr'}) {\n\t# Get original immutable bit\n\tmy $out = &backquote_command(\n\t\t\"lsattr \".quotemeta($file).\" 2>/dev/null\");\n\tif (!$?) {\n\t\t$out =~ s/\\s\\S+\\n//;\n\t\t@old_attributes = grep { $_ ne '-' } split(//, $out);\n\t\t}\n\tif (&indexof(\"i\", @old_attributes) >= 0) {\n\t\tmy $err = &backquote_logged(\n\t\t\t\"chattr -i \".quotemeta($file).\" 2>&1\");\n\t\tif ($?) {\n\t\t\t&error(\"Failed to remove immutable bit on \".\n\t\t\t       \"$file : $err\");\n\t\t\t}\n\t\t}\n\t}\nreturn @old_attributes;\n}\n\n=head2 reset_file_attributes(file, &attributes)\n\nPut back cleared attributes on some file. May call error. Mainly for internal\nuse by close_tempfile.\n\n=cut\nsub reset_file_attributes\n{\nmy ($file, $old_attributes) = @_;\nif (&indexof(\"i\", @$old_attributes) >= 0) {\n\tmy $err = &backquote_logged(\n\t\t\"chattr +i \".quotemeta($file).\" 2>&1\");\n\tif ($?) {\n\t\t&error(\"Failed to restore immutable bit on \".\n\t\t       \"$file : $err\");\n\t\t}\n\t}\n}\n\n=head2 cleanup_tempnames\n\nRemove all temporary files generated using transname. Typically only called\ninternally when a Webmin script exits.\n\n=cut\nsub cleanup_tempnames\n{\nforeach my $t (@main::temporary_files) {\n\t&unlink_file($t);\n\t}\n@main::temporary_files = ( );\n}\n\n=head2 open_lock_tempfile([handle], file, [no-error])\n\nReturns a temporary file for writing to some actual file, and also locks it.\nEffectively the same as calling lock_file and open_tempfile on the same file,\nbut calls the unlock for you automatically when it is closed.\n\n=cut\nsub open_lock_tempfile\n{\nmy ($fh, $file, $noerror, $notemp, $safe) = @_;\n$fh = &callers_package($fh);\nmy $lockfile = $file;\n$lockfile =~ s/^[^\\/]*//;\nif ($lockfile =~ /^\\//) {\n\twhile(-l $lockfile) {\n\t\t# If the file is a link, follow it so that locking is done on\n\t\t# the same file that gets unlocked later\n\t\t$lockfile = &resolve_links($lockfile);\n\t\t}\n\t$main::open_templocks{$lockfile} = &lock_file($lockfile);\n\t}\nreturn &open_tempfile($fh, $file, $noerror, $notemp, $safe);\n}\n\nsub END\n{\n$main::end_exit_status ||= $?;\nif ($$ == $main::initial_process_id) {\n\t# Exiting from initial process\n\t&cleanup_tempnames();\n\tif ($gconfig{'debug_what_start'} && $main::debug_log_start_time) {\n\t\tmy $len = time() - $main::debug_log_start_time;\n\t\t&webmin_debug_log(\"STOP\", \"runtime=$len\");\n\t\t$main::debug_log_start_time = 0;\n\t\t}\n\tif (!$ENV{'SCRIPT_NAME'}) {\n\t\t# In a command-line script - call the real exit, so that the\n\t\t# exit status gets properly propogated. In some cases this\n\t\t# was not happening.\n\t\texit($main::end_exit_status);\n\t\t}\n\t}\n}\n\n=head2 month_to_number(month)\n\nConverts a month name like feb to a number like 1.\n\n=cut\nsub month_to_number\n{\nreturn $month_to_number_map{lc(substr($_[0], 0, 3))};\n}\n\n=head2 number_to_month(number)\n\nConverts a number like 1 to a month name like Feb.\n\n=cut\nsub number_to_month\n{\nreturn ucfirst($number_to_month_map{$_[0]});\n}\n\n=head2 get_rbac_module_acl(user, module)\n\nReturns a hash reference of RBAC overrides ACLs for some user and module.\nMay return undef if none exist (indicating access denied), or the string *\nif full access is granted.\n\n=cut\nsub get_rbac_module_acl\n{\nmy ($user, $mod) = @_;\neval \"use Authen::SolarisRBAC\";\nreturn undef if ($@);\nmy %rv;\nmy $foundany = 0;\nif (Authen::SolarisRBAC::chkauth(\"webmin.$mod.admin\", $user)) {\n\t# Automagic webmin.modulename.admin authorization exists .. allow access\n\t$foundany = 1;\n\tif (!Authen::SolarisRBAC::chkauth(\"webmin.$mod.config\", $user)) {\n\t\t%rv = ( 'noconfig' => 1 );\n\t\t}\n\telse {\n\t\t%rv = ( );\n\t\t}\n\t}\nlocal $_;\nopen(RBAC, &module_root_directory($mod).\"/rbac-mapping\");\nwhile(<RBAC>) {\n\ts/\\r|\\n//g;\n\ts/#.*$//;\n\tmy ($auths, $acls) = split(/\\s+/, $_);\n\tmy @auths = split(/,/, $auths);\n\tnext if (!$auths);\n\tmy ($merge) = ($acls =~ s/^\\+//);\n\tmy $gotall = 1;\n\tif ($auths eq \"*\") {\n\t\t# These ACLs apply to all RBAC users.\n\t\t# Only if there is some that match a specific authorization\n\t\t# later will they be used though.\n\t\t}\n\telse {\n\t\t# Check each of the RBAC authorizations\n\t\tforeach my $a (@auths) {\n\t\t\tif (!Authen::SolarisRBAC::chkauth($a, $user)) {\n\t\t\t\t$gotall = 0;\n\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t$foundany++ if ($gotall);\n\t\t}\n\tif ($gotall) {\n\t\t# Found an RBAC authorization - return the ACLs\n\t\treturn \"*\" if ($acls eq \"*\");\n\t\tmy %acl = map { split(/=/, $_, 2) } split(/,/, $acls);\n\t\tif ($merge) {\n\t\t\t# Just add to current set\n\t\t\tforeach my $a (keys %acl) {\n\t\t\t\t$rv{$a} = $acl{$a};\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\t# Found final ACLs\n\t\t\treturn \\%acl;\n\t\t\t}\n\t\t}\n\t}\nclose(RBAC);\nreturn !$foundany ? undef : %rv ? \\%rv : undef;\n}\n\n=head2 supports_rbac([module])\n\nReturns 1 if RBAC client support is available, such as on Solaris.\n\n=cut\nsub supports_rbac\n{\nreturn 0 if ($gconfig{'os_type'} ne 'solaris');\neval \"use Authen::SolarisRBAC\";\nreturn 0 if ($@);\nif ($_[0]) {\n\t#return 0 if (!-r &module_root_directory($_[0]).\"/rbac-mapping\");\n\t}\nreturn 1;\n}\n\n=head2 supports_ipv6()\n\nReturns 1 if outgoing IPv6 connections can be made\n\n=cut\nsub supports_ipv6\n{\nreturn $ipv6_module_error ? 0 : 1;\n}\n\n=head2 use_rbac_module_acl(user, module)\n\nReturns 1 if some user should use RBAC to get permissions for a module\n\n=cut\nsub use_rbac_module_acl\n{\nmy $u = defined($_[0]) ? $_[0] : $base_remote_user;\nmy $m = defined($_[1]) ? $_[1] : &get_module_name();\nreturn 1 if ($gconfig{'rbacdeny_'.$u});\t\t# RBAC forced for user\nmy %access = &get_module_acl($u, $m, 1);\nreturn $access{'rbac'} ? 1 : 0;\n}\n\n=head2 execute_command(command, stdin, stdout, stderr, translate-files?, safe?)\n\nRuns some command, possibly feeding it input and capturing output to the\ngive files or scalar references. The parameters are :\n\n=item command - Full command to run, possibly including shell meta-characters.\n\n=item stdin - File to read input from, or a scalar ref containing input, or undef if no input should be given.\n\n=item stdout - File to write output to, or a scalar ref into which output should be placed, or undef if the output is to be discarded.\n\n=item stderr - File to write error output to, or a scalar ref into which error output should be placed, or undef if the error output is to be discarded.\n\n=item translate-files - Set to 1 to apply filename translation to any filenames. Usually has no effect.\n\n=item safe - Set to 1 if this command is safe and does not modify the state of the system.\n\n=cut\nsub execute_command\n{\nmy ($cmd, $stdin, $stdout, $stderr, $trans, $safe) = @_;\nif (&is_readonly_mode() && !$safe) {\n\tprint STDERR \"Vetoing command $_[0]\\n\";\n\t$? = 0;\n\treturn 0;\n\t}\n$cmd = &translate_command($cmd);\n\n# Use ` operator where possible\n&webmin_debug_log('CMD', \"cmd=$cmd\") if ($gconfig{'debug_what_cmd'});\nif (!$stdin && ref($stdout) && !$stderr) {\n\t$cmd = \"($cmd)\" if ($gconfig{'os_type'} ne 'windows');\n\t$$stdout = `$cmd 2>$null_file`;\n\treturn $?;\n\t}\nelsif (!$stdin && ref($stdout) && $stdout eq $stderr) {\n\t$cmd = \"($cmd)\" if ($gconfig{'os_type'} ne 'windows');\n\t$$stdout = `$cmd 2>&1`;\n\treturn $?;\n\t}\nelsif (!$stdin && !$stdout && !$stderr) {\n\t$cmd = \"($cmd)\" if ($gconfig{'os_type'} ne 'windows');\n\treturn system(\"$cmd >$null_file 2>$null_file <$null_file\");\n\t}\n\n# Setup pipes\n$| = 1;\t\t# needed on some systems to flush before forking\npipe(EXECSTDINr, EXECSTDINw);\npipe(EXECSTDOUTr, EXECSTDOUTw);\npipe(EXECSTDERRr, EXECSTDERRw);\nmy $pid;\nif (!($pid = fork())) {\n\tuntie(*STDIN);\n\tuntie(*STDOUT);\n\tuntie(*STDERR);\n\topen(STDIN, \"<&EXECSTDINr\");\n\topen(STDOUT, \">&EXECSTDOUTw\");\n\tif (ref($stderr) && $stderr eq $stdout) {\n\t\topen(STDERR, \">&EXECSTDOUTw\");\n\t\t}\n\telse {\n\t\topen(STDERR, \">&EXECSTDERRw\");\n\t\t}\n\t$| = 1;\n\tclose(EXECSTDINw);\n\tclose(EXECSTDOUTr);\n\tclose(EXECSTDERRr);\n\n\tmy $fullcmd = \"($cmd)\";\n\tif ($stdin && !ref($stdin)) {\n\t\t$fullcmd .= \" <$stdin\";\n\t\t}\n\tif ($stdout && !ref($stdout)) {\n\t\t$fullcmd .= \" >$stdout\";\n\t\t}\n\tif ($stderr && !ref($stderr)) {\n\t\tif ($stderr eq $stdout) {\n\t\t\t$fullcmd .= \" 2>&1\";\n\t\t\t}\n\t\telse {\n\t\t\t$fullcmd .= \" 2>$stderr\";\n\t\t\t}\n\t\t}\n\tif ($gconfig{'os_type'} eq 'windows') {\n\t\texec($fullcmd);\n\t\t}\n\telse {\n\t\texec(\"/bin/sh\", \"-c\", $fullcmd);\n\t\t}\n\tprint \"Exec failed : $!\\n\";\n\texit(1);\n\t}\nclose(EXECSTDINr);\nclose(EXECSTDOUTw);\nclose(EXECSTDERRw);\n\n# Feed input and capture output\nlocal $_;\nif ($stdin && ref($stdin)) {\n\tprint EXECSTDINw $$stdin;\n\tclose(EXECSTDINw);\n\t}\nif ($stdout && ref($stdout)) {\n\t$$stdout = undef;\n\twhile(<EXECSTDOUTr>) {\n\t\t$$stdout .= $_;\n\t\t}\n\tclose(EXECSTDOUTr);\n\t}\nif ($stderr && ref($stderr) && $stderr ne $stdout) {\n\t$$stderr = undef;\n\twhile(<EXECSTDERRr>) {\n\t\t$$stderr .= $_;\n\t\t}\n\tclose(EXECSTDERRr);\n\t}\n\n# Get exit status\nwaitpid($pid, 0);\nreturn $?;\n}\n\n=head2 open_readfile(handle, file)\n\nOpens some file for reading. Returns 1 on success, 0 on failure. Pretty much\nexactly the same as Perl's open function.\n\n=cut\nsub open_readfile\n{\nmy ($fh, $file) = @_;\n$fh = &callers_package($fh);\nmy $realfile = &translate_filename($file);\n&webmin_debug_log('READ', $file) if ($gconfig{'debug_what_read'});\nreturn open($fh, \"<\".$realfile);\n}\n\n=head2 open_execute_command(handle, command, output?, safe?)\n\nRuns some command, with the specified file handle set to either write to it if\nin-or-out is set to 0, or read to it if output is set to 1. The safe flag\nindicates if the command modifies the state of the system or not.\n\n=cut\nsub open_execute_command\n{\nmy ($fh, $cmd, $mode, $safe) = @_;\n$fh = &callers_package($fh);\nmy $realcmd = &translate_command($cmd);\nif (&is_readonly_mode() && !$safe) {\n\t# Don't actually run it\n\tprint STDERR \"vetoing command $cmd\\n\";\n\t$? = 0;\n\tif ($mode == 0) {\n\t\treturn open($fh, \">$null_file\");\n\t\t}\n\telse {\n\t\treturn open($fh, $null_file);\n\t\t}\n\t}\n# Really run it\n&webmin_debug_log('CMD', \"mode=$mode cmd=$realcmd\")\n\tif ($gconfig{'debug_what_cmd'});\nif ($mode == 0) {\n\treturn open($fh, \"| $cmd\");\n\t}\nelsif ($mode == 1) {\n\treturn open($fh, \"$cmd 2>$null_file |\");\n\t}\nelsif ($mode == 2) {\n\treturn open($fh, \"$cmd 2>&1 |\");\n\t}\n}\n\n=head2 translate_filename(filename)\n\nApplies all relevant registered translation functions to a filename. Mostly\nfor internal use, and typically does nothing.\n\n=cut\nsub translate_filename\n{\nmy ($realfile) = @_;\nmy @funcs = grep { $_->[0] eq &get_module_name() ||\n\t\t   !defined($_->[0]) } @main::filename_callbacks;\nforeach my $f (@funcs) {\n\tmy $func = $f->[1];\n\t$realfile = &$func($realfile, @{$f->[2]});\n\t}\nreturn $realfile;\n}\n\n=head2 translate_command(filename)\n\nApplies all relevant registered translation functions to a command. Mostly\nfor internal use, and typically does nothing.\n\n=cut\nsub translate_command\n{\nmy ($realcmd) = @_;\nmy @funcs = grep { $_->[0] eq &get_module_name() ||\n\t\t   !defined($_->[0]) } @main::command_callbacks;\nforeach my $f (@funcs) {\n\tmy $func = $f->[1];\n\t$realcmd = &$func($realcmd, @{$f->[2]});\n\t}\nreturn $realcmd;\n}\n\n=head2 register_filename_callback(module|undef, &function, &args)\n\nRegisters some function to be called when the specified module (or all\nmodules) tries to open a file for reading and writing. The function must\nreturn the actual file to open. This allows you to override which files\nother code actually operates on, via the translate_filename function.\n\n=cut\nsub register_filename_callback\n{\nmy ($mod, $func, $args) = @_;\npush(@main::filename_callbacks, [ $mod, $func, $args ]);\n}\n\n=head2 register_command_callback(module|undef, &function, &args)\n\nRegisters some function to be called when the specified module (or all\nmodules) tries to execute a command. The function must return the actual\ncommand to run. This allows you to override which commands other other code\nactually runs, via the translate_command function.\n\n=cut\nsub register_command_callback\n{\nmy ($mod, $func, $args) = @_;\npush(@main::command_callbacks, [ $mod, $func, $args ]);\n}\n\n=head2 capture_function_output(&function, arg, ...)\n\nCaptures output that some function prints to STDOUT, and returns it. Useful\nfor functions outside your control that print data when you really want to\nmanipulate it before output.\n\n=cut\nsub capture_function_output\n{\nmy ($func, @args) = @_;\nsocketpair(SOCKET2, SOCKET1, AF_UNIX, SOCK_STREAM, PF_UNSPEC);\nmy $old = select(SOCKET1);\nmy @rv = &$func(@args);\nselect($old);\nclose(SOCKET1);\nmy $out;\nlocal $_;\nwhile(<SOCKET2>) {\n\t$out .= $_;\n\t}\nclose(SOCKET2);\nreturn wantarray ? ($out, \\@rv) : $out;\n}\n\n=head2 capture_function_output_tempfile(&function, arg, ...)\n\nBehaves the same as capture_function_output, but uses a temporary file\nto avoid buffer full problems.\n\n=cut\nsub capture_function_output_tempfile\n{\nmy ($func, @args) = @_;\nmy $temp = &transname();\nopen(BUFFER, \">$temp\");\nmy $old = select(BUFFER);\nmy @rv = &$func(@args);\nselect($old);\nclose(BUFFER);\nmy $out = &read_file_contents($temp);\n&unlink_file($temp);\nreturn wantarray ? ($out, \\@rv) : $out;\n}\n\n=head2 modules_chooser_button(field, multiple, [form])\n\nReturns HTML for a button for selecting one or many Webmin modules.\nfield - Name of the HTML field to place the module names into.\nmultiple - Set to 1 if multiple modules can be selected.\nform - Index of the form on the page.\n\n=cut\nsub modules_chooser_button\n{\nreturn &theme_modules_chooser_button(@_)\n\tif (defined(&theme_modules_chooser_button));\nmy $form = defined($_[2]) ? $_[2] : 0;\nmy $w = $_[1] ? 700 : 500;\nmy $h = 200;\nif ($_[1] && $gconfig{'db_sizemodules'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizemodules'});\n\t}\nelsif (!$_[1] && $gconfig{'db_sizemodule'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizemodule'});\n\t}\nreturn \"<input type=button onClick='ifield = document.forms[$form].$_[0]; chooser = window.open(\\\"$gconfig{'webprefix'}/module_chooser.cgi?multi=$_[1]&module=\\\"+escape(ifield.value), \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,width=$w,height=$h\\\"); chooser.ifield = ifield; window.ifield = ifield' value=\\\"...\\\">\\n\";\n}\n\n=head2 substitute_template(text, &hash)\n\nGiven some text and a hash reference, for each occurrence of $FOO or ${FOO} in\nthe text replaces it with the value of the hash key foo. Also supports blocks\nlike ${IF-FOO} ... ${ENDIF-FOO}, whose contents are only included if foo is\nnon-zero, and ${IF-FOO} ... ${ELSE-FOO} ... ${ENDIF-FOO}.\n\n=cut\nsub substitute_template\n{\n# Add some extra fixed parameters to the hash\nmy %hash = %{$_[1]};\n$hash{'hostname'} = &get_system_hostname();\n$hash{'webmin_config'} = $config_directory;\n$hash{'webmin_etc'} = $config_directory;\n$hash{'module_config'} = &get_module_variable('$module_config_directory');\n$hash{'webmin_var'} = $var_directory;\n\n# Add time-based parameters, for use in DNS\n$hash{'current_time'} = time();\nmy @tm = localtime($hash{'current_time'});\n$hash{'current_year'} = $tm[5]+1900;\n$hash{'current_month'} = sprintf(\"%2.2d\", $tm[4]+1);\n$hash{'current_day'} = sprintf(\"%2.2d\", $tm[3]);\n$hash{'current_hour'} = sprintf(\"%2.2d\", $tm[2]);\n$hash{'current_minute'} = sprintf(\"%2.2d\", $tm[1]);\n$hash{'current_second'} = sprintf(\"%2.2d\", $tm[0]);\n\n# Actually do the substition\nmy $rv = $_[0];\nforeach my $s (keys %hash) {\n\tnext if ($s eq '');\t# Prevent just $ from being subbed\n\tmy $us = uc($s);\n\tmy $sv = $hash{$s};\n\tmy $qsv = quotemeta($sv);\n\t$rv =~ s/\\$\\{\\Q$us\\E\\}/$sv/g;\n\t$rv =~ s/\\$\\Q$us\\E/$sv/g;\n\t$rv =~ s/\\$\\{\\\\\\Q$us\\E\\}/$qsv/g;\n\tif ($sv) {\n\t\t# Replace ${IF}..${ELSE}..${ENDIF} block with first value,\n\t\t# and ${IF}..${ENDIF} with value\n\t\t$rv =~ s/\\$\\{IF-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ELSE-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIF-\\Q$us\\E\\}(\\n?)/$2/g;\n\t\t$rv =~ s/\\$\\{IF-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIF-\\Q$us\\E\\}(\\n?)/$2/g;\n\n\t\t# Replace $IF..$ELSE..$ENDIF block with first value,\n\t\t# and $IF..$ENDIF with value\n\t\t$rv =~ s/\\$IF-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ELSE-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ENDIF-\\Q$us\\E(\\n?)/$2/g;\n\t\t$rv =~ s/\\$IF-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ENDIF-\\Q$us\\E(\\n?)/$2/g;\n\n\t\t# Replace ${IFEQ}..${ENDIFEQ} block with first value if\n\t\t# matching, nothing if not\n\t\t$rv =~ s/\\$\\{IFEQ-\\Q$us\\E-\\Q$sv\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIFEQ-\\Q$us\\E-\\Q$sv\\E\\}(\\n?)/$2/g;\n\t\t$rv =~ s/\\$\\{IFEQ-\\Q$us\\E-[^\\}]+}(\\n?)([\\000-\\377]*?)\\$\\{ENDIFEQ-\\Q$us\\E-[^\\}]+\\}(\\n?)//g;\n\n\t\t# Replace $IFEQ..$ENDIFEQ block with first value if\n\t\t# matching, nothing if not\n\t\t$rv =~ s/\\$IFEQ-\\Q$us\\E-\\Q$sv\\E(\\n?)([\\000-\\377]*?)\\$ENDIFEQ-\\Q$us\\E-\\Q$sv\\E(\\n?)/$2/g;\n\t\t$rv =~ s/\\$IFEQ-\\Q$us\\E-\\S+(\\n?)([\\000-\\377]*?)\\$ENDIFEQ-\\Q$us\\E-\\S+(\\n?)//g;\n\t\t}\n\telse {\n\t\t# Replace ${IF}..${ELSE}..${ENDIF} block with second value,\n\t\t# and ${IF}..${ENDIF} with nothing\n\t\t$rv =~ s/\\$\\{IF-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ELSE-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIF-\\Q$us\\E\\}(\\n?)/$4/g;\n\t\t$rv =~ s/\\$\\{IF-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIF-\\Q$us\\E\\}(\\n?)//g;\n\n\t\t# Replace $IF..$ELSE..$ENDIF block with second value,\n\t\t# and $IF..$ENDIF with nothing\n\t\t$rv =~ s/\\$IF-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ELSE-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ENDIF-\\Q$us\\E(\\n?)/$4/g;\n\t\t$rv =~ s/\\$IF-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ENDIF-\\Q$us\\E(\\n?)//g;\n\n\t\t# Replace ${IFEQ}..${ENDIFEQ} block with nothing\n\t\t$rv =~ s/\\$\\{IFEQ-\\Q$us\\E-[^\\}]+}(\\n?)([\\000-\\377]*?)\\$\\{ENDIFEQ-\\Q$us\\E-[^\\}]+\\}(\\n?)//g;\n\t\t$rv =~ s/\\$IFEQ-\\Q$us\\E-\\S+(\\n?)([\\000-\\377]*?)\\$ENDIFEQ-\\Q$us\\E-\\S+(\\n?)//g;\n\t\t}\n\t}\n\n# Now assume any $IF blocks whose variables are not present in the hash\n# evaluate to false.\n# $IF...$ELSE x $ENDIF => x\n$rv =~ s/\\$\\{IF\\-([A-Z]+)\\}.*?\\$\\{ELSE\\-\\1\\}(.*?)\\$\\{ENDIF\\-\\1\\}/$2/gs;\n# $IF...x...$ENDIF => (nothing)\n$rv =~ s/\\$\\{IF\\-([A-Z]+)\\}.*?\\$\\{ENDIF\\-\\1\\}//gs;\n# ${var} => (nothing)\n$rv =~ s/\\$\\{[A-Z]+\\}//g;\n\nreturn $rv;\n}\n\n=head2 running_in_zone\n\nReturns 1 if the current Webmin instance is running in a Solaris zone. Used to\ndisable module and features that are not appropriate, like those that modify\nmounted filesystems.\n\n=cut\nsub running_in_zone\n{\nreturn 0 if ($gconfig{'os_type'} ne 'solaris' ||\n\t     $gconfig{'os_version'} < 10);\nmy $zn = `zonename 2>$null_file`;\nchop($zn);\nreturn $zn && $zn ne \"global\";\n}\n\n=head2 running_in_vserver\n\nReturns 1 if the current Webmin instance is running in a Linux VServer.\nUsed to disable modules and features that are not appropriate.\n\n=cut\nsub running_in_vserver\n{\nreturn 0 if ($gconfig{'os_type'} !~ /^\\*-linux$/);\nmy $vserver;\nlocal $_;\nopen(MTAB, \"/etc/mtab\");\nwhile(<MTAB>) {\n\tmy ($dev, $mp) = split(/\\s+/, $_);\n\tif ($mp eq \"/\" && $dev =~ /^\\/dev\\/hdv/) {\n\t\t$vserver = 1;\n\t\tlast;\n\t\t}\n\t}\nclose(MTAB);\nreturn $vserver;\n}\n\n=head2 running_in_xen\n\nReturns 1 if Webmin is running inside a Xen instance, by looking\nat /proc/xen/capabilities.\n\n=cut\nsub running_in_xen\n{\nreturn 0 if (!-r \"/proc/xen/capabilities\");\nmy $cap = &read_file_contents(\"/proc/xen/capabilities\");\nreturn $cap =~ /control_d/ ? 0 : 1;\n}\n\n=head2 running_in_openvz\n\nReturns 1 if Webmin is running inside an OpenVZ container, by looking\nat /proc/vz/veinfo for a non-zero line.\n\n=cut\nsub running_in_openvz\n{\nreturn 0 if (!-r \"/proc/vz/veinfo\");\nmy $lref = &read_file_lines(\"/proc/vz/veinfo\", 1);\nreturn 0 if (!$lref || !@$lref);\nforeach my $l (@$lref) {\n\t$l =~ s/^\\s+//;\n\tmy @ll = split(/\\s+/, $l);\n\treturn 0 if ($ll[0] eq '0');\n\t}\nreturn 1;\n}\n\n=head2 list_categories(&modules, [include-empty])\n\nReturns a hash mapping category codes to names, including any custom-defined\ncategories. The modules parameter must be an array ref of module hash objects,\nas returned by get_all_module_infos.\n\n=cut\nsub list_categories\n{\nmy ($mods, $empty) = @_;\nmy (%cats, %catnames);\n&read_file(\"$config_directory/webmin.catnames\", \\%catnames);\nforeach my $o (@lang_order_list) {\n\t&read_file(\"$config_directory/webmin.catnames.$o\", \\%catnames);\n\t}\n$catnames{''} ||= $catnames{'other'};\nif ($empty) {\n\t%cats = %catnames;\n\t}\nforeach my $m (@$mods) {\n\tmy $c = $m->{'category'};\n\tnext if ($cats{$c});\n\tif (defined($catnames{$c})) {\n\t\t$cats{$c} = $catnames{$c};\n\t\t}\n\telsif ($text{\"category_$c\"}) {\n\t\t$cats{$c} = $text{\"category_$c\"};\n\t\t}\n\telse {\n\t\t# try to get category name from module ..\n\t\tmy %mtext = &load_language($m->{'dir'});\n\t\tif ($mtext{\"category_$c\"}) {\n\t\t\t$cats{$c} = $mtext{\"category_$c\"};\n\t\t\t}\n\t\telse {\n\t\t\t$c = $m->{'category'} = \"\";\n\t\t\t$cats{$c} = $text{\"category_$c\"};\n\t\t\t}\n\t\t}\n\t}\nreturn %cats;\n}\n\n=head2 is_readonly_mode\n\nReturns 1 if the current user is in read-only mode, and thus all writes\nto files and command execution should fail.\n\n=cut\nsub is_readonly_mode\n{\nif (!defined($main::readonly_mode_cache)) {\n\tmy %gaccess = &get_module_acl(undef, \"\");\n\t$main::readonly_mode_cache = $gaccess{'readonly'} ? 1 : 0;\n\t}\nreturn $main::readonly_mode_cache;\n}\n\n=head2 command_as_user(user, with-env?, command, ...)\n\nReturns a command to execute some command as the given user, using the\nsu statement. If on Linux, the /bin/sh shell is forced in case the user\ndoes not have a valid shell. If with-env is set to 1, the - flag is added\nto the su command to read the user's .profile or .bashrc file. If with-env is\nset to 2, the user's shell is always used regardless. If set to 3, the user's\nshell is used AND the - flag is set.\n\n=cut\nsub command_as_user\n{\nmy ($user, $env, @args) = @_;\nmy @uinfo = getpwnam($user);\nif ($uinfo[8] ne \"/bin/sh\" && $uinfo[8] !~ /\\/bash$/ && $env < 2) {\n\t# User shell doesn't appear to be valid\n\tif ($gconfig{'os_type'} =~ /-linux$/) {\n\t\t# Use -s /bin/sh to force it\n\t\t$shellarg = \" -s /bin/sh\";\n\t\t}\n\telsif ($gconfig{'os_type'} eq 'freebsd' ||\n\t       $gconfig{'os_type'} eq 'solaris' &&\n\t\t$gconfig{'os_version'} >= 11 ||\n\t       $gconfig{'os_type'} eq 'macos') {\n\t\t# Use -m and force /bin/sh\n\t\t@args = ( \"/bin/sh\", \"-c\", quotemeta(join(\" \", @args)) );\n\t\t$shellarg = \" -m\";\n\t\t}\n\t}\nmy $rv = \"su\".($env == 1 || $env == 3 ? \" -\" : \"\").$shellarg.\n\t \" \".quotemeta($user).\" -c \".quotemeta(join(\" \", @args));\nreturn $rv;\n}\n\n=head2 list_osdn_mirrors(project, file)\n\nThis function is now deprecated in favor of letting sourceforge just\nredirect to the best mirror, and now just returns their primary download URL.\n\n=cut\nsub list_osdn_mirrors\n{\nmy ($project, $file) = @_;\nreturn ( { 'url' => \"http://downloads.sourceforge.net/$project/$file\",\n\t   'default' => 0,\n\t   'mirror' => 'downloads' } );\n}\n\n=head2 convert_osdn_url(url)\n\nGiven a URL like http://osdn.dl.sourceforge.net/sourceforge/project/file.zip\nor http://prdownloads.sourceforge.net/project/file.zip , convert it\nto a real URL on the sourceforge download redirector.\n\n=cut\nsub convert_osdn_url\n{\nmy ($url) = @_;\nif ($url =~ /^http:\\/\\/[^\\.]+.dl.sourceforge.net\\/sourceforge\\/([^\\/]+)\\/(.*)$/ ||\n    $url =~ /^http:\\/\\/prdownloads.sourceforge.net\\/([^\\/]+)\\/(.*)$/) {\n\t# Always use the Sourceforge mail download URL, which does\n\t# a location-based redirect for us\n\tmy ($project, $file) = ($1, $2);\n\t$url = \"http://prdownloads.sourceforge.net/sourceforge/\".\n\t       \"$project/$file\";\n\treturn wantarray ? ( $url, 0 ) : $url;\n\t}\nelse {\n\t# Some other source .. don't change\n\treturn wantarray ? ( $url, 2 ) : $url;\n\t}\n}\n\n=head2 get_current_dir\n\nReturns the directory the current process is running in.\n\n=cut\nsub get_current_dir\n{\nmy $out;\nif ($gconfig{'os_type'} eq 'windows') {\n\t# Use cd command\n\t$out = `cd`;\n\t}\nelse {\n\t# Use pwd command\n\t$out = `pwd`;\n\t$out =~ s/\\\\/\\//g;\n\t}\n$out =~ s/\\r|\\n//g;\nreturn $out;\n}\n\n=head2 supports_users\n\nReturns 1 if the current OS supports Unix user concepts and functions like\nsu , getpw* and so on. This will be true on Linux and other Unixes, but false\non Windows.\n\n=cut\nsub supports_users\n{\nreturn $gconfig{'os_type'} ne 'windows';\n}\n\n=head2 supports_symlinks\n\nReturns 1 if the current OS supports symbolic and hard links. This will not\nbe the case on Windows.\n\n=cut\nsub supports_symlinks\n{\nreturn $gconfig{'os_type'} ne 'windows';\n}\n\n=head2 quote_path(path)\n\nReturns a path with safe quoting for the current operating system.\n\n=cut\nsub quote_path\n{\nmy ($path) = @_;\nif ($gconfig{'os_type'} eq 'windows' || $path =~ /^[a-z]:/i) {\n\t# Windows only supports \"\" style quoting\n\treturn \"\\\"$path\\\"\";\n\t}\nelse {\n\treturn quotemeta($path);\n\t}\n}\n\n=head2 get_windows_root\n\nReturns the base windows system directory, like c:/windows.\n\n=cut\nsub get_windows_root\n{\nif ($ENV{'SystemRoot'}) {\n\tmy $rv = $ENV{'SystemRoot'};\n\t$rv =~ s/\\\\/\\//g;\n\treturn $rv;\n\t}\nelse {\n\treturn -d \"c:/windows\" ? \"c:/windows\" : \"c:/winnt\";\n\t}\n}\n\n=head2 read_file_contents(file)\n\nGiven a filename, returns its complete contents as a string. Effectively\nthe same as the Perl construct `cat file`.\n\n=cut\nsub read_file_contents\n{\nmy ($file) = @_;\n&open_readfile(FILE, $file) || return undef;\nlocal $/ = undef;\nmy $rv = <FILE>;\nclose(FILE);\nreturn $rv;\n}\n\n=head2 write_file_contents(file, data)\n\nWrites some data to the given file\n\n=cut\nsub write_file_contents\n{\nmy ($file, $data) = @_;\n&open_tempfile(FILE, \">$file\");\n&print_tempfile(FILE, $data);\n&close_tempfile(FILE);\n}\n\n=head2 unix_crypt(password, salt)\n\nPerforms Unix encryption on a password, using the built-in crypt function or\nthe Crypt::UnixCrypt module if the former does not work. The salt parameter\nmust be either an already-hashed password, or a two-character alpha-numeric\nstring.\n\n=cut\nsub unix_crypt\n{\nmy ($pass, $salt) = @_;\nreturn \"\" if ($salt !~ /^[a-zA-Z0-9\\.\\/]{2}/);   # same as real crypt\nmy $rv = eval \"crypt(\\$pass, \\$salt)\";\nmy $err = $@;\nreturn $rv if ($rv && !$@);\neval \"use Crypt::UnixCrypt\";\nif (!$@) {\n\treturn Crypt::UnixCrypt::crypt($pass, $salt);\n\t}\nelse {\n\t&error(\"Failed to encrypt password : $err\");\n\t}\n}\n\n=head2 split_quoted_string(string)\n\nGiven a string like I<foo \"bar baz\" quux>, returns the array :\nfoo, bar baz, quux\n\n=cut\nsub split_quoted_string\n{\nmy ($str) = @_;\nmy @rv;\nwhile($str =~ /^\"([^\"]*)\"\\s*([\\000-\\377]*)$/ ||\n      $str =~ /^'([^']*)'\\s*([\\000-\\377]*)$/ ||\n      $str =~ /^(\\S+)\\s*([\\000-\\377]*)$/) {\n\tpush(@rv, $1);\n\t$str = $2;\n\t}\nreturn @rv;\n}\n\n=head2 write_to_http_cache(url, file|&data)\n\nUpdates the Webmin cache with the contents of the given file, possibly also\nclearing out old data. Mainly for internal use by http_download.\n\n=cut\nsub write_to_http_cache\n{\nmy ($url, $file) = @_;\nreturn 0 if (!$gconfig{'cache_size'});\n\n# Don't cache downloads that look dynamic\nif ($url =~ /cgi-bin/ || $url =~ /\\?/) {\n\treturn 0;\n\t}\n\n# Check if the current module should do caching\nif ($gconfig{'cache_mods'} =~ /^\\!(.*)$/) {\n\t# Caching all except some modules\n\tmy @mods = split(/\\s+/, $1);\n\treturn 0 if (&indexof(&get_module_name(), @mods) != -1);\n\t}\nelsif ($gconfig{'cache_mods'}) {\n\t# Only caching some modules\n\tmy @mods = split(/\\s+/, $gconfig{'cache_mods'});\n\treturn 0 if (&indexof(&get_module_name(), @mods) == -1);\n\t}\n\n# Work out the size\nmy $size;\nif (ref($file)) {\n\t$size = length($$file);\n\t}\nelse {\n\tmy @st = stat($file);\n\t$size = $st[7];\n\t}\n\nif ($size > $gconfig{'cache_size'}) {\n\t# Bigger than the whole cache - so don't save it\n\treturn 0;\n\t}\nmy $cfile = $url;\n$cfile =~ s/\\//_/g;\n$cfile = \"$main::http_cache_directory/$cfile\";\n\n# See how much we have cached currently, clearing old files\nmy $total = 0;\nmkdir($main::http_cache_directory, 0700) if (!-d $main::http_cache_directory);\nopendir(CACHEDIR, $main::http_cache_directory);\nforeach my $f (readdir(CACHEDIR)) {\n\tnext if ($f eq \".\" || $f eq \"..\");\n\tmy $path = \"$main::http_cache_directory/$f\";\n\tmy @st = stat($path);\n\tif ($gconfig{'cache_days'} &&\n\t    time()-$st[9] > $gconfig{'cache_days'}*24*60*60) {\n\t\t# This file is too old .. trash it\n\t\tunlink($path);\n\t\t}\n\telse {\n\t\t$total += $st[7];\n\t\tpush(@cached, [ $path, $st[7], $st[9] ]);\n\t\t}\n\t}\nclosedir(CACHEDIR);\n@cached = sort { $a->[2] <=> $b->[2] } @cached;\nwhile($total+$size > $gconfig{'cache_size'} && @cached) {\n\t# Cache is too big .. delete some files until the new one will fit\n\tunlink($cached[0]->[0]);\n\t$total -= $cached[0]->[1];\n\tshift(@cached);\n\t}\n\n# Finally, write out the new file\nif (ref($file)) {\n\t&open_tempfile(CACHEFILE, \">$cfile\");\n\t&print_tempfile(CACHEFILE, $$file);\n\t&close_tempfile(CACHEFILE);\n\t}\nelse {\n\tmy ($ok, $err) = &copy_source_dest($file, $cfile);\n\t}\n\nreturn 1;\n}\n\n=head2 check_in_http_cache(url)\n\nIf some URL is in the cache and valid, return the filename for it. Mainly\nfor internal use by http_download.\n\n=cut\nsub check_in_http_cache\n{\nmy ($url) = @_;\nreturn undef if (!$gconfig{'cache_size'});\n\n# Check if the current module should do caching\nif ($gconfig{'cache_mods'} =~ /^\\!(.*)$/) {\n\t# Caching all except some modules\n\tmy @mods = split(/\\s+/, $1);\n\treturn 0 if (&indexof(&get_module_name(), @mods) != -1);\n\t}\nelsif ($gconfig{'cache_mods'}) {\n\t# Only caching some modules\n\tmy @mods = split(/\\s+/, $gconfig{'cache_mods'});\n\treturn 0 if (&indexof(&get_module_name(), @mods) == -1);\n\t}\n\nmy $cfile = $url;\n$cfile =~ s/\\//_/g;\n$cfile = \"$main::http_cache_directory/$cfile\";\nmy @st = stat($cfile);\nreturn undef if (!@st || !$st[7]);\nif ($gconfig{'cache_days'} && time()-$st[9] > $gconfig{'cache_days'}*24*60*60) {\n\t# Too old!\n\tunlink($cfile);\n\treturn undef;\n\t}\nopen(TOUCH, \">>$cfile\");\t# Update the file time, to keep it in the cache\nclose(TOUCH);\nreturn $cfile;\n}\n\n=head2 supports_javascript\n\nReturns 1 if the current browser is assumed to support javascript.\n\n=cut\nsub supports_javascript\n{\nif (defined(&theme_supports_javascript)) {\n\treturn &theme_supports_javascript();\n\t}\nreturn $ENV{'MOBILE_DEVICE'} ? 0 : 1;\n}\n\n=head2 get_module_name\n\nReturns the name of the Webmin module that called this function. For internal\nuse only by other API functions.\n\n=cut\nsub get_module_name\n{\nreturn &get_module_variable('$module_name');\n}\n\n=head2 get_module_variable(name, [ref])\n\nReturns the value of some variable which is set in the caller's context, if\nusing the new WebminCore package. For internal use only.\n\n=cut\nsub get_module_variable\n{\nmy ($v, $wantref) = @_;\nmy $slash = $wantref ? \"\\\\\" : \"\";\nmy $thispkg = &web_libs_package();\nif ($thispkg eq 'WebminCore') {\n\tmy ($vt, $vn) = split('', $v, 2);\n\tmy $callpkg;\n\tfor(my $i=0; ($callpkg) = caller($i); $i++) {\n\t\tlast if ($callpkg ne $thispkg);\n\t\t}\n\treturn eval \"${slash}${vt}${callpkg}::${vn}\";\n\t}\nreturn eval \"${slash}${v}\";\n}\n\n=head2 clear_time_locale()\n\nTemporarily force the locale to C, until reset_time_locale is called. This is\nuseful if your code is going to call C<strftime> from the POSIX package, and\nyou want to ensure that the output is in a consistent format.\n\n=cut\nsub clear_time_locale\n{\nif ($main::clear_time_locale_count == 0) {\n\teval {\n\t\t$main::clear_time_locale_old = POSIX::setlocale(POSIX::LC_TIME);\n\t\tPOSIX::setlocale(POSIX::LC_TIME, \"C\");\n\t\t};\n\t}\n$main::clear_time_locale_count++;\n}\n\n=head2 reset_time_locale()\n\nRevert the locale to whatever it was before clear_time_locale was called\n\n=cut\nsub reset_time_locale\n{\nif ($main::clear_time_locale_count == 1) {\n\teval {\n\t\tPOSIX::setlocale(POSIX::LC_TIME, $main::clear_time_locale_old);\n\t\t$main::clear_time_locale_old = undef;\n\t\t};\n\t}\n$main::clear_time_locale_count--;\n}\n\n=head2 callers_package(filehandle)\n\nConvert a non-module filehandle like FOO to one qualified with the\ncaller's caller's package, like fsdump::FOO. For internal use only.\n\n=cut\nsub callers_package\n{\nmy ($fh) = @_;\nmy $callpkg = (caller(1))[0];\nmy $thispkg = &web_libs_package();\nif (!ref($fh) && $fh !~ /::/ &&\n    $callpkg ne $thispkg && $thispkg eq 'WebminCore') {\n        $fh = $callpkg.\"::\".$fh;\n        }\nreturn $fh;\n}\n\n=head2 web_libs_package()\n\nReturns the package this code is in. We can't always trust __PACKAGE__. For\ninternal use only.\n\n=cut\nsub web_libs_package\n{\nif ($called_from_webmin_core) {\n\treturn \"WebminCore\";\n\t}\nreturn __PACKAGE__;\n}\n\n=head2 get_userdb_string\n\nReturns the URL-style string for connecting to the users and groups database\n\n=cut\nsub get_userdb_string\n{\nreturn undef if ($main::no_miniserv_userdb);\nmy %miniserv;\n&get_miniserv_config(\\%miniserv);\nreturn $miniserv{'userdb'};\n}\n\n=head2 connect_userdb(string)\n\nReturns a handle for talking to a user database - may be a DBI or LDAP handle.\nOn failure returns an error message string. In an array context, returns the\nprotocol type too.\n\n=cut\nsub connect_userdb\n{\nmy ($str) = @_;\nmy ($proto, $user, $pass, $host, $prefix, $args) = &split_userdb_string($str);\nif ($proto eq \"mysql\") {\n\t# Connect to MySQL with DBI\n\tmy $drh = eval \"use DBI; DBI->install_driver('mysql');\";\n\t$drh || return $text{'sql_emysqldriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $cstr = \"database=$prefix;host=$host\";\n\t$cstr .= \";port=$port\" if ($port);\n\tmy $dbh = $drh->connect($cstr, $user, $pass, { });\n\t$dbh || return &text('sql_emysqlconnect', $drh->errstr);\n\treturn wantarray ? ($dbh, $proto, $prefix, $args) : $dbh;\n\t}\nelsif ($proto eq \"postgresql\") {\n\t# Connect to PostgreSQL with DBI\n\tmy $drh = eval \"use DBI; DBI->install_driver('Pg');\";\n\t$drh || return $text{'sql_epostgresqldriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $cstr = \"dbname=$prefix;host=$host\";\n\t$cstr .= \";port=$port\" if ($port);\n\tmy $dbh = $drh->connect($cstr, $user, $pass);\n\t$dbh || return &text('sql_epostgresqlconnect', $drh->errstr);\n\treturn wantarray ? ($dbh, $proto, $prefix, $args) : $dbh;\n\t}\nelsif ($proto eq \"ldap\") {\n\t# Connect with perl LDAP module\n\teval \"use Net::LDAP\";\n\t$@ && return $text{'sql_eldapdriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $scheme = $args->{'scheme'} || 'ldap';\n\tif (!$port) {\n\t\t$port = $scheme eq 'ldaps' ? 636 : 389;\n\t\t}\n\tmy $ldap = Net::LDAP->new($host,\n\t\t\t\t  port => $port,\n\t\t\t\t  'scheme' => $scheme);\n\t$ldap || return &text('sql_eldapconnect', $host);\n\tmy $mesg;\n\tif ($args->{'tls'}) {\n\t\t# Switch to TLS mode\n\t\tif ($args->{'tls'} eq \"1_1\" or $args->{'tls'} eq \"1_2\") {\n\t\t\teval { $mesg = $ldap->start_tls(\n\t\t\t\t\tsslversion => \"TLSv\".$args->{'tls'}) };\n\t\t\t}\n\t\telse {\n\t\t\teval { $mesg = $ldap->start_tls(); };\n\t\t\t}\n\t\tif ($@ || !$mesg || $mesg->code) {\n\t\t\treturn &text('sql_eldaptls',\n\t\t\t    $@ ? $@ : $mesg ? $mesg->error : \"Unknown error\");\n\t\t\t}\n\t\t}\n\t# Login to the server\n\tif ($pass) {\n\t\t$mesg = $ldap->bind(dn => $user, password => $pass);\n\t\t}\n\telse {\n\t\t$mesg = $ldap->bind(dn => $user, anonymous => 1);\n\t\t}\n\tif (!$mesg || $mesg->code) {\n\t\treturn &text('sql_eldaplogin', $user,\n\t\t\t     $mesg ? $mesg->error : \"Unknown error\");\n\t\t}\n\treturn wantarray ? ($ldap, $proto, $prefix, $args) : $ldap;\n\t}\nelse {\n\treturn \"Unknown protocol $proto\";\n\t}\n}\n\n=head2 disconnect_userdb(string, &handle)\n\nCloses a handle opened by connect_userdb\n\n=cut\nsub disconnect_userdb\n{\nmy ($str, $h) = @_;\nif ($str =~ /^(mysql|postgresql):/) {\n\t# DBI disconnnect\n\tif (!$h->{'AutoCommit'}) {\n\t\t$h->commit();\n\t\t}\n\t$h->disconnect();\n\t}\nelsif ($str =~ /^ldap:/) {\n\t# LDAP disconnect\n\t$h->unbind();\n\t$h->disconnect();\n\t}\n}\n\n=head2 split_userdb_string(string)\n\nConverts a string like mysql://user:pass@host/db into separate parts\n\n=cut\nsub split_userdb_string\n{\nmy ($str) = @_;\nif ($str =~ /^([a-z]+):\\/\\/([^:]*):([^\\@]*)\\@([a-z0-9\\.\\-\\_]+)\\/([^\\?]+)(\\?(.*))?$/) {\n\tmy ($proto, $user, $pass, $host, $prefix, $argstr) =\n\t\t($1, $2, $3, $4, $5, $7);\n\tmy %args = map { split(/=/, $_, 2) } split(/\\&/, $argstr);\n\treturn ($proto, $user, $pass, $host, $prefix, \\%args);\n\t}\nreturn ( );\n}\n\n=head2 uniquelc(string, ...)\n\nReturns the unique elements of some array using a lowercase comparison,\npassed as its parameters.\n\n=cut\nsub uniquelc\n{\nmy (%found, @rv);\nforeach my $e (@_) {\n\tif (!$found{lc($e)}++) { push(@rv, $e); }\n\t}\nreturn @rv;\n}\n\n=head2 list_combined_webmin_menu(&data, &in)\n\nReturns an array of objects, each representing a menu item that a theme should\nrender such as on a left menu. Each object is a hash ref with the following\npossible keys :\n\n=item module - The Webmin module that supplied this object\n\n=item id - A unique ID for the object\n\n=item type - Can be \"item\" for a regular menu item, \"cat\" for a category which\n             will have sub-items (members), \"html\" for an arbitrary HTML block,\n\t     \"text\" for a line of text, \"hr\" for a separator, \"menu\" for a\n\t     selector, \"input\" for a text box, or \"title\" for a desired menu\n\t     title.\n\n=item desc - The text that should be displayed for the object\n\n=item icon - Desired icon path, like /module/images/foo.gif\n\n=item link - URL that the object should link to, for \"item\" types\n\n=item members - Array ref of further objects, for the \"cat\" type\n\n=item open - Set to 1 if the category should be open by default, for \"cat\" types\n\n=item html - HTML to display for this object, for \"html\" types\n\n=item menu - Array ref of array refs, each containing a the value and displayed\n\t     text for a entry in the selector when using \"menu\" types\n\n=item name - For an \"input\" item or \"menu\" item, the name of the selector or\n\t     HTML text box\n\n=item size - For an \"item\" item, desired width of the text box\n\n=item cgi - CGI script that the \"menu\" or \"input\" type item should submit to.\n\t    If missing, the form submits to the same menu page.\n\n=item target - Can be \"new\" for a new page, or \"window\" for the current whole\n\t       browser window\n\nThe &data parameter is a hash ref of additional information that the theme\nsupplies to all modules. The &in param is the CGI inputs from the menu, for\nuse where the menu has a form that submits to itself.\n\n=cut\nsub list_combined_webmin_menu\n{\nmy ($data, $in) = @_;\nforeach my $m (&get_available_module_infos()) {\n\tmy $dir = &module_root_directory($m->{'dir'});\n\tmy $mfile = \"$dir/webmin_menu.pl\";\n\tnext if (!-r $mfile);\n\teval {\n\t\tlocal $main::error_must_die = 1;\n\t\t&foreign_require($m->{'dir'}, \"webmin_menu.pl\");\n\t\tforeach my $i (&foreign_call($m->{'dir'}, \"list_webmin_menu\",\n\t\t\t\t\t     $data, $in)) {\n\t\t\t$i->{'module'} = $m->{'dir'};\n\t\t\tpush(@rv, $i);\n\t\t\t}\n\t\t};\n\t}\nreturn sort { ($b->{'priority'} || 0) <=> ($a->{'priority'} || 0) } @rv;\n}\n\n=head2 list_modules_webmin_menu()\n\nThis function returns a menu of Webmin modules available to the current user\nand with their desired categorization method, but in the same format as\nlist_combined_webmin_menu for easier use by theme authors.\n\n=cut\nsub list_modules_webmin_menu\n{\nmy @rv;\nmy @cats = get_visible_modules_categories();\nmy @catnames = map { $_->{'code'} } @cats;\nif ($gconfig{\"notabs_${base_remote_user}\"} == 2 ||\n    $gconfig{\"notabs_${base_remote_user}\"} == 0 && $gconfig{'notabs'}) {\n\t# Show modules in one list\n\t@rv = map { module_to_menu_item($_) }\n\t\t  (map { @{$_->{'modules'}} } @cats);\n\t}\nelse {\n\t# Show all modules under categories\n\tforeach my $c (@cats) {\n\t\tmy $citem = { 'type' => 'cat',\n\t\t\t      'id' => $c->{'code'},\n\t\t\t      'desc' => $c->{'desc'},\n\t\t\t      'members' => [ ] };\n\t\tforeach my $minfo (@{$c->{'modules'}}) {\n\t\t\tpush(@{$citem->{'members'}},\n\t\t\t     module_to_menu_item($minfo));\n\t\t\t}\n\t\tpush(@rv, $citem);\n\t\t}\n\t}\nreturn @rv;\n}\n\n=head2 module_to_menu_item(&module)\n\nInternal function for use by list_modules_webmin_menu\n\n=cut\nsub module_to_menu_item\n{\nmy ($minfo) = @_;\nreturn { 'type' => 'item',\n         'id' => $minfo->{'dir'},\n         'desc' => $minfo->{'desc'},\n         'link' => '/'.$minfo->{'dir'}.'/' };\n}\n\n=head2 list_combined_system_info(&data, &in)\n\nReturns an array of objects, each representing a block of system information\nto display. Each is a hash ref with the following keys :\n\n=item module - The Webmin module that supplied this object\n\n=item id - A unique ID for the object\n\n=item type - Can be \"html\" for an arbitrary block of HTML, \"table\" for a table\n\t     of information, \"usage\" for a table of usage of some resource,\n\t     \"redirect\" for a request to redirect the whole page to another URL,\n\t     \"warning\" for a warning dialog, \"link\" for a link to another\n\t     page, or \"veto\" to request removal of a block from another module.\n\n=item desc - The title for this section of info\n\n=item open - Set to 1 if it should be displayed by default\n\n=item table - In \"table\" mode, an array ref of fields to show. Each is a hash\n              ref with keys described below.\n\n=item html - In \"html\" mode, the raw HTML to display\n\n=item usage - In \"usage\" mode, an array ref of things to show some kind of\n\t      usage for. Each is a hash ref with keys described below.\n\n=item titles - In \"usage\" mode, an 3-element array ref of titles to show above\n\t       the usage columns.\n\n=item url - In \"redirect\" mode, the URL to redirect the system info page to\n\n=item warning - In \"warning\" mode, the HTML warning message\n\n=item level - In \"warning\" mode, can be one of \"success\", \"info\", \"warn\" or\n\t      \"danger\"\n\n=item link - In \"link\" mode, the destination URL\n\n=item veto - In \"veto\" mode, the ID of the block from some other module to skip\n\n=item target - In \"link\" mode, can be \"new\" for a new page, or \"window\" for the\n\t       current whole browser window\n\nFor \"table\" mode, the keys in each hash ref are :\n\n=item desc - Label for this item\n\n=item value - HTML to display next to the item\n\n=item chart - Array ref for a bar chart to show, in which the first element is\n\t      the total size, and each subsequent element is a value to show in\n\t      a different color. Any leftover is assumed is filled in with the\n\t      final color.\n\n=item wide - Set to 1 if this item should span a whole row\n\n=item header - Text to show above the table\n\nFor \"usage\" mode, the keys in each hash ref are :\n\n=item desc - Name of the thing for which usage is shown, like a domain\n\n=item chart - Bar chart (as above) with usage\n\n=item value - HTML for a description of the usage\n\n=item header - Text to show above the usage table\n\nThe &data parameter is a hash ref of additional information that the theme\nsupplies to all modules. The &in param is the CGI inputs from the page, for\nuse where a system info block has a form that submits to itself.\n\n=cut\nsub list_combined_system_info\n{\nmy ($data, $in) = @_;\nforeach my $m (&get_all_module_infos()) {\n\tmy $dir = &module_root_directory($m->{'dir'});\n\tmy $mfile = \"$dir/system_info.pl\";\n\tnext if (!-r $mfile);\n\t&foreign_require($m->{'dir'}, \"system_info.pl\");\n\tforeach my $i (&foreign_call($m->{'dir'}, \"list_system_info\",\n\t\t\t\t     $data, $in)) {\n\t\t$i->{'module'} = $m->{'dir'};\n\t\tpush(@rv, $i);\n\t\t}\n\t}\nif (&foreign_available(\"webmin\")) {\n\t# Merge in old-style notification API\n\t&foreign_require(\"webmin\");\n\tforeach my $n (&webmin::get_webmin_notifications()) {\n\t\tpush(@rv, { 'type' => 'warning',\n\t\t\t    'id' => 'notifications',\n\t\t\t    'level' => 'warn',\n\t\t\t    'module' => 'webmin',\n\t\t\t    'warning' => $n });\n\t\t}\n\t}\n# Obey vetos for blocks from other modules\nmy @vetos = grep { $_->{'type'} eq 'veto' } @rv;\nforeach my $veto (@vetos) {\n\tmy @vrv;\n\tforeach my $m (@rv) {\n\t\tmy $v = $m->{'id'} eq $veto->{'veto'} &&\n\t\t        (!$veto->{'veto_module'} ||\n\t\t         $veto->{'veto_module'} eq $m->{'module'});\n\t\tpush(@vrv, $m) if (!$v);\n\t\t}\n\t@rv = @vrv;\n\t}\n@rv = grep { $_->{'type'} ne 'veto' } @rv;\nreturn sort { ($b->{'priority'} || 0) <=> ($a->{'priority'} || 0) } @rv;\n}\n\n=head2 shell_is_bash\n\nReturns 1 if /bin/sh is bash, 0 if not\n\n=cut\nsub shell_is_bash\n{\nmy $bash = &has_command(\"bash\");\nif ($bash && &same_file(\"/bin/sh\", $bash)) {\n\t# Symlink to /bin/bash\n\treturn 1;\n\t}\nmy $out = &backquote_command(\"/bin/sh --help 2>&1 </dev/null\");\nif ($out =~ /GNU\\s+bash/) {\n\treturn 1;\n\t}\nreturn 0;\n}\n\n=head2 compare_version_numbers(ver1, ver2)\n\nCompares to version \"number\" strings, and returns -1 if ver1 is older than ver2,\n0 if they are equal, or 1 if ver1 is newer than ver2.\n\n=cut\nsub compare_version_numbers\n{\nmy ($ver1, $ver2) = @_;\nmy @sp1 = split(/[\\.\\-\\+\\~]/, $ver1);\nmy @sp2 = split(/[\\.\\-\\+\\~]/, $ver2);\nmy $tmp;\nfor(my $i=0; $i<@sp1 || $i<@sp2; $i++) {\n\tmy $v1 = $sp1[$i];\n\tmy $v2 = $sp2[$i];\n\tmy $comp;\n\tif ($v1 =~ /^\\d+$/ && $v2 =~ /^\\d+$/) {\n\t\t# Numeric only\n\t\t# ie. 5 vs 7\n\t\t$comp = $v1 <=> $v2;\n\t\t}\n\telsif ($v1 =~ /^(\\d+[^0-9]+)(\\d+)$/ && ($tmp = $1) &&\n\t       $v2 =~ /^(\\d+[^0-9]+)(\\d+)$/ &&\n\t       $tmp eq $1) {\n\t\t# Numeric followed by a string followed by a number, where\n\t\t# the first two components are the same\n\t\t# ie. 4ubuntu8 vs 4ubuntu10\n\t\t$v1 =~ /^(\\d+[^0-9]+)(\\d+)$/;\n\t\tmy $num1 = $2;\n\t\t$v2 =~ /^(\\d+[^0-9]+)(\\d+)$/;\n\t\tmy $num2 = $2;\n\t\t$comp = $num1 <=> $num2;\n\t\t}\n\telsif ($v1 =~ /^\\d+\\S*$/ && $v2 =~ /^\\d+\\S*$/) {\n\t\t# Numeric followed by string\n\t\t# ie. 6redhat vs 8redhat\n\t\t$v1 =~ /^(\\d+)(\\S*)$/;\n\t\tmy ($v1n, $v1s) = ($1, $2);\n\t\t$v2 =~ /^(\\d+)(\\S*)$/;\n\t\tmy ($v2n, $v2s) = ($1, $2);\n\t\t$comp = $v1n <=> $v2n;\n\t\tif (!$comp) {\n\t\t\t# X.rcN is always older than X\n\t\t\tif ($v1s =~ /^rc\\d+$/i && $v2s =~ /^\\d*$/) {\n\t\t\t\t$comp = -1;\n\t\t\t\t}\n\t\t\telsif ($v1s =~ /^\\d*$/ && $v2s =~ /^rc\\d+$/i) {\n\t\t\t\t$comp = 1;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t$comp = $v1s cmp $v2s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($v1 =~ /^(\\S+[^0-9]+)(\\d+)$/ && ($tmp = $1) &&\n\t       $v2 =~ /^(\\S+[^0-9]+)(\\d+)$/ &&\n\t       $tmp eq $1) {\n\t\t# String followed by a number, where the strings are the same\n\t\t# ie. centos7 vs centos8\n\t\t$v1 =~ /^(\\S+[^0-9]+)(\\d+)$/;\n\t\tmy $num1 = $2;\n\t\t$v2 =~ /^(\\S+[^0-9]+)(\\d+)$/;\n\t\tmy $num2 = $2;\n\t\t$comp = $num1 <=> $num2;\n\t\t}\n\telsif ($v1 =~ /^\\d+$/ && $v2 !~ /^\\d+$/) {\n\t\t# Numeric compared to non-numeric - numeric is always higher\n\t\t$comp = 1;\n\t\t}\n\telsif ($v1 !~ /^\\d+$/ && $v2 =~ /^\\d+$/) {\n\t\t# Non-numeric compared to numeric - numeric is always higher\n\t\t$comp = -1;\n\t\t}\n\telse {\n\t\t# String compare only\n\t\t$comp = $v1 cmp $v2;\n\t\t}\n\treturn $comp if ($comp);\n\t}\nreturn 0;\n}\n\n=head2 convert_to_json(data)\n\nConverts the given Perl data structure to encoded binary string\n\n=item data parameter is a hash/array reference\n\n=cut\nsub convert_to_json\n{\neval \"use JSON::PP\";\nif (!$@) {\n\tif (@_) {\n\t\treturn JSON::PP->new->latin1->encode(@_);\n\t\t}\n\telse {\n\t\treturn JSON::PP->new->latin1->encode({});\n\t\t}\n\t}\nelse {\n\terror(\"The JSON::PP Perl module is not available on your system : $@\");\n\t}\n}\n\n=head2 convert_from_json(data)\n\nParses given JSON string\n\n=item data parameter is encoded JSON string\n\n=cut\nsub convert_from_json\n{\neval \"use JSON::PP\";\nif (!$@) {\n\tmy ($json_text) = @_;\n\treturn JSON::PP->new->utf8->decode($json_text);\n\t}\nelse {\n\terror(\"The JSON::PP Perl module is not available on your system : $@\");\n\t}\n}\n\n=head2 print_json(data)\n\nPrints JSON data\n\n=item data parameter is a hash/array reference\n\n=cut\nsub print_json\n{\nprint \"Content-type: application/json;\\n\\n\";\nprint convert_to_json(@_);\n}\n\n$done_web_lib_funcs = 1;\n\n1;\n"], "fixing_code": ["=head1 web-lib-funcs.pl\n\nCommon functions for Webmin CGI scripts. This file gets in-directly included\nby all scripts that use web-lib.pl.\nExample code:\n\n  use WebminCore;\n  init_config();\n  ui_print_header(undef, 'My Module', '');\n  print 'This is Webmin version ',get_webmin_version(),'<p>\\n';\n  ui_print_footer();\n\n=cut\n\n##use warnings;\nuse Socket;\nuse POSIX;\neval \"use Socket6\";\n$ipv6_module_error = $@;\nour $error_handler_funcs = [ ];\n\nuse vars qw($user_risk_level $loaded_theme_library $wait_for_input\n\t    $done_webmin_header $trust_unknown_referers $unsafe_index_cgi\n\t    %done_foreign_require $webmin_feedback_address\n\t    $user_skill_level $pragma_no_cache $foreign_args);\n# Globals\nuse vars qw($module_index_name $number_to_month_map $month_to_number_map\n\t    $umask_already $default_charset $licence_status $os_type\n\t    $licence_message $script_name $loaded_theme_oo_library\n\t    $done_web_lib_funcs $os_version $module_index_link\n\t    $called_from_webmin_core $ipv6_module_error);\n\n=head2 read_file(file, &hash, [&order], [lowercase], [split-char])\n\nFill the given hash reference with name=value pairs from a file. The required\nparameters are :\n\n=item file - The file to head, which must be text with each line like name=value\n\n=item hash - The hash reference to add values read from the file to.\n\n=item order - If given, an array reference to add names to in the order they were read\n\n=item lowercase - If set to 1, names are converted to lower case\n\n=item split-char - If set, names and values are split on this character instead of =\n\n=cut\nsub read_file\n{\nlocal $_;\nmy $split = defined($_[4]) ? $_[4] : \"=\";\nmy $realfile = &translate_filename($_[0]);\n&open_readfile(ARFILE, $_[0]) || return 0;\nwhile(<ARFILE>) {\n\tchomp;\n\tmy $hash = index($_, \"#\");\n\tmy $eq = index($_, $split);\n\tif ($hash != 0 && $eq >= 0) {\n\t\tmy $n = substr($_, 0, $eq);\n\t\tmy $v = substr($_, $eq+1);\n\t\tchomp($v);\n\t\t$_[1]->{$_[3] ? lc($n) : $n} = $v;\n\t\tpush(@{$_[2]}, $n) if ($_[2]);\n        \t}\n        }\nclose(ARFILE);\n$main::read_file_missing{$realfile} = 0;\t# It exists now\nif (defined($main::read_file_cache{$realfile})) {\n\t%{$main::read_file_cache{$realfile}} = %{$_[1]};\n\t}\nreturn 1;\n}\n\n=head2 read_file_cached(file, &hash, [&order], [lowercase], [split-char])\n\nLike read_file, but reads from an in-memory cache if the file has already been\nread in this Webmin script. Recommended, as it behaves exactly the same as\nread_file, but can be much faster.\n\n=cut\nsub read_file_cached\n{\nmy $realfile = &translate_filename($_[0]);\nif (defined($main::read_file_cache{$realfile})) {\n\t# Use cached data\n\t%{$_[1]} = ( %{$_[1]}, %{$main::read_file_cache{$realfile}} );\n\treturn 1;\n\t}\nelsif ($main::read_file_missing{$realfile}) {\n\t# Doesn't exist, so don't re-try read\n\treturn 0;\n\t}\nelse {\n\t# Actually read the file\n\tmy %d;\n\tif (&read_file($_[0], \\%d, $_[2], $_[3], $_[4])) {\n\t\t%{$main::read_file_cache{$realfile}} = %d;\n\t\t%{$_[1]} = ( %{$_[1]}, %d );\n\t\treturn 1;\n\t\t}\n\telse {\n\t\t# Flag as non-existant\n\t\t$main::read_file_missing{$realfile} = 1;\n\t\treturn 0;\n\t\t}\n\t}\n}\n\n=head2 read_file_cached_with_stat(file, &hash, [&order], [lowercase], [split-char])\n\nLike read_file, but reads from an in-memory cache if the file has already been\nread in this Webmin script AND has not changed.\n\n=cut\nsub read_file_cached_with_stat\n{\nmy $realfile = &translate_filename($_[0]);\nmy $t = $main::read_file_cache_time{$realfile};\nmy @st = stat($realfile);\nif ($t && $st[9] != $t) {\n\t# Changed, invalidate cache\n\tdelete($main::read_file_cache{$realfile});\n\t}\nmy $rv = &read_file_cached(@_);\n$main::read_file_cache_time{$realfile} = $st[9];\nreturn $rv;\n}\n\n=head2 write_file(file, &hash, [join-char])\n\nWrite out the contents of a hash as name=value lines. The parameters are :\n\n=item file - Full path to write to\n\n=item hash - A hash reference containing names and values to output\n\n=item join-char - If given, names and values are separated by this instead of =\n\n=cut\nsub write_file\n{\nmy (%old, @order);\nmy $join = defined($_[2]) ? $_[2] : \"=\";\nmy $realfile = &translate_filename($_[0]);\n&read_file($_[0], \\%old, \\@order);\n&open_tempfile(ARFILE, \">$_[0]\");\nforeach $k (@order) {\n\tif (exists($_[1]->{$k})) {\n\t\t(print ARFILE $k,$join,$_[1]->{$k},\"\\n\") ||\n\t\t\t&error(&text(\"efilewrite\", $realfile, $!));\n\t\t}\n\t}\nforeach $k (keys %{$_[1]}) {\n\tif (!exists($old{$k})) {\n\t\t(print ARFILE $k,$join,$_[1]->{$k},\"\\n\") ||\n\t\t\t&error(&text(\"efilewrite\", $realfile, $!));\n\t\t}\n        }\n&close_tempfile(ARFILE);\nif (defined($main::read_file_cache{$realfile})) {\n\t%{$main::read_file_cache{$realfile}} = %{$_[1]};\n\t}\nif (defined($main::read_file_missing{$realfile})) {\n\t$main::read_file_missing{$realfile} = 0;\n\t}\n}\n\n=head2 html_escape(string)\n\nConverts &, < and > codes in text to HTML entities, and returns the new string.\nThis should be used when including data read from other sources in HTML pages.\n\n=cut\nsub html_escape\n{\nmy ($tmp) = @_;\nif (!defined $tmp) {\n    return ''; # empty string\n};\n$tmp =~ s/&/&amp;/g;\n$tmp =~ s/</&lt;/g;\n$tmp =~ s/>/&gt;/g;\n$tmp =~ s/\\\"/&quot;/g;\n$tmp =~ s/\\'/&#39;/g;\n$tmp =~ s/=/&#61;/g;\nreturn $tmp;\n}\n\n=head2 quote_escape(string, [only-quote])\n\nConverts ' and \" characters in a string into HTML entities, and returns it.\nUseful for outputing HTML tag values.\n\n=cut\nsub quote_escape\n{\nmy ($tmp, $only) = @_;\nif (!defined $tmp) {\n    return ''; # empty string\n};\nif ($tmp !~ /\\&[a-zA-Z]+;/ && $tmp !~ /\\&#/) {\n\t# convert &, unless it is part of &#nnn; or &foo;\n\t$tmp =~ s/&([^#])/&amp;$1/g;\n\t}\n$tmp =~ s/&$/&amp;/g;\n$tmp =~ s/\\\"/&quot;/g if (!$only || $only eq '\"');\n$tmp =~ s/\\'/&#39;/g if (!$only || $only eq \"'\");\nreturn $tmp;\n}\n\n=head2 quote_javascript(string)\n\nQuote all characters that are unsafe for inclusion in javascript strings in HTML\n\n=cut\nsub quote_javascript\n{\nmy ($str) = @_;\n$str =~ s/[\"'<>&\\\\]/sprintf('\\x%02x', ord $&)/ge;\nreturn $str;\n}\n\n=head2 tempname_dir()\n\nReturns the base directory under which temp files can be created.\n\n=cut\nsub tempname_dir\n{\nmy $tmp_base = $gconfig{'tempdir_'.&get_module_name()} ?\n\t\t\t$gconfig{'tempdir_'.&get_module_name()} :\n\t\t  $gconfig{'tempdir'} ? $gconfig{'tempdir'} :\n\t\t  $ENV{'TEMP'} && $ENV{'TEMP'} ne \"/tmp\" ? $ENV{'TEMP'} :\n\t\t  $ENV{'TMP'} && $ENV{'TMP'} ne \"/tmp\" ? $ENV{'TMP'} :\n\t\t  -d \"c:/temp\" ? \"c:/temp\" : \"/tmp/.webmin\";\nmy $tmp_dir;\nif (-d $remote_user_info[7] && !$gconfig{'nohometemp'}) {\n\t$tmp_dir = \"$remote_user_info[7]/.tmp\";\n\t}\nelsif (@remote_user_info) {\n\t$tmp_dir = $tmp_base.\"-\".$remote_user_info[2].\"-\".$remote_user;\n\t}\nelsif ($< != 0) {\n\tmy $u = getpwuid($<);\n\tif ($u) {\n\t\t$tmp_dir = $tmp_base.\"-\".$<.\"-\".$u;\n\t\t}\n\telse {\n\t\t$tmp_dir = $tmp_base.\"-\".$<;\n\t\t}\n\t}\nelse {\n\t$tmp_dir = $tmp_base;\n\t}\nreturn $tmp_dir;\n}\n\n=head2 tempname([filename])\n\nReturns a mostly random temporary file name, typically under the /tmp/.webmin\ndirectory. If filename is given, this will be the base name used. Otherwise\na unique name is selected randomly.\n\n=cut\nsub tempname\n{\nmy ($filename) = @_;\nmy $tmp_dir = &tempname_dir();\nif ($gconfig{'os_type'} eq 'windows' || $tmp_dir =~ /^[a-z]:/i) {\n\t# On Windows system, just create temp dir if missing\n\tif (!-d $tmp_dir) {\n\t\tmkdir($tmp_dir, 0755) ||\n\t\t\t&error(\"Failed to create temp directory $tmp_dir : $!\");\n\t\t}\n\t}\nelse {\n\t# On Unix systems, need to make sure temp dir is valid\n\tmy $tries = 0;\n\twhile($tries++ < 10) {\n\t\tmy @st = lstat($tmp_dir);\n\t\tlast if ($st[4] == $< && (-d _) && ($st[2] & 0777) == 0755);\n\t\tif (@st) {\n\t\t\tunlink($tmp_dir) || rmdir($tmp_dir) ||\n\t\t\t\tsystem(\"/bin/rm -rf \".quotemeta($tmp_dir));\n\t\t\t}\n\t\tmkdir($tmp_dir, 0755) || next;\n\t\tchown($<, $(, $tmp_dir);\n\t\tchmod(0755, $tmp_dir);\n\t\t}\n\tif ($tries >= 10) {\n\t\tmy @st = lstat($tmp_dir);\n\t\t&error(\"Failed to create temp directory $tmp_dir\");\n\t\t}\n\t# If running as root, check parent dir (usually /tmp) to make sure it's\n\t# world-writable and owned by root\n\tmy $tmp_parent = $tmp_dir;\n\t$tmp_parent =~ s/\\/[^\\/]+$//;\n\tif ($tmp_parent eq \"/tmp\") {\n\t\tmy @st = stat($tmp_parent);\n\t\tif (($st[2] & 0555) != 0555) {\n\t\t\t&error(\"Base temp directory $tmp_parent is not world readable and listable\");\n\t\t\t}\n\t\t}\n\t}\nmy $rv;\nif (defined($filename) && $filename !~ /\\.\\./) {\n\t$rv = \"$tmp_dir/$filename\";\n\t}\nelse {\n\t$main::tempfilecount++;\n\t&seed_random();\n\t$rv = $tmp_dir.\"/\".int(rand(1000000)).\"_\".$$.\"_\".\n\t       $main::tempfilecount.\"_\".$scriptname;\n\t}\nreturn $rv;\n}\n\n=head2 transname([filename])\n\nBehaves exactly like tempname, but records the temp file for deletion when the\ncurrent Webmin script process exits.\n\n=cut\nsub transname\n{\nmy $rv = &tempname(@_);\npush(@main::temporary_files, $rv);\nreturn $rv;\n}\n\n=head2 trunc(string, maxlen)\n\nTruncates a string to the shortest whole word less than or equal to the\ngiven width. Useful for word wrapping.\n\n=cut\nsub trunc\n{\nif (length($_[0]) <= $_[1]) {\n\treturn $_[0];\n\t}\nmy $str = substr($_[0],0,$_[1]);\nmy $c;\ndo {\n\t$c = chop($str);\n\t} while($c !~ /\\S/);\n$str =~ s/\\s+$//;\nreturn $str;\n}\n\n=head2 indexof(string, value, ...)\n\nReturns the index of some value in an array of values, or -1 if it was not\nfound.\n\n=cut\nsub indexof\n{\nfor(my $i=1; $i <= $#_; $i++) {\n\tif ($_[$i] eq $_[0]) { return $i - 1; }\n\t}\nreturn -1;\n}\n\n=head2 indexoflc(string, value, ...)\n\nLike indexof, but does a case-insensitive match\n\n=cut\nsub indexoflc\n{\nmy $str = lc(shift(@_));\nmy @arr = map { lc($_) } @_;\nreturn &indexof($str, @arr);\n}\n\n=head2 sysprint(handle, [string]+)\n\nOutputs some strings to a file handle, but bypassing IO buffering. Can be used\nas a replacement for print when writing to pipes or sockets.\n\n=cut\nsub sysprint\n{\nmy $fh = &callers_package($_[0]);\nmy $str = join('', @_[1..$#_]);\nsyswrite $fh, $str, length($str);\n}\n\n=head2 check_ipaddress(ip)\n\nCheck if some IPv4 address is properly formatted, returning 1 if so or 0 if not.\n\n=cut\nsub check_ipaddress\n{\nreturn $_[0] =~ /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/ &&\n\t$1 >= 0 && $1 <= 255 &&\n\t$2 >= 0 && $2 <= 255 &&\n\t$3 >= 0 && $3 <= 255 &&\n\t$4 >= 0 && $4 <= 255;\n}\n\n=head2 check_ip6address(ip)\n\nCheck if some IPv6 address is properly formatted, and returns 1 if so.\n\n=cut\nsub check_ip6address\n{\n  my @blocks = split(/:/, $_[0]);\n  return 0 if (@blocks == 0 || @blocks > 8);\n\n  # The address/netmask format is accepted. So we're looking for a \"/\" to isolate a possible netmask.\n  # After that, we delete the netmask to control the address only format, but we verify whether the netmask\n  # value is in [0;128].\n  my $ib = $#blocks;\n  my $where = index($blocks[$ib],\"/\");\n  my $m = 0;\n  if ($where != -1) {\n    my $b = substr($blocks[$ib],0,$where);\n    $m = substr($blocks[$ib],$where+1,length($blocks[$ib])-($where+1));\n    $blocks[$ib]=$b;\n  }\n\n  # The netmask must take its value in [0;128]\n  return 0 if ($m <0 || $m >128);\n\n  # Check the different blocks of the address : 16 bits block in hexa notation.\n  # Possibility of 1 empty block or 2 if the address begins with \"::\".\n  my $b;\n  my $empty = 0;\n  foreach $b (@blocks) {\n\t  return 0 if ($b ne \"\" && $b !~ /^[0-9a-f]{1,4}$/i);\n\t  $empty++ if ($b eq \"\");\n\t  }\n  return 0 if ($empty > 1 && !($_[0] =~ /^::/ && $empty == 2));\n  return 1;\n}\n\n\n\n=head2 generate_icon(image, title, link, [href], [width], [height], [before-title], [after-title])\n\nPrints HTML for an icon image. The parameters are :\n\n=item image - URL for the image, like images/foo.gif\n\n=item title - Text to appear under the icon\n\n=item link - Optional destination for the icon's link\n\n=item href - Other HTML attributes to be added to the <a href> for the link\n\n=item width - Optional width of the icon\n\n=item height - Optional height of the icon\n\n=item before-title - HTML to appear before the title link, but which is not actually in the link\n\n=item after-title - HTML to appear after the title link, but which is not actually in the link\n\n=cut\nsub generate_icon\n{\n&load_theme_library();\nif (defined(&theme_generate_icon)) {\n\t&theme_generate_icon(@_);\n\treturn;\n\t}\nmy $w = !defined($_[4]) ? \"width='48'\" : $_[4] ? \"width='$_[4]'\" : \"\";\nmy $h = !defined($_[5]) ? \"height='48'\" : $_[5] ? \"height='$_[5]'\" : \"\";\nif ($tconfig{'noicons'}) {\n\tif ($_[2]) {\n\t\tprint \"$_[6]<a href=\\\"$_[2]\\\" $_[3]>$_[1]</a>$_[7]\\n\";\n\t\t}\n\telse {\n\t\tprint \"$_[6]$_[1]$_[7]\\n\";\n\t\t}\n\t}\nelsif ($_[2]) {\n\tprint \"<table border><tr><td width='48' height='48'>\\n\",\n\t      \"<a href=\\\"$_[2]\\\" $_[3]><img src=\\\"$_[0]\\\" alt=\\\"\\\" border='0' \",\n\t      \"$w $h></a></td></tr></table>\\n\";\n\tprint \"$_[6]<a href=\\\"$_[2]\\\" $_[3]>$_[1]</a>$_[7]\\n\";\n\t}\nelse {\n\tprint \"<table border><tr><td width='48' height='48'>\\n\",\n\t      \"<img src=\\\"$_[0]\\\" alt=\\\"\\\" border='0' $w $h>\",\n\t      \"</td></tr></table>\\n$_[6]$_[1]$_[7]\\n\";\n\t}\n}\n\n=head2 urlize\n\nConverts a string to a form ok for putting in a URL, using % escaping.\n\n=cut\nsub urlize\n{\nmy ($rv) = @_;\n$rv =~ s/([^A-Za-z0-9])/sprintf(\"%%%2.2X\", ord($1))/ge;\nreturn $rv;\n}\n\n=head2 un_urlize(string)\n\nConverts a URL-encoded string to it's original contents - the reverse of the\nurlize function.\n\n=cut\nsub un_urlize\n{\nmy ($rv) = @_;\n$rv =~ s/\\+/ /g;\n$rv =~ s/%(..)/pack(\"c\",hex($1))/ge;\nreturn $rv;\n}\n\n=head2 include(filename)\n\nRead and output the contents of the given file.\n\n=cut\nsub include\n{\nlocal $_;\nopen(INCLUDE, &translate_filename($_[0])) || return 0;\nwhile(<INCLUDE>) {\n\tprint;\n\t}\nclose(INCLUDE);\nreturn 1;\n}\n\n=head2 copydata(in-handle, out-handle)\n\nRead from one file handle and write to another, until there is no more to read.\n\n=cut\nsub copydata\n{\nmy ($in, $out) = @_;\n$in = &callers_package($in);\n$out = &callers_package($out);\nmy $buf;\nwhile(read($in, $buf, 32768) > 0) {\n\t(print $out $buf) || return 0;\n\t}\nreturn 1;\n}\n\n=head2 ReadParseMime([maximum], [&cbfunc, &cbargs], [array-mode])\n\nRead data submitted via a POST request using the multipart/form-data coding,\nand store it in the global %in hash. The optional parameters are :\n\n=item maximum - If the number of bytes of input exceeds this number, stop reading and call error.\n\n=item cbfunc - A function reference to call after reading each block of data.\n\n=item cbargs - Additional parameters to the callback function.\n\n=item array-mode - If set to 1, values in %in are arrays. If set to 0, multiple values are joined with \\0. If set to 2, only the first value is used.\n\n=cut\nsub ReadParseMime\n{\nmy ($max, $cbfunc, $cbargs, $arrays) = @_;\nmy ($boundary, $line, $name, $got, $file, $count_lines, $max_lines);\nmy $err = &text('readparse_max', $max);\n$ENV{'CONTENT_TYPE'} =~ /boundary=(.*)$/ || &error($text{'readparse_enc'});\nif ($ENV{'CONTENT_LENGTH'} && $max && $ENV{'CONTENT_LENGTH'} > $max) {\n\t&error($err);\n\t}\n&$cbfunc(0, $ENV{'CONTENT_LENGTH'}, $file, @$cbargs) if ($cbfunc);\n$boundary = $1;\n$count_lines = 0;\n$max_lines = 1000;\n<STDIN>;\t# skip first boundary\nwhile(1) {\n\t$name = \"\";\n\t# Read section headers\n\tmy $lastheader;\n\twhile(1) {\n\t\t$line = <STDIN>;\n\t\t$got += length($line);\n\t\t&$cbfunc($got, $ENV{'CONTENT_LENGTH'}, @$cbargs) if ($cbfunc);\n\t\tif ($max && $got > $max) {\n\t\t\t&error($err)\n\t\t\t}\n\t\t$line =~ tr/\\r\\n//d;\n\t\tlast if (!$line);\n\t\tif ($line =~ /^(\\S+):\\s*(.*)$/) {\n\t\t\t$header{$lastheader = lc($1)} = $2;\n\t\t\t}\n\t\telsif ($line =~ /^\\s+(.*)$/) {\n\t\t\t$header{$lastheader} .= $line;\n\t\t\t}\n\t\t}\n\n\t# Parse out filename and type\n\tmy $file;\n\tif ($header{'content-disposition'} =~ /^form-data(.*)/) {\n\t\t$rest = $1;\n\t\twhile ($rest =~ /([a-zA-Z]*)=\\\"([^\\\"]*)\\\"(.*)/) {\n\t\t\tif ($1 eq 'name') {\n\t\t\t\t$name = $2;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tmy $foo = $name.\"_\".$1;\n\t\t\t\tif ($1 eq \"filename\") {\n\t\t\t\t\t$file = $2;\n\t\t\t\t\t}\n\t\t\t\tif ($arrays == 1) {\n\t\t\t\t\t$in{$foo} ||= [];\n\t\t\t\t\tpush(@{$in{$foo}}, $2);\n\t\t\t\t\t}\n\t\t\t\telsif ($arrays == 2) {\n\t\t\t\t\t$in{$foo} ||= $2;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$in{$foo} .= \"\\0\"\n\t\t\t\t\t\tif (defined($in{$foo}));\n\t\t\t\t\t$in{$foo} .= $2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t$rest = $3;\n\t\t\t}\n\t\t}\n\telse {\n\t\t&error($text{'readparse_cdheader'});\n\t\t}\n\n\t# Save content type separately\n\tif ($header{'content-type'} =~ /^([^\\s;]+)/) {\n\t\tmy $foo = $name.\"_content_type\";\n\t\tif ($arrays == 1) {\n\t\t\t$in{$foo} ||= [];\n\t\t\tpush(@{$in{$foo}}, $1);\n\t\t\t}\n\t\telsif ($arrays == 2) {\n\t\t\t$in{$foo} ||= $1;\n\t\t\t}\n\t\telse {\n\t\t\t$in{$foo} .= \"\\0\" if (defined($in{$foo}));\n\t\t\t$in{$foo} .= $1;\n\t\t\t}\n\t\t}\n\n\t# Read data\n\tmy $data = \"\";\n\twhile(1) {\n\t\t$line = <STDIN>;\n\t\t$got += length($line);\n\t\t$count_lines++;\n\t\tif ($count_lines == $max_lines) {\n\t\t\t&$cbfunc($got, $ENV{'CONTENT_LENGTH'}, $file, @$cbargs)\n\t\t\t\tif ($cbfunc);\n\t\t\t$count_lines = 0;\n\t\t\t}\n\t\tif ($max && $got > $max) {\n\t\t\t#print STDERR \"over limit of $max\\n\";\n\t\t\t#&error($err);\n\t\t\t}\n\t\tif (!$line) {\n\t\t\t# Unexpected EOF?\n\t\t\t&$cbfunc(-1, $ENV{'CONTENT_LENGTH'}, $file, @$cbargs)\n\t\t\t\tif ($cbfunc);\n\t\t\treturn;\n\t\t\t}\n\t\tif (index($line, $boundary) != -1) { last; }\n\t\t$data .= $line;\n\t\t}\n\tchop($data); chop($data);\n\tif ($arrays == 1) {\n\t\t$in{$name} ||= [];\n\t\tpush(@{$in{$name}}, $data);\n\t\t}\n\telsif ($arrays == 2) {\n\t\t$in{$name} ||= $data;\n\t\t}\n\telse {\n\t\t$in{$name} .= \"\\0\" if (defined($in{$name}));\n\t\t$in{$name} .= $data;\n\t\t}\n\tif (index($line,\"$boundary--\") != -1) { last; }\n\t}\n&$cbfunc(-1, $ENV{'CONTENT_LENGTH'}, $file, @$cbargs) if ($cbfunc);\n}\n\n=head2 ReadParse([&hash], [method], [noplus], [array-mode])\n\nFills the given hash reference with CGI parameters, or uses the global hash\n%in if none is given. Also sets the global variables $in and @in. The other\nparameters are :\n\n=item method - For use of this HTTP method, such as GET\n\n=item noplus - Don't convert + in parameters to spaces.\n\n=item array-mode - If set to 1, values in %in are arrays. If set to 0, multiple values are joined with \\0. If set to 2, only the first value is used.\n\n=cut\nsub ReadParse\n{\nmy $a = $_[0] || \\%in;\n%$a = ( );\nmy $meth = $_[1] ? $_[1] : $ENV{'REQUEST_METHOD'};\nundef($in);\nif ($meth eq 'POST') {\n\tmy $clen = $ENV{'CONTENT_LENGTH'};\n\t&read_fully(STDIN, \\$in, $clen) == $clen ||\n\t\t&error(\"Failed to read POST input : $!\");\n\t}\nif ($ENV{'QUERY_STRING'}) {\n\tif ($in) { $in .= \"&\".$ENV{'QUERY_STRING'}; }\n\telse { $in = $ENV{'QUERY_STRING'}; }\n\t}\n@in = split(/\\&/, $in);\nforeach my $i (@in) {\n\t$i =~ /\\0/ && &error(\"Null byte in query string\");\n\tmy ($k, $v) = split(/=/, $i, 2);\n\tif (!$_[2]) {\n\t\t$k =~ tr/\\+/ /;\n\t\t$v =~ tr/\\+/ /;\n\t\t}\n\t$k =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\t$v =~ s/%(..)/pack(\"c\",hex($1))/ge;\n\tif ($_[3] == 1) {\n\t\t$a->{$k} ||= [];\n\t\tpush(@{$a->{$k}}, $v);\n\t\t}\n\telsif ($_[3] == 2) {\n\t\t$a->{$k} ||= $v;\n\t\t}\n\telse {\n\t\t$a->{$k} = defined($a->{$k}) ? $a->{$k}.\"\\0\".$v : $v;\n\t\t}\n\t}\n}\n\n=head2 read_fully(fh, &buffer, length)\n\nRead data from some file handle up to the given length, even in the face\nof partial reads. Reads the number of bytes read. Stores received data in the\nstring pointed to be the buffer reference.\n\n=cut\nsub read_fully\n{\nmy ($fh, $buf, $len) = @_;\n$fh = &callers_package($fh);\nmy $got = 0;\nwhile($got < $len) {\n\tmy $r = read(STDIN, $$buf, $len-$got, $got);\n\tlast if ($r <= 0);\n\t$got += $r;\n\t}\nreturn $got;\n}\n\n=head2 read_parse_mime_callback(size, totalsize, upload-id)\n\nCalled by ReadParseMime as new data arrives from a form-data POST. Only updates\nthe file on every 1% change though. For internal use by the upload progress\ntracker.\n\n=cut\nsub read_parse_mime_callback\n{\nmy ($size, $totalsize, $filename, $id) = @_;\nreturn if ($gconfig{'no_upload_tracker'});\nreturn if (!$id);\n\n# Create the upload tracking directory - if running as non-root, this has to\n# be under the user's home\nmy $vardir;\nif ($<) {\n\tmy @uinfo = @remote_user_info ? @remote_user_info : getpwuid($<);\n\t$vardir = \"$uinfo[7]/.tmp\";\n\t}\nelse {\n\t$vardir = $ENV{'WEBMIN_VAR'};\n\t}\nif (!-d $vardir) {\n\t&make_dir($vardir, 0755);\n\t}\n\n# Remove any upload.* files more than 1 hour old\nif (!$main::read_parse_mime_callback_flushed) {\n\tmy $now = time();\n\topendir(UPDIR, $vardir);\n\tforeach my $f (readdir(UPDIR)) {\n\t\tnext if ($f !~ /^upload\\./);\n\t\tmy @st = stat(\"$vardir/$f\");\n\t\tif ($st[9] < $now-3600) {\n\t\t\tunlink(\"$vardir/$f\");\n\t\t\t}\n\t\t}\n\tclosedir(UPDIR);\n\t$main::read_parse_mime_callback_flushed++;\n\t}\n\n# Only update file once per percent\nmy $upfile = \"$vardir/upload.$id\";\nif ($totalsize && $size >= 0) {\n\tmy $pc = int(100 * $size / $totalsize);\n\tif ($pc <= $main::read_parse_mime_callback_pc{$upfile}) {\n\t\treturn;\n\t\t}\n\t$main::read_parse_mime_callback_pc{$upfile} = $pc;\n\t}\n\n# Write to the file\n&open_tempfile(UPFILE, \">$upfile\");\nprint UPFILE $size,\"\\n\";\nprint UPFILE $totalsize,\"\\n\";\nprint UPFILE $filename,\"\\n\";\n&close_tempfile(UPFILE);\n}\n\n=head2 read_parse_mime_javascript(upload-id, [&fields])\n\nReturns an onSubmit= Javascript statement to popup a window for tracking\nan upload with the given ID. For internal use by the upload progress tracker.\n\n=cut\nsub read_parse_mime_javascript\n{\nmy ($id, $fields) = @_;\nreturn \"\" if ($gconfig{'no_upload_tracker'});\nmy $opener = \"window.open(\\\"$gconfig{'webprefix'}/uptracker.cgi?id=$id&uid=$<\\\", \\\"uptracker\\\", \\\"toolbar=no,menubar=no,scrollbars=no,width=500,height=128\\\");\";\nif ($fields) {\n\tmy $if = join(\" || \", map { \"typeof($_) != \\\"undefined\\\" && $_.value != \\\"\\\"\" } @$fields);\n\treturn \"onSubmit='if ($if) { $opener }'\";\n\t}\nelse {\n\treturn \"onSubmit='$opener'\";\n\t}\n}\n\n=head2 PrintHeader(charset, [mime-type])\n\nOutputs the HTTP headers for an HTML page. The optional charset parameter\ncan be used to set a character set. Normally this function is not called\ndirectly, but is rather called by ui_print_header or header.\n\n=cut\nsub PrintHeader\n{\nmy ($cs, $mt) = @_;\n$mt ||= \"text/html\";\nif ($pragma_no_cache || $gconfig{'pragma_no_cache'}) {\n\tprint \"pragma: no-cache\\n\";\n\tprint \"Expires: Thu, 1 Jan 1970 00:00:00 GMT\\n\";\n\tprint \"Cache-Control: no-store, no-cache, must-revalidate\\n\";\n\tprint \"Cache-Control: post-check=0, pre-check=0\\n\";\n\t}\nif ($gconfig{'extra_headers'}) {\n\tforeach my $l (split(/\\t+/, $gconfig{'extra_headers'})) {\n\t\tprint $l.\"\\n\";\n\t\t}\n\t}\nif (!$gconfig{'no_frame_options'}) {\n\tprint \"X-Frame-Options: SAMEORIGIN\\n\";\n\t}\nif (!$gconfig{'no_content_security_policy'}) {\n\tprint \"Content-Security-Policy: script-src 'self' 'unsafe-inline' 'unsafe-eval'; frame-src 'self'; child-src 'self'\\n\";\n\t}\nif (defined($cs)) {\n\tprint \"Content-type: $mt; Charset=$cs\\n\\n\";\n\t}\nelse {\n\tprint \"Content-type: $mt\\n\\n\";\n\t}\n$main::header_content_type = $mt;\n}\n\n=head2 header(title, image, [help], [config], [nomodule], [nowebmin], [rightside], [head-stuff], [body-stuff], [below])\n\nOutputs a Webmin HTML page header with a title, including HTTP headers. The\nparameters are :\n\n=item title - The text to show at the top of the page\n\n=item image - An image to show instead of the title text. This is typically left blank.\n\n=item help - If set, this is the name of a help page that will be linked to in the title.\n\n=item config - If set to 1, the title will contain a link to the module's config page.\n\n=item nomodule - If set to 1, there will be no link in the title section to the module's index.\n\n=item nowebmin - If set to 1, there will be no link in the title section to the Webmin index.\n\n=item rightside - HTML to be shown on the right-hand side of the title. Can contain multiple lines, separated by <br>. Typically this is used for links to stop, start or restart servers.\n\n=item head-stuff - HTML to be included in the <head> section of the page.\n\n=item body-stuff - HTML attributes to be include in the <body> tag.\n\n=item below - HTML to be displayed below the title. Typically this is used for application or server version information.\n\n=cut\nsub header\n{\nreturn if ($main::done_webmin_header++);\nmy $ll;\nmy $charset = defined($main::force_charset) ? $main::force_charset\n\t\t\t\t\t    : &get_charset();\n&PrintHeader($charset);\n&load_theme_library();\nif (defined(&theme_header)) {\n\t$module_name = &get_module_name();\n\t&theme_header(@_);\n\t$miniserv::page_capture = 1;\n\treturn;\n\t}\nprint \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\";\nprint \"<html style=\\\"height:100%\\\">\\n\";\nprint \"<head>\\n\";\nif (defined(&theme_prehead)) {\n\t&theme_prehead(@_);\n\t}\nif ($charset) {\n\tprint \"<meta http-equiv=\\\"Content-Type\\\" \",\n\t      \"content=\\\"text/html; Charset=\".&quote_escape($charset).\"\\\">\\n\";\n\t}\nif (@_ > 0) {\n\tmy $title = &get_html_title($_[0]);\n        print \"<title>$title</title>\\n\" if ($_[7] !~ /<title>/i);\n\tprint $_[7] if ($_[7]);\n\tprint &get_html_status_line(0);\n\t}\nprint \"$tconfig{'headhtml'}\\n\" if ($tconfig{'headhtml'});\nif ($tconfig{'headinclude'}) {\n  my ($theme, $overlay) = split(' ', $gconfig{'theme'});\n  my $file_contents = read_file_contents(\"$root_directory/$overlay/$tconfig{'headinclude'}\");;\n  $file_contents = replace_meta($file_contents);\n  print $file_contents;\n  }\nprint \"</head>\\n\";\nmy $bgcolor = defined($tconfig{'cs_page'}) ? $tconfig{'cs_page'} :\n\t\t defined($gconfig{'cs_page'}) ? $gconfig{'cs_page'} : \"ffffff\";\nmy $link = defined($tconfig{'cs_link'}) ? $tconfig{'cs_link'} :\n\t      defined($gconfig{'cs_link'}) ? $gconfig{'cs_link'} : \"0000ee\";\nmy $text = defined($tconfig{'cs_text'}) ? $tconfig{'cs_text'} :\n\t      defined($gconfig{'cs_text'}) ? $gconfig{'cs_text'} : \"000000\";\nmy $bgimage = defined($tconfig{'bgimage'}) ? \"background=$tconfig{'bgimage'}\" : \"\";\nmy $dir = $current_lang_info->{'dir'} ? \"dir=\\\"$current_lang_info->{'dir'}\\\"\" : \"\";\nmy $html_body = \"<body bgcolor=\\\"#$bgcolor\\\" link=\\\"#$link\\\" vlink=\\\"#$link\\\" text=\\\"#$text\\\" style=\\\"height:100%\\\" $bgimage $tconfig{'inbody'} $dir $_[8]>\\n\";\n$html_body =~ s/\\s+\\>/>/g;\nprint $html_body;\n\nif (defined(&theme_prebody)) {\n\t&theme_prebody(@_);\n\t}\n\nmy $prebody = $tconfig{'prebody'};\nif ($prebody) {\n\t$prebody = replace_meta($prebody);\n\tprint \"$prebody\\n\";\n\t}\n\tif ($tconfig{'prebodyinclude'}) {\n    my ($theme, $overlay) = split(' ', $gconfig{'theme'});\n    my $file_contents = read_file_contents(\"$root_directory/$overlay/$tconfig{'prebodyinclude'}\");\n    $file_contents = replace_meta($file_contents);\n    print $file_contents;\n\t\t}\nif (@_ > 1) {\n\tprint $tconfig{'preheader'};\n\tmy %this_module_info = &get_module_info(&get_module_name());\n\tprint \"<table class='header' width='100%'><tr>\\n\";\n\tif ($gconfig{'sysinfo'} == 2 && $remote_user) {\n\t\tprint \"<td id='headln1' colspan='3' align='center'>\\n\";\n\t\tprint &get_html_status_line(1);\n\t\tprint \"</td></tr> <tr>\\n\";\n\t\t}\n\tprint \"<td id='headln2l' width='15%' valign='top' align='left'>\";\n\tif ($ENV{'HTTP_WEBMIN_SERVERS'} && !$tconfig{'framed'}) {\n\t\tprint \"<a href='$ENV{'HTTP_WEBMIN_SERVERS'}'>\",\n\t\t      \"$text{'header_servers'}</a><br>\\n\";\n\t\t}\n\tif (!$_[5] && !$tconfig{'noindex'}) {\n\t\tmy @avail = &get_available_module_infos(1);\n\t\tmy $nolo = $ENV{'ANONYMOUS_USER'} ||\n\t\t\t      $ENV{'SSL_USER'} || $ENV{'LOCAL_USER'} ||\n\t\t\t      $ENV{'HTTP_USER_AGENT'} =~ /webmin/i;\n\t\tif ($gconfig{'gotoone'} && $main::session_id && @avail == 1 &&\n\t\t    !$nolo) {\n\t\t\tprint \"<a href='$gconfig{'webprefix'}/session_login.cgi?logout=1'>\",\n\t\t\t      \"$text{'main_logout'}</a><br>\";\n\t\t\t}\n\t\telsif ($gconfig{'gotoone'} && @avail == 1 && !$nolo) {\n\t\t\tprint \"<a href=$gconfig{'webprefix'}/switch_user.cgi>\",\n\t\t\t      \"$text{'main_switch'}</a><br>\";\n\t\t\t}\n\t\telsif (!$gconfig{'gotoone'} || @avail > 1) {\n\t\t\tprint \"<a href='$gconfig{'webprefix'}/?cat=\",\n\t\t\t      $this_module_info{'category'},\n\t\t\t      \"'>$text{'header_webmin'}</a><br>\\n\";\n\t\t\t}\n\t\t}\n\tif (!$_[4] && !$tconfig{'nomoduleindex'}) {\n\t\tmy $idx = $this_module_info{'index_link'};\n\t\tmy $mi = $module_index_link || \"/\".&get_module_name().\"/$idx\";\n\t\tmy $mt = $module_index_name || $text{'header_module'};\n\t\tprint \"<a href=\\\"$gconfig{'webprefix'}$mi\\\">$mt</a><br>\\n\";\n\t\t}\n\tif (ref($_[2]) eq \"ARRAY\" && !$ENV{'ANONYMOUS_USER'} &&\n\t    !$tconfig{'nohelp'}) {\n\t\tprint &hlink($text{'header_help'}, $_[2]->[0], $_[2]->[1]),\n\t\t      \"<br>\\n\";\n\t\t}\n\telsif (defined($_[2]) && !$ENV{'ANONYMOUS_USER'} &&\n\t       !$tconfig{'nohelp'}) {\n\t\tprint &hlink($text{'header_help'}, $_[2]),\"<br>\\n\";\n\t\t}\n\tif ($_[3]) {\n\t\tmy %access = &get_module_acl();\n\t\tif (!$access{'noconfig'} && !$config{'noprefs'}) {\n\t\t\tmy $cprog = $user_module_config_directory ?\n\t\t\t\t\t\"uconfig.cgi\" : \"config.cgi\";\n\t\t\tprint \"<a href=\\\"$gconfig{'webprefix'}/$cprog?\",\n\t\t\t      &get_module_name().\"\\\">\",\n\t\t\t      $text{'header_config'},\"</a><br>\\n\";\n\t\t\t}\n\t\t}\n\tprint \"</td>\\n\";\n\tif ($_[1]) {\n\t\t# Title is a single image\n\t\tprint \"<td id='headln2c' align='center' width='70%'>\",\n\t\t      \"<img alt=\\\"$_[0]\\\" src=\\\"$_[1]\\\"></td>\\n\";\n\t\t}\n\telse {\n\t\t# Title is just text\n\t\tmy $ts = defined($tconfig{'titlesize'}) ?\n\t\t\t\t$tconfig{'titlesize'} : \"+2\";\n\t\tprint \"<td id='headln2c' align='center' width='70%'>\",\n\t\t      ($ts ? \"<font size='$ts'>\" : \"\"),$_[0],\n\t\t      ($ts ? \"</font>\" : \"\");\n\t\tprint \"<br>$_[9]\\n\" if ($_[9]);\n\t\tprint \"</td>\\n\";\n\t\t}\n\tprint \"<td id='headln2r' width='15%' valign='top' align='right'>\";\n\tprint $_[6];\n\tprint \"</td></tr></table>\\n\";\n\tprint $tconfig{'postheader'};\n\t}\n$miniserv::page_capture = 1;\n}\n\n=head2 get_html_title(title)\n\nReturns the full string to appear in the HTML <title> block.\n\n=cut\nsub get_html_title\n{\nmy ($msg) = @_;\nmy $title;\nmy $os_type = $gconfig{'real_os_type'} || $gconfig{'os_type'};\nmy $os_version = $gconfig{'real_os_version'} || $gconfig{'os_version'};\nmy $host = &get_display_hostname();\nif ($gconfig{'sysinfo'} == 1 && $remote_user) {\n\t$title = sprintf \"%s : %s on %s (%s %s)\\n\",\n\t\t$msg, $remote_user, $host,\n\t\t$os_type, $os_version;\n\t}\nelsif ($gconfig{'sysinfo'} == 4 && $remote_user) {\n\t$title = sprintf \"%s on %s (%s %s)\\n\",\n\t\t$remote_user, $host,\n\t\t$os_type, $os_version;\n\t}\nelse {\n\t$title = $msg;\n\t}\nif ($gconfig{'showlogin'} && $remote_user) {\n\t$title = $remote_user.($title ? \" : \".$title : \"\");\n\t}\nif ($gconfig{'showhost'}) {\n\t$title = $host.($title ? \" : \".$title : \"\");\n\t}\nreturn $title;\n}\n\n=head2 get_html_framed_title\n\nReturns the title text for a framed theme main page.\n\n=cut\nsub get_html_framed_title\n{\nmy $ostr;\nmy $os_type = $gconfig{'real_os_type'} || $gconfig{'os_type'};\nmy $os_version = $gconfig{'real_os_version'} || $gconfig{'os_version'};\nmy $title;\nif (($gconfig{'sysinfo'} == 4 || $gconfig{'sysinfo'} == 1) && $remote_user) {\n\t# Alternate title mode requested\n\t$title = sprintf \"%s on %s (%s %s)\\n\",\n\t\t$remote_user, &get_display_hostname(),\n\t\t$os_type, $os_version;\n\t}\nelse {\n\t# Title like 'Webmin x.yy on hostname (Linux 6)'\n\tif ($os_version eq \"*\") {\n\t\t$ostr = $os_type;\n\t\t}\n\telse {\n\t\t$ostr = \"$os_type $os_version\";\n\t\t}\n\tmy $host = &get_display_hostname();\n\tmy $ver = &get_webmin_version();\n\t$title = $gconfig{'nohostname'} ? $text{'main_title2'} :\n\t\t $gconfig{'showhost'} ? &text('main_title3', $ver, $ostr) :\n\t\t\t\t\t&text('main_title', $ver, $host, $ostr);\n\tif ($gconfig{'showlogin'}) {\n\t\t$title = $remote_user.($title ? \" : \".$title : \"\");\n\t\t}\n\tif ($gconfig{'showhost'}) {\n\t\t$title = $host.($title ? \" : \".$title : \"\");\n\t\t}\n\t}\nreturn $title;\n}\n\n=head2 get_html_status_line(text-only)\n\nReturns HTML for a script block that sets the status line, or if text-only\nis set to 1, just return the status line text.\n\n=cut\nsub get_html_status_line\n{\nmy ($textonly) = @_;\nif (($gconfig{'sysinfo'} != 0 || !$remote_user) && !$textonly) {\n\t# Disabled in this mode\n\treturn undef;\n\t}\nmy $os_type = $gconfig{'real_os_type'} || $gconfig{'os_type'};\nmy $os_version = $gconfig{'real_os_version'} || $gconfig{'os_version'};\nmy $line = &text('header_statusmsg',\n\t\t ($ENV{'ANONYMOUS_USER'} ? \"Anonymous user\"\n\t\t\t\t\t   : $remote_user).\n\t\t ($ENV{'SSL_USER'} ? \" (SSL certified)\" :\n\t\t  $ENV{'LOCAL_USER'} ? \" (Local user)\" : \"\"),\n\t\t $text{'programname'},\n\t\t &get_webmin_version(),\n\t\t &get_display_hostname(),\n\t\t $os_type.($os_version eq \"*\" ? \"\" :\" $os_version\"));\nif ($textonly) {\n\treturn $line;\n\t}\nelse {\n\t$line =~ s/\\r|\\n//g;\n\treturn \"<script type='text/javascript'>\\n\".\n\t       \"window.defaultStatus=\\\"\".&quote_escape($line).\"\\\";\\n\".\n\t       \"</script>\\n\";\n\t}\n}\n\n=head2 popup_header([title], [head-stuff], [body-stuff], [no-body])\n\nOutputs a page header, suitable for a popup window. If no title is given,\nabsolutely no decorations are output. Also useful in framesets. The parameters\nare :\n\n=item title - Title text for the popup window.\n\n=item head-stuff - HTML to appear in the <head> section.\n\n=item body-stuff - HTML attributes to be include in the <body> tag.\n\n=item no-body - If set to 1, don't generate a body tag\n\n=cut\nsub popup_header\n{\nreturn if ($main::done_webmin_header++);\nmy $ll;\nmy $charset = defined($main::force_charset) ? $main::force_charset\n\t\t\t\t\t    : &get_charset();\n&PrintHeader($charset);\n&load_theme_library();\nif (defined(&theme_popup_header)) {\n\t&theme_popup_header(@_);\n\t$miniserv::page_capture = 1;\n\treturn;\n\t}\nprint \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\";\nprint \"<html>\\n\";\nprint \"<head>\\n\";\nif (defined(&theme_popup_prehead)) {\n\t&theme_popup_prehead(@_);\n\t}\nprint \"<title>$_[0]</title>\\n\";\nprint $_[1];\nprint \"$tconfig{'headhtml'}\\n\" if ($tconfig{'headhtml'});\nif ($tconfig{'headinclude'}) {\n\tprint &read_file_contents(\n\t\t\"$theme_root_directory/$tconfig{'headinclude'}\");\n\t}\nprint \"</head>\\n\";\nmy $bgcolor = defined($tconfig{'cs_page'}) ? $tconfig{'cs_page'} :\n\t\t defined($gconfig{'cs_page'}) ? $gconfig{'cs_page'} : \"ffffff\";\nmy $link = defined($tconfig{'cs_link'}) ? $tconfig{'cs_link'} :\n\t      defined($gconfig{'cs_link'}) ? $gconfig{'cs_link'} : \"0000ee\";\nmy $text = defined($tconfig{'cs_text'}) ? $tconfig{'cs_text'} :\n\t      defined($gconfig{'cs_text'}) ? $gconfig{'cs_text'} : \"000000\";\nmy $bgimage = defined($tconfig{'bgimage'}) ? \"background='$tconfig{'bgimage'}'\"\n\t\t\t\t\t      : \"\";\nif (!$_[3]) {\n\tprint \"<body id='popup' bgcolor='#$bgcolor' link='#$link' vlink='#$link' \",\n\t      \"text='#$text' $bgimage $tconfig{'inbody'} $_[2]>\\n\";\n\tif (defined(&theme_popup_prebody)) {\n\t\t&theme_popup_prebody(@_);\n\t\t}\n\t}\n$miniserv::page_capture = 1;\n}\n\n=head2 footer([page, name]+, [noendbody])\n\nOutputs the footer for a Webmin HTML page, possibly with links back to other\npages. The links are specified by pairs of parameters, the first of which is\na link destination, and the second the link text. For example :\n\n footer('/', 'Webmin index', '', 'Module menu');\n\n=cut\nsub footer\n{\n$miniserv::page_capture = 0;\n&load_theme_library();\nmy %this_module_info = &get_module_info(&get_module_name());\nif (defined(&theme_footer)) {\n\t$module_name = &get_module_name();\t# Old themes use these\n\t%module_info = %this_module_info;\n\t&theme_footer(@_);\n\treturn;\n\t}\nfor(my $i=0; $i+1<@_; $i+=2) {\n\tmy $url = $_[$i];\n\tif ($url ne '/' || !$tconfig{'noindex'}) {\n\t\tif ($url eq '/') {\n\t\t\t$url = \"/?cat=$this_module_info{'category'}\";\n\t\t\t}\n\t\telsif ($url eq '' && &get_module_name()) {\n\t\t\t$url = \"/\".&get_module_name().\"/\".\n\t\t\t       $this_module_info{'index_link'};\n\t\t\t}\n\t\telsif ($url =~ /^\\?/ && &get_module_name()) {\n\t\t\t$url = \"/\".&get_module_name().\"/$url\";\n\t\t\t}\n\t\t$url = \"$gconfig{'webprefix'}$url\" if ($url =~ /^\\//);\n\t\tif ($i == 0) {\n\t\t\tprint \"<a href=\\\"$url\\\"><img alt=\\\"<-\\\" align='middle' border='0' src='$gconfig{'webprefix'}/images/left.gif'></a>\\n\";\n\t\t\t}\n\t\telse {\n\t\t\tprint \"&nbsp;|\\n\";\n\t\t\t}\n\t\tprint \"&nbsp;<a href=\\\"$url\\\">\",&text('main_return', $_[$i+1]),\"</a>\\n\";\n\t\t}\n\t}\nprint \"<br>\\n\";\nif (!$_[$i]) {\n\tmy $postbody = $tconfig{'postbody'};\n\tif ($postbody) {\n\t\t$postbody = replace_meta($postbody);\n\t\tprint \"$postbody\\n\";\n\t\t}\n\tif ($tconfig{'postbodyinclude'}) {\n    my ($theme, $overlay) = split(' ', $gconfig{'theme'});\n    my $file_contents = read_file_contents(\"$root_directory/$overlay/$tconfig{'postbodyinclude'}\");\n    $file_contents = replace_meta($file_contents);\n    print $file_contents;\n    }\n\tif (defined(&theme_postbody)) {\n\t\t&theme_postbody(@_);\n\t\t}\n\tprint \"</body></html>\\n\";\n\t}\n}\n\n=head2 popup_footer([no-body])\n\nOutputs html for a footer for a popup window, started by popup_header.\n\n=cut\nsub popup_footer\n{\n$miniserv::page_capture = 0;\n&load_theme_library();\nif (defined(&theme_popup_footer)) {\n\t&theme_popup_footer(@_);\n\treturn;\n\t}\nif (!$_[0]) {\n\tprint \"</body>\\n\";\n\t}\nprint \"</html>\\n\";\n}\n\n=head2 load_theme_library\n\nImmediately loads the current theme's theme.pl file. Not generally useful for\nmost module developers, as this is called automatically by the header function.\n\n=cut\nsub load_theme_library\n{\nreturn if (!$current_theme || $loaded_theme_library++);\nfor(my $i=0; $i<@theme_root_directories; $i++) {\n\tif ($theme_configs[$i]->{'functions'}) {\n\t\tdo $theme_root_directories[$i].\"/\".\n\t\t   $theme_configs[$i]->{'functions'};\n\t\t}\n\t}\n}\n\n=head2 redirect(url)\n\nOutput HTTP headers to redirect the browser to some page. The url parameter is\ntypically a relative URL like index.cgi or list_users.cgi.\n\n=cut\nsub redirect\n{\nmy $port = $ENV{'SERVER_PORT'} == 443 && uc($ENV{'HTTPS'}) eq \"ON\" ? \"\" :\n\t   $ENV{'SERVER_PORT'} == 80 && uc($ENV{'HTTPS'}) ne \"ON\" ? \"\" :\n\t\t\":$ENV{'SERVER_PORT'}\";\nmy $prot = uc($ENV{'HTTPS'}) eq \"ON\" ? \"https\" : \"http\";\nmy $wp = $gconfig{'webprefixnoredir'} ? undef : $gconfig{'webprefix'};\nmy $url;\nif ($_[0] =~ /^(http|https|ftp|gopher):/) {\n\t# Absolute URL (like http://...)\n\t$url = $_[0];\n\t}\nelsif ($_[0] =~ /^\\//) {\n\t# Absolute path (like /foo/bar.cgi)\n\tif ($gconfig{'relative_redir'}) {\n\t\t$url = \"$wp$_[0]\";\n\t\t}\n\telse {\n\t\t$url = \"$prot://$ENV{'SERVER_NAME'}$port$wp$_[0]\";\n\t\t}\n\t}\nelsif ($ENV{'SCRIPT_NAME'} =~ /^(.*)\\/[^\\/]*$/) {\n\t# Relative URL (like foo.cgi)\n\tif ($gconfig{'relative_redir'}) {\n\t\t$url = \"$wp$1/$_[0]\";\n\t\t}\n\telse {\n\t\t$url = \"$prot://$ENV{'SERVER_NAME'}$port$wp$1/$_[0]\";\n\t\t}\n\t}\nelse {\n\tif ($gconfig{'relative_redir'}) {\n\t\t$url = \"$wp$_[0]\";\n\t\t}\n\telse {\n\t\t$url = \"$prot://$ENV{'SERVER_NAME'}$port/$wp$_[0]\";\n\t\t}\n\t}\n&load_theme_library();\nif (defined(&theme_redirect)) {\n\t$module_name = &get_module_name();\t# Old themes use these\n\t%module_info = &get_module_info($module_name);\n\t&theme_redirect($_[0], $url);\n\t}\nelse {\n\tprint \"Location: $url\\n\\n\";\n\t}\n}\n\n=head2 kill_byname(name, signal)\n\nFinds a process whose command line contains the given name (such as httpd), and\nsends some signal to it. The signal can be numeric (like 9) or named\n(like KILL).\n\n=cut\nsub kill_byname\n{\nmy @pids = &find_byname($_[0]);\nreturn scalar(@pids) if (&is_readonly_mode());\n&webmin_debug_log('KILL', \"signal=$_[1] name=$_[0]\")\n\tif ($gconfig{'debug_what_procs'});\nif (@pids) { kill($_[1], @pids); return scalar(@pids); }\nelse { return 0; }\n}\n\n=head2 kill_byname_logged(name, signal)\n\nLike kill_byname, but also logs the killing.\n\n=cut\nsub kill_byname_logged\n{\nmy @pids = &find_byname($_[0]);\nreturn scalar(@pids) if (&is_readonly_mode());\nif (@pids) { &kill_logged($_[1], @pids); return scalar(@pids); }\nelse { return 0; }\n}\n\n=head2 find_byname(name)\n\nFinds processes searching for the given name in their command lines, and\nreturns a list of matching PIDs.\n\n=cut\nsub find_byname\n{\nif ($gconfig{'os_type'} =~ /-linux$/ && -r \"/proc/$$/cmdline\") {\n\t# Linux with /proc filesystem .. use cmdline files, as this is\n\t# faster than forking\n\tmy @pids;\n\topendir(PROCDIR, \"/proc\");\n\tforeach my $f (readdir(PROCDIR)) {\n\t\tif ($f eq int($f) && $f != $$) {\n\t\t\tmy $line = &read_file_contents(\"/proc/$f/cmdline\");\n\t\t\tif ($line =~ /$_[0]/) {\n\t\t\t\tpush(@pids, $f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclosedir(PROCDIR);\n\treturn @pids;\n\t}\n\nif (&foreign_check(\"proc\")) {\n\t# Call the proc module\n\t&foreign_require(\"proc\", \"proc-lib.pl\");\n\tif (defined(&proc::list_processes)) {\n\t\tmy @procs = &proc::list_processes();\n\t\tmy @pids;\n\t\tforeach my $p (@procs) {\n\t\t\tif ($p->{'args'} =~ /$_[0]/) {\n\t\t\t\tpush(@pids, $p->{'pid'});\n\t\t\t\t}\n\t\t\t}\n\t\t@pids = grep { $_ != $$ } @pids;\n\t\treturn @pids;\n\t\t}\n\t}\n\n# Fall back to running a command\nmy ($cmd, @pids);\n$cmd = $gconfig{'find_pid_command'};\n$cmd =~ s/NAME/\"$_[0]\"/g;\n$cmd = &translate_command($cmd);\n@pids = split(/\\n/, `($cmd) <$null_file 2>$null_file`);\n@pids = grep { $_ != $$ } @pids;\nreturn @pids;\n}\n\n=head2 error([message]+)\n\nDisplay an error message and exit. This should be used by CGI scripts that\nencounter a fatal error or invalid user input to notify users of the problem.\nIf error_setup has been called, the displayed error message will be prefixed\nby the message setup using that function.\n\n=cut\nsub error\n{\n$main::no_miniserv_userdb = 1;\nmy $msg = join(\"\", @_);\n$msg =~ s/<[^>]*>//g;\nif (!$main::error_must_die) {\n\tprint STDERR \"Error: \",$msg,\"\\n\";\n\t}\n&load_theme_library();\nif ($main::error_must_die) {\n\tdie @_;\n\t}\n&call_error_handlers();\nif (!$ENV{'REQUEST_METHOD'}) {\n\t# Show text-only error\n\tprint STDERR \"$text{'error'}\\n\";\n\tprint STDERR \"-----\\n\";\n\tprint STDERR ($main::whatfailed ? \"$main::whatfailed : \" : \"\"),\n\t\t     $msg,\"\\n\";\n\tprint STDERR \"-----\\n\";\n\tif ($gconfig{'error_stack'}) {\n\t\t# Show call stack\n\t\tprint STDERR $text{'error_stack'},\"\\n\";\n\t\tfor(my $i=0; my @stack = caller($i); $i++) {\n\t\t\tprint STDERR &text('error_stackline',\n\t\t\t\t$stack[1], $stack[2], $stack[3]),\"\\n\";\n\t\t\t}\n\t\t}\n\n\t}\nelsif (defined(&theme_error)) {\n\t&theme_error(@_);\n\t}\nelsif ($in{'json-error'} eq '1') {\n\tmy %jerror;\n\tmy $error_what = ($main::whatfailed ? \"$main::whatfailed: \" : \"\");\n\tmy $error_message = join(\",\", @_);\n\tmy $error = ($error_what . $error_message);\n\t%jerror = (error => $error,\n\t\t   error_fatal => 1, \n\t\t   error_what => $error_what, \n\t\t   error_message => $error_message\n\t\t  );\n\tprint_json(\\%jerror);\n\t}\nelse {\n\t&header($text{'error'}, \"\");\n\tprint \"<hr>\\n\";\n\tprint \"<h3>\",($main::whatfailed ? \"$main::whatfailed : \" : \"\"),\n\t\t     @_,\"</h3>\\n\";\n\tif ($gconfig{'error_stack'}) {\n\t\t# Show call stack\n\t\tprint \"<h3>$text{'error_stack'}</h3>\\n\";\n\t\tprint \"<table>\\n\";\n\t\tprint \"<tr> <td><b>$text{'error_file'}</b></td> \",\n\t\t      \"<td><b>$text{'error_line'}</b></td> \",\n\t\t      \"<td><b>$text{'error_sub'}</b></td> </tr>\\n\";\n\t\tfor($i=0; my @stack = caller($i); $i++) {\n\t\t\tprint \"<tr>\\n\";\n\t\t\tprint \"<td>$stack[1]</td>\\n\";\n\t\t\tprint \"<td>$stack[2]</td>\\n\";\n\t\t\tprint \"<td>$stack[3]</td>\\n\";\n\t\t\tprint \"</tr>\\n\";\n\t\t\t}\n\t\tprint \"</table>\\n\";\n\t\t}\n\tprint \"<hr>\\n\";\n\tif ($ENV{'HTTP_REFERER'} && $main::completed_referers_check) {\n\t\t&footer(\"javascript:history.back()\", $text{'error_previous'});\n\t\t}\n\telse {\n\t\t&footer();\n\t\t}\n\t}\n&unlock_all_files();\n&cleanup_tempnames();\nexit(1);\n}\n\n=head2 popup_error([message]+)\n\nThis function is almost identical to error, but displays the message with HTML\nheaders suitable for a popup window.\n\n=cut\nsub popup_error\n{\n$main::no_miniserv_userdb = 1;\n&load_theme_library();\nif ($main::error_must_die) {\n\tdie @_;\n\t}\n&call_error_handlers();\nif (defined(&theme_popup_error)) {\n\t&theme_popup_error(@_);\n\t}\nelse {\n\t&popup_header($text{'error'}, \"\");\n\tprint \"<h3>\",($main::whatfailed ? \"$main::whatfailed : \" : \"\"),@_,\"</h3>\\n\";\n\t&popup_footer();\n\t}\n&unlock_all_files();\n&cleanup_tempnames();\nexit;\n}\n\n=head2 register_error_handler(&func, arg, ...)\n\nRegister a function that will be called when this process exits, such as by\ncalling &error\n\n=cut\nsub register_error_handler\n{\nmy ($f, @args) = @_;\npush(@$error_handler_funcs, [ $f, @args ]);\n}\n\n\n=head2 call_error_handlers()\n\nInternal function to call all registered error handlers\n\n=cut\nsub call_error_handlers\n{\nmy @funcs = @$error_handler_funcs;\n$error_handler_funcs = [ ];\nforeach my $e (@funcs) {\n\tmy ($f, @args) = @$e;\n\t&$f(@args);\n\t}\n}\n\n=head2 error_setup(message)\n\nRegisters a message to be prepended to all error messages displayed by the\nerror function.\n\n=cut\nsub error_setup\n{\n$main::whatfailed = $_[0];\n}\n\n=head2 wait_for(handle, regexp, regexp, ...)\n\nReads from the input stream until one of the regexps matches, and returns the\nindex of the matching regexp, or -1 if input ended before any matched. This is\nvery useful for parsing the output of interactive programs, and can be used with\na two-way pipe to feed input to a program in response to output matched by\nthis function.\n\nIf the matching regexp contains bracketed sub-expressions, their values will\nbe placed in the global array @matches, indexed starting from 1. You cannot\nuse the Perl variables $1, $2 and so on to capture matches.\n\nExample code:\n\n $rv = wait_for($loginfh, \"username:\");\n if ($rv == -1) {\n   error(\"Didn't get username prompt\");\n }\n print $loginfh \"joe\\n\";\n $rv = wait_for($loginfh, \"password:\");\n if ($rv == -1) {\n   error(\"Didn't get password prompt\");\n }\n print $loginfh \"smeg\\n\";\n\n=cut\nsub wait_for\n{\nmy ($c, $i, $sw, $rv, $ha);\nundef($wait_for_input);\nif ($wait_for_debug) {\n\tprint STDERR \"wait_for(\",join(\",\", @_),\")\\n\";\n\t}\n$ha = &callers_package($_[0]);\nif ($wait_for_debug) {\n\tprint STDERR \"File handle=$ha fd=\",fileno($ha),\"\\n\";\n\t}\n$codes =\n\"my \\$hit;\\n\".\n\"while(1) {\\n\".\n\" if ((\\$c = getc(\\$ha)) eq \\\"\\\") { return -1; }\\n\".\n\" \\$wait_for_input .= \\$c;\\n\";\nif ($wait_for_debug) {\n\t$codes .= \"print STDERR \\$wait_for_input,\\\"\\\\n\\\";\";\n\t}\nfor($i=1; $i<@_; $i++) {\n        $sw = $i>1 ? \"elsif\" : \"if\";\n        $codes .= \" $sw (\\$wait_for_input =~ /$_[$i]/i) { \\$hit = $i-1; }\\n\";\n        }\n$codes .=\n\" if (defined(\\$hit)) {\\n\".\n\"  \\@matches = (-1, \\$1, \\$2, \\$3, \\$4, \\$5, \\$6, \\$7, \\$8, \\$9);\\n\".\n\"  return \\$hit;\\n\".\n\"  }\\n\".\n\" }\\n\";\n$rv = eval $codes;\nif ($@) {\n\t&error(\"wait_for error : $@\\n\");\n\t}\nreturn $rv;\n}\n\n=head2 fast_wait_for(handle, string, string, ...)\n\nThis function behaves very similar to wait_for (documented above), but instead\nof taking regular expressions as parameters, it takes strings. As soon as the\ninput contains one of them, it will return the index of the matching string.\nIf the input ends before any match, it returns -1.\n\n=cut\nsub fast_wait_for\n{\nmy ($inp, $maxlen, $ha, $i, $c, $inpl);\nfor($i=1; $i<@_; $i++) {\n\t$maxlen = length($_[$i]) > $maxlen ? length($_[$i]) : $maxlen;\n\t}\n$ha = $_[0];\nwhile(1) {\n\tif (($c = getc($ha)) eq \"\") {\n\t\t&error(\"fast_wait_for read error : $!\");\n\t\t}\n\t$inp .= $c;\n\tif (length($inp) > $maxlen) {\n\t\t$inp = substr($inp, length($inp)-$maxlen);\n\t\t}\n\t$inpl = length($inp);\n\tfor($i=1; $i<@_; $i++) {\n\t\tif ($_[$i] eq substr($inp, $inpl-length($_[$i]))) {\n\t\t\treturn $i-1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n=head2 has_command(command)\n\nReturns the full path to the executable if some command is in the path, or\nundef if not found. If the given command is already an absolute path and\nexists, then the same path will be returned.\n\n=cut\nsub has_command\n{\nif (!$_[0]) { return undef; }\nif (exists($main::has_command_cache{$_[0]})) {\n\treturn $main::has_command_cache{$_[0]};\n\t}\nmy $rv = undef;\nmy $slash = $gconfig{'os_type'} eq 'windows' ? '\\\\' : '/';\nif ($_[0] =~ /^\\// || $_[0] =~ /^[a-z]:[\\\\\\/]/i) {\n\t# Absolute path given - just use it\n\tmy $t = &translate_filename($_[0]);\n\t$rv = (-x $t && !-d _) ? $_[0] : undef;\n\t}\nelse {\n\t# Check each directory in the path\n\tmy %donedir;\n\tforeach my $d (split($path_separator, $ENV{'PATH'})) {\n\t\tnext if ($donedir{$d}++);\n\t\t$d =~ s/$slash$// if ($d ne $slash);\n\t\tmy $t = &translate_filename(\"$d/$_[0]\");\n\t\tif (-x $t && !-d _) {\n\t\t\t$rv = $d.$slash.$_[0];\n\t\t\tlast;\n\t\t\t}\n\t\tif ($gconfig{'os_type'} eq 'windows') {\n\t\t\tforeach my $sfx (\".exe\", \".com\", \".bat\") {\n\t\t\t\tmy $t = &translate_filename(\"$d/$_[0]\").$sfx;\n\t\t\t\tif (-r $t && !-d _) {\n\t\t\t\t\t$rv = $d.$slash.$_[0].$sfx;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n$main::has_command_cache{$_[0]} = $rv;\nreturn $rv;\n}\n\n=head2 make_date(seconds, [date-only], [fmt])\n\nConverts a Unix date/time in seconds to a human-readable form, by default\nformatted like dd/mmm/yyyy hh:mm:ss. Parameters are :\n\n=item seconds - Unix time is seconds to convert.\n\n=item date-only - If set to 1, exclude the time from the returned string.\n\n=item fmt - Optional, one of dd/mon/yyyy, dd/mm/yyyy, mm/dd/yyyy or yyyy/mm/dd\n\n=cut\nsub make_date\n{\n&load_theme_library();\nif (defined(&theme_make_date) &&\n    $main::header_content_type eq \"text/html\" &&\n    $main::webmin_script_type eq \"web\") {\n\treturn &theme_make_date(@_);\n\t}\nmy ($secs, $only, $fmt) = @_;\nmy @tm = localtime($secs);\nmy $date;\nif (!$fmt) {\n\t$fmt = $gconfig{'dateformat'} || 'dd/mon/yyyy';\n\t}\nif ($fmt eq 'dd/mon/yyyy') {\n\t$date = sprintf \"%2.2d/%s/%4.4d\",\n\t\t\t$tm[3], $text{\"smonth_\".($tm[4]+1)}, $tm[5]+1900;\n\t}\nelsif ($fmt eq 'dd/mm/yyyy') {\n\t$date = sprintf \"%2.2d/%2.2d/%4.4d\", $tm[3], $tm[4]+1, $tm[5]+1900;\n\t}\nelsif ($fmt eq 'mm/dd/yyyy') {\n\t$date = sprintf \"%2.2d/%2.2d/%4.4d\", $tm[4]+1, $tm[3], $tm[5]+1900;\n\t}\nelsif ($fmt eq 'yyyy/mm/dd') {\n\t$date = sprintf \"%4.4d/%2.2d/%2.2d\", $tm[5]+1900, $tm[4]+1, $tm[3];\n\t}\nelsif ($fmt eq 'd. mon yyyy') {\n\t$date = sprintf \"%d. %s %4.4d\",\n\t\t\t$tm[3], $text{\"smonth_\".($tm[4]+1)}, $tm[5]+1900;\n\t}\nelsif ($fmt eq 'dd.mm.yyyy') {\n\t$date = sprintf \"%2.2d.%2.2d.%4.4d\", $tm[3], $tm[4]+1, $tm[5]+1900;\n\t}\nelsif ($fmt eq 'yyyy-mm-dd') {\n\t$date = sprintf \"%4.4d-%2.2d-%2.2d\", $tm[5]+1900, $tm[4]+1, $tm[3];\n\t}\nif (!$only) {\n\t$date .= sprintf \" %2.2d:%2.2d\", $tm[2], $tm[1];\n\t}\nreturn $date;\n}\n\n=head2 file_chooser_button(input, type, [form], [chroot], [addmode])\n\nReturn HTML for a button that pops up a file chooser when clicked, and places\nthe selected filename into another HTML field. The parameters are :\n\n=item input - Name of the form field to store the filename in.\n\n=item type - 0 for file or directory chooser, or 1 for directory only.\n\n=item form - Index of the form containing the button.\n\n=item chroot - If set to 1, the chooser will be limited to this directory.\n\n=item addmode - If set to 1, the selected filename will be appended to the text box instead of replacing it's contents.\n\n=cut\nsub file_chooser_button\n{\nreturn &theme_file_chooser_button(@_)\n\tif (defined(&theme_file_chooser_button));\nmy $form = defined($_[2]) ? $_[2] : 0;\nmy $chroot = defined($_[3]) ? $_[3] : \"/\";\nmy $add = int($_[4]);\nmy ($w, $h) = (400, 300);\nif ($gconfig{'db_sizefile'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizefile'});\n\t}\nreturn \"<input type=button onClick='ifield = form.$_[0]; chooser = window.open(\\\"$gconfig{'webprefix'}/chooser.cgi?add=$add&type=$_[1]&chroot=$chroot&file=\\\"+encodeURIComponent(ifield.value), \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=no,resizable=yes,width=$w,height=$h\\\"); chooser.ifield = ifield; window.ifield = ifield' value=\\\"...\\\">\\n\";\n}\n\n=head2 popup_window_button(url, width, height, scrollbars?, &field-mappings)\n\nReturns HTML for a button that will popup a chooser window of some kind. The\nparameters are :\n\n=item url - Base URL of the popup window's contents\n\n=item width - Width of the window in pixels\n\n=item height - Height in pixels\n\n=item scrollbars - Set to 1 if the window should have scrollbars\n\n=item fields - See below\n\n=item disabled - The button is disabled if non-zero\n\nThe field-mappings parameter is an array ref of array refs containing\n\n=item - Attribute to assign field to in the popup window\n\n=item - Form field name\n\n=item - CGI parameter to URL for value, if any\n\n=cut\nsub popup_window_button\n{\nreturn &theme_popup_window_button(@_) if (defined(&theme_popup_window_button));\nmy ($url, $w, $h, $scroll, $fields, $disabled) = @_;\nmy $scrollyn = $scroll ? \"yes\" : \"no\";\nmy $rv = \"<input type=button onClick='\";\nforeach my $m (@$fields) {\n\t$rv .= \"$m->[0] = form.$m->[1]; \";\n\t}\nmy $sep = $url =~ /\\?/ ? \"&\" : \"?\";\n$rv .= \"chooser = window.open(\\\"$url\\\"\";\nforeach my $m (@$fields) {\n\tif ($m->[2]) {\n\t\t$rv .= \"+\\\"$sep$m->[2]=\\\"+escape($m->[0].value)\";\n\t\t$sep = \"&\";\n\t\t}\n\t}\n$rv .= \", \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=$scrollyn,resizable=yes,width=$w,height=$h\\\"); \";\nforeach my $m (@$fields) {\n\t$rv .= \"chooser.$m->[0] = $m->[0]; \";\n\t$rv .= \"window.$m->[0] = $m->[0]; \";\n\t}\n$rv .= \"' value=\\\"...\\\"\";\nif ($disabled) {\n\t$rv .= \" disabled\";\n\t}\n$rv .= \">\";\nreturn $rv;\n}\n\n=head2 popup_window_link(url, title, width, height, scrollbar, &field-mappings)\n\nReturns HTML for a link that will popup a chooser window of some kind. The\nparameters are :\n\n=item url - Base URL of the popup window's contents\n\n=item title - Text of the link\n\n=item width - Width of the window in pixels\n\n=item height - Height in pixels\n\n=item scrollbars - Set to 1 if the window should have scrollbars\n\n=item fields - See below\n\nThe field-mappings parameter is an array ref of array refs containing\n\n=item - Attribute to assign field to in the popup window\n\n=item - Form field name\n\n=item - CGI parameter to URL for value, if any\n\n=cut\nsub popup_window_link\n{\nreturn &theme_popup_window_link(@_) if (defined(&theme_popup_window_link));\nmy ($url, $title, $w, $h, $scrollyn, $fields) = @_;\nmy $scrollyn = $scroll ? \"yes\" : \"no\";\nmy $rv = \"onClick='\";\nforeach my $m (@$fields) {\n\t$rv .= \"$m->[0] = form.$m->[1]; \";\n\t}\nmy $sep = $url =~ /\\?/ ? \"&\" : \"?\";\n$rv .= \"chooser = window.open(\\\"$url\\\"\";\nforeach my $m (@$fields) {\n\tif ($m->[2]) {\n\t\t$rv .= \"+\\\"$sep$m->[2]=\\\"+escape($m->[0].value)\";\n\t\t$sep = \"&\";\n\t\t}\n\t}\n$rv .= \", \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=$scrollyn,resizable=yes,width=$w,height=$h\\\"); \";\nforeach my $m (@$fields) {\n\t$rv .= \"chooser.$m->[0] = $m->[0]; \";\n\t$rv .= \"window.$m->[0] = $m->[0]; \";\n\t}\n$rv .= \"return false;'\";\nreturn &ui_link($url, $title, undef, $rv);\n}\n\n=head2 read_acl(&user-module-hash, &user-list-hash, [&only-users])\n\nReads the Webmin acl file into the given hash references. The first is indexed\nby a combined key of username,module , with the value being set to 1 when\nthe user has access to that module. The second is indexed by username, with\nthe value being an array ref of allowed modules.\n\nThis function is deprecated in favour of foreign_available, which performs a\nmore comprehensive check of module availability.\n\nIf the only-users array ref parameter is given, the results may be limited to\nusers in that list of names.\n\n=cut\nsub read_acl\n{\nmy ($usermod, $userlist, $only) = @_;\nif (!%main::acl_hash_cache) {\n\t# Read from local files\n\tlocal $_;\n\topen(ACL, &acl_filename());\n\twhile(<ACL>) {\n\t\tif (/^([^:]+):\\s*(.*)/) {\n\t\t\tmy $user = $1;\n\t\t\tmy @mods = split(/\\s+/, $2);\n\t\t\tforeach my $m (@mods) {\n\t\t\t\t$main::acl_hash_cache{$user,$m}++;\n\t\t\t\t}\n\t\t\t$main::acl_array_cache{$user} = \\@mods;\n\t\t\t}\n\t\t}\n\tclose(ACL);\n\t}\n%$usermod = %main::acl_hash_cache if ($usermod);\n%$userlist = %main::acl_array_cache if ($userlist);\n\n# Read from user DB\nmy $userdb = &get_userdb_string();\nmy ($dbh, $proto, $prefix, $args) =\n\t$userdb ? &connect_userdb($userdb) : ( );\nif (ref($dbh)) {\n\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Select usernames and modules from SQL DB\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select webmin_user.name,webmin_user_attr.value \".\n\t\t\t\"from webmin_user,webmin_user_attr \".\n\t\t\t\"where webmin_user.id = webmin_user_attr.id \".\n\t\t\t\"and webmin_user_attr.attr = 'modules' \".\n\t\t\t($only ? \" and webmin_user.name in (\".\n\t\t\t\t join(\",\", map { \"'$_'\" } @$only).\")\" : \"\"));\n\t\tif ($cmd && $cmd->execute()) {\n\t\t\twhile(my ($user, $mods) = $cmd->fetchrow()) {\n\t\t\t\tmy @mods = split(/\\s+/, $mods);\n\t\t\t\tforeach my $m (@mods) {\n\t\t\t\t\t$usermod->{$user,$m}++ if ($usermod);\n\t\t\t\t\t}\n\t\t\t\t$userlist->{$user} = \\@mods if ($userlist);\n\t\t\t\t}\n\t\t\t}\n\t\t$cmd->finish() if ($cmd);\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Find users in LDAP\n\t\tmy $filter = '(objectClass='.$args->{'userclass'}.')';\n\t\tif ($only) {\n\t\t\tmy $ufilter =\n\t\t\t\t\"(|\".join(\"\", map { \"(cn=$_)\" } @$only).\")\";\n\t\t\t$filter = \"(&\".$filter.$ufilter.\")\";\n\t\t\t}\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => $filter,\n\t\t\tscope => 'sub',\n\t\t\tattrs => [ 'cn', 'webminModule' ]);\n\t\tif ($rv && !$rv->code) {\n\t\t\tforeach my $u ($rv->all_entries) {\n\t\t\t\tmy $user = $u->get_value('cn');\n\t\t\t\tmy @mods =$u->get_value('webminModule');\n\t\t\t\tforeach my $m (@mods) {\n\t\t\t\t\t$usermod->{$user,$m}++ if ($usermod);\n\t\t\t\t\t}\n\t\t\t\t$userlist->{$user} = \\@mods if ($userlist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($userdb, $dbh);\n\t}\n}\n\n=head2 acl_filename\n\nReturns the file containing the webmin ACL, which is usually\n/etc/webmin/webmin.acl.\n\n=cut\nsub acl_filename\n{\nreturn \"$config_directory/webmin.acl\";\n}\n\n=head2 acl_check\n\nDoes nothing, but kept around for compatibility.\n\n=cut\nsub acl_check\n{\n}\n\n=head2 get_miniserv_config(&hash)\n\nReads the Webmin webserver's (miniserv.pl) configuration file, usually located\nat /etc/webmin/miniserv.conf, and stores its names and values in the given\nhash reference.\n\n=cut\nsub get_miniserv_config\n{\nreturn &read_file_cached(\n\t$ENV{'MINISERV_CONFIG'} || \"$config_directory/miniserv.conf\", $_[0]);\n}\n\n=head2 put_miniserv_config(&hash)\n\nWrites out the Webmin webserver configuration file from the contents of\nthe given hash ref. This should be initially populated by get_miniserv_config,\nlike so :\n\n get_miniserv_config(\\%miniserv);\n $miniserv{'port'} = 10005;\n put_miniserv_config(\\%miniserv);\n restart_miniserv();\n\n=cut\nsub put_miniserv_config\n{\n&write_file($ENV{'MINISERV_CONFIG'} || \"$config_directory/miniserv.conf\",\n\t    $_[0]);\n}\n\n=head2 restart_miniserv([nowait], [ignore-errors])\n\nKill the old miniserv process and re-start it, then optionally waits for\nit to restart. This will apply all configuration settings.\n\n=cut\nsub restart_miniserv\n{\nmy ($nowait, $ignore) = @_;\nreturn undef if (&is_readonly_mode());\nmy %miniserv;\n&get_miniserv_config(\\%miniserv) || return;\nif ($main::webmin_script_type eq 'web' && !$ENV{\"MINISERV_CONFIG\"} &&\n    !$ENV{'MINISERV_PID'}) {\n\t# Running under some web server other than miniserv, so do nothing\n\treturn;\n\t}\n\nmy $i;\nif ($gconfig{'os_type'} ne 'windows') {\n\t# On Unix systems, we can restart with a signal\n\tmy ($pid, $addr, $i);\n\t$miniserv{'inetd'} && return;\n\tmy @oldst = stat($miniserv{'pidfile'});\n\t$pid = $ENV{'MINISERV_PID'};\n\tif (!$pid || !kill(0, $pid)) {\n\t\tif (!open(PID, $miniserv{'pidfile'})) {\n\t\t\tprint STDERR \"PID file $miniserv{'pidfile'} does \",\n\t\t\t\t     \"not exist\\n\" if (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\tchop($pid = <PID>);\n\t\tclose(PID);\n\t\tif (!$pid) {\n\t\t\tprint STDERR \"Invalid PID file $miniserv{'pidfile'}\\n\"\n\t\t\t\tif (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\tif (!kill(0, $pid)) {\n\t\t\tprint STDERR \"PID $pid from file $miniserv{'pidfile'} \",\n\t\t\t             \"is not valid\\n\" if (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t# Just signal miniserv to restart\n\tif (!&kill_logged('HUP', $pid)) {\n\t\t&error(\"Incorrect Webmin PID $pid\") if (!$ignore);\n\t\t}\n\n\t# Wait till new PID is written, indicating a restart\n\tfor($i=0; $i<60; $i++) {\n\t\tsleep(1);\n\t\tmy @newst = stat($miniserv{'pidfile'});\n\t\tlast if ($newst[9] != $oldst[9]);\n\t\t}\n\t$i < 60 || $ignore || &error(\"Webmin server did not write new PID file\");\n\n\t## Totally kill the process and re-run it\n\t#$SIG{'TERM'} = 'IGNORE';\n\t#&kill_logged('TERM', $pid);\n\t#&system_logged(\"$config_directory/start >/dev/null 2>&1 </dev/null\");\n\t}\nelse {\n\t# On Windows, we need to use the flag file\n\topen(TOUCH, \">$miniserv{'restartflag'}\");\n\tclose(TOUCH);\n\t}\n\nif (!$nowait) {\n\t# Wait for miniserv to come back up\n\tmy $addr = $miniserv{'bind'} || \"127.0.0.1\";\n\tmy $ok = 0;\n\tfor($i=0; $i<20; $i++) {\n\t\tmy $err;\n\t\tsleep(1);\n\t\t&open_socket($addr, $miniserv{'port'}, STEST, \\$err);\n\t\tclose(STEST);\n\t\tlast if (!$err && ++$ok >= 2);\n\t\t}\n\t$i < 20 || $ignore || &error(\"Failed to restart Webmin server!\");\n\t}\n}\n\n=head2 reload_miniserv([ignore-errors])\n\nSends a USR1 signal to the miniserv process, telling it to read-read it's\nconfiguration files. Not all changes will be applied though, such as the\nIP addresses and ports to accept connections on.\n\n=cut\nsub reload_miniserv\n{\nmy ($ignore) = @_;\nreturn undef if (&is_readonly_mode());\nmy %miniserv;\n&get_miniserv_config(\\%miniserv) || return;\nif ($main::webmin_script_type eq 'web' && !$ENV{\"MINISERV_CONFIG\"} &&\n    !$ENV{'MINISERV_PID'}) {\n\t# Running under some web server other than miniserv, so do nothing\n\treturn;\n\t}\n\nif ($gconfig{'os_type'} ne 'windows') {\n\t# Send a USR1 signal to re-read the config\n\tmy ($pid, $addr, $i);\n\t$miniserv{'inetd'} && return;\n\t$pid = $ENV{'MINISERV_PID'};\n\tif (!$pid || !kill(0, $pid)) {\n\t\tif (!open(PID, $miniserv{'pidfile'})) {\n\t\t\tprint STDERR \"PID file $miniserv{'pidfile'} does \",\n\t\t\t\t     \"not exist\\n\" if (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\tchop($pid = <PID>);\n\t\tclose(PID);\n\t\tif (!$pid) {\n\t\t\tprint STDERR \"Invalid PID file $miniserv{'pidfile'}\\n\"\n\t\t\t\tif (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\tif (!kill(0, $pid)) {\n\t\t\tprint STDERR \"PID $pid from file $miniserv{'pidfile'} \",\n\t\t\t             \"is not valid\\n\" if (!$ignore);\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\tif (!&kill_logged('USR1', $pid)) {\n\t\t&error(\"Incorrect Webmin PID $pid\") if (!$ignore);\n\t\t}\n\n\t# Make sure this didn't kill Webmin!\n\tsleep(1);\n\tif (!kill(0, $pid)) {\n\t\tprint STDERR \"USR1 signal killed Webmin - restarting\\n\"\n\t\t\tif (!$ignore);\n\t\t&system_logged(\"$config_directory/start >/dev/null 2>&1 </dev/null\");\n\t\t}\n\t}\nelse {\n\t# On Windows, we need to use the flag file\n\topen(TOUCH, \">$miniserv{'reloadflag'}\");\n\tclose(TOUCH);\n\t}\n}\n\n=head2 check_os_support(&minfo, [os-type, os-version], [api-only])\n\nReturns 1 if some module is supported on the current operating system, or the\nOS supplies as parameters. The parameters are :\n\n=item minfo - A hash ref of module information, as returned by get_module_info\n\n=item os-type - The Webmin OS code to use instead of the system's real OS, such as redhat-linux\n\n=item os-version - The Webmin OS version to use, such as 13.0\n\n=item api-only - If set to 1, considers a module supported if it provides an API to other modules on this OS, even if the majority of its functionality is not supported.\n\n=cut\nsub check_os_support\n{\nmy $oss = $_[0]->{'os_support'};\nif ($_[3] && $oss && $_[0]->{'api_os_support'}) {\n\t# May provide usable API\n\t$oss .= \" \".$_[0]->{'api_os_support'};\n\t}\nif ($_[0]->{'nozone'} && &running_in_zone()) {\n\t# Not supported in a Solaris Zone\n\treturn 0;\n\t}\nif ($_[0]->{'novserver'} && &running_in_vserver()) {\n\t# Not supported in a Linux Vserver\n\treturn 0;\n\t}\nif ($_[0]->{'noopenvz'} && &running_in_openvz()) {\n\t# Not supported in an OpenVZ container\n\treturn 0;\n\t}\nreturn 1 if (!$oss || $oss eq '*');\nmy $osver = $_[2] || $gconfig{'os_version'};\nmy $ostype = $_[1] || $gconfig{'os_type'};\nmy $anyneg = 0;\nwhile(1) {\n\tmy ($os, $ver, $codes);\n\tmy ($neg) = ($oss =~ s/^!//);\t# starts with !\n\t$anyneg++ if ($neg);\n\tif ($oss =~ /^([^\\/\\s]+)\\/([^\\{\\s]+)\\{([^\\}]*)\\}\\s*(.*)$/) {\n\t\t# OS/version{code}\n\t\t$os = $1; $ver = $2; $codes = $3; $oss = $4;\n\t\t}\n\telsif ($oss =~ /^([^\\/\\s]+)\\/([^\\/\\s]+)\\s*(.*)$/) {\n\t\t# OS/version\n\t\t$os = $1; $ver = $2; $oss = $3;\n\t\t}\n\telsif ($oss =~ /^([^\\{\\s]+)\\{([^\\}]*)\\}\\s*(.*)$/) {\n\t\t# OS/{code}\n\t\t$os = $1; $codes = $2; $oss = $3;\n\t\t}\n\telsif ($oss =~ /^\\{([^\\}]*)\\}\\s*(.*)$/) {\n\t\t# {code}\n\t\t$codes = $1; $oss = $2;\n\t\t}\n\telsif ($oss =~ /^(\\S+)\\s*(.*)$/) {\n\t\t# OS\n\t\t$os = $1; $oss = $2;\n\t\t}\n\telse { last; }\n\tnext if ($os && !($os eq $ostype ||\n\t\t\t  $ostype =~ /^(\\S+)-(\\S+)$/ && $os eq \"*-$2\"));\n\tif ($ver =~ /^([0-9\\.]+)\\-([0-9\\.]+)$/) {\n\t\tnext if ($osver < $1 || $osver > $2);\n\t\t}\n\telsif ($ver =~ /^([0-9\\.]+)\\-\\*$/) {\n\t\tnext if ($osver < $1);\n\t\t}\n\telsif ($ver =~ /^\\*\\-([0-9\\.]+)$/) {\n\t\tnext if ($osver > $1);\n\t\t}\n\telsif ($ver) {\n\t\tnext if ($ver ne $osver);\n\t\t}\n\tnext if ($codes && !eval $codes);\n\treturn !$neg;\n\t}\nreturn $anyneg;\n}\n\n=head2 http_download(host, port, page, destfile, [&error], [&callback], [sslmode], [user], [pass], [timeout], [osdn-convert], [no-cache], [&headers])\n\nDownloads data from a HTTP url to a local file or string. The parameters are :\n\n=item host - The hostname part of the URL, such as www.google.com\n\n=item port - The HTTP port number, such as 80\n\n=item page - The filename part of the URL, like /index.html\n\n=item destfile - The local file to save the URL data to, like /tmp/index.html. This can also be a scalar reference, in which case the data will be appended to that scalar.\n\n=item error - If set to a scalar ref, the function will store any error message in this scalar and return 0 on failure, or 1 on success. If not set, it will simply call the error function if the download fails.\n\n=item callback - If set to a function ref, it will be called after each block of data is received. This is typically set to \\&progress_callback, for printing download progress.\n\n=item sslmode - If set to 1, an HTTPS connection is used instead of HTTP.\n\n=item user - If set, HTTP authentication is done with this username.\n\n=item pass - The HTTP password to use with the username above.\n\n=item timeout - A timeout in seconds to wait for the TCP connection to be established before failing.\n\n=item osdn-convert - If set to 1, URL for downloads from sourceforge are converted to use an appropriate mirror site.\n\n=item no-cache - If set to 1, Webmin's internal caching for this URL is disabled.\n\n=item headers - If set to a hash ref of additional HTTP headers, they will be added to the request.\n\n=cut\nsub http_download\n{\nmy ($host, $port, $page, $dest, $error, $cbfunc, $ssl, $user, $pass,\n    $timeout, $osdn, $nocache, $headers) = @_;\nif ($gconfig{'debug_what_net'}) {\n\t&webmin_debug_log('HTTP', \"host=$host port=$port page=$page ssl=$ssl\".\n\t\t\t\t  ($user ? \" user=$user pass=$pass\" : \"\").\n\t\t\t\t  (ref($dest) ? \"\" : \" dest=$dest\"));\n\t}\nif ($osdn) {\n\t# Convert OSDN URL first\n\tmy $prot = $ssl ? \"https://\" : \"http://\";\n\tmy $portstr = $ssl && $port == 443 ||\n\t\t\t !$ssl && $port == 80 ? \"\" : \":$port\";\n\t($host, $port, $page, $ssl) = &parse_http_url(\n\t\t&convert_osdn_url($prot.$host.$portstr.$page));\n\t}\n\n# Check if we already have cached the URL\nmy $url = ($ssl ? \"https://\" : \"http://\").$host.\":\".$port.$page;\nmy $cfile = &check_in_http_cache($url);\nif ($cfile && !$nocache) {\n\t# Yes! Copy to dest file or variable\n\t&$cbfunc(6, $url) if ($cbfunc);\n\tif (ref($dest)) {\n\t\t&open_readfile(CACHEFILE, $cfile);\n\t\tlocal $/ = undef;\n\t\t$$dest = <CACHEFILE>;\n\t\tclose(CACHEFILE);\n\t\t}\n\telse {\n\t\t&copy_source_dest($cfile, $dest);\n\t\t}\n\treturn;\n\t}\n\n# Build headers\nmy @headers;\npush(@headers, [ \"Host\", $host ]);\npush(@headers, [ \"User-agent\", \"Webmin\" ]);\npush(@headers, [ \"Accept-language\", \"en\" ]);\nif ($user) {\n\tmy $auth = &encode_base64(\"$user:$pass\");\n\t$auth =~ tr/\\r\\n//d;\n\tpush(@headers, [ \"Authorization\", \"Basic $auth\" ]);\n\t}\nforeach my $hname (keys %$headers) {\n\tpush(@headers, [ $hname, $headers->{$hname} ]);\n\t}\n\n# Actually download it\n$main::download_timed_out = undef;\nlocal $SIG{ALRM} = \\&download_timeout;\n$timeout = 60 if (!defined($timeout));\nalarm($timeout) if ($timeout);\nmy $h = &make_http_connection($host, $port, $ssl, \"GET\", $page, \\@headers);\nalarm(0) if ($timeout);\n$h = $main::download_timed_out if ($main::download_timed_out);\nif (!ref($h)) {\n\tif ($error) { $$error = $h; return; }\n\telse { &error(&html_escape($h)); }\n\t}\n&complete_http_download($h, $dest, $error, $cbfunc, $osdn, $host, $port,\n\t\t\t$headers, $ssl, $nocache, $timeout);\nif ((!$error || !$$error) && !$nocache) {\n\t&write_to_http_cache($url, $dest);\n\t}\n}\n\n=head2 complete_http_download(handle, destfile, [&error], [&callback], [osdn], [oldhost], [oldport], [&send-headers], [old-ssl], [no-cache], [timeout])\n\nDo a HTTP download, after the headers have been sent. For internal use only,\ntypically called by http_download.\n\n=cut\nsub complete_http_download\n{\nmy ($h, $destfile, $error, $cbfunc, $osdn, $oldhost, $oldport, $headers,\n    $oldssl, $nocache, $timeout) = @_;\nlocal ($line, %header, @headers, $s);  # Kept local so that callback funcs\n\t\t\t\t       # can access them.\n\n# read headers\n$timeout = 60 if (!defined($timeout));\nalarm($timeout) if ($timeout);\n($line = &read_http_connection($h)) =~ tr/\\r\\n//d;\nif ($line !~ /^HTTP\\/1\\..\\s+(200|30[0-9]|400)(\\s+|$)/) {\n\talarm(0) if ($timeout);\n\t&close_http_connection($h);\n\tif ($error) { ${$error} = $line; return; }\n\telse { &error(\"Download failed : \".&html_escape($line)); }\n\t}\nmy $rcode = $1;\n&$cbfunc(1, $rcode >= 300 && $rcode < 400 ? 1 : 0)\n\tif ($cbfunc);\nwhile(1) {\n\t$line = &read_http_connection($h);\n\t$line =~ tr/\\r\\n//d;\n\t$line =~ /^(\\S+):\\s*(.*)$/ || last;\n\t$header{lc($1)} = $2;\n\tpush(@headers, [ lc($1), $2 ]);\n\t}\nalarm(0) if ($timeout);\nif ($main::download_timed_out) {\n\t&close_http_connection($h);\n\tif ($error) { ${$error} = $main::download_timed_out; return 0; }\n\telse { &error($main::download_timed_out); }\n\t}\n&$cbfunc(2, $header{'content-length'}) if ($cbfunc);\nif ($rcode >= 300 && $rcode < 400) {\n\t# follow the redirect\n\t&$cbfunc(5, $header{'location'}) if ($cbfunc);\n\tmy ($host, $port, $page, $ssl);\n\tif ($header{'location'} =~ /^(http|https):\\/\\/([^:]+):(\\d+)(\\/.*)?$/) {\n\t\t$ssl = $1 eq 'https' ? 1 : 0;\n\t\t$host = $2;\n\t\t$port = $3;\n\t\t$page = $4 || \"/\";\n\t\t}\n\telsif ($header{'location'} =~ /^(http|https):\\/\\/([^:\\/]+)(\\/.*)?$/) {\n\t\t$ssl = $1 eq 'https' ? 1 : 0;\n\t\t$host = $2;\n\t\t$port = $ssl ? 443 : 80;\n\t\t$page = $3 || \"/\";\n\t\t}\n\telsif ($header{'location'} =~ /^\\// && $_[5]) {\n\t\t# Relative to same server\n\t\t$host = $_[5];\n\t\t$port = $_[6];\n\t\t$ssl = $_[8];\n\t\t$page = $header{'location'};\n\t\t}\n\telsif ($header{'location'}) {\n\t\t# Assume relative to same dir .. not handled\n\t\t&close_http_connection($h);\n\t\tif ($error) { ${$error} = \"Invalid Location header $header{'location'}\"; return; }\n\t\telse { &error(\"Invalid Location header \".\n\t\t\t      &html_escape($header{'location'})); }\n\t\t}\n\telse {\n\t\t&close_http_connection($h);\n\t\tif ($error) { ${$error} = \"Missing Location header\"; return; }\n\t\telse { &error(\"Missing Location header\"); }\n\t\t}\n\tmy $params;\n\t($page, $params) = split(/\\?/, $page);\n\t$page =~ s/ /%20/g;\n\t$page .= \"?\".$params if (defined($params));\n\t&http_download($host, $port, $page, $destfile, $error, $cbfunc, $ssl,\n\t\t       undef, undef, undef, $_[4], $_[9], $_[7]);\n\t}\nelse {\n\t# read data\n\tif (ref($destfile)) {\n\t\t# Append to a variable\n\t\twhile(defined($buf = &read_http_connection($h, 1024))) {\n\t\t\t${$destfile} .= $buf;\n\t\t\t&$cbfunc(3, length(${$destfile})) if ($cbfunc);\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Write to a file\n\t\tmy $got = 0;\n\t\tif (!&open_tempfile(PFILE, \">$destfile\", 1)) {\n\t\t\t&close_http_connection($h);\n\t\t\tif ($error) { ${$error} = \"Failed to write to $destfile : $!\"; return; }\n\t\t\telse { &error(\"Failed to write to \".&html_escape($destfile).\" : \".&html_escape(\"$!\")); }\n\t\t\t}\n\t\tbinmode(PFILE);\t\t# For windows\n\t\twhile(defined($buf = &read_http_connection($h, 1024))) {\n\t\t\t&print_tempfile(PFILE, $buf);\n\t\t\t$got += length($buf);\n\t\t\t&$cbfunc(3, $got) if ($cbfunc);\n\t\t\t}\n\t\t&close_tempfile(PFILE);\n\t\tif ($header{'content-length'} &&\n\t\t    $got != $header{'content-length'}) {\n\t\t\t&close_http_connection($h);\n\t\t\tif ($error) { ${$error} = \"Download incomplete\"; return; }\n\t\t\telse { &error(\"Download incomplete\"); }\n\t\t\t}\n\t\t}\n\t&$cbfunc(4) if ($cbfunc);\n\t}\n&close_http_connection($h);\n}\n\n\n=head2 http_post(host, port, page, content, destfile, [&error], [&callback], [sslmode], [user, pass], [timeout], [osdn-convert], [no-cache], [&headers])\n\nPosts data to an HTTP url and downloads the response to a local file or string. The parameters are :\n\n=item host - The hostname part of the URL, such as www.google.com\n\n=item port - The HTTP port number, such as 80\n\n=item page - The filename part of the URL, like /index.html\n\n=item content - The data to post\n\n=item destfile - The local file to save the URL data to, like /tmp/index.html. This can also be a scalar reference, in which case the data will be appended to that scalar.\n\n=item error - If set to a scalar ref, the function will store any error message in this scalar and return 0 on failure, or 1 on success. If not set, it will simply call the error function if the download fails.\n\n=item callback - If set to a function ref, it will be called after each block of data is received. This is typically set to \\&progress_callback, for printing download progress.\n\n=item sslmode - If set to 1, an HTTPS connection is used instead of HTTP.\n\n=item user - If set, HTTP authentication is done with this username.\n\n=item pass - The HTTP password to use with the username above.\n\n=item timeout - A timeout in seconds to wait for the TCP connection to be established before failing.\n\n=item osdn-convert - If set to 1, URL for downloads from sourceforge are converted to use an appropriate mirror site.\n\n=item no-cache - If set to 1, Webmin's internal caching for this URL is disabled.\n\n=item headers - If set to a hash ref of additional HTTP headers, they will be added to the request.\n\n=cut\nsub http_post\n{\nmy ($host, $port, $page, $content, $dest, $error, $cbfunc, $ssl, $user, $pass,\n    $timeout, $osdn, $nocache, $headers) = @_;\nif ($gconfig{'debug_what_net'}) {\n\t&webmin_debug_log('HTTP', \"host=$host port=$port page=$page ssl=$ssl\".\n\t\t\t\t  ($user ? \" user=$user pass=$pass\" : \"\").\n\t\t\t\t  (ref($dest) ? \"\" : \" dest=$dest\"));\n\t}\nif ($osdn) {\n\t# Convert OSDN URL first\n\tmy $prot = $ssl ? \"https://\" : \"http://\";\n\tmy $portstr = $ssl && $port == 443 ||\n\t\t\t !$ssl && $port == 80 ? \"\" : \":$port\";\n\t($host, $port, $page, $ssl) = &parse_http_url(\n\t\t&convert_osdn_url($prot.$host.$portstr.$page));\n\t}\n\n# Build headers\nmy @headers;\npush(@headers, [ \"Host\", $host ]);\npush(@headers, [ \"User-agent\", \"Webmin\" ]);\npush(@headers, [ \"Accept-language\", \"en\" ]);\npush(@headers, [ \"Content-type\", \"application/x-www-form-urlencoded\" ]);\nif (defined($content)) {\n\tpush(@headers, [ \"Content-length\", length($content) ]);\n\t}\nif ($user) {\n\tmy $auth = &encode_base64(\"$user:$pass\");\n\t$auth =~ tr/\\r\\n//d;\n\tpush(@headers, [ \"Authorization\", \"Basic $auth\" ]);\n\t}\nforeach my $hname (keys %$headers) {\n\tpush(@headers, [ $hname, $headers->{$hname} ]);\n\t}\n\n# Actually download it\n$main::download_timed_out = undef;\nlocal $SIG{ALRM} = \\&download_timeout;\n$timeout = 60 if (!defined($timeout));\nalarm($timeout) if ($timeout);\nmy $h = &make_http_connection($host, $port, $ssl, \"POST\", $page, \\@headers);\nalarm(0) if ($timeout);\n$h = $main::download_timed_out if ($main::download_timed_out);\nif (!ref($h)) {\n\tif ($error) { $$error = $h; return; }\n\telse { &error($h); }\n\t}\n&write_http_connection($h, $content.\"\\r\\n\");\n&complete_http_download($h, $dest, $error, $cbfunc, $osdn, $host, $port,\n\t\t\t$headers, $ssl, $nocache);\n}\n\n=head2 ftp_download(host, file, destfile, [&error], [&callback], [user, pass], [port], [no-cache])\n\nDownload data from an FTP site to a local file. The parameters are :\n\n=item host - FTP server hostname\n\n=item file - File on the FTP server to download\n\n=item destfile - File on the Webmin system to download data to\n\n=item error - If set to a string ref, any error message is written into this string and the function returns 0 on failure, 1 on success. Otherwise, error is called on failure.\n\n=item callback - If set to a function ref, it will be called after each block of data is received. This is typically set to \\&progress_callback, for printing download progress.\n\n=item user - Username to login to the FTP server as. If missing, Webmin will login as anonymous.\n\n=item pass - Password for the username above.\n\n=item port - FTP server port number, which defaults to 21 if not set.\n\n=item no-cache - If set to 1, Webmin's internal caching for this URL is disabled.\n\n=item timeout - Timeout for connections, defaults to 60s\n\n=cut\nsub ftp_download\n{\nmy ($host, $file, $dest, $error, $cbfunc, $user, $pass, $port, $nocache, $timeout) = @_;\n$port ||= 21;\n$timeout = 60 if (!defined($timeout));\nif ($gconfig{'debug_what_net'}) {\n\t&webmin_debug_log('FTP', \"host=$host port=$port file=$file\".\n\t\t\t\t ($user ? \" user=$user pass=$pass\" : \"\").\n\t\t\t\t (ref($dest) ? \"\" : \" dest=$dest\"));\n\t}\nmy ($buf, @n);\nif (&is_readonly_mode()) {\n\tif ($error) {\n\t\t$$error = \"FTP connections not allowed in readonly mode\";\n\t\treturn 0;\n\t\t}\n\telse {\n\t\t&error(\"FTP connections not allowed in readonly mode\");\n\t\t}\n\t}\n\n# Check if we already have cached the URL\nmy $url = \"ftp://\".$host.$file;\nmy $cfile = &check_in_http_cache($url);\nif ($cfile && !$nocache) {\n\t# Yes! Copy to dest file or variable\n\t&$cbfunc(6, $url) if ($cbfunc);\n\tif (ref($dest)) {\n\t\t&open_readfile(CACHEFILE, $cfile);\n\t\tlocal $/ = undef;\n\t\t$$dest = <CACHEFILE>;\n\t\tclose(CACHEFILE);\n\t\t}\n\telse {\n\t\t&copy_source_dest($cfile, $dest);\n\t\t}\n\treturn;\n\t}\n\n# Actually download it\n$main::download_timed_out = undef;\nlocal $SIG{ALRM} = \\&download_timeout;\nalarm($timeout) if ($timeout);\nmy $connected;\nif ($gconfig{'ftp_proxy'} =~ /^http:\\/\\/(\\S+):(\\d+)/ && !&no_proxy($_[0])) {\n\t# download through http-style proxy\n\tmy $error;\n\tif (&open_socket($1, $2, \"SOCK\", \\$error)) {\n\t\t# Connected OK\n\t\tif ($main::download_timed_out) {\n\t\t\talarm(0) if ($timeout);\n\t\t\tif ($error) {\n\t\t\t\t$$error = $main::download_timed_out;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&error($main::download_timed_out);\n\t\t\t\t}\n\t\t\t}\n\t\tmy $esc = $file; $esc =~ s/ /%20/g;\n\t\tmy $up = \"${user}:${pass}\\@\" if ($user);\n\t\tmy $portstr = $port == 21 ? \"\" : \":$port\";\n\t\tprint SOCK \"GET ftp://${up}${host}${portstr}${esc} HTTP/1.0\\r\\n\";\n\t\tprint SOCK \"User-agent: Webmin\\r\\n\";\n\t\tif ($gconfig{'proxy_user'}) {\n\t\t\tmy $auth = &encode_base64(\n\t\t\t   \"$gconfig{'proxy_user'}:$gconfig{'proxy_pass'}\");\n\t\t\t$auth =~ tr/\\r\\n//d;\n\t\t\tprint SOCK \"Proxy-Authorization: Basic $auth\\r\\n\";\n\t\t\t}\n\t\tprint SOCK \"\\r\\n\";\n\t\t&complete_http_download(\n\t\t\t{ 'fh' => \"SOCK\" }, $dest, $error, $cbfunc,\n\t\t\tundef, undef, undef, undef, 0, $nocache);\n\t\t$connected = 1;\n\t\t}\n\telsif (!$gconfig{'proxy_fallback'}) {\n\t\talarm(0) if ($timeout);\n\t\tif ($error) {\n\t\t\t$$error = $main::download_timed_out;\n\t\t\treturn 0;\n\t\t\t}\n\t\telse {\n\t\t\t&error($main::download_timed_out);\n\t\t\t}\n\t\t}\n\t}\n\nif (!$connected) {\n\t# connect to host and login with real FTP protocol\n\t&open_socket($host, $port, \"SOCK\", $_[3]) || return 0;\n\talarm(0) if ($timeout);\n\tif ($main::download_timed_out) {\n\t\tif ($error) {\n\t\t\t$$error = $main::download_timed_out;\n\t\t\treturn 0;\n\t\t\t}\n\t\telse {\n\t\t\t&error($main::download_timed_out);\n\t\t\t}\n\t\t}\n\t&ftp_command(\"\", 2, $error) || return 0;\n\tif ($user) {\n\t\t# Login as supplied user\n\t\tmy @urv = &ftp_command(\"USER $user\", [ 2, 3 ], $error);\n\t\t@urv || return 0;\n\t\tif (int($urv[1]/100) == 3) {\n\t\t\t&ftp_command(\"PASS $pass\", 2, $error) || return 0;\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Login as anonymous\n\t\tmy @urv = &ftp_command(\"USER anonymous\", [ 2, 3 ], $error);\n\t\t@urv || return 0;\n\t\tif (int($urv[1]/100) == 3) {\n\t\t\t&ftp_command(\"PASS root\\@\".&get_system_hostname(), 2,\n\t\t\t\t     $error) || return 0;\n\t\t\t}\n\t\t}\n\t&$cbfunc(1, 0) if ($cbfunc);\n\n\tif ($file) {\n\t\t# get the file size and tell the callback\n\t\t&ftp_command(\"TYPE I\", 2, $error) || return 0;\n\t\tmy $size = &ftp_command(\"SIZE $file\", 2, $error);\n\t\tdefined($size) || return 0;\n\t\tif ($cbfunc) {\n\t\t\t&$cbfunc(2, int($size));\n\t\t\t}\n\n\t\t# are we using IPv6?\n\t\tmy $v6 = !&to_ipaddress($host) &&\n\t\t\t &to_ip6address($host);\n\n\t\tif ($v6) {\n\t\t\t# request the file over a EPSV port\n\t\t\tmy $epsv = &ftp_command(\"EPSV\", 2, $error);\n\t\t\tdefined($epsv) || return 0;\n\t\t\t$epsv =~ /\\|(\\d+)\\|/ || return 0;\n\t\t\tmy $epsvport = $1;\n\t\t\t&open_socket($host, $epsvport, CON, $error) || return 0;\n\t\t\t}\n\t\telse {\n\t\t\t# request the file over a PASV connection\n\t\t\tmy $pasv = &ftp_command(\"PASV\", 2, $error);\n\t\t\tdefined($pasv) || return 0;\n\t\t\t$pasv =~ /\\(([0-9,]+)\\)/ || return 0;\n\t\t\t@n = split(/,/ , $1);\n\t\t\t&open_socket(\"$n[0].$n[1].$n[2].$n[3]\",\n\t\t\t\t$n[4]*256 + $n[5], \"CON\", $_[3]) || return 0;\n\t\t\t}\n\t\t&ftp_command(\"RETR $file\", 1, $error) || return 0;\n\n\t\t# transfer data\n\t\tmy $got = 0;\n\t\t&open_tempfile(PFILE, \">$dest\", 1);\n\t\twhile(read(CON, $buf, 1024) > 0) {\n\t\t\t&print_tempfile(PFILE, $buf);\n\t\t\t$got += length($buf);\n\t\t\t&$cbfunc(3, $got) if ($cbfunc);\n\t\t\t}\n\t\t&close_tempfile(PFILE);\n\t\tclose(CON);\n\t\tif ($got != $size) {\n\t\t\tif ($error) {\n\t\t\t\t$$error = \"Download incomplete\";\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t&error(\"Download incomplete\");\n\t\t\t\t}\n\t\t\t}\n\t\t&$cbfunc(4) if ($cbfunc);\n\n\t\t&ftp_command(\"\", 2, $error) || return 0;\n\t\t}\n\n\t# finish off..\n\t&ftp_command(\"QUIT\", 2, $error) || return 0;\n\tclose(SOCK);\n\t}\n\n&write_to_http_cache($url, $dest);\nreturn 1;\n}\n\n=head2 ftp_upload(host, file, srcfile, [&error], [&callback], [user, pass], [port])\n\nUpload data from a local file to an FTP site. The parameters are :\n\n=item host - FTP server hostname\n\n=item file - File on the FTP server to write to\n\n=item srcfile - File on the Webmin system to upload data from\n\n=item error - If set to a string ref, any error message is written into this string and the function returns 0 on failure, 1 on success. Otherwise, error is called on failure.\n\n=item callback - If set to a function ref, it will be called after each block of data is received. This is typically set to \\&progress_callback, for printing upload progress.\n\n=item user - Username to login to the FTP server as. If missing, Webmin will login as anonymous.\n\n=item pass - Password for the username above.\n\n=item port - FTP server port number, which defaults to 21 if not set.\n\n=cut\nsub ftp_upload\n{\nmy ($buf, @n);\nmy $cbfunc = $_[4];\nif (&is_readonly_mode()) {\n\tif ($_[3]) { ${$_[3]} = \"FTP connections not allowed in readonly mode\";\n\t\t     return 0; }\n\telse { &error(\"FTP connections not allowed in readonly mode\"); }\n\t}\n\n$main::download_timed_out = undef;\nlocal $SIG{ALRM} = \\&download_timeout;\nalarm(60);\n\n# connect to host and login\n&open_socket($_[0], $_[7] || 21, \"SOCK\", $_[3]) || return 0;\nalarm(0);\nif ($main::download_timed_out) {\n\tif ($_[3]) { ${$_[3]} = $main::download_timed_out; return 0; }\n\telse { &error($main::download_timed_out); }\n\t}\n&ftp_command(\"\", 2, $_[3]) || return 0;\nif ($_[5]) {\n\t# Login as supplied user\n\tmy @urv = &ftp_command(\"USER $_[5]\", [ 2, 3 ], $_[3]);\n\t@urv || return 0;\n\tif (int($urv[1]/100) == 3) {\n\t\tif (!&ftp_command(\"PASS $_[6]\", 2, $_[3])) {\n\t\t\t${$_[3]} =~ s/PASS\\s+\\S+/PASS \\*\\*\\*\\*\\*/ if ($_[3]);\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t# Login as anonymous\n\tmy @urv = &ftp_command(\"USER anonymous\", [ 2, 3 ], $_[3]);\n\t@urv || return 0;\n\tif (int($urv[1]/100) == 3) {\n\t\tif (!&ftp_command(\"PASS root\\@\".&get_system_hostname(), 2,\n\t\t\t\t  $_[3])) {\n\t\t\t${$_[3]} =~ s/PASS\\s+\\S+/PASS \\*\\*\\*\\*\\*/ if ($_[3]);\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n&$cbfunc(1, 0) if ($cbfunc);\n\n&ftp_command(\"TYPE I\", 2, $_[3]) || return 0;\n\n# get the file size and tell the callback\nmy @st = stat($_[2]);\nif ($cbfunc) {\n\t&$cbfunc(2, $st[7]);\n\t}\n\n# are we using IPv6?\nmy $v6 = !&to_ipaddress($_[0]) && &to_ip6address($_[0]);\n\nif ($v6) {\n\t# send the file over a EPSV port\n\tmy $epsv = &ftp_command(\"EPSV\", 2, $_[3]);\n\tdefined($epsv) || return 0;\n\t$epsv =~ /\\|(\\d+)\\|/ || return 0;\n\tmy $epsvport = $1;\n\t&open_socket($_[0], $epsvport, \"CON\", $_[3]) || return 0;\n\t}\nelse {\n\t# send the file over a PASV connection\n\tmy $pasv = &ftp_command(\"PASV\", 2, $_[3]);\n\tdefined($pasv) || return 0;\n\t$pasv =~ /\\(([0-9,]+)\\)/ || return 0;\n\t@n = split(/,/ , $1);\n\t&open_socket(\"$n[0].$n[1].$n[2].$n[3]\", $n[4]*256 + $n[5], \"CON\", $_[3]) || return 0;\n\t}\n&ftp_command(\"STOR $_[1]\", 1, $_[3]) || return 0;\n\n# transfer data\nmy $got;\nopen(PFILE, $_[2]);\nwhile(read(PFILE, $buf, 1024) > 0) {\n\tprint CON $buf;\n\t$got += length($buf);\n\t&$cbfunc(3, $got) if ($cbfunc);\n\t}\nclose(PFILE);\nclose(CON);\nif ($got != $st[7]) {\n\tif ($_[3]) { ${$_[3]} = \"Upload incomplete\"; return 0; }\n\telse { &error(\"Upload incomplete\"); }\n\t}\n&$cbfunc(4) if ($cbfunc);\n\n# finish off..\n&ftp_command(\"\", 2, $_[3]) || return 0;\n&ftp_command(\"QUIT\", 2, $_[3]) || return 0;\nclose(SOCK);\n\nreturn 1;\n}\n\n=head2 no_proxy(host)\n\nChecks if some host is on the no proxy list. For internal use by the\nhttp_download and ftp_download functions.\n\n=cut\nsub no_proxy\n{\nmy $ip = &to_ipaddress($_[0]);\nforeach my $n (split(/\\s+/, $gconfig{'noproxy'})) {\n\treturn 1 if ($_[0] =~ /\\Q$n\\E/ ||\n\t\t     $ip =~ /\\Q$n\\E/);\n\t}\nreturn 0;\n}\n\n=head2 open_socket(host, port, handle, [&error])\n\nOpen a TCP connection to some host and port, using a file handle. The\nparameters are :\n\n=item host - Hostname or IP address to connect to.\n\n=item port - TCP port number.\n\n=item handle - A file handle name to use for the connection.\n\n=item error - A string reference to write any error message into. If not set, the error function is called on failure.\n\n=item bindip - Local IP address to bind to for outgoing connections\n\n=cut\nsub open_socket\n{\nmy ($host, $port, $fh, $err, $bindip) = @_;\n$fh = &callers_package($fh);\n$bindip ||= $gconfig{'bind_proxy'};\n\nif ($gconfig{'debug_what_net'}) {\n\t&webmin_debug_log('TCP', \"host=$host port=$port\");\n\t}\n\n# Lookup IP address for the host. Try v4 first, and failing that v6\nmy $ip;\nmy $proto = getprotobyname(\"tcp\");\nif ($ip = &to_ipaddress($host)) {\n\t# Create IPv4 socket and connection\n\tif (!socket($fh, PF_INET(), SOCK_STREAM, $proto)) {\n\t\tmy $msg = \"Failed to create socket : $!\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\tmy $addr = inet_aton($ip);\n\tif ($gconfig{'bind_proxy'}) {\n\t\t# BIND to outgoing IP\n\t\tif (!bind($fh, pack_sockaddr_in(0, inet_aton($bindip)))) {\n\t\t\tmy $msg = \"Failed to bind to source address : $!\";\n\t\t\tif ($err) { $$err = $msg; return 0; }\n\t\t\telse { &error($msg); }\n\t\t\t}\n\t\t}\n\tif (!connect($fh, pack_sockaddr_in($port, $addr))) {\n\t\tmy $msg = \"Failed to connect to $host:$port : $!\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\t}\nelsif ($ip = &to_ip6address($host)) {\n\t# Create IPv6 socket and connection\n\tif (!&supports_ipv6()) {\n\t\t$msg = \"IPv6 connections are not supported\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\tif (!socket($fh, PF_INET6(), SOCK_STREAM, $proto)) {\n\t\tmy $msg = \"Failed to create IPv6 socket : $!\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\tmy $addr = inet_pton(AF_INET6(), $ip);\n\tif (!connect($fh, pack_sockaddr_in6($port, $addr))) {\n\t\tmy $msg = \"Failed to IPv6 connect to $host:$port : $!\";\n\t\tif ($err) { $$err = $msg; return 0; }\n\t\telse { &error($msg); }\n\t\t}\n\t}\nelse {\n\t# Resolution failed\n\tmy $msg = \"Failed to lookup IP address for $host\";\n\tif ($err) { $$err = $msg; return 0; }\n\telse { &error($msg); }\n\t}\n\n# Disable buffering\nmy $old = select($fh);\n$| = 1;\nselect($old);\nreturn 1;\n}\n\n=head2 download_timeout\n\nCalled when a download times out. For internal use only.\n\n=cut\nsub download_timeout\n{\n$main::download_timed_out = \"Download timed out\";\n}\n\n=head2 ftp_command(command, expected, [&error], [filehandle])\n\nSend an FTP command, and die if the reply is not what was expected. Mainly\nfor internal use by the ftp_download and ftp_upload functions.\n\n=cut\nsub ftp_command\n{\nmy ($cmd, $expect, $err, $fh) = @_;\n$fh ||= \"SOCK\";\n$fh = &callers_package($fh);\n\nmy $line;\nmy $what = $cmd ne \"\" ? \"<i>$cmd</i>\" : \"initial connection\";\nif ($cmd ne \"\") {\n        print $fh \"$cmd\\r\\n\";\n        }\nalarm(60);\nif (!($line = <$fh>)) {\n\talarm(0);\n\tif ($err) { $$err = \"Failed to read reply to $what\"; return undef; }\n\telse { &error(\"Failed to read reply to $what\"); }\n        }\n$line =~ /^(...)(.)(.*)$/;\nmy $found = 0;\nif (ref($expect)) {\n\tforeach my $c (@$expect) {\n\t\t$found++ if (int($1/100) == $c);\n\t\t}\n\t}\nelse {\n\t$found++ if (int($1/100) == $_[1]);\n\t}\nif (!$found) {\n\talarm(0);\n\tif ($err) { $$err = \"$what failed : $3\"; return undef; }\n\telse { &error(\"$what failed : $3\"); }\n\t}\nmy $rcode = $1;\nmy $reply = $3;\nif ($2 eq \"-\") {\n        # Need to skip extra stuff..\n        while(1) {\n                if (!($line = <$fh>)) {\n\t\t\talarm(0);\n\t\t\tif ($err) { $$err = \"Failed to read reply to $what\";\n\t\t\t\t     return undef; }\n\t\t\telse { &error(\"Failed to read reply to $what\"); }\n                        }\n                $line =~ /^(....)(.*)$/; $reply .= $2;\n\t\tif ($1 eq \"$rcode \") { last; }\n                }\n        }\nalarm(0);\nreturn wantarray ? ($reply, $rcode) : $reply;\n}\n\n=head2 to_ipaddress(hostname)\n\nConverts a hostname to an a.b.c.d format IP address, or returns undef if\nit cannot be resolved.\n\n=cut\nsub to_ipaddress\n{\nif (&check_ipaddress($_[0])) {\n\treturn $_[0];\t# Already in v4 format\n\t}\nelsif (&check_ip6address($_[0])) {\n\treturn undef;\t# A v6 address cannot be converted to v4\n\t}\nelse {\n\tmy $hn = gethostbyname($_[0]);\n\treturn undef if (!$hn);\n\tlocal @ip = unpack(\"CCCC\", $hn);\n\treturn join(\".\" , @ip);\n\t}\n}\n\n=head2 to_ip6address(hostname)\n\nConverts a hostname to IPv6 address, or returns undef if it cannot be resolved.\n\n=cut\nsub to_ip6address\n{\nif (&check_ip6address($_[0])) {\n\treturn $_[0];\t# Already in v6 format\n\t}\nelsif (&check_ipaddress($_[0])) {\n\treturn undef;\t# A v4 address cannot be v6\n\t}\nelsif (!&supports_ipv6()) {\n\treturn undef;\t# Cannot lookup\n\t}\nelse {\n\t# Perform IPv6 DNS lookup\n\tmy $inaddr;\n\t(undef, undef, undef, $inaddr) =\n\t    getaddrinfo($_[0], undef, AF_INET6(), SOCK_STREAM);\n\treturn undef if (!$inaddr);\n\tmy $addr;\n\t(undef, $addr) = unpack_sockaddr_in6($inaddr);\n\treturn inet_ntop(AF_INET6(), $addr);\n\t}\n}\n\n=head2 to_hostname(ipv4|ipv6-address)\n\nReverse-resolves an IPv4 or 6 address to a hostname\n\n=cut\nsub to_hostname\n{\nmy ($addr) = @_;\nif (&check_ip6address($addr) && &supports_ipv6()) {\n\treturn gethostbyaddr(inet_pton(AF_INET6(), $addr), AF_INET6());\n\t}\nelse {\n\treturn gethostbyaddr(inet_aton($addr), AF_INET);\n\t}\n}\n\n=head2 icons_table(&links, &titles, &icons, [columns], [href], [width], [height], &befores, &afters)\n\nRenders a 4-column table of icons. The useful parameters are :\n\n=item links - An array ref of link destination URLs for the icons.\n\n=item titles - An array ref of titles to appear under the icons.\n\n=item icons - An array ref of URLs for icon images.\n\n=item columns - Number of columns to layout the icons with. Defaults to 4.\n\n=cut\nsub icons_table\n{\n&load_theme_library();\nif (defined(&theme_icons_table)) {\n\t&theme_icons_table(@_);\n\treturn;\n\t}\nmy $need_tr;\nmy $cols = $_[3] ? $_[3] : 4;\nmy $per = int(100.0 / $cols);\nprint \"<table class='icons_table' width='100%' cellpadding='5'>\\n\";\nfor(my $i=0; $i<@{$_[0]}; $i++) {\n\tif ($i%$cols == 0) { print \"<tr>\\n\"; }\n\tprint \"<td width='$per%' align='center' valign='top'>\\n\";\n\t&generate_icon($_[2]->[$i], $_[1]->[$i], $_[0]->[$i],\n\t\t       ref($_[4]) ? $_[4]->[$i] : $_[4], $_[5], $_[6],\n\t\t       $_[7]->[$i], $_[8]->[$i]);\n\tprint \"</td>\\n\";\n        if ($i%$cols == $cols-1) { print \"</tr>\\n\"; }\n        }\nwhile($i++%$cols) { print \"<td width='$per%'></td>\\n\"; $need_tr++; }\nprint \"</tr>\\n\" if ($need_tr);\nprint \"</table>\\n\";\n}\n\n=head2 replace_meta($string)\n\nReplaces all occurrences of meta words\n\n=item string - String value to search/replace in\n\n=cut\nsub replace_meta\n{\n  my ($string) = @_;\n\n  my $hostname   = &get_display_hostname();\n  my $version    = &get_webmin_version();\n  my $os_type    = $gconfig{'real_os_type'} || $gconfig{'os_type'};\n  my $os_version = $gconfig{'real_os_version'} || $gconfig{'os_version'};\n  $string =~ s/%HOSTNAME%/$hostname/g;\n  $string =~ s/%VERSION%/$version/g;\n  $string =~ s/%USER%/$remote_user/g;\n  $string =~ s/%OS%/$os_type $os_version/g;\n\n  return $string;\n}\n\n=head2 replace_file_line(file, line, [newline]*)\n\nReplaces one line in some file with 0 or more new lines. The parameters are :\n\n=item file - Full path to some file, like /etc/hosts.\n\n=item line - Line number to replace, starting from 0.\n\n=item newline - Zero or more lines to put into the file at the given line number. These must be newline-terminated strings.\n\n=cut\nsub replace_file_line\n{\nmy @lines;\nmy $realfile = &translate_filename($_[0]);\nopen(FILE, $realfile);\n@lines = <FILE>;\nclose(FILE);\nif (@_ > 2) { splice(@lines, $_[1], 1, @_[2..$#_]); }\nelse { splice(@lines, $_[1], 1); }\n&open_tempfile(FILE, \">$realfile\");\n&print_tempfile(FILE, @lines);\n&close_tempfile(FILE);\n}\n\n=head2 read_file_lines(file, [readonly])\n\nReturns a reference to an array containing the lines from some file. This\narray can be modified, and will be written out when flush_file_lines()\nis called. The parameters are :\n\n=item file - Full path to the file to read.\n\n=item readonly - Should be set 1 if the caller is only going to read the lines, and never write it out.\n\nExample code :\n\n $lref = read_file_lines(\"/etc/hosts\");\n push(@$lref, \"127.0.0.1 localhost\");\n flush_file_lines(\"/etc/hosts\");\n\n=cut\nsub read_file_lines\n{\nmy ($file, $readonly) = @_;\nif (!$file) {\n\tmy ($package, $filename, $line) = caller;\n\t&error(\"Missing file to read at ${package}::${filename} line $line\");\n\t}\nmy $realfile = &translate_filename($file);\nif (!$main::file_cache{$realfile}) {\n        my (@lines, $eol);\n\tlocal $_;\n\t&webmin_debug_log('READ', $file) if ($gconfig{'debug_what_read'});\n        open(READFILE, $realfile);\n        while(<READFILE>) {\n\t\tif (!$eol) {\n\t\t\t$eol = /\\r\\n$/ ? \"\\r\\n\" : \"\\n\";\n\t\t\t}\n                tr/\\r\\n//d;\n                push(@lines, $_);\n                }\n        close(READFILE);\n        $main::file_cache{$realfile} = \\@lines;\n\t$main::file_cache_noflush{$realfile} = $readonly;\n\t$main::file_cache_eol{$realfile} = $eol || \"\\n\";\n        }\nelse {\n\t# Make read-write if currently readonly\n\tif (!$readonly) {\n\t\t$main::file_cache_noflush{$realfile} = 0;\n\t\t}\n\t}\nreturn $main::file_cache{$realfile};\n}\n\n=head2 flush_file_lines([file], [eol], [ignore-unloaded])\n\nWrite out to a file previously read by read_file_lines to disk (except\nfor those marked readonly). The parameters are :\n\n=item file - The file to flush out.\n\n=item eof - End-of-line character for each line. Defaults to \\n.\n\n=item ignore-unloaded - Don't fail if the file isn't loaded\n\n=cut\nsub flush_file_lines\n{\nmy ($file, $eof, $ignore) = @_;\nmy @files;\nif ($file) {\n\tlocal $trans = &translate_filename($file);\n\tif (!$main::file_cache{$trans}) {\n\t\tif ($ignore) {\n\t\t\treturn 0;\n\t\t\t}\n\t\telse {\n\t\t\t&error(\"flush_file_lines called on non-loaded file $trans\");\n\t\t\t}\n\t\t}\n\tpush(@files, $trans);\n\t}\nelse {\n\t@files = ( keys %main::file_cache );\n\t}\nforeach my $f (@files) {\n\tmy $eol = $eof || $main::file_cache_eol{$f} || \"\\n\";\n\tif (!$main::file_cache_noflush{$f}) {\n\t\tno warnings; # XXX Bareword file handles should go away\n\t\t&open_tempfile(FLUSHFILE, \">$f\");\n\t\tforeach my $line (@{$main::file_cache{$f}}) {\n\t\t\t(print FLUSHFILE $line,$eol) ||\n\t\t\t\t&error(&text(\"efilewrite\", $f, $!));\n\t\t\t}\n\t\t&close_tempfile(FLUSHFILE);\n\t\t}\n\tdelete($main::file_cache{$f});\n\tdelete($main::file_cache_noflush{$f});\n        }\nreturn scalar(@files);\n}\n\n=head2 unflush_file_lines(file)\n\nClear the internal cache of some given file, previously read by read_file_lines.\n\n=cut\nsub unflush_file_lines\n{\nmy $realfile = &translate_filename($_[0]);\ndelete($main::file_cache{$realfile});\ndelete($main::file_cache_noflush{$realfile});\n}\n\n=head2 unix_user_input(fieldname, user, [form])\n\nReturns HTML for an input to select a Unix user. By default this is a text\nbox with a user popup button next to it.\n\n=cut\nsub unix_user_input\n{\nif (defined(&theme_unix_user_input)) {\n\treturn &theme_unix_user_input(@_);\n\t}\nreturn \"<input name=$_[0] size=13 value=\\\"$_[1]\\\"> \".\n       &user_chooser_button($_[0], 0, $_[2] || 0).\"\\n\";\n}\n\n=head2 unix_group_input(fieldname, user, [form])\n\nReturns HTML for an input to select a Unix group. By default this is a text\nbox with a group popup button next to it.\n\n=cut\nsub unix_group_input\n{\nif (defined(&theme_unix_group_input)) {\n\treturn &theme_unix_group_input(@_);\n\t}\nreturn \"<input name='$_[0]' size=13 value=\\\"$_[1]\\\"> \".\n       &group_chooser_button($_[0], 0, $_[2] || 0).\"\\n\";\n}\n\n=head2 hlink(text, page, [module], [width], [height])\n\nReturns HTML for a link that when clicked on pops up a window for a Webmin\nhelp page. The parameters are :\n\n=item text - Text for the link.\n\n=item page - Help page code, such as 'intro'.\n\n=item module - Module the help page is in. Defaults to the current module.\n\n=item width - Width of the help popup window. Defaults to 600 pixels.\n\n=item height - Height of the help popup window. Defaults to 400 pixels.\n\nThe actual help pages are in each module's help sub-directory, in files with\n.html extensions.\n\n=cut\nsub hlink\n{\nif (defined(&theme_hlink)) {\n\treturn &theme_hlink(@_);\n\t}\nmy $mod = $_[2] ? $_[2] : &get_module_name();\nmy $width = $_[3] || $tconfig{'help_width'} || $gconfig{'help_width'} || 600;\nmy $height = $_[4] || $tconfig{'help_height'} || $gconfig{'help_height'} || 400;\nreturn \"<a onClick='window.open(\\\"$gconfig{'webprefix'}/help.cgi/$mod/$_[1]\\\", \\\"help\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,width=$width,height=$height,resizable=yes\\\"); return false' href=\\\"$gconfig{'webprefix'}/help.cgi/$mod/$_[1]\\\">$_[0]</a>\";\n}\n\n=head2 user_chooser_button(field, multiple, [form])\n\nReturns HTML for a javascript button for choosing a Unix user or users.\nThe parameters are :\n\n=item field - Name of the HTML field to place the username into.\n\n=item multiple - Set to 1 if multiple users can be selected.\n\n=item form - Index of the form on the page.\n\n=cut\nsub user_chooser_button\n{\nreturn undef if (!&supports_users());\nreturn &theme_user_chooser_button(@_)\n\tif (defined(&theme_user_chooser_button));\nmy $form = defined($_[2]) ? $_[2] : 0;\nmy $w = $_[1] ? 500 : 300;\nmy $h = 200;\nif ($_[1] && $gconfig{'db_sizeusers'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizeusers'});\n\t}\nelsif (!$_[1] && $gconfig{'db_sizeuser'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizeuser'});\n\t}\nreturn \"<input type=button onClick='ifield = form.$_[0]; chooser = window.open(\\\"$gconfig{'webprefix'}/user_chooser.cgi?multi=$_[1]&user=\\\"+escape(ifield.value), \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,resizable=yes,width=$w,height=$h\\\"); chooser.ifield = ifield; window.ifield = ifield' value=\\\"...\\\">\\n\";\n}\n\n=head2 group_chooser_button(field, multiple, [form])\n\nReturns HTML for a javascript button for choosing a Unix group or groups\nThe parameters are :\n\n=item field - Name of the HTML field to place the group name into.\n\n=item multiple - Set to 1 if multiple groups can be selected.\n\n=item form - Index of the form on the page.\n\n=cut\nsub group_chooser_button\n{\nreturn undef if (!&supports_users());\nreturn &theme_group_chooser_button(@_)\n\tif (defined(&theme_group_chooser_button));\nmy $form = defined($_[2]) ? $_[2] : 0;\nmy $w = $_[1] ? 500 : 300;\nmy $h = 200;\nif ($_[1] && $gconfig{'db_sizeusers'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizeusers'});\n\t}\nelsif (!$_[1] && $gconfig{'db_sizeuser'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizeuser'});\n\t}\nreturn \"<input type=button onClick='ifield = form.$_[0]; chooser = window.open(\\\"$gconfig{'webprefix'}/group_chooser.cgi?multi=$_[1]&group=\\\"+escape(ifield.value), \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,resizable=yes,width=$w,height=$h\\\"); chooser.ifield = ifield; window.ifield = ifield' value=\\\"...\\\">\\n\";\n}\n\n=head2 foreign_check(module, [api-only])\n\nChecks if some other module exists and is supported on this OS. The parameters\nare :\n\n=item module - Name of the module to check.\n\n=item api-only - Set to 1 if you just want to check if the module provides an API that others can call, instead of the full web UI.\n\n=cut\nsub foreign_check\n{\nmy ($mod, $api) = @_;\nmy %minfo;\nmy $mdir = &module_root_directory($mod);\n&read_file_cached(\"$mdir/module.info\", \\%minfo) || return 0;\nreturn &check_os_support(\\%minfo, undef, undef, $api);\n}\n\n=head2 foreign_exists(module)\n\nChecks if some other module exists. The module parameter is the short module\nname.\n\n=cut\nsub foreign_exists\n{\nmy $mdir = &module_root_directory($_[0]);\nreturn -r \"$mdir/module.info\";\n}\n\n=head2 foreign_available(module)\n\nReturns 1 if some module is installed, and acessible to the current user. The\nmodule parameter is the module directory name.\n\n=cut\nsub foreign_available\n{\nreturn 0 if (!&foreign_check($_[0]) &&\n\t     !$gconfig{'available_even_if_no_support'});\nmy %foreign_module_info = &get_module_info($_[0]);\n\n# Check list of allowed modules\nmy %acl;\n&read_acl(\\%acl, undef, [ $base_remote_user ]);\nreturn 0 if (!$acl{$base_remote_user,$_[0]} &&\n\t     !$acl{$base_remote_user,'*'});\n\n# Check for usermod restrictions\nmy @usermods = &list_usermods();\nreturn 0 if (!&available_usermods( [ \\%foreign_module_info ], \\@usermods));\n\nif (&get_product_name() eq \"webmin\") {\n\t# Check if the user has any RBAC privileges in this module\n\tif (&supports_rbac($_[0]) &&\n\t    &use_rbac_module_acl(undef, $_[0])) {\n\t\t# RBAC is enabled for this user and module - check if he\n\t\t# has any rights\n\t\tmy $rbacs = &get_rbac_module_acl($remote_user, $_[0]);\n\t\treturn 0 if (!$rbacs);\n\t\t}\n\telsif ($gconfig{'rbacdeny_'.$base_remote_user}) {\n\t\t# If denying access to modules not specifically allowed by\n\t\t# RBAC, then prevent access\n\t\treturn 0;\n\t\t}\n\t}\n\n# Check readonly support\nif (&is_readonly_mode()) {\n\treturn 0 if (!$foreign_module_info{'readonly'});\n\t}\n\n# Check if theme vetos\nif (defined(&theme_foreign_available)) {\n\treturn 0 if (!&theme_foreign_available($_[0]));\n\t}\n\n# Check if licence module vetos\nif ($main::licence_module) {\n\treturn 0 if (!&foreign_call($main::licence_module,\n\t\t\t\t    \"check_module_licence\", $_[0]));\n\t}\n\nreturn 1;\n}\n\n=head2 foreign_require(module, [file], [package])\n\nBrings in functions from another module, and places them in the Perl namespace\nwith the same name as the module. The parameters are :\n\n=item module - The source module's directory name, like sendmail.\n\n=item file - The API file in that module, like sendmail-lib.pl. If missing, all API files are loaded.\n\n=item package - Perl package to place the module's functions and global variables in.\n\nIf the original module name contains dashes, they will be replaced with _ in\nthe package name.\n\n=cut\nsub foreign_require\n{\nmy ($mod, $file, $pkg) = @_;\n$pkg ||= $mod || \"global\";\n$pkg =~ s/[^A-Za-z0-9]/_/g;\nmy @files;\nif ($file) {\n\tpush(@files, $file);\n\t}\nelse {\n\t# Auto-detect files\n\tmy %minfo = &get_module_info($mod);\n\tif ($minfo{'library'}) {\n\t\t@files = split(/\\s+/, $minfo{'library'});\n\t\t}\n\telse {\n\t\t@files = ( ($minfo{'cloneof'} || $mod).\"-lib.pl\" );\n\t\t}\n\t}\n@files = grep { !$main::done_foreign_require{$pkg,$_} } @files;\nreturn 1 if (!@files);\nforeach my $f (@files) {\n\t$main::done_foreign_require{$pkg,$f}++;\n\t}\nmy @OLDINC = @INC;\nmy $mdir = &module_root_directory($mod);\n$mdir =~ /^(.*)$/; # untaint, part 1\n$mdir = $1; \t   # untaint, part 2\n@INC = &unique($mdir, @INC);\n-d $mdir || &error(\"Module $mod does not exist\");\nif (!&get_module_name() && $mod) {\n\tchdir($mdir);\n\t}\nmy $old_fmn = $ENV{'FOREIGN_MODULE_NAME'};\nmy $old_frd = $ENV{'FOREIGN_ROOT_DIRECTORY'};\nmy $code = \"package $pkg; \".\n\t   \"\\$ENV{'FOREIGN_MODULE_NAME'} = '$mod'; \".\n\t   \"\\$ENV{'FOREIGN_ROOT_DIRECTORY'} = '$root_directory'; \";\nforeach my $f (@files) {\n\t$code .= \"do '$mdir/$f' || die \\$@; \";\n\t}\neval $code;\nif (defined($old_fmn)) {\n\t$ENV{'FOREIGN_MODULE_NAME'} = $old_fmn;\n\t}\nelse {\n\tdelete($ENV{'FOREIGN_MODULE_NAME'});\n\t}\nif (defined($old_frd)) {\n\t$ENV{'FOREIGN_ROOT_DIRECTORY'} = $old_frd;\n\t}\nelse {\n\tdelete($ENV{'FOREIGN_ROOT_DIRECTORY'});\n\t}\n@INC = @OLDINC;\nif ($@) { &error(\"Require $mod/$files[0] failed : <pre>$@</pre>\"); }\nreturn 1;\n}\n\n=head2 foreign_call(module, function, [arg]*)\n\nCall a function in another module. The module parameter is the target module\ndirectory name, function is the perl sub to call, and the remaining parameters\nare the arguments. However, unless you need to call a function whose name\nis dynamic, it is better to use Perl's cross-module function call syntax\nlike module::function(args).\n\n=cut\nsub foreign_call\n{\nmy $pkg = $_[0] || \"global\";\n$pkg =~ s/[^A-Za-z0-9]/_/g;\nmy @args = @_[2 .. @_-1];\n$main::foreign_args = \\@args;\nmy @rv = eval <<EOF;\npackage $pkg;\n&$_[1](\\@{\\$main::foreign_args});\nEOF\nif ($@) { &error(\"$_[0]::$_[1] failed : $@\"); }\nreturn wantarray ? @rv : $rv[0];\n}\n\n=head2 foreign_config(module, [user-config])\n\nGet the configuration from another module, and return it as a hash. If the\nuser-config parameter is set to 1, returns the Usermin user-level preferences\nfor the current user instead.\n\n=cut\nsub foreign_config\n{\nmy ($mod, $uc) = @_;\nmy %fconfig;\nif ($uc) {\n\t&read_file_cached(\"$root_directory/$mod/defaultuconfig\", \\%fconfig);\n\t&read_file_cached(\"$config_directory/$mod/uconfig\", \\%fconfig);\n\t&read_file_cached(\"$user_config_directory/$mod/config\", \\%fconfig);\n\t}\nelse {\n\t&read_file_cached(\"$config_directory/$mod/config\", \\%fconfig);\n\t}\nreturn %fconfig;\n}\n\n=head2 foreign_installed(module, mode)\n\nChecks if the server for some module is installed, and possibly also checks\nif the module has been configured by Webmin.\nFor mode 1, returns 2 if the server is installed and configured for use by\nWebmin, 1 if installed but not configured, or 0 otherwise.\nFor mode 0, returns 1 if installed, 0 if not.\nIf the module does not provide an install_check.pl script, assumes that\nthe server is installed.\n\n=cut\nsub foreign_installed\n{\nmy ($mod, $configured) = @_;\nif (defined($main::foreign_installed_cache{$mod,$configured})) {\n\t# Already cached..\n\treturn $main::foreign_installed_cache{$mod,$configured};\n\t}\nelse {\n\tmy $rv;\n\tif (!&foreign_check($mod)) {\n\t\t# Module is missing\n\t\t$rv = 0;\n\t\t}\n\telse {\n\t\tmy $mdir = &module_root_directory($mod);\n\t\tif (!-r \"$mdir/install_check.pl\") {\n\t\t\t# Not known, assume OK\n\t\t\t$rv = $configured ? 2 : 1;\n\t\t\t}\n\t\telse {\n\t\t\t# Call function to check\n\t\t\t&foreign_require($mod, \"install_check.pl\");\n\t\t\t$rv = &foreign_call($mod, \"is_installed\", $configured);\n\t\t\t}\n\t\t}\n\t$main::foreign_installed_cache{$mod,$configured} = $rv;\n\treturn $rv;\n\t}\n}\n\n=head2 foreign_defined(module, function)\n\nReturns 1 if some function is defined in another module. In general, it is\nsimpler to use the syntax &defined(module::function) instead.\n\n=cut\nsub foreign_defined\n{\nmy ($pkg) = @_;\n$pkg =~ s/[^A-Za-z0-9]/_/g;\nmy $func = \"${pkg}::$_[1]\";\nreturn defined(&$func);\n}\n\n=head2 get_system_hostname([short], [skip-file])\n\nReturns the hostname of this system. If the short parameter is set to 1,\nthen the domain name is not prepended - otherwise, Webmin will attempt to get\nthe fully qualified hostname, like foo.example.com.\n\n=cut\nsub get_system_hostname\n{\nmy $m = int($_[0]);\nmy $skipfile = $_[1];\nif (!$main::get_system_hostname[$m]) {\n\tif ($gconfig{'os_type'} ne 'windows') {\n\t\t# Try some common Linux hostname files first\n\t\tmy $fromfile;\n\t\tif ($skipfile) {\n\t\t\t# Never get from file\n\t\t\t}\n\t\telsif ($gconfig{'os_type'} eq 'redhat-linux') {\n\t\t\tmy %nc;\n\t\t\t&read_env_file(\"/etc/sysconfig/network\", \\%nc);\n\t\t\tif ($nc{'HOSTNAME'}) {\n\t\t\t\t$fromfile = $nc{'HOSTNAME'};\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tmy $hn = &read_file_contents(\"/etc/hostname\");\n\t\t\t\tif ($hn) {\n\t\t\t\t\t$hn =~ s/\\r|\\n//g;\n\t\t\t\t\t$fromfile = $hn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($gconfig{'os_type'} eq 'debian-linux') {\n\t\t\tmy $hn = &read_file_contents(\"/etc/hostname\");\n\t\t\tif ($hn) {\n\t\t\t\t$hn =~ s/\\r|\\n//g;\n\t\t\t\t$fromfile = $hn;\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($gconfig{'os_type'} eq 'open-linux') {\n\t\t\tmy $hn = &read_file_contents(\"/etc/HOSTNAME\");\n\t\t\tif ($hn) {\n\t\t\t\t$hn =~ s/\\r|\\n//g;\n\t\t\t\t$fromfile = $hn;\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($gconfig{'os_type'} eq 'solaris') {\n\t\t\tmy $hn = &read_file_contents(\"/etc/nodename\");\n\t\t\tif ($hn) {\n\t\t\t\t$hn =~ s/\\r|\\n//g;\n\t\t\t\t$fromfile = $hn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t# Append domain name from DNS config if needed\n\t\tif ($fromfile && $fromfile !~ /\\./) {\n\t\t\tmy $lref = &read_file_lines(\"/etc/resolv.conf\", 1);\n\t\t\tforeach my $l (@$lref) {\n\t\t\t\tif ($l =~ /^(search|domain)\\s+(\\S+)/) {\n\t\t\t\t\t$dname = $2;\n\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t$fromfile .= \".\".$dname;\n\t\t\t}\n\n\t\t# If we found a hostname in a file, use it\n\t\tif ($fromfile && ($m || $fromfile =~ /\\./)) {\n\t\t\tif ($m) {\n\t\t\t\t$fromfile =~ s/\\..*$//;\n\t\t\t\t}\n\t\t\t$main::get_system_hostname[$m] = $fromfile;\n\t\t\treturn $fromfile;\n\t\t\t}\n\n\t\t# Can use hostname command on Unix\n\t\t&execute_command(\"hostname\", undef,\n\t\t\t\t \\$main::get_system_hostname[$m], undef, 0, 1);\n\t\tchop($main::get_system_hostname[$m]);\n\t\tif ($?) {\n\t\t\teval \"use Sys::Hostname\";\n\t\t\tif (!$@) {\n\t\t\t\t$main::get_system_hostname[$m] = eval \"hostname()\";\n\t\t\t\t}\n\t\t\tif ($@ || !$main::get_system_hostname[$m]) {\n\t\t\t\t$main::get_system_hostname[$m] = \"UNKNOWN\";\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($main::get_system_hostname[$m] !~ /\\./ &&\n\t\t       $gconfig{'os_type'} =~ /linux$/ &&\n\t\t       !$gconfig{'no_hostname_f'} && !$_[0]) {\n\t\t\t# Try with -f flag to get fully qualified name\n\t\t\tmy $flag;\n\t\t\tmy $ex = &execute_command(\"hostname -f\", undef, \\$flag,\n\t\t\t\t\t\t  undef, 0, 1);\n\t\t\tchop($flag);\n\t\t\tif ($ex || $flag eq \"\") {\n\t\t\t\t# -f not supported! We have probably set the\n\t\t\t\t# hostname to just '-f'. Fix the problem\n\t\t\t\t# (if we are root)\n\t\t\t\tif ($< == 0) {\n\t\t\t\t\t&execute_command(\"hostname \".\n\t\t\t\t\t\tquotemeta($main::get_system_hostname[$m]),\n\t\t\t\t\t\tundef, undef, undef, 0, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t$main::get_system_hostname[$m] = $flag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse {\n\t\t# On Windows, try computername environment variable\n\t\treturn $ENV{'computername'} if ($ENV{'computername'});\n\t\treturn $ENV{'COMPUTERNAME'} if ($ENV{'COMPUTERNAME'});\n\n\t\t# Fall back to net name command\n\t\tmy $out = `net name 2>&1`;\n\t\tif ($out =~ /\\-+\\r?\\n(\\S+)/) {\n\t\t\t$main::get_system_hostname[$m] = $1;\n\t\t\t}\n\t\telse {\n\t\t\t$main::get_system_hostname[$m] = \"windows\";\n\t\t\t}\n\t\t}\n\t}\nreturn $main::get_system_hostname[$m];\n}\n\n=head2 get_webmin_version\n\nReturns the version of Webmin currently being run, such as 1.450.\n\n=cut\nsub get_webmin_version\n{\nif (!$get_webmin_version) {\n\topen(VERSION, \"$root_directory/version\") || return 0;\n\t($get_webmin_version = <VERSION>) =~ tr/\\r|\\n//d;\n\tclose(VERSION);\n\tif (length($get_webmin_version) > 6) {\n\t\t$get_webmin_version_ui = substr($get_webmin_version, 0, 5) . \".\" . substr($get_webmin_version, 5, 5 - 1) . \".\" . substr($get_webmin_version, 5 * 2 - 1);\n\t\t}\n\t}\nif ($main::webmin_script_type eq 'web' && $get_webmin_version_ui) {\n\treturn $get_webmin_version_ui;\n\t}\nelse {\n\treturn $get_webmin_version;\n\t}\n}\n\n=head2 get_module_acl([user], [module], [no-rbac], [no-default])\n\nReturns a hash containing access control options for the given user and module.\nBy default the current username and module name are used. If the no-rbac flag\nis given, the permissions will not be updated based on the user's RBAC role\n(as seen on Solaris). If the no-default flag is given, default permissions for\nthe module will not be included.\n\n=cut\nsub get_module_acl\n{\nmy $u = defined($_[0]) ? $_[0] : $base_remote_user;\nmy $m = defined($_[1]) ? $_[1] : &get_module_name();\n$m ||= \"\";\nmy $mdir = &module_root_directory($m);\nmy %rv;\nif (!$_[3]) {\n\t# Read default ACL first, to be overridden by per-user settings\n\t&read_file_cached(\"$mdir/defaultacl\", \\%rv);\n\n\t# If this isn't a master admin user, apply the negative permissions\n\t# so that he doesn't un-expectedly gain access to new features\n\tmy %gacccess;\n\t&read_file_cached(\"$config_directory/$u.acl\", \\%gaccess);\n\tif ($gaccess{'negative'}) {\n\t\t&read_file_cached(\"$mdir/negativeacl\", \\%rv);\n\t\t}\n\t}\nmy %usersacl;\nif (!$_[2] && &supports_rbac($m) && &use_rbac_module_acl($u, $m)) {\n\t# RBAC overrides exist for this user in this module\n\tmy $rbac = &get_rbac_module_acl(\n\t\t\tdefined($_[0]) ? $_[0] : $remote_user, $m);\n\tforeach my $r (keys %$rbac) {\n\t\t$rv{$r} = $rbac->{$r};\n\t\t}\n\t}\nelsif ($gconfig{\"risk_$u\"} && $m) {\n\t# ACL is defined by user's risk level\n\tmy $rf = $gconfig{\"risk_$u\"}.'.risk';\n\t&read_file_cached(\"$mdir/$rf\", \\%rv);\n\n\tmy $sf = $gconfig{\"skill_$u\"}.'.skill';\n\t&read_file_cached(\"$mdir/$sf\", \\%rv);\n\t}\nelsif ($u ne '') {\n\t# Use normal Webmin ACL, if a user is set\n\tmy $userdb = &get_userdb_string();\n\tmy $foundindb = 0;\n\tif ($userdb && ($u ne $base_remote_user || $remote_user_proto)) {\n\t\t# Look for this user in the user/group DB, if one is defined\n\t\t# and if the user might be in the DB\n\t\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($userdb);\n\t\tif (!ref($dbh)) {\n\t\t\tprint STDERR \"Failed to connect to user database : \".\n\t\t\t\t     $dbh.\"\\n\";\n\t\t\t}\n\t\telsif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t\t# Find the user in the SQL DB\n\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t\t\"select id from webmin_user where name = ?\");\n\t\t\t$cmd && $cmd->execute($u) ||\n\t\t\t\t&error(&text('euserdbacl', $dbh->errstr));\n\t\t\tmy ($id) = $cmd->fetchrow();\n\t\t\t$foundindb = 1 if (defined($id));\n\t\t\t$cmd->finish();\n\n\t\t\t# Fetch ACLs with SQL\n\t\t\tif ($foundindb) {\n\t\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t\t    \"select attr,value from webmin_user_acl \".\n\t\t\t\t    \"where id = ? and module = ?\");\n\t\t\t\t$cmd && $cmd->execute($id, $m) ||\n\t\t\t\t    &error(&text('euserdbacl', $dbh->errstr));\n\t\t\t\twhile(my ($a, $v) = $cmd->fetchrow()) {\n\t\t\t\t\t$rv{$a} = $v;\n\t\t\t\t\t}\n\t\t\t\t$cmd->finish();\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($proto eq \"ldap\") {\n\t\t\t# Find user in LDAP\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $prefix,\n\t\t\t\tfilter => '(&(cn='.$u.')(objectClass='.\n\t\t\t\t\t  $args->{'userclass'}.'))',\n\t\t\t\tscope => 'sub');\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('euserdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\tmy ($user) = $rv->all_entries;\n\n\t\t\t# Find ACL sub-object for the module\n\t\t\tmy $ldapm = $m || \"global\";\n\t\t\tif ($user) {\n\t\t\t\tmy $rv = $dbh->search(\n\t\t\t\t\tbase => $user->dn(),\n\t\t\t\t\tfilter => '(cn='.$ldapm.')',\n\t\t\t\t\tscope => 'one');\n\t\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t\t&error(&text('euserdbacl',\n\t\t\t\t\t   $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t\t}\n\t\t\t\tmy ($acl) = $rv->all_entries;\n\t\t\t\tif ($acl) {\n\t\t\t\t\tforeach my $av ($acl->get_value(\n\t\t\t\t\t\t\t'webminAclEntry')) {\n\t\t\t\t\t\tmy ($a, $v) = split(/=/, $av,2);\n\t\t\t\t\t\t$rv{$a} = $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (ref($dbh)) {\n\t\t\t&disconnect_userdb($userdb, $dbh);\n\t\t\t}\n\t\t}\n\n\tif (!$foundindb) {\n\t\t# Read from local files\n\t\t&read_file_cached(\"$config_directory/$m/$u.acl\", \\%rv);\n\t\tif ($remote_user ne $base_remote_user && !defined($_[0])) {\n\t\t\t&read_file_cached(\n\t\t\t\t\"$config_directory/$m/$remote_user.acl\",\\%rv);\n\t\t\t}\n\t\t}\n\t}\nif ($tconfig{'preload_functions'}) {\n\t&load_theme_library();\n\t}\nif (defined(&theme_get_module_acl)) {\n\t%rv = &theme_get_module_acl($u, $m, \\%rv);\n\t}\nreturn %rv;\n}\n\n=head2 get_group_module_acl(group, [module], [no-default])\n\nReturns the ACL for a Webmin group, in an optional module (which defaults to\nthe current module).\n\n=cut\nsub get_group_module_acl\n{\nmy $g = $_[0];\nmy $m = defined($_[1]) ? $_[1] : &get_module_name();\nmy $mdir = &module_root_directory($m);\nmy %rv;\nif (!$_[2]) {\n\t&read_file_cached(\"$mdir/defaultacl\", \\%rv);\n\t}\n\nmy $userdb = &get_userdb_string();\nmy $foundindb = 0;\nif ($userdb) {\n\t# Look for this group in the user/group DB\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($userdb);\n\tref($dbh) || &error(&text('egroupdbacl', $dbh));\n\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Find the group in the SQL DB\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select id from webmin_group where name = ?\");\n\t\t$cmd && $cmd->execute($g) ||\n\t\t\t&error(&text('egroupdbacl', $dbh->errstr));\n\t\tmy ($id) = $cmd->fetchrow();\n\t\t$foundindb = 1 if (defined($id));\n\t\t$cmd->finish();\n\n\t\t# Fetch ACLs with SQL\n\t\tif ($foundindb) {\n\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t    \"select attr,value from webmin_group_acl \".\n\t\t\t    \"where id = ? and module = ?\");\n\t\t\t$cmd && $cmd->execute($id, $m) ||\n\t\t\t    &error(&text('egroupdbacl', $dbh->errstr));\n\t\t\twhile(my ($a, $v) = $cmd->fetchrow()) {\n\t\t\t\t$rv{$a} = $v;\n\t\t\t\t}\n\t\t\t$cmd->finish();\n\t\t\t}\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Find group in LDAP\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(&(cn='.$g.')(objectClass='.\n                                  $args->{'groupclass'}.'))',\n\t\t\tscope => 'sub');\n\t\tif (!$rv || $rv->code) {\n\t\t\t&error(&text('egroupdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t}\n\t\tmy ($group) = $rv->all_entries;\n\n\t\t# Find ACL sub-object for the module\n\t\tmy $ldapm = $m || \"global\";\n\t\tif ($group) {\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $group->dn(),\n\t\t\t\tfilter => '(cn='.$ldapm.')',\n\t\t\t\tscope => 'one');\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('egroupdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\tmy ($acl) = $rv->all_entries;\n\t\t\tif ($acl) {\n\t\t\t\tforeach my $av ($acl->get_value(\n\t\t\t\t\t\t'webminAclEntry')) {\n\t\t\t\t\tmy ($a, $v) = split(/=/, $av, 2);\n\t\t\t\t\t$rv{$a} = $v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($userdb, $dbh);\n\t}\nif (!$foundindb) {\n\t# Read from local files\n\t&read_file_cached(\"$config_directory/$m/$g.gacl\", \\%rv);\n\t}\nif (defined(&theme_get_module_acl)) {\n\t%rv = &theme_get_module_acl($g, $m, \\%rv);\n\t}\nreturn %rv;\n}\n\n=head2 save_module_acl(&acl, [user], [module], [never-update-group])\n\nUpdates the acl hash for some user and module. The parameters are :\n\n=item acl - Hash reference for the new access control options, or undef to clear\n\n=item user - User to update, defaulting to the current user.\n\n=item module - Module to update, defaulting to the caller.\n\n=item never-update-group - Never update the user's group's ACL\n\n=cut\nsub save_module_acl\n{\nmy $u = defined($_[1]) ? $_[1] : $base_remote_user;\nmy $m = defined($_[2]) ? $_[2] : &get_module_name();\n$u eq \"webmin\" && &error(\"Invalid username webmin for ACL\");\nif (!$_[3] && &foreign_check(\"acl\")) {\n\t# Check if this user is a member of a group, and if he gets the\n\t# module from a group. If so, update its ACL as well\n\t&foreign_require(\"acl\", \"acl-lib.pl\");\n\tmy $group;\n\tforeach my $g (&acl::list_groups()) {\n\t\tif (&indexof($u, @{$g->{'members'}}) >= 0 &&\n\t\t    &indexof($m, @{$g->{'modules'}}) >= 0) {\n\t\t\t$group = $g;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\tif ($group) {\n\t\t&save_group_module_acl($_[0], $group->{'name'}, $m);\n\t\t}\n\t}\n\nmy $userdb = &get_userdb_string();\nmy $foundindb = 0;\nif ($userdb && ($u ne $base_remote_user || $remote_user_proto)) {\n\t# Look for this user in the user/group DB\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($userdb);\n\tref($dbh) || &error(&text('euserdbacl', $dbh));\n\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Find the user in the SQL DB\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select id from webmin_user where name = ?\");\n\t\t$cmd && $cmd->execute($u) ||\n\t\t\t&error(&text('euserdbacl2', $dbh->errstr));\n\t\tmy ($id) = $cmd->fetchrow();\n\t\t$foundindb = 1 if (defined($id));\n\t\t$cmd->finish();\n\n\t\t# Replace ACLs for user\n\t\tif ($foundindb) {\n\t\t\tmy $cmd = $dbh->prepare(\"delete from webmin_user_acl \".\n\t\t\t\t\t\t\"where id = ? and module = ?\");\n\t\t\t$cmd && $cmd->execute($id, $m) ||\n\t\t\t    &error(&text('euserdbacl', $dbh->errstr));\n\t\t\t$cmd->finish();\n\t\t\tif ($_[0]) {\n\t\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t\t    \"insert into webmin_user_acl \".\n\t\t\t\t    \"(id,module,attr,value) values (?,?,?,?)\");\n\t\t\t\t$cmd || &error(&text('euserdbacl2',\n\t\t\t\t\t\t     $dbh->errstr));\n\t\t\t\tforeach my $a (keys %{$_[0]}) {\n\t\t\t\t\t$cmd->execute($id,$m,$a,$_[0]->{$a}) ||\n\t\t\t\t\t    &error(&text('euserdbacl2',\n\t\t\t\t\t\t\t $dbh->errstr));\n\t\t\t\t\t$cmd->finish();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Find the user in LDAP\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(&(cn='.$u.')(objectClass='.\n                                  $args->{'userclass'}.'))',\n\t\t\tscope => 'sub');\n\t\tif (!$rv || $rv->code) {\n\t\t\t&error(&text('euserdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t}\n\t\tmy ($user) = $rv->all_entries;\n\n\t\tif ($user) {\n\t\t\t# Find the ACL sub-object for the module\n\t\t\t$foundindb = 1;\n\t\t\tmy $ldapm = $m || \"global\";\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $user->dn(),\n\t\t\t\tfilter => '(cn='.$ldapm.')',\n\t\t\t\tscope => 'one');\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('euserdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\tmy ($acl) = $rv->all_entries;\n\n\t\t\tmy @al;\n\t\t\tforeach my $a (keys %{$_[0]}) {\n\t\t\t\tpush(@al, $a.\"=\".$_[0]->{$a});\n\t\t\t\t}\n\t\t\tif ($acl) {\n\t\t\t\t# Update attributes\n\t\t\t\t$rv = $dbh->modify($acl->dn(),\n\t\t\t\t  replace => { \"webminAclEntry\", \\@al });\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# Add a sub-object\n\t\t\t\tmy @attrs = ( \"cn\", $ldapm,\n\t\t\t\t\t      \"objectClass\", \"webminAcl\",\n\t\t\t\t\t      \"webminAclEntry\", \\@al );\n\t\t\t\t$rv = $dbh->add(\"cn=\".$ldapm.\",\".$user->dn(),\n\t\t\t\t\t\tattr => \\@attrs);\n\t\t\t\t}\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('euserdbacl2',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($userdb, $dbh);\n\t}\n\nif (!$foundindb) {\n\t# Save ACL to local file\n\tif (!-d \"$config_directory/$m\") {\n\t\tmkdir(\"$config_directory/$m\", 0755);\n\t\t}\n\tif ($_[0]) {\n\t\t&write_file(\"$config_directory/$m/$u.acl\", $_[0]);\n\t\t}\n\telse {\n\t\t&unlink_file(\"$config_directory/$m/$u.acl\");\n\t\t}\n\t}\n}\n\n=head2 save_group_module_acl(&acl, group, [module], [never-update-group])\n\nUpdates the acl hash for some group and module. The parameters are :\n\n=item acl - Hash reference for the new access control options.\n\n=item group - Group name to update.\n\n=item module - Module to update, defaulting to the caller.\n\n=item never-update-group - Never update the parent group's ACL\n\n=cut\nsub save_group_module_acl\n{\nmy $g = $_[1];\nmy $m = defined($_[2]) ? $_[2] : &get_module_name();\nif (!$_[3] && &foreign_check(\"acl\")) {\n\t# Check if this group is a member of a group, and if it gets the\n\t# module from a group. If so, update the parent ACL as well\n\t&foreign_require(\"acl\", \"acl-lib.pl\");\n\tmy $group;\n\tforeach my $pg (&acl::list_groups()) {\n\t\tif (&indexof('@'.$g, @{$pg->{'members'}}) >= 0 &&\n\t\t    &indexof($m, @{$pg->{'modules'}}) >= 0) {\n\t\t\t$group = $g;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\tif ($group) {\n\t\t&save_group_module_acl($_[0], $group->{'name'}, $m);\n\t\t}\n\t}\n\nmy $userdb = &get_userdb_string();\nmy $foundindb = 0;\nif ($userdb) {\n\t# Look for this group in the user/group DB\n\tmy ($dbh, $proto, $prefix, $args) = &connect_userdb($userdb);\n\tref($dbh) || &error(&text('egroupdbacl', $dbh));\n\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t# Find the group in the SQL DB\n\t\tmy $cmd = $dbh->prepare(\n\t\t\t\"select id from webmin_group where name = ?\");\n\t\t$cmd && $cmd->execute($g) ||\n\t\t\t&error(&text('egroupdbacl2', $dbh->errstr));\n\t\tmy ($id) = $cmd->fetchrow();\n\t\t$foundindb = 1 if (defined($id));\n\t\t$cmd->finish();\n\n\t\t# Replace ACLs for group\n\t\tif ($foundindb) {\n\t\t\tmy $cmd = $dbh->prepare(\"delete from webmin_group_acl \".\n\t\t\t\t\t\t\"where id = ? and module = ?\");\n\t\t\t$cmd && $cmd->execute($id, $m) ||\n\t\t\t    &error(&text('egroupdbacl', $dbh->errstr));\n\t\t\t$cmd->finish();\n\t\t\tif ($_[0]) {\n\t\t\t\tmy $cmd = $dbh->prepare(\n\t\t\t\t    \"insert into webmin_group_acl \".\n\t\t\t\t    \"(id,module,attr,value) values (?,?,?,?)\");\n\t\t\t\t$cmd || &error(&text('egroupdbacl2',\n\t\t\t\t\t\t     $dbh->errstr));\n\t\t\t\tforeach my $a (keys %{$_[0]}) {\n\t\t\t\t\t$cmd->execute($id,$m,$a,$_[0]->{$a}) ||\n\t\t\t\t\t    &error(&text('egroupdbacl2',\n\t\t\t\t\t\t\t $dbh->errstr));\n\t\t\t\t\t$cmd->finish();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($proto eq \"ldap\") {\n\t\t# Find the group in LDAP\n\t\tmy $rv = $dbh->search(\n\t\t\tbase => $prefix,\n\t\t\tfilter => '(&(cn='.$g.')(objectClass='.\n                                  $args->{'groupclass'}.'))',\n\t\t\tscope => 'sub');\n\t\tif (!$rv || $rv->code) {\n\t\t\t&error(&text('egroupdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t}\n\t\tmy ($group) = $rv->all_entries;\n\n\t\tmy $ldapm = $m || \"global\";\n\t\tif ($group) {\n\t\t\t# Find the ACL sub-object for the module\n\t\t\t$foundindb = 1;\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $group->dn(),\n\t\t\t\tfilter => '(cn='.$ldapm.')',\n\t\t\t\tscope => 'one');\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('egroupdbacl',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\tmy ($acl) = $rv->all_entries;\n\n\t\t\tmy @al;\n\t\t\tforeach my $a (keys %{$_[0]}) {\n\t\t\t\tpush(@al, $a.\"=\".$_[0]->{$a});\n\t\t\t\t}\n\t\t\tif ($acl) {\n\t\t\t\t# Update attributes\n\t\t\t\t$rv = $dbh->modify($acl->dn(),\n\t\t\t   \t\treplace => { \"webminAclEntry\", \\@al });\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# Add a sub-object\n\t\t\t\tmy @attrs = ( \"cn\", $ldapm,\n\t\t\t\t\t      \"objectClass\", \"webminAcl\",\n\t\t\t\t\t      \"webminAclEntry\", \\@al );\n\t\t\t\t$rv = $dbh->add(\"cn=\".$ldapm.\",\".$group->dn(),\n\t\t\t\t\t\tattr => \\@attrs);\n\t\t\t\t}\n\t\t\tif (!$rv || $rv->code) {\n\t\t\t\t&error(&text('egroupdbacl2',\n\t\t\t\t     $rv ? $rv->error : \"Unknown error\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t&disconnect_userdb($userdb, $dbh);\n\t}\n\nif (!$foundindb) {\n\t# Save ACL to local file\n\tif (!-d \"$config_directory/$m\") {\n\t\tmkdir(\"$config_directory/$m\", 0755);\n\t\t}\n\tif ($_[0]) {\n\t\t&write_file(\"$config_directory/$m/$g.gacl\", $_[0]);\n\t\t}\n\telse {\n\t\t&unlink_file(\"$config_directory/$m/$g.gacl\");\n\t\t}\n\t}\n}\n\n=head2 init_config\n\nThis function must be called by all Webmin CGI scripts, either directly or\nindirectly via a per-module lib.pl file. It performs a number of initialization\nand housekeeping tasks, such as working out the module name, checking that the\ncurrent user has access to the module, and populating global variables. Some\nof the variables set include :\n\n=item $config_directory - Base Webmin config directory, typically /etc/webmin\n\n=item $var_directory - Base logs directory, typically /var/webmin\n\n=item %config - Per-module configuration.\n\n=item %gconfig - Global configuration.\n\n=item $scriptname - Base name of the current perl script.\n\n=item $module_name - The name of the current module.\n\n=item $module_config_directory - The config directory for this module.\n\n=item $module_config_file - The config file for this module.\n\n=item $module_var_directory - The data directory for this module.\n\n=item $module_root_directory - This module's code directory.\n\n=item $webmin_logfile - The detailed logfile for webmin.\n\n=item $remote_user - The actual username used to login to webmin.\n\n=item $base_remote_user - The username whose permissions are in effect.\n\n=item $current_theme - The theme currently in use.\n\n=item $root_directory - The first root directory of this webmin install.\n\n=item @root_directories - All root directories for this webmin install.\n\n=cut\nsub init_config\n{\n# Record first process ID that called this, so we know when it exited to clean\n# up temp files\n$main::initial_process_id ||= $$;\n\n# Configuration and spool directories\nif (!defined($ENV{'WEBMIN_CONFIG'})) {\n\tdie \"WEBMIN_CONFIG not set\";\n\t}\n$config_directory = $ENV{'WEBMIN_CONFIG'};\nif (!defined($ENV{'WEBMIN_VAR'})) {\n\topen(VARPATH, \"$config_directory/var-path\");\n\tchop($var_directory = <VARPATH>);\n\tclose(VARPATH);\n\t}\nelse {\n\t$var_directory = $ENV{'WEBMIN_VAR'};\n\t}\n$main::http_cache_directory = $ENV{'WEBMIN_VAR'}.\"/cache\";\n$main::default_debug_log_file = $ENV{'WEBMIN_VAR'}.\"/webmin.debug\";\n\nif ($ENV{'SESSION_ID'}) {\n\t# Hide this variable from called programs, but keep it for internal use\n\t$main::session_id = $ENV{'SESSION_ID'};\n\tdelete($ENV{'SESSION_ID'});\n\t}\nif ($ENV{'REMOTE_PASS'}) {\n\t# Hide the password too\n\t$main::remote_pass = $ENV{'REMOTE_PASS'};\n\tdelete($ENV{'REMOTE_PASS'});\n\t}\n\nif ($> == 0 && $< != 0 && !$ENV{'FOREIGN_MODULE_NAME'}) {\n\t# Looks like we are running setuid, but the real UID hasn't been set.\n\t# Do so now, so that executed programs don't get confused\n\t$( = $);\n\t$< = $>;\n\t}\n\n# Read the webmin global config file. This contains the OS type and version,\n# OS specific configuration and global options such as proxy servers\n$config_file = \"$config_directory/config\";\n%gconfig = ( );\n&read_file_cached($config_file, \\%gconfig);\n$gconfig{'webprefix'} = '' if (!exists($gconfig{'webprefix'}));\n$null_file = $gconfig{'os_type'} eq 'windows' ? \"NUL\" : \"/dev/null\";\n$path_separator = $gconfig{'os_type'} eq 'windows' ? ';' : ':';\n\n# Work out of this is a web, command line or cron job\nif (!$main::webmin_script_type) {\n\tif ($ENV{'SCRIPT_NAME'}) {\n\t\t# Run via a CGI\n\t\t$main::webmin_script_type = 'web';\n\t\t}\n\telse {\n\t\t# Cron jobs have no TTY\n\t\tif ($gconfig{'os_type'} eq 'windows' ||\n\t\t    open(DEVTTY, \">/dev/tty\")) {\n\t\t\t$main::webmin_script_type = 'cmd';\n\t\t\tclose(DEVTTY);\n\t\t\t}\n\t\telse {\n\t\t\t$main::webmin_script_type = 'cron';\n\t\t\t}\n\t\t}\n\t}\n\n# If this is a cron job, suppress STDERR warnings\nif ($main::webmin_script_type eq 'cron') {\n\t$SIG{__WARN__} = sub { };\n\t}\n\n# If debugging is enabled, open the debug log\nif (($ENV{'WEBMIN_DEBUG'} || $gconfig{'debug_enabled'}) &&\n    !$main::opened_debug_log++) {\n\tmy $dlog = $gconfig{'debug_file'} || $main::default_debug_log_file;\n\tmy $dsize = $gconfig{'debug_size'} || $main::default_debug_log_size;\n\tmy @st = stat($dlog);\n\tif ($dsize && $st[7] > $dsize) {\n\t\trename($dlog, $dlog.\".0\");\n\t\t}\n\n\topen(main::DEBUGLOG, \">>$dlog\");\n\t$main::opened_debug_log = 1;\n\n\tif ($gconfig{'debug_what_start'}) {\n\t\tmy $script_name = $0 =~ /([^\\/]+)$/ ? $1 : '-';\n\t\t$main::debug_log_start_time = time();\n\t\t&webmin_debug_log(\"START\", \"script=$script_name\");\n\t\t}\n\t}\n\n# Set PATH and LD_LIBRARY_PATH\nif ($gconfig{'path'}) {\n\tif ($gconfig{'syspath'}) {\n\t\t# Webmin only\n\t\t$ENV{'PATH'} = $gconfig{'path'};\n\t\t}\n\telse {\n\t\t# Include OS too\n\t\t$ENV{'PATH'} = $gconfig{'path'}.$path_separator.$ENV{'PATH'};\n\t\t}\n\t}\n$ENV{$gconfig{'ld_env'}} = $gconfig{'ld_path'} if ($gconfig{'ld_env'});\n\n# Set http_proxy and ftp_proxy environment variables, based on Webmin settings\nif ($gconfig{'http_proxy'}) {\n\t$ENV{'http_proxy'} = $gconfig{'http_proxy'};\n\t}\nif ($gconfig{'ftp_proxy'}) {\n\t$ENV{'ftp_proxy'} = $gconfig{'ftp_proxy'};\n\t}\nif ($gconfig{'noproxy'}) {\n\t$ENV{'no_proxy'} = $gconfig{'noproxy'};\n\t}\n\n# Find all root directories\nmy %miniserv;\nif (&get_miniserv_config(\\%miniserv)) {\n\t@root_directories = ( $miniserv{'root'} );\n\tfor($i=0; defined($miniserv{\"extraroot_$i\"}); $i++) {\n\t\tpush(@root_directories, $miniserv{\"extraroot_$i\"});\n\t\t}\n\t}\n\n# Work out which module we are in, and read the per-module config file\n$0 =~ s/\\\\/\\//g;\t# Force consistent path on Windows\nif (defined($ENV{'FOREIGN_MODULE_NAME'}) && $ENV{'FOREIGN_ROOT_DIRECTORY'}) {\n\t# In a foreign call - use the module name given\n\t$root_directory = $ENV{'FOREIGN_ROOT_DIRECTORY'};\n\t$module_name = $ENV{'FOREIGN_MODULE_NAME'};\n\t@root_directories = ( $root_directory ) if (!@root_directories);\n\t}\nelsif ($ENV{'SCRIPT_NAME'}) {\n\tmy $sn = $ENV{'SCRIPT_NAME'};\n\t$sn =~ s/^$gconfig{'webprefix'}\\//\\//\n\t\tif (!$gconfig{'webprefixnoredir'});\n\tif ($sn =~ /^\\/([^\\/]+)\\//) {\n\t\t# Get module name from CGI path\n\t\t$module_name = $1;\n\t\t}\n\tif ($ENV{'SERVER_ROOT'}) {\n\t\t$root_directory = $ENV{'SERVER_ROOT'};\n\t\t}\n\telsif ($ENV{'SCRIPT_FILENAME'}) {\n\t\t$root_directory = $ENV{'SCRIPT_FILENAME'};\n\t\t$root_directory =~ s/$sn$//;\n\t\t}\n\t@root_directories = ( $root_directory ) if (!@root_directories);\n\t}\nelse {\n\t# Get root directory from miniserv.conf, and deduce module name from $0\n\t$root_directory = $root_directories[0];\n\tmy $rok = 0;\n\tforeach my $r (@root_directories) {\n\t\tif ($0 =~ /^$r\\/([^\\/]+)\\/[^\\/]+$/i) {\n\t\t\t# Under a module directory\n\t\t\t$module_name = $1;\n\t\t\t$rok = 1;\n\t\t\tlast;\n\t\t\t}\n\t\telsif ($0 =~ /^$root_directory\\/[^\\/]+$/i) {\n\t\t\t# At the top level\n\t\t\t$rok = 1;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t&error(\"Script was not run with full path (failed to find $0 under $root_directory)\") if (!$rok);\n\t}\n\n# Set the umask based on config\nif ($gconfig{'umask'} ne '' && !$main::umask_already++) {\n\tumask(oct($gconfig{'umask'}));\n\t}\n\n# If this is a cron job or other background task, set the nice level\nif (!$main::nice_already && $main::webmin_script_type eq 'cron') {\n\t# Set nice level\n\tif ($gconfig{'nice'}) {\n\t\teval 'POSIX::nice($gconfig{\\'nice\\'});';\n\t\t}\n\n\t# Set IO scheduling class and priority\n\tif ($gconfig{'sclass'} ne '' || $gconfig{'sprio'} ne '') {\n\t\tmy $cmd = \"ionice\";\n\t\t$cmd .= \" -c \".quotemeta($gconfig{'sclass'})\n\t\t\tif ($gconfig{'sclass'} ne '');\n\t\t$cmd .= \" -n \".quotemeta($gconfig{'sprio'})\n\t\t\tif ($gconfig{'sprio'} ne '');\n\t\t$cmd .= \" -p $$\";\n\t\t&execute_command(\"$cmd >/dev/null 2>&1\");\n\t\t}\n\t}\n$main::nice_already++;\n\n# Get the username\nmy $u = $ENV{'BASE_REMOTE_USER'} || $ENV{'REMOTE_USER'};\n$base_remote_user = $u;\n$remote_user = $ENV{'REMOTE_USER'};\n\n# Work out if user is definitely in the DB, and if so get his attrs\n$remote_user_proto = $ENV{\"REMOTE_USER_PROTO\"};\n%remote_user_attrs = ( );\nif ($remote_user_proto) {\n\tmy $userdb = &get_userdb_string();\n\tmy ($dbh, $proto, $prefix, $args) =\n\t\t$userdb ? &connect_userdb($userdb) : ( );\n\tif (ref($dbh)) {\n\t\tif ($proto eq \"mysql\" || $proto eq \"postgresql\") {\n\t\t\t# Read attrs from SQL\n\t\t\tmy $cmd = $dbh->prepare(\"select webmin_user_attr.attr,webmin_user_attr.value from webmin_user_attr,webmin_user where webmin_user_attr.id = webmin_user.id and webmin_user.name = ?\");\n\t\t\tif ($cmd && $cmd->execute($base_remote_user)) {\n\t\t\t\twhile(my ($attr, $value) = $cmd->fetchrow()) {\n\t\t\t\t\t$remote_user_attrs{$attr} = $value;\n\t\t\t\t\t}\n\t\t\t\t$cmd->finish();\n\t\t\t\t}\n\t\t\t}\n\t\telsif ($proto eq \"ldap\") {\n\t\t\t# Read attrs from LDAP\n\t\t\tmy $rv = $dbh->search(\n\t\t\t\tbase => $prefix,\n\t\t\t\tfilter => '(&(cn='.$base_remote_user.')'.\n\t\t\t\t\t  '(objectClass='.\n\t\t\t\t\t  $args->{'userclass'}.'))',\n\t\t\t\tscope => 'sub');\n\t\t\tmy ($u) = $rv && !$rv->code ? $rv->all_entries : ( );\n\t\t\tif ($u) {\n\t\t\t\tforeach $la ($u->get_value('webminAttr')) {\n\t\t\t\t\tmy ($attr, $value) = split(/=/, $la, 2);\n\t\t\t\t\t$remote_user_attrs{$attr} = $value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t&disconnect_userdb($userdb, $dbh);\n\t\t}\n\t}\n\nif ($module_name) {\n\t# Find and load the configuration file for this module\n\tmy (@ruinfo, $rgroup);\n\t$module_config_directory = \"$config_directory/$module_name\";\n\tif (&get_product_name() eq \"usermin\" &&\n\t    -r \"$module_config_directory/config.$remote_user\") {\n\t\t# Based on username\n\t\t$module_config_file = \"$module_config_directory/config.$remote_user\";\n\t\t}\n\telsif (&get_product_name() eq \"usermin\" &&\n\t    (@ruinfo = getpwnam($remote_user)) &&\n\t    ($rgroup = getgrgid($ruinfo[3])) &&\n\t    -r \"$module_config_directory/config.\\@$rgroup\") {\n\t\t# Based on group name\n\t\t$module_config_file = \"$module_config_directory/config.\\@$rgroup\";\n\t\t}\n\telse {\n\t\t# Global config\n\t\t$module_config_file = \"$module_config_directory/config\";\n\t\t}\n\t%config = ( );\n\t&read_file_cached($module_config_file, \\%config);\n\n\t# Create a module-specific var directory\n\tmy $var_base = \"$var_directory/modules\";\n\tif (!-d $var_base) {\n\t\t&make_dir($var_base, 0700);\n\t\t}\n\t$module_var_directory = \"$var_base/$module_name\";\n\tif (!-d $module_var_directory) {\n\t\t&make_dir($module_var_directory, 0700);\n\t\t}\n\n\t# Fix up windows-specific substitutions in values\n\tforeach my $k (keys %config) {\n\t\tif ($config{$k} =~ /\\$\\{systemroot\\}/) {\n\t\t\tmy $root = &get_windows_root();\n\t\t\t$config{$k} =~ s/\\$\\{systemroot\\}/$root/g;\n\t\t\t}\n\t\t}\n\t}\n\n# Record the initial module\n$main::initial_module_name ||= $module_name;\n\n# Set some useful variables\nmy $current_themes;\n$current_themes = $ENV{'MOBILE_DEVICE'} && defined($gconfig{'mobile_theme'}) ?\n\t\t    $gconfig{'mobile_theme'} :\n\t\t  defined($remote_user_attrs{'theme'}) ?\n\t\t    $remote_user_attrs{'theme'} :\n\t\t  defined($gconfig{'theme_'.$remote_user}) ?\n\t\t    $gconfig{'theme_'.$remote_user} :\n\t\t  defined($gconfig{'theme_'.$base_remote_user}) ?\n\t\t    $gconfig{'theme_'.$base_remote_user} :\n\t\t    $gconfig{'theme'};\n@current_themes = split(/\\s+/, $current_themes);\n$current_theme = $current_themes[0];\n@theme_root_directories = map { \"$root_directory/$_\" } @current_themes;\n$theme_root_directory = $theme_root_directories[0];\n@theme_configs = ( );\nforeach my $troot (@theme_root_directories) {\n\tmy %onetconfig;\n\t&read_file_cached(\"$troot/config\", \\%onetconfig);\n\t&read_file_cached(\"$troot/config\", \\%tconfig);\n\tpush(@theme_configs, \\%onetconfig);\n\t}\n$tb = defined($tconfig{'cs_header'}) ? \"bgcolor=\\\"#$tconfig{'cs_header'}\\\"\" :\n      defined($gconfig{'cs_header'}) ? \"bgcolor=\\\"#$gconfig{'cs_header'}\\\"\" :\n\t\t\t\t       \"bgcolor=\\\"#9999ff\\\"\";\n$cb = defined($tconfig{'cs_table'}) ? \"bgcolor=\\\"#$tconfig{'cs_table'}\\\"\" :\n      defined($gconfig{'cs_table'}) ? \"bgcolor=\\\"#$gconfig{'cs_table'}\\\"\" :\n\t\t\t\t      \"bgcolor=\\\"#cccccc\\\"\";\n$tb .= ' '.$tconfig{'tb'} if ($tconfig{'tb'});\n$cb .= ' '.$tconfig{'cb'} if ($tconfig{'cb'});\nif ($tconfig{'preload_functions'}) {\n\t# Force load of theme functions right now, if requested\n\t&load_theme_library();\n\t}\nif ($tconfig{'oofunctions'} && !$main::loaded_theme_oo_library++) {\n\t# Load the theme's Webmin:: package classes\n\tdo \"$theme_root_directory/$tconfig{'oofunctions'}\";\n\t}\n\n$0 =~ /([^\\/]+)$/;\n$scriptname = $1;\n$webmin_logfile = $gconfig{'webmin_log'} ? $gconfig{'webmin_log'}\n\t\t\t\t\t : \"$var_directory/webmin.log\";\n\n# Load language strings into %text\nmy @langs = &list_languages();\nmy $accepted_lang;\nif ($gconfig{'acceptlang'}) {\n\tforeach my $a (split(/,/, $ENV{'HTTP_ACCEPT_LANGUAGE'})) {\n\t\t$a =~ s/;.*//;\t# Remove ;q=0.5 or similar\n\t\tmy ($al) = grep { $_->{'lang'} eq $a } @langs;\n\t\tif ($al) {\n\t\t\t$accepted_lang = $al->{'lang'};\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\n$current_lang = $force_lang ? $force_lang :\n    $accepted_lang ? $accepted_lang :\n    $remote_user_attrs{'lang'} ? $remote_user_attrs{'lang'} :\n    $gconfig{\"lang_$remote_user\"} ? $gconfig{\"lang_$remote_user\"} :\n    $gconfig{\"lang_$base_remote_user\"} ? $gconfig{\"lang_$base_remote_user\"} :\n    $gconfig{\"lang\"} ? $gconfig{\"lang\"} : $default_lang;\nforeach my $l (@langs) {\n\t$current_lang_info = $l if ($l->{'lang'} eq $current_lang);\n\t}\n@lang_order_list = &unique($default_lang,\n\t\t     \t   split(/:/, $current_lang_info->{'fallback'}),\n\t\t\t   $current_lang);\n%text = &load_language($module_name);\n%text || &error(\"Failed to determine Webmin root from SERVER_ROOT, SCRIPT_FILENAME or the full command line\");\n\n# Get the %module_info for this module\nif ($module_name) {\n\tmy ($mi) = grep { $_->{'dir'} eq $module_name }\n\t\t\t &get_all_module_infos(2);\n\t%module_info = %$mi;\n\t$module_root_directory = &module_root_directory($module_name);\n\t}\n\nif ($module_name && !$main::no_acl_check &&\n    !defined($ENV{'FOREIGN_MODULE_NAME'}) &&\n    $main::webmin_script_type eq 'web') {\n\t# Check if the HTTP user can access this module\n\tif (!&foreign_available($module_name)) {\n\t\tif (!&foreign_check($module_name)) {\n\t\t\t&error(&text('emodulecheck',\n\t\t\t\t     \"<i>$module_info{'desc'}</i>\"));\n\t\t\t}\n\t\telse {\n\t\t\t&error(&text('emodule', \"<i>$u</i>\",\n\t\t\t\t     \"<i>$module_info{'desc'}</i>\"));\n\t\t\t}\n\t\t}\n\t$main::no_acl_check++;\n\t}\n\n# Check the Referer: header for nasty redirects\nmy @referers = split(/\\s+/, $gconfig{'referers'});\nmy $referer_site;\nmy $r = $ENV{'HTTP_REFERER'};\nmy $referer_port = $r =~ /^https:/ ? 443 : 80;\nif ($r =~ /^(http|https|ftp):\\/\\/([^:\\/]+:[^@\\/]+@)?\\[([^\\]]+)\\](:(\\d+))?/ ||\n    $r =~ /^(http|https|ftp):\\/\\/([^:\\/]+:[^@\\/]+@)?([^\\/:@]+)(:(\\d+))?/) {\n\t$referer_site = $3;\n\t$referer_port = $5 if ($5);\n\t}\nmy $http_host = $ENV{'HTTP_HOST'};\nmy $http_port = $ENV{'SERVER_PORT'} || 80;\nif ($http_host =~ s/:(\\d+)$//) {\n\t$http_port = $1;\n\t}\n$http_host =~ s/^\\[(\\S+)\\]$/$1/;\nmy $unsafe_index = $unsafe_index_cgi ||\n\t\t   &get_module_variable('$unsafe_index_cgi');\nmy $trustvar = $trust_unknown_referers ||\n\t       &get_module_variable('$trust_unknown_referers');\nmy $trust = 0;\nif (!$0) {\n\t# Script name not known\n\t$trust = 1;\n\t}\nelsif ($trustvar == 1) {\n\t# Module doesn't want referer checking at all\n\t$trust = 1;\n\t}\nelsif ($ENV{'DISABLE_REFERERS_CHECK'}) {\n\t# Check disabled by environment, perhaps due to cross-module call\n\t$trust = 1;\n\t}\nelsif (($ENV{'SCRIPT_NAME'} =~ /^\\/(index.cgi)?$/ ||\n\t$ENV{'SCRIPT_NAME'} =~ /^\\/([a-z0-9\\_\\-]+)\\/(index.cgi)?$/i) &&\n       !$unsafe_index) {\n\t# Script is a module's index.cgi, which is normally safe\n\t$trust = 1;\n\t}\nelsif ($0 =~ /(session_login|pam_login)\\.cgi$/) {\n\t# Webmin login page, which doesn't get a referer\n\t$trust = 1;\n\t}\nelsif ($gconfig{'referer'}) {\n\t# Referer checking disabled completely\n\t$trust = 1;\n\t}\nelsif (!$ENV{'MINISERV_CONFIG'}) {\n\t# Not a CGI script\n\t$trust = 1;\n\t}\nelsif ($main::no_referers_check) {\n\t# Caller requested disabling of checks completely\n\t$trust = 1;\n\t}\nelsif ($ENV{'HTTP_USER_AGENT'} =~ /^Webmin/i) {\n\t# Remote call from Webmin itself\n\t$trust = 1;\n\t}\nelsif (!$referer_site) {\n\t# No referer set in URL\n\tif (!$gconfig{'referers_none'}) {\n\t\t# Known referers are allowed\n\t\t$trust = 1;\n\t\t}\n\telsif ($trustvar == 2) {\n\t\t# Module wants to trust unknown referers\n\t\t$trust = 1;\n\t\t}\n\telse {\n\t\t$trust = 0;\n\t\t}\n\t}\nelsif (&indexof($referer_site, @referers) >= 0) {\n\t# Site is on the trusted list\n\t$trust = 1;\n\t}\nelsif ($referer_site eq $http_host &&\n       (!$referer_port || !$http_port || $referer_port == $http_port)) {\n\t# Link came from this website\n\t$trust = 1;\n\t}\nelse {\n\t# Unknown link source\n\t$trust = 0;\n\t}\n# Check for trigger URL to simply redirect to root: required for Authentic Theme 19.00+\nif ($ENV{'HTTP_X_REQUESTED_WITH'} ne \"XMLHttpRequest\" &&\n    $ENV{'REQUEST_URI'} !~ /xhr/  &&\n    $ENV{'REQUEST_URI'} !~ /pjax/ &&\n    $ENV{'REQUEST_URI'} !~ /link.cgi\\/\\d+/ &&\n    $ENV{'REQUEST_URI'} =~ /xnavigation=1/) {\n\t\t# Store requested URI if safe\n\t\tif ($main::session_id && $remote_user) {\n\t\t    my %var;\n\t\t    my $key  = 'goto';\n\t\t    my $xnav = \"xnavigation=1\";\n\t\t    my $url  = \"$gconfig{'webprefix'}$ENV{'REQUEST_URI'}\";\n\t\t    my $salt = substr(encode_base64($main::session_id), 0, 16);\n\t\t    $url =~ s/[?|&]$xnav//g;\n\t\t    $salt =~ tr/A-Za-z0-9//cd;\n\n\t\t    if (!$trust) {\n\t\t        my @parent_dir = split('/', $url);\n\t\t        $url = $gconfig{'webprefix'} ? $parent_dir[2] : $parent_dir[1];\n\t\t        if ($url =~ /.cgi/) {\n\t\t            $url = \"/\";\n\t\t        \t}\n\t\t        \telse {\n\t\t            $url = \"/\" . $url . \"/\";\n\t\t        \t}\n\t\t    \t}\n\t\t    # Append random string to stored file name, to process multiple, simultaneous requests\n\t\t    my $url_salt  = int(rand() * 10000000);\n\t\t    $var{$key} = $url;\n\n\t\t    # Write follow URL only once\n\t\t    if (!$main::redirect_built) {\n\t\t    \twrite_file(tempname('.theme_' . $salt . '_' . $url_salt . '_' . get_product_name() . '_' . $key . '_' . $remote_user), \\%var);\n\t\t    \t}\n\t\t    $main::redirect_built++\n\t\t}\n  &redirect(\"/\");\n\t}\nif (!$trust) {\n\t# Looks like a link from elsewhere .. show an error\n\t&header($text{'referer_title'}, \"\", undef, 0, 1, 1);\n\n\t$prot = lc($ENV{'HTTPS'}) eq 'on' ? \"https\" : \"http\";\n\tmy $url = \"<tt>\".&html_escape(\"$prot://$ENV{'HTTP_HOST'}$ENV{'REQUEST_URI'}\").\"</tt>\";\n\tif ($referer_site) {\n\t\t# From a known host\n\t\tprint &text('referer_warn',\n\t\t\t    \"<tt>\".&html_escape($r).\"</tt>\", $url);\n\t\tprint \"<p>\\n\";\n\t\tprint &text('referer_fix1', &html_escape($http_host)),\"<p>\\n\";\n\t\tprint &text('referer_fix2', &html_escape($http_host)),\"<p>\\n\";\n\t\t}\n\telse {\n\t\t# No referer info given\n\t\tprint &text('referer_warn_unknown', $url),\"<p>\\n\";\n\t\tprint &text('referer_fix3u'),\"<p>\\n\";\n\t\tprint &text('referer_fix2u'),\"<p>\\n\";\n\t\t}\n\tprint \"<p>\\n\";\n\n\texit;\n\t}\n$main::no_referers_check++;\n$main::completed_referers_check++;\n\n# Call theme post-init\nif (defined(&theme_post_init_config)) {\n\t&theme_post_init_config(@_);\n\t}\n\n# Record that we have done the calling library in this package\nmy ($callpkg, $lib) = caller();\n$lib =~ s/^.*\\///;\n$main::done_foreign_require{$callpkg,$lib} = 1;\n\n# If a licence checking is enabled, do it now\nif ($gconfig{'licence_module'} && !$main::done_licence_module_check &&\n    &foreign_check($gconfig{'licence_module'}) &&\n    -r \"$root_directory/$gconfig{'licence_module'}/licence_check.pl\") {\n\tmy $oldpwd = &get_current_dir();\n\t$main::done_licence_module_check++;\n\t$main::licence_module = $gconfig{'licence_module'};\n\t&foreign_require($main::licence_module, \"licence_check.pl\");\n\t($main::licence_status, $main::licence_message) =\n\t\t&foreign_call($main::licence_module, \"check_licence\");\n\tchdir($oldpwd);\n\t}\n\n# Export global variables to caller\nif ($main::export_to_caller) {\n\tforeach my $v ('$config_file', '%gconfig', '$null_file',\n\t\t       '$path_separator', '@root_directories',\n\t\t       '$root_directory', '$module_name',\n\t\t       '$base_remote_user', '$remote_user',\n\t\t       '$remote_user_proto', '%remote_user_attrs',\n\t\t       '$module_config_directory', '$module_config_file',\n\t\t       '%config', '@current_themes', '$current_theme',\n\t\t       '@theme_root_directories', '$theme_root_directory',\n\t\t       '%tconfig','@theme_configs', '$tb', '$cb', '$scriptname',\n\t\t       '$webmin_logfile', '$current_lang',\n\t\t       '$current_lang_info', '@lang_order_list', '%text',\n\t\t       '%module_info', '$module_root_directory',\n\t\t       '$module_var_directory') {\n\t\tmy ($vt, $vn) = split('', $v, 2);\n\t\teval \"${vt}${callpkg}::${vn} = ${vt}${vn}\";\n\t\t}\n\t}\n\nreturn 1;\n}\n\n=head2 load_language([module], [directory])\n\nReturns a hashtable mapping text codes to strings in the appropriate language,\nbased on the $current_lang global variable, which is in turn set based on\nthe Webmin user's selection. The optional module parameter tells the function\nwhich module to load strings for, and defaults to the calling module. The\noptional directory parameter can be used to load strings from a directory\nother than lang.\n\nIn regular module development you will never need to call this function\ndirectly, as init_config calls it for you, and places the module's strings\ninto the %text hash.\n\n=cut\nsub load_language\n{\nmy %text;\nmy $root = $root_directory;\nmy $ol = $gconfig{'overlang'};\nmy ($dir) = ($_[1] || \"lang\");\n\n# Read global lang files\nforeach my $o (@lang_order_list) {\n\tmy $ok = &read_file_cached_with_stat(\"$root/$dir/$o\", \\%text);\n\treturn () if (!$ok && $o eq $default_lang);\n\t}\nif ($ol) {\n\tforeach my $o (@lang_order_list) {\n\t\t&read_file_cached(\"$root/$ol/$o\", \\%text);\n\t\t}\n\t}\n&read_file_cached(\"$config_directory/custom-lang\", \\%text);\nforeach my $o (@lang_order_list) {\n\tnext if ($o eq \"en\");\n\t&read_file_cached(\"$config_directory/custom-lang.$o\", \\%text);\n\t}\nmy $norefs = $text{'__norefs'};\n\nif ($_[0]) {\n\t# Read module's lang files\n\tdelete($text{'__norefs'});\n\tmy $mdir = &module_root_directory($_[0]);\n\tforeach my $o (@lang_order_list) {\n\t\t&read_file_cached_with_stat(\"$mdir/$dir/$o\", \\%text);\n\t\t}\n\tif ($ol) {\n\t\tforeach my $o (@lang_order_list) {\n\t\t\t&read_file_cached(\"$mdir/$ol/$o\", \\%text);\n\t\t\t}\n\t\t}\n\t&read_file_cached(\"$config_directory/$_[0]/custom-lang\", \\%text);\n\tforeach my $o (@lang_order_list) {\n\t\tnext if ($o eq \"en\");\n\t\t&read_file_cached(\"$config_directory/$_[0]/custom-lang.$o\",\n\t\t\t\t  \\%text);\n\t\t}\n\t$norefs = $text{'__norefs'} if ($norefs);\n\t}\n\n# Replace references to other strings\nif (!$norefs) {\n\tforeach $k (keys %text) {\n\t\t$text{$k} =~ s/\\$(\\{([^\\}]+)\\}|([A-Za-z0-9\\.\\-\\_]+))/text_subs($2 || $3,\\%text)/ge;\n\t\t}\n\t}\n\nif (defined(&theme_load_language)) {\n\t&theme_load_language(\\%text, $_[0]);\n\t}\nreturn %text;\n}\n\n=head2 text_subs(string)\n\nUsed internally by load_language to expand $code substitutions in language\nfiles.\n\n=cut\nsub text_subs\n{\nif (substr($_[0], 0, 8) eq \"include:\") {\n\tlocal $_;\n\tmy $rv;\n\topen(INCLUDE, substr($_[0], 8));\n\twhile(<INCLUDE>) {\n\t\t$rv .= $_;\n\t\t}\n\tclose(INCLUDE);\n\treturn $rv;\n\t}\nelse {\n\tmy $t = $_[1]->{$_[0]};\n\treturn defined($t) ? $t : '$'.$_[0];\n\t}\n}\n\n=head2 text(message, [substitute]+)\n\nReturns a translated message from %text, but with $1, $2, etc.. replaced with\nthe substitute parameters. This makes it easy to use strings with placeholders\nthat get replaced with programmatically generated text. For example :\n\n print &text('index_hello', $remote_user),\"<p>\\n\";\n\n=cut\nsub text\n{\nmy $t = &get_module_variable('%text', 1);\nmy $rv = exists($t->{$_[0]}) ? $t->{$_[0]} : $text{$_[0]};\n$rv =~ s/\\$(\\d+)/$1 < @_ ? $_[$1] : '$'.$1/ge;\nreturn $rv;\n}\n\n=head2 encode_base64(string)\n\nEncodes a string into base64 format, for use in MIME email or HTTP\nauthorization headers.\n\n=cut\nsub encode_base64\n{\neval \"use MIME::Base64 ()\";\nif (!$@) {\n\treturn MIME::Base64::encode($_[0]);\n\t}\nmy $res;\npos($_[0]) = 0;                          # ensure start at the beginning\nwhile ($_[0] =~ /(.{1,57})/gs) {\n\t$res .= substr(pack('u57', $1), 1).\"\\n\";\n\tchop($res);\n\t}\n$res =~ tr|\\` -_|AA-Za-z0-9+/|;\nmy $padding = (3 - length($_[0]) % 3) % 3;\n$res =~ s/.{$padding}$/'=' x $padding/e if ($padding);\nreturn $res;\n}\n\n=head2 decode_base64(string)\n\nConverts a base64-encoded string into plain text. The opposite of encode_base64.\n\n=cut\nsub decode_base64\n{\neval \"use MIME::Base64 ()\";\nif (!$@) {\n\treturn MIME::Base64::decode($_[0]);\n\t}\nmy ($str) = @_;\nmy $res;\n$str =~ tr|A-Za-z0-9+=/||cd;            # remove non-base64 chars\nif (length($str) % 4) {\n\treturn undef;\n}\n$str =~ s/=+$//;                        # remove padding\n$str =~ tr|A-Za-z0-9+/| -_|;            # convert to uuencoded format\nwhile ($str =~ /(.{1,60})/gs) {\n        my $len = chr(32 + length($1)*3/4); # compute length byte\n        $res .= unpack(\"u\", $len . $1 );    # uudecode\n\t}\nreturn $res;\n}\n\n=head2 encode_base32(string)\n\nEncodes a string into base32 format.\n\n=cut\nsub encode_base32\n{\n$_ = shift @_;\nmy ($buffer, $l, $e);\n$_ = unpack('B*', $_);\ns/(.....)/000$1/g;\n$l = length;\nif ($l & 7) {\n\t$e = substr($_, $l & ~7);\n\t$_ = substr($_, 0, $l & ~7);\n\t$_ .= \"000$e\" . '0' x (5 - length $e);\n\t}\n$_ = pack('B*', $_);\ntr|\\0-\\37|A-Z2-7|;\n$_;\n}\n\n=head2 decode_base32(string)\n\nConverts a base32-encoded string into plain text. The opposite of encode_base32.\n\n=cut\nsub decode_base32\n{\n$_ = shift;\nmy ($l);\ntr|A-Z2-7|\\0-\\37|;\n$_ = unpack('B*', $_);\ns/000(.....)/$1/g;\n$l = length;\n$_ = substr($_, 0, $l & ~7) if $l & 7;\n$_ = pack('B*', $_);\nreturn $_;\n}\n\n=head2 get_module_info(module, [noclone], [forcache])\n\nReturns a hash containg details of the given module. Some useful keys are :\n\n=item dir - The module directory, like sendmail.\n\n=item desc - Human-readable description, in the current users' language.\n\n=item version - Optional module version number.\n\n=item os_support - List of supported operating systems and versions.\n\n=item category - Category on Webmin's left menu, like net.\n\n=cut\nsub get_module_info\n{\nreturn () if ($_[0] =~ /^\\./);\nmy (%rv, $clone, $o);\nmy $mdir = &module_root_directory($_[0]);\n&read_file_cached(\"$mdir/module.info\", \\%rv) || return ();\nif (-l $mdir) {\n\t# A clone is a module that links to another directory under the root\n\tforeach my $r (@root_directories) {\n\t\tif (&is_under_directory($r, $mdir)) {\n\t\t\t$clone = readlink($mdir);\n\t\t\t$clone =~ s/^.*\\///;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\n\n# Apply language-specific override files\nforeach $o (@lang_order_list) {\n\tnext if ($o eq \"en\");\n\t&read_file_cached(\"$mdir/module.info.$o\", \\%rv);\n\t}\n\n# Apply desc_$LANG overrides\nforeach $o (@lang_order_list) {\n\t$rv{\"desc\"} = $rv{\"desc_$o\"} if ($rv{\"desc_$o\"});\n\t$rv{\"longdesc\"} = $rv{\"longdesc_$o\"} if ($rv{\"longdesc_$o\"});\n\t}\n\n# Apply overrides if this is a cloned module\nif ($clone && !$_[1] && $config_directory) {\n\t$rv{'clone'} = $rv{'desc'};\n\t$rv{'cloneof'} = $clone;\n\t&read_file(\"$config_directory/$_[0]/clone\", \\%rv);\n\t}\n$rv{'dir'} = $_[0];\nmy %module_categories;\n&read_file_cached(\"$config_directory/webmin.cats\", \\%module_categories);\nmy $pn = &get_product_name();\nif (defined($rv{'category_'.$pn})) {\n\t# Can override category for webmin/usermin\n\t$rv{'category'} = $rv{'category_'.$pn};\n\t}\n$rv{'realcategory'} = $rv{'category'};\n$rv{'category'} = $module_categories{$_[0]}\n\tif (defined($module_categories{$_[0]}));\n\n# Apply site-specific description overrides\n$rv{'realdesc'} = $rv{'desc'};\nmy %descs;\n&read_file_cached(\"$config_directory/webmin.descs\", \\%descs);\nif ($descs{$_[0]}) {\n\t$rv{'desc'} = $descs{$_[0]};\n\t}\nforeach my $o (@lang_order_list) {\n\tmy $ov = $descs{$_[0].\" \".$o} || $descs{$_[0].\"_\".$o};\n\t$rv{'desc'} = $ov if ($ov);\n\t}\n\nif (!$_[2]) {\n\t# Apply per-user description override\n\tmy %gaccess = &get_module_acl(undef, \"\");\n\tif ($gaccess{'desc_'.$_[0]}) {\n\t\t$rv{'desc'} = $gaccess{'desc_'.$_[0]};\n\t\t}\n\t}\n\nif ($rv{'longdesc'}) {\n\t# All standard modules have an index.cgi\n\t$rv{'index_link'} = 'index.cgi';\n\t}\n\n# Call theme-specific override function\nif (defined(&theme_get_module_info)) {\n\t%rv = &theme_get_module_info(\\%rv, $_[0], $_[1], $_[2]);\n\t}\n\nreturn %rv;\n}\n\n=head2 get_all_module_infos(cachemode)\n\nReturns a list contains the information on all modules in this webmin\ninstall, including clones. Uses caching to reduce the number of module.info\nfiles that need to be read. Each element of the array is a hash reference\nin the same format as returned by get_module_info. The cache mode flag can be :\n0 = read and write, 1 = don't read or write, 2 = read only\n\n=cut\nsub get_all_module_infos\n{\nmy (%cache, @rv);\n\n# Is the cache out of date? (ie. have any of the root's changed?)\nmy $cache_file = \"$config_directory/module.infos.cache\";\nif (!-r $cache_file) {\n\t$cache_file = \"$var_directory/module.infos.cache\";\n\t}\nmy $changed = 0;\nif (&read_file_cached($cache_file, \\%cache)) {\n\tforeach my $r (@root_directories) {\n\t\tmy @st = stat($r);\n\t\tif ($st[9] != $cache{'mtime_'.$r}) {\n\t\t\t$changed = 2;\n\t\t\tlast;\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t$changed = 1;\n\t}\n\nif ($_[0] != 1 && !$changed && $cache{'lang'} eq $current_lang) {\n\t# Can use existing module.info cache\n\tmy %mods;\n\tforeach my $k (keys %cache) {\n\t\tif ($k =~ /^(\\S+) (\\S+)$/) {\n\t\t\t$mods{$1}->{$2} = $cache{$k};\n\t\t\t}\n\t\t}\n\t@rv = map { $mods{$_} } (keys %mods) if (%mods);\n\t}\nelse {\n\t# Need to rebuild cache\n\t%cache = ( );\n\tforeach my $r (@root_directories) {\n\t\topendir(DIR, $r);\n\t\tforeach my $m (readdir(DIR)) {\n\t\t\tnext if ($m =~ /^(config-|\\.)/ || $m =~ /\\.(cgi|pl)$/);\n\t\t\tmy %minfo = &get_module_info($m, 0, 1);\n\t\t\tnext if (!%minfo || !$minfo{'dir'});\n\t\t\tpush(@rv, \\%minfo);\n\t\t\tforeach $k (keys %minfo) {\n\t\t\t\t$cache{\"${m} ${k}\"} = $minfo{$k};\n\t\t\t\t}\n\t\t\t}\n\t\tclosedir(DIR);\n\t\tmy @st = stat($r);\n\t\t$cache{'mtime_'.$r} = $st[9];\n\t\t}\n\t$cache{'lang'} = $current_lang;\n\tif (!$_[0] && $< == 0 && $> == 0) {\n\t\teval {\n\t\t\t# Don't fail if cache write fails\n\t\t\tlocal $main::error_must_die = 1;\n\t\t\t&write_file($cache_file, \\%cache);\n\t\t\t}\n\t\t}\n\t}\n\n# Override descriptions for modules for current user\nmy %gaccess = &get_module_acl(undef, \"\");\nforeach my $m (@rv) {\n\tif ($gaccess{\"desc_\".$m->{'dir'}}) {\n\t\t$m->{'desc'} = $gaccess{\"desc_\".$m->{'dir'}};\n\t\t}\n\t}\n\n# Apply installed flags\nmy %installed;\n&read_file_cached(\"$config_directory/installed.cache\", \\%installed);\nforeach my $m (@rv) {\n\t$m->{'installed'} = $installed{$m->{'dir'}};\n\t}\n\nreturn @rv;\n}\n\n=head2 list_themes\n\nReturns an array of all installed themes, each of which is a hash ref\ncorresponding to the theme.info file.\n\n=cut\nsub list_themes\n{\nmy @rv;\nopendir(DIR, $root_directory);\nforeach my $m (readdir(DIR)) {\n\tmy %tinfo;\n\tnext if ($m =~ /^\\./);\n\tnext if (!&read_file_cached(\"$root_directory/$m/theme.info\", \\%tinfo));\n\tnext if (!&check_os_support(\\%tinfo));\n\tforeach my $o (@lang_order_list) {\n\t\tif ($tinfo{'desc_'.$o}) {\n\t\t\t$tinfo{'desc'} = $tinfo{'desc_'.$o};\n\t\t\t}\n\t\t}\n\t$tinfo{'dir'} = $m;\n\tpush(@rv, \\%tinfo);\n\t}\nclosedir(DIR);\nreturn sort { lc($a->{'desc'}) cmp lc($b->{'desc'}) } @rv;\n}\n\n=head2 get_theme_info(theme)\n\nReturns a hash containing a theme's details, taken from it's theme.info file.\nSome useful keys are :\n\n=item dir - The theme directory, like blue-theme.\n\n=item desc - Human-readable description, in the current users' language.\n\n=item version - Optional module version number.\n\n=item os_support - List of supported operating systems and versions.\n\n=cut\nsub get_theme_info\n{\nreturn () if ($_[0] =~ /^\\./);\nmy %rv;\nmy $tdir = &module_root_directory($_[0]);\n&read_file(\"$tdir/theme.info\", \\%rv) || return ();\nforeach my $o (@lang_order_list) {\n\t$rv{\"desc\"} = $rv{\"desc_$o\"} if ($rv{\"desc_$o\"});\n\t}\n$rv{\"dir\"} = $_[0];\nreturn %rv;\n}\n\n=head2 list_languages(current-lang)\n\nReturns an array of supported languages, taken from Webmin's os_list.txt file.\nEach is a hash reference with the following keys :\n\n=item lang - The short language code, like es for Spanish.\n\n=item desc - A human-readable description, in English.\n\n=item charset - An optional character set to use when displaying the language.\n\n=item titles - Set to 1 only if Webmin has title images for the language.\n\n=item fallback - The code for another language to use if a string does not exist in this one. For all languages, English is the ultimate fallback.\n\n=cut\nsub list_languages\n{\nmy ($current) = @_;\nif (!@main::list_languages_cache) {\n\tmy $o;\n\tlocal $_;\n\topen(LANG, \"$root_directory/lang_list.txt\");\n\twhile(<LANG>) {\n\t\tif (/^(\\S+)\\s+(.*)/) {\n\t\t\tmy $l = { 'desc' => $2 };\n\t\t\tforeach $o (split(/,/, $1)) {\n\t\t\t\tif ($o =~ /^([^=]+)=(.*)$/) {\n\t\t\t\t\t$l->{$1} = $2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t$l->{'index'} = scalar(@main::list_languages_cache);\n\t\t\tpush(@main::list_languages_cache, $l);\n\t\t\tmy $utf8lang = $l->{'lang'};\n\t\t\t$utf8lang =~ s/\\.(\\S+)$//;\n\t\t\t$utf8lang =~ s/_RU$//;\n\t\t\t$utf8lang .= \".UTF-8\";\n\t\t\tif ($l->{'charset'} ne 'UTF-8' &&\n\t\t\t    ($l->{'charset'} eq 'iso-8859-1' ||\n\t\t             $l->{'charset'} eq 'iso-8859-2' ||\n\t\t\t     -r \"$root_directory/lang/$utf8lang\")) {\n\t\t\t\t# Add UTF-8 variant\n\t\t\t\tmy $ul = { %$l };\n\t\t\t\t$ul->{'charset'} = 'UTF-8';\n\t\t\t\t$ul->{'lang'} = $utf8lang;\n\t\t\t\t$ul->{'index'} =\n\t\t\t\t\tscalar(@main::list_languages_cache);\n\t\t\t\t$l->{'utf8_variant'} = $ul;\n\t\t\t\tpush(@main::list_languages_cache, $ul);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tclose(LANG);\n\t@main::list_languages_cache = sort { $a->{'desc'} cmp $b->{'desc'} }\n\t\t\t\t     @main::list_languages_cache;\n\t}\nif ($current && $current =~ /\\.UTF-8$/) {\n\t# If the user is already using a UTF-8 language encoding, filter out\n\t# languages that have a UTF-8 variant\n\treturn grep { $_->{'charset'} eq 'UTF-8' ||\n\t\t      !$_->{'utf8_variant'} } @main::list_languages_cache;\n\t}\nreturn @main::list_languages_cache;\n}\n\n=head2 read_env_file(file, &hash, [include-commented])\n\nSimilar to Webmin's read_file function, but handles files containing shell\nenvironment variables formatted like :\n\n  export FOO=bar\n  SMEG=\"spod\"\n\nThe file parameter is the full path to the file to read, and hash a Perl hash\nref to read names and values into.\n\n=cut\nsub read_env_file\n{\nlocal $_;\n&open_readfile(FILE, $_[0]) || return 0;\nwhile(<FILE>) {\n\tif ($_[2]) {\n\t\t# Remove start of line comments\n\t\ts/^\\s*#+\\s*//;\n\t\t}\n\ts/#.*$//g;\n\tif (/^\\s*(export\\s*)?([A-Za-z0-9_\\.]+)\\s*=\\s*\"(.*)\"/i ||\n\t    /^\\s*(export\\s*)?([A-Za-z0-9_\\.]+)\\s*=\\s*'(.*)'/i ||\n\t    /^\\s*(export\\s*)?([A-Za-z0-9_\\.]+)\\s*=\\s*(.*)/i) {\n\t\t$_[1]->{$2} = $3;\n\t\t}\n\t}\nclose(FILE);\nreturn 1;\n}\n\n=head2 write_env_file(file, &hash, [export])\n\nWrites out a hash to a file in name='value' format, suitable for use in a shell\nscript. The parameters are :\n\n=item file - Full path for a file to write to\n\n=item hash - Hash reference of names and values to write.\n\n=item export - If set to 1, prepend each variable setting with the word 'export'.\n\n=cut\nsub write_env_file\n{\nmy $exp = $_[2] ? \"export \" : \"\";\n&open_tempfile(FILE, \">$_[0]\");\nforeach my $k (keys %{$_[1]}) {\n\tmy $v = $_[1]->{$k};\n\tif ($v =~ /^\\S+$/) {\n\t\t&print_tempfile(FILE, \"$exp$k=$v\\n\");\n\t\t}\n\telse {\n\t\t&print_tempfile(FILE, \"$exp$k=\\\"$v\\\"\\n\");\n\t\t}\n\t}\n&close_tempfile(FILE);\n}\n\n=head2 lock_file(filename, [readonly], [forcefile])\n\nLock a file for exclusive access. If the file is already locked, spin\nuntil it is freed. Uses a .lock file, which is not 100% reliable, but seems\nto work OK. The parameters are :\n\n=item filename - File or directory to lock.\n\n=item readonly - If set, the lock is for reading the file only. More than one script can have a readonly lock, but only one can hold a write lock.\n\n=item forcefile - Force the file to be considered as a real file and not a symlink for Webmin actions logging purposes.\n\n=cut\nsub lock_file\n{\nmy ($file, $readonly, $forcefile) = @_;\nif ($file =~ /\\r|\\n|\\0/) {\n\t&error(\"Lock filename contains invalid characters\");\n\t}\nmy $realfile = &translate_filename($file);\nreturn 0 if (!$file || defined($main::locked_file_list{$realfile}));\nmy $no_lock = !&can_lock_file($realfile);\nmy $lock_tries_count = 0;\nmy $last_lock_err;\nwhile(1) {\n\tmy $pid;\n\tif (!$no_lock && open(LOCKING, \"$realfile.lock\")) {\n\t\t$pid = <LOCKING>;\n\t\t$pid = int($pid);\n\t\tclose(LOCKING);\n\t\t}\n\tif ($no_lock || !$pid || !kill(0, $pid) || $pid == $$) {\n\t\t# Got the lock!\n\t\tif (!$no_lock) {\n\t\t\t# Create the .lock file\n\t\t\tmy $lockfile = $realfile.\".lock\";\n\t\t\tunlink($lockfile);\n\t\t\topen(LOCKING, \">$lockfile\") || return 0;\n\t\t\tmy $lck = eval \"flock(LOCKING, 2+4)\";\n\t\t\tmy $err = $!;\n\t\t\tif (!$lck && !$@) {\n\t\t\t\t# Lock of lock file failed! Wait till later\n\t\t\t\tclose(LOCKING);\n\t\t\t\tunlink($lockfile);\n\t\t\t\t$last_lock_err = \"Flock failed : \".($@ || $err);\n\t\t\t\tgoto tryagain;\n\t\t\t\t}\n\t\t\tmy $ok = (print LOCKING $$,\"\\n\");\n\t\t\t$err = $!;\n\t\t\tif (!$ok) {\n\t\t\t\t# Failed to write to .lock file ..\n\t\t\t\tclose(LOCKING);\n\t\t\t\tunlink($lockfile);\n\t\t\t\t$last_lock_err = \"Lock write failed : \".$err;\n\t\t\t\tgoto tryagain;\n\t\t\t\t}\n\t\t\teval \"flock(LOCKING, 8)\";\n\t\t\t$ok = close(LOCKING);\n\t\t\t$err = $!;\n\t\t\tif (!$ok) {\n\t\t\t\t# Failed to close lock file\n\t\t\t\tunlink($lockfile);\n\t\t\t\t$last_lock_err = \"Lock close failed : \".$err;\n\t\t\t\tgoto tryagain;\n\t\t\t\t}\n\t\t\t}\n\t\t$main::locked_file_list{$realfile} = int($readonly);\n\t\tpush(@main::temporary_files, $lockfile);\n\t\tif (($gconfig{'logfiles'} || $gconfig{'logfullfiles'}) &&\n\t\t    !&get_module_variable('$no_log_file_changes') &&\n\t\t    !$readonly) {\n\t\t\t# Grab a copy of this file for later diffing\n\t\t\tmy $lnk;\n\t\t\t$main::locked_file_data{$realfile} = undef;\n\t\t\tif (-d $realfile) {\n\t\t\t\t$main::locked_file_type{$realfile} = 1;\n\t\t\t\t$main::locked_file_data{$realfile} = '';\n\t\t\t\t}\n\t\t\telsif (!$forcefile && ($lnk = readlink($realfile))) {\n\t\t\t\t$main::locked_file_type{$realfile} = 2;\n\t\t\t\t$main::locked_file_data{$realfile} = $lnk;\n\t\t\t\t}\n\t\t\telsif (open(ORIGFILE, $realfile)) {\n\t\t\t\t$main::locked_file_type{$realfile} = 0;\n\t\t\t\t$main::locked_file_data{$realfile} = '';\n\t\t\t\tlocal $_;\n\t\t\t\twhile(<ORIGFILE>) {\n\t\t\t\t\t$main::locked_file_data{$realfile} .=$_;\n\t\t\t\t\t}\n\t\t\t\tclose(ORIGFILE);\n\t\t\t\t}\n\t\t\t}\n\t\tlast;\n\t\t}\n\telsif ($pid) {\n\t\t$last_lock_err = \"Locked by PID $pid\";\n\t\t}\n\telsif (!$pid) {\n\t\t$last_lock_err = \"Lock file contains no PID\";\n\t\t}\ntryagain:\n\tsleep(1);\n\tif ($lock_tries_count++ > 5*60) {\n\t\t# Give up after 5 minutes\n\t\t&error(&text('elock_tries2', \"<tt>$realfile</tt>\", 5,\n\t\t\t     $last_lock_err));\n\t\t}\n\t}\nreturn 1;\n}\n\n=head2 unlock_file(filename)\n\nRelease a lock on a file taken out by lock_file. If Webmin actions logging of\nfile changes is enabled, then at unlock file a diff will be taken between the\nold and new contents, and stored under /var/webmin/diffs when webmin_log is\ncalled. This can then be viewed in the Webmin Actions Log module.\n\n=cut\nsub unlock_file\n{\nmy ($file) = @_;\nmy $realfile = &translate_filename($file);\nreturn if (!$file || !defined($main::locked_file_list{$realfile}));\nunlink(\"$realfile.lock\") if (&can_lock_file($realfile));\ndelete($main::locked_file_list{$realfile});\nif (exists($main::locked_file_data{$realfile})) {\n\t# Diff the new file with the old\n\tstat($realfile);\n\tmy $lnk = readlink($realfile);\n\tmy $type = -d _ ? 1 : $lnk ? 2 : 0;\n\tmy $oldtype = $main::locked_file_type{$realfile};\n\tmy $new = !defined($main::locked_file_data{$realfile});\n\tif ($new && !-e _) {\n\t\t# file doesn't exist, and never did! do nothing ..\n\t\t}\n\telsif ($new && $type == 1 || !$new && $oldtype == 1) {\n\t\t# is (or was) a directory ..\n\t\tif (-d _ && !defined($main::locked_file_data{$realfile})) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'mkdir', 'object' => $realfile });\n\t\t\t}\n\t\telsif (!-d _ && defined($main::locked_file_data{$realfile})) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'rmdir', 'object' => $realfile });\n\t\t\t}\n\t\t}\n\telsif ($new && $type == 2 || !$new && $oldtype == 2) {\n\t\t# is (or was) a symlink ..\n\t\tif ($lnk && !defined($main::locked_file_data{$realfile})) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'symlink', 'object' => $realfile,\n\t\t\t       'data' => $lnk });\n\t\t\t}\n\t\telsif (!$lnk && defined($main::locked_file_data{$realfile})) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'unsymlink', 'object' => $realfile,\n\t\t\t       'data' => $main::locked_file_data{$realfile} });\n\t\t\t}\n\t\telsif ($lnk ne $main::locked_file_data{$realfile}) {\n\t\t\tpush(@main::locked_file_diff,\n\t\t\t     { 'type' => 'resymlink', 'object' => $realfile,\n\t\t\t       'data' => $lnk });\n\t\t\t}\n\t\t}\n\telse {\n\t\t# is a file, or has changed type?!\n\t\tmy ($diff, $delete_file);\n\t\tmy $type = \"modify\";\n\t\tif (!-r _) {\n\t\t\topen(NEWFILE, \">$realfile\");\n\t\t\tclose(NEWFILE);\n\t\t\t$delete_file++;\n\t\t\t$type = \"delete\";\n\t\t\t}\n\t\tif (!defined($main::locked_file_data{$realfile})) {\n\t\t\t$type = \"create\";\n\t\t\t}\n\t\topen(ORIGFILE, \">$realfile.webminorig\");\n\t\tprint ORIGFILE $main::locked_file_data{$realfile};\n\t\tclose(ORIGFILE);\n\t\t$diff = &backquote_command(\n\t\t\t\"diff \".quotemeta(\"$realfile.webminorig\").\" \".\n\t\t\t\tquotemeta($realfile).\" 2>/dev/null\");\n\t\tpush(@main::locked_file_diff,\n\t\t     { 'type' => $type, 'object' => $realfile,\n\t\t       'data' => $diff } ) if ($diff);\n\t\tunlink(\"$realfile.webminorig\");\n\t\tunlink($realfile) if ($delete_file);\n\t\t}\n\n\tif ($gconfig{'logfullfiles'}) {\n\t\t# Add file details to list of those to fully log\n\t\t$main::orig_file_data{$realfile} ||=\n\t\t\t$main::locked_file_data{$realfile};\n\t\t$main::orig_file_type{$realfile} ||=\n\t\t\t$main::locked_file_type{$realfile};\n\t\t}\n\n\tdelete($main::locked_file_data{$realfile});\n\tdelete($main::locked_file_type{$realfile});\n\t}\n}\n\n=head2 test_lock(file)\n\nReturns the PID if some file is currently locked, 0 if not.\n\n=cut\nsub test_lock\n{\nmy ($file) = @_;\nmy $realfile = &translate_filename($file);\nreturn 0 if (!$file);\nreturn $$ if (defined($main::locked_file_list{$realfile}));\nreturn 0 if (!&can_lock_file($realfile));\nmy $pid;\nif (open(LOCKING, \"$realfile.lock\")) {\n\t$pid = <LOCKING>;\n\t$pid = int($pid);\n\tclose(LOCKING);\n\t}\nreturn $pid && kill(0, $pid) ? $pid : undef;\n}\n\n=head2 unlock_all_files\n\nUnlocks all files locked by the current script.\n\n=cut\nsub unlock_all_files\n{\nforeach $f (keys %main::locked_file_list) {\n\t&unlock_file($f);\n\t}\n}\n\n=head2 can_lock_file(file)\n\nReturns 1 if some file should be locked, based on the settings in the\nWebmin Configuration module. For internal use by lock_file only.\n\n=cut\nsub can_lock_file\n{\nif (&is_readonly_mode()) {\n\treturn 0;\t# never lock in read-only mode\n\t}\nelsif ($gconfig{'lockmode'} == 0) {\n\treturn 1;\t# always\n\t}\nelsif ($gconfig{'lockmode'} == 1) {\n\treturn 0;\t# never\n\t}\nelse {\n\t# Check if under any of the directories\n\tmy $match;\n\tforeach my $d (split(/\\t+/, $gconfig{'lockdirs'})) {\n\t\tif (&same_file($d, $_[0]) ||\n\t\t    &is_under_directory($d, $_[0])) {\n\t\t\t$match = 1;\n\t\t\t}\n\t\t}\n\treturn $gconfig{'lockmode'} == 2 ? $match : !$match;\n\t}\n}\n\n=head2 webmin_log(action, type, object, &params, [module], [host, script-on-host, client-ip])\n\nLog some action taken by a user. This is typically called at the end of a\nscript, once all file changes are complete and all commands run. The\nparameters are :\n\n=item action - A short code for the action being performed, like 'create'.\n\n=item type - A code for the type of object the action is performed to, like 'user'.\n\n=item object - A short name for the object, like 'joe' if the Unix user 'joe' was just created.\n\n=item params - A hash ref of additional information about the action.\n\n=item module - Name of the module in which the action was performed, which defaults to the current module.\n\n=item host - Remote host on which the action was performed. You should never need to set this (or the following two parameters), as they are used only for remote Webmin logging.\n\n=item script-on-host - Script name like create_user.cgi on the host the action was performed on.\n\n=item client-ip - IP address of the browser that performed the action.\n\n=cut\nsub webmin_log\n{\nreturn if (!$gconfig{'log'} || &is_readonly_mode());\nmy $m = $_[4] ? $_[4] : &get_module_name();\n\nif ($gconfig{'logclear'}) {\n\t# check if it is time to clear the log\n\tmy @st = stat(\"$webmin_logfile.time\");\n\tmy $write_logtime = 0;\n\tif (@st) {\n\t\tif ($st[9]+$gconfig{'logtime'}*60*60 < time()) {\n\t\t\t# clear logfile and all diff files\n\t\t\t&unlink_file(\"$ENV{'WEBMIN_VAR'}/diffs\");\n\t\t\t&unlink_file(\"$ENV{'WEBMIN_VAR'}/files\");\n\t\t\t&unlink_file(\"$ENV{'WEBMIN_VAR'}/annotations\");\n\t\t\tunlink($webmin_logfile);\n\t\t\t$write_logtime = 1;\n\t\t\t}\n\t\t}\n\telse {\n\t\t$write_logtime = 1;\n\t\t}\n\tif ($write_logtime) {\n\t\topen(LOGTIME, \">$webmin_logfile.time\");\n\t\tprint LOGTIME time(),\"\\n\";\n\t\tclose(LOGTIME);\n\t\t}\n\t}\n\n# If an action script directory is defined, call the appropriate scripts\nif ($gconfig{'action_script_dir'}) {\n\tmy ($action, $type, $object) = ($_[0], $_[1], $_[2]);\n\tmy ($basedir) = $gconfig{'action_script_dir'};\n\tfor my $dir (\"$basedir/$type/$action\", \"$basedir/$type\", $basedir) {\n\t\tnext if (!-d $dir);\n\t\tmy ($file);\n\t\topendir(DIR, $dir) or die \"Can't open $dir: $!\";\n\t\twhile (defined($file = readdir(DIR))) {\n\t\t\tnext if ($file =~ /^\\.\\.?$/); # skip . and ..\n\t\t\tnext if (!-x \"$dir/$file\");\n\t\t\tmy %OLDENV = %ENV;\n\t\t\t$ENV{'ACTION_MODULE'} = &get_module_name();\n\t\t\t$ENV{'ACTION_ACTION'} = $_[0];\n\t\t\t$ENV{'ACTION_TYPE'} = $_[1];\n\t\t\t$ENV{'ACTION_OBJECT'} = $_[2];\n\t\t\t$ENV{'ACTION_SCRIPT'} = $script_name;\n\t\t\tforeach my $p (keys %param) {\n\t\t\t    $ENV{'ACTION_PARAM_'.uc($p)} = $param{$p};\n\t\t\t    }\n\t\t\tsystem(\"$dir/$file\", @_,\n\t\t\t   \"<$null_file\", \">$null_file\", \"2>&1\");\n\t\t\t%ENV = %OLDENV;\n\t\t\t}\n\t\t}\n\t}\n\n# should logging be done at all?\nreturn if ($gconfig{'logusers'} && &indexof($base_remote_user,\n\t   split(/\\s+/, $gconfig{'logusers'})) < 0);\nreturn if ($gconfig{'logmodules'} && &indexof($m,\n\t   split(/\\s+/, $gconfig{'logmodules'})) < 0);\n\n# log the action\nmy $now = time();\nmy @tm = localtime($now);\nmy $script_name = $0 =~ /([^\\/]+)$/ ? $1 : '-';\nmy $id = sprintf \"%d.%d.%d\", $now, $$, $main::action_id_count;\nmy $idprefix = substr($now, 0, 5);\n$main::action_id_count++;\nmy $line = sprintf \"%s [%2.2d/%s/%4.4d %2.2d:%2.2d:%2.2d] %s %s %s %s %s \\\"%s\\\" \\\"%s\\\" \\\"%s\\\"\",\n\t$id, $tm[3], ucfirst($number_to_month_map{$tm[4]}), $tm[5]+1900,\n\t$tm[2], $tm[1], $tm[0],\n\t$remote_user || '-',\n\t$main::session_id || '-',\n\t$_[7] || $ENV{'REMOTE_HOST'} || '-',\n\t$m, $_[5] ? \"$_[5]:$_[6]\" : $script_name,\n\t$_[0], $_[1] ne '' ? $_[1] : '-', $_[2] ne '' ? $_[2] : '-';\nmy %param;\nforeach my $k (sort { $a cmp $b } keys %{$_[3]}) {\n\tmy $v = $_[3]->{$k};\n\tmy @pv;\n\tif ($v eq '') {\n\t\t$line .= \" $k=''\";\n\t\t@rv = ( \"\" );\n\t\t}\n\telsif (ref($v) eq 'ARRAY') {\n\t\tforeach $vv (@$v) {\n\t\t\tnext if (ref($vv));\n\t\t\tpush(@pv, $vv);\n\t\t\t$vv =~ s/(['\"\\\\\\r\\n\\t\\%])/sprintf(\"%%%2.2X\",ord($1))/ge;\n\t\t\t$line .= \" $k='$vv'\";\n\t\t\t}\n\t\t}\n\telsif (!ref($v)) {\n\t\tforeach $vv (split(/\\0/, $v)) {\n\t\t\tpush(@pv, $vv);\n\t\t\t$vv =~ s/(['\"\\\\\\r\\n\\t\\%])/sprintf(\"%%%2.2X\",ord($1))/ge;\n\t\t\t$line .= \" $k='$vv'\";\n\t\t\t}\n\t\t}\n\t$param{$k} = join(\" \", @pv);\n\t}\nopen(WEBMINLOG, \">>$webmin_logfile\");\nprint WEBMINLOG $line,\"\\n\";\nclose(WEBMINLOG);\nif ($gconfig{'logperms'}) {\n\tchmod(oct($gconfig{'logperms'}), $webmin_logfile);\n\t}\nelse {\n\tchmod(0600, $webmin_logfile);\n\t}\n\nif ($gconfig{'logfiles'} && !&get_module_variable('$no_log_file_changes')) {\n\t# Find and record the changes made to any locked files, or commands run\n\tmy $i = 0;\n\tmkdir(\"$ENV{'WEBMIN_VAR'}/diffs\", 0700);\n\tforeach my $d (@main::locked_file_diff) {\n\t\tmkdir(\"$ENV{'WEBMIN_VAR'}/diffs/$idprefix\", 0700);\n\t\tmkdir(\"$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id\", 0700);\n\t\topen(DIFFLOG, \">$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id/$i\");\n\t\tprint DIFFLOG \"$d->{'type'} $d->{'object'}\\n\";\n\t\tprint DIFFLOG $d->{'data'};\n\t\tclose(DIFFLOG);\n\t\tif ($d->{'input'}) {\n\t\t\topen(DIFFLOG,\n\t\t\t  \">$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id/$i.input\");\n\t\t\tprint DIFFLOG $d->{'input'};\n\t\t\tclose(DIFFLOG);\n\t\t\t}\n\t\tif ($gconfig{'logperms'}) {\n\t\t\tchmod(oct($gconfig{'logperms'}),\n\t\t\t     \"$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id/$i\",\n\t\t\t     \"$ENV{'WEBMIN_VAR'}/diffs/$idprefix/$id/$i.input\");\n\t\t\t}\n\t\t$i++;\n\t\t}\n\t@main::locked_file_diff = undef;\n\t}\n\nif ($gconfig{'logfullfiles'}) {\n\t# Save the original contents of any modified files\n\tmy $i = 0;\n\tmkdir(\"$ENV{'WEBMIN_VAR'}/files\", 0700);\n\tforeach my $f (keys %main::orig_file_data) {\n\t\tmkdir(\"$ENV{'WEBMIN_VAR'}/files/$idprefix\", 0700);\n\t\tmkdir(\"$ENV{'WEBMIN_VAR'}/files/$idprefix/$id\", 0700);\n\t\topen(ORIGLOG, \">$ENV{'WEBMIN_VAR'}/files/$idprefix/$id/$i\");\n\t\tif (!defined($main::orig_file_type{$f})) {\n\t\t\tprint ORIGLOG -1,\" \",$f,\"\\n\";\n\t\t\t}\n\t\telse {\n\t\t\tprint ORIGLOG $main::orig_file_type{$f},\" \",$f,\"\\n\";\n\t\t\t}\n\t\tprint ORIGLOG $main::orig_file_data{$f};\n\t\tclose(ORIGLOG);\n\t\tif ($gconfig{'logperms'}) {\n\t\t\tchmod(oct($gconfig{'logperms'}),\n\t\t\t      \"$ENV{'WEBMIN_VAR'}/files/$idprefix/$id.$i\");\n\t\t\t}\n\t\t$i++;\n\t\t}\n\t%main::orig_file_data = undef;\n\t%main::orig_file_type = undef;\n\t}\n\nif ($miniserv::page_capture_out) {\n\t# Save the whole page output\n\tmkdir(\"$ENV{'WEBMIN_VAR'}/output\", 0700);\n\tmkdir(\"$ENV{'WEBMIN_VAR'}/output/$idprefix\", 0700);\n\topen(PAGEOUT, \">$ENV{'WEBMIN_VAR'}/output/$idprefix/$id\");\n\tprint PAGEOUT $miniserv::page_capture_out;\n\tclose(PAGEOUT);\n\tif ($gconfig{'logperms'}) {\n\t\tchmod(oct($gconfig{'logperms'}),\n\t\t      \"$ENV{'WEBMIN_VAR'}/output/$idprefix/$id\");\n\t\t}\n\t$miniserv::page_capture_out = undef;\n\t}\n\n# Convert params to a format usable by parse_webmin_log\nmy %params;\nforeach my $k (keys %{$_[3]}) {\n\tmy $v = $_[3]->{$k};\n\tif (ref($v) eq 'ARRAY') {\n\t\t$params{$k} = join(\"\\0\", @$v);\n\t\t}\n\telse {\n\t\t$params{$k} = $v;\n\t\t}\n\t}\n\n# Construct description if one is needed\nmy $logemail = $gconfig{'logemail'} &&\n\t       (!$gconfig{'logmodulesemail'} ||\n\t        &indexof($m, split(/\\s+/, $gconfig{'logmodulesemail'})) >= 0) &&\n\t       &foreign_check(\"mailboxes\");\nmy $msg = undef;\nmy %minfo = &get_module_info($m);\nif ($logemail || $gconfig{'logsyslog'}) {\n\tmy $mod = &get_module_name();\n\tmy $mdir = module_root_directory($mod);\n\tif (&foreign_check(\"webminlog\")) {\n\t\t&foreign_require(\"webminlog\");\n\t\tmy $act = &webminlog::parse_logline($line);\n\t\t$msg = &webminlog::get_action_description($act, 0);\n\t\t$msg =~ s/<[^>]*>//g;\t# Remove tags\n\t\t}\n\t$msg ||= \"$_[0] $_[1] $_[2]\";\n\t}\n\n# Log to syslog too\nif ($gconfig{'logsyslog'}) {\n\teval 'use Sys::Syslog qw(:DEFAULT setlogsock);\n\t      openlog(&get_product_name(), \"cons,pid,ndelay\", \"daemon\");\n\t      setlogsock(\"inet\");';\n\tif (!$@) {\n\t\teval { syslog(\"info\", \"%s\", \"[$minfo{'desc'}] $msg\"); };\n\t\t}\n\t}\n\n# Log to email, if enabled and for this module\nif ($logemail) {\n\t# Construct an email message\n\t&foreign_require(\"mailboxes\");\n\tmy $mdesc;\n\tif ($m && $m ne \"global\") {\n\t\t$mdesc = $minfo{'desc'} || $m;\n\t\t}\n\tmy $body = $text{'log_email_desc'}.\"\\n\\n\";\n\t$body .= &text('log_email_mod', $m || \"global\").\"\\n\";\n\tif ($mdesc) {\n\t\t$body .= &text('log_email_moddesc', $mdesc).\"\\n\";\n\t\t}\n\t$body .= &text('log_email_time', &make_date(time())).\"\\n\";\n\t$body .= &text('log_email_system', &get_display_hostname()).\"\\n\";\n\t$body .= &text('log_email_user', $remote_user).\"\\n\";\n\t$body .= &text('log_email_remote', $_[7] || $ENV{'REMOTE_HOST'}).\"\\n\";\n\t$body .= &text('log_email_script', $script_name).\"\\n\";\n\tif ($main::session_id) {\n\t\t$body .= &text('log_email_session', $main::session_id).\"\\n\";\n\t\t}\n\t$body .= \"\\n\";\n\t$body .= $msg.\"\\n\";\n\t&mailboxes::send_text_mail(\n\t\t&mailboxes::get_from_address(),\n\t\t$gconfig{'logemail'},\n\t\tundef,\n\t\t$mdesc ? &text('log_email_subject', $mdesc)\n\t\t       : $text{'log_email_global'},\n\t\t$body);\n\t}\n}\n\n=head2 additional_log(type, object, data, [input])\n\nRecords additional log data for an upcoming call to webmin_log, such\nas a command that was run or SQL that was executed. Typically you will never\nneed to call this function directory.\n\n=cut\nsub additional_log\n{\nif ($gconfig{'logfiles'} && !&get_module_variable('$no_log_file_changes')) {\n\tpush(@main::locked_file_diff,\n\t     { 'type' => $_[0], 'object' => $_[1], 'data' => $_[2],\n\t       'input' => $_[3] } );\n\t}\n}\n\n=head2 webmin_debug_log(type, message)\n\nWrite something to the Webmin debug log. For internal use only.\n\n=cut\nsub webmin_debug_log\n{\nmy ($type, $msg) = @_;\nreturn 0 if (!$main::opened_debug_log);\nreturn 0 if ($gconfig{'debug_no'.$main::webmin_script_type});\nif ($gconfig{'debug_modules'}) {\n\tmy @dmods = split(/\\s+/, $gconfig{'debug_modules'});\n\treturn 0 if (&indexof($main::initial_module_name, @dmods) < 0);\n\t}\nmy $now;\neval 'use Time::HiRes qw(gettimeofday); ($now, $ms) = gettimeofday';\n$now ||= time();\nmy @tm = localtime($now);\nmy $line = sprintf\n\t\"%s [%2.2d/%s/%4.4d %2.2d:%2.2d:%2.2d.%6.6d] %s %s %s %s \\\"%s\\\"\",\n        $$, $tm[3], ucfirst($number_to_month_map{$tm[4]}), $tm[5]+1900,\n        $tm[2], $tm[1], $tm[0], $ms,\n\t$remote_user || \"-\",\n\t$ENV{'REMOTE_HOST'} || \"-\",\n\t&get_module_name() || \"-\",\n\t$type,\n\t$msg;\nseek(main::DEBUGLOG, 0, 2);\nprint main::DEBUGLOG $line.\"\\n\";\nreturn 1;\n}\n\n=head2 system_logged(command)\n\nJust calls the Perl system() function, but also logs the command run.\n\n=cut\nsub system_logged\n{\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing command $_[0]\\n\";\n\treturn 0;\n\t}\nmy @realcmd = ( &translate_command($_[0]), @_[1..$#_] );\nmy $cmd = join(\" \", @realcmd);\nmy $and;\nif ($cmd =~ s/(\\s*&\\s*)$//) {\n\t$and = $1;\n\t}\nwhile($cmd =~ s/(\\d*)(<|>)((\\/(tmp|dev)\\S+)|&\\d+)\\s*$//) { }\n$cmd =~ s/^\\((.*)\\)\\s*$/$1/;\n$cmd .= $and;\n&additional_log('exec', undef, $cmd);\nreturn system(@realcmd);\n}\n\n=head2 backquote_logged(command)\n\nExecutes a command and returns the output (like `command`), but also logs it.\n\n=cut\nsub backquote_logged\n{\nif (&is_readonly_mode()) {\n\t$? = 0;\n\tprint STDERR \"Vetoing command $_[0]\\n\";\n\treturn undef;\n\t}\nmy $realcmd = &translate_command($_[0]);\nmy $cmd = $realcmd;\nmy $and;\nif ($cmd =~ s/(\\s*&\\s*)$//) {\n\t$and = $1;\n\t}\nwhile($cmd =~ s/(\\d*)(<|>)((\\/(tmp\\/.webmin|dev)\\S+)|&\\d+)\\s*$//) { }\n$cmd =~ s/^\\((.*)\\)\\s*$/$1/;\n$cmd .= $and;\n&additional_log('exec', undef, $cmd);\n&webmin_debug_log('CMD', \"cmd=$cmd\") if ($gconfig{'debug_what_cmd'});\nif ($realcmd !~ /;|\\&\\&|\\|/ && $realcmd !~ /^\\s*\\(/) {\n\t# Force run in shell, to get useful output if command doesn't exist\n\t$realcmd = \"($realcmd)\";\n\t}\nreturn `$realcmd`;\n}\n\n=head2 backquote_with_timeout(command, timeout, safe?, [maxlines])\n\nRuns some command, waiting at most the given number of seconds for it to\ncomplete, and returns the output. The maxlines parameter sets the number\nof lines of output to capture. The safe parameter should be set to 1 if the\ncommand is safe for read-only mode users to run.\n\n=cut\nsub backquote_with_timeout\n{\nmy $realcmd = &translate_command($_[0]);\nmy $out;\nmy $pid = &open_execute_command(OUT, \"($realcmd) <$null_file\", 1, $_[2]);\nmy $start = time();\nmy $timed_out = 0;\nmy $linecount = 0;\nwhile(1) {\n\tmy $elapsed = time() - $start;\n\tlast if ($elapsed > $_[1]);\n\tmy $rmask;\n\tvec($rmask, fileno(OUT), 1) = 1;\n\tmy $sel = select($rmask, undef, undef, $_[1] - $elapsed);\n\tlast if (!$sel || $sel < 0);\n\tmy $line = <OUT>;\n\tlast if (!defined($line));\n\t$out .= $line;\n\t$linecount++;\n\tif ($_[3] && $linecount >= $_[3]) {\n\t\t# Got enough lines\n\t\tlast;\n\t\t}\n\t}\nif (kill('TERM', $pid) && time() - $start >= $_[1]) {\n\t$timed_out = 1;\n\t}\nclose(OUT);\nreturn wantarray ? ($out, $timed_out) : $out;\n}\n\n=head2 backquote_command(command, safe?)\n\nExecutes a command and returns the output (like `command`), subject to\ncommand translation. The safe parameter should be set to 1 if the command\nis safe for read-only mode users to run.\n\n=cut\nsub backquote_command\n{\nif (&is_readonly_mode() && !$_[1]) {\n\tprint STDERR \"Vetoing command $_[0]\\n\";\n\t$? = 0;\n\treturn undef;\n\t}\nmy $realcmd = &translate_command($_[0]);\n&webmin_debug_log('CMD', \"cmd=$realcmd\") if ($gconfig{'debug_what_cmd'});\nif ($realcmd !~ /;|\\&\\&|\\|/ && $realcmd !~ /^\\s*\\(/) {\n\t# Force run in shell, to get useful output if command doesn't exist\n\t$realcmd = \"($realcmd)\";\n\t}\nreturn `$realcmd`;\n}\n\n=head2 kill_logged(signal, pid, ...)\n\nLike Perl's built-in kill function, but also logs the fact that some process\nwas killed. On Windows, falls back to calling process.exe to terminate a\nprocess.\n\n=cut\nsub kill_logged\n{\nreturn scalar(@_)-1 if (&is_readonly_mode());\n&webmin_debug_log('KILL', \"signal=$_[0] pids=\".join(\" \", @_[1..@_-1]))\n\tif ($gconfig{'debug_what_procs'});\n&additional_log('kill', $_[0], join(\" \", @_[1..@_-1])) if (@_ > 1);\nif ($gconfig{'os_type'} eq 'windows') {\n\t# Emulate some kills with process.exe\n\tmy $arg = $_[0] eq \"KILL\" ? \"-k\" :\n\t\t  $_[0] eq \"TERM\" ? \"-q\" :\n\t\t  $_[0] eq \"STOP\" ? \"-s\" :\n\t\t  $_[0] eq \"CONT\" ? \"-r\" : undef;\n\tmy $ok = 0;\n\tforeach my $p (@_[1..@_-1]) {\n\t\tif ($p < 0) {\n\t\t\t$ok ||= kill($_[0], $p);\n\t\t\t}\n\t\telsif ($arg) {\n\t\t\t&execute_command(\"process $arg $p\");\n\t\t\t$ok = 1;\n\t\t\t}\n\t\t}\n\treturn $ok;\n\t}\nelse {\n\t# Normal Unix kill\n\treturn kill(@_);\n\t}\n}\n\n=head2 rename_logged(old, new)\n\nRe-names a file and logs the rename. If the old and new files are on different\nfilesystems, calls mv or the Windows rename function to do the job.\n\n=cut\nsub rename_logged\n{\n&additional_log('rename', $_[0], $_[1]) if ($_[0] ne $_[1]);\nreturn &rename_file($_[0], $_[1]);\n}\n\n=head2 rename_file(old, new)\n\nRenames a file or directory. If the old and new files are on different\nfilesystems, calls mv or the Windows rename function to do the job.\n\n=cut\nsub rename_file\n{\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing rename from $_[0] to $_[1]\\n\";\n\treturn 1;\n\t}\nmy $src = &translate_filename($_[0]);\nmy $dst = &translate_filename($_[1]);\n&webmin_debug_log('RENAME', \"src=$src dst=$dst\")\n\tif ($gconfig{'debug_what_ops'});\nmy $ok = rename($src, $dst);\nif (!$ok && $! !~ /permission/i) {\n\t# Try the mv command, in case this is a cross-filesystem rename\n\tif ($gconfig{'os_type'} eq 'windows') {\n\t\t# Need to use rename\n\t\tmy $out = &backquote_command(\"rename \".quotemeta($_[0]).\n\t\t\t\t\t     \" \".quotemeta($_[1]).\" 2>&1\");\n\t\t$ok = !$?;\n\t\t$! = $out if (!$ok);\n\t\t}\n\telse {\n\t\t# Can use mv\n\t\tmy $out = &backquote_command(\"mv \".quotemeta($_[0]).\n\t\t\t\t\t     \" \".quotemeta($_[1]).\" 2>&1\");\n\t\t$ok = !$?;\n\t\t$! = $out if (!$ok);\n\t\t}\n\t}\nreturn $ok;\n}\n\n=head2 symlink_logged(src, dest)\n\nCreate a symlink, and logs it. Effectively does the same thing as the Perl\nsymlink function.\n\n=cut\nsub symlink_logged\n{\n&lock_file($_[1]);\nmy $rv = &symlink_file($_[0], $_[1]);\n&unlock_file($_[1]);\nreturn $rv;\n}\n\n=head2 symlink_file(src, dest)\n\nCreates a soft link, unless in read-only mode. Effectively does the same thing\nas the Perl symlink function.\n\n=cut\nsub symlink_file\n{\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing symlink from $_[0] to $_[1]\\n\";\n\treturn 1;\n\t}\nmy $src = &translate_filename($_[0]);\nmy $dst = &translate_filename($_[1]);\n&webmin_debug_log('SYMLINK', \"src=$src dst=$dst\")\n\tif ($gconfig{'debug_what_ops'});\nreturn symlink($src, $dst);\n}\n\n=head2 link_file(src, dest)\n\nCreates a hard link, unless in read-only mode. The existing new link file\nwill be deleted if necessary. Effectively the same as Perl's link function.\n\n=cut\nsub link_file\n{\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing link from $_[0] to $_[1]\\n\";\n\treturn 1;\n\t}\nmy $src = &translate_filename($_[0]);\nmy $dst = &translate_filename($_[1]);\n&webmin_debug_log('LINK', \"src=$src dst=$dst\")\n\tif ($gconfig{'debug_what_ops'});\nunlink($dst);\t\t\t# make sure link works\nreturn link($src, $dst);\n}\n\n=head2 make_dir(dir, perms, recursive)\n\nCreates a directory and sets permissions on it, unless in read-only mode.\nThe perms parameter sets the octal permissions to apply, which unlike Perl's\nmkdir will really get set. The recursive flag can be set to 1 to have the\nfunction create parent directories too.\n\n=cut\nsub make_dir\n{\nmy ($dir, $perms, $recur) = @_;\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing directory $dir\\n\";\n\treturn 1;\n\t}\n$dir = &translate_filename($dir);\nmy $exists = -d $dir ? 1 : 0;\nreturn 1 if ($exists && $recur);\t# already exists\n&webmin_debug_log('MKDIR', $dir) if ($gconfig{'debug_what_ops'});\nmy $rv = mkdir($dir, $perms);\nif (!$rv && $recur) {\n\t# Failed .. try mkdir -p\n\tmy $param = $gconfig{'os_type'} eq 'windows' ? \"\" : \"-p\";\n\tmy $ex = &execute_command(\"mkdir $param \".&quote_path($dir));\n\tif ($ex) {\n\t\treturn 0;\n\t\t}\n\t}\nif (!$exists) {\n\tchmod($perms, $dir);\n\t}\nreturn 1;\n}\n\n=head2 set_ownership_permissions(user, group, perms, file, ...)\n\nSets the user, group owner and permissions on some files. The parameters are :\n\n=item user - UID or username to change the file owner to. If undef, then the owner is not changed.\n\n=item group - GID or group name to change the file group to. If undef, then the group is set to the user's primary group.\n\n=item perms - Octal permissions set to set on the file. If undef, they are left alone.\n\n=item file - One or more files or directories to modify.\n\n=cut\nsub set_ownership_permissions\n{\nmy ($user, $group, $perms, @files) = @_;\nif (&is_readonly_mode()) {\n\tprint STDERR \"Vetoing permission changes on \",join(\" \", @files),\"\\n\";\n\treturn 1;\n\t}\n@files = map { &translate_filename($_) } @files;\nif ($gconfig{'debug_what_ops'}) {\n\tforeach my $f (@files) {\n\t\t&webmin_debug_log('PERMS',\n\t\t\t\"file=$f user=$user group=$group perms=$perms\");\n\t\t}\n\t}\nmy $rv = 1;\nif (defined($user)) {\n\tmy $uid = $user !~ /^\\d+$/ ? getpwnam($user) : $user;\n\tmy $gid;\n\tif (defined($group)) {\n\t\t$gid = $group !~ /^\\d+$/ ? getgrnam($group) : $group;\n\t\t}\n\telse {\n\t\tmy @uinfo = getpwuid($uid);\n\t\t$gid = $uinfo[3];\n\t\t}\n\t$rv = chown($uid, $gid, @files);\n\t}\nif ($rv && defined($perms)) {\n\t$rv = chmod($perms, @files);\n\t}\nreturn $rv;\n}\n\n=head2 unlink_logged(file, ...)\n\nLike Perl's unlink function, but locks the files beforehand and un-locks them\nafter so that the deletion is logged by Webmin.\n\n=cut\nsub unlink_logged\n{\nmy %locked;\nforeach my $f (@_) {\n\tif (!&test_lock($f)) {\n\t\t&lock_file($f);\n\t\t$locked{$f} = 1;\n\t\t}\n\t}\nmy @rv = &unlink_file(@_);\nforeach my $f (@_) {\n\tif ($locked{$f}) {\n\t\t&unlock_file($f);\n\t\t}\n\t}\nreturn wantarray ? @rv : $rv[0];\n}\n\n=head2 unlink_file(file, ...)\n\nDeletes some files or directories. Like Perl's unlink function, but also\nrecursively deletes directories with the rm command if needed.\n\n=cut\nsub unlink_file\n{\nreturn 1 if (&is_readonly_mode());\nmy $rv = 1;\nmy $err;\nforeach my $f (@_) {\n\t&unflush_file_lines($f);\n\tmy $realf = &translate_filename($f);\n\t&webmin_debug_log('UNLINK', $realf) if ($gconfig{'debug_what_ops'});\n\tif (-d $realf) {\n\t\tif (!rmdir($realf)) {\n\t\t\tmy $out;\n\t\t\tif ($gconfig{'os_type'} eq 'windows') {\n\t\t\t\t# Call del and rmdir commands\n\t\t\t\tmy $qm = $realf;\n\t\t\t\t$qm =~ s/\\//\\\\/g;\n\t\t\t\tmy $out = `del /q \"$qm\" 2>&1`;\n\t\t\t\tif (!$?) {\n\t\t\t\t\t$out = `rmdir \"$qm\" 2>&1`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t# Use rm command\n\t\t\t\tmy $qm = quotemeta($realf);\n\t\t\t\t$out = `rm -rf $qm 2>&1`;\n\t\t\t\t}\n\t\t\tif ($?) {\n\t\t\t\t$rv = 0;\n\t\t\t\t$err = $out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse {\n\t\tif (!unlink($realf)) {\n\t\t\t$rv = 0;\n\t\t\t$err = $!;\n\t\t\t}\n\t\t}\n\t}\nreturn wantarray ? ($rv, $err) : $rv;\n}\n\n=head2 copy_source_dest(source, dest, [copy-link-target])\n\nCopy some file or directory to a new location. Returns 1 on success, or 0\non failure - also sets $! on failure. If the source is a directory, uses\npiped tar commands to copy a whole directory structure including permissions\nand special files.\n\n=cut\nsub copy_source_dest\n{\nreturn (1, undef) if (&is_readonly_mode());\nmy ($src, $dst, $copylink) = @_;\nmy $ok = 1;\nmy ($err, $out);\n&webmin_debug_log('COPY', \"src=$src dst=$dst\")\n\tif ($gconfig{'debug_what_ops'});\nif ($gconfig{'os_type'} eq 'windows') {\n\t# No tar or cp on windows, so need to use copy command\n\t$src =~ s/\\//\\\\/g;\n\t$dst =~ s/\\//\\\\/g;\n\tif (-d $src) {\n\t\t$out = &backquote_logged(\"xcopy \\\"$src\\\" \\\"$dst\\\" /Y /E /I 2>&1\");\n\t\t}\n\telse {\n\t\t$out = &backquote_logged(\"copy /Y \\\"$src\\\" \\\"$dst\\\" 2>&1\");\n\t\t}\n\tif ($?) {\n\t\t$ok = 0;\n\t\t$err = $out;\n\t\t}\n\t}\nelsif (-d $src) {\n\t# A directory .. need to copy with tar command\n\tmy @st = stat($src);\n\tunlink($dst);\n\tmkdir($dst, 0755);\n\t&set_ownership_permissions($st[4], $st[5], $st[2], $dst);\n\t$out = &backquote_logged(\"(cd \".quotemeta($src).\" ; tar cf - . | (cd \".quotemeta($dst).\" ; tar xf -)) 2>&1\");\n\tif ($?) {\n\t\t$ok = 0;\n\t\t$err = $out;\n\t\t}\n\t}\nelsif (-l $src && !$copylink) {\n\t# A link .. re-create\n\tmy $linkdst = readlink($src);\n\t$ok = &symlink_logged($linkdst, $dst);\n\t$err = $ok ? undef : $!;\n\t}\nelse {\n\t# Can just copy with cp\n\tmy $out = &backquote_logged(\"cp -p \".quotemeta($src).\n\t\t\t\t    \" \".quotemeta($dst).\" 2>&1\");\n\tif ($?) {\n\t\t$ok = 0;\n\t\t$err = $out;\n\t\t}\n\t}\nreturn wantarray ? ($ok, $err) : $ok;\n}\n\n=head2 remote_session_name(host|&server)\n\nGenerates a session ID for some server. For this server, this will always\nbe an empty string. For a server object it will include the hostname and\nport and PID. For a server name, it will include the hostname and PID. For\ninternal use only.\n\n=cut\nsub remote_session_name\n{\nreturn ref($_[0]) && $_[0]->{'host'} && $_[0]->{'port'} ?\n\t\t\"$_[0]->{'host'}:$_[0]->{'port'}.$$\" :\n       $_[0] eq \"\" || ref($_[0]) && $_[0]->{'id'} == 0 ? \"\" :\n       ref($_[0]) ? \"\" : \"$_[0].$$\";\n}\n\n=head2 remote_foreign_require(server, module, file)\n\nConnects to rpc.cgi on a remote webmin server and have it open a session\nto a process that will actually do the require and run functions. This is the\nequivalent for foreign_require, but for a remote Webmin system. The server\nparameter can either be a hostname of a system registered in the Webmin\nServers Index module, or a hash reference for a system from that module.\n\n=cut\nsub remote_foreign_require\n{\nmy $call = { 'action' => 'require',\n\t     'module' => $_[1],\n\t     'file' => $_[2] };\nmy $sn = &remote_session_name($_[0]);\nif ($remote_session{$sn}) {\n\t$call->{'session'} = $remote_session{$sn};\n\t}\nelse {\n\t$call->{'newsession'} = 1;\n\t}\nmy $rv = &remote_rpc_call($_[0], $call);\nif ($rv->{'session'}) {\n\t$remote_session{$sn} = $rv->{'session'};\n\t$remote_session_server{$sn} = $_[0];\n\t}\n}\n\n=head2 remote_foreign_call(server, module, function, [arg]*)\n\nCall a function on a remote server. Must have been setup first with\nremote_foreign_require for the same server and module. Equivalent to\nforeign_call, but with the extra server parameter to specify the remote\nsystem's hostname.\n\n=cut\nsub remote_foreign_call\n{\nreturn undef if (&is_readonly_mode());\nmy $sn = &remote_session_name($_[0]);\nreturn &remote_rpc_call($_[0], { 'action' => 'call',\n\t\t\t\t 'module' => $_[1],\n\t\t\t\t 'func' => $_[2],\n\t\t\t\t 'session' => $remote_session{$sn},\n\t\t\t\t 'args' => [ @_[3 .. $#_] ] } );\n}\n\n=head2 remote_foreign_check(server, module, [api-only])\n\nChecks if some module is installed and supported on a remote server. Equivalent\nto foreign_check, but for the remote Webmin system specified by the server\nparameter.\n\n=cut\nsub remote_foreign_check\n{\nreturn &remote_rpc_call($_[0], { 'action' => 'check',\n\t\t\t\t 'module' => $_[1],\n\t\t\t\t 'api' => $_[2] });\n}\n\n=head2 remote_foreign_config(server, module)\n\nGets the configuration for some module from a remote server, as a hash ref.\nEquivalent to foreign_config, but for a remote system.\n\n=cut\nsub remote_foreign_config\n{\nreturn &remote_rpc_call($_[0], { 'action' => 'config',\n\t\t\t\t 'module' => $_[1] });\n}\n\n=head2 remote_eval(server, module, code)\n\nEvaluates some perl code in the context of a module on a remote webmin server.\nThe server parameter must be the hostname of a remote system, module must\nbe a module directory name, and code a string of Perl code to run. This can\nonly be called after remote_foreign_require for the same server and module.\n\n=cut\nsub remote_eval\n{\nreturn undef if (&is_readonly_mode());\nmy $sn = &remote_session_name($_[0]);\nreturn &remote_rpc_call($_[0], { 'action' => 'eval',\n\t\t\t\t 'module' => $_[1],\n\t\t\t\t 'code' => $_[2],\n\t\t\t\t 'session' => $remote_session{$sn} });\n}\n\n=head2 remote_write(server, localfile, [remotefile], [remotebasename])\n\nTransfers some local file to another server via Webmin's RPC protocol, and\nreturns the resulting remote filename. If the remotefile parameter is given,\nthat is the destination filename which will be used. Otherwise a randomly\nselected temporary filename will be used, and returned by the function.\n\n=cut\nsub remote_write\n{\nmy ($host, $localfile, $remotefile, $remotebase) = @_;\nreturn undef if (&is_readonly_mode());\nmy ($data, $got);\nmy $rv = &remote_rpc_call($host, { 'action' => 'tcpwrite',\n\t\t\t\t   'file' => $remotefile,\n\t\t\t\t   'name' => $remotebase } );\nmy $error;\nmy $serv = ref($host) ? $host->{'host'} : $host;\n&open_socket($serv || \"localhost\", $rv->[1], TWRITE, \\$error);\nreturn &$main::remote_error_handler(\"Failed to transfer file : $error\")\n\tif ($error);\nopen(FILE, $localfile) ||\n\treturn &$main::remote_error_handler(\"Failed to open $localfile : $!\");\nwhile(read(FILE, $got, 1024) > 0) {\n\tprint TWRITE $got;\n\t}\nclose(FILE);\nshutdown(TWRITE, 1);\n$error = <TWRITE>;\nif ($error && $error !~ /^OK/) {\n\t# Got back an error!\n\treturn &$main::remote_error_handler(\"Failed to transfer file : $error\");\n\t}\nclose(TWRITE);\nreturn $rv->[0];\n}\n\n=head2 remote_read(server, localfile, remotefile)\n\nTransfers a file from a remote server to this system, using Webmin's RPC\nprotocol. The server parameter must be the hostname of a system registered\nin the Webmin Servers Index module, localfile is the destination path on this\nsystem, and remotefile is the file to fetch from the remote server.\n\n=cut\nsub remote_read\n{\nmy ($host, $localfile, $remotefile) = @_;\nmy $rv = &remote_rpc_call($host, { 'action' => 'tcpread',\n\t\t\t\t   'file' => $remotefile } );\nif (!$rv->[0]) {\n\treturn &$main::remote_error_handler(\"Failed to transfer file : $rv->[1]\");\n\t}\nmy $error;\nmy $serv = ref($host) ? $host->{'host'} : $host;\n&open_socket($serv || \"localhost\", $rv->[1], TREAD, \\$error);\nreturn &$main::remote_error_handler(\"Failed to transfer file : $error\")\n\tif ($error);\nmy $got;\nopen(FILE, \">$localfile\") ||\n\treturn &$main::remote_error_handler(\"Failed to open $localfile : $!\");\nwhile(read(TREAD, $got, 1024) > 0) {\n\tprint FILE $got;\n\t}\nclose(FILE);\nclose(TREAD);\n}\n\n=head2 remote_finished\n\nClose all remote sessions. This happens automatically after a while\nanyway, but this function should be called to clean things up faster.\n\n=cut\nsub remote_finished\n{\nforeach my $sn (keys %remote_session) {\n\tmy $server = $remote_session_server{$sn};\n\t&remote_rpc_call($server, { 'action' => 'quit',\n\t\t\t            'session' => $remote_session{$sn} } );\n\tdelete($remote_session{$sn});\n\tdelete($remote_session_server{$sn});\n\t}\nforeach my $fh (keys %fast_fh_cache) {\n\tclose($fh);\n\tdelete($fast_fh_cache{$fh});\n\t}\n}\n\n=head2 remote_error_setup(&function)\n\nSets a function to be called instead of &error when a remote RPC operation\nfails. Useful if you want to have more control over your remote operations.\n\n=cut\nsub remote_error_setup\n{\n$main::remote_error_handler = $_[0] || \\&error;\n}\n\n=head2 remote_rpc_call(server, &structure)\n\nCalls rpc.cgi on some server and passes it a perl structure (hash,array,etc)\nand then reads back a reply structure. This is mainly for internal use only,\nand is called by the other remote_* functions.\n\n=cut\nsub remote_rpc_call\n{\nmy $serv;\nmy $sn = &remote_session_name($_[0]);\t# Will be undef for local connection\nif (ref($_[0])) {\n\t# Server structure was given\n\t$serv = $_[0];\n\t$serv->{'user'} || $serv->{'id'} == 0 ||\n\t\treturn &$main::remote_error_handler(\n\t\t\t\"No Webmin login set for server\");\n\t}\nelsif ($_[0]) {\n\t# lookup the server in the webmin servers module if needed\n\tif (!%main::remote_servers_cache) {\n\t\t&foreign_require(\"servers\");\n\t\tforeach $s (&foreign_call(\"servers\", \"list_servers\")) {\n\t\t\t$main::remote_servers_cache{$s->{'host'}} = $s;\n\t\t\t$main::remote_servers_cache{$s->{'host'}.\":\".$s->{'port'}} = $s;\n\t\t\t}\n\t\t}\n\t$serv = $main::remote_servers_cache{$_[0]};\n\t$serv || return &$main::remote_error_handler(\n\t\t\t\t\"No Webmin Servers entry for $_[0]\");\n\t$serv->{'user'} || return &$main::remote_error_handler(\n\t\t\t\t\"No login set for server $_[0]\");\n\t}\nmy $ip = $serv->{'ip'} || $serv->{'host'};\n\n# Work out the username and password\nmy ($user, $pass);\nif ($serv->{'sameuser'}) {\n\t$user = $remote_user;\n\tdefined($main::remote_pass) || return &$main::remote_error_handler(\n\t\t\t\t   \"Password for this server is not available\");\n\t$pass = $main::remote_pass;\n\t}\nelse {\n\t$user = $serv->{'user'};\n\t$pass = $serv->{'pass'};\n\t}\n\nif ($serv->{'fast'} || !$sn) {\n\t# Make TCP connection call to fastrpc.cgi\n\tif (!$fast_fh_cache{$sn} && $sn) {\n\t\t# Need to open the connection\n\t\tmy $reqs;\n\t\tif ($serv->{'checkssl'}) {\n\t\t\t$reqs = { 'host' => 1,\n\t\t\t\t  'checkhost' => $serv->{'host'},\n\t\t\t\t  'self' => 1 };\n\t\t\tmy %sconfig = &foreign_config(\"servers\");\n\t\t\tif ($sconfig{'capath'}) {\n\t\t\t\t$reqs->{'capath'} = $sconfig{'capath'};\n\t\t\t\t}\n\t\t\t}\n\t\tmy $con = &make_http_connection(\n\t\t\t$ip, $serv->{'port'}, $serv->{'ssl'},\n\t\t\t\"POST\", \"/fastrpc.cgi\", undef, undef, $reqs);\n\t\treturn &$main::remote_error_handler(\n\t\t    \"Failed to connect to $serv->{'host'} : $con\")\n\t\t\tif (!ref($con));\n\t\t&write_http_connection($con, \"Host: $serv->{'host'}\\r\\n\");\n\t\t&write_http_connection($con, \"User-agent: Webmin\\r\\n\");\n\t\tmy $auth = &encode_base64(\"$user:$pass\");\n\t\t$auth =~ tr/\\n//d;\n\t\t&write_http_connection($con, \"Authorization: basic $auth\\r\\n\");\n\t\t&write_http_connection($con, \"Content-length: \",\n\t\t\t\t\t     length($tostr),\"\\r\\n\");\n\t\t&write_http_connection($con, \"\\r\\n\");\n\t\t&write_http_connection($con, $tostr);\n\n\t\t# read back the response\n\t\tmy $line = &read_http_connection($con);\n\t\t$line =~ tr/\\r\\n//d;\n\t\tif ($line =~ /^HTTP\\/1\\..\\s+40[13]\\s+/) {\n\t\t\treturn &$main::remote_error_handler(\"Login to RPC server as $user rejected\");\n\t\t\t}\n\t\t$line =~ /^HTTP\\/1\\..\\s+200\\s+/ ||\n\t\t\treturn &$main::remote_error_handler(\"HTTP error : $line\");\n\t\tdo {\n\t\t\t$line = &read_http_connection($con);\n\t\t\t$line =~ tr/\\r\\n//d;\n\t\t\t} while($line);\n\t\t$line = &read_http_connection($con);\n\t\tif ($line =~ /^0\\s+(.*)/) {\n\t\t\treturn &$main::remote_error_handler(\"RPC error : $1\");\n\t\t\t}\n\t\telsif ($line =~ /^1\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/ ||\n\t\t       $line =~ /^1\\s+(\\S+)\\s+(\\S+)/) {\n\t\t\t# Started ok .. connect and save SID\n\t\t\t&close_http_connection($con);\n\t\t\tmy ($port, $sid, $version, $error) = ($1, $2, $3);\n\t\t\t&open_socket($ip, $port, $sid, \\$error);\n\t\t\treturn &$main::remote_error_handler(\"Failed to connect to fastrpc.cgi : $error\")\n\t\t\t\tif ($error);\n\t\t\t$fast_fh_cache{$sn} = $sid;\n\t\t\t$remote_server_version{$sn} = $version;\n\t\t\t}\n\t\telse {\n\t\t\twhile($stuff = &read_http_connection($con)) {\n\t\t\t\t$line .= $stuff;\n\t\t\t\t}\n\t\t\treturn &$main::remote_error_handler(\n\t\t\t\t\"Bad response from fastrpc.cgi : $line\");\n\t\t\t}\n\t\t}\n\telsif (!$fast_fh_cache{$sn}) {\n\t\t# Open the connection by running fastrpc.cgi locally\n\t\tpipe(RPCOUTr, RPCOUTw);\n\t\tif (!fork()) {\n\t\t\tuntie(*STDIN);\n\t\t\tuntie(*STDOUT);\n\t\t\topen(STDOUT, \">&RPCOUTw\");\n\t\t\tclose(STDIN);\n\t\t\tclose(RPCOUTr);\n\t\t\t$| = 1;\n\t\t\t$ENV{'REQUEST_METHOD'} = 'GET';\n\t\t\t$ENV{'SCRIPT_NAME'} = '/fastrpc.cgi';\n\t\t\t$ENV{'SERVER_ROOT'} ||= $root_directory;\n\t\t\tmy %acl;\n\t\t\tif ($base_remote_user ne 'root' &&\n\t\t\t    $base_remote_user ne 'admin') {\n\t\t\t\t# Need to fake up a login for the CGI!\n\t\t\t\t&read_acl(undef, \\%acl, [ 'root' ]);\n\t\t\t\t$ENV{'BASE_REMOTE_USER'} =\n\t\t\t\t\t$ENV{'REMOTE_USER'} =\n\t\t\t\t\t\t$acl{'root'} ? 'root' : 'admin';\n\t\t\t\t}\n\t\t\tdelete($ENV{'FOREIGN_MODULE_NAME'});\n\t\t\tdelete($ENV{'FOREIGN_ROOT_DIRECTORY'});\n\t\t\t$ENV{'DISABLE_REFERERS_CHECK'} = 1;\n\t\t\tchdir($root_directory);\n\t\t\tif (!exec(\"$root_directory/fastrpc.cgi\")) {\n\t\t\t\tprint \"exec failed : $!\\n\";\n\t\t\t\texit 1;\n\t\t\t\t}\n\t\t\t}\n\t\tclose(RPCOUTw);\n\t\tmy $line;\n\t\tdo {\n\t\t\t($line = <RPCOUTr>) =~ tr/\\r\\n//d;\n\t\t\t} while($line);\n\t\t$line = <RPCOUTr>;\n\t\tif ($line =~ /^0\\s+(.*)/) {\n\t\t\tclose(RPCOUTr);\n\t\t\treturn &$main::remote_error_handler(\"RPC error : $2\");\n\t\t\t}\n\t\telsif ($line =~ /^1\\s+(\\S+)\\s+(\\S+)/) {\n\t\t\t# Started ok .. connect and save SID\n\t\t\tclose(SOCK);\n\t\t\tclose(RPCOUTr);\n\t\t\tmy ($port, $sid, $error) = ($1, $2, undef);\n\t\t\t&open_socket(\"localhost\", $port, $sid, \\$error);\n\t\t\treturn &$main::remote_error_handler(\"Failed to connect to fastrpc.cgi : $error\") if ($error);\n\t\t\t$fast_fh_cache{$sn} = $sid;\n\t\t\t}\n\t\telse {\n\t\t\t# Unexpected response\n\t\t\tlocal $_;\n\t\t\twhile(<RPCOUTr>) {\n\t\t\t\t$line .= $_;\n\t\t\t\t}\n\t\t\tclose(RPCOUTr);\n\t\t\treturn &$main::remote_error_handler(\n\t\t\t\t\"Bad response from fastrpc.cgi : $line\");\n\t\t\t}\n\t\t}\n\t# Got a connection .. send off the request\n\tmy $fh = $fast_fh_cache{$sn};\n\tmy $tostr = &serialise_variable($_[1]);\n\tprint $fh length($tostr),\" $fh\\n\";\n\tprint $fh $tostr;\n\tmy $rstr = <$fh>;\n\tif ($rstr eq '') {\n\t\treturn &$main::remote_error_handler(\n\t\t\t\"Error reading response length from fastrpc.cgi : $!\")\n\t\t}\n\tmy $rlen = int($rstr);\n\tmy ($fromstr, $got);\n\twhile(length($fromstr) < $rlen) {\n\t\tmy $want = $rlen - length($fromstr);\n\t\tmy $readrv = read($fh, $got, $want);\n\t\tif (!defined($readrv) && $! == EINTR) {\n\t\t\t# Interrupted read .. re-try\n\t\t\tnext;\n\t\t\t}\n\t\telsif ($readrv < 0 || !defined($readrv)) {\n\t\t\treturn &$main::remote_error_handler(\n\t\t\t\t\"Failed to read from fastrpc.cgi : $!\")\n\t\t\t}\n\t\telsif ($readrv == 0) {\n\t\t\treturn &$main::remote_error_handler(\n\t\t\t\t\"Read of $want bytes from fastrpc.cgi failed\")\n\t\t\t}\n\t\t$fromstr .= $got;\n\t\t}\n\tmy $from = &unserialise_variable($fromstr);\n\tif (!$from) {\n\t\t# No response at all\n\t\treturn &$main::remote_error_handler(\"Remote Webmin error\");\n\t\t}\n\telsif (ref($from) ne 'HASH') {\n\t\t# Not a hash?!\n\t\treturn &$main::remote_error_handler(\n\t\t\t\"Invalid remote Webmin response : $from\");\n\t\t}\n\telsif (!$from->{'status'}) {\n\t\t# Call failed\n\t\t$from->{'rv'} =~ s/\\s+at\\s+(\\S+)\\s+line\\s+(\\d+)(,\\s+<\\S+>\\s+line\\s+(\\d+))?//;\n\t\treturn &$main::remote_error_handler($from->{'rv'});\n\t\t}\n\tif (defined($from->{'arv'})) {\n\t\treturn @{$from->{'arv'}};\n\t\t}\n\telse {\n\t\treturn $from->{'rv'};\n\t\t}\n\t}\nelse {\n\t# Call rpc.cgi on remote server\n\tmy $tostr = &serialise_variable($_[1]);\n\tmy $error = 0;\n\tmy $con = &make_http_connection($ip, $serv->{'port'},\n\t\t\t\t\t$serv->{'ssl'}, \"POST\", \"/rpc.cgi\");\n\treturn &$main::remote_error_handler(\"Failed to connect to $serv->{'host'} : $con\") if (!ref($con));\n\n\t&write_http_connection($con, \"Host: $serv->{'host'}\\r\\n\");\n\t&write_http_connection($con, \"User-agent: Webmin\\r\\n\");\n\tmy $auth = &encode_base64(\"$user:$pass\");\n\t$auth =~ tr/\\n//d;\n\t&write_http_connection($con, \"Authorization: basic $auth\\r\\n\");\n\t&write_http_connection($con, \"Content-length: \",length($tostr),\"\\r\\n\");\n\t&write_http_connection($con, \"\\r\\n\");\n\t&write_http_connection($con, $tostr);\n\n\t# read back the response\n\tmy $line = &read_http_connection($con);\n\t$line =~ tr/\\r\\n//d;\n\tif ($line =~ /^HTTP\\/1\\..\\s+401\\s+/) {\n\t\treturn &$main::remote_error_handler(\"Login to RPC server as $user rejected\");\n\t\t}\n\t$line =~ /^HTTP\\/1\\..\\s+200\\s+/ || return &$main::remote_error_handler(\"RPC HTTP error : $line\");\n\tdo {\n\t\t$line = &read_http_connection($con);\n\t\t$line =~ tr/\\r\\n//d;\n\t\t} while($line);\n\tmy $fromstr;\n\twhile($line = &read_http_connection($con)) {\n\t\t$fromstr .= $line;\n\t\t}\n\tclose(SOCK);\n\tmy $from = &unserialise_variable($fromstr);\n\treturn &$main::remote_error_handler(\"Invalid RPC login to $serv->{'host'}\") if (!$from->{'status'});\n\tif (defined($from->{'arv'})) {\n\t\treturn @{$from->{'arv'}};\n\t\t}\n\telse {\n\t\treturn $from->{'rv'};\n\t\t}\n\t}\n}\n\n=head2 remote_multi_callback(&servers, parallel, &function, arg|&args, &returns, &errors, [module, library])\n\nExecutes some function in parallel on multiple servers at once. Fills in\nthe returns and errors arrays respectively. If the module and library\nparameters are given, that module is remotely required on the server first,\nto check if it is connectable. The parameters are :\n\n=item servers - A list of Webmin system hash references.\n\n=item parallel - Number of parallel operations to perform.\n\n=item function - Reference to function to call for each system.\n\n=item args - Additional parameters to the function.\n\n=item returns - Array ref to place return values into, in same order as servers.\n\n=item errors - Array ref to place error messages into.\n\n=item module - Optional module to require on the remote system first.\n\n=item library - Optional library to require in the module.\n\n=cut\nsub remote_multi_callback\n{\nmy ($servs, $parallel, $func, $args, $rets, $errs, $mod, $lib) = @_;\n&remote_error_setup(\\&remote_multi_callback_error);\n\n# Call the functions\nmy $p = 0;\nforeach my $g (@$servs) {\n\tmy $rh = \"READ$p\";\n\tmy $wh = \"WRITE$p\";\n\tpipe($rh, $wh);\n\tif (!fork()) {\n\t\tclose($rh);\n\t\t$remote_multi_callback_err = undef;\n\t\tif ($mod) {\n\t\t\t# Require the remote lib\n\t\t\t&remote_foreign_require($g->{'host'}, $mod, $lib);\n\t\t\tif ($remote_multi_callback_err) {\n\t\t\t\t# Failed .. return error\n\t\t\t\tprint $wh &serialise_variable(\n\t\t\t\t\t[ undef, $remote_multi_callback_err ]);\n\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t# Call the function\n\t\tmy $a = ref($args) ? $args->[$p] : $args;\n\t\tmy $rv = &$func($g, $a);\n\n\t\t# Return the result\n\t\tprint $wh &serialise_variable(\n\t\t\t[ $rv, $remote_multi_callback_err ]);\n\t\tclose($wh);\n\t\texit(0);\n\t\t}\n\tclose($wh);\n\t$p++;\n\t}\n\n# Read back the results\n$p = 0;\nforeach my $g (@$servs) {\n\tmy $rh = \"READ$p\";\n\tmy $line = <$rh>;\n\tif (!$line) {\n\t\t$errs->[$p] = \"Failed to read response from $g->{'host'}\";\n\t\t}\n\telse {\n\t\tmy $rv = &unserialise_variable($line);\n\t\tclose($rh);\n\t\t$rets->[$p] = $rv->[0];\n\t\t$errs->[$p] = $rv->[1];\n\t\t}\n\t$p++;\n\t}\n\n&remote_error_setup(undef);\n}\n\nsub remote_multi_callback_error\n{\n$remote_multi_callback_err = $_[0];\n}\n\n=head2 serialise_variable(variable)\n\nConverts some variable (maybe a scalar, hash ref, array ref or scalar ref)\ninto a url-encoded string. In the cases of arrays and hashes, it is recursively\ncalled on each member to serialize the entire object.\n\n=cut\nsub serialise_variable\n{\nif (!defined($_[0])) {\n\treturn 'UNDEF';\n\t}\nmy $r = ref($_[0]);\nmy $rv;\nif (!$r) {\n\t$rv = &urlize($_[0]);\n\t}\nelsif ($r eq 'SCALAR') {\n\t$rv = &urlize(${$_[0]});\n\t}\nelsif ($r eq 'ARRAY') {\n\t$rv = join(\",\", map { &urlize(&serialise_variable($_)) } @{$_[0]});\n\t}\nelsif ($r eq 'HASH') {\n\t$rv = join(\",\", map { &urlize(&serialise_variable($_)).\",\".\n\t\t\t      &urlize(&serialise_variable($_[0]->{$_})) }\n\t\t            keys %{$_[0]});\n\t}\nelsif ($r eq 'REF') {\n\t$rv = &serialise_variable(${$_[0]});\n\t}\nelsif ($r eq 'CODE') {\n\t# Code not handled\n\t$rv = undef;\n\t}\nelsif ($r) {\n\t# An object - treat as a hash\n\t$r = \"OBJECT \".&urlize($r);\n\t$rv = join(\",\", map { &urlize(&serialise_variable($_)).\",\".\n\t\t\t      &urlize(&serialise_variable($_[0]->{$_})) }\n\t\t            keys %{$_[0]});\n\t}\nreturn ($r ? $r : 'VAL').\",\".$rv;\n}\n\n=head2 unserialise_variable(string)\n\nConverts a string created by serialise_variable() back into the original\nscalar, hash ref, array ref or scalar ref. If the original variable was a Perl\nobject, the same class is used on this system, if available.\n\n=cut\nsub unserialise_variable\n{\nmy @v = split(/,/, $_[0]);\nmy $rv;\nif ($v[0] eq 'VAL') {\n\t@v = split(/,/, $_[0], -1);\n\t$rv = &un_urlize($v[1]);\n\t}\nelsif ($v[0] eq 'SCALAR') {\n\tlocal $r = &un_urlize($v[1]);\n\t$rv = \\$r;\n\t}\nelsif ($v[0] eq 'ARRAY') {\n\t$rv = [ ];\n\tfor(my $i=1; $i<@v; $i++) {\n\t\tpush(@$rv, &unserialise_variable(&un_urlize($v[$i])));\n\t\t}\n\t}\nelsif ($v[0] eq 'HASH') {\n\t$rv = { };\n\tfor(my $i=1; $i<@v; $i+=2) {\n\t\t$rv->{&unserialise_variable(&un_urlize($v[$i]))} =\n\t\t\t&unserialise_variable(&un_urlize($v[$i+1]));\n\t\t}\n\t}\nelsif ($v[0] eq 'REF') {\n\tlocal $r = &unserialise_variable($v[1]);\n\t$rv = \\$r;\n\t}\nelsif ($v[0] eq 'UNDEF') {\n\t$rv = undef;\n\t}\nelsif ($v[0] =~ /^OBJECT\\s+([A-Za-z0-9_:]+)$/) {\n\t# An object hash that we have to re-bless\n\tmy $cls = $1;\n\t$rv = { };\n\tfor(my $i=1; $i<@v; $i+=2) {\n\t\t$rv->{&unserialise_variable(&un_urlize($v[$i]))} =\n\t\t\t&unserialise_variable(&un_urlize($v[$i+1]));\n\t\t}\n\teval \"use $cls\";\n\tbless $rv, $cls;\n\t}\nreturn $rv;\n}\n\n=head2 other_groups(user)\n\nReturns a list of secondary groups a user is a member of, as a list of\ngroup IDs.\n\n=cut\nsub other_groups\n{\nmy ($user) = @_;\nmy @rv;\nsetgrent();\nwhile(my @g = getgrent()) {\n\tmy @m = split(/\\s+/, $g[3]);\n\tpush(@rv, $g[2]) if (&indexof($user, @m) >= 0);\n\t}\nendgrent() if ($gconfig{'os_type'} ne 'hpux');\nreturn @rv;\n}\n\n=head2 date_chooser_button(dayfield, monthfield, yearfield)\n\nReturns HTML for a button that pops up a data chooser window. The parameters\nare :\n\n=item dayfield - Name of the text field to place the day of the month into.\n\n=item monthfield - Name of the select field to select the month of the year in, indexed from 1.\n\n=item yearfield - Name of the text field to place the year into.\n\n=cut\nsub date_chooser_button\n{\nreturn &theme_date_chooser_button(@_)\n\tif (defined(&theme_date_chooser_button));\nmy ($w, $h) = (250, 225);\nif ($gconfig{'db_sizedate'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizedate'});\n\t}\nreturn \"<input type=button onClick='window.dfield = form.$_[0]; window.mfield = form.$_[1]; window.yfield = form.$_[2]; window.open(\\\"$gconfig{'webprefix'}/date_chooser.cgi?day=\\\"+escape(dfield.value)+\\\"&month=\\\"+escape(mfield.selectedIndex)+\\\"&year=\\\"+yfield.value, \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,width=$w,height=$h\\\")' value=\\\"...\\\">\\n\";\n}\n\n=head2 help_file(module, file)\n\nReturns the path to a module's help file of some name, typically under the\nhelp directory with a .html extension.\n\n=cut\nsub help_file\n{\nmy $mdir = &module_root_directory($_[0]);\nmy $dir = \"$mdir/help\";\nforeach my $o (@lang_order_list) {\n\tmy $lang = \"$dir/$_[1].$o.html\";\n\treturn $lang if (-r $lang);\n\t}\nreturn \"$dir/$_[1].html\";\n}\n\n=head2 seed_random\n\nSeeds the random number generator, if not already done in this script. On Linux\nthis makes use of the current time, process ID and a read from /dev/urandom.\nOn other systems, only the current time and process ID are used.\n\n=cut\nsub seed_random\n{\nif (!$main::done_seed_random) {\n\tif (open(RANDOM, \"/dev/urandom\")) {\n\t\tmy $buf;\n\t\tread(RANDOM, $buf, 4);\n\t\tclose(RANDOM);\n\t\tsrand(time() ^ $$ ^ $buf);\n\t\t}\n\telse {\n\t\tsrand(time() ^ $$);\n\t\t}\n\t$main::done_seed_random = 1;\n\t}\n}\n\n=head2 disk_usage_kb(directory)\n\nReturns the number of kB used by some directory and all subdirs. Implemented\nby calling the C<du -k> command.\n\n=cut\nsub disk_usage_kb\n{\nmy $dir = &translate_filename($_[0]);\nmy $out;\nmy $ex = &execute_command(\"du -sk \".quotemeta($dir), undef, \\$out, undef, 0, 1);\nif ($ex) {\n\t&execute_command(\"du -s \".quotemeta($dir), undef, \\$out, undef, 0, 1);\n\t}\nreturn $out =~ /^([0-9]+)/ ? $1 : \"???\";\n}\n\n=head2 recursive_disk_usage(directory, [skip-regexp], [only-regexp])\n\nReturns the number of bytes taken up by all files in some directory and all\nsub-directories, by summing up their lengths. The disk_usage_kb is more\nreflective of reality, as the filesystem typically pads file sizes to 1k or\n4k blocks.\n\n=cut\nsub recursive_disk_usage\n{\nmy $dir = &translate_filename($_[0]);\nmy $skip = $_[1];\nmy $only = $_[2];\nif (-l $dir) {\n\treturn 0;\n\t}\nelsif (!-d $dir) {\n\tmy @st = stat($dir);\n\treturn $st[7];\n\t}\nelse {\n\tmy $rv = 0;\n\topendir(DIR, $dir);\n\tmy @files = readdir(DIR);\n\tclosedir(DIR);\n\tforeach my $f (@files) {\n\t\tnext if ($f eq \".\" || $f eq \"..\");\n\t\tnext if ($skip && $f =~ /$skip/);\n\t\tnext if ($only && $f !~ /$only/);\n\t\t$rv += &recursive_disk_usage(\"$dir/$f\", $skip, $only);\n\t\t}\n\treturn $rv;\n\t}\n}\n\n=head2 help_search_link(term, [ section, ... ] )\n\nReturns HTML for a link to the man module for searching local and online\ndocs for various search terms. The term parameter can either be a single\nword like 'bind', or a space-separated list of words. This function is typically\nused by modules that want to refer users to additional documentation in man\npages or local system doc files.\n\n=cut\nsub help_search_link\n{\nif (&foreign_available(\"man\") && !$tconfig{'nosearch'}) {\n\tmy $for = &urlize(shift(@_));\n\treturn \"<a href='$gconfig{'webprefix'}/man/search.cgi?\".\n\t       join(\"&\", map { \"section=$_\" } @_).\"&\".\n\t       \"for=$for&exact=1&check=\".&get_module_name().\"'>\".\n\t       $text{'helpsearch'}.\"</a>\\n\";\n\t}\nelse {\n\treturn \"\";\n\t}\n}\n\n=head2 make_http_connection(host, port, ssl, method, page, [&headers])\n\nOpens a connection to some HTTP server, maybe through a proxy, and returns\na handle object. The handle can then be used to send additional headers\nand read back a response. If anything goes wrong, returns an error string.\nThe parameters are :\n\n=item host - Hostname or IP address of the webserver to connect to.\n\n=item port - HTTP port number to connect to.\n\n=item ssl - Set to 1 to connect in SSL mode.\n\n=item method - HTTP method, like GET or POST.\n\n=item page - Page to request on the webserver, like /foo/index.html\n\n=item headers - Array ref of additional HTTP headers, each of which is a 2-element array ref.\n\n=item bindip - IP address to bind to for outgoing HTTP connection\n\n=item certreqs - A hash ref containing options for remote cert verification\n\n=cut\nsub make_http_connection\n{\nmy ($host, $port, $ssl, $method, $page, $headers, $bindip, $certreqs) = @_;\nmy $htxt;\nif ($headers) {\n\tforeach my $h (@$headers) {\n\t\t$htxt .= $h->[0].\": \".$h->[1].\"\\r\\n\";\n\t\t}\n\t$htxt .= \"\\r\\n\";\n\t}\nif (&is_readonly_mode()) {\n\treturn \"HTTP connections not allowed in readonly mode\";\n\t}\nmy $rv = { 'fh' => time().$$ };\nif ($ssl) {\n\t# Connect using SSL\n\teval \"use Net::SSLeay\";\n\t$@ && return $text{'link_essl'};\n\teval \"Net::SSLeay::SSLeay_add_ssl_algorithms()\";\n\teval \"Net::SSLeay::OpenSSL_add_all_algorithms()\";\n\teval \"Net::SSLeay::load_error_strings()\";\n\t$rv->{'ssl_ctx'} = Net::SSLeay::CTX_new() ||\n\t\treturn \"Failed to create SSL context\";\n\tif ($certreqs && $certreqs->{'capath'}) {\n\t\t# Require that remote cert be signed by a valid CA\n\t\t$main::last_set_verify_err = undef;\n\t\tif (-d $certreqs->{'capath'}) {\n\t\t\tNet::SSLeay::CTX_load_verify_locations(\n\t\t\t\t$rv->{'ssl_ctx'}, \"\", $certreqs->{'capath'});\n\t\t\t}\n\t\telse {\n\t\t\tNet::SSLeay::CTX_load_verify_locations(\n\t\t\t\t$rv->{'ssl_ctx'}, $certreqs->{'capath'}, \"\");\n\t\t\t}\n\t\tNet::SSLeay::CTX_set_verify(\n\t\t\t$rv->{'ssl_ctx'}, &Net::SSLeay::VERIFY_PEER,\n\t\t\tsub\n\t\t\t{\n\t\t\tmy $cert = Net::SSLeay::X509_STORE_CTX_get_current_cert($_[1]);\n\t\t\tif ($cert) {\n\t\t\t\tmy $subject = Net::SSLeay::X509_NAME_oneline(\n\t\t\t\t    Net::SSLeay::X509_get_subject_name($cert));\n\t\t\t\tmy $issuer = Net::SSLeay::X509_NAME_oneline(\n\t\t\t\t    Net::SSLeay::X509_get_issuer_name($cert));\n\t\t\t\tmy $errnum = Net::SSLeay::X509_STORE_CTX_get_error($_[1]);\n\t\t\t\tif ($errnum) {\n\t\t\t\t\t$main::last_set_verify_err =\n\t\t\t\t\t  \"Certificate is signed by an \".\n\t\t\t\t\t  \"unknown CA : $issuer (code $errnum)\";\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$main::last_set_verify_err = undef;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t$main::last_set_verify_err =\n\t\t\t\t  \"Could not fetch CA certificate from server\";\n\t\t\t\t}\n\t\t\treturn 1;\n\t\t\t});\n\t\t}\n\t$rv->{'ssl_con'} = Net::SSLeay::new($rv->{'ssl_ctx'}) ||\n\t\treturn \"Failed to create SSL connection\";\n\tmy $connected;\n\tif ($gconfig{'http_proxy'} =~ /^http:\\/\\/(\\S+):(\\d+)/ &&\n\t    !&no_proxy($host)) {\n\t\t# Via proxy\n\t\tmy $error;\n\t\t&open_socket($1, $2, $rv->{'fh'}, \\$error, $bindip);\n\t\tif (!$error) {\n\t\t\t# Connected OK\n\t\t\tmy $fh = $rv->{'fh'};\n\t\t\tprint $fh \"CONNECT $host:$port HTTP/1.0\\r\\n\";\n\t\t\tif ($gconfig{'proxy_user'}) {\n\t\t\t\tmy $auth = &encode_base64(\n\t\t\t\t   \"$gconfig{'proxy_user'}:\".\n\t\t\t\t   \"$gconfig{'proxy_pass'}\");\n\t\t\t\t$auth =~ tr/\\r\\n//d;\n\t\t\t\tprint $fh \"Proxy-Authorization: Basic $auth\\r\\n\";\n\t\t\t\t}\n\t\t\tprint $fh \"\\r\\n\";\n\t\t\tmy $line = <$fh>;\n\t\t\tif ($line =~ /^HTTP(\\S+)\\s+(\\d+)\\s+(.*)/) {\n\t\t\t\treturn \"Proxy error : $3\" if ($2 != 200);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"Proxy error : $line\";\n\t\t\t\t}\n\t\t\t$line = <$fh>;\n\t\t\t$connected = 1;\n\t\t\t}\n\t\telsif (!$gconfig{'proxy_fallback'}) {\n\t\t\t# Connection to proxy failed - give up\n\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\tif (!$connected) {\n\t\t# Direct connection\n\t\tmy $error;\n\t\t&open_socket($host, $port, $rv->{'fh'}, \\$error, $bindip);\n\t\treturn $error if ($error);\n\t\t}\n\tNet::SSLeay::set_fd($rv->{'ssl_con'}, fileno($rv->{'fh'}));\n\teval {\n\t\tmy $snihost = $certreqs && $certreqs->{'host'};\n\t\t$snihost ||= $host;\n\t\tNet::SSLeay::set_tlsext_host_name($rv->{'ssl_con'}, $snihost);\n\t\t};\n\tNet::SSLeay::connect($rv->{'ssl_con'}) ||\n\t\treturn \"SSL connect() failed\";\n\tif ($certreqs && !$certreqs->{'nocheckhost'}) {\n\t\tmy $err = &validate_ssl_connection(\n\t\t\t$rv->{'ssl_con'},\n\t\t\t$certreqs->{'checkhost'} ||\n\t\t\t  $certreqs->{'host'} || $host,\n\t\t\t$certreqs);\n\t\treturn \"Invalid SSL certificate : $err\" if ($err);\n\t\t}\n\tmy $rtxt = \"$method $page HTTP/1.0\\r\\n\".$htxt;\n\tNet::SSLeay::write($rv->{'ssl_con'}, $rtxt);\n\t}\nelse {\n\t# Plain HTTP request\n\tmy $connected;\n\tif ($gconfig{'http_proxy'} =~ /^http:\\/\\/(\\S+):(\\d+)/ &&\n\t    !&no_proxy($host)) {\n\t\t# Via a proxy\n\t\tmy $error;\n\t\t&open_socket($1, $2, $rv->{'fh'}, \\$error, $bindip);\n\t\tif (!$error) {\n\t\t\t# Connected OK\n\t\t\t$connected = 1;\n\t\t\tmy $fh = $rv->{'fh'};\n\t\t\tmy $rtxt = $method.\" \".\n\t\t\t\t   \"http://$host:$port$page HTTP/1.0\\r\\n\";\n\t\t\tif ($gconfig{'proxy_user'}) {\n\t\t\t\tmy $auth = &encode_base64(\n\t\t\t\t   \"$gconfig{'proxy_user'}:\".\n\t\t\t\t   \"$gconfig{'proxy_pass'}\");\n\t\t\t\t$auth =~ tr/\\r\\n//d;\n\t\t\t\t$rtxt .= \"Proxy-Authorization: Basic $auth\\r\\n\";\n\t\t\t\t}\n\t\t\t$rtxt .= $htxt;\n\t\t\tprint $fh $rtxt;\n\t\t\t}\n\t\telsif (!$gconfig{'proxy_fallback'}) {\n\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\tif (!$connected) {\n\t\t# Connecting directly\n\t\tmy $error;\n\t\t&open_socket($host, $port, $rv->{'fh'}, \\$error, $bindip);\n\t\treturn $error if ($error);\n\t\tmy $fh = $rv->{'fh'};\n\t\tmy $rtxt = \"$method $page HTTP/1.0\\r\\n\".$htxt;\n\t\tprint $fh $rtxt;\n\t\t}\n\t}\nreturn $rv;\n}\n\n=head2 validate_ssl_connection(&ssl-handle, hostname, &requirements)\n\nValidates the SSL certificate presented by a remote server, and returns an\nerror message if any requirements were not met.\n\n=cut\nsub validate_ssl_connection\n{\nmy ($ssl, $host, $reqs) = @_;\n$host = lc($host);\nmy $x509 = Net::SSLeay::get_peer_certificate($ssl);\n$x509 || return \"Could not fetch peer certificate\";\nif ($reqs->{'host'} || $reqs->{'checkhost'}) {\n\t# Check for sensible hostname\n\tmy @subjects;\n\tmy $subject = Net::SSLeay::X509_NAME_oneline(\n\t\tNet::SSLeay::X509_get_subject_name($x509));\n\t$subject =~ /CN=([a-z0-9\\-\\_\\.\\*]+)/i ||\n\t\treturn \"No CN found in subject $subject\";\n\tpush(@subjects, lc($1));\n\tmy @altlist = Net::SSLeay::X509_get_subjectAltNames($x509);\n\tfor(my $i=1; $i<@altlist; $i+=2) {\n\t\tpush(@subjects, lc($altlist[$i]));\n\t\t}\n\tmy @errs;\n\tforeach my $cn (@subjects) {\n\t\tif ($cn =~ /^\\*\\.(.*)$/) {\n\t\t\t# For a sub-domain\n\t\t\tmy $subcn = $1;\n\t\t\t$host eq $subcn || $host =~ /\\.\\Q$subcn\\E$/ ||\n\t\t\t    push(@errs, \"Certificate is for $cn, not $host.\");\n\t\t\t}\n\t\telsif ($cn eq \"*\") {\n\t\t\t# Matches anything .. but this may fail the\n\t\t\t# self-signed check\n\t\t\t}\n\t\telse {\n\t\t\t# For an exact domain\n\t\t\t$host eq $cn ||\n\t\t\t    push(@errs, \"Certificate is for $cn, not $host.\");\n\t\t\t}\n\t\t}\n\tif (scalar(@errs) == scalar(@subjects)) {\n\t\t# All subjects were bad\n\t\treturn join(\" \", @errs);\n\t\t}\n\t}\nif ($reqs->{'self'}) {\n\t# Check if self-signed\n\tmy $subject = Net::SSLeay::X509_NAME_oneline(\n\t\tNet::SSLeay::X509_get_subject_name($x509));\n\tmy $issuer = Net::SSLeay::X509_NAME_oneline(\n\t\tNet::SSLeay::X509_get_issuer_name($x509));\n\tif ($subject eq $issuer) {\n\t\treturn \"Certificate is self-signed by $subject\";\n\t\t}\n\t}\nif ($reqs->{'capath'}) {\n\t# Check if CA is signed by a valid authority (set in a callback)\n\treturn $main::last_set_verify_err if ($main::last_set_verify_err);\n\t}\nreturn undef;\n}\n\n=head2 read_http_connection(&handle, [bytes])\n\nReads either one line or up to the specified number of bytes from the handle,\noriginally supplied by make_http_connection.\n\n=cut\nsub read_http_connection\n{\nmy ($h, $want) = @_;\nmy $rv;\nif ($h->{'ssl_con'}) {\n\tif (!$want) {\n\t\tmy ($idx, $more);\n\t\twhile(($idx = index($h->{'buffer'}, \"\\n\")) < 0) {\n\t\t\t# need to read more..\n\t\t\tif (!($more = Net::SSLeay::read($h->{'ssl_con'}))) {\n\t\t\t\t# end of the data\n\t\t\t\t$rv = $h->{'buffer'};\n\t\t\t\tdelete($h->{'buffer'});\n\t\t\t\treturn $rv;\n\t\t\t\t}\n\t\t\t$h->{'buffer'} .= $more;\n\t\t\t}\n\t\t$rv = substr($h->{'buffer'}, 0, $idx+1);\n\t\t$h->{'buffer'} = substr($h->{'buffer'}, $idx+1);\n\t\t}\n\telse {\n\t\tif (length($h->{'buffer'})) {\n\t\t\t$rv = $h->{'buffer'};\n\t\t\tdelete($h->{'buffer'});\n\t\t\t}\n\t\telse {\n\t\t\t$rv = Net::SSLeay::read($h->{'ssl_con'}, $want);\n\t\t\t}\n\t\t}\n\t}\nelse {\n\tif ($want) {\n\t\tread($h->{'fh'}, $rv, $want) > 0 || return undef;\n\t\t}\n\telse {\n\t\tmy $fh = $h->{'fh'};\n\t\t$rv = <$fh>;\n\t\t}\n\t}\n$rv = undef if ($rv eq \"\");\nreturn $rv;\n}\n\n=head2 write_http_connection(&handle, [data+])\n\nWrites the given data to the given HTTP connection handle.\n\n=cut\nsub write_http_connection\n{\nmy $h = shift(@_);\nmy $fh = $h->{'fh'};\nmy $allok = 1;\nif ($h->{'ssl_ctx'}) {\n\tforeach my $s (@_) {\n\t\tmy $ok = Net::SSLeay::write($h->{'ssl_con'}, $s);\n\t\t$allok = 0 if (!$ok);\n\t\t}\n\t}\nelse {\n\tmy $ok = (print $fh @_);\n\t$allok = 0 if (!$ok);\n\t}\nreturn $allok;\n}\n\n=head2 close_http_connection(&handle)\n\nCloses a connection to an HTTP server, identified by the given handle.\n\n=cut\nsub close_http_connection\n{\nmy ($h) = @_;\nreturn close($h->{'fh'});\n}\n\n=head2 clean_environment\n\nDeletes any environment variables inherited from miniserv so that they\nwon't be passed to programs started by webmin. This is useful when calling\nprograms that check for CGI-related environment variables and modify their\nbehaviour, and to avoid passing sensitive variables to un-trusted programs.\n\n=cut\nsub clean_environment\n{\n%UNCLEAN_ENV = %ENV;\nforeach my $k (keys %ENV) {\n\tif ($k =~ /^(HTTP|VIRTUALSERVER|QUOTA|USERADMIN)_/) {\n\t\tdelete($ENV{$k});\n\t\t}\n\t}\nforeach my $e ('WEBMIN_CONFIG', 'SERVER_NAME', 'CONTENT_TYPE', 'REQUEST_URI',\n\t    'PATH_INFO', 'WEBMIN_VAR', 'REQUEST_METHOD', 'GATEWAY_INTERFACE',\n\t    'QUERY_STRING', 'REMOTE_USER', 'SERVER_SOFTWARE', 'SERVER_PROTOCOL',\n\t    'REMOTE_HOST', 'SERVER_PORT', 'DOCUMENT_ROOT', 'SERVER_ROOT',\n\t    'MINISERV_CONFIG', 'SCRIPT_NAME', 'SERVER_ADMIN', 'CONTENT_LENGTH',\n\t    'HTTPS', 'FOREIGN_MODULE_NAME', 'FOREIGN_ROOT_DIRECTORY',\n\t    'SCRIPT_FILENAME', 'PATH_TRANSLATED', 'BASE_REMOTE_USER',\n\t    'DOCUMENT_REALROOT', 'MINISERV_CONFIG', 'MYSQL_PWD',\n\t    'MINISERV_PID') {\n\tdelete($ENV{$e});\n\t}\n}\n\n=head2 reset_environment\n\nPuts the environment back how it was before clean_environment was callled.\n\n=cut\nsub reset_environment\n{\nif (%UNCLEAN_ENV) {\n\tforeach my $k (keys %UNCLEAN_ENV) {\n\t\t$ENV{$k} = $UNCLEAN_ENV{$k};\n\t\t}\n\tundef(%UNCLEAN_ENV);\n\t}\n}\n\n=head2 clean_language\n\nSets all language and locale-related environment variables to US english, to\nensure that commands run output in the expected language. Can be reverted by\nreset_environment.\n\n=cut\nsub clean_language\n{\nif (!%UNCLEAN_ENV) {\n\t%UNCLEAN_ENV = %ENV;\n\t}\n$ENV{'LANG'} = '';\n$ENV{'LANGUAGE'} = '';\n$ENV{'LC_ALL'} = '';\n$ENV{'LOCALE'} = '';\n}\n\n=head2 progress_callback\n\nNever called directly, but useful for passing to &http_download to print\nout progress of an HTTP request.\n\n=cut\nsub progress_callback\n{\nif (defined(&theme_progress_callback)) {\n\t# Call the theme override\n\treturn &theme_progress_callback(@_);\n\t}\nif ($_[0] == 2) {\n\t# Got size\n\tprint $progress_callback_prefix;\n\tif ($_[1]) {\n\t\t$progress_size = $_[1];\n\t\t$progress_step = int($_[1] / 10);\n\t\tprint &text('progress_size2', $progress_callback_url,\n\t\t\t    &nice_size($progress_size)),\"<br>\\n\";\n\t\t}\n\telse {\n\t\t$progress_size = undef;\n\t\tprint &text('progress_nosize', $progress_callback_url),\"<br>\\n\";\n\t\t}\n\t$last_progress_time = $last_progress_size = undef;\n\t}\nelsif ($_[0] == 3) {\n\t# Got data update\n\tmy $sp = $progress_callback_prefix.(\"&nbsp;\" x 5);\n\tif ($progress_size) {\n\t\t# And we have a size to compare against\n\t\tmy $st = int(($_[1] * 10) / $progress_size);\n\t\tmy $time_now = time();\n\t\tif ($st != $progress_step ||\n\t\t    $time_now - $last_progress_time > 60) {\n\t\t\t# Show progress every 10% or 60 seconds\n\t\t\tprint $sp,&text('progress_datan', &nice_size($_[1]),\n\t\t\t\t        int($_[1]*100/$progress_size)),\"<br>\\n\";\n\t\t\t$last_progress_time = $time_now;\n\t\t\t}\n\t\t$progress_step = $st;\n\t\t}\n\telse {\n\t\t# No total size .. so only show in 1M jumps\n\t\tif ($_[1] > $last_progress_size+1024*1024) {\n\t\t\tprint $sp,&text('progress_data2n',\n\t\t\t\t\t&nice_size($_[1])),\"<br>\\n\";\n\t\t\t$last_progress_size = $_[1];\n\t\t\t}\n\t\t}\n\t}\nelsif ($_[0] == 4) {\n\t# All done downloading\n\tprint $progress_callback_prefix,&text('progress_done'),\"<br>\\n\";\n\t}\nelsif ($_[0] == 5) {\n\t# Got new location after redirect\n\t$progress_callback_url = $_[1];\n\t}\nelsif ($_[0] == 6) {\n\t# URL is in cache\n\t$progress_callback_url = $_[1];\n\tprint &text('progress_incache', $progress_callback_url),\"<br>\\n\";\n\t}\n}\n\n=head2 switch_to_remote_user\n\nChanges the user and group of the current process to that of the unix user\nwith the same name as the current webmin login, or fails if there is none.\nThis should be called by Usermin module scripts that only need to run with\nlimited permissions.\n\n=cut\nsub switch_to_remote_user\n{\n@remote_user_info = $remote_user ? getpwnam($remote_user) :\n\t\t    \t\t   getpwuid($<);\n@remote_user_info || &error(&text('switch_remote_euser', $remote_user));\n&create_missing_homedir(\\@remote_user_info);\nif ($< == 0) {\n\t&switch_to_unix_user(\\@remote_user_info);\n\t$ENV{'USER'} = $ENV{'LOGNAME'} = $remote_user;\n\t$ENV{'HOME'} = $remote_user_info[7];\n\t}\n# Export global variables to caller\nif ($main::export_to_caller) {\n\tmy ($callpkg) = caller();\n\teval \"\\@${callpkg}::remote_user_info = \\@remote_user_info\";\n\t}\n}\n\n=head2 switch_to_unix_user(&user-details)\n\nSwitches the current process to the UID and group ID from the given list\nof user details, which must be in the format returned by getpwnam.\n\n=cut\nsub switch_to_unix_user\n{\nmy ($uinfo) = @_;\nif (!defined($uinfo->[0])) {\n\t# No username given, so just use given GID\n\t($(, $)) = ( $uinfo->[3], \"$uinfo->[3] $uinfo->[3]\" );\n\t}\nelse {\n\t# Use all groups from user\n\t($(, $)) = ( $uinfo->[3],\n\t\t     \"$uinfo->[3] \".join(\" \", $uinfo->[3],\n\t\t\t\t\t &other_groups($uinfo->[0])) );\n\t}\neval {\n\tPOSIX::setuid($uinfo->[2]);\n\t};\nif ($< != $uinfo->[2] || $> != $uinfo->[2]) {\n\t($>, $<) = ( $uinfo->[2], $uinfo->[2] );\n\t}\n}\n\n=head2 eval_as_unix_user(username, &code)\n\nRuns some code fragment with the effective UID and GID switch to that\nof the given Unix user, so that file IO takes place with his permissions.\n\n=cut\n\nsub eval_as_unix_user\n{\nmy ($user, $code) = @_;\nmy @uinfo = getpwnam($user);\nif (!scalar(@uinfo)) {\n\t&error(\"eval_as_unix_user called with invalid user $user\");\n\t}\n$) = $uinfo[3].\" \".join(\" \", $uinfo[3], &other_groups($user));\n$> = $uinfo[2];\nmy @rv;\neval {\n\tlocal $main::error_must_die = 1;\n\t@rv = &$code();\n\t};\nmy $err = $@;\n$) = 0;\n$> = 0;\nif ($err) {\n\t$err =~ s/\\s+at\\s+(\\/\\S+)\\s+line\\s+(\\d+)\\.?//;\n\t&error($err);\n\t}\nreturn wantarray ? @rv : $rv[0];\n}\n\n=head2 create_user_config_dirs\n\nCreates per-user config directories and sets $user_config_directory and\n$user_module_config_directory to them. Also reads per-user module configs\ninto %userconfig. This should be called by Usermin module scripts that need\nto store per-user preferences or other settings.\n\n=cut\nsub create_user_config_dirs\n{\nreturn if (!$gconfig{'userconfig'});\nmy @uinfo = @remote_user_info ? @remote_user_info : getpwnam($remote_user);\nreturn if (!@uinfo || !$uinfo[7]);\n&create_missing_homedir(\\@uinfo);\n$user_config_directory = \"$uinfo[7]/$gconfig{'userconfig'}\";\nif (!-d $user_config_directory) {\n\tmkdir($user_config_directory, 0700) ||\n\t\t&error(\"Failed to create $user_config_directory : $!\");\n\tif ($< == 0 && $uinfo[2]) {\n\t\tchown($uinfo[2], $uinfo[3], $user_config_directory);\n\t\t}\n\t}\nif (&get_module_name()) {\n\t$user_module_config_directory = $user_config_directory.\"/\".\n\t\t\t\t\t&get_module_name();\n\tif (!-d $user_module_config_directory) {\n\t\tmkdir($user_module_config_directory, 0700) ||\n\t\t\t&error(\"Failed to create $user_module_config_directory : $!\");\n\t\tif ($< == 0 && $uinfo[2]) {\n\t\t\tchown($uinfo[2], $uinfo[3], $user_config_directory);\n\t\t\t}\n\t\t}\n\tundef(%userconfig);\n\t&read_file_cached(\"$module_root_directory/defaultuconfig\",\n\t\t\t  \\%userconfig);\n\t&read_file_cached(\"$module_config_directory/uconfig\", \\%userconfig);\n\t&read_file_cached(\"$user_module_config_directory/config\",\n\t\t\t  \\%userconfig);\n\t}\n\n# Export global variables to caller\nif ($main::export_to_caller) {\n\tmy ($callpkg) = caller();\n\tforeach my $v ('$user_config_directory',\n\t\t       '$user_module_config_directory', '%userconfig') {\n\t\tmy ($vt, $vn) = split('', $v, 2);\n\t\teval \"${vt}${callpkg}::${vn} = ${vt}${vn}\";\n\t\t}\n\t}\n}\n\n=head2 create_missing_homedir(&uinfo)\n\nIf auto homedir creation is enabled, create one for this user if needed.\nFor internal use only.\n\n=cut\nsub create_missing_homedir\n{\nmy ($uinfo) = @_;\nif (!-e $uinfo->[7] && $gconfig{'create_homedir'}) {\n\t# Use has no home dir .. make one\n\tsystem(\"mkdir -p \".quotemeta($uinfo->[7]));\n\tchown($uinfo->[2], $uinfo->[3], $uinfo->[7]);\n\tif ($gconfig{'create_homedir_perms'} ne '') {\n\t\tchmod(oct($gconfig{'create_homedir_perms'}), $uinfo->[7]);\n\t\t}\n\t}\n}\n\n=head2 filter_javascript(text)\n\nDisables all javascript <script>, onClick= and so on tags in the given HTML,\nand returns the new HTML. Useful for displaying HTML from an un-trusted source.\n\n=cut\nsub filter_javascript\n{\nmy ($rv) = @_;\n$rv =~ s/<\\s*script[^>]*>([\\000-\\377]*?)<\\s*\\/script\\s*>//gi;\n$rv =~ s/(on(Abort|BeforeUnload|Blur|Change|Click|ContextMenu|Copy|Cut|DblClick|Drag|DragEnd|DragEnter|DragLeave|DragOver|DragStart|DragDrop|Drop|Error|Focus|FocusIn|FocusOut|HashChange|Input|Invalid|KeyDown|KeyPress|KeyUp|Load|MouseDown|MouseEnter|MouseLeave|MouseMove|MouseOut|MouseOver|MouseUp|Move|Paste|PageShow|PageHide|Reset|Resize|Scroll|Search|Select|Submit|Toggle|Unload)=)/x$1/gi;\n$rv =~ s/(javascript:)/x$1/gi;\n$rv =~ s/(vbscript:)/x$1/gi;\n$rv =~ s/<([^>]*\\s|)(on\\S+=)(.*)>/<$1x$2$3>/gi;\nreturn $rv;\n}\n\n=head2 resolve_links(path)\n\nGiven a path that may contain symbolic links, returns the real path.\n\n=cut\nsub resolve_links\n{\nmy ($path) = @_;\n$path =~ s/\\/+/\\//g;\n$path =~ s/\\/$// if ($path ne \"/\");\nmy @p = split(/\\/+/, $path);\nshift(@p);\nfor(my $i=0; $i<@p; $i++) {\n\tmy $sofar = \"/\".join(\"/\", @p[0..$i]);\n\tmy $lnk = readlink($sofar);\n\tif ($lnk eq $sofar) {\n\t\t# Link to itself! Cannot do anything more really ..\n\t\tlast;\n\t\t}\n\telsif ($lnk =~ /^\\//) {\n\t\t# Link is absolute..\n\t\treturn &resolve_links($lnk.\"/\".join(\"/\", @p[$i+1 .. $#p]));\n\t\t}\n\telsif ($lnk) {\n\t\t# Link is relative\n\t\treturn &resolve_links(\"/\".join(\"/\", @p[0..$i-1]).\"/\".$lnk.\"/\".join(\"/\", @p[$i+1 .. $#p]));\n\t\t}\n\t}\nreturn $path;\n}\n\n=head2 simplify_path(path, bogus)\n\nGiven a path, maybe containing elements \"..\" and \".\" , convert it to a\nclean, absolute form. Returns undef if this is not possible.\n\n=cut\nsub simplify_path\n{\nmy ($dir) = @_;\n$dir =~ s/^\\/+//g;\n$dir =~ s/\\/+$//g;\nmy @bits = split(/\\/+/, $dir);\nmy @fixedbits = ();\n$_[1] = 0;\nforeach my $b (@bits) {\n        if ($b eq \".\") {\n                # Do nothing..\n                }\n        elsif ($b eq \"..\") {\n                # Remove last dir\n                if (scalar(@fixedbits) == 0) {\n\t\t\t# Cannot! Already at root!\n\t\t\treturn undef;\n                        }\n                pop(@fixedbits);\n                }\n        else {\n                # Add dir to list\n                push(@fixedbits, $b);\n                }\n        }\nreturn \"/\".join('/', @fixedbits);\n}\n\n=head2 same_file(file1, file2)\n\nReturns 1 if two files are actually the same\n\n=cut\nsub same_file\n{\nreturn 1 if ($_[0] eq $_[1]);\nreturn 0 if ($_[0] !~ /^\\// || $_[1] !~ /^\\//);\nmy @stat1 = $stat_cache{$_[0]} ? @{$stat_cache{$_[0]}}\n\t\t\t       : (@{$stat_cache{$_[0]}} = stat($_[0]));\nmy @stat2 = $stat_cache{$_[1]} ? @{$stat_cache{$_[1]}}\n\t\t\t       : (@{$stat_cache{$_[1]}} = stat($_[1]));\nreturn 0 if (!@stat1 || !@stat2);\nreturn $stat1[0] == $stat2[0] && $stat1[1] == $stat2[1];\n}\n\n=head2 flush_webmin_caches\n\nClears all in-memory and on-disk caches used by Webmin.\n\n=cut\nsub flush_webmin_caches\n{\nundef(%main::read_file_cache);\nundef(%main::acl_hash_cache);\nundef(%main::acl_array_cache);\nundef(%main::has_command_cache);\nundef(@main::list_languages_cache);\nundef($main::got_list_usermods_cache);\nundef(@main::list_usermods_cache);\nundef(%main::foreign_installed_cache);\nunlink(\"$config_directory/module.infos.cache\");\nunlink(\"$var_directory/module.infos.cache\");\n&get_all_module_infos();\n}\n\n=head2 list_usermods\n\nReturns a list of additional module restrictions. For internal use in\nUsermin only.\n\n=cut\nsub list_usermods\n{\nif (!$main::got_list_usermods_cache) {\n\t@main::list_usermods_cache = ( );\n\tlocal $_;\n\topen(USERMODS, \"$config_directory/usermin.mods\");\n\twhile(<USERMODS>) {\n\t\tif (/^([^:]+):(\\+|-|):(.*)/) {\n\t\t\tpush(@main::list_usermods_cache,\n\t\t\t     [ $1, $2, [ split(/\\s+/, $3) ] ]);\n\t\t\t}\n\t\t}\n\tclose(USERMODS);\n\t$main::got_list_usermods_cache = 1;\n\t}\nreturn @main::list_usermods_cache;\n}\n\n=head2 available_usermods(&allmods, &usermods)\n\nReturns a list of modules that are available to the given user, based\non usermod additional/subtractions. For internal use by Usermin only.\n\n=cut\nsub available_usermods\n{\nreturn @{$_[0]} if (!@{$_[1]});\n\nmy %mods = map { $_->{'dir'}, 1 } @{$_[0]};\nmy @uinfo = @remote_user_info;\n@uinfo = getpwnam($remote_user) if (!@uinfo);\nforeach my $u (@{$_[1]}) {\n\tmy $applies;\n\tif ($u->[0] eq \"*\" || $u->[0] eq $remote_user) {\n\t\t$applies++;\n\t\t}\n\telsif ($u->[0] =~ /^\\@(.*)$/) {\n\t\t# Check for group membership\n\t\tmy @ginfo = getgrnam($1);\n\t\t$applies++ if (@ginfo && ($ginfo[2] == $uinfo[3] ||\n\t\t\t&indexof($remote_user, split(/\\s+/, $ginfo[3])) >= 0));\n\t\t}\n\telsif ($u->[0] =~ /^\\//) {\n\t\t# Check users and groups in file\n\t\tlocal $_;\n\t\topen(USERFILE, $u->[0]);\n\t\twhile(<USERFILE>) {\n\t\t\ttr/\\r\\n//d;\n\t\t\tif ($_ eq $remote_user) {\n\t\t\t\t$applies++;\n\t\t\t\t}\n\t\t\telsif (/^\\@(.*)$/) {\n\t\t\t\tmy @ginfo = getgrnam($1);\n\t\t\t\t$applies++\n\t\t\t\t  if (@ginfo && ($ginfo[2] == $uinfo[3] ||\n\t\t\t\t      &indexof($remote_user,\n\t\t\t\t\t       split(/\\s+/, $ginfo[3])) >= 0));\n\t\t\t\t}\n\t\t\tlast if ($applies);\n\t\t\t}\n\t\tclose(USERFILE);\n\t\t}\n\tif ($applies) {\n\t\tif ($u->[1] eq \"+\") {\n\t\t\tmap { $mods{$_}++ } @{$u->[2]};\n\t\t\t}\n\t\telsif ($u->[1] eq \"-\") {\n\t\t\tmap { delete($mods{$_}) } @{$u->[2]};\n\t\t\t}\n\t\telse {\n\t\t\tundef(%mods);\n\t\t\tmap { $mods{$_}++ } @{$u->[2]};\n\t\t\t}\n\t\t}\n\t}\nreturn grep { $mods{$_->{'dir'}} } @{$_[0]};\n}\n\n=head2 get_available_module_infos(nocache)\n\nReturns a list of modules available to the current user, based on\noperating system support, access control and usermod restrictions. Useful\nin themes that need to display a list of modules the user can use.\nEach element of the returned array is a hash reference in the same format as\nreturned by get_module_info.\n\n=cut\nsub get_available_module_infos\n{\nmy (%acl, %uacl);\n&read_acl(\\%acl, \\%uacl, [ $base_remote_user ]);\nmy $risk = $gconfig{'risk_'.$base_remote_user};\nmy @rv;\nforeach my $minfo (&get_all_module_infos($_[0])) {\n\tnext if (!&check_os_support($minfo));\n\tif ($risk) {\n\t\t# Check module risk level\n\t\tnext if ($risk ne 'high' && $minfo->{'risk'} &&\n\t\t\t $minfo->{'risk'} !~ /$risk/);\n\t\t}\n\telse {\n\t\t# Check user's ACL\n\t\tnext if (!$acl{$base_remote_user,$minfo->{'dir'}} &&\n\t\t\t !$acl{$base_remote_user,\"*\"});\n\t\t}\n\tnext if (&is_readonly_mode() && !$minfo->{'readonly'});\n\tpush(@rv, $minfo);\n\t}\n\n# Check usermod restrictions\nmy @usermods = &list_usermods();\n@rv = sort { lc($a->{'desc'}) cmp lc($b->{'desc'}) }\n\t    &available_usermods(\\@rv, \\@usermods);\n\n# Check RBAC restrictions\nmy @rbacrv;\nforeach my $m (@rv) {\n\tif (&supports_rbac($m->{'dir'}) &&\n\t    &use_rbac_module_acl(undef, $m->{'dir'})) {\n\t\tlocal $rbacs = &get_rbac_module_acl($remote_user,\n\t\t\t\t\t\t    $m->{'dir'});\n\t\tif ($rbacs) {\n\t\t\t# RBAC allows\n\t\t\tpush(@rbacrv, $m);\n\t\t\t}\n\t\t}\n\telse {\n\t\t# Module or system doesn't support RBAC\n\t\tpush(@rbacrv, $m) if (!$gconfig{'rbacdeny_'.$base_remote_user});\n\t\t}\n\t}\n\n# Check theme vetos\nmy @themerv;\nif (defined(&theme_foreign_available)) {\n\tforeach my $m (@rbacrv) {\n\t\tif (&theme_foreign_available($m->{'dir'})) {\n\t\t\tpush(@themerv, $m);\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t@themerv = @rbacrv;\n\t}\n\n# Check licence module vetos\nmy @licrv;\nif ($main::licence_module) {\n\tforeach my $m (@themerv) {\n\t\tif (&foreign_call($main::licence_module,\n\t\t\t\t  \"check_module_licence\", $m->{'dir'})) {\n\t\t\tpush(@licrv, $m);\n\t\t\t}\n\t\t}\n\t}\nelse {\n\t@licrv = @themerv;\n\t}\n\nreturn @licrv;\n}\n\n=head2 get_visible_module_infos(nocache)\n\nLike get_available_module_infos, but excludes hidden modules from the list.\nEach element of the returned array is a hash reference in the same format as\nreturned by get_module_info.\n\n=cut\nsub get_visible_module_infos\n{\nmy ($nocache) = @_;\nmy $pn = &get_product_name();\nreturn grep { !$_->{'hidden'} &&\n\t      !$_->{$pn.'_hidden'} } &get_available_module_infos($nocache);\n}\n\n=head2 get_visible_modules_categories(nocache)\n\nReturns a list of Webmin module categories, each of which is a hash ref\nwith 'code', 'desc' and 'modules' keys. The modules value is an array ref\nof modules in the category, in the format returned by get_module_info.\nUn-used modules are automatically assigned to the 'unused' category, and\nthose with no category are put into 'others'.\n\n=cut\nsub get_visible_modules_categories\n{\nmy ($nocache) = @_;\nmy @mods = &get_visible_module_infos($nocache);\nmy @unmods;\nif (&get_product_name() eq 'webmin') {\n\t@unmods = grep { $_->{'installed'} eq '0' } @mods;\n\t@mods = grep { $_->{'installed'} ne '0' } @mods;\n\t}\nmy %cats = &list_categories(\\@mods);\nmy @rv;\nforeach my $c (keys %cats) {\n\tmy $cat = { 'code' => $c || 'other',\n\t\t    'desc' => $cats{$c} };\n\t$cat->{'modules'} = [ grep { $_->{'category'} eq $c } @mods ];\n\tpush(@rv, $cat);\n\t}\n@rv = sort { ($b->{'code'} eq \"others\" ? \"\" : $b->{'code'}) cmp\n\t     ($a->{'code'} eq \"others\" ? \"\" : $a->{'code'}) } @rv;\nif (@unmods) {\n\t# Add un-installed modules in magic category\n\tmy $cat = { 'code' => 'unused',\n\t\t    'desc' => $text{'main_unused'},\n\t\t    'unused' => 1,\n\t\t    'modules' => \\@unmods };\n\tpush(@rv, $cat);\n\t}\nreturn @rv;\n}\n\n=head2 is_under_directory(directory, file)\n\nReturns 1 if the given file is under the specified directory, 0 if not.\nSymlinks are taken into account in the file to find it's 'real' location.\n\n=cut\nsub is_under_directory\n{\nmy ($dir, $file) = @_;\nreturn 1 if ($dir eq \"/\");\nreturn 0 if ($file =~ /\\.\\./);\nmy $ld = &resolve_links($dir);\nif ($ld ne $dir) {\n\treturn &is_under_directory($ld, $file);\n\t}\nmy $lp = &resolve_links($file);\nif ($lp ne $file) {\n\treturn &is_under_directory($dir, $lp);\n\t}\nreturn 0 if (length($file) < length($dir));\nreturn 1 if ($dir eq $file);\n$dir =~ s/\\/*$/\\//;\nreturn substr($file, 0, length($dir)) eq $dir;\n}\n\n=head2 parse_http_url(url, [basehost, baseport, basepage, basessl])\n\nGiven an absolute URL, returns the host, port, page and ssl flag components.\nIf a username and password are given before the hostname, return those too.\nRelative URLs can also be parsed, if the base information is provided.\nSSL mode 0 = HTTP, 1 = HTTPS, 2 = FTP.\n\n=cut\nsub parse_http_url\n{\nif ($_[0] =~ /^(http|https|ftp):\\/\\/([^\\@]+\\@)?\\[([^\\]]+)\\](:(\\d+))?(\\/\\S*)?$/ ||\n    $_[0] =~ /^(http|https|ftp):\\/\\/([^\\@]+\\@)?([^:\\/]+)(:(\\d+))?(\\/\\S*)?$/) {\n\t# An absolute URL\n\tmy $ssl = $1 eq 'https' ? 1 : $1 eq 'ftp' ? 2 : 0;\n\tmy @rv = ($3,\n\t\t  $4 ? $5 : $ssl == 1 ? 443 : $ssl == 2 ? 21 : 80,\n\t\t  $6 || \"/\",\n\t\t  $ssl,\n\t\t );\n\tif ($2 =~ /^([^:]+):(\\S+)\\@/) {\n\t\tpush(@rv, $1, $2);\n\t\t}\n\treturn @rv;\n\t}\nelsif (!$_[1]) {\n\t# Could not parse\n\treturn undef;\n\t}\nelsif ($_[0] =~ /^\\/\\S*$/) {\n\t# A relative to the server URL\n\treturn ($_[1], $_[2], $_[0], $_[4], $_[5], $_[6]);\n\t}\nelse {\n\t# A relative to the directory URL\n\tmy $page = $_[3];\n\t$page =~ s/[^\\/]+$//;\n\treturn ($_[1], $_[2], $page.$_[0], $_[4], $_[5], $_[6]);\n\t}\n}\n\n=head2 check_clicks_function\n\nReturns HTML for a JavaScript function called check_clicks that returns\ntrue when first called, but false subsequently. Useful on onClick for\ncritical buttons. Deprecated, as this method of preventing duplicate actions\nis un-reliable.\n\n=cut\nsub check_clicks_function\n{\nreturn <<EOF;\n<script type='text/javascript'>\nclicks = 0;\nfunction check_clicks(form)\n{\nclicks++;\nif (clicks == 1)\n\treturn true;\nelse {\n\tif (form != null) {\n\t\tfor(i=0; i<form.length; i++)\n\t\t\tform.elements[i].disabled = true;\n\t\t}\n\treturn false;\n\t}\n}\n</script>\nEOF\n}\n\n=head2 load_entities_map\n\nReturns a hash ref containing mappings between HTML entities (like ouml) and\nascii values (like 246). Mainly for internal use.\n\n=cut\nsub load_entities_map\n{\nif (!%entities_map_cache) {\n\tlocal $_;\n\topen(EMAP, \"$root_directory/entities_map.txt\");\n\twhile(<EMAP>) {\n\t\tif (/^(\\d+)\\s+(\\S+)/) {\n\t\t\t$entities_map_cache{$2} = $1;\n\t\t\t}\n\t\t}\n\tclose(EMAP);\n\t}\nreturn \\%entities_map_cache;\n}\n\n=head2 entities_to_ascii(string)\n\nGiven a string containing HTML entities like &ouml; and &#55;, replace them\nwith their ASCII equivalents.\n\n=cut\nsub entities_to_ascii\n{\nmy ($str) = @_;\nmy $emap = &load_entities_map();\n$str =~ s/&([a-z]+);/chr($emap->{$1})/ge;\n$str =~ s/&#(\\d+);/chr($1)/ge;\nreturn $str;\n}\n\n=head2 get_product_name\n\nReturns either 'webmin' or 'usermin', depending on which program the current\nmodule is in. Useful for modules that can be installed into either.\n\n=cut\nsub get_product_name\n{\nreturn $gconfig{'product'} if (defined($gconfig{'product'}));\nreturn defined($gconfig{'userconfig'}) ? 'usermin' : 'webmin';\n}\n\n=head2 get_charset\n\nReturns the character set for the current language, such as iso-8859-1.\n\n=cut\nsub get_charset\n{\nmy $charset = defined($gconfig{'charset'}) ? $gconfig{'charset'} :\n\t\t $current_lang_info->{'charset'} ?\n\t\t $current_lang_info->{'charset'} : $default_charset;\nreturn $charset;\n}\n\n=head2 get_display_hostname\n\nReturns the system's hostname for UI display purposes. This may be different\nfrom the actual hostname if you administrator has configured it so in the\nWebmin Configuration module.\n\n=cut\nsub get_display_hostname\n{\nif ($gconfig{'hostnamemode'} == 0) {\n\treturn &get_system_hostname();\n\t}\nelsif ($gconfig{'hostnamemode'} == 3) {\n\treturn $gconfig{'hostnamedisplay'};\n\t}\nelse {\n\tmy $h = $ENV{'HTTP_HOST'};\n\treturn &get_system_hostname() if (!$h);\n\t$h =~ s/:\\d+//g;\n\tif ($gconfig{'hostnamemode'} == 2) {\n\t\t$h =~ s/^(www|ftp|mail)\\.//i;\n\t\t}\n\treturn $h;\n\t}\n}\n\n=head2 save_module_config([&config], [modulename])\n\nSaves the configuration for some module. The config parameter is an optional\nhash reference of names and values to save, which defaults to the global\n%config hash. The modulename parameter is the module to update the config\nfile, which defaults to the current module.\n\n=cut\nsub save_module_config\n{\nmy $c = $_[0] || { &get_module_variable('%config') };\nmy $m;\nif (defined($_[1])) {\n\t$m = $_[1];\n\t}\nelse {\n\t$m = &get_module_name();\n\t$m || &error(\"could not compute current module in save_module_config\");\n\t}\n&write_file(\"$config_directory/$m/config\", $c);\n}\n\n=head2 save_user_module_config([&config], [modulename])\n\nSaves the user's Usermin preferences for some module. The config parameter is\nan optional hash reference of names and values to save, which defaults to the\nglobal %userconfig hash. The modulename parameter is the module to update the\nconfig file, which defaults to the current module.\n\n=cut\nsub save_user_module_config\n{\nmy $c = $_[0] || { &get_module_variable('%userconfig') };\nmy $m = $_[1] || &get_module_name();\nmy $ucd = $user_config_directory;\nif (!$ucd) {\n\tmy @uinfo = @remote_user_info ? @remote_user_info\n\t\t\t\t      : getpwnam($remote_user);\n\treturn if (!@uinfo || !$uinfo[7]);\n\t$ucd = \"$uinfo[7]/$gconfig{'userconfig'}\";\n\t}\n&write_file(\"$ucd/$m/config\", $c);\n}\n\n=head2 nice_size(bytes, [min])\n\nConverts a number of bytes into a number followed by a suffix like GB, MB\nor kB. Rounding is to two decimal digits. The optional min parameter sets the\nsmallest units to use - so you could pass 1024*1024 to never show bytes or kB.\n\n=cut\nsub nice_size\n{\nmy ($units, $uname);\n&load_theme_library();\nif (defined(&theme_nice_size) &&\n    $main::header_content_type eq \"text/html\" &&\n    $main::webmin_script_type eq \"web\") {\n\treturn &theme_nice_size(@_);\n\t}\nif (abs($_[0]) > 1024*1024*1024*1024 || $_[1] >= 1024*1024*1024*1024) {\n\t$units = 1024*1024*1024*1024;\n\t$uname = \"TB\";\n\t}\nelsif (abs($_[0]) > 1024*1024*1024 || $_[1] >= 1024*1024*1024) {\n\t$units = 1024*1024*1024;\n\t$uname = \"GB\";\n\t}\nelsif (abs($_[0]) > 1024*1024 || $_[1] >= 1024*1024) {\n\t$units = 1024*1024;\n\t$uname = \"MB\";\n\t}\nelsif (abs($_[0]) > 1024 || $_[1] >= 1024) {\n\t$units = 1024;\n\t$uname = \"kB\";\n\t}\nelse {\n\t$units = 1;\n\t$uname = \"bytes\";\n\t}\nmy $sz = sprintf(\"%.2f\", ($_[0]*1.0 / $units));\n$sz =~ s/\\.00$//;\nreturn $sz.\" \".$uname;\n}\n\n=head2 get_perl_path\n\nReturns the path to Perl currently in use, such as /usr/bin/perl.\n\n=cut\nsub get_perl_path\n{\nif (open(PERL, \"$config_directory/perl-path\")) {\n\tmy $rv;\n\tchop($rv = <PERL>);\n\tclose(PERL);\n\treturn $rv;\n\t}\nreturn $^X if (-x $^X);\nreturn &has_command(\"perl\");\n}\n\n=head2 get_goto_module([&mods])\n\nReturns the details of a module that the current user should be re-directed\nto after logging in, or undef if none. Useful for themes.\n\n=cut\nsub get_goto_module\n{\nmy @mods = $_[0] ? @{$_[0]} : &get_visible_module_infos();\nif ($gconfig{'gotomodule'}) {\n\tmy ($goto) = grep { $_->{'dir'} eq $gconfig{'gotomodule'} } @mods;\n\treturn $goto if ($goto);\n\t}\nif (@mods == 1 && $gconfig{'gotoone'}) {\n\treturn $mods[0];\n\t}\nreturn undef;\n}\n\n=head2 select_all_link(field, form, [text])\n\nReturns HTML for a 'Select all' link that uses Javascript to select\nmultiple checkboxes with the same name. The parameters are :\n\n=item field - Name of the checkbox inputs.\n\n=item form - Index of the form on the page.\n\n=item text - Message for the link, defaulting to 'Select all'.\n\n=cut\nsub select_all_link\n{\nreturn &theme_select_all_link(@_) if (defined(&theme_select_all_link));\nmy ($field, $form, $text) = @_;\n$form = int($form);\n$text ||= $text{'ui_selall'};\nreturn \"<a class='select_all' href='#' onClick='var ff = document.forms[$form].$field; ff.checked = true; for(i=0; i<ff.length; i++) { if (!ff[i].disabled) { ff[i].checked = true; } } return false'>$text</a>\";\n}\n\n=head2 select_invert_link(field, form, text)\n\nReturns HTML for an 'Invert selection' link that uses Javascript to invert the\nselection on multiple checkboxes with the same name. The parameters are :\n\n=item field - Name of the checkbox inputs.\n\n=item form - Index of the form on the page.\n\n=item text - Message for the link, defaulting to 'Invert selection'.\n\n=cut\nsub select_invert_link\n{\nreturn &theme_select_invert_link(@_) if (defined(&theme_select_invert_link));\nmy ($field, $form, $text) = @_;\n$form = int($form);\n$text ||= $text{'ui_selinv'};\nreturn \"<a class='select_invert' href='#' onClick='var ff = document.forms[$form].$field; ff.checked = !ff.checked; for(i=0; i<ff.length; i++) { if (!ff[i].disabled) { ff[i].checked = !ff[i].checked; } } return false'>$text</a>\";\n}\n\n=head2 select_rows_link(field, form, text, &rows)\n\nReturns HTML for a link that uses Javascript to select rows with particular\nvalues for their checkboxes. The parameters are :\n\n=item field - Name of the checkbox inputs.\n\n=item form - Index of the form on the page.\n\n=item text - Message for the link, de\n\n=item rows - Reference to an array of 1 or 0 values, indicating which rows to check.\n\n=cut\nsub select_rows_link\n{\nreturn &theme_select_rows_link(@_) if (defined(&theme_select_rows_link));\nmy ($field, $form, $text, $rows) = @_;\n$form = int($form);\nmy $js = \"var sel = { \".join(\",\", map { \"\\\"\".&quote_escape($_).\"\\\":1\" } @$rows).\" }; \";\n$js .= \"for(var i=0; i<document.forms[$form].${field}.length; i++) { var r = document.forms[$form].${field}[i]; r.checked = sel[r.value]; } \";\n$js .= \"return false;\";\nreturn \"<a href='#' onClick='$js'>$text</a>\";\n}\n\n=head2 check_pid_file(file)\n\nGiven a pid file, returns the PID it contains if the process is running.\n\n=cut\nsub check_pid_file\n{\nopen(PIDFILE, $_[0]) || return undef;\nmy $pid = <PIDFILE>;\nclose(PIDFILE);\n$pid =~ /^\\s*(\\d+)/ || return undef;\nkill(0, $1) || return undef;\nreturn $1;\n}\n\n=head2 get_mod_lib\n\nReturn the local os-specific library name to this module. For internal use only.\n\n=cut\nsub get_mod_lib\n{\nmy $mn = &get_module_name();\nmy $md = &module_root_directory($mn);\nif (-r \"$md/$mn-$gconfig{'os_type'}-$gconfig{'os_version'}-lib.pl\") {\n        return \"$mn-$gconfig{'os_type'}-$gconfig{'os_version'}-lib.pl\";\n        }\nelsif (-r \"$md/$mn-$gconfig{'os_type'}-lib.pl\") {\n        return \"$mn-$gconfig{'os_type'}-lib.pl\";\n        }\nelsif (-r \"$md/$mn-generic-lib.pl\") {\n        return \"$mn-generic-lib.pl\";\n        }\nelse {\n\treturn \"\";\n\t}\n}\n\n=head2 module_root_directory(module)\n\nGiven a module name, returns its root directory. On a typical Webmin install,\nall modules are under the same directory - but it is theoretically possible to\nhave more than one.\n\n=cut\nsub module_root_directory\n{\nmy $d = ref($_[0]) ? $_[0]->{'dir'} : $_[0];\nif (@root_directories > 1) {\n\tforeach my $r (@root_directories) {\n\t\tif (-d \"$r/$d\") {\n\t\t\treturn \"$r/$d\";\n\t\t\t}\n\t\t}\n\t}\nreturn \"$root_directories[0]/$d\";\n}\n\n=head2 list_mime_types\n\nReturns a list of all known MIME types and their extensions, as a list of hash\nreferences with keys :\n\n=item type - The MIME type, like text/plain.\n\n=item exts - A list of extensions, like .doc and .avi.\n\n=item desc - A human-readable description for the MIME type.\n\n=cut\nsub list_mime_types\n{\nif (!@list_mime_types_cache) {\n\tlocal $_;\n\topen(MIME, \"$root_directory/mime.types\");\n\twhile(<MIME>) {\n\t\tmy $cmt;\n\t\ts/\\r|\\n//g;\n\t\tif (s/#\\s*(.*)$//g) {\n\t\t\t$cmt = $1;\n\t\t\t}\n\t\tmy ($type, @exts) = split(/\\s+/);\n\t\tif ($type) {\n\t\t\tpush(@list_mime_types_cache, { 'type' => $type,\n\t\t\t\t\t\t       'exts' => \\@exts,\n\t\t\t\t\t\t       'desc' => $cmt });\n\t\t\t}\n\t\t}\n\tclose(MIME);\n\t}\nreturn @list_mime_types_cache;\n}\n\n=head2 guess_mime_type(filename, [default])\n\nGiven a file name like xxx.gif or foo.html, returns a guessed MIME type.\nThe optional default parameter sets a default type of use if none is found,\nwhich defaults to application/octet-stream.\n\n=cut\nsub guess_mime_type\n{\nif ($_[0] =~ /\\.([A-Za-z0-9\\-]+)$/) {\n\tmy $ext = $1;\n\tforeach my $t (&list_mime_types()) {\n\t\tforeach my $e (@{$t->{'exts'}}) {\n\t\t\treturn $t->{'type'} if (lc($e) eq lc($ext));\n\t\t\t}\n\t\t}\n\t}\nreturn @_ > 1 ? $_[1] : \"application/octet-stream\";\n}\n\n=head2 open_tempfile([handle], file, [no-error], [no-tempfile], [safe?])\n\nOpens a file handle for writing to a temporary file, which will only be\nrenamed over the real file when the handle is closed. This allows critical\nfiles like /etc/shadow to be updated safely, even if writing fails part way\nthrough due to lack of disk space. The parameters are :\n\n=item handle - File handle to open, as you would use in Perl's open function.\n\n=item file - Full path to the file to write, prefixed by > or >> to indicate over-writing or appending. In append mode, no temp file is used.\n\n=item no-error - By default, this function will call error if the open fails. Setting this parameter to 1 causes it to return 0 on failure, and set $! with the error code.\n\n=item no-tempfile - If set to 1, writing will be direct to the file instead of using a temporary file.\n\n=item safe - Indicates to users in read-only mode that this write is safe and non-destructive.\n\n=cut\nsub open_tempfile\n{\nif (@_ == 1) {\n\t# Just getting a temp file\n\tif (!defined($main::open_tempfiles{$_[0]})) {\n\t\t$_[0] =~ /^(.*)\\/(.*)$/ || return $_[0];\n\t\tmy $dir = $1 || \"/\";\n\t\tmy $tmp = \"$dir/$2.webmintmp.$$\";\n\t\t$main::open_tempfiles{$_[0]} = $tmp;\n\t\tpush(@main::temporary_files, $tmp);\n\t\t}\n\treturn $main::open_tempfiles{$_[0]};\n\t}\nelse {\n\t# Actually opening\n\tmy ($fh, $file, $noerror, $notemp, $safe) = @_;\n\t$fh = &callers_package($fh);\n\t$main::open_tempfiles_noerror{$file} = $noerror;\n\n\tmy %gaccess = &get_module_acl(undef, \"\");\n\tmy $db = $gconfig{'debug_what_write'};\n\tif ($file =~ /\\r|\\n|\\0/) {\n\t\tif ($noerror) { return 0; }\n\t\telse { &error(\"Filename contains invalid characters\"); }\n\t\t}\n\tif (&is_readonly_mode() && $file =~ />/ && !$safe) {\n\t\t# Read-only mode .. veto all writes\n\t\tprint STDERR \"vetoing write to $file\\n\";\n\t\treturn open($fh, \">$null_file\");\n\t\t}\n\telsif ($file =~ /^(>|>>|)nul$/i) {\n\t\t# Write to Windows null device\n\t\t&webmin_debug_log($1 eq \">\" ? \"WRITE\" :\n\t\t\t  $1 eq \">>\" ? \"APPEND\" : \"READ\", \"nul\") if ($db);\n\t\t}\n\telsif ($file =~ /^(>|>>)(\\/dev\\/.*)/ || lc($file) eq \"nul\") {\n\t\t# Writes to /dev/null or TTYs don't need to be handled\n\t\t&webmin_debug_log($1 eq \">\" ? \"WRITE\" : \"APPEND\", $2) if ($db);\n\t\treturn open($fh, $file);\n\t\t}\n\telsif ($file =~ /^>\\s*(([a-zA-Z]:)?\\/.*)$/ && !$notemp) {\n\t\t&webmin_debug_log(\"WRITE\", $1) if ($db);\n\t\t# Over-writing a file, via a temp file\n\t\t$file = $1;\n\t\t$file = &translate_filename($file);\n\t\twhile(-l $file) {\n\t\t\t# Open the link target instead\n\t\t\t$file = &resolve_links($file);\n\t\t\t}\n\t\tif (-d $file) {\n\t\t\t# Cannot open a directory!\n\t\t\tif ($noerror) { return 0; }\n\t\t\telse { &error(\"Cannot write to directory $file\"); }\n\t\t\t}\n\t\tmy @oldst = stat($file);\n\t\tmy $directopen = 0;\n\t\tmy $tmp = &open_tempfile($file);\n\t\tmy $ex = open($fh, \">$tmp\");\n\t\tif (!$ex && $! =~ /permission/i) {\n\t\t\t# Could not open temp file .. try opening actual file\n\t\t\t# instead directly\n\t\t\t$ex = open($fh, \">$file\");\n\t\t\tdelete($main::open_tempfiles{$file});\n\t\t\t$directopen = 1;\n\t\t\t}\n\t\telse {\n\t\t\t$main::open_temphandles{$fh} = $file;\n\t\t\t}\n\t\tif (!$ex && !$noerror) {\n\t\t\t&error(&text(\"efileopen\", $file, $!));\n\t\t\t}\n\t\tbinmode($fh);\n\t\tif (@oldst && !$directopen) {\n\t\t\t# Use same permissions as the file being overwritten\n\t\t\tchmod($oldst[2], $tmp);\n\t\t\t}\n\t\treturn $ex;\n\t\t}\n\telsif ($file =~ /^>\\s*(([a-zA-Z]:)?\\/.*)$/ && $notemp) {\n\t\t# Just writing direct to a file\n\t\t&webmin_debug_log(\"WRITE\", $1) if ($db);\n\t\t$file = $1;\n\t\t$file = &translate_filename($file);\n\t\tmy @old_attributes = &get_clear_file_attributes($file);\n\t\tmy $ex = open($fh, \">$file\");\n\t\t&reset_file_attributes($file, \\@old_attributes);\n\t\t$main::open_temphandles{$fh} = $file;\n\t\tif (!$ex && !$noerror) {\n\t\t\t&error(&text(\"efileopen\", $file, $!));\n\t\t\t}\n\t\tbinmode($fh);\n\t\treturn $ex;\n\t\t}\n\telsif ($file =~ /^>>\\s*(([a-zA-Z]:)?\\/.*)$/) {\n\t\t# Appending to a file .. nothing special to do\n\t\t&webmin_debug_log(\"APPEND\", $1) if ($db);\n\t\t$file = $1;\n\t\t$file = &translate_filename($file);\n\t\tmy @old_attributes = &get_clear_file_attributes($file);\n\t\tmy $ex = open($fh, \">>$file\");\n\t\t&reset_file_attributes($file, \\@old_attributes);\n\t\t$main::open_temphandles{$fh} = $file;\n\t\tif (!$ex && !$noerror) {\n\t\t\t&error(&text(\"efileopen\", $file, $!));\n\t\t\t}\n\t\tbinmode($fh);\n\t\treturn $ex;\n\t\t}\n\telsif ($file =~ /^([a-zA-Z]:)?\\//) {\n\t\t# Read mode .. nothing to do here\n\t\t&webmin_debug_log(\"READ\", $file) if ($db);\n\t\t$file = &translate_filename($file);\n\t\treturn open($fh, $file);\n\t\t}\n\telsif ($file eq \">\" || $file eq \">>\") {\n\t\tmy ($package, $filename, $line) = caller;\n\t\tif ($noerror) { return 0; }\n\t\telse { &error(\"Missing file to open at ${package}::${filename} line $line\"); }\n\t\t}\n\telse {\n\t\tmy ($package, $filename, $line) = caller;\n\t\t&error(\"Unsupported file or mode $file at ${package}::${filename} line $line\");\n\t\t}\n\t}\n}\n\n=head2 close_tempfile(file|handle)\n\nCopies a temp file to the actual file, assuming that all writes were\nsuccessful. The handle must have been one passed to open_tempfile.\n\n=cut\nsub close_tempfile\n{\nmy $file;\nmy $fh = &callers_package($_[0]);\n\nif (defined($file = $main::open_temphandles{$fh})) {\n\t# Closing a handle\n\tmy $noerror = $main::open_tempfiles_noerror{$file};\n\tif (!close($fh)) {\n\t\tif ($noerror) { return 0; }\n\t\telse { &error(&text(\"efileclose\", $file, $!)); }\n\t\t}\n\tdelete($main::open_temphandles{$fh});\n\treturn &close_tempfile($file);\n\t}\nelsif (defined($main::open_tempfiles{$_[0]})) {\n\t# Closing a file\n\tmy $noerror = $main::open_tempfiles_noerror{$_[0]};\n\t&webmin_debug_log(\"CLOSE\", $_[0]) if ($gconfig{'debug_what_write'});\n\tmy @st = stat($_[0]);\n\tif (&is_selinux_enabled() && &has_command(\"chcon\")) {\n\t\t# Set original security context\n\t\tsystem(\"chcon --reference=\".quotemeta($_[0]).\n\t\t       \" \".quotemeta($main::open_tempfiles{$_[0]}).\n\t\t       \" >/dev/null 2>&1\");\n\t\t}\n\tmy @old_attributes = &get_clear_file_attributes($_[0]);\n\tif (!rename($main::open_tempfiles{$_[0]}, $_[0])) {\n\t\tif ($noerror) { return 0; }\n\t\telse { &error(\"Failed to replace $_[0] with $main::open_tempfiles{$_[0]} : $!\"); }\n\t\t}\n\tif (@st) {\n\t\t# Set original permissions and ownership\n\t\tchmod($st[2], $_[0]);\n\t\tchown($st[4], $st[5], $_[0]);\n\t\t}\n\t&reset_file_attributes($_[0], \\@old_attributes);\n\tdelete($main::open_tempfiles{$_[0]});\n\tdelete($main::open_tempfiles_noerror{$_[0]});\n\t@main::temporary_files = grep { $_ ne $main::open_tempfiles{$_[0]} } @main::temporary_files;\n\tif ($main::open_templocks{$_[0]}) {\n\t\t&unlock_file($_[0]);\n\t\tdelete($main::open_templocks{$_[0]});\n\t\t}\n\treturn 1;\n\t}\nelse {\n\t# Must be closing a handle not associated with a file\n\tclose($_[0]);\n\treturn 1;\n\t}\n}\n\n=head2 print_tempfile(handle, text, ...)\n\nLike the normal print function, but calls &error on failure. Useful when\ncombined with open_tempfile, to ensure that a criticial file is never\nonly partially written.\n\n=cut\nsub print_tempfile\n{\nmy ($fh, @args) = @_;\n$fh = &callers_package($fh);\n(print $fh @args) || &error(&text(\"efilewrite\",\n\t\t\t    $main::open_temphandles{$fh} || $fh, $!));\n}\n\n=head2 is_selinux_enabled\n\nReturns 1 if SElinux is supported on this system and enabled, 0 if not.\n\n=cut\nsub is_selinux_enabled\n{\nif (!defined($main::selinux_enabled_cache)) {\n\tmy %seconfig;\n\tif ($gconfig{'os_type'} !~ /-linux$/) {\n\t\t# Not on linux, so no way\n\t\t$main::selinux_enabled_cache = 0;\n\t\t}\n\telsif (&read_env_file(\"/etc/selinux/config\", \\%seconfig)) {\n\t\t# Use global config file\n\t\t$main::selinux_enabled_cache =\n\t\t\t$seconfig{'SELINUX'} eq 'disabled' ||\n\t\t\t!$seconfig{'SELINUX'} ? 0 : 1;\n\t\t}\n\telse {\n\t\t# Use selinuxenabled command\n\t\t#$selinux_enabled_cache =\n\t\t#\tsystem(\"selinuxenabled >/dev/null 2>&1\") ? 0 : 1;\n\t\t$main::selinux_enabled_cache = 0;\n\t\t}\n\t}\nreturn $main::selinux_enabled_cache;\n}\n\n=head2 get_clear_file_attributes(file)\n\nFinds file attributes that may prevent writing, clears them and returns them\nas a list. May call error. Mainly for internal use by open_tempfile and\nclose_tempfile.\n\n=cut\nsub get_clear_file_attributes\n{\nmy ($file) = @_;\nmy @old_attributes;\nif ($gconfig{'chattr'}) {\n\t# Get original immutable bit\n\tmy $out = &backquote_command(\n\t\t\"lsattr \".quotemeta($file).\" 2>/dev/null\");\n\tif (!$?) {\n\t\t$out =~ s/\\s\\S+\\n//;\n\t\t@old_attributes = grep { $_ ne '-' } split(//, $out);\n\t\t}\n\tif (&indexof(\"i\", @old_attributes) >= 0) {\n\t\tmy $err = &backquote_logged(\n\t\t\t\"chattr -i \".quotemeta($file).\" 2>&1\");\n\t\tif ($?) {\n\t\t\t&error(\"Failed to remove immutable bit on \".\n\t\t\t       \"$file : $err\");\n\t\t\t}\n\t\t}\n\t}\nreturn @old_attributes;\n}\n\n=head2 reset_file_attributes(file, &attributes)\n\nPut back cleared attributes on some file. May call error. Mainly for internal\nuse by close_tempfile.\n\n=cut\nsub reset_file_attributes\n{\nmy ($file, $old_attributes) = @_;\nif (&indexof(\"i\", @$old_attributes) >= 0) {\n\tmy $err = &backquote_logged(\n\t\t\"chattr +i \".quotemeta($file).\" 2>&1\");\n\tif ($?) {\n\t\t&error(\"Failed to restore immutable bit on \".\n\t\t       \"$file : $err\");\n\t\t}\n\t}\n}\n\n=head2 cleanup_tempnames\n\nRemove all temporary files generated using transname. Typically only called\ninternally when a Webmin script exits.\n\n=cut\nsub cleanup_tempnames\n{\nforeach my $t (@main::temporary_files) {\n\t&unlink_file($t);\n\t}\n@main::temporary_files = ( );\n}\n\n=head2 open_lock_tempfile([handle], file, [no-error])\n\nReturns a temporary file for writing to some actual file, and also locks it.\nEffectively the same as calling lock_file and open_tempfile on the same file,\nbut calls the unlock for you automatically when it is closed.\n\n=cut\nsub open_lock_tempfile\n{\nmy ($fh, $file, $noerror, $notemp, $safe) = @_;\n$fh = &callers_package($fh);\nmy $lockfile = $file;\n$lockfile =~ s/^[^\\/]*//;\nif ($lockfile =~ /^\\//) {\n\twhile(-l $lockfile) {\n\t\t# If the file is a link, follow it so that locking is done on\n\t\t# the same file that gets unlocked later\n\t\t$lockfile = &resolve_links($lockfile);\n\t\t}\n\t$main::open_templocks{$lockfile} = &lock_file($lockfile);\n\t}\nreturn &open_tempfile($fh, $file, $noerror, $notemp, $safe);\n}\n\nsub END\n{\n$main::end_exit_status ||= $?;\nif ($$ == $main::initial_process_id) {\n\t# Exiting from initial process\n\t&cleanup_tempnames();\n\tif ($gconfig{'debug_what_start'} && $main::debug_log_start_time) {\n\t\tmy $len = time() - $main::debug_log_start_time;\n\t\t&webmin_debug_log(\"STOP\", \"runtime=$len\");\n\t\t$main::debug_log_start_time = 0;\n\t\t}\n\tif (!$ENV{'SCRIPT_NAME'}) {\n\t\t# In a command-line script - call the real exit, so that the\n\t\t# exit status gets properly propogated. In some cases this\n\t\t# was not happening.\n\t\texit($main::end_exit_status);\n\t\t}\n\t}\n}\n\n=head2 month_to_number(month)\n\nConverts a month name like feb to a number like 1.\n\n=cut\nsub month_to_number\n{\nreturn $month_to_number_map{lc(substr($_[0], 0, 3))};\n}\n\n=head2 number_to_month(number)\n\nConverts a number like 1 to a month name like Feb.\n\n=cut\nsub number_to_month\n{\nreturn ucfirst($number_to_month_map{$_[0]});\n}\n\n=head2 get_rbac_module_acl(user, module)\n\nReturns a hash reference of RBAC overrides ACLs for some user and module.\nMay return undef if none exist (indicating access denied), or the string *\nif full access is granted.\n\n=cut\nsub get_rbac_module_acl\n{\nmy ($user, $mod) = @_;\neval \"use Authen::SolarisRBAC\";\nreturn undef if ($@);\nmy %rv;\nmy $foundany = 0;\nif (Authen::SolarisRBAC::chkauth(\"webmin.$mod.admin\", $user)) {\n\t# Automagic webmin.modulename.admin authorization exists .. allow access\n\t$foundany = 1;\n\tif (!Authen::SolarisRBAC::chkauth(\"webmin.$mod.config\", $user)) {\n\t\t%rv = ( 'noconfig' => 1 );\n\t\t}\n\telse {\n\t\t%rv = ( );\n\t\t}\n\t}\nlocal $_;\nopen(RBAC, &module_root_directory($mod).\"/rbac-mapping\");\nwhile(<RBAC>) {\n\ts/\\r|\\n//g;\n\ts/#.*$//;\n\tmy ($auths, $acls) = split(/\\s+/, $_);\n\tmy @auths = split(/,/, $auths);\n\tnext if (!$auths);\n\tmy ($merge) = ($acls =~ s/^\\+//);\n\tmy $gotall = 1;\n\tif ($auths eq \"*\") {\n\t\t# These ACLs apply to all RBAC users.\n\t\t# Only if there is some that match a specific authorization\n\t\t# later will they be used though.\n\t\t}\n\telse {\n\t\t# Check each of the RBAC authorizations\n\t\tforeach my $a (@auths) {\n\t\t\tif (!Authen::SolarisRBAC::chkauth($a, $user)) {\n\t\t\t\t$gotall = 0;\n\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t$foundany++ if ($gotall);\n\t\t}\n\tif ($gotall) {\n\t\t# Found an RBAC authorization - return the ACLs\n\t\treturn \"*\" if ($acls eq \"*\");\n\t\tmy %acl = map { split(/=/, $_, 2) } split(/,/, $acls);\n\t\tif ($merge) {\n\t\t\t# Just add to current set\n\t\t\tforeach my $a (keys %acl) {\n\t\t\t\t$rv{$a} = $acl{$a};\n\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\t# Found final ACLs\n\t\t\treturn \\%acl;\n\t\t\t}\n\t\t}\n\t}\nclose(RBAC);\nreturn !$foundany ? undef : %rv ? \\%rv : undef;\n}\n\n=head2 supports_rbac([module])\n\nReturns 1 if RBAC client support is available, such as on Solaris.\n\n=cut\nsub supports_rbac\n{\nreturn 0 if ($gconfig{'os_type'} ne 'solaris');\neval \"use Authen::SolarisRBAC\";\nreturn 0 if ($@);\nif ($_[0]) {\n\t#return 0 if (!-r &module_root_directory($_[0]).\"/rbac-mapping\");\n\t}\nreturn 1;\n}\n\n=head2 supports_ipv6()\n\nReturns 1 if outgoing IPv6 connections can be made\n\n=cut\nsub supports_ipv6\n{\nreturn $ipv6_module_error ? 0 : 1;\n}\n\n=head2 use_rbac_module_acl(user, module)\n\nReturns 1 if some user should use RBAC to get permissions for a module\n\n=cut\nsub use_rbac_module_acl\n{\nmy $u = defined($_[0]) ? $_[0] : $base_remote_user;\nmy $m = defined($_[1]) ? $_[1] : &get_module_name();\nreturn 1 if ($gconfig{'rbacdeny_'.$u});\t\t# RBAC forced for user\nmy %access = &get_module_acl($u, $m, 1);\nreturn $access{'rbac'} ? 1 : 0;\n}\n\n=head2 execute_command(command, stdin, stdout, stderr, translate-files?, safe?)\n\nRuns some command, possibly feeding it input and capturing output to the\ngive files or scalar references. The parameters are :\n\n=item command - Full command to run, possibly including shell meta-characters.\n\n=item stdin - File to read input from, or a scalar ref containing input, or undef if no input should be given.\n\n=item stdout - File to write output to, or a scalar ref into which output should be placed, or undef if the output is to be discarded.\n\n=item stderr - File to write error output to, or a scalar ref into which error output should be placed, or undef if the error output is to be discarded.\n\n=item translate-files - Set to 1 to apply filename translation to any filenames. Usually has no effect.\n\n=item safe - Set to 1 if this command is safe and does not modify the state of the system.\n\n=cut\nsub execute_command\n{\nmy ($cmd, $stdin, $stdout, $stderr, $trans, $safe) = @_;\nif (&is_readonly_mode() && !$safe) {\n\tprint STDERR \"Vetoing command $_[0]\\n\";\n\t$? = 0;\n\treturn 0;\n\t}\n$cmd = &translate_command($cmd);\n\n# Use ` operator where possible\n&webmin_debug_log('CMD', \"cmd=$cmd\") if ($gconfig{'debug_what_cmd'});\nif (!$stdin && ref($stdout) && !$stderr) {\n\t$cmd = \"($cmd)\" if ($gconfig{'os_type'} ne 'windows');\n\t$$stdout = `$cmd 2>$null_file`;\n\treturn $?;\n\t}\nelsif (!$stdin && ref($stdout) && $stdout eq $stderr) {\n\t$cmd = \"($cmd)\" if ($gconfig{'os_type'} ne 'windows');\n\t$$stdout = `$cmd 2>&1`;\n\treturn $?;\n\t}\nelsif (!$stdin && !$stdout && !$stderr) {\n\t$cmd = \"($cmd)\" if ($gconfig{'os_type'} ne 'windows');\n\treturn system(\"$cmd >$null_file 2>$null_file <$null_file\");\n\t}\n\n# Setup pipes\n$| = 1;\t\t# needed on some systems to flush before forking\npipe(EXECSTDINr, EXECSTDINw);\npipe(EXECSTDOUTr, EXECSTDOUTw);\npipe(EXECSTDERRr, EXECSTDERRw);\nmy $pid;\nif (!($pid = fork())) {\n\tuntie(*STDIN);\n\tuntie(*STDOUT);\n\tuntie(*STDERR);\n\topen(STDIN, \"<&EXECSTDINr\");\n\topen(STDOUT, \">&EXECSTDOUTw\");\n\tif (ref($stderr) && $stderr eq $stdout) {\n\t\topen(STDERR, \">&EXECSTDOUTw\");\n\t\t}\n\telse {\n\t\topen(STDERR, \">&EXECSTDERRw\");\n\t\t}\n\t$| = 1;\n\tclose(EXECSTDINw);\n\tclose(EXECSTDOUTr);\n\tclose(EXECSTDERRr);\n\n\tmy $fullcmd = \"($cmd)\";\n\tif ($stdin && !ref($stdin)) {\n\t\t$fullcmd .= \" <$stdin\";\n\t\t}\n\tif ($stdout && !ref($stdout)) {\n\t\t$fullcmd .= \" >$stdout\";\n\t\t}\n\tif ($stderr && !ref($stderr)) {\n\t\tif ($stderr eq $stdout) {\n\t\t\t$fullcmd .= \" 2>&1\";\n\t\t\t}\n\t\telse {\n\t\t\t$fullcmd .= \" 2>$stderr\";\n\t\t\t}\n\t\t}\n\tif ($gconfig{'os_type'} eq 'windows') {\n\t\texec($fullcmd);\n\t\t}\n\telse {\n\t\texec(\"/bin/sh\", \"-c\", $fullcmd);\n\t\t}\n\tprint \"Exec failed : $!\\n\";\n\texit(1);\n\t}\nclose(EXECSTDINr);\nclose(EXECSTDOUTw);\nclose(EXECSTDERRw);\n\n# Feed input and capture output\nlocal $_;\nif ($stdin && ref($stdin)) {\n\tprint EXECSTDINw $$stdin;\n\tclose(EXECSTDINw);\n\t}\nif ($stdout && ref($stdout)) {\n\t$$stdout = undef;\n\twhile(<EXECSTDOUTr>) {\n\t\t$$stdout .= $_;\n\t\t}\n\tclose(EXECSTDOUTr);\n\t}\nif ($stderr && ref($stderr) && $stderr ne $stdout) {\n\t$$stderr = undef;\n\twhile(<EXECSTDERRr>) {\n\t\t$$stderr .= $_;\n\t\t}\n\tclose(EXECSTDERRr);\n\t}\n\n# Get exit status\nwaitpid($pid, 0);\nreturn $?;\n}\n\n=head2 open_readfile(handle, file)\n\nOpens some file for reading. Returns 1 on success, 0 on failure. Pretty much\nexactly the same as Perl's open function.\n\n=cut\nsub open_readfile\n{\nmy ($fh, $file) = @_;\n$fh = &callers_package($fh);\nmy $realfile = &translate_filename($file);\n&webmin_debug_log('READ', $file) if ($gconfig{'debug_what_read'});\nreturn open($fh, \"<\".$realfile);\n}\n\n=head2 open_execute_command(handle, command, output?, safe?)\n\nRuns some command, with the specified file handle set to either write to it if\nin-or-out is set to 0, or read to it if output is set to 1. The safe flag\nindicates if the command modifies the state of the system or not.\n\n=cut\nsub open_execute_command\n{\nmy ($fh, $cmd, $mode, $safe) = @_;\n$fh = &callers_package($fh);\nmy $realcmd = &translate_command($cmd);\nif (&is_readonly_mode() && !$safe) {\n\t# Don't actually run it\n\tprint STDERR \"vetoing command $cmd\\n\";\n\t$? = 0;\n\tif ($mode == 0) {\n\t\treturn open($fh, \">$null_file\");\n\t\t}\n\telse {\n\t\treturn open($fh, $null_file);\n\t\t}\n\t}\n# Really run it\n&webmin_debug_log('CMD', \"mode=$mode cmd=$realcmd\")\n\tif ($gconfig{'debug_what_cmd'});\nif ($mode == 0) {\n\treturn open($fh, \"| $cmd\");\n\t}\nelsif ($mode == 1) {\n\treturn open($fh, \"$cmd 2>$null_file |\");\n\t}\nelsif ($mode == 2) {\n\treturn open($fh, \"$cmd 2>&1 |\");\n\t}\n}\n\n=head2 translate_filename(filename)\n\nApplies all relevant registered translation functions to a filename. Mostly\nfor internal use, and typically does nothing.\n\n=cut\nsub translate_filename\n{\nmy ($realfile) = @_;\nmy @funcs = grep { $_->[0] eq &get_module_name() ||\n\t\t   !defined($_->[0]) } @main::filename_callbacks;\nforeach my $f (@funcs) {\n\tmy $func = $f->[1];\n\t$realfile = &$func($realfile, @{$f->[2]});\n\t}\nreturn $realfile;\n}\n\n=head2 translate_command(filename)\n\nApplies all relevant registered translation functions to a command. Mostly\nfor internal use, and typically does nothing.\n\n=cut\nsub translate_command\n{\nmy ($realcmd) = @_;\nmy @funcs = grep { $_->[0] eq &get_module_name() ||\n\t\t   !defined($_->[0]) } @main::command_callbacks;\nforeach my $f (@funcs) {\n\tmy $func = $f->[1];\n\t$realcmd = &$func($realcmd, @{$f->[2]});\n\t}\nreturn $realcmd;\n}\n\n=head2 register_filename_callback(module|undef, &function, &args)\n\nRegisters some function to be called when the specified module (or all\nmodules) tries to open a file for reading and writing. The function must\nreturn the actual file to open. This allows you to override which files\nother code actually operates on, via the translate_filename function.\n\n=cut\nsub register_filename_callback\n{\nmy ($mod, $func, $args) = @_;\npush(@main::filename_callbacks, [ $mod, $func, $args ]);\n}\n\n=head2 register_command_callback(module|undef, &function, &args)\n\nRegisters some function to be called when the specified module (or all\nmodules) tries to execute a command. The function must return the actual\ncommand to run. This allows you to override which commands other other code\nactually runs, via the translate_command function.\n\n=cut\nsub register_command_callback\n{\nmy ($mod, $func, $args) = @_;\npush(@main::command_callbacks, [ $mod, $func, $args ]);\n}\n\n=head2 capture_function_output(&function, arg, ...)\n\nCaptures output that some function prints to STDOUT, and returns it. Useful\nfor functions outside your control that print data when you really want to\nmanipulate it before output.\n\n=cut\nsub capture_function_output\n{\nmy ($func, @args) = @_;\nsocketpair(SOCKET2, SOCKET1, AF_UNIX, SOCK_STREAM, PF_UNSPEC);\nmy $old = select(SOCKET1);\nmy @rv = &$func(@args);\nselect($old);\nclose(SOCKET1);\nmy $out;\nlocal $_;\nwhile(<SOCKET2>) {\n\t$out .= $_;\n\t}\nclose(SOCKET2);\nreturn wantarray ? ($out, \\@rv) : $out;\n}\n\n=head2 capture_function_output_tempfile(&function, arg, ...)\n\nBehaves the same as capture_function_output, but uses a temporary file\nto avoid buffer full problems.\n\n=cut\nsub capture_function_output_tempfile\n{\nmy ($func, @args) = @_;\nmy $temp = &transname();\nopen(BUFFER, \">$temp\");\nmy $old = select(BUFFER);\nmy @rv = &$func(@args);\nselect($old);\nclose(BUFFER);\nmy $out = &read_file_contents($temp);\n&unlink_file($temp);\nreturn wantarray ? ($out, \\@rv) : $out;\n}\n\n=head2 modules_chooser_button(field, multiple, [form])\n\nReturns HTML for a button for selecting one or many Webmin modules.\nfield - Name of the HTML field to place the module names into.\nmultiple - Set to 1 if multiple modules can be selected.\nform - Index of the form on the page.\n\n=cut\nsub modules_chooser_button\n{\nreturn &theme_modules_chooser_button(@_)\n\tif (defined(&theme_modules_chooser_button));\nmy $form = defined($_[2]) ? $_[2] : 0;\nmy $w = $_[1] ? 700 : 500;\nmy $h = 200;\nif ($_[1] && $gconfig{'db_sizemodules'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizemodules'});\n\t}\nelsif (!$_[1] && $gconfig{'db_sizemodule'}) {\n\t($w, $h) = split(/x/, $gconfig{'db_sizemodule'});\n\t}\nreturn \"<input type=button onClick='ifield = document.forms[$form].$_[0]; chooser = window.open(\\\"$gconfig{'webprefix'}/module_chooser.cgi?multi=$_[1]&module=\\\"+escape(ifield.value), \\\"chooser\\\", \\\"toolbar=no,menubar=no,scrollbars=yes,width=$w,height=$h\\\"); chooser.ifield = ifield; window.ifield = ifield' value=\\\"...\\\">\\n\";\n}\n\n=head2 substitute_template(text, &hash)\n\nGiven some text and a hash reference, for each occurrence of $FOO or ${FOO} in\nthe text replaces it with the value of the hash key foo. Also supports blocks\nlike ${IF-FOO} ... ${ENDIF-FOO}, whose contents are only included if foo is\nnon-zero, and ${IF-FOO} ... ${ELSE-FOO} ... ${ENDIF-FOO}.\n\n=cut\nsub substitute_template\n{\n# Add some extra fixed parameters to the hash\nmy %hash = %{$_[1]};\n$hash{'hostname'} = &get_system_hostname();\n$hash{'webmin_config'} = $config_directory;\n$hash{'webmin_etc'} = $config_directory;\n$hash{'module_config'} = &get_module_variable('$module_config_directory');\n$hash{'webmin_var'} = $var_directory;\n\n# Add time-based parameters, for use in DNS\n$hash{'current_time'} = time();\nmy @tm = localtime($hash{'current_time'});\n$hash{'current_year'} = $tm[5]+1900;\n$hash{'current_month'} = sprintf(\"%2.2d\", $tm[4]+1);\n$hash{'current_day'} = sprintf(\"%2.2d\", $tm[3]);\n$hash{'current_hour'} = sprintf(\"%2.2d\", $tm[2]);\n$hash{'current_minute'} = sprintf(\"%2.2d\", $tm[1]);\n$hash{'current_second'} = sprintf(\"%2.2d\", $tm[0]);\n\n# Actually do the substition\nmy $rv = $_[0];\nforeach my $s (keys %hash) {\n\tnext if ($s eq '');\t# Prevent just $ from being subbed\n\tmy $us = uc($s);\n\tmy $sv = $hash{$s};\n\tmy $qsv = quotemeta($sv);\n\t$rv =~ s/\\$\\{\\Q$us\\E\\}/$sv/g;\n\t$rv =~ s/\\$\\Q$us\\E/$sv/g;\n\t$rv =~ s/\\$\\{\\\\\\Q$us\\E\\}/$qsv/g;\n\tif ($sv) {\n\t\t# Replace ${IF}..${ELSE}..${ENDIF} block with first value,\n\t\t# and ${IF}..${ENDIF} with value\n\t\t$rv =~ s/\\$\\{IF-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ELSE-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIF-\\Q$us\\E\\}(\\n?)/$2/g;\n\t\t$rv =~ s/\\$\\{IF-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIF-\\Q$us\\E\\}(\\n?)/$2/g;\n\n\t\t# Replace $IF..$ELSE..$ENDIF block with first value,\n\t\t# and $IF..$ENDIF with value\n\t\t$rv =~ s/\\$IF-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ELSE-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ENDIF-\\Q$us\\E(\\n?)/$2/g;\n\t\t$rv =~ s/\\$IF-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ENDIF-\\Q$us\\E(\\n?)/$2/g;\n\n\t\t# Replace ${IFEQ}..${ENDIFEQ} block with first value if\n\t\t# matching, nothing if not\n\t\t$rv =~ s/\\$\\{IFEQ-\\Q$us\\E-\\Q$sv\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIFEQ-\\Q$us\\E-\\Q$sv\\E\\}(\\n?)/$2/g;\n\t\t$rv =~ s/\\$\\{IFEQ-\\Q$us\\E-[^\\}]+}(\\n?)([\\000-\\377]*?)\\$\\{ENDIFEQ-\\Q$us\\E-[^\\}]+\\}(\\n?)//g;\n\n\t\t# Replace $IFEQ..$ENDIFEQ block with first value if\n\t\t# matching, nothing if not\n\t\t$rv =~ s/\\$IFEQ-\\Q$us\\E-\\Q$sv\\E(\\n?)([\\000-\\377]*?)\\$ENDIFEQ-\\Q$us\\E-\\Q$sv\\E(\\n?)/$2/g;\n\t\t$rv =~ s/\\$IFEQ-\\Q$us\\E-\\S+(\\n?)([\\000-\\377]*?)\\$ENDIFEQ-\\Q$us\\E-\\S+(\\n?)//g;\n\t\t}\n\telse {\n\t\t# Replace ${IF}..${ELSE}..${ENDIF} block with second value,\n\t\t# and ${IF}..${ENDIF} with nothing\n\t\t$rv =~ s/\\$\\{IF-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ELSE-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIF-\\Q$us\\E\\}(\\n?)/$4/g;\n\t\t$rv =~ s/\\$\\{IF-\\Q$us\\E\\}(\\n?)([\\000-\\377]*?)\\$\\{ENDIF-\\Q$us\\E\\}(\\n?)//g;\n\n\t\t# Replace $IF..$ELSE..$ENDIF block with second value,\n\t\t# and $IF..$ENDIF with nothing\n\t\t$rv =~ s/\\$IF-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ELSE-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ENDIF-\\Q$us\\E(\\n?)/$4/g;\n\t\t$rv =~ s/\\$IF-\\Q$us\\E(\\n?)([\\000-\\377]*?)\\$ENDIF-\\Q$us\\E(\\n?)//g;\n\n\t\t# Replace ${IFEQ}..${ENDIFEQ} block with nothing\n\t\t$rv =~ s/\\$\\{IFEQ-\\Q$us\\E-[^\\}]+}(\\n?)([\\000-\\377]*?)\\$\\{ENDIFEQ-\\Q$us\\E-[^\\}]+\\}(\\n?)//g;\n\t\t$rv =~ s/\\$IFEQ-\\Q$us\\E-\\S+(\\n?)([\\000-\\377]*?)\\$ENDIFEQ-\\Q$us\\E-\\S+(\\n?)//g;\n\t\t}\n\t}\n\n# Now assume any $IF blocks whose variables are not present in the hash\n# evaluate to false.\n# $IF...$ELSE x $ENDIF => x\n$rv =~ s/\\$\\{IF\\-([A-Z]+)\\}.*?\\$\\{ELSE\\-\\1\\}(.*?)\\$\\{ENDIF\\-\\1\\}/$2/gs;\n# $IF...x...$ENDIF => (nothing)\n$rv =~ s/\\$\\{IF\\-([A-Z]+)\\}.*?\\$\\{ENDIF\\-\\1\\}//gs;\n# ${var} => (nothing)\n$rv =~ s/\\$\\{[A-Z]+\\}//g;\n\nreturn $rv;\n}\n\n=head2 running_in_zone\n\nReturns 1 if the current Webmin instance is running in a Solaris zone. Used to\ndisable module and features that are not appropriate, like those that modify\nmounted filesystems.\n\n=cut\nsub running_in_zone\n{\nreturn 0 if ($gconfig{'os_type'} ne 'solaris' ||\n\t     $gconfig{'os_version'} < 10);\nmy $zn = `zonename 2>$null_file`;\nchop($zn);\nreturn $zn && $zn ne \"global\";\n}\n\n=head2 running_in_vserver\n\nReturns 1 if the current Webmin instance is running in a Linux VServer.\nUsed to disable modules and features that are not appropriate.\n\n=cut\nsub running_in_vserver\n{\nreturn 0 if ($gconfig{'os_type'} !~ /^\\*-linux$/);\nmy $vserver;\nlocal $_;\nopen(MTAB, \"/etc/mtab\");\nwhile(<MTAB>) {\n\tmy ($dev, $mp) = split(/\\s+/, $_);\n\tif ($mp eq \"/\" && $dev =~ /^\\/dev\\/hdv/) {\n\t\t$vserver = 1;\n\t\tlast;\n\t\t}\n\t}\nclose(MTAB);\nreturn $vserver;\n}\n\n=head2 running_in_xen\n\nReturns 1 if Webmin is running inside a Xen instance, by looking\nat /proc/xen/capabilities.\n\n=cut\nsub running_in_xen\n{\nreturn 0 if (!-r \"/proc/xen/capabilities\");\nmy $cap = &read_file_contents(\"/proc/xen/capabilities\");\nreturn $cap =~ /control_d/ ? 0 : 1;\n}\n\n=head2 running_in_openvz\n\nReturns 1 if Webmin is running inside an OpenVZ container, by looking\nat /proc/vz/veinfo for a non-zero line.\n\n=cut\nsub running_in_openvz\n{\nreturn 0 if (!-r \"/proc/vz/veinfo\");\nmy $lref = &read_file_lines(\"/proc/vz/veinfo\", 1);\nreturn 0 if (!$lref || !@$lref);\nforeach my $l (@$lref) {\n\t$l =~ s/^\\s+//;\n\tmy @ll = split(/\\s+/, $l);\n\treturn 0 if ($ll[0] eq '0');\n\t}\nreturn 1;\n}\n\n=head2 list_categories(&modules, [include-empty])\n\nReturns a hash mapping category codes to names, including any custom-defined\ncategories. The modules parameter must be an array ref of module hash objects,\nas returned by get_all_module_infos.\n\n=cut\nsub list_categories\n{\nmy ($mods, $empty) = @_;\nmy (%cats, %catnames);\n&read_file(\"$config_directory/webmin.catnames\", \\%catnames);\nforeach my $o (@lang_order_list) {\n\t&read_file(\"$config_directory/webmin.catnames.$o\", \\%catnames);\n\t}\n$catnames{''} ||= $catnames{'other'};\nif ($empty) {\n\t%cats = %catnames;\n\t}\nforeach my $m (@$mods) {\n\tmy $c = $m->{'category'};\n\tnext if ($cats{$c});\n\tif (defined($catnames{$c})) {\n\t\t$cats{$c} = $catnames{$c};\n\t\t}\n\telsif ($text{\"category_$c\"}) {\n\t\t$cats{$c} = $text{\"category_$c\"};\n\t\t}\n\telse {\n\t\t# try to get category name from module ..\n\t\tmy %mtext = &load_language($m->{'dir'});\n\t\tif ($mtext{\"category_$c\"}) {\n\t\t\t$cats{$c} = $mtext{\"category_$c\"};\n\t\t\t}\n\t\telse {\n\t\t\t$c = $m->{'category'} = \"\";\n\t\t\t$cats{$c} = $text{\"category_$c\"};\n\t\t\t}\n\t\t}\n\t}\nreturn %cats;\n}\n\n=head2 is_readonly_mode\n\nReturns 1 if the current user is in read-only mode, and thus all writes\nto files and command execution should fail.\n\n=cut\nsub is_readonly_mode\n{\nif (!defined($main::readonly_mode_cache)) {\n\tmy %gaccess = &get_module_acl(undef, \"\");\n\t$main::readonly_mode_cache = $gaccess{'readonly'} ? 1 : 0;\n\t}\nreturn $main::readonly_mode_cache;\n}\n\n=head2 command_as_user(user, with-env?, command, ...)\n\nReturns a command to execute some command as the given user, using the\nsu statement. If on Linux, the /bin/sh shell is forced in case the user\ndoes not have a valid shell. If with-env is set to 1, the - flag is added\nto the su command to read the user's .profile or .bashrc file. If with-env is\nset to 2, the user's shell is always used regardless. If set to 3, the user's\nshell is used AND the - flag is set.\n\n=cut\nsub command_as_user\n{\nmy ($user, $env, @args) = @_;\nmy @uinfo = getpwnam($user);\nif ($uinfo[8] ne \"/bin/sh\" && $uinfo[8] !~ /\\/bash$/ && $env < 2) {\n\t# User shell doesn't appear to be valid\n\tif ($gconfig{'os_type'} =~ /-linux$/) {\n\t\t# Use -s /bin/sh to force it\n\t\t$shellarg = \" -s /bin/sh\";\n\t\t}\n\telsif ($gconfig{'os_type'} eq 'freebsd' ||\n\t       $gconfig{'os_type'} eq 'solaris' &&\n\t\t$gconfig{'os_version'} >= 11 ||\n\t       $gconfig{'os_type'} eq 'macos') {\n\t\t# Use -m and force /bin/sh\n\t\t@args = ( \"/bin/sh\", \"-c\", quotemeta(join(\" \", @args)) );\n\t\t$shellarg = \" -m\";\n\t\t}\n\t}\nmy $rv = \"su\".($env == 1 || $env == 3 ? \" -\" : \"\").$shellarg.\n\t \" \".quotemeta($user).\" -c \".quotemeta(join(\" \", @args));\nreturn $rv;\n}\n\n=head2 list_osdn_mirrors(project, file)\n\nThis function is now deprecated in favor of letting sourceforge just\nredirect to the best mirror, and now just returns their primary download URL.\n\n=cut\nsub list_osdn_mirrors\n{\nmy ($project, $file) = @_;\nreturn ( { 'url' => \"http://downloads.sourceforge.net/$project/$file\",\n\t   'default' => 0,\n\t   'mirror' => 'downloads' } );\n}\n\n=head2 convert_osdn_url(url)\n\nGiven a URL like http://osdn.dl.sourceforge.net/sourceforge/project/file.zip\nor http://prdownloads.sourceforge.net/project/file.zip , convert it\nto a real URL on the sourceforge download redirector.\n\n=cut\nsub convert_osdn_url\n{\nmy ($url) = @_;\nif ($url =~ /^http:\\/\\/[^\\.]+.dl.sourceforge.net\\/sourceforge\\/([^\\/]+)\\/(.*)$/ ||\n    $url =~ /^http:\\/\\/prdownloads.sourceforge.net\\/([^\\/]+)\\/(.*)$/) {\n\t# Always use the Sourceforge mail download URL, which does\n\t# a location-based redirect for us\n\tmy ($project, $file) = ($1, $2);\n\t$url = \"http://prdownloads.sourceforge.net/sourceforge/\".\n\t       \"$project/$file\";\n\treturn wantarray ? ( $url, 0 ) : $url;\n\t}\nelse {\n\t# Some other source .. don't change\n\treturn wantarray ? ( $url, 2 ) : $url;\n\t}\n}\n\n=head2 get_current_dir\n\nReturns the directory the current process is running in.\n\n=cut\nsub get_current_dir\n{\nmy $out;\nif ($gconfig{'os_type'} eq 'windows') {\n\t# Use cd command\n\t$out = `cd`;\n\t}\nelse {\n\t# Use pwd command\n\t$out = `pwd`;\n\t$out =~ s/\\\\/\\//g;\n\t}\n$out =~ s/\\r|\\n//g;\nreturn $out;\n}\n\n=head2 supports_users\n\nReturns 1 if the current OS supports Unix user concepts and functions like\nsu , getpw* and so on. This will be true on Linux and other Unixes, but false\non Windows.\n\n=cut\nsub supports_users\n{\nreturn $gconfig{'os_type'} ne 'windows';\n}\n\n=head2 supports_symlinks\n\nReturns 1 if the current OS supports symbolic and hard links. This will not\nbe the case on Windows.\n\n=cut\nsub supports_symlinks\n{\nreturn $gconfig{'os_type'} ne 'windows';\n}\n\n=head2 quote_path(path)\n\nReturns a path with safe quoting for the current operating system.\n\n=cut\nsub quote_path\n{\nmy ($path) = @_;\nif ($gconfig{'os_type'} eq 'windows' || $path =~ /^[a-z]:/i) {\n\t# Windows only supports \"\" style quoting\n\treturn \"\\\"$path\\\"\";\n\t}\nelse {\n\treturn quotemeta($path);\n\t}\n}\n\n=head2 get_windows_root\n\nReturns the base windows system directory, like c:/windows.\n\n=cut\nsub get_windows_root\n{\nif ($ENV{'SystemRoot'}) {\n\tmy $rv = $ENV{'SystemRoot'};\n\t$rv =~ s/\\\\/\\//g;\n\treturn $rv;\n\t}\nelse {\n\treturn -d \"c:/windows\" ? \"c:/windows\" : \"c:/winnt\";\n\t}\n}\n\n=head2 read_file_contents(file)\n\nGiven a filename, returns its complete contents as a string. Effectively\nthe same as the Perl construct `cat file`.\n\n=cut\nsub read_file_contents\n{\nmy ($file) = @_;\n&open_readfile(FILE, $file) || return undef;\nlocal $/ = undef;\nmy $rv = <FILE>;\nclose(FILE);\nreturn $rv;\n}\n\n=head2 write_file_contents(file, data)\n\nWrites some data to the given file\n\n=cut\nsub write_file_contents\n{\nmy ($file, $data) = @_;\n&open_tempfile(FILE, \">$file\");\n&print_tempfile(FILE, $data);\n&close_tempfile(FILE);\n}\n\n=head2 unix_crypt(password, salt)\n\nPerforms Unix encryption on a password, using the built-in crypt function or\nthe Crypt::UnixCrypt module if the former does not work. The salt parameter\nmust be either an already-hashed password, or a two-character alpha-numeric\nstring.\n\n=cut\nsub unix_crypt\n{\nmy ($pass, $salt) = @_;\nreturn \"\" if ($salt !~ /^[a-zA-Z0-9\\.\\/]{2}/);   # same as real crypt\nmy $rv = eval \"crypt(\\$pass, \\$salt)\";\nmy $err = $@;\nreturn $rv if ($rv && !$@);\neval \"use Crypt::UnixCrypt\";\nif (!$@) {\n\treturn Crypt::UnixCrypt::crypt($pass, $salt);\n\t}\nelse {\n\t&error(\"Failed to encrypt password : $err\");\n\t}\n}\n\n=head2 split_quoted_string(string)\n\nGiven a string like I<foo \"bar baz\" quux>, returns the array :\nfoo, bar baz, quux\n\n=cut\nsub split_quoted_string\n{\nmy ($str) = @_;\nmy @rv;\nwhile($str =~ /^\"([^\"]*)\"\\s*([\\000-\\377]*)$/ ||\n      $str =~ /^'([^']*)'\\s*([\\000-\\377]*)$/ ||\n      $str =~ /^(\\S+)\\s*([\\000-\\377]*)$/) {\n\tpush(@rv, $1);\n\t$str = $2;\n\t}\nreturn @rv;\n}\n\n=head2 write_to_http_cache(url, file|&data)\n\nUpdates the Webmin cache with the contents of the given file, possibly also\nclearing out old data. Mainly for internal use by http_download.\n\n=cut\nsub write_to_http_cache\n{\nmy ($url, $file) = @_;\nreturn 0 if (!$gconfig{'cache_size'});\n\n# Don't cache downloads that look dynamic\nif ($url =~ /cgi-bin/ || $url =~ /\\?/) {\n\treturn 0;\n\t}\n\n# Check if the current module should do caching\nif ($gconfig{'cache_mods'} =~ /^\\!(.*)$/) {\n\t# Caching all except some modules\n\tmy @mods = split(/\\s+/, $1);\n\treturn 0 if (&indexof(&get_module_name(), @mods) != -1);\n\t}\nelsif ($gconfig{'cache_mods'}) {\n\t# Only caching some modules\n\tmy @mods = split(/\\s+/, $gconfig{'cache_mods'});\n\treturn 0 if (&indexof(&get_module_name(), @mods) == -1);\n\t}\n\n# Work out the size\nmy $size;\nif (ref($file)) {\n\t$size = length($$file);\n\t}\nelse {\n\tmy @st = stat($file);\n\t$size = $st[7];\n\t}\n\nif ($size > $gconfig{'cache_size'}) {\n\t# Bigger than the whole cache - so don't save it\n\treturn 0;\n\t}\nmy $cfile = $url;\n$cfile =~ s/\\//_/g;\n$cfile = \"$main::http_cache_directory/$cfile\";\n\n# See how much we have cached currently, clearing old files\nmy $total = 0;\nmkdir($main::http_cache_directory, 0700) if (!-d $main::http_cache_directory);\nopendir(CACHEDIR, $main::http_cache_directory);\nforeach my $f (readdir(CACHEDIR)) {\n\tnext if ($f eq \".\" || $f eq \"..\");\n\tmy $path = \"$main::http_cache_directory/$f\";\n\tmy @st = stat($path);\n\tif ($gconfig{'cache_days'} &&\n\t    time()-$st[9] > $gconfig{'cache_days'}*24*60*60) {\n\t\t# This file is too old .. trash it\n\t\tunlink($path);\n\t\t}\n\telse {\n\t\t$total += $st[7];\n\t\tpush(@cached, [ $path, $st[7], $st[9] ]);\n\t\t}\n\t}\nclosedir(CACHEDIR);\n@cached = sort { $a->[2] <=> $b->[2] } @cached;\nwhile($total+$size > $gconfig{'cache_size'} && @cached) {\n\t# Cache is too big .. delete some files until the new one will fit\n\tunlink($cached[0]->[0]);\n\t$total -= $cached[0]->[1];\n\tshift(@cached);\n\t}\n\n# Finally, write out the new file\nif (ref($file)) {\n\t&open_tempfile(CACHEFILE, \">$cfile\");\n\t&print_tempfile(CACHEFILE, $$file);\n\t&close_tempfile(CACHEFILE);\n\t}\nelse {\n\tmy ($ok, $err) = &copy_source_dest($file, $cfile);\n\t}\n\nreturn 1;\n}\n\n=head2 check_in_http_cache(url)\n\nIf some URL is in the cache and valid, return the filename for it. Mainly\nfor internal use by http_download.\n\n=cut\nsub check_in_http_cache\n{\nmy ($url) = @_;\nreturn undef if (!$gconfig{'cache_size'});\n\n# Check if the current module should do caching\nif ($gconfig{'cache_mods'} =~ /^\\!(.*)$/) {\n\t# Caching all except some modules\n\tmy @mods = split(/\\s+/, $1);\n\treturn 0 if (&indexof(&get_module_name(), @mods) != -1);\n\t}\nelsif ($gconfig{'cache_mods'}) {\n\t# Only caching some modules\n\tmy @mods = split(/\\s+/, $gconfig{'cache_mods'});\n\treturn 0 if (&indexof(&get_module_name(), @mods) == -1);\n\t}\n\nmy $cfile = $url;\n$cfile =~ s/\\//_/g;\n$cfile = \"$main::http_cache_directory/$cfile\";\nmy @st = stat($cfile);\nreturn undef if (!@st || !$st[7]);\nif ($gconfig{'cache_days'} && time()-$st[9] > $gconfig{'cache_days'}*24*60*60) {\n\t# Too old!\n\tunlink($cfile);\n\treturn undef;\n\t}\nopen(TOUCH, \">>$cfile\");\t# Update the file time, to keep it in the cache\nclose(TOUCH);\nreturn $cfile;\n}\n\n=head2 supports_javascript\n\nReturns 1 if the current browser is assumed to support javascript.\n\n=cut\nsub supports_javascript\n{\nif (defined(&theme_supports_javascript)) {\n\treturn &theme_supports_javascript();\n\t}\nreturn $ENV{'MOBILE_DEVICE'} ? 0 : 1;\n}\n\n=head2 get_module_name\n\nReturns the name of the Webmin module that called this function. For internal\nuse only by other API functions.\n\n=cut\nsub get_module_name\n{\nreturn &get_module_variable('$module_name');\n}\n\n=head2 get_module_variable(name, [ref])\n\nReturns the value of some variable which is set in the caller's context, if\nusing the new WebminCore package. For internal use only.\n\n=cut\nsub get_module_variable\n{\nmy ($v, $wantref) = @_;\nmy $slash = $wantref ? \"\\\\\" : \"\";\nmy $thispkg = &web_libs_package();\nif ($thispkg eq 'WebminCore') {\n\tmy ($vt, $vn) = split('', $v, 2);\n\tmy $callpkg;\n\tfor(my $i=0; ($callpkg) = caller($i); $i++) {\n\t\tlast if ($callpkg ne $thispkg);\n\t\t}\n\treturn eval \"${slash}${vt}${callpkg}::${vn}\";\n\t}\nreturn eval \"${slash}${v}\";\n}\n\n=head2 clear_time_locale()\n\nTemporarily force the locale to C, until reset_time_locale is called. This is\nuseful if your code is going to call C<strftime> from the POSIX package, and\nyou want to ensure that the output is in a consistent format.\n\n=cut\nsub clear_time_locale\n{\nif ($main::clear_time_locale_count == 0) {\n\teval {\n\t\t$main::clear_time_locale_old = POSIX::setlocale(POSIX::LC_TIME);\n\t\tPOSIX::setlocale(POSIX::LC_TIME, \"C\");\n\t\t};\n\t}\n$main::clear_time_locale_count++;\n}\n\n=head2 reset_time_locale()\n\nRevert the locale to whatever it was before clear_time_locale was called\n\n=cut\nsub reset_time_locale\n{\nif ($main::clear_time_locale_count == 1) {\n\teval {\n\t\tPOSIX::setlocale(POSIX::LC_TIME, $main::clear_time_locale_old);\n\t\t$main::clear_time_locale_old = undef;\n\t\t};\n\t}\n$main::clear_time_locale_count--;\n}\n\n=head2 callers_package(filehandle)\n\nConvert a non-module filehandle like FOO to one qualified with the\ncaller's caller's package, like fsdump::FOO. For internal use only.\n\n=cut\nsub callers_package\n{\nmy ($fh) = @_;\nmy $callpkg = (caller(1))[0];\nmy $thispkg = &web_libs_package();\nif (!ref($fh) && $fh !~ /::/ &&\n    $callpkg ne $thispkg && $thispkg eq 'WebminCore') {\n        $fh = $callpkg.\"::\".$fh;\n        }\nreturn $fh;\n}\n\n=head2 web_libs_package()\n\nReturns the package this code is in. We can't always trust __PACKAGE__. For\ninternal use only.\n\n=cut\nsub web_libs_package\n{\nif ($called_from_webmin_core) {\n\treturn \"WebminCore\";\n\t}\nreturn __PACKAGE__;\n}\n\n=head2 get_userdb_string\n\nReturns the URL-style string for connecting to the users and groups database\n\n=cut\nsub get_userdb_string\n{\nreturn undef if ($main::no_miniserv_userdb);\nmy %miniserv;\n&get_miniserv_config(\\%miniserv);\nreturn $miniserv{'userdb'};\n}\n\n=head2 connect_userdb(string)\n\nReturns a handle for talking to a user database - may be a DBI or LDAP handle.\nOn failure returns an error message string. In an array context, returns the\nprotocol type too.\n\n=cut\nsub connect_userdb\n{\nmy ($str) = @_;\nmy ($proto, $user, $pass, $host, $prefix, $args) = &split_userdb_string($str);\nif ($proto eq \"mysql\") {\n\t# Connect to MySQL with DBI\n\tmy $drh = eval \"use DBI; DBI->install_driver('mysql');\";\n\t$drh || return $text{'sql_emysqldriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $cstr = \"database=$prefix;host=$host\";\n\t$cstr .= \";port=$port\" if ($port);\n\tmy $dbh = $drh->connect($cstr, $user, $pass, { });\n\t$dbh || return &text('sql_emysqlconnect', $drh->errstr);\n\treturn wantarray ? ($dbh, $proto, $prefix, $args) : $dbh;\n\t}\nelsif ($proto eq \"postgresql\") {\n\t# Connect to PostgreSQL with DBI\n\tmy $drh = eval \"use DBI; DBI->install_driver('Pg');\";\n\t$drh || return $text{'sql_epostgresqldriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $cstr = \"dbname=$prefix;host=$host\";\n\t$cstr .= \";port=$port\" if ($port);\n\tmy $dbh = $drh->connect($cstr, $user, $pass);\n\t$dbh || return &text('sql_epostgresqlconnect', $drh->errstr);\n\treturn wantarray ? ($dbh, $proto, $prefix, $args) : $dbh;\n\t}\nelsif ($proto eq \"ldap\") {\n\t# Connect with perl LDAP module\n\teval \"use Net::LDAP\";\n\t$@ && return $text{'sql_eldapdriver'};\n\tmy ($host, $port) = split(/:/, $host);\n\tmy $scheme = $args->{'scheme'} || 'ldap';\n\tif (!$port) {\n\t\t$port = $scheme eq 'ldaps' ? 636 : 389;\n\t\t}\n\tmy $ldap = Net::LDAP->new($host,\n\t\t\t\t  port => $port,\n\t\t\t\t  'scheme' => $scheme);\n\t$ldap || return &text('sql_eldapconnect', $host);\n\tmy $mesg;\n\tif ($args->{'tls'}) {\n\t\t# Switch to TLS mode\n\t\tif ($args->{'tls'} eq \"1_1\" or $args->{'tls'} eq \"1_2\") {\n\t\t\teval { $mesg = $ldap->start_tls(\n\t\t\t\t\tsslversion => \"TLSv\".$args->{'tls'}) };\n\t\t\t}\n\t\telse {\n\t\t\teval { $mesg = $ldap->start_tls(); };\n\t\t\t}\n\t\tif ($@ || !$mesg || $mesg->code) {\n\t\t\treturn &text('sql_eldaptls',\n\t\t\t    $@ ? $@ : $mesg ? $mesg->error : \"Unknown error\");\n\t\t\t}\n\t\t}\n\t# Login to the server\n\tif ($pass) {\n\t\t$mesg = $ldap->bind(dn => $user, password => $pass);\n\t\t}\n\telse {\n\t\t$mesg = $ldap->bind(dn => $user, anonymous => 1);\n\t\t}\n\tif (!$mesg || $mesg->code) {\n\t\treturn &text('sql_eldaplogin', $user,\n\t\t\t     $mesg ? $mesg->error : \"Unknown error\");\n\t\t}\n\treturn wantarray ? ($ldap, $proto, $prefix, $args) : $ldap;\n\t}\nelse {\n\treturn \"Unknown protocol $proto\";\n\t}\n}\n\n=head2 disconnect_userdb(string, &handle)\n\nCloses a handle opened by connect_userdb\n\n=cut\nsub disconnect_userdb\n{\nmy ($str, $h) = @_;\nif ($str =~ /^(mysql|postgresql):/) {\n\t# DBI disconnnect\n\tif (!$h->{'AutoCommit'}) {\n\t\t$h->commit();\n\t\t}\n\t$h->disconnect();\n\t}\nelsif ($str =~ /^ldap:/) {\n\t# LDAP disconnect\n\t$h->unbind();\n\t$h->disconnect();\n\t}\n}\n\n=head2 split_userdb_string(string)\n\nConverts a string like mysql://user:pass@host/db into separate parts\n\n=cut\nsub split_userdb_string\n{\nmy ($str) = @_;\nif ($str =~ /^([a-z]+):\\/\\/([^:]*):([^\\@]*)\\@([a-z0-9\\.\\-\\_]+)\\/([^\\?]+)(\\?(.*))?$/) {\n\tmy ($proto, $user, $pass, $host, $prefix, $argstr) =\n\t\t($1, $2, $3, $4, $5, $7);\n\tmy %args = map { split(/=/, $_, 2) } split(/\\&/, $argstr);\n\treturn ($proto, $user, $pass, $host, $prefix, \\%args);\n\t}\nreturn ( );\n}\n\n=head2 uniquelc(string, ...)\n\nReturns the unique elements of some array using a lowercase comparison,\npassed as its parameters.\n\n=cut\nsub uniquelc\n{\nmy (%found, @rv);\nforeach my $e (@_) {\n\tif (!$found{lc($e)}++) { push(@rv, $e); }\n\t}\nreturn @rv;\n}\n\n=head2 list_combined_webmin_menu(&data, &in)\n\nReturns an array of objects, each representing a menu item that a theme should\nrender such as on a left menu. Each object is a hash ref with the following\npossible keys :\n\n=item module - The Webmin module that supplied this object\n\n=item id - A unique ID for the object\n\n=item type - Can be \"item\" for a regular menu item, \"cat\" for a category which\n             will have sub-items (members), \"html\" for an arbitrary HTML block,\n\t     \"text\" for a line of text, \"hr\" for a separator, \"menu\" for a\n\t     selector, \"input\" for a text box, or \"title\" for a desired menu\n\t     title.\n\n=item desc - The text that should be displayed for the object\n\n=item icon - Desired icon path, like /module/images/foo.gif\n\n=item link - URL that the object should link to, for \"item\" types\n\n=item members - Array ref of further objects, for the \"cat\" type\n\n=item open - Set to 1 if the category should be open by default, for \"cat\" types\n\n=item html - HTML to display for this object, for \"html\" types\n\n=item menu - Array ref of array refs, each containing a the value and displayed\n\t     text for a entry in the selector when using \"menu\" types\n\n=item name - For an \"input\" item or \"menu\" item, the name of the selector or\n\t     HTML text box\n\n=item size - For an \"item\" item, desired width of the text box\n\n=item cgi - CGI script that the \"menu\" or \"input\" type item should submit to.\n\t    If missing, the form submits to the same menu page.\n\n=item target - Can be \"new\" for a new page, or \"window\" for the current whole\n\t       browser window\n\nThe &data parameter is a hash ref of additional information that the theme\nsupplies to all modules. The &in param is the CGI inputs from the menu, for\nuse where the menu has a form that submits to itself.\n\n=cut\nsub list_combined_webmin_menu\n{\nmy ($data, $in) = @_;\nforeach my $m (&get_available_module_infos()) {\n\tmy $dir = &module_root_directory($m->{'dir'});\n\tmy $mfile = \"$dir/webmin_menu.pl\";\n\tnext if (!-r $mfile);\n\teval {\n\t\tlocal $main::error_must_die = 1;\n\t\t&foreign_require($m->{'dir'}, \"webmin_menu.pl\");\n\t\tforeach my $i (&foreign_call($m->{'dir'}, \"list_webmin_menu\",\n\t\t\t\t\t     $data, $in)) {\n\t\t\t$i->{'module'} = $m->{'dir'};\n\t\t\tpush(@rv, $i);\n\t\t\t}\n\t\t};\n\t}\nreturn sort { ($b->{'priority'} || 0) <=> ($a->{'priority'} || 0) } @rv;\n}\n\n=head2 list_modules_webmin_menu()\n\nThis function returns a menu of Webmin modules available to the current user\nand with their desired categorization method, but in the same format as\nlist_combined_webmin_menu for easier use by theme authors.\n\n=cut\nsub list_modules_webmin_menu\n{\nmy @rv;\nmy @cats = get_visible_modules_categories();\nmy @catnames = map { $_->{'code'} } @cats;\nif ($gconfig{\"notabs_${base_remote_user}\"} == 2 ||\n    $gconfig{\"notabs_${base_remote_user}\"} == 0 && $gconfig{'notabs'}) {\n\t# Show modules in one list\n\t@rv = map { module_to_menu_item($_) }\n\t\t  (map { @{$_->{'modules'}} } @cats);\n\t}\nelse {\n\t# Show all modules under categories\n\tforeach my $c (@cats) {\n\t\tmy $citem = { 'type' => 'cat',\n\t\t\t      'id' => $c->{'code'},\n\t\t\t      'desc' => $c->{'desc'},\n\t\t\t      'members' => [ ] };\n\t\tforeach my $minfo (@{$c->{'modules'}}) {\n\t\t\tpush(@{$citem->{'members'}},\n\t\t\t     module_to_menu_item($minfo));\n\t\t\t}\n\t\tpush(@rv, $citem);\n\t\t}\n\t}\nreturn @rv;\n}\n\n=head2 module_to_menu_item(&module)\n\nInternal function for use by list_modules_webmin_menu\n\n=cut\nsub module_to_menu_item\n{\nmy ($minfo) = @_;\nreturn { 'type' => 'item',\n         'id' => $minfo->{'dir'},\n         'desc' => $minfo->{'desc'},\n         'link' => '/'.$minfo->{'dir'}.'/' };\n}\n\n=head2 list_combined_system_info(&data, &in)\n\nReturns an array of objects, each representing a block of system information\nto display. Each is a hash ref with the following keys :\n\n=item module - The Webmin module that supplied this object\n\n=item id - A unique ID for the object\n\n=item type - Can be \"html\" for an arbitrary block of HTML, \"table\" for a table\n\t     of information, \"usage\" for a table of usage of some resource,\n\t     \"redirect\" for a request to redirect the whole page to another URL,\n\t     \"warning\" for a warning dialog, \"link\" for a link to another\n\t     page, or \"veto\" to request removal of a block from another module.\n\n=item desc - The title for this section of info\n\n=item open - Set to 1 if it should be displayed by default\n\n=item table - In \"table\" mode, an array ref of fields to show. Each is a hash\n              ref with keys described below.\n\n=item html - In \"html\" mode, the raw HTML to display\n\n=item usage - In \"usage\" mode, an array ref of things to show some kind of\n\t      usage for. Each is a hash ref with keys described below.\n\n=item titles - In \"usage\" mode, an 3-element array ref of titles to show above\n\t       the usage columns.\n\n=item url - In \"redirect\" mode, the URL to redirect the system info page to\n\n=item warning - In \"warning\" mode, the HTML warning message\n\n=item level - In \"warning\" mode, can be one of \"success\", \"info\", \"warn\" or\n\t      \"danger\"\n\n=item link - In \"link\" mode, the destination URL\n\n=item veto - In \"veto\" mode, the ID of the block from some other module to skip\n\n=item target - In \"link\" mode, can be \"new\" for a new page, or \"window\" for the\n\t       current whole browser window\n\nFor \"table\" mode, the keys in each hash ref are :\n\n=item desc - Label for this item\n\n=item value - HTML to display next to the item\n\n=item chart - Array ref for a bar chart to show, in which the first element is\n\t      the total size, and each subsequent element is a value to show in\n\t      a different color. Any leftover is assumed is filled in with the\n\t      final color.\n\n=item wide - Set to 1 if this item should span a whole row\n\n=item header - Text to show above the table\n\nFor \"usage\" mode, the keys in each hash ref are :\n\n=item desc - Name of the thing for which usage is shown, like a domain\n\n=item chart - Bar chart (as above) with usage\n\n=item value - HTML for a description of the usage\n\n=item header - Text to show above the usage table\n\nThe &data parameter is a hash ref of additional information that the theme\nsupplies to all modules. The &in param is the CGI inputs from the page, for\nuse where a system info block has a form that submits to itself.\n\n=cut\nsub list_combined_system_info\n{\nmy ($data, $in) = @_;\nforeach my $m (&get_all_module_infos()) {\n\tmy $dir = &module_root_directory($m->{'dir'});\n\tmy $mfile = \"$dir/system_info.pl\";\n\tnext if (!-r $mfile);\n\t&foreign_require($m->{'dir'}, \"system_info.pl\");\n\tforeach my $i (&foreign_call($m->{'dir'}, \"list_system_info\",\n\t\t\t\t     $data, $in)) {\n\t\t$i->{'module'} = $m->{'dir'};\n\t\tpush(@rv, $i);\n\t\t}\n\t}\nif (&foreign_available(\"webmin\")) {\n\t# Merge in old-style notification API\n\t&foreign_require(\"webmin\");\n\tforeach my $n (&webmin::get_webmin_notifications()) {\n\t\tpush(@rv, { 'type' => 'warning',\n\t\t\t    'id' => 'notifications',\n\t\t\t    'level' => 'warn',\n\t\t\t    'module' => 'webmin',\n\t\t\t    'warning' => $n });\n\t\t}\n\t}\n# Obey vetos for blocks from other modules\nmy @vetos = grep { $_->{'type'} eq 'veto' } @rv;\nforeach my $veto (@vetos) {\n\tmy @vrv;\n\tforeach my $m (@rv) {\n\t\tmy $v = $m->{'id'} eq $veto->{'veto'} &&\n\t\t        (!$veto->{'veto_module'} ||\n\t\t         $veto->{'veto_module'} eq $m->{'module'});\n\t\tpush(@vrv, $m) if (!$v);\n\t\t}\n\t@rv = @vrv;\n\t}\n@rv = grep { $_->{'type'} ne 'veto' } @rv;\nreturn sort { ($b->{'priority'} || 0) <=> ($a->{'priority'} || 0) } @rv;\n}\n\n=head2 shell_is_bash\n\nReturns 1 if /bin/sh is bash, 0 if not\n\n=cut\nsub shell_is_bash\n{\nmy $bash = &has_command(\"bash\");\nif ($bash && &same_file(\"/bin/sh\", $bash)) {\n\t# Symlink to /bin/bash\n\treturn 1;\n\t}\nmy $out = &backquote_command(\"/bin/sh --help 2>&1 </dev/null\");\nif ($out =~ /GNU\\s+bash/) {\n\treturn 1;\n\t}\nreturn 0;\n}\n\n=head2 compare_version_numbers(ver1, ver2)\n\nCompares to version \"number\" strings, and returns -1 if ver1 is older than ver2,\n0 if they are equal, or 1 if ver1 is newer than ver2.\n\n=cut\nsub compare_version_numbers\n{\nmy ($ver1, $ver2) = @_;\nmy @sp1 = split(/[\\.\\-\\+\\~]/, $ver1);\nmy @sp2 = split(/[\\.\\-\\+\\~]/, $ver2);\nmy $tmp;\nfor(my $i=0; $i<@sp1 || $i<@sp2; $i++) {\n\tmy $v1 = $sp1[$i];\n\tmy $v2 = $sp2[$i];\n\tmy $comp;\n\tif ($v1 =~ /^\\d+$/ && $v2 =~ /^\\d+$/) {\n\t\t# Numeric only\n\t\t# ie. 5 vs 7\n\t\t$comp = $v1 <=> $v2;\n\t\t}\n\telsif ($v1 =~ /^(\\d+[^0-9]+)(\\d+)$/ && ($tmp = $1) &&\n\t       $v2 =~ /^(\\d+[^0-9]+)(\\d+)$/ &&\n\t       $tmp eq $1) {\n\t\t# Numeric followed by a string followed by a number, where\n\t\t# the first two components are the same\n\t\t# ie. 4ubuntu8 vs 4ubuntu10\n\t\t$v1 =~ /^(\\d+[^0-9]+)(\\d+)$/;\n\t\tmy $num1 = $2;\n\t\t$v2 =~ /^(\\d+[^0-9]+)(\\d+)$/;\n\t\tmy $num2 = $2;\n\t\t$comp = $num1 <=> $num2;\n\t\t}\n\telsif ($v1 =~ /^\\d+\\S*$/ && $v2 =~ /^\\d+\\S*$/) {\n\t\t# Numeric followed by string\n\t\t# ie. 6redhat vs 8redhat\n\t\t$v1 =~ /^(\\d+)(\\S*)$/;\n\t\tmy ($v1n, $v1s) = ($1, $2);\n\t\t$v2 =~ /^(\\d+)(\\S*)$/;\n\t\tmy ($v2n, $v2s) = ($1, $2);\n\t\t$comp = $v1n <=> $v2n;\n\t\tif (!$comp) {\n\t\t\t# X.rcN is always older than X\n\t\t\tif ($v1s =~ /^rc\\d+$/i && $v2s =~ /^\\d*$/) {\n\t\t\t\t$comp = -1;\n\t\t\t\t}\n\t\t\telsif ($v1s =~ /^\\d*$/ && $v2s =~ /^rc\\d+$/i) {\n\t\t\t\t$comp = 1;\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\t$comp = $v1s cmp $v2s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telsif ($v1 =~ /^(\\S+[^0-9]+)(\\d+)$/ && ($tmp = $1) &&\n\t       $v2 =~ /^(\\S+[^0-9]+)(\\d+)$/ &&\n\t       $tmp eq $1) {\n\t\t# String followed by a number, where the strings are the same\n\t\t# ie. centos7 vs centos8\n\t\t$v1 =~ /^(\\S+[^0-9]+)(\\d+)$/;\n\t\tmy $num1 = $2;\n\t\t$v2 =~ /^(\\S+[^0-9]+)(\\d+)$/;\n\t\tmy $num2 = $2;\n\t\t$comp = $num1 <=> $num2;\n\t\t}\n\telsif ($v1 =~ /^\\d+$/ && $v2 !~ /^\\d+$/) {\n\t\t# Numeric compared to non-numeric - numeric is always higher\n\t\t$comp = 1;\n\t\t}\n\telsif ($v1 !~ /^\\d+$/ && $v2 =~ /^\\d+$/) {\n\t\t# Non-numeric compared to numeric - numeric is always higher\n\t\t$comp = -1;\n\t\t}\n\telse {\n\t\t# String compare only\n\t\t$comp = $v1 cmp $v2;\n\t\t}\n\treturn $comp if ($comp);\n\t}\nreturn 0;\n}\n\n=head2 convert_to_json(data)\n\nConverts the given Perl data structure to encoded binary string\n\n=item data parameter is a hash/array reference\n\n=cut\nsub convert_to_json\n{\neval \"use JSON::PP\";\nif (!$@) {\n\tif (@_) {\n\t\treturn JSON::PP->new->latin1->encode(@_);\n\t\t}\n\telse {\n\t\treturn JSON::PP->new->latin1->encode({});\n\t\t}\n\t}\nelse {\n\terror(\"The JSON::PP Perl module is not available on your system : $@\");\n\t}\n}\n\n=head2 convert_from_json(data)\n\nParses given JSON string\n\n=item data parameter is encoded JSON string\n\n=cut\nsub convert_from_json\n{\neval \"use JSON::PP\";\nif (!$@) {\n\tmy ($json_text) = @_;\n\treturn JSON::PP->new->utf8->decode($json_text);\n\t}\nelse {\n\terror(\"The JSON::PP Perl module is not available on your system : $@\");\n\t}\n}\n\n=head2 print_json(data)\n\nPrints JSON data\n\n=item data parameter is a hash/array reference\n\n=cut\nsub print_json\n{\nprint \"Content-type: application/json;\\n\\n\";\nprint convert_to_json(@_);\n}\n\n$done_web_lib_funcs = 1;\n\n1;\n"], "filenames": ["web-lib-funcs.pl"], "buggy_code_start_loc": [7310], "buggy_code_end_loc": [7311], "fixing_code_start_loc": [7310], "fixing_code_end_loc": [7311], "type": "CWE-94", "message": "rpc.cgi in Webmin through 1.920 allows authenticated Remote Code Execution via a crafted object name because unserialise_variable makes an eval call. NOTE: the Webmin_Servers_Index documentation states \"RPC can be used to run any command or modify any file on a server, which is why access to it must not be granted to un-trusted Webmin users.\"", "other": {"cve": {"id": "CVE-2019-15642", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-26T18:15:12.983", "lastModified": "2019-09-04T18:09:32.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "rpc.cgi in Webmin through 1.920 allows authenticated Remote Code Execution via a crafted object name because unserialise_variable makes an eval call. NOTE: the Webmin_Servers_Index documentation states \"RPC can be used to run any command or modify any file on a server, which is why access to it must not be granted to un-trusted Webmin users.\""}, {"lang": "es", "value": "rpc.cgi en Webmin hasta la version 1.920 permite la ejecuci\u00f3n remota de c\u00f3digo autenticada a trav\u00e9s de un nombre de objeto dise\u00f1ado porque unserialise_variable realiza una llamada de evaluaci\u00f3n. NOTA: la documentaci\u00f3n de Webmin_Servers_Index establece que \"RPC se puede usar para ejecutar cualquier comando o modificar cualquier archivo en un servidor, por lo que no se debe otorgar acceso a los usuarios de Webmin que no son de confianza\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.920", "matchCriteriaId": "0662557D-EC4E-4850-BC78-AA3A5B67CAE8"}]}]}], "references": [{"url": "https://doxfer.webmin.com/Webmin/Webmin_Servers_Index", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/webmin/webmin/blob/ab5e00e41ea1ecc1e24b8f8693f3495a0abb1aed/rpc.cgi#L26-L37", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/webmin/webmin/commit/df8a43fb4bdc9c858874f72773bcba597ae9432c", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.calypt.com/blog/index.php/authenticated-rce-on-webmin/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/webmin/webmin/commit/df8a43fb4bdc9c858874f72773bcba597ae9432c"}}