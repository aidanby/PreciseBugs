{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/server/fastcgi/fastcgi-server.h\"\n\n#include \"hphp/runtime/server/http-server.h\"\n\nnamespace HPHP {\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool FastCGIAcceptor::canAccept(const folly::SocketAddress& /*address*/) {\n  // TODO: Support server IP whitelist.\n  auto const cons = m_server->getLibEventConnectionCount();\n  return (RuntimeOption::ServerConnectionLimit == 0 ||\n          cons < RuntimeOption::ServerConnectionLimit);\n}\n\nvoid FastCGIAcceptor::onNewConnection(\n  folly::AsyncTransportWrapper::UniquePtr sock,\n  const folly::SocketAddress* peerAddress,\n  const std::string& /*nextProtocolName*/,\n  SecureTransportType /*secureProtocolType*/,\n  const ::wangle::TransportInfo& /*tinfo*/) {\n  folly::SocketAddress localAddress;\n  try {\n    sock->getLocalAddress(&localAddress);\n  } catch (std::system_error& e) {\n    // If getSockName fails it's bad news; abort the connection\n    return;\n  }\n\n  // Will delete itself when it gets a closing callback\n  auto session = new FastCGISession(\n      m_server->getEventBaseManager()->getExistingEventBase(),\n      m_server->getDispatcher(),\n      std::move(sock),\n      localAddress,\n      *peerAddress\n    );\n\n  // NB: ~ManagedConnection will call removeConnection() before the session\n  //     destroys itself.\n  Acceptor::addConnection(session);\n};\n\nvoid FastCGIAcceptor::onConnectionsDrained() {\n  m_server->onConnectionsDrained();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nFastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    // default to 2 minutes\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}\n\nvoid FastCGIServer::start() {\n  // It's not safe to call this function more than once\n  m_socket.reset(new folly::AsyncServerSocket(m_worker.getEventBase()));\n  try {\n    m_socket->bind(m_socketConfig.bindAddress);\n  } catch (const std::system_error& ex) {\n    Logger::Error(std::string(ex.what()));\n    if (m_socketConfig.bindAddress.getFamily() == AF_UNIX) {\n      throw FailedToListenException(m_socketConfig.bindAddress.getPath());\n    }\n    throw FailedToListenException(m_socketConfig.bindAddress.getAddressStr(),\n                                  m_socketConfig.bindAddress.getPort());\n  }\n  if (m_socketConfig.bindAddress.getFamily() == AF_UNIX) {\n    auto path = m_socketConfig.bindAddress.getPath();\n    chmod(path.c_str(), 0760);\n  }\n  m_acceptor.reset(new FastCGIAcceptor(m_socketConfig, this));\n  m_acceptor->init(m_socket.get(), m_worker.getEventBase());\n  m_worker.getEventBase()->runInEventBaseThread([&] {\n    if (!m_socket) {\n      // Someone called stop before we got here. With the exception of a\n      // second call to start being made this should be safe as any place\n      // we mutate m_socket is done within the event base.\n      return;\n    }\n    m_socket->listen(m_socketConfig.acceptBacklog);\n    m_socket->startAccepting();\n  });\n  setStatus(RunStatus::RUNNING);\n  folly::AsyncTimeout::attachEventBase(m_worker.getEventBase());\n  m_worker.start();\n  m_dispatcher.start();\n}\n\nvoid FastCGIServer::waitForEnd() {\n  // When m_worker stops the server has stopped accepting new requests, there\n  // may be pedning vm jobs. wait() is always safe to call regardless of thread\n  m_worker.wait();\n}\n\nvoid FastCGIServer::stop() {\n  if (getStatus() != RunStatus::RUNNING) return; // nothing to do\n\n  setStatus(RunStatus::STOPPING);\n  HttpServer::MarkShutdownStat(ShutdownEvent::SHUTDOWN_DRAIN_READS);\n\n  m_worker.getEventBase()->runInEventBaseThread([&] {\n    // Shutdown the server socket. Unfortunately, we will drop all unaccepted\n    // connections; there is no way to do a partial shutdown of a server socket\n    m_socket->stopAccepting();\n\n    if (RuntimeOption::ServerGracefulShutdownWait > 0) {\n      // Gracefully drain any incomplete requests. We cannot go offline until\n      // they are finished as we own their dispatcher and event base.\n      if (m_acceptor) {\n        m_acceptor->drainAllConnections();\n      }\n\n      std::chrono::seconds s(RuntimeOption::ServerGracefulShutdownWait);\n      std::chrono::milliseconds m(s);\n      scheduleTimeout(m);\n    } else {\n      // Drop all connections. We cannot shutdown until they stop because we\n      // own their dispatcher and event base.\n      if (m_acceptor) {\n        m_acceptor->forceStop();\n      }\n\n      terminateServer();\n    }\n  });\n}\n\nvoid FastCGIServer::onConnectionsDrained() {\n  // NOTE: called from FastCGIAcceptor::onConnectionsDrained()\n  cancelTimeout();\n  terminateServer();\n}\n\nvoid FastCGIServer::timeoutExpired() noexcept {\n  // Acceptor failed to drain connections on time; drop them so that we can\n  // shutdown.\n  if (m_acceptor) {\n    m_acceptor->forceStop();\n  }\n\n  terminateServer();\n}\n\nvoid FastCGIServer::terminateServer() {\n  if (getStatus() != RunStatus::STOPPING) {\n    setStatus(RunStatus::STOPPING);\n  }\n  // Wait for the server socket thread to stop running\n  m_worker.stopWhenIdle();\n\n  HttpServer::MarkShutdownStat(ShutdownEvent::SHUTDOWN_DRAIN_DISPATCHER);\n  // Wait for VMs to shutdown\n  m_dispatcher.stop();\n\n  setStatus(RunStatus::STOPPED);\n  HttpServer::MarkShutdownStat(ShutdownEvent::SHUTDOWN_DONE);\n\n  // Notify HttpServer that we've shutdown\n  for (auto listener: m_listeners) {\n    listener->serverStopped(this);\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n}\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction test1Controller($hphpdOutput, $hphpdProcessId, $serverPort) {\n  // Request a page so that the client can debug it.\n  waitForClientToOutput($hphpdOutput, \"Waiting for server response\");\n  $url = \"http://\".php_uname('n').':'.$serverPort.'/test1.php';\n  echo \"Requesting test1.php\\n\";\n  request(php_uname('n'), $serverPort, 'test1.php', 10); // ignore response\n\n  // Let client run until script quits\n  waitForClientToOutput($hphpdOutput, \"quit\");\n}\n\nrunTest('test1', \"test1Controller\");\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction BadAuthDigestTestController($serverPort) {\n  $args = array('Authorization' => 'Digest \"username=\"admin\", ' .\n    'realm=\"Restricted area\", nonce=\"564a12f5c065e\", ' .\n    'uri=\"/test_auth_digest.php\", cnonce=\"MjIyMTg2\", nc=00000001, ' .\n    'qop=\"auth\", response=\"6dfbea52fbf13016476c1879e6436004\", ' .\n    'opaque=\"cdce8a5c95a1427d74df7acbf41c9ce0\"');\n  var_dump(request(php_uname('n'), $serverPort, \"test_auth_digest.php\",\n                  [], [], $args));\n}\n\nfunction GoodAuthDigestTestController($serverPort) {\n  $args = array('Authorization' => 'Digest username=\"admin\", ' .\n    'realm=\"Restricted area\", nonce=\"564a12611dae8\", ' .\n    'uri=\"/test_auth_digest.php\", cnonce=\"MjIyMTg1\", nc=00000001, ' .\n    'qop=\"auth\", response=\"e544aaed06917adea3e5c74dd49f0e32\", ' .\n    'opaque=\"cdce8a5c95a1427d74df7acbf41c9ce0\"');\n  var_dump(request(php_uname('n'), $serverPort, \"test_auth_digest.php\",\n                  [], [], $args));\n}\n\nrunTest(\"BadAuthDigestTestController\");\nrunTest(\"GoodAuthDigestTestController\");\n", "<?hh\n\n// Remove this test once we unify the zend ini compat diff (D1797805) with the\n// per dir diff (D2099778)\n\nrequire_once('test_base.inc');\n\nfunction disableIniZendCompatController($port) {\n  echo request(php_uname('n'), $port, 'test_disable_ini_zend_compat.php');\n}\n\necho \"---Enable Ini Zend Compat ON---\\n\";\nrunTest(\"disableIniZendCompatController\",\n        \"-dhhvm.enable_zend_ini_compat=true\");\necho \"\\n---Enable Ini Zend Compat OFF---\\n\";\nrunTest(\"disableIniZendCompatController\",\n        \"-dhhvm.enable_zend_ini_compat=false\");\n", "<?hh\n\nrequire_once(__DIR__ . '/test_base.inc');\n\n$requests = array(\n  array(\n    '-dalways_populate_raw_post_data=1',\n    ['CONTENT_TYPE' => 'multipart/form-data; boundary=dumy']),\n  array('-dalways_populate_raw_post_data=1', []),\n  array('', []),\n  array('-dvariables_order=NONE -drequest_order=', []),\n  array('-dvariables_order=E -drequest_order=GPC', []),\n  array('-dvariables_order=CGP -drequest_order=GP', []),\n  array('-dvariables_order=GC -drequest_order=CG', []),\n  array('-dvariables_order=GC -drequest_order=GC', []),\n  array('-dvariables_order=GC -drequest_order=P', []),\n);\n\nforeach($requests as $request) {\n  echo \"------------ {$request[0]} --------\\n\";\n  runTest(function($port) use($request) {\n    list($options, $extra) = $request;\n    $path = 'global_variables.php?var=GET&get=1';\n    $post = array('var' => 'POST', 'post' => 2);\n    $headers = array('Cookie' => 'var=COOKIE;cookie=3;');\n    echo request(php_uname('n'), $port, $path, $post, $headers, $extra) . \"\\n\";\n  }, $request[0]);\n}\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction headerTestController($serverPort) {\n  $args = array('Authorization' => 'foo');\n  var_dump(request(php_uname('n'), $serverPort, \"test_headers.php\",\n                  [], ['PROXY' => 'foobar'], $args));\n}\n\nrunTest(\"headerTestController\");\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction httpsTestController($serverPort) {\n  $args = array('HTTPS' => '');\n  var_dump(request(php_uname('n'), $serverPort, \"test_https.php\",\n                  [], [], $args));\n}\n\nrunTest(\"httpsTestController\");\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction invalidTestController($port) {\n  $host = php_uname('n');\n\n  $filename = __DIR__.'/request-doesnotexist.dat';\n  $file = fopen($filename, 'rb');\n  $req_dat = fread($file, filesize($filename));\n  fclose($file);\n\n  // Repeat the data three times, to make it invalid. This particular bytestream\n  // (and ones like it -- repeat 3 times!) in particular used to tickle a\n  // use-after-free in the FastCGI support.\n  $req_dat = $req_dat . $req_dat . $req_dat;\n\n  $sock = fsockopen($host, $port);\n  fwrite($sock, $req_dat);\n  fclose($sock);\n\n  // Should still be able to recover and respond to a request over the port on a\n  // new TCP connection.\n  echo request($host, $port, 'hello.php');\n  echo \"\\n\";\n}\n\nrunTest(\"invalidTestController\");\n", "<?hh\n\n\nabstract final class ServerUtilServerTests {\n  public static $error_log_file;\n  public static $test_run_id = 0;\n  public static $LOG_ROOT;\n  public static $DOC_ROOT;\n  public static $next_instance_id = 0;\n  public static $repo_builds = dict[];\n}\n\nServerUtilServerTests::$test_run_id = posix_getpid();\nServerUtilServerTests::$error_log_file = fopen(ServerUtilServerTests::$LOG_ROOT.'_test'.ServerUtilServerTests::$test_run_id.\".log\", 'w');\n\nfunction tlog($str) {\n\n\n  fwrite(ServerUtilServerTests::$error_log_file, $str ?? '');\n  fwrite(ServerUtilServerTests::$error_log_file, \"\\n\");\n  fflush(ServerUtilServerTests::$error_log_file);\n  // error_log($str);\n}\n\nfunction dumpLogFilesToStdoutAndDie() {\n  $LOG_ROOT = ServerUtilServerTests::$LOG_ROOT;\n  $test_run_id = ServerUtilServerTests::$test_run_id;\n\n  sleep(1);\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_server$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test_server$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_server_stdout$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test_server_stdout$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_server_stderr$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test_server_stderr$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_client$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test_client$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_sandbox_access.log'\");\n  readfile(\"${LOG_ROOT}_test_sandbox_access.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_curl$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_curl$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  throw new Exception(\"test failed\");\n}\n\nfunction hphp_home() {\n  // __DIR__ == result.'hphp/test/server/util'\n  return realpath(__DIR__.'/../../../..');\n}\n\nfunction get_random_port($exclude1, $exclude2) {\n  $BasePort = 20000;\n  $PortRange = 3000;\n  do {\n    $t = rand($BasePort, $BasePort+$PortRange);\n  } while ($t == $exclude1 || $t == $exclude2);\n  return $t;\n}\n\n# Return the command line to start the server with the specified options\nfunction getServerCmd($serverPort, $adminPort, $debugPort, $home, $root,\n                      $customArgs = '', $serverId = null, $repoArgs = '') {\n  $LOG_ROOT = ServerUtilServerTests::$LOG_ROOT;\n  $test_run_id = ServerUtilServerTests::$test_run_id;\n\n  $instance_id = ServerUtilServerTests::$next_instance_id;\n  ++ServerUtilServerTests::$next_instance_id;\n\n  $portConfig = ' -vServer.Port='.$serverPort;\n  $serverConfig = ' --config='.$home.'/config/server.ini';\n  $logFileConfig = ' -vLog.File='.\"${LOG_ROOT}_test_server$test_run_id.log\";\n  $logFileConfig.= ' -vLog.Access.Default.File='.\n    \"${LOG_ROOT}_access_log$test_run_id.log\";\n  $srcRootConfig = ' -vServer.SourceRoot='.$root;\n  $includePathConfig = ' -vServer.IncludeSearchPaths.0='.$root;\n  $adminPortConfig = $adminPort ? ' -vAdminServer.Port='.$adminPort : '';\n  $debugPortConfig = $debugPort ? ' -vEval.Debugger.Port='.$debugPort : '';\n  $repoConfig = \" -vRepo.Central.Path=${LOG_ROOT}_server{$test_run_id}_{$instance_id}.hhbc\";\n  $useJit = array_key_exists('HHVM_JIT', $_ENV) && $_ENV['HHVM_JIT'] == 1;\n  $jitConfig = ' -vEval.Jit='.($useJit ? \"true\" : \"false\");\n  // To emulate sandbox setup, let Sandbox.Home be '$home'\n  // and user name be 'debugger', so that the server can find the\n  // sandbox_conf.hdf in '$root'.\n  $sandboxHomeConfig = ' -vSandbox.Home='.$home;\n  $serverId ??= $test_run_id;\n\n  $hhvm = PHP_BINARY;\n\n  if (ini_get('hhvm.repo.authoritative')) {\n    if (count(ServerUtilServerTests::$repo_builds) === 0) {\n      register_shutdown_function(\n         function() {\n           foreach (ServerUtilServerTests::$repo_builds as $dir) {\n             @unlink($dir . \"/hhvm.hhbc\");\n             @rmdir($dir);\n           }\n         }\n       );\n    }\n    $repoKey = 'x'.$root.':'.$repoArgs;\n    if (!isset(ServerUtilServerTests::$repo_builds[$repoKey])) {\n      ServerUtilServerTests::$repo_builds[$repoKey] =\n        \"${LOG_ROOT}_bytecode{$test_run_id}_{$instance_id}\";\n      $cmd = \"$hhvm --hphp -k1 -l2 -t hhbc -o \" . ServerUtilServerTests::$repo_builds[$repoKey] .\n        \" --input-dir $root $repoArgs\";\n\n      tlog('Building repo with command: '.$cmd);\n      tlog(exec($cmd));\n    }\n    $repoConfig .=\n      \" -vRepo.Local.Path=\".ServerUtilServerTests::$repo_builds[$repoKey].\"/hhvm.hhbc\".\n      \" -vRepo.Authoritative=true\";\n  }\n\n  $cmd = \"exec env MALLOC_CONF=junk:true TESTID={$serverId} \" .\n    \"SERVERPORT={$serverPort} $hhvm\" .\n    ' --mode=server' . $serverConfig . $logFileConfig .\n    ' -vServer.ExitOnBindFail=true' .\n    ' --instance-id=' . $test_run_id .\n    ' -vPageletServer.ThreadCount=5' .\n    $portConfig . $srcRootConfig .\n    $includePathConfig . $sandboxHomeConfig . $adminPortConfig .\n    $debugPortConfig . $repoConfig . $jitConfig . ' ' . $customArgs .\n    \" > ${LOG_ROOT}_test_server_stdout$test_run_id.log\" .\n    \" 2> ${LOG_ROOT}_test_server_stderr$test_run_id.log\";\n\n  return $cmd;\n}\n\nfunction startServer(&$serverPort, &$adminPort, &$debugPort, $home, $root,\n                     $customArgs = '', $serverId = null, $repoArgs = '') {\n\n\n  $chooseServer = $serverPort === null;\n  $chooseAdmin = $adminPort === null;\n  $chooseDebug = $debugPort === null;\n  $pid = posix_getpid();\n  $safe_children = array_flip(array_map(\n    $v ==> (int)$v,\n    explode(',', exec(\"pgrep -f -d , -P $pid\")),\n  ));\n\n  for ($i = 0; $i < 5; $i++) {\n    if ($chooseServer) $serverPort = get_random_port($adminPort, $debugPort);\n    if ($chooseAdmin) $adminPort = get_random_port($serverPort, $debugPort);\n    if ($chooseDebug) $debugPort = get_random_port($serverPort, $adminPort);\n\n    $cmd = getServerCmd($serverPort, $adminPort, $debugPort, $home, $root,\n                        $customArgs, $serverId, $repoArgs);\n    tlog('Starting server with command: '.$cmd);\n    $pipes = array();\n    $serverProc = proc_open($cmd, array(), &$pipes);\n    if (!is_resource($serverProc)) {\n      tlog('Failed to start a shell process for the server');\n    } else if (waitForServerToGetGoing($serverPort, $serverProc, $serverId)) {\n      return $serverProc;\n    }\n    killChildren($pid, $safe_children);\n    if ($serverProc) proc_close($serverProc);\n  }\n  dumpLogFilesToStdoutAndDie();\n}\n\n// Check if the server id is in the expected list of ids.\nfunction checkServerId($serverPort, $expectedIds) {\n  $host = php_uname('n');\n  $r = request($host, $serverPort, \"hello.php\");\n  if (preg_match('/Hello, World!(.*+)/', $r ?? '', &$matches)) {\n    foreach ((array)$expectedIds as $id) {\n      if ($matches[1] == $id) return true;\n    }\n    tlog('a server for a different test responded');\n    return false;\n  }\n  tlog('Server replied: '.$r);\n  return false;\n}\n\nfunction waitForServerToGetGoing($serverPort, $serverProc, $serverId = null) {\n\n  $serverId ??= ServerUtilServerTests::$test_run_id;\n  for ($i = 1; $i <= 20; $i++) {\n    $status = proc_get_status($serverProc);\n    if ($status === false || !$status['running']) {\n      break;\n    }\n    sleep(1);\n    if (checkServerId($serverPort, $serverId)) {\n      return true;\n    }\n  }\n\n  tlog('Server is not responding.');\n  return false;\n}\n\nfunction stopServer($adminPort, $serverProc) {\n  $LOG_ROOT = ServerUtilServerTests::$LOG_ROOT;\n  $test_run_id = ServerUtilServerTests::$test_run_id;\n\n\n  $r = \"\";\n  for ($i = 1; $i <= 10; $i++) {\n    $r = request(php_uname('n'), $adminPort, 'stop?instance-id='.$test_run_id);\n    if ($r === \"OK\") break;\n    usleep(100000);\n  }\n  if ($r != \"OK\") {\n    tlog(\"Server did not stop. Response was $r\");\n    dumpLogFilesToStdoutAndDie();\n  }\n  proc_close($serverProc);\n\n  @unlink(\"${LOG_ROOT}_test$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_test_server$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_test_server_stderr$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_test_server_stdout$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_test_client$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_client$test_run_id.hhbc\");\n  @unlink(\"${LOG_ROOT}_curl$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_access_log$test_run_id.log\");\n\n  $next_instance_id = ServerUtilServerTests::$next_instance_id;\n  for ($instance_id = 0; $instance_id < $next_instance_id; $instance_id++) {\n    @unlink(\"${LOG_ROOT}_server{$test_run_id}_{$instance_id}.hhbc\");\n  }\n}\n\n// Start a new server to takeover the old one, we want to assign a new\n// server id in order to distinguish between the two servers.\nfunction takeoverOldServer($serverPort, $adminPort, $home, $root,\n                           $socketFile, $oldServerProc, $customArgs,\n                           $serverId) {\n  $status = proc_get_status($oldServerProc);\n  if ($status === false || !$status['running']) {\n    tlog('Old server is not running');\n    return;\n  }\n  $customArgs .= \" -vServer.TakeoverFilename=${socketFile}\";\n  $cmd = getServerCmd($serverPort, $adminPort, false, $home, $root,\n                      $customArgs, $serverId);\n  $pipes = array();\n  $serverProc = proc_open($cmd, array(), &$pipes);\n  if (!is_resource($serverProc)) {\n    tlog('Failed to start a shell process for the server');\n    return;\n  }\n  return $serverProc;\n}\n\nfunction http_request($host, $port, $path, $timeout = 1200, $curl_opts = '') {\n\n  if (is_array($path)) {\n    $headers = $path[2] ?? null;\n    $post = $path[1] ?? null;\n    $path = $path[0];\n  } else {\n    $headers = null;\n    $post = null;\n  }\n  if ($post) {\n    $post = http_build_query($post);\n    $post = '--data-urlencode='.urlencode($post);;\n  }\n  if ($headers) {\n    $s = array();\n    foreach ($headers as $h => $v) {\n      $s[] = \"-H '$h: $v'\";\n    }\n    $headers = implode(\" \", $s);\n  }\n  $url = \"http://$host:$port/$path\";\n  $host_name = \"hphpd.debugger.\".php_uname('n');\n\n  $LOG_ROOT = ServerUtilServerTests::$LOG_ROOT;\n  $test_run_id = ServerUtilServerTests::$test_run_id;\n  $cmd = \"curl $post --trace-ascii ${LOG_ROOT}_curl$test_run_id.log \".\n    \"--silent $curl_opts --connect-timeout $timeout \".\n    \"-H 'Host: $host_name' $headers --url \\\"$url\\\"\";\n  tlog(\"Requesting page with command: $cmd\");\n  if (exec($cmd, &$result) === null) return null;\n  return implode(\"\\n\", $result);\n}\n\nfunction requestAll(array $requests, $customArgs = '', $repoArgs = '') {\n  runTest(\n    function($serverPort) use ($requests) {\n      foreach ($requests as $request) {\n        $r = is_array($request) ? $request[0] : $request;\n        echo \"Requesting '$r'\\n\";\n        var_dump(request(php_uname('n'), $serverPort, $request));\n      }\n    },\n    $customArgs,\n    $repoArgs,\n  );\n}\n\nif (!function_exists(\"request\")) {\n  include 'server_tests1.inc';\n}\n\nfunction killChildren($pid, $safe_children = array()) {\n  $childIds = exec(\"pgrep -f -d , -P $pid\");\n  foreach (array_map($v ==> (int)$v, explode(\",\", $childIds ?? '')) as $cid) {\n    if (!$cid) continue;\n    if (isset($safe_children[$cid])) continue;\n    tlog(\"killing \".exec(\"ps -f -p \".$cid));\n    killChildren($cid, $safe_children);\n    posix_kill($cid, SIGKILL);\n  }\n}\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/server/fastcgi/fastcgi-server.h\"\n\n#include \"hphp/runtime/server/http-server.h\"\n\nnamespace HPHP {\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool FastCGIAcceptor::canAccept(const folly::SocketAddress& /*address*/) {\n  // TODO: Support server IP whitelist.\n  auto const cons = m_server->getLibEventConnectionCount();\n  return (RuntimeOption::ServerConnectionLimit == 0 ||\n          cons < RuntimeOption::ServerConnectionLimit);\n}\n\nvoid FastCGIAcceptor::onNewConnection(\n  folly::AsyncTransportWrapper::UniquePtr sock,\n  const folly::SocketAddress* peerAddress,\n  const std::string& /*nextProtocolName*/,\n  SecureTransportType /*secureProtocolType*/,\n  const ::wangle::TransportInfo& /*tinfo*/) {\n  folly::SocketAddress localAddress;\n  try {\n    sock->getLocalAddress(&localAddress);\n  } catch (std::system_error& e) {\n    // If getSockName fails it's bad news; abort the connection\n    return;\n  }\n\n  // Will delete itself when it gets a closing callback\n  auto session = new FastCGISession(\n      m_server->getEventBaseManager()->getExistingEventBase(),\n      m_server->getDispatcher(),\n      std::move(sock),\n      localAddress,\n      *peerAddress\n    );\n\n  // NB: ~ManagedConnection will call removeConnection() before the session\n  //     destroys itself.\n  Acceptor::addConnection(session);\n};\n\nvoid FastCGIAcceptor::onConnectionsDrained() {\n  m_server->onConnectionsDrained();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nFastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromHostPort(\"localhost\", port);\n    assert(sock_addr.isLoopbackAddress());\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    // default to 2 minutes\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}\n\nvoid FastCGIServer::start() {\n  // It's not safe to call this function more than once\n  m_socket.reset(new folly::AsyncServerSocket(m_worker.getEventBase()));\n  try {\n    m_socket->bind(m_socketConfig.bindAddress);\n  } catch (const std::system_error& ex) {\n    Logger::Error(std::string(ex.what()));\n    if (m_socketConfig.bindAddress.getFamily() == AF_UNIX) {\n      throw FailedToListenException(m_socketConfig.bindAddress.getPath());\n    }\n    throw FailedToListenException(m_socketConfig.bindAddress.getAddressStr(),\n                                  m_socketConfig.bindAddress.getPort());\n  }\n  if (m_socketConfig.bindAddress.getFamily() == AF_UNIX) {\n    auto path = m_socketConfig.bindAddress.getPath();\n    chmod(path.c_str(), 0760);\n  }\n  m_acceptor.reset(new FastCGIAcceptor(m_socketConfig, this));\n  m_acceptor->init(m_socket.get(), m_worker.getEventBase());\n  m_worker.getEventBase()->runInEventBaseThread([&] {\n    if (!m_socket) {\n      // Someone called stop before we got here. With the exception of a\n      // second call to start being made this should be safe as any place\n      // we mutate m_socket is done within the event base.\n      return;\n    }\n    m_socket->listen(m_socketConfig.acceptBacklog);\n    m_socket->startAccepting();\n  });\n  setStatus(RunStatus::RUNNING);\n  folly::AsyncTimeout::attachEventBase(m_worker.getEventBase());\n  m_worker.start();\n  m_dispatcher.start();\n}\n\nvoid FastCGIServer::waitForEnd() {\n  // When m_worker stops the server has stopped accepting new requests, there\n  // may be pedning vm jobs. wait() is always safe to call regardless of thread\n  m_worker.wait();\n}\n\nvoid FastCGIServer::stop() {\n  if (getStatus() != RunStatus::RUNNING) return; // nothing to do\n\n  setStatus(RunStatus::STOPPING);\n  HttpServer::MarkShutdownStat(ShutdownEvent::SHUTDOWN_DRAIN_READS);\n\n  m_worker.getEventBase()->runInEventBaseThread([&] {\n    // Shutdown the server socket. Unfortunately, we will drop all unaccepted\n    // connections; there is no way to do a partial shutdown of a server socket\n    m_socket->stopAccepting();\n\n    if (RuntimeOption::ServerGracefulShutdownWait > 0) {\n      // Gracefully drain any incomplete requests. We cannot go offline until\n      // they are finished as we own their dispatcher and event base.\n      if (m_acceptor) {\n        m_acceptor->drainAllConnections();\n      }\n\n      std::chrono::seconds s(RuntimeOption::ServerGracefulShutdownWait);\n      std::chrono::milliseconds m(s);\n      scheduleTimeout(m);\n    } else {\n      // Drop all connections. We cannot shutdown until they stop because we\n      // own their dispatcher and event base.\n      if (m_acceptor) {\n        m_acceptor->forceStop();\n      }\n\n      terminateServer();\n    }\n  });\n}\n\nvoid FastCGIServer::onConnectionsDrained() {\n  // NOTE: called from FastCGIAcceptor::onConnectionsDrained()\n  cancelTimeout();\n  terminateServer();\n}\n\nvoid FastCGIServer::timeoutExpired() noexcept {\n  // Acceptor failed to drain connections on time; drop them so that we can\n  // shutdown.\n  if (m_acceptor) {\n    m_acceptor->forceStop();\n  }\n\n  terminateServer();\n}\n\nvoid FastCGIServer::terminateServer() {\n  if (getStatus() != RunStatus::STOPPING) {\n    setStatus(RunStatus::STOPPING);\n  }\n  // Wait for the server socket thread to stop running\n  m_worker.stopWhenIdle();\n\n  HttpServer::MarkShutdownStat(ShutdownEvent::SHUTDOWN_DRAIN_DISPATCHER);\n  // Wait for VMs to shutdown\n  m_dispatcher.stop();\n\n  setStatus(RunStatus::STOPPED);\n  HttpServer::MarkShutdownStat(ShutdownEvent::SHUTDOWN_DONE);\n\n  // Notify HttpServer that we've shutdown\n  for (auto listener: m_listeners) {\n    listener->serverStopped(this);\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n}\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction test1Controller($hphpdOutput, $hphpdProcessId, $serverPort) {\n  // Request a page so that the client can debug it.\n  waitForClientToOutput($hphpdOutput, \"Waiting for server response\");\n  echo \"Requesting test1.php\\n\";\n  request('localhost', $serverPort, 'test1.php', 10); // ignore response\n\n  // Let client run until script quits\n  waitForClientToOutput($hphpdOutput, \"quit\");\n}\n\nrunTest('test1', \"test1Controller\");\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction BadAuthDigestTestController($serverPort) {\n  $args = array('Authorization' => 'Digest \"username=\"admin\", ' .\n    'realm=\"Restricted area\", nonce=\"564a12f5c065e\", ' .\n    'uri=\"/test_auth_digest.php\", cnonce=\"MjIyMTg2\", nc=00000001, ' .\n    'qop=\"auth\", response=\"6dfbea52fbf13016476c1879e6436004\", ' .\n    'opaque=\"cdce8a5c95a1427d74df7acbf41c9ce0\"');\n  var_dump(request('localhost', $serverPort, \"test_auth_digest.php\",\n                  [], [], $args));\n}\n\nfunction GoodAuthDigestTestController($serverPort) {\n  $args = array('Authorization' => 'Digest username=\"admin\", ' .\n    'realm=\"Restricted area\", nonce=\"564a12611dae8\", ' .\n    'uri=\"/test_auth_digest.php\", cnonce=\"MjIyMTg1\", nc=00000001, ' .\n    'qop=\"auth\", response=\"e544aaed06917adea3e5c74dd49f0e32\", ' .\n    'opaque=\"cdce8a5c95a1427d74df7acbf41c9ce0\"');\n  var_dump(request('localhost', $serverPort, \"test_auth_digest.php\",\n                  [], [], $args));\n}\n\nrunTest(\"BadAuthDigestTestController\");\nrunTest(\"GoodAuthDigestTestController\");\n", "<?hh\n\n// Remove this test once we unify the zend ini compat diff (D1797805) with the\n// per dir diff (D2099778)\n\nrequire_once('test_base.inc');\n\nfunction disableIniZendCompatController($port) {\n  echo request('localhost', $port, 'test_disable_ini_zend_compat.php');\n}\n\necho \"---Enable Ini Zend Compat ON---\\n\";\nrunTest(\"disableIniZendCompatController\",\n        \"-dhhvm.enable_zend_ini_compat=true\");\necho \"\\n---Enable Ini Zend Compat OFF---\\n\";\nrunTest(\"disableIniZendCompatController\",\n        \"-dhhvm.enable_zend_ini_compat=false\");\n", "<?hh\n\nrequire_once(__DIR__ . '/test_base.inc');\n\n$requests = array(\n  array(\n    '-dalways_populate_raw_post_data=1',\n    ['CONTENT_TYPE' => 'multipart/form-data; boundary=dumy']),\n  array('-dalways_populate_raw_post_data=1', []),\n  array('', []),\n  array('-dvariables_order=NONE -drequest_order=', []),\n  array('-dvariables_order=E -drequest_order=GPC', []),\n  array('-dvariables_order=CGP -drequest_order=GP', []),\n  array('-dvariables_order=GC -drequest_order=CG', []),\n  array('-dvariables_order=GC -drequest_order=GC', []),\n  array('-dvariables_order=GC -drequest_order=P', []),\n);\n\nforeach($requests as $request) {\n  echo \"------------ {$request[0]} --------\\n\";\n  runTest(function($port) use($request) {\n    list($options, $extra) = $request;\n    $path = 'global_variables.php?var=GET&get=1';\n    $post = array('var' => 'POST', 'post' => 2);\n    $headers = array('Cookie' => 'var=COOKIE;cookie=3;');\n    echo request('localhost', $port, $path, $post, $headers, $extra) . \"\\n\";\n  }, $request[0]);\n}\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction headerTestController($serverPort) {\n  $args = array('Authorization' => 'foo');\n  var_dump(request('localhost', $serverPort, \"test_headers.php\",\n                  [], ['PROXY' => 'foobar'], $args));\n}\n\nrunTest(\"headerTestController\");\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction httpsTestController($serverPort) {\n  $args = array('HTTPS' => '');\n  var_dump(request('localhost', $serverPort, \"test_https.php\",\n                  [], [], $args));\n}\n\nrunTest(\"httpsTestController\");\n", "<?hh\n\nrequire_once('test_base.inc');\n\nfunction invalidTestController($port) {\n  $host = 'localhost';\n\n  $filename = __DIR__.'/request-doesnotexist.dat';\n  $file = fopen($filename, 'rb');\n  $req_dat = fread($file, filesize($filename));\n  fclose($file);\n\n  // Repeat the data three times, to make it invalid. This particular bytestream\n  // (and ones like it -- repeat 3 times!) in particular used to tickle a\n  // use-after-free in the FastCGI support.\n  $req_dat = $req_dat . $req_dat . $req_dat;\n\n  $sock = fsockopen($host, $port);\n  fwrite($sock, $req_dat);\n  fclose($sock);\n\n  // Should still be able to recover and respond to a request over the port on a\n  // new TCP connection.\n  echo request($host, $port, 'hello.php');\n  echo \"\\n\";\n}\n\nrunTest(\"invalidTestController\");\n", "<?hh\n\n\nabstract final class ServerUtilServerTests {\n  public static $error_log_file;\n  public static $test_run_id = 0;\n  public static $LOG_ROOT;\n  public static $DOC_ROOT;\n  public static $next_instance_id = 0;\n  public static $repo_builds = dict[];\n}\n\nServerUtilServerTests::$test_run_id = posix_getpid();\nServerUtilServerTests::$error_log_file = fopen(ServerUtilServerTests::$LOG_ROOT.'_test'.ServerUtilServerTests::$test_run_id.\".log\", 'w');\n\nfunction tlog($str) {\n\n\n  fwrite(ServerUtilServerTests::$error_log_file, $str ?? '');\n  fwrite(ServerUtilServerTests::$error_log_file, \"\\n\");\n  fflush(ServerUtilServerTests::$error_log_file);\n  // error_log($str);\n}\n\nfunction dumpLogFilesToStdoutAndDie() {\n  $LOG_ROOT = ServerUtilServerTests::$LOG_ROOT;\n  $test_run_id = ServerUtilServerTests::$test_run_id;\n\n  sleep(1);\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_server$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test_server$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_server_stdout$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test_server_stdout$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_server_stderr$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test_server_stderr$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_client$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_test_client$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_test_sandbox_access.log'\");\n  readfile(\"${LOG_ROOT}_test_sandbox_access.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  error_log(\"Contents of '${LOG_ROOT}_curl$test_run_id.log'\");\n  readfile(\"${LOG_ROOT}_curl$test_run_id.log\");\n  echo \"\\n\";\n  error_log('-------------------------------------------');\n  throw new Exception(\"test failed\");\n}\n\nfunction hphp_home() {\n  // __DIR__ == result.'hphp/test/server/util'\n  return realpath(__DIR__.'/../../../..');\n}\n\nfunction get_random_port($exclude1, $exclude2) {\n  $BasePort = 20000;\n  $PortRange = 3000;\n  do {\n    $t = rand($BasePort, $BasePort+$PortRange);\n  } while ($t == $exclude1 || $t == $exclude2);\n  return $t;\n}\n\n# Return the command line to start the server with the specified options\nfunction getServerCmd($serverPort, $adminPort, $debugPort, $home, $root,\n                      $customArgs = '', $serverId = null, $repoArgs = '') {\n  $LOG_ROOT = ServerUtilServerTests::$LOG_ROOT;\n  $test_run_id = ServerUtilServerTests::$test_run_id;\n\n  $instance_id = ServerUtilServerTests::$next_instance_id;\n  ++ServerUtilServerTests::$next_instance_id;\n\n  $portConfig = ' -vServer.Port='.$serverPort;\n  $serverConfig = ' --config='.$home.'/config/server.ini';\n  $logFileConfig = ' -vLog.File='.\"${LOG_ROOT}_test_server$test_run_id.log\";\n  $logFileConfig.= ' -vLog.Access.Default.File='.\n    \"${LOG_ROOT}_access_log$test_run_id.log\";\n  $srcRootConfig = ' -vServer.SourceRoot='.$root;\n  $includePathConfig = ' -vServer.IncludeSearchPaths.0='.$root;\n  $adminPortConfig = $adminPort ? ' -vAdminServer.Port='.$adminPort : '';\n  $debugPortConfig = $debugPort ? ' -vEval.Debugger.Port='.$debugPort : '';\n  $repoConfig = \" -vRepo.Central.Path=${LOG_ROOT}_server{$test_run_id}_{$instance_id}.hhbc\";\n  $useJit = array_key_exists('HHVM_JIT', $_ENV) && $_ENV['HHVM_JIT'] == 1;\n  $jitConfig = ' -vEval.Jit='.($useJit ? \"true\" : \"false\");\n  // To emulate sandbox setup, let Sandbox.Home be '$home'\n  // and user name be 'debugger', so that the server can find the\n  // sandbox_conf.hdf in '$root'.\n  $sandboxHomeConfig = ' -vSandbox.Home='.$home;\n  $serverId ??= $test_run_id;\n\n  $hhvm = PHP_BINARY;\n\n  if (ini_get('hhvm.repo.authoritative')) {\n    if (count(ServerUtilServerTests::$repo_builds) === 0) {\n      register_shutdown_function(\n         function() {\n           foreach (ServerUtilServerTests::$repo_builds as $dir) {\n             @unlink($dir . \"/hhvm.hhbc\");\n             @rmdir($dir);\n           }\n         }\n       );\n    }\n    $repoKey = 'x'.$root.':'.$repoArgs;\n    if (!isset(ServerUtilServerTests::$repo_builds[$repoKey])) {\n      ServerUtilServerTests::$repo_builds[$repoKey] =\n        \"${LOG_ROOT}_bytecode{$test_run_id}_{$instance_id}\";\n      $cmd = \"$hhvm --hphp -k1 -l2 -t hhbc -o \" . ServerUtilServerTests::$repo_builds[$repoKey] .\n        \" --input-dir $root $repoArgs\";\n\n      tlog('Building repo with command: '.$cmd);\n      tlog(exec($cmd));\n    }\n    $repoConfig .=\n      \" -vRepo.Local.Path=\".ServerUtilServerTests::$repo_builds[$repoKey].\"/hhvm.hhbc\".\n      \" -vRepo.Authoritative=true\";\n  }\n\n  $cmd = \"exec env MALLOC_CONF=junk:true TESTID={$serverId} \" .\n    \"SERVERPORT={$serverPort} $hhvm\" .\n    ' --mode=server' . $serverConfig . $logFileConfig .\n    ' -vServer.ExitOnBindFail=true' .\n    ' --instance-id=' . $test_run_id .\n    ' -vPageletServer.ThreadCount=5' .\n    $portConfig . $srcRootConfig .\n    $includePathConfig . $sandboxHomeConfig . $adminPortConfig .\n    $debugPortConfig . $repoConfig . $jitConfig . ' ' . $customArgs .\n    \" > ${LOG_ROOT}_test_server_stdout$test_run_id.log\" .\n    \" 2> ${LOG_ROOT}_test_server_stderr$test_run_id.log\";\n\n  return $cmd;\n}\n\nfunction startServer(&$serverPort, &$adminPort, &$debugPort, $home, $root,\n                     $customArgs = '', $serverId = null, $repoArgs = '') {\n\n\n  $chooseServer = $serverPort === null;\n  $chooseAdmin = $adminPort === null;\n  $chooseDebug = $debugPort === null;\n  $pid = posix_getpid();\n  $safe_children = array_flip(array_map(\n    $v ==> (int)$v,\n    explode(',', exec(\"pgrep -f -d , -P $pid\")),\n  ));\n\n  for ($i = 0; $i < 5; $i++) {\n    if ($chooseServer) $serverPort = get_random_port($adminPort, $debugPort);\n    if ($chooseAdmin) $adminPort = get_random_port($serverPort, $debugPort);\n    if ($chooseDebug) $debugPort = get_random_port($serverPort, $adminPort);\n\n    $cmd = getServerCmd($serverPort, $adminPort, $debugPort, $home, $root,\n                        $customArgs, $serverId, $repoArgs);\n    tlog('Starting server with command: '.$cmd);\n    $pipes = array();\n    $serverProc = proc_open($cmd, array(), &$pipes);\n    if (!is_resource($serverProc)) {\n      tlog('Failed to start a shell process for the server');\n    } else if (waitForServerToGetGoing($serverPort, $serverProc, $serverId)) {\n      return $serverProc;\n    }\n    killChildren($pid, $safe_children);\n    if ($serverProc) proc_close($serverProc);\n  }\n  dumpLogFilesToStdoutAndDie();\n}\n\n// Check if the server id is in the expected list of ids.\nfunction checkServerId($serverPort, $expectedIds) {\n  $host = 'localhost';\n  $r = request($host, $serverPort, \"hello.php\");\n  if (preg_match('/Hello, World!(.*+)/', $r ?? '', &$matches)) {\n    foreach ((array)$expectedIds as $id) {\n      if ($matches[1] == $id) return true;\n    }\n    tlog('a server for a different test responded');\n    return false;\n  }\n  tlog('Server replied: '.$r);\n  return false;\n}\n\nfunction waitForServerToGetGoing($serverPort, $serverProc, $serverId = null) {\n\n  $serverId ??= ServerUtilServerTests::$test_run_id;\n  for ($i = 1; $i <= 20; $i++) {\n    $status = proc_get_status($serverProc);\n    if ($status === false || !$status['running']) {\n      break;\n    }\n    sleep(1);\n    if (checkServerId($serverPort, $serverId)) {\n      return true;\n    }\n  }\n\n  tlog('Server is not responding.');\n  return false;\n}\n\nfunction stopServer($adminPort, $serverProc) {\n  $LOG_ROOT = ServerUtilServerTests::$LOG_ROOT;\n  $test_run_id = ServerUtilServerTests::$test_run_id;\n\n\n  $r = \"\";\n  for ($i = 1; $i <= 10; $i++) {\n    $r = request('localhost', $adminPort, 'stop?instance-id='.$test_run_id);\n    if ($r === \"OK\") break;\n    usleep(100000);\n  }\n  if ($r != \"OK\") {\n    tlog(\"Server did not stop. Response was $r\");\n    dumpLogFilesToStdoutAndDie();\n  }\n  proc_close($serverProc);\n\n  @unlink(\"${LOG_ROOT}_test$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_test_server$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_test_server_stderr$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_test_server_stdout$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_test_client$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_client$test_run_id.hhbc\");\n  @unlink(\"${LOG_ROOT}_curl$test_run_id.log\");\n  @unlink(\"${LOG_ROOT}_access_log$test_run_id.log\");\n\n  $next_instance_id = ServerUtilServerTests::$next_instance_id;\n  for ($instance_id = 0; $instance_id < $next_instance_id; $instance_id++) {\n    @unlink(\"${LOG_ROOT}_server{$test_run_id}_{$instance_id}.hhbc\");\n  }\n}\n\n// Start a new server to takeover the old one, we want to assign a new\n// server id in order to distinguish between the two servers.\nfunction takeoverOldServer($serverPort, $adminPort, $home, $root,\n                           $socketFile, $oldServerProc, $customArgs,\n                           $serverId) {\n  $status = proc_get_status($oldServerProc);\n  if ($status === false || !$status['running']) {\n    tlog('Old server is not running');\n    return;\n  }\n  $customArgs .= \" -vServer.TakeoverFilename=${socketFile}\";\n  $cmd = getServerCmd($serverPort, $adminPort, false, $home, $root,\n                      $customArgs, $serverId);\n  $pipes = array();\n  $serverProc = proc_open($cmd, array(), &$pipes);\n  if (!is_resource($serverProc)) {\n    tlog('Failed to start a shell process for the server');\n    return;\n  }\n  return $serverProc;\n}\n\nfunction http_request($host, $port, $path, $timeout = 1200, $curl_opts = '') {\n\n  if (is_array($path)) {\n    $headers = $path[2] ?? null;\n    $post = $path[1] ?? null;\n    $path = $path[0];\n  } else {\n    $headers = null;\n    $post = null;\n  }\n  if ($post) {\n    $post = http_build_query($post);\n    $post = '--data-urlencode='.urlencode($post);;\n  }\n  if ($headers) {\n    $s = array();\n    foreach ($headers as $h => $v) {\n      $s[] = \"-H '$h: $v'\";\n    }\n    $headers = implode(\" \", $s);\n  }\n  $url = \"http://$host:$port/$path\";\n  $host_name = \"hphpd.debugger.\".\\php_uname('n');\n\n  $LOG_ROOT = ServerUtilServerTests::$LOG_ROOT;\n  $test_run_id = ServerUtilServerTests::$test_run_id;\n  $cmd = \"curl $post --trace-ascii ${LOG_ROOT}_curl$test_run_id.log \".\n    \"--silent $curl_opts --connect-timeout $timeout \".\n    \"-H 'Host: $host_name' $headers --url \\\"$url\\\"\";\n  tlog(\"Requesting page with command: $cmd\");\n  if (exec($cmd, &$result) === null) return null;\n  return implode(\"\\n\", $result);\n}\n\nfunction requestAll(array $requests, $customArgs = '', $repoArgs = '') {\n  runTest(\n    function($serverPort) use ($requests) {\n      foreach ($requests as $request) {\n        $r = is_array($request) ? $request[0] : $request;\n        echo \"Requesting '$r'\\n\";\n        var_dump(request('localhost', $serverPort, $request));\n      }\n    },\n    $customArgs,\n    $repoArgs,\n  );\n}\n\nif (!function_exists(\"request\")) {\n  include 'server_tests1.inc';\n}\n\nfunction killChildren($pid, $safe_children = array()) {\n  $childIds = exec(\"pgrep -f -d , -P $pid\");\n  foreach (array_map($v ==> (int)$v, explode(\",\", $childIds ?? '')) as $cid) {\n    if (!$cid) continue;\n    if (isset($safe_children[$cid])) continue;\n    tlog(\"killing \".exec(\"ps -f -p \".$cid));\n    killChildren($cid, $safe_children);\n    posix_kill($cid, SIGKILL);\n  }\n}\n"], "filenames": ["hphp/runtime/server/fastcgi/fastcgi-server.cpp", "hphp/test/server/debugger/tests/runTest1.php", "hphp/test/server/fastcgi/tests/authDigestTest.php", "hphp/test/server/fastcgi/tests/disable_ini_zend_compat.php", "hphp/test/server/fastcgi/tests/global_variables_server.php", "hphp/test/server/fastcgi/tests/headerTest.php", "hphp/test/server/fastcgi/tests/httpsTest.php", "hphp/test/server/fastcgi/tests/invalid.php", "hphp/test/server/util/server_tests.inc"], "buggy_code_start_loc": [83, 8, 11, 9, 26, 7, 7, 6, 182], "buggy_code_end_loc": [84, 11, 22, 10, 27, 8, 8, 7, 308], "fixing_code_start_loc": [83, 7, 11, 9, 26, 7, 7, 6, 182], "fixing_code_end_loc": [85, 10, 22, 10, 27, 8, 8, 7, 308], "type": "CWE-668", "message": "HHVM, when used with FastCGI, would bind by default to all available interfaces. This behavior could allow a malicious individual unintended direct access to the application, which could result in information disclosure. This issue affects versions 4.3.0, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, versions 3.30.5 and below, and all versions in the 4.0, 4.1, and 4.2 series.", "other": {"cve": {"id": "CVE-2019-3569", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-06-26T15:15:09.887", "lastModified": "2021-09-14T12:19:24.367", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HHVM, when used with FastCGI, would bind by default to all available interfaces. This behavior could allow a malicious individual unintended direct access to the application, which could result in information disclosure. This issue affects versions 4.3.0, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, versions 3.30.5 and below, and all versions in the 4.0, 4.1, and 4.2 series."}, {"lang": "es", "value": "HHVM, cuando se usa con FastCGI vincular\u00eda por defecto a todos los interfaces disponibles. Este comportamiento podr\u00eda permitir accesos  directos involuntarios individuales maliciosos para la aplicaci\u00f3n, lo cual podr\u00eda dar como resultado una revelaci\u00f3n de la informaci\u00f3n. Este error afecta a las versiones 4.3.0, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, versiones 3.30.5 y abajo, y todas las versiones en  el  4.0, 4.1, y 4.2 series"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.30.5", "matchCriteriaId": "4D3D5055-D49B-4E8F-BC0A-08D779135A8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "4C45FDDD-7D26-4B6D-92C5-2CC56744E640"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "66C30666-3B5A-48F4-B9D0-C10E9987D697"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "2814F556-8F34-4944-BF56-16EE580460E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "4B387839-87D3-4864-8850-F80DBA120E15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "5FAB1506-8A10-4D12-986F-9CB505613896"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "E66B50A7-1F3B-484E-881C-E82A6BCAE451"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "C20F7A3C-1AB7-4ACB-94F4-AE30E5A059E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "2C228A35-6BD8-4873-B0C1-ED85EAE3DD0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "0D0BC86A-393F-4929-BD95-9C5107BD2D68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "0972CED9-09D2-40F1-BD60-17ADA19645CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "915D9CF1-34C1-4608-A481-8B6ED43490FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "68C3110F-F78C-4701-9E9C-113A5544B762"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "91234ACF-30A1-4BA8-833C-32D21679801A"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/97ef580ec2cca9a54da6f9bd9fdd9a455f6d74ed", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hhvm.com/blog/2019/06/10/hhvm-4.9.0.html", "source": "cve-assign@fb.com", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/97ef580ec2cca9a54da6f9bd9fdd9a455f6d74ed"}}