{"buggy_code": ["<?php\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\nif (!defined('GLPI_ROOT')) {\n   die(\"Sorry. You can't access this file directly\");\n}\n\n/**\n * Calendar Class\n**/\nclass Calendar extends CommonDropdown {\n   use Glpi\\Features\\Clonable;\n\n   // From CommonDBTM\n   public $dohistory                   = true;\n   public $can_be_translated           = false;\n\n   static protected $forward_entity_to = ['CalendarSegment'];\n\n   static $rightname = 'calendar';\n\n\n   public function getCloneRelations() :array {\n      return [\n         Calendar_Holiday::class,\n         CalendarSegment::class\n      ];\n   }\n\n\n   /**\n    * @since 0.84\n   **/\n   function getForbiddenStandardMassiveAction() {\n\n      $forbidden   = parent::getForbiddenStandardMassiveAction();\n      $forbidden[] = 'CommonDropdown'.MassiveAction::CLASS_ACTION_SEPARATOR.'merge';\n      return $forbidden;\n   }\n\n\n   static function getTypeName($nb = 0) {\n      return _n('Calendar', 'Calendars', $nb);\n   }\n\n\n   function defineTabs($options = []) {\n\n      $ong = parent::defineTabs($options);\n      $this->addStandardTab('CalendarSegment', $ong, $options);\n      $this->addStandardTab('Calendar_Holiday', $ong, $options);\n\n      return $ong;\n   }\n\n\n   function getSpecificMassiveActions($checkitem = null) {\n\n      $isadmin = static::canUpdate();\n      $actions = parent::getSpecificMassiveActions($checkitem);\n\n      if ($isadmin) {\n         $actions[__CLASS__.MassiveAction::CLASS_ACTION_SEPARATOR.'duplicate'] = _x('button', 'Duplicate');\n         $actions[__CLASS__.MassiveAction::CLASS_ACTION_SEPARATOR.'addholiday'] = __('Add a close time');\n      }\n      return $actions;\n   }\n\n\n   static function showMassiveActionsSubForm(MassiveAction $ma) {\n\n      switch ($ma->getAction()) {\n         case 'duplicate' :\n            Entity::dropdown();\n            echo \"<br><br>\";\n            echo Html::submit(_x('button', 'Duplicate'), ['name' => 'massiveaction']).\"</span>\";\n            return true;\n\n         case 'addholiday' :\n            Holiday::dropdown();\n            echo \"<br><br>\";\n            echo Html::submit(_x('button', 'Add'), ['name' => 'massiveaction']).\"</span>\";\n            return true;\n      }\n\n      return parent::showMassiveActionsSubForm($ma);\n   }\n\n\n   static function processMassiveActionsForOneItemtype(MassiveAction $ma, CommonDBTM $item,\n                                                       array $ids) {\n\n      switch ($ma->getAction()) {\n         case 'duplicate' : // For calendar duplicate in another entity\n            if (method_exists($item, 'duplicate')) {\n               $input = $ma->getInput();\n               $options = [];\n               if ($item->isEntityAssign()) {\n                  $options = ['entities_id' => $input['entities_id']];\n               }\n               foreach ($ids as $id) {\n                  if ($item->getFromDB($id)) {\n                     if (!$item->isEntityAssign()\n                         || ($input['entities_id'] != $item->getEntityID())) {\n                        if ($item->can(-1, CREATE, $options)) {\n                           if ($item->duplicate($options)) {\n                              $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_OK);\n                           } else {\n                              $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                              $ma->addMessage($item->getErrorMessage(ERROR_ON_ACTION));\n                           }\n                        } else {\n                           $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_NORIGHT);\n                           $ma->addMessage($item->getErrorMessage(ERROR_RIGHT));\n                        }\n                     } else {\n                        $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                        $ma->addMessage($item->getErrorMessage(ERROR_COMPAT));\n                     }\n                  } else {\n                     $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                     $ma->addMessage($item->getErrorMessage(ERROR_NOT_FOUND));\n                  }\n               }\n            } else {\n               $ma->itemDone($item->getType(), $ids, MassiveAction::ACTION_KO);\n            }\n            return;\n\n         case 'addholiday' : // add an holiday with massive action\n            $input = $ma->getInput();\n            if ($input['holidays_id'] > 0) {\n               $holiday          = new Holiday();\n               $calendar_holiday = new Calendar_Holiday();\n\n               $holiday->getFromDB($input['holidays_id']);\n               $entities = [$holiday->getEntityID() => $holiday->getEntityID()];\n               if ($holiday->isRecursive()) {\n                  $entities = getSonsOf(\"glpi_entities\", $holiday->getEntityID());\n               }\n\n               foreach ($ids as $id) {\n                  $entities_id = CommonDBTM::getItemEntity('Calendar', $id);\n                  if (isset($entities[$entities_id])) {\n                     $input = ['calendars_id' => $id,\n                                    'holidays_id'  => $input['holidays_id']];\n                     if ($calendar_holiday->add($input)) {\n                        $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_OK);\n                     } else {\n                        $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                        $ma->addMessage($item->getErrorMessage(ERROR_ON_ACTION));\n                     }\n                  } else {\n                     $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                     $ma->addMessage($item->getErrorMessage(ERROR_ON_ACTION));\n                  }\n               }\n            } else {\n               $ma->itemDone($item->getType(), $ids, MassiveAction::ACTION_KO);\n            }\n            return;\n      }\n      parent::processMassiveActionsForOneItemtype($ma, $item, $ids);\n   }\n\n\n   /**\n    * Clone a calendar to another entity : name is updated\n    *\n    * @param $options array of new values to set\n    * @return boolean True on success\n    */\n   function duplicate($options = []) {\n\n      $input = $this->fields;\n      unset($input['id']);\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $val) {\n            if (isset($this->fields[$key])) {\n               $input[$key] = $val;\n            }\n         }\n      }\n\n      if ($newID = $this->clone($input)) {\n         $this->updateDurationCache($newID);\n         return true;\n      }\n\n      return false;\n   }\n\n\n   function cleanDBonPurge() {\n\n      $this->deleteChildrenAndRelationsFromDb(\n         [\n            Calendar_Holiday::class,\n            CalendarSegment::class,\n         ]\n      );\n   }\n\n   /**\n    * Check if the given date is a holiday\n    *\n    * @param string $date Date of the day to check\n    *\n    * @return boolean\n   **/\n   function isHoliday($date) {\n      global $DB;\n\n      $result = $DB->request([\n         'COUNT'        => 'cpt',\n         'FROM'         => 'glpi_calendars_holidays',\n         'INNER JOIN'   => [\n            'glpi_holidays'   => [\n               'ON' => [\n                  'glpi_calendars_holidays'  => 'holidays_id',\n                  'glpi_holidays'            => 'id'\n               ]\n            ]\n         ],\n         'WHERE'        => [\n            'glpi_calendars_holidays.calendars_id' => $this->fields['id'],\n            'OR'                                   => [\n               [\n                  'AND' => [\n                     'glpi_holidays.end_date'            => ['>=', $date],\n                     'glpi_holidays.begin_date'          => ['<=', $date]\n                  ]\n               ],\n               [\n                  'AND' => [\n                     'glpi_holidays.is_perpetual'  => 1,\n                     new \\QueryExpression(\"MONTH(\".$DB->quoteName('end_date').\")*100 + DAY(\".$DB->quoteName('end_date').\") >= \".date('nd', strtotime($date))),\n                     new \\QueryExpression(\"MONTH(\".$DB->quoteName('begin_date').\")*100 + DAY(\".$DB->quoteName('begin_date').\") <= \".date('nd', strtotime($date)))\n                  ]\n               ]\n            ]\n         ]\n      ])->next();\n\n      return (int)$result['cpt'] > 0;\n   }\n\n\n   /**\n    * Get active time between to date time for the active calendar\n    *\n    * @param $start           datetime begin\n    * @param $end             datetime end\n    * @param $work_in_days    boolean  force working in days (false by default)\n    *\n    * @return integer timestamp of delay\n    */\n   function getActiveTimeBetween($start, $end, $work_in_days = false) {\n\n      if (!isset($this->fields['id'])) {\n         return false;\n      }\n\n      if ($end < $start) {\n         return 0;\n      }\n\n      $timestart  = strtotime($start);\n      $timeend    = strtotime($end);\n      $datestart  = date('Y-m-d', $timestart);\n      $dateend    = date('Y-m-d', $timeend);\n      // Need to finish at the closing day : set hour to midnight (23:59:59 for PHP)\n      $timerealend = strtotime($dateend.' 23:59:59');\n\n      $activetime = 0;\n\n      if ($work_in_days) {\n         $activetime = $timeend-$timestart;\n\n      } else {\n         $cache_duration = $this->getDurationsCache();\n\n         for ($actualtime=$timestart; $actualtime<=$timerealend; $actualtime+=DAY_TIMESTAMP) {\n            $actualdate = date('Y-m-d', $actualtime);\n\n            if (!$this->isHoliday($actualdate)) {\n               $beginhour    = '00:00:00';\n               // Calendar segment work with '24:00:00' format for midnight\n               $endhour      = '24:00:00';\n               $dayofweek    = self::getDayNumberInWeek($actualtime);\n               $timeoftheday = 0;\n\n               if ($actualdate == $datestart) { // First day : cannot use cache\n                  $beginhour = date('H:i:s', $timestart);\n               }\n\n               if ($actualdate == $dateend) { // Last day : cannot use cache\n                  $endhour = date('H:i:s', $timeend);\n               }\n\n               if ((($actualdate == $datestart) || ($actualdate == $dateend))\n                   && ($cache_duration[$dayofweek] > 0)) {\n                  $timeoftheday = CalendarSegment::getActiveTimeBetween($this->fields['id'],\n                                                                        $dayofweek, $beginhour,\n                                                                        $endhour);\n               } else {\n                  $timeoftheday = $cache_duration[$dayofweek];\n               }\n               $activetime += $timeoftheday;\n            }\n         }\n      }\n      return $activetime;\n   }\n\n\n   /**\n    * Check if the given time is on a working day (does not check working hours)\n    *\n    * @since 0.84\n    *\n    * @param integer $time Time to check\n    *\n    * @return boolean\n    */\n   function isAWorkingDay($time) {\n\n      $cache_duration   = $this->getDurationsCache();\n      $dayofweek        = self::getDayNumberInWeek($time);\n      $date             = date('Y-m-d', $time);\n      return (($cache_duration[$dayofweek] > 0) && !$this->isHoliday($date));\n   }\n\n\n   /**\n    * Determines if calendar has, at least, one working day.\n    *\n    * @since 9.4.3\n    *\n    * @return boolean\n    */\n   public function hasAWorkingDay() {\n\n      $durations = $this->getDurationsCache();\n      return false !== $durations && array_sum($durations) > 0;\n   }\n\n\n   /**\n    *\n    * Check if the given time is in a working hour\n    *\n    * @since 0.85\n    *\n    * @param integer $time Time to check\n    *\n    * @return boolean\n    */\n   function isAWorkingHour($time) {\n\n      if ($this->isAWorkingDay($time)) {\n         $dayofweek = self::getDayNumberInWeek($time);\n         return CalendarSegment::isAWorkingHour($this->fields['id'], $dayofweek,\n                                                date('H:i:s', $time));\n      }\n      return false;\n   }\n\n\n   /**\n    * Add a delay to a date using the active calendar\n    *\n    * if delay >= DAY_TIMESTAMP : work in days\n    * else work in minutes\n    *\n    * @param datetime $start               begin\n    * @param integer  $delay               delay to add (in seconds)\n    * @param integer  $additional_delay    delay to add (default 0)\n    * @param boolean  $work_in_days        force working in days (false by default)\n    * @param boolean  $end_of_working_day  end of working day (false by default)\n    *\n    * @return boolean|string end date\n   **/\n   function computeEndDate($start, $delay, $additional_delay = 0, $work_in_days = false, $end_of_working_day = false) {\n\n      if (!isset($this->fields['id'])) {\n         return false;\n      }\n\n      if (!$this->hasAWorkingDay()) {\n         // Invalid calendar (no working day = unable to find any date inside calendar hours)\n         return false;\n      }\n\n      $actualtime = strtotime($start);\n      $timestart  = strtotime($start);\n      $datestart  = date('Y-m-d', $timestart);\n\n      // manage dates in past\n      $negative_delay = false;\n      if ($delay < 0) {\n         $delay = -$delay;\n         $negative_delay = true;\n      }\n\n      // End of working day\n      if ($end_of_working_day) {\n         $numberofdays = $delay / DAY_TIMESTAMP;\n         // Add $additional_delay to start time.\n         // If start + delay is next day : +1 day\n         $actualtime += $additional_delay;\n         $cache_duration = $this->getDurationsCache();\n         $dayofweek      = self::getDayNumberInWeek($actualtime);\n         $actualdate     = date('Y-m-d', $actualtime);\n\n         // Begin next day working\n         if ($this->isHoliday($actualdate)\n             || ($cache_duration[$dayofweek] == 0)) {\n\n            while ($this->isHoliday($actualdate)\n                   || ($cache_duration[$dayofweek] == 0)) {\n               $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n               $actualdate  = date('Y-m-d', $actualtime);\n               $dayofweek   = self::getDayNumberInWeek($actualtime);\n            }\n         }\n\n         while ($numberofdays > 0) {\n            if (!$this->isHoliday($actualdate)\n                && ($cache_duration[$dayofweek] > 0)) {\n               $numberofdays --;\n            }\n            $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n            $actualdate  = date('Y-m-d', $actualtime);\n            $dayofweek   = self::getDayNumberInWeek($actualtime);\n         }\n\n         // Get next working day\n         if ($this->isHoliday($actualdate)\n             || ($cache_duration[$dayofweek] == 0)) {\n\n            while ($this->isHoliday($actualdate)\n                   || ($cache_duration[$dayofweek] == 0)) {\n               $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n               $actualdate  = date('Y-m-d', $actualtime);\n               $dayofweek   = self::getDayNumberInWeek($actualtime);\n            }\n         }\n\n         $lastworkinghour = CalendarSegment::getLastWorkingHour($this->fields['id'], $dayofweek);\n         $actualtime      = strtotime(date('Y-m-d', $actualtime).' '.$lastworkinghour);\n         return date('Y-m-d H:i:s', $actualtime);\n      }\n\n      // Add additional delay to initial delay\n      $delay += $additional_delay;\n\n      if ($work_in_days) { // only based on days\n         $cache_duration = $this->getDurationsCache();\n\n         // Compute Real starting time\n         // If day is an holiday must start on the begin of next working day\n         $actualdate = date('Y-m-d', $actualtime);\n         $dayofweek  = self::getDayNumberInWeek($actualtime);\n         if ($this->isHoliday($actualdate)\n             || ($cache_duration[$dayofweek] == 0)) {\n\n            while ($this->isHoliday($actualdate)\n                   || ($cache_duration[$dayofweek] == 0)) {\n               $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n               $actualdate = date('Y-m-d', $actualtime);\n               $dayofweek  = self::getDayNumberInWeek($actualtime);\n            }\n            $firstworkhour = CalendarSegment::getFirstWorkingHour($this->fields['id'],\n                                                                  $dayofweek);\n            $actualtime    = strtotime($actualdate.' '.$firstworkhour);\n         }\n\n         while ($delay > 0) {\n            // Begin next day : do not take into account first day : must finish to a working day\n            $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n            $actualdate = date('Y-m-d', $actualtime);\n            $dayofweek  = self::getDayNumberInWeek($actualtime);\n\n            if (!$this->isHoliday($actualdate)\n                && ($cache_duration[$dayofweek] > 0)) {\n               $delay -= DAY_TIMESTAMP;\n            }\n            if ($delay < 0) { // delay done : if < 0 delete hours\n               $actualtime = self::getActualTime($actualtime, $delay, $negative_delay);\n            }\n         }\n\n         // If > last working hour set last working hour\n         $dayofweek       = self::getDayNumberInWeek($actualtime);\n         $lastworkinghour = CalendarSegment::getLastWorkingHour($this->fields['id'], $dayofweek);\n         if ($lastworkinghour < date('H:i:s', $actualtime)) {\n            $actualtime   = strtotime(date('Y-m-d', $actualtime).' '.$lastworkinghour);\n         }\n\n         return date('Y-m-d H:i:s', $actualtime);\n      }\n\n      // else  // based on working hours\n      $cache_duration = $this->getDurationsCache();\n\n      // Only if segments exists\n      if (countElementsInTable('glpi_calendarsegments',\n                               ['calendars_id' => $this->fields['id']])) {\n         while ($delay >= 0) {\n            $actualdate = date('Y-m-d', $actualtime);\n            if (!$this->isHoliday($actualdate)) {\n               $dayofweek = self::getDayNumberInWeek($actualtime);\n               $beginhour = '00:00:00';\n\n               if ($actualdate == $datestart) { // First day cannot use cache\n                  $beginhour    = date('H:i:s', $timestart);\n                  $timeoftheday = CalendarSegment::getActiveTimeBetween($this->fields['id'],\n                                                                        $dayofweek, $beginhour,\n                                                                        '24:00:00');\n               } else {\n                  $timeoftheday = $cache_duration[$dayofweek];\n               }\n\n               if ($timeoftheday <= $delay && !$negative_delay\n                  || $timeoftheday >= $delay && $negative_delay) {\n                  // Delay is greater or equal than remaining time in day\n                  // -> pass to next day\n                  $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n                  $delay      -= $timeoftheday;\n               } else {\n                  // End of the delay in the day : get hours with this delay\n                  $endhour = CalendarSegment::addDelayInDay($this->fields['id'], $dayofweek,\n                                                            $beginhour, $delay);\n                  return $actualdate.' '.$endhour;\n               }\n\n            } else { // Holiday : pass to next day\n               $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n            }\n         }\n      }\n      return false;\n   }\n\n   static function getActualTime($current_time, $number = 0, $negative = false) {\n      if ($negative) {\n         return $current_time - $number;\n      } else {\n         return $current_time + $number;\n      }\n   }\n\n\n   /**\n    * Get days durations including all segments of the current calendar\n    *\n    * @return boolean|array\n   **/\n   function getDurationsCache() {\n\n      if (!isset($this->fields['id'])) {\n         return false;\n      }\n      $cache_duration = importArrayFromDB($this->fields['cache_duration']);\n\n      // Invalid cache duration : recompute it\n      if (!isset($cache_duration[0])) {\n         $this->updateDurationCache($this->fields['id']);\n         $cache_duration = importArrayFromDB($this->fields['cache_duration']);\n      }\n\n      return $cache_duration;\n   }\n\n\n   /**\n    * Get days durations including all segments of the current calendar\n    *\n    * @return boolean|array\n   **/\n   function getDaysDurations() {\n\n      if (!isset($this->fields['id'])) {\n         return false;\n      }\n\n      $results = [];\n      for ($i=0; $i<7; $i++) {\n         $results[$i] = CalendarSegment::getActiveTimeBetween($this->fields['id'], $i, '00:00:00',\n                                                              '24:00:00');\n      }\n      return $results;\n   }\n\n\n   /**\n    * Update the calendar cache\n    *\n    * @param integer $calendars_id ID of the calendar\n    *\n    * @return bool True if successful in updating the cache, otherwise returns false.\n    */\n   function updateDurationCache($calendars_id) {\n\n      if ($this->getFromDB($calendars_id)) {\n         $input = [\n            'id'             => $calendars_id,\n            'cache_duration' => exportArrayToDB($this->getDaysDurations()),\n         ];\n         return $this->update($input);\n      }\n      return false;\n   }\n\n\n   /**\n    * Get day number (in week) for a date.\n    *\n    * @param integer $date Date as a UNIX timestamp\n    *\n    * @return integer\n    */\n   static function getDayNumberInWeek($date) {\n      return (int)date('w', $date);\n   }\n}\n", "<?php\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\nuse Glpi\\Event;\n\nif (!defined('GLPI_ROOT')) {\n   die(\"Sorry. You can't access this file directly\");\n}\n\n/**\n*  Common DataBase Table Manager Class - Persistent Object\n**/\nclass CommonDBTM extends CommonGLPI {\n\n   /**\n    * Data fields of the Item.\n    *\n    * @var mixed[]\n    */\n   public $fields = [];\n\n   /**\n    * Flag to determine whether or not changes must be logged into history.\n    *\n    * @var boolean\n    */\n   public $dohistory = false;\n\n   /**\n    * List of fields that must not be taken into account when logging history or computating last\n    * modification date.\n    *\n    * @var string[]\n    */\n   public $history_blacklist = [];\n\n   /**\n    * Flag to determine whether or not automatic messages must be generated on actions.\n    *\n    * @var boolean\n    */\n   public $auto_message_on_action = true;\n\n   /**\n    * Flag to determine whether or not a link to item form can be automatically generated via\n    * self::getLink() method.\n    *\n    * @var boolean\n    */\n   public $no_form_page = false;\n\n   /**\n    * Flag to determine whether or not table name of item can be automatically generated via\n    * self::getTable() method.\n    *\n    * @var boolean\n    */\n   static protected $notable = false;\n\n   /**\n    * List of fields that must not be taken into account for dictionnary processing.\n    *\n    * @var string[]\n    */\n   public $additional_fields_for_dictionnary = [];\n\n   /**\n    * List of linked item types on which entities informations should be forwarded on update.\n    *\n    * @var string[]\n    */\n   static protected $forward_entity_to = [];\n\n   /**\n    * Foreign key field cache : set dynamically calling getForeignKeyField\n    *\n    * @TODO Remove this variable as it is not used ?\n    */\n   protected $fkfield = \"\";\n\n   /**\n    * Search option of item. Initialized on first call to self::getOptions() and used as cache.\n    *\n    * @var array\n    *\n    * @TODO Should be removed and replaced by real cache usage.\n    */\n   protected $searchopt = false;\n\n   /**\n    * {@inheritDoc}\n    */\n   public $taborientation = 'vertical';\n\n   /**\n    * {@inheritDoc}\n    */\n   public $get_item_to_display_tab = true;\n\n   /**\n    * List of linked item types from plugins on which entities informations should be forwarded on update.\n    *\n    * @var array\n    */\n   static protected $plugins_forward_entity = [];\n\n   /**\n    * Flag to determine whether or not table name of item has a notepad.\n    *\n    * @var boolean\n    */\n   protected $usenotepad = false;\n\n   /**\n    * Flag to determine whether or not notification queu should be flushed immediately when an\n    * action is performed on item.\n    *\n    * @var boolean\n    */\n   public $notificationqueueonaction = false;\n\n   /**\n    * Computed/forced values of classes tables.\n    * @var string[]\n    */\n   protected static $tables_of = [];\n\n   /**\n    * Computed values of classes foreign keys.\n    * @var string[]\n    */\n   protected static $foreign_key_fields_of = [];\n\n\n   /**\n    * Fields to remove when querying data with api\n    * @var array\n    */\n   static $undisclosedFields = [];\n\n   /**\n    * Constructor\n   **/\n   function __construct () {\n   }\n\n\n   /**\n    * Return the table used to store this object\n    *\n    * @param string $classname Force class (to avoid late_binding on inheritance)\n    *\n    * @return string\n   **/\n   static function getTable($classname = null) {\n      if ($classname === null) {\n         $classname = get_called_class();\n      }\n\n      if (!class_exists($classname) || $classname::$notable) {\n         return '';\n      }\n\n      if (!isset(self::$tables_of[$classname]) || empty(self::$tables_of[$classname])) {\n         self::$tables_of[$classname] = getTableForItemType($classname);\n      }\n\n      return self::$tables_of[$classname];\n   }\n\n\n   /**\n    * force table value (used for config management for old versions)\n    *\n    * @param string $table name of the table to be forced\n    *\n    * @return void\n   **/\n   static function forceTable($table) {\n      self::$tables_of[get_called_class()] = $table;\n   }\n\n\n   static function getForeignKeyField() {\n      $classname = get_called_class();\n\n      if (!isset(self::$foreign_key_fields_of[$classname])\n         || empty(self::$foreign_key_fields_of[$classname])) {\n         self::$foreign_key_fields_of[$classname] = getForeignKeyFieldForTable(static::getTable());\n      }\n\n      return self::$foreign_key_fields_of[$classname];\n   }\n\n   /**\n    * Return SQL path to access a field.\n    *\n    * @param string      $field     Name of the field (or SQL keyword like '*')\n    * @param string|null $classname Forced classname (to avoid late_binding on inheritance)\n    *\n    * @return string\n    *\n    * @throws InvalidArgumentException\n    * @throws LogicException\n    **/\n   static function getTableField($field, $classname = null) {\n\n      if (empty($field)) {\n         throw new InvalidArgumentException('Argument $field cannot be empty.');\n      }\n\n      $tablename = self::getTable($classname);\n      if (empty($tablename)) {\n         throw new LogicException('Invalid table name.');\n      }\n\n      return sprintf('%s.%s', $tablename, $field);\n   }\n\n   /**\n    * Retrieve an item from the database\n    *\n    * @param integer $ID ID of the item to get\n    *\n    * @return boolean true if succeed else false\n   **/\n   function getFromDB($ID) {\n      global $DB;\n      // Make new database object and fill variables\n\n      // != 0 because 0 is consider as empty\n      if (strlen($ID) == 0) {\n         return false;\n      }\n\n      $iterator = $DB->request([\n         'FROM'   => $this->getTable(),\n         'WHERE'  => [\n            $this->getTable() . '.' . $this->getIndexName() => Toolbox::cleanInteger($ID)\n         ],\n         'LIMIT'  => 1\n      ]);\n\n      if (count($iterator) == 1) {\n         $this->fields = $iterator->next();\n         $this->post_getFromDB();\n         return true;\n      } else if (count($iterator) > 1) {\n         Toolbox::logWarning(\n            sprintf(\n               'getFromDB expects to get one result, %1$s found!',\n               count($iterator)\n            )\n         );\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Hydrate an object from a resultset row\n    *\n    * @param array $rs The row\n    *\n    * @return void\n    */\n   function getFromResultSet($rs) {\n      //just set fields!\n      $this->fields = $rs;\n   }\n\n\n   /**\n    * Generator to browse object from an iterator\n    * @see http://php.net/manual/en/language.generators.syntax.php\n    *\n    * @since 9.2\n    *\n    * @param DBmysqlIterator $iter Iterator instance\n    *\n    * @return CommonDBTM\n    */\n   public static function getFromIter(DBmysqlIterator $iter) {\n      $item = new static;\n\n      foreach ($iter as $row) {\n         if (!isset($row[\"id\"])) {\n            continue;\n         }\n         if ($item->getFromDB($row[\"id\"])) {\n            yield $item;\n         }\n      }\n   }\n\n\n   /**\n    * Get an object using some criteria\n    *\n    * @since 9.2\n    *\n    * @param Array $crit search criteria\n    *\n    * @return boolean|array\n    */\n   public function getFromDBByCrit(array $crit) {\n      global $DB;\n\n      $crit = ['SELECT' => 'id',\n               'FROM'   => $this->getTable(),\n               'WHERE'  => $crit];\n\n      $iter = $DB->request($crit);\n      if (count($iter) == 1) {\n         $row = $iter->next();\n         return $this->getFromDB($row['id']);\n      } else if (count($iter) > 1) {\n         Toolbox::logWarning(\n            sprintf(\n               'getFromDBByCrit expects to get one result, %1$s found!',\n               count($iter)\n            )\n         );\n      }\n      return false;\n   }\n\n\n   /**\n    * Retrieve an item from the database by request. The request is an array\n    * similar to the one expected in DB::request().\n    *\n    * @since 9.3\n    *\n    * @see DB::request()\n    *\n    * @param array $request expression\n    *\n    * @return boolean true if succeed else false\n    **/\n   public function getFromDBByRequest(array $request) {\n      global $DB;\n\n      // Limit the request to the useful expressions\n      $request = array_diff_key($request, [\n         'FROM' => '',\n         'SELECT' => '',\n         'COUNT' => '',\n         'GROUPBY' => '',\n      ]);\n      $request['FROM'] = $this->getTable();\n      $request['SELECT'] = $this->getTable() . '.*';\n\n      $iterator = $DB->request($request);\n      if (count($iterator) == 1) {\n         $this->fields = $iterator->next();\n         $this->post_getFromDB();\n         return true;\n      } else if (count($iterator) > 1) {\n         Toolbox::logWarning(\n               sprintf(\n                     'getFromDBByRequest expects to get one result, %1$s found!',\n                     count($iterator)\n                     )\n               );\n      }\n      return false;\n   }\n\n   /**\n    * Get the identifier of the current item\n    *\n    * @return integer ID\n   **/\n   function getID() {\n\n      if (isset($this->fields[static::getIndexName()])) {\n         return $this->fields[static::getIndexName()];\n      }\n      return -1;\n   }\n\n\n   /**\n    * Actions done at the end of the getFromDB function\n    *\n    * @return void\n   **/\n   function post_getFromDB() {\n   }\n\n\n   /**\n    * Actions done to not show some fields when geting a single item from API calls\n    *\n    * @param array $fields Fields to unset undiscloseds\n    *\n    * @return void\n    */\n   static public function unsetUndisclosedFields(&$fields) {\n      foreach (static::$undisclosedFields as $key) {\n         unset($fields[$key]);\n      }\n   }\n\n\n   /**\n    * Retrieve all items from the database\n    *\n    * @param array        $condition condition used to search if needed (empty get all) (default '')\n    * @param array|string $order     order field if needed (default '')\n    * @param integer      $limit     limit retrieved data if needed (default '')\n    *\n    * @return array all retrieved data in a associative array by id\n   **/\n   function find($condition = [], $order = [], $limit = null) {\n      global $DB;\n\n      $criteria = [\n         'FROM'   => $this->getTable()\n      ];\n\n      if (count($condition)) {\n         $criteria['WHERE'] = $condition;\n      }\n\n      if (!is_array($order)) {\n         $order = [$order];\n      }\n      if (count($order)) {\n         $criteria['ORDERBY'] = $order;\n      }\n\n      if ((int)$limit > 0) {\n         $criteria['LIMIT'] = (int)$limit;\n      }\n\n      $data = [];\n      $iterator = $DB->request($criteria);\n      while ($line = $iterator->next()) {\n         $data[$line['id']] = $line;\n      }\n\n      return $data;\n   }\n\n\n   /**\n    * Get the name of the index field\n    *\n    * @return string name of the index field\n   **/\n   static function getIndexName() {\n      return \"id\";\n   }\n\n\n   /**\n    * Get an empty item\n    *\n    *@return boolean true if succeed else false\n   **/\n   function getEmpty() {\n      global $DB;\n\n      //make an empty database object\n      $table = $this->getTable();\n\n      if (!empty($table) &&\n          ($fields = $DB->listFields($table))) {\n\n         foreach (array_keys($fields) as $key) {\n            $this->fields[$key] = \"\";\n         }\n      } else {\n         return false;\n      }\n\n      if (array_key_exists('entities_id', $this->fields)\n          && isset($_SESSION[\"glpiactive_entity\"])) {\n         $this->fields['entities_id'] = $_SESSION[\"glpiactive_entity\"];\n      }\n\n      $this->post_getEmpty();\n\n      // Call the plugin hook - $this->fields can be altered\n      Plugin::doHook(\"item_empty\", $this);\n      return true;\n   }\n\n\n   /**\n    * Actions done at the end of the getEmpty function\n    *\n    * @return void\n   **/\n   function post_getEmpty() {\n   }\n\n\n   /**\n    * Get type to register log on\n    *\n    * @since 0.83\n    *\n    * @return array array of type + ID\n   **/\n   function getLogTypeID() {\n      return [$this->getType(), $this->fields['id']];\n   }\n\n\n   /**\n    * Update the item in the database\n    *\n    * @param string[] $updates   fields to update\n    * @param string[] $oldvalues array of old values of the updated fields\n    *\n    * @return void\n   **/\n   function updateInDB($updates, $oldvalues = []) {\n      global $DB;\n\n      foreach ($updates as $field) {\n         if (isset($this->fields[$field])) {\n            $DB->update(\n               $this->getTable(),\n               [$field => $this->fields[$field]],\n               ['id' => $this->fields['id']]\n            );\n            if ($DB->affectedRows() == 0) {\n               if (isset($oldvalues[$field])) {\n                  unset($oldvalues[$field]);\n               }\n            }\n         } else {\n            // Clean oldvalues\n            if (isset($oldvalues[$field])) {\n               unset($oldvalues[$field]);\n            }\n         }\n\n      }\n\n      if (count($oldvalues)) {\n         Log::constructHistory($this, $oldvalues, $this->fields);\n      }\n\n      return true;\n   }\n\n\n   /**\n    * Add an item to the database\n    *\n    * @return integer|boolean new ID of the item is insert successfull else false\n   **/\n   function addToDB() {\n      global $DB;\n\n      $nb_fields = count($this->fields);\n      if ($nb_fields > 0) {\n         $params = [];\n         foreach ($this->fields as $key => $value) {\n            //FIXME: why is that handled here?\n            if (($this->getType() == 'ProfileRight') && ($value == '')) {\n               $value = 0;\n            }\n            $params[$key] = $value;\n         }\n\n         $result = $DB->insert($this->getTable(), $params);\n         if ($result) {\n            if (!isset($this->fields['id'])\n                  || is_null($this->fields['id'])\n                  || ($this->fields['id'] == 0)) {\n               $this->fields['id'] = $DB->insertId();\n            }\n\n            return $this->fields['id'];\n         }\n      }\n      return false;\n   }\n\n\n   /**\n    * Restore item = set deleted flag to 0\n    *\n    * @return boolean true if succeed else false\n   **/\n   function restoreInDB() {\n      global $DB;\n\n      if ($this->maybeDeleted()) {\n         $params = ['is_deleted' => 0];\n         // Auto set date_mod if exsist\n         if (isset($this->fields['date_mod'])) {\n            $params['date_mod'] = $_SESSION[\"glpi_currenttime\"];\n         }\n\n         if ($DB->update($this->getTable(), $params, ['id' => $this->fields['id']])) {\n            return true;\n         }\n\n      }\n      return false;\n   }\n\n\n   /**\n    * Mark deleted or purge an item in the database\n    *\n    * @param boolean $force force the purge of the item (not used if the table do not have a deleted field)\n    *               (default 0)\n    *\n    * @return boolean true if succeed else false\n   **/\n   function deleteFromDB($force = 0) {\n      global $DB;\n\n      if (($force == 1)\n          || !$this->maybeDeleted()\n          || ($this->useDeletedToLockIfDynamic()\n              && !$this->isDynamic())) {\n         $this->cleanDBonPurge();\n         if ($this instanceof CommonDropdown) {\n            $this->cleanTranslations();\n         }\n         $this->cleanHistory();\n         $this->cleanRelationData();\n         $this->cleanRelationTable();\n\n         $result = $DB->delete(\n            $this->getTable(), [\n               'id' => $this->fields['id']\n            ]\n         );\n         if ($result) {\n            $this->post_deleteFromDB();\n            return true;\n         }\n\n      } else {\n         // Auto set date_mod if exsist\n         $toadd = [];\n         if (isset($this->fields['date_mod'])) {\n            $toadd['date_mod'] = $_SESSION[\"glpi_currenttime\"];\n         }\n\n         $result = $DB->update(\n            $this->getTable(), [\n               'is_deleted' => 1\n            ] + $toadd, [\n               'id' => $this->fields['id']\n            ]\n         );\n         $this->cleanDBonMarkDeleted();\n\n         if ($result) {\n            return true;\n         }\n\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Clean data in the tables which have linked the deleted item\n    *\n    * @return void\n   **/\n   function cleanHistory() {\n      global $DB;\n\n      if ($this->dohistory) {\n         $DB->delete(\n            'glpi_logs', [\n               'itemtype'  => $this->getType(),\n               'items_id'  => $this->fields['id']\n            ]\n         );\n      }\n   }\n\n\n   /**\n    * Clean data in the tables which have linked the deleted item\n    * Clear 1/N Relation\n    *\n    * @return void\n   **/\n   function cleanRelationData() {\n      global $DB, $CFG_GLPI;\n\n      $RELATION = getDbRelations();\n      if (isset($RELATION[$this->getTable()])) {\n         $newval = (isset($this->input['_replace_by']) ? $this->input['_replace_by'] : 0);\n\n         foreach ($RELATION[$this->getTable()] as $tablename => $field) {\n            if ($tablename[0] != '_') {\n\n               $itemtype = getItemTypeForTable($tablename);\n\n               // Code factorization : we transform the singleton to an array\n               if (!is_array($field)) {\n                  $field = [$field];\n               }\n\n               foreach ($field as $f) {\n                  $result = $DB->request(\n                     [\n                        'FROM'  => $tablename,\n                        'WHERE' => [$f => $this->getID()],\n                     ]\n                  );\n                  foreach ($result as $data) {\n                     // Be carefull : we must use getIndexName because self::update rely on that !\n                     if ($object = getItemForItemtype($itemtype)) {\n                        $idName = $object->getIndexName();\n                        // And we must ensure that the index name is not the same as the field\n                        // we try to modify. Otherwise we will loose this element because all\n                        // will be set to $newval ...\n                        if ($idName != $f) {\n                           $object->update([$idName          => $data[$idName],\n                                            $f               => $newval,\n                                            '_disablenotif'  => true]); // Disable notifs\n                        }\n                     }\n                  }\n               }\n\n            }\n         }\n\n      }\n\n      // Clean ticket open against the item\n      if (in_array($this->getType(), $CFG_GLPI[\"ticket_types\"])) {\n         $job         = new Ticket();\n         $itemsticket = new Item_Ticket();\n\n         $iterator = $DB->request([\n            'FROM'   => 'glpi_items_tickets',\n            'WHERE'  => [\n               'items_id'  => $this->getID(),\n               'itemtype'  => $this->getType()\n            ]\n         ]);\n\n         while ($data = $iterator->next()) {\n            $cnt = countElementsInTable('glpi_items_tickets', ['tickets_id' => $data['tickets_id']]);\n            $itemsticket->delete([\"id\" => $data[\"id\"]]);\n            if ($cnt == 1 && !$CFG_GLPI[\"keep_tickets_on_delete\"]) {\n               $job->delete([\"id\" => $data[\"tickets_id\"]]);\n            }\n         }\n\n      }\n   }\n\n\n   /**\n    * Actions done after the DELETE of the item in the database\n    *\n    * @return void\n   **/\n   function post_deleteFromDB() {\n   }\n\n\n   /**\n    * Actions done when item is deleted from the database\n    *\n    * @return void\n   **/\n   function cleanDBonPurge() {\n   }\n\n\n   /**\n    * Delete children items and relation with other items from database.\n    *\n    * @param array $relations_classes List of classname on which deletion will be done\n    *                                 Classes needs to extends CommonDBConnexity.\n    *\n    * @return void\n    **/\n   protected function deleteChildrenAndRelationsFromDb(array $relations_classes) {\n\n      foreach ($relations_classes as $classname) {\n         if (!is_a($classname, CommonDBConnexity::class, true)) {\n            Toolbox::logWarning(\n               sprintf(\n                  'Unable to clean elements of class %s as it does not extends \"CommonDBConnexity\"',\n                  $classname\n               )\n            );\n            continue;\n         }\n\n         /** @var CommonDBConnexity $relation_item */\n         $relation_item = new $classname();\n         $relation_item->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n   }\n\n\n   /**\n    * Clean translations associated to a dropdown\n    *\n    * @since 0.85\n    *\n    * @return void\n   **/\n   function cleanTranslations() {\n\n      //Do not try to clean is dropdown translation is globally off\n      if (DropdownTranslation::isDropdownTranslationActive()) {\n         $translation = new DropdownTranslation();\n         $translation->deleteByCriteria(['itemtype' => get_class($this),\n                                         'items_id' => $this->getID()]);\n      }\n   }\n\n\n   /**\n    * Clean the date in the relation tables for the deleted item\n    * Clear N/N Relation\n    *\n    * @return void\n   **/\n   function cleanRelationTable() {\n      global $CFG_GLPI, $DB;\n\n      // If this type have INFOCOM, clean one associated to purged item\n      if (Infocom::canApplyOn($this)) {\n         $infocom = new Infocom();\n\n         if ($infocom->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n             $infocom->delete(['id' => $infocom->fields['id']]);\n         }\n      }\n\n      // If this type have NETPORT, clean one associated to purged item\n      if (in_array($this->getType(), $CFG_GLPI['networkport_types'])) {\n         // If we don't use delete, then cleanDBonPurge() is not call and the NetworkPorts are not\n         // clean properly\n         $networkPortObject = new NetworkPort();\n         $networkPortObject->cleanDBonItemDelete($this->getType(), $this->getID());\n         // Manage networkportmigration if exists\n         if ($DB->tableExists('glpi_networkportmigrations')) {\n            $networkPortMigObject = new NetworkPortMigration();\n            $networkPortMigObject->cleanDBonItemDelete($this->getType(), $this->getID());\n         }\n      }\n\n      // If this type is RESERVABLE clean one associated to purged item\n      if (in_array($this->getType(), $CFG_GLPI['reservation_types'])) {\n         $rr = new ReservationItem();\n         $rr->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      // If this type have CONTRACT, clean one associated to purged item\n      if (in_array($this->getType(), $CFG_GLPI['contract_types'])) {\n         $ci = new Contract_Item();\n         $ci->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      // If this type have DOCUMENT, clean one associated to purged item\n      if (Document::canApplyOn($this)) {\n         $di = new Document_Item();\n         $di->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      // If this type have NOTEPAD, clean one associated to purged item\n      if ($this->usenotepad) {\n         $note = new Notepad();\n         $note->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      // Delete relations with KB\n      if (in_array($this->getType(), $CFG_GLPI['kb_types'])) {\n         $kbitem_item = new KnowbaseItem_Item();\n         $kbitem_item->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['ticket_types'])) {\n         //delete relation beetween item and changes/problems\n         $this->deleteChildrenAndRelationsFromDb(\n            [\n               Change_Item::class,\n               Item_Problem::class,\n            ]\n         );\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['rackable_types'])) {\n         //delete relation beetween rackable type and its rack\n         $item_rack = new Item_Rack();\n         $item_rack->deleteByCriteria(\n            [\n               'itemtype' => $this->getType(),\n               'items_id' => $this->fields['id']\n            ]\n         );\n\n         $item_enclosure = new Item_Enclosure();\n         $item_enclosure->deleteByCriteria(\n            [\n               'itemtype' => $this->getType(),\n               'items_id' => $this->fields['id']\n            ]\n         );\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['cluster_types'])) {\n         //delete relation beetween clusterable elements type and their cluster\n         $this->deleteChildrenAndRelationsFromDb(\n            [\n               Item_Cluster::class,\n            ]\n         );\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['operatingsystem_types'])) {\n         $this->deleteChildrenAndRelationsFromDb([\n            Item_OperatingSystem::class\n         ]);\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['software_types'])) {\n         $this->deleteChildrenAndRelationsFromDb([\n            Item_SoftwareVersion::class\n         ]);\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['kanban_types'])) {\n         $this->deleteChildrenAndRelationsFromDb([\n            Item_Kanban::class\n         ]);\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['domain_types'])) {\n         $this->deleteChildrenAndRelationsFromDb([\n            Domain_Item::class\n         ]);\n      }\n   }\n\n\n   /**\n    * Actions done when item flag deleted is set to an item\n    *\n    * @return void\n   **/\n   function cleanDBonMarkDeleted() {\n   }\n\n\n   /**\n    * Save the input data in the Session\n    *\n    * @since 0.84\n    *\n    * @return void\n   **/\n   protected function saveInput() {\n      $_SESSION['saveInput'][$this->getType()] = $this->input;\n   }\n\n\n   /**\n    * Clear the saved data stored in the session\n    *\n    * @since 0.84\n    *\n    * @return void\n   **/\n   protected function clearSavedInput() {\n      unset($_SESSION['saveInput'][$this->getType()]);\n   }\n\n\n   /**\n    * Get the data saved in the session\n    *\n    * @since 0.84\n    *\n    * @param array $default Array of value used if session is empty\n    *\n    * @return array Array of value\n   **/\n   protected function restoreInput(Array $default = []) {\n\n      if (isset($_SESSION['saveInput'][$this->getType()])) {\n         $saved = Html::cleanPostForTextArea($_SESSION['saveInput'][$this->getType()]);\n\n         // clear saved data when restored (only need once)\n         $this->clearSavedInput();\n\n         return $saved;\n      }\n\n      return $default;\n   }\n\n\n   // Common functions\n   /**\n    * Add an item in the database with all it's items.\n    *\n    * @param array   $input   the _POST vars returned by the item form when press add\n    * @param array   $options with the insert options\n    *   - unicity_message : do not display message if item it a duplicate (default is yes)\n    * @param boolean $history do history log ? (true by default)\n    *\n    * @return integer the new ID of the added item (or false if fail)\n   **/\n   function add(array $input, $options = [], $history = true) {\n      global $DB, $CFG_GLPI;\n\n      if ($DB->isSlave()) {\n         return false;\n      }\n\n      // This means we are not adding a cloned object\n      if (!isset($input['clone'])) {\n         // This means we are asked to clone the object (old way). This will clone the clone method\n         // that will set the clone parameter to true\n         if (isset($input['_oldID'])) {\n            $id_to_clone = $input['_oldID'];\n         }\n         if (isset($input['id'])) {\n            $id_to_clone = $input['id'];\n         }\n         if (isset($id_to_clone) && $this->getFromDB($id_to_clone)) {\n            return $this->clone($input, $history);\n         }\n      }\n\n      // Store input in the object to be available in all sub-method / hook\n      $this->input = $input;\n\n      // Manage the _no_history\n      if (!isset($this->input['_no_history'])) {\n         $this->input['_no_history'] = !$history;\n      }\n\n      if (isset($this->input['add'])) {\n         // Input from the interface\n         // Save this data to be available if add fail\n         $this->saveInput();\n      }\n\n      // Call the plugin hook - $this->input can be altered\n      // This hook get the data from the form, not yet altered\n      Plugin::doHook(\"pre_item_add\", $this);\n\n      if ($this->input && is_array($this->input)) {\n\n         if (isset($this->input['add'])) {\n            $this->input['_add'] = $this->input['add'];\n            unset($this->input['add']);\n         }\n\n         $this->input = $this->prepareInputForAdd($this->input);\n      }\n\n      if ($this->input && is_array($this->input)) {\n         // Call the plugin hook - $this->input can be altered\n         // This hook get the data altered by the object method\n         Plugin::doHook(\"post_prepareadd\", $this);\n      }\n\n      if ($this->input && is_array($this->input)) {\n         //Check values to inject\n         $this->filterValues(!isCommandLine());\n      }\n\n      //Process business rules for assets\n      $this->assetBusinessRules(\\RuleAsset::ONADD);\n\n      if ($this->input && is_array($this->input)) {\n         $this->fields = [];\n         $table_fields = $DB->listFields($this->getTable());\n\n         // fill array for add\n         foreach (array_keys($this->input) as $key) {\n            if (($key[0] != '_')\n                && isset($table_fields[$key])) {\n               $this->fields[$key] = $this->input[$key];\n            }\n         }\n\n         // Auto set date_creation if exsist\n         if (isset($table_fields['date_creation']) && !isset($this->input['date_creation'])) {\n            $this->fields['date_creation'] = $_SESSION[\"glpi_currenttime\"];\n         }\n\n         // Auto set date_mod if exsist\n         if (isset($table_fields['date_mod']) && !isset($this->input['date_mod'])) {\n            $this->fields['date_mod'] = $_SESSION[\"glpi_currenttime\"];\n         }\n\n         if ($this->checkUnicity(true, $options)) {\n            if ($this->addToDB() !== false) {\n               $this->post_addItem();\n               $this->addMessageOnAddAction();\n\n               if ($this->dohistory && $history) {\n                  $changes = [\n                     0,\n                     '',\n                     '',\n                  ];\n                  Log::history($this->fields[\"id\"], $this->getType(), $changes, 0,\n                               Log::HISTORY_CREATE_ITEM);\n               }\n\n                // Auto create infocoms\n               if (isset($CFG_GLPI[\"auto_create_infocoms\"]) && $CFG_GLPI[\"auto_create_infocoms\"]\n                   && Infocom::canApplyOn($this)) {\n\n                  $ic = new Infocom();\n                  if (!$ic->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n                     $ic->add(['itemtype' => $this->getType(),\n                               'items_id' => $this->fields['id']]);\n                  }\n               }\n\n               // If itemtype is in infocomtype and if states_id field is filled\n               // and item is not a template\n               if (Infocom::canApplyOn($this)\n                   && isset($this->input['states_id'])\n                            && (!isset($this->input['is_template'])\n                                || !$this->input['is_template'])) {\n\n                  //Check if we have to automatical fill dates\n                  Infocom::manageDateOnStatusChange($this);\n               }\n               Plugin::doHook(\"item_add\", $this);\n\n               // As add have suceed, clean the old input value\n               if (isset($this->input['_add'])) {\n                  $this->clearSavedInput();\n               }\n               if ($this->notificationqueueonaction) {\n                  QueuedNotification::forceSendFor($this->getType(), $this->fields['id']);\n               }\n               return $this->fields['id'];\n            }\n         }\n\n      }\n\n      return false;\n   }\n\n   /**\n    * Clones the current item\n    *\n    * @since 9.5\n    *\n    * @param array $override_input custom input to override\n    * @param boolean $history do history log ? (true by default)\n    *\n    * @return integer the new ID of the clone (or false if fail)\n    */\n   function clone(array $override_input = [], bool $history = true) {\n      global $DB, $CFG_GLPI;\n\n      if ($DB->isSlave()) {\n         return false;\n      }\n      $new_item = new static();\n      $input = $this->fields;\n      foreach ($override_input as $key => $value) {\n         $input[$key] = $value;\n      }\n      $input = $new_item->prepareInputForClone($input);\n      if (isset($input['id'])) {\n         $input['_oldID'] =  $input['id'];\n         unset($input['id']);\n      }\n      unset($input['date_creation']);\n      unset($input['date_mod']);\n\n      if (isset($input['template_name'])) {\n         unset($input['template_name']);\n      }\n      if (isset($input['is_template'])) {\n         unset($input['is_template']);\n      }\n\n      $input['clone'] = true;\n      $newID = $new_item->add($input, [], $history);\n      // If the item needs post clone (recursive cloning for example)\n      $new_item->post_clone($this, $history);\n      return $newID;\n   }\n\n\n   /**\n    * Get the link to an item\n    *\n    * @param array $options array of options\n    *    - comments     : boolean / display comments\n    *    - complete     : boolean / display completename instead of name\n    *    - additional   : boolean / display additionals information\n    *    - linkoption   : string  / additional options to add to <a>\n    *\n    * @return string HTML link\n   **/\n   function getLink($options = []) {\n\n      $p = [\n         'linkoption' => '',\n      ];\n\n      if (isset($options['linkoption'])) {\n         $p['linkoption'] = $options['linkoption'];\n      }\n\n      if (!isset($this->fields['id'])) {\n         return '';\n      }\n\n      if ($this->no_form_page\n          || !$this->can($this->fields['id'], READ)) {\n         return $this->getNameID($options);\n      }\n\n      $link = $this->getLinkURL();\n\n      $label = $this->getNameID($options);\n      $title = '';\n      if (!preg_match('/title=/', $p['linkoption'])) {\n         $thename = $this->getName(['complete' => true]);\n         if ($thename != NOT_AVAILABLE) {\n            $title = ' title=\"' . htmlentities($thename, ENT_QUOTES, 'utf-8') . '\"';\n         }\n      }\n\n      return \"<a \".$p['linkoption'].\" href='$link' $title>$label</a>\";\n   }\n\n\n   /**\n    * Get the link url to an item\n    *\n    * @return string HTML link\n   **/\n   function getLinkURL() {\n\n      if (!isset($this->fields['id'])) {\n         return '';\n      }\n\n      $link  = $this->getFormURLWithID($this->getID());\n      $link .= ($this->isTemplate() ? \"&withtemplate=1\" : \"\");\n\n      return $link;\n   }\n\n\n   /**\n    * Add a message on add action\n    *\n    * @return void\n   **/\n   function addMessageOnAddAction() {\n\n      $addMessAfterRedirect = false;\n      if (isset($this->input['_add'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         if ($this->getName() == NOT_AVAILABLE) {\n            //TRANS: %1$s is the itemtype, %2$d is the id of the item\n            $this->fields['name'] = sprintf(__('%1$s - ID %2$d'),\n                                            $this->getTypeName(1), $this->fields['id']);\n         }\n         $display = (isset($this->input['_no_message_link'])?$this->getNameID()\n                                                            :$this->getLink());\n\n         // Do not display quotes\n         //TRANS : %s is the description of the added item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully added'),\n                                                  stripslashes($display)));\n\n      }\n   }\n\n\n   /**\n    * Add needed information to $input (example entities_id)\n    *\n    * @param array $input datas used to add the item\n    *\n    * @since 0.84\n    *\n    * @return array the modified $input array\n   **/\n   function addNeededInfoToInput($input) {\n      return $input;\n   }\n\n\n   /**\n    * Prepare input datas for adding the item\n    *\n    * @param array $input datas used to add the item\n    *\n    * @return array the modified $input array\n   **/\n   function prepareInputForAdd($input) {\n      return $input;\n   }\n\n    /**\n    * Prepare input datas for cloning the item\n    *\n    * @since 9.5\n    *\n    * @param array $input datas used to add the item\n    *\n    * @return array the modified $input array\n   **/\n   function prepareInputForClone($input) {\n      return $input;\n   }\n\n\n   /**\n    * Actions done after the ADD of the item in the database\n    *\n    * @return void\n   **/\n   function post_addItem() {\n   }\n\n   /**\n    * Actions done after the clone of the item in the database\n    *\n    * @since 9.5\n    *\n    * @param $source the item that is being cloned\n    * @param $history do history log ?\n    *\n    * @return void\n   **/\n   function post_clone($source, $history) {\n   }\n\n\n   /**\n    * Update some elements of an item in the database.\n    *\n    * @param array   $input   the _POST vars returned by the item form when press update\n    * @param boolean $history do history log ? (default 1)\n    * @param array   $options with the insert options\n    *\n    * @return boolean true on success\n   **/\n   function update(array $input, $history = 1, $options = []) {\n      global $DB, $GLPI_CACHE;\n\n      if ($DB->isSlave()) {\n         return false;\n      }\n\n      if (!$this->getFromDB($input[static::getIndexName()])) {\n         return false;\n      }\n\n      // Store input in the object to be available in all sub-method / hook\n      $this->input = $input;\n\n      // Manage the _no_history\n      if (!isset($this->input['_no_history'])) {\n         $this->input['_no_history'] = !$history;\n      }\n\n      // Plugin hook - $this->input can be altered\n      Plugin::doHook(\"pre_item_update\", $this);\n      if ($this->input && is_array($this->input)) {\n         $this->input = $this->prepareInputForUpdate($this->input);\n\n         if (isset($this->input['update'])) {\n            $this->input['_update'] = $this->input['update'];\n            unset($this->input['update']);\n         }\n         $this->filterValues(!isCommandLine());\n      }\n\n      //Process business rules for assets\n      $this->assetBusinessRules(\\RuleAsset::ONUPDATE);\n\n      // Valid input for update\n      if ($this->checkUnicity(false, $options)) {\n         if ($this->input && is_array($this->input)) {\n            // Fill the update-array with changes\n            $x               = 0;\n            $this->updates   = [];\n            $this->oldvalues = [];\n\n            foreach (array_keys($this->input) as $key) {\n               if (array_key_exists($key, $this->fields)) {\n\n                  // Prevent history for date statement (for date for example)\n                  if (is_null($this->fields[$key])\n                      && ($this->input[$key] == 'NULL')) {\n                     $this->fields[$key] = 'NULL';\n                  }\n                  // Compare item\n                  $ischanged = true;\n                  $searchopt = $this->getSearchOptionByField('field', $key, $this->getTable());\n                  if (isset($searchopt['datatype'])) {\n                     switch ($searchopt['datatype']) {\n                        case 'string' :\n                        case 'text' :\n                           $ischanged = (strcmp($DB->escape($this->fields[$key]),\n                                                $this->input[$key]) != 0);\n                           break;\n\n                        case 'itemlink' :\n                           if ($key == 'name') {\n                              $ischanged = (strcmp($DB->escape($this->fields[$key]),\n                                                               $this->input[$key]) != 0);\n                              break;\n                           } // else default\n\n                        default :\n                           $ischanged = ($DB->escape($this->fields[$key]) != $this->input[$key]);\n                           break;\n                     }\n                  } else {\n                     // No searchoption case\n                     $ischanged = ($DB->escape($this->fields[$key]) != $this->input[$key]);\n\n                  }\n                  if ($ischanged) {\n                     if ($key != \"id\") {\n\n                        // Store old values\n                        if (!in_array($key, $this->history_blacklist)) {\n                           $this->oldvalues[$key] = $this->fields[$key];\n                        }\n\n                        $this->fields[$key] = $this->input[$key];\n                        $this->updates[$x]  = $key;\n                        $x++;\n                     }\n                  }\n\n               }\n            }\n            if (count($this->updates)) {\n               if (array_key_exists('date_mod', $this->fields)) {\n                  // is a non blacklist field exists\n                  if (count(array_diff($this->updates, $this->history_blacklist)) > 0) {\n                     $this->fields['date_mod'] = $_SESSION[\"glpi_currenttime\"];\n                     $this->updates[$x++]      = 'date_mod';\n                  }\n               }\n               $this->pre_updateInDB();\n\n               if (count($this->updates)) {\n                  if ($this->updateInDB($this->updates,\n                                        ($this->dohistory && $history ? $this->oldvalues\n                                                                      : []))) {\n                     $this->addMessageOnUpdateAction();\n                     Plugin::doHook(\"item_update\", $this);\n\n                     //Fill forward_entity_to array with itemtypes coming from plugins\n                     if (isset(self::$plugins_forward_entity[$this->getType()])) {\n                        foreach (self::$plugins_forward_entity[$this->getType()] as $itemtype) {\n                           static::$forward_entity_to[] = $itemtype;\n                        }\n                     }\n                     // forward entity information if needed\n                     if (count(static::$forward_entity_to)\n                         && (in_array(\"entities_id\", $this->updates)\n                             || in_array(\"is_recursive\", $this->updates))) {\n                        $this->forwardEntityInformations();\n                     }\n\n                     // If itemtype is in infocomtype and if states_id field is filled\n                     // and item not a template\n                     if (Infocom::canApplyOn($this)\n                         && in_array('states_id', $this->updates)\n                         && ($this->getField('is_template') != NOT_AVAILABLE)) {\n                        //Check if we have to automatical fill dates\n                        Infocom::manageDateOnStatusChange($this, false);\n                     }\n                  }\n               }\n            }\n            $this->post_updateItem($history);\n\n            if ($this->notificationqueueonaction) {\n               QueuedNotification::forceSendFor($this->getType(), $this->fields['id']);\n            }\n\n            return true;\n         }\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Forward entity information to linked items\n    *\n    * @return void\n   **/\n   protected function forwardEntityInformations() {\n      global $DB;\n\n      if (!isset($this->fields['id']) || !($this->fields['id'] >= 0)) {\n         return false;\n      }\n\n      if (count(static::$forward_entity_to)) {\n         foreach (static::$forward_entity_to as $type) {\n            $item  = new $type();\n            $query = [\n               'SELECT' => ['id'],\n               'FROM'   => $item->getTable()\n            ];\n\n            $OR = [];\n            if ($item->isField('itemtype')) {\n               $OR[] = [\n                  'itemtype'  => $this->getType(),\n                  'items_id'  => $this->getID()\n               ];\n            }\n            if ($item->isField($this->getForeignKeyField())) {\n               $OR[] = [$this->getForeignKeyField() => $this->getID()];\n            }\n            $query['WHERE'][] = ['OR' => $OR];\n\n            $input = [\n               'entities_id'  => $this->getEntityID(),\n               '_transfer'    => 1\n            ];\n            if ($this->maybeRecursive()) {\n               $input['is_recursive'] = $this->isRecursive();\n            }\n\n            $iterator = $DB->request($query);\n            while ($data = $iterator->next()) {\n               $input['id'] = $data['id'];\n               // No history for such update\n               $item->update($input, 0);\n            }\n         }\n      }\n   }\n\n\n   /**\n    * Add a message on update action\n    *\n    * @return void\n   **/\n   function addMessageOnUpdateAction() {\n\n      $addMessAfterRedirect = false;\n\n      if (isset($this->input['_update'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         // Do not display quotes\n         if (isset($this->fields['name'])) {\n            $this->fields['name'] = stripslashes($this->fields['name']);\n         } else {\n            //TRANS: %1$s is the itemtype, %2$d is the id of the item\n            $this->fields['name'] = sprintf(__('%1$s - ID %2$d'),\n                                            $this->getTypeName(1), $this->fields['id']);\n         }\n\n         if (isset($this->input['_no_message_link'])) {\n            $display = $this->getNameID();\n         } else {\n            $display = $this->getLink();\n         }\n         //TRANS : %s is the description of the updated item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully updated'), $display));\n\n      }\n\n   }\n\n\n   /**\n    * Prepare input datas for updating the item\n    *\n    * @param array $input data used to update the item\n    *\n    * @return array the modified $input array\n   **/\n   function prepareInputForUpdate($input) {\n      return $input;\n   }\n\n\n   /**\n    * Actions done after the UPDATE of the item in the database\n    *\n    * @param boolean $history store changes history ? (default 1)\n    *\n    * @return void\n   **/\n   function post_updateItem($history = 1) {\n   }\n\n\n   /**\n    * Actions done before the UPDATE of the item in the database\n    *\n    * @return void\n   **/\n   function pre_updateInDB() {\n   }\n\n\n   /**\n    * Delete an item in the database.\n    *\n    * @param array   $input   the _POST vars returned by the item form when press delete\n    * @param boolean $force   force deletion (default 0)\n    * @param boolean $history do history log ? (default 1)\n    *\n    * @return boolean true on success\n   **/\n   function delete(array $input, $force = 0, $history = 1) {\n      global $DB;\n\n      if ($DB->isSlave()) {\n         return false;\n      }\n\n      if (!$this->getFromDB($input[static::getIndexName()])) {\n         return false;\n      }\n\n      // Force purge for templates / may not to be deleted / not dynamic lockable items\n      if ($this->isTemplate()\n          || !$this->maybeDeleted()\n          // Do not take into account deleted field if maybe dynamic but not dynamic\n          || ($this->useDeletedToLockIfDynamic()\n              && !$this->isDynamic())) {\n         $force = 1;\n      }\n\n      // Store input in the object to be available in all sub-method / hook\n      $this->input = $input;\n\n      if (isset($this->input['purge'])) {\n         $this->input['_purge'] = $this->input['purge'];\n         unset($this->input['purge']);\n      } else if ($force) {\n         $this->input['_purge'] = 1;\n         $this->input['_no_message'] = $this->input['_no_message'] ?? 1;\n      }\n\n      if (isset($this->input['delete'])) {\n         $this->input['_delete'] = $this->input['delete'];\n         unset($this->input['delete']);\n      } else if (!$force) {\n         $this->input['_delete'] = 1;\n         $this->input['_no_message'] = $this->input['_no_message'] ?? 1;\n      }\n\n      if (!isset($this->input['_no_history'])) {\n         $this->input['_no_history'] = !$history;\n      }\n\n      // Purge\n      if ($force) {\n         Plugin::doHook(\"pre_item_purge\", $this);\n      } else {\n         Plugin::doHook(\"pre_item_delete\", $this);\n      }\n\n      if (!is_array($this->input)) {\n         // $input clear by a hook to cancel delete\n         return false;\n      }\n\n      if ($this->pre_deleteItem()) {\n\n         if ($this->deleteFromDB($force)) {\n\n            if ($force) {\n               $this->addMessageOnPurgeAction();\n               $this->post_purgeItem();\n               Plugin::doHook(\"item_purge\", $this);\n               Impact::clean($this);\n            } else {\n               $this->addMessageOnDeleteAction();\n\n               if ($this->dohistory && $history) {\n                  $changes = [\n                     0,\n                     '',\n                     '',\n                  ];\n                  $logaction  = Log::HISTORY_DELETE_ITEM;\n                  if ($this->useDeletedToLockIfDynamic()\n                      && $this->isDynamic()) {\n                     $logaction = Log::HISTORY_LOCK_ITEM;\n                  }\n\n                  Log::history($this->fields[\"id\"], $this->getType(), $changes, 0,\n                               $logaction);\n               }\n               $this->post_deleteItem();\n\n               Plugin::doHook(\"item_delete\", $this);\n            }\n            if ($this->notificationqueueonaction) {\n               QueuedNotification::forceSendFor($this->getType(), $this->fields['id']);\n            }\n\n            return true;\n         }\n\n      }\n      return false;\n   }\n\n\n   /**\n    * Actions done after the DELETE (mark as deleted) of the item in the database\n    *\n    * @return void\n   **/\n   function post_deleteItem() {\n   }\n\n\n   /**\n    * Actions done after the PURGE of the item in the database\n    *\n    * @return void\n   **/\n   function post_purgeItem() {\n   }\n\n\n   /**\n    * Add a message on delete action\n    *\n    * @return void\n   **/\n   function addMessageOnDeleteAction() {\n\n      if (!$this->maybeDeleted()) {\n         return;\n      }\n\n      $addMessAfterRedirect = false;\n      if (isset($this->input['_delete'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         if (isset($this->input['_no_message_link'])) {\n            $display = $this->getNameID();\n         } else {\n            $display = $this->getLink();\n         }\n         //TRANS : %s is the description of the updated item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully deleted'), $display));\n\n      }\n   }\n\n\n   /**\n    * Add a message on purge action\n    *\n    * @return void\n   **/\n   function addMessageOnPurgeAction() {\n\n      $addMessAfterRedirect = false;\n\n      if (isset($this->input['_purge'])\n          || isset($this->input['_delete'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_purge'])) {\n         $this->input['_no_message_link'] = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         if (isset($this->input['_no_message_link'])) {\n            $display = $this->getNameID();\n         } else {\n            $display = $this->getLink();\n         }\n          //TRANS : %s is the description of the updated item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully purged'),\n                                                  $display));\n      }\n   }\n\n\n   /**\n    * Actions done before the DELETE of the item in the database /\n    * Maybe used to add another check for deletion\n    *\n    * @return boolean true if item need to be deleted else false\n   **/\n   function pre_deleteItem() {\n      return true;\n   }\n\n\n   /**\n    * Restore an item put in the trashbin in the database.\n    *\n    * @param array   $input   the _POST vars returned by the item form when press restore\n    * @param boolean $history do history log ? (default 1)\n    *\n    * @return boolean true on success\n   **/\n   function restore(array $input, $history = 1) {\n\n      if (!$this->getFromDB($input[static::getIndexName()])) {\n         return false;\n      }\n\n      if (isset($input['restore'])) {\n         $input['_restore'] = $input['restore'];\n         unset($input['restore']);\n      } else {\n         $this->input['_restore'] = 1;\n         $this->input['_no_message'] = $this->input['_no_message'] ?? 1;\n      }\n\n      // Store input in the object to be available in all sub-method / hook\n      $this->input = $input;\n      Plugin::doHook(\"pre_item_restore\", $this);\n      if (!is_array($this->input)) {\n         // $input clear by a hook to cancel retore\n         return false;\n      }\n\n      if ($this->restoreInDB()) {\n         $this->addMessageOnRestoreAction();\n\n         if ($this->dohistory && $history) {\n            $changes = [\n               0,\n               '',\n               '',\n            ];\n            $logaction  = Log::HISTORY_RESTORE_ITEM;\n            if ($this->useDeletedToLockIfDynamic()\n                && $this->isDynamic()) {\n               $logaction = Log::HISTORY_UNLOCK_ITEM;\n            }\n            Log::history($this->input[\"id\"], $this->getType(), $changes, 0, $logaction);\n         }\n\n         $this->post_restoreItem();\n         Plugin::doHook(\"item_restore\", $this);\n         if ($this->notificationqueueonaction) {\n            QueuedNotification::forceSendFor($this->getType(), $this->fields['id']);\n         }\n         return true;\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Actions done after the restore of the item\n    *\n    * @return void\n   **/\n   function post_restoreItem() {\n   }\n\n\n   /**\n    * Add a message on restore action\n    *\n    * @return void\n   **/\n   function addMessageOnRestoreAction() {\n\n      $addMessAfterRedirect = false;\n      if (isset($this->input['_restore'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         if (isset($this->input['_no_message_link'])) {\n            $display = $this->getNameID();\n         } else {\n            $display = $this->getLink();\n         }\n         //TRANS : %s is the description of the updated item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully restored'), $display));\n      }\n   }\n\n\n   /**\n    * Reset fields of the item\n    *\n    * @return void\n   **/\n   function reset() {\n      $this->fields = [];\n   }\n\n\n   /**\n    * Have I the global right to add an item for the Object\n    * May be overloaded if needed (ex Ticket)\n    *\n    * @since 0.83\n    *\n    * @param string $type itemtype of object to add\n    *\n    * @return boolean\n   **/\n   function canAddItem($type) {\n      return $this->can($this->getID(), UPDATE);\n   }\n\n\n   /**\n    * Have I the right to \"create\" the Object\n    *\n    * Default is true and check entity if the objet is entity assign\n    *\n    * May be overloaded if needed\n    *\n    * @return boolean\n    **/\n   function canCreateItem() {\n\n      if (!$this->checkEntity()) {\n         return false;\n      }\n      return true;\n   }\n\n\n   /**\n    * Have I the right to \"update\" the Object\n    *\n    * Default is true and check entity if the objet is entity assign\n    *\n    * May be overloaded if needed\n    *\n    * @return boolean\n   **/\n   function canUpdateItem() {\n\n      if (!$this->checkEntity()) {\n         return false;\n      }\n      return true;\n   }\n\n\n   /**\n    * Have I the right to \"delete\" the Object\n    *\n    * Default is true and check entity if the objet is entity assign\n    *\n    * May be overloaded if needed\n    *\n    * @return boolean\n   **/\n   function canDeleteItem() {\n\n      if (!$this->checkEntity()) {\n         return false;\n      }\n      return true;\n   }\n\n\n   /**\n    * Have I the right to \"purge\" the Object\n    *\n    * Default is true and check entity if the objet is entity assign\n    *\n    * @since 0.85\n    *\n    * @return boolean\n   **/\n   function canPurgeItem() {\n\n      if (!$this->checkEntity()) {\n         return false;\n      }\n\n      // Can purge an object with Infocom only if can purge Infocom\n      if (Infocom::canApplyOn($this)) {\n         $infocom = new Infocom();\n\n         if ($infocom->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n            return $infocom->canPurge();\n         }\n      }\n      return true;\n   }\n\n\n   /**\n    * Have I the right to \"view\" the Object\n    * May be overloaded if needed\n    *\n    * @return boolean\n   **/\n   function canViewItem() {\n\n      if (!$this->checkEntity(true)) {\n         return false;\n      }\n\n      // else : Global item\n      return true;\n   }\n\n\n   /**\n    * Have i right to see action button\n    *\n    * @param integer $ID ID to check\n    *\n    * @since 0.85\n    *\n    * @return boolean\n   **/\n   function canEdit($ID) {\n\n      if ($this->maybeDeleted()) {\n         return ($this->can($ID, CREATE)\n                 || $this->can($ID, UPDATE)\n                 || $this->can($ID, DELETE)\n                 || $this->can($ID, PURGE));\n      }\n      return ($this->can($ID, CREATE)\n              || $this->can($ID, UPDATE)\n              || $this->can($ID, PURGE));\n   }\n\n\n   /**\n    * Can I change recursive flag to false\n    * check if there is \"linked\" object in another entity\n    *\n    * May be overloaded if needed\n    *\n    * @return boolean\n   **/\n   function canUnrecurs() {\n      global $DB;\n\n      $ID  = $this->fields['id'];\n      if (($ID < 0)\n          || !$this->fields['is_recursive']) {\n         return true;\n      }\n\n      $entities = getAncestorsOf('glpi_entities', $this->fields['entities_id']);\n      $entities[] = $this->fields['entities_id'];\n      $RELATION  = getDbRelations();\n\n      if ($this instanceof CommonTreeDropdown) {\n         $f = getForeignKeyFieldForTable($this->getTable());\n\n         if (countElementsInTable($this->getTable(),\n                                  [ $f => $ID, 'NOT' => [ 'entities_id' => $entities ]]) > 0) {\n            return false;\n         }\n      }\n\n      if (isset($RELATION[$this->getTable()])) {\n         foreach ($RELATION[$this->getTable()] as $tablename => $field) {\n            if ($tablename[0] != '_') {\n\n               $itemtype = getItemTypeForTable($tablename);\n               $item     = new $itemtype();\n\n               if ($item->isEntityAssign()) {\n\n                  // 1->N Relation\n                  if (is_array($field)) {\n                     foreach ($field as $f) {\n                        if (countElementsInTable($tablename,\n                                                 [ $f => $ID, 'NOT' => [ 'entities_id' => $entities ]]) > 0) {\n                           return false;\n                        }\n                     }\n\n                  } else {\n                     if (countElementsInTable($tablename,\n                                              [ $field => $ID, 'NOT' => [ 'entities_id' => $entities ]]) > 0) {\n                        return false;\n                     }\n                  }\n\n               } else {\n                  foreach ($RELATION as $othertable => $rel) {\n                     // Search for a N->N Relation with devices\n                     if (($othertable == \"_virtual_device\")\n                         && isset($rel[$tablename])) {\n                        $devfield  = $rel[$tablename][0]; // items_id...\n                        $typefield = $rel[$tablename][1]; // itemtype...\n\n                        $iterator = $DB->request([\n                           'SELECT'          => $typefield,\n                           'DISTINCT'        => true,\n                           'FROM'            => $tablename,\n                           'WHERE'           => [$field => $ID]\n                        ]);\n\n                        // Search linked device of each type\n                        while ($data = $iterator->next()) {\n                           $itemtype  = $data[$typefield];\n                           $itemtable = getTableForItemType($itemtype);\n                           $item      = new $itemtype();\n\n                           if ($item->isEntityAssign()) {\n                              if (countElementsInTable([$tablename, $itemtable],\n                                                         [\"$tablename.$field\"     => $ID,\n                                                         \"$tablename.$typefield\" => $itemtype,\n                                                         'FKEY' => [$tablename => $devfield, $itemtable => 'id'],\n                                                         'NOT'  => [$itemtable.'.entities_id' => $entities ]]) > '0') {\n                                 return false;\n                              }\n                           }\n                        }\n\n                     } else if (($othertable != $this->getTable())\n                              && isset($rel[$tablename])) {\n\n                        // Search for another N->N Relation\n                        $itemtype = getItemTypeForTable($othertable);\n                        $item     = new $itemtype();\n\n                        if ($item->isEntityAssign()) {\n                           if (is_array($rel[$tablename])) {\n                              foreach ($rel[$tablename] as $otherfield) {\n                                 if (countElementsInTable([$tablename, $othertable],\n                                                          [\"$tablename.$field\" => $ID,\n                                                           'FKEY' => [$tablename => $otherfield, $othertable => 'id'],\n                                                           'NOT'  => [$othertable.'.entities_id' => $entities ]]) > '0') {\n                                    return false;\n                                 }\n                              }\n\n                           } else {\n                              $otherfield = $rel[$tablename];\n                              if (countElementsInTable([$tablename, $othertable],\n                                                       [\"$tablename.$field\" => $ID,\n                                                        'FKEY' => [$tablename => $otherfield, $othertable =>'id'],\n                                                        'NOT'  => [ $othertable.'.entities_id' => $entities ]]) > '0') {\n                                 return false;\n                              }\n                           }\n\n                        }\n                     }\n                  }\n               }\n            }\n         }\n      }\n\n      // Doc links to this item\n      if (($this->getType() > 0)\n          && countElementsInTable(['glpi_documents_items', 'glpi_documents'],\n                                  ['glpi_documents_items.items_id'=> $ID,\n                                   'glpi_documents_items.itemtype'=> $this->getType(),\n                                   'FKEY' => ['glpi_documents_items' => 'documents_id','glpi_documents' => 'id'],\n                                   'NOT'  => ['glpi_documents.entities_id' => $entities]]) > '0') {\n         return false;\n      }\n      // TODO : do we need to check all relations in $RELATION[\"_virtual_device\"] for this item\n\n      // check connections of a computer\n      $connectcomputer = ['Monitor', 'Peripheral', 'Phone', 'Printer'];\n      if (in_array($this->getType(), $connectcomputer)) {\n         return Computer_Item::canUnrecursSpecif($this, $entities);\n      }\n      return true;\n   }\n\n\n   /**\n    * check if this action can be done on this field of this item by massive actions\n    *\n    * @since 0.83\n    *\n    * @param string  $action name of the action\n    * @param integer $field  id of the field\n    * @param string  $value  value of the field\n    *\n    * @return boolean\n   **/\n   function canMassiveAction($action, $field, $value) {\n      return true;\n   }\n\n\n   /**\n    * @since 9.1\n    *\n    * @param array $options Options\n    *\n    * @return boolean\n   **/\n   function showDates($options = []) {\n\n      $isNewID = ((isset($options['withtemplate']) && ($options['withtemplate'] == 2))\n         || $this->isNewID($this->getID()));\n\n      if ($isNewID) {\n         return true;\n      }\n\n      $date_creation_exists = ($this->getField('date_creation') != NOT_AVAILABLE);\n      $date_mod_exists = ($this->getField('date_mod') != NOT_AVAILABLE);\n\n      $colspan = $options['colspan'];\n      if ((!isset($options['withtemplate']) || ($options['withtemplate'] == 0))\n          && !empty($this->fields['template_name'])) {\n         $colspan = 1;\n      }\n\n      echo \"<tr class='tab_bg_1 footerRow'>\";\n      //Display when it's not a new asset being created\n      if ($date_creation_exists\n         && $this->getID() > 0\n            && (!isset($options['withtemplate']) || $options['withtemplate'] == 0)) {\n         echo \"<th colspan='$colspan'>\";\n         printf(__('Created on %s'), Html::convDateTime($this->fields[\"date_creation\"]));\n         echo \"</th>\";\n      } else if (!isset($options['withtemplate']) || $options['withtemplate'] == 0) {\n         echo \"<th colspan='$colspan'>\";\n         echo \"</th>\";\n      }\n\n      if (isset($options['withtemplate']) && $options['withtemplate']) {\n         echo \"<th colspan='$colspan'>\";\n         //TRANS: %s is the datetime of insertion\n         printf(__('Created on %s'), Html::convDateTime($_SESSION[\"glpi_currenttime\"]));\n         echo \"</th>\";\n      }\n\n      if ($date_mod_exists) {\n         echo \"<th colspan='$colspan'>\";\n         //TRANS: %s is the datetime of update\n         printf(__('Last update on %s'), Html::convDateTime($this->fields[\"date_mod\"]));\n         echo \"</th>\";\n      } else {\n         echo \"<th colspan='$colspan'>\";\n         echo \"</th>\";\n      }\n\n      if ((!isset($options['withtemplate']) || ($options['withtemplate'] == 0))\n          && !empty($this->fields['template_name'])) {\n         echo \"<th colspan='\".($colspan * 2).\"'>\";\n         printf(__('Created from the template %s'), $this->fields['template_name']);\n         echo \"</th>\";\n      }\n\n      echo \"</tr>\";\n   }\n\n   /**\n    * Display a 2 columns Footer for Form buttons\n    * Close the form is user can edit\n    *\n    * @param array $options array of possible options:\n    *     - withtemplate : 1 for newtemplate, 2 for newobject from template\n    *     - colspan for each column (default 2)\n    *     - candel : set to false to hide \"delete\" button\n    *     - canedit : set to false to hide all buttons\n    *     - addbuttons : array of buttons to add\n    *\n    * @return void\n   **/\n   function showFormButtons($options = []) {\n\n      // for single object like config\n      if (isset($this->fields['id'])) {\n         $ID = $this->fields['id'];\n      } else {\n         $ID = 1;\n      }\n\n      $params = [\n         'colspan'      => 2,\n         'withtemplate' => '',\n         'candel'       => true,\n         'canedit'      => true,\n         'addbuttons'   => [],\n         'formfooter'   => null,\n      ];\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $val) {\n            $params[$key] = $val;\n         }\n      }\n\n      Plugin::doHook(\"post_item_form\", ['item' => $this, 'options' => &$params]);\n\n      if ($params['formfooter'] === null) {\n          $this->showDates($params);\n      }\n\n      if (!$params['canedit']\n          || !$this->canEdit($ID)) {\n         echo \"</table></div>\";\n         // Form Header always open form\n         Html::closeForm();\n         return false;\n      }\n\n      echo \"<tr class='tab_bg_2'>\";\n\n      if ($params['withtemplate']\n          ||$this->isNewID($ID)) {\n\n         echo \"<td class='center' colspan='\".($params['colspan']*2).\"'>\";\n\n         if (($ID <= 0) || ($params['withtemplate'] == 2)) {\n            echo Html::submit(\n               \"<i class='fas fa-plus'></i>&nbsp;\"._x('button', 'Add'),\n               ['name' => 'add']\n            );\n         } else {\n            //TRANS : means update / actualize\n            echo Html::submit(\n               \"<i class='fas fa-save'></i>&nbsp;\"._x('button', 'Save'),\n               ['name' => 'update']\n            );\n         }\n\n      } else {\n         if ($params['candel']\n             && !$this->can($ID, DELETE)\n             && !$this->can($ID, PURGE)) {\n            $params['candel'] = false;\n         }\n\n         if ($params['canedit'] && $this->can($ID, UPDATE)) {\n            echo \"<td class='center' colspan='\".($params['colspan']*2).\"'>\\n\";\n            echo Html::submit(\n               \"<i class='fas fa-save'></i>&nbsp;\"._x('button', 'Save'),\n               ['name' => 'update']\n            );\n         }\n\n         if ($params['candel']) {\n            if ($params['canedit'] && $this->can($ID, UPDATE)) {\n               echo \"</td></tr><tr class='tab_bg_2'>\\n\";\n            }\n            if ($this->isDeleted()) {\n               if ($this->can($ID, DELETE)) {\n                  echo \"<td class='right' colspan='\".($params['colspan']*2).\"' >\\n\";\n                  echo Html::submit(\n                     \"<i class='fas fa-trash-restore'></i>&nbsp;\"._x('button', 'Restore'),\n                     ['name' => 'restore']\n                  );\n               }\n\n               if ($this->can($ID, PURGE)) {\n                  echo \"<span class='very_small_space'>\";\n                  if (in_array($this->getType(), Item_Devices::getConcernedItems())) {\n                     Html::showToolTip(__('Check to keep the devices while deleting this item'));\n                     echo \"&nbsp;\";\n                     echo \"<input type='checkbox' name='keep_devices' value='1'\";\n                     if (!empty($_SESSION['glpikeep_devices_when_purging_item'])) {\n                        echo \" checked\";\n                     }\n                     echo \">&nbsp;\";\n                  }\n                  echo Html::submit(\n                     \"<i class='fas fa-trash-alt'></i>&nbsp;\"._x('button', 'Delete permanently'),\n                     ['name' => 'purge']\n                  );\n                  echo \"</span>\";\n               }\n\n            } else {\n               echo \"<td class='right' colspan='\".($params['colspan']*2).\"' >\\n\";\n               // If maybe dynamic : do not take into account  is_deleted  field\n               if (!$this->maybeDeleted()\n                   || $this->useDeletedToLockIfDynamic()) {\n                  if ($this->can($ID, PURGE)) {\n                     echo Html::submit(\n                        \"<i class='fas fa-trash-alt'></i>&nbsp;\"._x('button', 'Delete permanently'),\n                        [\n                           'name'    => 'purge',\n                           'confirm' => __('Confirm the final deletion?')\n                        ]\n                     );\n                  }\n               } else if (!$this->isDeleted()\n                          && $this->can($ID, DELETE)) {\n                  echo Html::submit(\n                     \"<i class='fas fa-trash-alt'></i>&nbsp;\"._x('button', 'Put in trashbin'),\n                     ['name' => 'delete']\n                  );\n               }\n            }\n\n         }\n         if ($this->isField('date_mod')) {\n            echo \"<input type='hidden' name='_read_date_mod' value='\".$this->getField('date_mod').\"'>\";\n         }\n      }\n\n      if (!$this->isNewID($ID)) {\n         echo \"<input type='hidden' name='id' value='$ID'>\";\n      }\n      echo \"</td>\";\n      echo \"</tr>\\n\";\n\n      if ($params['canedit']\n          && count($params['addbuttons'])) {\n         echo \"<tr class='tab_bg_2'>\";\n         echo \"<td class='right' colspan='\".($params['colspan']*2).\"'>\";\n         foreach ($params['addbuttons'] as $key => $val) {\n            echo \"<button type='submit' class='vsubmit' name='$key' value='1'>\n                  $val\n               </button>&nbsp;\";\n         }\n         echo \"</td>\";\n         echo \"</tr>\";\n      }\n\n      // Close for Form\n      echo \"</table></div>\";\n      Html::closeForm();\n   }\n\n\n   /**\n    * Initialize item and check right before managing the edit form\n    *\n    * @since 0.84\n    *\n    * @param integer $ID      ID of the item/template\n    * @param array   $options Array of possible options:\n    *     - withtemplate : 1 for newtemplate, 2 for newobject from template\n    *\n    * @return integer|void value of withtemplate option (exit of no right)\n   **/\n   function initForm($ID, Array $options = []) {\n\n      if (isset($options['withtemplate'])\n          && ($options['withtemplate'] == 2)\n          && !$this->isNewID($ID)) {\n         // Create item from template\n         // Check read right on the template\n         $this->check($ID, READ);\n\n         // Restore saved input or template data\n         $input = $this->restoreInput($this->fields);\n\n         // If entity assign force current entity to manage recursive templates\n         if ($this->isEntityAssign()) {\n            $input['entities_id'] = $_SESSION['glpiactive_entity'];\n         }\n\n         // Check create right\n         $this->check(-1, CREATE, $input);\n\n      } else if ($this->isNewID($ID)) {\n         // Restore saved input if available\n         $input = $this->restoreInput($options);\n         // Create item\n         $this->check(-1, CREATE, $input);\n      } else {\n         // Existing item\n         $this->check($ID, READ);\n      }\n\n      return (isset($options['withtemplate']) ? $options['withtemplate'] : '');\n   }\n\n\n   /**\n    *\n    * Display a 2 columns Header 1 for ID, 1 for recursivity menu\n    * Open the form is user can edit\n    *\n    * @param array $options array of possible options:\n    *     - target for the Form\n    *     - withtemplate : 1 for newtemplate, 2 for newobject from template\n    *     - colspan for each column (default 2)\n    *     - formoptions string (javascript p.e.)\n    *     - canedit boolean edit mode of form ?\n    *     - formtitle specific form title\n    *     - noid Set to true if ID should not be append (eg. already done in formtitle)\n    *\n    * @return void\n   **/\n   function showFormHeader($options = []) {\n\n      $ID     = $this->fields['id'];\n\n      $params = [\n         'target'       => $this->getFormURL(),\n         'colspan'      => 2,\n         'withtemplate' => '',\n         'formoptions'  => '',\n         'canedit'      => true,\n         'formtitle'    => null,\n         'noid'         => false\n      ];\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $val) {\n            $params[$key] = $val;\n         }\n      }\n\n      // Template case : clean entities data\n      if (($params['withtemplate'] == 2)\n          && $this->isEntityAssign()) {\n         $this->fields['entities_id']  = $_SESSION['glpiactive_entity'];\n      }\n\n      $rand = mt_rand();\n      if ($this->canEdit($ID)) {\n         echo \"<form name='form' method='post' action='\".$params['target'].\"' \".\n                $params['formoptions'].\" enctype=\\\"multipart/form-data\\\">\";\n\n         //Should add an hidden entities_id field ?\n         //If the table has an entities_id field\n         if ($this->isField(\"entities_id\")) {\n            //The object type can be assigned to an entity\n            if ($this->isEntityAssign()) {\n               if (isset($params['entities_id'])) {\n                  $entity = $this->fields['entities_id'] = $params['entities_id'];\n\n               } else if ($this->isNewID($ID)\n                          || ($params['withtemplate'] == 2)) {\n                  //It's a new object to be added\n                  $entity = $_SESSION['glpiactive_entity'];\n\n               } else {\n                  //It's an existing object to be displayed\n                  $entity = $this->fields['entities_id'];\n               }\n\n               echo \"<input type='hidden' name='entities_id' value='$entity'>\";\n\n            } else if ($this->getType() != 'User') {\n               // For Rules except ruleticket and slalevel\n               echo \"<input type='hidden' name='entities_id' value='0'>\";\n\n            }\n         }\n      }\n\n      echo \"<div class='spaced' id='tabsbody'>\";\n      echo \"<table class='tab_cadre_fixe' id='mainformtable'>\";\n\n      if ($params['formtitle'] !== '' && $params['formtitle'] !== false) {\n         echo \"<tr class='headerRow'><th colspan='\".$params['colspan'].\"'>\";\n\n         if (!empty($params['withtemplate']) && ($params['withtemplate'] == 2)\n            && !$this->isNewID($ID)) {\n\n            echo \"<input type='hidden' name='template_name' value='\".$this->fields[\"template_name\"].\"'>\";\n\n            //TRANS: %s is the template name\n            printf(__('Created from the template %s'), $this->fields[\"template_name\"]);\n\n         } else if (!empty($params['withtemplate']) && ($params['withtemplate'] == 1)) {\n            echo \"<input type='hidden' name='is_template' value='1'>\\n\";\n            echo \"<label for='textfield_template_name$rand'>\" . __('Template name') . \"</label>\";\n            Html::autocompletionTextField(\n               $this,\n               'template_name',\n               [\n                  'size'      => 25,\n                  'required'  => true,\n                  'rand'      => $rand\n               ]\n            );\n         } else if ($this->isNewID($ID)) {\n            $nametype = $params['formtitle'] !== null ? $params['formtitle'] : $this->getTypeName(1);\n            printf(__('%1$s - %2$s'), __('New item'), $nametype);\n         } else {\n            $nametype = $params['formtitle'] !== null ? $params['formtitle'] : $this->getTypeName(1);\n            if (!$params['noid'] && ($_SESSION['glpiis_ids_visible'] || empty($nametype))) {\n               //TRANS: %1$s is the Itemtype name and $2$d the ID of the item\n               $nametype = sprintf(__('%1$s - ID %2$d'), $nametype, $ID);\n            }\n            echo $nametype;\n         }\n         $entityname = '';\n         if (isset($this->fields[\"entities_id\"])\n            && Session::isMultiEntitiesMode()\n            && $this->isEntityAssign()) {\n            $entityname = Dropdown::getDropdownName(\"glpi_entities\", $this->fields[\"entities_id\"]);\n         }\n\n         echo \"</th><th colspan='\".$params['colspan'].\"'>\";\n         if (get_class($this) != 'Entity') {\n            if ($this->maybeRecursive()) {\n               if (Session::isMultiEntitiesMode()) {\n                  echo \"<table class='tab_format'><tr class='headerRow responsive_hidden'><th>\".$entityname.\"</th>\";\n                  echo \"<th class='right'><label for='dropdown_is_recursive$rand'>\".__('Child entities').\"</label></th><th>\";\n                  if ($params['canedit']) {\n                     if ($this instanceof CommonDBChild) {\n                        echo Dropdown::getYesNo($this->isRecursive());\n                        if (isset($this->fields[\"is_recursive\"])) {\n                           echo \"<input type='hidden' name='is_recursive' value='\".$this->fields[\"is_recursive\"].\"'>\";\n                        }\n                        $comment = __(\"Can't change this attribute. It's inherited from its parent.\");\n                        // CommonDBChild : entity data is get or copy from parent\n\n                     } else if (!$this->can($ID, 'recursive')) {\n                        echo Dropdown::getYesNo($this->fields[\"is_recursive\"]);\n                        $comment = __('You are not allowed to change the visibility flag for child entities.');\n\n                     } else if (!$this->canUnrecurs()) {\n                        echo Dropdown::getYesNo($this->fields[\"is_recursive\"]);\n                        $comment = __('Flag change forbidden. Linked items found.');\n\n                     } else {\n                        Dropdown::showYesNo(\"is_recursive\", $this->fields[\"is_recursive\"], -1, ['rand' => $rand]);\n                        $comment = __('Change visibility in child entities');\n                     }\n                     echo \" \";\n                     Html::showToolTip($comment);\n                  } else {\n                     echo Dropdown::getYesNo($this->fields[\"is_recursive\"]);\n                  }\n                  echo \"</th></tr></table>\";\n               } else {\n                  echo $entityname;\n                  echo \"<input type='hidden' name='is_recursive' value='0'>\";\n               }\n            } else {\n               echo $entityname;\n            }\n         }\n         echo \"</th></tr>\\n\";\n      }\n\n      Plugin::doHook(\"pre_item_form\", ['item' => $this, 'options' => &$params]);\n\n      // If in modal : do not display link on message after redirect\n      if (isset($_REQUEST['_in_modal']) && $_REQUEST['_in_modal']) {\n         echo \"<input type='hidden' name='_no_message_link' value='1'>\";\n      }\n\n   }\n\n\n   /**\n    * is the parameter ID must be considered as new one ?\n    * Default is empty of <0 may be overriden (for entity for example)\n    *\n    * @param integer $ID ID of the item (-1 if new item)\n    *\n    * @return boolean\n   **/\n   static function isNewID($ID) {\n      return (empty($ID) || ($ID <= 0));\n   }\n\n\n   /**\n    * is the current object a new  one\n    *\n    * @since 0.83\n    *\n    * @return boolean\n   **/\n   function isNewItem() {\n\n      if (isset($this->fields['id'])) {\n         return $this->isNewID($this->fields['id']);\n      }\n      return true;\n   }\n\n\n   /**\n    * Check right on an item\n    *\n    * @param integer $ID    ID of the item (-1 if new item)\n    * @param mixed   $right Right to check : r / w / recursive / READ / UPDATE / DELETE\n    * @param array   $input array of input data (used for adding item) (default NULL)\n    *\n    * @return boolean\n   **/\n   function can($ID, $right, array &$input = null) {\n      // Clean ID :\n      $ID = Toolbox::cleanInteger($ID);\n\n      // Create process\n      if ($this->isNewID($ID)) {\n         if (!isset($this->fields['id'])) {\n            // Only once\n            $this->getEmpty();\n         }\n\n         if (is_array($input)) {\n            $input = $this->addNeededInfoToInput($input);\n            // Copy input field to allow getEntityID() to work\n            // from entites_id field or from parent item ref\n            foreach ($input as $key => $val) {\n               if (isset($this->fields[$key])) {\n                  $this->fields[$key] = $val;\n               }\n            }\n            // Store to be available for others functions\n            $this->input = $input;\n         }\n\n         if ($this->isPrivate()\n             && ($this->fields['users_id'] === Session::getLoginUserID())) {\n            return true;\n         }\n         return (static::canCreate() && $this->canCreateItem());\n\n      }\n      // else : Get item if not already loaded\n      if (!isset($this->fields['id']) || ($this->fields['id'] != $ID)) {\n         // Item not found : no right\n         if (!$this->getFromDB($ID)) {\n            return false;\n         }\n      }\n\n      /* Hook to restrict user right on current item @since 9.2 */\n      $this->right = $right;\n      Plugin::doHook(\"item_can\", $this);\n      if ($this->right !== $right) {\n         return false;\n      }\n      unset($this->right);\n\n      switch ($right) {\n         case READ :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canView() && $this->canViewItem());\n\n         case UPDATE :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canUpdate() && $this->canUpdateItem());\n\n         case DELETE :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canDelete() && $this->canDeleteItem());\n\n         case PURGE :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canPurge() && $this->canPurgeItem());\n\n         case CREATE :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canCreate() && $this->canCreateItem());\n\n         case 'recursive' :\n            if ($this->isEntityAssign()\n                && $this->maybeRecursive()) {\n               if (static::canCreate()\n                   && Session::haveAccessToEntity($this->getEntityID())) {\n                  // Can make recursive if recursive access to entity\n                  return Session::haveRecursiveAccessToEntity($this->getEntityID());\n               }\n            }\n            break;\n\n      }\n      return false;\n   }\n\n\n   /**\n    * Check right on an item with block\n    *\n    * @param integer $ID    ID of the item (-1 if new item)\n    * @param mixed   $right Right to check : r / w / recursive\n    * @param array   $input array of input data (used for adding item) (default NULL)\n    *\n    * @return void\n   **/\n   function check($ID, $right, array &$input = null) {\n\n      // Check item exists\n      if (!$this->isNewID($ID)\n          && (!isset($this->fields['id']) || $this->fields['id'] != $ID)\n          && !$this->getFromDB($ID)) {\n         // Gestion timeout session\n         Session::redirectIfNotLoggedIn();\n         Html::displayNotFoundError();\n\n      } else {\n         if (!$this->can($ID, $right, $input)) {\n            // Gestion timeout session\n            Session::redirectIfNotLoggedIn();\n            Html::displayRightError();\n         }\n      }\n   }\n\n\n   /**\n    * Check if have right on this entity\n    *\n    * @param boolean $recursive set true to accept recursive items of ancestors\n    *                           of active entities (View case for example) (default false)\n    * @since 0.85\n    *\n    * @return boolean\n   **/\n   function checkEntity($recursive = false) {\n\n      // Is an item assign to an entity\n      if ($this->isEntityAssign()) {\n         // Can be recursive check\n         if ($recursive && $this->maybeRecursive()) {\n            return Session::haveAccessToEntity($this->getEntityID(), $this->isRecursive());\n         }\n         //  else : No recursive item         // Have access to entity\n         return Session::haveAccessToEntity($this->getEntityID());\n      }\n      // else : Global item\n      return true;\n   }\n\n\n   /**\n    * Check global right on an object\n    *\n    * @param mixed $right Right to check : c / r / w / d\n    *\n    * @return void\n   **/\n   function checkGlobal($right) {\n\n      if (!$this->canGlobal($right)) {\n         // Gestion timeout session\n         Session::redirectIfNotLoggedIn();\n         Html::displayRightError();\n      }\n   }\n\n\n   /**\n    * Get global right on an object\n    *\n    * @param mixed $right Right to check : c / r / w / d / READ / UPDATE / CREATE / DELETE\n    *\n    * @return void\n   **/\n   function canGlobal($right) {\n\n      switch ($right) {\n         case READ :\n            return static::canView();\n\n         case UPDATE :\n            return static::canUpdate();\n\n         case CREATE :\n            return static::canCreate();\n\n         case DELETE :\n            return static::canDelete();\n\n         case PURGE :\n            return static::canPurge();\n\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Get the ID of entity assigned to the object\n    *\n    * Can be overloaded (ex : infocom)\n    *\n    * @return integer ID of the entity\n   **/\n   function getEntityID() {\n\n      if ($this->isEntityAssign()) {\n         return $this->fields[\"entities_id\"];\n      }\n      return  -1;\n   }\n\n\n   /**\n    * Is the object assigned to an entity\n    *\n    * Can be overloaded (ex : infocom)\n    *\n    * @return boolean\n   **/\n   function isEntityAssign() {\n\n      if (!array_key_exists('id', $this->fields)) {\n         $this->getEmpty();\n      }\n      return array_key_exists('entities_id', $this->fields);\n   }\n\n\n   /**\n    * Is the object may be recursive\n    *\n    * Can be overloaded (ex : infocom)\n    *\n    * @return boolean\n   **/\n   function maybeRecursive() {\n\n      if (!array_key_exists('id', $this->fields)) {\n         $this->getEmpty();\n      }\n      return array_key_exists('is_recursive', $this->fields);\n   }\n\n\n   /**\n    * Is the object recursive\n    *\n    * Can be overloaded (ex : infocom)\n    *\n    * @return boolean\n   **/\n   function isRecursive() {\n\n      if ($this->maybeRecursive()) {\n         return $this->fields[\"is_recursive\"];\n      }\n      // Return integer value to be used to fill is_recursive field\n      return 0;\n   }\n\n\n   /**\n    * Is the object may be deleted\n    *\n    * @return boolean\n   **/\n   function maybeDeleted() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return array_key_exists('is_deleted', $this->fields);\n   }\n\n\n   /**\n    * Is the object deleted\n    *\n    * @return boolean\n   **/\n   function isDeleted() {\n\n      if ($this->maybeDeleted()) {\n         return $this->fields[\"is_deleted\"];\n      }\n      // Return integer value to be used to fill is_deleted field\n      return 0;\n\n   }\n\n\n   /**\n    * Can object be activated\n    *\n    * @since 9.2\n    *\n    * @return boolean\n    **/\n   function maybeActive() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return array_key_exists('is_active', $this->fields);\n   }\n\n\n   /**\n    * Is the object active\n    *\n    * @since 9.2\n    *\n    * @return boolean\n    **/\n   function isActive() {\n\n      if ($this->maybeActive()) {\n         return $this->fields[\"is_active\"];\n      }\n      // Return integer value to be used to fill is_active field\n      return 1;\n\n   }\n\n\n   /**\n    * Is the object may be a template\n    *\n    * @return boolean\n   **/\n   function maybeTemplate() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return isset($this->fields['is_template']);\n   }\n\n\n   /**\n    * Is the object a template\n    *\n    * @return boolean\n   **/\n   function isTemplate() {\n\n      if ($this->maybeTemplate()) {\n         return $this->fields[\"is_template\"];\n      }\n      // Return integer value to be used to fill is_template field\n      return 0;\n   }\n\n\n   /**\n    * Can the object be dynamic\n    *\n    * @since 0.84\n    *\n    * @return boolean\n   **/\n   function maybeDynamic() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return array_key_exists('is_dynamic', $this->fields);\n   }\n\n\n   /**\n    * Use deleted field in case of dynamic management to lock ?\n    *\n    * need to be overriden if object need to use standard deleted management (Computer...)\n    * @since 0.84\n    *\n    * @return boolean\n   **/\n   function useDeletedToLockIfDynamic() {\n      return $this->maybeDynamic();\n   }\n\n\n   /**\n    * Is an object dynamic or not\n    *\n    * @since 0.84\n    *\n    * @return boolean\n   **/\n   function isDynamic() {\n\n      if ($this->maybeDynamic()) {\n         return $this->fields['is_dynamic'];\n      }\n      return 0;\n   }\n\n\n   /**\n    * Is the object may be private\n    *\n    * @return boolean\n   **/\n   function maybePrivate() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return (array_key_exists('is_private', $this->fields)\n              && array_key_exists('users_id', $this->fields));\n   }\n\n\n   /**\n    * Is the object private\n    *\n    * @return boolean\n   **/\n   function isPrivate() {\n\n      if ($this->maybePrivate()) {\n         return $this->fields[\"is_private\"];\n      }\n      return false;\n   }\n\n   /**\n    * Can object have a location\n    *\n    * @since 9.3\n    *\n    * @return boolean\n    */\n   function maybeLocated() {\n\n      if (!array_key_exists('id', $this->fields)) {\n         $this->getEmpty();\n      }\n      return array_key_exists('locations_id', $this->fields);\n   }\n\n   /**\n    * Return the linked items (in computers_items)\n    *\n    * @return array an array of linked items  like array('Computer' => array(1,2), 'Printer' => array(5,6))\n    * @since 0.84.4\n   **/\n   function getLinkedItems() {\n      return [];\n   }\n\n\n   /**\n    * Return the count of linked items (in computers_items)\n    *\n    * @return integer number of linked items\n    * @since 0.84.4\n   **/\n   function getLinkedItemsCount() {\n\n      $linkeditems = $this->getLinkedItems();\n      $nb          = 0;\n      if (count($linkeditems)) {\n         foreach ($linkeditems as $tab) {\n            $nb += count($tab);\n         }\n      }\n      return $nb;\n   }\n\n\n   /**\n    * Return a field Value if exists\n    *\n    * @param string $field field name\n    *\n    * @return mixed value of the field / false if not exists\n   **/\n   function getField($field) {\n\n      if (array_key_exists($field, $this->fields)) {\n         return $this->fields[$field];\n      }\n      return NOT_AVAILABLE;\n   }\n\n\n   /**\n    * Determine if a field exists\n    *\n    * @param string $field field name\n    *\n    * @return boolean\n   **/\n   function isField($field) {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n       return array_key_exists($field, $this->fields);\n   }\n\n\n   /**\n    * Get comments of the Object\n    *\n    * @return string comments of the object in the current language (HTML)\n   **/\n   function getComments() {\n\n      $comment = \"\";\n      $toadd   = [];\n      if ($this->isField('completename')) {\n         $toadd[] = ['name'  => __('Complete name'),\n                          'value' => nl2br($this->getField('completename'))];\n      }\n\n      if ($this->isField('serial')) {\n         $toadd[] = ['name'  => __('Serial number'),\n                          'value' => nl2br($this->getField('serial'))];\n      }\n\n      if ($this->isField('otherserial')) {\n         $toadd[] = ['name'  => __('Inventory number'),\n                          'value' => nl2br($this->getField('otherserial'))];\n      }\n\n      if ($this->isField('states_id') && $this->getType()!='State') {\n         $tmp = Dropdown::getDropdownName('glpi_states', $this->getField('states_id'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('Status'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('locations_id') && $this->getType()!='Location') {\n         $tmp = Dropdown::getDropdownName(\"glpi_locations\", $this->getField('locations_id'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('Location'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('users_id')) {\n         $tmp = getUserName($this->getField('users_id'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('User'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('groups_id')\n          && ($this->getType() != 'Group')) {\n         $tmp = Dropdown::getDropdownName(\"glpi_groups\", $this->getField('groups_id'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('Group'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('users_id_tech')) {\n         $tmp = getUserName($this->getField('users_id_tech'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('Technician in charge of the hardware'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('contact')) {\n         $toadd[] = ['name'  => __('Alternate username'),\n                          'value' => nl2br($this->getField('contact'))];\n      }\n\n      if ($this->isField('contact_num')) {\n         $toadd[] = ['name'  => __('Alternate username number'),\n                          'value' => nl2br($this->getField('contact_num'))];\n      }\n\n      if (Infocom::canApplyOn($this)) {\n         $infocom = new Infocom();\n         if ($infocom->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n            $toadd[] = ['name'  => __('Warranty expiration date'),\n                             'value' => Infocom::getWarrantyExpir($infocom->fields[\"warranty_date\"],\n                                                                  $infocom->fields[\"warranty_duration\"],\n                                                                  0, true)];\n         }\n      }\n\n      if (($this instanceof CommonDropdown)\n          && $this->isField('comment')) {\n         $toadd[] = ['name'  => __('Comments'),\n                          'value' => nl2br($this->getField('comment'))];\n      }\n\n      if (count($toadd)) {\n         foreach ($toadd as $data) {\n            // Do not use SPAN here\n            $comment .= sprintf(__('%1$s: %2$s').\"<br>\",\n                                \"<strong>\".$data['name'], \"</strong>\".$data['value']);\n         }\n      }\n\n      if (!empty($comment)) {\n         return Html::showToolTip($comment, ['display' => false]);\n      }\n\n      return $comment;\n   }\n\n\n   /**\n    * @since 0.84\n    *\n    * Get field used for name\n    *\n    * @return string\n   **/\n   static function getNameField() {\n      return 'name';\n   }\n\n\n   /**\n    * @since 0.84\n    *\n    * Get field used for completename\n    *\n    * @return string\n   **/\n   static function getCompleteNameField() {\n      return 'completename';\n   }\n\n\n   /**\n    * Get raw name of the object\n    * Maybe overloaded\n    *\n    * @deprecated 9.5\n    * @see CommonDBTM::getNameField\n    * @since 0.85\n    *\n    * @return string\n   **/\n   function getRawName() {\n      \\Toolbox::deprecated('Use CommonDBTM::getFriendlyName()');\n\n      return $this->getFriendlyName();\n   }\n\n\n   /** Get raw completename of the object\n    * Maybe overloaded\n    *\n    * @see CommonDBTM::getCompleteNameField\n    *\n    * @since 0.85\n    *\n    * @return string\n   **/\n   function getRawCompleteName() {\n\n      if (isset($this->fields[static::getCompleteNameField()])) {\n         return $this->fields[static::getCompleteNameField()];\n      }\n      return '';\n   }\n\n\n   /**\n    * Get the name of the object\n    *\n    * @param array $options array of options\n    *    - comments     : boolean / display comments\n    *    - complete     : boolean / display completename instead of name\n    *    - additional   : boolean / display aditionals information\n    *\n    * @return string name of the object in the current language\n    *\n    * @see CommonDBTM::getRawCompleteName\n    * @see CommonDBTM::getFriendlyName\n   **/\n   function getName($options = []) {\n\n      $p = [\n         'comments'   => false,\n         'complete'   => false,\n         'additional' => false,\n      ];\n\n      if (is_array($options)) {\n         foreach ($options as $key => $val) {\n            $p[$key] = $val;\n         }\n      }\n\n      $name = '';\n      if ($p['complete']) {\n         $name = $this->getRawCompleteName();\n      }\n      if (empty($name)) {\n         $name = $this->getFriendlyName();\n      }\n\n      if (strlen($name) != 0) {\n         if ($p['additional']) {\n            $pre = $this->getPreAdditionalInfosForName();\n            if (!empty($pre)) {\n               $name = sprintf(__('%1$s - %2$s'), $pre, $name);\n            }\n            $post = $this->getPostAdditionalInfosForName();\n            if (!empty($post)) {\n               $name = sprintf(__('%1$s - %2$s'), $name, $post);\n            }\n         }\n         if ($p['comments']) {\n            $comment = $this->getComments();\n            if (!empty($comment)) {\n               $name = sprintf(__('%1$s - %2$s'), $name, $comment);\n            }\n         }\n         return $name;\n      }\n      return NOT_AVAILABLE;\n   }\n\n\n   /**\n    * Get additionals information to add before name\n    *\n    * @since 0.84\n    *\n    * @return string string to add\n   **/\n   function getPreAdditionalInfosForName() {\n      return '';\n   }\n\n   /**\n    * Get additionals information to add after name\n    *\n    * @since 0.84\n    *\n    * @return string string to add\n   **/\n   function getPostAdditionalInfosForName() {\n      return '';\n   }\n\n\n   /**\n    * Get the name of the object with the ID if the config is set\n    * Should Not be overloaded (overload getName() instead)\n    *\n    * @see CommonDBTM::getName\n    *\n    * @param array $options array of options\n    *    - comments     : boolean / display comments\n    *    - complete     : boolean / display completename instead of name\n    *    - additional   : boolean / display aditionals information\n    *    - forceid      : boolean  override config and display item's ID (false by default)\n    *\n    * @return string name of the object in the current language\n   **/\n   function getNameID($options = []) {\n\n      $p = [\n         'forceid'  => false,\n         'comments' => false,\n      ];\n\n      if (is_array($options)) {\n         foreach ($options as $key => $val) {\n            $p[$key] = $val;\n         }\n      }\n\n      if ($p['forceid']\n          || $_SESSION['glpiis_ids_visible']) {\n         $addcomment = $p['comments'];\n\n         // unset comment\n         $p['comments'] = false;\n         $name = $this->getName($p);\n\n         //TRANS: %1$s is a name, %2$s is ID\n         $name = sprintf(__('%1$s (%2$s)'), $name, $this->getField('id'));\n\n         if ($addcomment) {\n            $comment = $this->getComments();\n            if (!empty($comment)) {\n               $name = sprintf(__('%1$s - %2$s'), $name, $comment);\n            }\n         }\n         return $name;\n      }\n      return $this->getName($options);\n   }\n\n   /**\n    * Get the Search options for the given Type\n    * If you want to work on search options, @see CommonDBTM::rawSearchOptions\n    *\n    * @return array an *indexed* array of search options\n    *\n    * @see https://glpi-developer-documentation.rtfd.io/en/master/devapi/search.html\n   **/\n   public final function searchOptions() {\n      static $options;\n\n      if (!isset($options)) {\n         $options = [];\n\n         foreach ($this->rawSearchOptions() as $opt) {\n            $missingFields = [];\n            if (!isset($opt['id'])) {\n               $missingFields[] = 'id';\n            }\n            if (!isset($opt['name'])) {\n               $missingFields[] = 'name';\n            }\n            if (count($missingFields) > 0) {\n               throw new \\Exception(\n                  vsprintf(\n                     'Invalid search option in \"%1$s\": missing \"%2$s\" field(s). %3$s',\n                     [\n                        get_called_class(),\n                        implode('\", \"', $missingFields),\n                        print_r($opt, true)\n                     ]\n                  )\n               );\n            }\n\n            $optid = $opt['id'];\n            unset($opt['id']);\n\n            if (isset($options[$optid])) {\n               $message = \"Duplicate key $optid ({$options[$optid]['name']}/{$opt['name']}) in \".\n                   get_class($this) . \" searchOptions!\";\n\n               Toolbox::logError($message);\n            }\n\n            foreach ($opt as $k => $v) {\n               $options[$optid][$k] = $v;\n            }\n         }\n      }\n\n      return $options;\n   }\n\n\n   /**\n    * Provides search options configuration. Do not rely directly\n    * on this, @see CommonDBTM::searchOptions instead.\n    *\n    * @since 9.3\n    *\n    * This should be overloaded in Class\n    *\n    * @return array a *not indexed* array of search options\n    *\n    * @see https://glpi-developer-documentation.rtfd.io/en/master/devapi/search.html\n   **/\n   public function rawSearchOptions() {\n      $tab = [];\n\n      $tab[] = [\n          'id'   => 'common',\n          'name' => __('Characteristics')\n      ];\n\n      if ($this->isField('name')) {\n         $tab[] = [\n            'id'            => 1,\n            'table'         => $this->getTable(),\n            'field'         => 'name',\n            'name'          => __('Name'),\n            'datatype'      => 'itemlink',\n            'massiveaction' => false,\n            'autocomplete'  => true,\n         ];\n      }\n\n      if ($this->isField('is_recursive')) {\n         $tab[] = [\n            'id'       => 86,\n            'table'      => $this->getTable(),\n            'field'      => 'is_recursive',\n            'name'       => __('Child entities'),\n            'datatype'   => 'bool',\n            'searchtype' => 'equals',\n         ];\n      }\n\n      // add objectlock search options\n      $tab = array_merge($tab, ObjectLock::rawSearchOptionsToAdd(get_class($this)));\n\n      return $tab;\n   }\n\n   /**\n    * Summary of getSearchOptionsToAdd\n    * @since 9.2\n    *\n    * @param string $itemtype Item type, defaults to null\n    *\n    * @return array\n   **/\n   static function getSearchOptionsToAdd($itemtype = null) {\n      $options = [];\n\n      $classname = get_called_class();\n      $method_name = 'rawSearchOptionsToAdd';\n      if (!method_exists($classname, $method_name)) {\n         return $options;\n      }\n\n      if (defined('TU_USER') && $itemtype != null && $itemtype != 'AllAssets') {\n         $item = new $itemtype;\n         $all_options = $item->searchOptions();\n      }\n\n      foreach ($classname::$method_name($itemtype) as $opt) {\n         if (!isset($opt['id'])) {\n            throw new \\Exception(get_called_class() . ': invalid search option! ' . print_r($opt, true));\n         }\n         $optid = $opt['id'];\n         unset($opt['id']);\n\n         if (defined('TU_USER') && $itemtype != null) {\n            if (isset($all_options[$optid])) {\n               $message = \"Duplicate key $optid ({$all_options[$optid]['name']}/{$opt['name']}) in \".\n                  self::class . \" searchOptionsToAdd for $itemtype!\";\n\n               Toolbox::logError($message);\n            }\n         }\n\n         foreach ($opt as $k => $v) {\n            $options[$optid][$k] = $v;\n            if (defined('TU_USER') && $itemtype != null) {\n               $all_options[$optid][$k] = $v;\n            }\n         }\n      }\n\n      return $options;\n   }\n\n   /**\n    * Get all the massive actions available for the current class regarding given itemtype\n    *\n    * @since 0.85\n    *\n    * @param array      $actions    array of the actions to update\n    * @param string     $itemtype   the type of the item for which we want the actions\n    * @param boolean    $is_deleted (default 0)\n    * @param CommonDBTM $checkitem  (default NULL)\n    *\n    * @return void (update is set inside $actions)\n   **/\n   static function getMassiveActionsForItemtype(array &$actions, $itemtype, $is_deleted = 0,\n                                                CommonDBTM $checkitem = null) {\n   }\n\n\n   /**\n    * Class-specific method used to show the fields to specify the massive action\n    *\n    * @since 0.85\n    *\n    * @param MassiveAction $ma the current massive action object\n    *\n    * @return boolean false if parameters displayed ?\n   **/\n   static function showMassiveActionsSubForm(MassiveAction $ma) {\n      return false;\n   }\n\n\n   /**\n    * Class specific execution of the massive action (new system) by itemtypes\n    *\n    * @since 0.85\n    *\n    * @param MassiveAction $ma   the current massive action object\n    * @param CommonDBTM    $item the item on which apply the massive action\n    * @param array         $ids  an array of the ids of the item on which apply the action\n    *\n    * @return void (direct submit to $ma object)\n   **/\n   static function processMassiveActionsForOneItemtype(MassiveAction $ma, CommonDBTM $item,\n                                                       array $ids) {\n   }\n\n\n   /**\n    * Get the standard massive actions which are forbidden\n    *\n    * @since 0.84\n    *\n    * This should be overloaded in Class\n    *\n    * @return array an array of massive actions\n   **/\n   function getForbiddenStandardMassiveAction() {\n      return [];\n   }\n\n\n   /**\n    * Get forbidden single action\n    *\n    * @since 9.5.0\n    *\n    * @return array\n   **/\n   public function getForbiddenSingleMassiveActions() {\n      $excluded = [\n         '*:update',\n         '*:delete',\n         '*:remove',\n         '*:purge',\n         '*:unlock'\n      ];\n\n      if (Infocom::canApplyOn($this)) {\n         $ic = new Infocom();\n         if ($ic->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n            $excluded[] = 'Infocom:activate';\n         }\n      }\n\n      return $excluded;\n   }\n\n   /**\n    * Get whitelisted single actions\n    *\n    * @since 9.5.0\n    *\n    * @return array\n   **/\n   public function getWhitelistedSingleMassiveActions() {\n      return ['MassiveAction:add_transfer_list'];\n   }\n\n\n   /**\n    * Get the specific massive actions\n    *\n    * @since 0.84\n    *\n    * This should be overloaded in Class\n    *\n    * @param object $checkitem link item to check right (default NULL)\n    *\n    * @return array an array of massive actions\n   **/\n   function getSpecificMassiveActions($checkitem = null) {\n      global $DB;\n\n      $actions = [];\n      // test if current profile has rights to unlock current item type\n      if (Session::haveRight( static::$rightname, UNLOCK)) {\n         $actions['ObjectLock'.MassiveAction::CLASS_ACTION_SEPARATOR.'unlock']\n                        = _x('button', 'Unlock items');\n      }\n      if ($DB->fieldExists(static::getTable(), 'entities_id') && static::canUpdate()) {\n         MassiveAction::getAddTransferList($actions);\n      }\n\n      //massive action to link appliances from possible item types\n      if (in_array(static::getType(), Appliance::getTypes(true)) && static::canUpdate()) {\n         $actions['Appliance'.MassiveAction::CLASS_ACTION_SEPARATOR.'add_item'] = __('Associate to appliance');\n      }\n\n      return $actions;\n   }\n\n\n   /**\n    * Print out an HTML \"<select>\" for a dropdown\n    *\n    * This should be overloaded in Class\n    *\n    * @param array $options array of possible options:\n    * Parameters which could be used in options array :\n    *    - name : string / name of the select (default is depending itemtype)\n    *    - value : integer / preselected value (default 0)\n    *    - comments : boolean / is the comments displayed near the dropdown (default true)\n    *    - entity : integer or array / restrict to a defined entity or array of entities\n    *                   (default -1 : no restriction)\n    *    - toupdate : array / Update a specific item on select change on dropdown\n    *                   (need value_fieldname, to_update, url (see Ajax::updateItemOnSelectEvent for information)\n    *                   and may have moreparams)\n    *    - used : array / Already used items ID: not to display in dropdown (default empty)\n    *\n    * @return void display the dropdown\n   **/\n   static function dropdown($options = []) {\n      /// TODO try to revert usage : Dropdown::show calling this function\n      /// TODO use this function instead of Dropdown::show\n      return Dropdown::show(get_called_class(), $options);\n   }\n\n\n   /**\n    * Return a search option by looking for a value of a specific field and maybe a specific table\n    *\n    * @param string $field the field in which looking for the value (for example : table, name, etc)\n    * @param string $value the value to look for in the field\n    * @param string $table the table (default '')\n    *\n    * @return array the search option array, or an empty array if not found\n   **/\n   function getSearchOptionByField($field, $value, $table = '') {\n\n      foreach ($this->searchOptions() as $id => $searchOption) {\n         if ((isset($searchOption['linkfield']) && ($searchOption['linkfield'] == $value))\n             || (isset($searchOption[$field]) && ($searchOption[$field] == $value))) {\n            if (($table == '')\n                || (($table != '') && ($searchOption['table'] == $table))) {\n               // Set ID;\n               $searchOption['id'] = $id;\n               return $searchOption;\n            }\n         }\n      }\n      return [];\n   }\n\n\n   /**\n    * Get search options\n    *\n    * @since 0.85\n    *\n    * @return array the search option array\n   **/\n   function getOptions() {\n\n      if (!$this->searchopt) {\n         $this->searchopt = Search::getOptions($this->getType());\n      }\n\n      return $this->searchopt;\n   }\n\n\n   /**\n    * Return a search option ID by looking for a value of a specific field and maybe a specific table\n    *\n    * @since 0.83\n    *\n    * @param string $field the field in which looking for the value (for example : table, name, etc)\n    * @param string $value the value to look for in the field\n    * @param string $table the table (default '')\n    *\n    * @return mixed the search option id, or -1 if not found\n   **/\n   function getSearchOptionIDByField($field, $value, $table = '') {\n\n      $tab = $this->getSearchOptionByField($field, $value, $table);\n      if (isset($tab['id'])) {\n         return $tab['id'];\n      }\n      return -1;\n   }\n\n\n   /**\n    * Check float and decimal values\n    *\n    * @param boolean $display display or not messages in and addAfterRedirect (true by default)\n    *\n    * @return void\n   **/\n   function filterValues($display = true) {\n      // MoYo : comment it because do not understand why filtering is disable\n      // if (in_array('CommonDBRelation', class_parents($this))) {\n      //    return true;\n      // }\n      //Type mismatched fields\n      $fails = [];\n      if (isset($this->input) && is_array($this->input) && count($this->input)) {\n\n         foreach ($this->input as $key => $value) {\n            $unset        = false;\n            $regs         = [];\n            $searchOption = $this->getSearchOptionByField('field', $key);\n\n            if (isset($searchOption['datatype'])\n                && (is_null($value) || ($value == '') || ($value == 'NULL'))) {\n\n               switch ($searchOption['datatype']) {\n                  case 'date' :\n                  case 'datetime' :\n                     // don't use $unset', because this is not a failure\n                     $this->input[$key] = 'NULL';\n                     break;\n               }\n            } else if (isset($searchOption['datatype'])\n                       && !is_null($value)\n                       && ($value != '')\n                       && ($value != 'NULL')) {\n\n               switch ($searchOption['datatype']) {\n                  case 'integer' :\n                  case 'count' :\n                  case 'number' :\n                  case 'decimal' :\n                     $value = str_replace(',', '.', $value);\n                     if ($searchOption['datatype'] == 'decimal') {\n                        $this->input[$key] = floatval(Toolbox::cleanDecimal($value));\n                     } else {\n                        $this->input[$key] = intval(Toolbox::cleanInteger($value));\n                     }\n                     if (!is_numeric($this->input[$key])) {\n                        $unset = true;\n                     }\n                     break;\n\n                  case 'bool' :\n                     if (!in_array($value, [0,1])) {\n                        $unset = true;\n                     }\n                     break;\n\n                  case 'ip' :\n                     $address = new IPAddress();\n                     if (!$address->setAddressFromString($value)) {\n                        $unset = true;\n                     } else if (!$address->is_ipv4()) {\n                        $unset = true;\n                     }\n                     break;\n\n                  case 'mac' :\n                     preg_match(\"/([0-9a-fA-F]{1,2}([:-]|$)){6}$/\", $value, $regs);\n                     if (empty($regs)) {\n                        $unset = true;\n                     }\n                     // Define the MAC address to lower to reduce complexity of SQL queries\n                     $this->input[$key] = strtolower ($value);\n                     break;\n\n                  case 'date' :\n                  case 'datetime' :\n                     // Date is already \"reformat\" according to getDateFormat()\n                     $pattern  = \"/^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})\";\n                     $pattern .= \"([_][01][0-9]|2[0-3]:[0-5][0-9]:[0-5]?[0-9])?/\";\n                     preg_match($pattern, $value, $regs);\n                     if (empty($regs)) {\n                        $unset = true;\n                     }\n                     break;\n\n                  case 'itemtype' :\n                     //Want to insert an itemtype, but the associated class doesn't exists\n                     if (!class_exists($value)) {\n                        $unset = true;\n                     }\n\n                  case 'email' :\n                  case 'string' :\n                     if (strlen($value) > 255) {\n                        Toolbox::logWarning(\"$value exceed 255 characters long (\".strlen($value).\"), it will be truncated.\");\n                        $this->input[$key] = substr($value, 0, 254);\n                     }\n                     break;\n\n                  default :\n                     //Plugins can implement their own checks\n                     if (!$this->checkSpecificValues($searchOption['datatype'], $value)) {\n                        $unset = true;\n                     }\n                     // Copy value if check have update it\n                     $this->input[$key] = $value;\n                     break;\n               }\n            }\n\n            if ($unset) {\n               $fails[] = $searchOption['name'];\n               unset($this->input[$key]);\n            }\n         }\n      }\n      if ($display && count($fails)) {\n         //Display a message to indicate that one or more value where filtered\n         //TRANS: %s is the list of the failed fields\n         $message = sprintf(__('%1$s: %2$s'), __('At least one field has an incorrect value'),\n                            implode(',', $fails));\n         Session::addMessageAfterRedirect($message, INFO, true);\n      }\n   }\n\n\n   /**\n    * Add more check for values\n    *\n    * @param string $datatype datatype of the value\n    * @param array  $value    value to check (pass by reference)\n    *\n    * @return boolean true if value is ok, false if not\n   **/\n   function checkSpecificValues($datatype, &$value) {\n      return true;\n   }\n\n\n   /**\n    * Get fields to display in the unicity error message\n    *\n    * @return array an array which contains field => label\n   **/\n   function getUnicityFieldsToDisplayInErrorMessage() {\n\n      return ['id'          => __('ID'),\n                   'serial'      => __('Serial number'),\n                   'entities_id' => __('Entity')];\n   }\n\n\n   function getUnallowedFieldsForUnicity() {\n      return ['alert', 'comment', 'date_mod', 'id', 'is_recursive', 'items_id'];\n   }\n\n\n   /**\n    * Build an unicity error message\n    *\n    * @param array $msgs    the string not transleted to be display on the screen, or to be sent in a notification\n    * @param array $unicity the unicity criterion that failed to match\n    * @param array $doubles the items that are already present in DB\n    *\n    * @return string\n   **/\n   function getUnicityErrorMessage($msgs, $unicity, $doubles) {\n\n      $message = [];\n      foreach ($msgs as $field => $value) {\n         $table = getTableNameForForeignKeyField($field);\n         if ($table != '') {\n            $searchOption = $this->getSearchOptionByField('field', 'name', $table);\n         } else {\n            $searchOption = $this->getSearchOptionByField('field', $field);\n         }\n         $message[] = sprintf(__('%1$s = %2$s'), $searchOption['name'], $value);\n      }\n\n      if ($unicity['action_refuse']) {\n         $message_text = sprintf(__('Impossible record for %s'),\n                                 implode('&nbsp;&amp;&nbsp;', $message));\n      } else {\n         $message_text = sprintf(__('Item successfully added but duplicate record on %s'),\n                                 implode('&nbsp;&amp;&nbsp;', $message));\n      }\n      $message_text .= '<br>'.__('Other item exist');\n\n      foreach ($doubles as $double) {\n         if (in_array('CommonDBChild', class_parents($this))) {\n            if ($this->getField($this->itemtype)) {\n               $item = new $double['itemtype']();\n            } else {\n               $item = new $this->itemtype();\n            }\n\n            $item->getFromDB($double['items_id']);\n         } else {\n            $item = clone $this;\n            $item->getFromDB($double['id']);\n         }\n\n         $double_text = '';\n         if ($item->canView() && $item->canViewItem()) {\n            $double_text = $item->getLink();\n         }\n\n         foreach ($this->getUnicityFieldsToDisplayInErrorMessage() as $key => $value) {\n            $field_value = $item->getField($key);\n            if ($field_value != NOT_AVAILABLE) {\n               if (getTableNameForForeignKeyField($key) != '') {\n                  $field_value = Dropdown::getDropdownName(getTableNameForForeignKeyField($key),\n                                                           $field_value);\n               }\n               $new_text = sprintf(__('%1$s: %2$s'), $value, $field_value);\n               if (empty($double_text)) {\n                  $double_text = $new_text;\n               } else {\n                  $double_text = sprintf(__('%1$s - %2$s'), $double_text, $new_text);\n               }\n            }\n         }\n         // Add information on item in trashbin\n         if ($item->isField('is_deleted') && $item->getField('is_deleted')) {\n            $double_text = sprintf(__('%1$s - %2$s'), $double_text, __('Item in the trashbin'));\n         }\n\n         $message_text .= \"<br>[$double_text]\";\n      }\n      return $message_text;\n   }\n\n\n   /**\n    * Check field unicity before insert or update\n    *\n    * @param boolean $add     true for insert, false for update (false by default)\n    * @param array   $options array\n    *\n    * @return boolean true if item can be written in DB, false if not\n   **/\n   function checkUnicity($add = false, $options = []) {\n      global $CFG_GLPI;\n\n      $p = [\n         'unicity_error_message'  => true,\n         'add_event_on_duplicate' => true,\n         'disable_unicity_check'  => false,\n      ];\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $value) {\n            $p[$key] = $value;\n         }\n      }\n\n      // Do not check for template\n      if (isset($this->input['is_template']) && $this->input['is_template']) {\n         return true;\n      }\n\n      $result = true;\n\n      //Do not check unicity when creating infocoms or if checking is expliclty disabled\n      if ($p['disable_unicity_check']) {\n         return $result;\n      }\n\n      //Get all checks for this itemtype and this entity\n      if (in_array(get_class($this), $CFG_GLPI[\"unicity_types\"])) {\n         // Get input entities if set / else get object one\n         if (isset($this->input['entities_id'])) {\n            $entities_id = $this->input['entities_id'];\n         } else if (isset($this->fields['entities_id'])) {\n            $entities_id = $this->fields['entities_id'];\n         } else {\n            $message = 'Missing entity ID!';\n            Toolbox::logError($message);\n         }\n\n         $all_fields =  FieldUnicity::getUnicityFieldsConfig(get_class($this), $entities_id);\n         foreach ($all_fields as $key => $fields) {\n\n            //If there's fields to check\n            if (!empty($fields) && !empty($fields['fields'])) {\n               $where    = [];\n               $continue = true;\n               foreach (explode(',', $fields['fields']) as $field) {\n                  if (isset($this->input[$field]) //Field is set\n                      //Standard field not null\n                      && (((getTableNameForForeignKeyField($field) == '')\n                           && ($this->input[$field] != ''))\n                          //Foreign key and value is not 0\n                          || ((getTableNameForForeignKeyField($field) != '')\n                              && ($this->input[$field] > 0)))\n                      && !Fieldblacklist::isFieldBlacklisted(get_class($this), $entities_id, $field,\n                                                             $this->input[$field])) {\n                     $where[$this->getTable() . '.' . $field] = $this->input[$field];\n                  } else {\n                     $continue = false;\n                  }\n               }\n\n               if ($continue\n                   && count($where)) {\n                  $entities = $fields['entities_id'];\n                  if ($fields['is_recursive']) {\n                     $entities = getSonsOf('glpi_entities', $fields['entities_id']);\n                  }\n                  $where[] = getEntitiesRestrictCriteria($this->getTable(), '', $entities);\n\n                  $tmp = clone $this;\n                  if ($tmp->maybeTemplate()) {\n                     $where['is_template'] = 0;\n                  }\n\n                  //If update, exclude ID of the current object\n                  if (!$add) {\n                     $where['NOT'] = [$this->getTable() . '.id' => $this->input['id']];\n                  }\n\n                  if (countElementsInTable($this->getTable(), $where) > 0) {\n                     if ($p['unicity_error_message']\n                         || $p['add_event_on_duplicate']) {\n                        $message = [];\n                        foreach (explode(',', $fields['fields']) as $field) {\n                           $message[$field] = $this->input[$field];\n                        }\n\n                        $doubles      = getAllDataFromTable($this->getTable(), $where);\n                        $message_text = $this->getUnicityErrorMessage($message, $fields, $doubles);\n                        if ($p['unicity_error_message']) {\n                           if (!$fields['action_refuse']) {\n                              $show_other_messages = ($fields['action_refuse']?true:false);\n                           } else {\n                              $show_other_messages = true;\n                           }\n                           Session::addMessageAfterRedirect($message_text, true,\n                                                            $show_other_messages,\n                                                            $show_other_messages);\n                        }\n                        if ($p['add_event_on_duplicate']) {\n                           Event::log ((!$add?$this->fields['id']:0), get_class($this), 4,\n                                       'inventory',\n                                       //TRANS: %1$s is the user login, %2$s the message\n                                       sprintf(__('%1$s trying to add an item that already exists: %2$s'),\n                                               $_SESSION[\"glpiname\"], $message_text));\n                        }\n                     }\n                     if ($fields['action_refuse']) {\n                        $result = false;\n                     }\n                     if ($fields['action_notify']) {\n                        $params = [\n                           'action_type' => $add,\n                           'action_user' => getUserName(Session::getLoginUserID()),\n                           'entities_id' => $entities_id,\n                           'itemtype'    => get_class($this),\n                           'date'        => $_SESSION['glpi_currenttime'],\n                           'refuse'      => $fields['action_refuse'],\n                           'label'       => $message,\n                           'field'       => $fields,\n                           'double'      => $doubles];\n                        NotificationEvent::raiseEvent('refuse', new FieldUnicity(), $params);\n                     }\n                  }\n               }\n            }\n         }\n\n      }\n\n      return $result;\n   }\n\n\n   /**\n    * Clean all infos which match some criteria\n    *\n    * @param array   $crit    array of criteria (ex array('is_active'=>'1'))\n    * @param boolean $force   force purge not on put in trashbin (default 0)\n    * @param boolean $history do history log ? (true by default)\n    *\n    * @return boolean\n   **/\n   function deleteByCriteria($crit = [], $force = 0, $history = 1) {\n      global $DB;\n\n      $ok = false;\n      if (is_array($crit) && (count($crit) > 0)) {\n         $crit['FIELDS'] = [$this::getTable() => 'id'];\n         $ok = true;\n         $iterator = $DB->request($this->getTable(), $crit);\n         foreach ($iterator as $row) {\n            if (!$this->delete($row, $force, $history)) {\n               $ok = false;\n            }\n         }\n\n      }\n      return $ok;\n   }\n\n\n   /**\n    * get the Entity of an Item\n    *\n    * @param string  $itemtype item type\n    * @param integer $items_id id of the item\n    *\n    * @return integer ID of the entity or -1\n   **/\n   static function getItemEntity($itemtype, $items_id) {\n\n      if ($itemtype\n          && ($item = getItemForItemtype($itemtype))) {\n\n         if ($item->getFromDB($items_id)) {\n            return $item->getEntityID();\n         }\n\n      }\n      return -1;\n   }\n\n\n   /**\n    * display a specific field value\n    *\n    * @since 0.83\n    *\n    * @param string       $field   name of the field\n    * @param string|array $values  with the value to display or a Single value\n    * @param array        $options Array of options\n    *\n    * @return string the string to display\n   **/\n   static function getSpecificValueToDisplay($field, $values, array $options = []) {\n\n      switch ($field) {\n         case '_virtual_datacenter_position':\n            if (method_exists(static::class, 'getDcBreadcrumbSpecificValueToDisplay')) {\n               return static::getDcBreadcrumbSpecificValueToDisplay($values['id']);\n            }\n      }\n\n      return '';\n   }\n\n\n   /**\n    * display a field using standard system\n    *\n    * @since 0.83\n    *\n    * @param integer|string|array $field_id_or_search_options id of the search option field\n    *                                                             or field name\n    *                                                             or search option array\n    * @param mixed                $values                     value to display\n    * @param array                $options                    array of possible options:\n    * Parameters which could be used in options array :\n    *    - comments : boolean / is the comments displayed near the value (default false)\n    *    - any others options passed to specific display method\n    *\n    * @return string the string to display\n   **/\n   function getValueToDisplay($field_id_or_search_options, $values, $options = []) {\n      global $CFG_GLPI;\n\n      $param = [\n         'comments' => false,\n         'html'     => false,\n      ];\n      foreach ($param as $key => $val) {\n         if (!isset($options[$key])) {\n            $options[$key] = $val;\n         }\n      }\n\n      $searchoptions = [];\n      if (is_array($field_id_or_search_options)) {\n         $searchoptions = $field_id_or_search_options;\n      } else {\n         $searchopt = $this->searchOptions();\n\n         // Get if id of search option is passed\n         if (is_numeric($field_id_or_search_options)) {\n            if (isset($searchopt[$field_id_or_search_options])) {\n               $searchoptions = $searchopt[$field_id_or_search_options];\n            }\n         } else { // Get if field name is passed\n            $searchoptions = $this->getSearchOptionByField('field', $field_id_or_search_options,\n                                                           $this->getTable());\n         }\n      }\n\n      if (count($searchoptions)) {\n         $field = $searchoptions['field'];\n\n         // Normalize option\n         if (is_array($values)) {\n            $value = $values[$field];\n         } else {\n            $value  = $values;\n            $values = [$field => $value];\n         }\n\n         if (isset($searchoptions['datatype'])) {\n            $unit = '';\n            if (isset($searchoptions['unit'])) {\n               $unit = $searchoptions['unit'];\n            }\n\n            switch ($searchoptions['datatype']) {\n               case \"count\" :\n               case \"number\" :\n                  if (isset($searchoptions['toadd']) && isset($searchoptions['toadd'][$value])) {\n                     return $searchoptions['toadd'][$value];\n                  }\n                  if ($options['html']) {\n                     return Dropdown::getValueWithUnit(Html::formatNumber($value, false, 0), $unit);\n                  }\n                  return $value;\n\n               case \"decimal\" :\n                  if ($options['html']) {\n                     return Dropdown::getValueWithUnit(Html::formatNumber($value), $unit);\n                  }\n                  return $value;\n\n               case \"string\" :\n               case \"mac\" :\n               case \"ip\" :\n                  return $value;\n\n               case \"text\" :\n\n                  if ($options['html']) {\n                     $text = nl2br($value);\n                  } else {\n                     $text = $value;\n                  }\n                  if (isset($searchoptions['htmltext']) && $searchoptions['htmltext']) {\n                     $text = Html::clean(Toolbox::unclean_cross_side_scripting_deep($text));\n                  }\n                  return $text;\n\n               case \"bool\" :\n                  return Dropdown::getYesNo($value);\n\n               case \"date\" :\n               case \"date_delay\" :\n                  if (isset($options['relative_dates']) && $options['relative_dates']) {\n                     $dates = Html::getGenericDateTimeSearchItems(['with_time'   => true,\n                                                                        'with_future' => true]);\n                     return $dates[$value];\n                  }\n                  return Html::convDate(Html::computeGenericDateTimeSearch($value, true));\n\n               case \"datetime\" :\n                  if (isset($options['relative_dates']) && $options['relative_dates']) {\n                     $dates = Html::getGenericDateTimeSearchItems(['with_time'   => true,\n                                                                        'with_future' => true]);\n                     return $dates[$value];\n                  }\n                  return Html::convDateTime(Html::computeGenericDateTimeSearch($value, false));\n\n               case \"timestamp\" :\n                  if (($value == 0)\n                      && isset($searchoptions['emptylabel'])) {\n                     return $searchoptions['emptylabel'];\n                  }\n                  $withseconds = false;\n                  if (isset($searchoptions['withseconds'])) {\n                     $withseconds = $searchoptions['withseconds'];\n                  }\n                  return Html::timestampToString($value, $withseconds);\n\n               case \"email\" :\n                  if ($options['html']) {\n                     return \"<a href='mailto:$value'>$value</a>\";\n                  }\n                  return $value;\n\n               case \"weblink\" :\n                  $orig_link = trim($value);\n                  if (!empty($orig_link)) {\n                     // strip begin of link\n                     $link = preg_replace('/https?:\\/\\/(www[^\\.]*\\.)?/', '', $orig_link);\n                     $link = preg_replace('/\\/$/', '', $link);\n                     if (Toolbox::strlen($link) > $CFG_GLPI[\"url_maxlength\"]) {\n                        $link = Toolbox::substr($link, 0, $CFG_GLPI[\"url_maxlength\"]).\"...\";\n                     }\n                     return \"<a href=\\\"\".Toolbox::formatOutputWebLink($orig_link).\"\\\" target='_blank'>$link\".\n                            \"</a>\";\n                  }\n                  return \"&nbsp;\";\n\n               case \"itemlink\" :\n                  if ($searchoptions['table'] == $this->getTable()) {\n                     break;\n                  }\n\n               case \"dropdown\" :\n                  if (isset($searchoptions['toadd']) && isset($searchoptions['toadd'][$value])) {\n                     return $searchoptions['toadd'][$value];\n                  }\n                  if (!is_numeric($value)) {\n                     return $value;\n                  }\n\n                  if (($value == 0)\n                      && isset($searchoptions['emptylabel'])) {\n                     return $searchoptions['emptylabel'];\n                  }\n\n                  if ($searchoptions['table'] == 'glpi_users') {\n                     if ($param['comments']) {\n                        $tmp = getUserName($value, 2);\n                        return $tmp['name'].'&nbsp;'.Html::showToolTip($tmp['comment'],\n                                                                       ['display' => false]);\n                     }\n                     return getUserName($value);\n                  }\n                  if ($param['comments']) {\n                     $tmp = Dropdown::getDropdownName($searchoptions['table'], $value, 1);\n                     return $tmp['name'].'&nbsp;'.Html::showToolTip($tmp['comment'],\n                                                                    ['display' => false]);\n                  }\n                  return Dropdown::getDropdownName($searchoptions['table'], $value);\n\n               case \"itemtypename\" :\n                  if ($obj = getItemForItemtype($value)) {\n                     return $obj->getTypeName(1);\n                  }\n                  break;\n\n               case \"language\" :\n                  if (isset($CFG_GLPI['languages'][$value])) {\n                     return $CFG_GLPI['languages'][$value][0];\n                  }\n                  return __('Default value');\n\n            }\n         }\n         // Get specific display if available\n         $itemtype = getItemTypeForTable($searchoptions['table']);\n         if ($item = getItemForItemtype($itemtype)) {\n            $options['searchopt'] = $searchoptions;\n            $specific = $item->getSpecificValueToDisplay($field, $values, $options);\n            if (!empty($specific)) {\n               return $specific;\n            }\n         }\n\n      }\n      return $value;\n   }\n\n   /**\n    * display a specific field selection system\n    *\n    * @since 0.83\n    *\n    * @param string       $field   name of the field\n    * @param string       $name    name of the select (if empty use linkfield) (default '')\n    * @param string|array $values  with the value to select or a Single value (default '')\n    * @param array        $options aArray of options\n    *\n    * @return string the string to display\n   **/\n   static function getSpecificValueToSelect($field, $name = '', $values = '', array $options = []) {\n      return '';\n   }\n\n\n   /**\n    * Select a field using standard system\n    *\n    * @since 0.83\n    *\n    * @param integer|string|array $field_id_or_search_options id of the search option field\n    *                                                             or field name\n    *                                                             or search option array\n    * @param string               $name                       name of the select (if empty use linkfield)\n    *                                                         (default '')\n    * @param mixed                $values                     default value to display\n    *                                                         (default '')\n    * @param array                $options                    array of possible options:\n    * Parameters which could be used in options array :\n    *    - comments : boolean / is the comments displayed near the value (default false)\n    *    - any others options passed to specific display method\n    *\n    * @return string the string to display\n   **/\n   function getValueToSelect($field_id_or_search_options, $name = '', $values = '', $options = []) {\n      global $CFG_GLPI;\n\n      $param = [\n         'comments' => false,\n         'html'     => false,\n      ];\n      foreach ($param as $key => $val) {\n         if (!isset($options[$key])) {\n            $options[$key] = $val;\n         }\n      }\n\n      $searchoptions = [];\n      if (is_array($field_id_or_search_options)) {\n         $searchoptions = $field_id_or_search_options;\n      } else {\n         $searchopt = $this->searchOptions();\n\n         // Get if id of search option is passed\n         if (is_numeric($field_id_or_search_options)) {\n            if (isset($searchopt[$field_id_or_search_options])) {\n               $searchoptions = $searchopt[$field_id_or_search_options];\n            }\n         } else { // Get if field name is passed\n            $searchoptions = $this->getSearchOptionByField('field', $field_id_or_search_options,\n                                                           $this->getTable());\n         }\n      }\n      if (count($searchoptions)) {\n         $field = $searchoptions['field'];\n         // Normalize option\n         if (is_array($values)) {\n            $value = $values[$field];\n         } else {\n            $value  = $values;\n            $values = [$field => $value];\n         }\n\n         if (empty($name)) {\n            $name = $searchoptions['linkfield'];\n         }\n         // If not set : set to specific\n         if (!isset($searchoptions['datatype'])) {\n            $searchoptions['datatype'] = 'specific';\n         }\n\n         $options['display'] = false;\n\n         if (isset($options[$searchoptions['table'].'.'.$searchoptions['field']])) {\n            $options = array_merge($options,\n                                   $options[$searchoptions['table'].'.'.$searchoptions['field']]);\n         }\n\n         switch ($searchoptions['datatype']) {\n            case \"count\" :\n            case \"number\" :\n            case \"integer\" :\n               $copytooption = ['min', 'max', 'step', 'toadd', 'unit'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Dropdown::showNumber($name, $options);\n\n            case \"decimal\" :\n            case \"mac\" :\n            case \"ip\" :\n            case \"string\" :\n            case \"email\" :\n            case \"weblink\" :\n               $this->fields[$name] = $value;\n               return Html::autocompletionTextField($this, $name, $options);\n\n            case \"text\" :\n               $out = '';\n               if (isset($searchoptions['htmltext']) && $searchoptions['htmltext']) {\n                  $out = Html::initEditorSystem($name, '', false);\n               }\n               return $out.\"<textarea cols='45' rows='5' name='$name'>$value</textarea>\";\n\n            case \"bool\" :\n               return Dropdown::showYesNo($name, $value, -1, $options);\n\n            case \"color\" :\n               return Html::showColorField($name, $options);\n\n            case \"date\" :\n            case \"date_delay\" :\n               if (isset($options['relative_dates']) && $options['relative_dates']) {\n                  if (isset($searchoptions['maybefuture']) && $searchoptions['maybefuture']) {\n                     $options['with_future'] = true;\n                  }\n                  return Html::showGenericDateTimeSearch($name, $value, $options);\n               }\n               $copytooption = ['min', 'max', 'maybeempty', 'showyear'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Html::showDateField($name, $options);\n\n            case \"datetime\" :\n               if (isset($options['relative_dates']) && $options['relative_dates']) {\n                  if (isset($searchoptions['maybefuture']) && $searchoptions['maybefuture']) {\n                     $options['with_future'] = true;\n                  }\n                  $options['with_time'] = true;\n                  return Html::showGenericDateTimeSearch($name, $value, $options);\n               }\n               $copytooption = ['mindate', 'maxdate', 'mintime', 'maxtime',\n                                     'maybeempty', 'timestep'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Html::showDateTimeField($name, $options);\n\n            case \"timestamp\" :\n               $copytooption = ['addfirstminutes', 'emptylabel', 'inhours',  'max', 'min',\n                                     'step', 'toadd', 'display_emptychoice'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Dropdown::showTimeStamp($name, $options);\n\n            case \"itemlink\" :\n               // Do not use dropdown if wanted to select string value instead of ID\n               if (isset($options['itemlink_as_string']) && $options['itemlink_as_string']) {\n                  break;\n               }\n\n            case \"dropdown\" :\n               $copytooption     = ['condition', 'displaywith', 'emptylabel',\n                                         'right', 'toadd'];\n               $options['name']  = $name;\n               $options['value'] = $value;\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               if (!isset($options['entity'])) {\n                  $options['entity'] = $_SESSION['glpiactiveentities'];\n               }\n               $itemtype = getItemTypeForTable($searchoptions['table']);\n\n               return $itemtype::dropdown($options);\n\n            case \"right\" :\n                return Profile::dropdownRights(Profile::getRightsFor($searchoptions['rightclass']),\n                                               $name, $value, ['multiple' => false,\n                                                                    'display'  => false]);\n\n            case \"itemtypename\" :\n               if (isset($searchoptions['itemtype_list'])) {\n                  $options['types'] = $CFG_GLPI[$searchoptions['itemtype_list']];\n               }\n               $copytooption     = ['types'];\n               $options['value'] = $value;\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               if (isset($options['types'])) {\n                  return Dropdown::showItemTypes($name, $options['types'],\n                                                   $options);\n               }\n               return false;\n\n            case \"language\" :\n               $copytooption = ['emptylabel', 'display_emptychoice'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Dropdown::showLanguages($name, $options);\n\n         }\n         // Get specific display if available\n         $itemtype = getItemTypeForTable($searchoptions['table']);\n         if ($item = getItemForItemtype($itemtype)) {\n            $specific = $item->getSpecificValueToSelect($searchoptions['field'], $name,\n                                                        $values, $options);\n            if (strlen($specific)) {\n               return $specific;\n            }\n         }\n      }\n      // default case field text\n      $this->fields[$name] = $value;\n      return Html::autocompletionTextField($this, $name, $options);\n   }\n\n\n   /**\n    * @param string  $itemtype Item type\n    * @param string  $target   Target\n    * @param boolean $add      (default 0)\n    *\n    * @return false|void\n    */\n   static function listTemplates($itemtype, $target, $add = 0) {\n      global $DB;\n\n      if (!($item = getItemForItemtype($itemtype))) {\n         return false;\n      }\n\n      if (!$item->maybeTemplate()) {\n         return false;\n      }\n\n      // Avoid to get old data\n      $item->clearSavedInput();\n\n      //Check is user have minimum right r\n      if (!$item->canView()\n          && !$item->canCreate()) {\n         return false;\n      }\n\n      $request = [\n         'FROM'   => $item->getTable(),\n         'WHERE'  => [\n            'is_template'  => 1\n         ],\n         'ORDER'  => ['template_name']\n      ];\n\n      if ($item->isEntityAssign()) {\n         $request['WHERE'] = $request['WHERE'] + getEntitiesRestrictCriteria(\n            $item->getTable(),\n            'entities_id',\n            $_SESSION['glpiactiveentities'],\n            $item->maybeRecursive()\n         );\n      }\n\n      if (Session::isMultiEntitiesMode()) {\n         $colspan=3;\n      } else {\n         $colspan=2;\n      }\n\n      $iterator = $DB->request($request);\n      $blank_params = (strpos($target, '?') ? '&' : '?') . \"id=-1&withtemplate=2\";\n      $target_blank = $target . $blank_params;\n\n      if ($add && count($iterator) == 0) {\n         //if there is no template, just use blank\n         Html::redirect($target_blank);\n      }\n\n      echo \"<div class='center'><table class='tab_cadre'>\";\n      if ($add) {\n         echo \"<tr><th>\" . $item->getTypeName(1).\"</th>\";\n         echo \"<th>\".__('Choose a template').\"</th></tr>\";\n         echo \"<tr><td class='tab_bg_1 center' colspan='$colspan'>\";\n         echo \"<a href=\\\"\" . Html::entities_deep($target_blank) . \"\\\">\".__('Blank Template').\"</a></td>\";\n         echo \"</tr>\";\n      } else {\n         echo \"<tr><th>\".$item->getTypeName(1).\"</th>\";\n         if (Session::isMultiEntitiesMode()) {\n            echo \"<th>\".__('Entity').\"</th>\";\n         }\n         echo \"<th>\".__('Templates').\"</th></tr>\";\n      }\n\n      while ($data = $iterator->next()) {\n         $templname = $data[\"template_name\"];\n         if ($_SESSION[\"glpiis_ids_visible\"] || empty($data[\"template_name\"])) {\n            $templname = sprintf(__('%1$s (%2$s)'), $templname, $data[\"id\"]);\n         }\n         if (Session::isMultiEntitiesMode()) {\n            $entity = Dropdown::getDropdownName('glpi_entities', $data['entities_id']);\n         }\n         if ($item->canCreate() && !$add) {\n            $modify_params =\n               (strpos($target, '?') ? '&amp;' : '?')\n               . \"id=\".$data['id']\n               . \"&amp;withtemplate=1\";\n            $target_modify = $target . $modify_params;\n\n            echo \"<tr><td class='tab_bg_1 center'>\";\n            echo \"<a href=\\\"$target_modify\\\">\";\n            echo \"&nbsp;&nbsp;&nbsp;$templname&nbsp;&nbsp;&nbsp;</a></td>\";\n            if (Session::isMultiEntitiesMode()) {\n               echo \"<td class='tab_bg_1 center'>$entity</td>\";\n            }\n            echo \"<td class='tab_bg_2 center b'>\";\n            if ($item->can($data['id'], PURGE)) {\n               Html::showSimpleForm($target, 'purge', _x('button', 'Delete permanently'),\n                                    ['withtemplate' => 1,\n                                       'id'           => $data['id']]);\n            }\n            echo \"</td>\";\n         } else {\n            $add_params =\n               (strpos($target, '?') ? '&amp;' : '?')\n               . \"id=\".$data['id']\n               . \"&amp;withtemplate=2\";\n            $target_add = $target . $add_params;\n\n            echo \"<tr><td class='tab_bg_1 center' colspan='2'>\";\n            echo \"<a href=\\\"$target_add\\\">\";\n            echo \"&nbsp;&nbsp;&nbsp;$templname&nbsp;&nbsp;&nbsp;</a></td>\";\n         }\n         echo \"</tr>\";\n      }\n\n      if ($item->canCreate() && !$add) {\n         $create_params =\n            (strpos($target, '?') ? '&amp;' : '?')\n            . \"withtemplate=1\";\n         $target_create = $target . $create_params;\n         echo \"<tr><td class='tab_bg_2 center b' colspan='3'>\";\n         echo \"<a href=\\\"$target_create\\\">\" . __('Add a template...') . \"</a>\";\n         echo \"</td></tr>\";\n      }\n      echo \"</table></div>\\n\";\n   }\n\n\n   /**\n    * Specificy a plugin itemtype for which entities_id and is_recursive should be forwarded\n    *\n    * @since 0.83\n    *\n    * @param string $for_itemtype change of entity for this itemtype will be forwarder\n    * @param string $to_itemtype  change of entity will affect this itemtype\n    *\n    * @return void\n   **/\n   static function addForwardEntity($for_itemtype, $to_itemtype) {\n      self::$plugins_forward_entity[$for_itemtype][] = $to_itemtype;\n   }\n\n\n   /**\n    * Is entity informations forward To ?\n    *\n    * @since 0.84\n    *\n    * @param string $itemtype itemtype to check\n    *\n    * @return boolean\n   **/\n   static function isEntityForwardTo($itemtype) {\n\n      if (in_array($itemtype, static::$forward_entity_to)) {\n         return true;\n      }\n      //Fill forward_entity_to array with itemtypes coming from plugins\n      if (isset(static::$plugins_forward_entity[static::getType()])\n          && in_array($itemtype, static::$plugins_forward_entity[static::getType()])) {\n         return true;\n      }\n      return false;\n   }\n\n\n   /**\n    * Get rights for an item _ may be overload by object\n    *\n    * @since 0.85\n    *\n    * @param string $interface (defalt 'central')\n    *\n    * @return array array of rights to display\n   **/\n   function getRights($interface = 'central') {\n\n      $values = [CREATE  => __('Create'),\n                      READ    => __('Read'),\n                      UPDATE  => __('Update'),\n                      PURGE   => ['short' => __('Purge'),\n                                       'long'  => _x('button', 'Delete permanently')]];\n\n      $values += ObjectLock::getRightsToAdd( get_class($this), $interface );\n\n      if ($this->maybeDeleted()) {\n         $values[DELETE] = ['short' => __('Delete'),\n                                 'long'  => _x('button', 'Put in trashbin')];\n      }\n      if ($this->usenotepad) {\n         $values[READNOTE] = ['short' => __('Read notes'),\n                                   'long' => __(\"Read the item's notes\")];\n         $values[UPDATENOTE] = ['short' => __('Update notes'),\n                                     'long' => __(\"Update the item's notes\")];\n      }\n\n      return $values;\n   }\n\n   /**\n    * Generate link\n    *\n    * @since 9.1\n    *\n    * @param string     $link original string content\n    * @param CommonDBTM $item item used to make replacements\n    *\n    * @return array of link contents (may have several when item have several IP / MAC cases)\n   **/\n   static function generateLinkContents($link, CommonDBTM $item) {\n      return Link::generateLinkContents($link, $item);\n   }\n\n\n   /**\n    * add files from a textarea (from $this->input['content'])\n    * or a file input (from $this->input['_filename']) to an CommonDBTM object\n    * create document if needed\n    * create link from document to CommonDBTM object\n    *\n    * @since 9.2\n    *\n    * @param array $input   Input data\n    * @param array $options array with theses keys\n    *                        - force_update (default false) update the content field of the object\n    *                        - content_field (default content) the field who receive the main text\n    *                                                          (with images)\n    *                        - name (default filename) name of the HTML input containing files\n    *\n    * @return array the input param transformed\n   **/\n   function addFiles(array $input, $options = []) {\n      global $CFG_GLPI;\n\n      $default_options = [\n         'force_update'  => false,\n         'content_field' => 'content',\n         'name'          => 'filename',\n      ];\n      $options = array_merge($default_options, $options);\n\n      $uploadName = '_' . $options['name'];\n      $tagUploadName = '_tag_' . $options['name'];\n      $prefixUploadName = '_prefix_' . $options['name'];\n\n      if (!isset($input[$uploadName])\n          || (count($input[$uploadName]) == 0)) {\n         return $input;\n      }\n      $docadded     = [];\n      $donotif      = isset($input['_donotif']) ? $input['_donotif'] : 0;\n      $disablenotif = isset($input['_disablenotif']) ? $input['_disablenotif'] : 0;\n\n      foreach ($input[$uploadName] as $key => $file) {\n         $doc      = new Document();\n         $docitem  = new Document_Item();\n         $docID    = 0;\n         $filename = GLPI_TMP_DIR.\"/\".$file;\n         $input2   = [];\n\n         //If file tag is present\n         if (isset($input[$tagUploadName])\n             && !empty($input[$tagUploadName][$key])) {\n            $input['_tag'][$key] = $input[$tagUploadName][$key];\n         }\n\n         //retrieve entity\n         $entities_id = isset($_SESSION['glpiactive_entity']) ? $_SESSION['glpiactive_entity'] : 0;\n         if (isset($this->fields[\"entities_id\"])) {\n            $entities_id = $this->fields[\"entities_id\"];\n         } else if (isset($input['entities_id'])) {\n            $entities_id = $input['entities_id'];\n         } else if (isset($input['_job']->fields['entities_id'])) {\n            $entities_id = $input['_job']->fields['entities_id'];\n         }\n\n         // Check for duplicate\n         if ($doc->getFromDBbyContent($entities_id, $filename)) {\n            if (!$doc->fields['is_blacklisted']) {\n               $docID = $doc->fields[\"id\"];\n            }\n            // File already exist, we replace the tag by the existing one\n            if (isset($input['_tag'][$key])\n                && ($docID > 0)\n                && isset($input[$options['content_field']])) {\n\n               $input[$options['content_field']] = str_replace(\n                  $input['_tag'][$key],\n                  $doc->fields[\"tag\"],\n                  $input[$options['content_field']]\n               );\n               $docadded[$docID]['tag'] = $doc->fields[\"tag\"];\n            }\n\n         } else {\n            if ($this->getType() == 'Ticket') {\n               //TRANS: Default document to files attached to tickets : %d is the ticket id\n               $input2[\"name\"] = addslashes(sprintf(__('Document Ticket %d'), $this->getID()));\n               $input2[\"tickets_id\"] = $this->getID();\n            }\n\n            if (isset($input['_tag'][$key])) {\n               // Insert image tag\n               $input2[\"tag\"] = $input['_tag'][$key];\n            }\n\n            $input2[\"entities_id\"]             = $entities_id;\n            $input2[\"is_recursive\"]            = 1;\n            $input2[\"documentcategories_id\"]   = $CFG_GLPI[\"documentcategories_id_forticket\"];\n            $input2[\"_only_if_upload_succeed\"] = 1;\n            $input2[\"_filename\"]               = [$file];\n            if (isset($this->input[$prefixUploadName][$key])) {\n               $input2[$prefixUploadName]  = [$this->input[$prefixUploadName][$key]];\n            }\n            $docID = $doc->add($input2);\n\n            if (isset($input['_tag'][$key])) {\n               // Store image tag\n               $docadded[$docID]['tag'] = $doc->fields[\"tag\"];\n            }\n         }\n\n         if ($docID > 0) {\n            // complete doc information\n            $docadded[$docID]['data'] = sprintf(__('%1$s - %2$s'),\n                                                stripslashes($doc->fields[\"name\"]),\n                                                stripslashes($doc->fields[\"filename\"]));\n            $docadded[$docID]['filepath'] = $doc->fields[\"filepath\"];\n\n            // add doc - item link\n            $toadd = [\n               'documents_id'  => $docID,\n               '_do_notif'     => $donotif,\n               '_disablenotif' => $disablenotif,\n               'itemtype'      => $this->getType(),\n               'items_id'      => $this->getID()\n            ];\n            if (isset($input['users_id'])) {\n               $toadd['users_id'] = $input['users_id'];\n            }\n            if (isset($input[$options['content_field']])\n                && strpos($input[$options['content_field']], $doc->fields[\"tag\"]) !== false\n                && strpos($doc->fields['mime'], 'image/') !== false) {\n               //do not display inline docs in timeline\n               $toadd['timeline_position'] = CommonITILObject::NO_TIMELINE;\n            }\n\n            $docitem->add($toadd);\n         }\n         // Only notification for the first New doc\n         $donotif = false;\n      }\n\n      // manage content transformation\n      if (isset($input[$options['content_field']])) {\n         $input[$options['content_field']] = Toolbox::convertTagToImage(\n            $input[$options['content_field']],\n            $this,\n            $docadded\n         );\n\n         if (isset($this->input['_forcenotif'])) {\n            $input['_forcenotif'] = $this->input['_forcenotif'];\n            unset($input['_disablenotif']);\n         }\n\n         // force update of content on add process (we are in post_addItem function)\n         if ($options['force_update']) {\n            $this->fields[$options['content_field']] = $input[$options['content_field']];\n            $this->updateInDB([$options['content_field']]);\n         }\n      }\n\n      return $input;\n   }\n\n   /**\n    * Get autofill mark for/from templates\n    *\n    * @param string $field   Field name\n    * @param array  $options Withtemplate parameter\n    * @param string $value   Optional value (if field to check is not part of current itemtype)\n    *\n    * @return string\n    */\n   public function getAutofillMark($field, $options, $value = null) {\n      $mark = '';\n      $title = null;\n      if (($this->isTemplate() || $this->isNewItem()) && $options['withtemplate'] == 1) {\n         $title = __s('You can define an autofill template');\n      } else if ($this->isTemplate()) {\n         if ($value === null) {\n            $value = $this->getField($field);\n         }\n         $len = Toolbox::strlen($value);\n         if ($len > 8\n            && Toolbox::substr($value, 0, 4) === '&lt;'\n            && Toolbox::substr($value, $len -4, 4) === '&gt;'\n            && preg_match(\"/\\\\#{1,10}/\", Toolbox::substr($value, 4, $len - 8))\n         ) {\n            $title = __s('Autofilled from template');\n         } else {\n            return '';\n         }\n      }\n      if ($title !== null) {\n         $mark = \"<i class='fa fa-magic' title='$title'></i>\";\n      }\n      return $mark;\n   }\n\n   /**\n   * Manage business rules for assets\n   *\n   * @since 9.4\n   *\n   * @param boolean $condition the condition (RuleAsset::ONADD or RuleAsset::ONUPDATE)\n   *\n   * @return void\n   */\n   private function assetBusinessRules($condition) {\n      global $CFG_GLPI;\n\n      //Only process itemtype that are assets\n      if (in_array($this->getType(), $CFG_GLPI['asset_types'])) {\n         $ruleasset          = new RuleAssetCollection();\n         $input              = $this->input;\n         $input['_itemtype'] = $this->getType();\n\n         //If _auto is not defined : it's a manual process : set it's value to 0\n         if (!isset($this->input['_auto'])) {\n            $input['_auto'] = 0;\n         }\n         //Set the condition (add or update)\n         $params = [\n            'condition' => $condition\n         ];\n         $output = $ruleasset->processAllRules($input, [], $params);\n         //If at least one rule has matched\n         if (isset($output['_rule_process'])) {\n            foreach ($output as $key => $value) {\n               if ($key == '_rule_process' || $key == '_no_rule_matches') {\n                  continue;\n               }\n               //Add the rule output to the input array\n               $this->input[$key] = $value;\n            }\n         }\n      }\n   }\n\n   /**\n    * Ensure the relation would not create a circular parent-child relation.\n    * @since 9.5.0\n    * @param int    $items_id The ID of the item to evaluate.\n    * @param int    $parents_id  The wanted parent of the specified item.\n    * @return bool True if there is a circular relation.\n    */\n   static function checkCircularRelation($items_id, $parents_id) {\n      global $DB;\n\n      $fk = static::getForeignKeyField();\n      if ($items_id == 0 || $parents_id == 0 || !$DB->fieldExists(static::getTable(), $fk)) {\n         return false;\n      }\n\n      $next_parent = $parents_id;\n      while ($next_parent > 0) {\n         if ($next_parent == $items_id) {\n            // This item is a parent higher up\n            return true;\n         }\n         $iterator = $DB->request([\n            'SELECT' => [$fk],\n            'FROM'   => static::getTable(),\n            'WHERE'  => ['id' => $next_parent]\n         ]);\n         if ($iterator->count()) {\n            $next_parent = $iterator->next()[$fk];\n         } else {\n            // Invalid parent\n            return false;\n         }\n      }\n      // No circular relations\n      return false;\n   }\n\n   /**\n    * Get incidents, request, changes and problem linked to this object\n    *\n    * @return array\n    */\n   public function getITILTickets(bool $count = false) {\n      $ticket = new Ticket();\n      $problem = new Problem();\n      $change = new Change();\n\n      $data = [\n         'incidents' => iterator_to_array(\n            $ticket->getActiveTicketsForItem(\n               get_class($this),\n               $this->getID(),\n               Ticket::INCIDENT_TYPE\n            ),\n            false\n         ),\n         'requests'  => iterator_to_array(\n            $ticket->getActiveTicketsForItem(\n               get_class($this),\n               $this->getID(),\n               Ticket::DEMAND_TYPE\n            ),\n            false\n         ),\n         'changes'   => iterator_to_array(\n            $change->getActiveChangesForItem(\n               get_class($this),\n               $this->getID()\n            ),\n            false\n         ),\n         'problems'  => iterator_to_array(\n            $problem->getActiveProblemsForItem(\n               get_class($this),\n               $this->getID()\n            ),\n            false\n         )\n      ];\n\n      if ($count) {\n         $data['count'] = count($data['incidents'])\n            + count($data['requests'])\n            + count($data['changes'])\n            + count($data['problems']);\n      }\n\n      return $data;\n   }\n\n   static function getIcon() {\n      return \"fas fa-empty-icon\";\n   }\n\n   /**\n    * Get cache key containing raw name for a given itemtype and id\n    *\n    * @since 9.5\n    *\n    * @param string  $itemtype\n    * @param int     $id\n    */\n   public static function getCacheKeyForFriendlyName($itemtype, $id) {\n      return \"raw_name__{$itemtype}__{$id}\";\n   }\n\n   /**\n    * Get friendly name by items id\n    * The purpose of this function is to try to access the friendly name\n    * without having to read the object from the database\n    *\n    * @since 9.5\n    *\n    * @param int $id\n    *\n    * @return string Friendly name of the object\n    */\n   public static function getFriendlyNameById($id) {\n      $item = new static();\n      $item->getFromDB($id);\n      return $item->getFriendlyName();\n   }\n\n   /**\n    * Return the computed friendly name and set the cache.\n    *\n    * @since 9.5\n    *\n    * @return string\n    */\n   final public function getFriendlyName() {\n      return $this->computeFriendlyName();\n   }\n\n   /**\n    * Compute the friendly name of the object\n    *\n    * @since 9.5\n    *\n    * @return string\n    */\n   protected function computeFriendlyName() {\n      if (isset($this->fields[static::getNameField()])) {\n         return $this->fields[static::getNameField()];\n      }\n      return '';\n   }\n\n   /**\n    * Retrieve an item from the database\n    *\n    * @param integer $ID ID of the item to get\n    *\n    * @return boolean true if succeed else false\n   */\n   public static function getById(int $id) {\n      $item = new static();\n\n      if (!$item->getFromDB($id)) {\n         return false;\n      }\n\n      return $item;\n   }\n\n   /**\n    * Correct entity id if needed when cloning a template\n    *\n    * @param array  $data\n    * @param string $parent_field\n    *\n    * @return array\n    */\n   public static function checkTemplateEntity(\n      array $data,\n      $parent_id,\n      $parent_itemtype\n   ) {\n      // No entity field -> no modification needed\n      if (!isset($data['entities_id'])) {\n         return $data;\n      }\n\n      // If the entity used in the template in not allowed for our current user,\n      // fallback to the parent template entity\n      if (!Session::haveAccessToEntity($data['entities_id'])) {\n         // Load parent\n         $parent = new $parent_itemtype();\n\n         if (!$parent->getFromDB($parent_id)) {\n            // Can't load parent -> no modification\n            return $data;\n         }\n\n         $data['entities_id'] = $parent->getEntityID();\n      }\n\n      return $data;\n   }\n}\n", "<?php\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\nnamespace tests\\units;\n\nuse DbTestCase;\n\n/* Test for inc/calendar.class.php */\n\nclass Calendar extends DbTestCase {\n\n   public function testComputeEndDate() {\n      $calendar = new \\Calendar;\n      //get default calendar\n      $this->boolean($calendar->getFromDB(getItemByTypeName('Calendar', 'Default', true)))->isTrue();\n\n      // ## test future dates\n      $end_date = $calendar->ComputeEndDate(\"2018-11-19 10:00:00\", 7 * DAY_TIMESTAMP, 0, true);\n      $this->string($end_date)->isEqualTo(\"2018-11-28 10:00:00\");\n      // end of day\n      $end_date = $calendar->ComputeEndDate(\"2018-11-19 10:00:00\", 7 * DAY_TIMESTAMP, 0, true, true);\n      $this->string($end_date)->isEqualTo(\"2018-11-28 20:00:00\");\n\n      // ## test past dates\n      $end_date = $calendar->ComputeEndDate(\"2018-11-19 10:00:00\", -7 * DAY_TIMESTAMP, 0, true);\n      $this->string($end_date)->isEqualTo(\"2018-11-08 10:00:00\");\n      // end of day\n      $end_date = $calendar->ComputeEndDate(\"2018-11-19 10:00:00\", -7 * DAY_TIMESTAMP, 0, true, true);\n      $this->string($end_date)->isEqualTo(\"2018-11-08 20:00:00\");\n   }\n\n   protected function activeProvider() {\n      return [\n         [\n            'start'  => '2019-01-01 07:00:00',\n            'end'    => '2019-01-01 09:00:00',\n            'value'  => HOUR_TIMESTAMP\n         ], [\n            'start'  => '2019-01-01 06:00:00',\n            'end'    => '2019-01-01 07:00:00',\n            'value'  => 0\n         ], [\n            'start'  => '2019-01-01 00:00:00',\n            'end'    => '2019-01-08 00:00:00',\n            'value'  => 12 * HOUR_TIMESTAMP * 5\n         ], [\n            'start'  => '2019-01-08 00:00:00',\n            'end'    => '2019-01-01 00:00:00',\n            'value'  => 0\n         ], [\n            'start'  => '2019-01-01 07:00:00',\n            'end'    => '2019-01-01 09:00:00',\n            'value'  => HOUR_TIMESTAMP * 2,\n            'day'    => true\n         ], [\n            'start'  => '2019-01-01 00:00:00',\n            'end'    => '2019-01-08 00:00:00',\n            'value'  => WEEK_TIMESTAMP,\n            'day'    => true\n         ]\n      ];\n   }\n\n   /**\n    * @dataProvider activeProvider\n    */\n   public function testGetActiveTimeBetween($start, $end, $value, $days = false) {\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB(1))->isTrue(); //get default calendar\n\n      $this->variable(\n         $calendar->getActiveTimeBetween(\n            $start,\n            $end,\n            $days\n         )\n      )->isEqualTo($value);\n   }\n\n   protected function workingdayProvider() {\n      return [\n         ['2019-01-01 00:00:00', true],\n         ['2019-01-02 00:00:00', true],\n         ['2019-01-03 00:00:00', true],\n         ['2019-01-04 00:00:00', true],\n         ['2019-01-05 00:00:00', false],\n         ['2019-01-06 00:00:00', false]\n      ];\n   }\n\n   /**\n    * @dataProvider workingdayProvider\n    */\n   public function testIsAWorkingDay($date, $expected) {\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB(1))->isTrue(); //get default calendar\n\n      $this->boolean($calendar->isAWorkingDay(strtotime($date)))->isIdenticalTo($expected);\n   }\n\n   public function testHasAWorkingDay() {\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB(1))->isTrue(); //get default calendar\n      $this->boolean($calendar->hasAWorkingDay())->isTrue();\n\n      $cid = $calendar->add([\n         'name'   => 'Test'\n      ]);\n      $this->integer($cid)->isGreaterThan(0);\n      $this->boolean($calendar->getFromDB($cid));\n      $this->boolean($calendar->hasAWorkingDay())->isFalse();\n   }\n\n   protected function workinghourProvider() {\n      return [\n         ['2019-01-01 00:00:00', false],\n         ['2019-01-02 08:30:00', true],\n         ['2019-01-03 18:10:00', true],\n         ['2019-01-04 21:00:00', false],\n         ['2019-01-05 08:30:00', false],\n         ['2019-01-06 00:00:00', false]\n      ];\n   }\n\n   /**\n    * @dataProvider workinghourProvider\n    */\n   public function testIsAWorkingHour($date, $expected) {\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB(1))->isTrue(); //get default calendar\n\n      $this->boolean($calendar->isAWorkingHour(strtotime($date)))->isIdenticalTo($expected);\n   }\n\n   private function addXmas(\\Calendar $calendar) {\n      $calendar_holiday = new \\Calendar_Holiday();\n      $this->integer(\n         (int)$calendar_holiday->add([\n            'calendars_id' => $calendar->fields['id'],\n            'holidays_id'  => getItemByTypeName('Holiday', 'X-Mas', true)\n         ])\n      )->isGreaterThan(0);\n\n      $this->checkXmas($calendar);\n   }\n\n   private function checkXmas(\\Calendar $calendar) {\n      $this->boolean(\n         $calendar->isHoliday('2018-01-01')\n      )->isFalse();\n\n      $this->boolean(\n         $calendar->isHoliday('2019-01-01')\n      )->isTrue();\n   }\n\n   public function testIsHoliday() {\n      $calendar = new \\Calendar();\n      // get Default calendar\n      $this->boolean($calendar->getFromDB(getItemByTypeName('Calendar', 'Default', true)))->isTrue();\n\n      $this->addXmas($calendar);\n\n      $dates= [\n         '2019-05-01'   => true,\n         '2019-05-02'   => false,\n         '2019-07-01'   => false,\n         '2019-07-12'   => true\n      ];\n\n      //no holiday by default\n      foreach (array_keys($dates) as $date) {\n         $this->boolean($calendar->isHoliday($date))->isFalse;\n      }\n\n      //Add holidays\n      $calendar_holiday = new \\Calendar_Holiday();\n      $holiday = new \\Holiday();\n      $hid = (int)$holiday->add([\n         'name'         => '1st of may',\n         'entities_id'  => 0,\n         'is_recursive' => 1,\n         'begin_date'   => '2019-05-01',\n         'end_date'     => '2019-05-01',\n         'is_perpetual' => 1\n      ]);\n      $this->integer($hid)->isGreaterThan(0);\n      $this->integer(\n         (int)$calendar_holiday->add([\n            'holidays_id'  => $hid,\n            'calendars_id' => $calendar->fields['id']\n         ])\n      )->isGreaterThan(0);\n\n      $hid = (int)$holiday->add([\n         'name'   => 'Summer vacations',\n         'entities_id'  => 0,\n         'is_recursive' => 1,\n         'begin_date'   => '2019-07-08',\n         'end_date'     => '2019-09-01',\n         'is_perpetual' => 0\n      ]);\n      $this->integer($hid)->isGreaterThan(0);\n      $this->integer(\n         (int)$calendar_holiday->add([\n            'holidays_id'  => $hid,\n            'calendars_id' => $calendar->fields['id']\n         ])\n      )->isGreaterThan(0);\n\n      foreach ($dates as $date => $expected) {\n         $this->boolean($calendar->isHoliday($date))->isIdenticalTo($expected);\n      }\n   }\n\n   public function testClone() {\n      $calendar = new \\Calendar();\n      $default_id = getItemByTypeName('Calendar', 'Default', true);\n      // get Default calendar\n      $this->boolean($calendar->getFromDB($default_id))->isTrue();\n      $this->addXmas($calendar);\n\n      $id = $calendar->clone();\n      $this->integer($id)->isGreaterThan($default_id);\n      $this->boolean($calendar->getFromDB($id))->isTrue();\n      //should have been duplicated too.\n      $this->checkXmas($calendar);\n   }\n}\n", "<?php\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n*/\n\nnamespace tests\\units;\n\nuse DbTestCase;\n\n/* Test for inc/computer.class.php */\n\nclass Computer extends DbTestCase {\n\n   private function getNewComputer() {\n      $computer = getItemByTypeName('Computer', '_test_pc01');\n      $fields   = $computer->fields;\n      unset($fields['id']);\n      unset($fields['date_creation']);\n      unset($fields['date_mod']);\n      $fields['name'] = $this->getUniqueString();\n      $this->integer((int)$computer->add($fields))->isGreaterThan(0);\n      return $computer;\n   }\n\n   private function getNewPrinter() {\n      $printer  = getItemByTypeName('Printer', '_test_printer_all');\n      $pfields  = $printer->fields;\n      unset($pfields['id']);\n      unset($pfields['date_creation']);\n      unset($pfields['date_mod']);\n      $pfields['name'] = $this->getUniqueString();\n      $this->integer((int)$printer->add($pfields))->isGreaterThan(0);\n      return $printer;\n   }\n\n   public function testUpdate() {\n      global $CFG_GLPI;\n      $saveconf = $CFG_GLPI;\n\n      $computer = $this->getNewComputer();\n      $printer  = $this->getNewPrinter();\n\n      // Create the link\n      $link = new \\Computer_Item();\n      $in = ['computers_id' => $computer->getField('id'),\n             'itemtype'     => $printer->getType(),\n             'items_id'     => $printer->getID(),\n      ];\n      $this->integer((int)$link->add($in))->isGreaterThan(0);\n\n      // Change the computer\n      $CFG_GLPI['is_contact_autoupdate']  = 1;\n      $CFG_GLPI['is_user_autoupdate']     = 1;\n      $CFG_GLPI['is_group_autoupdate']    = 1;\n      $CFG_GLPI['state_autoupdate_mode']  = -1;\n      $CFG_GLPI['is_location_autoupdate'] = 1;\n      $in = ['id'           => $computer->getField('id'),\n             'contact'      => $this->getUniqueString(),\n             'contact_num'  => $this->getUniqueString(),\n             'users_id'     => $this->getUniqueInteger(),\n             'groups_id'    => $this->getUniqueInteger(),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update($in))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($printer->getFromDB($printer->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($printer->getField($k))->isEqualTo($v);\n      }\n\n      //reset values\n      $in = ['id'           => $computer->getField('id'),\n             'contact'      => '',\n             'contact_num'  => '',\n             'users_id'     => 0,\n             'groups_id'    => 0,\n             'states_id'    => 0,\n             'locations_id' => 0,\n      ];\n      $this->boolean($computer->update($in))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($printer->getFromDB($printer->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($printer->getField($k))->isEqualTo($v);\n      }\n\n      // Change the computer again\n      $CFG_GLPI['is_contact_autoupdate']  = 0;\n      $CFG_GLPI['is_user_autoupdate']     = 0;\n      $CFG_GLPI['is_group_autoupdate']    = 0;\n      $CFG_GLPI['state_autoupdate_mode']  = 0;\n      $CFG_GLPI['is_location_autoupdate'] = 0;\n      $in2 = ['id'          => $computer->getField('id'),\n             'contact'      => $this->getUniqueString(),\n             'contact_num'  => $this->getUniqueString(),\n             'users_id'     => $this->getUniqueInteger(),\n             'groups_id'    => $this->getUniqueInteger(),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update($in2))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($printer->getFromDB($printer->getID()))->isTrue();\n      unset($in2['id']);\n      foreach ($in2 as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation DOES NOT occurs\n         $this->variable($printer->getField($k))->isEqualTo($in[$k]);\n      }\n\n      // Restore configuration\n      $computer = $this->getNewComputer();\n      $CFG_GLPI = $saveconf;\n\n      //update devices\n      $cpu = new \\DeviceProcessor();\n      $cpuid = $cpu->add(\n         [\n            'designation'  => 'Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz',\n            'frequence'    => '1700'\n         ]\n      );\n\n      $this->integer((int)$cpuid)->isGreaterThan(0);\n\n      $link = new \\Item_DeviceProcessor();\n      $linkid = $link->add(\n         [\n            'items_id'              => $computer->getID(),\n            'itemtype'              => \\Computer::getType(),\n            'deviceprocessors_id'   => $cpuid,\n            'locations_id'          => $computer->getField('locations_id'),\n            'states_id'             => $computer->getField('status_id'),\n         ]\n      );\n\n      $this->integer((int)$linkid)->isGreaterThan(0);\n\n      // Change the computer\n      $CFG_GLPI['state_autoupdate_mode']  = -1;\n      $CFG_GLPI['is_location_autoupdate'] = 1;\n      $in = ['id'           => $computer->getField('id'),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update($in))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($link->getFromDB($link->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($link->getField($k))->isEqualTo($v);\n      }\n\n      //reset\n      $in = ['id'           => $computer->getField('id'),\n             'states_id'    => 0,\n             'locations_id' => 0,\n      ];\n      $this->boolean($computer->update($in))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($link->getFromDB($link->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($link->getField($k))->isEqualTo($v);\n      }\n\n      // Change the computer again\n      $CFG_GLPI['state_autoupdate_mode']  = 0;\n      $CFG_GLPI['is_location_autoupdate'] = 0;\n      $in2 = ['id'          => $computer->getField('id'),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update($in2))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($link->getFromDB($link->getID()))->isTrue();\n      unset($in2['id']);\n      foreach ($in2 as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation DOES NOT occurs\n         $this->variable($link->getField($k))->isEqualTo($in[$k]);\n      }\n\n      // Restore configuration\n      $CFG_GLPI = $saveconf;\n   }\n\n   /**\n    * Checks that newly created links inherits locations, status, and so on\n    *\n    * @return void\n    */\n   public function testCreateLinks() {\n      global $CFG_GLPI;\n\n      $computer = $this->getNewComputer();\n      $saveconf = $CFG_GLPI;\n\n      $CFG_GLPI['is_contact_autoupdate']  = 1;\n      $CFG_GLPI['is_user_autoupdate']     = 1;\n      $CFG_GLPI['is_group_autoupdate']    = 1;\n      $CFG_GLPI['state_autoupdate_mode']  = -1;\n      $CFG_GLPI['is_location_autoupdate'] = 1;\n\n      // Change the computer\n      $in = ['id'           => $computer->getField('id'),\n             'contact'      => $this->getUniqueString(),\n             'contact_num'  => $this->getUniqueString(),\n             'users_id'     => $this->getUniqueInteger(),\n             'groups_id'    => $this->getUniqueInteger(),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update($in))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n\n      $printer = new \\Printer();\n      $pid = $printer->add(\n         [\n            'name'         => 'A test printer',\n            'entities_id'  => $computer->getField('entities_id')\n         ]\n      );\n\n      $this->integer((int)$pid)->isGreaterThan(0);\n\n      // Create the link\n      $link = new \\Computer_Item();\n      $in2 = ['computers_id' => $computer->getField('id'),\n             'itemtype'     => $printer->getType(),\n             'items_id'     => $printer->getID(),\n      ];\n      $this->integer((int)$link->add($in2))->isGreaterThan(0);\n\n      $this->boolean($printer->getFromDB($printer->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($printer->getField($k))->isEqualTo($v);\n      }\n\n      //create devices\n      $cpu = new \\DeviceProcessor();\n      $cpuid = $cpu->add(\n         [\n            'designation'  => 'Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz',\n            'frequence'    => '1700'\n         ]\n      );\n\n      $this->integer((int)$cpuid)->isGreaterThan(0);\n\n      $link = new \\Item_DeviceProcessor();\n      $linkid = $link->add(\n         [\n            'items_id'              => $computer->getID(),\n            'itemtype'              => \\Computer::getType(),\n            'deviceprocessors_id'   => $cpuid\n         ]\n      );\n\n      $this->integer((int)$linkid)->isGreaterThan(0);\n\n      $in3 = ['states_id'    => $in['states_id'],\n              'locations_id' => $in['locations_id'],\n      ];\n\n      $this->boolean($link->getFromDB($link->getID()))->isTrue();\n      foreach ($in3 as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($link->getField($k))->isEqualTo($v);\n      }\n\n      // Restore configuration\n      $CFG_GLPI = $saveconf;\n   }\n\n   public function testGetFromIter() {\n      global $DB;\n\n      $iter = $DB->request(['SELECT' => 'id',\n                            'FROM'   => 'glpi_computers']);\n      $prev = false;\n      foreach (\\Computer::getFromIter($iter) as $comp) {\n         $this->object($comp)->isInstanceOf('Computer');\n         $this->array($comp->fields)\n            ->hasKey('name')\n            ->string['name']->isNotEqualTo($prev);\n         $prev = $comp->fields['name'];\n      }\n      $this->boolean((bool)$prev)->isTrue(); // we are retrieve something\n   }\n\n   public function testGetFromDbByCrit() {\n      $comp = new \\Computer();\n      $this->boolean($comp->getFromDBByCrit(['name' => '_test_pc01']))->isTrue();\n      $this->string($comp->getField('name'))->isIdenticalTo('_test_pc01');\n\n      $this->exception(\n         function () use ($comp) {\n            $this->boolean($comp->getFromDBByCrit(['name' => ['LIKE', '_test%']]))->isFalse();\n         }\n      )->message->contains('getFromDBByCrit expects to get one result, 8 found!');\n   }\n\n   public function testClone() {\n      $this->login();\n      $this->setEntity('_test_root_entity', true);\n\n      $date = date('Y-m-d H:i:s');\n      $_SESSION['glpi_currenttime'] = $date;\n\n      // Test item cloning\n      $computer = $this->getNewComputer();\n      $id = $computer->fields['id'];\n\n      //add note\n      $note = new \\Notepad();\n      $this->integer(\n         $note->add([\n            'itemtype'  => 'Computer',\n            'items_id'  => $id\n         ])\n      )->isGreaterThan(0);\n\n      //add os\n      $os = new \\OperatingSystem();\n      $osid = $os->add([\n         'name'   => 'My own OS'\n      ]);\n      $this->integer($osid)->isGreaterThan(0);\n\n      $ios = new \\Item_OperatingSystem();\n      $this->integer(\n         $ios->add([\n            'itemtype'  => 'Computer',\n            'items_id'  => $id\n         ])\n      )->isGreaterThan(0);\n\n      //add infocom\n      $infocom = new \\Infocom();\n      $this->integer(\n         $infocom->add([\n            'itemtype'  => 'Computer',\n            'items_id'  => $id\n         ])\n      )->isGreaterThan(0);\n\n      //add device\n      $cpu = new \\DeviceProcessor();\n      $cpuid = $cpu->add(\n         [\n            'designation'  => 'Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz',\n            'frequence'    => '1700'\n         ]\n      );\n\n      $this->integer((int)$cpuid)->isGreaterThan(0);\n\n      $link = new \\Item_DeviceProcessor();\n      $linkid = $link->add(\n         [\n            'items_id'              => $id,\n            'itemtype'              => 'Computer',\n            'deviceprocessors_id'   => $cpuid\n         ]\n      );\n      $this->integer((int)$linkid)->isGreaterThan(0);\n\n      //add document\n      $document = new \\Document();\n      $docid = (int)$document->add(['name' => 'Test link document']);\n      $this->integer($docid)->isGreaterThan(0);\n\n      $docitem = new \\Document_Item();\n      $this->integer(\n         $docitem->add([\n            'documents_id' => $docid,\n            'itemtype'     => 'Computer',\n            'items_id'     => $id\n         ])\n      )->isGreaterThan(0);\n\n      //clone!\n      $added = $computer->clone();\n      $this->integer((int)$added)->isGreaterThan(0);\n      $this->integer($added)->isNotEqualTo($computer->fields['id']);\n\n      $clonedComputer = new \\Computer();\n      $this->boolean($clonedComputer->getFromDB($added))->isTrue();\n\n      $fields = $computer->fields;\n\n      // Check the computers values. Id and dates must be different, everything else must be equal\n      foreach ($fields as $k => $v) {\n         switch ($k) {\n            case 'id':\n               $this->variable($clonedComputer->getField($k))->isNotEqualTo($computer->getField($k));\n               break;\n            case 'date_mod':\n            case 'date_creation':\n               $dateClone = new \\DateTime($clonedComputer->getField($k));\n               $expectedDate = new \\DateTime($date);\n               $this->dateTime($dateClone)->isEqualTo($expectedDate);\n               break;\n            default:\n               $this->variable($clonedComputer->getField($k))->isEqualTo($computer->getField($k));\n         }\n      }\n\n      //TODO: would be better to check each Computer::getCloneRelations() ones.\n      $relations = [\n         \\Infocom::class => 1,\n         \\Notepad::class  => 1,\n         \\Item_OperatingSystem::class => 1\n      ];\n\n      foreach ($relations as $relation => $expected) {\n         $this->integer(\n            countElementsInTable(\n               $relation::getTable(),\n               ['items_id' => $clonedComputer->fields['id']]\n            )\n         )->isIdenticalTo($expected);\n      }\n\n      //check processor has been cloned\n      $this->boolean($link->getFromDBByCrit(['itemtype' => 'Computer', 'items_id' => $added]))->isTrue();\n      $this->boolean($docitem->getFromDBByCrit(['itemtype' => 'Computer', 'items_id' => $added]))->isTrue();\n   }\n}\n"], "fixing_code": ["<?php\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\nif (!defined('GLPI_ROOT')) {\n   die(\"Sorry. You can't access this file directly\");\n}\n\n/**\n * Calendar Class\n**/\nclass Calendar extends CommonDropdown {\n   use Glpi\\Features\\Clonable;\n\n   // From CommonDBTM\n   public $dohistory                   = true;\n   public $can_be_translated           = false;\n\n   static protected $forward_entity_to = ['CalendarSegment'];\n\n   static $rightname = 'calendar';\n\n\n   public function getCloneRelations() :array {\n      return [\n         Calendar_Holiday::class,\n         CalendarSegment::class\n      ];\n   }\n\n\n   /**\n    * @since 0.84\n   **/\n   function getForbiddenStandardMassiveAction() {\n\n      $forbidden   = parent::getForbiddenStandardMassiveAction();\n      $forbidden[] = 'CommonDropdown'.MassiveAction::CLASS_ACTION_SEPARATOR.'merge';\n      return $forbidden;\n   }\n\n\n   static function getTypeName($nb = 0) {\n      return _n('Calendar', 'Calendars', $nb);\n   }\n\n\n   function defineTabs($options = []) {\n\n      $ong = parent::defineTabs($options);\n      $this->addStandardTab('CalendarSegment', $ong, $options);\n      $this->addStandardTab('Calendar_Holiday', $ong, $options);\n\n      return $ong;\n   }\n\n\n   function getSpecificMassiveActions($checkitem = null) {\n\n      $isadmin = static::canUpdate();\n      $actions = parent::getSpecificMassiveActions($checkitem);\n\n      if ($isadmin) {\n         $actions[__CLASS__.MassiveAction::CLASS_ACTION_SEPARATOR.'duplicate'] = _x('button', 'Duplicate');\n         $actions[__CLASS__.MassiveAction::CLASS_ACTION_SEPARATOR.'addholiday'] = __('Add a close time');\n      }\n      return $actions;\n   }\n\n\n   static function showMassiveActionsSubForm(MassiveAction $ma) {\n\n      switch ($ma->getAction()) {\n         case 'duplicate' :\n            Entity::dropdown();\n            echo \"<br><br>\";\n            echo Html::submit(_x('button', 'Duplicate'), ['name' => 'massiveaction']).\"</span>\";\n            return true;\n\n         case 'addholiday' :\n            Holiday::dropdown();\n            echo \"<br><br>\";\n            echo Html::submit(_x('button', 'Add'), ['name' => 'massiveaction']).\"</span>\";\n            return true;\n      }\n\n      return parent::showMassiveActionsSubForm($ma);\n   }\n\n\n   static function processMassiveActionsForOneItemtype(MassiveAction $ma, CommonDBTM $item,\n                                                       array $ids) {\n\n      switch ($ma->getAction()) {\n         case 'duplicate' : // For calendar duplicate in another entity\n            if (method_exists($item, 'duplicate')) {\n               $input = $ma->getInput();\n               $options = [];\n               if ($item->isEntityAssign()) {\n                  $options = ['entities_id' => $input['entities_id']];\n               }\n               foreach ($ids as $id) {\n                  if ($item->getFromDB($id)) {\n                     if (!$item->isEntityAssign()\n                         || ($input['entities_id'] != $item->getEntityID())) {\n                        if ($item->can(-1, CREATE, $options)) {\n                           if ($item->duplicate($options)) {\n                              $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_OK);\n                           } else {\n                              $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                              $ma->addMessage($item->getErrorMessage(ERROR_ON_ACTION));\n                           }\n                        } else {\n                           $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_NORIGHT);\n                           $ma->addMessage($item->getErrorMessage(ERROR_RIGHT));\n                        }\n                     } else {\n                        $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                        $ma->addMessage($item->getErrorMessage(ERROR_COMPAT));\n                     }\n                  } else {\n                     $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                     $ma->addMessage($item->getErrorMessage(ERROR_NOT_FOUND));\n                  }\n               }\n            } else {\n               $ma->itemDone($item->getType(), $ids, MassiveAction::ACTION_KO);\n            }\n            return;\n\n         case 'addholiday' : // add an holiday with massive action\n            $input = $ma->getInput();\n            if ($input['holidays_id'] > 0) {\n               $holiday          = new Holiday();\n               $calendar_holiday = new Calendar_Holiday();\n\n               $holiday->getFromDB($input['holidays_id']);\n               $entities = [$holiday->getEntityID() => $holiday->getEntityID()];\n               if ($holiday->isRecursive()) {\n                  $entities = getSonsOf(\"glpi_entities\", $holiday->getEntityID());\n               }\n\n               foreach ($ids as $id) {\n                  $entities_id = CommonDBTM::getItemEntity('Calendar', $id);\n                  if (isset($entities[$entities_id])) {\n                     $input = ['calendars_id' => $id,\n                                    'holidays_id'  => $input['holidays_id']];\n                     if ($calendar_holiday->add($input)) {\n                        $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_OK);\n                     } else {\n                        $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                        $ma->addMessage($item->getErrorMessage(ERROR_ON_ACTION));\n                     }\n                  } else {\n                     $ma->itemDone($item->getType(), $id, MassiveAction::ACTION_KO);\n                     $ma->addMessage($item->getErrorMessage(ERROR_ON_ACTION));\n                  }\n               }\n            } else {\n               $ma->itemDone($item->getType(), $ids, MassiveAction::ACTION_KO);\n            }\n            return;\n      }\n      parent::processMassiveActionsForOneItemtype($ma, $item, $ids);\n   }\n\n\n   /**\n    * Clone a calendar to another entity : name is updated\n    *\n    * @param $options array of new values to set\n    * @return boolean True on success\n    */\n   function duplicate($options = []) {\n\n      $input = Toolbox::addslashes_deep($this->fields);\n      unset($input['id']);\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $val) {\n            if (isset($this->fields[$key])) {\n               $input[$key] = $val;\n            }\n         }\n      }\n\n      if ($newID = $this->clone($input)) {\n         $this->updateDurationCache($newID);\n         return true;\n      }\n\n      return false;\n   }\n\n\n   function cleanDBonPurge() {\n\n      $this->deleteChildrenAndRelationsFromDb(\n         [\n            Calendar_Holiday::class,\n            CalendarSegment::class,\n         ]\n      );\n   }\n\n   /**\n    * Check if the given date is a holiday\n    *\n    * @param string $date Date of the day to check\n    *\n    * @return boolean\n   **/\n   function isHoliday($date) {\n      global $DB;\n\n      $result = $DB->request([\n         'COUNT'        => 'cpt',\n         'FROM'         => 'glpi_calendars_holidays',\n         'INNER JOIN'   => [\n            'glpi_holidays'   => [\n               'ON' => [\n                  'glpi_calendars_holidays'  => 'holidays_id',\n                  'glpi_holidays'            => 'id'\n               ]\n            ]\n         ],\n         'WHERE'        => [\n            'glpi_calendars_holidays.calendars_id' => $this->fields['id'],\n            'OR'                                   => [\n               [\n                  'AND' => [\n                     'glpi_holidays.end_date'            => ['>=', $date],\n                     'glpi_holidays.begin_date'          => ['<=', $date]\n                  ]\n               ],\n               [\n                  'AND' => [\n                     'glpi_holidays.is_perpetual'  => 1,\n                     new \\QueryExpression(\"MONTH(\".$DB->quoteName('end_date').\")*100 + DAY(\".$DB->quoteName('end_date').\") >= \".date('nd', strtotime($date))),\n                     new \\QueryExpression(\"MONTH(\".$DB->quoteName('begin_date').\")*100 + DAY(\".$DB->quoteName('begin_date').\") <= \".date('nd', strtotime($date)))\n                  ]\n               ]\n            ]\n         ]\n      ])->next();\n\n      return (int)$result['cpt'] > 0;\n   }\n\n\n   /**\n    * Get active time between to date time for the active calendar\n    *\n    * @param $start           datetime begin\n    * @param $end             datetime end\n    * @param $work_in_days    boolean  force working in days (false by default)\n    *\n    * @return integer timestamp of delay\n    */\n   function getActiveTimeBetween($start, $end, $work_in_days = false) {\n\n      if (!isset($this->fields['id'])) {\n         return false;\n      }\n\n      if ($end < $start) {\n         return 0;\n      }\n\n      $timestart  = strtotime($start);\n      $timeend    = strtotime($end);\n      $datestart  = date('Y-m-d', $timestart);\n      $dateend    = date('Y-m-d', $timeend);\n      // Need to finish at the closing day : set hour to midnight (23:59:59 for PHP)\n      $timerealend = strtotime($dateend.' 23:59:59');\n\n      $activetime = 0;\n\n      if ($work_in_days) {\n         $activetime = $timeend-$timestart;\n\n      } else {\n         $cache_duration = $this->getDurationsCache();\n\n         for ($actualtime=$timestart; $actualtime<=$timerealend; $actualtime+=DAY_TIMESTAMP) {\n            $actualdate = date('Y-m-d', $actualtime);\n\n            if (!$this->isHoliday($actualdate)) {\n               $beginhour    = '00:00:00';\n               // Calendar segment work with '24:00:00' format for midnight\n               $endhour      = '24:00:00';\n               $dayofweek    = self::getDayNumberInWeek($actualtime);\n               $timeoftheday = 0;\n\n               if ($actualdate == $datestart) { // First day : cannot use cache\n                  $beginhour = date('H:i:s', $timestart);\n               }\n\n               if ($actualdate == $dateend) { // Last day : cannot use cache\n                  $endhour = date('H:i:s', $timeend);\n               }\n\n               if ((($actualdate == $datestart) || ($actualdate == $dateend))\n                   && ($cache_duration[$dayofweek] > 0)) {\n                  $timeoftheday = CalendarSegment::getActiveTimeBetween($this->fields['id'],\n                                                                        $dayofweek, $beginhour,\n                                                                        $endhour);\n               } else {\n                  $timeoftheday = $cache_duration[$dayofweek];\n               }\n               $activetime += $timeoftheday;\n            }\n         }\n      }\n      return $activetime;\n   }\n\n\n   /**\n    * Check if the given time is on a working day (does not check working hours)\n    *\n    * @since 0.84\n    *\n    * @param integer $time Time to check\n    *\n    * @return boolean\n    */\n   function isAWorkingDay($time) {\n\n      $cache_duration   = $this->getDurationsCache();\n      $dayofweek        = self::getDayNumberInWeek($time);\n      $date             = date('Y-m-d', $time);\n      return (($cache_duration[$dayofweek] > 0) && !$this->isHoliday($date));\n   }\n\n\n   /**\n    * Determines if calendar has, at least, one working day.\n    *\n    * @since 9.4.3\n    *\n    * @return boolean\n    */\n   public function hasAWorkingDay() {\n\n      $durations = $this->getDurationsCache();\n      return false !== $durations && array_sum($durations) > 0;\n   }\n\n\n   /**\n    *\n    * Check if the given time is in a working hour\n    *\n    * @since 0.85\n    *\n    * @param integer $time Time to check\n    *\n    * @return boolean\n    */\n   function isAWorkingHour($time) {\n\n      if ($this->isAWorkingDay($time)) {\n         $dayofweek = self::getDayNumberInWeek($time);\n         return CalendarSegment::isAWorkingHour($this->fields['id'], $dayofweek,\n                                                date('H:i:s', $time));\n      }\n      return false;\n   }\n\n\n   /**\n    * Add a delay to a date using the active calendar\n    *\n    * if delay >= DAY_TIMESTAMP : work in days\n    * else work in minutes\n    *\n    * @param datetime $start               begin\n    * @param integer  $delay               delay to add (in seconds)\n    * @param integer  $additional_delay    delay to add (default 0)\n    * @param boolean  $work_in_days        force working in days (false by default)\n    * @param boolean  $end_of_working_day  end of working day (false by default)\n    *\n    * @return boolean|string end date\n   **/\n   function computeEndDate($start, $delay, $additional_delay = 0, $work_in_days = false, $end_of_working_day = false) {\n\n      if (!isset($this->fields['id'])) {\n         return false;\n      }\n\n      if (!$this->hasAWorkingDay()) {\n         // Invalid calendar (no working day = unable to find any date inside calendar hours)\n         return false;\n      }\n\n      $actualtime = strtotime($start);\n      $timestart  = strtotime($start);\n      $datestart  = date('Y-m-d', $timestart);\n\n      // manage dates in past\n      $negative_delay = false;\n      if ($delay < 0) {\n         $delay = -$delay;\n         $negative_delay = true;\n      }\n\n      // End of working day\n      if ($end_of_working_day) {\n         $numberofdays = $delay / DAY_TIMESTAMP;\n         // Add $additional_delay to start time.\n         // If start + delay is next day : +1 day\n         $actualtime += $additional_delay;\n         $cache_duration = $this->getDurationsCache();\n         $dayofweek      = self::getDayNumberInWeek($actualtime);\n         $actualdate     = date('Y-m-d', $actualtime);\n\n         // Begin next day working\n         if ($this->isHoliday($actualdate)\n             || ($cache_duration[$dayofweek] == 0)) {\n\n            while ($this->isHoliday($actualdate)\n                   || ($cache_duration[$dayofweek] == 0)) {\n               $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n               $actualdate  = date('Y-m-d', $actualtime);\n               $dayofweek   = self::getDayNumberInWeek($actualtime);\n            }\n         }\n\n         while ($numberofdays > 0) {\n            if (!$this->isHoliday($actualdate)\n                && ($cache_duration[$dayofweek] > 0)) {\n               $numberofdays --;\n            }\n            $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n            $actualdate  = date('Y-m-d', $actualtime);\n            $dayofweek   = self::getDayNumberInWeek($actualtime);\n         }\n\n         // Get next working day\n         if ($this->isHoliday($actualdate)\n             || ($cache_duration[$dayofweek] == 0)) {\n\n            while ($this->isHoliday($actualdate)\n                   || ($cache_duration[$dayofweek] == 0)) {\n               $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n               $actualdate  = date('Y-m-d', $actualtime);\n               $dayofweek   = self::getDayNumberInWeek($actualtime);\n            }\n         }\n\n         $lastworkinghour = CalendarSegment::getLastWorkingHour($this->fields['id'], $dayofweek);\n         $actualtime      = strtotime(date('Y-m-d', $actualtime).' '.$lastworkinghour);\n         return date('Y-m-d H:i:s', $actualtime);\n      }\n\n      // Add additional delay to initial delay\n      $delay += $additional_delay;\n\n      if ($work_in_days) { // only based on days\n         $cache_duration = $this->getDurationsCache();\n\n         // Compute Real starting time\n         // If day is an holiday must start on the begin of next working day\n         $actualdate = date('Y-m-d', $actualtime);\n         $dayofweek  = self::getDayNumberInWeek($actualtime);\n         if ($this->isHoliday($actualdate)\n             || ($cache_duration[$dayofweek] == 0)) {\n\n            while ($this->isHoliday($actualdate)\n                   || ($cache_duration[$dayofweek] == 0)) {\n               $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n               $actualdate = date('Y-m-d', $actualtime);\n               $dayofweek  = self::getDayNumberInWeek($actualtime);\n            }\n            $firstworkhour = CalendarSegment::getFirstWorkingHour($this->fields['id'],\n                                                                  $dayofweek);\n            $actualtime    = strtotime($actualdate.' '.$firstworkhour);\n         }\n\n         while ($delay > 0) {\n            // Begin next day : do not take into account first day : must finish to a working day\n            $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n            $actualdate = date('Y-m-d', $actualtime);\n            $dayofweek  = self::getDayNumberInWeek($actualtime);\n\n            if (!$this->isHoliday($actualdate)\n                && ($cache_duration[$dayofweek] > 0)) {\n               $delay -= DAY_TIMESTAMP;\n            }\n            if ($delay < 0) { // delay done : if < 0 delete hours\n               $actualtime = self::getActualTime($actualtime, $delay, $negative_delay);\n            }\n         }\n\n         // If > last working hour set last working hour\n         $dayofweek       = self::getDayNumberInWeek($actualtime);\n         $lastworkinghour = CalendarSegment::getLastWorkingHour($this->fields['id'], $dayofweek);\n         if ($lastworkinghour < date('H:i:s', $actualtime)) {\n            $actualtime   = strtotime(date('Y-m-d', $actualtime).' '.$lastworkinghour);\n         }\n\n         return date('Y-m-d H:i:s', $actualtime);\n      }\n\n      // else  // based on working hours\n      $cache_duration = $this->getDurationsCache();\n\n      // Only if segments exists\n      if (countElementsInTable('glpi_calendarsegments',\n                               ['calendars_id' => $this->fields['id']])) {\n         while ($delay >= 0) {\n            $actualdate = date('Y-m-d', $actualtime);\n            if (!$this->isHoliday($actualdate)) {\n               $dayofweek = self::getDayNumberInWeek($actualtime);\n               $beginhour = '00:00:00';\n\n               if ($actualdate == $datestart) { // First day cannot use cache\n                  $beginhour    = date('H:i:s', $timestart);\n                  $timeoftheday = CalendarSegment::getActiveTimeBetween($this->fields['id'],\n                                                                        $dayofweek, $beginhour,\n                                                                        '24:00:00');\n               } else {\n                  $timeoftheday = $cache_duration[$dayofweek];\n               }\n\n               if ($timeoftheday <= $delay && !$negative_delay\n                  || $timeoftheday >= $delay && $negative_delay) {\n                  // Delay is greater or equal than remaining time in day\n                  // -> pass to next day\n                  $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n                  $delay      -= $timeoftheday;\n               } else {\n                  // End of the delay in the day : get hours with this delay\n                  $endhour = CalendarSegment::addDelayInDay($this->fields['id'], $dayofweek,\n                                                            $beginhour, $delay);\n                  return $actualdate.' '.$endhour;\n               }\n\n            } else { // Holiday : pass to next day\n               $actualtime = self::getActualTime($actualtime, DAY_TIMESTAMP, $negative_delay);\n            }\n         }\n      }\n      return false;\n   }\n\n   static function getActualTime($current_time, $number = 0, $negative = false) {\n      if ($negative) {\n         return $current_time - $number;\n      } else {\n         return $current_time + $number;\n      }\n   }\n\n\n   /**\n    * Get days durations including all segments of the current calendar\n    *\n    * @return boolean|array\n   **/\n   function getDurationsCache() {\n\n      if (!isset($this->fields['id'])) {\n         return false;\n      }\n      $cache_duration = importArrayFromDB($this->fields['cache_duration']);\n\n      // Invalid cache duration : recompute it\n      if (!isset($cache_duration[0])) {\n         $this->updateDurationCache($this->fields['id']);\n         $cache_duration = importArrayFromDB($this->fields['cache_duration']);\n      }\n\n      return $cache_duration;\n   }\n\n\n   /**\n    * Get days durations including all segments of the current calendar\n    *\n    * @return boolean|array\n   **/\n   function getDaysDurations() {\n\n      if (!isset($this->fields['id'])) {\n         return false;\n      }\n\n      $results = [];\n      for ($i=0; $i<7; $i++) {\n         $results[$i] = CalendarSegment::getActiveTimeBetween($this->fields['id'], $i, '00:00:00',\n                                                              '24:00:00');\n      }\n      return $results;\n   }\n\n\n   /**\n    * Update the calendar cache\n    *\n    * @param integer $calendars_id ID of the calendar\n    *\n    * @return bool True if successful in updating the cache, otherwise returns false.\n    */\n   function updateDurationCache($calendars_id) {\n\n      if ($this->getFromDB($calendars_id)) {\n         $input = [\n            'id'             => $calendars_id,\n            'cache_duration' => exportArrayToDB($this->getDaysDurations()),\n         ];\n         return $this->update($input);\n      }\n      return false;\n   }\n\n\n   /**\n    * Get day number (in week) for a date.\n    *\n    * @param integer $date Date as a UNIX timestamp\n    *\n    * @return integer\n    */\n   static function getDayNumberInWeek($date) {\n      return (int)date('w', $date);\n   }\n}\n", "<?php\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\nuse Glpi\\Event;\n\nif (!defined('GLPI_ROOT')) {\n   die(\"Sorry. You can't access this file directly\");\n}\n\n/**\n*  Common DataBase Table Manager Class - Persistent Object\n**/\nclass CommonDBTM extends CommonGLPI {\n\n   /**\n    * Data fields of the Item.\n    *\n    * @var mixed[]\n    */\n   public $fields = [];\n\n   /**\n    * Flag to determine whether or not changes must be logged into history.\n    *\n    * @var boolean\n    */\n   public $dohistory = false;\n\n   /**\n    * List of fields that must not be taken into account when logging history or computating last\n    * modification date.\n    *\n    * @var string[]\n    */\n   public $history_blacklist = [];\n\n   /**\n    * Flag to determine whether or not automatic messages must be generated on actions.\n    *\n    * @var boolean\n    */\n   public $auto_message_on_action = true;\n\n   /**\n    * Flag to determine whether or not a link to item form can be automatically generated via\n    * self::getLink() method.\n    *\n    * @var boolean\n    */\n   public $no_form_page = false;\n\n   /**\n    * Flag to determine whether or not table name of item can be automatically generated via\n    * self::getTable() method.\n    *\n    * @var boolean\n    */\n   static protected $notable = false;\n\n   /**\n    * List of fields that must not be taken into account for dictionnary processing.\n    *\n    * @var string[]\n    */\n   public $additional_fields_for_dictionnary = [];\n\n   /**\n    * List of linked item types on which entities informations should be forwarded on update.\n    *\n    * @var string[]\n    */\n   static protected $forward_entity_to = [];\n\n   /**\n    * Foreign key field cache : set dynamically calling getForeignKeyField\n    *\n    * @TODO Remove this variable as it is not used ?\n    */\n   protected $fkfield = \"\";\n\n   /**\n    * Search option of item. Initialized on first call to self::getOptions() and used as cache.\n    *\n    * @var array\n    *\n    * @TODO Should be removed and replaced by real cache usage.\n    */\n   protected $searchopt = false;\n\n   /**\n    * {@inheritDoc}\n    */\n   public $taborientation = 'vertical';\n\n   /**\n    * {@inheritDoc}\n    */\n   public $get_item_to_display_tab = true;\n\n   /**\n    * List of linked item types from plugins on which entities informations should be forwarded on update.\n    *\n    * @var array\n    */\n   static protected $plugins_forward_entity = [];\n\n   /**\n    * Flag to determine whether or not table name of item has a notepad.\n    *\n    * @var boolean\n    */\n   protected $usenotepad = false;\n\n   /**\n    * Flag to determine whether or not notification queu should be flushed immediately when an\n    * action is performed on item.\n    *\n    * @var boolean\n    */\n   public $notificationqueueonaction = false;\n\n   /**\n    * Computed/forced values of classes tables.\n    * @var string[]\n    */\n   protected static $tables_of = [];\n\n   /**\n    * Computed values of classes foreign keys.\n    * @var string[]\n    */\n   protected static $foreign_key_fields_of = [];\n\n\n   /**\n    * Fields to remove when querying data with api\n    * @var array\n    */\n   static $undisclosedFields = [];\n\n   /**\n    * Constructor\n   **/\n   function __construct () {\n   }\n\n\n   /**\n    * Return the table used to store this object\n    *\n    * @param string $classname Force class (to avoid late_binding on inheritance)\n    *\n    * @return string\n   **/\n   static function getTable($classname = null) {\n      if ($classname === null) {\n         $classname = get_called_class();\n      }\n\n      if (!class_exists($classname) || $classname::$notable) {\n         return '';\n      }\n\n      if (!isset(self::$tables_of[$classname]) || empty(self::$tables_of[$classname])) {\n         self::$tables_of[$classname] = getTableForItemType($classname);\n      }\n\n      return self::$tables_of[$classname];\n   }\n\n\n   /**\n    * force table value (used for config management for old versions)\n    *\n    * @param string $table name of the table to be forced\n    *\n    * @return void\n   **/\n   static function forceTable($table) {\n      self::$tables_of[get_called_class()] = $table;\n   }\n\n\n   static function getForeignKeyField() {\n      $classname = get_called_class();\n\n      if (!isset(self::$foreign_key_fields_of[$classname])\n         || empty(self::$foreign_key_fields_of[$classname])) {\n         self::$foreign_key_fields_of[$classname] = getForeignKeyFieldForTable(static::getTable());\n      }\n\n      return self::$foreign_key_fields_of[$classname];\n   }\n\n   /**\n    * Return SQL path to access a field.\n    *\n    * @param string      $field     Name of the field (or SQL keyword like '*')\n    * @param string|null $classname Forced classname (to avoid late_binding on inheritance)\n    *\n    * @return string\n    *\n    * @throws InvalidArgumentException\n    * @throws LogicException\n    **/\n   static function getTableField($field, $classname = null) {\n\n      if (empty($field)) {\n         throw new InvalidArgumentException('Argument $field cannot be empty.');\n      }\n\n      $tablename = self::getTable($classname);\n      if (empty($tablename)) {\n         throw new LogicException('Invalid table name.');\n      }\n\n      return sprintf('%s.%s', $tablename, $field);\n   }\n\n   /**\n    * Retrieve an item from the database\n    *\n    * @param integer $ID ID of the item to get\n    *\n    * @return boolean true if succeed else false\n   **/\n   function getFromDB($ID) {\n      global $DB;\n      // Make new database object and fill variables\n\n      // != 0 because 0 is consider as empty\n      if (strlen($ID) == 0) {\n         return false;\n      }\n\n      $iterator = $DB->request([\n         'FROM'   => $this->getTable(),\n         'WHERE'  => [\n            $this->getTable() . '.' . $this->getIndexName() => Toolbox::cleanInteger($ID)\n         ],\n         'LIMIT'  => 1\n      ]);\n\n      if (count($iterator) == 1) {\n         $this->fields = $iterator->next();\n         $this->post_getFromDB();\n         return true;\n      } else if (count($iterator) > 1) {\n         Toolbox::logWarning(\n            sprintf(\n               'getFromDB expects to get one result, %1$s found!',\n               count($iterator)\n            )\n         );\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Hydrate an object from a resultset row\n    *\n    * @param array $rs The row\n    *\n    * @return void\n    */\n   function getFromResultSet($rs) {\n      //just set fields!\n      $this->fields = $rs;\n   }\n\n\n   /**\n    * Generator to browse object from an iterator\n    * @see http://php.net/manual/en/language.generators.syntax.php\n    *\n    * @since 9.2\n    *\n    * @param DBmysqlIterator $iter Iterator instance\n    *\n    * @return CommonDBTM\n    */\n   public static function getFromIter(DBmysqlIterator $iter) {\n      $item = new static;\n\n      foreach ($iter as $row) {\n         if (!isset($row[\"id\"])) {\n            continue;\n         }\n         if ($item->getFromDB($row[\"id\"])) {\n            yield $item;\n         }\n      }\n   }\n\n\n   /**\n    * Get an object using some criteria\n    *\n    * @since 9.2\n    *\n    * @param Array $crit search criteria\n    *\n    * @return boolean|array\n    */\n   public function getFromDBByCrit(array $crit) {\n      global $DB;\n\n      $crit = ['SELECT' => 'id',\n               'FROM'   => $this->getTable(),\n               'WHERE'  => $crit];\n\n      $iter = $DB->request($crit);\n      if (count($iter) == 1) {\n         $row = $iter->next();\n         return $this->getFromDB($row['id']);\n      } else if (count($iter) > 1) {\n         Toolbox::logWarning(\n            sprintf(\n               'getFromDBByCrit expects to get one result, %1$s found!',\n               count($iter)\n            )\n         );\n      }\n      return false;\n   }\n\n\n   /**\n    * Retrieve an item from the database by request. The request is an array\n    * similar to the one expected in DB::request().\n    *\n    * @since 9.3\n    *\n    * @see DB::request()\n    *\n    * @param array $request expression\n    *\n    * @return boolean true if succeed else false\n    **/\n   public function getFromDBByRequest(array $request) {\n      global $DB;\n\n      // Limit the request to the useful expressions\n      $request = array_diff_key($request, [\n         'FROM' => '',\n         'SELECT' => '',\n         'COUNT' => '',\n         'GROUPBY' => '',\n      ]);\n      $request['FROM'] = $this->getTable();\n      $request['SELECT'] = $this->getTable() . '.*';\n\n      $iterator = $DB->request($request);\n      if (count($iterator) == 1) {\n         $this->fields = $iterator->next();\n         $this->post_getFromDB();\n         return true;\n      } else if (count($iterator) > 1) {\n         Toolbox::logWarning(\n               sprintf(\n                     'getFromDBByRequest expects to get one result, %1$s found!',\n                     count($iterator)\n                     )\n               );\n      }\n      return false;\n   }\n\n   /**\n    * Get the identifier of the current item\n    *\n    * @return integer ID\n   **/\n   function getID() {\n\n      if (isset($this->fields[static::getIndexName()])) {\n         return $this->fields[static::getIndexName()];\n      }\n      return -1;\n   }\n\n\n   /**\n    * Actions done at the end of the getFromDB function\n    *\n    * @return void\n   **/\n   function post_getFromDB() {\n   }\n\n\n   /**\n    * Actions done to not show some fields when geting a single item from API calls\n    *\n    * @param array $fields Fields to unset undiscloseds\n    *\n    * @return void\n    */\n   static public function unsetUndisclosedFields(&$fields) {\n      foreach (static::$undisclosedFields as $key) {\n         unset($fields[$key]);\n      }\n   }\n\n\n   /**\n    * Retrieve all items from the database\n    *\n    * @param array        $condition condition used to search if needed (empty get all) (default '')\n    * @param array|string $order     order field if needed (default '')\n    * @param integer      $limit     limit retrieved data if needed (default '')\n    *\n    * @return array all retrieved data in a associative array by id\n   **/\n   function find($condition = [], $order = [], $limit = null) {\n      global $DB;\n\n      $criteria = [\n         'FROM'   => $this->getTable()\n      ];\n\n      if (count($condition)) {\n         $criteria['WHERE'] = $condition;\n      }\n\n      if (!is_array($order)) {\n         $order = [$order];\n      }\n      if (count($order)) {\n         $criteria['ORDERBY'] = $order;\n      }\n\n      if ((int)$limit > 0) {\n         $criteria['LIMIT'] = (int)$limit;\n      }\n\n      $data = [];\n      $iterator = $DB->request($criteria);\n      while ($line = $iterator->next()) {\n         $data[$line['id']] = $line;\n      }\n\n      return $data;\n   }\n\n\n   /**\n    * Get the name of the index field\n    *\n    * @return string name of the index field\n   **/\n   static function getIndexName() {\n      return \"id\";\n   }\n\n\n   /**\n    * Get an empty item\n    *\n    *@return boolean true if succeed else false\n   **/\n   function getEmpty() {\n      global $DB;\n\n      //make an empty database object\n      $table = $this->getTable();\n\n      if (!empty($table) &&\n          ($fields = $DB->listFields($table))) {\n\n         foreach (array_keys($fields) as $key) {\n            $this->fields[$key] = \"\";\n         }\n      } else {\n         return false;\n      }\n\n      if (array_key_exists('entities_id', $this->fields)\n          && isset($_SESSION[\"glpiactive_entity\"])) {\n         $this->fields['entities_id'] = $_SESSION[\"glpiactive_entity\"];\n      }\n\n      $this->post_getEmpty();\n\n      // Call the plugin hook - $this->fields can be altered\n      Plugin::doHook(\"item_empty\", $this);\n      return true;\n   }\n\n\n   /**\n    * Actions done at the end of the getEmpty function\n    *\n    * @return void\n   **/\n   function post_getEmpty() {\n   }\n\n\n   /**\n    * Get type to register log on\n    *\n    * @since 0.83\n    *\n    * @return array array of type + ID\n   **/\n   function getLogTypeID() {\n      return [$this->getType(), $this->fields['id']];\n   }\n\n\n   /**\n    * Update the item in the database\n    *\n    * @param string[] $updates   fields to update\n    * @param string[] $oldvalues array of old values of the updated fields\n    *\n    * @return void\n   **/\n   function updateInDB($updates, $oldvalues = []) {\n      global $DB;\n\n      foreach ($updates as $field) {\n         if (isset($this->fields[$field])) {\n            $DB->update(\n               $this->getTable(),\n               [$field => $this->fields[$field]],\n               ['id' => $this->fields['id']]\n            );\n            if ($DB->affectedRows() == 0) {\n               if (isset($oldvalues[$field])) {\n                  unset($oldvalues[$field]);\n               }\n            }\n         } else {\n            // Clean oldvalues\n            if (isset($oldvalues[$field])) {\n               unset($oldvalues[$field]);\n            }\n         }\n\n      }\n\n      if (count($oldvalues)) {\n         Log::constructHistory($this, $oldvalues, $this->fields);\n      }\n\n      return true;\n   }\n\n\n   /**\n    * Add an item to the database\n    *\n    * @return integer|boolean new ID of the item is insert successfull else false\n   **/\n   function addToDB() {\n      global $DB;\n\n      $nb_fields = count($this->fields);\n      if ($nb_fields > 0) {\n         $params = [];\n         foreach ($this->fields as $key => $value) {\n            //FIXME: why is that handled here?\n            if (($this->getType() == 'ProfileRight') && ($value == '')) {\n               $value = 0;\n            }\n            $params[$key] = $value;\n         }\n\n         $result = $DB->insert($this->getTable(), $params);\n         if ($result) {\n            if (!isset($this->fields['id'])\n                  || is_null($this->fields['id'])\n                  || ($this->fields['id'] == 0)) {\n               $this->fields['id'] = $DB->insertId();\n            }\n\n            return $this->fields['id'];\n         }\n      }\n      return false;\n   }\n\n\n   /**\n    * Restore item = set deleted flag to 0\n    *\n    * @return boolean true if succeed else false\n   **/\n   function restoreInDB() {\n      global $DB;\n\n      if ($this->maybeDeleted()) {\n         $params = ['is_deleted' => 0];\n         // Auto set date_mod if exsist\n         if (isset($this->fields['date_mod'])) {\n            $params['date_mod'] = $_SESSION[\"glpi_currenttime\"];\n         }\n\n         if ($DB->update($this->getTable(), $params, ['id' => $this->fields['id']])) {\n            return true;\n         }\n\n      }\n      return false;\n   }\n\n\n   /**\n    * Mark deleted or purge an item in the database\n    *\n    * @param boolean $force force the purge of the item (not used if the table do not have a deleted field)\n    *               (default 0)\n    *\n    * @return boolean true if succeed else false\n   **/\n   function deleteFromDB($force = 0) {\n      global $DB;\n\n      if (($force == 1)\n          || !$this->maybeDeleted()\n          || ($this->useDeletedToLockIfDynamic()\n              && !$this->isDynamic())) {\n         $this->cleanDBonPurge();\n         if ($this instanceof CommonDropdown) {\n            $this->cleanTranslations();\n         }\n         $this->cleanHistory();\n         $this->cleanRelationData();\n         $this->cleanRelationTable();\n\n         $result = $DB->delete(\n            $this->getTable(), [\n               'id' => $this->fields['id']\n            ]\n         );\n         if ($result) {\n            $this->post_deleteFromDB();\n            return true;\n         }\n\n      } else {\n         // Auto set date_mod if exsist\n         $toadd = [];\n         if (isset($this->fields['date_mod'])) {\n            $toadd['date_mod'] = $_SESSION[\"glpi_currenttime\"];\n         }\n\n         $result = $DB->update(\n            $this->getTable(), [\n               'is_deleted' => 1\n            ] + $toadd, [\n               'id' => $this->fields['id']\n            ]\n         );\n         $this->cleanDBonMarkDeleted();\n\n         if ($result) {\n            return true;\n         }\n\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Clean data in the tables which have linked the deleted item\n    *\n    * @return void\n   **/\n   function cleanHistory() {\n      global $DB;\n\n      if ($this->dohistory) {\n         $DB->delete(\n            'glpi_logs', [\n               'itemtype'  => $this->getType(),\n               'items_id'  => $this->fields['id']\n            ]\n         );\n      }\n   }\n\n\n   /**\n    * Clean data in the tables which have linked the deleted item\n    * Clear 1/N Relation\n    *\n    * @return void\n   **/\n   function cleanRelationData() {\n      global $DB, $CFG_GLPI;\n\n      $RELATION = getDbRelations();\n      if (isset($RELATION[$this->getTable()])) {\n         $newval = (isset($this->input['_replace_by']) ? $this->input['_replace_by'] : 0);\n\n         foreach ($RELATION[$this->getTable()] as $tablename => $field) {\n            if ($tablename[0] != '_') {\n\n               $itemtype = getItemTypeForTable($tablename);\n\n               // Code factorization : we transform the singleton to an array\n               if (!is_array($field)) {\n                  $field = [$field];\n               }\n\n               foreach ($field as $f) {\n                  $result = $DB->request(\n                     [\n                        'FROM'  => $tablename,\n                        'WHERE' => [$f => $this->getID()],\n                     ]\n                  );\n                  foreach ($result as $data) {\n                     // Be carefull : we must use getIndexName because self::update rely on that !\n                     if ($object = getItemForItemtype($itemtype)) {\n                        $idName = $object->getIndexName();\n                        // And we must ensure that the index name is not the same as the field\n                        // we try to modify. Otherwise we will loose this element because all\n                        // will be set to $newval ...\n                        if ($idName != $f) {\n                           $object->update([$idName          => $data[$idName],\n                                            $f               => $newval,\n                                            '_disablenotif'  => true]); // Disable notifs\n                        }\n                     }\n                  }\n               }\n\n            }\n         }\n\n      }\n\n      // Clean ticket open against the item\n      if (in_array($this->getType(), $CFG_GLPI[\"ticket_types\"])) {\n         $job         = new Ticket();\n         $itemsticket = new Item_Ticket();\n\n         $iterator = $DB->request([\n            'FROM'   => 'glpi_items_tickets',\n            'WHERE'  => [\n               'items_id'  => $this->getID(),\n               'itemtype'  => $this->getType()\n            ]\n         ]);\n\n         while ($data = $iterator->next()) {\n            $cnt = countElementsInTable('glpi_items_tickets', ['tickets_id' => $data['tickets_id']]);\n            $itemsticket->delete([\"id\" => $data[\"id\"]]);\n            if ($cnt == 1 && !$CFG_GLPI[\"keep_tickets_on_delete\"]) {\n               $job->delete([\"id\" => $data[\"tickets_id\"]]);\n            }\n         }\n\n      }\n   }\n\n\n   /**\n    * Actions done after the DELETE of the item in the database\n    *\n    * @return void\n   **/\n   function post_deleteFromDB() {\n   }\n\n\n   /**\n    * Actions done when item is deleted from the database\n    *\n    * @return void\n   **/\n   function cleanDBonPurge() {\n   }\n\n\n   /**\n    * Delete children items and relation with other items from database.\n    *\n    * @param array $relations_classes List of classname on which deletion will be done\n    *                                 Classes needs to extends CommonDBConnexity.\n    *\n    * @return void\n    **/\n   protected function deleteChildrenAndRelationsFromDb(array $relations_classes) {\n\n      foreach ($relations_classes as $classname) {\n         if (!is_a($classname, CommonDBConnexity::class, true)) {\n            Toolbox::logWarning(\n               sprintf(\n                  'Unable to clean elements of class %s as it does not extends \"CommonDBConnexity\"',\n                  $classname\n               )\n            );\n            continue;\n         }\n\n         /** @var CommonDBConnexity $relation_item */\n         $relation_item = new $classname();\n         $relation_item->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n   }\n\n\n   /**\n    * Clean translations associated to a dropdown\n    *\n    * @since 0.85\n    *\n    * @return void\n   **/\n   function cleanTranslations() {\n\n      //Do not try to clean is dropdown translation is globally off\n      if (DropdownTranslation::isDropdownTranslationActive()) {\n         $translation = new DropdownTranslation();\n         $translation->deleteByCriteria(['itemtype' => get_class($this),\n                                         'items_id' => $this->getID()]);\n      }\n   }\n\n\n   /**\n    * Clean the date in the relation tables for the deleted item\n    * Clear N/N Relation\n    *\n    * @return void\n   **/\n   function cleanRelationTable() {\n      global $CFG_GLPI, $DB;\n\n      // If this type have INFOCOM, clean one associated to purged item\n      if (Infocom::canApplyOn($this)) {\n         $infocom = new Infocom();\n\n         if ($infocom->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n             $infocom->delete(['id' => $infocom->fields['id']]);\n         }\n      }\n\n      // If this type have NETPORT, clean one associated to purged item\n      if (in_array($this->getType(), $CFG_GLPI['networkport_types'])) {\n         // If we don't use delete, then cleanDBonPurge() is not call and the NetworkPorts are not\n         // clean properly\n         $networkPortObject = new NetworkPort();\n         $networkPortObject->cleanDBonItemDelete($this->getType(), $this->getID());\n         // Manage networkportmigration if exists\n         if ($DB->tableExists('glpi_networkportmigrations')) {\n            $networkPortMigObject = new NetworkPortMigration();\n            $networkPortMigObject->cleanDBonItemDelete($this->getType(), $this->getID());\n         }\n      }\n\n      // If this type is RESERVABLE clean one associated to purged item\n      if (in_array($this->getType(), $CFG_GLPI['reservation_types'])) {\n         $rr = new ReservationItem();\n         $rr->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      // If this type have CONTRACT, clean one associated to purged item\n      if (in_array($this->getType(), $CFG_GLPI['contract_types'])) {\n         $ci = new Contract_Item();\n         $ci->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      // If this type have DOCUMENT, clean one associated to purged item\n      if (Document::canApplyOn($this)) {\n         $di = new Document_Item();\n         $di->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      // If this type have NOTEPAD, clean one associated to purged item\n      if ($this->usenotepad) {\n         $note = new Notepad();\n         $note->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      // Delete relations with KB\n      if (in_array($this->getType(), $CFG_GLPI['kb_types'])) {\n         $kbitem_item = new KnowbaseItem_Item();\n         $kbitem_item->cleanDBonItemDelete($this->getType(), $this->fields['id']);\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['ticket_types'])) {\n         //delete relation beetween item and changes/problems\n         $this->deleteChildrenAndRelationsFromDb(\n            [\n               Change_Item::class,\n               Item_Problem::class,\n            ]\n         );\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['rackable_types'])) {\n         //delete relation beetween rackable type and its rack\n         $item_rack = new Item_Rack();\n         $item_rack->deleteByCriteria(\n            [\n               'itemtype' => $this->getType(),\n               'items_id' => $this->fields['id']\n            ]\n         );\n\n         $item_enclosure = new Item_Enclosure();\n         $item_enclosure->deleteByCriteria(\n            [\n               'itemtype' => $this->getType(),\n               'items_id' => $this->fields['id']\n            ]\n         );\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['cluster_types'])) {\n         //delete relation beetween clusterable elements type and their cluster\n         $this->deleteChildrenAndRelationsFromDb(\n            [\n               Item_Cluster::class,\n            ]\n         );\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['operatingsystem_types'])) {\n         $this->deleteChildrenAndRelationsFromDb([\n            Item_OperatingSystem::class\n         ]);\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['software_types'])) {\n         $this->deleteChildrenAndRelationsFromDb([\n            Item_SoftwareVersion::class\n         ]);\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['kanban_types'])) {\n         $this->deleteChildrenAndRelationsFromDb([\n            Item_Kanban::class\n         ]);\n      }\n\n      if (in_array($this->getType(), $CFG_GLPI['domain_types'])) {\n         $this->deleteChildrenAndRelationsFromDb([\n            Domain_Item::class\n         ]);\n      }\n   }\n\n\n   /**\n    * Actions done when item flag deleted is set to an item\n    *\n    * @return void\n   **/\n   function cleanDBonMarkDeleted() {\n   }\n\n\n   /**\n    * Save the input data in the Session\n    *\n    * @since 0.84\n    *\n    * @return void\n   **/\n   protected function saveInput() {\n      $_SESSION['saveInput'][$this->getType()] = $this->input;\n   }\n\n\n   /**\n    * Clear the saved data stored in the session\n    *\n    * @since 0.84\n    *\n    * @return void\n   **/\n   protected function clearSavedInput() {\n      unset($_SESSION['saveInput'][$this->getType()]);\n   }\n\n\n   /**\n    * Get the data saved in the session\n    *\n    * @since 0.84\n    *\n    * @param array $default Array of value used if session is empty\n    *\n    * @return array Array of value\n   **/\n   protected function restoreInput(Array $default = []) {\n\n      if (isset($_SESSION['saveInput'][$this->getType()])) {\n         $saved = Html::cleanPostForTextArea($_SESSION['saveInput'][$this->getType()]);\n\n         // clear saved data when restored (only need once)\n         $this->clearSavedInput();\n\n         return $saved;\n      }\n\n      return $default;\n   }\n\n\n   // Common functions\n   /**\n    * Add an item in the database with all it's items.\n    *\n    * @param array   $input   the _POST vars returned by the item form when press add\n    * @param array   $options with the insert options\n    *   - unicity_message : do not display message if item it a duplicate (default is yes)\n    * @param boolean $history do history log ? (true by default)\n    *\n    * @return integer the new ID of the added item (or false if fail)\n   **/\n   function add(array $input, $options = [], $history = true) {\n      global $DB, $CFG_GLPI;\n\n      if ($DB->isSlave()) {\n         return false;\n      }\n\n      // This means we are not adding a cloned object\n      if (!isset($input['clone'])) {\n         // This means we are asked to clone the object (old way). This will clone the clone method\n         // that will set the clone parameter to true\n         if (isset($input['_oldID'])) {\n            $id_to_clone = $input['_oldID'];\n         }\n         if (isset($input['id'])) {\n            $id_to_clone = $input['id'];\n         }\n         if (isset($id_to_clone) && $this->getFromDB($id_to_clone)) {\n            return $this->clone($input, $history);\n         }\n      }\n\n      // Store input in the object to be available in all sub-method / hook\n      $this->input = $input;\n\n      // Manage the _no_history\n      if (!isset($this->input['_no_history'])) {\n         $this->input['_no_history'] = !$history;\n      }\n\n      if (isset($this->input['add'])) {\n         // Input from the interface\n         // Save this data to be available if add fail\n         $this->saveInput();\n      }\n\n      // Call the plugin hook - $this->input can be altered\n      // This hook get the data from the form, not yet altered\n      Plugin::doHook(\"pre_item_add\", $this);\n\n      if ($this->input && is_array($this->input)) {\n\n         if (isset($this->input['add'])) {\n            $this->input['_add'] = $this->input['add'];\n            unset($this->input['add']);\n         }\n\n         $this->input = $this->prepareInputForAdd($this->input);\n      }\n\n      if ($this->input && is_array($this->input)) {\n         // Call the plugin hook - $this->input can be altered\n         // This hook get the data altered by the object method\n         Plugin::doHook(\"post_prepareadd\", $this);\n      }\n\n      if ($this->input && is_array($this->input)) {\n         //Check values to inject\n         $this->filterValues(!isCommandLine());\n      }\n\n      //Process business rules for assets\n      $this->assetBusinessRules(\\RuleAsset::ONADD);\n\n      if ($this->input && is_array($this->input)) {\n         $this->fields = [];\n         $table_fields = $DB->listFields($this->getTable());\n\n         // fill array for add\n         foreach (array_keys($this->input) as $key) {\n            if (($key[0] != '_')\n                && isset($table_fields[$key])) {\n               $this->fields[$key] = $this->input[$key];\n            }\n         }\n\n         // Auto set date_creation if exsist\n         if (isset($table_fields['date_creation']) && !isset($this->input['date_creation'])) {\n            $this->fields['date_creation'] = $_SESSION[\"glpi_currenttime\"];\n         }\n\n         // Auto set date_mod if exsist\n         if (isset($table_fields['date_mod']) && !isset($this->input['date_mod'])) {\n            $this->fields['date_mod'] = $_SESSION[\"glpi_currenttime\"];\n         }\n\n         if ($this->checkUnicity(true, $options)) {\n            if ($this->addToDB() !== false) {\n               $this->post_addItem();\n               $this->addMessageOnAddAction();\n\n               if ($this->dohistory && $history) {\n                  $changes = [\n                     0,\n                     '',\n                     '',\n                  ];\n                  Log::history($this->fields[\"id\"], $this->getType(), $changes, 0,\n                               Log::HISTORY_CREATE_ITEM);\n               }\n\n                // Auto create infocoms\n               if (isset($CFG_GLPI[\"auto_create_infocoms\"]) && $CFG_GLPI[\"auto_create_infocoms\"]\n                   && Infocom::canApplyOn($this)) {\n\n                  $ic = new Infocom();\n                  if (!$ic->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n                     $ic->add(['itemtype' => $this->getType(),\n                               'items_id' => $this->fields['id']]);\n                  }\n               }\n\n               // If itemtype is in infocomtype and if states_id field is filled\n               // and item is not a template\n               if (Infocom::canApplyOn($this)\n                   && isset($this->input['states_id'])\n                            && (!isset($this->input['is_template'])\n                                || !$this->input['is_template'])) {\n\n                  //Check if we have to automatical fill dates\n                  Infocom::manageDateOnStatusChange($this);\n               }\n               Plugin::doHook(\"item_add\", $this);\n\n               // As add have suceed, clean the old input value\n               if (isset($this->input['_add'])) {\n                  $this->clearSavedInput();\n               }\n               if ($this->notificationqueueonaction) {\n                  QueuedNotification::forceSendFor($this->getType(), $this->fields['id']);\n               }\n               return $this->fields['id'];\n            }\n         }\n\n      }\n\n      return false;\n   }\n\n   /**\n    * Clones the current item\n    *\n    * @since 9.5\n    *\n    * @param array $override_input custom input to override\n    * @param boolean $history do history log ? (true by default)\n    *\n    * @return integer the new ID of the clone (or false if fail)\n    */\n   function clone(array $override_input = [], bool $history = true) {\n      global $DB, $CFG_GLPI;\n\n      if ($DB->isSlave()) {\n         return false;\n      }\n      $new_item = new static();\n      $input = Toolbox::addslashes_deep($this->fields);\n      foreach ($override_input as $key => $value) {\n         $input[$key] = $value;\n      }\n      $input = $new_item->prepareInputForClone($input);\n      if (isset($input['id'])) {\n         $input['_oldID'] =  $input['id'];\n         unset($input['id']);\n      }\n      unset($input['date_creation']);\n      unset($input['date_mod']);\n\n      if (isset($input['template_name'])) {\n         unset($input['template_name']);\n      }\n      if (isset($input['is_template'])) {\n         unset($input['is_template']);\n      }\n\n      $input['clone'] = true;\n      $newID = $new_item->add($input, [], $history);\n      // If the item needs post clone (recursive cloning for example)\n      $new_item->post_clone($this, $history);\n      return $newID;\n   }\n\n\n   /**\n    * Get the link to an item\n    *\n    * @param array $options array of options\n    *    - comments     : boolean / display comments\n    *    - complete     : boolean / display completename instead of name\n    *    - additional   : boolean / display additionals information\n    *    - linkoption   : string  / additional options to add to <a>\n    *\n    * @return string HTML link\n   **/\n   function getLink($options = []) {\n\n      $p = [\n         'linkoption' => '',\n      ];\n\n      if (isset($options['linkoption'])) {\n         $p['linkoption'] = $options['linkoption'];\n      }\n\n      if (!isset($this->fields['id'])) {\n         return '';\n      }\n\n      if ($this->no_form_page\n          || !$this->can($this->fields['id'], READ)) {\n         return $this->getNameID($options);\n      }\n\n      $link = $this->getLinkURL();\n\n      $label = $this->getNameID($options);\n      $title = '';\n      if (!preg_match('/title=/', $p['linkoption'])) {\n         $thename = $this->getName(['complete' => true]);\n         if ($thename != NOT_AVAILABLE) {\n            $title = ' title=\"' . htmlentities($thename, ENT_QUOTES, 'utf-8') . '\"';\n         }\n      }\n\n      return \"<a \".$p['linkoption'].\" href='$link' $title>$label</a>\";\n   }\n\n\n   /**\n    * Get the link url to an item\n    *\n    * @return string HTML link\n   **/\n   function getLinkURL() {\n\n      if (!isset($this->fields['id'])) {\n         return '';\n      }\n\n      $link  = $this->getFormURLWithID($this->getID());\n      $link .= ($this->isTemplate() ? \"&withtemplate=1\" : \"\");\n\n      return $link;\n   }\n\n\n   /**\n    * Add a message on add action\n    *\n    * @return void\n   **/\n   function addMessageOnAddAction() {\n\n      $addMessAfterRedirect = false;\n      if (isset($this->input['_add'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         if ($this->getName() == NOT_AVAILABLE) {\n            //TRANS: %1$s is the itemtype, %2$d is the id of the item\n            $this->fields['name'] = sprintf(__('%1$s - ID %2$d'),\n                                            $this->getTypeName(1), $this->fields['id']);\n         }\n         $display = (isset($this->input['_no_message_link'])?$this->getNameID()\n                                                            :$this->getLink());\n\n         // Do not display quotes\n         //TRANS : %s is the description of the added item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully added'),\n                                                  stripslashes($display)));\n\n      }\n   }\n\n\n   /**\n    * Add needed information to $input (example entities_id)\n    *\n    * @param array $input datas used to add the item\n    *\n    * @since 0.84\n    *\n    * @return array the modified $input array\n   **/\n   function addNeededInfoToInput($input) {\n      return $input;\n   }\n\n\n   /**\n    * Prepare input datas for adding the item\n    *\n    * @param array $input datas used to add the item\n    *\n    * @return array the modified $input array\n   **/\n   function prepareInputForAdd($input) {\n      return $input;\n   }\n\n    /**\n    * Prepare input datas for cloning the item\n    *\n    * @since 9.5\n    *\n    * @param array $input datas used to add the item\n    *\n    * @return array the modified $input array\n   **/\n   function prepareInputForClone($input) {\n      return $input;\n   }\n\n\n   /**\n    * Actions done after the ADD of the item in the database\n    *\n    * @return void\n   **/\n   function post_addItem() {\n   }\n\n   /**\n    * Actions done after the clone of the item in the database\n    *\n    * @since 9.5\n    *\n    * @param $source the item that is being cloned\n    * @param $history do history log ?\n    *\n    * @return void\n   **/\n   function post_clone($source, $history) {\n   }\n\n\n   /**\n    * Update some elements of an item in the database.\n    *\n    * @param array   $input   the _POST vars returned by the item form when press update\n    * @param boolean $history do history log ? (default 1)\n    * @param array   $options with the insert options\n    *\n    * @return boolean true on success\n   **/\n   function update(array $input, $history = 1, $options = []) {\n      global $DB, $GLPI_CACHE;\n\n      if ($DB->isSlave()) {\n         return false;\n      }\n\n      if (!$this->getFromDB($input[static::getIndexName()])) {\n         return false;\n      }\n\n      // Store input in the object to be available in all sub-method / hook\n      $this->input = $input;\n\n      // Manage the _no_history\n      if (!isset($this->input['_no_history'])) {\n         $this->input['_no_history'] = !$history;\n      }\n\n      // Plugin hook - $this->input can be altered\n      Plugin::doHook(\"pre_item_update\", $this);\n      if ($this->input && is_array($this->input)) {\n         $this->input = $this->prepareInputForUpdate($this->input);\n\n         if (isset($this->input['update'])) {\n            $this->input['_update'] = $this->input['update'];\n            unset($this->input['update']);\n         }\n         $this->filterValues(!isCommandLine());\n      }\n\n      //Process business rules for assets\n      $this->assetBusinessRules(\\RuleAsset::ONUPDATE);\n\n      // Valid input for update\n      if ($this->checkUnicity(false, $options)) {\n         if ($this->input && is_array($this->input)) {\n            // Fill the update-array with changes\n            $x               = 0;\n            $this->updates   = [];\n            $this->oldvalues = [];\n\n            foreach (array_keys($this->input) as $key) {\n               if (array_key_exists($key, $this->fields)) {\n\n                  // Prevent history for date statement (for date for example)\n                  if (is_null($this->fields[$key])\n                      && ($this->input[$key] == 'NULL')) {\n                     $this->fields[$key] = 'NULL';\n                  }\n                  // Compare item\n                  $ischanged = true;\n                  $searchopt = $this->getSearchOptionByField('field', $key, $this->getTable());\n                  if (isset($searchopt['datatype'])) {\n                     switch ($searchopt['datatype']) {\n                        case 'string' :\n                        case 'text' :\n                           $ischanged = (strcmp($DB->escape($this->fields[$key]),\n                                                $this->input[$key]) != 0);\n                           break;\n\n                        case 'itemlink' :\n                           if ($key == 'name') {\n                              $ischanged = (strcmp($DB->escape($this->fields[$key]),\n                                                               $this->input[$key]) != 0);\n                              break;\n                           } // else default\n\n                        default :\n                           $ischanged = ($DB->escape($this->fields[$key]) != $this->input[$key]);\n                           break;\n                     }\n                  } else {\n                     // No searchoption case\n                     $ischanged = ($DB->escape($this->fields[$key]) != $this->input[$key]);\n\n                  }\n                  if ($ischanged) {\n                     if ($key != \"id\") {\n\n                        // Store old values\n                        if (!in_array($key, $this->history_blacklist)) {\n                           $this->oldvalues[$key] = $this->fields[$key];\n                        }\n\n                        $this->fields[$key] = $this->input[$key];\n                        $this->updates[$x]  = $key;\n                        $x++;\n                     }\n                  }\n\n               }\n            }\n            if (count($this->updates)) {\n               if (array_key_exists('date_mod', $this->fields)) {\n                  // is a non blacklist field exists\n                  if (count(array_diff($this->updates, $this->history_blacklist)) > 0) {\n                     $this->fields['date_mod'] = $_SESSION[\"glpi_currenttime\"];\n                     $this->updates[$x++]      = 'date_mod';\n                  }\n               }\n               $this->pre_updateInDB();\n\n               if (count($this->updates)) {\n                  if ($this->updateInDB($this->updates,\n                                        ($this->dohistory && $history ? $this->oldvalues\n                                                                      : []))) {\n                     $this->addMessageOnUpdateAction();\n                     Plugin::doHook(\"item_update\", $this);\n\n                     //Fill forward_entity_to array with itemtypes coming from plugins\n                     if (isset(self::$plugins_forward_entity[$this->getType()])) {\n                        foreach (self::$plugins_forward_entity[$this->getType()] as $itemtype) {\n                           static::$forward_entity_to[] = $itemtype;\n                        }\n                     }\n                     // forward entity information if needed\n                     if (count(static::$forward_entity_to)\n                         && (in_array(\"entities_id\", $this->updates)\n                             || in_array(\"is_recursive\", $this->updates))) {\n                        $this->forwardEntityInformations();\n                     }\n\n                     // If itemtype is in infocomtype and if states_id field is filled\n                     // and item not a template\n                     if (Infocom::canApplyOn($this)\n                         && in_array('states_id', $this->updates)\n                         && ($this->getField('is_template') != NOT_AVAILABLE)) {\n                        //Check if we have to automatical fill dates\n                        Infocom::manageDateOnStatusChange($this, false);\n                     }\n                  }\n               }\n            }\n            $this->post_updateItem($history);\n\n            if ($this->notificationqueueonaction) {\n               QueuedNotification::forceSendFor($this->getType(), $this->fields['id']);\n            }\n\n            return true;\n         }\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Forward entity information to linked items\n    *\n    * @return void\n   **/\n   protected function forwardEntityInformations() {\n      global $DB;\n\n      if (!isset($this->fields['id']) || !($this->fields['id'] >= 0)) {\n         return false;\n      }\n\n      if (count(static::$forward_entity_to)) {\n         foreach (static::$forward_entity_to as $type) {\n            $item  = new $type();\n            $query = [\n               'SELECT' => ['id'],\n               'FROM'   => $item->getTable()\n            ];\n\n            $OR = [];\n            if ($item->isField('itemtype')) {\n               $OR[] = [\n                  'itemtype'  => $this->getType(),\n                  'items_id'  => $this->getID()\n               ];\n            }\n            if ($item->isField($this->getForeignKeyField())) {\n               $OR[] = [$this->getForeignKeyField() => $this->getID()];\n            }\n            $query['WHERE'][] = ['OR' => $OR];\n\n            $input = [\n               'entities_id'  => $this->getEntityID(),\n               '_transfer'    => 1\n            ];\n            if ($this->maybeRecursive()) {\n               $input['is_recursive'] = $this->isRecursive();\n            }\n\n            $iterator = $DB->request($query);\n            while ($data = $iterator->next()) {\n               $input['id'] = $data['id'];\n               // No history for such update\n               $item->update($input, 0);\n            }\n         }\n      }\n   }\n\n\n   /**\n    * Add a message on update action\n    *\n    * @return void\n   **/\n   function addMessageOnUpdateAction() {\n\n      $addMessAfterRedirect = false;\n\n      if (isset($this->input['_update'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         // Do not display quotes\n         if (isset($this->fields['name'])) {\n            $this->fields['name'] = stripslashes($this->fields['name']);\n         } else {\n            //TRANS: %1$s is the itemtype, %2$d is the id of the item\n            $this->fields['name'] = sprintf(__('%1$s - ID %2$d'),\n                                            $this->getTypeName(1), $this->fields['id']);\n         }\n\n         if (isset($this->input['_no_message_link'])) {\n            $display = $this->getNameID();\n         } else {\n            $display = $this->getLink();\n         }\n         //TRANS : %s is the description of the updated item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully updated'), $display));\n\n      }\n\n   }\n\n\n   /**\n    * Prepare input datas for updating the item\n    *\n    * @param array $input data used to update the item\n    *\n    * @return array the modified $input array\n   **/\n   function prepareInputForUpdate($input) {\n      return $input;\n   }\n\n\n   /**\n    * Actions done after the UPDATE of the item in the database\n    *\n    * @param boolean $history store changes history ? (default 1)\n    *\n    * @return void\n   **/\n   function post_updateItem($history = 1) {\n   }\n\n\n   /**\n    * Actions done before the UPDATE of the item in the database\n    *\n    * @return void\n   **/\n   function pre_updateInDB() {\n   }\n\n\n   /**\n    * Delete an item in the database.\n    *\n    * @param array   $input   the _POST vars returned by the item form when press delete\n    * @param boolean $force   force deletion (default 0)\n    * @param boolean $history do history log ? (default 1)\n    *\n    * @return boolean true on success\n   **/\n   function delete(array $input, $force = 0, $history = 1) {\n      global $DB;\n\n      if ($DB->isSlave()) {\n         return false;\n      }\n\n      if (!$this->getFromDB($input[static::getIndexName()])) {\n         return false;\n      }\n\n      // Force purge for templates / may not to be deleted / not dynamic lockable items\n      if ($this->isTemplate()\n          || !$this->maybeDeleted()\n          // Do not take into account deleted field if maybe dynamic but not dynamic\n          || ($this->useDeletedToLockIfDynamic()\n              && !$this->isDynamic())) {\n         $force = 1;\n      }\n\n      // Store input in the object to be available in all sub-method / hook\n      $this->input = $input;\n\n      if (isset($this->input['purge'])) {\n         $this->input['_purge'] = $this->input['purge'];\n         unset($this->input['purge']);\n      } else if ($force) {\n         $this->input['_purge'] = 1;\n         $this->input['_no_message'] = $this->input['_no_message'] ?? 1;\n      }\n\n      if (isset($this->input['delete'])) {\n         $this->input['_delete'] = $this->input['delete'];\n         unset($this->input['delete']);\n      } else if (!$force) {\n         $this->input['_delete'] = 1;\n         $this->input['_no_message'] = $this->input['_no_message'] ?? 1;\n      }\n\n      if (!isset($this->input['_no_history'])) {\n         $this->input['_no_history'] = !$history;\n      }\n\n      // Purge\n      if ($force) {\n         Plugin::doHook(\"pre_item_purge\", $this);\n      } else {\n         Plugin::doHook(\"pre_item_delete\", $this);\n      }\n\n      if (!is_array($this->input)) {\n         // $input clear by a hook to cancel delete\n         return false;\n      }\n\n      if ($this->pre_deleteItem()) {\n\n         if ($this->deleteFromDB($force)) {\n\n            if ($force) {\n               $this->addMessageOnPurgeAction();\n               $this->post_purgeItem();\n               Plugin::doHook(\"item_purge\", $this);\n               Impact::clean($this);\n            } else {\n               $this->addMessageOnDeleteAction();\n\n               if ($this->dohistory && $history) {\n                  $changes = [\n                     0,\n                     '',\n                     '',\n                  ];\n                  $logaction  = Log::HISTORY_DELETE_ITEM;\n                  if ($this->useDeletedToLockIfDynamic()\n                      && $this->isDynamic()) {\n                     $logaction = Log::HISTORY_LOCK_ITEM;\n                  }\n\n                  Log::history($this->fields[\"id\"], $this->getType(), $changes, 0,\n                               $logaction);\n               }\n               $this->post_deleteItem();\n\n               Plugin::doHook(\"item_delete\", $this);\n            }\n            if ($this->notificationqueueonaction) {\n               QueuedNotification::forceSendFor($this->getType(), $this->fields['id']);\n            }\n\n            return true;\n         }\n\n      }\n      return false;\n   }\n\n\n   /**\n    * Actions done after the DELETE (mark as deleted) of the item in the database\n    *\n    * @return void\n   **/\n   function post_deleteItem() {\n   }\n\n\n   /**\n    * Actions done after the PURGE of the item in the database\n    *\n    * @return void\n   **/\n   function post_purgeItem() {\n   }\n\n\n   /**\n    * Add a message on delete action\n    *\n    * @return void\n   **/\n   function addMessageOnDeleteAction() {\n\n      if (!$this->maybeDeleted()) {\n         return;\n      }\n\n      $addMessAfterRedirect = false;\n      if (isset($this->input['_delete'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         if (isset($this->input['_no_message_link'])) {\n            $display = $this->getNameID();\n         } else {\n            $display = $this->getLink();\n         }\n         //TRANS : %s is the description of the updated item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully deleted'), $display));\n\n      }\n   }\n\n\n   /**\n    * Add a message on purge action\n    *\n    * @return void\n   **/\n   function addMessageOnPurgeAction() {\n\n      $addMessAfterRedirect = false;\n\n      if (isset($this->input['_purge'])\n          || isset($this->input['_delete'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_purge'])) {\n         $this->input['_no_message_link'] = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         if (isset($this->input['_no_message_link'])) {\n            $display = $this->getNameID();\n         } else {\n            $display = $this->getLink();\n         }\n          //TRANS : %s is the description of the updated item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully purged'),\n                                                  $display));\n      }\n   }\n\n\n   /**\n    * Actions done before the DELETE of the item in the database /\n    * Maybe used to add another check for deletion\n    *\n    * @return boolean true if item need to be deleted else false\n   **/\n   function pre_deleteItem() {\n      return true;\n   }\n\n\n   /**\n    * Restore an item put in the trashbin in the database.\n    *\n    * @param array   $input   the _POST vars returned by the item form when press restore\n    * @param boolean $history do history log ? (default 1)\n    *\n    * @return boolean true on success\n   **/\n   function restore(array $input, $history = 1) {\n\n      if (!$this->getFromDB($input[static::getIndexName()])) {\n         return false;\n      }\n\n      if (isset($input['restore'])) {\n         $input['_restore'] = $input['restore'];\n         unset($input['restore']);\n      } else {\n         $this->input['_restore'] = 1;\n         $this->input['_no_message'] = $this->input['_no_message'] ?? 1;\n      }\n\n      // Store input in the object to be available in all sub-method / hook\n      $this->input = $input;\n      Plugin::doHook(\"pre_item_restore\", $this);\n      if (!is_array($this->input)) {\n         // $input clear by a hook to cancel retore\n         return false;\n      }\n\n      if ($this->restoreInDB()) {\n         $this->addMessageOnRestoreAction();\n\n         if ($this->dohistory && $history) {\n            $changes = [\n               0,\n               '',\n               '',\n            ];\n            $logaction  = Log::HISTORY_RESTORE_ITEM;\n            if ($this->useDeletedToLockIfDynamic()\n                && $this->isDynamic()) {\n               $logaction = Log::HISTORY_UNLOCK_ITEM;\n            }\n            Log::history($this->input[\"id\"], $this->getType(), $changes, 0, $logaction);\n         }\n\n         $this->post_restoreItem();\n         Plugin::doHook(\"item_restore\", $this);\n         if ($this->notificationqueueonaction) {\n            QueuedNotification::forceSendFor($this->getType(), $this->fields['id']);\n         }\n         return true;\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Actions done after the restore of the item\n    *\n    * @return void\n   **/\n   function post_restoreItem() {\n   }\n\n\n   /**\n    * Add a message on restore action\n    *\n    * @return void\n   **/\n   function addMessageOnRestoreAction() {\n\n      $addMessAfterRedirect = false;\n      if (isset($this->input['_restore'])) {\n         $addMessAfterRedirect = true;\n      }\n\n      if (isset($this->input['_no_message'])\n          || !$this->auto_message_on_action) {\n         $addMessAfterRedirect = false;\n      }\n\n      if ($addMessAfterRedirect) {\n         $link = $this->getFormURL();\n         if (!isset($link)) {\n            return;\n         }\n         if (isset($this->input['_no_message_link'])) {\n            $display = $this->getNameID();\n         } else {\n            $display = $this->getLink();\n         }\n         //TRANS : %s is the description of the updated item\n         Session::addMessageAfterRedirect(sprintf(__('%1$s: %2$s'), __('Item successfully restored'), $display));\n      }\n   }\n\n\n   /**\n    * Reset fields of the item\n    *\n    * @return void\n   **/\n   function reset() {\n      $this->fields = [];\n   }\n\n\n   /**\n    * Have I the global right to add an item for the Object\n    * May be overloaded if needed (ex Ticket)\n    *\n    * @since 0.83\n    *\n    * @param string $type itemtype of object to add\n    *\n    * @return boolean\n   **/\n   function canAddItem($type) {\n      return $this->can($this->getID(), UPDATE);\n   }\n\n\n   /**\n    * Have I the right to \"create\" the Object\n    *\n    * Default is true and check entity if the objet is entity assign\n    *\n    * May be overloaded if needed\n    *\n    * @return boolean\n    **/\n   function canCreateItem() {\n\n      if (!$this->checkEntity()) {\n         return false;\n      }\n      return true;\n   }\n\n\n   /**\n    * Have I the right to \"update\" the Object\n    *\n    * Default is true and check entity if the objet is entity assign\n    *\n    * May be overloaded if needed\n    *\n    * @return boolean\n   **/\n   function canUpdateItem() {\n\n      if (!$this->checkEntity()) {\n         return false;\n      }\n      return true;\n   }\n\n\n   /**\n    * Have I the right to \"delete\" the Object\n    *\n    * Default is true and check entity if the objet is entity assign\n    *\n    * May be overloaded if needed\n    *\n    * @return boolean\n   **/\n   function canDeleteItem() {\n\n      if (!$this->checkEntity()) {\n         return false;\n      }\n      return true;\n   }\n\n\n   /**\n    * Have I the right to \"purge\" the Object\n    *\n    * Default is true and check entity if the objet is entity assign\n    *\n    * @since 0.85\n    *\n    * @return boolean\n   **/\n   function canPurgeItem() {\n\n      if (!$this->checkEntity()) {\n         return false;\n      }\n\n      // Can purge an object with Infocom only if can purge Infocom\n      if (Infocom::canApplyOn($this)) {\n         $infocom = new Infocom();\n\n         if ($infocom->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n            return $infocom->canPurge();\n         }\n      }\n      return true;\n   }\n\n\n   /**\n    * Have I the right to \"view\" the Object\n    * May be overloaded if needed\n    *\n    * @return boolean\n   **/\n   function canViewItem() {\n\n      if (!$this->checkEntity(true)) {\n         return false;\n      }\n\n      // else : Global item\n      return true;\n   }\n\n\n   /**\n    * Have i right to see action button\n    *\n    * @param integer $ID ID to check\n    *\n    * @since 0.85\n    *\n    * @return boolean\n   **/\n   function canEdit($ID) {\n\n      if ($this->maybeDeleted()) {\n         return ($this->can($ID, CREATE)\n                 || $this->can($ID, UPDATE)\n                 || $this->can($ID, DELETE)\n                 || $this->can($ID, PURGE));\n      }\n      return ($this->can($ID, CREATE)\n              || $this->can($ID, UPDATE)\n              || $this->can($ID, PURGE));\n   }\n\n\n   /**\n    * Can I change recursive flag to false\n    * check if there is \"linked\" object in another entity\n    *\n    * May be overloaded if needed\n    *\n    * @return boolean\n   **/\n   function canUnrecurs() {\n      global $DB;\n\n      $ID  = $this->fields['id'];\n      if (($ID < 0)\n          || !$this->fields['is_recursive']) {\n         return true;\n      }\n\n      $entities = getAncestorsOf('glpi_entities', $this->fields['entities_id']);\n      $entities[] = $this->fields['entities_id'];\n      $RELATION  = getDbRelations();\n\n      if ($this instanceof CommonTreeDropdown) {\n         $f = getForeignKeyFieldForTable($this->getTable());\n\n         if (countElementsInTable($this->getTable(),\n                                  [ $f => $ID, 'NOT' => [ 'entities_id' => $entities ]]) > 0) {\n            return false;\n         }\n      }\n\n      if (isset($RELATION[$this->getTable()])) {\n         foreach ($RELATION[$this->getTable()] as $tablename => $field) {\n            if ($tablename[0] != '_') {\n\n               $itemtype = getItemTypeForTable($tablename);\n               $item     = new $itemtype();\n\n               if ($item->isEntityAssign()) {\n\n                  // 1->N Relation\n                  if (is_array($field)) {\n                     foreach ($field as $f) {\n                        if (countElementsInTable($tablename,\n                                                 [ $f => $ID, 'NOT' => [ 'entities_id' => $entities ]]) > 0) {\n                           return false;\n                        }\n                     }\n\n                  } else {\n                     if (countElementsInTable($tablename,\n                                              [ $field => $ID, 'NOT' => [ 'entities_id' => $entities ]]) > 0) {\n                        return false;\n                     }\n                  }\n\n               } else {\n                  foreach ($RELATION as $othertable => $rel) {\n                     // Search for a N->N Relation with devices\n                     if (($othertable == \"_virtual_device\")\n                         && isset($rel[$tablename])) {\n                        $devfield  = $rel[$tablename][0]; // items_id...\n                        $typefield = $rel[$tablename][1]; // itemtype...\n\n                        $iterator = $DB->request([\n                           'SELECT'          => $typefield,\n                           'DISTINCT'        => true,\n                           'FROM'            => $tablename,\n                           'WHERE'           => [$field => $ID]\n                        ]);\n\n                        // Search linked device of each type\n                        while ($data = $iterator->next()) {\n                           $itemtype  = $data[$typefield];\n                           $itemtable = getTableForItemType($itemtype);\n                           $item      = new $itemtype();\n\n                           if ($item->isEntityAssign()) {\n                              if (countElementsInTable([$tablename, $itemtable],\n                                                         [\"$tablename.$field\"     => $ID,\n                                                         \"$tablename.$typefield\" => $itemtype,\n                                                         'FKEY' => [$tablename => $devfield, $itemtable => 'id'],\n                                                         'NOT'  => [$itemtable.'.entities_id' => $entities ]]) > '0') {\n                                 return false;\n                              }\n                           }\n                        }\n\n                     } else if (($othertable != $this->getTable())\n                              && isset($rel[$tablename])) {\n\n                        // Search for another N->N Relation\n                        $itemtype = getItemTypeForTable($othertable);\n                        $item     = new $itemtype();\n\n                        if ($item->isEntityAssign()) {\n                           if (is_array($rel[$tablename])) {\n                              foreach ($rel[$tablename] as $otherfield) {\n                                 if (countElementsInTable([$tablename, $othertable],\n                                                          [\"$tablename.$field\" => $ID,\n                                                           'FKEY' => [$tablename => $otherfield, $othertable => 'id'],\n                                                           'NOT'  => [$othertable.'.entities_id' => $entities ]]) > '0') {\n                                    return false;\n                                 }\n                              }\n\n                           } else {\n                              $otherfield = $rel[$tablename];\n                              if (countElementsInTable([$tablename, $othertable],\n                                                       [\"$tablename.$field\" => $ID,\n                                                        'FKEY' => [$tablename => $otherfield, $othertable =>'id'],\n                                                        'NOT'  => [ $othertable.'.entities_id' => $entities ]]) > '0') {\n                                 return false;\n                              }\n                           }\n\n                        }\n                     }\n                  }\n               }\n            }\n         }\n      }\n\n      // Doc links to this item\n      if (($this->getType() > 0)\n          && countElementsInTable(['glpi_documents_items', 'glpi_documents'],\n                                  ['glpi_documents_items.items_id'=> $ID,\n                                   'glpi_documents_items.itemtype'=> $this->getType(),\n                                   'FKEY' => ['glpi_documents_items' => 'documents_id','glpi_documents' => 'id'],\n                                   'NOT'  => ['glpi_documents.entities_id' => $entities]]) > '0') {\n         return false;\n      }\n      // TODO : do we need to check all relations in $RELATION[\"_virtual_device\"] for this item\n\n      // check connections of a computer\n      $connectcomputer = ['Monitor', 'Peripheral', 'Phone', 'Printer'];\n      if (in_array($this->getType(), $connectcomputer)) {\n         return Computer_Item::canUnrecursSpecif($this, $entities);\n      }\n      return true;\n   }\n\n\n   /**\n    * check if this action can be done on this field of this item by massive actions\n    *\n    * @since 0.83\n    *\n    * @param string  $action name of the action\n    * @param integer $field  id of the field\n    * @param string  $value  value of the field\n    *\n    * @return boolean\n   **/\n   function canMassiveAction($action, $field, $value) {\n      return true;\n   }\n\n\n   /**\n    * @since 9.1\n    *\n    * @param array $options Options\n    *\n    * @return boolean\n   **/\n   function showDates($options = []) {\n\n      $isNewID = ((isset($options['withtemplate']) && ($options['withtemplate'] == 2))\n         || $this->isNewID($this->getID()));\n\n      if ($isNewID) {\n         return true;\n      }\n\n      $date_creation_exists = ($this->getField('date_creation') != NOT_AVAILABLE);\n      $date_mod_exists = ($this->getField('date_mod') != NOT_AVAILABLE);\n\n      $colspan = $options['colspan'];\n      if ((!isset($options['withtemplate']) || ($options['withtemplate'] == 0))\n          && !empty($this->fields['template_name'])) {\n         $colspan = 1;\n      }\n\n      echo \"<tr class='tab_bg_1 footerRow'>\";\n      //Display when it's not a new asset being created\n      if ($date_creation_exists\n         && $this->getID() > 0\n            && (!isset($options['withtemplate']) || $options['withtemplate'] == 0)) {\n         echo \"<th colspan='$colspan'>\";\n         printf(__('Created on %s'), Html::convDateTime($this->fields[\"date_creation\"]));\n         echo \"</th>\";\n      } else if (!isset($options['withtemplate']) || $options['withtemplate'] == 0) {\n         echo \"<th colspan='$colspan'>\";\n         echo \"</th>\";\n      }\n\n      if (isset($options['withtemplate']) && $options['withtemplate']) {\n         echo \"<th colspan='$colspan'>\";\n         //TRANS: %s is the datetime of insertion\n         printf(__('Created on %s'), Html::convDateTime($_SESSION[\"glpi_currenttime\"]));\n         echo \"</th>\";\n      }\n\n      if ($date_mod_exists) {\n         echo \"<th colspan='$colspan'>\";\n         //TRANS: %s is the datetime of update\n         printf(__('Last update on %s'), Html::convDateTime($this->fields[\"date_mod\"]));\n         echo \"</th>\";\n      } else {\n         echo \"<th colspan='$colspan'>\";\n         echo \"</th>\";\n      }\n\n      if ((!isset($options['withtemplate']) || ($options['withtemplate'] == 0))\n          && !empty($this->fields['template_name'])) {\n         echo \"<th colspan='\".($colspan * 2).\"'>\";\n         printf(__('Created from the template %s'), $this->fields['template_name']);\n         echo \"</th>\";\n      }\n\n      echo \"</tr>\";\n   }\n\n   /**\n    * Display a 2 columns Footer for Form buttons\n    * Close the form is user can edit\n    *\n    * @param array $options array of possible options:\n    *     - withtemplate : 1 for newtemplate, 2 for newobject from template\n    *     - colspan for each column (default 2)\n    *     - candel : set to false to hide \"delete\" button\n    *     - canedit : set to false to hide all buttons\n    *     - addbuttons : array of buttons to add\n    *\n    * @return void\n   **/\n   function showFormButtons($options = []) {\n\n      // for single object like config\n      if (isset($this->fields['id'])) {\n         $ID = $this->fields['id'];\n      } else {\n         $ID = 1;\n      }\n\n      $params = [\n         'colspan'      => 2,\n         'withtemplate' => '',\n         'candel'       => true,\n         'canedit'      => true,\n         'addbuttons'   => [],\n         'formfooter'   => null,\n      ];\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $val) {\n            $params[$key] = $val;\n         }\n      }\n\n      Plugin::doHook(\"post_item_form\", ['item' => $this, 'options' => &$params]);\n\n      if ($params['formfooter'] === null) {\n          $this->showDates($params);\n      }\n\n      if (!$params['canedit']\n          || !$this->canEdit($ID)) {\n         echo \"</table></div>\";\n         // Form Header always open form\n         Html::closeForm();\n         return false;\n      }\n\n      echo \"<tr class='tab_bg_2'>\";\n\n      if ($params['withtemplate']\n          ||$this->isNewID($ID)) {\n\n         echo \"<td class='center' colspan='\".($params['colspan']*2).\"'>\";\n\n         if (($ID <= 0) || ($params['withtemplate'] == 2)) {\n            echo Html::submit(\n               \"<i class='fas fa-plus'></i>&nbsp;\"._x('button', 'Add'),\n               ['name' => 'add']\n            );\n         } else {\n            //TRANS : means update / actualize\n            echo Html::submit(\n               \"<i class='fas fa-save'></i>&nbsp;\"._x('button', 'Save'),\n               ['name' => 'update']\n            );\n         }\n\n      } else {\n         if ($params['candel']\n             && !$this->can($ID, DELETE)\n             && !$this->can($ID, PURGE)) {\n            $params['candel'] = false;\n         }\n\n         if ($params['canedit'] && $this->can($ID, UPDATE)) {\n            echo \"<td class='center' colspan='\".($params['colspan']*2).\"'>\\n\";\n            echo Html::submit(\n               \"<i class='fas fa-save'></i>&nbsp;\"._x('button', 'Save'),\n               ['name' => 'update']\n            );\n         }\n\n         if ($params['candel']) {\n            if ($params['canedit'] && $this->can($ID, UPDATE)) {\n               echo \"</td></tr><tr class='tab_bg_2'>\\n\";\n            }\n            if ($this->isDeleted()) {\n               if ($this->can($ID, DELETE)) {\n                  echo \"<td class='right' colspan='\".($params['colspan']*2).\"' >\\n\";\n                  echo Html::submit(\n                     \"<i class='fas fa-trash-restore'></i>&nbsp;\"._x('button', 'Restore'),\n                     ['name' => 'restore']\n                  );\n               }\n\n               if ($this->can($ID, PURGE)) {\n                  echo \"<span class='very_small_space'>\";\n                  if (in_array($this->getType(), Item_Devices::getConcernedItems())) {\n                     Html::showToolTip(__('Check to keep the devices while deleting this item'));\n                     echo \"&nbsp;\";\n                     echo \"<input type='checkbox' name='keep_devices' value='1'\";\n                     if (!empty($_SESSION['glpikeep_devices_when_purging_item'])) {\n                        echo \" checked\";\n                     }\n                     echo \">&nbsp;\";\n                  }\n                  echo Html::submit(\n                     \"<i class='fas fa-trash-alt'></i>&nbsp;\"._x('button', 'Delete permanently'),\n                     ['name' => 'purge']\n                  );\n                  echo \"</span>\";\n               }\n\n            } else {\n               echo \"<td class='right' colspan='\".($params['colspan']*2).\"' >\\n\";\n               // If maybe dynamic : do not take into account  is_deleted  field\n               if (!$this->maybeDeleted()\n                   || $this->useDeletedToLockIfDynamic()) {\n                  if ($this->can($ID, PURGE)) {\n                     echo Html::submit(\n                        \"<i class='fas fa-trash-alt'></i>&nbsp;\"._x('button', 'Delete permanently'),\n                        [\n                           'name'    => 'purge',\n                           'confirm' => __('Confirm the final deletion?')\n                        ]\n                     );\n                  }\n               } else if (!$this->isDeleted()\n                          && $this->can($ID, DELETE)) {\n                  echo Html::submit(\n                     \"<i class='fas fa-trash-alt'></i>&nbsp;\"._x('button', 'Put in trashbin'),\n                     ['name' => 'delete']\n                  );\n               }\n            }\n\n         }\n         if ($this->isField('date_mod')) {\n            echo \"<input type='hidden' name='_read_date_mod' value='\".$this->getField('date_mod').\"'>\";\n         }\n      }\n\n      if (!$this->isNewID($ID)) {\n         echo \"<input type='hidden' name='id' value='$ID'>\";\n      }\n      echo \"</td>\";\n      echo \"</tr>\\n\";\n\n      if ($params['canedit']\n          && count($params['addbuttons'])) {\n         echo \"<tr class='tab_bg_2'>\";\n         echo \"<td class='right' colspan='\".($params['colspan']*2).\"'>\";\n         foreach ($params['addbuttons'] as $key => $val) {\n            echo \"<button type='submit' class='vsubmit' name='$key' value='1'>\n                  $val\n               </button>&nbsp;\";\n         }\n         echo \"</td>\";\n         echo \"</tr>\";\n      }\n\n      // Close for Form\n      echo \"</table></div>\";\n      Html::closeForm();\n   }\n\n\n   /**\n    * Initialize item and check right before managing the edit form\n    *\n    * @since 0.84\n    *\n    * @param integer $ID      ID of the item/template\n    * @param array   $options Array of possible options:\n    *     - withtemplate : 1 for newtemplate, 2 for newobject from template\n    *\n    * @return integer|void value of withtemplate option (exit of no right)\n   **/\n   function initForm($ID, Array $options = []) {\n\n      if (isset($options['withtemplate'])\n          && ($options['withtemplate'] == 2)\n          && !$this->isNewID($ID)) {\n         // Create item from template\n         // Check read right on the template\n         $this->check($ID, READ);\n\n         // Restore saved input or template data\n         $input = $this->restoreInput($this->fields);\n\n         // If entity assign force current entity to manage recursive templates\n         if ($this->isEntityAssign()) {\n            $input['entities_id'] = $_SESSION['glpiactive_entity'];\n         }\n\n         // Check create right\n         $this->check(-1, CREATE, $input);\n\n      } else if ($this->isNewID($ID)) {\n         // Restore saved input if available\n         $input = $this->restoreInput($options);\n         // Create item\n         $this->check(-1, CREATE, $input);\n      } else {\n         // Existing item\n         $this->check($ID, READ);\n      }\n\n      return (isset($options['withtemplate']) ? $options['withtemplate'] : '');\n   }\n\n\n   /**\n    *\n    * Display a 2 columns Header 1 for ID, 1 for recursivity menu\n    * Open the form is user can edit\n    *\n    * @param array $options array of possible options:\n    *     - target for the Form\n    *     - withtemplate : 1 for newtemplate, 2 for newobject from template\n    *     - colspan for each column (default 2)\n    *     - formoptions string (javascript p.e.)\n    *     - canedit boolean edit mode of form ?\n    *     - formtitle specific form title\n    *     - noid Set to true if ID should not be append (eg. already done in formtitle)\n    *\n    * @return void\n   **/\n   function showFormHeader($options = []) {\n\n      $ID     = $this->fields['id'];\n\n      $params = [\n         'target'       => $this->getFormURL(),\n         'colspan'      => 2,\n         'withtemplate' => '',\n         'formoptions'  => '',\n         'canedit'      => true,\n         'formtitle'    => null,\n         'noid'         => false\n      ];\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $val) {\n            $params[$key] = $val;\n         }\n      }\n\n      // Template case : clean entities data\n      if (($params['withtemplate'] == 2)\n          && $this->isEntityAssign()) {\n         $this->fields['entities_id']  = $_SESSION['glpiactive_entity'];\n      }\n\n      $rand = mt_rand();\n      if ($this->canEdit($ID)) {\n         echo \"<form name='form' method='post' action='\".$params['target'].\"' \".\n                $params['formoptions'].\" enctype=\\\"multipart/form-data\\\">\";\n\n         //Should add an hidden entities_id field ?\n         //If the table has an entities_id field\n         if ($this->isField(\"entities_id\")) {\n            //The object type can be assigned to an entity\n            if ($this->isEntityAssign()) {\n               if (isset($params['entities_id'])) {\n                  $entity = $this->fields['entities_id'] = $params['entities_id'];\n\n               } else if ($this->isNewID($ID)\n                          || ($params['withtemplate'] == 2)) {\n                  //It's a new object to be added\n                  $entity = $_SESSION['glpiactive_entity'];\n\n               } else {\n                  //It's an existing object to be displayed\n                  $entity = $this->fields['entities_id'];\n               }\n\n               echo \"<input type='hidden' name='entities_id' value='$entity'>\";\n\n            } else if ($this->getType() != 'User') {\n               // For Rules except ruleticket and slalevel\n               echo \"<input type='hidden' name='entities_id' value='0'>\";\n\n            }\n         }\n      }\n\n      echo \"<div class='spaced' id='tabsbody'>\";\n      echo \"<table class='tab_cadre_fixe' id='mainformtable'>\";\n\n      if ($params['formtitle'] !== '' && $params['formtitle'] !== false) {\n         echo \"<tr class='headerRow'><th colspan='\".$params['colspan'].\"'>\";\n\n         if (!empty($params['withtemplate']) && ($params['withtemplate'] == 2)\n            && !$this->isNewID($ID)) {\n\n            echo \"<input type='hidden' name='template_name' value='\".$this->fields[\"template_name\"].\"'>\";\n\n            //TRANS: %s is the template name\n            printf(__('Created from the template %s'), $this->fields[\"template_name\"]);\n\n         } else if (!empty($params['withtemplate']) && ($params['withtemplate'] == 1)) {\n            echo \"<input type='hidden' name='is_template' value='1'>\\n\";\n            echo \"<label for='textfield_template_name$rand'>\" . __('Template name') . \"</label>\";\n            Html::autocompletionTextField(\n               $this,\n               'template_name',\n               [\n                  'size'      => 25,\n                  'required'  => true,\n                  'rand'      => $rand\n               ]\n            );\n         } else if ($this->isNewID($ID)) {\n            $nametype = $params['formtitle'] !== null ? $params['formtitle'] : $this->getTypeName(1);\n            printf(__('%1$s - %2$s'), __('New item'), $nametype);\n         } else {\n            $nametype = $params['formtitle'] !== null ? $params['formtitle'] : $this->getTypeName(1);\n            if (!$params['noid'] && ($_SESSION['glpiis_ids_visible'] || empty($nametype))) {\n               //TRANS: %1$s is the Itemtype name and $2$d the ID of the item\n               $nametype = sprintf(__('%1$s - ID %2$d'), $nametype, $ID);\n            }\n            echo $nametype;\n         }\n         $entityname = '';\n         if (isset($this->fields[\"entities_id\"])\n            && Session::isMultiEntitiesMode()\n            && $this->isEntityAssign()) {\n            $entityname = Dropdown::getDropdownName(\"glpi_entities\", $this->fields[\"entities_id\"]);\n         }\n\n         echo \"</th><th colspan='\".$params['colspan'].\"'>\";\n         if (get_class($this) != 'Entity') {\n            if ($this->maybeRecursive()) {\n               if (Session::isMultiEntitiesMode()) {\n                  echo \"<table class='tab_format'><tr class='headerRow responsive_hidden'><th>\".$entityname.\"</th>\";\n                  echo \"<th class='right'><label for='dropdown_is_recursive$rand'>\".__('Child entities').\"</label></th><th>\";\n                  if ($params['canedit']) {\n                     if ($this instanceof CommonDBChild) {\n                        echo Dropdown::getYesNo($this->isRecursive());\n                        if (isset($this->fields[\"is_recursive\"])) {\n                           echo \"<input type='hidden' name='is_recursive' value='\".$this->fields[\"is_recursive\"].\"'>\";\n                        }\n                        $comment = __(\"Can't change this attribute. It's inherited from its parent.\");\n                        // CommonDBChild : entity data is get or copy from parent\n\n                     } else if (!$this->can($ID, 'recursive')) {\n                        echo Dropdown::getYesNo($this->fields[\"is_recursive\"]);\n                        $comment = __('You are not allowed to change the visibility flag for child entities.');\n\n                     } else if (!$this->canUnrecurs()) {\n                        echo Dropdown::getYesNo($this->fields[\"is_recursive\"]);\n                        $comment = __('Flag change forbidden. Linked items found.');\n\n                     } else {\n                        Dropdown::showYesNo(\"is_recursive\", $this->fields[\"is_recursive\"], -1, ['rand' => $rand]);\n                        $comment = __('Change visibility in child entities');\n                     }\n                     echo \" \";\n                     Html::showToolTip($comment);\n                  } else {\n                     echo Dropdown::getYesNo($this->fields[\"is_recursive\"]);\n                  }\n                  echo \"</th></tr></table>\";\n               } else {\n                  echo $entityname;\n                  echo \"<input type='hidden' name='is_recursive' value='0'>\";\n               }\n            } else {\n               echo $entityname;\n            }\n         }\n         echo \"</th></tr>\\n\";\n      }\n\n      Plugin::doHook(\"pre_item_form\", ['item' => $this, 'options' => &$params]);\n\n      // If in modal : do not display link on message after redirect\n      if (isset($_REQUEST['_in_modal']) && $_REQUEST['_in_modal']) {\n         echo \"<input type='hidden' name='_no_message_link' value='1'>\";\n      }\n\n   }\n\n\n   /**\n    * is the parameter ID must be considered as new one ?\n    * Default is empty of <0 may be overriden (for entity for example)\n    *\n    * @param integer $ID ID of the item (-1 if new item)\n    *\n    * @return boolean\n   **/\n   static function isNewID($ID) {\n      return (empty($ID) || ($ID <= 0));\n   }\n\n\n   /**\n    * is the current object a new  one\n    *\n    * @since 0.83\n    *\n    * @return boolean\n   **/\n   function isNewItem() {\n\n      if (isset($this->fields['id'])) {\n         return $this->isNewID($this->fields['id']);\n      }\n      return true;\n   }\n\n\n   /**\n    * Check right on an item\n    *\n    * @param integer $ID    ID of the item (-1 if new item)\n    * @param mixed   $right Right to check : r / w / recursive / READ / UPDATE / DELETE\n    * @param array   $input array of input data (used for adding item) (default NULL)\n    *\n    * @return boolean\n   **/\n   function can($ID, $right, array &$input = null) {\n      // Clean ID :\n      $ID = Toolbox::cleanInteger($ID);\n\n      // Create process\n      if ($this->isNewID($ID)) {\n         if (!isset($this->fields['id'])) {\n            // Only once\n            $this->getEmpty();\n         }\n\n         if (is_array($input)) {\n            $input = $this->addNeededInfoToInput($input);\n            // Copy input field to allow getEntityID() to work\n            // from entites_id field or from parent item ref\n            foreach ($input as $key => $val) {\n               if (isset($this->fields[$key])) {\n                  $this->fields[$key] = $val;\n               }\n            }\n            // Store to be available for others functions\n            $this->input = $input;\n         }\n\n         if ($this->isPrivate()\n             && ($this->fields['users_id'] === Session::getLoginUserID())) {\n            return true;\n         }\n         return (static::canCreate() && $this->canCreateItem());\n\n      }\n      // else : Get item if not already loaded\n      if (!isset($this->fields['id']) || ($this->fields['id'] != $ID)) {\n         // Item not found : no right\n         if (!$this->getFromDB($ID)) {\n            return false;\n         }\n      }\n\n      /* Hook to restrict user right on current item @since 9.2 */\n      $this->right = $right;\n      Plugin::doHook(\"item_can\", $this);\n      if ($this->right !== $right) {\n         return false;\n      }\n      unset($this->right);\n\n      switch ($right) {\n         case READ :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canView() && $this->canViewItem());\n\n         case UPDATE :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canUpdate() && $this->canUpdateItem());\n\n         case DELETE :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canDelete() && $this->canDeleteItem());\n\n         case PURGE :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canPurge() && $this->canPurgeItem());\n\n         case CREATE :\n            // Personnal item\n            if ($this->isPrivate()\n                && ($this->fields['users_id'] === Session::getLoginUserID())) {\n               return true;\n            }\n            return (static::canCreate() && $this->canCreateItem());\n\n         case 'recursive' :\n            if ($this->isEntityAssign()\n                && $this->maybeRecursive()) {\n               if (static::canCreate()\n                   && Session::haveAccessToEntity($this->getEntityID())) {\n                  // Can make recursive if recursive access to entity\n                  return Session::haveRecursiveAccessToEntity($this->getEntityID());\n               }\n            }\n            break;\n\n      }\n      return false;\n   }\n\n\n   /**\n    * Check right on an item with block\n    *\n    * @param integer $ID    ID of the item (-1 if new item)\n    * @param mixed   $right Right to check : r / w / recursive\n    * @param array   $input array of input data (used for adding item) (default NULL)\n    *\n    * @return void\n   **/\n   function check($ID, $right, array &$input = null) {\n\n      // Check item exists\n      if (!$this->isNewID($ID)\n          && (!isset($this->fields['id']) || $this->fields['id'] != $ID)\n          && !$this->getFromDB($ID)) {\n         // Gestion timeout session\n         Session::redirectIfNotLoggedIn();\n         Html::displayNotFoundError();\n\n      } else {\n         if (!$this->can($ID, $right, $input)) {\n            // Gestion timeout session\n            Session::redirectIfNotLoggedIn();\n            Html::displayRightError();\n         }\n      }\n   }\n\n\n   /**\n    * Check if have right on this entity\n    *\n    * @param boolean $recursive set true to accept recursive items of ancestors\n    *                           of active entities (View case for example) (default false)\n    * @since 0.85\n    *\n    * @return boolean\n   **/\n   function checkEntity($recursive = false) {\n\n      // Is an item assign to an entity\n      if ($this->isEntityAssign()) {\n         // Can be recursive check\n         if ($recursive && $this->maybeRecursive()) {\n            return Session::haveAccessToEntity($this->getEntityID(), $this->isRecursive());\n         }\n         //  else : No recursive item         // Have access to entity\n         return Session::haveAccessToEntity($this->getEntityID());\n      }\n      // else : Global item\n      return true;\n   }\n\n\n   /**\n    * Check global right on an object\n    *\n    * @param mixed $right Right to check : c / r / w / d\n    *\n    * @return void\n   **/\n   function checkGlobal($right) {\n\n      if (!$this->canGlobal($right)) {\n         // Gestion timeout session\n         Session::redirectIfNotLoggedIn();\n         Html::displayRightError();\n      }\n   }\n\n\n   /**\n    * Get global right on an object\n    *\n    * @param mixed $right Right to check : c / r / w / d / READ / UPDATE / CREATE / DELETE\n    *\n    * @return void\n   **/\n   function canGlobal($right) {\n\n      switch ($right) {\n         case READ :\n            return static::canView();\n\n         case UPDATE :\n            return static::canUpdate();\n\n         case CREATE :\n            return static::canCreate();\n\n         case DELETE :\n            return static::canDelete();\n\n         case PURGE :\n            return static::canPurge();\n\n      }\n\n      return false;\n   }\n\n\n   /**\n    * Get the ID of entity assigned to the object\n    *\n    * Can be overloaded (ex : infocom)\n    *\n    * @return integer ID of the entity\n   **/\n   function getEntityID() {\n\n      if ($this->isEntityAssign()) {\n         return $this->fields[\"entities_id\"];\n      }\n      return  -1;\n   }\n\n\n   /**\n    * Is the object assigned to an entity\n    *\n    * Can be overloaded (ex : infocom)\n    *\n    * @return boolean\n   **/\n   function isEntityAssign() {\n\n      if (!array_key_exists('id', $this->fields)) {\n         $this->getEmpty();\n      }\n      return array_key_exists('entities_id', $this->fields);\n   }\n\n\n   /**\n    * Is the object may be recursive\n    *\n    * Can be overloaded (ex : infocom)\n    *\n    * @return boolean\n   **/\n   function maybeRecursive() {\n\n      if (!array_key_exists('id', $this->fields)) {\n         $this->getEmpty();\n      }\n      return array_key_exists('is_recursive', $this->fields);\n   }\n\n\n   /**\n    * Is the object recursive\n    *\n    * Can be overloaded (ex : infocom)\n    *\n    * @return boolean\n   **/\n   function isRecursive() {\n\n      if ($this->maybeRecursive()) {\n         return $this->fields[\"is_recursive\"];\n      }\n      // Return integer value to be used to fill is_recursive field\n      return 0;\n   }\n\n\n   /**\n    * Is the object may be deleted\n    *\n    * @return boolean\n   **/\n   function maybeDeleted() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return array_key_exists('is_deleted', $this->fields);\n   }\n\n\n   /**\n    * Is the object deleted\n    *\n    * @return boolean\n   **/\n   function isDeleted() {\n\n      if ($this->maybeDeleted()) {\n         return $this->fields[\"is_deleted\"];\n      }\n      // Return integer value to be used to fill is_deleted field\n      return 0;\n\n   }\n\n\n   /**\n    * Can object be activated\n    *\n    * @since 9.2\n    *\n    * @return boolean\n    **/\n   function maybeActive() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return array_key_exists('is_active', $this->fields);\n   }\n\n\n   /**\n    * Is the object active\n    *\n    * @since 9.2\n    *\n    * @return boolean\n    **/\n   function isActive() {\n\n      if ($this->maybeActive()) {\n         return $this->fields[\"is_active\"];\n      }\n      // Return integer value to be used to fill is_active field\n      return 1;\n\n   }\n\n\n   /**\n    * Is the object may be a template\n    *\n    * @return boolean\n   **/\n   function maybeTemplate() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return isset($this->fields['is_template']);\n   }\n\n\n   /**\n    * Is the object a template\n    *\n    * @return boolean\n   **/\n   function isTemplate() {\n\n      if ($this->maybeTemplate()) {\n         return $this->fields[\"is_template\"];\n      }\n      // Return integer value to be used to fill is_template field\n      return 0;\n   }\n\n\n   /**\n    * Can the object be dynamic\n    *\n    * @since 0.84\n    *\n    * @return boolean\n   **/\n   function maybeDynamic() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return array_key_exists('is_dynamic', $this->fields);\n   }\n\n\n   /**\n    * Use deleted field in case of dynamic management to lock ?\n    *\n    * need to be overriden if object need to use standard deleted management (Computer...)\n    * @since 0.84\n    *\n    * @return boolean\n   **/\n   function useDeletedToLockIfDynamic() {\n      return $this->maybeDynamic();\n   }\n\n\n   /**\n    * Is an object dynamic or not\n    *\n    * @since 0.84\n    *\n    * @return boolean\n   **/\n   function isDynamic() {\n\n      if ($this->maybeDynamic()) {\n         return $this->fields['is_dynamic'];\n      }\n      return 0;\n   }\n\n\n   /**\n    * Is the object may be private\n    *\n    * @return boolean\n   **/\n   function maybePrivate() {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n      return (array_key_exists('is_private', $this->fields)\n              && array_key_exists('users_id', $this->fields));\n   }\n\n\n   /**\n    * Is the object private\n    *\n    * @return boolean\n   **/\n   function isPrivate() {\n\n      if ($this->maybePrivate()) {\n         return $this->fields[\"is_private\"];\n      }\n      return false;\n   }\n\n   /**\n    * Can object have a location\n    *\n    * @since 9.3\n    *\n    * @return boolean\n    */\n   function maybeLocated() {\n\n      if (!array_key_exists('id', $this->fields)) {\n         $this->getEmpty();\n      }\n      return array_key_exists('locations_id', $this->fields);\n   }\n\n   /**\n    * Return the linked items (in computers_items)\n    *\n    * @return array an array of linked items  like array('Computer' => array(1,2), 'Printer' => array(5,6))\n    * @since 0.84.4\n   **/\n   function getLinkedItems() {\n      return [];\n   }\n\n\n   /**\n    * Return the count of linked items (in computers_items)\n    *\n    * @return integer number of linked items\n    * @since 0.84.4\n   **/\n   function getLinkedItemsCount() {\n\n      $linkeditems = $this->getLinkedItems();\n      $nb          = 0;\n      if (count($linkeditems)) {\n         foreach ($linkeditems as $tab) {\n            $nb += count($tab);\n         }\n      }\n      return $nb;\n   }\n\n\n   /**\n    * Return a field Value if exists\n    *\n    * @param string $field field name\n    *\n    * @return mixed value of the field / false if not exists\n   **/\n   function getField($field) {\n\n      if (array_key_exists($field, $this->fields)) {\n         return $this->fields[$field];\n      }\n      return NOT_AVAILABLE;\n   }\n\n\n   /**\n    * Determine if a field exists\n    *\n    * @param string $field field name\n    *\n    * @return boolean\n   **/\n   function isField($field) {\n\n      if (!isset($this->fields['id'])) {\n         $this->getEmpty();\n      }\n       return array_key_exists($field, $this->fields);\n   }\n\n\n   /**\n    * Get comments of the Object\n    *\n    * @return string comments of the object in the current language (HTML)\n   **/\n   function getComments() {\n\n      $comment = \"\";\n      $toadd   = [];\n      if ($this->isField('completename')) {\n         $toadd[] = ['name'  => __('Complete name'),\n                          'value' => nl2br($this->getField('completename'))];\n      }\n\n      if ($this->isField('serial')) {\n         $toadd[] = ['name'  => __('Serial number'),\n                          'value' => nl2br($this->getField('serial'))];\n      }\n\n      if ($this->isField('otherserial')) {\n         $toadd[] = ['name'  => __('Inventory number'),\n                          'value' => nl2br($this->getField('otherserial'))];\n      }\n\n      if ($this->isField('states_id') && $this->getType()!='State') {\n         $tmp = Dropdown::getDropdownName('glpi_states', $this->getField('states_id'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('Status'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('locations_id') && $this->getType()!='Location') {\n         $tmp = Dropdown::getDropdownName(\"glpi_locations\", $this->getField('locations_id'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('Location'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('users_id')) {\n         $tmp = getUserName($this->getField('users_id'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('User'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('groups_id')\n          && ($this->getType() != 'Group')) {\n         $tmp = Dropdown::getDropdownName(\"glpi_groups\", $this->getField('groups_id'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('Group'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('users_id_tech')) {\n         $tmp = getUserName($this->getField('users_id_tech'));\n         if ((strlen($tmp) != 0) && ($tmp != '&nbsp;')) {\n            $toadd[] = ['name'  => __('Technician in charge of the hardware'),\n                             'value' => $tmp];\n         }\n      }\n\n      if ($this->isField('contact')) {\n         $toadd[] = ['name'  => __('Alternate username'),\n                          'value' => nl2br($this->getField('contact'))];\n      }\n\n      if ($this->isField('contact_num')) {\n         $toadd[] = ['name'  => __('Alternate username number'),\n                          'value' => nl2br($this->getField('contact_num'))];\n      }\n\n      if (Infocom::canApplyOn($this)) {\n         $infocom = new Infocom();\n         if ($infocom->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n            $toadd[] = ['name'  => __('Warranty expiration date'),\n                             'value' => Infocom::getWarrantyExpir($infocom->fields[\"warranty_date\"],\n                                                                  $infocom->fields[\"warranty_duration\"],\n                                                                  0, true)];\n         }\n      }\n\n      if (($this instanceof CommonDropdown)\n          && $this->isField('comment')) {\n         $toadd[] = ['name'  => __('Comments'),\n                          'value' => nl2br($this->getField('comment'))];\n      }\n\n      if (count($toadd)) {\n         foreach ($toadd as $data) {\n            // Do not use SPAN here\n            $comment .= sprintf(__('%1$s: %2$s').\"<br>\",\n                                \"<strong>\".$data['name'], \"</strong>\".$data['value']);\n         }\n      }\n\n      if (!empty($comment)) {\n         return Html::showToolTip($comment, ['display' => false]);\n      }\n\n      return $comment;\n   }\n\n\n   /**\n    * @since 0.84\n    *\n    * Get field used for name\n    *\n    * @return string\n   **/\n   static function getNameField() {\n      return 'name';\n   }\n\n\n   /**\n    * @since 0.84\n    *\n    * Get field used for completename\n    *\n    * @return string\n   **/\n   static function getCompleteNameField() {\n      return 'completename';\n   }\n\n\n   /**\n    * Get raw name of the object\n    * Maybe overloaded\n    *\n    * @deprecated 9.5\n    * @see CommonDBTM::getNameField\n    * @since 0.85\n    *\n    * @return string\n   **/\n   function getRawName() {\n      \\Toolbox::deprecated('Use CommonDBTM::getFriendlyName()');\n\n      return $this->getFriendlyName();\n   }\n\n\n   /** Get raw completename of the object\n    * Maybe overloaded\n    *\n    * @see CommonDBTM::getCompleteNameField\n    *\n    * @since 0.85\n    *\n    * @return string\n   **/\n   function getRawCompleteName() {\n\n      if (isset($this->fields[static::getCompleteNameField()])) {\n         return $this->fields[static::getCompleteNameField()];\n      }\n      return '';\n   }\n\n\n   /**\n    * Get the name of the object\n    *\n    * @param array $options array of options\n    *    - comments     : boolean / display comments\n    *    - complete     : boolean / display completename instead of name\n    *    - additional   : boolean / display aditionals information\n    *\n    * @return string name of the object in the current language\n    *\n    * @see CommonDBTM::getRawCompleteName\n    * @see CommonDBTM::getFriendlyName\n   **/\n   function getName($options = []) {\n\n      $p = [\n         'comments'   => false,\n         'complete'   => false,\n         'additional' => false,\n      ];\n\n      if (is_array($options)) {\n         foreach ($options as $key => $val) {\n            $p[$key] = $val;\n         }\n      }\n\n      $name = '';\n      if ($p['complete']) {\n         $name = $this->getRawCompleteName();\n      }\n      if (empty($name)) {\n         $name = $this->getFriendlyName();\n      }\n\n      if (strlen($name) != 0) {\n         if ($p['additional']) {\n            $pre = $this->getPreAdditionalInfosForName();\n            if (!empty($pre)) {\n               $name = sprintf(__('%1$s - %2$s'), $pre, $name);\n            }\n            $post = $this->getPostAdditionalInfosForName();\n            if (!empty($post)) {\n               $name = sprintf(__('%1$s - %2$s'), $name, $post);\n            }\n         }\n         if ($p['comments']) {\n            $comment = $this->getComments();\n            if (!empty($comment)) {\n               $name = sprintf(__('%1$s - %2$s'), $name, $comment);\n            }\n         }\n         return $name;\n      }\n      return NOT_AVAILABLE;\n   }\n\n\n   /**\n    * Get additionals information to add before name\n    *\n    * @since 0.84\n    *\n    * @return string string to add\n   **/\n   function getPreAdditionalInfosForName() {\n      return '';\n   }\n\n   /**\n    * Get additionals information to add after name\n    *\n    * @since 0.84\n    *\n    * @return string string to add\n   **/\n   function getPostAdditionalInfosForName() {\n      return '';\n   }\n\n\n   /**\n    * Get the name of the object with the ID if the config is set\n    * Should Not be overloaded (overload getName() instead)\n    *\n    * @see CommonDBTM::getName\n    *\n    * @param array $options array of options\n    *    - comments     : boolean / display comments\n    *    - complete     : boolean / display completename instead of name\n    *    - additional   : boolean / display aditionals information\n    *    - forceid      : boolean  override config and display item's ID (false by default)\n    *\n    * @return string name of the object in the current language\n   **/\n   function getNameID($options = []) {\n\n      $p = [\n         'forceid'  => false,\n         'comments' => false,\n      ];\n\n      if (is_array($options)) {\n         foreach ($options as $key => $val) {\n            $p[$key] = $val;\n         }\n      }\n\n      if ($p['forceid']\n          || $_SESSION['glpiis_ids_visible']) {\n         $addcomment = $p['comments'];\n\n         // unset comment\n         $p['comments'] = false;\n         $name = $this->getName($p);\n\n         //TRANS: %1$s is a name, %2$s is ID\n         $name = sprintf(__('%1$s (%2$s)'), $name, $this->getField('id'));\n\n         if ($addcomment) {\n            $comment = $this->getComments();\n            if (!empty($comment)) {\n               $name = sprintf(__('%1$s - %2$s'), $name, $comment);\n            }\n         }\n         return $name;\n      }\n      return $this->getName($options);\n   }\n\n   /**\n    * Get the Search options for the given Type\n    * If you want to work on search options, @see CommonDBTM::rawSearchOptions\n    *\n    * @return array an *indexed* array of search options\n    *\n    * @see https://glpi-developer-documentation.rtfd.io/en/master/devapi/search.html\n   **/\n   public final function searchOptions() {\n      static $options;\n\n      if (!isset($options)) {\n         $options = [];\n\n         foreach ($this->rawSearchOptions() as $opt) {\n            $missingFields = [];\n            if (!isset($opt['id'])) {\n               $missingFields[] = 'id';\n            }\n            if (!isset($opt['name'])) {\n               $missingFields[] = 'name';\n            }\n            if (count($missingFields) > 0) {\n               throw new \\Exception(\n                  vsprintf(\n                     'Invalid search option in \"%1$s\": missing \"%2$s\" field(s). %3$s',\n                     [\n                        get_called_class(),\n                        implode('\", \"', $missingFields),\n                        print_r($opt, true)\n                     ]\n                  )\n               );\n            }\n\n            $optid = $opt['id'];\n            unset($opt['id']);\n\n            if (isset($options[$optid])) {\n               $message = \"Duplicate key $optid ({$options[$optid]['name']}/{$opt['name']}) in \".\n                   get_class($this) . \" searchOptions!\";\n\n               Toolbox::logError($message);\n            }\n\n            foreach ($opt as $k => $v) {\n               $options[$optid][$k] = $v;\n            }\n         }\n      }\n\n      return $options;\n   }\n\n\n   /**\n    * Provides search options configuration. Do not rely directly\n    * on this, @see CommonDBTM::searchOptions instead.\n    *\n    * @since 9.3\n    *\n    * This should be overloaded in Class\n    *\n    * @return array a *not indexed* array of search options\n    *\n    * @see https://glpi-developer-documentation.rtfd.io/en/master/devapi/search.html\n   **/\n   public function rawSearchOptions() {\n      $tab = [];\n\n      $tab[] = [\n          'id'   => 'common',\n          'name' => __('Characteristics')\n      ];\n\n      if ($this->isField('name')) {\n         $tab[] = [\n            'id'            => 1,\n            'table'         => $this->getTable(),\n            'field'         => 'name',\n            'name'          => __('Name'),\n            'datatype'      => 'itemlink',\n            'massiveaction' => false,\n            'autocomplete'  => true,\n         ];\n      }\n\n      if ($this->isField('is_recursive')) {\n         $tab[] = [\n            'id'       => 86,\n            'table'      => $this->getTable(),\n            'field'      => 'is_recursive',\n            'name'       => __('Child entities'),\n            'datatype'   => 'bool',\n            'searchtype' => 'equals',\n         ];\n      }\n\n      // add objectlock search options\n      $tab = array_merge($tab, ObjectLock::rawSearchOptionsToAdd(get_class($this)));\n\n      return $tab;\n   }\n\n   /**\n    * Summary of getSearchOptionsToAdd\n    * @since 9.2\n    *\n    * @param string $itemtype Item type, defaults to null\n    *\n    * @return array\n   **/\n   static function getSearchOptionsToAdd($itemtype = null) {\n      $options = [];\n\n      $classname = get_called_class();\n      $method_name = 'rawSearchOptionsToAdd';\n      if (!method_exists($classname, $method_name)) {\n         return $options;\n      }\n\n      if (defined('TU_USER') && $itemtype != null && $itemtype != 'AllAssets') {\n         $item = new $itemtype;\n         $all_options = $item->searchOptions();\n      }\n\n      foreach ($classname::$method_name($itemtype) as $opt) {\n         if (!isset($opt['id'])) {\n            throw new \\Exception(get_called_class() . ': invalid search option! ' . print_r($opt, true));\n         }\n         $optid = $opt['id'];\n         unset($opt['id']);\n\n         if (defined('TU_USER') && $itemtype != null) {\n            if (isset($all_options[$optid])) {\n               $message = \"Duplicate key $optid ({$all_options[$optid]['name']}/{$opt['name']}) in \".\n                  self::class . \" searchOptionsToAdd for $itemtype!\";\n\n               Toolbox::logError($message);\n            }\n         }\n\n         foreach ($opt as $k => $v) {\n            $options[$optid][$k] = $v;\n            if (defined('TU_USER') && $itemtype != null) {\n               $all_options[$optid][$k] = $v;\n            }\n         }\n      }\n\n      return $options;\n   }\n\n   /**\n    * Get all the massive actions available for the current class regarding given itemtype\n    *\n    * @since 0.85\n    *\n    * @param array      $actions    array of the actions to update\n    * @param string     $itemtype   the type of the item for which we want the actions\n    * @param boolean    $is_deleted (default 0)\n    * @param CommonDBTM $checkitem  (default NULL)\n    *\n    * @return void (update is set inside $actions)\n   **/\n   static function getMassiveActionsForItemtype(array &$actions, $itemtype, $is_deleted = 0,\n                                                CommonDBTM $checkitem = null) {\n   }\n\n\n   /**\n    * Class-specific method used to show the fields to specify the massive action\n    *\n    * @since 0.85\n    *\n    * @param MassiveAction $ma the current massive action object\n    *\n    * @return boolean false if parameters displayed ?\n   **/\n   static function showMassiveActionsSubForm(MassiveAction $ma) {\n      return false;\n   }\n\n\n   /**\n    * Class specific execution of the massive action (new system) by itemtypes\n    *\n    * @since 0.85\n    *\n    * @param MassiveAction $ma   the current massive action object\n    * @param CommonDBTM    $item the item on which apply the massive action\n    * @param array         $ids  an array of the ids of the item on which apply the action\n    *\n    * @return void (direct submit to $ma object)\n   **/\n   static function processMassiveActionsForOneItemtype(MassiveAction $ma, CommonDBTM $item,\n                                                       array $ids) {\n   }\n\n\n   /**\n    * Get the standard massive actions which are forbidden\n    *\n    * @since 0.84\n    *\n    * This should be overloaded in Class\n    *\n    * @return array an array of massive actions\n   **/\n   function getForbiddenStandardMassiveAction() {\n      return [];\n   }\n\n\n   /**\n    * Get forbidden single action\n    *\n    * @since 9.5.0\n    *\n    * @return array\n   **/\n   public function getForbiddenSingleMassiveActions() {\n      $excluded = [\n         '*:update',\n         '*:delete',\n         '*:remove',\n         '*:purge',\n         '*:unlock'\n      ];\n\n      if (Infocom::canApplyOn($this)) {\n         $ic = new Infocom();\n         if ($ic->getFromDBforDevice($this->getType(), $this->fields['id'])) {\n            $excluded[] = 'Infocom:activate';\n         }\n      }\n\n      return $excluded;\n   }\n\n   /**\n    * Get whitelisted single actions\n    *\n    * @since 9.5.0\n    *\n    * @return array\n   **/\n   public function getWhitelistedSingleMassiveActions() {\n      return ['MassiveAction:add_transfer_list'];\n   }\n\n\n   /**\n    * Get the specific massive actions\n    *\n    * @since 0.84\n    *\n    * This should be overloaded in Class\n    *\n    * @param object $checkitem link item to check right (default NULL)\n    *\n    * @return array an array of massive actions\n   **/\n   function getSpecificMassiveActions($checkitem = null) {\n      global $DB;\n\n      $actions = [];\n      // test if current profile has rights to unlock current item type\n      if (Session::haveRight( static::$rightname, UNLOCK)) {\n         $actions['ObjectLock'.MassiveAction::CLASS_ACTION_SEPARATOR.'unlock']\n                        = _x('button', 'Unlock items');\n      }\n      if ($DB->fieldExists(static::getTable(), 'entities_id') && static::canUpdate()) {\n         MassiveAction::getAddTransferList($actions);\n      }\n\n      //massive action to link appliances from possible item types\n      if (in_array(static::getType(), Appliance::getTypes(true)) && static::canUpdate()) {\n         $actions['Appliance'.MassiveAction::CLASS_ACTION_SEPARATOR.'add_item'] = __('Associate to appliance');\n      }\n\n      return $actions;\n   }\n\n\n   /**\n    * Print out an HTML \"<select>\" for a dropdown\n    *\n    * This should be overloaded in Class\n    *\n    * @param array $options array of possible options:\n    * Parameters which could be used in options array :\n    *    - name : string / name of the select (default is depending itemtype)\n    *    - value : integer / preselected value (default 0)\n    *    - comments : boolean / is the comments displayed near the dropdown (default true)\n    *    - entity : integer or array / restrict to a defined entity or array of entities\n    *                   (default -1 : no restriction)\n    *    - toupdate : array / Update a specific item on select change on dropdown\n    *                   (need value_fieldname, to_update, url (see Ajax::updateItemOnSelectEvent for information)\n    *                   and may have moreparams)\n    *    - used : array / Already used items ID: not to display in dropdown (default empty)\n    *\n    * @return void display the dropdown\n   **/\n   static function dropdown($options = []) {\n      /// TODO try to revert usage : Dropdown::show calling this function\n      /// TODO use this function instead of Dropdown::show\n      return Dropdown::show(get_called_class(), $options);\n   }\n\n\n   /**\n    * Return a search option by looking for a value of a specific field and maybe a specific table\n    *\n    * @param string $field the field in which looking for the value (for example : table, name, etc)\n    * @param string $value the value to look for in the field\n    * @param string $table the table (default '')\n    *\n    * @return array the search option array, or an empty array if not found\n   **/\n   function getSearchOptionByField($field, $value, $table = '') {\n\n      foreach ($this->searchOptions() as $id => $searchOption) {\n         if ((isset($searchOption['linkfield']) && ($searchOption['linkfield'] == $value))\n             || (isset($searchOption[$field]) && ($searchOption[$field] == $value))) {\n            if (($table == '')\n                || (($table != '') && ($searchOption['table'] == $table))) {\n               // Set ID;\n               $searchOption['id'] = $id;\n               return $searchOption;\n            }\n         }\n      }\n      return [];\n   }\n\n\n   /**\n    * Get search options\n    *\n    * @since 0.85\n    *\n    * @return array the search option array\n   **/\n   function getOptions() {\n\n      if (!$this->searchopt) {\n         $this->searchopt = Search::getOptions($this->getType());\n      }\n\n      return $this->searchopt;\n   }\n\n\n   /**\n    * Return a search option ID by looking for a value of a specific field and maybe a specific table\n    *\n    * @since 0.83\n    *\n    * @param string $field the field in which looking for the value (for example : table, name, etc)\n    * @param string $value the value to look for in the field\n    * @param string $table the table (default '')\n    *\n    * @return mixed the search option id, or -1 if not found\n   **/\n   function getSearchOptionIDByField($field, $value, $table = '') {\n\n      $tab = $this->getSearchOptionByField($field, $value, $table);\n      if (isset($tab['id'])) {\n         return $tab['id'];\n      }\n      return -1;\n   }\n\n\n   /**\n    * Check float and decimal values\n    *\n    * @param boolean $display display or not messages in and addAfterRedirect (true by default)\n    *\n    * @return void\n   **/\n   function filterValues($display = true) {\n      // MoYo : comment it because do not understand why filtering is disable\n      // if (in_array('CommonDBRelation', class_parents($this))) {\n      //    return true;\n      // }\n      //Type mismatched fields\n      $fails = [];\n      if (isset($this->input) && is_array($this->input) && count($this->input)) {\n\n         foreach ($this->input as $key => $value) {\n            $unset        = false;\n            $regs         = [];\n            $searchOption = $this->getSearchOptionByField('field', $key);\n\n            if (isset($searchOption['datatype'])\n                && (is_null($value) || ($value == '') || ($value == 'NULL'))) {\n\n               switch ($searchOption['datatype']) {\n                  case 'date' :\n                  case 'datetime' :\n                     // don't use $unset', because this is not a failure\n                     $this->input[$key] = 'NULL';\n                     break;\n               }\n            } else if (isset($searchOption['datatype'])\n                       && !is_null($value)\n                       && ($value != '')\n                       && ($value != 'NULL')) {\n\n               switch ($searchOption['datatype']) {\n                  case 'integer' :\n                  case 'count' :\n                  case 'number' :\n                  case 'decimal' :\n                     $value = str_replace(',', '.', $value);\n                     if ($searchOption['datatype'] == 'decimal') {\n                        $this->input[$key] = floatval(Toolbox::cleanDecimal($value));\n                     } else {\n                        $this->input[$key] = intval(Toolbox::cleanInteger($value));\n                     }\n                     if (!is_numeric($this->input[$key])) {\n                        $unset = true;\n                     }\n                     break;\n\n                  case 'bool' :\n                     if (!in_array($value, [0,1])) {\n                        $unset = true;\n                     }\n                     break;\n\n                  case 'ip' :\n                     $address = new IPAddress();\n                     if (!$address->setAddressFromString($value)) {\n                        $unset = true;\n                     } else if (!$address->is_ipv4()) {\n                        $unset = true;\n                     }\n                     break;\n\n                  case 'mac' :\n                     preg_match(\"/([0-9a-fA-F]{1,2}([:-]|$)){6}$/\", $value, $regs);\n                     if (empty($regs)) {\n                        $unset = true;\n                     }\n                     // Define the MAC address to lower to reduce complexity of SQL queries\n                     $this->input[$key] = strtolower ($value);\n                     break;\n\n                  case 'date' :\n                  case 'datetime' :\n                     // Date is already \"reformat\" according to getDateFormat()\n                     $pattern  = \"/^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})\";\n                     $pattern .= \"([_][01][0-9]|2[0-3]:[0-5][0-9]:[0-5]?[0-9])?/\";\n                     preg_match($pattern, $value, $regs);\n                     if (empty($regs)) {\n                        $unset = true;\n                     }\n                     break;\n\n                  case 'itemtype' :\n                     //Want to insert an itemtype, but the associated class doesn't exists\n                     if (!class_exists($value)) {\n                        $unset = true;\n                     }\n\n                  case 'email' :\n                  case 'string' :\n                     if (strlen($value) > 255) {\n                        Toolbox::logWarning(\"$value exceed 255 characters long (\".strlen($value).\"), it will be truncated.\");\n                        $this->input[$key] = substr($value, 0, 254);\n                     }\n                     break;\n\n                  default :\n                     //Plugins can implement their own checks\n                     if (!$this->checkSpecificValues($searchOption['datatype'], $value)) {\n                        $unset = true;\n                     }\n                     // Copy value if check have update it\n                     $this->input[$key] = $value;\n                     break;\n               }\n            }\n\n            if ($unset) {\n               $fails[] = $searchOption['name'];\n               unset($this->input[$key]);\n            }\n         }\n      }\n      if ($display && count($fails)) {\n         //Display a message to indicate that one or more value where filtered\n         //TRANS: %s is the list of the failed fields\n         $message = sprintf(__('%1$s: %2$s'), __('At least one field has an incorrect value'),\n                            implode(',', $fails));\n         Session::addMessageAfterRedirect($message, INFO, true);\n      }\n   }\n\n\n   /**\n    * Add more check for values\n    *\n    * @param string $datatype datatype of the value\n    * @param array  $value    value to check (pass by reference)\n    *\n    * @return boolean true if value is ok, false if not\n   **/\n   function checkSpecificValues($datatype, &$value) {\n      return true;\n   }\n\n\n   /**\n    * Get fields to display in the unicity error message\n    *\n    * @return array an array which contains field => label\n   **/\n   function getUnicityFieldsToDisplayInErrorMessage() {\n\n      return ['id'          => __('ID'),\n                   'serial'      => __('Serial number'),\n                   'entities_id' => __('Entity')];\n   }\n\n\n   function getUnallowedFieldsForUnicity() {\n      return ['alert', 'comment', 'date_mod', 'id', 'is_recursive', 'items_id'];\n   }\n\n\n   /**\n    * Build an unicity error message\n    *\n    * @param array $msgs    the string not transleted to be display on the screen, or to be sent in a notification\n    * @param array $unicity the unicity criterion that failed to match\n    * @param array $doubles the items that are already present in DB\n    *\n    * @return string\n   **/\n   function getUnicityErrorMessage($msgs, $unicity, $doubles) {\n\n      $message = [];\n      foreach ($msgs as $field => $value) {\n         $table = getTableNameForForeignKeyField($field);\n         if ($table != '') {\n            $searchOption = $this->getSearchOptionByField('field', 'name', $table);\n         } else {\n            $searchOption = $this->getSearchOptionByField('field', $field);\n         }\n         $message[] = sprintf(__('%1$s = %2$s'), $searchOption['name'], $value);\n      }\n\n      if ($unicity['action_refuse']) {\n         $message_text = sprintf(__('Impossible record for %s'),\n                                 implode('&nbsp;&amp;&nbsp;', $message));\n      } else {\n         $message_text = sprintf(__('Item successfully added but duplicate record on %s'),\n                                 implode('&nbsp;&amp;&nbsp;', $message));\n      }\n      $message_text .= '<br>'.__('Other item exist');\n\n      foreach ($doubles as $double) {\n         if (in_array('CommonDBChild', class_parents($this))) {\n            if ($this->getField($this->itemtype)) {\n               $item = new $double['itemtype']();\n            } else {\n               $item = new $this->itemtype();\n            }\n\n            $item->getFromDB($double['items_id']);\n         } else {\n            $item = clone $this;\n            $item->getFromDB($double['id']);\n         }\n\n         $double_text = '';\n         if ($item->canView() && $item->canViewItem()) {\n            $double_text = $item->getLink();\n         }\n\n         foreach ($this->getUnicityFieldsToDisplayInErrorMessage() as $key => $value) {\n            $field_value = $item->getField($key);\n            if ($field_value != NOT_AVAILABLE) {\n               if (getTableNameForForeignKeyField($key) != '') {\n                  $field_value = Dropdown::getDropdownName(getTableNameForForeignKeyField($key),\n                                                           $field_value);\n               }\n               $new_text = sprintf(__('%1$s: %2$s'), $value, $field_value);\n               if (empty($double_text)) {\n                  $double_text = $new_text;\n               } else {\n                  $double_text = sprintf(__('%1$s - %2$s'), $double_text, $new_text);\n               }\n            }\n         }\n         // Add information on item in trashbin\n         if ($item->isField('is_deleted') && $item->getField('is_deleted')) {\n            $double_text = sprintf(__('%1$s - %2$s'), $double_text, __('Item in the trashbin'));\n         }\n\n         $message_text .= \"<br>[$double_text]\";\n      }\n      return $message_text;\n   }\n\n\n   /**\n    * Check field unicity before insert or update\n    *\n    * @param boolean $add     true for insert, false for update (false by default)\n    * @param array   $options array\n    *\n    * @return boolean true if item can be written in DB, false if not\n   **/\n   function checkUnicity($add = false, $options = []) {\n      global $CFG_GLPI;\n\n      $p = [\n         'unicity_error_message'  => true,\n         'add_event_on_duplicate' => true,\n         'disable_unicity_check'  => false,\n      ];\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $value) {\n            $p[$key] = $value;\n         }\n      }\n\n      // Do not check for template\n      if (isset($this->input['is_template']) && $this->input['is_template']) {\n         return true;\n      }\n\n      $result = true;\n\n      //Do not check unicity when creating infocoms or if checking is expliclty disabled\n      if ($p['disable_unicity_check']) {\n         return $result;\n      }\n\n      //Get all checks for this itemtype and this entity\n      if (in_array(get_class($this), $CFG_GLPI[\"unicity_types\"])) {\n         // Get input entities if set / else get object one\n         if (isset($this->input['entities_id'])) {\n            $entities_id = $this->input['entities_id'];\n         } else if (isset($this->fields['entities_id'])) {\n            $entities_id = $this->fields['entities_id'];\n         } else {\n            $message = 'Missing entity ID!';\n            Toolbox::logError($message);\n         }\n\n         $all_fields =  FieldUnicity::getUnicityFieldsConfig(get_class($this), $entities_id);\n         foreach ($all_fields as $key => $fields) {\n\n            //If there's fields to check\n            if (!empty($fields) && !empty($fields['fields'])) {\n               $where    = [];\n               $continue = true;\n               foreach (explode(',', $fields['fields']) as $field) {\n                  if (isset($this->input[$field]) //Field is set\n                      //Standard field not null\n                      && (((getTableNameForForeignKeyField($field) == '')\n                           && ($this->input[$field] != ''))\n                          //Foreign key and value is not 0\n                          || ((getTableNameForForeignKeyField($field) != '')\n                              && ($this->input[$field] > 0)))\n                      && !Fieldblacklist::isFieldBlacklisted(get_class($this), $entities_id, $field,\n                                                             $this->input[$field])) {\n                     $where[$this->getTable() . '.' . $field] = $this->input[$field];\n                  } else {\n                     $continue = false;\n                  }\n               }\n\n               if ($continue\n                   && count($where)) {\n                  $entities = $fields['entities_id'];\n                  if ($fields['is_recursive']) {\n                     $entities = getSonsOf('glpi_entities', $fields['entities_id']);\n                  }\n                  $where[] = getEntitiesRestrictCriteria($this->getTable(), '', $entities);\n\n                  $tmp = clone $this;\n                  if ($tmp->maybeTemplate()) {\n                     $where['is_template'] = 0;\n                  }\n\n                  //If update, exclude ID of the current object\n                  if (!$add) {\n                     $where['NOT'] = [$this->getTable() . '.id' => $this->input['id']];\n                  }\n\n                  if (countElementsInTable($this->getTable(), $where) > 0) {\n                     if ($p['unicity_error_message']\n                         || $p['add_event_on_duplicate']) {\n                        $message = [];\n                        foreach (explode(',', $fields['fields']) as $field) {\n                           $message[$field] = $this->input[$field];\n                        }\n\n                        $doubles      = getAllDataFromTable($this->getTable(), $where);\n                        $message_text = $this->getUnicityErrorMessage($message, $fields, $doubles);\n                        if ($p['unicity_error_message']) {\n                           if (!$fields['action_refuse']) {\n                              $show_other_messages = ($fields['action_refuse']?true:false);\n                           } else {\n                              $show_other_messages = true;\n                           }\n                           Session::addMessageAfterRedirect($message_text, true,\n                                                            $show_other_messages,\n                                                            $show_other_messages);\n                        }\n                        if ($p['add_event_on_duplicate']) {\n                           Event::log ((!$add?$this->fields['id']:0), get_class($this), 4,\n                                       'inventory',\n                                       //TRANS: %1$s is the user login, %2$s the message\n                                       sprintf(__('%1$s trying to add an item that already exists: %2$s'),\n                                               $_SESSION[\"glpiname\"], $message_text));\n                        }\n                     }\n                     if ($fields['action_refuse']) {\n                        $result = false;\n                     }\n                     if ($fields['action_notify']) {\n                        $params = [\n                           'action_type' => $add,\n                           'action_user' => getUserName(Session::getLoginUserID()),\n                           'entities_id' => $entities_id,\n                           'itemtype'    => get_class($this),\n                           'date'        => $_SESSION['glpi_currenttime'],\n                           'refuse'      => $fields['action_refuse'],\n                           'label'       => $message,\n                           'field'       => $fields,\n                           'double'      => $doubles];\n                        NotificationEvent::raiseEvent('refuse', new FieldUnicity(), $params);\n                     }\n                  }\n               }\n            }\n         }\n\n      }\n\n      return $result;\n   }\n\n\n   /**\n    * Clean all infos which match some criteria\n    *\n    * @param array   $crit    array of criteria (ex array('is_active'=>'1'))\n    * @param boolean $force   force purge not on put in trashbin (default 0)\n    * @param boolean $history do history log ? (true by default)\n    *\n    * @return boolean\n   **/\n   function deleteByCriteria($crit = [], $force = 0, $history = 1) {\n      global $DB;\n\n      $ok = false;\n      if (is_array($crit) && (count($crit) > 0)) {\n         $crit['FIELDS'] = [$this::getTable() => 'id'];\n         $ok = true;\n         $iterator = $DB->request($this->getTable(), $crit);\n         foreach ($iterator as $row) {\n            if (!$this->delete($row, $force, $history)) {\n               $ok = false;\n            }\n         }\n\n      }\n      return $ok;\n   }\n\n\n   /**\n    * get the Entity of an Item\n    *\n    * @param string  $itemtype item type\n    * @param integer $items_id id of the item\n    *\n    * @return integer ID of the entity or -1\n   **/\n   static function getItemEntity($itemtype, $items_id) {\n\n      if ($itemtype\n          && ($item = getItemForItemtype($itemtype))) {\n\n         if ($item->getFromDB($items_id)) {\n            return $item->getEntityID();\n         }\n\n      }\n      return -1;\n   }\n\n\n   /**\n    * display a specific field value\n    *\n    * @since 0.83\n    *\n    * @param string       $field   name of the field\n    * @param string|array $values  with the value to display or a Single value\n    * @param array        $options Array of options\n    *\n    * @return string the string to display\n   **/\n   static function getSpecificValueToDisplay($field, $values, array $options = []) {\n\n      switch ($field) {\n         case '_virtual_datacenter_position':\n            if (method_exists(static::class, 'getDcBreadcrumbSpecificValueToDisplay')) {\n               return static::getDcBreadcrumbSpecificValueToDisplay($values['id']);\n            }\n      }\n\n      return '';\n   }\n\n\n   /**\n    * display a field using standard system\n    *\n    * @since 0.83\n    *\n    * @param integer|string|array $field_id_or_search_options id of the search option field\n    *                                                             or field name\n    *                                                             or search option array\n    * @param mixed                $values                     value to display\n    * @param array                $options                    array of possible options:\n    * Parameters which could be used in options array :\n    *    - comments : boolean / is the comments displayed near the value (default false)\n    *    - any others options passed to specific display method\n    *\n    * @return string the string to display\n   **/\n   function getValueToDisplay($field_id_or_search_options, $values, $options = []) {\n      global $CFG_GLPI;\n\n      $param = [\n         'comments' => false,\n         'html'     => false,\n      ];\n      foreach ($param as $key => $val) {\n         if (!isset($options[$key])) {\n            $options[$key] = $val;\n         }\n      }\n\n      $searchoptions = [];\n      if (is_array($field_id_or_search_options)) {\n         $searchoptions = $field_id_or_search_options;\n      } else {\n         $searchopt = $this->searchOptions();\n\n         // Get if id of search option is passed\n         if (is_numeric($field_id_or_search_options)) {\n            if (isset($searchopt[$field_id_or_search_options])) {\n               $searchoptions = $searchopt[$field_id_or_search_options];\n            }\n         } else { // Get if field name is passed\n            $searchoptions = $this->getSearchOptionByField('field', $field_id_or_search_options,\n                                                           $this->getTable());\n         }\n      }\n\n      if (count($searchoptions)) {\n         $field = $searchoptions['field'];\n\n         // Normalize option\n         if (is_array($values)) {\n            $value = $values[$field];\n         } else {\n            $value  = $values;\n            $values = [$field => $value];\n         }\n\n         if (isset($searchoptions['datatype'])) {\n            $unit = '';\n            if (isset($searchoptions['unit'])) {\n               $unit = $searchoptions['unit'];\n            }\n\n            switch ($searchoptions['datatype']) {\n               case \"count\" :\n               case \"number\" :\n                  if (isset($searchoptions['toadd']) && isset($searchoptions['toadd'][$value])) {\n                     return $searchoptions['toadd'][$value];\n                  }\n                  if ($options['html']) {\n                     return Dropdown::getValueWithUnit(Html::formatNumber($value, false, 0), $unit);\n                  }\n                  return $value;\n\n               case \"decimal\" :\n                  if ($options['html']) {\n                     return Dropdown::getValueWithUnit(Html::formatNumber($value), $unit);\n                  }\n                  return $value;\n\n               case \"string\" :\n               case \"mac\" :\n               case \"ip\" :\n                  return $value;\n\n               case \"text\" :\n\n                  if ($options['html']) {\n                     $text = nl2br($value);\n                  } else {\n                     $text = $value;\n                  }\n                  if (isset($searchoptions['htmltext']) && $searchoptions['htmltext']) {\n                     $text = Html::clean(Toolbox::unclean_cross_side_scripting_deep($text));\n                  }\n                  return $text;\n\n               case \"bool\" :\n                  return Dropdown::getYesNo($value);\n\n               case \"date\" :\n               case \"date_delay\" :\n                  if (isset($options['relative_dates']) && $options['relative_dates']) {\n                     $dates = Html::getGenericDateTimeSearchItems(['with_time'   => true,\n                                                                        'with_future' => true]);\n                     return $dates[$value];\n                  }\n                  return Html::convDate(Html::computeGenericDateTimeSearch($value, true));\n\n               case \"datetime\" :\n                  if (isset($options['relative_dates']) && $options['relative_dates']) {\n                     $dates = Html::getGenericDateTimeSearchItems(['with_time'   => true,\n                                                                        'with_future' => true]);\n                     return $dates[$value];\n                  }\n                  return Html::convDateTime(Html::computeGenericDateTimeSearch($value, false));\n\n               case \"timestamp\" :\n                  if (($value == 0)\n                      && isset($searchoptions['emptylabel'])) {\n                     return $searchoptions['emptylabel'];\n                  }\n                  $withseconds = false;\n                  if (isset($searchoptions['withseconds'])) {\n                     $withseconds = $searchoptions['withseconds'];\n                  }\n                  return Html::timestampToString($value, $withseconds);\n\n               case \"email\" :\n                  if ($options['html']) {\n                     return \"<a href='mailto:$value'>$value</a>\";\n                  }\n                  return $value;\n\n               case \"weblink\" :\n                  $orig_link = trim($value);\n                  if (!empty($orig_link)) {\n                     // strip begin of link\n                     $link = preg_replace('/https?:\\/\\/(www[^\\.]*\\.)?/', '', $orig_link);\n                     $link = preg_replace('/\\/$/', '', $link);\n                     if (Toolbox::strlen($link) > $CFG_GLPI[\"url_maxlength\"]) {\n                        $link = Toolbox::substr($link, 0, $CFG_GLPI[\"url_maxlength\"]).\"...\";\n                     }\n                     return \"<a href=\\\"\".Toolbox::formatOutputWebLink($orig_link).\"\\\" target='_blank'>$link\".\n                            \"</a>\";\n                  }\n                  return \"&nbsp;\";\n\n               case \"itemlink\" :\n                  if ($searchoptions['table'] == $this->getTable()) {\n                     break;\n                  }\n\n               case \"dropdown\" :\n                  if (isset($searchoptions['toadd']) && isset($searchoptions['toadd'][$value])) {\n                     return $searchoptions['toadd'][$value];\n                  }\n                  if (!is_numeric($value)) {\n                     return $value;\n                  }\n\n                  if (($value == 0)\n                      && isset($searchoptions['emptylabel'])) {\n                     return $searchoptions['emptylabel'];\n                  }\n\n                  if ($searchoptions['table'] == 'glpi_users') {\n                     if ($param['comments']) {\n                        $tmp = getUserName($value, 2);\n                        return $tmp['name'].'&nbsp;'.Html::showToolTip($tmp['comment'],\n                                                                       ['display' => false]);\n                     }\n                     return getUserName($value);\n                  }\n                  if ($param['comments']) {\n                     $tmp = Dropdown::getDropdownName($searchoptions['table'], $value, 1);\n                     return $tmp['name'].'&nbsp;'.Html::showToolTip($tmp['comment'],\n                                                                    ['display' => false]);\n                  }\n                  return Dropdown::getDropdownName($searchoptions['table'], $value);\n\n               case \"itemtypename\" :\n                  if ($obj = getItemForItemtype($value)) {\n                     return $obj->getTypeName(1);\n                  }\n                  break;\n\n               case \"language\" :\n                  if (isset($CFG_GLPI['languages'][$value])) {\n                     return $CFG_GLPI['languages'][$value][0];\n                  }\n                  return __('Default value');\n\n            }\n         }\n         // Get specific display if available\n         $itemtype = getItemTypeForTable($searchoptions['table']);\n         if ($item = getItemForItemtype($itemtype)) {\n            $options['searchopt'] = $searchoptions;\n            $specific = $item->getSpecificValueToDisplay($field, $values, $options);\n            if (!empty($specific)) {\n               return $specific;\n            }\n         }\n\n      }\n      return $value;\n   }\n\n   /**\n    * display a specific field selection system\n    *\n    * @since 0.83\n    *\n    * @param string       $field   name of the field\n    * @param string       $name    name of the select (if empty use linkfield) (default '')\n    * @param string|array $values  with the value to select or a Single value (default '')\n    * @param array        $options aArray of options\n    *\n    * @return string the string to display\n   **/\n   static function getSpecificValueToSelect($field, $name = '', $values = '', array $options = []) {\n      return '';\n   }\n\n\n   /**\n    * Select a field using standard system\n    *\n    * @since 0.83\n    *\n    * @param integer|string|array $field_id_or_search_options id of the search option field\n    *                                                             or field name\n    *                                                             or search option array\n    * @param string               $name                       name of the select (if empty use linkfield)\n    *                                                         (default '')\n    * @param mixed                $values                     default value to display\n    *                                                         (default '')\n    * @param array                $options                    array of possible options:\n    * Parameters which could be used in options array :\n    *    - comments : boolean / is the comments displayed near the value (default false)\n    *    - any others options passed to specific display method\n    *\n    * @return string the string to display\n   **/\n   function getValueToSelect($field_id_or_search_options, $name = '', $values = '', $options = []) {\n      global $CFG_GLPI;\n\n      $param = [\n         'comments' => false,\n         'html'     => false,\n      ];\n      foreach ($param as $key => $val) {\n         if (!isset($options[$key])) {\n            $options[$key] = $val;\n         }\n      }\n\n      $searchoptions = [];\n      if (is_array($field_id_or_search_options)) {\n         $searchoptions = $field_id_or_search_options;\n      } else {\n         $searchopt = $this->searchOptions();\n\n         // Get if id of search option is passed\n         if (is_numeric($field_id_or_search_options)) {\n            if (isset($searchopt[$field_id_or_search_options])) {\n               $searchoptions = $searchopt[$field_id_or_search_options];\n            }\n         } else { // Get if field name is passed\n            $searchoptions = $this->getSearchOptionByField('field', $field_id_or_search_options,\n                                                           $this->getTable());\n         }\n      }\n      if (count($searchoptions)) {\n         $field = $searchoptions['field'];\n         // Normalize option\n         if (is_array($values)) {\n            $value = $values[$field];\n         } else {\n            $value  = $values;\n            $values = [$field => $value];\n         }\n\n         if (empty($name)) {\n            $name = $searchoptions['linkfield'];\n         }\n         // If not set : set to specific\n         if (!isset($searchoptions['datatype'])) {\n            $searchoptions['datatype'] = 'specific';\n         }\n\n         $options['display'] = false;\n\n         if (isset($options[$searchoptions['table'].'.'.$searchoptions['field']])) {\n            $options = array_merge($options,\n                                   $options[$searchoptions['table'].'.'.$searchoptions['field']]);\n         }\n\n         switch ($searchoptions['datatype']) {\n            case \"count\" :\n            case \"number\" :\n            case \"integer\" :\n               $copytooption = ['min', 'max', 'step', 'toadd', 'unit'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Dropdown::showNumber($name, $options);\n\n            case \"decimal\" :\n            case \"mac\" :\n            case \"ip\" :\n            case \"string\" :\n            case \"email\" :\n            case \"weblink\" :\n               $this->fields[$name] = $value;\n               return Html::autocompletionTextField($this, $name, $options);\n\n            case \"text\" :\n               $out = '';\n               if (isset($searchoptions['htmltext']) && $searchoptions['htmltext']) {\n                  $out = Html::initEditorSystem($name, '', false);\n               }\n               return $out.\"<textarea cols='45' rows='5' name='$name'>$value</textarea>\";\n\n            case \"bool\" :\n               return Dropdown::showYesNo($name, $value, -1, $options);\n\n            case \"color\" :\n               return Html::showColorField($name, $options);\n\n            case \"date\" :\n            case \"date_delay\" :\n               if (isset($options['relative_dates']) && $options['relative_dates']) {\n                  if (isset($searchoptions['maybefuture']) && $searchoptions['maybefuture']) {\n                     $options['with_future'] = true;\n                  }\n                  return Html::showGenericDateTimeSearch($name, $value, $options);\n               }\n               $copytooption = ['min', 'max', 'maybeempty', 'showyear'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Html::showDateField($name, $options);\n\n            case \"datetime\" :\n               if (isset($options['relative_dates']) && $options['relative_dates']) {\n                  if (isset($searchoptions['maybefuture']) && $searchoptions['maybefuture']) {\n                     $options['with_future'] = true;\n                  }\n                  $options['with_time'] = true;\n                  return Html::showGenericDateTimeSearch($name, $value, $options);\n               }\n               $copytooption = ['mindate', 'maxdate', 'mintime', 'maxtime',\n                                     'maybeempty', 'timestep'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Html::showDateTimeField($name, $options);\n\n            case \"timestamp\" :\n               $copytooption = ['addfirstminutes', 'emptylabel', 'inhours',  'max', 'min',\n                                     'step', 'toadd', 'display_emptychoice'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Dropdown::showTimeStamp($name, $options);\n\n            case \"itemlink\" :\n               // Do not use dropdown if wanted to select string value instead of ID\n               if (isset($options['itemlink_as_string']) && $options['itemlink_as_string']) {\n                  break;\n               }\n\n            case \"dropdown\" :\n               $copytooption     = ['condition', 'displaywith', 'emptylabel',\n                                         'right', 'toadd'];\n               $options['name']  = $name;\n               $options['value'] = $value;\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               if (!isset($options['entity'])) {\n                  $options['entity'] = $_SESSION['glpiactiveentities'];\n               }\n               $itemtype = getItemTypeForTable($searchoptions['table']);\n\n               return $itemtype::dropdown($options);\n\n            case \"right\" :\n                return Profile::dropdownRights(Profile::getRightsFor($searchoptions['rightclass']),\n                                               $name, $value, ['multiple' => false,\n                                                                    'display'  => false]);\n\n            case \"itemtypename\" :\n               if (isset($searchoptions['itemtype_list'])) {\n                  $options['types'] = $CFG_GLPI[$searchoptions['itemtype_list']];\n               }\n               $copytooption     = ['types'];\n               $options['value'] = $value;\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               if (isset($options['types'])) {\n                  return Dropdown::showItemTypes($name, $options['types'],\n                                                   $options);\n               }\n               return false;\n\n            case \"language\" :\n               $copytooption = ['emptylabel', 'display_emptychoice'];\n               foreach ($copytooption as $key) {\n                  if (isset($searchoptions[$key]) && !isset($options[$key])) {\n                     $options[$key] = $searchoptions[$key];\n                  }\n               }\n               $options['value'] = $value;\n               return Dropdown::showLanguages($name, $options);\n\n         }\n         // Get specific display if available\n         $itemtype = getItemTypeForTable($searchoptions['table']);\n         if ($item = getItemForItemtype($itemtype)) {\n            $specific = $item->getSpecificValueToSelect($searchoptions['field'], $name,\n                                                        $values, $options);\n            if (strlen($specific)) {\n               return $specific;\n            }\n         }\n      }\n      // default case field text\n      $this->fields[$name] = $value;\n      return Html::autocompletionTextField($this, $name, $options);\n   }\n\n\n   /**\n    * @param string  $itemtype Item type\n    * @param string  $target   Target\n    * @param boolean $add      (default 0)\n    *\n    * @return false|void\n    */\n   static function listTemplates($itemtype, $target, $add = 0) {\n      global $DB;\n\n      if (!($item = getItemForItemtype($itemtype))) {\n         return false;\n      }\n\n      if (!$item->maybeTemplate()) {\n         return false;\n      }\n\n      // Avoid to get old data\n      $item->clearSavedInput();\n\n      //Check is user have minimum right r\n      if (!$item->canView()\n          && !$item->canCreate()) {\n         return false;\n      }\n\n      $request = [\n         'FROM'   => $item->getTable(),\n         'WHERE'  => [\n            'is_template'  => 1\n         ],\n         'ORDER'  => ['template_name']\n      ];\n\n      if ($item->isEntityAssign()) {\n         $request['WHERE'] = $request['WHERE'] + getEntitiesRestrictCriteria(\n            $item->getTable(),\n            'entities_id',\n            $_SESSION['glpiactiveentities'],\n            $item->maybeRecursive()\n         );\n      }\n\n      if (Session::isMultiEntitiesMode()) {\n         $colspan=3;\n      } else {\n         $colspan=2;\n      }\n\n      $iterator = $DB->request($request);\n      $blank_params = (strpos($target, '?') ? '&' : '?') . \"id=-1&withtemplate=2\";\n      $target_blank = $target . $blank_params;\n\n      if ($add && count($iterator) == 0) {\n         //if there is no template, just use blank\n         Html::redirect($target_blank);\n      }\n\n      echo \"<div class='center'><table class='tab_cadre'>\";\n      if ($add) {\n         echo \"<tr><th>\" . $item->getTypeName(1).\"</th>\";\n         echo \"<th>\".__('Choose a template').\"</th></tr>\";\n         echo \"<tr><td class='tab_bg_1 center' colspan='$colspan'>\";\n         echo \"<a href=\\\"\" . Html::entities_deep($target_blank) . \"\\\">\".__('Blank Template').\"</a></td>\";\n         echo \"</tr>\";\n      } else {\n         echo \"<tr><th>\".$item->getTypeName(1).\"</th>\";\n         if (Session::isMultiEntitiesMode()) {\n            echo \"<th>\".__('Entity').\"</th>\";\n         }\n         echo \"<th>\".__('Templates').\"</th></tr>\";\n      }\n\n      while ($data = $iterator->next()) {\n         $templname = $data[\"template_name\"];\n         if ($_SESSION[\"glpiis_ids_visible\"] || empty($data[\"template_name\"])) {\n            $templname = sprintf(__('%1$s (%2$s)'), $templname, $data[\"id\"]);\n         }\n         if (Session::isMultiEntitiesMode()) {\n            $entity = Dropdown::getDropdownName('glpi_entities', $data['entities_id']);\n         }\n         if ($item->canCreate() && !$add) {\n            $modify_params =\n               (strpos($target, '?') ? '&amp;' : '?')\n               . \"id=\".$data['id']\n               . \"&amp;withtemplate=1\";\n            $target_modify = $target . $modify_params;\n\n            echo \"<tr><td class='tab_bg_1 center'>\";\n            echo \"<a href=\\\"$target_modify\\\">\";\n            echo \"&nbsp;&nbsp;&nbsp;$templname&nbsp;&nbsp;&nbsp;</a></td>\";\n            if (Session::isMultiEntitiesMode()) {\n               echo \"<td class='tab_bg_1 center'>$entity</td>\";\n            }\n            echo \"<td class='tab_bg_2 center b'>\";\n            if ($item->can($data['id'], PURGE)) {\n               Html::showSimpleForm($target, 'purge', _x('button', 'Delete permanently'),\n                                    ['withtemplate' => 1,\n                                       'id'           => $data['id']]);\n            }\n            echo \"</td>\";\n         } else {\n            $add_params =\n               (strpos($target, '?') ? '&amp;' : '?')\n               . \"id=\".$data['id']\n               . \"&amp;withtemplate=2\";\n            $target_add = $target . $add_params;\n\n            echo \"<tr><td class='tab_bg_1 center' colspan='2'>\";\n            echo \"<a href=\\\"$target_add\\\">\";\n            echo \"&nbsp;&nbsp;&nbsp;$templname&nbsp;&nbsp;&nbsp;</a></td>\";\n         }\n         echo \"</tr>\";\n      }\n\n      if ($item->canCreate() && !$add) {\n         $create_params =\n            (strpos($target, '?') ? '&amp;' : '?')\n            . \"withtemplate=1\";\n         $target_create = $target . $create_params;\n         echo \"<tr><td class='tab_bg_2 center b' colspan='3'>\";\n         echo \"<a href=\\\"$target_create\\\">\" . __('Add a template...') . \"</a>\";\n         echo \"</td></tr>\";\n      }\n      echo \"</table></div>\\n\";\n   }\n\n\n   /**\n    * Specificy a plugin itemtype for which entities_id and is_recursive should be forwarded\n    *\n    * @since 0.83\n    *\n    * @param string $for_itemtype change of entity for this itemtype will be forwarder\n    * @param string $to_itemtype  change of entity will affect this itemtype\n    *\n    * @return void\n   **/\n   static function addForwardEntity($for_itemtype, $to_itemtype) {\n      self::$plugins_forward_entity[$for_itemtype][] = $to_itemtype;\n   }\n\n\n   /**\n    * Is entity informations forward To ?\n    *\n    * @since 0.84\n    *\n    * @param string $itemtype itemtype to check\n    *\n    * @return boolean\n   **/\n   static function isEntityForwardTo($itemtype) {\n\n      if (in_array($itemtype, static::$forward_entity_to)) {\n         return true;\n      }\n      //Fill forward_entity_to array with itemtypes coming from plugins\n      if (isset(static::$plugins_forward_entity[static::getType()])\n          && in_array($itemtype, static::$plugins_forward_entity[static::getType()])) {\n         return true;\n      }\n      return false;\n   }\n\n\n   /**\n    * Get rights for an item _ may be overload by object\n    *\n    * @since 0.85\n    *\n    * @param string $interface (defalt 'central')\n    *\n    * @return array array of rights to display\n   **/\n   function getRights($interface = 'central') {\n\n      $values = [CREATE  => __('Create'),\n                      READ    => __('Read'),\n                      UPDATE  => __('Update'),\n                      PURGE   => ['short' => __('Purge'),\n                                       'long'  => _x('button', 'Delete permanently')]];\n\n      $values += ObjectLock::getRightsToAdd( get_class($this), $interface );\n\n      if ($this->maybeDeleted()) {\n         $values[DELETE] = ['short' => __('Delete'),\n                                 'long'  => _x('button', 'Put in trashbin')];\n      }\n      if ($this->usenotepad) {\n         $values[READNOTE] = ['short' => __('Read notes'),\n                                   'long' => __(\"Read the item's notes\")];\n         $values[UPDATENOTE] = ['short' => __('Update notes'),\n                                     'long' => __(\"Update the item's notes\")];\n      }\n\n      return $values;\n   }\n\n   /**\n    * Generate link\n    *\n    * @since 9.1\n    *\n    * @param string     $link original string content\n    * @param CommonDBTM $item item used to make replacements\n    *\n    * @return array of link contents (may have several when item have several IP / MAC cases)\n   **/\n   static function generateLinkContents($link, CommonDBTM $item) {\n      return Link::generateLinkContents($link, $item);\n   }\n\n\n   /**\n    * add files from a textarea (from $this->input['content'])\n    * or a file input (from $this->input['_filename']) to an CommonDBTM object\n    * create document if needed\n    * create link from document to CommonDBTM object\n    *\n    * @since 9.2\n    *\n    * @param array $input   Input data\n    * @param array $options array with theses keys\n    *                        - force_update (default false) update the content field of the object\n    *                        - content_field (default content) the field who receive the main text\n    *                                                          (with images)\n    *                        - name (default filename) name of the HTML input containing files\n    *\n    * @return array the input param transformed\n   **/\n   function addFiles(array $input, $options = []) {\n      global $CFG_GLPI;\n\n      $default_options = [\n         'force_update'  => false,\n         'content_field' => 'content',\n         'name'          => 'filename',\n      ];\n      $options = array_merge($default_options, $options);\n\n      $uploadName = '_' . $options['name'];\n      $tagUploadName = '_tag_' . $options['name'];\n      $prefixUploadName = '_prefix_' . $options['name'];\n\n      if (!isset($input[$uploadName])\n          || (count($input[$uploadName]) == 0)) {\n         return $input;\n      }\n      $docadded     = [];\n      $donotif      = isset($input['_donotif']) ? $input['_donotif'] : 0;\n      $disablenotif = isset($input['_disablenotif']) ? $input['_disablenotif'] : 0;\n\n      foreach ($input[$uploadName] as $key => $file) {\n         $doc      = new Document();\n         $docitem  = new Document_Item();\n         $docID    = 0;\n         $filename = GLPI_TMP_DIR.\"/\".$file;\n         $input2   = [];\n\n         //If file tag is present\n         if (isset($input[$tagUploadName])\n             && !empty($input[$tagUploadName][$key])) {\n            $input['_tag'][$key] = $input[$tagUploadName][$key];\n         }\n\n         //retrieve entity\n         $entities_id = isset($_SESSION['glpiactive_entity']) ? $_SESSION['glpiactive_entity'] : 0;\n         if (isset($this->fields[\"entities_id\"])) {\n            $entities_id = $this->fields[\"entities_id\"];\n         } else if (isset($input['entities_id'])) {\n            $entities_id = $input['entities_id'];\n         } else if (isset($input['_job']->fields['entities_id'])) {\n            $entities_id = $input['_job']->fields['entities_id'];\n         }\n\n         // Check for duplicate\n         if ($doc->getFromDBbyContent($entities_id, $filename)) {\n            if (!$doc->fields['is_blacklisted']) {\n               $docID = $doc->fields[\"id\"];\n            }\n            // File already exist, we replace the tag by the existing one\n            if (isset($input['_tag'][$key])\n                && ($docID > 0)\n                && isset($input[$options['content_field']])) {\n\n               $input[$options['content_field']] = str_replace(\n                  $input['_tag'][$key],\n                  $doc->fields[\"tag\"],\n                  $input[$options['content_field']]\n               );\n               $docadded[$docID]['tag'] = $doc->fields[\"tag\"];\n            }\n\n         } else {\n            if ($this->getType() == 'Ticket') {\n               //TRANS: Default document to files attached to tickets : %d is the ticket id\n               $input2[\"name\"] = addslashes(sprintf(__('Document Ticket %d'), $this->getID()));\n               $input2[\"tickets_id\"] = $this->getID();\n            }\n\n            if (isset($input['_tag'][$key])) {\n               // Insert image tag\n               $input2[\"tag\"] = $input['_tag'][$key];\n            }\n\n            $input2[\"entities_id\"]             = $entities_id;\n            $input2[\"is_recursive\"]            = 1;\n            $input2[\"documentcategories_id\"]   = $CFG_GLPI[\"documentcategories_id_forticket\"];\n            $input2[\"_only_if_upload_succeed\"] = 1;\n            $input2[\"_filename\"]               = [$file];\n            if (isset($this->input[$prefixUploadName][$key])) {\n               $input2[$prefixUploadName]  = [$this->input[$prefixUploadName][$key]];\n            }\n            $docID = $doc->add($input2);\n\n            if (isset($input['_tag'][$key])) {\n               // Store image tag\n               $docadded[$docID]['tag'] = $doc->fields[\"tag\"];\n            }\n         }\n\n         if ($docID > 0) {\n            // complete doc information\n            $docadded[$docID]['data'] = sprintf(__('%1$s - %2$s'),\n                                                stripslashes($doc->fields[\"name\"]),\n                                                stripslashes($doc->fields[\"filename\"]));\n            $docadded[$docID]['filepath'] = $doc->fields[\"filepath\"];\n\n            // add doc - item link\n            $toadd = [\n               'documents_id'  => $docID,\n               '_do_notif'     => $donotif,\n               '_disablenotif' => $disablenotif,\n               'itemtype'      => $this->getType(),\n               'items_id'      => $this->getID()\n            ];\n            if (isset($input['users_id'])) {\n               $toadd['users_id'] = $input['users_id'];\n            }\n            if (isset($input[$options['content_field']])\n                && strpos($input[$options['content_field']], $doc->fields[\"tag\"]) !== false\n                && strpos($doc->fields['mime'], 'image/') !== false) {\n               //do not display inline docs in timeline\n               $toadd['timeline_position'] = CommonITILObject::NO_TIMELINE;\n            }\n\n            $docitem->add($toadd);\n         }\n         // Only notification for the first New doc\n         $donotif = false;\n      }\n\n      // manage content transformation\n      if (isset($input[$options['content_field']])) {\n         $input[$options['content_field']] = Toolbox::convertTagToImage(\n            $input[$options['content_field']],\n            $this,\n            $docadded\n         );\n\n         if (isset($this->input['_forcenotif'])) {\n            $input['_forcenotif'] = $this->input['_forcenotif'];\n            unset($input['_disablenotif']);\n         }\n\n         // force update of content on add process (we are in post_addItem function)\n         if ($options['force_update']) {\n            $this->fields[$options['content_field']] = $input[$options['content_field']];\n            $this->updateInDB([$options['content_field']]);\n         }\n      }\n\n      return $input;\n   }\n\n   /**\n    * Get autofill mark for/from templates\n    *\n    * @param string $field   Field name\n    * @param array  $options Withtemplate parameter\n    * @param string $value   Optional value (if field to check is not part of current itemtype)\n    *\n    * @return string\n    */\n   public function getAutofillMark($field, $options, $value = null) {\n      $mark = '';\n      $title = null;\n      if (($this->isTemplate() || $this->isNewItem()) && $options['withtemplate'] == 1) {\n         $title = __s('You can define an autofill template');\n      } else if ($this->isTemplate()) {\n         if ($value === null) {\n            $value = $this->getField($field);\n         }\n         $len = Toolbox::strlen($value);\n         if ($len > 8\n            && Toolbox::substr($value, 0, 4) === '&lt;'\n            && Toolbox::substr($value, $len -4, 4) === '&gt;'\n            && preg_match(\"/\\\\#{1,10}/\", Toolbox::substr($value, 4, $len - 8))\n         ) {\n            $title = __s('Autofilled from template');\n         } else {\n            return '';\n         }\n      }\n      if ($title !== null) {\n         $mark = \"<i class='fa fa-magic' title='$title'></i>\";\n      }\n      return $mark;\n   }\n\n   /**\n   * Manage business rules for assets\n   *\n   * @since 9.4\n   *\n   * @param boolean $condition the condition (RuleAsset::ONADD or RuleAsset::ONUPDATE)\n   *\n   * @return void\n   */\n   private function assetBusinessRules($condition) {\n      global $CFG_GLPI;\n\n      //Only process itemtype that are assets\n      if (in_array($this->getType(), $CFG_GLPI['asset_types'])) {\n         $ruleasset          = new RuleAssetCollection();\n         $input              = $this->input;\n         $input['_itemtype'] = $this->getType();\n\n         //If _auto is not defined : it's a manual process : set it's value to 0\n         if (!isset($this->input['_auto'])) {\n            $input['_auto'] = 0;\n         }\n         //Set the condition (add or update)\n         $params = [\n            'condition' => $condition\n         ];\n         $output = $ruleasset->processAllRules($input, [], $params);\n         //If at least one rule has matched\n         if (isset($output['_rule_process'])) {\n            foreach ($output as $key => $value) {\n               if ($key == '_rule_process' || $key == '_no_rule_matches') {\n                  continue;\n               }\n               //Add the rule output to the input array\n               $this->input[$key] = $value;\n            }\n         }\n      }\n   }\n\n   /**\n    * Ensure the relation would not create a circular parent-child relation.\n    * @since 9.5.0\n    * @param int    $items_id The ID of the item to evaluate.\n    * @param int    $parents_id  The wanted parent of the specified item.\n    * @return bool True if there is a circular relation.\n    */\n   static function checkCircularRelation($items_id, $parents_id) {\n      global $DB;\n\n      $fk = static::getForeignKeyField();\n      if ($items_id == 0 || $parents_id == 0 || !$DB->fieldExists(static::getTable(), $fk)) {\n         return false;\n      }\n\n      $next_parent = $parents_id;\n      while ($next_parent > 0) {\n         if ($next_parent == $items_id) {\n            // This item is a parent higher up\n            return true;\n         }\n         $iterator = $DB->request([\n            'SELECT' => [$fk],\n            'FROM'   => static::getTable(),\n            'WHERE'  => ['id' => $next_parent]\n         ]);\n         if ($iterator->count()) {\n            $next_parent = $iterator->next()[$fk];\n         } else {\n            // Invalid parent\n            return false;\n         }\n      }\n      // No circular relations\n      return false;\n   }\n\n   /**\n    * Get incidents, request, changes and problem linked to this object\n    *\n    * @return array\n    */\n   public function getITILTickets(bool $count = false) {\n      $ticket = new Ticket();\n      $problem = new Problem();\n      $change = new Change();\n\n      $data = [\n         'incidents' => iterator_to_array(\n            $ticket->getActiveTicketsForItem(\n               get_class($this),\n               $this->getID(),\n               Ticket::INCIDENT_TYPE\n            ),\n            false\n         ),\n         'requests'  => iterator_to_array(\n            $ticket->getActiveTicketsForItem(\n               get_class($this),\n               $this->getID(),\n               Ticket::DEMAND_TYPE\n            ),\n            false\n         ),\n         'changes'   => iterator_to_array(\n            $change->getActiveChangesForItem(\n               get_class($this),\n               $this->getID()\n            ),\n            false\n         ),\n         'problems'  => iterator_to_array(\n            $problem->getActiveProblemsForItem(\n               get_class($this),\n               $this->getID()\n            ),\n            false\n         )\n      ];\n\n      if ($count) {\n         $data['count'] = count($data['incidents'])\n            + count($data['requests'])\n            + count($data['changes'])\n            + count($data['problems']);\n      }\n\n      return $data;\n   }\n\n   static function getIcon() {\n      return \"fas fa-empty-icon\";\n   }\n\n   /**\n    * Get cache key containing raw name for a given itemtype and id\n    *\n    * @since 9.5\n    *\n    * @param string  $itemtype\n    * @param int     $id\n    */\n   public static function getCacheKeyForFriendlyName($itemtype, $id) {\n      return \"raw_name__{$itemtype}__{$id}\";\n   }\n\n   /**\n    * Get friendly name by items id\n    * The purpose of this function is to try to access the friendly name\n    * without having to read the object from the database\n    *\n    * @since 9.5\n    *\n    * @param int $id\n    *\n    * @return string Friendly name of the object\n    */\n   public static function getFriendlyNameById($id) {\n      $item = new static();\n      $item->getFromDB($id);\n      return $item->getFriendlyName();\n   }\n\n   /**\n    * Return the computed friendly name and set the cache.\n    *\n    * @since 9.5\n    *\n    * @return string\n    */\n   final public function getFriendlyName() {\n      return $this->computeFriendlyName();\n   }\n\n   /**\n    * Compute the friendly name of the object\n    *\n    * @since 9.5\n    *\n    * @return string\n    */\n   protected function computeFriendlyName() {\n      if (isset($this->fields[static::getNameField()])) {\n         return $this->fields[static::getNameField()];\n      }\n      return '';\n   }\n\n   /**\n    * Retrieve an item from the database\n    *\n    * @param integer $ID ID of the item to get\n    *\n    * @return boolean true if succeed else false\n   */\n   public static function getById(int $id) {\n      $item = new static();\n\n      if (!$item->getFromDB($id)) {\n         return false;\n      }\n\n      return $item;\n   }\n\n   /**\n    * Correct entity id if needed when cloning a template\n    *\n    * @param array  $data\n    * @param string $parent_field\n    *\n    * @return array\n    */\n   public static function checkTemplateEntity(\n      array $data,\n      $parent_id,\n      $parent_itemtype\n   ) {\n      // No entity field -> no modification needed\n      if (!isset($data['entities_id'])) {\n         return $data;\n      }\n\n      // If the entity used in the template in not allowed for our current user,\n      // fallback to the parent template entity\n      if (!Session::haveAccessToEntity($data['entities_id'])) {\n         // Load parent\n         $parent = new $parent_itemtype();\n\n         if (!$parent->getFromDB($parent_id)) {\n            // Can't load parent -> no modification\n            return $data;\n         }\n\n         $data['entities_id'] = $parent->getEntityID();\n      }\n\n      return $data;\n   }\n}\n", "<?php\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\nnamespace tests\\units;\n\nuse DbTestCase;\n\n/* Test for inc/calendar.class.php */\n\nclass Calendar extends DbTestCase {\n\n   public function testComputeEndDate() {\n      $calendar = new \\Calendar;\n      //get default calendar\n      $this->boolean($calendar->getFromDB(getItemByTypeName('Calendar', 'Default', true)))->isTrue();\n\n      // ## test future dates\n      $end_date = $calendar->ComputeEndDate(\"2018-11-19 10:00:00\", 7 * DAY_TIMESTAMP, 0, true);\n      $this->string($end_date)->isEqualTo(\"2018-11-28 10:00:00\");\n      // end of day\n      $end_date = $calendar->ComputeEndDate(\"2018-11-19 10:00:00\", 7 * DAY_TIMESTAMP, 0, true, true);\n      $this->string($end_date)->isEqualTo(\"2018-11-28 20:00:00\");\n\n      // ## test past dates\n      $end_date = $calendar->ComputeEndDate(\"2018-11-19 10:00:00\", -7 * DAY_TIMESTAMP, 0, true);\n      $this->string($end_date)->isEqualTo(\"2018-11-08 10:00:00\");\n      // end of day\n      $end_date = $calendar->ComputeEndDate(\"2018-11-19 10:00:00\", -7 * DAY_TIMESTAMP, 0, true, true);\n      $this->string($end_date)->isEqualTo(\"2018-11-08 20:00:00\");\n   }\n\n   protected function activeProvider() {\n      return [\n         [\n            'start'  => '2019-01-01 07:00:00',\n            'end'    => '2019-01-01 09:00:00',\n            'value'  => HOUR_TIMESTAMP\n         ], [\n            'start'  => '2019-01-01 06:00:00',\n            'end'    => '2019-01-01 07:00:00',\n            'value'  => 0\n         ], [\n            'start'  => '2019-01-01 00:00:00',\n            'end'    => '2019-01-08 00:00:00',\n            'value'  => 12 * HOUR_TIMESTAMP * 5\n         ], [\n            'start'  => '2019-01-08 00:00:00',\n            'end'    => '2019-01-01 00:00:00',\n            'value'  => 0\n         ], [\n            'start'  => '2019-01-01 07:00:00',\n            'end'    => '2019-01-01 09:00:00',\n            'value'  => HOUR_TIMESTAMP * 2,\n            'day'    => true\n         ], [\n            'start'  => '2019-01-01 00:00:00',\n            'end'    => '2019-01-08 00:00:00',\n            'value'  => WEEK_TIMESTAMP,\n            'day'    => true\n         ]\n      ];\n   }\n\n   /**\n    * @dataProvider activeProvider\n    */\n   public function testGetActiveTimeBetween($start, $end, $value, $days = false) {\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB(1))->isTrue(); //get default calendar\n\n      $this->variable(\n         $calendar->getActiveTimeBetween(\n            $start,\n            $end,\n            $days\n         )\n      )->isEqualTo($value);\n   }\n\n   protected function workingdayProvider() {\n      return [\n         ['2019-01-01 00:00:00', true],\n         ['2019-01-02 00:00:00', true],\n         ['2019-01-03 00:00:00', true],\n         ['2019-01-04 00:00:00', true],\n         ['2019-01-05 00:00:00', false],\n         ['2019-01-06 00:00:00', false]\n      ];\n   }\n\n   /**\n    * @dataProvider workingdayProvider\n    */\n   public function testIsAWorkingDay($date, $expected) {\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB(1))->isTrue(); //get default calendar\n\n      $this->boolean($calendar->isAWorkingDay(strtotime($date)))->isIdenticalTo($expected);\n   }\n\n   public function testHasAWorkingDay() {\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB(1))->isTrue(); //get default calendar\n      $this->boolean($calendar->hasAWorkingDay())->isTrue();\n\n      $cid = $calendar->add([\n         'name'   => 'Test'\n      ]);\n      $this->integer($cid)->isGreaterThan(0);\n      $this->boolean($calendar->getFromDB($cid));\n      $this->boolean($calendar->hasAWorkingDay())->isFalse();\n   }\n\n   protected function workinghourProvider() {\n      return [\n         ['2019-01-01 00:00:00', false],\n         ['2019-01-02 08:30:00', true],\n         ['2019-01-03 18:10:00', true],\n         ['2019-01-04 21:00:00', false],\n         ['2019-01-05 08:30:00', false],\n         ['2019-01-06 00:00:00', false]\n      ];\n   }\n\n   /**\n    * @dataProvider workinghourProvider\n    */\n   public function testIsAWorkingHour($date, $expected) {\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB(1))->isTrue(); //get default calendar\n\n      $this->boolean($calendar->isAWorkingHour(strtotime($date)))->isIdenticalTo($expected);\n   }\n\n   private function addXmas(\\Calendar $calendar) {\n      $calendar_holiday = new \\Calendar_Holiday();\n      $this->integer(\n         (int)$calendar_holiday->add([\n            'calendars_id' => $calendar->fields['id'],\n            'holidays_id'  => getItemByTypeName('Holiday', 'X-Mas', true)\n         ])\n      )->isGreaterThan(0);\n\n      $this->checkXmas($calendar);\n   }\n\n   private function checkXmas(\\Calendar $calendar) {\n      $this->boolean(\n         $calendar->isHoliday('2018-01-01')\n      )->isFalse();\n\n      $this->boolean(\n         $calendar->isHoliday('2019-01-01')\n      )->isTrue();\n   }\n\n   public function testIsHoliday() {\n      $calendar = new \\Calendar();\n      // get Default calendar\n      $this->boolean($calendar->getFromDB(getItemByTypeName('Calendar', 'Default', true)))->isTrue();\n\n      $this->addXmas($calendar);\n\n      $dates= [\n         '2019-05-01'   => true,\n         '2019-05-02'   => false,\n         '2019-07-01'   => false,\n         '2019-07-12'   => true\n      ];\n\n      //no holiday by default\n      foreach (array_keys($dates) as $date) {\n         $this->boolean($calendar->isHoliday($date))->isFalse;\n      }\n\n      //Add holidays\n      $calendar_holiday = new \\Calendar_Holiday();\n      $holiday = new \\Holiday();\n      $hid = (int)$holiday->add([\n         'name'         => '1st of may',\n         'entities_id'  => 0,\n         'is_recursive' => 1,\n         'begin_date'   => '2019-05-01',\n         'end_date'     => '2019-05-01',\n         'is_perpetual' => 1\n      ]);\n      $this->integer($hid)->isGreaterThan(0);\n      $this->integer(\n         (int)$calendar_holiday->add([\n            'holidays_id'  => $hid,\n            'calendars_id' => $calendar->fields['id']\n         ])\n      )->isGreaterThan(0);\n\n      $hid = (int)$holiday->add([\n         'name'   => 'Summer vacations',\n         'entities_id'  => 0,\n         'is_recursive' => 1,\n         'begin_date'   => '2019-07-08',\n         'end_date'     => '2019-09-01',\n         'is_perpetual' => 0\n      ]);\n      $this->integer($hid)->isGreaterThan(0);\n      $this->integer(\n         (int)$calendar_holiday->add([\n            'holidays_id'  => $hid,\n            'calendars_id' => $calendar->fields['id']\n         ])\n      )->isGreaterThan(0);\n\n      foreach ($dates as $date => $expected) {\n         $this->boolean($calendar->isHoliday($date))->isIdenticalTo($expected);\n      }\n   }\n\n   public function testClone() {\n      $calendar = new \\Calendar();\n      $default_id = getItemByTypeName('Calendar', 'Default', true);\n      // get Default calendar\n      $this->boolean($calendar->getFromDB($default_id))->isTrue();\n      $this->addXmas($calendar);\n\n      $id = $calendar->clone();\n      $this->integer($id)->isGreaterThan($default_id);\n      $this->boolean($calendar->getFromDB($id))->isTrue();\n      //should have been duplicated too.\n      $this->checkXmas($calendar);\n\n      //change name, and clone again\n      $this->boolean($calendar->update(['id' => $id, 'name' => \"Je s\\'apelle Groot\"]))->isTrue();\n\n      $calendar = new \\Calendar();\n      $this->boolean($calendar->getFromDB($id))->isTrue();\n\n      $this->boolean($calendar->duplicate())->isTrue();\n      $other_id = $calendar->fields['id'];\n      $this->integer($other_id)->isGreaterThan($id);\n      $this->boolean($calendar->getFromDB($other_id))->isTrue();\n      //should have been duplicated too.\n      $this->checkXmas($calendar);\n\n   }\n}\n", "<?php\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n*/\n\nnamespace tests\\units;\n\nuse DbTestCase;\n\n/* Test for inc/computer.class.php */\n\nclass Computer extends DbTestCase {\n\n   protected function getUniqueString() {\n      $string = parent::getUniqueString();\n      $string .= \"with a ' inside!\";\n      return $string;\n   }\n\n   private function getNewComputer() {\n      $computer = getItemByTypeName('Computer', '_test_pc01');\n      $fields   = $computer->fields;\n      unset($fields['id']);\n      unset($fields['date_creation']);\n      unset($fields['date_mod']);\n      $fields['name'] = $this->getUniqueString();\n      $this->integer((int)$computer->add(\\Toolbox::addslashes_deep($fields)))->isGreaterThan(0);\n      return $computer;\n   }\n\n   private function getNewPrinter() {\n      $printer  = getItemByTypeName('Printer', '_test_printer_all');\n      $pfields  = $printer->fields;\n      unset($pfields['id']);\n      unset($pfields['date_creation']);\n      unset($pfields['date_mod']);\n      $pfields['name'] = $this->getUniqueString();\n      $this->integer((int)$printer->add(\\Toolbox::addslashes_deep($pfields)))->isGreaterThan(0);\n      return $printer;\n   }\n\n   public function testUpdate() {\n      global $CFG_GLPI;\n      $saveconf = $CFG_GLPI;\n\n      $computer = $this->getNewComputer();\n      $printer  = $this->getNewPrinter();\n\n      // Create the link\n      $link = new \\Computer_Item();\n      $in = ['computers_id' => $computer->getField('id'),\n             'itemtype'     => $printer->getType(),\n             'items_id'     => $printer->getID(),\n      ];\n      $this->integer((int)$link->add($in))->isGreaterThan(0);\n\n      // Change the computer\n      $CFG_GLPI['is_contact_autoupdate']  = 1;\n      $CFG_GLPI['is_user_autoupdate']     = 1;\n      $CFG_GLPI['is_group_autoupdate']    = 1;\n      $CFG_GLPI['state_autoupdate_mode']  = -1;\n      $CFG_GLPI['is_location_autoupdate'] = 1;\n      $in = ['id'           => $computer->getField('id'),\n             'contact'      => $this->getUniqueString(),\n             'contact_num'  => $this->getUniqueString(),\n             'users_id'     => $this->getUniqueInteger(),\n             'groups_id'    => $this->getUniqueInteger(),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update(\\Toolbox::addslashes_deep($in)))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($printer->getFromDB($printer->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($printer->getField($k))->isEqualTo($v);\n      }\n\n      //reset values\n      $in = ['id'           => $computer->getField('id'),\n             'contact'      => '',\n             'contact_num'  => '',\n             'users_id'     => 0,\n             'groups_id'    => 0,\n             'states_id'    => 0,\n             'locations_id' => 0,\n      ];\n      $this->boolean($computer->update($in))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($printer->getFromDB($printer->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($printer->getField($k))->isEqualTo($v);\n      }\n\n      // Change the computer again\n      $CFG_GLPI['is_contact_autoupdate']  = 0;\n      $CFG_GLPI['is_user_autoupdate']     = 0;\n      $CFG_GLPI['is_group_autoupdate']    = 0;\n      $CFG_GLPI['state_autoupdate_mode']  = 0;\n      $CFG_GLPI['is_location_autoupdate'] = 0;\n      $in2 = ['id'          => $computer->getField('id'),\n             'contact'      => $this->getUniqueString(),\n             'contact_num'  => $this->getUniqueString(),\n             'users_id'     => $this->getUniqueInteger(),\n             'groups_id'    => $this->getUniqueInteger(),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update(\\Toolbox::addslashes_deep($in2)))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($printer->getFromDB($printer->getID()))->isTrue();\n      unset($in2['id']);\n      foreach ($in2 as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation DOES NOT occurs\n         $this->variable($printer->getField($k))->isEqualTo($in[$k]);\n      }\n\n      // Restore configuration\n      $computer = $this->getNewComputer();\n      $CFG_GLPI = $saveconf;\n\n      //update devices\n      $cpu = new \\DeviceProcessor();\n      $cpuid = $cpu->add(\n         [\n            'designation'  => 'Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz',\n            'frequence'    => '1700'\n         ]\n      );\n\n      $this->integer((int)$cpuid)->isGreaterThan(0);\n\n      $link = new \\Item_DeviceProcessor();\n      $linkid = $link->add(\n         [\n            'items_id'              => $computer->getID(),\n            'itemtype'              => \\Computer::getType(),\n            'deviceprocessors_id'   => $cpuid,\n            'locations_id'          => $computer->getField('locations_id'),\n            'states_id'             => $computer->getField('status_id'),\n         ]\n      );\n\n      $this->integer((int)$linkid)->isGreaterThan(0);\n\n      // Change the computer\n      $CFG_GLPI['state_autoupdate_mode']  = -1;\n      $CFG_GLPI['is_location_autoupdate'] = 1;\n      $in = ['id'           => $computer->getField('id'),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update($in))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($link->getFromDB($link->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($link->getField($k))->isEqualTo($v);\n      }\n\n      //reset\n      $in = ['id'           => $computer->getField('id'),\n             'states_id'    => 0,\n             'locations_id' => 0,\n      ];\n      $this->boolean($computer->update($in))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($link->getFromDB($link->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($link->getField($k))->isEqualTo($v);\n      }\n\n      // Change the computer again\n      $CFG_GLPI['state_autoupdate_mode']  = 0;\n      $CFG_GLPI['is_location_autoupdate'] = 0;\n      $in2 = ['id'          => $computer->getField('id'),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update($in2))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n      $this->boolean($link->getFromDB($link->getID()))->isTrue();\n      unset($in2['id']);\n      foreach ($in2 as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation DOES NOT occurs\n         $this->variable($link->getField($k))->isEqualTo($in[$k]);\n      }\n\n      // Restore configuration\n      $CFG_GLPI = $saveconf;\n   }\n\n   /**\n    * Checks that newly created links inherits locations, status, and so on\n    *\n    * @return void\n    */\n   public function testCreateLinks() {\n      global $CFG_GLPI;\n\n      $computer = $this->getNewComputer();\n      $saveconf = $CFG_GLPI;\n\n      $CFG_GLPI['is_contact_autoupdate']  = 1;\n      $CFG_GLPI['is_user_autoupdate']     = 1;\n      $CFG_GLPI['is_group_autoupdate']    = 1;\n      $CFG_GLPI['state_autoupdate_mode']  = -1;\n      $CFG_GLPI['is_location_autoupdate'] = 1;\n\n      // Change the computer\n      $in = ['id'           => $computer->getField('id'),\n             'contact'      => $this->getUniqueString(),\n             'contact_num'  => $this->getUniqueString(),\n             'users_id'     => $this->getUniqueInteger(),\n             'groups_id'    => $this->getUniqueInteger(),\n             'states_id'    => $this->getUniqueInteger(),\n             'locations_id' => $this->getUniqueInteger(),\n      ];\n      $this->boolean($computer->update(\\Toolbox::addslashes_deep($in)))->isTrue();\n      $this->boolean($computer->getFromDB($computer->getID()))->isTrue();\n\n      $printer = new \\Printer();\n      $pid = $printer->add(\n         [\n            'name'         => 'A test printer',\n            'entities_id'  => $computer->getField('entities_id')\n         ]\n      );\n\n      $this->integer((int)$pid)->isGreaterThan(0);\n\n      // Create the link\n      $link = new \\Computer_Item();\n      $in2 = ['computers_id' => $computer->getField('id'),\n             'itemtype'     => $printer->getType(),\n             'items_id'     => $printer->getID(),\n      ];\n      $this->integer((int)$link->add($in2))->isGreaterThan(0);\n\n      $this->boolean($printer->getFromDB($printer->getID()))->isTrue();\n      unset($in['id']);\n      foreach ($in as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($printer->getField($k))->isEqualTo($v);\n      }\n\n      //create devices\n      $cpu = new \\DeviceProcessor();\n      $cpuid = $cpu->add(\n         [\n            'designation'  => 'Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz',\n            'frequence'    => '1700'\n         ]\n      );\n\n      $this->integer((int)$cpuid)->isGreaterThan(0);\n\n      $link = new \\Item_DeviceProcessor();\n      $linkid = $link->add(\n         [\n            'items_id'              => $computer->getID(),\n            'itemtype'              => \\Computer::getType(),\n            'deviceprocessors_id'   => $cpuid\n         ]\n      );\n\n      $this->integer((int)$linkid)->isGreaterThan(0);\n\n      $in3 = ['states_id'    => $in['states_id'],\n              'locations_id' => $in['locations_id'],\n      ];\n\n      $this->boolean($link->getFromDB($link->getID()))->isTrue();\n      foreach ($in3 as $k => $v) {\n         // Check the computer new values\n         $this->variable($computer->getField($k))->isEqualTo($v);\n         // Check the printer and test propagation occurs\n         $this->variable($link->getField($k))->isEqualTo($v);\n      }\n\n      // Restore configuration\n      $CFG_GLPI = $saveconf;\n   }\n\n   public function testGetFromIter() {\n      global $DB;\n\n      $iter = $DB->request(['SELECT' => 'id',\n                            'FROM'   => 'glpi_computers']);\n      $prev = false;\n      foreach (\\Computer::getFromIter($iter) as $comp) {\n         $this->object($comp)->isInstanceOf('Computer');\n         $this->array($comp->fields)\n            ->hasKey('name')\n            ->string['name']->isNotEqualTo($prev);\n         $prev = $comp->fields['name'];\n      }\n      $this->boolean((bool)$prev)->isTrue(); // we are retrieve something\n   }\n\n   public function testGetFromDbByCrit() {\n      $comp = new \\Computer();\n      $this->boolean($comp->getFromDBByCrit(['name' => '_test_pc01']))->isTrue();\n      $this->string($comp->getField('name'))->isIdenticalTo('_test_pc01');\n\n      $this->exception(\n         function () use ($comp) {\n            $this->boolean($comp->getFromDBByCrit(['name' => ['LIKE', '_test%']]))->isFalse();\n         }\n      )->message->contains('getFromDBByCrit expects to get one result, 8 found!');\n   }\n\n   public function testClone() {\n      $this->login();\n      $this->setEntity('_test_root_entity', true);\n\n      $date = date('Y-m-d H:i:s');\n      $_SESSION['glpi_currenttime'] = $date;\n\n      // Test item cloning\n      $computer = $this->getNewComputer();\n      $id = $computer->fields['id'];\n\n      //add note\n      $note = new \\Notepad();\n      $this->integer(\n         $note->add([\n            'itemtype'  => 'Computer',\n            'items_id'  => $id\n         ])\n      )->isGreaterThan(0);\n\n      //add os\n      $os = new \\OperatingSystem();\n      $osid = $os->add([\n         'name'   => 'My own OS'\n      ]);\n      $this->integer($osid)->isGreaterThan(0);\n\n      $ios = new \\Item_OperatingSystem();\n      $this->integer(\n         $ios->add([\n            'itemtype'  => 'Computer',\n            'items_id'  => $id\n         ])\n      )->isGreaterThan(0);\n\n      //add infocom\n      $infocom = new \\Infocom();\n      $this->integer(\n         $infocom->add([\n            'itemtype'  => 'Computer',\n            'items_id'  => $id\n         ])\n      )->isGreaterThan(0);\n\n      //add device\n      $cpu = new \\DeviceProcessor();\n      $cpuid = $cpu->add(\n         [\n            'designation'  => 'Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz',\n            'frequence'    => '1700'\n         ]\n      );\n\n      $this->integer((int)$cpuid)->isGreaterThan(0);\n\n      $link = new \\Item_DeviceProcessor();\n      $linkid = $link->add(\n         [\n            'items_id'              => $id,\n            'itemtype'              => 'Computer',\n            'deviceprocessors_id'   => $cpuid\n         ]\n      );\n      $this->integer((int)$linkid)->isGreaterThan(0);\n\n      //add document\n      $document = new \\Document();\n      $docid = (int)$document->add(['name' => 'Test link document']);\n      $this->integer($docid)->isGreaterThan(0);\n\n      $docitem = new \\Document_Item();\n      $this->integer(\n         $docitem->add([\n            'documents_id' => $docid,\n            'itemtype'     => 'Computer',\n            'items_id'     => $id\n         ])\n      )->isGreaterThan(0);\n\n      //clone!\n      $computer = new \\Computer(); //$computer->fields contents is already escaped!\n      $this->boolean($computer->getFromDB($id))->isTrue();\n      $added = $computer->clone();\n      $this->integer((int)$added)->isGreaterThan(0);\n      $this->integer($added)->isNotEqualTo($computer->fields['id']);\n\n      $clonedComputer = new \\Computer();\n      $this->boolean($clonedComputer->getFromDB($added))->isTrue();\n\n      $fields = $computer->fields;\n\n      // Check the computers values. Id and dates must be different, everything else must be equal\n      foreach ($fields as $k => $v) {\n         switch ($k) {\n            case 'id':\n               $this->variable($clonedComputer->getField($k))->isNotEqualTo($computer->getField($k));\n               break;\n            case 'date_mod':\n            case 'date_creation':\n               $dateClone = new \\DateTime($clonedComputer->getField($k));\n               $expectedDate = new \\DateTime($date);\n               $this->dateTime($dateClone)->isEqualTo($expectedDate);\n               break;\n            default:\n               $this->variable($clonedComputer->getField($k))->isEqualTo($computer->getField($k));\n         }\n      }\n\n      //TODO: would be better to check each Computer::getCloneRelations() ones.\n      $relations = [\n         \\Infocom::class => 1,\n         \\Notepad::class  => 1,\n         \\Item_OperatingSystem::class => 1\n      ];\n\n      foreach ($relations as $relation => $expected) {\n         $this->integer(\n            countElementsInTable(\n               $relation::getTable(),\n               ['items_id' => $clonedComputer->fields['id']]\n            )\n         )->isIdenticalTo($expected);\n      }\n\n      //check processor has been cloned\n      $this->boolean($link->getFromDBByCrit(['itemtype' => 'Computer', 'items_id' => $added]))->isTrue();\n      $this->boolean($docitem->getFromDBByCrit(['itemtype' => 'Computer', 'items_id' => $added]))->isTrue();\n   }\n}\n"], "filenames": ["inc/calendar.class.php", "inc/commondbtm.class.php", "tests/functionnal/Calendar.php", "tests/functionnal/Computer.php"], "buggy_code_start_loc": [204, 1209, 256, 39], "buggy_code_end_loc": [205, 1210, 256, 433], "fixing_code_start_loc": [204, 1209, 257, 40], "fixing_code_end_loc": [205, 1210, 271, 442], "type": "CWE-89", "message": "In glpi before 9.5.1, there is a SQL injection for all usages of \"Clone\" feature. This has been fixed in 9.5.1.", "other": {"cve": {"id": "CVE-2020-15108", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-17T21:15:12.780", "lastModified": "2020-07-22T15:38:33.420", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In glpi before 9.5.1, there is a SQL injection for all usages of \"Clone\" feature. This has been fixed in 9.5.1."}, {"lang": "es", "value": "En glpi versiones anteriores a 9.5.1, se presenta una inyecci\u00f3n SQL para todos los usos de la funcionalidad \"Clone\". Esto ha sido corregido en 9.5.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:glpi-project:glpi:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.5.1", "matchCriteriaId": "6AC6E700-75F2-4062-A8AD-AE72EAE047E0"}]}]}], "references": [{"url": "https://github.com/glpi-project/glpi/commit/a4baa64114eb92fd2adf6056a36e0582324414ba", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/glpi-project/glpi/pull/6684", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/glpi-project/glpi/security/advisories/GHSA-qv6w-68gq-wx2v", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/glpi-project/glpi/commit/a4baa64114eb92fd2adf6056a36e0582324414ba"}}