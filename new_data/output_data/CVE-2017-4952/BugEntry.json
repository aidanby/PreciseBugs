{"buggy_code": ["/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport java.io.NotActiveException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.logging.Level;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UiContentService;\n\n\n/**\n * Utility service managing the various URI control REST APIs for each service instance. A single\n * utility service instance manages operations on multiple URI suffixes (/stats, /subscriptions,\n * etc) in order to reduce runtime overhead per service instance\n */\npublic class UtilityService implements Service {\n    private transient Service parent;\n    private ServiceStats stats;\n    private ServiceSubscriptionState subscriptions;\n    private UiContentService uiService;\n\n    public UtilityService() {\n    }\n\n    public UtilityService setParent(Service parent) {\n        this.parent = parent;\n        return this;\n    }\n\n    @Override\n    public void authorizeRequest(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op) {\n        String uriPrefix = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n\n        if (op.getUri().getPath().startsWith(uriPrefix)) {\n            // startsWith catches all /factory/instance/ui/some-script.js\n            handleUiRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_STATS)) {\n            handleStatsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS)) {\n            handleSubscriptionsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_TEMPLATE)) {\n            handleDocumentTemplateRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_CONFIG)) {\n            this.parent.handleConfigurationRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_AVAILABLE)) {\n            handleAvailableRequest(op);\n        } else {\n            op.fail(new UnknownHostException());\n        }\n    }\n\n    @Override\n    public void handleCreate(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void handleStart(Operation startPost) {\n        startPost.complete();\n    }\n\n    @Override\n    public void handleStop(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op, OperationProcessingStage opProcessingStage) {\n        handleRequest(op);\n    }\n\n    private void handleAvailableRequest(Operation op) {\n        if (op.getAction() == Action.GET) {\n            if (this.parent.getProcessingStage() != ProcessingStage.PAUSED\n                    && this.parent.getProcessingStage() != ProcessingStage.AVAILABLE) {\n                // processing stage takes precedence over isAvailable statistic\n                op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n                return;\n            }\n            if (this.stats == null) {\n                op.complete();\n                return;\n            }\n            ServiceStat st = this.getStat(STAT_NAME_AVAILABLE, false);\n            if (st == null || st.latestValue == 1.0) {\n                op.complete();\n                return;\n            }\n            op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n        } else if (op.getAction() == Action.PATCH || op.getAction() == Action.PUT) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalArgumentException(\"body is required\"));\n                return;\n            }\n            ServiceStat st = op.getBody(ServiceStat.class);\n            if (!STAT_NAME_AVAILABLE.equals(st.name)) {\n                op.fail(new IllegalArgumentException(\n                        \"body must be of type ServiceStat and name must be \"\n                                + STAT_NAME_AVAILABLE));\n                return;\n            }\n            handleStatsRequest(op);\n        } else {\n            getHost().failRequestActionNotSupported(op);\n        }\n    }\n\n    private void handleSubscriptionsRequest(Operation op) {\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                this.subscriptions = new ServiceSubscriptionState();\n                this.subscriptions.subscribers = new ConcurrentSkipListMap<>();\n            }\n        }\n\n        ServiceSubscriber body = null;\n        if (op.hasBody()) {\n            body = op.getBody(ServiceSubscriber.class);\n            if (body.reference == null) {\n                op.fail(new IllegalArgumentException(\"reference is required\"));\n                return;\n            }\n        }\n\n        switch (op.getAction()) {\n        case POST:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.put(body.reference, body);\n            }\n            if (!body.replayState) {\n                break;\n            }\n            // if replayState is set, replay the current state to the subscriber\n            URI notificationURI = body.reference;\n            this.parent.sendRequest(Operation.createGet(this, this.parent.getSelfLink())\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    op.fail(new IllegalStateException(\n                                            \"Unable to get current state\"));\n                                    return;\n                                }\n                                Operation putOp = Operation\n                                        .createPut(notificationURI)\n                                        .setBodyNoCloning(o.getBody(this.parent.getStateType()))\n                                        .addPragmaDirective(\n                                                Operation.PRAGMA_DIRECTIVE_NOTIFICATION)\n                                        .setReferer(getUri());\n                                this.parent.sendRequest(putOp);\n                            }));\n\n            break;\n        case DELETE:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.remove(body.reference);\n            }\n            break;\n        case GET:\n            ServiceDocument rsp;\n            synchronized (this.subscriptions) {\n                rsp = Utils.clone(this.subscriptions);\n            }\n            op.setBody(rsp);\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n\n        op.complete();\n    }\n\n    public boolean hasSubscribers() {\n        ServiceSubscriptionState subscriptions = this.subscriptions;\n        return subscriptions != null\n                && subscriptions.subscribers != null\n                && !subscriptions.subscribers.isEmpty();\n    }\n\n    public boolean hasStats() {\n        ServiceStats stats = this.stats;\n        return stats != null && stats.entries != null && !stats.entries.isEmpty();\n    }\n\n    public void notifySubscribers(Operation op) {\n        try {\n            if (op.getAction() == Action.GET) {\n                return;\n            }\n\n            if (!this.hasSubscribers()) {\n                return;\n            }\n\n            long now = Utils.getNowMicrosUtc();\n\n            Operation clone = op.clone();\n            clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NOTIFICATION);\n            for (Entry<URI, ServiceSubscriber> e : this.subscriptions.subscribers.entrySet()) {\n                ServiceSubscriber s = e.getValue();\n                notifySubscriber(now, clone, s);\n            }\n\n            if (!performSubscriptionsMaintenance(now)) {\n                return;\n            }\n        } catch (Throwable e) {\n            this.parent.getHost().log(Level.WARNING,\n                    \"Uncaught exception notifying subscribers for %s: %s\",\n                    this.parent.getSelfLink(), Utils.toString(e));\n        }\n    }\n\n    private void notifySubscriber(long now, Operation clone, ServiceSubscriber s) {\n        synchronized (s) {\n            if (s.failedNotificationCount != null) {\n                // indicate to the subscriber that they missed notifications and should retrieve latest state\n                clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS);\n            }\n        }\n\n        CompletionHandler c = (o, ex) -> {\n            s.documentUpdateTimeMicros = Utils.getNowMicrosUtc();\n            synchronized (s) {\n                if (ex != null) {\n                    if (s.failedNotificationCount == null) {\n                        s.failedNotificationCount = 0L;\n                        s.initialFailedNotificationTimeMicros = now;\n                    }\n                    s.failedNotificationCount++;\n                    return;\n                }\n\n                if (s.failedNotificationCount != null) {\n                    // the subscriber is available again.\n                    s.failedNotificationCount = null;\n                    s.initialFailedNotificationTimeMicros = null;\n                }\n            }\n        };\n\n        this.parent.sendRequest(clone.setUri(s.reference).setCompletion(c));\n    }\n\n    private boolean performSubscriptionsMaintenance(long now) {\n        List<URI> subscribersToDelete = null;\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                return false;\n            }\n\n            Iterator<Entry<URI, ServiceSubscriber>> it = this.subscriptions.subscribers.entrySet()\n                    .iterator();\n            while (it.hasNext()) {\n                Entry<URI, ServiceSubscriber> e = it.next();\n                ServiceSubscriber s = e.getValue();\n                boolean remove = false;\n                synchronized (s) {\n                    if (s.documentExpirationTimeMicros != 0 && s.documentExpirationTimeMicros < now) {\n                        remove = true;\n                    } else if (s.notificationLimit != null) {\n                        if (s.notificationCount == null) {\n                            s.notificationCount = 0L;\n                        }\n                        if (++s.notificationCount >= s.notificationLimit) {\n                            remove = true;\n                        }\n                    } else if (s.failedNotificationCount != null\n                            && s.failedNotificationCount > ServiceSubscriber.NOTIFICATION_FAILURE_LIMIT) {\n                        if (now - s.initialFailedNotificationTimeMicros > getHost()\n                                .getMaintenanceIntervalMicros()) {\n                            remove = true;\n                        }\n                    }\n                }\n\n                if (!remove) {\n                    continue;\n                }\n\n                it.remove();\n                if (subscribersToDelete == null) {\n                    subscribersToDelete = new ArrayList<>();\n                }\n                subscribersToDelete.add(s.reference);\n                continue;\n            }\n        }\n\n        if (subscribersToDelete != null) {\n            for (URI subscriber : subscribersToDelete) {\n                this.parent.sendRequest(Operation.createDelete(subscriber));\n            }\n        }\n\n        return true;\n    }\n\n    private void handleUiRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new IllegalArgumentException(\"Action not supported\"));\n            return;\n        }\n\n        if (!this.parent.hasOption(ServiceOption.HTML_USER_INTERFACE)) {\n            String servicePath = UriUtils.buildUriPath(ServiceUriPaths.UI_SERVICE_BASE_URL, op\n                    .getUri().getPath());\n            String defaultHtmlPath = UriUtils.buildUriPath(servicePath.substring(0,\n                    servicePath.length() - ServiceUriPaths.UI_PATH_SUFFIX.length()),\n                    ServiceUriPaths.UI_SERVICE_HOME);\n\n            redirectGetToHtmlUiResource(op, defaultHtmlPath);\n            return;\n        }\n\n        if (this.uiService == null) {\n            this.uiService = new UiContentService() {\n            };\n            this.uiService.setHost(this.parent.getHost());\n        }\n\n        // simulate a full service deployed at the utility endpoint /service/ui\n        String selfLink = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n        this.uiService.handleUiGet(selfLink, this.parent, op);\n    }\n\n    public void redirectGetToHtmlUiResource(Operation op, String htmlResourcePath) {\n        // redirect using relative url without host:port\n        // not so much optimization as handling the case of port forwarding/containers\n        try {\n            op.addResponseHeader(Operation.LOCATION_HEADER,\n                    URLDecoder.decode(htmlResourcePath, Utils.CHARSET));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e);\n        }\n\n        op.setStatusCode(Operation.STATUS_CODE_MOVED_TEMP);\n        op.complete();\n    }\n\n    private void handleStatsRequest(Operation op) {\n        switch (op.getAction()) {\n        case PUT:\n            ServiceStats.ServiceStat stat = op\n                    .getBody(ServiceStats.ServiceStat.class);\n            if (stat.kind == null) {\n                op.fail(new IllegalArgumentException(\"kind is required\"));\n                return;\n            }\n            if (stat.kind.equals(ServiceStats.ServiceStat.KIND)) {\n                if (stat.name == null) {\n                    op.fail(new IllegalArgumentException(\"stat name is required\"));\n                    return;\n                }\n                replaceSingleStat(stat);\n            } else if (stat.kind.equals(ServiceStats.KIND)) {\n                ServiceStats stats = op.getBody(ServiceStats.class);\n                if (stats.entries == null || stats.entries.isEmpty()) {\n                    op.fail(new IllegalArgumentException(\"stats entries need to be defined\"));\n                    return;\n                }\n                replaceAllStats(stats);\n            } else {\n                op.fail(new IllegalArgumentException(\"operation not supported for kind\"));\n                return;\n            }\n            op.complete();\n            break;\n        case POST:\n            ServiceStats.ServiceStat newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // create a stat object if one does not exist\n            ServiceStats.ServiceStat existingStat = this.getStat(newStat.name);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat does not exist\"));\n                return;\n            }\n            initializeOrSetStat(existingStat, newStat);\n            op.complete();\n            break;\n        case DELETE:\n            // TODO support removing stats externally - do we need this?\n            op.fail(new NotActiveException());\n            break;\n        case PATCH:\n            newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // if an existing stat by this name exists, adjust the stat value, else this is a no-op\n            existingStat = this.getStat(newStat.name, false);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat to patch does not exist\"));\n                return;\n            }\n            adjustStat(existingStat, newStat.latestValue);\n            op.complete();\n            break;\n        case GET:\n            if (this.stats == null) {\n                ServiceStats s = new ServiceStats();\n                populateDocumentProperties(s);\n                op.setBody(s).complete();\n            } else {\n                ServiceDocument rsp;\n                synchronized (this.stats) {\n                    rsp = populateDocumentProperties(this.stats);\n                    rsp = Utils.clone(rsp);\n                }\n                op.setBodyNoCloning(rsp);\n                op.complete();\n            }\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n    }\n\n    private ServiceStats populateDocumentProperties(ServiceStats stats) {\n        ServiceStats clone = new ServiceStats();\n        clone.entries = stats.entries;\n        clone.documentUpdateTimeMicros = stats.documentUpdateTimeMicros;\n        clone.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(),\n                ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        clone.documentOwner = getHost().getId();\n        clone.documentKind = Utils.buildKind(ServiceStats.class);\n        return clone;\n    }\n\n    private void handleDocumentTemplateRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new NotActiveException());\n            return;\n        }\n        ServiceDocument template = this.parent.getDocumentTemplate();\n        String serializedTemplate = Utils.toJsonHtml(template);\n        op.setBody(serializedTemplate).complete();\n    }\n\n    @Override\n    public void handleConfigurationRequest(Operation op) {\n        this.parent.handleConfigurationRequest(op);\n    }\n\n    public void handlePatchConfiguration(Operation op, ServiceConfigUpdateRequest updateBody) {\n        if (updateBody == null) {\n            updateBody = op.getBody(ServiceConfigUpdateRequest.class);\n        }\n\n        if (!ServiceConfigUpdateRequest.KIND.equals(updateBody.kind)) {\n            op.fail(new IllegalArgumentException(\"Unrecognized kind: \" + updateBody.kind));\n            return;\n        }\n\n        if (updateBody.maintenanceIntervalMicros == null\n                && updateBody.operationQueueLimit == null\n                && updateBody.epoch == null\n                && (updateBody.addOptions == null || updateBody.addOptions.isEmpty())\n                && (updateBody.removeOptions == null || updateBody.removeOptions\n                        .isEmpty())) {\n            op.fail(new IllegalArgumentException(\n                    \"At least one configuraton field must be specified\"));\n            return;\n        }\n\n        // service might fail a capability toggle if the capability can not be changed after start\n        if (updateBody.addOptions != null) {\n            for (ServiceOption c : updateBody.addOptions) {\n                this.parent.toggleOption(c, true);\n            }\n        }\n\n        if (updateBody.removeOptions != null) {\n            for (ServiceOption c : updateBody.removeOptions) {\n                this.parent.toggleOption(c, false);\n            }\n        }\n\n        if (updateBody.maintenanceIntervalMicros != null) {\n            this.parent.setMaintenanceIntervalMicros(updateBody.maintenanceIntervalMicros);\n        }\n\n        op.complete();\n    }\n\n    private void initializeOrSetStat(ServiceStat stat, ServiceStat newValue) {\n        synchronized (stat) {\n            if (stat.timeSeriesStats == null && newValue.timeSeriesStats != null) {\n                stat.timeSeriesStats = new TimeSeriesStats(newValue.timeSeriesStats.numBins,\n                        newValue.timeSeriesStats.binDurationMillis, newValue.timeSeriesStats.aggregationType);\n            }\n            stat.unit = newValue.unit;\n            stat.sourceTimeMicrosUtc = newValue.sourceTimeMicrosUtc;\n            setStat(stat, newValue.latestValue);\n        }\n    }\n\n    @Override\n    public void setStat(ServiceStat stat, double newValue) {\n        allocateStats();\n        findStat(stat.name, true, stat);\n\n        synchronized (stat) {\n            stat.version++;\n            stat.accumulatedValue += newValue;\n            stat.latestValue = newValue;\n            if (stat.logHistogram != null) {\n                int binIndex = 0;\n                if (newValue > 0.0) {\n                    binIndex = (int) Math.log10(newValue);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, newValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, newValue);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void adjustStat(ServiceStat stat, double delta) {\n        allocateStats();\n        synchronized (stat) {\n            stat.latestValue += delta;\n            stat.version++;\n            if (stat.logHistogram != null) {\n\n                int binIndex = 0;\n                if (delta > 0.0) {\n                    binIndex = (int) Math.log10(delta);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, stat.latestValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, stat.latestValue);\n                }\n            }\n        }\n    }\n\n    @Override\n    public ServiceStat getStat(String name) {\n        return getStat(name, true);\n    }\n\n    private ServiceStat getStat(String name, boolean create) {\n        if (!allocateStats(true)) {\n            return null;\n        }\n        return findStat(name, create, null);\n    }\n\n    private void replaceSingleStat(ServiceStat stat) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // create a new stat with the default values\n            ServiceStat newStat = new ServiceStat();\n            newStat.name = stat.name;\n            initializeOrSetStat(newStat, stat);\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            // add it to the list of stats for this service\n            this.stats.entries.put(stat.name, newStat);\n        }\n    }\n\n    private void replaceAllStats(ServiceStats newStats) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // reset the current set of stats\n            this.stats.entries.clear();\n            for (ServiceStats.ServiceStat currentStat : newStats.entries.values()) {\n                replaceSingleStat(currentStat);\n            }\n\n        }\n    }\n\n    private ServiceStat findStat(String name, boolean create, ServiceStat initialStat) {\n        synchronized (this.stats) {\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            ServiceStat st = this.stats.entries.get(name);\n            if (st == null && create) {\n                st = initialStat != null ? initialStat : new ServiceStat();\n                st.name = name;\n                this.stats.entries.put(name, st);\n            }\n            return st;\n        }\n    }\n\n    private void allocateStats() {\n        allocateStats(true);\n    }\n\n    private synchronized boolean allocateStats(boolean mustAllocate) {\n        if (!mustAllocate && this.stats == null) {\n            return false;\n        }\n        if (this.stats != null) {\n            return true;\n        }\n        this.stats = new ServiceStats();\n        return true;\n    }\n\n    @Override\n    public ServiceHost getHost() {\n        return this.parent.getHost();\n    }\n\n    @Override\n    public String getSelfLink() {\n        return null;\n    }\n\n    @Override\n    public URI getUri() {\n        return null;\n    }\n\n    @Override\n    public OperationProcessingChain getOperationProcessingChain() {\n        return null;\n    }\n\n    @Override\n    public ProcessingStage getProcessingStage() {\n        return ProcessingStage.AVAILABLE;\n    }\n\n    @Override\n    public EnumSet<ServiceOption> getOptions() {\n        return EnumSet.of(ServiceOption.UTILITY);\n    }\n\n    @Override\n    public boolean hasOption(ServiceOption cap) {\n        return false;\n    }\n\n    @Override\n    public void toggleOption(ServiceOption cap, boolean enable) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public void adjustStat(String name, double delta) {\n        return;\n    }\n\n    @Override\n    public void setStat(String name, double newValue) {\n        return;\n    }\n\n    @Override\n    public void handleMaintenance(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void setHost(ServiceHost serviceHost) {\n\n    }\n\n    @Override\n    public void setSelfLink(String path) {\n\n    }\n\n    @Override\n    public void setOperationProcessingChain(OperationProcessingChain opProcessingChain) {\n\n    }\n\n    @Override\n    public ServiceRuntimeContext setProcessingStage(ProcessingStage initialized) {\n        return null;\n    }\n\n    @Override\n    public ServiceDocument setInitialState(Object state, Long initialVersion) {\n        return null;\n    }\n\n    @Override\n    public Service getUtilityService(String uriPath) {\n        return null;\n    }\n\n    @Override\n    public boolean queueRequest(Operation op) {\n        return false;\n    }\n\n    @Override\n    public void sendRequest(Operation op) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public ServiceDocument getDocumentTemplate() {\n        return null;\n    }\n\n    @Override\n    public void setPeerNodeSelectorPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getPeerNodeSelectorPath() {\n        return null;\n    }\n\n    @Override\n    public void setState(Operation op, ServiceDocument newState) {\n        op.linkState(newState);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends ServiceDocument> T getState(Operation op) {\n        return (T) op.getLinkedState();\n    }\n\n    @Override\n    public void setMaintenanceIntervalMicros(long micros) {\n        throw new RuntimeException(\"not implemented\");\n    }\n\n    @Override\n    public long getMaintenanceIntervalMicros() {\n        return 0;\n    }\n\n    @Override\n    public Operation dequeueRequest() {\n        return null;\n    }\n\n    @Override\n    public Class<? extends ServiceDocument> getStateType() {\n        return null;\n    }\n\n    @Override\n    public final void setAuthorizationContext(Operation op, AuthorizationContext ctx) {\n        throw new RuntimeException(\"Service not allowed to set authorization context\");\n    }\n\n    @Override\n    public final AuthorizationContext getSystemAuthorizationContext() {\n        throw new RuntimeException(\"Service not allowed to get system authorization context\");\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.security.GeneralSecurityException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.test.AuthorizationHelper;\nimport com.vmware.xenon.common.test.QueryTestUtils;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationCacheUtils;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.GuestUserService;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.SystemUserService;\nimport com.vmware.xenon.services.common.UserGroupService;\nimport com.vmware.xenon.services.common.UserGroupService.UserGroupState;\nimport com.vmware.xenon.services.common.UserService.UserState;\n\npublic class TestAuthorization extends BasicTestCase {\n\n    public static class AuthzStatelessService extends StatelessService {\n        public void handleRequest(Operation op) {\n            if (op.getAction() == Action.PATCH) {\n                op.complete();\n                return;\n            }\n            super.handleRequest(op);\n        }\n    }\n\n    public int serviceCount = 10;\n\n    private String userServicePath;\n    private AuthorizationHelper authHelper;\n\n    @Override\n    public void beforeHostStart(VerificationHost host) {\n        // Enable authorization service; this is an end to end test\n        host.setAuthorizationService(new AuthorizationContextService());\n        host.setAuthorizationEnabled(true);\n        CommandLineArgumentParser.parseFromProperties(this);\n    }\n\n    @Before\n    public void enableTracing() throws Throwable {\n        // Enable operation tracing to verify tracing does not error out with auth enabled.\n        this.host.toggleOperationTracing(this.host.getUri(), true);\n    }\n\n    @After\n    public void disableTracing() throws Throwable {\n        this.host.toggleOperationTracing(this.host.getUri(), false);\n    }\n\n    @Before\n    public void setupRoles() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        this.authHelper = new AuthorizationHelper(this.host);\n        this.userServicePath = this.authHelper.createUserService(this.host, \"jane@doe.com\");\n        this.authHelper.createRoles(this.host, \"jane@doe.com\");\n        this.host.resetAuthorizationContext();\n    }\n\n    @Test\n    public void statelessServiceAuthorization() throws Throwable {\n        // assume system identity so we can create roles\n        this.host.setSystemAuthorizationContext();\n\n        String serviceLink = UUID.randomUUID().toString();\n\n        // create a specific role for a stateless service\n        String resourceGroupLink = this.authHelper.createResourceGroup(this.host,\n                \"stateless-service-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                UriUtils.URI_PATH_CHAR + serviceLink)\n                        .build());\n        this.authHelper.createRole(this.host, this.authHelper.getUserGroupLink(),\n                resourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE)));\n        this.host.resetAuthorizationContext();\n\n        CompletionHandler ch = (o, e) -> {\n            if (e == null || o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                this.host.failIteration(new IllegalStateException(\n                        \"Operation did not fail with proper status code\"));\n                return;\n            }\n            this.host.completeIteration();\n        };\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // Verify startService\n        Operation post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // stop service so we can attempt restart\n        this.host.testStart(1);\n        Operation delete = Operation.createDelete(post.getUri())\n                .setCompletion(this.host.getCompletion());\n        this.host.send(delete);\n        this.host.testWait();\n\n        // Verify DENY startService\n        this.host.resetAuthorizationContext();\n        this.host.testStart(1);\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        post.setCompletion(ch);\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // restart service\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // Verify PATCH\n        Operation patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(this.host.getCompletion());\n        this.host.send(patch);\n        this.host.testWait();\n\n        // Verify DENY PATCH\n        this.host.resetAuthorizationContext();\n        patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(ch);\n        this.host.send(patch);\n        this.host.testWait();\n    }\n\n    @Test\n    public void queryTasksDirectAndContinuous() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n        createExampleServices(\"jane\");\n\n        // do a direct, simple query first\n        this.host.createAndWaitSimpleDirectQuery(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                this.userServicePath, this.serviceCount, this.serviceCount);\n\n        // now do a paginated query to verify we can get to paged results with authz enabled\n        QueryTask qt = QueryTask.Builder.create().setResultLimit(this.serviceCount / 2)\n                .build();\n        qt.querySpec.query = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                        this.userServicePath)\n                .build();\n\n        URI taskUri = this.host.createQueryTaskService(qt);\n        this.host.waitFor(\"task not finished in time\", () -> {\n            QueryTask r = this.host.getServiceState(null, QueryTask.class, taskUri);\n            if (TaskState.isFailed(r.taskInfo)) {\n                throw new IllegalStateException(\"task failed\");\n            }\n            if (TaskState.isFinished(r.taskInfo)) {\n                qt.taskInfo = r.taskInfo;\n                qt.results = r.results;\n                return true;\n            }\n            return false;\n        });\n\n\n        TestContext ctx = this.host.testCreate(1);\n        Operation get = Operation.createGet(UriUtils.buildUri(this.host, qt.results.nextPageLink))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(get);\n        ctx.await();\n\n        TestContext kryoCtx = this.host.testCreate(1);\n        Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                .setBody(new ServiceDocument())\n                .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                .setCompletion((o, e) -> {\n                    if (e != null && o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED) {\n                        kryoCtx.completeIteration();\n                        return;\n                    }\n                    kryoCtx.failIteration(new IllegalStateException(\"expected a failure\"));\n                });\n        this.host.send(patchOp);\n        kryoCtx.await();\n\n        int requestCount = this.serviceCount;\n        TestContext notifyCtx = this.testCreate(requestCount);\n\n        Consumer<Operation> notify = (o) -> {\n            o.complete();\n            String subject = o.getAuthorizationContext().getClaims().getSubject();\n            if (!this.userServicePath.equals(subject)) {\n                notifyCtx.fail(new IllegalStateException(\n                        \"Invalid aith subject in notification: \" + subject));\n                return;\n            }\n            this.host.log(\"Received authorized notification for index patch: %s\", o.toString());\n            notifyCtx.complete();\n        };\n\n        Query q = Query.Builder.create()\n                .addKindFieldClause(ExampleServiceState.class)\n                .build();\n        QueryTask cqt = QueryTask.Builder.create().setQuery(q).build();\n\n        // do a continuous query, verify we receive some notifications\n        URI notifyURI = QueryTestUtils.startAndSubscribeToContinuousQuery(\n                this.host.getTestRequestSender(), this.host, cqt,\n                notify);\n\n        // issue updates, create some services\n        createExampleServices(\"jane\");\n        this.host.log(\"Waiting on continiuous query task notifications (%d)\", requestCount);\n        notifyCtx.await();\n\n        QueryTestUtils.stopContinuousQuerySubscription(\n                this.host.getTestRequestSender(), this.host, notifyURI,\n                cqt);\n\n    }\n\n    @Test\n    public void validateKryoOctetStreamRequests() throws Throwable {\n        Consumer<Boolean> validate = (expectUnauthorizedResponse) -> {\n            TestContext kryoCtx = this.host.testCreate(1);\n            Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                    .setBody(new ServiceDocument())\n                    .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                    .setCompletion((o, e) -> {\n                        boolean isUnauthorizedResponse = o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED;\n                        if (expectUnauthorizedResponse == isUnauthorizedResponse) {\n                            kryoCtx.completeIteration();\n                            return;\n                        }\n                        kryoCtx.failIteration(new IllegalStateException(\"Response did not match expectation\"));\n                    });\n            this.host.send(patchOp);\n            kryoCtx.await();\n        };\n\n        // Validate GUEST users are not authorized for sending kryo-octet-stream requests.\n        this.host.resetAuthorizationContext();\n        validate.accept(true);\n\n        // Validate non-Guest, non-System users are also not authorized.\n        this.host.assumeIdentity(this.userServicePath);\n        validate.accept(true);\n\n        // Validate System users are allowed.\n        this.host.assumeIdentity(SystemUserService.SELF_LINK);\n        validate.accept(false);\n    }\n\n    @Test\n    public void contextPropagationOnScheduleAndRunContext() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n\n        AuthorizationContext callerAuthContext = OperationContext.getAuthorizationContext();\n        Runnable task = () -> {\n            if (OperationContext.getAuthorizationContext().equals(callerAuthContext)) {\n                this.host.completeIteration();\n                return;\n            }\n            this.host.failIteration(new IllegalStateException(\"Incorrect auth context obtained\"));\n        };\n\n        this.host.testStart(1);\n        this.host.schedule(task, 1, TimeUnit.MILLISECONDS);\n        this.host.testWait();\n\n        this.host.testStart(1);\n        this.host.run(task);\n        this.host.testWait();\n    }\n\n    @Test\n    public void guestAuthorization() throws Throwable {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n\n        // Create user group for guest user\n        String userGroupLink =\n                this.authHelper.createUserGroup(this.host, \"guest-user-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                GuestUserService.SELF_LINK)\n                        .build());\n\n        // Create resource group for example service state\n        String exampleServiceResourceGroupLink =\n                this.authHelper.createResourceGroup(this.host, \"guest-resource-group\", Builder.create()\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_KIND,\n                                Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_NAME,\n                                \"guest\")\n                        .build());\n\n        // Create roles tying these together\n        this.authHelper.createRole(this.host, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH)));\n\n        // Create some example services; some accessible, some not\n        Map<URI, ExampleServiceState> exampleServices = new HashMap<>();\n        exampleServices.putAll(createExampleServices(\"jane\"));\n        exampleServices.putAll(createExampleServices(\"guest\"));\n\n        OperationContext.setAuthorizationContext(null);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n        Operation responseOp = sender.sendAndWait(Operation.createGet(this.host, ExampleService.FACTORY_LINK));\n\n        // Make sure only the authorized services were returned\n        ServiceDocumentQueryResult getResult = responseOp.getBody(ServiceDocumentQueryResult.class);\n        assertAuthorizedServicesInResult(\"guest\", exampleServices, getResult);\n        String guestLink = getResult.documentLinks.iterator().next();\n\n        // Make sure we are able to PATCH the example service.\n        ExampleServiceState state = new ExampleServiceState();\n        state.counter = 2L;\n        responseOp = sender.sendAndWait(Operation.createPatch(this.host, guestLink).setBody(state));\n        assertEquals(Operation.STATUS_CODE_OK, responseOp.getStatusCode());\n\n        // Let's try to do another PATCH using kryo-octet-stream\n        state.counter = 3L;\n        FailureResponse failureResponse = sender.sendAndWaitFailure(\n                Operation.createPatch(this.host, guestLink)\n                        .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                        .forceRemote()\n                        .setBody(state));\n        assertEquals(Operation.STATUS_CODE_UNAUTHORIZED, failureResponse.op.getStatusCode());\n\n    }\n\n    @Test\n    public void actionBasedAuthorization() throws Throwable {\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // add docs accessible by jane\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"jane\");\n\n        // Execute get on factory trying to get all example services\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    this.host.completeIteration();\n                });\n\n        this.host.testStart(1);\n        this.host.send(getFactory);\n        this.host.testWait();\n\n        // DELETE operation should be denied\n        Set<String> selfLinks = new HashSet<>(factoryGetResult[0].documentLinks);\n        for (String selfLink : selfLinks) {\n            Operation deleteOperation =\n                    Operation.createDelete(UriUtils.buildUri(this.host, selfLink))\n                            .setCompletion((o, e) -> {\n                                if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                    String message = String.format(\"Expected %d, got %s\",\n                                            Operation.STATUS_CODE_FORBIDDEN,\n                                            o.getStatusCode());\n                                    this.host.failIteration(new IllegalStateException(message));\n                                    return;\n                                }\n\n                                this.host.completeIteration();\n                            });\n            this.host.testStart(1);\n            this.host.send(deleteOperation);\n            this.host.testWait();\n        }\n\n        // PATCH operation should be allowed\n        for (String selfLink : selfLinks) {\n            Operation patchOperation =\n                    Operation.createPatch(UriUtils.buildUri(this.host, selfLink))\n                        .setBody(exampleServices.get(selfLink))\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_OK,\n                                        o.getStatusCode());\n                                this.host.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            this.host.completeIteration();\n                        });\n            this.host.testStart(1);\n            this.host.send(patchOperation);\n            this.host.testWait();\n        }\n    }\n\n    @Test\n    public void statefulServiceAuthorization() throws Throwable {\n        // Create example services not accessible by jane (as the system user)\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"john\");\n\n        // try to create services with no user context set; we should get a 403\n        OperationContext.setAuthorizationContext(null);\n        ExampleServiceState state = createExampleServiceState(\"jane\", new Long(\"100\"));\n        this.host.testStart(1);\n        this.host.send(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(state)\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_FORBIDDEN,\n                                        o.getStatusCode());\n                                this.host.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            this.host.completeIteration();\n                        }));\n        this.host.testWait();\n\n        // issue a GET on a factory with no auth context, no documents should be returned\n        this.host.testStart(1);\n        this.host.send(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(new IllegalStateException(e));\n                        return;\n                    }\n                    ServiceDocumentQueryResult res = o\n                            .getBody(ServiceDocumentQueryResult.class);\n                    if (!res.documentLinks.isEmpty()) {\n                        String message = String.format(\"Expected 0 results; Got %d\",\n                                res.documentLinks.size());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    this.host.completeIteration();\n                }));\n        this.host.testWait();\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n        // add docs accessible by jane\n        exampleServices.putAll(createExampleServices(\"jane\"));\n\n        verifyJaneAccess(exampleServices, null);\n\n        // Execute get on factory trying to get all example services\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    this.host.completeIteration();\n                });\n\n        this.host.testStart(1);\n        this.host.send(getFactory);\n        this.host.testWait();\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, factoryGetResult[0]);\n\n        // Execute query task trying to get all example services\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND)\n                .setTermMatchValue(Utils.buildKind(ExampleServiceState.class));\n        URI u = this.host.createQueryTaskService(QueryTask.create(q));\n        QueryTask task = this.host.waitForQueryTaskCompletion(q, 1, 1, u, false, true, false);\n        assertEquals(TaskState.TaskStage.FINISHED, task.taskInfo.stage);\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, task.results);\n\n        // reset the auth context\n        OperationContext.setAuthorizationContext(null);\n\n        // Assume Jane's identity through header auth token\n        String authToken = generateAuthToken(this.userServicePath);\n\n        verifyJaneAccess(exampleServices, authToken);\n    }\n\n    private AuthorizationContext assumeIdentityAndGetContext(String userLink,\n            Service privilegedService, boolean populateCache) throws Throwable {\n        AuthorizationContext authContext = this.host.assumeIdentity(userLink);\n        if (populateCache) {\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        }\n        return this.host.getAuthorizationContext(privilegedService, authContext.getToken());\n    }\n\n    @Test\n    public void authCacheClearToken() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        AuthorizationContext authContext1 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        AuthorizationContext authContext2 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        assertNotNull(authContext1);\n        assertNotNull(authContext2);\n\n        this.host.setSystemAuthorizationContext();\n        Operation clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n\n        assertNull(this.host.getAuthorizationContext(s, authContext1.getToken()));\n        assertNull(this.host.getAuthorizationContext(s, authContext2.getToken()));\n    }\n\n    @Test\n    public void updateAuthzCache() throws Throwable {\n        ExecutorService executor = null;\n        try {\n            this.host.setSystemAuthorizationContext();\n            AuthorizationHelper authsetupHelper = new AuthorizationHelper(this.host);\n            String email = \"foo@foo.com\";\n            String userLink = authsetupHelper.createUserService(this.host, email);\n            Query userGroupQuery = Query.Builder.create().addFieldClause(UserState.FIELD_NAME_EMAIL, email).build();\n            String userGroupLink = authsetupHelper.createUserGroup(this.host, email, userGroupQuery);\n            UserState patchState = new UserState();\n            patchState.userGroupLinks = Collections.singleton(userGroupLink);\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createPatch(UriUtils.buildUri(this.host, userLink))\n                    .setBody(patchState));\n            TestContext ctx = this.host.testCreate(this.serviceCount);\n            Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                    .toString());\n            executor = this.host.allocateExecutor(s);\n            this.host.resetSystemAuthorizationContext();\n            for (int i = 0; i < this.serviceCount; i++) {\n                this.host.run(executor, () -> {\n                    String serviceName = UUID.randomUUID().toString();\n                    try {\n                        this.host.setSystemAuthorizationContext();\n                        Query resourceQuery = Query.Builder.create().addFieldClause(ExampleServiceState.FIELD_NAME_NAME,\n                                serviceName).build();\n                        String resourceGroupLink = authsetupHelper.createResourceGroup(this.host, serviceName, resourceQuery);\n                        authsetupHelper.createRole(this.host, userGroupLink, resourceGroupLink, EnumSet.allOf(Action.class));\n                        this.host.resetSystemAuthorizationContext();\n                        this.host.assumeIdentity(userLink);\n                        ExampleServiceState exampleState = new ExampleServiceState();\n                        exampleState.name = serviceName;\n                        exampleState.documentSelfLink = serviceName;\n                        // Issue: https://www.pivotaltracker.com/story/show/131520613\n                        // We have a potential race condition in the code where the role\n                        // created above is not being reflected in the auth context for\n                        // the user; We are retrying the operation to mitigate the issue\n                        // till we have a fix for the issue\n                        for (int retryCounter = 0; retryCounter < 3; retryCounter++) {\n                            try {\n                                this.host.sendAndWaitExpectSuccess(\n                                        Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                                        .setBody(exampleState));\n                                break;\n                            } catch (Throwable t) {\n                                this.host.log(Level.WARNING, \"Error creating example service: \" + t.getMessage());\n                                if (retryCounter == 2) {\n                                    ctx.fail(new IllegalStateException(\"Example service creation failed thrice\"));\n                                    return;\n                                }\n                            }\n                        }\n                        this.host.sendAndWaitExpectSuccess(\n                                Operation.createDelete(UriUtils.buildUri(this.host,\n                                        UriUtils.buildUriPath(ExampleService.FACTORY_LINK, serviceName))));\n                        ctx.complete();\n                    } catch (Throwable e) {\n                        this.host.log(Level.WARNING, e.getMessage());\n                        ctx.fail(e);\n                    }\n                });\n            }\n            this.host.testWait(ctx);\n        } finally {\n            if (executor != null) {\n                executor.shutdown();\n            }\n        }\n    }\n\n    @Test\n    public void testAuthzUtils() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        UserState patchState = new UserState();\n        patchState.userGroupLinks = new HashSet<String>();\n        patchState.userGroupLinks.add(UriUtils.buildUriPath(\n                UserGroupService.FACTORY_LINK, authHelperForFoo.getUserGroupName(email)));\n        authHelperForFoo.patchUserService(this.host, fooUserLink, patchState);\n        // create a user group based on a query for userGroupLink\n        authHelperForFoo.createRoles(this.host, email, true);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        String userGroupLink = authHelperForFoo.getUserGroupLink();\n        String resourceGroupLink = authHelperForFoo.getResourceGroupLink();\n        String roleLink = authHelperForFoo.getRoleLink();\n\n\n        // get the user group service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getUserGroupStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, userGroupLink));\n        Operation resultOp = this.host.waitForResponse(getUserGroupStateOp);\n        UserGroupState userGroupState = resultOp.getBody(UserGroupState.class);\n        Operation clearAuthOp = new Operation();\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUserGroup(s, clearAuthOp, userGroupState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the resource group and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, resourceGroupLink));\n        AuthorizationCacheUtils.clearAuthzCacheForResourceGroup(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the role service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getRoleStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, roleLink));\n        resultOp = this.host.waitForResponse(getRoleStateOp);\n        RoleState roleState = resultOp.getBody(RoleState.class);\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForRole(s, clearAuthOp, roleState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // finally, get the user service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n    }\n\n    private void verifyJaneAccess(Map<URI, ExampleServiceState> exampleServices, String authToken) throws Throwable {\n        // Try to GET all example services\n        this.host.testStart(exampleServices.size());\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            Operation get = Operation.createGet(entry.getKey());\n            // force to create a remote context\n            if (authToken != null) {\n                get.forceRemote();\n                get.getRequestHeaders().put(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken);\n            }\n            if (entry.getValue().name.equals(\"jane\")) {\n                // Expect 200 OK\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_OK,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    ExampleServiceState body = o.getBody(ExampleServiceState.class);\n                    if (!body.documentAuthPrincipalLink.equals(this.userServicePath)) {\n                        String message = String.format(\"Expected %s, got %s\",\n                                this.userServicePath, body.documentAuthPrincipalLink);\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    this.host.completeIteration();\n                });\n            } else {\n                // Expect 403 Forbidden\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_FORBIDDEN,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    this.host.completeIteration();\n                });\n            }\n\n            this.host.send(get);\n        }\n        this.host.testWait();\n    }\n\n    private void assertAuthorizedServicesInResult(String name,\n            Map<URI, ExampleServiceState> exampleServices,\n            ServiceDocumentQueryResult result) {\n        Set<String> selfLinks = new HashSet<>(result.documentLinks);\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            String selfLink = entry.getKey().getPath();\n            if (entry.getValue().name.equals(name)) {\n                assertTrue(selfLinks.contains(selfLink));\n            } else {\n                assertFalse(selfLinks.contains(selfLink));\n            }\n        }\n    }\n\n    private String generateAuthToken(String userServicePath) throws GeneralSecurityException {\n        Claims.Builder builder = new Claims.Builder();\n        builder.setSubject(userServicePath);\n        Claims claims = builder.getResult();\n        return this.host.getTokenSigner().sign(claims);\n    }\n\n    private ExampleServiceState createExampleServiceState(String name, Long counter) {\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = name;\n        state.counter = counter;\n        state.documentAuthPrincipalLink = \"stringtooverwrite\";\n        return state;\n    }\n\n    private Map<URI, ExampleServiceState> createExampleServices(String userName) throws Throwable {\n        Collection<ExampleServiceState> bodies = new LinkedList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            bodies.add(createExampleServiceState(userName, 1L));\n        }\n\n        Iterator<ExampleServiceState> it = bodies.iterator();\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(it.next());\n        };\n\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                bodies.size(),\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n\n        return states;\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport static com.vmware.xenon.services.common.authn.BasicAuthenticationUtils.constructBasicAuth;\n\nimport java.net.URI;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UserService;\nimport com.vmware.xenon.services.common.authn.AuthenticationRequest;\nimport com.vmware.xenon.services.common.authn.BasicAuthenticationService;\n\npublic class TestExampleServiceHost extends BasicReusableHostTestCase {\n\n    private static final String adminUser = \"admin@localhost\";\n    private static final String exampleUser = \"example@localhost\";\n\n    /**\n     * Verify that the example service host creates users as expected.\n     *\n     * In theory we could test that authentication and authorization works correctly\n     * for these users. It's not critical to do here since we already test it in\n     * TestAuthSetupHelper.\n     */\n    @Test\n    public void createUsers() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        TemporaryFolder tmpFolder = new TemporaryFolder();\n        tmpFolder.create();\n        try {\n            String bindAddress = \"127.0.0.1\";\n\n            String[] args = {\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--isAuthorizationEnabled=\" + Boolean.TRUE.toString(),\n                    \"--adminUser=\" + adminUser,\n                    \"--adminUserPassword=\" + adminUser,\n                    \"--exampleUser=\" + exampleUser,\n                    \"--exampleUserPassword=\" + exampleUser,\n            };\n\n            h.initialize(args);\n            h.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n            h.start();\n\n            URI hostUri = h.getUri();\n            String authToken = loginUser(hostUri);\n            waitForUsers(hostUri, authToken);\n\n        } finally {\n            h.stop();\n            tmpFolder.delete();\n        }\n    }\n\n    /**\n     * Supports createUsers() by logging in as the admin. The admin user\n     * isn't created immediately, so this polls.\n     */\n    private String loginUser(URI hostUri) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        // wait for factory availability\n        this.host.waitForReplicatedFactoryServiceAvailable(usersLink);\n\n        String basicAuth = constructBasicAuth(adminUser, adminUser);\n        URI loginUri = UriUtils.buildUri(hostUri, ServiceUriPaths.CORE_AUTHN_BASIC);\n        AuthenticationRequest login = new AuthenticationRequest();\n        login.requestType = AuthenticationRequest.AuthenticationRequestType.LOGIN;\n\n        String[] authToken = new String[1];\n        authToken[0] = null;\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            Operation loginPost = Operation.createPost(loginUri)\n                    .setBody(login)\n                    .addRequestHeader(BasicAuthenticationService.AUTHORIZATION_HEADER_NAME,\n                            basicAuth)\n                    .forceRemote()\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            this.host.completeIteration();\n                            return;\n                        }\n                        authToken[0] = op.getResponseHeader(Operation.REQUEST_AUTH_TOKEN_HEADER);\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(loginPost);\n            this.host.testWait();\n\n            if (authToken[0] != null) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n\n        if (new Date().after(exp)) {\n            throw new TimeoutException();\n        }\n\n        assertNotNull(authToken[0]);\n\n        return authToken[0];\n    }\n\n    /**\n     * Supports createUsers() by waiting for two users to be created. They aren't created immediately,\n     * so this polls.\n     */\n    private void waitForUsers(URI hostUri, String authToken) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        Integer[] numberUsers = new Integer[1];\n        for (int i = 0; i < 20; i++) {\n            Operation get = Operation.createGet(usersLink)\n                    .forceRemote()\n                    .addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken)\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            if (op.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                this.host.failIteration(ex);\n                                return;\n                            } else {\n                                numberUsers[0] = 0;\n                                this.host.completeIteration();\n                                return;\n                            }\n                        }\n                        ServiceDocumentQueryResult response = op\n                                .getBody(ServiceDocumentQueryResult.class);\n                        assertTrue(response != null && response.documentLinks != null);\n                        numberUsers[0] = response.documentLinks.size();\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(get);\n            this.host.testWait();\n\n            if (numberUsers[0] == 2) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n        assertTrue(numberUsers[0] == 2);\n    }\n\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport java.net.URI;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.junit.After;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.common.http.netty.NettyHttpServiceClient;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\n\n\npublic class TestSubscriptions extends BasicTestCase {\n    private final int NODE_COUNT = 2;\n\n    public int serviceCount = 100;\n    public long updateCount = 10;\n    public long iterationCount = 0;\n\n    public void beforeHostStart(VerificationHost host) {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n    }\n\n    @After\n    public void tearDown() {\n        this.host.tearDown();\n        this.host.tearDownInProcessPeers();\n    }\n\n    private void setUpPeers() throws Throwable {\n        this.host.setUpPeerHosts(this.NODE_COUNT);\n        this.host.joinNodesAndVerifyConvergence(this.NODE_COUNT);\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptionsLoop() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            tearDown();\n            this.host = createHost();\n            initializeHost(this.host);\n            beforeHostStart(this.host);\n            this.host.start();\n            remoteAndReliableSubscriptions();\n        }\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptions() throws Throwable {\n        setUpPeers();\n\n        // pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n        URI factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        // test host to receive notifications\n        VerificationHost localHost = this.host;\n        int serviceCount = 1;\n        List<URI> exampleURIs = new ArrayList<>();\n        // create example service documents across all nodes\n        serviceHost.createExampleServices(serviceHost, serviceCount, exampleURIs, null);\n        TestContext oneUseNotificationCtx = this.host.testCreate(1);\n        StatelessService notificationTarget = new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                update.complete();\n                if (update.getAction().equals(Action.PATCH)) {\n                    if (update.getUri().getHost() == null) {\n                        oneUseNotificationCtx.fail(new IllegalStateException(\n                                \"Notification URI does not have host specified\"));\n                        return;\n                    }\n                    oneUseNotificationCtx.complete();\n                }\n            }\n        };\n\n        String[] ownerHostId = new String[1];\n        URI uri = exampleURIs.get(0);\n        URI subUri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n        TestContext subscribeCtx = this.host.testCreate(1);\n        Operation subscribe = Operation.createPost(subUri)\n                .setCompletion(subscribeCtx.getCompletion());\n        subscribe.setReferer(localHost.getReferer());\n        subscribe.forceRemote();\n        // replay state\n        serviceHost.startSubscriptionService(subscribe, notificationTarget, ServiceSubscriber\n                .create(false).setUsePublicUri(true));\n        this.host.testWait(subscribeCtx);\n\n        // do an update to cause a notification\n        TestContext updateCtx = this.host.testCreate(1);\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body).setCompletion((o, e) -> {\n            if (e != null) {\n                updateCtx.fail(e);\n                return;\n            }\n            ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n            ownerHostId[0] = rsp.documentOwner;\n            updateCtx.complete();\n\n        }));\n        this.host.testWait(updateCtx);\n        this.host.testWait(oneUseNotificationCtx);\n\n        // remove subscription\n        TestContext unSubscribeCtx = this.host.testCreate(1);\n        Operation unSubscribe = subscribe.clone()\n                .setCompletion(unSubscribeCtx.getCompletion())\n                .setAction(Action.DELETE);\n        serviceHost.stopSubscriptionService(unSubscribe,\n                notificationTarget.getUri());\n        this.host.testWait(unSubscribeCtx);\n        this.verifySubscriberCount(new URI[] { uri }, 0);\n\n        VerificationHost ownerHost = null;\n        // find the host that owns the example service and make sure we subscribe from the OTHER\n        // host (since we will stop the current owner)\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            if (!h.getId().equals(ownerHostId[0])) {\n                serviceHost = h;\n            } else {\n                ownerHost = h;\n            }\n        }\n\n        this.host.log(\"Owner node: %s, subscriber node: %s (%s)\", ownerHostId[0],\n                serviceHost.getId(), serviceHost.getUri());\n\n        AtomicInteger reliableNotificationCount = new AtomicInteger();\n        TestContext subscribeCtxNonOwner = this.host.testCreate(1);\n        // subscribe using non owner host\n        subscribe.setCompletion(subscribeCtxNonOwner.getCompletion());\n        serviceHost.startReliableSubscriptionService(subscribe, (o) -> {\n            reliableNotificationCount.incrementAndGet();\n            o.complete();\n        });\n        localHost.testWait(subscribeCtxNonOwner);\n\n        // send explicit update to example service\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body));\n\n        while (reliableNotificationCount.get() < 1) {\n            Thread.sleep(100);\n        }\n\n        reliableNotificationCount.set(0);\n\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // Check reliability: determine what host is owner for the example service we subscribed to.\n        // Then stop that host which should cause the remaining host(s) to pick up ownership.\n        // Subscriptions will not survive on their own, but we expect the ReliableSubscriptionService\n        // to notice the subscription is gone on the new owner, and re subscribe.\n        List<URI> exampleSubUris = new ArrayList<>();\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            exampleSubUris.add(UriUtils.buildUri(hostUri, uri.getPath(),\n                    ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS));\n        }\n\n        // stop host that has ownership of example service\n        NodeGroupConfig cfg = new NodeGroupConfig();\n        cfg.nodeRemovalDelayMicros = TimeUnit.SECONDS.toMicros(2);\n        this.host.setNodeGroupConfig(cfg);\n\n        // relax quorum\n        this.host.setNodeGroupQuorum(1);\n        // stop host with subscription\n        this.host.stopHost(ownerHost);\n\n        factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        uri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n\n        // verify that we still have 1 subscription on the remaining host, which can only happen if the\n        // reliable subscription service notices the current owner failure and re subscribed\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // and test once again that notifications flow.\n        this.host.log(\"Sending PATCH requests to %s\", uri);\n        long c = this.updateCount;\n        for (int i = 0; i < c; i++) {\n            body.name = \"post-stop-\" + UUID.randomUUID().toString();\n            this.host.send(Operation.createPatch(uri).setBody(body));\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (reliableNotificationCount.get() < c) {\n            Thread.sleep(250);\n            this.host.log(\"Received %d notifications, expecting %d\",\n                    reliableNotificationCount.get(), c);\n            if (new Date().after(exp)) {\n                throw new TimeoutException();\n            }\n        }\n    }\n\n    @Test\n    public void subscriptionsToFactoryAndChildren() throws Throwable {\n        this.host.stop();\n        this.host.setPort(0);\n        this.host.start();\n        this.host.setPublicUri(UriUtils.buildUri(\"localhost\", this.host.getPort(), \"\", null));\n        this.host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        URI factoryUri = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n\n        String prefix = \"example-\";\n        Long counterValue = Long.MAX_VALUE;\n        URI[] childUris = new URI[this.serviceCount];\n\n        doFactoryPostNotifications(factoryUri, this.serviceCount, prefix, counterValue, childUris);\n\n        doNotificationsWithReplayState(childUris);\n\n        doNotificationsWithFailure(childUris);\n\n        doNotificationsWithLimitAndPublicUri(childUris);\n\n        doNotificationsWithExpiration(childUris);\n\n        doDeleteNotifications(childUris, counterValue);\n    }\n\n    @Test\n    public void testSubscriptionsWithAuth() throws Throwable {\n        VerificationHost hostWithAuth = null;\n        try {\n            String testUserEmail = \"foo@vmware.com\";\n            hostWithAuth = VerificationHost.create(0);\n            hostWithAuth.setAuthorizationEnabled(true);\n            hostWithAuth.start();\n            hostWithAuth.setSystemAuthorizationContext();\n            TestContext waitContext = new TestContext(1, Duration.ofSeconds(5));\n            AuthorizationSetupHelper.create()\n                    .setHost(hostWithAuth)\n                    .setDocumentKind(Utils.buildKind(MinimalTestServiceState.class))\n                    .setUserEmail(testUserEmail)\n                    .setUserSelfLink(testUserEmail)\n                    .setUserPassword(testUserEmail)\n                    .setCompletion(waitContext.getCompletion())\n                    .start();\n            hostWithAuth.testWait(waitContext);\n            hostWithAuth.resetSystemAuthorizationContext();\n            hostWithAuth.assumeIdentity(UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, testUserEmail));\n            MinimalTestService s = new MinimalTestService();\n            MinimalTestServiceState serviceState = new MinimalTestServiceState();\n            serviceState.id = UUID.randomUUID().toString();\n            String minimalServiceUUID = UUID.randomUUID().toString();\n            TestContext notifyContext = new TestContext(1, Duration.ofSeconds(5));\n            hostWithAuth.startServiceAndWait(s, minimalServiceUUID, serviceState);\n\n            Consumer<Operation> notifyC = (nOp) -> {\n                nOp.complete();\n                switch (nOp.getAction()) {\n                case PUT:\n                    notifyContext.completeIteration();\n                    break;\n                default:\n                    break;\n\n                }\n            };\n            Operation subscribe = Operation.createPost(UriUtils.buildUri(hostWithAuth, minimalServiceUUID));\n            subscribe.setReferer(hostWithAuth.getReferer());\n            ServiceSubscriber subscriber = new ServiceSubscriber();\n            subscriber.replayState = true;\n            hostWithAuth.startSubscriptionService(subscribe, notifyC, subscriber);\n            hostWithAuth.testWait(notifyContext);\n        } finally {\n            if (hostWithAuth != null) {\n                hostWithAuth.tearDown();\n            }\n        }\n    }\n\n    @Test\n    public void subscribeAndWaitForServiceAvailability() throws Throwable {\n        // until HTTP2 support is we must only subscribe to less than max connections!\n        // otherwise we deadlock: the connection for the queued subscribe is used up,\n        // no more connections can be created, to that owner.\n        this.serviceCount = NettyHttpServiceClient.DEFAULT_CONNECTIONS_PER_HOST / 2;\n        // set the connection limit higher for the test host since it will be issuing parallel\n        // subscribes, POSTs\n        this.host.getClient().setConnectionLimitPerHost(this.serviceCount * 4);\n        setUpPeers();\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.getClient().setConnectionLimitPerHost(this.serviceCount * 4);\n        }\n\n        this.host.waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK));\n\n        // Pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n\n        // Create example service states to subscribe to\n        List<ExampleServiceState> states = new ArrayList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.documentSelfLink = UriUtils.buildUriPath(\n                    ExampleService.FACTORY_LINK,\n                    UUID.randomUUID().toString());\n            state.name = UUID.randomUUID().toString();\n            states.add(state);\n        }\n\n        AtomicInteger notifications = new AtomicInteger();\n        // Subscription target\n        ServiceSubscriber sr = createAndStartNotificationTarget((update) -> {\n            if (update.getAction() != Action.PATCH) {\n                // because we start multiple nodes and we do not wait for factory start\n                // we will receive synchronization related PUT requests, on each service.\n                // Ignore everything but the PATCH we send from the test\n                return false;\n            }\n            this.host.completeIteration();\n            this.host.log(\"notification %d\", notifications.incrementAndGet());\n            update.complete();\n            return true;\n        });\n\n        this.host.log(\"Subscribing to %d services\", this.serviceCount);\n        // Subscribe to factory (will not complete until factory is started again)\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            subscribeToService(uri, sr);\n        }\n\n        // First the subscription requests will be sent and will be queued.\n        // So N completions come from the subscribe requests.\n        // After that, the services will be POSTed and started. This is the second set\n        // of N completions.\n        this.host.testStart(2 * this.serviceCount);\n        this.host.log(\"Sending parallel POST for %d services\", this.serviceCount);\n\n        AtomicInteger postCount = new AtomicInteger();\n        // Create example services, triggering subscriptions to complete\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildFactoryUri(serviceHost, ExampleService.class);\n            Operation op = Operation.createPost(uri)\n                    .setBody(state)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        this.host.log(\"POST count %d\", postCount.incrementAndGet());\n                        this.host.completeIteration();\n                    });\n            this.host.send(op);\n        }\n\n        this.host.testWait();\n\n        this.host.testStart(2 * this.serviceCount);\n        // now send N PATCH ops so we get notifications\n        for (ExampleServiceState state : states) {\n            // send a PATCH, to trigger notification\n            URI u = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            state.counter = Utils.getNowMicrosUtc();\n            Operation patch = Operation.createPatch(u)\n                    .setBody(state)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(patch);\n        }\n        this.host.testWait();\n    }\n\n    private void doFactoryPostNotifications(URI factoryUri, int childCount, String prefix,\n            Long counterValue,\n            URI[] childUris) throws Throwable {\n        this.host.log(\"starting subscription to factory\");\n        this.host.testStart(1);\n        // let the service host update the URI from the factory to its subscriptions\n        Operation subscribeOp = Operation.createPost(factoryUri)\n                .setReferer(this.host.getReferer())\n                .setCompletion(this.host.getCompletion());\n        URI notificationTarget = host.startSubscriptionService(subscribeOp, (o) -> {\n            if (o.getAction() == Action.POST) {\n                this.host.completeIteration();\n            } else {\n                this.host.failIteration(new IllegalStateException(\"Unexpected notification: \"\n                        + o.toString()));\n            }\n        });\n        this.host.testWait();\n\n        // expect a POST notification per child, a POST completion per child\n        this.host.testStart(childCount * 2);\n        for (int i = 0; i < childCount; i++) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.name = initialState.documentSelfLink = prefix + i;\n            initialState.counter = counterValue;\n            final int finalI = i;\n\n            // create an example service\n            this.host.send(Operation\n                    .createPost(factoryUri)\n                    .setBody(initialState).setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        ServiceDocument rsp = o.getBody(ServiceDocument.class);\n                        childUris[finalI] = UriUtils.buildUri(this.host, rsp.documentSelfLink);\n                        this.host.completeIteration();\n                    }));\n        }\n        this.host.testWait();\n\n        this.host.testStart(1);\n        Operation delete = subscribeOp.clone().setUri(factoryUri).setAction(Action.DELETE);\n        this.host.stopSubscriptionService(delete, notificationTarget);\n        this.host.testWait();\n        this.verifySubscriberCount(new URI[]{factoryUri}, 0);\n    }\n\n    private void doNotificationsWithReplayState(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with replay\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(\n                UUID.randomUUID().toString(),\n                deletesRemainingCount);\n        sr.replayState = true;\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        patchChildren(childUris, false);\n\n        patchChildren(childUris, false);\n\n        // Finally un subscribe the notification handlers\n        unsubscribeFromChildren(childUris, sr.reference, false);\n        verifySubscriberCount(childUris, 0);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doNotificationsWithExpiration(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with expiration\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n\n        // start a notification target that will not complete test iterations since expirations race\n        // with notifications, allowing for notifications to be processed after the next test starts\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount, false, false);\n        sr.documentExpirationTimeMicros = Utils.getNowMicrosUtc()\n                + this.host.getMaintenanceIntervalMicros() * 2;\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        Thread.sleep((this.host.getMaintenanceIntervalMicros() / 1000) * 2);\n        // do a patch which will cause the publisher to evaluate and expire subscriptions\n        patchChildren(childUris, true);\n\n        verifySubscriberCount(childUris, 0);\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void deleteNotificationTarget(AtomicInteger deletesRemainingCount,\n            ServiceSubscriber sr) throws Throwable {\n        deletesRemainingCount.set(1);\n        TestContext ctx = testCreate(1);\n        this.host.send(Operation.createDelete(sr.reference)\n                .setCompletion((o, e) -> ctx.completeIteration()));\n        testWait(ctx);\n    }\n\n    private void doNotificationsWithFailure(URI[] childUris) throws Throwable, InterruptedException {\n        this.host.log(\"starting subscription with failure, stopping notification target\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, but stop the notification target, causing automatic removal of the\n        // subscriptions\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        // send updates and expect failure in delivering notifications\n        patchChildren(childUris, true);\n        // expect the publisher to note at least one failed notification attempt\n        verifySubscriberCount(true, childUris, 1, 1L);\n\n        // restart notification target service but expect a pragma in the notifications\n        // saying we missed some\n        boolean expectSkippedNotificationsPragma = true;\n        this.host.log(\"restarting notification target\");\n        createAndStartNotificationTarget(sr.reference.getPath(),\n                deletesRemainingCount, expectSkippedNotificationsPragma, true);\n\n        // send some more updates, this time expect ZERO failures;\n        patchChildren(childUris, false);\n        verifySubscriberCount(true, childUris, 1, 0L);\n\n        this.host.log(\"stopping notification target, again\");\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        while (!verifySubscriberCount(false, childUris, 0, null)) {\n            Thread.sleep(VerificationHost.FAST_MAINT_INTERVAL_MILLIS);\n            patchChildren(childUris, true);\n        }\n\n        this.host.log(\"Verifying all subscriptions have been removed\");\n        // because we sent more than K updates, causing K + 1 notification delivery failures,\n        // the subscriptions should all be automatically removed!\n        verifySubscriberCount(childUris, 0);\n    }\n\n    private void doNotificationsWithLimitAndPublicUri(URI[] childUris) throws Throwable,\n            InterruptedException, TimeoutException {\n        this.host.log(\"starting subscription with limit and public uri\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, use public URI and limit notifications to one.\n        // After these notifications are sent, we should see all subscriptions removed\n        deletesRemainingCount.set(childUris.length + 1);\n        sr.usePublicUri = true;\n        sr.notificationLimit = this.updateCount;\n\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        // Issue another patch request on every example service instance\n        patchChildren(childUris, false);\n\n        // because we set notificationLimit, all subscriptions should be removed\n        verifySubscriberCount(childUris, 0);\n\n        Date exp = this.host.getTestExpiration();\n        // verify we received DELETEs on the notification target when a subscription was removed\n        while (deletesRemainingCount.get() != 1) {\n            Thread.sleep(250);\n            if (new Date().after(exp)) {\n                throw new TimeoutException(\"DELETEs not received at notification target:\"\n                        + deletesRemainingCount.get());\n            }\n        }\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doDeleteNotifications(URI[] childUris, Long counterValue) throws Throwable {\n        this.host.log(\"starting subscription for DELETEs\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        subscribeToServices(childUris, sr);\n\n        // Issue DELETEs and verify the subscription was notified\n        this.host.testStart(childUris.length * 2);\n        for (URI child : childUris) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.counter = counterValue;\n            Operation delete = Operation\n                    .createDelete(child)\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(delete);\n        }\n        this.host.testWait();\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount) throws Throwable {\n        return createAndStartNotificationTarget(link, deletesRemainingCount, false, true);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount,\n            boolean expectSkipNotificationsPragma,\n            boolean completeIterations) throws Throwable {\n        final AtomicBoolean seenSkippedNotificationPragma =\n                new AtomicBoolean(false);\n\n        return createAndStartNotificationTarget(link, (update) -> {\n            if (!update.isNotification()) {\n                if (update.getAction() == Action.DELETE) {\n                    int r = deletesRemainingCount.decrementAndGet();\n                    if (r != 0) {\n                        update.complete();\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            if (update.getAction() != Action.PATCH &&\n                    update.getAction() != Action.PUT &&\n                    update.getAction() != Action.DELETE) {\n                update.complete();\n                return true;\n            }\n\n            if (expectSkipNotificationsPragma) {\n                String pragma = update.getRequestHeader(Operation.PRAGMA_HEADER);\n                if (!seenSkippedNotificationPragma.get() && (pragma == null\n                        || !pragma.contains(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS))) {\n                    this.host.failIteration(new IllegalStateException(\n                            \"Missing skipped notification pragma\"));\n                    return true;\n                } else {\n                    seenSkippedNotificationPragma.set(true);\n                }\n            }\n\n            if (completeIterations) {\n                this.host.completeIteration();\n            }\n\n            update.complete();\n            return true;\n        });\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            Function<Operation, Boolean> h) throws Throwable {\n        return createAndStartNotificationTarget(UUID.randomUUID().toString(), h);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            String link,\n            Function<Operation, Boolean> h) throws Throwable {\n        StatelessService notificationTarget = createNotificationTargetService(h);\n\n        // Start notification target (shared between subscriptions)\n        Operation startOp = Operation\n                .createPost(UriUtils.buildUri(this.host, link))\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer());\n        this.host.testStart(1);\n        this.host.startService(startOp, notificationTarget);\n        this.host.testWait();\n\n        ServiceSubscriber sr = new ServiceSubscriber();\n        sr.reference = notificationTarget.getUri();\n        return sr;\n    }\n\n    private StatelessService createNotificationTargetService(Function<Operation, Boolean> h) {\n        return new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                if (!h.apply(update)) {\n                    super.handleRequest(update);\n                }\n            }\n        };\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr) throws Throwable {\n        int expectedCompletions = uris.length;\n        if (sr.replayState) {\n            expectedCompletions *= 2;\n        }\n        subscribeToServices(uris, sr, expectedCompletions);\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr, int expectedCompletions) throws Throwable {\n        this.host.testStart(expectedCompletions);\n        for (int i = 0; i < uris.length; i++) {\n            subscribeToService(uris[i], sr);\n        }\n        this.host.testWait();\n    }\n\n    private void subscribeToService(URI uri, ServiceSubscriber sr) {\n        if (sr.usePublicUri) {\n            sr = Utils.clone(sr);\n            sr.reference = UriUtils.buildPublicUri(this.host, sr.reference.getPath());\n        }\n\n        URI subUri = UriUtils.buildSubscriptionUri(uri);\n        this.host.send(Operation.createPost(subUri)\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer())\n                .setBody(sr)\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_QUEUE_FOR_SERVICE_AVAILABILITY));\n    }\n\n    private void unsubscribeFromChildren(URI[] uris, URI targetUri,\n            boolean useServiceHostStopSubscription) throws Throwable {\n        int count = uris.length;\n        TestContext ctx = testCreate(count);\n        for (int i = 0; i < count; i++) {\n            if (useServiceHostStopSubscription) {\n                // stop the subscriptions using the service host API\n                host.stopSubscriptionService(\n                        Operation.createDelete(uris[i])\n                                .setCompletion(ctx.getCompletion()),\n                        targetUri);\n                continue;\n            }\n            ServiceSubscriber unsubscribeBody = new ServiceSubscriber();\n            unsubscribeBody.reference = targetUri;\n\n            URI subUri = UriUtils.buildSubscriptionUri(uris[i]);\n            this.host.send(Operation.createDelete(subUri)\n                    .setCompletion(ctx.getCompletion())\n                    .setBody(unsubscribeBody));\n        }\n        testWait(ctx);\n    }\n\n    private boolean verifySubscriberCount(URI[] uris, int subscriberCount) throws Throwable {\n        return verifySubscriberCount(true, uris, subscriberCount, null);\n    }\n\n    private boolean verifySubscriberCount(boolean wait, URI[] uris, int subscriberCount,\n            Long failedNotificationCount)\n            throws Throwable {\n        URI[] subUris = new URI[uris.length];\n        int i = 0;\n        for (URI u : uris) {\n            URI subUri = UriUtils.buildSubscriptionUri(u);\n            subUris[i++] = subUri;\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            Map<URI, ServiceSubscriptionState> subStates = this.host.getServiceState(null,\n                    ServiceSubscriptionState.class, subUris);\n            for (ServiceSubscriptionState state : subStates.values()) {\n                int expected = subscriberCount;\n                int actual = state.subscribers.size();\n                if (actual != expected) {\n                    isConverged = false;\n                    break;\n                }\n\n                if (failedNotificationCount == null) {\n                    continue;\n                }\n\n                for (ServiceSubscriber sr : state.subscribers.values()) {\n                    if (sr.failedNotificationCount == null && failedNotificationCount == 0) {\n                        continue;\n                    }\n                    if (sr.failedNotificationCount == null\n                            || 0 != sr.failedNotificationCount.compareTo(failedNotificationCount)) {\n                        isConverged = false;\n                        break;\n                    }\n                }\n\n            }\n            if (isConverged) {\n                return true;\n            }\n            if (!wait) {\n                return false;\n            }\n            Thread.sleep(250);\n        }\n\n        throw new TimeoutException(\"Subscriber count did not converge to \" + subscriberCount);\n    }\n\n    private void patchChildren(URI[] uris, boolean expectFailure) throws Throwable {\n        int count = expectFailure ? uris.length : uris.length * 2;\n        long c = this.updateCount;\n        if (!expectFailure) {\n            count *= this.updateCount;\n        } else {\n            c = 1;\n        }\n\n        this.host.testStart(count);\n        for (int i = 0; i < uris.length; i++) {\n            for (int k = 0; k < c; k++) {\n                ExampleServiceState initialState = new ExampleServiceState();\n                initialState.counter = Long.MAX_VALUE;\n                Operation patch = Operation\n                        .createPatch(uris[i])\n                        .setBody(initialState)\n                        .setCompletion(this.host.getCompletion());\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait();\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.TimeBin;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\n\npublic class TestUtilityService extends BasicReusableHostTestCase {\n\n    private List<Service> createServices(int count) throws Throwable {\n        List<Service> services = this.host.doThroughputServiceStart(\n                count, MinimalTestService.class,\n                this.host.buildMinimalTestState(),\n                null, null);\n        return services;\n    }\n\n    @Before\n    public void setUp() {\n        // We tell the verification host that we re-use it across test methods. This enforces\n        // the use of TestContext, to isolate test methods from each other.\n        // In this test class we host.testCreate(count) to get an isolated test context and\n        // then either wait on the context itself, or ask the convenience method host.testWait(ctx)\n        // to do it for us.\n        this.host.setSingleton(true);\n    }\n\n    @Test\n    public void patchConfiguration() throws Throwable {\n        int count = 10;\n\n        host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        // try config patch on a factory\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = EnumSet.of(ServiceOption.IDEMPOTENT_POST);\n        TestContext ctx = this.testCreate(1);\n\n        URI configUri = UriUtils.buildConfigUri(host, ExampleService.FACTORY_LINK);\n        this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                .setCompletion(ctx.getCompletion()));\n\n        this.testWait(ctx);\n\n        TestContext ctx2 = this.testCreate(1);\n        // verify option removed\n        this.host.send(Operation.createGet(configUri).setCompletion((o, e) -> {\n            if (e != null) {\n                ctx2.failIteration(e);\n                return;\n            }\n\n            ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n            if (!cfg.options.contains(ServiceOption.IDEMPOTENT_POST)) {\n                ctx2.completeIteration();\n            } else {\n                ctx2.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n            }\n\n        }));\n\n        this.testWait(ctx2);\n\n        List<Service> services = createServices(count);\n        // verify no stats exist before we enable that capability\n        for (Service s : services) {\n            Map<String, ServiceStat> stats = this.host.getServiceStats(s.getUri());\n            assertTrue(stats != null);\n            assertTrue(stats.isEmpty());\n        }\n\n        updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.addOptions = EnumSet.of(ServiceOption.INSTRUMENTATION);\n        ctx = this.testCreate(services.size());\n        for (Service s : services) {\n            configUri = UriUtils.buildConfigUri(s.getUri());\n            this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                    .setCompletion(ctx.getCompletion()));\n        }\n        this.testWait(ctx);\n\n        // get configuration and verify options\n        TestContext ctx3 = testCreate(services.size());\n        for (Service s : services) {\n            URI u = UriUtils.buildConfigUri(s.getUri());\n            host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                if (e != null) {\n                    ctx3.failIteration(e);\n                    return;\n                }\n\n                ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n                if (cfg.options.contains(ServiceOption.INSTRUMENTATION)) {\n                    ctx3.completeIteration();\n                } else {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                }\n\n            }));\n        }\n        testWait(ctx3);\n\n        ctx = testCreate(services.size());\n        // issue some updates so stats get updated\n        for (Service s : services) {\n            this.host.send(Operation.createPatch(s.getUri())\n                    .setBody(this.host.buildMinimalTestState())\n                    .setCompletion(ctx.getCompletion()));\n        }\n        testWait(ctx);\n\n        for (Service s : services) {\n            Map<String, ServiceStat> stats = this.host.getServiceStats(s.getUri());\n            assertTrue(stats != null);\n            assertTrue(!stats.isEmpty());\n        }\n    }\n\n    @Test\n    public void redirectToUiServiceIndex() throws Throwable {\n        // create an example child service and also verify it has a default UI html page\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = UUID.randomUUID().toString();\n        s.documentSelfLink = s.name;\n        Operation post = Operation\n                .createPost(UriUtils.buildFactoryUri(this.host, ExampleService.class))\n                .setBody(s);\n        this.host.sendAndWaitExpectSuccess(post);\n\n        // do a get on examples/ui and examples/<uuid>/ui, twice to test the code path that caches\n        // the resource file lookup\n        for (int i = 0; i < 2; i++) {\n            Operation htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n\n            htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK, s.name,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n        }\n    }\n\n    @Test\n    public void testUtilityStats() throws Throwable {\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 2;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stat.unit = \"unit\";\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 3 - POST a stat with the same key again and verify that the\n        // version and accumulated value are updated\n        stat.latestValue = 50;\n        stat.unit = \"unit1\";\n        Long updatedMicrosUtc1 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc1;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        // Step 4 - POST a stat with a new key and verify that the\n        // previously posted stat is not updated\n        stat.name = \"key2\";\n        stat.latestValue = 50;\n        stat.unit = \"unit2\";\n        Long updatedMicrosUtc2 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc2;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        retStatEntry = allStats.entries.get(\"key2\");\n        assertTrue(retStatEntry.accumulatedValue == 50);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit2\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc2);\n\n        // Step 5 - Issue a PUT for the first stat key and verify that the doc state is replaced\n        stat.name = \"key1\";\n        stat.latestValue = 75;\n        stat.unit = \"replaceUnit\";\n        stat.sourceTimeMicrosUtc = null;\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 75);\n        assertTrue(retStatEntry.latestValue == 75);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"replaceUnit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 6 - Issue a bulk PUT and verify that the complete set of stats is updated\n        ServiceStats stats = new ServiceStats();\n        stat.name = \"key3\";\n        stat.latestValue = 200;\n        stat.unit = \"unit3\";\n        stats.entries.put(\"key3\", stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stats));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        if (allStats.entries.size() != 1) {\n            // there is a possibility of node group maintenance kicking in and adding a stat\n            ServiceStat nodeGroupStat = allStats.entries.get(\n                    Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n\n            if (nodeGroupStat == null) {\n                throw new IllegalStateException(\n                        \"Expected single stat, got: \" + Utils.toJsonHtml(allStats));\n            }\n        }\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.accumulatedValue == 200);\n        assertTrue(retStatEntry.latestValue == 200);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit3\"));\n\n        // Step 7 - Issue a PATCH and verify that the latestValue is updated\n        stat.latestValue = 25;\n        this.host.sendAndWaitExpectSuccess(Operation.createPatch(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.latestValue == 225);\n        assertTrue(retStatEntry.version == 2);\n    }\n\n    @Test\n    public void testTimeSeriesStats() throws Throwable {\n        long startTime = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());\n        int numBins = 4;\n        long interval = 1000;\n        double value = 100;\n        // set data to fill up the specified number of bins\n        TimeSeriesStats timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.allOf(AggregationType.class));\n        for (int i = 0; i < numBins; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        // insert additional unique datapoints; the earliest entries should be dropped\n        for (int i = 0; i < numBins / 2; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        long timeMicros = startTime - TimeUnit.MILLISECONDS.toMicros(interval * (numBins - 1));\n        long timeMillis = TimeUnit.MICROSECONDS.toMillis(timeMicros);\n        timeMillis -= (timeMillis % interval);\n        assertTrue(timeSeriesStats.bins.firstKey() == timeMillis);\n\n        // insert additional datapoints for an existing bin. The count should increase,\n        // min, max, average computed appropriately\n        double origValue = value;\n        double accumulatedValue = value;\n        double newValue = value;\n        double count = 1;\n        for (int i = 0; i < numBins / 2; i++) {\n            newValue++;\n            count++;\n            timeSeriesStats.add(startTime, newValue);\n            accumulatedValue += newValue;\n        }\n        TimeBin lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg.equals(accumulatedValue / count));\n        assertTrue(lastBin.sum.equals(accumulatedValue));\n        assertTrue(lastBin.count == count);\n        assertTrue(lastBin.max.equals(newValue));\n        assertTrue(lastBin.min.equals(origValue));\n\n        // test with a subset of the aggregation types specified\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.AVG));\n        timeSeriesStats.add(startTime, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg != null);\n        assertTrue(lastBin.count != 0);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.MIN, AggregationType.MAX));\n        timeSeriesStats.add(startTime, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.max != null);\n        assertTrue(lastBin.min != null);\n\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        // set bin size to 1ms\n        stat.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        for (int i = 0; i < numBins; i++) {\n            Thread.sleep(1);\n            this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                    this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        }\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(stat.name);\n        assertTrue(retStatEntry.accumulatedValue == 100 * (numBins + 1));\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == numBins + 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == numBins);\n\n        // Step 3 - POST a stat to the service instance with sourceTimeMicrosUtc and verify we can fetch the stat just posted\n        String statName = UUID.randomUUID().toString();\n        ExampleServiceState exampleState = new ExampleServiceState();\n        exampleState.name = statName;\n        Consumer<Operation> setter = (o) -> {\n            o.setBody(exampleState);\n        };\n        Map<URI, ExampleServiceState> stateMap = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, setter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n        ExampleServiceState returnExampleState = stateMap.values().iterator().next();\n        ServiceStats.ServiceStat sourceStat1 = new ServiceStat();\n        sourceStat1.name = \"sourceKey1\";\n        sourceStat1.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 1, 2000\n        Long sourceTimeMicrosUtc1 = 946713600000000L;\n        sourceStat1.sourceTimeMicrosUtc = sourceTimeMicrosUtc1;\n        ServiceStats.ServiceStat sourceStat2 = new ServiceStat();\n        sourceStat2.name = \"sourceKey2\";\n        sourceStat2.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 2, 2000\n        Long sourceTimeMicrosUtc2 = 946800000000000L;\n        sourceStat2.sourceTimeMicrosUtc = sourceTimeMicrosUtc2;\n        // set bucket size to 1ms\n        sourceStat1.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        sourceStat2.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat1));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat2));\n        allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, returnExampleState.documentSelfLink));\n        retStatEntry = allStats.entries.get(sourceStat1.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc1)));\n\n        retStatEntry = allStats.entries.get(sourceStat2.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc2)));\n    }\n\n    public static class SetAvailableValidationService extends StatefulService {\n\n        public SetAvailableValidationService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public void handleStart(Operation op) {\n            setAvailable(false);\n            // we will transition to available only when we receive a special PATCH.\n            // This simulates a service that starts, but then self patch itself sometime\n            // later to indicate its done with some complex init. It does not do it in handle\n            // start, since it wants to make POST quick.\n            op.complete();\n        }\n\n        @Override\n        public void handlePatch(Operation op) {\n            // regardless of body, just become available\n            setAvailable(true);\n            op.complete();\n        }\n    }\n\n    @Test\n    public void failureOnReservedSuffixServiceStart() throws Throwable {\n        TestContext ctx = this.testCreate(ServiceHost.RESERVED_SERVICE_URI_PATHS.length);\n        for (String reservedSuffix : ServiceHost.RESERVED_SERVICE_URI_PATHS) {\n            Operation post = Operation.createPost(this.host,\n                    UUID.randomUUID().toString() + \"/\" + reservedSuffix)\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.startService(post, new MinimalTestService());\n        }\n        this.testWait(ctx);\n    }\n\n    @Test\n    public void testIsAvailableStatAndSuffix() throws Throwable {\n        long c = 1;\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // first verify that service that do not explicitly use the setAvailable method,\n        // appear available. Both a factory and a child service\n        this.host.waitForServiceAvailable(factoryURI);\n\n        // expect 200 from /factory/<child>/available\n        TestContext ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            Operation get = Operation.createGet(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // verify that PUT on /available can make it switch to unavailable (503)\n        ServiceStat body = new ServiceStat();\n        body.name = Service.STAT_NAME_AVAILABLE;\n        body.latestValue = 0.0;\n\n        Operation put = Operation.createPut(\n                UriUtils.buildAvailableUri(this.host, factoryURI.getPath()))\n                .setBody(body);\n        this.host.sendAndWaitExpectSuccess(put);\n\n        // verify factory now appears unavailable\n        Operation get = Operation.createGet(UriUtils.buildAvailableUri(factoryURI));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // verify PUT on child services makes them unavailable\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            put = put.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setBody(body)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(put);\n        }\n        testWait(ctx);\n\n        // expect 503 from /factory/<child>/available\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            get = get.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // now validate a stateful service that is in memory, and explicitly calls setAvailable\n        // sometime after it starts\n        Service service = this.host.startServiceAndWait(new SetAvailableValidationService(),\n                UUID.randomUUID().toString(), new ExampleServiceState());\n\n        // verify service is NOT available, since we have not yet poked it, to become available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // send a PATCH to this special test service, to make it switch to available\n        Operation patch = Operation.createPatch(service.getUri())\n                .setBody(new ExampleServiceState());\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        // verify service now appears available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectSuccess(get);\n    }\n\n    public void validateServiceUiHtmlResponse(Operation op) {\n        assertTrue(op.getStatusCode() == Operation.STATUS_CODE_MOVED_TEMP);\n        assertTrue(op.getResponseHeader(\"Location\").contains(\n                \"/core/ui/default/#\"));\n    }\n\n    public static void validateTimeSeriesStat(ServiceStat stat, long expectedBinDurationMillis) {\n        assertTrue(stat != null);\n        assertTrue(stat.timeSeriesStats != null);\n        assertTrue(stat.version > 1);\n        assertEquals(expectedBinDurationMillis, stat.timeSeriesStats.binDurationMillis);\n        double maxAvg = 0;\n        double countPerMaxAvgBin = 0;\n        for (TimeBin bin : stat.timeSeriesStats.bins.values()) {\n            if (bin.avg != null && bin.avg > maxAvg) {\n                maxAvg = bin.avg;\n                countPerMaxAvgBin = bin.count;\n            }\n        }\n        assertTrue(maxAvg > 0);\n        assertTrue(countPerMaxAvgBin >= 1);\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common.test;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static com.vmware.xenon.services.common.authn.BasicAuthenticationUtils.constructBasicAuth;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification;\nimport com.vmware.xenon.services.common.ResourceGroupService.ResourceGroupState;\nimport com.vmware.xenon.services.common.RoleService.Policy;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UserGroupService;\nimport com.vmware.xenon.services.common.UserGroupService.UserGroupState;\nimport com.vmware.xenon.services.common.UserService.UserState;\nimport com.vmware.xenon.services.common.authn.AuthenticationRequest;\nimport com.vmware.xenon.services.common.authn.BasicAuthenticationService;\n\n/**\n * Consider using {@link com.vmware.xenon.common.AuthorizationSetupHelper}\n */\npublic class AuthorizationHelper {\n\n    private String userGroupLink;\n    private String resourceGroupLink;\n    private String roleLink;\n\n    VerificationHost host;\n\n    public AuthorizationHelper(VerificationHost host) {\n        this.host = host;\n    }\n\n    public static String createUserService(VerificationHost host, ServiceHost target, String email) throws Throwable {\n        final String[] userUriPath = new String[1];\n\n        UserState userState = new UserState();\n        userState.documentSelfLink = email;\n        userState.email = email;\n\n        URI postUserUri = UriUtils.buildUri(target, ServiceUriPaths.CORE_AUTHZ_USERS);\n        host.testStart(1);\n        host.send(Operation\n                .createPost(postUserUri)\n                .setBody(userState)\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        host.failIteration(e);\n                        return;\n                    }\n                    UserState state = o.getBody(UserState.class);\n                    userUriPath[0] = state.documentSelfLink;\n                    host.completeIteration();\n                }));\n        host.testWait();\n        return userUriPath[0];\n    }\n\n    public void patchUserService(ServiceHost target, String userServiceLink, UserState userState) throws Throwable {\n        URI patchUserUri = UriUtils.buildUri(target, userServiceLink);\n        this.host.testStart(1);\n        this.host.send(Operation\n                .createPatch(patchUserUri)\n                .setBody(userState)\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n                    this.host.completeIteration();\n                }));\n        this.host.testWait();\n    }\n\n    /**\n     * Find user document and return the path.\n     *   ex: /core/authz/users/sample@vmware.com\n     *\n     * @see VerificationHost#assumeIdentity(String)\n     */\n    public String findUserServiceLink(String userEmail) throws Throwable {\n        Query userQuery = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(UserState.class))\n                .addFieldClause(UserState.FIELD_NAME_EMAIL, userEmail)\n                .build();\n\n        QueryTask queryTask = QueryTask.Builder.createDirectTask()\n                .setQuery(userQuery)\n                .build();\n\n        URI queryTaskUri = UriUtils.buildUri(this.host, ServiceUriPaths.CORE_QUERY_TASKS);\n\n        String[] userServiceLink = new String[1];\n\n        TestContext ctx = this.host.testCreate(1);\n        Operation postQuery = Operation.createPost(queryTaskUri)\n                .setBody(queryTask)\n                .setCompletion((op, ex) -> {\n                    if (ex != null) {\n                        ctx.failIteration(ex);\n                        return;\n                    }\n                    QueryTask queryResponse = op.getBody(QueryTask.class);\n                    int resultSize = queryResponse.results.documentLinks.size();\n                    if (queryResponse.results.documentLinks.size() != 1) {\n                        String msg = String\n                                .format(\"Could not find user %s, found=%d\", userEmail, resultSize);\n                        ctx.failIteration(new IllegalStateException(msg));\n                        return;\n                    } else {\n                        userServiceLink[0] = queryResponse.results.documentLinks.get(0);\n                    }\n                    ctx.completeIteration();\n                });\n        this.host.send(postQuery);\n        this.host.testWait(ctx);\n\n        return userServiceLink[0];\n    }\n\n    /**\n     * Call BasicAuthenticationService and returns auth token.\n     */\n    public String login(String email, String password) throws Throwable {\n        String basicAuth = constructBasicAuth(email, password);\n        URI loginUri = UriUtils.buildUri(this.host, ServiceUriPaths.CORE_AUTHN_BASIC);\n        AuthenticationRequest login = new AuthenticationRequest();\n        login.requestType = AuthenticationRequest.AuthenticationRequestType.LOGIN;\n\n        String[] authToken = new String[1];\n\n        TestContext ctx = this.host.testCreate(1);\n\n        Operation loginPost = Operation.createPost(loginUri)\n                .setBody(login)\n                .addRequestHeader(BasicAuthenticationService.AUTHORIZATION_HEADER_NAME,\n                        basicAuth)\n                .forceRemote()\n                .setCompletion((op, ex) -> {\n                    if (ex != null) {\n                        ctx.failIteration(ex);\n                        return;\n                    }\n                    authToken[0] = op.getResponseHeader(Operation.REQUEST_AUTH_TOKEN_HEADER);\n                    if (authToken[0] == null) {\n                        ctx.failIteration(\n                                new IllegalStateException(\"Missing auth token in login response\"));\n                        return;\n                    }\n                    ctx.completeIteration();\n                });\n\n        this.host.send(loginPost);\n        this.host.testWait(ctx);\n\n        assertTrue(authToken[0] != null);\n\n        return authToken[0];\n\n    }\n\n    public void setUserGroupLink(String userGroupLink) {\n        this.userGroupLink = userGroupLink;\n    }\n\n    public void setResourceGroupLink(String resourceGroupLink) {\n        this.resourceGroupLink = resourceGroupLink;\n    }\n\n    public void setRoleLink(String roleLink) {\n        this.roleLink = roleLink;\n    }\n\n    public String getUserGroupLink() {\n        return this.userGroupLink;\n    }\n\n    public String getResourceGroupLink() {\n        return this.resourceGroupLink;\n    }\n\n    public String getRoleLink() {\n        return this.roleLink;\n    }\n\n    public String createUserService(ServiceHost target, String email) throws Throwable {\n        return createUserService(this.host, target, email);\n    }\n\n    public Collection<String> createRoles(ServiceHost target, String email) throws Throwable {\n        return createRoles(target, email, true);\n    }\n\n    public String getUserGroupName(String email) {\n        String emailPrefix = email.substring(0, email.indexOf(\"@\"));\n        return emailPrefix + \"-user-group\";\n    }\n\n    public Collection<String> createRoles(ServiceHost target, String email, boolean createUserGroupByEmail) throws Throwable {\n        String emailPrefix = email.substring(0, email.indexOf(\"@\"));\n        String userGroupLink = null;\n        // Create user group\n        if (createUserGroupByEmail) {\n            userGroupLink =  createUserGroup(target, getUserGroupName(email), Builder.create()\n                        .addFieldClause(\n                                \"email\",\n                                email)\n                        .build());\n\n        } else {\n            String groupName = getUserGroupName(email);\n            userGroupLink =  createUserGroup(target, groupName, Builder.create()\n                    .addFieldClause(\n                            QuerySpecification\n                            .buildCollectionItemName(UserState.FIELD_NAME_USER_GROUP_LINKS),\n                            UriUtils.buildUriPath(UserGroupService.FACTORY_LINK, groupName))\n                    .build());\n        }\n        setUserGroupLink(userGroupLink);\n\n        // Create resource group for example service state\n        String exampleServiceResourceGroupLink =\n                createResourceGroup(target, emailPrefix + \"-resource-group\", Builder.create()\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_KIND,\n                                Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_NAME,\n                                emailPrefix)\n                        .build());\n        setResourceGroupLink(exampleServiceResourceGroupLink);\n        // Create resource group to allow access on ALL query tasks created by user\n        String queryTaskResourceGroupLink =\n                createResourceGroup(target, \"any-query-task-resource-group\", Builder.create()\n                        .addFieldClause(\n                                QueryTask.FIELD_NAME_KIND,\n                                Utils.buildKind(QueryTask.class))\n                        .addFieldClause(\n                                QueryTask.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                                UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, email))\n                        .build());\n\n        Collection<String> paths = new HashSet<>();\n\n        // Create roles tying these together\n        String exampleRoleLink = createRole(target, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST)));\n        setRoleLink(exampleRoleLink);\n        paths.add(exampleRoleLink);\n        // Create another role with PATCH permission to test if we calculate overall permissions correctly across roles.\n        paths.add(createRole(target, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Collections.singletonList(Action.PATCH))));\n\n        // Create role authorizing access to the user's own query tasks\n        paths.add(createRole(target, userGroupLink, queryTaskResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE))));\n        return paths;\n    }\n\n    public String createUserGroup(ServiceHost target, String name, Query q) throws Throwable {\n        URI postUserGroupsUri =\n                UriUtils.buildUri(target, ServiceUriPaths.CORE_AUTHZ_USER_GROUPS);\n        String selfLink =\n                UriUtils.extendUri(postUserGroupsUri, name).getPath();\n\n        // Create user group\n        UserGroupState userGroupState = new UserGroupState();\n        userGroupState.documentSelfLink = selfLink;\n        userGroupState.query = q;\n\n        this.host.sendAndWaitExpectSuccess(Operation\n                .createPost(postUserGroupsUri)\n                .setBody(userGroupState));\n        return selfLink;\n    }\n\n    public String createResourceGroup(ServiceHost target, String name, Query q) throws Throwable {\n        URI postResourceGroupsUri =\n                UriUtils.buildUri(target, ServiceUriPaths.CORE_AUTHZ_RESOURCE_GROUPS);\n        String selfLink =\n                UriUtils.extendUri(postResourceGroupsUri, name).getPath();\n\n        ResourceGroupState resourceGroupState = new ResourceGroupState();\n        resourceGroupState.documentSelfLink = selfLink;\n        resourceGroupState.query = q;\n        this.host.sendAndWaitExpectSuccess(Operation\n                .createPost(postResourceGroupsUri)\n                .setBody(resourceGroupState));\n        return selfLink;\n    }\n\n    public String createRole(ServiceHost target, String userGroupLink, String resourceGroupLink, Set<Action> verbs) throws Throwable {\n        // Build selfLink from user group, resource group, and verbs\n        String userGroupSegment = userGroupLink.substring(userGroupLink.lastIndexOf('/') + 1);\n        String resourceGroupSegment = resourceGroupLink.substring(resourceGroupLink.lastIndexOf('/') + 1);\n        String verbSegment = \"\";\n        for (Action a : verbs) {\n            if (verbSegment.isEmpty()) {\n                verbSegment = a.toString();\n            } else {\n                verbSegment += \"+\" + a.toString();\n            }\n        }\n        String selfLink = userGroupSegment + \"-\" + resourceGroupSegment + \"-\" + verbSegment;\n\n        RoleState roleState = new RoleState();\n        roleState.documentSelfLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_ROLES, selfLink);\n        roleState.userGroupLink = userGroupLink;\n        roleState.resourceGroupLink = resourceGroupLink;\n        roleState.verbs = verbs;\n        roleState.policy = Policy.ALLOW;\n        this.host.sendAndWaitExpectSuccess(Operation\n                .createPost(UriUtils.buildUri(target, ServiceUriPaths.CORE_AUTHZ_ROLES))\n                .setBody(roleState));\n        return roleState.documentSelfLink;\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common.test;\n\nimport static java.util.function.Function.identity;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toMap;\nimport static java.util.stream.Collectors.toSet;\nimport static javax.xml.bind.DatatypeConverter.printBase64Binary;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URI;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.logging.Handler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.net.ssl.SSLContext;\nimport javax.xml.bind.DatatypeConverter;\n\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\nimport org.apache.lucene.store.LockObtainFailedException;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.Claims;\nimport com.vmware.xenon.common.CommandLineArgumentParser;\nimport com.vmware.xenon.common.DeferredResult;\nimport com.vmware.xenon.common.NodeSelectorService;\nimport com.vmware.xenon.common.NodeSelectorState;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Operation.OperationOption;\nimport com.vmware.xenon.common.Service;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceClient;\nimport com.vmware.xenon.common.ServiceConfigUpdateRequest;\nimport com.vmware.xenon.common.ServiceConfiguration;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceDocumentDescription;\nimport com.vmware.xenon.common.ServiceDocumentDescription.Builder;\nimport com.vmware.xenon.common.ServiceDocumentQueryResult;\nimport com.vmware.xenon.common.ServiceErrorResponse;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.ServiceStats;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.ServiceStatLogHistogram;\nimport com.vmware.xenon.common.TaskState;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.common.http.netty.NettyHttpServiceClient;\nimport com.vmware.xenon.common.serialization.KryoSerializers;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ConsistentHashingNodeSelectorService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.MinimalTestService.MinimalTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.NodeGroupService.JoinPeerRequest;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeGroupService.UpdateQuorumRequest;\nimport com.vmware.xenon.services.common.NodeGroupUtils;\nimport com.vmware.xenon.services.common.NodeState;\nimport com.vmware.xenon.services.common.NodeState.NodeOption;\nimport com.vmware.xenon.services.common.NodeState.NodeStatus;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification.QueryOption;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.QueryValidationTestService.NestedType;\nimport com.vmware.xenon.services.common.QueryValidationTestService.QueryValidationServiceState;\nimport com.vmware.xenon.services.common.ServiceHostLogService.LogServiceState;\nimport com.vmware.xenon.services.common.ServiceHostManagementService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.TaskService;\n\npublic class VerificationHost extends ExampleServiceHost {\n\n    public static final int FAST_MAINT_INTERVAL_MILLIS = 100;\n\n    public static final String LOCATION1 = \"L1\";\n    public static final String LOCATION2 = \"L2\";\n\n    private volatile TestContext context;\n\n    private int timeoutSeconds = 30;\n\n    private long testStartMicros;\n\n    private long testEndMicros;\n\n    private long expectedCompletionCount;\n\n    private Throwable failure;\n\n    private URI referer;\n\n    /**\n     * Command line argument. Comma separated list of one or more peer nodes to join through Nodes\n     * must be defined in URI form, e.g --peerNodes=http://192.168.1.59:8000,http://192.168.1.82\n     */\n    public String[] peerNodes;\n\n    /**\n     * Command line argument indicating this is a stress test\n     */\n    public boolean isStressTest;\n\n    /**\n     * Command line argument indicating this is a multi-location test\n     */\n    public boolean isMultiLocationTest;\n\n    /**\n     * Command line argument for test duration, set for long running tests\n     */\n    public long testDurationSeconds;\n\n    /**\n     * Command line argument\n     */\n    public long maintenanceIntervalMillis = FAST_MAINT_INTERVAL_MILLIS;\n\n    /**\n     * Command line argument\n     */\n    public String connectionTag;\n\n    private String lastTestName;\n\n    private TemporaryFolder temporaryFolder;\n\n    private TestRequestSender sender;\n\n    public static AtomicInteger hostNumber = new AtomicInteger();\n\n    public static VerificationHost create() {\n        return new VerificationHost();\n    }\n\n    public static VerificationHost create(Integer port) throws Exception {\n        ServiceHost.Arguments args = buildDefaultServiceHostArguments(port);\n        return initialize(new VerificationHost(), args);\n    }\n\n    public static ServiceHost.Arguments buildDefaultServiceHostArguments(Integer port) {\n        ServiceHost.Arguments args = new ServiceHost.Arguments();\n        args.id = \"host-\" + hostNumber.incrementAndGet();\n        args.port = port;\n        args.sandbox = null;\n        args.bindAddress = ServiceHost.LOOPBACK_ADDRESS;\n        return args;\n    }\n\n    public static VerificationHost create(ServiceHost.Arguments args)\n            throws Exception {\n        return initialize(new VerificationHost(), args);\n    }\n\n    public static VerificationHost initialize(VerificationHost h, ServiceHost.Arguments args)\n            throws Exception {\n\n        if (args.sandbox == null) {\n            h.setTemporaryFolder(new TemporaryFolder());\n            h.getTemporaryFolder().create();\n            args.sandbox = h.getTemporaryFolder().getRoot().toPath();\n        }\n\n        try {\n            h.initialize(args);\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n\n        h.sender = new TestRequestSender(h);\n        return h;\n    }\n\n    public static void createAndAttachSSLClient(ServiceHost h) throws Throwable {\n        // we create a random userAgent string to validate host to host communication when\n        // the client appears to be from an external, non-Xenon source.\n        ServiceClient client = NettyHttpServiceClient.create(UUID.randomUUID().toString(),\n                null,\n                h.getScheduledExecutor(), h);\n\n        SSLContext clientContext = SSLContext.getInstance(ServiceClient.TLS_PROTOCOL_NAME);\n        clientContext.init(null, InsecureTrustManagerFactory.INSTANCE.getTrustManagers(), null);\n        client.setSSLContext(clientContext);\n        h.setClient(client);\n\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        h.setCertificateFileReference(ssc.certificate().toURI());\n        h.setPrivateKeyFileReference(ssc.privateKey().toURI());\n    }\n\n    @Override\n    protected void configureLoggerFormatter(Logger logger) {\n        super.configureLoggerFormatter(logger);\n\n        // override with formatters for VerificationHost\n        // if custom formatter has already set, do NOT replace it.\n        for (Handler h : logger.getParent().getHandlers()) {\n            if (Objects.equals(h.getFormatter(), LOG_FORMATTER)) {\n                h.setFormatter(VerificationHostLogFormatter.NORMAL_FORMAT);\n            } else if (Objects.equals(h.getFormatter(), COLOR_LOG_FORMATTER)) {\n                h.setFormatter(VerificationHostLogFormatter.COLORED_FORMAT);\n            }\n        }\n    }\n\n    public void tearDown() {\n        stop();\n        TemporaryFolder tempFolder = this.getTemporaryFolder();\n        if (tempFolder != null) {\n            tempFolder.delete();\n        }\n    }\n\n    public Operation createServiceStartPost(TestContext ctx) {\n        Operation post = Operation.createPost(null);\n        post.setUri(UriUtils.buildUri(this, \"service/\" + post.getId()));\n        return post.setCompletion(ctx.getCompletion());\n    }\n\n    public CompletionHandler getCompletion() {\n        return (o, e) -> {\n            if (e != null) {\n                failIteration(e);\n                return;\n            }\n            completeIteration();\n        };\n    }\n\n    public <T> BiConsumer<T, ? super Throwable> getCompletionDeferred() {\n        return (ignore, e) -> {\n            if (e != null) {\n                if (e instanceof CompletionException) {\n                    e = e.getCause();\n                }\n                failIteration(e);\n                return;\n            }\n            completeIteration();\n        };\n    }\n\n    public CompletionHandler getExpectedFailureCompletion() {\n        return getExpectedFailureCompletion(null);\n    }\n\n    public CompletionHandler getExpectedFailureCompletion(Integer statusCode) {\n        return (o, e) -> {\n            if (e == null) {\n                failIteration(new IllegalStateException(\"Failure expected\"));\n                return;\n            }\n\n            if (statusCode != null) {\n                if (!statusCode.equals(o.getStatusCode())) {\n                    failIteration(new IllegalStateException(\n                            \"Expected different status code \"\n                                    + statusCode + \" got \" + o.getStatusCode()));\n                    return;\n                }\n            }\n\n            if (e instanceof TimeoutException) {\n                if (o.getStatusCode() != Operation.STATUS_CODE_TIMEOUT) {\n                    failIteration(new IllegalArgumentException(\n                            \"TImeout exception did not have timeout status code\"));\n                    return;\n                }\n            }\n\n            if (o.hasBody()) {\n                ServiceErrorResponse rsp = o.getBody(ServiceErrorResponse.class);\n                if (rsp.message != null && rsp.message.toLowerCase().contains(\"timeout\")\n                        && rsp.statusCode != Operation.STATUS_CODE_TIMEOUT) {\n                    failIteration(new IllegalArgumentException(\n                            \"Service error response did not have timeout status code:\"\n                                    + Utils.toJsonHtml(rsp)));\n                    return;\n                }\n\n            }\n\n            completeIteration();\n        };\n    }\n\n    public VerificationHost setTimeoutSeconds(int seconds) {\n        this.timeoutSeconds = seconds;\n        if (this.sender != null) {\n            this.sender.setTimeout(Duration.ofSeconds(seconds));\n        }\n        return this;\n    }\n\n    public int getTimeoutSeconds() {\n        return this.timeoutSeconds;\n    }\n\n    public void send(Operation op) {\n        op.setReferer(getReferer());\n        super.sendRequest(op);\n    }\n\n    @Override\n    public DeferredResult<Operation> sendWithDeferredResult(Operation operation) {\n        operation.setReferer(getReferer());\n        return super.sendWithDeferredResult(operation);\n    }\n\n    @Override\n    public <T> DeferredResult<T> sendWithDeferredResult(Operation operation, Class<T> resultType) {\n        operation.setReferer(getReferer());\n        return super.sendWithDeferredResult(operation, resultType);\n    }\n\n    /**\n     * Creates a test wait context that can be nested and isolated from other wait contexts\n     */\n    public TestContext testCreate(int c) {\n        return TestContext.create(c, TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n    }\n\n    /**\n     * Creates a test wait context that can be nested and isolated from other wait contexts\n     */\n    public TestContext testCreate(long c) {\n        return testCreate((int) c);\n    }\n\n    /**\n     * Starts a test context used for a single synchronous test execution for the entire host\n     * @param c Expected completions\n     */\n    public void testStart(long c) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use testCreate on singleton, shared host instances\");\n        }\n        String testName = buildTestNameFromStack();\n        testStart(\n                testName,\n                EnumSet.noneOf(TestProperty.class), c);\n    }\n\n    public String buildTestNameFromStack() {\n        StackTraceElement[] stack = new Exception().getStackTrace();\n        String rootTestMethod = \"\";\n        for (StackTraceElement s : stack) {\n            if (s.getClassName().contains(\"vmware\")) {\n                rootTestMethod = s.getMethodName();\n            }\n        }\n        String testName = rootTestMethod + \":\" + stack[2].getMethodName();\n        return testName;\n    }\n\n    public void testStart(String testName, EnumSet<TestProperty> properties, long c) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        if (this.context != null) {\n            throw new IllegalStateException(\"A test is already started\");\n        }\n\n        String negative = properties != null && properties.contains(TestProperty.FORCE_FAILURE)\n                ? \"(NEGATIVE)\"\n                : \"\";\n        if (c > 1) {\n            log(\"%sTest %s, iterations %d, started\", negative, testName, c);\n        }\n        this.failure = null;\n        this.expectedCompletionCount = c;\n        this.testStartMicros = Utils.getNowMicrosUtc();\n        this.context = TestContext.create((int) c, TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n    }\n\n    public void completeIteration() {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        TestContext ctx = this.context;\n\n        if (ctx == null) {\n            String error = \"testStart() and testWait() not paired properly\" +\n                    \" or testStart(N) was called with N being less than actual completions\";\n            log(error);\n            return;\n        }\n        ctx.completeIteration();\n    }\n\n    public void failIteration(Throwable e) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        if (isStopping()) {\n            log(\"Received completion after stop\");\n            return;\n        }\n\n        TestContext ctx = this.context;\n\n        if (ctx == null) {\n            log(\"Test finished, ignoring completion. This might indicate wrong count was used in testStart(count)\");\n            return;\n        }\n\n        log(\"test failed: %s\", e.toString());\n        ctx.failIteration(e);\n    }\n\n    public void testWait(TestContext ctx) {\n        ctx.await();\n    }\n\n    public void testWait() {\n        testWait(new Exception().getStackTrace()[1].getMethodName(),\n                this.timeoutSeconds);\n    }\n\n    public void testWait(int timeoutSeconds) {\n        testWait(new Exception().getStackTrace()[1].getMethodName(), timeoutSeconds);\n    }\n\n    public void testWait(String testName, int timeoutSeconds) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n\n        TestContext ctx = this.context;\n        if (ctx == null) {\n            throw new IllegalStateException(\"testStart() was not called before testWait()\");\n        }\n\n        if (this.expectedCompletionCount > 1) {\n            log(\"Test %s, iterations %d, waiting ...\", testName,\n                    this.expectedCompletionCount);\n        }\n\n        try {\n            ctx.await();\n            this.testEndMicros = Utils.getNowMicrosUtc();\n            if (this.expectedCompletionCount > 1) {\n                log(\"Test %s, iterations %d, complete!\", testName,\n                        this.expectedCompletionCount);\n            }\n        } finally {\n            this.context = null;\n            this.lastTestName = testName;\n        }\n    }\n\n    public double calculateThroughput() {\n        double t = this.testEndMicros - this.testStartMicros;\n        t /= 1000000.0;\n        t = this.expectedCompletionCount / t;\n        return t;\n    }\n\n    public long computeIterationsFromMemory(int serviceCount) {\n        return computeIterationsFromMemory(EnumSet.noneOf(TestProperty.class), serviceCount);\n    }\n\n    public long computeIterationsFromMemory(EnumSet<TestProperty> props, int serviceCount) {\n        long total = Runtime.getRuntime().totalMemory();\n\n        total /= 512;\n        total /= serviceCount;\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        if (props.contains(TestProperty.FORCE_REMOTE)) {\n            total /= 5;\n        }\n\n        if (props.contains(TestProperty.PERSISTED)) {\n            total /= 5;\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)\n                || props.contains(TestProperty.EXPECT_FAILURE)) {\n            total = 10;\n        }\n\n        if (!this.isStressTest) {\n            total /= 100;\n            total = Math.max(Runtime.getRuntime().availableProcessors() * 16, total);\n        }\n        total = Math.max(1, total);\n\n        if (props.contains(TestProperty.SINGLE_ITERATION)) {\n            total = 1;\n        }\n\n        return total;\n    }\n\n    public void logThroughput() {\n        log(\"Test %s iterations per second: %f\", this.lastTestName, calculateThroughput());\n        logMemoryInfo();\n    }\n\n    public void log(String fmt, Object... args) {\n        super.log(Level.INFO, 3, fmt, args);\n    }\n\n    public ServiceDocument buildMinimalTestState() {\n        return buildMinimalTestState(20);\n    }\n\n    public MinimalTestServiceState buildMinimalTestState(int bytes) {\n        MinimalTestServiceState minState = new MinimalTestServiceState();\n        minState.id = Utils.getNowMicrosUtc() + \"\";\n        byte[] body = new byte[bytes];\n        new Random().nextBytes(body);\n        minState.stringValue = DatatypeConverter.printBase64Binary(body);\n        return minState;\n    }\n\n    public CompletableFuture<Operation> sendWithFuture(Operation op) {\n        if (op.getCompletion() != null) {\n            throw new IllegalStateException(\"completion handler must not be set\");\n        }\n\n        CompletableFuture<Operation> res = new CompletableFuture<>();\n        op.setCompletion((o, e) -> {\n            if (e != null) {\n                res.completeExceptionally(e);\n            } else {\n                res.complete(o);\n            }\n        });\n\n        this.send(op);\n\n        return res;\n    }\n\n    /**\n     * Use built in Java synchronous HTTP client to verify DCP HttpListener is compliant\n     */\n    public String sendWithJavaClient(URI serviceUri, String contentType, String body)\n            throws IOException {\n        URL url = serviceUri.toURL();\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setDoInput(true);\n\n        connection.addRequestProperty(Operation.CONTENT_TYPE_HEADER, contentType);\n        if (body != null) {\n            connection.setDoOutput(true);\n            connection.getOutputStream().write(body.getBytes(Utils.CHARSET));\n        }\n\n        BufferedReader in = null;\n        try {\n            try {\n                in = new BufferedReader(\n                        new InputStreamReader(\n                                connection.getInputStream(), Utils.CHARSET));\n\n            } catch (Throwable e) {\n                InputStream errorStream = connection.getErrorStream();\n                if (errorStream != null) {\n                    in = new BufferedReader(\n                            new InputStreamReader(errorStream, Utils.CHARSET));\n                }\n            }\n            StringBuilder stringResponseBuilder = new StringBuilder();\n\n            if (in == null) {\n                return \"\";\n            }\n            do {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                stringResponseBuilder.append(line);\n            } while (true);\n\n            return stringResponseBuilder.toString();\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    public URI createQueryTaskService(QueryTask create) {\n        return createQueryTaskService(create, false);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote) {\n        return createQueryTaskService(create, forceRemote, false, null, null);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote, String sourceLink) {\n        return createQueryTaskService(create, forceRemote, false, null, sourceLink);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote, boolean isDirect,\n            QueryTask taskResult,\n            String sourceLink) {\n        return createQueryTaskService(null, create, forceRemote, isDirect, taskResult, sourceLink);\n    }\n\n    public URI createQueryTaskService(URI factoryUri, QueryTask create, boolean forceRemote,\n            boolean isDirect,\n            QueryTask taskResult,\n            String sourceLink) {\n\n        if (create.documentExpirationTimeMicros == 0) {\n            create.documentExpirationTimeMicros = Utils.getNowMicrosUtc()\n                    + this.getOperationTimeoutMicros();\n        }\n\n        if (factoryUri == null) {\n            VerificationHost h = this;\n            if (!getInProcessHostMap().isEmpty()) {\n                // pick one host to create the query task\n                h = getInProcessHostMap().values().iterator().next();\n            }\n            factoryUri = UriUtils.buildUri(h, ServiceUriPaths.CORE_QUERY_TASKS);\n        }\n        create.documentSelfLink = UUID.randomUUID().toString();\n        create.documentSourceLink = sourceLink;\n        create.taskInfo.isDirect = isDirect;\n        Operation startPost = Operation.createPost(factoryUri).setBody(create);\n\n        if (forceRemote) {\n            startPost.forceRemote();\n        }\n\n        log(\"Starting query with options:%s, resultLimit: %d\",\n                create.querySpec.options,\n                create.querySpec.resultLimit);\n\n        QueryTask result;\n        try {\n            result = this.sender.sendAndWait(startPost, QueryTask.class);\n        } catch (RuntimeException e) {\n            // throw original exception\n            throw ExceptionTestUtils.throwAsUnchecked(e.getSuppressed()[0]);\n        }\n\n        if (isDirect) {\n            taskResult.results = result.results;\n            taskResult.taskInfo.durationMicros = result.results.queryTimeMicros;\n        }\n\n        return UriUtils.extendUri(factoryUri, create.documentSelfLink);\n    }\n\n    public QueryTask waitForQueryTaskCompletion(QuerySpecification q, int totalDocuments,\n            int versionCount, URI u, boolean forceRemote, boolean deleteOnFinish) {\n        return waitForQueryTaskCompletion(q, totalDocuments, versionCount, u, forceRemote,\n                deleteOnFinish, true);\n    }\n\n    public boolean isOwner(String documentSelfLink, String nodeSelector) {\n        final boolean[] isOwner = new boolean[1];\n        TestContext ctx = this.testCreate(1);\n        Operation op = Operation\n                .createPost(null)\n                .setExpiration(Utils.getNowMicrosUtc() + TimeUnit.SECONDS.toMicros(10))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx.failIteration(e);\n                        return;\n                    }\n\n                    NodeSelectorService.SelectOwnerResponse rsp =\n                            o.getBody(NodeSelectorService.SelectOwnerResponse.class);\n                    isOwner[0] = rsp.isLocalHostOwner;\n                    ctx.completeIteration();\n                });\n        this.selectOwner(nodeSelector, documentSelfLink, op);\n        ctx.await();\n\n        return isOwner[0];\n    }\n\n    public QueryTask waitForQueryTaskCompletion(QuerySpecification q, int totalDocuments,\n            int versionCount, URI u, boolean forceRemote, boolean deleteOnFinish,\n            boolean throwOnFailure) {\n\n        long startNanos = System.nanoTime();\n        if (q.options == null) {\n            q.options = EnumSet.noneOf(QueryOption.class);\n        }\n\n        EnumSet<TestProperty> props = EnumSet.noneOf(TestProperty.class);\n        if (forceRemote) {\n            props.add(TestProperty.FORCE_REMOTE);\n        }\n        waitFor(\"Query did not complete in time\", () -> {\n            QueryTask taskState = getServiceState(props, QueryTask.class, u);\n            return taskState.taskInfo.stage == TaskState.TaskStage.FINISHED\n                    || taskState.taskInfo.stage == TaskState.TaskStage.FAILED\n                    || taskState.taskInfo.stage == TaskState.TaskStage.CANCELLED;\n        });\n\n        QueryTask latestTaskState = getServiceState(props, QueryTask.class, u);\n\n        // Throw if task was expected to be successful\n        if (throwOnFailure && (latestTaskState.taskInfo.stage == TaskState.TaskStage.FAILED)) {\n            throw new IllegalStateException(Utils.toJsonHtml(latestTaskState.taskInfo.failure));\n        }\n\n        if (totalDocuments * versionCount > 1) {\n            long endNanos = System.nanoTime();\n            double deltaSeconds = endNanos - startNanos;\n            deltaSeconds /= TimeUnit.SECONDS.toNanos(1);\n            double thpt = totalDocuments / deltaSeconds;\n            log(\"Options: %s.  Throughput (documents / sec): %f\", q.options.toString(), thpt);\n        }\n\n        // Delete task, if not direct\n        if (latestTaskState.taskInfo.isDirect) {\n            return latestTaskState;\n        }\n\n        if (deleteOnFinish) {\n            send(Operation.createDelete(u).setBody(new ServiceDocument()));\n        }\n\n        return latestTaskState;\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(\n            String fieldName, String fieldValue, long documentCount, long expectedResultCount) {\n        return createAndWaitSimpleDirectQuery(this.getUri(), fieldName, fieldValue, documentCount,\n                expectedResultCount);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(URI hostUri,\n            String fieldName, String fieldValue, long documentCount, long expectedResultCount) {\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(fieldName).setTermMatchValue(fieldValue);\n        return createAndWaitSimpleDirectQuery(hostUri, q,\n                documentCount, expectedResultCount);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(\n            QueryTask.QuerySpecification spec,\n            long documentCount, long expectedResultCount) {\n        return createAndWaitSimpleDirectQuery(this.getUri(), spec,\n                documentCount, expectedResultCount);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(URI hostUri,\n            QueryTask.QuerySpecification spec, long documentCount, long expectedResultCount) {\n        long start = Utils.getNowMicrosUtc();\n\n        QueryTask[] tasks = new QueryTask[1];\n        waitFor(\"\", () -> {\n            QueryTask task = QueryTask.create(spec).setDirect(true);\n            createQueryTaskService(UriUtils.buildUri(hostUri, ServiceUriPaths.CORE_QUERY_TASKS),\n                    task, false, true, task, null);\n            if (task.results.documentLinks.size() == expectedResultCount) {\n                tasks[0] = task;\n                return true;\n            }\n            log(\"Expected %d, got %d, Query task: %s\", expectedResultCount,\n                    task.results.documentLinks.size(), task);\n            return false;\n        });\n\n        QueryTask resultTask = tasks[0];\n\n        assertTrue(\n                String.format(\"Got %d links, expected %d\", resultTask.results.documentLinks.size(),\n                        expectedResultCount),\n                resultTask.results.documentLinks.size() == expectedResultCount);\n        long end = Utils.getNowMicrosUtc();\n        double delta = (end - start) / 1000000.0;\n        double thpt = documentCount / delta;\n        log(\"Document count: %d, Expected match count: %d, Documents / sec: %f\",\n                documentCount, expectedResultCount, thpt);\n        return resultTask.results;\n    }\n\n    public void validatePermanentServiceDocumentDeletion(String linkPrefix, long count,\n            boolean failOnMismatch)\n            throws Throwable {\n        long start = Utils.getNowMicrosUtc();\n\n        while (Utils.getNowMicrosUtc() - start < this.getOperationTimeoutMicros()) {\n            QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n            q.query = new QueryTask.Query()\n                    .setTermPropertyName(ServiceDocument.FIELD_NAME_SELF_LINK)\n                    .setTermMatchType(MatchType.WILDCARD)\n                    .setTermMatchValue(linkPrefix + UriUtils.URI_WILDCARD_CHAR);\n\n            URI u = createQueryTaskService(QueryTask.create(q), false);\n            QueryTask finishedTaskState = waitForQueryTaskCompletion(q,\n                    (int) count, (int) count, u, false, true);\n            if (finishedTaskState.results.documentLinks.size() == count) {\n                return;\n            }\n            log(\"got %d links back, expected %d: %s\",\n                    finishedTaskState.results.documentLinks.size(), count,\n                    Utils.toJsonHtml(finishedTaskState));\n\n            if (!failOnMismatch) {\n                return;\n            }\n            Thread.sleep(100);\n        }\n        if (failOnMismatch) {\n            throw new TimeoutException();\n        }\n    }\n\n    public String sendHttpRequest(ServiceClient client, String uri, String requestBody, int count) {\n\n        Object[] rspBody = new Object[1];\n        TestContext ctx = testCreate(count);\n        Operation op = Operation.createGet(URI.create(uri)).setCompletion(\n                (o, e) -> {\n                    if (e != null) {\n                        ctx.failIteration(e);\n                        return;\n                    }\n                    rspBody[0] = o.getBodyRaw();\n                    ctx.completeIteration();\n                });\n\n        if (requestBody != null) {\n            op.setAction(Action.POST).setBody(requestBody);\n        }\n\n        op.setExpiration(Utils.getNowMicrosUtc() + getOperationTimeoutMicros());\n        op.setReferer(getReferer());\n        ServiceClient c = client != null ? client : getClient();\n        for (int i = 0; i < count; i++) {\n            c.send(op);\n        }\n        ctx.await();\n\n        String htmlResponse = (String) rspBody[0];\n        return htmlResponse;\n    }\n\n    public Operation sendUIHttpRequest(String uri, String requestBody, int count) {\n        Operation op = Operation.createGet(URI.create(uri));\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            ops.add(op);\n        }\n        List<Operation> responses = this.sender.sendAndWait(ops);\n        return responses.get(0);\n    }\n\n    public <T extends ServiceDocument> T getServiceState(EnumSet<TestProperty> props, Class<T> type,\n            URI uri) {\n        Map<URI, T> r = getServiceState(props, type, new URI[] { uri });\n        return r.values().iterator().next();\n    }\n\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type,\n            Collection<URI> uris) {\n        URI[] array = new URI[uris.size()];\n        int i = 0;\n        for (URI u : uris) {\n            array[i++] = u;\n        }\n        return getServiceState(props, type, array);\n    }\n\n    public <T extends TaskService.TaskServiceState> T getServiceStateUsingQueryTask(\n            Class<T> type, String uri) {\n        QueryTask.Query q = QueryTask.Query.Builder.create()\n                .setTerm(ServiceDocument.FIELD_NAME_SELF_LINK, uri)\n                .build();\n\n        QueryTask queryTask = new QueryTask();\n        queryTask.querySpec = new QueryTask.QuerySpecification();\n        queryTask.querySpec.query = q;\n        queryTask.querySpec.options.add(QueryOption.EXPAND_CONTENT);\n\n        this.createQueryTaskService(null, queryTask, false, true, queryTask, null);\n        return Utils.fromJson(queryTask.results.documents.get(uri), type);\n    }\n\n    /**\n     * Retrieve in parallel, state from N services. This method will block execution until responses\n     * are received or a failure occurs. It is not optimized for throughput measurements\n     *\n     * @param type\n     * @param uris\n     */\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type, URI... uris) {\n\n        if (type == null) {\n            throw new IllegalArgumentException(\"type is required\");\n        }\n\n        if (uris == null || uris.length == 0) {\n            throw new IllegalArgumentException(\"uris are required\");\n        }\n\n        List<Operation> ops = new ArrayList<>();\n        for (URI u : uris) {\n            Operation get = Operation.createGet(u).setReferer(getReferer());\n            if (props != null && props.contains(TestProperty.FORCE_REMOTE)) {\n                get.forceRemote();\n            }\n            if (props != null && props.contains(TestProperty.HTTP2)) {\n                get.setConnectionSharing(true);\n            }\n\n            if (props != null && props.contains(TestProperty.DISABLE_CONTEXT_ID_VALIDATION)) {\n                get.setContextId(TestProperty.DISABLE_CONTEXT_ID_VALIDATION.toString());\n            }\n\n            ops.add(get);\n        }\n\n        Map<URI, T> results = new HashMap<>();\n\n        List<Operation> responses = this.sender.sendAndWait(ops);\n        for (Operation response : responses) {\n            T doc = response.getBody(type);\n            results.put(UriUtils.buildUri(response.getUri(), doc.documentSelfLink), doc);\n        }\n\n        return results;\n    }\n\n    /**\n     * Retrieve in parallel, state from N services. This method will block execution until responses\n     * are received or a failure occurs. It is not optimized for throughput measurements\n     */\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type,\n            List<Service> services) {\n        URI[] uris = new URI[services.size()];\n        int i = 0;\n        for (Service s : services) {\n            uris[i++] = s.getUri();\n        }\n        return this.getServiceState(props, type, uris);\n    }\n\n    public ServiceDocumentQueryResult getFactoryState(URI factoryUri) {\n        return this.getServiceState(null, ServiceDocumentQueryResult.class, factoryUri);\n    }\n\n    public ServiceDocumentQueryResult getExpandedFactoryState(URI factoryUri) {\n        factoryUri = UriUtils.buildExpandLinksQueryUri(factoryUri);\n        return this.getServiceState(null, ServiceDocumentQueryResult.class, factoryUri);\n    }\n\n    public Map<String, ServiceStat> getServiceStats(URI serviceUri) {\n        ServiceStats stats = this.getServiceState(\n                null, ServiceStats.class, UriUtils.buildStatsUri(serviceUri));\n        return stats.entries;\n    }\n\n    public void doExampleServiceUpdateAndQueryByVersion(URI hostUri, int serviceCount) {\n        Consumer<Operation> bodySetter = (o) -> {\n            ExampleServiceState s = new ExampleServiceState();\n            s.name = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> services = doFactoryChildServiceStart(null,\n                serviceCount,\n                ExampleServiceState.class, bodySetter,\n                UriUtils.buildUri(hostUri, ExampleService.FACTORY_LINK));\n\n        Map<URI, ExampleServiceState> statesBeforeUpdate = getServiceState(null,\n                ExampleServiceState.class, services.keySet());\n\n        for (ExampleServiceState state : statesBeforeUpdate.values()) {\n            assertEquals(state.documentVersion, 0);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, null,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 1L,\n                    null);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 10L,\n                    null);\n        }\n\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        doServiceUpdates(services.keySet(), Action.PUT, body);\n        Map<URI, ExampleServiceState> statesAfterPut = getServiceState(null,\n                ExampleServiceState.class, services.keySet());\n\n        for (ExampleServiceState state : statesAfterPut.values()) {\n            assertEquals(state.documentVersion, 1);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 1L,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, null,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 10L,\n                    null);\n        }\n\n        doServiceUpdates(services.keySet(), Action.DELETE, body);\n\n        for (ExampleServiceState state : statesAfterPut.values()) {\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 1L,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE, 2L,\n                    2L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE,\n                    null, 2L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE,\n                    10L, null);\n        }\n    }\n\n    private void doServiceUpdates(Collection<URI> serviceUris, Action action,\n            ServiceDocument body) {\n        List<Operation> ops = new ArrayList<>();\n        for (URI u : serviceUris) {\n            Operation update = Operation.createPost(u)\n                    .setAction(action)\n                    .setBody(body);\n            ops.add(update);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    private void queryDocumentIndexByVersionAndVerify(URI hostUri, String selfLink,\n            Action expectedAction,\n            Long version,\n            Long latestVersion) {\n\n        URI localQueryUri = UriUtils.buildDefaultDocumentQueryUri(\n                hostUri,\n                selfLink,\n                false,\n                true,\n                ServiceOption.PERSISTENCE);\n\n        if (version != null) {\n            localQueryUri = UriUtils.appendQueryParam(localQueryUri,\n                    ServiceDocument.FIELD_NAME_VERSION,\n                    Long.toString(version));\n        }\n\n        Operation remoteGet = Operation.createGet(localQueryUri);\n        Operation result = this.sender.sendAndWait(remoteGet);\n        if (latestVersion == null) {\n            assertFalse(\"Document not expected\", result.hasBody());\n            return;\n        }\n\n        ServiceDocument doc = result.getBody(ServiceDocument.class);\n        int expectedVersion = version == null ? latestVersion.intValue() : version.intValue();\n        assertEquals(\"Invalid document version returned\", doc.documentVersion, expectedVersion);\n\n        String action = doc.documentUpdateAction;\n        assertEquals(\"Invalid document update action returned:\" + action, expectedAction.name(),\n                action);\n\n    }\n\n    public <T> void doPutPerService(List<Service> services)\n            throws Throwable {\n        doPutPerService(EnumSet.noneOf(TestProperty.class), services);\n    }\n\n    public <T> void doPutPerService(EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        doPutPerService(computeIterationsFromMemory(properties, services.size()),\n                properties,\n                services);\n    }\n\n    public <T> void doPatchPerService(long count,\n            EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        doServiceUpdates(Action.PATCH, count, properties, services);\n    }\n\n    public <T> void doPutPerService(long count, EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        doServiceUpdates(Action.PUT, count, properties, services);\n    }\n\n    public void doServiceUpdates(Action action, long count,\n            EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n\n        if (properties == null) {\n            properties = EnumSet.noneOf(TestProperty.class);\n        }\n\n        logMemoryInfo();\n        StackTraceElement[] e = new Exception().getStackTrace();\n        String testName = String.format(\n                \"Parent: %s, %s test with properties %s, service caps: %s\",\n                e[1].getMethodName(),\n                action, properties.toString(), services.get(0).getOptions());\n\n        Map<URI, MinimalTestServiceState> statesBeforeUpdate = getServiceState(properties,\n                MinimalTestServiceState.class, services);\n\n\n        long startTimeMicros = System.nanoTime() / 1000;\n        TestContext ctx = testCreate(count * services.size());\n        ctx.setTestName(testName);\n        ctx.logBefore();\n\n        // create a template PUT. Each operation instance is cloned on send, so\n        // we can re-use across services\n        Operation updateOp = Operation.createPut(null).setCompletion(ctx.getCompletion());\n\n        updateOp.setAction(action);\n\n        if (properties.contains(TestProperty.FORCE_REMOTE)) {\n            updateOp.forceRemote();\n        }\n        MinimalTestServiceState body = (MinimalTestServiceState) buildMinimalTestState();\n        byte[] binaryBody = null;\n\n        // put random values in core document properties to verify they are\n        // ignored\n        if (!this.isStressTest()) {\n            body.documentSelfLink = UUID.randomUUID().toString();\n            body.documentKind = UUID.randomUUID().toString();\n        } else {\n            body.stringValue = UUID.randomUUID().toString();\n            body.id = UUID.randomUUID().toString();\n            body.responseDelay = 10;\n            body.documentVersion = 10;\n            body.documentEpoch = 10L;\n            body.documentOwner = UUID.randomUUID().toString();\n        }\n\n        if (properties.contains(TestProperty.SET_EXPIRATION)) {\n            // set expiration to the maintenance interval, which should already be very small\n            // when the caller sets this test property\n            body.documentExpirationTimeMicros = Utils.getNowMicrosUtc()\n                    + this.getMaintenanceIntervalMicros();\n        }\n\n        final int maxByteCount = 256 * 1024;\n        if (properties.contains(TestProperty.LARGE_PAYLOAD)) {\n            Random r = new Random();\n            int byteCount = getClient().getRequestPayloadSizeLimit() / 4;\n            if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n                if (properties.contains(TestProperty.FORCE_FAILURE)) {\n                    byteCount = getClient().getRequestPayloadSizeLimit() * 2;\n                } else {\n                    // make sure we do not blow memory if max request size is high\n                    byteCount = Math.min(maxByteCount, byteCount);\n                }\n            } else {\n                byteCount = maxByteCount;\n            }\n            byte[] data = new byte[byteCount];\n            r.nextBytes(data);\n            if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n                binaryBody = data;\n            } else {\n                body.stringValue = printBase64Binary(data);\n            }\n        }\n\n        if (properties.contains(TestProperty.HTTP2)) {\n            updateOp.setConnectionSharing(true);\n        }\n\n        if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n            updateOp.setContentType(Operation.MEDIA_TYPE_APPLICATION_OCTET_STREAM);\n            updateOp.setCompletion((o, eb) -> {\n                if (eb != null) {\n                    ctx.fail(eb);\n                    return;\n                }\n\n                if (!Operation.MEDIA_TYPE_APPLICATION_OCTET_STREAM.equals(o.getContentType())) {\n                    ctx.fail(new IllegalArgumentException(\"unexpected content type: \"\n                            + o.getContentType()));\n                    return;\n                }\n                ctx.complete();\n            });\n\n        }\n\n        boolean isFailureExpected = false;\n        if (properties.contains(TestProperty.FORCE_FAILURE)\n                || properties.contains(TestProperty.EXPECT_FAILURE)) {\n            toggleNegativeTestMode(true);\n            isFailureExpected = true;\n\n            if (properties.contains(TestProperty.LARGE_PAYLOAD)) {\n                updateOp.setCompletion((o, ex) -> {\n                    if (ex == null) {\n                        ctx.fail(new IllegalStateException(\"expected failure\"));\n                    } else {\n                        ctx.complete();\n                    }\n                });\n            } else {\n                updateOp.setCompletion((o, ex) -> {\n                    if (ex == null) {\n                        ctx.fail(new IllegalStateException(\"failure expected\"));\n                        return;\n                    }\n\n                    MinimalTestServiceErrorResponse rsp = o\n                            .getBody(MinimalTestServiceErrorResponse.class);\n                    if (!MinimalTestServiceErrorResponse.KIND.equals(rsp.documentKind)) {\n                        ctx.fail(new IllegalStateException(\"Response not expected:\"\n                                + Utils.toJson(rsp)));\n                        return;\n                    }\n                    ctx.complete();\n                });\n            }\n        }\n\n        int byteCount = Utils.toJson(body).getBytes(Utils.CHARSET).length;\n        if (properties.contains(TestProperty.BINARY_SERIALIZATION)) {\n            long c = KryoSerializers.serializeDocument(body, 4096).position();\n            byteCount = (int) c;\n        }\n        log(\"Bytes per payload %s\", byteCount);\n\n        boolean isConcurrentSend = properties.contains(TestProperty.CONCURRENT_SEND);\n        final boolean isFailureExpectedFinal = isFailureExpected;\n\n        for (Service s : services) {\n            if (properties.contains(TestProperty.FORCE_REMOTE)) {\n                updateOp.setConnectionTag(this.connectionTag);\n            }\n\n            long[] expectedVersion = new long[1];\n            if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                // we have to serialize requests and properly set version to match expected current\n                // version\n                MinimalTestServiceState initialState = statesBeforeUpdate.get(s.getUri());\n                expectedVersion[0] = isFailureExpected ? Integer.MAX_VALUE\n                        : initialState.documentVersion;\n            }\n\n            URI sUri = s.getUri();\n            updateOp.setUri(sUri).setReferer(getReferer());\n\n            for (int i = 0; i < count; i++) {\n                if (!isFailureExpected) {\n                    body.id = \"\" + i;\n                } else if (!properties.contains(TestProperty.LARGE_PAYLOAD)) {\n                    body.id = null;\n                }\n\n                CountDownLatch[] l = new CountDownLatch[1];\n                if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                    // only used for strict update checking, serialized requests\n                    l[0] = new CountDownLatch(1);\n                    // we have to serialize requests and properly set version\n                    body.documentVersion = expectedVersion[0];\n                    updateOp.setCompletion((o, ex) -> {\n                        if (ex == null || isFailureExpectedFinal) {\n                            MinimalTestServiceState rsp = o.getBody(MinimalTestServiceState.class);\n                            expectedVersion[0] = rsp.documentVersion;\n                            ctx.complete();\n                            l[0].countDown();\n                            return;\n                        }\n                        ctx.fail(ex);\n                        l[0].countDown();\n                    });\n                }\n\n                Object b = binaryBody != null ? binaryBody : body;\n                if (properties.contains(TestProperty.BINARY_SERIALIZATION)) {\n                    // provide hints to runtime on how to serialize the body,\n                    // using binary serialization and a buffer size equal to content length\n                    updateOp.setContentLength(byteCount);\n                    updateOp.setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM);\n                }\n\n                if (isConcurrentSend) {\n                    Operation putClone = updateOp.clone();\n                    putClone.setBody(b).setUri(sUri);\n                    run(() -> {\n                        send(putClone);\n                    });\n                } else if (properties.contains(TestProperty.CALLBACK_SEND)) {\n                    updateOp.toggleOption(OperationOption.SEND_WITH_CALLBACK, true);\n                    send(updateOp.setBody(b));\n                } else {\n                    send(updateOp.setBody(b));\n                }\n                if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                    // we have to serialize requests and properly set version\n                    if (!isFailureExpected) {\n                        l[0].await();\n                    }\n                    if (this.failure != null) {\n                        throw this.failure;\n                    }\n\n                }\n            }\n        }\n\n        testWait(ctx);\n        ctx.logAfter();\n\n        if (isFailureExpected) {\n            this.toggleNegativeTestMode(false);\n            return;\n        }\n\n        if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n            return;\n        }\n\n        List<URI> getUris = new ArrayList<>();\n        if (services.get(0).hasOption(ServiceOption.PERSISTENCE)) {\n            for (Service s : services) {\n                // bypass the services, which rely on caching, and go straight to the index\n                URI u = UriUtils.buildDocumentQueryUri(this, s.getSelfLink(), true, false,\n                        ServiceOption.PERSISTENCE);\n                getUris.add(u);\n\n            }\n        } else {\n            for (Service s : services) {\n                getUris.add(s.getUri());\n            }\n        }\n\n        Map<URI, MinimalTestServiceState> statesAfterUpdate = getServiceState(\n                properties,\n                MinimalTestServiceState.class, getUris);\n\n        for (MinimalTestServiceState st : statesAfterUpdate.values()) {\n            URI serviceUri = UriUtils.buildUri(this, st.documentSelfLink);\n            ServiceDocument beforeSt = statesBeforeUpdate.get(serviceUri);\n            long expectedVersion = beforeSt.documentVersion + count;\n            if (st.documentVersion != expectedVersion) {\n                QueryTestUtils.logVersionInfoForService(this.sender, serviceUri, expectedVersion);\n                throw new IllegalStateException(\"got \" + st.documentVersion + \", expected \"\n                        + (beforeSt.documentVersion + count));\n            }\n            assertTrue(st.documentVersion == beforeSt.documentVersion + count);\n            assertTrue(st.id != null);\n            assertTrue(st.documentSelfLink != null\n                    && st.documentSelfLink.equals(beforeSt.documentSelfLink));\n            assertTrue(st.documentKind != null\n                    && st.documentKind.equals(Utils.buildKind(MinimalTestServiceState.class)));\n            assertTrue(st.documentUpdateTimeMicros > startTimeMicros);\n            assertTrue(st.documentUpdateAction != null);\n            assertTrue(st.documentUpdateAction.equals(action.toString()));\n        }\n\n        logMemoryInfo();\n\n    }\n\n    public void logMemoryInfo() {\n        log(\"Memory free:%d, available:%s, total:%s\", Runtime.getRuntime().freeMemory(),\n                Runtime.getRuntime().totalMemory(),\n                Runtime.getRuntime().maxMemory());\n    }\n\n    public URI getReferer() {\n        if (this.referer == null) {\n            this.referer = getUri();\n        }\n        return this.referer;\n    }\n\n    public void waitForServiceAvailable(String... links) {\n        for (String link : links) {\n            TestContext ctx = testCreate(1);\n            this.registerForServiceAvailability(ctx.getCompletion(), link);\n            ctx.await();\n        }\n    }\n\n    public void waitForReplicatedFactoryServiceAvailable(URI u) {\n        waitForReplicatedFactoryServiceAvailable(u, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n    }\n\n    public void waitForReplicatedFactoryServiceAvailable(URI u, String nodeSelectorPath) {\n        waitFor(\"replicated available check time out for \" + u, () -> {\n            boolean[] isReady = new boolean[1];\n            TestContext ctx = testCreate(1);\n            NodeGroupUtils.checkServiceAvailability((o, e) -> {\n                if (e != null) {\n                    isReady[0] = false;\n                    ctx.completeIteration();\n                    return;\n                }\n\n                isReady[0] = true;\n                ctx.completeIteration();\n            }, this, u, nodeSelectorPath);\n            ctx.await();\n            return isReady[0];\n        });\n    }\n\n    public void waitForServiceAvailable(URI u) {\n        boolean[] isReady = new boolean[1];\n        log(\"Starting /available check on %s\", u);\n        waitFor(\"available check timeout for \" + u, () -> {\n            TestContext ctx = testCreate(1);\n            URI available = UriUtils.buildAvailableUri(u);\n            Operation get = Operation.createGet(available).setCompletion((o, e) -> {\n                if (e != null) {\n                    // not ready\n                    isReady[0] = false;\n                    ctx.completeIteration();\n                    return;\n                }\n                isReady[0] = true;\n                ctx.completeIteration();\n                return;\n            });\n            send(get);\n            ctx.await();\n\n            if (isReady[0]) {\n                log(\"%s /available returned success\", get.getUri());\n                return true;\n            }\n            return false;\n        });\n    }\n\n    public <T extends ServiceDocument> Map<URI, T> doFactoryChildServiceStart(\n            EnumSet<TestProperty> props,\n            long c,\n            Class<T> bodyType,\n            Consumer<Operation> setInitialStateConsumer,\n            URI factoryURI) {\n        Map<URI, T> initialStates = new HashMap<>();\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        log(\"Sending %d POST requests to %s\", c, factoryURI);\n\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            Operation createPost = Operation.createPost(factoryURI);\n            // call callback to set the body\n            setInitialStateConsumer.accept(createPost);\n            if (props.contains(TestProperty.FORCE_REMOTE)) {\n                createPost.forceRemote();\n            }\n\n            ops.add(createPost);\n        }\n\n        List<T> responses = this.sender.sendAndWait(ops, bodyType);\n        Map<URI, T> docByChildURI = responses.stream().collect(\n                toMap(doc -> UriUtils.buildUri(factoryURI, doc.documentSelfLink), identity()));\n        initialStates.putAll(docByChildURI);\n        log(\"Done with %d POST requests to %s\", c, factoryURI);\n        return initialStates;\n    }\n\n    public List<Service> doThroughputServiceStart(long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove) throws Throwable {\n        return doThroughputServiceStart(EnumSet.noneOf(TestProperty.class), c, type, initialState,\n                options, null);\n    }\n\n    public List<Service> doThroughputServiceStart(\n            EnumSet<TestProperty> props,\n            long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove) throws Throwable {\n        return doThroughputServiceStart(props, c, type, initialState,\n                options, optionsToRemove, null);\n    }\n\n    public List<Service> doThroughputServiceStart(\n            EnumSet<TestProperty> props,\n            long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove,\n            Long maintIntervalMicros) throws Throwable {\n\n        List<Service> services = new ArrayList<>();\n\n        TestContext ctx = testCreate((int) c);\n        for (int i = 0; i < c; i++) {\n            Service e = type.newInstance();\n            if (options != null) {\n                for (Service.ServiceOption cap : options) {\n                    e.toggleOption(cap, true);\n                }\n            }\n            if (optionsToRemove != null) {\n                for (ServiceOption opt : optionsToRemove) {\n                    e.toggleOption(opt, false);\n                }\n            }\n\n            Operation post = createServiceStartPost(ctx);\n            if (initialState != null) {\n                post.setBody(initialState);\n            }\n\n            if (props != null && props.contains(TestProperty.SET_CONTEXT_ID)) {\n                post.setContextId(TestProperty.SET_CONTEXT_ID.toString());\n            }\n\n            if (maintIntervalMicros != null) {\n                e.setMaintenanceIntervalMicros(maintIntervalMicros);\n            }\n\n            startService(post, e);\n            services.add(e);\n        }\n        ctx.await();\n        logThroughput();\n        return services;\n    }\n\n    public Service startServiceAndWait(Class<? extends Service> serviceType,\n            String uriPath)\n            throws Throwable {\n        return startServiceAndWait(serviceType.newInstance(), uriPath, null);\n    }\n\n    public Service startServiceAndWait(Service s,\n            String uriPath,\n            ServiceDocument body)\n            throws Throwable {\n        TestContext ctx = testCreate(1);\n        URI u = null;\n        if (uriPath != null) {\n            u = UriUtils.buildUri(this, uriPath);\n        }\n\n        Operation post = Operation\n                .createPost(u)\n                .setBody(body)\n                .setCompletion(ctx.getCompletion());\n\n        startService(post, s);\n        ctx.await();\n        return s;\n    }\n\n    public <T extends ServiceDocument> void doServiceRestart(List<Service> services,\n            Class<T> stateType,\n            EnumSet<Service.ServiceOption> caps)\n            throws Throwable {\n        ServiceDocumentDescription sdd = buildDescription(stateType);\n        // first collect service state before shutdown so we can compare after\n        // they restart\n        Map<URI, T> statesBeforeRestart = getServiceState(null, stateType, services);\n\n        List<Service> freshServices = new ArrayList<>();\n        List<Operation> ops = new ArrayList<>();\n        for (Service s : services) {\n            // delete with no body means stop the service\n            Operation delete = Operation.createDelete(s.getUri());\n            ops.add(delete);\n        }\n        this.sender.sendAndWait(ops);\n\n        // restart services\n        TestContext ctx = testCreate(services.size());\n        for (Service oldInstance : services) {\n            Service e = oldInstance.getClass().newInstance();\n\n            for (Service.ServiceOption cap : caps) {\n                e.toggleOption(cap, true);\n            }\n\n            // use the same exact URI so the document index can find the service\n            // state by self link\n            startService(\n                    Operation.createPost(oldInstance.getUri()).setCompletion(ctx.getCompletion()),\n                    e);\n            freshServices.add(e);\n        }\n        ctx.await();\n        services = null;\n\n        Map<URI, T> statesAfterRestart = getServiceState(null, stateType, freshServices);\n\n        for (Entry<URI, T> e : statesAfterRestart.entrySet()) {\n            T stateAfter = e.getValue();\n            if (stateAfter.documentSelfLink == null) {\n                throw new IllegalStateException(\"missing selflink\");\n            }\n            if (stateAfter.documentKind == null) {\n                throw new IllegalStateException(\"missing kind\");\n            }\n\n            T stateBefore = statesBeforeRestart.get(e.getKey());\n            if (stateBefore == null) {\n                throw new IllegalStateException(\n                        \"New service has new self link, not in previous service instances\");\n            }\n\n            if (!stateBefore.documentKind.equals(stateAfter.documentKind)) {\n                throw new IllegalStateException(\"kind mismatch\");\n            }\n\n            if (!caps.contains(Service.ServiceOption.PERSISTENCE)) {\n                continue;\n            }\n\n            if (stateBefore.documentVersion != stateAfter.documentVersion) {\n                String error = String.format(\n                        \"Version mismatch. Before State: %s%n%n After state:%s\",\n                        Utils.toJson(stateBefore),\n                        Utils.toJson(stateAfter));\n                throw new IllegalStateException(error);\n            }\n\n            if (stateBefore.documentUpdateTimeMicros != stateAfter.documentUpdateTimeMicros) {\n                throw new IllegalStateException(\"update time mismatch\");\n            }\n\n            if (stateBefore.documentVersion == 0) {\n                throw new IllegalStateException(\"PUT did not appear to take place before restart\");\n            }\n            if (!ServiceDocument.equals(sdd, stateBefore, stateAfter)) {\n                throw new IllegalStateException(\"content signature mismatch\");\n            }\n        }\n\n    }\n\n    private Map<String, NodeState> peerHostIdToNodeState = new ConcurrentHashMap<>();\n    private Map<URI, URI> peerNodeGroups = new ConcurrentHashMap<>();\n    private Map<URI, VerificationHost> localPeerHosts = new ConcurrentHashMap<>();\n\n    private boolean isRemotePeerTest;\n\n    private boolean isSingleton;\n\n    public Map<URI, VerificationHost> getInProcessHostMap() {\n        return new HashMap<>(this.localPeerHosts);\n    }\n\n    public Map<URI, URI> getNodeGroupMap() {\n        return new HashMap<>(this.peerNodeGroups);\n    }\n\n    public Map<String, NodeState> getNodeStateMap() {\n        return new HashMap<>(this.peerHostIdToNodeState);\n    }\n\n    public void scheduleSynchronizationIfAutoSyncDisabled(String selectorPath) {\n        if (this.isPeerSynchronizationEnabled()) {\n            return;\n        }\n        for (VerificationHost peerHost : getInProcessHostMap().values()) {\n            peerHost.scheduleNodeGroupChangeMaintenance(selectorPath);\n            ServiceStats selectorStats = getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(peerHost, selectorPath));\n            ServiceStat synchStat = selectorStats.entries\n                    .get(ConsistentHashingNodeSelectorService.STAT_NAME_SYNCHRONIZATION_COUNT);\n            if (synchStat != null && synchStat.latestValue > 0) {\n                throw new IllegalStateException(\"Automatic synchronization was triggered\");\n            }\n        }\n    }\n\n    public void setUpPeerHosts(int localHostCount) {\n        CommandLineArgumentParser.parseFromProperties(this);\n        if (this.peerNodes == null) {\n            this.setUpLocalPeersHosts(localHostCount, null);\n        } else {\n            this.setUpWithRemotePeers(this.peerNodes);\n        }\n    }\n\n    public void setUpLocalPeersHosts(int localHostCount, Long maintIntervalMillis) {\n        testStart(localHostCount);\n        if (maintIntervalMillis == null) {\n            maintIntervalMillis = this.maintenanceIntervalMillis;\n        }\n        final long intervalMicros = TimeUnit.MILLISECONDS.toMicros(maintIntervalMillis);\n        for (int i = 0; i < localHostCount; i++) {\n            String location = this.isMultiLocationTest\n                    ? ((i < localHostCount / 2) ? LOCATION1 : LOCATION2)\n                    : null;\n            run(() -> {\n                try {\n                    this.setUpLocalPeerHost(null, intervalMicros, location);\n                } catch (Throwable e) {\n                    failIteration(e);\n                }\n            });\n        }\n        testWait();\n    }\n\n    public Map<URI, URI> getNodeGroupToFactoryMap(String factoryLink) {\n        Map<URI, URI> nodeGroupToFactoryMap = new HashMap<>();\n        for (URI nodeGroup : this.peerNodeGroups.values()) {\n            nodeGroupToFactoryMap.put(nodeGroup,\n                    UriUtils.buildUri(nodeGroup.getScheme(), nodeGroup.getHost(),\n                            nodeGroup.getPort(), factoryLink, null));\n        }\n        return nodeGroupToFactoryMap;\n    }\n\n    public VerificationHost setUpLocalPeerHost(Collection<ServiceHost> hosts,\n            long maintIntervalMicros) throws Throwable {\n        return setUpLocalPeerHost(0, maintIntervalMicros, hosts);\n    }\n\n    public VerificationHost setUpLocalPeerHost(int port, long maintIntervalMicros,\n            Collection<ServiceHost> hosts)\n            throws Throwable {\n        return setUpLocalPeerHost(port, maintIntervalMicros, hosts, null);\n    }\n\n    public VerificationHost setUpLocalPeerHost(Collection<ServiceHost> hosts,\n            long maintIntervalMicros, String location) throws Throwable {\n        return setUpLocalPeerHost(0, maintIntervalMicros, hosts, location);\n    }\n\n    public VerificationHost setUpLocalPeerHost(int port, long maintIntervalMicros,\n            Collection<ServiceHost> hosts, String location)\n            throws Throwable {\n\n        VerificationHost h = VerificationHost.create(port);\n\n        h.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled());\n        h.setAuthorizationEnabled(this.isAuthorizationEnabled());\n\n        if (this.getCurrentHttpScheme() == HttpScheme.HTTPS_ONLY) {\n            // disable HTTP on new peer host\n            h.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n            // request a random HTTPS port\n            h.setSecurePort(0);\n        }\n\n        if (this.isAuthorizationEnabled()) {\n            h.setAuthorizationService(new AuthorizationContextService());\n        }\n        try {\n            VerificationHost.createAndAttachSSLClient(h);\n\n            // override with parent cert info.\n            // Within same node group, all hosts are required to use same cert, private key, and\n            // passphrase for now.\n            h.setCertificateFileReference(this.getState().certificateFileReference);\n            h.setPrivateKeyFileReference(this.getState().privateKeyFileReference);\n            h.setPrivateKeyPassphrase(this.getState().privateKeyPassphrase);\n            if (location != null) {\n                h.setLocation(location);\n            }\n\n            h.start();\n            h.setMaintenanceIntervalMicros(maintIntervalMicros);\n        } catch (Throwable e) {\n            throw new Exception(e);\n        }\n\n        addPeerNode(h);\n        if (hosts != null) {\n            hosts.add(h);\n        }\n        this.completeIteration();\n        return h;\n    }\n\n    public void setUpWithRemotePeers(String[] peerNodes) {\n        this.isRemotePeerTest = true;\n\n        this.peerNodeGroups.clear();\n        for (String remoteNode : peerNodes) {\n            URI remoteHostBaseURI = URI.create(remoteNode);\n            if (remoteHostBaseURI.getPort() == 80 || remoteHostBaseURI.getPort() == -1) {\n                remoteHostBaseURI = UriUtils.buildUri(remoteNode, ServiceHost.DEFAULT_PORT, \"\",\n                        null);\n            }\n\n            URI remoteNodeGroup = UriUtils.extendUri(remoteHostBaseURI,\n                    ServiceUriPaths.DEFAULT_NODE_GROUP);\n            this.peerNodeGroups.put(remoteHostBaseURI, remoteNodeGroup);\n        }\n\n    }\n\n    public void joinNodesAndVerifyConvergence(int nodeCount) throws Throwable {\n        joinNodesAndVerifyConvergence(null, nodeCount, nodeCount, null);\n    }\n\n    public boolean isRemotePeerTest() {\n        return this.isRemotePeerTest;\n    }\n\n    public int getPeerCount() {\n        return this.peerNodeGroups.size();\n    }\n\n    public URI getPeerHostUri() {\n        return getPeerServiceUri(\"\");\n    }\n\n    public URI getPeerNodeGroupUri() {\n        return getPeerServiceUri(ServiceUriPaths.DEFAULT_NODE_GROUP);\n    }\n\n    /**\n     * Randomly returns one of peer hosts.\n     */\n    public VerificationHost getPeerHost() {\n        URI hostUri = getPeerServiceUri(null);\n        if (hostUri != null) {\n            return this.localPeerHosts.get(hostUri);\n        }\n        return null;\n    }\n\n    public URI getPeerServiceUri(String link) {\n        if (!this.localPeerHosts.isEmpty()) {\n            List<URI> localPeerList = new ArrayList<>();\n            for (VerificationHost h : this.localPeerHosts.values()) {\n                if (h.isStopping() || !h.isStarted()) {\n                    continue;\n                }\n                localPeerList.add(h.getUri());\n            }\n            return getUriFromList(link, localPeerList);\n        } else {\n            List<URI> peerList = new ArrayList<>(this.peerNodeGroups.keySet());\n            return getUriFromList(link, peerList);\n        }\n    }\n\n    /**\n     * Randomly choose one uri from uriList and extend with the link\n     */\n    private URI getUriFromList(String link, List<URI> uriList) {\n        if (!uriList.isEmpty()) {\n            Collections.shuffle(uriList, new Random(System.nanoTime()));\n            URI baseUri = uriList.iterator().next();\n            return UriUtils.extendUri(baseUri, link);\n        }\n        return null;\n    }\n\n    public void createCustomNodeGroupOnPeers(String customGroupName) {\n        createCustomNodeGroupOnPeers(customGroupName, null);\n    }\n\n    public void createCustomNodeGroupOnPeers(String customGroupName,\n            Map<URI, NodeState> selfState) {\n        if (selfState == null) {\n            selfState = new HashMap<>();\n        }\n        // create a custom node group on all peer nodes\n        List<Operation> ops = new ArrayList<>();\n        for (URI peerHostBaseUri : getNodeGroupMap().keySet()) {\n            URI nodeGroupFactoryUri = UriUtils.buildUri(peerHostBaseUri,\n                    ServiceUriPaths.NODE_GROUP_FACTORY);\n            Operation op = getCreateCustomNodeGroupOperation(customGroupName, nodeGroupFactoryUri,\n                    selfState.get(peerHostBaseUri));\n            ops.add(op);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    private Operation getCreateCustomNodeGroupOperation(String customGroupName,\n            URI nodeGroupFactoryUri,\n            NodeState selfState) {\n        NodeGroupState body = new NodeGroupState();\n        body.documentSelfLink = customGroupName;\n        if (selfState != null) {\n            body.nodes.put(selfState.id, selfState);\n        }\n        return Operation.createPost(nodeGroupFactoryUri).setBody(body);\n    }\n\n    public void joinNodesAndVerifyConvergence(String customGroupPath, int hostCount,\n            int memberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode)\n            throws Throwable {\n        joinNodesAndVerifyConvergence(customGroupPath, hostCount, memberCount,\n                expectedOptionsPerNode, true);\n    }\n\n    public void joinNodesAndVerifyConvergence(int hostCount, boolean waitForTimeSync)\n            throws Throwable {\n        joinNodesAndVerifyConvergence(hostCount, hostCount, waitForTimeSync);\n    }\n\n    public void joinNodesAndVerifyConvergence(int hostCount, int memberCount,\n            boolean waitForTimeSync) throws Throwable {\n        joinNodesAndVerifyConvergence(null, hostCount, memberCount, null, waitForTimeSync);\n    }\n\n    public void joinNodesAndVerifyConvergence(String customGroupPath, int hostCount,\n            int memberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode,\n            boolean waitForTimeSync) throws Throwable {\n\n        // invoke op as system user\n        setAuthorizationContext(getSystemAuthorizationContext());\n        if (hostCount == 0) {\n            return;\n        }\n\n        Map<URI, URI> nodeGroupPerHost = new HashMap<>();\n        if (customGroupPath != null) {\n            for (Entry<URI, URI> e : this.peerNodeGroups.entrySet()) {\n                URI ngUri = UriUtils.buildUri(e.getKey(), customGroupPath);\n                nodeGroupPerHost.put(e.getKey(), ngUri);\n            }\n        } else {\n            nodeGroupPerHost = this.peerNodeGroups;\n        }\n\n        if (this.isRemotePeerTest()) {\n            memberCount = getPeerCount();\n        } else {\n            for (URI initialNodeGroupService : this.peerNodeGroups.values()) {\n                if (customGroupPath != null) {\n                    initialNodeGroupService = UriUtils.buildUri(initialNodeGroupService,\n                            customGroupPath);\n                }\n\n                for (URI nodeGroup : this.peerNodeGroups.values()) {\n                    if (customGroupPath != null) {\n                        nodeGroup = UriUtils.buildUri(nodeGroup, customGroupPath);\n                    }\n\n                    if (initialNodeGroupService.equals(nodeGroup)) {\n                        continue;\n                    }\n\n                    testStart(1);\n                    joinNodeGroup(nodeGroup, initialNodeGroupService, memberCount);\n                    testWait();\n                }\n            }\n\n        }\n\n        // for local or remote tests, we still want to wait for convergence\n        waitForNodeGroupConvergence(nodeGroupPerHost.values(), memberCount, null,\n                expectedOptionsPerNode, waitForTimeSync);\n\n        waitForNodeGroupIsAvailableConvergence(customGroupPath);\n\n        //reset auth context\n        setAuthorizationContext(null);\n    }\n\n    public void joinNodeGroup(URI newNodeGroupService,\n            URI nodeGroup, Integer quorum) {\n        if (nodeGroup.equals(newNodeGroupService)) {\n            return;\n        }\n\n        // to become member of a group of nodes, you send a POST to self\n        // (the local node group service) with the URI of the remote node\n        // group you wish to join\n        JoinPeerRequest joinBody = JoinPeerRequest.create(nodeGroup, quorum);\n\n        log(\"Joining %s through %s\", newNodeGroupService, nodeGroup);\n        // send the request to the node group instance we have picked as the\n        // \"initial\" one\n        send(Operation.createPost(newNodeGroupService)\n                .setBody(joinBody)\n                .setCompletion(getCompletion()));\n    }\n\n    public void joinNodeGroup(URI newNodeGroupService, URI nodeGroup) {\n        joinNodeGroup(newNodeGroupService, nodeGroup, null);\n    }\n\n    public void subscribeForNodeGroupConvergence(URI nodeGroup, int expectedAvailableCount,\n            CompletionHandler convergedCompletion) {\n\n        TestContext ctx = testCreate(1);\n        Operation subscribeToNodeGroup = Operation.createPost(\n                UriUtils.buildSubscriptionUri(nodeGroup))\n                .setCompletion(ctx.getCompletion())\n                .setReferer(getUri());\n        startSubscriptionService(subscribeToNodeGroup, (op) -> {\n            op.complete();\n            if (op.getAction() != Action.PATCH) {\n                return;\n            }\n\n            NodeGroupState ngs = op.getBody(NodeGroupState.class);\n            if (ngs.nodes == null && ngs.nodes.isEmpty()) {\n                return;\n            }\n\n            int c = 0;\n            for (NodeState ns : ngs.nodes.values()) {\n                if (ns.status == NodeStatus.AVAILABLE) {\n                    c++;\n                }\n            }\n\n            if (c != expectedAvailableCount) {\n                return;\n            }\n            convergedCompletion.handle(op, null);\n        });\n        ctx.await();\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence() {\n        waitForNodeGroupIsAvailableConvergence(ServiceUriPaths.DEFAULT_NODE_GROUP);\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence(String nodeGroupPath) {\n        waitForNodeGroupIsAvailableConvergence(nodeGroupPath, this.peerNodeGroups.values());\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence(String nodeGroupPath,\n            Collection<URI> nodeGroupUris) {\n        if (nodeGroupPath == null) {\n            nodeGroupPath = ServiceUriPaths.DEFAULT_NODE_GROUP;\n        }\n        String finalNodeGroupPath = nodeGroupPath;\n\n        waitFor(\"Node group is not available for convergence\", () -> {\n            boolean isConverged = true;\n            for (URI nodeGroupUri : nodeGroupUris) {\n                URI u = UriUtils.buildUri(nodeGroupUri, finalNodeGroupPath);\n                URI statsUri = UriUtils.buildStatsUri(u);\n                ServiceStats stats = getServiceState(null, ServiceStats.class, statsUri);\n                ServiceStat availableStat = stats.entries.get(Service.STAT_NAME_AVAILABLE);\n                if (availableStat == null || availableStat.latestValue != Service.STAT_VALUE_TRUE) {\n                    log(\"Service stat available is missing or not 1.0\");\n                    isConverged = false;\n                    break;\n                }\n            }\n            return isConverged;\n        });\n\n    }\n\n    public void waitForNodeGroupConvergence(int memberCount) {\n        waitForNodeGroupConvergence(memberCount, null);\n    }\n\n    public void waitForNodeGroupConvergence(int healthyMemberCount, Integer totalMemberCount) {\n        waitForNodeGroupConvergence(this.peerNodeGroups.values(), healthyMemberCount,\n                totalMemberCount, true);\n    }\n\n    public void waitForNodeGroupConvergence(Collection<URI> nodeGroupUris, int healthyMemberCount,\n            Integer totalMemberCount,\n            boolean waitForTimeSync) {\n        waitForNodeGroupConvergence(nodeGroupUris, healthyMemberCount, totalMemberCount,\n                new HashMap<>(), waitForTimeSync);\n    }\n\n    /**\n     * Check node group convergence.\n     *\n     * Due to the implementation of {@link NodeGroupUtils#isNodeGroupAvailable}, quorum needs to\n     * be set less than the available node counts.\n     *\n     * Since {@link TestNodeGroupManager} requires all passing nodes to be in a same nodegroup,\n     * hosts in in-memory host map({@code this.localPeerHosts}) that do not match with the given\n     * nodegroup will be skipped for check.\n     *\n     * For existing API compatibility, keeping unused variables in signature.\n     * Only {@code nodeGroupUris} parameter is used.\n     *\n     * Sample node group URI: http://127.0.0.1:8000/core/node-groups/default\n     *\n     * @see TestNodeGroupManager#waitForConvergence()\n     */\n    public void waitForNodeGroupConvergence(Collection<URI> nodeGroupUris,\n            int healthyMemberCount,\n            Integer totalMemberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNodeGroupUri,\n            boolean waitForTimeSync) {\n\n        Set<String> nodeGroupNames = nodeGroupUris.stream()\n                .map(URI::getPath)\n                .map(UriUtils::getLastPathSegment)\n                .collect(toSet());\n        if (nodeGroupNames.size() != 1) {\n            throw new RuntimeException(\"Multiple nodegroups are not supported. \" + nodeGroupNames);\n        }\n        String nodeGroupName = nodeGroupNames.iterator().next();\n\n        Date exp = getTestExpiration();\n        Duration timeout = Duration.between(Instant.now(), exp.toInstant());\n\n        // Convert \"http://127.0.0.1:1234/core/node-groups/default\" to \"http://127.0.0.1:1234\"\n        Set<URI> baseUris = nodeGroupUris.stream()\n                .map(uri -> uri.toString().replace(uri.getPath(), \"\"))\n                .map(URI::create)\n                .collect(toSet());\n\n        // pick up hosts that match with the base uris of given node group uris\n        Set<ServiceHost> hosts = getInProcessHostMap().values().stream()\n                .filter(host -> baseUris.contains(host.getPublicUri()))\n                .collect(toSet());\n\n        // perform \"waitForConvergence()\"\n        if (hosts != null && !hosts.isEmpty()) {\n            TestNodeGroupManager manager = new TestNodeGroupManager(nodeGroupName);\n            manager.addHosts(hosts);\n            manager.setTimeout(timeout);\n            manager.waitForConvergence();\n        } else {\n            this.waitFor(\"Node group did not converge\", () -> {\n                String nodeGroupPath = ServiceUriPaths.NODE_GROUP_FACTORY + \"/\" + nodeGroupName;\n                List<Operation> nodeGroupOps = baseUris.stream()\n                        .map(u -> UriUtils.buildUri(u, nodeGroupPath))\n                        .map(Operation::createGet)\n                        .collect(toList());\n                List<NodeGroupState> nodeGroupStates = getTestRequestSender()\n                        .sendAndWait(nodeGroupOps, NodeGroupState.class);\n\n                for (NodeGroupState nodeGroupState : nodeGroupStates) {\n                    TestContext testContext = this.testCreate(1);\n                    // placeholder operation\n                    Operation parentOp = Operation.createGet(null)\n                            .setReferer(this.getUri())\n                            .setCompletion(testContext.getCompletion());\n                    try {\n                        NodeGroupUtils.checkConvergenceFromAnyHost(this, nodeGroupState, parentOp);\n                        testContext.await();\n                    } catch (Exception e) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        // To be compatible with old behavior, populate peerHostIdToNodeState same way as before\n        List<Operation> nodeGroupGetOps = nodeGroupUris.stream()\n                .map(UriUtils::buildExpandLinksQueryUri)\n                .map(Operation::createGet)\n                .collect(toList());\n        List<NodeGroupState> nodeGroupStats = this.sender.sendAndWait(nodeGroupGetOps, NodeGroupState.class);\n\n        for (NodeGroupState nodeGroupStat : nodeGroupStats) {\n            for (NodeState nodeState : nodeGroupStat.nodes.values()) {\n                if (nodeState.status == NodeStatus.AVAILABLE) {\n                    this.peerHostIdToNodeState.put(nodeState.id, nodeState);\n                }\n            }\n        }\n    }\n\n    public int calculateHealthyNodeCount(NodeGroupState r) {\n        int healthyNodeCount = 0;\n        for (NodeState ns : r.nodes.values()) {\n            if (ns.status == NodeStatus.AVAILABLE) {\n                healthyNodeCount++;\n            }\n        }\n        return healthyNodeCount;\n    }\n\n    public void getNodeState(URI nodeGroup, Map<URI, NodeGroupState> nodesPerHost) {\n        getNodeState(nodeGroup, nodesPerHost, null);\n    }\n\n    public void getNodeState(URI nodeGroup, Map<URI, NodeGroupState> nodesPerHost,\n            TestContext ctx) {\n        URI u = UriUtils.buildExpandLinksQueryUri(nodeGroup);\n        Operation get = Operation.createGet(u).setCompletion((o, e) -> {\n            NodeGroupState ngs = null;\n            if (e != null) {\n                // failure is OK, since we might have just stopped a host\n                log(\"Host %s failed GET with %s\", nodeGroup, e.getMessage());\n                ngs = new NodeGroupState();\n            } else {\n                ngs = o.getBody(NodeGroupState.class);\n            }\n            synchronized (nodesPerHost) {\n                nodesPerHost.put(nodeGroup, ngs);\n            }\n            if (ctx == null) {\n                completeIteration();\n            } else {\n                ctx.completeIteration();\n            }\n        });\n        send(get);\n    }\n\n    public void validateNodes(NodeGroupState r, int expectedNodesPerGroup,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode) {\n\n        int healthyNodes = 0;\n        NodeState localNode = null;\n        for (NodeState ns : r.nodes.values()) {\n            if (ns.status == NodeStatus.AVAILABLE) {\n                healthyNodes++;\n            }\n            assertTrue(ns.documentKind.equals(Utils.buildKind(NodeState.class)));\n            if (ns.documentSelfLink.endsWith(r.documentOwner)) {\n                localNode = ns;\n            }\n\n            assertTrue(ns.options != null);\n            EnumSet<NodeOption> expectedOptions = expectedOptionsPerNode.get(ns.groupReference);\n            if (expectedOptions == null) {\n                expectedOptions = NodeState.DEFAULT_OPTIONS;\n            }\n\n            for (NodeOption eo : expectedOptions) {\n                assertTrue(ns.options.contains(eo));\n            }\n\n            assertTrue(ns.id != null);\n            assertTrue(ns.groupReference != null);\n            assertTrue(ns.documentSelfLink.startsWith(ns.groupReference.getPath()));\n        }\n\n        assertTrue(healthyNodes >= expectedNodesPerGroup);\n        assertTrue(localNode != null);\n    }\n\n    public void doNodeGroupStatsVerification(Map<URI, URI> defaultNodeGroupsPerHost) {\n        List<Operation> ops = new ArrayList<>();\n        for (URI nodeGroup : defaultNodeGroupsPerHost.values()) {\n            Operation get = Operation.createGet(UriUtils.extendUri(nodeGroup,\n                    ServiceHost.SERVICE_URI_SUFFIX_STATS));\n            ops.add(get);\n        }\n        List<Operation> results = this.sender.sendAndWait(ops);\n        for (Operation result : results) {\n            ServiceStats stats = result.getBody(ServiceStats.class);\n            assertTrue(!stats.entries.isEmpty());\n        }\n    }\n\n    public void setNodeGroupConfig(NodeGroupConfig config) {\n        setSystemAuthorizationContext();\n        List<Operation> ops = new ArrayList<>();\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            NodeGroupState body = new NodeGroupState();\n            body.config = config;\n            body.nodes = null;\n            ops.add(Operation.createPatch(nodeGroup).setBody(body));\n        }\n        this.sender.sendAndWait(ops);\n        resetAuthorizationContext();\n    }\n\n    public void setNodeGroupQuorum(Integer quorum)\n            throws Throwable {\n        // we can issue the update to any one node and it will update\n        // everyone in the group\n\n        setSystemAuthorizationContext();\n\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            log(\"Changing quorum to %d on group %s\", quorum, nodeGroup);\n            setNodeGroupQuorum(quorum, nodeGroup);\n            // nodes might not be joined, so we need to ask each node to set quorum\n        }\n\n        Date exp = getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            setSystemAuthorizationContext();\n            for (URI n : this.peerNodeGroups.values()) {\n                NodeGroupState s = getServiceState(null, NodeGroupState.class, n);\n                for (NodeState ns : s.nodes.values()) {\n                    if (quorum != ns.membershipQuorum) {\n                        isConverged = false;\n                    }\n                }\n            }\n            resetAuthorizationContext();\n            if (isConverged) {\n\n                log(\"converged\");\n                return;\n            }\n            Thread.sleep(500);\n        }\n        waitForNodeSelectorQuorumConvergence(ServiceUriPaths.DEFAULT_NODE_SELECTOR, quorum);\n        resetAuthorizationContext();\n\n        throw new TimeoutException();\n    }\n\n    public void waitForNodeSelectorQuorumConvergence(String nodeSelectorPath, int quorum) {\n        waitFor(\"quorum not updated\", () -> {\n            for (URI peerHostUri : getNodeGroupMap().keySet()) {\n                URI nodeSelectorUri = UriUtils.buildUri(peerHostUri, nodeSelectorPath);\n                NodeSelectorState nss = getServiceState(null, NodeSelectorState.class,\n                        nodeSelectorUri);\n                if (nss.membershipQuorum != quorum) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    public void setNodeGroupQuorum(Integer quorum, URI nodeGroup) {\n        UpdateQuorumRequest body = UpdateQuorumRequest.create(true);\n\n        if (quorum != null) {\n            body.setMembershipQuorum(quorum);\n        }\n\n        this.sender.sendAndWait(Operation.createPatch(nodeGroup).setBody(body));\n    }\n\n    public <T extends ServiceDocument> void validateDocumentPartitioning(\n            Map<URI, T> provisioningTasks,\n            Class<T> type) {\n        Map<String, Map<String, Long>> taskToOwnerCount = new HashMap<>();\n\n        for (URI baseHostURI : getNodeGroupMap().keySet()) {\n            List<URI> documentsPerDcpHost = new ArrayList<>();\n            for (URI serviceUri : provisioningTasks.keySet()) {\n                URI u = UriUtils.extendUri(baseHostURI, serviceUri.getPath());\n                documentsPerDcpHost.add(u);\n            }\n\n            Map<URI, T> tasksOnThisHost = getServiceState(\n                    null,\n                    type, documentsPerDcpHost);\n\n            for (T task : tasksOnThisHost.values()) {\n                Map<String, Long> ownerCount = taskToOwnerCount.get(task.documentSelfLink);\n                if (ownerCount == null) {\n                    ownerCount = new HashMap<>();\n                    taskToOwnerCount.put(task.documentSelfLink, ownerCount);\n                }\n\n                Long count = ownerCount.get(task.documentOwner);\n                if (count == null) {\n                    count = 0L;\n                }\n                count++;\n                ownerCount.put(task.documentOwner, count);\n            }\n        }\n\n        // now verify that each task had a single owner assigned to it\n        for (Entry<String, Map<String, Long>> e : taskToOwnerCount.entrySet()) {\n            Map<String, Long> owners = e.getValue();\n            if (owners.size() > 1) {\n                throw new IllegalStateException(\"Multiple owners assigned on task \" + e.getKey());\n            }\n        }\n\n    }\n\n    public void createExampleServices(ServiceHost h, long serviceCount, List<URI> exampleURIs,\n            Long expiration) {\n        waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        ExampleServiceState initialState = new ExampleServiceState();\n        URI exampleFactoryUri = UriUtils.buildFactoryUri(h,\n                ExampleService.class);\n\n        // create example services\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < serviceCount; i++) {\n            initialState.counter = 123L;\n            if (expiration != null) {\n                initialState.documentExpirationTimeMicros = expiration;\n            }\n            initialState.name = initialState.documentSelfLink = UUID.randomUUID().toString();\n            exampleURIs.add(UriUtils.extendUri(exampleFactoryUri, initialState.documentSelfLink));\n\n            Operation createPost = Operation.createPost(exampleFactoryUri).setBody(initialState);\n            ops.add(createPost);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    public Date getTestExpiration() {\n        long duration = this.timeoutSeconds + this.testDurationSeconds;\n        return new Date(new Date().getTime()\n                + TimeUnit.SECONDS.toMillis(duration));\n    }\n\n    public boolean isStressTest() {\n        return this.isStressTest;\n    }\n\n    public void setStressTest(boolean isStressTest) {\n        this.isStressTest = isStressTest;\n        if (isStressTest) {\n            this.timeoutSeconds = 600;\n            this.setOperationTimeOutMicros(TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n        } else {\n            this.timeoutSeconds = (int) TimeUnit.MICROSECONDS.toSeconds(\n                    ServiceHostState.DEFAULT_OPERATION_TIMEOUT_MICROS);\n        }\n    }\n\n    public boolean isMultiLocationTest() {\n        return this.isMultiLocationTest;\n    }\n\n    public void setMultiLocationTest(boolean isMultiLocationTest) {\n        this.isMultiLocationTest = isMultiLocationTest;\n    }\n\n    public void toggleServiceOptions(URI serviceUri, EnumSet<ServiceOption> optionsToEnable,\n            EnumSet<ServiceOption> optionsToDisable) {\n\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = optionsToDisable;\n        updateBody.addOptions = optionsToEnable;\n\n        URI configUri = UriUtils.buildConfigUri(serviceUri);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(updateBody));\n    }\n\n    public void setOperationQueueLimit(URI serviceUri, int limit) {\n        // send a set limit configuration request\n        ServiceConfigUpdateRequest body = ServiceConfigUpdateRequest.create();\n        body.operationQueueLimit = limit;\n        URI configUri = UriUtils.buildConfigUri(serviceUri);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(body));\n\n        // verify new operation limit is set\n        ServiceConfiguration config = this.sender.sendAndWait(Operation.createGet(configUri),\n                ServiceConfiguration.class);\n        assertEquals(\"Invalid queue limit\", body.operationQueueLimit,\n                (Integer) config.operationQueueLimit);\n    }\n\n    public void toggleNegativeTestMode(boolean enable) {\n        log(\"++++++ Negative test mode %s, failure logs expected: %s\", enable, enable);\n    }\n\n    public void logNodeProcessLogs(Set<URI> keySet, String logSuffix) {\n        List<URI> logServices = new ArrayList<>();\n        for (URI host : keySet) {\n            logServices.add(UriUtils.extendUri(host, logSuffix));\n        }\n\n        Map<URI, LogServiceState> states = this.getServiceState(null, LogServiceState.class,\n                logServices);\n        for (Entry<URI, LogServiceState> entry : states.entrySet()) {\n            log(\"Process log for node %s\\n\\n%s\", entry.getKey(),\n                    Utils.toJsonHtml(entry.getValue()));\n        }\n    }\n\n    public void logNodeManagementState(Set<URI> keySet) {\n        List<URI> services = new ArrayList<>();\n        for (URI host : keySet) {\n            services.add(UriUtils.extendUri(host, ServiceUriPaths.CORE_MANAGEMENT));\n        }\n\n        Map<URI, ServiceHostState> states = this.getServiceState(null, ServiceHostState.class,\n                services);\n        for (Entry<URI, ServiceHostState> entry : states.entrySet()) {\n            log(\"Management state for node %s\\n\\n%s\", entry.getKey(),\n                    Utils.toJsonHtml(entry.getValue()));\n        }\n    }\n\n    public void tearDownInProcessPeers() {\n        for (VerificationHost h : this.localPeerHosts.values()) {\n            if (h == null) {\n                continue;\n            }\n            stopHost(h);\n        }\n    }\n\n    public void stopHost(VerificationHost host) {\n        log(\"Stopping host %s (%s)\", host.getUri(), host.getId());\n        host.tearDown();\n        this.peerHostIdToNodeState.remove(host.getId());\n        this.peerNodeGroups.remove(host.getUri());\n        this.localPeerHosts.remove(host.getUri());\n    }\n\n    public void stopHostAndPreserveState(ServiceHost host) {\n        log(\"Stopping host %s\", host.getUri());\n        // Do not delete the temporary directory with the lucene index. Notice that\n        // we do not call host.tearDown(), which will delete disk state, we simply\n        // stop the host and remove it from the peer node tracking tables\n        host.stop();\n        this.peerHostIdToNodeState.remove(host.getId());\n        this.peerNodeGroups.remove(host.getUri());\n        this.localPeerHosts.remove(host.getUri());\n    }\n\n    public boolean isLongDurationTest() {\n        return this.testDurationSeconds > 0;\n    }\n\n    public void logServiceStats(URI uri) {\n        ServiceStats stats = getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(uri));\n        if (stats == null || stats.entries == null) {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(String.format(\"Stats for %s%n\", uri));\n        sb.append(String.format(\"\\tCount\\t\\tAvg\\t\\tTotal\\t\\t\\tName%n\"));\n        for (ServiceStat st : stats.entries.values()) {\n            logStat(uri, st, sb);\n        }\n        log(sb.toString());\n    }\n\n    private void logStat(URI serviceUri, ServiceStat st, StringBuilder sb) {\n        ServiceStatLogHistogram hist = st.logHistogram;\n        st.logHistogram = null;\n\n        double total = st.accumulatedValue != 0 ? st.accumulatedValue : st.latestValue;\n        double avg = total / st.version;\n        sb.append(\n                String.format(\"\\t%08d\\t\\t%08.2f\\t%010.2f\\t%s%n\", st.version, avg, total, st.name));\n        if (hist == null) {\n            return;\n        }\n    }\n\n    /**\n     * Retrieves node group service state from all peers and logs it in JSON format\n     */\n    public void logNodeGroupState() {\n        List<Operation> ops = new ArrayList<>();\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            ops.add(Operation.createGet(nodeGroup));\n        }\n        List<NodeGroupState> stats = this.sender.sendAndWait(ops, NodeGroupState.class);\n        for (NodeGroupState stat : stats) {\n            log(\"%s\", Utils.toJsonHtml(stat));\n        }\n    }\n\n    public void setServiceMaintenanceIntervalMicros(String path, long micros) {\n        setServiceMaintenanceIntervalMicros(UriUtils.buildUri(this, path), micros);\n    }\n\n    public void setServiceMaintenanceIntervalMicros(URI u, long micros) {\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.maintenanceIntervalMicros = micros;\n        URI configUri = UriUtils.extendUri(u, ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(updateBody));\n    }\n\n    /**\n     * Toggles the operation tracing service\n     *\n     * @param baseHostURI  the uri of the tracing service\n     * @param enable state to toggle to\n     */\n    public void toggleOperationTracing(URI baseHostURI, boolean enable) {\n        ServiceHostManagementService.ConfigureOperationTracingRequest r = new ServiceHostManagementService.ConfigureOperationTracingRequest();\n        r.enable = enable ? ServiceHostManagementService.OperationTracingEnable.START\n                : ServiceHostManagementService.OperationTracingEnable.STOP;\n        r.kind = ServiceHostManagementService.ConfigureOperationTracingRequest.KIND;\n\n        this.setSystemAuthorizationContext();\n        this.sender.sendAndWait(Operation.createPatch(\n                UriUtils.extendUri(baseHostURI, ServiceHostManagementService.SELF_LINK))\n                .setBody(r));\n        this.resetAuthorizationContext();\n    }\n\n    public CompletionHandler getSuccessOrFailureCompletion() {\n        return (o, e) -> {\n            completeIteration();\n        };\n    }\n\n    public static QueryValidationServiceState buildQueryValidationState() {\n        QueryValidationServiceState newState = new QueryValidationServiceState();\n\n        newState.ignoredStringValue = \"should be ignored by index\";\n        newState.exampleValue = new ExampleServiceState();\n        newState.exampleValue.counter = 10L;\n        newState.exampleValue.name = \"example name\";\n\n        newState.nestedComplexValue = new NestedType();\n        newState.nestedComplexValue.id = UUID.randomUUID().toString();\n        newState.nestedComplexValue.longValue = Long.MIN_VALUE;\n\n        newState.listOfExampleValues = new ArrayList<>();\n        ExampleServiceState exampleItem = new ExampleServiceState();\n        exampleItem.name = \"nested name\";\n        newState.listOfExampleValues.add(exampleItem);\n\n        newState.listOfStrings = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            newState.listOfStrings.add(UUID.randomUUID().toString());\n        }\n\n        newState.arrayOfExampleValues = new ExampleServiceState[2];\n        newState.arrayOfExampleValues[0] = new ExampleServiceState();\n        newState.arrayOfExampleValues[0].name = UUID.randomUUID().toString();\n\n        newState.arrayOfStrings = new String[2];\n        newState.arrayOfStrings[0] = UUID.randomUUID().toString();\n        newState.arrayOfStrings[1] = UUID.randomUUID().toString();\n\n        newState.mapOfStrings = new HashMap<>();\n        String keyOne = \"keyOne\";\n        String keyTwo = \"keyTwo\";\n        String valueOne = UUID.randomUUID().toString();\n        String valueTwo = UUID.randomUUID().toString();\n        newState.mapOfStrings.put(keyOne, valueOne);\n        newState.mapOfStrings.put(keyTwo, valueTwo);\n\n        newState.mapOfBooleans = new HashMap<>();\n        newState.mapOfBooleans.put(\"trueKey\", true);\n        newState.mapOfBooleans.put(\"falseKey\", false);\n\n        newState.mapOfBytesArrays = new HashMap<>();\n        newState.mapOfBytesArrays.put(\"bytes\", new byte[] { 0x01, 0x02 });\n\n        newState.mapOfDoubles = new HashMap<>();\n        newState.mapOfDoubles.put(\"one\", 1.0);\n        newState.mapOfDoubles.put(\"minusOne\", -1.0);\n\n        newState.mapOfEnums = new HashMap<>();\n        newState.mapOfEnums.put(\"GET\", Service.Action.GET);\n\n        newState.mapOfLongs = new HashMap<>();\n        newState.mapOfLongs.put(\"one\", 1L);\n        newState.mapOfLongs.put(\"two\", 2L);\n\n        newState.mapOfNestedTypes = new HashMap<>();\n        newState.mapOfNestedTypes.put(\"nested\", newState.nestedComplexValue);\n\n        newState.mapOfUris = new HashMap<>();\n        newState.mapOfUris.put(\"uri\", UriUtils.buildUri(\"/foo/bar\"));\n\n        newState.ignoredArrayOfStrings = new String[2];\n        newState.ignoredArrayOfStrings[0] = UUID.randomUUID().toString();\n        newState.ignoredArrayOfStrings[1] = UUID.randomUUID().toString();\n\n        newState.binaryContent = UUID.randomUUID().toString().getBytes();\n        return newState;\n    }\n\n    public void updateServiceOptions(Collection<String> selfLinks,\n            ServiceConfigUpdateRequest cfgBody) {\n\n        List<Operation> ops = new ArrayList<>();\n        for (String link : selfLinks) {\n            URI bUri = UriUtils.buildUri(getUri(), link,\n                    ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n\n            ops.add(Operation.createPatch(bUri).setBody(cfgBody));\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    public void addPeerNode(VerificationHost h) {\n        URI localBaseURI = h.getPublicUri();\n        URI nodeGroup = UriUtils.buildUri(h.getPublicUri(), ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.peerNodeGroups.put(localBaseURI, nodeGroup);\n        this.localPeerHosts.put(localBaseURI, h);\n    }\n\n    public void addPeerNode(URI ngUri) {\n        URI hostUri = UriUtils.buildUri(ngUri.getScheme(), ngUri.getHost(), ngUri.getPort(), null,\n                null);\n        this.peerNodeGroups.put(hostUri, ngUri);\n    }\n\n    public ServiceDocumentDescription buildDescription(Class<? extends ServiceDocument> type) {\n        EnumSet<ServiceOption> options = EnumSet.noneOf(ServiceOption.class);\n        return Builder.create().buildDescription(type, options);\n    }\n\n    public void logAllDocuments(Set<URI> baseHostUris) {\n        QueryTask task = new QueryTask();\n        task.setDirect(true);\n        task.querySpec = new QuerySpecification();\n        task.querySpec.query.setTermPropertyName(\"documentSelfLink\").setTermMatchValue(\"*\");\n        task.querySpec.query.setTermMatchType(MatchType.WILDCARD);\n        task.querySpec.options = EnumSet.of(QueryOption.EXPAND_CONTENT);\n\n        List<Operation> ops = new ArrayList<>();\n        for (URI baseHost : baseHostUris) {\n            Operation queryPost = Operation\n                    .createPost(UriUtils.buildUri(baseHost, ServiceUriPaths.CORE_QUERY_TASKS))\n                    .setBody(task);\n            ops.add(queryPost);\n        }\n        List<QueryTask> queryTasks = this.sender.sendAndWait(ops, QueryTask.class);\n        for (QueryTask queryTask : queryTasks) {\n            log(Utils.toJsonHtml(queryTask));\n        }\n    }\n\n    public void setSystemAuthorizationContext() {\n        setAuthorizationContext(getSystemAuthorizationContext());\n    }\n\n    public void resetSystemAuthorizationContext() {\n        super.setAuthorizationContext(null);\n    }\n\n    @Override\n    public void addPrivilegedService(Class<? extends Service> serviceType) {\n        // Overriding just for test cases\n        super.addPrivilegedService(serviceType);\n    }\n\n    @Override\n    public void setAuthorizationContext(AuthorizationContext context) {\n        super.setAuthorizationContext(context);\n    }\n\n    public void resetAuthorizationContext() {\n        super.setAuthorizationContext(null);\n    }\n\n    /**\n     * Inject user identity into operation context.\n     *\n     * @param userServicePath user document link\n     */\n    public AuthorizationContext assumeIdentity(String userServicePath)\n            throws GeneralSecurityException {\n        return assumeIdentity(userServicePath, null);\n    }\n\n    /**\n     * Inject user identity into operation context.\n     *\n     * @param userServicePath user document link\n     * @param properties custom properties in claims\n     * @throws GeneralSecurityException any generic security exception\n     */\n    public AuthorizationContext assumeIdentity(String userServicePath,\n            Map<String, String> properties) throws GeneralSecurityException {\n        Claims.Builder builder = new Claims.Builder();\n        builder.setSubject(userServicePath);\n        builder.setProperties(properties);\n        Claims claims = builder.getResult();\n        String token = getTokenSigner().sign(claims);\n\n        AuthorizationContext.Builder ab = AuthorizationContext.Builder.create();\n        ab.setClaims(claims);\n        ab.setToken(token);\n\n        // Associate resulting authorization context with this thread\n        AuthorizationContext authContext = ab.getResult();\n        setAuthorizationContext(authContext);\n        return authContext;\n    }\n\n    public void deleteAllChildServices(URI factoryURI) {\n        deleteOrStopAllChildServices(factoryURI, false);\n    }\n\n    public void deleteOrStopAllChildServices(URI factoryURI, boolean stopOnly) {\n        ServiceDocumentQueryResult res = getFactoryState(factoryURI);\n        if (res.documentLinks.isEmpty()) {\n            return;\n        }\n        List<Operation> ops = new ArrayList<>();\n        for (String link : res.documentLinks) {\n            Operation op = Operation.createDelete(UriUtils.buildUri(factoryURI, link));\n            if (stopOnly) {\n                op.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NO_INDEX_UPDATE);\n            } else {\n                op.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                        Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n            }\n            ops.add(op);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    public <T extends ServiceDocument> ServiceDocument verifyPost(Class<T> documentType,\n            String factoryLink,\n            T state,\n            int expectedStatusCode) {\n        URI uri = UriUtils.buildUri(this, factoryLink);\n\n        Operation op = Operation.createPost(uri).setBody(state);\n        Operation response = this.sender.sendAndWait(op);\n        String message = String.format(\"Status code expected: %s, actual: %s\", expectedStatusCode,\n                response.getStatusCode());\n        assertEquals(message, expectedStatusCode, response.getStatusCode());\n\n        return response.getBody(documentType);\n    }\n\n    protected TemporaryFolder getTemporaryFolder() {\n        return this.temporaryFolder;\n    }\n\n    public void setTemporaryFolder(TemporaryFolder temporaryFolder) {\n        this.temporaryFolder = temporaryFolder;\n    }\n\n    /**\n     * Sends an operation and waits for completion. CompletionHandler on passed operation will be cleared.\n     */\n    public void sendAndWaitExpectSuccess(Operation op) {\n        // to be compatible with old behavior, clear the completion handler\n        op.setCompletion(null);\n\n        this.sender.sendAndWait(op);\n    }\n\n    public void sendAndWaitExpectFailure(Operation op) {\n        sendAndWaitExpectFailure(op, null);\n    }\n\n    public void sendAndWaitExpectFailure(Operation op, Integer expectedFailureCode) {\n\n        // to be compatible with old behavior, clear the completion handler\n        op.setCompletion(null);\n\n        FailureResponse resposne = this.sender.sendAndWaitFailure(op);\n\n        if (expectedFailureCode == null) {\n            return;\n        }\n        String msg = \"got unexpected status: \" + expectedFailureCode;\n        assertEquals(msg, (int) expectedFailureCode, resposne.op.getStatusCode());\n    }\n\n    /**\n     * Sends an operation and waits for completion.\n     */\n    public void sendAndWait(Operation op) {\n        // assume completion is attached, using our getCompletion() or\n        // getExpectedFailureCompletion()\n        testStart(1);\n        send(op);\n        testWait();\n    }\n\n    /**\n     * Sends an operation, waits for completion and return the response representation.\n     */\n    public Operation waitForResponse(Operation op) {\n        final Operation[] result = new Operation[1];\n        op.nestCompletion((o, e) -> {\n            result[0] = o;\n            completeIteration();\n        });\n\n        sendAndWait(op);\n\n        return result[0];\n    }\n\n    /**\n     * Decorates a {@link CompletionHandler} with a try/catch-all\n     * and fails the current iteration on exception. Allow for calling\n     * Assert.assert* directly in a handler.\n     *\n     * A safe handler will call completeIteration or failIteration exactly once.\n     *\n     * @param handler\n     * @return\n     */\n    public CompletionHandler getSafeHandler(CompletionHandler handler) {\n        return (o, e) -> {\n            try {\n                handler.handle(o, e);\n                completeIteration();\n            } catch (Throwable t) {\n                failIteration(t);\n            }\n        };\n    }\n\n    public CompletionHandler getSafeHandler(TestContext ctx, CompletionHandler handler) {\n        return (o, e) -> {\n            try {\n                handler.handle(o, e);\n                ctx.completeIteration();\n            } catch (Throwable t) {\n                ctx.failIteration(t);\n            }\n        };\n    }\n\n    /**\n     * Creates a new service instance of type {@code service} via a {@code HTTP POST} to the service\n     * factory URI (which is discovered automatically based on {@code service}). It passes {@code\n     * state} as the body of the {@code POST}.\n     * <p/>\n     * See javadoc for <i>handler</i> param for important details on how to properly use this\n     * method. If your test expects the service instance to be created successfully, you might use:\n     * <pre>\n     * String[] taskUri = new String[1];\n     * CompletionHandler successHandler = getCompletionWithUri(taskUri);\n     * sendFactoryPost(ExampleTaskService.class, new ExampleTaskServiceState(), successHandler);\n     * </pre>\n     *\n     * @param service the type of service to create\n     * @param state   the body of the {@code POST} to use to create the service instance\n     * @param handler the completion handler to use when creating the service instance.\n     *                <b>IMPORTANT</b>: This handler must properly call {@code host.failIteration()}\n     *                or {@code host.completeIteration()}.\n     * @param <T>     the state that represents the service instance\n     */\n    public <T extends ServiceDocument> void sendFactoryPost(Class<? extends Service> service,\n            T state, CompletionHandler handler) {\n        URI factoryURI = UriUtils.buildFactoryUri(this, service);\n        log(Level.INFO, \"Creating POST for [uri=%s] [body=%s]\", factoryURI, state);\n        Operation createPost = Operation.createPost(factoryURI)\n                .setBody(state)\n                .setCompletion(handler);\n\n        this.sender.sendAndWait(createPost);\n    }\n\n    /**\n     * Helper completion handler that:\n     * <ul>\n     * <li>Expects valid response to be returned; no exceptions when processing the operation</li>\n     * <li>Expects a {@code ServiceDocument} to be returned in the response body. The response's\n     * {@link ServiceDocument#documentSelfLink} will be stored in {@code storeUri[0]} so it can be\n     * used for test assertions and logic</li>\n     * </ul>\n     *\n     * @param storedLink The {@code documentSelfLink} of the created {@code ServiceDocument} will be\n     *                 stored in {@code storedLink[0]} so it can be used for test assertions and\n     *                 logic. This must be non-null and its length cannot be zero\n     * @return a completion handler, handy for using in methods like {@link\n     * #sendFactoryPost(Class, ServiceDocument, CompletionHandler)}\n     */\n    public CompletionHandler getCompletionWithSelflink(String[] storedLink) {\n        if (storedLink == null || storedLink.length == 0) {\n            throw new IllegalArgumentException(\n                    \"storeUri must be initialized and have room for at least one item\");\n        }\n\n        return (op, ex) -> {\n            if (ex != null) {\n                failIteration(ex);\n                return;\n            }\n\n            ServiceDocument response = op.getBody(ServiceDocument.class);\n            if (response == null) {\n                failIteration(new IllegalStateException(\n                        \"Expected non-null ServiceDocument in response body\"));\n                return;\n            }\n\n            log(Level.INFO, \"Created service instance. [selfLink=%s] [kind=%s]\",\n                    response.documentSelfLink, response.documentKind);\n            storedLink[0] = response.documentSelfLink;\n            completeIteration();\n        };\n    }\n\n    /**\n     * Helper completion handler that:\n     * <ul>\n     * <li>Expects an exception when processing the handler; it is a {@code failIteration} if an\n     * exception is <b>not</b> thrown.</li>\n     * <li>The exception will be stored in {@code storeException[0]} so it can be used for test\n     * assertions and logic.</li>\n     * </ul>\n     *\n     * @param storeException the exception that occurred in completion handler will be stored in\n     *                       {@code storeException[0]} so it can be used for test assertions and\n     *                       logic. This must be non-null and its length cannot be zero.\n     * @return a completion handler, handy for using in methods like {@link\n     * #sendFactoryPost(Class, ServiceDocument, CompletionHandler)}\n     */\n    public CompletionHandler getExpectedFailureCompletionReturningThrowable(\n            Throwable[] storeException) {\n        if (storeException == null || storeException.length == 0) {\n            throw new IllegalArgumentException(\n                    \"storeException must be initialized and have room for at least one item\");\n        }\n\n        return (op, ex) -> {\n            if (ex == null) {\n                failIteration(new IllegalStateException(\"Failure expected\"));\n            }\n            storeException[0] = ex;\n            completeIteration();\n        };\n    }\n\n    /**\n     * Helper method that waits for a query task to reach the expected stage\n     */\n    public QueryTask waitForQueryTask(URI uri, TaskState.TaskStage expectedStage) {\n\n        // If the task's state ever reaches one of these \"final\" stages, we can stop waiting...\n        List<TaskState.TaskStage> finalTaskStages = Arrays\n                .asList(TaskState.TaskStage.CANCELLED, TaskState.TaskStage.FAILED,\n                        TaskState.TaskStage.FINISHED, expectedStage);\n\n        String error = String.format(\"Task did not reach expected state %s\", expectedStage);\n        Object[] r = new Object[1];\n        final URI finalUri = uri;\n        waitFor(error, () -> {\n            QueryTask state = this.getServiceState(null, QueryTask.class, finalUri);\n            r[0] = state;\n            if (state.taskInfo != null) {\n                if (finalTaskStages.contains(state.taskInfo.stage)) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        return (QueryTask) r[0];\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FINISHED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it's {@code FINISHED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFinishedTask(Class<T> type,\n            String taskUri) {\n        return waitForTask(type, taskUri, TaskState.TaskStage.FINISHED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FINISHED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it's {@code FINISHED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFinishedTask(Class<T> type,\n            URI taskUri) {\n        return waitForTask(type, taskUri.toString(), TaskState.TaskStage.FINISHED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FAILED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it s {@code FAILED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFailedTask(Class<T> type,\n            String taskUri) {\n        return waitForTask(type, taskUri, TaskState.TaskStage.FAILED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * expectedStage}.\n     *\n     * @param type          The class type of that represents the task's state\n     * @param taskUri       the URI of the task to wait for\n     * @param expectedStage the stage we expect the task to eventually get to\n     * @param <T>           the type that represents the task's state\n     * @return the state of the task once it's {@link TaskState.TaskStage} == {@code expectedStage}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForTask(Class<T> type, String taskUri,\n            TaskState.TaskStage expectedStage) {\n        return waitForTask(type, taskUri, expectedStage, false);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * expectedStage}.\n     *\n     * @param type          The class type of that represents the task's state\n     * @param taskUri       the URI of the task to wait for\n     * @param expectedStage the stage we expect the task to eventually get to\n     * @param useQueryTask  Uses {@link QueryTask} to retrieve the current stage of the Task\n     * @param <T>           the type that represents the task's state\n     * @return the state of the task once it's {@link TaskState.TaskStage} == {@code expectedStage}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends TaskService.TaskServiceState> T waitForTask(Class<T> type, String taskUri,\n            TaskState.TaskStage expectedStage, boolean useQueryTask) {\n        URI uri = UriUtils.buildUri(taskUri);\n\n        if (!uri.isAbsolute()) {\n            uri = UriUtils.buildUri(this, taskUri);\n        }\n\n        List<TaskState.TaskStage> finalTaskStages = Arrays\n                .asList(TaskState.TaskStage.CANCELLED, TaskState.TaskStage.FAILED,\n                        TaskState.TaskStage.FINISHED);\n\n        String error = String.format(\"Task did not reach expected state %s\", expectedStage);\n        Object[] r = new Object[1];\n        final URI finalUri = uri;\n        waitFor(error, () -> {\n            T state = (useQueryTask)\n                    ? this.getServiceStateUsingQueryTask(type, taskUri)\n                    : this.getServiceState(null, type, finalUri);\n\n            r[0] = state;\n            if (state.taskInfo != null) {\n                if (expectedStage == state.taskInfo.stage) {\n                    return true;\n                }\n                if (finalTaskStages.contains(state.taskInfo.stage)) {\n                    fail(String.format(\n                            \"Task was expected to reach stage %s but reached a final stage %s\",\n                            expectedStage, state.taskInfo.stage));\n                }\n            }\n            return false;\n        });\n        return (T) r[0];\n    }\n\n    @FunctionalInterface\n    public interface WaitHandler {\n        boolean isReady() throws Throwable;\n    }\n\n    public void waitFor(String timeoutMsg, WaitHandler wh) {\n        ExceptionTestUtils.executeSafely(() -> {\n            Date exp = getTestExpiration();\n            while (new Date().before(exp)) {\n                if (wh.isReady()) {\n                    return;\n                }\n                // sleep for a tenth of the maintenance interval\n                Thread.sleep(TimeUnit.MICROSECONDS.toMillis(getMaintenanceIntervalMicros()) / 10);\n            }\n            throw new TimeoutException(timeoutMsg);\n        });\n    }\n\n    public void setSingleton(boolean enable) {\n        this.isSingleton = enable;\n    }\n\n    /*\n    * Running restart tests in VMs, in over provisioned CI will cause a restart using the same\n    * index sand box to fail, due to a file system LockHeldException.\n    * The sleep just reduces the false negative test failure rate, but it can still happen.\n    * Not much else we can do other adding some weird polling on all the index files.\n    *\n    * Returns true of host restarted, false if retry attempts expired or other exceptions where thrown\n     */\n    public static boolean restartStatefulHost(ServiceHost host) throws Throwable {\n        long exp = Utils.getNowMicrosUtc() + host.getOperationTimeoutMicros();\n\n        do {\n            Thread.sleep(2000);\n            try {\n                host.start();\n                return true;\n            } catch (Throwable e) {\n                Logger.getAnonymousLogger().warning(String\n                        .format(\"exception on host restart: %s\", e.getMessage()));\n                try {\n                    host.stop();\n                } catch (Throwable e1) {\n                    return false;\n                }\n                if (e instanceof LockObtainFailedException) {\n                    Logger.getAnonymousLogger()\n                            .warning(\"Lock held exception on host restart, retrying\");\n                    continue;\n                }\n                return false;\n            }\n        } while (Utils.getNowMicrosUtc() < exp);\n        return false;\n    }\n\n    public void waitForGC() {\n        if (!isStressTest()) {\n            return;\n        }\n        for (int k = 0; k < 10; k++) {\n            Runtime.getRuntime().gc();\n            Runtime.getRuntime().runFinalization();\n        }\n    }\n\n    public TestRequestSender getTestRequestSender() {\n        return this.sender;\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.services.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.lang.reflect.Field;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.concurrent.ConcurrentSkipListSet;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiPredicate;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.AuthorizationSetupHelper;\nimport com.vmware.xenon.common.CommandLineArgumentParser;\nimport com.vmware.xenon.common.FactoryService;\nimport com.vmware.xenon.common.NodeSelectorService.SelectAndForwardRequest;\nimport com.vmware.xenon.common.NodeSelectorService.SelectOwnerResponse;\nimport com.vmware.xenon.common.NodeSelectorState;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.OperationJoin;\nimport com.vmware.xenon.common.Service;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ProcessingStage;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceConfigUpdateRequest;\nimport com.vmware.xenon.common.ServiceConfiguration;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceDocumentDescription;\nimport com.vmware.xenon.common.ServiceDocumentQueryResult;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.ServiceHost.HttpScheme;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState;\nimport com.vmware.xenon.common.ServiceStats;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.StatefulService;\nimport com.vmware.xenon.common.SynchronizationTaskService;\nimport com.vmware.xenon.common.TaskState;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.common.serialization.KryoSerializers;\nimport com.vmware.xenon.common.test.AuthorizationHelper;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.RoundRobinIterator;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestProperty;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.common.test.VerificationHost.WaitHandler;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleTaskService.ExampleTaskServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService.MinimalTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.NodeGroupBroadcastResult.PeerNodeResult;\nimport com.vmware.xenon.services.common.NodeGroupService.JoinPeerRequest;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeState.NodeOption;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.ReplicationTestService.ReplicationTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.ReplicationTestService.ReplicationTestServiceState;\nimport com.vmware.xenon.services.common.ResourceGroupService.PatchQueryRequest;\nimport com.vmware.xenon.services.common.ResourceGroupService.ResourceGroupState;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.UserService.UserState;\n\npublic class TestNodeGroupService {\n\n    public static class PeriodicExampleFactoryService extends FactoryService {\n        public static final String SELF_LINK = \"test/examples-periodic\";\n\n        public PeriodicExampleFactoryService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public Service createServiceInstance() throws Throwable {\n            ExampleService s = new ExampleService();\n            s.toggleOption(ServiceOption.PERIODIC_MAINTENANCE, true);\n            return s;\n        }\n    }\n\n    public static class ExampleServiceWithCustomSelector extends StatefulService {\n\n        public ExampleServiceWithCustomSelector() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.REPLICATION, true);\n            super.toggleOption(ServiceOption.OWNER_SELECTION, true);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n\n    }\n\n    public static class ExampleFactoryServiceWithCustomSelector extends FactoryService {\n\n        public ExampleFactoryServiceWithCustomSelector() {\n            super(ExampleServiceState.class);\n            super.setPeerNodeSelectorPath(CUSTOM_GROUP_NODE_SELECTOR);\n        }\n\n        @Override\n        public Service createServiceInstance() throws Throwable {\n            return new ExampleServiceWithCustomSelector();\n        }\n\n    }\n\n    private static final String CUSTOM_EXAMPLE_SERVICE_KIND = \"xenon:examplestate\";\n    private static final String CUSTOM_NODE_GROUP_NAME = \"custom\";\n    private static final String CUSTOM_NODE_GROUP = UriUtils.buildUriPath(\n            ServiceUriPaths.NODE_GROUP_FACTORY,\n            CUSTOM_NODE_GROUP_NAME);\n    private static final String CUSTOM_GROUP_NODE_SELECTOR = UriUtils.buildUriPath(\n            ServiceUriPaths.NODE_SELECTOR_PREFIX,\n            CUSTOM_NODE_GROUP_NAME);\n\n    public static final long DEFAULT_MAINT_INTERVAL_MICROS = TimeUnit.MILLISECONDS\n            .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS);\n    private VerificationHost host;\n\n    /**\n     * Command line argument specifying number of times to run the same test method.\n     */\n    public int testIterationCount = 1;\n\n    /**\n     * Command line argument specifying default number of in process service hosts\n     */\n    public int nodeCount = 3;\n\n    /**\n     * Command line argument specifying request count\n     */\n    public int updateCount = 10;\n\n    /**\n     * Command line argument specifying service instance count\n     */\n    public int serviceCount = 10;\n\n    /**\n     * Command line argument specifying test duration\n     */\n    public long testDurationSeconds;\n\n    /**\n     * Command line argument specifying iterations per test method\n     */\n    public long iterationCount = 1;\n\n    /**\n     * Command line argument used by replication long running tests\n     */\n    public long totalOperationLimit = Long.MAX_VALUE;\n\n    private NodeGroupConfig nodeGroupConfig = new NodeGroupConfig();\n    private EnumSet<ServiceOption> postCreationServiceOptions = EnumSet.noneOf(ServiceOption.class);\n    private boolean expectFailure;\n    private long expectedFailureStartTimeMicros;\n    private List<URI> expectedFailedHosts = new ArrayList<>();\n    private String replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n    private String replicationNodeSelector = ServiceUriPaths.DEFAULT_NODE_SELECTOR;\n    private long replicationFactor;\n\n    private BiPredicate<ExampleServiceState, ExampleServiceState> exampleStateConvergenceChecker = (\n            initial, current) -> {\n        if (current.name == null) {\n            return false;\n        }\n        if (!this.host.isRemotePeerTest() &&\n                !CUSTOM_EXAMPLE_SERVICE_KIND.equals(current.documentKind)) {\n            return false;\n        }\n        return current.name.equals(initial.name);\n    };\n\n    private Function<ExampleServiceState, Void> exampleStateUpdateBodySetter = (\n            ExampleServiceState state) -> {\n        state.name = Utils.getNowMicrosUtc() + \"\";\n        return null;\n    };\n\n    private boolean isPeerSynchronizationEnabled = true;\n    private boolean isAuthorizationEnabled = false;\n    private HttpScheme replicationUriScheme;\n    private boolean skipAvailabilityChecks = false;\n    private boolean isMultiLocationTest = false;\n\n    private void setUp(int localHostCount) throws Throwable {\n        if (this.host != null) {\n            return;\n        }\n        CommandLineArgumentParser.parseFromProperties(this);\n        this.host = VerificationHost.create(0);\n        this.host.setAuthorizationEnabled(this.isAuthorizationEnabled);\n\n        VerificationHost.createAndAttachSSLClient(this.host);\n\n        if (this.replicationUriScheme == HttpScheme.HTTPS_ONLY) {\n            // disable HTTP, forcing host.getPublicUri() to return a HTTPS schemed URI. This in\n            // turn forces the node group to use HTTPS for join, replication, etc\n            this.host.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n            // the default is disable (-1) so we must set port to 0, to enable SSL and make the\n            // runtime pick a random HTTPS port\n            this.host.setSecurePort(0);\n        }\n\n        if (this.testDurationSeconds > 0) {\n            // for long running tests use the default interval to match production code\n            this.host.maintenanceIntervalMillis = TimeUnit.MICROSECONDS.toMillis(\n                    ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS);\n        }\n\n        this.host.start();\n\n        if (this.host.isAuthorizationEnabled()) {\n            this.host.setSystemAuthorizationContext();\n        }\n\n        CommandLineArgumentParser.parseFromProperties(this.host);\n        this.host.setStressTest(this.host.isStressTest);\n        this.host.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled);\n        this.host.setMultiLocationTest(this.isMultiLocationTest);\n        this.host.setUpPeerHosts(localHostCount);\n\n        for (VerificationHost h1 : this.host.getInProcessHostMap().values()) {\n            setUpPeerHostWithAdditionalServices(h1);\n        }\n\n        // If the peer hosts are remote, then we undo CUSTOM_EXAMPLE_SERVICE_KIND\n        // from the KINDS cache and use the real documentKind of ExampleService.\n        if (this.host.isRemotePeerTest()) {\n            Utils.registerKind(ExampleServiceState.class,\n                    Utils.toDocumentKind(ExampleServiceState.class));\n        }\n    }\n\n    private void setUpPeerHostWithAdditionalServices(VerificationHost h1) throws Throwable {\n        h1.setStressTest(this.host.isStressTest);\n\n        h1.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        Replication1xExampleFactoryService exampleFactory1x = new Replication1xExampleFactoryService();\n        h1.startServiceAndWait(exampleFactory1x,\n                Replication1xExampleFactoryService.SELF_LINK,\n                null);\n\n        Replication3xExampleFactoryService exampleFactory3x = new Replication3xExampleFactoryService();\n        h1.startServiceAndWait(exampleFactory3x,\n                Replication3xExampleFactoryService.SELF_LINK,\n                null);\n\n        // start the replication test factory service with OWNER_SELECTION\n        ReplicationFactoryTestService ownerSelRplFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(ownerSelRplFactory,\n                ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK,\n                null);\n\n        // start the replication test factory service with STRICT update checking\n        ReplicationFactoryTestService strictReplFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(strictReplFactory,\n                ReplicationFactoryTestService.STRICT_SELF_LINK, null);\n\n        // start the replication test factory service with simple replication, no owner selection\n        ReplicationFactoryTestService replFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(replFactory,\n                ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK, null);\n    }\n\n    private Map<URI, URI> getFactoriesPerNodeGroup(String factoryLink) {\n        Map<URI, URI> map = this.host.getNodeGroupToFactoryMap(factoryLink);\n        for (URI h : this.expectedFailedHosts) {\n            URI e = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            // do not send messages through hosts that will be stopped: this allows all messages to\n            // end the node group and the succeed or fail based on the test goals. If we let messages\n            // route through a host that we will abruptly stop, the message might timeout, which is\n            // OK for the expected failure case when quorum is not met, but will prevent is from confirming\n            // in the non eager consistency case, that all updates were written to at least one host\n            map.remove(e);\n        }\n\n        return map;\n    }\n\n    @Before\n    public void setUp() {\n        CommandLineArgumentParser.parseFromProperties(this);\n        Utils.registerKind(ExampleServiceState.class, CUSTOM_EXAMPLE_SERVICE_KIND);\n    }\n\n    private void setUpOnDemandLoad() throws Throwable {\n        setUp();\n        // we need at least 5 nodes, because we're going to stop 2\n        // nodes and we need majority quorum\n        this.nodeCount = Math.max(5, this.nodeCount);\n\n        this.isPeerSynchronizationEnabled = true;\n        this.skipAvailabilityChecks = true;\n        // create node group, join nodes and set majority quorum\n        setUp(this.nodeCount);\n        toggleOnDemandLoad();\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.host.getPeerCount() / 2 + 1);\n    }\n\n    private void toggleOnDemandLoad() {\n        for (URI nodeUri : this.host.getNodeGroupMap().keySet()) {\n            URI factoryUri = UriUtils.buildUri(nodeUri, ExampleService.FACTORY_LINK);\n            this.host.toggleServiceOptions(factoryUri, EnumSet.of(ServiceOption.ON_DEMAND_LOAD),\n                    null);\n        }\n    }\n\n    @After\n    public void tearDown() throws InterruptedException {\n        Utils.registerKind(ExampleServiceState.class,\n                Utils.toDocumentKind(ExampleServiceState.class));\n        if (this.host == null) {\n            return;\n        }\n\n        if (this.host.isRemotePeerTest()) {\n            try {\n                this.host.logNodeProcessLogs(this.host.getNodeGroupMap().keySet(),\n                        ServiceUriPaths.PROCESS_LOG);\n            } catch (Throwable e) {\n                this.host.log(\"Failure retrieving process logs: %s\", Utils.toString(e));\n            }\n\n            try {\n                this.host.logNodeManagementState(this.host.getNodeGroupMap().keySet());\n            } catch (Throwable e) {\n                this.host.log(\"Failure retrieving management state: %s\", Utils.toString(e));\n            }\n        }\n\n        this.host.tearDownInProcessPeers();\n        this.host.toggleNegativeTestMode(false);\n        this.host.tearDown();\n        this.host = null;\n\n        System.clearProperty(\n                NodeSelectorReplicationService.PROPERTY_NAME_REPLICA_NOT_FOUND_TIMEOUT_MICROS);\n    }\n\n    @Test\n    public void synchronizationCollisionWithPosts() throws Throwable {\n        // POST requests go through the FactoryService\n        // and do not get queued with Synchronization\n        // requests, so if synchronization was running\n        // while POSTs were happening for the same factory\n        // service, we could run into collisions. This test\n        // verifies that xenon handles such collisions and\n        // POST requests are always successful.\n\n        // Join the nodes with full quorum and wait for nodes to\n        // converge and synchronization to complete.\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        // Find the owner node for /core/examples. We will\n        // use it to start on-demand synchronization for\n        // this factory\n        URI factoryUri = UriUtils.buildUri(this.host.getPeerHost(), ExampleService.FACTORY_LINK);\n        waitForReplicatedFactoryServiceAvailable(factoryUri, this.replicationNodeSelector);\n\n        String taskPath = UriUtils.buildUriPath(\n                SynchronizationTaskService.FACTORY_LINK,\n                UriUtils.convertPathCharsFromLink(ExampleService.FACTORY_LINK));\n\n        VerificationHost owner = null;\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            if (peer.isOwner(ExampleService.FACTORY_LINK, ServiceUriPaths.DEFAULT_NODE_SELECTOR)) {\n                owner = peer;\n                break;\n            }\n        }\n        this.host.log(Level.INFO, \"Owner of synch-task is %s\", owner.getId());\n\n        // Get the membershipUpdateTimeMicros so that we can\n        // kick-off the synch-task on-demand.\n        URI taskUri = UriUtils.buildUri(owner, taskPath);\n        SynchronizationTaskService.State taskState = this.host.getServiceState(\n                null, SynchronizationTaskService.State.class, taskUri);\n        long membershipUpdateTimeMicros = taskState.membershipUpdateTimeMicros;\n\n        // Start posting and in the middle also start\n        // synchronization. All POSTs should succeed!\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"testing\";\n        TestContext ctx = this.host.testCreate((this.serviceCount * 10) + 1);\n        for (int i = 0; i < this.serviceCount * 10; i++) {\n            if (i == 5) {\n                SynchronizationTaskService.State task = new SynchronizationTaskService.State();\n                task.documentSelfLink = UriUtils.convertPathCharsFromLink(ExampleService.FACTORY_LINK);\n                task.factorySelfLink = ExampleService.FACTORY_LINK;\n                task.factoryStateKind = Utils.buildKind(ExampleService.ExampleServiceState.class);\n                task.membershipUpdateTimeMicros = membershipUpdateTimeMicros + 1;\n                task.nodeSelectorLink = ServiceUriPaths.DEFAULT_NODE_SELECTOR;\n                task.queryResultLimit = 1000;\n                task.taskInfo = TaskState.create();\n                task.taskInfo.isDirect = true;\n\n                Operation post = Operation\n                        .createPost(owner, SynchronizationTaskService.FACTORY_LINK)\n                        .setBody(task)\n                        .setReferer(this.host.getUri())\n                        .setCompletion(ctx.getCompletion());\n                this.host.sendRequest(post);\n            }\n            Operation post = Operation\n                    .createPost(factoryUri)\n                    .setBody(state)\n                    .setReferer(this.host.getUri())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(post);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void recognizeSelfInPeerNodesByPublicUri() throws Throwable {\n        String id = \"node-\" + VerificationHost.hostNumber.incrementAndGet();\n        String publicUri = \"http://myhostname.local:\";\n\n        // In order not to hardcode a port, 0 is used which will pick random port.\n        // The value of the random port is then used to set the initialPeerNodes and publicUri is if they\n        // used the assigned port to begin with.\n        ExampleServiceHost nodeA = new ExampleServiceHost() {\n            @Override\n            public List<URI> getInitialPeerHosts() {\n                try {\n                    Field field = ServiceHost.class.getDeclaredField(\"state\");\n                    field.setAccessible(true);\n                    ServiceHostState s = (ServiceHostState) field.get(this);\n                    s.initialPeerNodes = new String[] { publicUri + getPort() };\n                    s.publicUri = URI.create(publicUri + getPort());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n\n                return super.getInitialPeerHosts();\n            }\n        };\n        TemporaryFolder tmpFolderA = new TemporaryFolder();\n        tmpFolderA.create();\n        try {\n            String[] args = {\n                    \"--port=0\",\n                    \"--id=\" + id,\n                    \"--publicUri=\" + publicUri,\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\" + tmpFolderA.getRoot().getAbsolutePath()\n            };\n\n            nodeA.initialize(args);\n            nodeA.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n            nodeA.start();\n\n            URI nodeGroupUri = UriUtils.buildUri(nodeA, ServiceUriPaths.DEFAULT_NODE_GROUP, null);\n\n            TestRequestSender sender = new TestRequestSender(nodeA);\n            Operation op = Operation.createGet(nodeGroupUri)\n                    .setReferer(nodeA.getUri());\n\n            NodeGroupState nodeGroupState = sender.sendAndWait(op, NodeGroupState.class);\n\n            assertEquals(1, nodeGroupState.nodes.size());\n            assertEquals(1, nodeGroupState.nodes.values().iterator().next().membershipQuorum);\n        } finally {\n            tmpFolderA.delete();\n            nodeA.stop();\n        }\n    }\n\n    @Test\n    public void commandLineJoinRetries() throws Throwable {\n        this.host = VerificationHost.create(0);\n        this.host.start();\n\n        ExampleServiceHost nodeA = null;\n        TemporaryFolder tmpFolderA = new TemporaryFolder();\n        tmpFolderA.create();\n        this.setUp(1);\n        try {\n            // start a node, supplying a bogus peer. Verify we retry, up to expiration which is\n            // the operation timeout\n            nodeA = new ExampleServiceHost();\n\n            String id = \"nodeA-\" + VerificationHost.hostNumber.incrementAndGet();\n            int bogusPort = 1;\n            String[] args = {\n                    \"--port=0\",\n                    \"--id=\" + id,\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\" + tmpFolderA.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + \"http://127.0.0.1:\" + bogusPort\n            };\n\n            nodeA.initialize(args);\n            nodeA.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n            nodeA.start();\n\n            // verify we see a specific retry stat\n            URI nodeGroupUri = UriUtils.buildUri(nodeA, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            URI statsUri = UriUtils.buildStatsUri(nodeGroupUri);\n            this.host.waitFor(\"expected stat did not converge\", () -> {\n                ServiceStats stats = this.host.getServiceState(null, ServiceStats.class, statsUri);\n                ServiceStat st = stats.entries.get(NodeGroupService.STAT_NAME_JOIN_RETRY_COUNT);\n                if (st == null || st.latestValue < 1) {\n                    return false;\n                }\n                return true;\n            });\n\n        } finally {\n            if (nodeA != null) {\n                nodeA.stop();\n                tmpFolderA.delete();\n            }\n        }\n    }\n\n    @Test\n    public void synchronizationOnDemandLoad() throws Throwable {\n        // Setup peer nodes\n        setUp(this.nodeCount);\n\n        long intervalMicros = TimeUnit.MILLISECONDS.toMicros(200);\n\n        // Start the ODL Factory service on all the peers.\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            // Reduce cache clear delay to short duration\n            // to cause ODL service stops.\n            h.setServiceCacheClearDelayMicros(h.getMaintenanceIntervalMicros());\n\n            // create an on demand load factory and services\n            OnDemandLoadFactoryService.create(h);\n        }\n\n        // join the nodes and set full quorum.\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(OnDemandLoadFactoryService.SELF_LINK),\n                this.replicationNodeSelector);\n\n        // Create a few child-services.\n        VerificationHost h = this.host.getPeerHost();\n        Map<URI, ExampleServiceState> childServices = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState initialState = new ExampleServiceState();\n                    initialState.name = UUID.randomUUID().toString();\n                    o.setBody(initialState);\n                },\n                UriUtils.buildFactoryUri(h, OnDemandLoadFactoryService.class));\n\n        // Verify that each peer host reports the correct value for ODL stop count.\n        for (VerificationHost vh : this.host.getInProcessHostMap().values()) {\n            this.host.waitFor(\"ODL services did not stop as expected\",\n                    () -> checkOdlServiceStopCount(vh, this.serviceCount));\n        }\n\n        // Add a new host to the cluster.\n        VerificationHost newHost = this.host.setUpLocalPeerHost(0, h.getMaintenanceIntervalMicros(),\n                null);\n        newHost.setServiceCacheClearDelayMicros(intervalMicros);\n        OnDemandLoadFactoryService.create(newHost);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount + 1);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(OnDemandLoadFactoryService.SELF_LINK),\n                this.replicationNodeSelector);\n\n        // Do GETs on each previously created child services by calling the newly added host.\n        // This will trigger synchronization for the child services.\n        this.host.log(Level.INFO, \"Verifying synchronization for ODL services\");\n        for (Entry<URI, ExampleServiceState> childService : childServices.entrySet()) {\n            String childServicePath = childService.getKey().getPath();\n            ExampleServiceState state = this.host.getServiceState(null,\n                    ExampleServiceState.class, UriUtils.buildUri(newHost, childServicePath));\n            assertNotNull(state);\n        }\n\n        // Verify that the new peer host reports the correct value for ODL stop count.\n        this.host.waitFor(\"ODL services did not stop as expected\",\n                () -> checkOdlServiceStopCount(newHost, this.serviceCount));\n    }\n\n    private boolean checkOdlServiceStopCount(VerificationHost host, int serviceCount)\n            throws Throwable {\n        ServiceStat stopCount = host\n                .getServiceStats(host.getManagementServiceUri())\n                .get(ServiceHostManagementService.STAT_NAME_ODL_STOP_COUNT);\n        if (stopCount == null || stopCount.latestValue < serviceCount) {\n            this.host.log(Level.INFO,\n                    \"Current stopCount is %s\",\n                    (stopCount != null) ? String.valueOf(stopCount.latestValue) : \"null\");\n            return false;\n        }\n        return true;\n    }\n\n    @Test\n    public void customNodeGroupWithObservers() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            Logger.getAnonymousLogger().info(\"Iteration: \" + i);\n            verifyCustomNodeGroupWithObservers();\n            tearDown();\n        }\n    }\n\n    private void verifyCustomNodeGroupWithObservers() throws Throwable {\n        setUp(this.nodeCount);\n        // on one of the hosts create the custom group but with self as an observer. That peer should\n        // never receive replicated or broadcast requests\n        URI observerHostUri = this.host.getPeerHostUri();\n        ServiceHostState observerHostState = this.host.getServiceState(null,\n                ServiceHostState.class,\n                UriUtils.buildUri(observerHostUri, ServiceUriPaths.CORE_MANAGEMENT));\n        Map<URI, NodeState> selfStatePerNode = new HashMap<>();\n        NodeState observerSelfState = new NodeState();\n        observerSelfState.id = observerHostState.id;\n        observerSelfState.options = EnumSet.of(NodeOption.OBSERVER);\n\n        selfStatePerNode.put(observerHostUri, observerSelfState);\n        this.host.createCustomNodeGroupOnPeers(CUSTOM_NODE_GROUP_NAME, selfStatePerNode);\n\n        final String customFactoryLink = \"custom-factory\";\n        // start a node selector attached to the custom group\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            NodeSelectorState initialState = new NodeSelectorState();\n            initialState.nodeGroupLink = CUSTOM_NODE_GROUP;\n            h.startServiceAndWait(new ConsistentHashingNodeSelectorService(),\n                    CUSTOM_GROUP_NODE_SELECTOR, initialState);\n            // start the factory that is attached to the custom group selector\n            h.startServiceAndWait(ExampleFactoryServiceWithCustomSelector.class, customFactoryLink);\n        }\n\n        URI customNodeGroupServiceOnObserver = UriUtils\n                .buildUri(observerHostUri, CUSTOM_NODE_GROUP);\n        Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode = new HashMap<>();\n        expectedOptionsPerNode.put(customNodeGroupServiceOnObserver,\n                observerSelfState.options);\n\n        this.host.joinNodesAndVerifyConvergence(CUSTOM_NODE_GROUP, this.nodeCount,\n                this.nodeCount, expectedOptionsPerNode);\n        // one of the nodes is observer, so we must set quorum to 2 explicitly\n        this.host.setNodeGroupQuorum(2, customNodeGroupServiceOnObserver);\n        this.host.waitForNodeSelectorQuorumConvergence(CUSTOM_GROUP_NODE_SELECTOR, 2);\n        this.host.waitForNodeGroupIsAvailableConvergence(CUSTOM_NODE_GROUP);\n\n        int restartCount = 0;\n        // verify that the observer node shows up as OBSERVER on all peers, including self\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            URI customNodeGroupUri = UriUtils.buildUri(hostUri, CUSTOM_NODE_GROUP);\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    customNodeGroupUri);\n\n            for (NodeState ns : ngs.nodes.values()) {\n                if (ns.id.equals(observerHostState.id)) {\n                    assertTrue(ns.options.contains(NodeOption.OBSERVER));\n                } else {\n                    assertTrue(ns.options.contains(NodeOption.PEER));\n                }\n            }\n\n            ServiceStats nodeGroupStats = this.host.getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(customNodeGroupUri));\n            ServiceStat restartStat = nodeGroupStats.entries\n                    .get(NodeGroupService.STAT_NAME_RESTARTING_SERVICES_COUNT);\n            if (restartStat != null) {\n                restartCount += restartStat.latestValue;\n            }\n        }\n\n        assertEquals(\"expected different number of service restarts\", restartCount, 0);\n\n        // join all the nodes through the default group, making sure another group still works\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount, true);\n\n        URI observerFactoryUri = UriUtils.buildUri(observerHostUri, customFactoryLink);\n\n        waitForReplicatedFactoryServiceAvailable(observerFactoryUri, CUSTOM_GROUP_NODE_SELECTOR);\n\n        // create N services on the custom group, verify none of them got created on the observer.\n        // We actually post directly to the observer node, which should forward to the other nodes\n        Map<URI, ExampleServiceState> serviceStatesOnPost = this.host.doFactoryChildServiceStart(\n                null, this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState body = new ExampleServiceState();\n                    body.name = Utils.getNowMicrosUtc() + \"\";\n                    o.setBody(body);\n                },\n                observerFactoryUri);\n\n        ServiceDocumentQueryResult r = this.host.getFactoryState(observerFactoryUri);\n        assertEquals(0, r.documentLinks.size());\n\n        // do a GET on each service and confirm the owner id is never that of the observer node\n        Map<URI, ExampleServiceState> serviceStatesFromGet = this.host.getServiceState(\n                null, ExampleServiceState.class, serviceStatesOnPost.keySet());\n\n        for (ExampleServiceState s : serviceStatesFromGet.values()) {\n            if (observerHostState.id.equals(s.documentOwner)) {\n                throw new IllegalStateException(\"Observer node reported state for service\");\n            }\n        }\n\n        // create additional example services which are not associated with the custom node group\n        // and verify that they are always included in queries which target the custom node group\n        // (e.g. that the query is never executed on the OBSERVER node).\n        createExampleServices(observerHostUri);\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND).setTermMatchValue(\n                Utils.buildKind(ExampleServiceState.class));\n        QueryTask task = QueryTask.create(q).setDirect(true);\n\n        for (Entry<URI, URI> node : this.host.getNodeGroupMap().entrySet()) {\n            URI nodeUri = node.getKey();\n            URI serviceUri = UriUtils.buildUri(nodeUri, ServiceUriPaths.CORE_LOCAL_QUERY_TASKS);\n            URI forwardQueryUri = UriUtils.buildForwardRequestUri(serviceUri, null,\n                    CUSTOM_GROUP_NODE_SELECTOR);\n            TestContext ctx = this.host.testCreate(1);\n            Operation post = Operation\n                    .createPost(forwardQueryUri)\n                    .setBody(task)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            ctx.fail(e);\n                            return;\n                        }\n\n                        QueryTask rsp = o.getBody(QueryTask.class);\n                        int resultCount = rsp.results.documentLinks.size();\n                        if (resultCount != 2 * this.serviceCount) {\n                            ctx.fail(new IllegalStateException(\n                                    \"Forwarded query returned unexpected document count \" +\n                                            resultCount));\n                            return;\n                        }\n\n                        ctx.complete();\n                    });\n            this.host.send(post);\n            ctx.await();\n        }\n\n        task.querySpec.options = EnumSet.of(QueryTask.QuerySpecification.QueryOption.BROADCAST);\n        task.nodeSelectorLink = CUSTOM_GROUP_NODE_SELECTOR;\n        URI queryPostUri = UriUtils.buildUri(observerHostUri, ServiceUriPaths.CORE_QUERY_TASKS);\n        TestContext ctx = this.host.testCreate(1);\n        Operation post = Operation\n                .createPost(queryPostUri)\n                .setBody(task)\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx.fail(e);\n                        return;\n                    }\n\n                    QueryTask rsp = o.getBody(QueryTask.class);\n                    int resultCount = rsp.results.documentLinks.size();\n                    if (resultCount != 2 * this.serviceCount) {\n                        ctx.fail(new IllegalStateException(\n                                \"Broadcast query returned unexpected document count \" +\n                                        resultCount));\n                        return;\n                    }\n\n                    ctx.complete();\n                });\n        this.host.send(post);\n        ctx.await();\n\n        URI existingNodeGroup = this.host.getPeerNodeGroupUri();\n\n        // start more nodes, insert them to existing group, but with no synchronization required\n        // start some additional nodes\n        Collection<VerificationHost> existingHosts = this.host.getInProcessHostMap().values();\n        int additionalHostCount = this.nodeCount;\n        this.host.setUpPeerHosts(additionalHostCount);\n\n        List<ServiceHost> newHosts = Collections.synchronizedList(new ArrayList<>());\n        newHosts.addAll(this.host.getInProcessHostMap().values());\n        newHosts.removeAll(existingHosts);\n\n        expectedOptionsPerNode.clear();\n        // join new nodes with existing node group.\n\n        TestContext testContext = this.host.testCreate(newHosts.size());\n        for (ServiceHost h : newHosts) {\n            URI newCustomNodeGroupUri = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n            JoinPeerRequest joinBody = JoinPeerRequest.create(existingNodeGroup, null);\n            joinBody.localNodeOptions = EnumSet.of(NodeOption.PEER);\n            this.host.send(Operation.createPost(newCustomNodeGroupUri)\n                    .setBody(joinBody)\n                    .setCompletion(testContext.getCompletion()));\n            expectedOptionsPerNode.put(newCustomNodeGroupUri, joinBody.localNodeOptions);\n        }\n\n        testContext.await();\n        this.host.waitForNodeGroupConvergence(this.host.getNodeGroupMap().values(),\n                this.host.getNodeGroupMap().size(),\n                this.host.getNodeGroupMap().size(),\n                expectedOptionsPerNode, false);\n\n        restartCount = 0;\n        // do another restart check. None of the new nodes should have reported restarts\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            URI nodeGroupUri = UriUtils.buildUri(hostUri, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            ServiceStats nodeGroupStats = this.host.getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(nodeGroupUri));\n            ServiceStat restartStat = nodeGroupStats.entries\n                    .get(NodeGroupService.STAT_NAME_RESTARTING_SERVICES_COUNT);\n            if (restartStat != null) {\n                restartCount += restartStat.latestValue;\n            }\n        }\n\n        assertEquals(\"expected different number of service restarts\", 0,\n                restartCount);\n    }\n\n    @Test\n    public void verifyGossipForObservers() throws Throwable {\n        setUp(this.nodeCount);\n\n        Iterator<Entry<URI, URI>> nodeGroupIterator = this.host.getNodeGroupMap().entrySet()\n                .iterator();\n        URI observerUri = nodeGroupIterator.next().getKey();\n        String observerId = this.host.getServiceState(null,\n                ServiceHostState.class,\n                UriUtils.buildUri(observerUri, ServiceUriPaths.CORE_MANAGEMENT)).id;\n\n        // Create a custom node group. Mark one node as OBSERVER and rest as PEER\n        Map<URI, NodeState> selfStatePerNode = new HashMap<>();\n        NodeState observerSelfState = new NodeState();\n        observerSelfState.id = observerId;\n        observerSelfState.options = EnumSet.of(NodeOption.OBSERVER);\n        selfStatePerNode.put(observerUri, observerSelfState);\n        this.host.createCustomNodeGroupOnPeers(CUSTOM_NODE_GROUP_NAME, selfStatePerNode);\n\n        // Pick a PEER and join it to each node in the node-group\n        URI peerUri = nodeGroupIterator.next().getKey();\n        URI peerCustomUri = UriUtils.buildUri(peerUri, CUSTOM_NODE_GROUP);\n\n        Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode = new HashMap<>();\n        Set<URI> customNodeUris = new HashSet<>();\n\n        for (Entry<URI, URI> node : this.host.getNodeGroupMap().entrySet()) {\n            URI nodeUri = node.getKey();\n            URI nodeCustomUri = UriUtils.buildUri(nodeUri, CUSTOM_NODE_GROUP);\n\n            JoinPeerRequest request = new JoinPeerRequest();\n            request.memberGroupReference = nodeCustomUri;\n            TestContext ctx = this.host.testCreate(1);\n            Operation post = Operation\n                    .createPost(peerCustomUri)\n                    .setBody(request)\n                    .setReferer(this.host.getReferer())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(post);\n            ctx.await();\n\n            expectedOptionsPerNode.put(nodeCustomUri,\n                    EnumSet.of((nodeUri == observerUri)\n                            ? NodeOption.OBSERVER : NodeOption.PEER));\n            customNodeUris.add(nodeCustomUri);\n        }\n\n        // Verify that gossip will propagate the single OBSERVER and the PEER nodes\n        // to every node in the custom node-group.\n        this.host.waitForNodeGroupConvergence(\n                customNodeUris, this.nodeCount, this.nodeCount, expectedOptionsPerNode, false);\n    }\n\n    @Test\n    public void synchronizationOneByOneWithAbruptNodeShutdown() throws Throwable {\n        setUp(this.nodeCount);\n\n        this.replicationTargetFactoryLink = PeriodicExampleFactoryService.SELF_LINK;\n        // start the periodic example service factory on each node\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.startServiceAndWait(PeriodicExampleFactoryService.class,\n                    PeriodicExampleFactoryService.SELF_LINK);\n        }\n\n        // On one host, add some services. They exist only on this host and we expect them to synchronize\n        // across all hosts once this one joins with the group\n        VerificationHost initialHost = this.host.getPeerHost();\n        URI hostUriWithInitialState = initialHost.getUri();\n        Map<String, ExampleServiceState> exampleStatesPerSelfLink = createExampleServices(\n                hostUriWithInitialState);\n\n        URI hostWithStateNodeGroup = UriUtils.buildUri(hostUriWithInitialState,\n                ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n        // before start joins, verify isolated factory synchronization is done\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            waitForReplicatedFactoryServiceAvailable(\n                    UriUtils.buildUri(hostUri, this.replicationTargetFactoryLink),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        }\n\n        // join a node, with no state, one by one, to the host with state.\n        // The steps are:\n        // 1) set quorum to node group size + 1\n        // 2) Join new empty node with existing node group\n        // 3) verify convergence of factory state\n        // 4) repeat\n\n        List<URI> joinedHosts = new ArrayList<>();\n        Map<URI, URI> factories = new HashMap<>();\n        factories.put(hostWithStateNodeGroup, UriUtils.buildUri(hostWithStateNodeGroup,\n                this.replicationTargetFactoryLink));\n        joinedHosts.add(hostWithStateNodeGroup);\n        int fullQuorum = 1;\n\n        for (URI nodeGroupUri : this.host.getNodeGroupMap().values()) {\n            // skip host with state\n            if (hostWithStateNodeGroup.equals(nodeGroupUri)) {\n                continue;\n            }\n\n            this.host.log(\"Setting quorum to %d, already joined: %d\",\n                    fullQuorum + 1, joinedHosts.size());\n            // set quorum to expected full node group size, for the setup hosts\n            this.host.setNodeGroupQuorum(++fullQuorum);\n\n            this.host.testStart(1);\n            // join empty node, with node with state\n            this.host.joinNodeGroup(hostWithStateNodeGroup, nodeGroupUri, fullQuorum);\n            this.host.testWait();\n            joinedHosts.add(nodeGroupUri);\n            factories.put(nodeGroupUri, UriUtils.buildUri(nodeGroupUri,\n                    this.replicationTargetFactoryLink));\n            this.host.waitForNodeGroupConvergence(joinedHosts, fullQuorum, fullQuorum, true);\n            this.host.waitForNodeGroupIsAvailableConvergence(nodeGroupUri.getPath(), joinedHosts);\n\n            this.waitForReplicatedFactoryChildServiceConvergence(\n                    factories,\n                    exampleStatesPerSelfLink,\n                    this.exampleStateConvergenceChecker, exampleStatesPerSelfLink.size(),\n                    0);\n\n            // Do updates, which will verify that the services are converged in terms of ownership.\n            // Since we also synchronize on demand, if there was any discrepancy, after updates, the\n            // services will converge\n            doExampleServicePatch(exampleStatesPerSelfLink,\n                    joinedHosts.get(0));\n\n            Set<String> ownerIds = this.host.getNodeStateMap().keySet();\n            verifyDocumentOwnerAndEpoch(exampleStatesPerSelfLink, initialHost, joinedHosts, 0, 1,\n                    ownerIds.size() - 1);\n        }\n\n        doNodeStopWithUpdates(exampleStatesPerSelfLink);\n    }\n\n    private void doExampleServicePatch(Map<String, ExampleServiceState> states,\n            URI nodeGroupOnSomeHost) throws Throwable {\n        this.host.log(\"Starting PATCH to %d example services\", states.size());\n        TestContext ctx = this.host\n                .testCreate(this.updateCount * states.size());\n\n        this.setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(this.host.getTimeoutSeconds()));\n\n        for (int i = 0; i < this.updateCount; i++) {\n            for (Entry<String, ExampleServiceState> e : states.entrySet()) {\n                ExampleServiceState st = Utils.clone(e.getValue());\n                st.counter = (long) i;\n                Operation patch = Operation\n                        .createPatch(UriUtils.buildUri(nodeGroupOnSomeHost, e.getKey()))\n                        .setCompletion(ctx.getCompletion())\n                        .setBody(st);\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait(ctx);\n        this.host.log(\"Done with PATCH to %d example services\", states.size());\n    }\n\n    public void doNodeStopWithUpdates(Map<String, ExampleServiceState> exampleStatesPerSelfLink)\n            throws Throwable {\n        this.host.log(\"Starting to stop nodes and send updates\");\n        VerificationHost remainingHost = this.host.getPeerHost();\n        Collection<VerificationHost> hostsToStop = new ArrayList<>(this.host.getInProcessHostMap()\n                .values());\n        hostsToStop.remove(remainingHost);\n        List<URI> targetServices = new ArrayList<>();\n        for (String link : exampleStatesPerSelfLink.keySet()) {\n            // build the URIs using the host we plan to keep, so the maps we use below to lookup\n            // stats from URIs, work before and after node stop\n            targetServices.add(UriUtils.buildUri(remainingHost, link));\n        }\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setPeerSynchronizationTimeLimitSeconds(this.host.getTimeoutSeconds() / 3);\n        }\n\n        // capture current stats from each service\n        Map<URI, ServiceStats> prevStats = verifyMaintStatsAfterSynchronization(targetServices,\n                null);\n\n        stopHostsAndVerifyQueuing(hostsToStop, remainingHost, targetServices);\n\n        // its important to verify document ownership before we do any updates on the services.\n        // This is because we verify, that even without any on demand synchronization,\n        // the factory driven synchronization set the services in the proper state\n        Set<String> ownerIds = this.host.getNodeStateMap().keySet();\n        List<URI> remainingHosts = new ArrayList<>(this.host.getNodeGroupMap().keySet());\n        verifyDocumentOwnerAndEpoch(exampleStatesPerSelfLink,\n                this.host.getInProcessHostMap().values().iterator().next(),\n                remainingHosts, 0, 1,\n                ownerIds.size() - 1);\n\n        // confirm maintenance is back up and running on all services\n        verifyMaintStatsAfterSynchronization(targetServices, prevStats);\n\n        // nodes are stopped, do updates again, quorum is relaxed, they should work\n        doExampleServicePatch(exampleStatesPerSelfLink, remainingHost.getUri());\n\n        this.host.log(\"Done with stop nodes and send updates\");\n    }\n\n    private void verifyDynamicMaintOptionToggle(Map<String, ExampleServiceState> childStates) {\n\n        List<URI> targetServices = new ArrayList<>();\n        childStates.keySet().forEach((l) -> targetServices.add(this.host.getPeerServiceUri(l)));\n\n        List<URI> targetServiceStats = new ArrayList<>();\n        List<URI> targetServiceConfig = new ArrayList<>();\n        for (URI child : targetServices) {\n            targetServiceStats.add(UriUtils.buildStatsUri(child));\n            targetServiceConfig.add(UriUtils.buildConfigUri(child));\n        }\n\n        Map<URI, ServiceConfiguration> configPerService = this.host.getServiceState(\n                null, ServiceConfiguration.class, targetServiceConfig);\n        for (ServiceConfiguration cfg : configPerService.values()) {\n            assertTrue(!cfg.options.contains(ServiceOption.PERIODIC_MAINTENANCE));\n        }\n\n        for (URI child : targetServices) {\n            this.host.toggleServiceOptions(child,\n                    EnumSet.of(ServiceOption.PERIODIC_MAINTENANCE),\n                    null);\n        }\n\n        verifyMaintStatsAfterSynchronization(targetServices, null);\n    }\n\n    private Map<URI, ServiceStats> verifyMaintStatsAfterSynchronization(List<URI> targetServices,\n            Map<URI, ServiceStats> statsPerService) {\n\n        List<URI> targetServiceStats = new ArrayList<>();\n        List<URI> targetServiceConfig = new ArrayList<>();\n        for (URI child : targetServices) {\n            targetServiceStats.add(UriUtils.buildStatsUri(child));\n            targetServiceConfig.add(UriUtils.buildConfigUri(child));\n        }\n\n        if (statsPerService == null) {\n            statsPerService = new HashMap<>();\n        }\n        final Map<URI, ServiceStats> previousStatsPerService = statsPerService;\n        this.host.waitFor(\n                \"maintenance not enabled\",\n                () -> {\n                    Map<URI, ServiceStats> stats = this.host.getServiceState(null,\n                            ServiceStats.class, targetServiceStats);\n                    for (Entry<URI, ServiceStats> currentEntry : stats.entrySet()) {\n                        ServiceStats previousStats = previousStatsPerService.get(currentEntry\n                                .getKey());\n                        ServiceStats currentStats = currentEntry.getValue();\n                        ServiceStat previousMaintStat = previousStats == null ? new ServiceStat()\n                                : previousStats.entries\n                                .get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                        double previousValue = previousMaintStat == null ? 0L\n                                : previousMaintStat.latestValue;\n                        ServiceStat maintStat = currentStats.entries\n                                .get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                        if (maintStat == null || maintStat.latestValue <= previousValue) {\n                            return false;\n                        }\n                    }\n                    previousStatsPerService.putAll(stats);\n                    return true;\n                });\n        return statsPerService;\n    }\n\n    private Map<String, ExampleServiceState> createExampleServices(URI hostUri) throws Throwable {\n        URI factoryUri = UriUtils.buildUri(hostUri, this.replicationTargetFactoryLink);\n        this.host.log(\"POSTing children to %s\", hostUri);\n\n        // add some services on one of the peers, so we can verify the get synchronized after they all join\n        Map<URI, ExampleServiceState> exampleStates = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState s = new ExampleServiceState();\n                    s.name = UUID.randomUUID().toString();\n                    o.setBody(s);\n                }, factoryUri);\n\n        Map<String, ExampleServiceState> exampleStatesPerSelfLink = new HashMap<>();\n\n        for (ExampleServiceState s : exampleStates.values()) {\n            exampleStatesPerSelfLink.put(s.documentSelfLink, s);\n        }\n        return exampleStatesPerSelfLink;\n    }\n\n    @Test\n    public void synchronizationWithPeerNodeListAndDuplicates() throws Throwable {\n        ExampleServiceHost h = null;\n\n        TemporaryFolder tmpFolder = new TemporaryFolder();\n        tmpFolder.create();\n\n        try {\n            setUp(this.nodeCount);\n\n            // the hosts are started, but not joined. We need to relax the quorum for any updates\n            // to go through\n            this.host.setNodeGroupQuorum(1);\n\n            Map<String, ExampleServiceState> exampleStatesPerSelfLink = new HashMap<>();\n\n            // add the *same* service instance, all *all* peers, so we force synchronization and epoch\n            // change on an instance that exists everywhere\n\n            int dupServiceCount = this.serviceCount;\n            AtomicInteger counter = new AtomicInteger();\n            Map<URI, ExampleServiceState> dupStates = new HashMap<>();\n            for (VerificationHost v : this.host.getInProcessHostMap().values()) {\n                counter.set(0);\n                URI factoryUri = UriUtils.buildFactoryUri(v,\n                        ExampleService.class);\n                dupStates = this.host.doFactoryChildServiceStart(\n                        null,\n                        dupServiceCount,\n                        ExampleServiceState.class,\n                        (o) -> {\n                            ExampleServiceState s = new ExampleServiceState();\n                            s.documentSelfLink = \"duplicateExampleInstance-\"\n                                    + counter.incrementAndGet();\n                            s.name = s.documentSelfLink;\n                            o.setBody(s);\n                        }, factoryUri);\n            }\n\n            for (ExampleServiceState s : dupStates.values()) {\n                exampleStatesPerSelfLink.put(s.documentSelfLink, s);\n            }\n\n            // increment to account for link found on all nodes\n            this.serviceCount = exampleStatesPerSelfLink.size();\n\n            // create peer argument list, all the nodes join.\n            Collection<URI> peerNodeGroupUris = new ArrayList<>();\n            StringBuilder peerNodes = new StringBuilder();\n            for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n                peerNodeGroupUris.add(UriUtils.buildUri(peer, ServiceUriPaths.DEFAULT_NODE_GROUP));\n                peerNodes.append(peer.getUri().toString()).append(\",\");\n            }\n\n            CountDownLatch notifications = new CountDownLatch(this.nodeCount);\n            for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n                this.host.subscribeForNodeGroupConvergence(nodeGroup, this.nodeCount + 1,\n                        (o, e) -> {\n                            if (e != null) {\n                                this.host.log(\"Error in notificaiton: %s\", Utils.toString(e));\n                                return;\n                            }\n                            notifications.countDown();\n                        });\n            }\n\n            // now start a new Host and supply the already created peer, then observe the automatic\n            // join\n            h = new ExampleServiceHost();\n            int quorum = this.host.getPeerCount() + 1;\n\n            String mainHostId = \"main-\" + VerificationHost.hostNumber.incrementAndGet();\n            String[] args = {\n                    \"--port=0\",\n                    \"--id=\" + mainHostId,\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + peerNodes.toString()\n            };\n\n            h.initialize(args);\n\n            h.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled);\n            h.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n\n            h.start();\n            URI mainHostNodeGroupUri = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n            int totalCount = this.nodeCount + 1;\n            peerNodeGroupUris.add(mainHostNodeGroupUri);\n            this.host.waitForNodeGroupIsAvailableConvergence();\n            this.host.waitForNodeGroupConvergence(peerNodeGroupUris, totalCount,\n                    totalCount, true);\n\n            this.host.setNodeGroupQuorum(quorum, mainHostNodeGroupUri);\n            this.host.setNodeGroupQuorum(quorum);\n\n            this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n\n            int peerNodeCount = h.getInitialPeerHosts().size();\n            // include self in peers\n            assertTrue(totalCount >= peerNodeCount + 1);\n\n            // Before factory synch is complete, make sure POSTs to existing services fail,\n            // since they are not marked idempotent.\n            verifyReplicatedInConflictPost(dupStates);\n\n            // now verify all nodes synchronize and see the example service instances that existed on the single\n            // host\n            waitForReplicatedFactoryChildServiceConvergence(\n                    exampleStatesPerSelfLink,\n                    this.exampleStateConvergenceChecker,\n                    this.serviceCount, 0);\n\n            // Send some updates after the full group has formed  and verify the updates are seen by services on all nodes\n\n            doStateUpdateReplicationTest(Action.PATCH, this.serviceCount, this.updateCount, 0,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    exampleStatesPerSelfLink);\n\n            URI exampleFactoryUri = this.host.getPeerServiceUri(ExampleService.FACTORY_LINK);\n            waitForReplicatedFactoryServiceAvailable(\n                    UriUtils.buildUri(exampleFactoryUri, ExampleService.FACTORY_LINK),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        } finally {\n            this.host.log(\"test finished\");\n            if (h != null) {\n                h.stop();\n                tmpFolder.delete();\n            }\n        }\n    }\n\n    private void verifyReplicatedInConflictPost(Map<URI, ExampleServiceState> dupStates)\n            throws Throwable {\n        // Its impossible to guarantee that this runs during factory synch. It might run before,\n        // it might run during, it might run after. Since we runs 1000s of tests per day, CI\n        // will let us know if the production code works. Here, we add a small sleep so we increase\n        // chance we overlap with factory synchronization.\n        Thread.sleep(TimeUnit.MICROSECONDS.toMillis(\n                this.host.getPeerHost().getMaintenanceIntervalMicros()));\n        // Issue a POST for a service we know exists and expect failure, since the example service\n        // is not marked IDEMPOTENT. We expect CONFLICT error code, but if synchronization is active\n        // we want to confirm we dont get 500, but the 409 is preserved\n        TestContext ctx = this.host.testCreate(dupStates.size());\n        for (ExampleServiceState st : dupStates.values()) {\n            URI factoryUri = this.host.getPeerServiceUri(ExampleService.FACTORY_LINK);\n            Operation post = Operation.createPost(factoryUri).setBody(st)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_CONFLICT) {\n                                ctx.failIteration(new IllegalStateException(\n                                        \"Expected conflict status, got \" + o.getStatusCode()));\n                                return;\n                            }\n                            ctx.completeIteration();\n                            return;\n                        }\n                        ctx.failIteration(new IllegalStateException(\n                                \"Expected failure on duplicate POST\"));\n                    });\n            this.host.send(post);\n        }\n        this.host.testWait(ctx);\n    }\n\n    @Test\n    public void replicationWithQuorumAfterAbruptNodeStopOnDemandLoad() throws Throwable {\n        tearDown();\n        for (int i = 0; i < this.testIterationCount; i++) {\n\n            setUpOnDemandLoad();\n\n            int hostStopCount = 2;\n            doReplicationWithQuorumAfterAbruptNodeStop(hostStopCount);\n            this.host.log(\"Done with iteration %d\", i);\n            tearDown();\n            this.host = null;\n        }\n    }\n\n    private void doReplicationWithQuorumAfterAbruptNodeStop(int hostStopCount)\n            throws Throwable {\n        // create some documents\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n        updateExampleServiceOptions(childStates);\n\n        // stop minority number of hosts - quorum is still intact\n        int i = 0;\n        for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n            this.expectedFailedHosts.add(e.getKey());\n            this.host.stopHost(e.getValue());\n            if (++i >= hostStopCount) {\n                break;\n            }\n        }\n\n        // do some updates with strong quorum enabled\n        int expectedVersion = this.updateCount;\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                expectedVersion,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    @Test\n    public void replicationWithQuorumAfterAbruptNodeStopMultiLocation()\n            throws Throwable {\n        // we need 6 nodes, 3 in each location\n        this.nodeCount = 6;\n\n        this.isPeerSynchronizationEnabled = true;\n        this.skipAvailabilityChecks = true;\n        this.isMultiLocationTest = true;\n\n        if (this.host == null) {\n            // create node group, join nodes and set local majority quorum\n            setUp(this.nodeCount);\n            this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n            this.host.setNodeGroupQuorum(2);\n        }\n\n        // create some documents\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n        updateExampleServiceOptions(childStates);\n\n        // stop hosts in location \"L2\"\n        for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n            VerificationHost h = e.getValue();\n            if (h.getLocation().equals(VerificationHost.LOCATION2)) {\n                this.expectedFailedHosts.add(e.getKey());\n                this.host.stopHost(h);\n            }\n        }\n\n        // do some updates\n        int expectedVersion = this.updateCount;\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                expectedVersion,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    /**\n     * This test validates that if a host, joined in a peer node group, stops/fails and another\n     * host, listening on the same address:port, rejoins, the existing peer members will mark the\n     * OLD host instance as FAILED, and mark the new instance, with the new ID as HEALTHY\n     *\n     * @throws Throwable\n     */\n    @Test\n    public void nodeRestartWithSameAddressDifferentId() throws Throwable {\n        int failedNodeCount = 1;\n        int afterFailureQuorum = this.nodeCount - failedNodeCount;\n\n        setUp(this.nodeCount);\n        setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(5));\n\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        this.host.log(\"Stopping node\");\n\n        // relax quorum for convergence check\n        this.host.setNodeGroupQuorum(afterFailureQuorum);\n\n        // we should now have N nodes, that see each other. Stop one of the\n        // nodes, and verify the other host's node group deletes the entry\n        List<ServiceHostState> hostStates = stopHostsToSimulateFailure(failedNodeCount);\n        URI remainingPeerNodeGroup = this.host.getPeerNodeGroupUri();\n\n        // wait for convergence of the remaining peers, before restarting. The failed host\n        // should be marked FAILED, otherwise we will not converge\n        this.host.waitForNodeGroupConvergence(this.nodeCount - failedNodeCount);\n\n        ServiceHostState stoppedHostState = hostStates.get(0);\n\n        // start a new HOST, with a new ID, but with the same address:port as the one we stopped\n        this.host.testStart(1);\n        VerificationHost newHost = this.host.setUpLocalPeerHost(stoppedHostState.httpPort,\n                VerificationHost.FAST_MAINT_INTERVAL_MILLIS, null);\n        this.host.testWait();\n\n        // re-join the remaining peers\n        URI newHostNodeGroupService = UriUtils\n                .buildUri(newHost.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.host.testStart(1);\n        this.host.joinNodeGroup(newHostNodeGroupService, remainingPeerNodeGroup);\n        this.host.testWait();\n\n        // now wait for convergence. If the logic is correct, the old HOST, that listened on the\n        // same port as the new host, should stay in the FAILED state, but the new host should\n        // be marked as HEALTHY\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n    }\n\n    public void setMaintenanceIntervalMillis(long defaultMaintIntervalMillis) {\n        for (VerificationHost h1 : this.host.getInProcessHostMap().values()) {\n            // set short interval so failure detection and convergence happens quickly\n            h1.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(defaultMaintIntervalMillis));\n        }\n    }\n\n    @Test\n    public void synchronizationRequestQueuing() throws Throwable {\n        setUp(this.nodeCount);\n\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicationFactoryConvergence();\n\n        VerificationHost peerHost = this.host.getPeerHost();\n\n        List<URI> exampleUris = new ArrayList<>();\n        this.host.createExampleServices(peerHost, 1, exampleUris, null);\n\n        URI instanceUri = exampleUris.get(0);\n\n        ExampleServiceState synchState = new ExampleServiceState();\n        synchState.documentSelfLink = UriUtils.getLastPathSegment(instanceUri);\n\n        TestContext ctx = this.host.testCreate(this.updateCount);\n        for (int i = 0; i < this.updateCount; i++) {\n            Operation op = Operation.createPost(peerHost, ExampleService.FACTORY_LINK)\n                    .setBody(synchState)\n                    .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SYNCH_OWNER)\n                    .setReferer(this.host.getUri())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(op);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void enforceHighQuorumWithNodeConcurrentStop()\n            throws Throwable {\n        int hostRestartCount = 2;\n\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n\n        updateExampleServiceOptions(childStates);\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setPeerSynchronizationTimeLimitSeconds(1);\n        }\n\n        this.host.setNodeGroupConfig(this.nodeGroupConfig);\n        this.host.setNodeGroupQuorum((this.nodeCount + 1) / 2);\n\n        // do some replication with strong quorum enabled\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                0,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        long now = Utils.getNowMicrosUtc();\n\n        validatePerOperationReplicationQuorum(childStates, now);\n\n        // expect failure, since we will stop some hosts, break quorum\n        this.expectFailure = true;\n\n        // when quorum is not met the runtime will just queue requests until expiration, so\n        // we set expiration to something quick. Some requests will make it past queuing\n        // and will fail because replication quorum is not met\n        long opTimeoutMicros = TimeUnit.MILLISECONDS.toMicros(500);\n        setOperationTimeoutMicros(opTimeoutMicros);\n\n        int i = 0;\n        for (URI h : this.host.getInProcessHostMap().keySet()) {\n            this.expectedFailedHosts.add(h);\n            if (++i >= hostRestartCount) {\n                break;\n            }\n        }\n\n        // stop one host right away\n        stopHostsToSimulateFailure(1);\n\n        // concurrently with the PATCH requests below, stop another host\n        Runnable r = () -> {\n            stopHostsToSimulateFailure(hostRestartCount - 1);\n            // add a small bit of time slop since its feasible a host completed a operation *after* we stopped it,\n            // the netty handlers are stopped in async (not forced) mode\n            this.expectedFailureStartTimeMicros = Utils.getNowMicrosUtc()\n                    + TimeUnit.MILLISECONDS.toMicros(250);\n\n        };\n        this.host.schedule(r, 1, TimeUnit.MILLISECONDS);\n\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                this.updateCount,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        doStateUpdateReplicationTest(Action.PATCH, childStates.size(), this.updateCount,\n                this.updateCount * 2,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        doStateUpdateReplicationTest(Action.PATCH, childStates.size(), 1,\n                this.updateCount * 2,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    private void validatePerOperationReplicationQuorum(Map<String, ExampleServiceState> childStates,\n            long now) throws Throwable {\n        Random r = new Random();\n        // issue a patch, with per operation quorum set, verify it applied\n        for (Entry<String, ExampleServiceState> e : childStates.entrySet()) {\n            TestContext ctx = this.host.testCreate(1);\n            ExampleServiceState body = e.getValue();\n            body.counter = now;\n            Operation patch = Operation.createPatch(this.host.getPeerServiceUri(e.getKey()))\n                    .setCompletion(ctx.getCompletion())\n                    .setBody(body);\n\n            // add an explicit replication count header, using either the \"all\" value, or an\n            // explicit node count\n            if (r.nextBoolean()) {\n                patch.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                        Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n            } else {\n                patch.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                        this.nodeCount + \"\");\n            }\n\n            this.host.send(patch);\n            this.host.testWait(ctx);\n            // Go to each peer, directly to their index, and verify update is present. This is not\n            // proof the per operation quorum was applied \"synchronously\", before the response\n            // was sent, but over many runs, if there is a race or its applied asynchronously,\n            // we will see failures\n            for (URI hostBaseUri : this.host.getNodeGroupMap().keySet()) {\n                URI indexUri = UriUtils.buildUri(hostBaseUri, ServiceUriPaths.CORE_DOCUMENT_INDEX);\n                indexUri = UriUtils.buildIndexQueryUri(indexUri,\n                        e.getKey(), true, false, ServiceOption.PERSISTENCE);\n\n                ExampleServiceState afterState = this.host.getServiceState(null,\n                        ExampleServiceState.class, indexUri);\n                assertEquals(body.counter, afterState.counter);\n            }\n        }\n\n        this.host.toggleNegativeTestMode(true);\n        // verify that if we try to set per operation quorum too high, request will fail\n        for (Entry<String, ExampleServiceState> e : childStates.entrySet()) {\n            TestContext ctx = this.host.testCreate(1);\n            ExampleServiceState body = e.getValue();\n            body.counter = now;\n            Operation patch = Operation.createPatch(this.host.getPeerServiceUri(e.getKey()))\n                    .addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                            (this.nodeCount * 2) + \"\")\n                    .setCompletion(ctx.getExpectedFailureCompletion())\n                    .setBody(body);\n            this.host.send(patch);\n            this.host.testWait(ctx);\n            break;\n        }\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    private void setOperationTimeoutMicros(long opTimeoutMicros) {\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setOperationTimeOutMicros(opTimeoutMicros);\n        }\n        this.host.setOperationTimeOutMicros(opTimeoutMicros);\n    }\n\n    /**\n     * This test creates N local service hosts, each with K instances of a replicated service. The\n     * service will create a query task, also replicated, and self patch itself. The test makes sure\n     * all K instances, on all N hosts see the self PATCHs AND that the query tasks exist on all\n     * hosts\n     *\n     * @throws Throwable\n     */\n    @Test\n    public void replicationWithCrossServiceDependencies() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        setUp(this.nodeCount);\n\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n\n        Consumer<Operation> setBodyCallback = (o) -> {\n            ReplicationTestServiceState s = new ReplicationTestServiceState();\n            s.stringField = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n\n        URI hostUri = this.host.getPeerServiceUri(null);\n\n        URI factoryUri = UriUtils.buildUri(hostUri,\n                ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK);\n        doReplicatedServiceFactoryPost(this.serviceCount, setBodyCallback, factoryUri);\n\n        factoryUri = UriUtils.buildUri(hostUri,\n                ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK);\n        Map<URI, ReplicationTestServiceState> ownerSelectedServices = doReplicatedServiceFactoryPost(\n                this.serviceCount, setBodyCallback, factoryUri);\n\n        factoryUri = UriUtils.buildUri(hostUri, ReplicationFactoryTestService.STRICT_SELF_LINK);\n        doReplicatedServiceFactoryPost(this.serviceCount, setBodyCallback, factoryUri);\n\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        Query kindClause = new Query();\n        kindClause.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND)\n                .setTermMatchValue(Utils.buildKind(ReplicationTestServiceState.class));\n        q.query.addBooleanClause(kindClause);\n\n        Query nameClause = new Query();\n        nameClause.setTermPropertyName(\"stringField\")\n                .setTermMatchValue(\"*\")\n                .setTermMatchType(MatchType.WILDCARD);\n        q.query.addBooleanClause(nameClause);\n\n        // expect results for strict and regular service instances\n        int expectedServiceCount = this.serviceCount * 3;\n\n        Date exp = this.host.getTestExpiration();\n        while (exp.after(new Date())) {\n            // create N direct query tasks. Direct tasks complete in the context of the POST to the\n            // query task factory\n            int count = 10;\n            URI queryFactoryUri = UriUtils.extendUri(hostUri,\n                    ServiceUriPaths.CORE_QUERY_TASKS);\n            TestContext testContext = this.host.testCreate(count);\n\n            Map<String, QueryTask> taskResults = new ConcurrentSkipListMap<>();\n            for (int i = 0; i < count; i++) {\n                QueryTask qt = QueryTask.create(q);\n                qt.taskInfo.isDirect = true;\n                qt.documentSelfLink = UUID.randomUUID().toString();\n                Operation startPost = Operation\n                        .createPost(queryFactoryUri)\n                        .setBody(qt)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContext.fail(e);\n                                        return;\n                                    }\n\n                                    QueryTask rsp = o.getBody(QueryTask.class);\n                                    qt.results = rsp.results;\n                                    qt.documentOwner = rsp.documentOwner;\n                                    taskResults.put(rsp.documentSelfLink, qt);\n                                    testContext.complete();\n                                });\n\n                this.host.send(startPost);\n            }\n            testContext.await();\n            this.host.logThroughput();\n\n            boolean converged = true;\n            for (QueryTask qt : taskResults.values()) {\n                if (qt.results == null || qt.results.documentLinks == null) {\n                    throw new IllegalStateException(\"Missing results\");\n                }\n                if (qt.results.documentLinks.size() != expectedServiceCount) {\n                    this.host.log(\"%s\", Utils.toJsonHtml(qt));\n                    converged = false;\n                    break;\n                }\n            }\n\n            if (!converged) {\n                Thread.sleep(250);\n                continue;\n            }\n            break;\n        }\n\n        if (exp.before(new Date())) {\n            throw new TimeoutException();\n        }\n\n        // Negative tests: Make sure custom error response body is preserved\n        URI childUri = ownerSelectedServices.keySet().iterator().next();\n        TestContext testContext = this.host.testCreate(1);\n        ReplicationTestServiceState badRequestBody = new ReplicationTestServiceState();\n        this.host\n                .send(Operation\n                        .createPatch(childUri)\n                        .setBody(badRequestBody)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e == null) {\n                                        testContext.fail(new IllegalStateException(\n                                                \"Expected failure\"));\n                                        return;\n                                    }\n\n                                    ReplicationTestServiceErrorResponse rsp = o\n                                            .getBody(ReplicationTestServiceErrorResponse.class);\n                                    if (!ReplicationTestServiceErrorResponse.KIND\n                                            .equals(rsp.documentKind)) {\n                                        testContext.fail(new IllegalStateException(\n                                                \"Expected custom response body\"));\n                                        return;\n                                    }\n\n                                    testContext.complete();\n                                }));\n        testContext.await();\n\n        // verify that each owner selected service reports stats from the same node that reports state\n        Map<URI, ReplicationTestServiceState> latestState = this.host.getServiceState(null,\n                ReplicationTestServiceState.class, ownerSelectedServices.keySet());\n        Map<String, String> ownerIdPerLink = new HashMap<>();\n        List<URI> statsUris = new ArrayList<>();\n        for (ReplicationTestServiceState state : latestState.values()) {\n            URI statsUri = this.host.getPeerServiceUri(UriUtils.buildUriPath(\n                    state.documentSelfLink, ServiceHost.SERVICE_URI_SUFFIX_STATS));\n            ownerIdPerLink.put(state.documentSelfLink, state.documentOwner);\n            statsUris.add(statsUri);\n        }\n\n        Map<URI, ServiceStats> latestStats = this.host.getServiceState(null, ServiceStats.class,\n                statsUris);\n        for (ServiceStats perServiceStats : latestStats.values()) {\n\n            String serviceLink = UriUtils.getParentPath(perServiceStats.documentSelfLink);\n            String expectedOwnerId = ownerIdPerLink.get(serviceLink);\n            if (expectedOwnerId.equals(perServiceStats.documentOwner)) {\n                continue;\n            }\n            throw new IllegalStateException(\"owner routing issue with stats: \"\n                    + Utils.toJsonHtml(perServiceStats));\n\n        }\n\n        exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            // verify all factories report same number of children\n            for (VerificationHost peerHost : this.host.getInProcessHostMap().values()) {\n                factoryUri = UriUtils.buildUri(peerHost,\n                        ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK);\n                ServiceDocumentQueryResult rsp = this.host.getFactoryState(factoryUri);\n                if (rsp.documentLinks.size() != latestState.size()) {\n                    this.host.log(\"Factory %s reporting %d children, expected %d\", factoryUri,\n                            rsp.documentLinks.size(), latestState.size());\n                    isConverged = false;\n                    break;\n                }\n            }\n            if (!isConverged) {\n                Thread.sleep(250);\n                continue;\n            }\n            break;\n        }\n\n        if (new Date().after(exp)) {\n            throw new TimeoutException(\"factories did not converge\");\n        }\n\n        this.host.log(\"Inducing synchronization\");\n        // Induce synchronization on stable node group. No changes should be observed since\n        // all nodes should have identical state\n        this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n        // give synchronization a chance to run, its 100% asynchronous so we can't really tell when each\n        // child is done, but a small delay should be sufficient for 99.9% of test environments, even under\n        // load\n        Thread.sleep(2000);\n\n        // verify that example states did not change due to the induced synchronization\n        Map<URI, ReplicationTestServiceState> latestStateAfter = this.host.getServiceState(null,\n                ReplicationTestServiceState.class, ownerSelectedServices.keySet());\n        for (Entry<URI, ReplicationTestServiceState> afterEntry : latestStateAfter.entrySet()) {\n            ReplicationTestServiceState beforeState = latestState.get(afterEntry.getKey());\n            ReplicationTestServiceState afterState = afterEntry.getValue();\n            assertEquals(beforeState.documentVersion, afterState.documentVersion);\n        }\n\n        verifyOperationJoinAcrossPeers(latestStateAfter);\n    }\n\n    private Map<URI, ReplicationTestServiceState> doReplicatedServiceFactoryPost(int serviceCount,\n            Consumer<Operation> setBodyCallback, URI factoryUri) throws Throwable,\n            InterruptedException, TimeoutException {\n\n        ServiceDocumentDescription sdd = this.host\n                .buildDescription(ReplicationTestServiceState.class);\n        Map<URI, ReplicationTestServiceState> serviceMap = this.host.doFactoryChildServiceStart(\n                null, serviceCount, ReplicationTestServiceState.class, setBodyCallback, factoryUri);\n\n        Date expiration = this.host.getTestExpiration();\n        boolean isConverged = true;\n        Map<URI, String> uriToSignature = new HashMap<>();\n        while (new Date().before(expiration)) {\n            isConverged = true;\n            uriToSignature.clear();\n            for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n                URI baseUri = e.getKey();\n                VerificationHost h = e.getValue();\n                URI u = UriUtils.buildUri(baseUri, factoryUri.getPath());\n                u = UriUtils.buildExpandLinksQueryUri(u);\n                ServiceDocumentQueryResult r = this.host.getFactoryState(u);\n                if (r.documents.size() != serviceCount) {\n                    this.host.log(\"instance count mismatch, expected %d, got %d, from %s\",\n                            serviceCount, r.documents.size(), u);\n                    isConverged = false;\n                    break;\n                }\n\n                for (URI instanceUri : serviceMap.keySet()) {\n                    ReplicationTestServiceState initialState = serviceMap.get(instanceUri);\n                    ReplicationTestServiceState newState = Utils.fromJson(\n                            r.documents.get(instanceUri.getPath()),\n                            ReplicationTestServiceState.class);\n                    if (newState.documentVersion == 0) {\n                        this.host.log(\"version mismatch, expected %d, got %d, from %s\", 0,\n                                newState.documentVersion, instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (initialState.stringField.equals(newState.stringField)) {\n                        this.host.log(\"field mismatch, expected %s, got %s, from %s\",\n                                initialState.stringField, newState.stringField, instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (newState.queryTaskLink == null) {\n                        this.host.log(\"missing query task link from %s\", instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    // Only instances with OWNER_SELECTION patch string field with self link so bypass this check\n                    if (!newState.documentSelfLink\n                            .contains(ReplicationFactoryTestService.STRICT_SELF_LINK)\n                            && !newState.documentSelfLink\n                            .contains(ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK)\n                            && !newState.stringField.equals(newState.documentSelfLink)) {\n                        this.host.log(\"State not in final state\");\n                        isConverged = false;\n                        break;\n                    }\n\n                    String sig = uriToSignature.get(instanceUri);\n                    if (sig == null) {\n                        sig = Utils.computeSignature(newState, sdd);\n                        uriToSignature.put(instanceUri, sig);\n                    } else {\n                        String newSig = Utils.computeSignature(newState, sdd);\n                        if (!sig.equals(newSig)) {\n                            isConverged = false;\n                            this.host.log(\"signature mismatch, expected %s, got %s, from %s\",\n                                    sig, newSig, instanceUri);\n                        }\n                    }\n\n                    ProcessingStage ps = h.getServiceStage(newState.queryTaskLink);\n                    if (ps == null || ps != ProcessingStage.AVAILABLE) {\n                        this.host.log(\"missing query task service from %s\", newState.queryTaskLink,\n                                instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n                }\n\n                if (isConverged == false) {\n                    break;\n                }\n            }\n            if (isConverged == true) {\n                break;\n            }\n\n            Thread.sleep(100);\n        }\n\n        if (!isConverged) {\n            throw new TimeoutException(\"States did not converge\");\n        }\n\n        return serviceMap;\n    }\n\n    @Test\n    public void replicationWithOutOfOrderPostAndUpdates() throws Throwable {\n        // This test verifies that if a replica receives\n        // replication requests of POST and PATCH/PUT\n        // out-of-order, xenon can still handle it\n        // by doing retries for failed out-of-order\n        // updates. To verify this, we setup a node\n        // group and set quorum to just 1, so that the post\n        // returns as soon as the owner commits the post,\n        // so that we increase the chance of out-of-order\n        // update replication requests.\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(1);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicationFactoryConvergence();\n\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"testing\";\n        state.counter = 1L;\n\n        VerificationHost peer = this.host.getPeerHost();\n\n        TestContext ctx = this.host.testCreate(this.serviceCount * this.updateCount);\n        for (int i = 0; i < this.serviceCount; i++) {\n            Operation post = Operation\n                    .createPost(peer, ExampleService.FACTORY_LINK)\n                    .setBody(state)\n                    .setReferer(this.host.getUri())\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            ctx.failIteration(e);\n                            return;\n                        }\n\n                        ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n                        for (int k = 0; k < this.updateCount; k++) {\n                            ExampleServiceState update = new ExampleServiceState();\n                            state.counter = (long) k;\n                            Operation patch = Operation\n                                    .createPatch(peer, rsp.documentSelfLink)\n                                    .setBody(update)\n                                    .setReferer(this.host.getUri())\n                                    .setCompletion(ctx.getCompletion());\n                            this.host.sendRequest(patch);\n                        }\n\n                    });\n            this.host.sendRequest(post);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void replication() throws Throwable {\n        this.replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replicationSsl() throws Throwable {\n        this.replicationUriScheme = ServiceHost.HttpScheme.HTTPS_ONLY;\n        this.replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replication1x() throws Throwable {\n        this.replicationFactor = 1L;\n        this.replicationNodeSelector = ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR;\n        this.replicationTargetFactoryLink = Replication1xExampleFactoryService.SELF_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replication3x() throws Throwable {\n        this.replicationFactor = 3L;\n        this.replicationNodeSelector = ServiceUriPaths.DEFAULT_3X_NODE_SELECTOR;\n        this.replicationTargetFactoryLink = Replication3xExampleFactoryService.SELF_LINK;\n        this.nodeCount = Math.max(5, this.nodeCount);\n        doReplication();\n    }\n\n    private void doReplication() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        CommandLineArgumentParser.parseFromProperties(this);\n        Date expiration = new Date();\n        if (this.testDurationSeconds > 0) {\n            expiration = new Date(expiration.getTime()\n                    + TimeUnit.SECONDS.toMillis(this.testDurationSeconds));\n        }\n\n        Map<Action, Long> elapsedTimePerAction = new HashMap<>();\n        Map<Action, Long> countPerAction = new HashMap<>();\n\n        long totalOperations = 0;\n        int iterationCount = 0;\n        do {\n            if (this.host == null) {\n                setUp(this.nodeCount);\n                this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n                // for limited replication factor, we will still set the quorum high, and expect\n                // the limited replication selector to use the minimum between majority of replication\n                // factor, versus node group membership quorum\n                this.host.setNodeGroupQuorum(this.nodeCount);\n                // since we have disabled peer synch, trigger it explicitly so factories become available\n                this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n\n                waitForReplicatedFactoryServiceAvailable(\n                        this.host.getPeerServiceUri(this.replicationTargetFactoryLink),\n                        this.replicationNodeSelector);\n\n                waitForReplicationFactoryConvergence();\n                if (this.replicationUriScheme == ServiceHost.HttpScheme.HTTPS_ONLY) {\n                    // confirm nodes are joined using HTTPS group references\n                    for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n                        assertTrue(UriUtils.HTTPS_SCHEME.equals(nodeGroup.getScheme()));\n                    }\n                }\n\n            }\n\n            Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                    this.serviceCount, countPerAction, elapsedTimePerAction);\n            totalOperations += this.serviceCount;\n\n            if (this.testDurationSeconds == 0) {\n                // various validation tests, executed just once, ignored in long running test\n                this.host.doExampleServiceUpdateAndQueryByVersion(this.host.getPeerHostUri(),\n                        this.serviceCount);\n                verifyReplicatedForcedPostAfterDelete(childStates);\n                verifyInstantNotFoundFailureOnBadLinks();\n                verifyReplicatedIdempotentPost(childStates);\n                verifyDynamicMaintOptionToggle(childStates);\n            }\n\n            totalOperations += this.serviceCount;\n\n            if (expiration == null) {\n                expiration = this.host.getTestExpiration();\n            }\n            int expectedVersion = this.updateCount;\n\n            if (!this.host.isStressTest()\n                    && (this.host.getPeerCount() > 16\n                    || this.serviceCount * this.updateCount > 100)) {\n                this.host.setStressTest(true);\n            }\n\n            long opCount = this.serviceCount * this.updateCount;\n            childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                    this.updateCount,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n            expectedVersion += this.updateCount;\n\n            totalOperations += opCount;\n\n            childStates = doStateUpdateReplicationTest(Action.PUT, this.serviceCount,\n                    this.updateCount,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n\n            totalOperations += opCount;\n\n            Date queryExp = this.host.getTestExpiration();\n            if (expiration.after(queryExp)) {\n                queryExp = expiration;\n            }\n            while (new Date().before(queryExp)) {\n                Set<String> links = verifyReplicatedServiceCountWithBroadcastQueries();\n                if (links.size() < this.serviceCount) {\n                    this.host.log(\"Found only %d links across nodes, retrying\", links.size());\n                    Thread.sleep(500);\n                    continue;\n                }\n                break;\n            }\n\n            totalOperations += this.serviceCount;\n\n            if (queryExp.before(new Date())) {\n                throw new TimeoutException();\n            }\n\n            expectedVersion += 1;\n            doStateUpdateReplicationTest(Action.DELETE, this.serviceCount, 1,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n\n            totalOperations += this.serviceCount;\n\n            // compute the binary serialized payload, and the JSON payload size\n            ExampleServiceState st = childStates.values().iterator().next();\n            String json = Utils.toJson(st);\n            int byteCount = KryoSerializers.serializeDocument(st, 4096).position();\n            int jsonByteCount = json.getBytes(Utils.CHARSET).length;\n            // estimate total bytes transferred between nodes. The owner receives JSON from the client\n            // but then uses binary serialization to the N-1 replicas\n            long totalBytes = jsonByteCount * totalOperations\n                    + (this.nodeCount - 1) * byteCount * totalOperations;\n\n            this.host.log(\n                    \"Bytes per json:%d, per binary: %d, Total operations: %d, Total bytes:%d\",\n                    jsonByteCount,\n                    byteCount,\n                    totalOperations,\n                    totalBytes);\n\n            if (iterationCount++ < 2 && this.testDurationSeconds > 0) {\n                // ignore data during JVM warm-up, first two iterations\n                countPerAction.clear();\n                elapsedTimePerAction.clear();\n            }\n\n        } while (new Date().before(expiration) && this.totalOperationLimit > totalOperations);\n\n        logHostStats();\n        logPerActionThroughput(elapsedTimePerAction, countPerAction);\n\n        this.host.doNodeGroupStatsVerification(this.host.getNodeGroupMap());\n    }\n\n    private void logHostStats() {\n        for (URI u : this.host.getNodeGroupMap().keySet()) {\n            URI mgmtUri = UriUtils.buildUri(u, ServiceHostManagementService.SELF_LINK);\n            mgmtUri = UriUtils.buildStatsUri(mgmtUri);\n            ServiceStats stats = this.host.getServiceState(null, ServiceStats.class, mgmtUri);\n            this.host.log(\"%s: %s\", u, Utils.toJsonHtml(stats));\n        }\n    }\n\n    private void logPerActionThroughput(Map<Action, Long> elapsedTimePerAction,\n            Map<Action, Long> countPerAction) {\n        for (Action a : EnumSet.allOf(Action.class)) {\n            Long count = countPerAction.get(a);\n            if (count == null) {\n                continue;\n            }\n            Long elapsedMicros = elapsedTimePerAction.get(a);\n\n            double thpt = (count * 1.0) / (1.0 * elapsedMicros);\n            thpt *= 1000000;\n            this.host.log(\"Total ops for %s: %d, Throughput (ops/sec): %f\", a, count, thpt);\n        }\n    }\n\n    private void updatePerfDataPerAction(Action a, Long startTime, Long opCount,\n            Map<Action, Long> countPerAction, Map<Action, Long> elapsedTime) {\n        if (opCount == null || countPerAction != null) {\n            countPerAction.merge(a, opCount, (e, n) -> {\n                if (e == null) {\n                    return n;\n                }\n                return e + n;\n            });\n        }\n\n        if (startTime == null || elapsedTime == null) {\n            return;\n        }\n\n        long delta = Utils.getNowMicrosUtc() - startTime;\n        elapsedTime.merge(a, delta, (e, n) -> {\n            if (e == null) {\n                return n;\n            }\n            return e + n;\n        });\n    }\n\n    private void verifyReplicatedIdempotentPost(Map<String, ExampleServiceState> childStates)\n            throws Throwable {\n        // verify IDEMPOTENT POST conversion to PUT, with replication\n        // Since the factory is not idempotent by default, enable the option dynamically\n        Map<URI, URI> exampleFactoryUris = this.host\n                .getNodeGroupToFactoryMap(ExampleService.FACTORY_LINK);\n        for (URI factoryUri : exampleFactoryUris.values()) {\n            this.host.toggleServiceOptions(factoryUri,\n                    EnumSet.of(ServiceOption.IDEMPOTENT_POST), null);\n        }\n        TestContext ctx = this.host.testCreate(childStates.size());\n        for (Entry<String, ExampleServiceState> entry : childStates.entrySet()) {\n            Operation post = Operation\n                    .createPost(this.host.getPeerServiceUri(ExampleService.FACTORY_LINK))\n                    .setBody(entry.getValue())\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(post);\n        }\n        ctx.await();\n    }\n\n    /**\n     * Verifies that DELETE actions propagate and commit, and, that forced POST actions succeed\n     */\n    private void verifyReplicatedForcedPostAfterDelete(Map<String, ExampleServiceState> childStates)\n            throws Throwable {\n        // delete one of the children, then re-create but with a zero version, using a special\n        // directive that forces creation\n        Entry<String, ExampleServiceState> childEntry = childStates.entrySet().iterator().next();\n        TestContext ctx = this.host.testCreate(1);\n        Operation delete = Operation\n                .createDelete(this.host.getPeerServiceUri(childEntry.getKey()))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(delete);\n        ctx.await();\n\n        if (!this.host.isRemotePeerTest()) {\n            this.host.waitFor(\"services not deleted\", () -> {\n                for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n                    ProcessingStage stg = h.getServiceStage(childEntry.getKey());\n                    if (stg != null) {\n                        this.host.log(\"Service exists %s on host %s, stage %s\",\n                                childEntry.getKey(), h.toString(), stg);\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        TestContext postCtx = this.host.testCreate(1);\n        Operation opPost = Operation\n                .createPost(this.host.getPeerServiceUri(this.replicationTargetFactoryLink))\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_FORCE_INDEX_UPDATE)\n                .setBody(childEntry.getValue())\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        postCtx.failIteration(e);\n                    } else {\n                        postCtx.completeIteration();\n                    }\n                });\n        this.host.send(opPost);\n        this.host.testWait(postCtx);\n    }\n\n    private void waitForReplicationFactoryConvergence() throws Throwable {\n\n        // for code coverage, verify the convenience method on the host also reports available\n        WaitHandler wh = () -> {\n            TestContext ctx = this.host.testCreate(1);\n            boolean[] isReady = new boolean[1];\n            CompletionHandler ch = (o, e) -> {\n                if (e != null) {\n                    isReady[0] = false;\n                } else {\n                    isReady[0] = true;\n                }\n                ctx.completeIteration();\n            };\n\n            VerificationHost peerHost = this.host.getPeerHost();\n            if (peerHost == null) {\n                NodeGroupUtils.checkServiceAvailability(ch, this.host,\n                        this.host.getPeerServiceUri(this.replicationTargetFactoryLink),\n                        this.replicationNodeSelector);\n            } else {\n                peerHost.checkReplicatedServiceAvailable(ch, this.replicationTargetFactoryLink);\n            }\n            ctx.await();\n            return isReady[0];\n        };\n\n        this.host.waitFor(\"available check timeout for \" + this.replicationTargetFactoryLink, wh);\n    }\n\n    private Set<String> verifyReplicatedServiceCountWithBroadcastQueries()\n            throws Throwable {\n        // create a query task, which will execute on a randomly selected node. Since there is no guarantee the node\n        // selected to execute the query task is the one with all the replicated services, broadcast to all nodes, then\n        // join the results\n\n        URI nodeUri = this.host.getPeerHostUri();\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND).setTermMatchValue(\n                Utils.buildKind(ExampleServiceState.class));\n        QueryTask task = QueryTask.create(q).setDirect(true);\n        URI queryTaskFactoryUri = UriUtils\n                .buildUri(nodeUri, ServiceUriPaths.CORE_LOCAL_QUERY_TASKS);\n\n        // send the POST to the forwarding service on one of the nodes, with the broadcast query parameter set\n        URI forwardingService = UriUtils.buildBroadcastRequestUri(queryTaskFactoryUri,\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        Set<String> links = new HashSet<>();\n\n        TestContext testContext = this.host.testCreate(1);\n        Operation postQuery = Operation\n                .createPost(forwardingService)\n                .setBody(task)\n                .setCompletion(\n                        (o, e) -> {\n                            if (e != null) {\n                                this.host.failIteration(e);\n                                return;\n                            }\n\n                            NodeGroupBroadcastResponse rsp = o\n                                    .getBody(NodeGroupBroadcastResponse.class);\n\n                            NodeGroupBroadcastResult broadcastResponse = NodeGroupUtils.toBroadcastResult(rsp);\n                            if (broadcastResponse.hasFailure()) {\n                                testContext.fail(new IllegalStateException(\n                                        \"Failure from query tasks: \" + Utils.toJsonHtml(rsp)));\n                                return;\n                            }\n\n                            // verify broadcast requests should come from all discrete nodes\n                            Set<String> ownerIds = new HashSet<>();\n\n                            for (PeerNodeResult successResponse : broadcastResponse.successResponses) {\n                                QueryTask qt = successResponse.castBodyTo(QueryTask.class);\n                                this.host.log(\"Broadcast response from %s %s\", qt.documentSelfLink,\n                                        qt.documentOwner);\n                                ownerIds.add(qt.documentOwner);\n                                if (qt.results == null) {\n                                    this.host.log(\"Node %s had no results\", successResponse.requestUri);\n                                    continue;\n                                }\n                                for (String l : qt.results.documentLinks) {\n                                    links.add(l);\n                                }\n                            }\n\n                            testContext.completeIteration();\n                        });\n\n        this.host.send(postQuery);\n        testContext.await();\n\n        return links;\n    }\n\n    private void verifyInstantNotFoundFailureOnBadLinks() throws Throwable {\n        this.host.toggleNegativeTestMode(true);\n\n        TestContext testContext = this.host.testCreate(this.serviceCount);\n\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                testContext.complete();\n                return;\n            }\n            // strange, service exists, lets verify\n            for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n                ProcessingStage stg = h.getServiceStage(o.getUri().getPath());\n                if (stg != null) {\n                    this.host.log(\"Service exists %s on host %s, stage %s\",\n                            o.getUri().getPath(), h.toString(), stg);\n                }\n            }\n            testContext.fail(new Throwable(\"Expected service to not exist:\"\n                    + o.toString()));\n        };\n\n        // do a negative test: send request to a example child we know does not exist, but disable queuing\n        // so we get 404 right away\n        for (int i = 0; i < this.serviceCount; i++) {\n            URI factoryURI = this.host.getNodeGroupToFactoryMap(ExampleService.FACTORY_LINK)\n                    .values().iterator().next();\n            URI bogusChild = UriUtils.extendUri(factoryURI,\n                    Utils.getNowMicrosUtc() + UUID.randomUUID().toString());\n            Operation patch = Operation.createPatch(bogusChild)\n                    .setCompletion(c)\n                    .setBody(new ExampleServiceState());\n\n            this.host.send(patch);\n        }\n        testContext.await();\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    @Test\n    public void factorySynchronization() throws Throwable {\n\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n\n        factorySynchronizationNoChildren();\n\n        factoryDuplicatePost();\n    }\n\n    @Test\n    public void replicationWithAuthzCacheClear() throws Throwable {\n        this.isAuthorizationEnabled = true;\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        VerificationHost groupHost = this.host.getPeerHost();\n\n        // wait for auth related services to be stabilized\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, UserService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, UserGroupService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, ResourceGroupService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, RoleService.FACTORY_LINK));\n\n        String fooUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"foo@vmware.com\");\n        String barUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"bar@vmware.com\");\n        String bazUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"baz@vmware.com\");\n\n        groupHost.setSystemAuthorizationContext();\n\n        // create user, user-group, resource-group, role for foo@vmware.com\n        //   user: /core/authz/users/foo@vmware.com\n        //   user-group: /core/authz/user-groups/foo-user-group\n        //   resource-group:  /core/authz/resource-groups/foo-resource-group\n        //   role: /core/authz/roles/foo-role-1\n        TestContext testContext = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"foo@vmware.com\")\n                .setUserEmail(\"foo@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setUserGroupName(\"foo-user-group\")\n                .setResourceGroupName(\"foo-resource-group\")\n                .setRoleName(\"foo-role-1\")\n                .setCompletion(testContext.getCompletion())\n                .start();\n        testContext.await();\n\n        // create another user-group, resource-group, and role for foo@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: /core/authz/role/foo-role-2\n        TestContext ctxToCreateAnotherRole = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(fooUserLink)\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setRoleName(\"foo-role-2\")\n                .setCompletion(ctxToCreateAnotherRole.getCompletion())\n                .setupRole();\n        ctxToCreateAnotherRole.await();\n\n        // create user, user-group, resource-group, role for bar@vmware.com\n        //   user: /core/authz/users/bar@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: (not important)\n        TestContext ctxToCreateBar = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"bar@vmware.com\")\n                .setUserEmail(\"bar@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(ctxToCreateBar.getCompletion())\n                .start();\n        ctxToCreateBar.await();\n\n        // create user, user-group, resource-group, role for baz@vmware.com\n        //   user: /core/authz/users/baz@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: (not important)\n        TestContext ctxToCreateBaz = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"baz@vmware.com\")\n                .setUserEmail(\"baz@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(ctxToCreateBaz.getCompletion())\n                .start();\n        ctxToCreateBaz.await();\n\n        AuthorizationContext fooAuthContext = groupHost.assumeIdentity(fooUserLink);\n        AuthorizationContext barAuthContext = groupHost.assumeIdentity(barUserLink);\n        AuthorizationContext bazAuthContext = groupHost.assumeIdentity(bazUserLink);\n        String fooToken = fooAuthContext.getToken();\n        String barToken = barAuthContext.getToken();\n        String bazToken = bazAuthContext.getToken();\n\n        groupHost.resetSystemAuthorizationContext();\n\n        // verify GET will NOT clear cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/users/foo@vmware.com\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/user-groups/foo-user-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/resource-groups/foo-resource-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/roles/foo-role-1\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n\n        // verify deleting role should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(\n                        UriUtils.buildUri(groupHost, \"/core/authz/roles/foo-role-1\")));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify deleting user-group should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        // delete the user group associated with the user\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(\n                        UriUtils.buildUri(groupHost, \"/core/authz/user-groups/foo-user-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify creating new role should clear the auth cache (using bar@vmware.com)\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        Query q = Builder.create()\n                .addFieldClause(\n                        ExampleServiceState.FIELD_NAME_KIND,\n                        Utils.buildKind(ExampleServiceState.class))\n                .build();\n        TestContext ctxToCreateAnotherRoleForBar = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(barUserLink)\n                .setResourceGroupName(\"/core/authz/resource-groups/new-rg\")\n                .setResourceQuery(q)\n                .setRoleName(\"bar-role-2\")\n                .setCompletion(ctxToCreateAnotherRoleForBar.getCompletion())\n                .setupRole();\n        ctxToCreateAnotherRoleForBar.await();\n        groupHost.resetSystemAuthorizationContext();\n\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n        //\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n\n        // Updating the resource group should be able to handle the fact that the user group does not exist\n        String newResourceGroupLink = \"/core/authz/resource-groups/new-rg\";\n        Query updateResourceGroupQuery = Builder.create()\n                .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, \"bar\")\n                .build();\n        ResourceGroupState resourceGroupState = new ResourceGroupState();\n        resourceGroupState.query = updateResourceGroupQuery;\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPut(UriUtils.buildUri(groupHost, newResourceGroupLink))\n                        .setBody(resourceGroupState));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n        // verify patching user should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        UserState userState = new UserState();\n        userState.userGroupLinks = new HashSet<>();\n        userState.userGroupLinks.add(\"foo\");\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(groupHost, fooUserLink))\n                        .setBody(userState));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify deleting user should clear the auth cache\n        populateAuthCacheInAllPeers(bazAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(UriUtils.buildUri(groupHost, bazUserLink)));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(bazToken);\n\n        // verify patching ResourceGroup should clear the auth cache\n        // uses \"new-rg\" resource group that has associated to user bar\n        TestRequestSender sender = new TestRequestSender(this.host.getPeerHost());\n        groupHost.setSystemAuthorizationContext();\n        Operation newResourceGroupGetOp = Operation.createGet(groupHost, newResourceGroupLink);\n        ResourceGroupState newResourceGroupState = sender.sendAndWait(newResourceGroupGetOp, ResourceGroupState.class);\n        groupHost.resetSystemAuthorizationContext();\n\n        PatchQueryRequest patchBody = PatchQueryRequest.create(newResourceGroupState.query, false);\n\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(groupHost, newResourceGroupLink))\n                        .setBody(patchBody));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n    }\n\n    private void populateAuthCacheInAllPeers(AuthorizationContext authContext) throws Throwable {\n\n        // send a GET request to the ExampleService factory to populate auth cache on each peer.\n        // since factory is not OWNER_SELECTION service, request goes to the specified node.\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            peer.setAuthorizationContext(authContext);\n\n            // based on the role created in test, all users have access to ExampleService\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createGet(UriUtils.buildStatsUri(peer, ExampleService.FACTORY_LINK)));\n        }\n\n        this.host.waitFor(\"Timeout waiting for correct auth cache state\",\n                () -> checkCacheInAllPeers(authContext.getToken(), true));\n    }\n\n    private void verifyAuthCacheHasClearedInAllPeers(String userToken) {\n        this.host.waitFor(\"Timeout waiting for correct auth cache state\",\n                () -> checkCacheInAllPeers(userToken, false));\n    }\n\n    private boolean checkCacheInAllPeers(String token, boolean expectEntries) throws Throwable {\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            peer.setSystemAuthorizationContext();\n            MinimalTestService s = new MinimalTestService();\n            peer.addPrivilegedService(MinimalTestService.class);\n            peer.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n            peer.resetSystemAuthorizationContext();\n\n            boolean contextFound = peer.getAuthorizationContext(s, token) != null;\n            if ((expectEntries && !contextFound) || (!expectEntries && contextFound)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void factoryDuplicatePost() throws Throwable, InterruptedException, TimeoutException {\n        // pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n        Consumer<Operation> setBodyCallback = (o) -> {\n            ReplicationTestServiceState s = new ReplicationTestServiceState();\n            s.stringField = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n\n        URI factoryUri = this.host\n                .getPeerServiceUri(ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK);\n        Map<URI, ReplicationTestServiceState> states = doReplicatedServiceFactoryPost(\n                this.serviceCount, setBodyCallback, factoryUri);\n\n        TestContext testContext = serviceHost.testCreate(states.size());\n        ReplicationTestServiceState initialState = new ReplicationTestServiceState();\n\n        for (URI uri : states.keySet()) {\n            initialState.documentSelfLink = uri.toString().substring(uri.toString()\n                    .lastIndexOf(UriUtils.URI_PATH_CHAR) + 1);\n            Operation createPost = Operation\n                    .createPost(factoryUri)\n                    .setBody(initialState)\n                    .setCompletion(\n                            (o, e) -> {\n                                if (o.getStatusCode() != Operation.STATUS_CODE_CONFLICT) {\n                                    testContext.fail(\n                                            new IllegalStateException(\n                                                    \"Incorrect response code received\"));\n                                    return;\n                                }\n                                testContext.complete();\n                            });\n            serviceHost.send(createPost);\n        }\n        testContext.await();\n    }\n\n    private void factorySynchronizationNoChildren() throws Throwable {\n        int factoryCount = Math.max(this.serviceCount, 25);\n        setUp(this.nodeCount);\n\n        // start many factories, in each host, so when the nodes join there will be a storm\n        // of synchronization requests between the nodes + factory instances\n        TestContext testContext = this.host.testCreate(this.nodeCount * factoryCount);\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            for (int i = 0; i < factoryCount; i++) {\n                Operation startPost = Operation.createPost(\n                        UriUtils.buildUri(h,\n                                UriUtils.buildUriPath(ExampleService.FACTORY_LINK, UUID\n                                        .randomUUID().toString())))\n                        .setCompletion(testContext.getCompletion());\n                h.startService(startPost, ExampleService.createFactory());\n            }\n        }\n        testContext.await();\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n    }\n\n    @Test\n    public void forwardingAndSelection() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        for (int i = 0; i < this.iterationCount; i++) {\n            directOwnerSelection();\n            forwardingToPeerId();\n            forwardingToKeyHashNode();\n            broadcast();\n        }\n    }\n\n    public void broadcast() throws Throwable {\n        // Do a broadcast on a local, non replicated service. Replicated services can not\n        // be used with broadcast since they will duplicate the update and potentially route\n        // to a single node\n        URI nodeGroup = this.host.getPeerNodeGroupUri();\n\n        long c = this.updateCount * this.nodeCount;\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        // we broadcast one update, per service, through one peer. We expect to see\n        // the same update across all peers, just like with replicated services\n        nodeGroup = this.host.getPeerNodeGroupUri();\n        testContext = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            URI serviceUri = UriUtils.buildUri(nodeGroup, s.documentSelfLink);\n            URI u = UriUtils.buildBroadcastRequestUri(serviceUri,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            body.id = serviceUri.getPath();\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(testContext.getCompletion())\n                    .setBody(body));\n        }\n        testContext.await();\n\n        for (URI baseHostUri : this.host.getNodeGroupMap().keySet()) {\n            List<URI> uris = new ArrayList<>();\n            for (ServiceDocument s : initialStates) {\n                URI serviceUri = UriUtils.buildUri(baseHostUri, s.documentSelfLink);\n                uris.add(serviceUri);\n            }\n            Map<URI, MinimalTestServiceState> states = this.host.getServiceState(null,\n                    MinimalTestServiceState.class, uris);\n            for (MinimalTestServiceState s : states.values()) {\n                // the PUT we issued, should have been forwarded to this service and modified its\n                // initial ID to be the same as the self link\n                if (!s.id.equals(s.documentSelfLink)) {\n                    throw new IllegalStateException(\"Service broadcast failure\");\n                }\n\n            }\n        }\n    }\n\n    public void forwardingToKeyHashNode() throws Throwable {\n        long c = this.updateCount * this.nodeCount;\n        Map<String, List<String>> ownersPerServiceLink = new HashMap<>();\n\n        // 0) Create N service instances, in each peer host. Services are NOT replicated\n        // 1) issue a forward request to owner, per service link\n        // 2) verify the request ended up on the owner the partitioning service predicted\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        URI nodeGroup = this.host.getPeerNodeGroupUri();\n        testContext = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            URI serviceUri = UriUtils.buildUri(nodeGroup, s.documentSelfLink);\n            URI u = UriUtils.buildForwardRequestUri(serviceUri,\n                    null,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            body.id = serviceUri.getPath();\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(testContext.getCompletion())\n                    .setBody(body));\n        }\n        testContext.await();\n        this.host.logThroughput();\n\n        AtomicInteger assignedLinks = new AtomicInteger();\n        TestContext testContextForPost = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            // make sure the key is the path to the service. The initial state self link is not a\n            // path ...\n            String key = UriUtils.normalizeUriPath(s.documentSelfLink);\n            s.documentSelfLink = key;\n            SelectAndForwardRequest body = new SelectAndForwardRequest();\n            body.key = key;\n            Operation post = Operation.createPost(UriUtils.buildUri(nodeGroup,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                    .setBody(body)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            testContextForPost.fail(e);\n                            return;\n                        }\n                        synchronized (ownersPerServiceLink) {\n                            SelectOwnerResponse rsp = o.getBody(SelectOwnerResponse.class);\n                            List<String> links = ownersPerServiceLink.get(rsp.ownerNodeId);\n                            if (links == null) {\n                                links = new ArrayList<>();\n                                ownersPerServiceLink.put(rsp.ownerNodeId, links);\n                            }\n                            links.add(key);\n                            ownersPerServiceLink.put(rsp.ownerNodeId, links);\n                        }\n                        assignedLinks.incrementAndGet();\n                        testContextForPost.complete();\n                    });\n            this.host.send(post);\n        }\n        testContextForPost.await();\n\n        assertTrue(assignedLinks.get() == initialStates.size());\n\n        // verify the services on the node that should be owner, has modified state\n        for (Entry<String, List<String>> e : ownersPerServiceLink.entrySet()) {\n            String nodeId = e.getKey();\n            List<String> links = e.getValue();\n            NodeState ns = this.host.getNodeStateMap().get(nodeId);\n            List<URI> uris = new ArrayList<>();\n            // make a list of URIs to the services assigned to this peer node\n            for (String l : links) {\n                uris.add(UriUtils.buildUri(ns.groupReference, l));\n            }\n\n            Map<URI, MinimalTestServiceState> states = this.host.getServiceState(null,\n                    MinimalTestServiceState.class, uris);\n            for (MinimalTestServiceState s : states.values()) {\n                // the PUT we issued, should have been forwarded to this service and modified its\n                // initial ID to be the same as the self link\n                if (!s.id.equals(s.documentSelfLink)) {\n                    throw new IllegalStateException(\"Service forwarding failure\");\n                } else {\n                }\n            }\n        }\n    }\n\n    public void forwardingToPeerId() throws Throwable {\n        long c = this.updateCount * this.nodeCount;\n        // 0) Create N service instances, in each peer host. Services are NOT replicated\n        // 1) issue a forward request to a specific peer id, per service link\n        // 2) verify the request ended up on the peer we targeted\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                s = Utils.clone(s);\n                // set the owner to be the target node. we will use this to verify it matches\n                // the id in the state, which is set through a forwarded PATCH\n                s.documentOwner = peer.getId();\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        VerificationHost peerEntryPoint = this.host.getPeerHost();\n\n        // add a custom header and make sure the service sees it in its handler, in the request\n        // headers, and we see a service response header in our response\n        String headerName = MinimalTestService.TEST_HEADER_NAME.toLowerCase();\n        UUID id = UUID.randomUUID();\n        String headerRequestValue = \"request-\" + id;\n        String headerResponseValue = \"response-\" + id;\n        TestContext testContextForPut = this.host.testCreate(initialStates.size() * this.nodeCount);\n\n        for (ServiceDocument s : initialStates) {\n            // send a PATCH the id for each document, to each peer. If it routes to the proper peer\n            // the initial state.documentOwner, will match the state.id\n\n            for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n                // For testing coverage, force the use of the same forwarding service instance.\n                // We make all request flow from one peer to others, testing both loopback p2p\n                // and true forwarding. Otherwise, the forwarding happens by directly contacting\n                // peer we want to land on!\n                URI localForwardingUri = UriUtils.buildUri(peerEntryPoint.getUri(),\n                        s.documentSelfLink);\n                // add a query to make sure it does not affect forwarding\n                localForwardingUri = UriUtils.extendUriWithQuery(localForwardingUri, \"k\", \"v\",\n                        \"k1\", \"v1\", \"k2\", \"v2\");\n                URI u = UriUtils.buildForwardToPeerUri(localForwardingUri, peer.getId(),\n                        ServiceUriPaths.DEFAULT_NODE_SELECTOR, EnumSet.noneOf(ServiceOption.class));\n                MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                        .buildMinimalTestState();\n                body.id = peer.getId();\n\n                this.host.send(Operation.createPut(u)\n                        .addRequestHeader(headerName, headerRequestValue)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContextForPut.fail(e);\n                                        return;\n                                    }\n                                    String value = o.getResponseHeader(headerName);\n                                    if (value == null || !value.equals(headerResponseValue)) {\n                                        testContextForPut.fail(new IllegalArgumentException(\n                                                \"response header not found\"));\n                                        return;\n                                    }\n                                    testContextForPut.complete();\n                                })\n                        .setBody(body));\n            }\n        }\n        testContextForPut.await();\n        this.host.logThroughput();\n\n        TestContext ctx = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation get = Operation.createGet(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        ctx.fail(e);\n                                        return;\n                                    }\n                                    MinimalTestServiceState rsp = o\n                                            .getBody(MinimalTestServiceState.class);\n                                    if (!rsp.id.equals(rsp.documentOwner)) {\n                                        ctx.fail(\n                                                new IllegalStateException(\"Expected: \"\n                                                        + rsp.documentOwner + \" was: \" + rsp.id));\n                                    } else {\n                                        ctx.complete();\n                                    }\n                                });\n                this.host.send(get);\n            }\n        }\n        ctx.await();\n\n        // Do a negative test: Send a request that will induce failure in the service handler and\n        // make sure we receive back failure, with a ServiceErrorResponse body\n\n        this.host.toggleDebuggingMode(true);\n        TestContext testCxtForPut = this.host.testCreate(this.host.getInProcessHostMap().size());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            ServiceDocument s = initialStates.get(0);\n            URI serviceUri = UriUtils.buildUri(peerEntryPoint.getUri(), s.documentSelfLink);\n            URI u = UriUtils.buildForwardToPeerUri(serviceUri, peer.getId(),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR,\n                    null);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            // setting id to null will cause validation failure.\n            body.id = null;\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e == null) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected failure\"));\n                                    return;\n                                }\n                                MinimalTestServiceErrorResponse rsp = o\n                                        .getBody(MinimalTestServiceErrorResponse.class);\n                                if (rsp.message == null || rsp.message.isEmpty()) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected error response message\"));\n                                    return;\n                                }\n\n                                if (!MinimalTestServiceErrorResponse.KIND.equals(rsp.documentKind)\n                                        || 0 != Double.compare(Math.PI, rsp.customErrorField)) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected custom error fields\"));\n                                    return;\n                                }\n                                testCxtForPut.complete();\n                            })\n                    .setBody(body));\n        }\n        testCxtForPut.await();\n        this.host.toggleDebuggingMode(false);\n    }\n\n    private void directOwnerSelection() throws Throwable {\n        Map<URI, Map<String, Long>> keyToNodeAssignmentsPerNode = new HashMap<>();\n        List<String> keys = new ArrayList<>();\n\n        long c = this.updateCount * this.nodeCount;\n        // generate N keys once, then ask each node to assign to its peers. Each node should come up\n        // with the same distribution\n\n        for (int i = 0; i < c; i++) {\n            keys.add(Utils.getNowMicrosUtc() + \"\");\n        }\n\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            keyToNodeAssignmentsPerNode.put(nodeGroup, new HashMap<>());\n        }\n\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        TestContext testContext = this.host.testCreate(c * this.nodeCount);\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            for (String key : keys) {\n                SelectAndForwardRequest body = new SelectAndForwardRequest();\n                body.key = key;\n                Operation post = Operation\n                        .createPost(UriUtils.buildUri(nodeGroup,\n                                ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                        .setBody(body)\n                        .setCompletion(\n                                (o, e) -> {\n                                    try {\n                                        synchronized (keyToNodeAssignmentsPerNode) {\n                                            SelectOwnerResponse rsp = o\n                                                    .getBody(SelectOwnerResponse.class);\n                                            Map<String, Long> assignmentsPerNode = keyToNodeAssignmentsPerNode\n                                                    .get(nodeGroup);\n                                            Long l = assignmentsPerNode.get(rsp.ownerNodeId);\n                                            if (l == null) {\n                                                l = 0L;\n                                            }\n                                            assignmentsPerNode.put(rsp.ownerNodeId, l + 1);\n                                            testContext.complete();\n                                        }\n                                    } catch (Throwable ex) {\n                                        testContext.fail(ex);\n                                    }\n                                });\n                this.host.send(post);\n            }\n        }\n        testContext.await();\n        this.host.logThroughput();\n\n        Map<String, Long> countPerNode = null;\n\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            Map<String, Long> assignmentsPerNode = keyToNodeAssignmentsPerNode.get(nodeGroup);\n            if (countPerNode == null) {\n                countPerNode = assignmentsPerNode;\n            }\n\n            this.host.log(\"Node group %s assignments: %s\", nodeGroup, assignmentsPerNode);\n\n            for (Entry<String, Long> e : assignmentsPerNode.entrySet()) {\n                // we assume that with random keys, and random node ids, each node will get at least\n                // one key.\n                assertTrue(e.getValue() > 0);\n                Long count = countPerNode.get(e.getKey());\n                if (count == null) {\n                    continue;\n                }\n                if (!count.equals(e.getValue())) {\n                    this.host.logNodeGroupState();\n                    throw new IllegalStateException(\n                            \"Node id got assigned the same key different number of times, on one of the nodes\");\n                }\n            }\n\n        }\n    }\n\n    @Test\n    public void replicationFullQuorumMissingServiceOnPeer() throws Throwable {\n        // This test verifies the following scenario:\n        // A new node joins an existing node-group with\n        // services already created. Synchronization is\n        // still in-progress and a write request arrives.\n        // If the quorum is configured to FULL, the write\n        // request will fail on the new node with not-found\n        // error, since synchronization hasn't completed.\n        // The test verifies that when this happens, the\n        // owner node will try to synchronize on-demand\n        // and retry the original update reqeust.\n\n        // Artificially setting the replica not found timeout to\n        // a lower-value, to reduce the wait time before owner\n        // retries\n        System.setProperty(\n                NodeSelectorReplicationService.PROPERTY_NAME_REPLICA_NOT_FOUND_TIMEOUT_MICROS,\n                Long.toString(TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS)));\n\n        this.host = VerificationHost.create(0);\n        this.host.setPeerSynchronizationEnabled(false);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(\n                VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n        this.host.start();\n\n        // Setup one host and create some example\n        // services on it.\n        List<URI> exampleUris = new ArrayList<>();\n        this.host.createExampleServices(this.host, this.serviceCount, exampleUris, null);\n\n        // Add a second host with synchronization disabled,\n        // Join it to the existing host.\n        VerificationHost host2 = new VerificationHost();\n\n        try {\n            TemporaryFolder tmpFolder = new TemporaryFolder();\n            tmpFolder.create();\n\n            String mainHostId = \"main-\" + VerificationHost.hostNumber.incrementAndGet();\n            String[] args = {\n                    \"--id=\" + mainHostId,\n                    \"--port=0\",\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + this.host.getUri()\n            };\n\n            host2.initialize(args);\n            host2.setPeerSynchronizationEnabled(false);\n            host2.setMaintenanceIntervalMicros(\n                    TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n            host2.start();\n\n            this.host.addPeerNode(host2);\n\n            // Wait for node-group to converge\n            List<URI> nodeGroupUris = new ArrayList<>();\n            nodeGroupUris.add(UriUtils.buildUri(this.host, ServiceUriPaths.DEFAULT_NODE_GROUP));\n            nodeGroupUris.add(UriUtils.buildUri(host2, ServiceUriPaths.DEFAULT_NODE_GROUP));\n            this.host.waitForNodeGroupConvergence(nodeGroupUris, 2, 2, true);\n\n            // Set the quorum to full.\n            this.host.setNodeGroupQuorum(2, nodeGroupUris.get(0));\n            host2.setNodeGroupQuorum(2);\n\n            // Filter the created examples to only those\n            // that are owned by host-1.\n            List<URI> host1Examples = exampleUris.stream()\n                    .filter(e -> this.host.isOwner(e.getPath(), ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                    .collect(Collectors.toList());\n\n            // Start patching all filtered examples. Because\n            // synchronization is disabled each of these\n            // example services will not exist on the new\n            // node that we added resulting in a non_found\n            // error. However, the owner will retry this\n            // after on-demand synchronization and hence\n            // patches should succeed.\n            ExampleServiceState state = new ExampleServiceState();\n            state.counter = 1L;\n\n            if (host1Examples.size() > 0) {\n                this.host.log(Level.INFO, \"Starting patches\");\n                TestContext ctx = this.host.testCreate(host1Examples.size());\n                for (URI exampleUri : host1Examples) {\n                    Operation patch = Operation\n                            .createPatch(exampleUri)\n                            .setBody(state)\n                            .setReferer(\"localhost\")\n                            .setCompletion(ctx.getCompletion());\n                    this.host.sendRequest(patch);\n                }\n                ctx.await();\n            }\n        } finally {\n            host2.tearDown();\n        }\n    }\n\n    @Test\n    public void replicationWithAuthAndNodeRestart() throws Throwable {\n        AuthorizationHelper authHelper;\n\n        this.isAuthorizationEnabled = true;\n        setUp(this.nodeCount);\n\n        authHelper = new AuthorizationHelper(this.host);\n\n        // relax quorum to allow for divergent writes, on independent nodes (not yet joined)\n\n        this.host.setSystemAuthorizationContext();\n\n        // Create the same users and roles on every peer independently\n        Map<ServiceHost, Collection<String>> roleLinksByHost = new HashMap<>();\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            String email = \"jane@doe.com\";\n            authHelper.createUserService(h, email);\n            authHelper.createRoles(h, email);\n        }\n\n        // Get roles from all nodes\n        Map<ServiceHost, Map<URI, RoleState>> roleStateByHost = getRolesByHost(roleLinksByHost);\n\n        // Join nodes to force synchronization and convergence\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n\n        // Get roles from all nodes\n        Map<ServiceHost, Map<URI, RoleState>> newRoleStateByHost = getRolesByHost(roleLinksByHost);\n\n        // Verify that every host independently advances their version & epoch\n        for (ServiceHost h : roleStateByHost.keySet()) {\n            Map<URI, RoleState> roleState = roleStateByHost.get(h);\n            for (URI u : roleState.keySet()) {\n                RoleState oldRole = roleState.get(u);\n                RoleState newRole = newRoleStateByHost.get(h).get(u);\n                assertTrue(\"version should have advanced\",\n                        newRole.documentVersion > oldRole.documentVersion);\n                assertTrue(\"epoch should have advanced\",\n                        newRole.documentEpoch > oldRole.documentEpoch);\n            }\n        }\n\n        // Verify that every host converged to the same version, epoch, and owner\n        Map<String, Long> versions = new HashMap<>();\n        Map<String, Long> epochs = new HashMap<>();\n        Map<String, String> owners = new HashMap<>();\n        for (ServiceHost h : newRoleStateByHost.keySet()) {\n            Map<URI, RoleState> roleState = newRoleStateByHost.get(h);\n            for (URI u : roleState.keySet()) {\n                RoleState newRole = roleState.get(u);\n\n                if (versions.containsKey(newRole.documentSelfLink)) {\n                    assertTrue(versions.get(newRole.documentSelfLink) == newRole.documentVersion);\n                } else {\n                    versions.put(newRole.documentSelfLink, newRole.documentVersion);\n                }\n\n                if (epochs.containsKey(newRole.documentSelfLink)) {\n                    assertTrue(Objects.equals(epochs.get(newRole.documentSelfLink),\n                            newRole.documentEpoch));\n                } else {\n                    epochs.put(newRole.documentSelfLink, newRole.documentEpoch);\n                }\n\n                if (owners.containsKey(newRole.documentSelfLink)) {\n                    assertEquals(owners.get(newRole.documentSelfLink), newRole.documentOwner);\n                } else {\n                    owners.put(newRole.documentSelfLink, newRole.documentOwner);\n                }\n            }\n        }\n\n        // create some example tasks, which delete example services. We dont have any\n        // examples services created, which is good, since we just want these tasks to\n        // go to finished state, then verify, after node restart, they all start\n        Set<String> exampleTaskLinks = new ConcurrentSkipListSet<>();\n        createReplicatedExampleTasks(exampleTaskLinks, null);\n\n        Set<String> exampleLinks = new ConcurrentSkipListSet<>();\n        verifyReplicatedAuthorizedPost(exampleLinks);\n\n        // verify restart, with authorization.\n        // stop one host\n        VerificationHost hostToStop = this.host.getInProcessHostMap().values().iterator().next();\n        stopAndRestartHost(exampleLinks, exampleTaskLinks, hostToStop);\n    }\n\n    private void createReplicatedExampleTasks(Set<String> exampleTaskLinks, String name)\n            throws Throwable {\n        URI factoryUri = UriUtils.buildFactoryUri(this.host.getPeerHost(),\n                ExampleTaskService.class);\n        this.host.setSystemAuthorizationContext();\n        // Sample body that this user is authorized to create\n        ExampleTaskServiceState exampleServiceState = new ExampleTaskServiceState();\n        if (name != null) {\n            exampleServiceState.customQueryClause = Query.Builder.create()\n                    .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, name).build();\n        }\n        this.host.log(\"creating example *task* instances\");\n        TestContext testContext = this.host.testCreate(this.serviceCount);\n        for (int i = 0; i < this.serviceCount; i++) {\n            CompletionHandler c = (o, e) -> {\n                if (e != null) {\n                    testContext.fail(e);\n                    return;\n                }\n                ExampleTaskServiceState rsp = o.getBody(ExampleTaskServiceState.class);\n                synchronized (exampleTaskLinks) {\n                    exampleTaskLinks.add(rsp.documentSelfLink);\n                }\n                testContext.complete();\n            };\n            this.host.send(Operation\n                    .createPost(factoryUri)\n                    .setBody(exampleServiceState)\n                    .setCompletion(c));\n        }\n        testContext.await();\n\n        // ensure all tasks are in finished state\n        this.host.waitFor(\"Example tasks did not finish\", () -> {\n            ServiceDocumentQueryResult rsp = this.host.getExpandedFactoryState(factoryUri);\n            for (Object o : rsp.documents.values()) {\n                ExampleTaskServiceState doc = Utils.fromJson(o, ExampleTaskServiceState.class);\n                if (TaskState.isFailed(doc.taskInfo)) {\n                    this.host.log(\"task %s failed: %s\", doc.documentSelfLink, doc.failureMessage);\n                    throw new IllegalStateException(\"task failed\");\n                }\n                if (!TaskState.isFinished(doc.taskInfo)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private void verifyReplicatedAuthorizedPost(Set<String> exampleLinks)\n            throws Throwable {\n        Collection<VerificationHost> hosts = this.host.getInProcessHostMap().values();\n        RoundRobinIterator<VerificationHost> it = new RoundRobinIterator<>(hosts);\n        int exampleServiceCount = this.serviceCount;\n\n        String userLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, \"jane@doe.com\");\n        // Verify we can assert identity and make a request to every host\n        this.host.assumeIdentity(userLink);\n\n        // Sample body that this user is authorized to create\n        ExampleServiceState exampleServiceState = new ExampleServiceState();\n        exampleServiceState.name = \"jane\";\n\n        this.host.log(\"creating example instances\");\n        TestContext testContext = this.host.testCreate(exampleServiceCount);\n        for (int i = 0; i < exampleServiceCount; i++) {\n            CompletionHandler c = (o, e) -> {\n                if (e != null) {\n                    testContext.fail(e);\n                    return;\n                }\n\n                try {\n                    // Verify the user is set as principal\n                    ExampleServiceState state = o.getBody(ExampleServiceState.class);\n                    assertEquals(state.documentAuthPrincipalLink,\n                            userLink);\n                    exampleLinks.add(state.documentSelfLink);\n                    testContext.complete();\n                } catch (Throwable e2) {\n                    testContext.fail(e2);\n                }\n            };\n            this.host.send(Operation\n                    .createPost(UriUtils.buildFactoryUri(it.next(), ExampleService.class))\n                    .setBody(exampleServiceState)\n                    .setCompletion(c));\n        }\n        testContext.await();\n\n        this.host.toggleNegativeTestMode(true);\n        // Sample body that this user is NOT authorized to create\n        ExampleServiceState invalidExampleServiceState = new ExampleServiceState();\n        invalidExampleServiceState.name = \"somebody other than jane\";\n\n        this.host.log(\"issuing non authorized request\");\n        TestContext testCtx = this.host.testCreate(exampleServiceCount);\n        for (int i = 0; i < exampleServiceCount; i++) {\n            this.host.send(Operation\n                    .createPost(UriUtils.buildFactoryUri(it.next(), ExampleService.class))\n                    .setBody(invalidExampleServiceState)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            assertEquals(Operation.STATUS_CODE_FORBIDDEN, o.getStatusCode());\n                            testCtx.complete();\n                            return;\n                        }\n\n                        testCtx.fail(new IllegalStateException(\"expected failure\"));\n                    }));\n        }\n        testCtx.await();\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    private void stopAndRestartHost(Set<String> exampleLinks, Set<String> exampleTaskLinks,\n            VerificationHost hostToStop)\n            throws Throwable, InterruptedException {\n        // relax quorum\n        this.host.setNodeGroupQuorum(this.nodeCount - 1);\n        // expire node that went away quickly to avoid alot of log spam from gossip failures\n        NodeGroupConfig cfg = new NodeGroupConfig();\n        cfg.nodeRemovalDelayMicros = TimeUnit.SECONDS.toMicros(1);\n        this.host.setNodeGroupConfig(cfg);\n\n        this.host.stopHostAndPreserveState(hostToStop);\n        this.host.waitForNodeGroupConvergence(2, 2);\n        VerificationHost existingHost = this.host.getInProcessHostMap().values().iterator().next();\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleTaskService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        // create some additional tasks on the remaining two hosts, but make sure they don't delete\n        // any example service instances, by specifying a name value we know will not match anything\n        createReplicatedExampleTasks(exampleTaskLinks, UUID.randomUUID().toString());\n\n        // delete some of the task links, to test synchronization of deleted entries on the restarted\n        // host\n        Set<String> deletedExampleLinks = deleteSomeServices(exampleLinks);\n\n        // increase quorum on existing nodes, so they wait for new node\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        hostToStop.setPort(0);\n        hostToStop.setSecurePort(0);\n        if (!VerificationHost.restartStatefulHost(hostToStop)) {\n            this.host.log(\"Failed restart of host, aborting\");\n            return;\n        }\n\n        // restart host, rejoin it\n        URI nodeGroupU = UriUtils.buildUri(hostToStop, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        URI eNodeGroupU = UriUtils.buildUri(existingHost, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.host.testStart(1);\n        this.host.setSystemAuthorizationContext();\n        this.host.joinNodeGroup(nodeGroupU, eNodeGroupU, this.nodeCount);\n        this.host.testWait();\n        this.host.addPeerNode(hostToStop);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n        // set quorum on new node as well\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        this.host.resetAuthorizationContext();\n\n        this.host.waitFor(\"Task services not started in restarted host:\" + exampleTaskLinks, () -> {\n            return checkChildServicesIfStarted(exampleTaskLinks, hostToStop) == 0;\n        });\n\n        // verify all services, not previously deleted, are restarted\n        this.host.waitFor(\"Services not started in restarted host:\" + exampleLinks, () -> {\n            return checkChildServicesIfStarted(exampleLinks, hostToStop) == 0;\n        });\n\n        int deletedCount = deletedExampleLinks.size();\n        this.host.waitFor(\"Deleted services still present in restarted host\", () -> {\n            return checkChildServicesIfStarted(deletedExampleLinks, hostToStop) == deletedCount;\n        });\n    }\n\n    private Set<String> deleteSomeServices(Set<String> exampleLinks)\n            throws Throwable {\n        int deleteCount = exampleLinks.size() / 3;\n        Iterator<String> itLinks = exampleLinks.iterator();\n        Set<String> deletedExampleLinks = new HashSet<>();\n        TestContext testContext = this.host.testCreate(deleteCount);\n        for (int i = 0; i < deleteCount; i++) {\n            String link = itLinks.next();\n            deletedExampleLinks.add(link);\n            exampleLinks.remove(link);\n            Operation delete = Operation.createDelete(this.host.getPeerServiceUri(link))\n                    .setCompletion(testContext.getCompletion());\n            this.host.send(delete);\n        }\n        testContext.await();\n        this.host.log(\"Deleted links: %s\", deletedExampleLinks);\n        return deletedExampleLinks;\n    }\n\n    private int checkChildServicesIfStarted(Set<String> exampleTaskLinks,\n            VerificationHost host) {\n        this.host.setSystemAuthorizationContext();\n        int notStartedCount = 0;\n        for (String s : exampleTaskLinks) {\n            ProcessingStage st = host.getServiceStage(s);\n            if (st == null) {\n                notStartedCount++;\n            }\n        }\n        this.host.resetAuthorizationContext();\n        if (notStartedCount > 0) {\n            this.host.log(\"%d services not started on %s (%s)\", notStartedCount,\n                    host.getPublicUri(), host.getId());\n        }\n        return notStartedCount;\n    }\n\n    private Map<ServiceHost, Map<URI, RoleState>> getRolesByHost(\n            Map<ServiceHost, Collection<String>> roleLinksByHost) throws Throwable {\n        Map<ServiceHost, Map<URI, RoleState>> roleStateByHost = new HashMap<>();\n        for (ServiceHost h : roleLinksByHost.keySet()) {\n            Collection<String> roleLinks = roleLinksByHost.get(h);\n            Collection<URI> roleURIs = new ArrayList<>();\n            for (String link : roleLinks) {\n                roleURIs.add(UriUtils.buildUri(h, link));\n            }\n\n            Map<URI, RoleState> serviceState = this.host.getServiceState(null, RoleState.class,\n                    roleURIs);\n            roleStateByHost.put(h, serviceState);\n        }\n        return roleStateByHost;\n    }\n\n    private void verifyOperationJoinAcrossPeers(Map<URI, ReplicationTestServiceState> childStates)\n            throws Throwable {\n        // do a OperationJoin across N nodes, making sure join works when forwarding is involved\n        List<Operation> joinedOps = new ArrayList<>();\n        for (ReplicationTestServiceState st : childStates.values()) {\n            Operation get = Operation.createGet(\n                    this.host.getPeerServiceUri(st.documentSelfLink)).setReferer(\n                    this.host.getReferer());\n            joinedOps.add(get);\n        }\n\n        TestContext testContext = this.host.testCreate(1);\n        OperationJoin\n                .create(joinedOps)\n                .setCompletion(\n                        (ops, exc) -> {\n                            if (exc != null) {\n                                testContext.fail(exc.values().iterator().next());\n                                return;\n                            }\n\n                            for (Operation o : ops.values()) {\n                                ReplicationTestServiceState state = o.getBody(\n                                        ReplicationTestServiceState.class);\n                                if (state.stringField == null) {\n                                    testContext.fail(new IllegalStateException());\n                                    return;\n                                }\n                            }\n                            testContext.complete();\n                        })\n                .sendWith(this.host.getPeerHost());\n        testContext.await();\n    }\n\n    public Map<String, Set<String>> computeOwnerIdsPerLink(VerificationHost joinedHost,\n            Collection<String> links)\n            throws Throwable {\n\n        TestContext testContext = this.host.testCreate(links.size());\n\n        Map<String, Set<String>> expectedOwnersPerLink = new ConcurrentSkipListMap<>();\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                testContext.fail(e);\n                return;\n            }\n\n            SelectOwnerResponse rsp = o.getBody(SelectOwnerResponse.class);\n            Set<String> eligibleNodeIds = new HashSet<>();\n            for (NodeState ns : rsp.selectedNodes) {\n                eligibleNodeIds.add(ns.id);\n            }\n            expectedOwnersPerLink.put(rsp.key, eligibleNodeIds);\n            testContext.complete();\n        };\n\n        for (String link : links) {\n            Operation selectOp = Operation.createGet(null)\n                    .setCompletion(c)\n                    .setExpiration(this.host.getOperationTimeoutMicros() + Utils.getNowMicrosUtc());\n\n            joinedHost.selectOwner(this.replicationNodeSelector, link, selectOp);\n        }\n        testContext.await();\n        return expectedOwnersPerLink;\n    }\n\n    public <T extends ServiceDocument> void verifyDocumentOwnerAndEpoch(Map<String, T> childStates,\n            VerificationHost joinedHost,\n            List<URI> joinedHostUris,\n            int minExpectedEpochRetries,\n            int maxExpectedEpochRetries, int expectedOwnerChanges)\n            throws Throwable, InterruptedException, TimeoutException {\n\n        Map<URI, NodeGroupState> joinedHostNodeGroupStates = this.host.getServiceState(null,\n                NodeGroupState.class, joinedHostUris);\n        Set<String> joinedHostOwnerIds = new HashSet<>();\n        for (NodeGroupState st : joinedHostNodeGroupStates.values()) {\n            joinedHostOwnerIds.add(st.documentOwner);\n        }\n\n        this.host.waitFor(\"ownership did not converge\", () -> {\n            Map<String, Set<String>> ownerIdsPerLink = computeOwnerIdsPerLink(joinedHost,\n                    childStates.keySet());\n            boolean isConverged = true;\n            Map<String, Set<Long>> epochsPerLink = new HashMap<>();\n            List<URI> nodeSelectorStatsUris = new ArrayList<>();\n\n            for (URI baseNodeUri : joinedHostUris) {\n                nodeSelectorStatsUris.add(UriUtils.buildUri(baseNodeUri,\n                        ServiceUriPaths.DEFAULT_NODE_SELECTOR,\n                        ServiceHost.SERVICE_URI_SUFFIX_STATS));\n\n                URI factoryUri = UriUtils.buildUri(\n                        baseNodeUri, this.replicationTargetFactoryLink);\n                ServiceDocumentQueryResult factoryRsp = this.host\n                        .getFactoryState(factoryUri);\n                if (factoryRsp.documentLinks == null\n                        || factoryRsp.documentLinks.size() != childStates.size()) {\n                    isConverged = false;\n                    // services not all started in new nodes yet;\n                    this.host.log(\"Node %s does not have all services: %s\", baseNodeUri,\n                            Utils.toJsonHtml(factoryRsp));\n                    break;\n                }\n\n                List<URI> childUris = new ArrayList<>();\n                for (String link : childStates.keySet()) {\n                    childUris.add(UriUtils.buildUri(baseNodeUri, link));\n                }\n\n                // retrieve the document state directly from each service\n                Map<URI, ServiceDocument> childDocs = this.host.getServiceState(null,\n                        ServiceDocument.class, childUris);\n\n                List<URI> childStatUris = new ArrayList<>();\n                for (ServiceDocument state : childDocs.values()) {\n\n                    if (state.documentOwner == null) {\n                        this.host.log(\"Owner not set in service on new node: %s\",\n                                Utils.toJsonHtml(state));\n                        isConverged = false;\n                        break;\n                    }\n\n                    URI statUri = UriUtils.buildUri(baseNodeUri, state.documentSelfLink,\n                            ServiceHost.SERVICE_URI_SUFFIX_STATS);\n                    childStatUris.add(statUri);\n\n                    Set<Long> epochs = epochsPerLink.get(state.documentEpoch);\n                    if (epochs == null) {\n                        epochs = new HashSet<>();\n                        epochsPerLink.put(state.documentSelfLink, epochs);\n                    }\n\n                    epochs.add(state.documentEpoch);\n                    Set<String> eligibleNodeIds = ownerIdsPerLink.get(state.documentSelfLink);\n\n                    if (!joinedHostOwnerIds.contains(state.documentOwner)) {\n                        this.host.log(\"Owner id for %s not expected: %s, valid ids: %s\",\n                                state.documentSelfLink, state.documentOwner, joinedHostOwnerIds);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (eligibleNodeIds != null && !eligibleNodeIds.contains(state.documentOwner)) {\n                        this.host.log(\"Owner id for %s not eligible: %s, eligible ids: %s\",\n                                state.documentSelfLink, state.documentOwner, joinedHostOwnerIds);\n                        isConverged = false;\n                        break;\n                    }\n                }\n\n                int nodeGroupMaintCount = 0;\n                int docOwnerToggleOffCount = 0;\n                int docOwnerToggleCount = 0;\n                // verify stats were reported by owner node, not a random peer\n                Map<URI, ServiceStats> allChildStats = this.host.getServiceState(null,\n                        ServiceStats.class, childStatUris);\n                for (ServiceStats childStats : allChildStats.values()) {\n                    String parentLink = UriUtils.getParentPath(childStats.documentSelfLink);\n                    Set<String> eligibleNodes = ownerIdsPerLink.get(parentLink);\n                    if (!eligibleNodes.contains(childStats.documentOwner)) {\n                        this.host.log(\"Stats for %s owner not expected. Is %s, should be %s\",\n                                parentLink, childStats.documentOwner,\n                                ownerIdsPerLink.get(parentLink));\n                        isConverged = false;\n                        break;\n                    }\n                    ServiceStat maintStat = childStats.entries\n                            .get(Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n                    if (maintStat != null) {\n                        nodeGroupMaintCount++;\n                    }\n                    ServiceStat docOwnerToggleOffStat = childStats.entries\n                            .get(Service.STAT_NAME_DOCUMENT_OWNER_TOGGLE_OFF_MAINT_COUNT);\n                    if (docOwnerToggleOffStat != null) {\n                        docOwnerToggleOffCount++;\n                    }\n                    ServiceStat docOwnerToggleStat = childStats.entries\n                            .get(Service.STAT_NAME_DOCUMENT_OWNER_TOGGLE_ON_MAINT_COUNT);\n                    if (docOwnerToggleStat != null) {\n                        docOwnerToggleCount++;\n                    }\n                }\n\n                this.host.log(\"Node group change maintenance observed: %d\", nodeGroupMaintCount);\n                if (nodeGroupMaintCount < expectedOwnerChanges) {\n                    isConverged = false;\n                }\n\n                this.host.log(\"Toggled off doc owner count: %d, toggle on count: %d\",\n                        docOwnerToggleOffCount, docOwnerToggleCount);\n                if (docOwnerToggleCount < childStates.size()) {\n                    isConverged = false;\n                }\n\n                // verify epochs\n                for (Set<Long> epochs : epochsPerLink.values()) {\n                    if (epochs.size() > 1) {\n                        this.host.log(\"Documents have different epochs:%s\", epochs.toString());\n                        isConverged = false;\n                    }\n                }\n\n                if (!isConverged) {\n                    break;\n                }\n            }\n\n            return isConverged;\n        });\n    }\n\n    private <T extends ServiceDocument> Map<String, T> doStateUpdateReplicationTest(Action action,\n            int childCount, int updateCount,\n            long expectedVersion,\n            Function<T, Void> updateBodySetter,\n            BiPredicate<T, T> convergenceChecker,\n            Map<String, T> initialStatesPerChild) throws Throwable {\n        return doStateUpdateReplicationTest(action, childCount, updateCount, expectedVersion,\n                updateBodySetter, convergenceChecker, initialStatesPerChild, null, null);\n    }\n\n    private <T extends ServiceDocument> Map<String, T> doStateUpdateReplicationTest(Action action,\n            int childCount, int updateCount,\n            long expectedVersion,\n            Function<T, Void> updateBodySetter,\n            BiPredicate<T, T> convergenceChecker,\n            Map<String, T> initialStatesPerChild,\n            Map<Action, Long> countsPerAction,\n            Map<Action, Long> elapsedTimePerAction) throws Throwable {\n\n        int testCount = childCount * updateCount;\n        String testName = \"Replication with \" + action;\n        TestContext testContext = this.host.testCreate(testCount);\n        testContext.setTestName(testName).logBefore();\n\n        if (!this.expectFailure) {\n            // Before we do the replication test, wait for factory availability.\n            for (URI fu : this.host.getNodeGroupToFactoryMap(this.replicationTargetFactoryLink)\n                    .values()) {\n                // confirm that /factory/available returns 200 across all nodes\n                waitForReplicatedFactoryServiceAvailable(fu, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            }\n        }\n\n        long before = Utils.getNowMicrosUtc();\n        AtomicInteger failedCount = new AtomicInteger();\n        // issue an update to each child service and verify it was reflected\n        // among\n        // peers\n        for (T initState : initialStatesPerChild.values()) {\n            // change a field in the initial state of each service but keep it\n            // the same across all updates so potential re ordering of the\n            // updates does not cause spurious test breaks\n            updateBodySetter.apply(initState);\n\n            for (int i = 0; i < updateCount; i++) {\n\n                long sentTime = 0;\n                if (this.expectFailure) {\n                    sentTime = Utils.getNowMicrosUtc();\n                }\n                URI factoryOnRandomPeerUri = this.host\n                        .getPeerServiceUri(this.replicationTargetFactoryLink);\n\n                long finalSentTime = sentTime;\n                this.host\n                        .send(Operation\n                                .createPatch(UriUtils.buildUri(factoryOnRandomPeerUri,\n                                        initState.documentSelfLink))\n                                .setAction(action)\n                                .forceRemote()\n                                .setBodyNoCloning(initState)\n                                .setCompletion(\n                                        (o, e) -> {\n                                            if (e != null) {\n                                                if (this.expectFailure) {\n                                                    failedCount.incrementAndGet();\n                                                    testContext.complete();\n                                                    return;\n                                                }\n                                                testContext.fail(e);\n                                                return;\n                                            }\n\n                                            if (this.expectFailure\n                                                    && this.expectedFailureStartTimeMicros > 0\n                                                    && finalSentTime > this.expectedFailureStartTimeMicros) {\n                                                testContext.fail(new IllegalStateException(\n                                                        \"Request should have failed: %s\"\n                                                                + o.toString()\n                                                                + \" sent at \" + finalSentTime));\n                                                return;\n                                            }\n                                            testContext.complete();\n                                        }));\n            }\n        }\n\n        testContext.await();\n        testContext.logAfter();\n\n        updatePerfDataPerAction(action, before, (long) (childCount * updateCount), countsPerAction,\n                elapsedTimePerAction);\n\n        if (this.expectFailure) {\n            this.host.log(\"Failed count: %d\", failedCount.get());\n            if (failedCount.get() == 0) {\n                throw new IllegalStateException(\n                        \"Possible false negative but expected at least one failure\");\n            }\n            return initialStatesPerChild;\n        }\n\n        // All updates sent to all children within one host, now wait for\n        // convergence\n        if (action != Action.DELETE) {\n            return waitForReplicatedFactoryChildServiceConvergence(initialStatesPerChild,\n                    convergenceChecker,\n                    childCount,\n                    expectedVersion);\n        }\n\n        // for DELETE replication, we expect the child services to be stopped\n        // across hosts and their state marked \"deleted\". So confirm no children\n        // are available\n        return waitForReplicatedFactoryChildServiceConvergence(initialStatesPerChild,\n                convergenceChecker,\n                0,\n                expectedVersion);\n    }\n\n    private Map<String, ExampleServiceState> doExampleFactoryPostReplicationTest(int childCount,\n            Map<Action, Long> countPerAction,\n            Map<Action, Long> elapsedTimePerAction)\n            throws Throwable {\n        return doExampleFactoryPostReplicationTest(childCount, null,\n                countPerAction, elapsedTimePerAction);\n    }\n\n    private Map<String, ExampleServiceState> doExampleFactoryPostReplicationTest(int childCount,\n            EnumSet<TestProperty> props,\n            Map<Action, Long> countPerAction,\n            Map<Action, Long> elapsedTimePerAction) throws Throwable {\n\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        if (this.host == null) {\n            setUp(this.nodeCount);\n            this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)) {\n            this.host.toggleNegativeTestMode(true);\n        }\n\n        String factoryPath = this.replicationTargetFactoryLink;\n        Map<String, ExampleServiceState> serviceStates = new HashMap<>();\n        long before = Utils.getNowMicrosUtc();\n        TestContext testContext = this.host.testCreate(childCount);\n        testContext.setTestName(\"POST replication\");\n        testContext.logBefore();\n        for (int i = 0; i < childCount; i++) {\n            URI factoryOnRandomPeerUri = this.host.getPeerServiceUri(factoryPath);\n            Operation post = Operation\n                    .createPost(factoryOnRandomPeerUri)\n                    .setCompletion(testContext.getCompletion());\n\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.name = \"\" + post.getId();\n            initialState.counter = Long.MIN_VALUE;\n\n            // set the self link as a hint so the child service URI is\n            // predefined instead of random\n            initialState.documentSelfLink = \"\" + post.getId();\n\n            // factory service is started on all hosts. Now issue a POST to one,\n            // to create a child service with some initial state.\n            post.setReferer(this.host.getReferer());\n            this.host.sendRequest(post.setBody(initialState));\n\n            // initial state is cloned and sent, now we can change self link per\n            // child to reflect its runtime URI, which will\n            // contain the factory service path\n            initialState.documentSelfLink = UriUtils.buildUriPath(factoryPath,\n                    initialState.documentSelfLink);\n            serviceStates.put(initialState.documentSelfLink, initialState);\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)) {\n            // do not wait for convergence of the child services. Instead\n            // proceed to the next test which is probably stopping hosts\n            // abruptly\n            return serviceStates;\n        }\n\n        testContext.await();\n        updatePerfDataPerAction(Action.POST, before, (long) this.serviceCount, countPerAction,\n                elapsedTimePerAction);\n\n        testContext.logAfter();\n\n        return waitForReplicatedFactoryChildServiceConvergence(serviceStates,\n                this.exampleStateConvergenceChecker,\n                childCount,\n                0L);\n    }\n\n    private void updateExampleServiceOptions(\n            Map<String, ExampleServiceState> statesPerSelfLink) throws Throwable {\n        if (this.postCreationServiceOptions == null || this.postCreationServiceOptions.isEmpty()) {\n            return;\n        }\n        TestContext testContext = this.host.testCreate(statesPerSelfLink.size());\n        URI nodeGroup = this.host.getNodeGroupMap().values().iterator().next();\n        for (String link : statesPerSelfLink.keySet()) {\n            URI bUri = UriUtils.buildBroadcastRequestUri(\n                    UriUtils.buildUri(nodeGroup, link, ServiceHost.SERVICE_URI_SUFFIX_CONFIG),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            ServiceConfigUpdateRequest cfgBody = ServiceConfigUpdateRequest.create();\n            cfgBody.addOptions = this.postCreationServiceOptions;\n            this.host.send(Operation.createPatch(bUri)\n                    .setBody(cfgBody)\n                    .setCompletion(testContext.getCompletion()));\n\n        }\n        testContext.await();\n    }\n\n    private <T extends ServiceDocument> Map<String, T> waitForReplicatedFactoryChildServiceConvergence(\n            Map<String, T> serviceStates,\n            BiPredicate<T, T> stateChecker,\n            int expectedChildCount, long expectedVersion)\n            throws Throwable, TimeoutException {\n        return waitForReplicatedFactoryChildServiceConvergence(\n                getFactoriesPerNodeGroup(this.replicationTargetFactoryLink),\n                serviceStates,\n                stateChecker,\n                expectedChildCount,\n                expectedVersion);\n    }\n\n    private <T extends ServiceDocument> Map<String, T> waitForReplicatedFactoryChildServiceConvergence(\n            Map<URI, URI> factories,\n            Map<String, T> serviceStates,\n            BiPredicate<T, T> stateChecker,\n            int expectedChildCount, long expectedVersion)\n            throws Throwable, TimeoutException {\n        // now poll all hosts until they converge: They all have a child service\n        // with the expected URI and it has the same state\n\n        Map<String, T> updatedStatesPerSelfLink = new HashMap<>();\n        Date expiration = new Date(new Date().getTime()\n                + TimeUnit.SECONDS.toMillis(this.host.getTimeoutSeconds()));\n        do {\n\n            URI node = factories.keySet().iterator().next();\n            AtomicInteger getFailureCount = new AtomicInteger();\n            if (expectedChildCount != 0) {\n                // issue direct GETs to the services, we do not trust the factory\n\n                for (String link : serviceStates.keySet()) {\n                    TestContext ctx = this.host.testCreate(1);\n                    Operation get = Operation.createGet(UriUtils.buildUri(node, link))\n                            .setReferer(this.host.getReferer())\n                            .setExpiration(Utils.getNowMicrosUtc() + TimeUnit.SECONDS.toMicros(5))\n                            .setCompletion(\n                                    (o, e) -> {\n                                        if (e != null) {\n                                            getFailureCount.incrementAndGet();\n                                        }\n                                        ctx.completeIteration();\n                                    });\n                    this.host.sendRequest(get);\n                    this.host.testWait(ctx);\n                }\n\n            }\n\n            if (getFailureCount.get() > 0) {\n                this.host.log(\"Child services not propagated yet. Failure count: %d\",\n                        getFailureCount.get());\n                Thread.sleep(500);\n                continue;\n            }\n\n            TestContext testContext = this.host.testCreate(factories.size());\n            Map<URI, ServiceDocumentQueryResult> childServicesPerNode = new HashMap<>();\n            for (URI remoteFactory : factories.values()) {\n                URI factoryUriWithExpand = UriUtils.buildExpandLinksQueryUri(remoteFactory);\n                Operation get = Operation.createGet(factoryUriWithExpand)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContext.complete();\n                                        return;\n                                    }\n                                    if (!o.hasBody()) {\n                                        testContext.complete();\n                                        return;\n                                    }\n                                    ServiceDocumentQueryResult r = o\n                                            .getBody(ServiceDocumentQueryResult.class);\n                                    synchronized (childServicesPerNode) {\n                                        childServicesPerNode.put(o.getUri(), r);\n                                    }\n                                    testContext.complete();\n                                });\n                this.host.send(get);\n            }\n            testContext.await();\n\n            long expectedNodeCountPerLinkMax = factories.size();\n            long expectedNodeCountPerLinkMin = expectedNodeCountPerLinkMax;\n            if (this.replicationFactor != 0) {\n                // We expect services to end up either on K nodes, or K + 1 nodes,\n                // if limited replication is enabled. The reason we might end up with services on\n                // an additional node, is because we elect an owner to synchronize an entire factory,\n                // using the factory's link, and that might end up on a node not used for any child.\n                // This will produce children on that node, giving us K+1 replication, which is acceptable\n                // given K (replication factor) << N (total nodes in group)\n                expectedNodeCountPerLinkMax = this.replicationFactor + 1;\n                expectedNodeCountPerLinkMin = this.replicationFactor;\n            }\n\n            if (expectedChildCount == 0) {\n                expectedNodeCountPerLinkMax = 0;\n                expectedNodeCountPerLinkMin = 0;\n            }\n\n            // build a service link to node map so we can tell on which node each service instance landed\n            Map<String, Set<URI>> linkToNodeMap = new HashMap<>();\n\n            boolean isConverged = true;\n            for (Entry<URI, ServiceDocumentQueryResult> entry : childServicesPerNode.entrySet()) {\n                for (String link : entry.getValue().documentLinks) {\n                    if (!serviceStates.containsKey(link)) {\n                        this.host.log(\"service %s not expected, node: %s\", link, entry.getKey());\n                        isConverged = false;\n                        continue;\n                    }\n\n                    Set<URI> hostsPerLink = linkToNodeMap.get(link);\n                    if (hostsPerLink == null) {\n                        hostsPerLink = new HashSet<>();\n                    }\n                    hostsPerLink.add(entry.getKey());\n                    linkToNodeMap.put(link, hostsPerLink);\n                }\n            }\n\n            if (!isConverged) {\n                Thread.sleep(500);\n                continue;\n            }\n\n            // each link must exist on N hosts, where N is either the replication factor, or, if not used, all nodes\n            for (Entry<String, Set<URI>> e : linkToNodeMap.entrySet()) {\n                if (e.getValue() == null && this.replicationFactor == 0) {\n                    this.host.log(\"Service %s not found on any nodes\", e.getKey());\n                    isConverged = false;\n                    continue;\n                }\n\n                if (e.getValue().size() < expectedNodeCountPerLinkMin\n                        || e.getValue().size() > expectedNodeCountPerLinkMax) {\n                    this.host.log(\"Service %s found on %d nodes, expected %d -> %d\", e.getKey(), e\n                                    .getValue().size(), expectedNodeCountPerLinkMin,\n                            expectedNodeCountPerLinkMax);\n                    isConverged = false;\n                }\n            }\n\n            if (!isConverged) {\n                Thread.sleep(500);\n                continue;\n            }\n\n            if (expectedChildCount == 0) {\n                // DELETE test, all children removed from all hosts, we are done\n                return updatedStatesPerSelfLink;\n            }\n\n            // verify /available reports correct results on the factory.\n            URI factoryUri = factories.values().iterator().next();\n            Class<?> stateType = serviceStates.values().iterator().next().getClass();\n            waitForReplicatedFactoryServiceAvailable(factoryUri,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n            // we have the correct number of services on all hosts. Now verify\n            // the state of each service matches what we expect\n\n            isConverged = true;\n\n            for (Entry<String, Set<URI>> entry : linkToNodeMap.entrySet()) {\n                String selfLink = entry.getKey();\n                int convergedNodeCount = 0;\n                for (URI nodeUri : entry.getValue()) {\n                    ServiceDocumentQueryResult childLinksAndDocsPerHost = childServicesPerNode\n                            .get(nodeUri);\n                    Object jsonState = childLinksAndDocsPerHost.documents.get(selfLink);\n                    if (jsonState == null && this.replicationFactor == 0) {\n                        this.host\n                                .log(\"Service %s not present on host %s\", selfLink, entry.getKey());\n                        continue;\n                    }\n\n                    if (jsonState == null) {\n                        continue;\n                    }\n\n                    T initialState = serviceStates.get(selfLink);\n\n                    if (initialState == null) {\n                        continue;\n                    }\n\n                    @SuppressWarnings(\"unchecked\")\n                    T stateOnNode = (T) Utils.fromJson(jsonState, stateType);\n                    if (!stateChecker.test(initialState, stateOnNode)) {\n                        this.host\n                                .log(\"State for %s not converged on node %s. Current state: %s, Initial: %s\",\n                                        selfLink, nodeUri, Utils.toJsonHtml(stateOnNode),\n                                        Utils.toJsonHtml(initialState));\n                        break;\n                    }\n\n                    if (stateOnNode.documentVersion < expectedVersion) {\n                        this.host\n                                .log(\"Version (%d, expected %d) not converged, state: %s\",\n                                        stateOnNode.documentVersion,\n                                        expectedVersion,\n                                        Utils.toJsonHtml(stateOnNode));\n                        break;\n                    }\n\n                    if (stateOnNode.documentEpoch == null) {\n                        this.host.log(\"Epoch is missing, state: %s\",\n                                Utils.toJsonHtml(stateOnNode));\n                        break;\n                    }\n\n                    // Do not check exampleState.counter, in this validation loop.\n                    // We can not compare the counter since the replication test sends the updates\n                    // in parallel, meaning some of them will get re-ordered and ignored due to\n                    // version being out of date.\n\n                    updatedStatesPerSelfLink.put(selfLink, stateOnNode);\n                    convergedNodeCount++;\n                }\n\n                if (convergedNodeCount < expectedNodeCountPerLinkMin\n                        || convergedNodeCount > expectedNodeCountPerLinkMax) {\n                    isConverged = false;\n                    break;\n                }\n            }\n\n            if (isConverged) {\n                return updatedStatesPerSelfLink;\n            }\n\n            Thread.sleep(500);\n        } while (new Date().before(expiration));\n\n        throw new TimeoutException();\n    }\n\n    private List<ServiceHostState> stopHostsToSimulateFailure(int failedNodeCount) {\n        int k = 0;\n        List<ServiceHostState> stoppedHosts = new ArrayList<>();\n        for (VerificationHost hostToStop : this.host.getInProcessHostMap().values()) {\n            this.host.log(\"Stopping host %s\", hostToStop);\n            stoppedHosts.add(hostToStop.getState());\n            this.host.stopHost(hostToStop);\n\n            k++;\n            if (k >= failedNodeCount) {\n                break;\n            }\n        }\n        return stoppedHosts;\n    }\n\n    public static class StopVerificationTestService extends StatefulService {\n\n        public Collection<URI> serviceTargets;\n\n        public AtomicInteger outboundRequestCompletion = new AtomicInteger();\n        public AtomicInteger outboundRequestFailureCompletion = new AtomicInteger();\n\n        public StopVerificationTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation deleteForStop) {\n            // send requests to replicated services, during stop to verify that the\n            // runtime prevents any outbound requests from making it out\n            for (URI uri : this.serviceTargets) {\n                ReplicationTestServiceState body = new ReplicationTestServiceState();\n                body.stringField = ReplicationTestServiceState.CLIENT_PATCH_HINT;\n                for (int i = 0; i < 10; i++) {\n                    // send patch to self, so the select owner logic gets invoked and in theory\n                    // queues or cancels the request\n                    Operation op = Operation.createPatch(this, uri.getPath()).setBody(body)\n                            .setTargetReplicated(true)\n                            .setCompletion((o, e) -> {\n                                if (e != null) {\n                                    this.outboundRequestFailureCompletion.incrementAndGet();\n                                } else {\n                                    this.outboundRequestCompletion.incrementAndGet();\n                                }\n                            });\n                    sendRequest(op);\n                }\n            }\n        }\n\n    }\n\n    private void stopHostsAndVerifyQueuing(Collection<VerificationHost> hostsToStop,\n            VerificationHost remainingHost,\n            Collection<URI> serviceTargets) throws Throwable {\n        this.host.log(\"Starting to stop hosts and verify queuing\");\n\n        // reduce node expiration for unavailable hosts so gossip warning\n        // messages do not flood the logs\n        this.nodeGroupConfig.nodeRemovalDelayMicros = remainingHost.getMaintenanceIntervalMicros();\n        this.host.setNodeGroupConfig(this.nodeGroupConfig);\n        this.setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(10));\n\n        // relax quorum to single remaining host\n        this.host.setNodeGroupQuorum(1);\n\n        // start a special test service that will attempt to send messages when it sees\n        // handleStop(). This is not expected of production code, since service authors\n        // should never have to worry about handleStop(). We rely on the fact that handleStop\n        // will be called due to node shutdown, and issue requests to replicated targets,\n        // then check if anyone of them actually made it out (they should not have)\n\n        List<StopVerificationTestService> verificationServices = new ArrayList<>();\n\n        // Do the inverse test. Remove all of the original hosts and this time, expect all the\n        // documents have owners assigned to the new hosts\n        for (VerificationHost h : hostsToStop) {\n            StopVerificationTestService s = new StopVerificationTestService();\n            verificationServices.add(s);\n            s.serviceTargets = serviceTargets;\n            h.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n            this.host.stopHost(h);\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            for (StopVerificationTestService s : verificationServices) {\n                if (s.outboundRequestCompletion.get() > 0) {\n                    throw new IllegalStateException(\"Replicated request succeeded\");\n                }\n                if (s.outboundRequestFailureCompletion.get() < serviceTargets.size()) {\n                    // We expect at least one failure per service target, if we have less\n                    // keep polling.\n                    this.host.log(\n                            \"Not converged yet: service %s on host %s has %d outbound request failures, which is lower than %d\",\n                            s.getSelfLink(), s.getHost().getId(),\n                            s.outboundRequestFailureCompletion.get(), serviceTargets.size());\n                    isConverged = false;\n                    break;\n                }\n            }\n\n            if (isConverged) {\n                this.host.log(\"Done with stop hosts and verify queuing\");\n                return;\n            }\n\n            Thread.sleep(250);\n        }\n\n        throw new TimeoutException();\n    }\n\n    private void waitForReplicatedFactoryServiceAvailable(URI uri, String nodeSelectorPath)\n            throws Throwable {\n        if (this.skipAvailabilityChecks) {\n            return;\n        }\n        if (UriUtils.isHostEqual(this.host, uri)) {\n\n            VerificationHost host = this.host;\n\n            // if uri is for in-process peers, then use the one\n            URI peerUri = UriUtils.buildUri(uri.toString().replace(uri.getPath(), \"\"));\n            VerificationHost peer = this.host.getInProcessHostMap().get(peerUri);\n            if (peer != null) {\n                host = peer;\n            }\n\n            TestContext ctx = host.testCreate(1);\n            CompletionHandler ch = (o, e) -> {\n                if (e != null) {\n                    String msg = \"Failed to check replicated factory service availability\";\n                    ctx.failIteration(new RuntimeException(msg, e));\n                    return;\n                }\n                ctx.completeIteration();\n            };\n\n            host.registerForServiceAvailability(ch, nodeSelectorPath, true, uri.getPath());\n            ctx.await();\n\n        } else {\n            // for remote host\n            this.host.waitForReplicatedFactoryServiceAvailable(uri, nodeSelectorPath);\n        }\n\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport java.io.NotActiveException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.logging.Level;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UiContentService;\n\n\n/**\n * Utility service managing the various URI control REST APIs for each service instance. A single\n * utility service instance manages operations on multiple URI suffixes (/stats, /subscriptions,\n * etc) in order to reduce runtime overhead per service instance\n */\npublic class UtilityService implements Service {\n    private transient Service parent;\n    private ServiceStats stats;\n    private ServiceSubscriptionState subscriptions;\n    private UiContentService uiService;\n\n    public UtilityService() {\n    }\n\n    public UtilityService setParent(Service parent) {\n        this.parent = parent;\n        return this;\n    }\n\n    @Override\n    public void authorizeRequest(Operation op) {\n\n        String suffix = UriUtils.buildUriPath(UriUtils.URI_PATH_CHAR, UriUtils.getLastPathSegment(op.getUri()));\n\n        // allow access to ui endpoint\n        if (ServiceHost.SERVICE_URI_SUFFIX_UI.equals(suffix)) {\n            op.complete();\n            return;\n        }\n\n        ServiceDocument doc = new ServiceDocument();\n        if (this.parent.getOptions().contains(ServiceOption.FACTORY_ITEM)) {\n            doc.documentSelfLink = UriUtils.buildUriPath(UriUtils.getParentPath(this.parent.getSelfLink()), suffix);\n        } else {\n            doc.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(), suffix);\n        }\n\n        doc.documentKind = Utils.buildKind(this.parent.getStateType());\n        if (getHost().isAuthorized(this.parent, doc, op)) {\n            op.complete();\n            return;\n        }\n\n        op.fail(Operation.STATUS_CODE_FORBIDDEN);\n    }\n\n    @Override\n    public void handleRequest(Operation op) {\n        String uriPrefix = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n\n        if (op.getUri().getPath().startsWith(uriPrefix)) {\n            // startsWith catches all /factory/instance/ui/some-script.js\n            handleUiRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_STATS)) {\n            handleStatsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS)) {\n            handleSubscriptionsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_TEMPLATE)) {\n            handleDocumentTemplateRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_CONFIG)) {\n            this.parent.handleConfigurationRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_AVAILABLE)) {\n            handleAvailableRequest(op);\n        } else {\n            op.fail(new UnknownHostException());\n        }\n    }\n\n    @Override\n    public void handleCreate(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void handleStart(Operation startPost) {\n        startPost.complete();\n    }\n\n    @Override\n    public void handleStop(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op, OperationProcessingStage opProcessingStage) {\n        handleRequest(op);\n    }\n\n    private void handleAvailableRequest(Operation op) {\n        if (op.getAction() == Action.GET) {\n            if (this.parent.getProcessingStage() != ProcessingStage.PAUSED\n                    && this.parent.getProcessingStage() != ProcessingStage.AVAILABLE) {\n                // processing stage takes precedence over isAvailable statistic\n                op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n                return;\n            }\n            if (this.stats == null) {\n                op.complete();\n                return;\n            }\n            ServiceStat st = this.getStat(STAT_NAME_AVAILABLE, false);\n            if (st == null || st.latestValue == 1.0) {\n                op.complete();\n                return;\n            }\n            op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n        } else if (op.getAction() == Action.PATCH || op.getAction() == Action.PUT) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalArgumentException(\"body is required\"));\n                return;\n            }\n            ServiceStat st = op.getBody(ServiceStat.class);\n            if (!STAT_NAME_AVAILABLE.equals(st.name)) {\n                op.fail(new IllegalArgumentException(\n                        \"body must be of type ServiceStat and name must be \"\n                                + STAT_NAME_AVAILABLE));\n                return;\n            }\n            handleStatsRequest(op);\n        } else {\n            getHost().failRequestActionNotSupported(op);\n        }\n    }\n\n    private void handleSubscriptionsRequest(Operation op) {\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                this.subscriptions = new ServiceSubscriptionState();\n                this.subscriptions.subscribers = new ConcurrentSkipListMap<>();\n            }\n        }\n\n        ServiceSubscriber body = null;\n        if (op.hasBody()) {\n            body = op.getBody(ServiceSubscriber.class);\n            if (body.reference == null) {\n                op.fail(new IllegalArgumentException(\"reference is required\"));\n                return;\n            }\n        }\n\n        switch (op.getAction()) {\n        case POST:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.put(body.reference, body);\n            }\n            if (!body.replayState) {\n                break;\n            }\n            // if replayState is set, replay the current state to the subscriber\n            URI notificationURI = body.reference;\n            this.parent.sendRequest(Operation.createGet(this, this.parent.getSelfLink())\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    op.fail(new IllegalStateException(\n                                            \"Unable to get current state\"));\n                                    return;\n                                }\n                                Operation putOp = Operation\n                                        .createPut(notificationURI)\n                                        .setBodyNoCloning(o.getBody(this.parent.getStateType()))\n                                        .addPragmaDirective(\n                                                Operation.PRAGMA_DIRECTIVE_NOTIFICATION)\n                                        .setReferer(getUri());\n                                this.parent.sendRequest(putOp);\n                            }));\n\n            break;\n        case DELETE:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.remove(body.reference);\n            }\n            break;\n        case GET:\n            ServiceDocument rsp;\n            synchronized (this.subscriptions) {\n                rsp = Utils.clone(this.subscriptions);\n            }\n            op.setBody(rsp);\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n\n        op.complete();\n    }\n\n    public boolean hasSubscribers() {\n        ServiceSubscriptionState subscriptions = this.subscriptions;\n        return subscriptions != null\n                && subscriptions.subscribers != null\n                && !subscriptions.subscribers.isEmpty();\n    }\n\n    public boolean hasStats() {\n        ServiceStats stats = this.stats;\n        return stats != null && stats.entries != null && !stats.entries.isEmpty();\n    }\n\n    public void notifySubscribers(Operation op) {\n        try {\n            if (op.getAction() == Action.GET) {\n                return;\n            }\n\n            if (!this.hasSubscribers()) {\n                return;\n            }\n\n            long now = Utils.getNowMicrosUtc();\n\n            Operation clone = op.clone();\n            clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NOTIFICATION);\n            for (Entry<URI, ServiceSubscriber> e : this.subscriptions.subscribers.entrySet()) {\n                ServiceSubscriber s = e.getValue();\n                notifySubscriber(now, clone, s);\n            }\n\n            if (!performSubscriptionsMaintenance(now)) {\n                return;\n            }\n        } catch (Throwable e) {\n            this.parent.getHost().log(Level.WARNING,\n                    \"Uncaught exception notifying subscribers for %s: %s\",\n                    this.parent.getSelfLink(), Utils.toString(e));\n        }\n    }\n\n    private void notifySubscriber(long now, Operation clone, ServiceSubscriber s) {\n        synchronized (s) {\n            if (s.failedNotificationCount != null) {\n                // indicate to the subscriber that they missed notifications and should retrieve latest state\n                clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS);\n            }\n        }\n\n        CompletionHandler c = (o, ex) -> {\n            s.documentUpdateTimeMicros = Utils.getNowMicrosUtc();\n            synchronized (s) {\n                if (ex != null) {\n                    if (s.failedNotificationCount == null) {\n                        s.failedNotificationCount = 0L;\n                        s.initialFailedNotificationTimeMicros = now;\n                    }\n                    s.failedNotificationCount++;\n                    return;\n                }\n\n                if (s.failedNotificationCount != null) {\n                    // the subscriber is available again.\n                    s.failedNotificationCount = null;\n                    s.initialFailedNotificationTimeMicros = null;\n                }\n            }\n        };\n\n        this.parent.sendRequest(clone.setUri(s.reference).setCompletion(c));\n    }\n\n    private boolean performSubscriptionsMaintenance(long now) {\n        List<URI> subscribersToDelete = null;\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                return false;\n            }\n\n            Iterator<Entry<URI, ServiceSubscriber>> it = this.subscriptions.subscribers.entrySet()\n                    .iterator();\n            while (it.hasNext()) {\n                Entry<URI, ServiceSubscriber> e = it.next();\n                ServiceSubscriber s = e.getValue();\n                boolean remove = false;\n                synchronized (s) {\n                    if (s.documentExpirationTimeMicros != 0 && s.documentExpirationTimeMicros < now) {\n                        remove = true;\n                    } else if (s.notificationLimit != null) {\n                        if (s.notificationCount == null) {\n                            s.notificationCount = 0L;\n                        }\n                        if (++s.notificationCount >= s.notificationLimit) {\n                            remove = true;\n                        }\n                    } else if (s.failedNotificationCount != null\n                            && s.failedNotificationCount > ServiceSubscriber.NOTIFICATION_FAILURE_LIMIT) {\n                        if (now - s.initialFailedNotificationTimeMicros > getHost()\n                                .getMaintenanceIntervalMicros()) {\n                            remove = true;\n                        }\n                    }\n                }\n\n                if (!remove) {\n                    continue;\n                }\n\n                it.remove();\n                if (subscribersToDelete == null) {\n                    subscribersToDelete = new ArrayList<>();\n                }\n                subscribersToDelete.add(s.reference);\n                continue;\n            }\n        }\n\n        if (subscribersToDelete != null) {\n            for (URI subscriber : subscribersToDelete) {\n                this.parent.sendRequest(Operation.createDelete(subscriber));\n            }\n        }\n\n        return true;\n    }\n\n    private void handleUiRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new IllegalArgumentException(\"Action not supported\"));\n            return;\n        }\n\n        if (!this.parent.hasOption(ServiceOption.HTML_USER_INTERFACE)) {\n            String servicePath = UriUtils.buildUriPath(ServiceUriPaths.UI_SERVICE_BASE_URL, op\n                    .getUri().getPath());\n            String defaultHtmlPath = UriUtils.buildUriPath(servicePath.substring(0,\n                    servicePath.length() - ServiceUriPaths.UI_PATH_SUFFIX.length()),\n                    ServiceUriPaths.UI_SERVICE_HOME);\n\n            redirectGetToHtmlUiResource(op, defaultHtmlPath);\n            return;\n        }\n\n        if (this.uiService == null) {\n            this.uiService = new UiContentService() {\n            };\n            this.uiService.setHost(this.parent.getHost());\n        }\n\n        // simulate a full service deployed at the utility endpoint /service/ui\n        String selfLink = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n        this.uiService.handleUiGet(selfLink, this.parent, op);\n    }\n\n    public void redirectGetToHtmlUiResource(Operation op, String htmlResourcePath) {\n        // redirect using relative url without host:port\n        // not so much optimization as handling the case of port forwarding/containers\n        try {\n            op.addResponseHeader(Operation.LOCATION_HEADER,\n                    URLDecoder.decode(htmlResourcePath, Utils.CHARSET));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e);\n        }\n\n        op.setStatusCode(Operation.STATUS_CODE_MOVED_TEMP);\n        op.complete();\n    }\n\n    private void handleStatsRequest(Operation op) {\n        switch (op.getAction()) {\n        case PUT:\n            ServiceStats.ServiceStat stat = op\n                    .getBody(ServiceStats.ServiceStat.class);\n            if (stat.kind == null) {\n                op.fail(new IllegalArgumentException(\"kind is required\"));\n                return;\n            }\n            if (stat.kind.equals(ServiceStats.ServiceStat.KIND)) {\n                if (stat.name == null) {\n                    op.fail(new IllegalArgumentException(\"stat name is required\"));\n                    return;\n                }\n                replaceSingleStat(stat);\n            } else if (stat.kind.equals(ServiceStats.KIND)) {\n                ServiceStats stats = op.getBody(ServiceStats.class);\n                if (stats.entries == null || stats.entries.isEmpty()) {\n                    op.fail(new IllegalArgumentException(\"stats entries need to be defined\"));\n                    return;\n                }\n                replaceAllStats(stats);\n            } else {\n                op.fail(new IllegalArgumentException(\"operation not supported for kind\"));\n                return;\n            }\n            op.complete();\n            break;\n        case POST:\n            ServiceStats.ServiceStat newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // create a stat object if one does not exist\n            ServiceStats.ServiceStat existingStat = this.getStat(newStat.name);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat does not exist\"));\n                return;\n            }\n            initializeOrSetStat(existingStat, newStat);\n            op.complete();\n            break;\n        case DELETE:\n            // TODO support removing stats externally - do we need this?\n            op.fail(new NotActiveException());\n            break;\n        case PATCH:\n            newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // if an existing stat by this name exists, adjust the stat value, else this is a no-op\n            existingStat = this.getStat(newStat.name, false);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat to patch does not exist\"));\n                return;\n            }\n            adjustStat(existingStat, newStat.latestValue);\n            op.complete();\n            break;\n        case GET:\n            if (this.stats == null) {\n                ServiceStats s = new ServiceStats();\n                populateDocumentProperties(s);\n                op.setBody(s).complete();\n            } else {\n                ServiceDocument rsp;\n                synchronized (this.stats) {\n                    rsp = populateDocumentProperties(this.stats);\n                    rsp = Utils.clone(rsp);\n                }\n                op.setBodyNoCloning(rsp);\n                op.complete();\n            }\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n    }\n\n    private ServiceStats populateDocumentProperties(ServiceStats stats) {\n        ServiceStats clone = new ServiceStats();\n        clone.entries = stats.entries;\n        clone.documentUpdateTimeMicros = stats.documentUpdateTimeMicros;\n        clone.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(),\n                ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        clone.documentOwner = getHost().getId();\n        clone.documentKind = Utils.buildKind(ServiceStats.class);\n        return clone;\n    }\n\n    private void handleDocumentTemplateRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new NotActiveException());\n            return;\n        }\n        ServiceDocument template = this.parent.getDocumentTemplate();\n        String serializedTemplate = Utils.toJsonHtml(template);\n        op.setBody(serializedTemplate).complete();\n    }\n\n    @Override\n    public void handleConfigurationRequest(Operation op) {\n        this.parent.handleConfigurationRequest(op);\n    }\n\n    public void handlePatchConfiguration(Operation op, ServiceConfigUpdateRequest updateBody) {\n        if (updateBody == null) {\n            updateBody = op.getBody(ServiceConfigUpdateRequest.class);\n        }\n\n        if (!ServiceConfigUpdateRequest.KIND.equals(updateBody.kind)) {\n            op.fail(new IllegalArgumentException(\"Unrecognized kind: \" + updateBody.kind));\n            return;\n        }\n\n        if (updateBody.maintenanceIntervalMicros == null\n                && updateBody.operationQueueLimit == null\n                && updateBody.epoch == null\n                && (updateBody.addOptions == null || updateBody.addOptions.isEmpty())\n                && (updateBody.removeOptions == null || updateBody.removeOptions\n                        .isEmpty())) {\n            op.fail(new IllegalArgumentException(\n                    \"At least one configuraton field must be specified\"));\n            return;\n        }\n\n        // service might fail a capability toggle if the capability can not be changed after start\n        if (updateBody.addOptions != null) {\n            for (ServiceOption c : updateBody.addOptions) {\n                this.parent.toggleOption(c, true);\n            }\n        }\n\n        if (updateBody.removeOptions != null) {\n            for (ServiceOption c : updateBody.removeOptions) {\n                this.parent.toggleOption(c, false);\n            }\n        }\n\n        if (updateBody.maintenanceIntervalMicros != null) {\n            this.parent.setMaintenanceIntervalMicros(updateBody.maintenanceIntervalMicros);\n        }\n\n        op.complete();\n    }\n\n    private void initializeOrSetStat(ServiceStat stat, ServiceStat newValue) {\n        synchronized (stat) {\n            if (stat.timeSeriesStats == null && newValue.timeSeriesStats != null) {\n                stat.timeSeriesStats = new TimeSeriesStats(newValue.timeSeriesStats.numBins,\n                        newValue.timeSeriesStats.binDurationMillis, newValue.timeSeriesStats.aggregationType);\n            }\n            stat.unit = newValue.unit;\n            stat.sourceTimeMicrosUtc = newValue.sourceTimeMicrosUtc;\n            setStat(stat, newValue.latestValue);\n        }\n    }\n\n    @Override\n    public void setStat(ServiceStat stat, double newValue) {\n        allocateStats();\n        findStat(stat.name, true, stat);\n\n        synchronized (stat) {\n            stat.version++;\n            stat.accumulatedValue += newValue;\n            stat.latestValue = newValue;\n            if (stat.logHistogram != null) {\n                int binIndex = 0;\n                if (newValue > 0.0) {\n                    binIndex = (int) Math.log10(newValue);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, newValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, newValue);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void adjustStat(ServiceStat stat, double delta) {\n        allocateStats();\n        synchronized (stat) {\n            stat.latestValue += delta;\n            stat.version++;\n            if (stat.logHistogram != null) {\n\n                int binIndex = 0;\n                if (delta > 0.0) {\n                    binIndex = (int) Math.log10(delta);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, stat.latestValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, stat.latestValue);\n                }\n            }\n        }\n    }\n\n    @Override\n    public ServiceStat getStat(String name) {\n        return getStat(name, true);\n    }\n\n    private ServiceStat getStat(String name, boolean create) {\n        if (!allocateStats(true)) {\n            return null;\n        }\n        return findStat(name, create, null);\n    }\n\n    private void replaceSingleStat(ServiceStat stat) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // create a new stat with the default values\n            ServiceStat newStat = new ServiceStat();\n            newStat.name = stat.name;\n            initializeOrSetStat(newStat, stat);\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            // add it to the list of stats for this service\n            this.stats.entries.put(stat.name, newStat);\n        }\n    }\n\n    private void replaceAllStats(ServiceStats newStats) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // reset the current set of stats\n            this.stats.entries.clear();\n            for (ServiceStats.ServiceStat currentStat : newStats.entries.values()) {\n                replaceSingleStat(currentStat);\n            }\n\n        }\n    }\n\n    private ServiceStat findStat(String name, boolean create, ServiceStat initialStat) {\n        synchronized (this.stats) {\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            ServiceStat st = this.stats.entries.get(name);\n            if (st == null && create) {\n                st = initialStat != null ? initialStat : new ServiceStat();\n                st.name = name;\n                this.stats.entries.put(name, st);\n            }\n            return st;\n        }\n    }\n\n    private void allocateStats() {\n        allocateStats(true);\n    }\n\n    private synchronized boolean allocateStats(boolean mustAllocate) {\n        if (!mustAllocate && this.stats == null) {\n            return false;\n        }\n        if (this.stats != null) {\n            return true;\n        }\n        this.stats = new ServiceStats();\n        return true;\n    }\n\n    @Override\n    public ServiceHost getHost() {\n        return this.parent.getHost();\n    }\n\n    @Override\n    public String getSelfLink() {\n        return null;\n    }\n\n    @Override\n    public URI getUri() {\n        return null;\n    }\n\n    @Override\n    public OperationProcessingChain getOperationProcessingChain() {\n        return null;\n    }\n\n    @Override\n    public ProcessingStage getProcessingStage() {\n        return ProcessingStage.AVAILABLE;\n    }\n\n    @Override\n    public EnumSet<ServiceOption> getOptions() {\n        return EnumSet.of(ServiceOption.UTILITY);\n    }\n\n    @Override\n    public boolean hasOption(ServiceOption cap) {\n        return false;\n    }\n\n    @Override\n    public void toggleOption(ServiceOption cap, boolean enable) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public void adjustStat(String name, double delta) {\n        return;\n    }\n\n    @Override\n    public void setStat(String name, double newValue) {\n        return;\n    }\n\n    @Override\n    public void handleMaintenance(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void setHost(ServiceHost serviceHost) {\n\n    }\n\n    @Override\n    public void setSelfLink(String path) {\n\n    }\n\n    @Override\n    public void setOperationProcessingChain(OperationProcessingChain opProcessingChain) {\n\n    }\n\n    @Override\n    public ServiceRuntimeContext setProcessingStage(ProcessingStage initialized) {\n        return null;\n    }\n\n    @Override\n    public ServiceDocument setInitialState(Object state, Long initialVersion) {\n        return null;\n    }\n\n    @Override\n    public Service getUtilityService(String uriPath) {\n        return null;\n    }\n\n    @Override\n    public boolean queueRequest(Operation op) {\n        return false;\n    }\n\n    @Override\n    public void sendRequest(Operation op) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public ServiceDocument getDocumentTemplate() {\n        return null;\n    }\n\n    @Override\n    public void setPeerNodeSelectorPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getPeerNodeSelectorPath() {\n        return null;\n    }\n\n    @Override\n    public void setState(Operation op, ServiceDocument newState) {\n        op.linkState(newState);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends ServiceDocument> T getState(Operation op) {\n        return (T) op.getLinkedState();\n    }\n\n    @Override\n    public void setMaintenanceIntervalMicros(long micros) {\n        throw new RuntimeException(\"not implemented\");\n    }\n\n    @Override\n    public long getMaintenanceIntervalMicros() {\n        return 0;\n    }\n\n    @Override\n    public Operation dequeueRequest() {\n        return null;\n    }\n\n    @Override\n    public Class<? extends ServiceDocument> getStateType() {\n        return null;\n    }\n\n    @Override\n    public final void setAuthorizationContext(Operation op, AuthorizationContext ctx) {\n        throw new RuntimeException(\"Service not allowed to set authorization context\");\n    }\n\n    @Override\n    public final AuthorizationContext getSystemAuthorizationContext() {\n        throw new RuntimeException(\"Service not allowed to get system authorization context\");\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.security.GeneralSecurityException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.test.AuthorizationHelper;\nimport com.vmware.xenon.common.test.QueryTestUtils;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationCacheUtils;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.GuestUserService;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.SystemUserService;\nimport com.vmware.xenon.services.common.UserGroupService;\nimport com.vmware.xenon.services.common.UserGroupService.UserGroupState;\nimport com.vmware.xenon.services.common.UserService.UserState;\n\npublic class TestAuthorization extends BasicTestCase {\n\n    public static class AuthzStatelessService extends StatelessService {\n        public void handleRequest(Operation op) {\n            if (op.getAction() == Action.PATCH) {\n                op.complete();\n                return;\n            }\n            super.handleRequest(op);\n        }\n    }\n\n    public int serviceCount = 10;\n\n    private String userServicePath;\n    private AuthorizationHelper authHelper;\n\n    @Override\n    public void beforeHostStart(VerificationHost host) {\n        // Enable authorization service; this is an end to end test\n        host.setAuthorizationService(new AuthorizationContextService());\n        host.setAuthorizationEnabled(true);\n        CommandLineArgumentParser.parseFromProperties(this);\n    }\n\n    @Before\n    public void enableTracing() throws Throwable {\n        // Enable operation tracing to verify tracing does not error out with auth enabled.\n        this.host.toggleOperationTracing(this.host.getUri(), true);\n    }\n\n    @After\n    public void disableTracing() throws Throwable {\n        this.host.toggleOperationTracing(this.host.getUri(), false);\n    }\n\n    @Before\n    public void setupRoles() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        this.authHelper = new AuthorizationHelper(this.host);\n        this.userServicePath = this.authHelper.createUserService(this.host, \"jane@doe.com\");\n        this.authHelper.createRoles(this.host, \"jane@doe.com\");\n        this.host.resetAuthorizationContext();\n    }\n\n    @Test\n    public void statelessServiceAuthorization() throws Throwable {\n        // assume system identity so we can create roles\n        this.host.setSystemAuthorizationContext();\n\n        String serviceLink = UUID.randomUUID().toString();\n\n        // create a specific role for a stateless service\n        String resourceGroupLink = this.authHelper.createResourceGroup(this.host,\n                \"stateless-service-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                UriUtils.URI_PATH_CHAR + serviceLink)\n                        .build());\n        this.authHelper.createRole(this.host, this.authHelper.getUserGroupLink(),\n                resourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE)));\n        this.host.resetAuthorizationContext();\n\n        CompletionHandler ch = (o, e) -> {\n            if (e == null || o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                this.host.failIteration(new IllegalStateException(\n                        \"Operation did not fail with proper status code\"));\n                return;\n            }\n            this.host.completeIteration();\n        };\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // Verify startService\n        Operation post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // stop service so we can attempt restart\n        this.host.testStart(1);\n        Operation delete = Operation.createDelete(post.getUri())\n                .setCompletion(this.host.getCompletion());\n        this.host.send(delete);\n        this.host.testWait();\n\n        // Verify DENY startService\n        this.host.resetAuthorizationContext();\n        this.host.testStart(1);\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        post.setCompletion(ch);\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // restart service\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // Verify PATCH\n        Operation patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(this.host.getCompletion());\n        this.host.send(patch);\n        this.host.testWait();\n\n        // Verify DENY PATCH\n        this.host.resetAuthorizationContext();\n        patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(ch);\n        this.host.send(patch);\n        this.host.testWait();\n    }\n\n    @Test\n    public void queryTasksDirectAndContinuous() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n        createExampleServices(\"jane\");\n\n        // do a direct, simple query first\n        this.host.createAndWaitSimpleDirectQuery(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                this.userServicePath, this.serviceCount, this.serviceCount);\n\n        // now do a paginated query to verify we can get to paged results with authz enabled\n        QueryTask qt = QueryTask.Builder.create().setResultLimit(this.serviceCount / 2)\n                .build();\n        qt.querySpec.query = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                        this.userServicePath)\n                .build();\n\n        URI taskUri = this.host.createQueryTaskService(qt);\n        this.host.waitFor(\"task not finished in time\", () -> {\n            QueryTask r = this.host.getServiceState(null, QueryTask.class, taskUri);\n            if (TaskState.isFailed(r.taskInfo)) {\n                throw new IllegalStateException(\"task failed\");\n            }\n            if (TaskState.isFinished(r.taskInfo)) {\n                qt.taskInfo = r.taskInfo;\n                qt.results = r.results;\n                return true;\n            }\n            return false;\n        });\n\n\n        TestContext ctx = this.host.testCreate(1);\n        Operation get = Operation.createGet(UriUtils.buildUri(this.host, qt.results.nextPageLink))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(get);\n        ctx.await();\n\n        TestContext kryoCtx = this.host.testCreate(1);\n        Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                .setBody(new ServiceDocument())\n                .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                .setCompletion((o, e) -> {\n                    if (e != null && o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED) {\n                        kryoCtx.completeIteration();\n                        return;\n                    }\n                    kryoCtx.failIteration(new IllegalStateException(\"expected a failure\"));\n                });\n        this.host.send(patchOp);\n        kryoCtx.await();\n\n        int requestCount = this.serviceCount;\n        TestContext notifyCtx = this.testCreate(requestCount);\n\n        Consumer<Operation> notify = (o) -> {\n            o.complete();\n            String subject = o.getAuthorizationContext().getClaims().getSubject();\n            if (!this.userServicePath.equals(subject)) {\n                notifyCtx.fail(new IllegalStateException(\n                        \"Invalid aith subject in notification: \" + subject));\n                return;\n            }\n            this.host.log(\"Received authorized notification for index patch: %s\", o.toString());\n            notifyCtx.complete();\n        };\n\n        Query q = Query.Builder.create()\n                .addKindFieldClause(ExampleServiceState.class)\n                .build();\n        QueryTask cqt = QueryTask.Builder.create().setQuery(q).build();\n\n        // do a continuous query, verify we receive some notifications\n        URI notifyURI = QueryTestUtils.startAndSubscribeToContinuousQuery(\n                this.host.getTestRequestSender(), this.host, cqt,\n                notify);\n\n        // issue updates, create some services\n        createExampleServices(\"jane\");\n        this.host.log(\"Waiting on continiuous query task notifications (%d)\", requestCount);\n        notifyCtx.await();\n\n        QueryTestUtils.stopContinuousQuerySubscription(\n                this.host.getTestRequestSender(), this.host, notifyURI,\n                cqt);\n\n    }\n\n    @Test\n    public void validateKryoOctetStreamRequests() throws Throwable {\n        Consumer<Boolean> validate = (expectUnauthorizedResponse) -> {\n            TestContext kryoCtx = this.host.testCreate(1);\n            Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                    .setBody(new ServiceDocument())\n                    .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                    .setCompletion((o, e) -> {\n                        boolean isUnauthorizedResponse = o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED;\n                        if (expectUnauthorizedResponse == isUnauthorizedResponse) {\n                            kryoCtx.completeIteration();\n                            return;\n                        }\n                        kryoCtx.failIteration(new IllegalStateException(\"Response did not match expectation\"));\n                    });\n            this.host.send(patchOp);\n            kryoCtx.await();\n        };\n\n        // Validate GUEST users are not authorized for sending kryo-octet-stream requests.\n        this.host.resetAuthorizationContext();\n        validate.accept(true);\n\n        // Validate non-Guest, non-System users are also not authorized.\n        this.host.assumeIdentity(this.userServicePath);\n        validate.accept(true);\n\n        // Validate System users are allowed.\n        this.host.assumeIdentity(SystemUserService.SELF_LINK);\n        validate.accept(false);\n    }\n\n    @Test\n    public void contextPropagationOnScheduleAndRunContext() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n\n        AuthorizationContext callerAuthContext = OperationContext.getAuthorizationContext();\n        Runnable task = () -> {\n            if (OperationContext.getAuthorizationContext().equals(callerAuthContext)) {\n                this.host.completeIteration();\n                return;\n            }\n            this.host.failIteration(new IllegalStateException(\"Incorrect auth context obtained\"));\n        };\n\n        this.host.testStart(1);\n        this.host.schedule(task, 1, TimeUnit.MILLISECONDS);\n        this.host.testWait();\n\n        this.host.testStart(1);\n        this.host.run(task);\n        this.host.testWait();\n    }\n\n    @Test\n    public void guestAuthorization() throws Throwable {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n\n        // Create user group for guest user\n        String userGroupLink =\n                this.authHelper.createUserGroup(this.host, \"guest-user-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                GuestUserService.SELF_LINK)\n                        .build());\n\n        // Create resource group for example service state\n        String exampleServiceResourceGroupLink =\n                this.authHelper.createResourceGroup(this.host, \"guest-resource-group\", Builder.create()\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_KIND,\n                                Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_NAME,\n                                \"guest\")\n                        .build());\n\n        // Create roles tying these together\n        this.authHelper.createRole(this.host, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH)));\n\n        // Create some example services; some accessible, some not\n        Map<URI, ExampleServiceState> exampleServices = new HashMap<>();\n        exampleServices.putAll(createExampleServices(\"jane\"));\n        exampleServices.putAll(createExampleServices(\"guest\"));\n\n        OperationContext.setAuthorizationContext(null);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n        Operation responseOp = sender.sendAndWait(Operation.createGet(this.host, ExampleService.FACTORY_LINK));\n\n        // Make sure only the authorized services were returned\n        ServiceDocumentQueryResult getResult = responseOp.getBody(ServiceDocumentQueryResult.class);\n        assertAuthorizedServicesInResult(\"guest\", exampleServices, getResult);\n        String guestLink = getResult.documentLinks.iterator().next();\n\n        // Make sure we are able to PATCH the example service.\n        ExampleServiceState state = new ExampleServiceState();\n        state.counter = 2L;\n        responseOp = sender.sendAndWait(Operation.createPatch(this.host, guestLink).setBody(state));\n        assertEquals(Operation.STATUS_CODE_OK, responseOp.getStatusCode());\n\n        // Let's try to do another PATCH using kryo-octet-stream\n        state.counter = 3L;\n        FailureResponse failureResponse = sender.sendAndWaitFailure(\n                Operation.createPatch(this.host, guestLink)\n                        .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                        .forceRemote()\n                        .setBody(state));\n        assertEquals(Operation.STATUS_CODE_UNAUTHORIZED, failureResponse.op.getStatusCode());\n\n    }\n\n    @Test\n    public void actionBasedAuthorization() throws Throwable {\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // add docs accessible by jane\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"jane\");\n\n        // Execute get on factory trying to get all example services\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    this.host.completeIteration();\n                });\n\n        this.host.testStart(1);\n        this.host.send(getFactory);\n        this.host.testWait();\n\n        // DELETE operation should be denied\n        Set<String> selfLinks = new HashSet<>(factoryGetResult[0].documentLinks);\n        for (String selfLink : selfLinks) {\n            Operation deleteOperation =\n                    Operation.createDelete(UriUtils.buildUri(this.host, selfLink))\n                            .setCompletion((o, e) -> {\n                                if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                    String message = String.format(\"Expected %d, got %s\",\n                                            Operation.STATUS_CODE_FORBIDDEN,\n                                            o.getStatusCode());\n                                    this.host.failIteration(new IllegalStateException(message));\n                                    return;\n                                }\n\n                                this.host.completeIteration();\n                            });\n            this.host.testStart(1);\n            this.host.send(deleteOperation);\n            this.host.testWait();\n        }\n\n        // PATCH operation should be allowed\n        for (String selfLink : selfLinks) {\n            Operation patchOperation =\n                    Operation.createPatch(UriUtils.buildUri(this.host, selfLink))\n                        .setBody(exampleServices.get(selfLink))\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_OK,\n                                        o.getStatusCode());\n                                this.host.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            this.host.completeIteration();\n                        });\n            this.host.testStart(1);\n            this.host.send(patchOperation);\n            this.host.testWait();\n        }\n    }\n\n    @Test\n    public void statefulServiceAuthorization() throws Throwable {\n        // Create example services not accessible by jane (as the system user)\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"john\");\n\n        // try to create services with no user context set; we should get a 403\n        OperationContext.setAuthorizationContext(null);\n        ExampleServiceState state = createExampleServiceState(\"jane\", new Long(\"100\"));\n        this.host.testStart(1);\n        this.host.send(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(state)\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_FORBIDDEN,\n                                        o.getStatusCode());\n                                this.host.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            this.host.completeIteration();\n                        }));\n        this.host.testWait();\n\n        // issue a GET on a factory with no auth context, no documents should be returned\n        this.host.testStart(1);\n        this.host.send(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(new IllegalStateException(e));\n                        return;\n                    }\n                    ServiceDocumentQueryResult res = o\n                            .getBody(ServiceDocumentQueryResult.class);\n                    if (!res.documentLinks.isEmpty()) {\n                        String message = String.format(\"Expected 0 results; Got %d\",\n                                res.documentLinks.size());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    this.host.completeIteration();\n                }));\n        this.host.testWait();\n\n        // do GET on factory /stats, we should get 403\n        Operation statsGet = Operation.createGet(this.host,\n                ExampleService.FACTORY_LINK + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        this.host.sendAndWaitExpectFailure(statsGet, Operation.STATUS_CODE_FORBIDDEN);\n\n        // do GET on factory /config, we should get 403\n        Operation configGet = Operation.createGet(this.host,\n                ExampleService.FACTORY_LINK + ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n        this.host.sendAndWaitExpectFailure(configGet, Operation.STATUS_CODE_FORBIDDEN);\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n        // add docs accessible by jane\n        exampleServices.putAll(createExampleServices(\"jane\"));\n\n        verifyJaneAccess(exampleServices, null);\n\n        // Execute get on factory trying to get all example services\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    this.host.completeIteration();\n                });\n\n        this.host.testStart(1);\n        this.host.send(getFactory);\n        this.host.testWait();\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, factoryGetResult[0]);\n\n        // Execute query task trying to get all example services\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND)\n                .setTermMatchValue(Utils.buildKind(ExampleServiceState.class));\n        URI u = this.host.createQueryTaskService(QueryTask.create(q));\n        QueryTask task = this.host.waitForQueryTaskCompletion(q, 1, 1, u, false, true, false);\n        assertEquals(TaskState.TaskStage.FINISHED, task.taskInfo.stage);\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, task.results);\n\n        // reset the auth context\n        OperationContext.setAuthorizationContext(null);\n\n        // do GET on utility suffixes in example child services, we should get 403\n        for (URI childUri : exampleServices.keySet()) {\n            statsGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n            this.host.sendAndWaitExpectFailure(statsGet, Operation.STATUS_CODE_FORBIDDEN);\n            configGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n            this.host.sendAndWaitExpectFailure(configGet, Operation.STATUS_CODE_FORBIDDEN);\n        }\n\n        // Assume Jane's identity through header auth token\n        String authToken = generateAuthToken(this.userServicePath);\n\n        // do GET on utility suffixes in example child services, we should get 200\n        for (URI childUri : exampleServices.keySet()) {\n            statsGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n            statsGet.addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken);\n            this.host.sendAndWaitExpectSuccess(statsGet);\n        }\n\n        verifyJaneAccess(exampleServices, authToken);\n    }\n\n    private AuthorizationContext assumeIdentityAndGetContext(String userLink,\n            Service privilegedService, boolean populateCache) throws Throwable {\n        AuthorizationContext authContext = this.host.assumeIdentity(userLink);\n        if (populateCache) {\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        }\n        return this.host.getAuthorizationContext(privilegedService, authContext.getToken());\n    }\n\n    @Test\n    public void authCacheClearToken() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        AuthorizationContext authContext1 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        AuthorizationContext authContext2 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        assertNotNull(authContext1);\n        assertNotNull(authContext2);\n\n        this.host.setSystemAuthorizationContext();\n        Operation clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n\n        assertNull(this.host.getAuthorizationContext(s, authContext1.getToken()));\n        assertNull(this.host.getAuthorizationContext(s, authContext2.getToken()));\n    }\n\n    @Test\n    public void updateAuthzCache() throws Throwable {\n        ExecutorService executor = null;\n        try {\n            this.host.setSystemAuthorizationContext();\n            AuthorizationHelper authsetupHelper = new AuthorizationHelper(this.host);\n            String email = \"foo@foo.com\";\n            String userLink = authsetupHelper.createUserService(this.host, email);\n            Query userGroupQuery = Query.Builder.create().addFieldClause(UserState.FIELD_NAME_EMAIL, email).build();\n            String userGroupLink = authsetupHelper.createUserGroup(this.host, email, userGroupQuery);\n            UserState patchState = new UserState();\n            patchState.userGroupLinks = Collections.singleton(userGroupLink);\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createPatch(UriUtils.buildUri(this.host, userLink))\n                    .setBody(patchState));\n            TestContext ctx = this.host.testCreate(this.serviceCount);\n            Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                    .toString());\n            executor = this.host.allocateExecutor(s);\n            this.host.resetSystemAuthorizationContext();\n            for (int i = 0; i < this.serviceCount; i++) {\n                this.host.run(executor, () -> {\n                    String serviceName = UUID.randomUUID().toString();\n                    try {\n                        this.host.setSystemAuthorizationContext();\n                        Query resourceQuery = Query.Builder.create().addFieldClause(ExampleServiceState.FIELD_NAME_NAME,\n                                serviceName).build();\n                        String resourceGroupLink = authsetupHelper.createResourceGroup(this.host, serviceName, resourceQuery);\n                        authsetupHelper.createRole(this.host, userGroupLink, resourceGroupLink, EnumSet.allOf(Action.class));\n                        this.host.resetSystemAuthorizationContext();\n                        this.host.assumeIdentity(userLink);\n                        ExampleServiceState exampleState = new ExampleServiceState();\n                        exampleState.name = serviceName;\n                        exampleState.documentSelfLink = serviceName;\n                        // Issue: https://www.pivotaltracker.com/story/show/131520613\n                        // We have a potential race condition in the code where the role\n                        // created above is not being reflected in the auth context for\n                        // the user; We are retrying the operation to mitigate the issue\n                        // till we have a fix for the issue\n                        for (int retryCounter = 0; retryCounter < 3; retryCounter++) {\n                            try {\n                                this.host.sendAndWaitExpectSuccess(\n                                        Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                                        .setBody(exampleState));\n                                break;\n                            } catch (Throwable t) {\n                                this.host.log(Level.WARNING, \"Error creating example service: \" + t.getMessage());\n                                if (retryCounter == 2) {\n                                    ctx.fail(new IllegalStateException(\"Example service creation failed thrice\"));\n                                    return;\n                                }\n                            }\n                        }\n                        this.host.sendAndWaitExpectSuccess(\n                                Operation.createDelete(UriUtils.buildUri(this.host,\n                                        UriUtils.buildUriPath(ExampleService.FACTORY_LINK, serviceName))));\n                        ctx.complete();\n                    } catch (Throwable e) {\n                        this.host.log(Level.WARNING, e.getMessage());\n                        ctx.fail(e);\n                    }\n                });\n            }\n            this.host.testWait(ctx);\n        } finally {\n            if (executor != null) {\n                executor.shutdown();\n            }\n        }\n    }\n\n    @Test\n    public void testAuthzUtils() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        UserState patchState = new UserState();\n        patchState.userGroupLinks = new HashSet<String>();\n        patchState.userGroupLinks.add(UriUtils.buildUriPath(\n                UserGroupService.FACTORY_LINK, authHelperForFoo.getUserGroupName(email)));\n        authHelperForFoo.patchUserService(this.host, fooUserLink, patchState);\n        // create a user group based on a query for userGroupLink\n        authHelperForFoo.createRoles(this.host, email, true);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        String userGroupLink = authHelperForFoo.getUserGroupLink();\n        String resourceGroupLink = authHelperForFoo.getResourceGroupLink();\n        String roleLink = authHelperForFoo.getRoleLink();\n\n\n        // get the user group service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getUserGroupStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, userGroupLink));\n        Operation resultOp = this.host.waitForResponse(getUserGroupStateOp);\n        UserGroupState userGroupState = resultOp.getBody(UserGroupState.class);\n        Operation clearAuthOp = new Operation();\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUserGroup(s, clearAuthOp, userGroupState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the resource group and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, resourceGroupLink));\n        AuthorizationCacheUtils.clearAuthzCacheForResourceGroup(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the role service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getRoleStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, roleLink));\n        resultOp = this.host.waitForResponse(getRoleStateOp);\n        RoleState roleState = resultOp.getBody(RoleState.class);\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForRole(s, clearAuthOp, roleState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // finally, get the user service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n    }\n\n    private void verifyJaneAccess(Map<URI, ExampleServiceState> exampleServices, String authToken) throws Throwable {\n        // Try to GET all example services\n        this.host.testStart(exampleServices.size());\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            Operation get = Operation.createGet(entry.getKey());\n            // force to create a remote context\n            if (authToken != null) {\n                get.forceRemote();\n                get.getRequestHeaders().put(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken);\n            }\n            if (entry.getValue().name.equals(\"jane\")) {\n                // Expect 200 OK\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_OK,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    ExampleServiceState body = o.getBody(ExampleServiceState.class);\n                    if (!body.documentAuthPrincipalLink.equals(this.userServicePath)) {\n                        String message = String.format(\"Expected %s, got %s\",\n                                this.userServicePath, body.documentAuthPrincipalLink);\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    this.host.completeIteration();\n                });\n            } else {\n                // Expect 403 Forbidden\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_FORBIDDEN,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    this.host.completeIteration();\n                });\n            }\n\n            this.host.send(get);\n        }\n        this.host.testWait();\n    }\n\n    private void assertAuthorizedServicesInResult(String name,\n            Map<URI, ExampleServiceState> exampleServices,\n            ServiceDocumentQueryResult result) {\n        Set<String> selfLinks = new HashSet<>(result.documentLinks);\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            String selfLink = entry.getKey().getPath();\n            if (entry.getValue().name.equals(name)) {\n                assertTrue(selfLinks.contains(selfLink));\n            } else {\n                assertFalse(selfLinks.contains(selfLink));\n            }\n        }\n    }\n\n    private String generateAuthToken(String userServicePath) throws GeneralSecurityException {\n        Claims.Builder builder = new Claims.Builder();\n        builder.setSubject(userServicePath);\n        Claims claims = builder.getResult();\n        return this.host.getTokenSigner().sign(claims);\n    }\n\n    private ExampleServiceState createExampleServiceState(String name, Long counter) {\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = name;\n        state.counter = counter;\n        state.documentAuthPrincipalLink = \"stringtooverwrite\";\n        return state;\n    }\n\n    private Map<URI, ExampleServiceState> createExampleServices(String userName) throws Throwable {\n        Collection<ExampleServiceState> bodies = new LinkedList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            bodies.add(createExampleServiceState(userName, 1L));\n        }\n\n        Iterator<ExampleServiceState> it = bodies.iterator();\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(it.next());\n        };\n\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                bodies.size(),\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n\n        return states;\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport static com.vmware.xenon.services.common.authn.BasicAuthenticationUtils.constructBasicAuth;\n\nimport java.net.URI;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UserService;\nimport com.vmware.xenon.services.common.authn.AuthenticationRequest;\nimport com.vmware.xenon.services.common.authn.BasicAuthenticationService;\n\npublic class TestExampleServiceHost extends BasicReusableHostTestCase {\n\n    private static final String adminUser = \"admin@localhost\";\n    private static final String exampleUser = \"example@localhost\";\n\n    /**\n     * Verify that the example service host creates users as expected.\n     *\n     * In theory we could test that authentication and authorization works correctly\n     * for these users. It's not critical to do here since we already test it in\n     * TestAuthSetupHelper.\n     */\n    @Test\n    public void createUsers() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        TemporaryFolder tmpFolder = new TemporaryFolder();\n        tmpFolder.create();\n        try {\n            String bindAddress = \"127.0.0.1\";\n\n            String[] args = {\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--isAuthorizationEnabled=\" + Boolean.TRUE.toString(),\n                    \"--adminUser=\" + adminUser,\n                    \"--adminUserPassword=\" + adminUser,\n                    \"--exampleUser=\" + exampleUser,\n                    \"--exampleUserPassword=\" + exampleUser,\n            };\n\n            h.initialize(args);\n            h.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n            h.start();\n\n            URI hostUri = h.getUri();\n            String authToken = loginUser(hostUri);\n            waitForUsers(hostUri, authToken);\n\n        } finally {\n            h.stop();\n            tmpFolder.delete();\n        }\n    }\n\n    /**\n     * Supports createUsers() by logging in as the admin. The admin user\n     * isn't created immediately, so this polls.\n     */\n    private String loginUser(URI hostUri) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        // wait for factory availability\n        this.host.setSystemAuthorizationContext();\n        this.host.waitForReplicatedFactoryServiceAvailable(usersLink);\n        this.host.resetAuthorizationContext();\n\n        String basicAuth = constructBasicAuth(adminUser, adminUser);\n        URI loginUri = UriUtils.buildUri(hostUri, ServiceUriPaths.CORE_AUTHN_BASIC);\n        AuthenticationRequest login = new AuthenticationRequest();\n        login.requestType = AuthenticationRequest.AuthenticationRequestType.LOGIN;\n\n        String[] authToken = new String[1];\n        authToken[0] = null;\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            Operation loginPost = Operation.createPost(loginUri)\n                    .setBody(login)\n                    .addRequestHeader(BasicAuthenticationService.AUTHORIZATION_HEADER_NAME,\n                            basicAuth)\n                    .forceRemote()\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            this.host.completeIteration();\n                            return;\n                        }\n                        authToken[0] = op.getResponseHeader(Operation.REQUEST_AUTH_TOKEN_HEADER);\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(loginPost);\n            this.host.testWait();\n\n            if (authToken[0] != null) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n\n        if (new Date().after(exp)) {\n            throw new TimeoutException();\n        }\n\n        assertNotNull(authToken[0]);\n\n        return authToken[0];\n    }\n\n    /**\n     * Supports createUsers() by waiting for two users to be created. They aren't created immediately,\n     * so this polls.\n     */\n    private void waitForUsers(URI hostUri, String authToken) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        Integer[] numberUsers = new Integer[1];\n        for (int i = 0; i < 20; i++) {\n            Operation get = Operation.createGet(usersLink)\n                    .forceRemote()\n                    .addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken)\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            if (op.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                this.host.failIteration(ex);\n                                return;\n                            } else {\n                                numberUsers[0] = 0;\n                                this.host.completeIteration();\n                                return;\n                            }\n                        }\n                        ServiceDocumentQueryResult response = op\n                                .getBody(ServiceDocumentQueryResult.class);\n                        assertTrue(response != null && response.documentLinks != null);\n                        numberUsers[0] = response.documentLinks.size();\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(get);\n            this.host.testWait();\n\n            if (numberUsers[0] == 2) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n        assertTrue(numberUsers[0] == 2);\n    }\n\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport java.net.URI;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.junit.After;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.common.http.netty.NettyHttpServiceClient;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\n\n\npublic class TestSubscriptions extends BasicTestCase {\n    private final int NODE_COUNT = 2;\n\n    public int serviceCount = 100;\n    public long updateCount = 10;\n    public long iterationCount = 0;\n\n    public void beforeHostStart(VerificationHost host) {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n    }\n\n    @After\n    public void tearDown() {\n        this.host.tearDown();\n        this.host.tearDownInProcessPeers();\n    }\n\n    private void setUpPeers() throws Throwable {\n        this.host.setUpPeerHosts(this.NODE_COUNT);\n        this.host.joinNodesAndVerifyConvergence(this.NODE_COUNT);\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptionsLoop() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            tearDown();\n            this.host = createHost();\n            initializeHost(this.host);\n            beforeHostStart(this.host);\n            this.host.start();\n            remoteAndReliableSubscriptions();\n        }\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptions() throws Throwable {\n        setUpPeers();\n\n        // pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n        URI factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        // test host to receive notifications\n        VerificationHost localHost = this.host;\n        int serviceCount = 1;\n        List<URI> exampleURIs = new ArrayList<>();\n        // create example service documents across all nodes\n        serviceHost.createExampleServices(serviceHost, serviceCount, exampleURIs, null);\n        TestContext oneUseNotificationCtx = this.host.testCreate(1);\n        StatelessService notificationTarget = new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                update.complete();\n                if (update.getAction().equals(Action.PATCH)) {\n                    if (update.getUri().getHost() == null) {\n                        oneUseNotificationCtx.fail(new IllegalStateException(\n                                \"Notification URI does not have host specified\"));\n                        return;\n                    }\n                    oneUseNotificationCtx.complete();\n                }\n            }\n        };\n\n        String[] ownerHostId = new String[1];\n        URI uri = exampleURIs.get(0);\n        URI subUri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n        TestContext subscribeCtx = this.host.testCreate(1);\n        Operation subscribe = Operation.createPost(subUri)\n                .setCompletion(subscribeCtx.getCompletion());\n        subscribe.setReferer(localHost.getReferer());\n        subscribe.forceRemote();\n        // replay state\n        serviceHost.startSubscriptionService(subscribe, notificationTarget, ServiceSubscriber\n                .create(false).setUsePublicUri(true));\n        this.host.testWait(subscribeCtx);\n\n        // do an update to cause a notification\n        TestContext updateCtx = this.host.testCreate(1);\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body).setCompletion((o, e) -> {\n            if (e != null) {\n                updateCtx.fail(e);\n                return;\n            }\n            ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n            ownerHostId[0] = rsp.documentOwner;\n            updateCtx.complete();\n\n        }));\n        this.host.testWait(updateCtx);\n        this.host.testWait(oneUseNotificationCtx);\n\n        // remove subscription\n        TestContext unSubscribeCtx = this.host.testCreate(1);\n        Operation unSubscribe = subscribe.clone()\n                .setCompletion(unSubscribeCtx.getCompletion())\n                .setAction(Action.DELETE);\n        serviceHost.stopSubscriptionService(unSubscribe,\n                notificationTarget.getUri());\n        this.host.testWait(unSubscribeCtx);\n        this.verifySubscriberCount(new URI[] { uri }, 0);\n\n        VerificationHost ownerHost = null;\n        // find the host that owns the example service and make sure we subscribe from the OTHER\n        // host (since we will stop the current owner)\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            if (!h.getId().equals(ownerHostId[0])) {\n                serviceHost = h;\n            } else {\n                ownerHost = h;\n            }\n        }\n\n        this.host.log(\"Owner node: %s, subscriber node: %s (%s)\", ownerHostId[0],\n                serviceHost.getId(), serviceHost.getUri());\n\n        AtomicInteger reliableNotificationCount = new AtomicInteger();\n        TestContext subscribeCtxNonOwner = this.host.testCreate(1);\n        // subscribe using non owner host\n        subscribe.setCompletion(subscribeCtxNonOwner.getCompletion());\n        serviceHost.startReliableSubscriptionService(subscribe, (o) -> {\n            reliableNotificationCount.incrementAndGet();\n            o.complete();\n        });\n        localHost.testWait(subscribeCtxNonOwner);\n\n        // send explicit update to example service\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body));\n\n        while (reliableNotificationCount.get() < 1) {\n            Thread.sleep(100);\n        }\n\n        reliableNotificationCount.set(0);\n\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // Check reliability: determine what host is owner for the example service we subscribed to.\n        // Then stop that host which should cause the remaining host(s) to pick up ownership.\n        // Subscriptions will not survive on their own, but we expect the ReliableSubscriptionService\n        // to notice the subscription is gone on the new owner, and re subscribe.\n        List<URI> exampleSubUris = new ArrayList<>();\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            exampleSubUris.add(UriUtils.buildUri(hostUri, uri.getPath(),\n                    ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS));\n        }\n\n        // stop host that has ownership of example service\n        NodeGroupConfig cfg = new NodeGroupConfig();\n        cfg.nodeRemovalDelayMicros = TimeUnit.SECONDS.toMicros(2);\n        this.host.setNodeGroupConfig(cfg);\n\n        // relax quorum\n        this.host.setNodeGroupQuorum(1);\n        // stop host with subscription\n        this.host.stopHost(ownerHost);\n\n        factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        uri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n\n        // verify that we still have 1 subscription on the remaining host, which can only happen if the\n        // reliable subscription service notices the current owner failure and re subscribed\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // and test once again that notifications flow.\n        this.host.log(\"Sending PATCH requests to %s\", uri);\n        long c = this.updateCount;\n        for (int i = 0; i < c; i++) {\n            body.name = \"post-stop-\" + UUID.randomUUID().toString();\n            this.host.send(Operation.createPatch(uri).setBody(body));\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (reliableNotificationCount.get() < c) {\n            Thread.sleep(250);\n            this.host.log(\"Received %d notifications, expecting %d\",\n                    reliableNotificationCount.get(), c);\n            if (new Date().after(exp)) {\n                throw new TimeoutException();\n            }\n        }\n    }\n\n    @Test\n    public void subscriptionsToFactoryAndChildren() throws Throwable {\n        this.host.stop();\n        this.host.setPort(0);\n        this.host.start();\n        this.host.setPublicUri(UriUtils.buildUri(\"localhost\", this.host.getPort(), \"\", null));\n        this.host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        URI factoryUri = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n\n        String prefix = \"example-\";\n        Long counterValue = Long.MAX_VALUE;\n        URI[] childUris = new URI[this.serviceCount];\n\n        doFactoryPostNotifications(factoryUri, this.serviceCount, prefix, counterValue, childUris);\n\n        doNotificationsWithReplayState(childUris);\n\n        doNotificationsWithFailure(childUris);\n\n        doNotificationsWithLimitAndPublicUri(childUris);\n\n        doNotificationsWithExpiration(childUris);\n\n        doDeleteNotifications(childUris, counterValue);\n    }\n\n    @Test\n    public void testSubscriptionsWithAuth() throws Throwable {\n        VerificationHost hostWithAuth = null;\n        try {\n            String testUserEmail = \"foo@vmware.com\";\n            hostWithAuth = VerificationHost.create(0);\n            hostWithAuth.setAuthorizationEnabled(true);\n            hostWithAuth.start();\n            hostWithAuth.setSystemAuthorizationContext();\n            TestContext waitContext = new TestContext(1, Duration.ofSeconds(5));\n            AuthorizationSetupHelper.create()\n                    .setHost(hostWithAuth)\n                    .setDocumentKind(Utils.buildKind(MinimalTestServiceState.class))\n                    .setUserEmail(testUserEmail)\n                    .setUserSelfLink(testUserEmail)\n                    .setUserPassword(testUserEmail)\n                    .setCompletion(waitContext.getCompletion())\n                    .start();\n            hostWithAuth.testWait(waitContext);\n            hostWithAuth.resetSystemAuthorizationContext();\n            hostWithAuth.assumeIdentity(UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, testUserEmail));\n            MinimalTestService s = new MinimalTestService();\n            MinimalTestServiceState serviceState = new MinimalTestServiceState();\n            serviceState.id = UUID.randomUUID().toString();\n            String minimalServiceUUID = UUID.randomUUID().toString();\n            TestContext notifyContext = new TestContext(1, Duration.ofSeconds(5));\n            hostWithAuth.startServiceAndWait(s, minimalServiceUUID, serviceState);\n\n            Consumer<Operation> notifyC = (nOp) -> {\n                nOp.complete();\n                switch (nOp.getAction()) {\n                case PUT:\n                    notifyContext.completeIteration();\n                    break;\n                default:\n                    break;\n\n                }\n            };\n\n            hostWithAuth.setSystemAuthorizationContext();\n            Operation subscribe = Operation.createPost(UriUtils.buildUri(hostWithAuth, minimalServiceUUID));\n            subscribe.setReferer(hostWithAuth.getReferer());\n            ServiceSubscriber subscriber = new ServiceSubscriber();\n            subscriber.replayState = true;\n            hostWithAuth.startSubscriptionService(subscribe, notifyC, subscriber);\n            hostWithAuth.resetAuthorizationContext();\n            hostWithAuth.testWait(notifyContext);\n        } finally {\n            if (hostWithAuth != null) {\n                hostWithAuth.tearDown();\n            }\n        }\n    }\n\n    @Test\n    public void subscribeAndWaitForServiceAvailability() throws Throwable {\n        // until HTTP2 support is we must only subscribe to less than max connections!\n        // otherwise we deadlock: the connection for the queued subscribe is used up,\n        // no more connections can be created, to that owner.\n        this.serviceCount = NettyHttpServiceClient.DEFAULT_CONNECTIONS_PER_HOST / 2;\n        // set the connection limit higher for the test host since it will be issuing parallel\n        // subscribes, POSTs\n        this.host.getClient().setConnectionLimitPerHost(this.serviceCount * 4);\n        setUpPeers();\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.getClient().setConnectionLimitPerHost(this.serviceCount * 4);\n        }\n\n        this.host.waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK));\n\n        // Pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n\n        // Create example service states to subscribe to\n        List<ExampleServiceState> states = new ArrayList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.documentSelfLink = UriUtils.buildUriPath(\n                    ExampleService.FACTORY_LINK,\n                    UUID.randomUUID().toString());\n            state.name = UUID.randomUUID().toString();\n            states.add(state);\n        }\n\n        AtomicInteger notifications = new AtomicInteger();\n        // Subscription target\n        ServiceSubscriber sr = createAndStartNotificationTarget((update) -> {\n            if (update.getAction() != Action.PATCH) {\n                // because we start multiple nodes and we do not wait for factory start\n                // we will receive synchronization related PUT requests, on each service.\n                // Ignore everything but the PATCH we send from the test\n                return false;\n            }\n            this.host.completeIteration();\n            this.host.log(\"notification %d\", notifications.incrementAndGet());\n            update.complete();\n            return true;\n        });\n\n        this.host.log(\"Subscribing to %d services\", this.serviceCount);\n        // Subscribe to factory (will not complete until factory is started again)\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            subscribeToService(uri, sr);\n        }\n\n        // First the subscription requests will be sent and will be queued.\n        // So N completions come from the subscribe requests.\n        // After that, the services will be POSTed and started. This is the second set\n        // of N completions.\n        this.host.testStart(2 * this.serviceCount);\n        this.host.log(\"Sending parallel POST for %d services\", this.serviceCount);\n\n        AtomicInteger postCount = new AtomicInteger();\n        // Create example services, triggering subscriptions to complete\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildFactoryUri(serviceHost, ExampleService.class);\n            Operation op = Operation.createPost(uri)\n                    .setBody(state)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        this.host.log(\"POST count %d\", postCount.incrementAndGet());\n                        this.host.completeIteration();\n                    });\n            this.host.send(op);\n        }\n\n        this.host.testWait();\n\n        this.host.testStart(2 * this.serviceCount);\n        // now send N PATCH ops so we get notifications\n        for (ExampleServiceState state : states) {\n            // send a PATCH, to trigger notification\n            URI u = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            state.counter = Utils.getNowMicrosUtc();\n            Operation patch = Operation.createPatch(u)\n                    .setBody(state)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(patch);\n        }\n        this.host.testWait();\n    }\n\n    private void doFactoryPostNotifications(URI factoryUri, int childCount, String prefix,\n            Long counterValue,\n            URI[] childUris) throws Throwable {\n        this.host.log(\"starting subscription to factory\");\n        this.host.testStart(1);\n        // let the service host update the URI from the factory to its subscriptions\n        Operation subscribeOp = Operation.createPost(factoryUri)\n                .setReferer(this.host.getReferer())\n                .setCompletion(this.host.getCompletion());\n        URI notificationTarget = host.startSubscriptionService(subscribeOp, (o) -> {\n            if (o.getAction() == Action.POST) {\n                this.host.completeIteration();\n            } else {\n                this.host.failIteration(new IllegalStateException(\"Unexpected notification: \"\n                        + o.toString()));\n            }\n        });\n        this.host.testWait();\n\n        // expect a POST notification per child, a POST completion per child\n        this.host.testStart(childCount * 2);\n        for (int i = 0; i < childCount; i++) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.name = initialState.documentSelfLink = prefix + i;\n            initialState.counter = counterValue;\n            final int finalI = i;\n\n            // create an example service\n            this.host.send(Operation\n                    .createPost(factoryUri)\n                    .setBody(initialState).setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        ServiceDocument rsp = o.getBody(ServiceDocument.class);\n                        childUris[finalI] = UriUtils.buildUri(this.host, rsp.documentSelfLink);\n                        this.host.completeIteration();\n                    }));\n        }\n        this.host.testWait();\n\n        this.host.testStart(1);\n        Operation delete = subscribeOp.clone().setUri(factoryUri).setAction(Action.DELETE);\n        this.host.stopSubscriptionService(delete, notificationTarget);\n        this.host.testWait();\n        this.verifySubscriberCount(new URI[]{factoryUri}, 0);\n    }\n\n    private void doNotificationsWithReplayState(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with replay\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(\n                UUID.randomUUID().toString(),\n                deletesRemainingCount);\n        sr.replayState = true;\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        patchChildren(childUris, false);\n\n        patchChildren(childUris, false);\n\n        // Finally un subscribe the notification handlers\n        unsubscribeFromChildren(childUris, sr.reference, false);\n        verifySubscriberCount(childUris, 0);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doNotificationsWithExpiration(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with expiration\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n\n        // start a notification target that will not complete test iterations since expirations race\n        // with notifications, allowing for notifications to be processed after the next test starts\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount, false, false);\n        sr.documentExpirationTimeMicros = Utils.getNowMicrosUtc()\n                + this.host.getMaintenanceIntervalMicros() * 2;\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        Thread.sleep((this.host.getMaintenanceIntervalMicros() / 1000) * 2);\n        // do a patch which will cause the publisher to evaluate and expire subscriptions\n        patchChildren(childUris, true);\n\n        verifySubscriberCount(childUris, 0);\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void deleteNotificationTarget(AtomicInteger deletesRemainingCount,\n            ServiceSubscriber sr) throws Throwable {\n        deletesRemainingCount.set(1);\n        TestContext ctx = testCreate(1);\n        this.host.send(Operation.createDelete(sr.reference)\n                .setCompletion((o, e) -> ctx.completeIteration()));\n        testWait(ctx);\n    }\n\n    private void doNotificationsWithFailure(URI[] childUris) throws Throwable, InterruptedException {\n        this.host.log(\"starting subscription with failure, stopping notification target\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, but stop the notification target, causing automatic removal of the\n        // subscriptions\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        // send updates and expect failure in delivering notifications\n        patchChildren(childUris, true);\n        // expect the publisher to note at least one failed notification attempt\n        verifySubscriberCount(true, childUris, 1, 1L);\n\n        // restart notification target service but expect a pragma in the notifications\n        // saying we missed some\n        boolean expectSkippedNotificationsPragma = true;\n        this.host.log(\"restarting notification target\");\n        createAndStartNotificationTarget(sr.reference.getPath(),\n                deletesRemainingCount, expectSkippedNotificationsPragma, true);\n\n        // send some more updates, this time expect ZERO failures;\n        patchChildren(childUris, false);\n        verifySubscriberCount(true, childUris, 1, 0L);\n\n        this.host.log(\"stopping notification target, again\");\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        while (!verifySubscriberCount(false, childUris, 0, null)) {\n            Thread.sleep(VerificationHost.FAST_MAINT_INTERVAL_MILLIS);\n            patchChildren(childUris, true);\n        }\n\n        this.host.log(\"Verifying all subscriptions have been removed\");\n        // because we sent more than K updates, causing K + 1 notification delivery failures,\n        // the subscriptions should all be automatically removed!\n        verifySubscriberCount(childUris, 0);\n    }\n\n    private void doNotificationsWithLimitAndPublicUri(URI[] childUris) throws Throwable,\n            InterruptedException, TimeoutException {\n        this.host.log(\"starting subscription with limit and public uri\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, use public URI and limit notifications to one.\n        // After these notifications are sent, we should see all subscriptions removed\n        deletesRemainingCount.set(childUris.length + 1);\n        sr.usePublicUri = true;\n        sr.notificationLimit = this.updateCount;\n\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        // Issue another patch request on every example service instance\n        patchChildren(childUris, false);\n\n        // because we set notificationLimit, all subscriptions should be removed\n        verifySubscriberCount(childUris, 0);\n\n        Date exp = this.host.getTestExpiration();\n        // verify we received DELETEs on the notification target when a subscription was removed\n        while (deletesRemainingCount.get() != 1) {\n            Thread.sleep(250);\n            if (new Date().after(exp)) {\n                throw new TimeoutException(\"DELETEs not received at notification target:\"\n                        + deletesRemainingCount.get());\n            }\n        }\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doDeleteNotifications(URI[] childUris, Long counterValue) throws Throwable {\n        this.host.log(\"starting subscription for DELETEs\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        subscribeToServices(childUris, sr);\n\n        // Issue DELETEs and verify the subscription was notified\n        this.host.testStart(childUris.length * 2);\n        for (URI child : childUris) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.counter = counterValue;\n            Operation delete = Operation\n                    .createDelete(child)\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(delete);\n        }\n        this.host.testWait();\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount) throws Throwable {\n        return createAndStartNotificationTarget(link, deletesRemainingCount, false, true);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount,\n            boolean expectSkipNotificationsPragma,\n            boolean completeIterations) throws Throwable {\n        final AtomicBoolean seenSkippedNotificationPragma =\n                new AtomicBoolean(false);\n\n        return createAndStartNotificationTarget(link, (update) -> {\n            if (!update.isNotification()) {\n                if (update.getAction() == Action.DELETE) {\n                    int r = deletesRemainingCount.decrementAndGet();\n                    if (r != 0) {\n                        update.complete();\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            if (update.getAction() != Action.PATCH &&\n                    update.getAction() != Action.PUT &&\n                    update.getAction() != Action.DELETE) {\n                update.complete();\n                return true;\n            }\n\n            if (expectSkipNotificationsPragma) {\n                String pragma = update.getRequestHeader(Operation.PRAGMA_HEADER);\n                if (!seenSkippedNotificationPragma.get() && (pragma == null\n                        || !pragma.contains(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS))) {\n                    this.host.failIteration(new IllegalStateException(\n                            \"Missing skipped notification pragma\"));\n                    return true;\n                } else {\n                    seenSkippedNotificationPragma.set(true);\n                }\n            }\n\n            if (completeIterations) {\n                this.host.completeIteration();\n            }\n\n            update.complete();\n            return true;\n        });\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            Function<Operation, Boolean> h) throws Throwable {\n        return createAndStartNotificationTarget(UUID.randomUUID().toString(), h);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            String link,\n            Function<Operation, Boolean> h) throws Throwable {\n        StatelessService notificationTarget = createNotificationTargetService(h);\n\n        // Start notification target (shared between subscriptions)\n        Operation startOp = Operation\n                .createPost(UriUtils.buildUri(this.host, link))\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer());\n        this.host.testStart(1);\n        this.host.startService(startOp, notificationTarget);\n        this.host.testWait();\n\n        ServiceSubscriber sr = new ServiceSubscriber();\n        sr.reference = notificationTarget.getUri();\n        return sr;\n    }\n\n    private StatelessService createNotificationTargetService(Function<Operation, Boolean> h) {\n        return new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                if (!h.apply(update)) {\n                    super.handleRequest(update);\n                }\n            }\n        };\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr) throws Throwable {\n        int expectedCompletions = uris.length;\n        if (sr.replayState) {\n            expectedCompletions *= 2;\n        }\n        subscribeToServices(uris, sr, expectedCompletions);\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr, int expectedCompletions) throws Throwable {\n        this.host.testStart(expectedCompletions);\n        for (int i = 0; i < uris.length; i++) {\n            subscribeToService(uris[i], sr);\n        }\n        this.host.testWait();\n    }\n\n    private void subscribeToService(URI uri, ServiceSubscriber sr) {\n        if (sr.usePublicUri) {\n            sr = Utils.clone(sr);\n            sr.reference = UriUtils.buildPublicUri(this.host, sr.reference.getPath());\n        }\n\n        URI subUri = UriUtils.buildSubscriptionUri(uri);\n        this.host.send(Operation.createPost(subUri)\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer())\n                .setBody(sr)\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_QUEUE_FOR_SERVICE_AVAILABILITY));\n    }\n\n    private void unsubscribeFromChildren(URI[] uris, URI targetUri,\n            boolean useServiceHostStopSubscription) throws Throwable {\n        int count = uris.length;\n        TestContext ctx = testCreate(count);\n        for (int i = 0; i < count; i++) {\n            if (useServiceHostStopSubscription) {\n                // stop the subscriptions using the service host API\n                host.stopSubscriptionService(\n                        Operation.createDelete(uris[i])\n                                .setCompletion(ctx.getCompletion()),\n                        targetUri);\n                continue;\n            }\n            ServiceSubscriber unsubscribeBody = new ServiceSubscriber();\n            unsubscribeBody.reference = targetUri;\n\n            URI subUri = UriUtils.buildSubscriptionUri(uris[i]);\n            this.host.send(Operation.createDelete(subUri)\n                    .setCompletion(ctx.getCompletion())\n                    .setBody(unsubscribeBody));\n        }\n        testWait(ctx);\n    }\n\n    private boolean verifySubscriberCount(URI[] uris, int subscriberCount) throws Throwable {\n        return verifySubscriberCount(true, uris, subscriberCount, null);\n    }\n\n    private boolean verifySubscriberCount(boolean wait, URI[] uris, int subscriberCount,\n            Long failedNotificationCount)\n            throws Throwable {\n        URI[] subUris = new URI[uris.length];\n        int i = 0;\n        for (URI u : uris) {\n            URI subUri = UriUtils.buildSubscriptionUri(u);\n            subUris[i++] = subUri;\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            Map<URI, ServiceSubscriptionState> subStates = this.host.getServiceState(null,\n                    ServiceSubscriptionState.class, subUris);\n            for (ServiceSubscriptionState state : subStates.values()) {\n                int expected = subscriberCount;\n                int actual = state.subscribers.size();\n                if (actual != expected) {\n                    isConverged = false;\n                    break;\n                }\n\n                if (failedNotificationCount == null) {\n                    continue;\n                }\n\n                for (ServiceSubscriber sr : state.subscribers.values()) {\n                    if (sr.failedNotificationCount == null && failedNotificationCount == 0) {\n                        continue;\n                    }\n                    if (sr.failedNotificationCount == null\n                            || 0 != sr.failedNotificationCount.compareTo(failedNotificationCount)) {\n                        isConverged = false;\n                        break;\n                    }\n                }\n\n            }\n            if (isConverged) {\n                return true;\n            }\n            if (!wait) {\n                return false;\n            }\n            Thread.sleep(250);\n        }\n\n        throw new TimeoutException(\"Subscriber count did not converge to \" + subscriberCount);\n    }\n\n    private void patchChildren(URI[] uris, boolean expectFailure) throws Throwable {\n        int count = expectFailure ? uris.length : uris.length * 2;\n        long c = this.updateCount;\n        if (!expectFailure) {\n            count *= this.updateCount;\n        } else {\n            c = 1;\n        }\n\n        this.host.testStart(count);\n        for (int i = 0; i < uris.length; i++) {\n            for (int k = 0; k < c; k++) {\n                ExampleServiceState initialState = new ExampleServiceState();\n                initialState.counter = Long.MAX_VALUE;\n                Operation patch = Operation\n                        .createPatch(uris[i])\n                        .setBody(initialState)\n                        .setCompletion(this.host.getCompletion());\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait();\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport static com.vmware.xenon.common.ServiceHost.SERVICE_URI_SUFFIX_TEMPLATE;\nimport static com.vmware.xenon.common.ServiceHost.SERVICE_URI_SUFFIX_UI;\n\nimport java.net.URI;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.TimeBin;\nimport com.vmware.xenon.common.test.AuthTestUtils;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.QueryTask.Query;\n\npublic class TestUtilityService extends BasicReusableHostTestCase {\n\n    private List<Service> createServices(int count) throws Throwable {\n        List<Service> services = this.host.doThroughputServiceStart(\n                count, MinimalTestService.class,\n                this.host.buildMinimalTestState(),\n                null, null);\n        return services;\n    }\n\n    @Before\n    public void setUp() {\n        // We tell the verification host that we re-use it across test methods. This enforces\n        // the use of TestContext, to isolate test methods from each other.\n        // In this test class we host.testCreate(count) to get an isolated test context and\n        // then either wait on the context itself, or ask the convenience method host.testWait(ctx)\n        // to do it for us.\n        this.host.setSingleton(true);\n    }\n\n    @Test\n    public void patchConfiguration() throws Throwable {\n        int count = 10;\n\n        host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        // try config patch on a factory\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = EnumSet.of(ServiceOption.IDEMPOTENT_POST);\n        TestContext ctx = this.testCreate(1);\n\n        URI configUri = UriUtils.buildConfigUri(host, ExampleService.FACTORY_LINK);\n        this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                .setCompletion(ctx.getCompletion()));\n\n        this.testWait(ctx);\n\n        TestContext ctx2 = this.testCreate(1);\n        // verify option removed\n        this.host.send(Operation.createGet(configUri).setCompletion((o, e) -> {\n            if (e != null) {\n                ctx2.failIteration(e);\n                return;\n            }\n\n            ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n            if (!cfg.options.contains(ServiceOption.IDEMPOTENT_POST)) {\n                ctx2.completeIteration();\n            } else {\n                ctx2.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n            }\n\n        }));\n\n        this.testWait(ctx2);\n\n        List<Service> services = createServices(count);\n        // verify no stats exist before we enable that capability\n        for (Service s : services) {\n            Map<String, ServiceStat> stats = this.host.getServiceStats(s.getUri());\n            assertTrue(stats != null);\n            assertTrue(stats.isEmpty());\n        }\n\n        updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.addOptions = EnumSet.of(ServiceOption.INSTRUMENTATION);\n        ctx = this.testCreate(services.size());\n        for (Service s : services) {\n            configUri = UriUtils.buildConfigUri(s.getUri());\n            this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                    .setCompletion(ctx.getCompletion()));\n        }\n        this.testWait(ctx);\n\n        // get configuration and verify options\n        TestContext ctx3 = testCreate(services.size());\n        for (Service s : services) {\n            URI u = UriUtils.buildConfigUri(s.getUri());\n            host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                if (e != null) {\n                    ctx3.failIteration(e);\n                    return;\n                }\n\n                ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n                if (cfg.options.contains(ServiceOption.INSTRUMENTATION)) {\n                    ctx3.completeIteration();\n                } else {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                }\n\n            }));\n        }\n        testWait(ctx3);\n\n        ctx = testCreate(services.size());\n        // issue some updates so stats get updated\n        for (Service s : services) {\n            this.host.send(Operation.createPatch(s.getUri())\n                    .setBody(this.host.buildMinimalTestState())\n                    .setCompletion(ctx.getCompletion()));\n        }\n        testWait(ctx);\n\n        for (Service s : services) {\n            Map<String, ServiceStat> stats = this.host.getServiceStats(s.getUri());\n            assertTrue(stats != null);\n            assertTrue(!stats.isEmpty());\n        }\n    }\n\n    @Test\n    public void redirectToUiServiceIndex() throws Throwable {\n        // create an example child service and also verify it has a default UI html page\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = UUID.randomUUID().toString();\n        s.documentSelfLink = s.name;\n        Operation post = Operation\n                .createPost(UriUtils.buildFactoryUri(this.host, ExampleService.class))\n                .setBody(s);\n        this.host.sendAndWaitExpectSuccess(post);\n\n        // do a get on examples/ui and examples/<uuid>/ui, twice to test the code path that caches\n        // the resource file lookup\n        for (int i = 0; i < 2; i++) {\n            Operation htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n\n            htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK, s.name,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n        }\n    }\n\n    @Test\n    public void testUtilityStats() throws Throwable {\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 2;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stat.unit = \"unit\";\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 3 - POST a stat with the same key again and verify that the\n        // version and accumulated value are updated\n        stat.latestValue = 50;\n        stat.unit = \"unit1\";\n        Long updatedMicrosUtc1 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc1;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        // Step 4 - POST a stat with a new key and verify that the\n        // previously posted stat is not updated\n        stat.name = \"key2\";\n        stat.latestValue = 50;\n        stat.unit = \"unit2\";\n        Long updatedMicrosUtc2 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc2;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        retStatEntry = allStats.entries.get(\"key2\");\n        assertTrue(retStatEntry.accumulatedValue == 50);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit2\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc2);\n\n        // Step 5 - Issue a PUT for the first stat key and verify that the doc state is replaced\n        stat.name = \"key1\";\n        stat.latestValue = 75;\n        stat.unit = \"replaceUnit\";\n        stat.sourceTimeMicrosUtc = null;\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 75);\n        assertTrue(retStatEntry.latestValue == 75);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"replaceUnit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 6 - Issue a bulk PUT and verify that the complete set of stats is updated\n        ServiceStats stats = new ServiceStats();\n        stat.name = \"key3\";\n        stat.latestValue = 200;\n        stat.unit = \"unit3\";\n        stats.entries.put(\"key3\", stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stats));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        if (allStats.entries.size() != 1) {\n            // there is a possibility of node group maintenance kicking in and adding a stat\n            ServiceStat nodeGroupStat = allStats.entries.get(\n                    Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n\n            if (nodeGroupStat == null) {\n                throw new IllegalStateException(\n                        \"Expected single stat, got: \" + Utils.toJsonHtml(allStats));\n            }\n        }\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.accumulatedValue == 200);\n        assertTrue(retStatEntry.latestValue == 200);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit3\"));\n\n        // Step 7 - Issue a PATCH and verify that the latestValue is updated\n        stat.latestValue = 25;\n        this.host.sendAndWaitExpectSuccess(Operation.createPatch(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.latestValue == 225);\n        assertTrue(retStatEntry.version == 2);\n    }\n\n    @Test\n    public void testTimeSeriesStats() throws Throwable {\n        long startTime = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());\n        int numBins = 4;\n        long interval = 1000;\n        double value = 100;\n        // set data to fill up the specified number of bins\n        TimeSeriesStats timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.allOf(AggregationType.class));\n        for (int i = 0; i < numBins; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        // insert additional unique datapoints; the earliest entries should be dropped\n        for (int i = 0; i < numBins / 2; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        long timeMicros = startTime - TimeUnit.MILLISECONDS.toMicros(interval * (numBins - 1));\n        long timeMillis = TimeUnit.MICROSECONDS.toMillis(timeMicros);\n        timeMillis -= (timeMillis % interval);\n        assertTrue(timeSeriesStats.bins.firstKey() == timeMillis);\n\n        // insert additional datapoints for an existing bin. The count should increase,\n        // min, max, average computed appropriately\n        double origValue = value;\n        double accumulatedValue = value;\n        double newValue = value;\n        double count = 1;\n        for (int i = 0; i < numBins / 2; i++) {\n            newValue++;\n            count++;\n            timeSeriesStats.add(startTime, newValue);\n            accumulatedValue += newValue;\n        }\n        TimeBin lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg.equals(accumulatedValue / count));\n        assertTrue(lastBin.sum.equals(accumulatedValue));\n        assertTrue(lastBin.count == count);\n        assertTrue(lastBin.max.equals(newValue));\n        assertTrue(lastBin.min.equals(origValue));\n\n        // test with a subset of the aggregation types specified\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.AVG));\n        timeSeriesStats.add(startTime, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg != null);\n        assertTrue(lastBin.count != 0);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.MIN, AggregationType.MAX));\n        timeSeriesStats.add(startTime, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.max != null);\n        assertTrue(lastBin.min != null);\n\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        // set bin size to 1ms\n        stat.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        for (int i = 0; i < numBins; i++) {\n            Thread.sleep(1);\n            this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                    this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        }\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(stat.name);\n        assertTrue(retStatEntry.accumulatedValue == 100 * (numBins + 1));\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == numBins + 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == numBins);\n\n        // Step 3 - POST a stat to the service instance with sourceTimeMicrosUtc and verify we can fetch the stat just posted\n        String statName = UUID.randomUUID().toString();\n        ExampleServiceState exampleState = new ExampleServiceState();\n        exampleState.name = statName;\n        Consumer<Operation> setter = (o) -> {\n            o.setBody(exampleState);\n        };\n        Map<URI, ExampleServiceState> stateMap = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, setter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n        ExampleServiceState returnExampleState = stateMap.values().iterator().next();\n        ServiceStats.ServiceStat sourceStat1 = new ServiceStat();\n        sourceStat1.name = \"sourceKey1\";\n        sourceStat1.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 1, 2000\n        Long sourceTimeMicrosUtc1 = 946713600000000L;\n        sourceStat1.sourceTimeMicrosUtc = sourceTimeMicrosUtc1;\n        ServiceStats.ServiceStat sourceStat2 = new ServiceStat();\n        sourceStat2.name = \"sourceKey2\";\n        sourceStat2.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 2, 2000\n        Long sourceTimeMicrosUtc2 = 946800000000000L;\n        sourceStat2.sourceTimeMicrosUtc = sourceTimeMicrosUtc2;\n        // set bucket size to 1ms\n        sourceStat1.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        sourceStat2.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat1));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat2));\n        allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, returnExampleState.documentSelfLink));\n        retStatEntry = allStats.entries.get(sourceStat1.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc1)));\n\n        retStatEntry = allStats.entries.get(sourceStat2.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc2)));\n    }\n\n    public static class SetAvailableValidationService extends StatefulService {\n\n        public SetAvailableValidationService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public void handleStart(Operation op) {\n            setAvailable(false);\n            // we will transition to available only when we receive a special PATCH.\n            // This simulates a service that starts, but then self patch itself sometime\n            // later to indicate its done with some complex init. It does not do it in handle\n            // start, since it wants to make POST quick.\n            op.complete();\n        }\n\n        @Override\n        public void handlePatch(Operation op) {\n            // regardless of body, just become available\n            setAvailable(true);\n            op.complete();\n        }\n    }\n\n    @Test\n    public void failureOnReservedSuffixServiceStart() throws Throwable {\n        TestContext ctx = this.testCreate(ServiceHost.RESERVED_SERVICE_URI_PATHS.length);\n        for (String reservedSuffix : ServiceHost.RESERVED_SERVICE_URI_PATHS) {\n            Operation post = Operation.createPost(this.host,\n                    UUID.randomUUID().toString() + \"/\" + reservedSuffix)\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.startService(post, new MinimalTestService());\n        }\n        this.testWait(ctx);\n    }\n\n    @Test\n    public void testIsAvailableStatAndSuffix() throws Throwable {\n        long c = 1;\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // first verify that service that do not explicitly use the setAvailable method,\n        // appear available. Both a factory and a child service\n        this.host.waitForServiceAvailable(factoryURI);\n\n        // expect 200 from /factory/<child>/available\n        TestContext ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            Operation get = Operation.createGet(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // verify that PUT on /available can make it switch to unavailable (503)\n        ServiceStat body = new ServiceStat();\n        body.name = Service.STAT_NAME_AVAILABLE;\n        body.latestValue = 0.0;\n\n        Operation put = Operation.createPut(\n                UriUtils.buildAvailableUri(this.host, factoryURI.getPath()))\n                .setBody(body);\n        this.host.sendAndWaitExpectSuccess(put);\n\n        // verify factory now appears unavailable\n        Operation get = Operation.createGet(UriUtils.buildAvailableUri(factoryURI));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // verify PUT on child services makes them unavailable\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            put = put.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setBody(body)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(put);\n        }\n        testWait(ctx);\n\n        // expect 503 from /factory/<child>/available\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            get = get.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // now validate a stateful service that is in memory, and explicitly calls setAvailable\n        // sometime after it starts\n        Service service = this.host.startServiceAndWait(new SetAvailableValidationService(),\n                UUID.randomUUID().toString(), new ExampleServiceState());\n\n        // verify service is NOT available, since we have not yet poked it, to become available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // send a PATCH to this special test service, to make it switch to available\n        Operation patch = Operation.createPatch(service.getUri())\n                .setBody(new ExampleServiceState());\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        // verify service now appears available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectSuccess(get);\n    }\n\n    public void validateServiceUiHtmlResponse(Operation op) {\n        assertTrue(op.getStatusCode() == Operation.STATUS_CODE_MOVED_TEMP);\n        assertTrue(op.getResponseHeader(\"Location\").contains(\n                \"/core/ui/default/#\"));\n    }\n\n    public static void validateTimeSeriesStat(ServiceStat stat, long expectedBinDurationMillis) {\n        assertTrue(stat != null);\n        assertTrue(stat.timeSeriesStats != null);\n        assertTrue(stat.version > 1);\n        assertEquals(expectedBinDurationMillis, stat.timeSeriesStats.binDurationMillis);\n        double maxAvg = 0;\n        double countPerMaxAvgBin = 0;\n        for (TimeBin bin : stat.timeSeriesStats.bins.values()) {\n            if (bin.avg != null && bin.avg > maxAvg) {\n                maxAvg = bin.avg;\n                countPerMaxAvgBin = bin.count;\n            }\n        }\n        assertTrue(maxAvg > 0);\n        assertTrue(countPerMaxAvgBin >= 1);\n    }\n\n    @Test\n    public void endpointAuthorization() throws Throwable {\n        VerificationHost host = VerificationHost.create(0);\n        host.setAuthorizationService(new AuthorizationContextService());\n        host.setAuthorizationEnabled(true);\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n        host.start();\n\n        TestRequestSender sender = host.getTestRequestSender();\n\n        host.setSystemAuthorizationContext();\n        host.waitForReplicatedFactoryServiceAvailable(UriUtils.buildUri(host, ExampleService.FACTORY_LINK));\n\n        String exampleUser = \"example@vmware.com\";\n        String examplePass = \"password\";\n        TestContext authCtx = host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(host)\n                .setUserEmail(exampleUser)\n                .setUserPassword(examplePass)\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class))\n                        .build())\n                .setCompletion(authCtx.getCompletion())\n                .start();\n        authCtx.await();\n\n        // create a sample service\n        ExampleServiceState doc = new ExampleServiceState();\n        doc.name = \"foo\";\n        doc.documentSelfLink = \"foo\";\n\n        Operation post = Operation.createPost(host, ExampleService.FACTORY_LINK).setBody(doc);\n        ExampleServiceState postResult = sender.sendAndWait(post, ExampleServiceState.class);\n\n        host.resetAuthorizationContext();\n\n        URI factoryAvailableUri = UriUtils.buildAvailableUri(host, ExampleService.FACTORY_LINK);\n        URI factoryStatsUri = UriUtils.buildStatsUri(host, ExampleService.FACTORY_LINK);\n        URI factoryConfigUri = UriUtils.buildConfigUri(host, ExampleService.FACTORY_LINK);\n        URI factorySubscriptionUri = UriUtils.buildSubscriptionUri(host, ExampleService.FACTORY_LINK);\n        URI factoryTemplateUri = UriUtils.buildUri(host, UriUtils.buildUriPath(ExampleService.FACTORY_LINK, SERVICE_URI_SUFFIX_TEMPLATE));\n        URI factoryUiUri = UriUtils.buildUri(host, UriUtils.buildUriPath(ExampleService.FACTORY_LINK, SERVICE_URI_SUFFIX_UI));\n\n        URI serviceAvailableUri = UriUtils.buildAvailableUri(host, postResult.documentSelfLink);\n        URI serviceStatsUri = UriUtils.buildStatsUri(host, postResult.documentSelfLink);\n        URI serviceConfigUri = UriUtils.buildConfigUri(host, postResult.documentSelfLink);\n        URI serviceSubscriptionUri = UriUtils.buildSubscriptionUri(host, postResult.documentSelfLink);\n        URI serviceTemplateUri = UriUtils.buildUri(host, UriUtils.buildUriPath(postResult.documentSelfLink, SERVICE_URI_SUFFIX_TEMPLATE));\n        URI serviceUiUri = UriUtils.buildUri(host, UriUtils.buildUriPath(postResult.documentSelfLink, SERVICE_URI_SUFFIX_UI));\n\n        // check non-authenticated user receives forbidden response\n        FailureResponse failureResponse;\n        Operation uiOpResult;\n\n        // check factory endpoints\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factoryAvailableUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factoryStatsUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factoryConfigUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factorySubscriptionUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factoryTemplateUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        uiOpResult = sender.sendAndWait(Operation.createGet(factoryUiUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, uiOpResult.getStatusCode());\n\n        // check service endpoints\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceAvailableUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceStatsUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceConfigUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceSubscriptionUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceTemplateUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        uiOpResult = sender.sendAndWait(Operation.createGet(serviceUiUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, uiOpResult.getStatusCode());\n\n\n        // check authenticated user does NOT receive forbidden response\n        AuthTestUtils.login(host, exampleUser, examplePass);\n\n        Operation response;\n\n        // check factory endpoints\n        response = sender.sendAndWait(Operation.createGet(factoryAvailableUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factoryStatsUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factoryConfigUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factorySubscriptionUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factoryTemplateUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factoryUiUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n\n        // check service endpoints\n        response = sender.sendAndWait(Operation.createGet(serviceAvailableUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceStatsUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceConfigUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceSubscriptionUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceTemplateUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceUiUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n    }\n\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common.test;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static com.vmware.xenon.services.common.authn.BasicAuthenticationUtils.constructBasicAuth;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification;\nimport com.vmware.xenon.services.common.ResourceGroupService.ResourceGroupState;\nimport com.vmware.xenon.services.common.RoleService.Policy;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UserGroupService;\nimport com.vmware.xenon.services.common.UserGroupService.UserGroupState;\nimport com.vmware.xenon.services.common.UserService.UserState;\nimport com.vmware.xenon.services.common.authn.AuthenticationRequest;\nimport com.vmware.xenon.services.common.authn.BasicAuthenticationService;\n\n/**\n * Consider using {@link com.vmware.xenon.common.AuthorizationSetupHelper}\n */\npublic class AuthorizationHelper {\n\n    private String userGroupLink;\n    private String resourceGroupLink;\n    private String roleLink;\n\n    VerificationHost host;\n\n    public AuthorizationHelper(VerificationHost host) {\n        this.host = host;\n    }\n\n    public static String createUserService(VerificationHost host, ServiceHost target, String email) throws Throwable {\n        final String[] userUriPath = new String[1];\n\n        UserState userState = new UserState();\n        userState.documentSelfLink = email;\n        userState.email = email;\n\n        URI postUserUri = UriUtils.buildUri(target, ServiceUriPaths.CORE_AUTHZ_USERS);\n        host.testStart(1);\n        host.send(Operation\n                .createPost(postUserUri)\n                .setBody(userState)\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        host.failIteration(e);\n                        return;\n                    }\n                    UserState state = o.getBody(UserState.class);\n                    userUriPath[0] = state.documentSelfLink;\n                    host.completeIteration();\n                }));\n        host.testWait();\n        return userUriPath[0];\n    }\n\n    public void patchUserService(ServiceHost target, String userServiceLink, UserState userState) throws Throwable {\n        URI patchUserUri = UriUtils.buildUri(target, userServiceLink);\n        this.host.testStart(1);\n        this.host.send(Operation\n                .createPatch(patchUserUri)\n                .setBody(userState)\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n                    this.host.completeIteration();\n                }));\n        this.host.testWait();\n    }\n\n    /**\n     * Find user document and return the path.\n     *   ex: /core/authz/users/sample@vmware.com\n     *\n     * @see VerificationHost#assumeIdentity(String)\n     */\n    public String findUserServiceLink(String userEmail) throws Throwable {\n        Query userQuery = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(UserState.class))\n                .addFieldClause(UserState.FIELD_NAME_EMAIL, userEmail)\n                .build();\n\n        QueryTask queryTask = QueryTask.Builder.createDirectTask()\n                .setQuery(userQuery)\n                .build();\n\n        URI queryTaskUri = UriUtils.buildUri(this.host, ServiceUriPaths.CORE_QUERY_TASKS);\n\n        String[] userServiceLink = new String[1];\n\n        TestContext ctx = this.host.testCreate(1);\n        Operation postQuery = Operation.createPost(queryTaskUri)\n                .setBody(queryTask)\n                .setCompletion((op, ex) -> {\n                    if (ex != null) {\n                        ctx.failIteration(ex);\n                        return;\n                    }\n                    QueryTask queryResponse = op.getBody(QueryTask.class);\n                    int resultSize = queryResponse.results.documentLinks.size();\n                    if (queryResponse.results.documentLinks.size() != 1) {\n                        String msg = String\n                                .format(\"Could not find user %s, found=%d\", userEmail, resultSize);\n                        ctx.failIteration(new IllegalStateException(msg));\n                        return;\n                    } else {\n                        userServiceLink[0] = queryResponse.results.documentLinks.get(0);\n                    }\n                    ctx.completeIteration();\n                });\n        this.host.send(postQuery);\n        this.host.testWait(ctx);\n\n        return userServiceLink[0];\n    }\n\n    /**\n     * Call BasicAuthenticationService and returns auth token.\n     */\n    public String login(String email, String password) throws Throwable {\n        String basicAuth = constructBasicAuth(email, password);\n        URI loginUri = UriUtils.buildUri(this.host, ServiceUriPaths.CORE_AUTHN_BASIC);\n        AuthenticationRequest login = new AuthenticationRequest();\n        login.requestType = AuthenticationRequest.AuthenticationRequestType.LOGIN;\n\n        String[] authToken = new String[1];\n\n        TestContext ctx = this.host.testCreate(1);\n\n        Operation loginPost = Operation.createPost(loginUri)\n                .setBody(login)\n                .addRequestHeader(BasicAuthenticationService.AUTHORIZATION_HEADER_NAME,\n                        basicAuth)\n                .forceRemote()\n                .setCompletion((op, ex) -> {\n                    if (ex != null) {\n                        ctx.failIteration(ex);\n                        return;\n                    }\n                    authToken[0] = op.getResponseHeader(Operation.REQUEST_AUTH_TOKEN_HEADER);\n                    if (authToken[0] == null) {\n                        ctx.failIteration(\n                                new IllegalStateException(\"Missing auth token in login response\"));\n                        return;\n                    }\n                    ctx.completeIteration();\n                });\n\n        this.host.send(loginPost);\n        this.host.testWait(ctx);\n\n        assertTrue(authToken[0] != null);\n\n        return authToken[0];\n\n    }\n\n    public void setUserGroupLink(String userGroupLink) {\n        this.userGroupLink = userGroupLink;\n    }\n\n    public void setResourceGroupLink(String resourceGroupLink) {\n        this.resourceGroupLink = resourceGroupLink;\n    }\n\n    public void setRoleLink(String roleLink) {\n        this.roleLink = roleLink;\n    }\n\n    public String getUserGroupLink() {\n        return this.userGroupLink;\n    }\n\n    public String getResourceGroupLink() {\n        return this.resourceGroupLink;\n    }\n\n    public String getRoleLink() {\n        return this.roleLink;\n    }\n\n    public String createUserService(ServiceHost target, String email) throws Throwable {\n        return createUserService(this.host, target, email);\n    }\n\n    public Collection<String> createRoles(ServiceHost target, String email) throws Throwable {\n        return createRoles(target, email, true);\n    }\n\n    public String getUserGroupName(String email) {\n        String emailPrefix = email.substring(0, email.indexOf(\"@\"));\n        return emailPrefix + \"-user-group\";\n    }\n\n    public Collection<String> createRoles(ServiceHost target, String email, boolean createUserGroupByEmail) throws Throwable {\n        String emailPrefix = email.substring(0, email.indexOf(\"@\"));\n        String userGroupLink = null;\n        // Create user group\n        if (createUserGroupByEmail) {\n            userGroupLink =  createUserGroup(target, getUserGroupName(email), Builder.create()\n                        .addFieldClause(\n                                \"email\",\n                                email)\n                        .build());\n\n        } else {\n            String groupName = getUserGroupName(email);\n            userGroupLink =  createUserGroup(target, groupName, Builder.create()\n                    .addFieldClause(\n                            QuerySpecification\n                            .buildCollectionItemName(UserState.FIELD_NAME_USER_GROUP_LINKS),\n                            UriUtils.buildUriPath(UserGroupService.FACTORY_LINK, groupName))\n                    .build());\n        }\n        setUserGroupLink(userGroupLink);\n\n        // Create resource group for example service state\n        String exampleServiceResourceGroupLink =\n                createResourceGroup(target, emailPrefix + \"-resource-group\", Builder.create()\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_KIND,\n                                Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_NAME,\n                                emailPrefix)\n                        .build());\n        setResourceGroupLink(exampleServiceResourceGroupLink);\n        // Create resource group to allow access on ALL query tasks created by user\n        String queryTaskResourceGroupLink =\n                createResourceGroup(target, \"any-query-task-resource-group\", Builder.create()\n                        .addFieldClause(\n                                QueryTask.FIELD_NAME_KIND,\n                                Utils.buildKind(QueryTask.class))\n                        .addFieldClause(\n                                QueryTask.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                                UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, email))\n                        .build());\n\n        // Create resource group to allow access on utility paths\n        String statsResourceGroupLink = createResourceGroup(target, \"stats-resource-group\",\n                Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                ExampleService.FACTORY_LINK + ServiceHost.SERVICE_URI_SUFFIX_STATS)\n                        .build());\n\n        String subscriptionsResourceGroupLink = createResourceGroup(target, \"subs-resource-group\",\n                Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                ServiceUriPaths.CORE_LOCAL_QUERY_TASKS\n                                        + ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS)\n                        .build());\n\n        Collection<String> paths = new HashSet<>();\n\n        // Create roles tying these together\n        String exampleRoleLink = createRole(target, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST)));\n        setRoleLink(exampleRoleLink);\n        paths.add(exampleRoleLink);\n        // Create another role with PATCH permission to test if we calculate overall permissions correctly across roles.\n        paths.add(createRole(target, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Collections.singletonList(Action.PATCH))));\n\n        // Create role authorizing access to the user's own query tasks\n        paths.add(createRole(target, userGroupLink, queryTaskResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE))));\n\n        // Create role authorizing access to /stats\n        paths.add(createRole(target, userGroupLink, statsResourceGroupLink,\n                new HashSet<>(\n                        Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE))));\n\n        // Create role authorizing access to /subscriptions of query tasks\n        paths.add(createRole(target, userGroupLink, subscriptionsResourceGroupLink,\n                new HashSet<>(\n                        Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE))));\n        return paths;\n    }\n\n    public String createUserGroup(ServiceHost target, String name, Query q) throws Throwable {\n        URI postUserGroupsUri =\n                UriUtils.buildUri(target, ServiceUriPaths.CORE_AUTHZ_USER_GROUPS);\n        String selfLink =\n                UriUtils.extendUri(postUserGroupsUri, name).getPath();\n\n        // Create user group\n        UserGroupState userGroupState = new UserGroupState();\n        userGroupState.documentSelfLink = selfLink;\n        userGroupState.query = q;\n\n        this.host.sendAndWaitExpectSuccess(Operation\n                .createPost(postUserGroupsUri)\n                .setBody(userGroupState));\n        return selfLink;\n    }\n\n    public String createResourceGroup(ServiceHost target, String name, Query q) throws Throwable {\n        URI postResourceGroupsUri =\n                UriUtils.buildUri(target, ServiceUriPaths.CORE_AUTHZ_RESOURCE_GROUPS);\n        String selfLink =\n                UriUtils.extendUri(postResourceGroupsUri, name).getPath();\n\n        ResourceGroupState resourceGroupState = new ResourceGroupState();\n        resourceGroupState.documentSelfLink = selfLink;\n        resourceGroupState.query = q;\n        this.host.sendAndWaitExpectSuccess(Operation\n                .createPost(postResourceGroupsUri)\n                .setBody(resourceGroupState));\n        return selfLink;\n    }\n\n    public String createRole(ServiceHost target, String userGroupLink, String resourceGroupLink, Set<Action> verbs) throws Throwable {\n        // Build selfLink from user group, resource group, and verbs\n        String userGroupSegment = userGroupLink.substring(userGroupLink.lastIndexOf('/') + 1);\n        String resourceGroupSegment = resourceGroupLink.substring(resourceGroupLink.lastIndexOf('/') + 1);\n        String verbSegment = \"\";\n        for (Action a : verbs) {\n            if (verbSegment.isEmpty()) {\n                verbSegment = a.toString();\n            } else {\n                verbSegment += \"+\" + a.toString();\n            }\n        }\n        String selfLink = userGroupSegment + \"-\" + resourceGroupSegment + \"-\" + verbSegment;\n\n        RoleState roleState = new RoleState();\n        roleState.documentSelfLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_ROLES, selfLink);\n        roleState.userGroupLink = userGroupLink;\n        roleState.resourceGroupLink = resourceGroupLink;\n        roleState.verbs = verbs;\n        roleState.policy = Policy.ALLOW;\n        this.host.sendAndWaitExpectSuccess(Operation\n                .createPost(UriUtils.buildUri(target, ServiceUriPaths.CORE_AUTHZ_ROLES))\n                .setBody(roleState));\n        return roleState.documentSelfLink;\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common.test;\n\nimport static java.util.function.Function.identity;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toMap;\nimport static java.util.stream.Collectors.toSet;\nimport static javax.xml.bind.DatatypeConverter.printBase64Binary;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URI;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.logging.Handler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.net.ssl.SSLContext;\nimport javax.xml.bind.DatatypeConverter;\n\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\nimport org.apache.lucene.store.LockObtainFailedException;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.Claims;\nimport com.vmware.xenon.common.CommandLineArgumentParser;\nimport com.vmware.xenon.common.DeferredResult;\nimport com.vmware.xenon.common.NodeSelectorService;\nimport com.vmware.xenon.common.NodeSelectorState;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Operation.OperationOption;\nimport com.vmware.xenon.common.OperationContext;\nimport com.vmware.xenon.common.Service;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceClient;\nimport com.vmware.xenon.common.ServiceConfigUpdateRequest;\nimport com.vmware.xenon.common.ServiceConfiguration;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceDocumentDescription;\nimport com.vmware.xenon.common.ServiceDocumentDescription.Builder;\nimport com.vmware.xenon.common.ServiceDocumentQueryResult;\nimport com.vmware.xenon.common.ServiceErrorResponse;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.ServiceStats;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.ServiceStatLogHistogram;\nimport com.vmware.xenon.common.TaskState;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.common.http.netty.NettyHttpServiceClient;\nimport com.vmware.xenon.common.serialization.KryoSerializers;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ConsistentHashingNodeSelectorService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.MinimalTestService.MinimalTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.NodeGroupService.JoinPeerRequest;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeGroupService.UpdateQuorumRequest;\nimport com.vmware.xenon.services.common.NodeGroupUtils;\nimport com.vmware.xenon.services.common.NodeState;\nimport com.vmware.xenon.services.common.NodeState.NodeOption;\nimport com.vmware.xenon.services.common.NodeState.NodeStatus;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification.QueryOption;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.QueryValidationTestService.NestedType;\nimport com.vmware.xenon.services.common.QueryValidationTestService.QueryValidationServiceState;\nimport com.vmware.xenon.services.common.ServiceHostLogService.LogServiceState;\nimport com.vmware.xenon.services.common.ServiceHostManagementService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.TaskService;\n\npublic class VerificationHost extends ExampleServiceHost {\n\n    public static final int FAST_MAINT_INTERVAL_MILLIS = 100;\n\n    public static final String LOCATION1 = \"L1\";\n    public static final String LOCATION2 = \"L2\";\n\n    private volatile TestContext context;\n\n    private int timeoutSeconds = 30;\n\n    private long testStartMicros;\n\n    private long testEndMicros;\n\n    private long expectedCompletionCount;\n\n    private Throwable failure;\n\n    private URI referer;\n\n    /**\n     * Command line argument. Comma separated list of one or more peer nodes to join through Nodes\n     * must be defined in URI form, e.g --peerNodes=http://192.168.1.59:8000,http://192.168.1.82\n     */\n    public String[] peerNodes;\n\n    /**\n     * Command line argument indicating this is a stress test\n     */\n    public boolean isStressTest;\n\n    /**\n     * Command line argument indicating this is a multi-location test\n     */\n    public boolean isMultiLocationTest;\n\n    /**\n     * Command line argument for test duration, set for long running tests\n     */\n    public long testDurationSeconds;\n\n    /**\n     * Command line argument\n     */\n    public long maintenanceIntervalMillis = FAST_MAINT_INTERVAL_MILLIS;\n\n    /**\n     * Command line argument\n     */\n    public String connectionTag;\n\n    private String lastTestName;\n\n    private TemporaryFolder temporaryFolder;\n\n    private TestRequestSender sender;\n\n    public static AtomicInteger hostNumber = new AtomicInteger();\n\n    public static VerificationHost create() {\n        return new VerificationHost();\n    }\n\n    public static VerificationHost create(Integer port) throws Exception {\n        ServiceHost.Arguments args = buildDefaultServiceHostArguments(port);\n        return initialize(new VerificationHost(), args);\n    }\n\n    public static ServiceHost.Arguments buildDefaultServiceHostArguments(Integer port) {\n        ServiceHost.Arguments args = new ServiceHost.Arguments();\n        args.id = \"host-\" + hostNumber.incrementAndGet();\n        args.port = port;\n        args.sandbox = null;\n        args.bindAddress = ServiceHost.LOOPBACK_ADDRESS;\n        return args;\n    }\n\n    public static VerificationHost create(ServiceHost.Arguments args)\n            throws Exception {\n        return initialize(new VerificationHost(), args);\n    }\n\n    public static VerificationHost initialize(VerificationHost h, ServiceHost.Arguments args)\n            throws Exception {\n\n        if (args.sandbox == null) {\n            h.setTemporaryFolder(new TemporaryFolder());\n            h.getTemporaryFolder().create();\n            args.sandbox = h.getTemporaryFolder().getRoot().toPath();\n        }\n\n        try {\n            h.initialize(args);\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n\n        h.sender = new TestRequestSender(h);\n        return h;\n    }\n\n    public static void createAndAttachSSLClient(ServiceHost h) throws Throwable {\n        // we create a random userAgent string to validate host to host communication when\n        // the client appears to be from an external, non-Xenon source.\n        ServiceClient client = NettyHttpServiceClient.create(UUID.randomUUID().toString(),\n                null,\n                h.getScheduledExecutor(), h);\n\n        SSLContext clientContext = SSLContext.getInstance(ServiceClient.TLS_PROTOCOL_NAME);\n        clientContext.init(null, InsecureTrustManagerFactory.INSTANCE.getTrustManagers(), null);\n        client.setSSLContext(clientContext);\n        h.setClient(client);\n\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        h.setCertificateFileReference(ssc.certificate().toURI());\n        h.setPrivateKeyFileReference(ssc.privateKey().toURI());\n    }\n\n    @Override\n    protected void configureLoggerFormatter(Logger logger) {\n        super.configureLoggerFormatter(logger);\n\n        // override with formatters for VerificationHost\n        // if custom formatter has already set, do NOT replace it.\n        for (Handler h : logger.getParent().getHandlers()) {\n            if (Objects.equals(h.getFormatter(), LOG_FORMATTER)) {\n                h.setFormatter(VerificationHostLogFormatter.NORMAL_FORMAT);\n            } else if (Objects.equals(h.getFormatter(), COLOR_LOG_FORMATTER)) {\n                h.setFormatter(VerificationHostLogFormatter.COLORED_FORMAT);\n            }\n        }\n    }\n\n    public void tearDown() {\n        stop();\n        TemporaryFolder tempFolder = this.getTemporaryFolder();\n        if (tempFolder != null) {\n            tempFolder.delete();\n        }\n    }\n\n    public Operation createServiceStartPost(TestContext ctx) {\n        Operation post = Operation.createPost(null);\n        post.setUri(UriUtils.buildUri(this, \"service/\" + post.getId()));\n        return post.setCompletion(ctx.getCompletion());\n    }\n\n    public CompletionHandler getCompletion() {\n        return (o, e) -> {\n            if (e != null) {\n                failIteration(e);\n                return;\n            }\n            completeIteration();\n        };\n    }\n\n    public <T> BiConsumer<T, ? super Throwable> getCompletionDeferred() {\n        return (ignore, e) -> {\n            if (e != null) {\n                if (e instanceof CompletionException) {\n                    e = e.getCause();\n                }\n                failIteration(e);\n                return;\n            }\n            completeIteration();\n        };\n    }\n\n    public CompletionHandler getExpectedFailureCompletion() {\n        return getExpectedFailureCompletion(null);\n    }\n\n    public CompletionHandler getExpectedFailureCompletion(Integer statusCode) {\n        return (o, e) -> {\n            if (e == null) {\n                failIteration(new IllegalStateException(\"Failure expected\"));\n                return;\n            }\n\n            if (statusCode != null) {\n                if (!statusCode.equals(o.getStatusCode())) {\n                    failIteration(new IllegalStateException(\n                            \"Expected different status code \"\n                                    + statusCode + \" got \" + o.getStatusCode()));\n                    return;\n                }\n            }\n\n            if (e instanceof TimeoutException) {\n                if (o.getStatusCode() != Operation.STATUS_CODE_TIMEOUT) {\n                    failIteration(new IllegalArgumentException(\n                            \"TImeout exception did not have timeout status code\"));\n                    return;\n                }\n            }\n\n            if (o.hasBody()) {\n                ServiceErrorResponse rsp = o.getBody(ServiceErrorResponse.class);\n                if (rsp.message != null && rsp.message.toLowerCase().contains(\"timeout\")\n                        && rsp.statusCode != Operation.STATUS_CODE_TIMEOUT) {\n                    failIteration(new IllegalArgumentException(\n                            \"Service error response did not have timeout status code:\"\n                                    + Utils.toJsonHtml(rsp)));\n                    return;\n                }\n\n            }\n\n            completeIteration();\n        };\n    }\n\n    public VerificationHost setTimeoutSeconds(int seconds) {\n        this.timeoutSeconds = seconds;\n        if (this.sender != null) {\n            this.sender.setTimeout(Duration.ofSeconds(seconds));\n        }\n        return this;\n    }\n\n    public int getTimeoutSeconds() {\n        return this.timeoutSeconds;\n    }\n\n    public void send(Operation op) {\n        op.setReferer(getReferer());\n        super.sendRequest(op);\n    }\n\n    @Override\n    public DeferredResult<Operation> sendWithDeferredResult(Operation operation) {\n        operation.setReferer(getReferer());\n        return super.sendWithDeferredResult(operation);\n    }\n\n    @Override\n    public <T> DeferredResult<T> sendWithDeferredResult(Operation operation, Class<T> resultType) {\n        operation.setReferer(getReferer());\n        return super.sendWithDeferredResult(operation, resultType);\n    }\n\n    /**\n     * Creates a test wait context that can be nested and isolated from other wait contexts\n     */\n    public TestContext testCreate(int c) {\n        return TestContext.create(c, TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n    }\n\n    /**\n     * Creates a test wait context that can be nested and isolated from other wait contexts\n     */\n    public TestContext testCreate(long c) {\n        return testCreate((int) c);\n    }\n\n    /**\n     * Starts a test context used for a single synchronous test execution for the entire host\n     * @param c Expected completions\n     */\n    public void testStart(long c) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use testCreate on singleton, shared host instances\");\n        }\n        String testName = buildTestNameFromStack();\n        testStart(\n                testName,\n                EnumSet.noneOf(TestProperty.class), c);\n    }\n\n    public String buildTestNameFromStack() {\n        StackTraceElement[] stack = new Exception().getStackTrace();\n        String rootTestMethod = \"\";\n        for (StackTraceElement s : stack) {\n            if (s.getClassName().contains(\"vmware\")) {\n                rootTestMethod = s.getMethodName();\n            }\n        }\n        String testName = rootTestMethod + \":\" + stack[2].getMethodName();\n        return testName;\n    }\n\n    public void testStart(String testName, EnumSet<TestProperty> properties, long c) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        if (this.context != null) {\n            throw new IllegalStateException(\"A test is already started\");\n        }\n\n        String negative = properties != null && properties.contains(TestProperty.FORCE_FAILURE)\n                ? \"(NEGATIVE)\"\n                : \"\";\n        if (c > 1) {\n            log(\"%sTest %s, iterations %d, started\", negative, testName, c);\n        }\n        this.failure = null;\n        this.expectedCompletionCount = c;\n        this.testStartMicros = Utils.getNowMicrosUtc();\n        this.context = TestContext.create((int) c, TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n    }\n\n    public void completeIteration() {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        TestContext ctx = this.context;\n\n        if (ctx == null) {\n            String error = \"testStart() and testWait() not paired properly\" +\n                    \" or testStart(N) was called with N being less than actual completions\";\n            log(error);\n            return;\n        }\n        ctx.completeIteration();\n    }\n\n    public void failIteration(Throwable e) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        if (isStopping()) {\n            log(\"Received completion after stop\");\n            return;\n        }\n\n        TestContext ctx = this.context;\n\n        if (ctx == null) {\n            log(\"Test finished, ignoring completion. This might indicate wrong count was used in testStart(count)\");\n            return;\n        }\n\n        log(\"test failed: %s\", e.toString());\n        ctx.failIteration(e);\n    }\n\n    public void testWait(TestContext ctx) {\n        ctx.await();\n    }\n\n    public void testWait() {\n        testWait(new Exception().getStackTrace()[1].getMethodName(),\n                this.timeoutSeconds);\n    }\n\n    public void testWait(int timeoutSeconds) {\n        testWait(new Exception().getStackTrace()[1].getMethodName(), timeoutSeconds);\n    }\n\n    public void testWait(String testName, int timeoutSeconds) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n\n        TestContext ctx = this.context;\n        if (ctx == null) {\n            throw new IllegalStateException(\"testStart() was not called before testWait()\");\n        }\n\n        if (this.expectedCompletionCount > 1) {\n            log(\"Test %s, iterations %d, waiting ...\", testName,\n                    this.expectedCompletionCount);\n        }\n\n        try {\n            ctx.await();\n            this.testEndMicros = Utils.getNowMicrosUtc();\n            if (this.expectedCompletionCount > 1) {\n                log(\"Test %s, iterations %d, complete!\", testName,\n                        this.expectedCompletionCount);\n            }\n        } finally {\n            this.context = null;\n            this.lastTestName = testName;\n        }\n    }\n\n    public double calculateThroughput() {\n        double t = this.testEndMicros - this.testStartMicros;\n        t /= 1000000.0;\n        t = this.expectedCompletionCount / t;\n        return t;\n    }\n\n    public long computeIterationsFromMemory(int serviceCount) {\n        return computeIterationsFromMemory(EnumSet.noneOf(TestProperty.class), serviceCount);\n    }\n\n    public long computeIterationsFromMemory(EnumSet<TestProperty> props, int serviceCount) {\n        long total = Runtime.getRuntime().totalMemory();\n\n        total /= 512;\n        total /= serviceCount;\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        if (props.contains(TestProperty.FORCE_REMOTE)) {\n            total /= 5;\n        }\n\n        if (props.contains(TestProperty.PERSISTED)) {\n            total /= 5;\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)\n                || props.contains(TestProperty.EXPECT_FAILURE)) {\n            total = 10;\n        }\n\n        if (!this.isStressTest) {\n            total /= 100;\n            total = Math.max(Runtime.getRuntime().availableProcessors() * 16, total);\n        }\n        total = Math.max(1, total);\n\n        if (props.contains(TestProperty.SINGLE_ITERATION)) {\n            total = 1;\n        }\n\n        return total;\n    }\n\n    public void logThroughput() {\n        log(\"Test %s iterations per second: %f\", this.lastTestName, calculateThroughput());\n        logMemoryInfo();\n    }\n\n    public void log(String fmt, Object... args) {\n        super.log(Level.INFO, 3, fmt, args);\n    }\n\n    public ServiceDocument buildMinimalTestState() {\n        return buildMinimalTestState(20);\n    }\n\n    public MinimalTestServiceState buildMinimalTestState(int bytes) {\n        MinimalTestServiceState minState = new MinimalTestServiceState();\n        minState.id = Utils.getNowMicrosUtc() + \"\";\n        byte[] body = new byte[bytes];\n        new Random().nextBytes(body);\n        minState.stringValue = DatatypeConverter.printBase64Binary(body);\n        return minState;\n    }\n\n    public CompletableFuture<Operation> sendWithFuture(Operation op) {\n        if (op.getCompletion() != null) {\n            throw new IllegalStateException(\"completion handler must not be set\");\n        }\n\n        CompletableFuture<Operation> res = new CompletableFuture<>();\n        op.setCompletion((o, e) -> {\n            if (e != null) {\n                res.completeExceptionally(e);\n            } else {\n                res.complete(o);\n            }\n        });\n\n        this.send(op);\n\n        return res;\n    }\n\n    /**\n     * Use built in Java synchronous HTTP client to verify DCP HttpListener is compliant\n     */\n    public String sendWithJavaClient(URI serviceUri, String contentType, String body)\n            throws IOException {\n        URL url = serviceUri.toURL();\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setDoInput(true);\n\n        connection.addRequestProperty(Operation.CONTENT_TYPE_HEADER, contentType);\n        if (body != null) {\n            connection.setDoOutput(true);\n            connection.getOutputStream().write(body.getBytes(Utils.CHARSET));\n        }\n\n        BufferedReader in = null;\n        try {\n            try {\n                in = new BufferedReader(\n                        new InputStreamReader(\n                                connection.getInputStream(), Utils.CHARSET));\n\n            } catch (Throwable e) {\n                InputStream errorStream = connection.getErrorStream();\n                if (errorStream != null) {\n                    in = new BufferedReader(\n                            new InputStreamReader(errorStream, Utils.CHARSET));\n                }\n            }\n            StringBuilder stringResponseBuilder = new StringBuilder();\n\n            if (in == null) {\n                return \"\";\n            }\n            do {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                stringResponseBuilder.append(line);\n            } while (true);\n\n            return stringResponseBuilder.toString();\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    public URI createQueryTaskService(QueryTask create) {\n        return createQueryTaskService(create, false);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote) {\n        return createQueryTaskService(create, forceRemote, false, null, null);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote, String sourceLink) {\n        return createQueryTaskService(create, forceRemote, false, null, sourceLink);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote, boolean isDirect,\n            QueryTask taskResult,\n            String sourceLink) {\n        return createQueryTaskService(null, create, forceRemote, isDirect, taskResult, sourceLink);\n    }\n\n    public URI createQueryTaskService(URI factoryUri, QueryTask create, boolean forceRemote,\n            boolean isDirect,\n            QueryTask taskResult,\n            String sourceLink) {\n\n        if (create.documentExpirationTimeMicros == 0) {\n            create.documentExpirationTimeMicros = Utils.getNowMicrosUtc()\n                    + this.getOperationTimeoutMicros();\n        }\n\n        if (factoryUri == null) {\n            VerificationHost h = this;\n            if (!getInProcessHostMap().isEmpty()) {\n                // pick one host to create the query task\n                h = getInProcessHostMap().values().iterator().next();\n            }\n            factoryUri = UriUtils.buildUri(h, ServiceUriPaths.CORE_QUERY_TASKS);\n        }\n        create.documentSelfLink = UUID.randomUUID().toString();\n        create.documentSourceLink = sourceLink;\n        create.taskInfo.isDirect = isDirect;\n        Operation startPost = Operation.createPost(factoryUri).setBody(create);\n\n        if (forceRemote) {\n            startPost.forceRemote();\n        }\n\n        log(\"Starting query with options:%s, resultLimit: %d\",\n                create.querySpec.options,\n                create.querySpec.resultLimit);\n\n        QueryTask result;\n        try {\n            result = this.sender.sendAndWait(startPost, QueryTask.class);\n        } catch (RuntimeException e) {\n            // throw original exception\n            throw ExceptionTestUtils.throwAsUnchecked(e.getSuppressed()[0]);\n        }\n\n        if (isDirect) {\n            taskResult.results = result.results;\n            taskResult.taskInfo.durationMicros = result.results.queryTimeMicros;\n        }\n\n        return UriUtils.extendUri(factoryUri, create.documentSelfLink);\n    }\n\n    public QueryTask waitForQueryTaskCompletion(QuerySpecification q, int totalDocuments,\n            int versionCount, URI u, boolean forceRemote, boolean deleteOnFinish) {\n        return waitForQueryTaskCompletion(q, totalDocuments, versionCount, u, forceRemote,\n                deleteOnFinish, true);\n    }\n\n    public boolean isOwner(String documentSelfLink, String nodeSelector) {\n        final boolean[] isOwner = new boolean[1];\n        TestContext ctx = this.testCreate(1);\n        Operation op = Operation\n                .createPost(null)\n                .setExpiration(Utils.getNowMicrosUtc() + TimeUnit.SECONDS.toMicros(10))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx.failIteration(e);\n                        return;\n                    }\n\n                    NodeSelectorService.SelectOwnerResponse rsp =\n                            o.getBody(NodeSelectorService.SelectOwnerResponse.class);\n                    isOwner[0] = rsp.isLocalHostOwner;\n                    ctx.completeIteration();\n                });\n        this.selectOwner(nodeSelector, documentSelfLink, op);\n        ctx.await();\n\n        return isOwner[0];\n    }\n\n    public QueryTask waitForQueryTaskCompletion(QuerySpecification q, int totalDocuments,\n            int versionCount, URI u, boolean forceRemote, boolean deleteOnFinish,\n            boolean throwOnFailure) {\n\n        long startNanos = System.nanoTime();\n        if (q.options == null) {\n            q.options = EnumSet.noneOf(QueryOption.class);\n        }\n\n        EnumSet<TestProperty> props = EnumSet.noneOf(TestProperty.class);\n        if (forceRemote) {\n            props.add(TestProperty.FORCE_REMOTE);\n        }\n        waitFor(\"Query did not complete in time\", () -> {\n            QueryTask taskState = getServiceState(props, QueryTask.class, u);\n            return taskState.taskInfo.stage == TaskState.TaskStage.FINISHED\n                    || taskState.taskInfo.stage == TaskState.TaskStage.FAILED\n                    || taskState.taskInfo.stage == TaskState.TaskStage.CANCELLED;\n        });\n\n        QueryTask latestTaskState = getServiceState(props, QueryTask.class, u);\n\n        // Throw if task was expected to be successful\n        if (throwOnFailure && (latestTaskState.taskInfo.stage == TaskState.TaskStage.FAILED)) {\n            throw new IllegalStateException(Utils.toJsonHtml(latestTaskState.taskInfo.failure));\n        }\n\n        if (totalDocuments * versionCount > 1) {\n            long endNanos = System.nanoTime();\n            double deltaSeconds = endNanos - startNanos;\n            deltaSeconds /= TimeUnit.SECONDS.toNanos(1);\n            double thpt = totalDocuments / deltaSeconds;\n            log(\"Options: %s.  Throughput (documents / sec): %f\", q.options.toString(), thpt);\n        }\n\n        // Delete task, if not direct\n        if (latestTaskState.taskInfo.isDirect) {\n            return latestTaskState;\n        }\n\n        if (deleteOnFinish) {\n            send(Operation.createDelete(u).setBody(new ServiceDocument()));\n        }\n\n        return latestTaskState;\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(\n            String fieldName, String fieldValue, long documentCount, long expectedResultCount) {\n        return createAndWaitSimpleDirectQuery(this.getUri(), fieldName, fieldValue, documentCount,\n                expectedResultCount);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(URI hostUri,\n            String fieldName, String fieldValue, long documentCount, long expectedResultCount) {\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(fieldName).setTermMatchValue(fieldValue);\n        return createAndWaitSimpleDirectQuery(hostUri, q,\n                documentCount, expectedResultCount);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(\n            QueryTask.QuerySpecification spec,\n            long documentCount, long expectedResultCount) {\n        return createAndWaitSimpleDirectQuery(this.getUri(), spec,\n                documentCount, expectedResultCount);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(URI hostUri,\n            QueryTask.QuerySpecification spec, long documentCount, long expectedResultCount) {\n        long start = Utils.getNowMicrosUtc();\n\n        QueryTask[] tasks = new QueryTask[1];\n        waitFor(\"\", () -> {\n            QueryTask task = QueryTask.create(spec).setDirect(true);\n            createQueryTaskService(UriUtils.buildUri(hostUri, ServiceUriPaths.CORE_QUERY_TASKS),\n                    task, false, true, task, null);\n            if (task.results.documentLinks.size() == expectedResultCount) {\n                tasks[0] = task;\n                return true;\n            }\n            log(\"Expected %d, got %d, Query task: %s\", expectedResultCount,\n                    task.results.documentLinks.size(), task);\n            return false;\n        });\n\n        QueryTask resultTask = tasks[0];\n\n        assertTrue(\n                String.format(\"Got %d links, expected %d\", resultTask.results.documentLinks.size(),\n                        expectedResultCount),\n                resultTask.results.documentLinks.size() == expectedResultCount);\n        long end = Utils.getNowMicrosUtc();\n        double delta = (end - start) / 1000000.0;\n        double thpt = documentCount / delta;\n        log(\"Document count: %d, Expected match count: %d, Documents / sec: %f\",\n                documentCount, expectedResultCount, thpt);\n        return resultTask.results;\n    }\n\n    public void validatePermanentServiceDocumentDeletion(String linkPrefix, long count,\n            boolean failOnMismatch)\n            throws Throwable {\n        long start = Utils.getNowMicrosUtc();\n\n        while (Utils.getNowMicrosUtc() - start < this.getOperationTimeoutMicros()) {\n            QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n            q.query = new QueryTask.Query()\n                    .setTermPropertyName(ServiceDocument.FIELD_NAME_SELF_LINK)\n                    .setTermMatchType(MatchType.WILDCARD)\n                    .setTermMatchValue(linkPrefix + UriUtils.URI_WILDCARD_CHAR);\n\n            URI u = createQueryTaskService(QueryTask.create(q), false);\n            QueryTask finishedTaskState = waitForQueryTaskCompletion(q,\n                    (int) count, (int) count, u, false, true);\n            if (finishedTaskState.results.documentLinks.size() == count) {\n                return;\n            }\n            log(\"got %d links back, expected %d: %s\",\n                    finishedTaskState.results.documentLinks.size(), count,\n                    Utils.toJsonHtml(finishedTaskState));\n\n            if (!failOnMismatch) {\n                return;\n            }\n            Thread.sleep(100);\n        }\n        if (failOnMismatch) {\n            throw new TimeoutException();\n        }\n    }\n\n    public String sendHttpRequest(ServiceClient client, String uri, String requestBody, int count) {\n\n        Object[] rspBody = new Object[1];\n        TestContext ctx = testCreate(count);\n        Operation op = Operation.createGet(URI.create(uri)).setCompletion(\n                (o, e) -> {\n                    if (e != null) {\n                        ctx.failIteration(e);\n                        return;\n                    }\n                    rspBody[0] = o.getBodyRaw();\n                    ctx.completeIteration();\n                });\n\n        if (requestBody != null) {\n            op.setAction(Action.POST).setBody(requestBody);\n        }\n\n        op.setExpiration(Utils.getNowMicrosUtc() + getOperationTimeoutMicros());\n        op.setReferer(getReferer());\n        ServiceClient c = client != null ? client : getClient();\n        for (int i = 0; i < count; i++) {\n            c.send(op);\n        }\n        ctx.await();\n\n        String htmlResponse = (String) rspBody[0];\n        return htmlResponse;\n    }\n\n    public Operation sendUIHttpRequest(String uri, String requestBody, int count) {\n        Operation op = Operation.createGet(URI.create(uri));\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            ops.add(op);\n        }\n        List<Operation> responses = this.sender.sendAndWait(ops);\n        return responses.get(0);\n    }\n\n    public <T extends ServiceDocument> T getServiceState(EnumSet<TestProperty> props, Class<T> type,\n            URI uri) {\n        Map<URI, T> r = getServiceState(props, type, new URI[] { uri });\n        return r.values().iterator().next();\n    }\n\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type,\n            Collection<URI> uris) {\n        URI[] array = new URI[uris.size()];\n        int i = 0;\n        for (URI u : uris) {\n            array[i++] = u;\n        }\n        return getServiceState(props, type, array);\n    }\n\n    public <T extends TaskService.TaskServiceState> T getServiceStateUsingQueryTask(\n            Class<T> type, String uri) {\n        QueryTask.Query q = QueryTask.Query.Builder.create()\n                .setTerm(ServiceDocument.FIELD_NAME_SELF_LINK, uri)\n                .build();\n\n        QueryTask queryTask = new QueryTask();\n        queryTask.querySpec = new QueryTask.QuerySpecification();\n        queryTask.querySpec.query = q;\n        queryTask.querySpec.options.add(QueryOption.EXPAND_CONTENT);\n\n        this.createQueryTaskService(null, queryTask, false, true, queryTask, null);\n        return Utils.fromJson(queryTask.results.documents.get(uri), type);\n    }\n\n    /**\n     * Retrieve in parallel, state from N services. This method will block execution until responses\n     * are received or a failure occurs. It is not optimized for throughput measurements\n     *\n     * @param type\n     * @param uris\n     */\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type, URI... uris) {\n\n        if (type == null) {\n            throw new IllegalArgumentException(\"type is required\");\n        }\n\n        if (uris == null || uris.length == 0) {\n            throw new IllegalArgumentException(\"uris are required\");\n        }\n\n        List<Operation> ops = new ArrayList<>();\n        for (URI u : uris) {\n            Operation get = Operation.createGet(u).setReferer(getReferer());\n            if (props != null && props.contains(TestProperty.FORCE_REMOTE)) {\n                get.forceRemote();\n            }\n            if (props != null && props.contains(TestProperty.HTTP2)) {\n                get.setConnectionSharing(true);\n            }\n\n            if (props != null && props.contains(TestProperty.DISABLE_CONTEXT_ID_VALIDATION)) {\n                get.setContextId(TestProperty.DISABLE_CONTEXT_ID_VALIDATION.toString());\n            }\n\n            ops.add(get);\n        }\n\n        Map<URI, T> results = new HashMap<>();\n\n        List<Operation> responses = this.sender.sendAndWait(ops);\n        for (Operation response : responses) {\n            T doc = response.getBody(type);\n            results.put(UriUtils.buildUri(response.getUri(), doc.documentSelfLink), doc);\n        }\n\n        return results;\n    }\n\n    /**\n     * Retrieve in parallel, state from N services. This method will block execution until responses\n     * are received or a failure occurs. It is not optimized for throughput measurements\n     */\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type,\n            List<Service> services) {\n        URI[] uris = new URI[services.size()];\n        int i = 0;\n        for (Service s : services) {\n            uris[i++] = s.getUri();\n        }\n        return this.getServiceState(props, type, uris);\n    }\n\n    public ServiceDocumentQueryResult getFactoryState(URI factoryUri) {\n        return this.getServiceState(null, ServiceDocumentQueryResult.class, factoryUri);\n    }\n\n    public ServiceDocumentQueryResult getExpandedFactoryState(URI factoryUri) {\n        factoryUri = UriUtils.buildExpandLinksQueryUri(factoryUri);\n        return this.getServiceState(null, ServiceDocumentQueryResult.class, factoryUri);\n    }\n\n    public Map<String, ServiceStat> getServiceStats(URI serviceUri) {\n        AuthorizationContext ctx = null;\n        if (this.isAuthorizationEnabled()) {\n            ctx = OperationContext.getAuthorizationContext();\n            this.setSystemAuthorizationContext();\n        }\n        ServiceStats stats = this.getServiceState(\n                null, ServiceStats.class, UriUtils.buildStatsUri(serviceUri));\n        if (this.isAuthorizationEnabled()) {\n            this.setAuthorizationContext(ctx);\n        }\n        return stats.entries;\n    }\n\n    public void doExampleServiceUpdateAndQueryByVersion(URI hostUri, int serviceCount) {\n        Consumer<Operation> bodySetter = (o) -> {\n            ExampleServiceState s = new ExampleServiceState();\n            s.name = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> services = doFactoryChildServiceStart(null,\n                serviceCount,\n                ExampleServiceState.class, bodySetter,\n                UriUtils.buildUri(hostUri, ExampleService.FACTORY_LINK));\n\n        Map<URI, ExampleServiceState> statesBeforeUpdate = getServiceState(null,\n                ExampleServiceState.class, services.keySet());\n\n        for (ExampleServiceState state : statesBeforeUpdate.values()) {\n            assertEquals(state.documentVersion, 0);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, null,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 1L,\n                    null);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 10L,\n                    null);\n        }\n\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        doServiceUpdates(services.keySet(), Action.PUT, body);\n        Map<URI, ExampleServiceState> statesAfterPut = getServiceState(null,\n                ExampleServiceState.class, services.keySet());\n\n        for (ExampleServiceState state : statesAfterPut.values()) {\n            assertEquals(state.documentVersion, 1);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 1L,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, null,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 10L,\n                    null);\n        }\n\n        doServiceUpdates(services.keySet(), Action.DELETE, body);\n\n        for (ExampleServiceState state : statesAfterPut.values()) {\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 1L,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE, 2L,\n                    2L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE,\n                    null, 2L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE,\n                    10L, null);\n        }\n    }\n\n    private void doServiceUpdates(Collection<URI> serviceUris, Action action,\n            ServiceDocument body) {\n        List<Operation> ops = new ArrayList<>();\n        for (URI u : serviceUris) {\n            Operation update = Operation.createPost(u)\n                    .setAction(action)\n                    .setBody(body);\n            ops.add(update);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    private void queryDocumentIndexByVersionAndVerify(URI hostUri, String selfLink,\n            Action expectedAction,\n            Long version,\n            Long latestVersion) {\n\n        URI localQueryUri = UriUtils.buildDefaultDocumentQueryUri(\n                hostUri,\n                selfLink,\n                false,\n                true,\n                ServiceOption.PERSISTENCE);\n\n        if (version != null) {\n            localQueryUri = UriUtils.appendQueryParam(localQueryUri,\n                    ServiceDocument.FIELD_NAME_VERSION,\n                    Long.toString(version));\n        }\n\n        Operation remoteGet = Operation.createGet(localQueryUri);\n        Operation result = this.sender.sendAndWait(remoteGet);\n        if (latestVersion == null) {\n            assertFalse(\"Document not expected\", result.hasBody());\n            return;\n        }\n\n        ServiceDocument doc = result.getBody(ServiceDocument.class);\n        int expectedVersion = version == null ? latestVersion.intValue() : version.intValue();\n        assertEquals(\"Invalid document version returned\", doc.documentVersion, expectedVersion);\n\n        String action = doc.documentUpdateAction;\n        assertEquals(\"Invalid document update action returned:\" + action, expectedAction.name(),\n                action);\n\n    }\n\n    public <T> void doPutPerService(List<Service> services)\n            throws Throwable {\n        doPutPerService(EnumSet.noneOf(TestProperty.class), services);\n    }\n\n    public <T> void doPutPerService(EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        doPutPerService(computeIterationsFromMemory(properties, services.size()),\n                properties,\n                services);\n    }\n\n    public <T> void doPatchPerService(long count,\n            EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        doServiceUpdates(Action.PATCH, count, properties, services);\n    }\n\n    public <T> void doPutPerService(long count, EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        doServiceUpdates(Action.PUT, count, properties, services);\n    }\n\n    public void doServiceUpdates(Action action, long count,\n            EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n\n        if (properties == null) {\n            properties = EnumSet.noneOf(TestProperty.class);\n        }\n\n        logMemoryInfo();\n        StackTraceElement[] e = new Exception().getStackTrace();\n        String testName = String.format(\n                \"Parent: %s, %s test with properties %s, service caps: %s\",\n                e[1].getMethodName(),\n                action, properties.toString(), services.get(0).getOptions());\n\n        Map<URI, MinimalTestServiceState> statesBeforeUpdate = getServiceState(properties,\n                MinimalTestServiceState.class, services);\n\n\n        long startTimeMicros = System.nanoTime() / 1000;\n        TestContext ctx = testCreate(count * services.size());\n        ctx.setTestName(testName);\n        ctx.logBefore();\n\n        // create a template PUT. Each operation instance is cloned on send, so\n        // we can re-use across services\n        Operation updateOp = Operation.createPut(null).setCompletion(ctx.getCompletion());\n\n        updateOp.setAction(action);\n\n        if (properties.contains(TestProperty.FORCE_REMOTE)) {\n            updateOp.forceRemote();\n        }\n        MinimalTestServiceState body = (MinimalTestServiceState) buildMinimalTestState();\n        byte[] binaryBody = null;\n\n        // put random values in core document properties to verify they are\n        // ignored\n        if (!this.isStressTest()) {\n            body.documentSelfLink = UUID.randomUUID().toString();\n            body.documentKind = UUID.randomUUID().toString();\n        } else {\n            body.stringValue = UUID.randomUUID().toString();\n            body.id = UUID.randomUUID().toString();\n            body.responseDelay = 10;\n            body.documentVersion = 10;\n            body.documentEpoch = 10L;\n            body.documentOwner = UUID.randomUUID().toString();\n        }\n\n        if (properties.contains(TestProperty.SET_EXPIRATION)) {\n            // set expiration to the maintenance interval, which should already be very small\n            // when the caller sets this test property\n            body.documentExpirationTimeMicros = Utils.getNowMicrosUtc()\n                    + this.getMaintenanceIntervalMicros();\n        }\n\n        final int maxByteCount = 256 * 1024;\n        if (properties.contains(TestProperty.LARGE_PAYLOAD)) {\n            Random r = new Random();\n            int byteCount = getClient().getRequestPayloadSizeLimit() / 4;\n            if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n                if (properties.contains(TestProperty.FORCE_FAILURE)) {\n                    byteCount = getClient().getRequestPayloadSizeLimit() * 2;\n                } else {\n                    // make sure we do not blow memory if max request size is high\n                    byteCount = Math.min(maxByteCount, byteCount);\n                }\n            } else {\n                byteCount = maxByteCount;\n            }\n            byte[] data = new byte[byteCount];\n            r.nextBytes(data);\n            if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n                binaryBody = data;\n            } else {\n                body.stringValue = printBase64Binary(data);\n            }\n        }\n\n        if (properties.contains(TestProperty.HTTP2)) {\n            updateOp.setConnectionSharing(true);\n        }\n\n        if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n            updateOp.setContentType(Operation.MEDIA_TYPE_APPLICATION_OCTET_STREAM);\n            updateOp.setCompletion((o, eb) -> {\n                if (eb != null) {\n                    ctx.fail(eb);\n                    return;\n                }\n\n                if (!Operation.MEDIA_TYPE_APPLICATION_OCTET_STREAM.equals(o.getContentType())) {\n                    ctx.fail(new IllegalArgumentException(\"unexpected content type: \"\n                            + o.getContentType()));\n                    return;\n                }\n                ctx.complete();\n            });\n\n        }\n\n        boolean isFailureExpected = false;\n        if (properties.contains(TestProperty.FORCE_FAILURE)\n                || properties.contains(TestProperty.EXPECT_FAILURE)) {\n            toggleNegativeTestMode(true);\n            isFailureExpected = true;\n\n            if (properties.contains(TestProperty.LARGE_PAYLOAD)) {\n                updateOp.setCompletion((o, ex) -> {\n                    if (ex == null) {\n                        ctx.fail(new IllegalStateException(\"expected failure\"));\n                    } else {\n                        ctx.complete();\n                    }\n                });\n            } else {\n                updateOp.setCompletion((o, ex) -> {\n                    if (ex == null) {\n                        ctx.fail(new IllegalStateException(\"failure expected\"));\n                        return;\n                    }\n\n                    MinimalTestServiceErrorResponse rsp = o\n                            .getBody(MinimalTestServiceErrorResponse.class);\n                    if (!MinimalTestServiceErrorResponse.KIND.equals(rsp.documentKind)) {\n                        ctx.fail(new IllegalStateException(\"Response not expected:\"\n                                + Utils.toJson(rsp)));\n                        return;\n                    }\n                    ctx.complete();\n                });\n            }\n        }\n\n        int byteCount = Utils.toJson(body).getBytes(Utils.CHARSET).length;\n        if (properties.contains(TestProperty.BINARY_SERIALIZATION)) {\n            long c = KryoSerializers.serializeDocument(body, 4096).position();\n            byteCount = (int) c;\n        }\n        log(\"Bytes per payload %s\", byteCount);\n\n        boolean isConcurrentSend = properties.contains(TestProperty.CONCURRENT_SEND);\n        final boolean isFailureExpectedFinal = isFailureExpected;\n\n        for (Service s : services) {\n            if (properties.contains(TestProperty.FORCE_REMOTE)) {\n                updateOp.setConnectionTag(this.connectionTag);\n            }\n\n            long[] expectedVersion = new long[1];\n            if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                // we have to serialize requests and properly set version to match expected current\n                // version\n                MinimalTestServiceState initialState = statesBeforeUpdate.get(s.getUri());\n                expectedVersion[0] = isFailureExpected ? Integer.MAX_VALUE\n                        : initialState.documentVersion;\n            }\n\n            URI sUri = s.getUri();\n            updateOp.setUri(sUri).setReferer(getReferer());\n\n            for (int i = 0; i < count; i++) {\n                if (!isFailureExpected) {\n                    body.id = \"\" + i;\n                } else if (!properties.contains(TestProperty.LARGE_PAYLOAD)) {\n                    body.id = null;\n                }\n\n                CountDownLatch[] l = new CountDownLatch[1];\n                if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                    // only used for strict update checking, serialized requests\n                    l[0] = new CountDownLatch(1);\n                    // we have to serialize requests and properly set version\n                    body.documentVersion = expectedVersion[0];\n                    updateOp.setCompletion((o, ex) -> {\n                        if (ex == null || isFailureExpectedFinal) {\n                            MinimalTestServiceState rsp = o.getBody(MinimalTestServiceState.class);\n                            expectedVersion[0] = rsp.documentVersion;\n                            ctx.complete();\n                            l[0].countDown();\n                            return;\n                        }\n                        ctx.fail(ex);\n                        l[0].countDown();\n                    });\n                }\n\n                Object b = binaryBody != null ? binaryBody : body;\n                if (properties.contains(TestProperty.BINARY_SERIALIZATION)) {\n                    // provide hints to runtime on how to serialize the body,\n                    // using binary serialization and a buffer size equal to content length\n                    updateOp.setContentLength(byteCount);\n                    updateOp.setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM);\n                }\n\n                if (isConcurrentSend) {\n                    Operation putClone = updateOp.clone();\n                    putClone.setBody(b).setUri(sUri);\n                    run(() -> {\n                        send(putClone);\n                    });\n                } else if (properties.contains(TestProperty.CALLBACK_SEND)) {\n                    updateOp.toggleOption(OperationOption.SEND_WITH_CALLBACK, true);\n                    send(updateOp.setBody(b));\n                } else {\n                    send(updateOp.setBody(b));\n                }\n                if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                    // we have to serialize requests and properly set version\n                    if (!isFailureExpected) {\n                        l[0].await();\n                    }\n                    if (this.failure != null) {\n                        throw this.failure;\n                    }\n\n                }\n            }\n        }\n\n        testWait(ctx);\n        ctx.logAfter();\n\n        if (isFailureExpected) {\n            this.toggleNegativeTestMode(false);\n            return;\n        }\n\n        if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n            return;\n        }\n\n        List<URI> getUris = new ArrayList<>();\n        if (services.get(0).hasOption(ServiceOption.PERSISTENCE)) {\n            for (Service s : services) {\n                // bypass the services, which rely on caching, and go straight to the index\n                URI u = UriUtils.buildDocumentQueryUri(this, s.getSelfLink(), true, false,\n                        ServiceOption.PERSISTENCE);\n                getUris.add(u);\n\n            }\n        } else {\n            for (Service s : services) {\n                getUris.add(s.getUri());\n            }\n        }\n\n        Map<URI, MinimalTestServiceState> statesAfterUpdate = getServiceState(\n                properties,\n                MinimalTestServiceState.class, getUris);\n\n        for (MinimalTestServiceState st : statesAfterUpdate.values()) {\n            URI serviceUri = UriUtils.buildUri(this, st.documentSelfLink);\n            ServiceDocument beforeSt = statesBeforeUpdate.get(serviceUri);\n            long expectedVersion = beforeSt.documentVersion + count;\n            if (st.documentVersion != expectedVersion) {\n                QueryTestUtils.logVersionInfoForService(this.sender, serviceUri, expectedVersion);\n                throw new IllegalStateException(\"got \" + st.documentVersion + \", expected \"\n                        + (beforeSt.documentVersion + count));\n            }\n            assertTrue(st.documentVersion == beforeSt.documentVersion + count);\n            assertTrue(st.id != null);\n            assertTrue(st.documentSelfLink != null\n                    && st.documentSelfLink.equals(beforeSt.documentSelfLink));\n            assertTrue(st.documentKind != null\n                    && st.documentKind.equals(Utils.buildKind(MinimalTestServiceState.class)));\n            assertTrue(st.documentUpdateTimeMicros > startTimeMicros);\n            assertTrue(st.documentUpdateAction != null);\n            assertTrue(st.documentUpdateAction.equals(action.toString()));\n        }\n\n        logMemoryInfo();\n\n    }\n\n    public void logMemoryInfo() {\n        log(\"Memory free:%d, available:%s, total:%s\", Runtime.getRuntime().freeMemory(),\n                Runtime.getRuntime().totalMemory(),\n                Runtime.getRuntime().maxMemory());\n    }\n\n    public URI getReferer() {\n        if (this.referer == null) {\n            this.referer = getUri();\n        }\n        return this.referer;\n    }\n\n    public void waitForServiceAvailable(String... links) {\n        for (String link : links) {\n            TestContext ctx = testCreate(1);\n            this.registerForServiceAvailability(ctx.getCompletion(), link);\n            ctx.await();\n        }\n    }\n\n    public void waitForReplicatedFactoryServiceAvailable(URI u) {\n        waitForReplicatedFactoryServiceAvailable(u, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n    }\n\n    public void waitForReplicatedFactoryServiceAvailable(URI u, String nodeSelectorPath) {\n        waitFor(\"replicated available check time out for \" + u, () -> {\n            boolean[] isReady = new boolean[1];\n            TestContext ctx = testCreate(1);\n            NodeGroupUtils.checkServiceAvailability((o, e) -> {\n                if (e != null) {\n                    isReady[0] = false;\n                    ctx.completeIteration();\n                    return;\n                }\n\n                isReady[0] = true;\n                ctx.completeIteration();\n            }, this, u, nodeSelectorPath);\n            ctx.await();\n            return isReady[0];\n        });\n    }\n\n    public void waitForServiceAvailable(URI u) {\n        boolean[] isReady = new boolean[1];\n        log(\"Starting /available check on %s\", u);\n        waitFor(\"available check timeout for \" + u, () -> {\n            TestContext ctx = testCreate(1);\n            URI available = UriUtils.buildAvailableUri(u);\n            Operation get = Operation.createGet(available).setCompletion((o, e) -> {\n                if (e != null) {\n                    // not ready\n                    isReady[0] = false;\n                    ctx.completeIteration();\n                    return;\n                }\n                isReady[0] = true;\n                ctx.completeIteration();\n                return;\n            });\n            send(get);\n            ctx.await();\n\n            if (isReady[0]) {\n                log(\"%s /available returned success\", get.getUri());\n                return true;\n            }\n            return false;\n        });\n    }\n\n    public <T extends ServiceDocument> Map<URI, T> doFactoryChildServiceStart(\n            EnumSet<TestProperty> props,\n            long c,\n            Class<T> bodyType,\n            Consumer<Operation> setInitialStateConsumer,\n            URI factoryURI) {\n        Map<URI, T> initialStates = new HashMap<>();\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        log(\"Sending %d POST requests to %s\", c, factoryURI);\n\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            Operation createPost = Operation.createPost(factoryURI);\n            // call callback to set the body\n            setInitialStateConsumer.accept(createPost);\n            if (props.contains(TestProperty.FORCE_REMOTE)) {\n                createPost.forceRemote();\n            }\n\n            ops.add(createPost);\n        }\n\n        List<T> responses = this.sender.sendAndWait(ops, bodyType);\n        Map<URI, T> docByChildURI = responses.stream().collect(\n                toMap(doc -> UriUtils.buildUri(factoryURI, doc.documentSelfLink), identity()));\n        initialStates.putAll(docByChildURI);\n        log(\"Done with %d POST requests to %s\", c, factoryURI);\n        return initialStates;\n    }\n\n    public List<Service> doThroughputServiceStart(long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove) throws Throwable {\n        return doThroughputServiceStart(EnumSet.noneOf(TestProperty.class), c, type, initialState,\n                options, null);\n    }\n\n    public List<Service> doThroughputServiceStart(\n            EnumSet<TestProperty> props,\n            long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove) throws Throwable {\n        return doThroughputServiceStart(props, c, type, initialState,\n                options, optionsToRemove, null);\n    }\n\n    public List<Service> doThroughputServiceStart(\n            EnumSet<TestProperty> props,\n            long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove,\n            Long maintIntervalMicros) throws Throwable {\n\n        List<Service> services = new ArrayList<>();\n\n        TestContext ctx = testCreate((int) c);\n        for (int i = 0; i < c; i++) {\n            Service e = type.newInstance();\n            if (options != null) {\n                for (Service.ServiceOption cap : options) {\n                    e.toggleOption(cap, true);\n                }\n            }\n            if (optionsToRemove != null) {\n                for (ServiceOption opt : optionsToRemove) {\n                    e.toggleOption(opt, false);\n                }\n            }\n\n            Operation post = createServiceStartPost(ctx);\n            if (initialState != null) {\n                post.setBody(initialState);\n            }\n\n            if (props != null && props.contains(TestProperty.SET_CONTEXT_ID)) {\n                post.setContextId(TestProperty.SET_CONTEXT_ID.toString());\n            }\n\n            if (maintIntervalMicros != null) {\n                e.setMaintenanceIntervalMicros(maintIntervalMicros);\n            }\n\n            startService(post, e);\n            services.add(e);\n        }\n        ctx.await();\n        logThroughput();\n        return services;\n    }\n\n    public Service startServiceAndWait(Class<? extends Service> serviceType,\n            String uriPath)\n            throws Throwable {\n        return startServiceAndWait(serviceType.newInstance(), uriPath, null);\n    }\n\n    public Service startServiceAndWait(Service s,\n            String uriPath,\n            ServiceDocument body)\n            throws Throwable {\n        TestContext ctx = testCreate(1);\n        URI u = null;\n        if (uriPath != null) {\n            u = UriUtils.buildUri(this, uriPath);\n        }\n\n        Operation post = Operation\n                .createPost(u)\n                .setBody(body)\n                .setCompletion(ctx.getCompletion());\n\n        startService(post, s);\n        ctx.await();\n        return s;\n    }\n\n    public <T extends ServiceDocument> void doServiceRestart(List<Service> services,\n            Class<T> stateType,\n            EnumSet<Service.ServiceOption> caps)\n            throws Throwable {\n        ServiceDocumentDescription sdd = buildDescription(stateType);\n        // first collect service state before shutdown so we can compare after\n        // they restart\n        Map<URI, T> statesBeforeRestart = getServiceState(null, stateType, services);\n\n        List<Service> freshServices = new ArrayList<>();\n        List<Operation> ops = new ArrayList<>();\n        for (Service s : services) {\n            // delete with no body means stop the service\n            Operation delete = Operation.createDelete(s.getUri());\n            ops.add(delete);\n        }\n        this.sender.sendAndWait(ops);\n\n        // restart services\n        TestContext ctx = testCreate(services.size());\n        for (Service oldInstance : services) {\n            Service e = oldInstance.getClass().newInstance();\n\n            for (Service.ServiceOption cap : caps) {\n                e.toggleOption(cap, true);\n            }\n\n            // use the same exact URI so the document index can find the service\n            // state by self link\n            startService(\n                    Operation.createPost(oldInstance.getUri()).setCompletion(ctx.getCompletion()),\n                    e);\n            freshServices.add(e);\n        }\n        ctx.await();\n        services = null;\n\n        Map<URI, T> statesAfterRestart = getServiceState(null, stateType, freshServices);\n\n        for (Entry<URI, T> e : statesAfterRestart.entrySet()) {\n            T stateAfter = e.getValue();\n            if (stateAfter.documentSelfLink == null) {\n                throw new IllegalStateException(\"missing selflink\");\n            }\n            if (stateAfter.documentKind == null) {\n                throw new IllegalStateException(\"missing kind\");\n            }\n\n            T stateBefore = statesBeforeRestart.get(e.getKey());\n            if (stateBefore == null) {\n                throw new IllegalStateException(\n                        \"New service has new self link, not in previous service instances\");\n            }\n\n            if (!stateBefore.documentKind.equals(stateAfter.documentKind)) {\n                throw new IllegalStateException(\"kind mismatch\");\n            }\n\n            if (!caps.contains(Service.ServiceOption.PERSISTENCE)) {\n                continue;\n            }\n\n            if (stateBefore.documentVersion != stateAfter.documentVersion) {\n                String error = String.format(\n                        \"Version mismatch. Before State: %s%n%n After state:%s\",\n                        Utils.toJson(stateBefore),\n                        Utils.toJson(stateAfter));\n                throw new IllegalStateException(error);\n            }\n\n            if (stateBefore.documentUpdateTimeMicros != stateAfter.documentUpdateTimeMicros) {\n                throw new IllegalStateException(\"update time mismatch\");\n            }\n\n            if (stateBefore.documentVersion == 0) {\n                throw new IllegalStateException(\"PUT did not appear to take place before restart\");\n            }\n            if (!ServiceDocument.equals(sdd, stateBefore, stateAfter)) {\n                throw new IllegalStateException(\"content signature mismatch\");\n            }\n        }\n\n    }\n\n    private Map<String, NodeState> peerHostIdToNodeState = new ConcurrentHashMap<>();\n    private Map<URI, URI> peerNodeGroups = new ConcurrentHashMap<>();\n    private Map<URI, VerificationHost> localPeerHosts = new ConcurrentHashMap<>();\n\n    private boolean isRemotePeerTest;\n\n    private boolean isSingleton;\n\n    public Map<URI, VerificationHost> getInProcessHostMap() {\n        return new HashMap<>(this.localPeerHosts);\n    }\n\n    public Map<URI, URI> getNodeGroupMap() {\n        return new HashMap<>(this.peerNodeGroups);\n    }\n\n    public Map<String, NodeState> getNodeStateMap() {\n        return new HashMap<>(this.peerHostIdToNodeState);\n    }\n\n    public void scheduleSynchronizationIfAutoSyncDisabled(String selectorPath) {\n        if (this.isPeerSynchronizationEnabled()) {\n            return;\n        }\n        for (VerificationHost peerHost : getInProcessHostMap().values()) {\n            peerHost.scheduleNodeGroupChangeMaintenance(selectorPath);\n            ServiceStats selectorStats = getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(peerHost, selectorPath));\n            ServiceStat synchStat = selectorStats.entries\n                    .get(ConsistentHashingNodeSelectorService.STAT_NAME_SYNCHRONIZATION_COUNT);\n            if (synchStat != null && synchStat.latestValue > 0) {\n                throw new IllegalStateException(\"Automatic synchronization was triggered\");\n            }\n        }\n    }\n\n    public void setUpPeerHosts(int localHostCount) {\n        CommandLineArgumentParser.parseFromProperties(this);\n        if (this.peerNodes == null) {\n            this.setUpLocalPeersHosts(localHostCount, null);\n        } else {\n            this.setUpWithRemotePeers(this.peerNodes);\n        }\n    }\n\n    public void setUpLocalPeersHosts(int localHostCount, Long maintIntervalMillis) {\n        testStart(localHostCount);\n        if (maintIntervalMillis == null) {\n            maintIntervalMillis = this.maintenanceIntervalMillis;\n        }\n        final long intervalMicros = TimeUnit.MILLISECONDS.toMicros(maintIntervalMillis);\n        for (int i = 0; i < localHostCount; i++) {\n            String location = this.isMultiLocationTest\n                    ? ((i < localHostCount / 2) ? LOCATION1 : LOCATION2)\n                    : null;\n            run(() -> {\n                try {\n                    this.setUpLocalPeerHost(null, intervalMicros, location);\n                } catch (Throwable e) {\n                    failIteration(e);\n                }\n            });\n        }\n        testWait();\n    }\n\n    public Map<URI, URI> getNodeGroupToFactoryMap(String factoryLink) {\n        Map<URI, URI> nodeGroupToFactoryMap = new HashMap<>();\n        for (URI nodeGroup : this.peerNodeGroups.values()) {\n            nodeGroupToFactoryMap.put(nodeGroup,\n                    UriUtils.buildUri(nodeGroup.getScheme(), nodeGroup.getHost(),\n                            nodeGroup.getPort(), factoryLink, null));\n        }\n        return nodeGroupToFactoryMap;\n    }\n\n    public VerificationHost setUpLocalPeerHost(Collection<ServiceHost> hosts,\n            long maintIntervalMicros) throws Throwable {\n        return setUpLocalPeerHost(0, maintIntervalMicros, hosts);\n    }\n\n    public VerificationHost setUpLocalPeerHost(int port, long maintIntervalMicros,\n            Collection<ServiceHost> hosts)\n            throws Throwable {\n        return setUpLocalPeerHost(port, maintIntervalMicros, hosts, null);\n    }\n\n    public VerificationHost setUpLocalPeerHost(Collection<ServiceHost> hosts,\n            long maintIntervalMicros, String location) throws Throwable {\n        return setUpLocalPeerHost(0, maintIntervalMicros, hosts, location);\n    }\n\n    public VerificationHost setUpLocalPeerHost(int port, long maintIntervalMicros,\n            Collection<ServiceHost> hosts, String location)\n            throws Throwable {\n\n        VerificationHost h = VerificationHost.create(port);\n\n        h.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled());\n        h.setAuthorizationEnabled(this.isAuthorizationEnabled());\n\n        if (this.getCurrentHttpScheme() == HttpScheme.HTTPS_ONLY) {\n            // disable HTTP on new peer host\n            h.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n            // request a random HTTPS port\n            h.setSecurePort(0);\n        }\n\n        if (this.isAuthorizationEnabled()) {\n            h.setAuthorizationService(new AuthorizationContextService());\n        }\n        try {\n            VerificationHost.createAndAttachSSLClient(h);\n\n            // override with parent cert info.\n            // Within same node group, all hosts are required to use same cert, private key, and\n            // passphrase for now.\n            h.setCertificateFileReference(this.getState().certificateFileReference);\n            h.setPrivateKeyFileReference(this.getState().privateKeyFileReference);\n            h.setPrivateKeyPassphrase(this.getState().privateKeyPassphrase);\n            if (location != null) {\n                h.setLocation(location);\n            }\n\n            h.start();\n            h.setMaintenanceIntervalMicros(maintIntervalMicros);\n        } catch (Throwable e) {\n            throw new Exception(e);\n        }\n\n        addPeerNode(h);\n        if (hosts != null) {\n            hosts.add(h);\n        }\n        this.completeIteration();\n        return h;\n    }\n\n    public void setUpWithRemotePeers(String[] peerNodes) {\n        this.isRemotePeerTest = true;\n\n        this.peerNodeGroups.clear();\n        for (String remoteNode : peerNodes) {\n            URI remoteHostBaseURI = URI.create(remoteNode);\n            if (remoteHostBaseURI.getPort() == 80 || remoteHostBaseURI.getPort() == -1) {\n                remoteHostBaseURI = UriUtils.buildUri(remoteNode, ServiceHost.DEFAULT_PORT, \"\",\n                        null);\n            }\n\n            URI remoteNodeGroup = UriUtils.extendUri(remoteHostBaseURI,\n                    ServiceUriPaths.DEFAULT_NODE_GROUP);\n            this.peerNodeGroups.put(remoteHostBaseURI, remoteNodeGroup);\n        }\n\n    }\n\n    public void joinNodesAndVerifyConvergence(int nodeCount) throws Throwable {\n        joinNodesAndVerifyConvergence(null, nodeCount, nodeCount, null);\n    }\n\n    public boolean isRemotePeerTest() {\n        return this.isRemotePeerTest;\n    }\n\n    public int getPeerCount() {\n        return this.peerNodeGroups.size();\n    }\n\n    public URI getPeerHostUri() {\n        return getPeerServiceUri(\"\");\n    }\n\n    public URI getPeerNodeGroupUri() {\n        return getPeerServiceUri(ServiceUriPaths.DEFAULT_NODE_GROUP);\n    }\n\n    /**\n     * Randomly returns one of peer hosts.\n     */\n    public VerificationHost getPeerHost() {\n        URI hostUri = getPeerServiceUri(null);\n        if (hostUri != null) {\n            return this.localPeerHosts.get(hostUri);\n        }\n        return null;\n    }\n\n    public URI getPeerServiceUri(String link) {\n        if (!this.localPeerHosts.isEmpty()) {\n            List<URI> localPeerList = new ArrayList<>();\n            for (VerificationHost h : this.localPeerHosts.values()) {\n                if (h.isStopping() || !h.isStarted()) {\n                    continue;\n                }\n                localPeerList.add(h.getUri());\n            }\n            return getUriFromList(link, localPeerList);\n        } else {\n            List<URI> peerList = new ArrayList<>(this.peerNodeGroups.keySet());\n            return getUriFromList(link, peerList);\n        }\n    }\n\n    /**\n     * Randomly choose one uri from uriList and extend with the link\n     */\n    private URI getUriFromList(String link, List<URI> uriList) {\n        if (!uriList.isEmpty()) {\n            Collections.shuffle(uriList, new Random(System.nanoTime()));\n            URI baseUri = uriList.iterator().next();\n            return UriUtils.extendUri(baseUri, link);\n        }\n        return null;\n    }\n\n    public void createCustomNodeGroupOnPeers(String customGroupName) {\n        createCustomNodeGroupOnPeers(customGroupName, null);\n    }\n\n    public void createCustomNodeGroupOnPeers(String customGroupName,\n            Map<URI, NodeState> selfState) {\n        if (selfState == null) {\n            selfState = new HashMap<>();\n        }\n        // create a custom node group on all peer nodes\n        List<Operation> ops = new ArrayList<>();\n        for (URI peerHostBaseUri : getNodeGroupMap().keySet()) {\n            URI nodeGroupFactoryUri = UriUtils.buildUri(peerHostBaseUri,\n                    ServiceUriPaths.NODE_GROUP_FACTORY);\n            Operation op = getCreateCustomNodeGroupOperation(customGroupName, nodeGroupFactoryUri,\n                    selfState.get(peerHostBaseUri));\n            ops.add(op);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    private Operation getCreateCustomNodeGroupOperation(String customGroupName,\n            URI nodeGroupFactoryUri,\n            NodeState selfState) {\n        NodeGroupState body = new NodeGroupState();\n        body.documentSelfLink = customGroupName;\n        if (selfState != null) {\n            body.nodes.put(selfState.id, selfState);\n        }\n        return Operation.createPost(nodeGroupFactoryUri).setBody(body);\n    }\n\n    public void joinNodesAndVerifyConvergence(String customGroupPath, int hostCount,\n            int memberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode)\n            throws Throwable {\n        joinNodesAndVerifyConvergence(customGroupPath, hostCount, memberCount,\n                expectedOptionsPerNode, true);\n    }\n\n    public void joinNodesAndVerifyConvergence(int hostCount, boolean waitForTimeSync)\n            throws Throwable {\n        joinNodesAndVerifyConvergence(hostCount, hostCount, waitForTimeSync);\n    }\n\n    public void joinNodesAndVerifyConvergence(int hostCount, int memberCount,\n            boolean waitForTimeSync) throws Throwable {\n        joinNodesAndVerifyConvergence(null, hostCount, memberCount, null, waitForTimeSync);\n    }\n\n    public void joinNodesAndVerifyConvergence(String customGroupPath, int hostCount,\n            int memberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode,\n            boolean waitForTimeSync) throws Throwable {\n\n        // invoke op as system user\n        setAuthorizationContext(getSystemAuthorizationContext());\n        if (hostCount == 0) {\n            return;\n        }\n\n        Map<URI, URI> nodeGroupPerHost = new HashMap<>();\n        if (customGroupPath != null) {\n            for (Entry<URI, URI> e : this.peerNodeGroups.entrySet()) {\n                URI ngUri = UriUtils.buildUri(e.getKey(), customGroupPath);\n                nodeGroupPerHost.put(e.getKey(), ngUri);\n            }\n        } else {\n            nodeGroupPerHost = this.peerNodeGroups;\n        }\n\n        if (this.isRemotePeerTest()) {\n            memberCount = getPeerCount();\n        } else {\n            for (URI initialNodeGroupService : this.peerNodeGroups.values()) {\n                if (customGroupPath != null) {\n                    initialNodeGroupService = UriUtils.buildUri(initialNodeGroupService,\n                            customGroupPath);\n                }\n\n                for (URI nodeGroup : this.peerNodeGroups.values()) {\n                    if (customGroupPath != null) {\n                        nodeGroup = UriUtils.buildUri(nodeGroup, customGroupPath);\n                    }\n\n                    if (initialNodeGroupService.equals(nodeGroup)) {\n                        continue;\n                    }\n\n                    testStart(1);\n                    joinNodeGroup(nodeGroup, initialNodeGroupService, memberCount);\n                    testWait();\n                }\n            }\n\n        }\n\n        // for local or remote tests, we still want to wait for convergence\n        waitForNodeGroupConvergence(nodeGroupPerHost.values(), memberCount, null,\n                expectedOptionsPerNode, waitForTimeSync);\n\n        waitForNodeGroupIsAvailableConvergence(customGroupPath);\n\n        //reset auth context\n        setAuthorizationContext(null);\n    }\n\n    public void joinNodeGroup(URI newNodeGroupService,\n            URI nodeGroup, Integer quorum) {\n        if (nodeGroup.equals(newNodeGroupService)) {\n            return;\n        }\n\n        // to become member of a group of nodes, you send a POST to self\n        // (the local node group service) with the URI of the remote node\n        // group you wish to join\n        JoinPeerRequest joinBody = JoinPeerRequest.create(nodeGroup, quorum);\n\n        log(\"Joining %s through %s\", newNodeGroupService, nodeGroup);\n        // send the request to the node group instance we have picked as the\n        // \"initial\" one\n        send(Operation.createPost(newNodeGroupService)\n                .setBody(joinBody)\n                .setCompletion(getCompletion()));\n    }\n\n    public void joinNodeGroup(URI newNodeGroupService, URI nodeGroup) {\n        joinNodeGroup(newNodeGroupService, nodeGroup, null);\n    }\n\n    public void subscribeForNodeGroupConvergence(URI nodeGroup, int expectedAvailableCount,\n            CompletionHandler convergedCompletion) {\n\n        TestContext ctx = testCreate(1);\n        Operation subscribeToNodeGroup = Operation.createPost(\n                UriUtils.buildSubscriptionUri(nodeGroup))\n                .setCompletion(ctx.getCompletion())\n                .setReferer(getUri());\n        startSubscriptionService(subscribeToNodeGroup, (op) -> {\n            op.complete();\n            if (op.getAction() != Action.PATCH) {\n                return;\n            }\n\n            NodeGroupState ngs = op.getBody(NodeGroupState.class);\n            if (ngs.nodes == null && ngs.nodes.isEmpty()) {\n                return;\n            }\n\n            int c = 0;\n            for (NodeState ns : ngs.nodes.values()) {\n                if (ns.status == NodeStatus.AVAILABLE) {\n                    c++;\n                }\n            }\n\n            if (c != expectedAvailableCount) {\n                return;\n            }\n            convergedCompletion.handle(op, null);\n        });\n        ctx.await();\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence() {\n        waitForNodeGroupIsAvailableConvergence(ServiceUriPaths.DEFAULT_NODE_GROUP);\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence(String nodeGroupPath) {\n        waitForNodeGroupIsAvailableConvergence(nodeGroupPath, this.peerNodeGroups.values());\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence(String nodeGroupPath,\n            Collection<URI> nodeGroupUris) {\n        if (nodeGroupPath == null) {\n            nodeGroupPath = ServiceUriPaths.DEFAULT_NODE_GROUP;\n        }\n        String finalNodeGroupPath = nodeGroupPath;\n\n        waitFor(\"Node group is not available for convergence\", () -> {\n            boolean isConverged = true;\n            for (URI nodeGroupUri : nodeGroupUris) {\n                URI u = UriUtils.buildUri(nodeGroupUri, finalNodeGroupPath);\n                URI statsUri = UriUtils.buildStatsUri(u);\n                ServiceStats stats = getServiceState(null, ServiceStats.class, statsUri);\n                ServiceStat availableStat = stats.entries.get(Service.STAT_NAME_AVAILABLE);\n                if (availableStat == null || availableStat.latestValue != Service.STAT_VALUE_TRUE) {\n                    log(\"Service stat available is missing or not 1.0\");\n                    isConverged = false;\n                    break;\n                }\n            }\n            return isConverged;\n        });\n\n    }\n\n    public void waitForNodeGroupConvergence(int memberCount) {\n        waitForNodeGroupConvergence(memberCount, null);\n    }\n\n    public void waitForNodeGroupConvergence(int healthyMemberCount, Integer totalMemberCount) {\n        waitForNodeGroupConvergence(this.peerNodeGroups.values(), healthyMemberCount,\n                totalMemberCount, true);\n    }\n\n    public void waitForNodeGroupConvergence(Collection<URI> nodeGroupUris, int healthyMemberCount,\n            Integer totalMemberCount,\n            boolean waitForTimeSync) {\n        waitForNodeGroupConvergence(nodeGroupUris, healthyMemberCount, totalMemberCount,\n                new HashMap<>(), waitForTimeSync);\n    }\n\n    /**\n     * Check node group convergence.\n     *\n     * Due to the implementation of {@link NodeGroupUtils#isNodeGroupAvailable}, quorum needs to\n     * be set less than the available node counts.\n     *\n     * Since {@link TestNodeGroupManager} requires all passing nodes to be in a same nodegroup,\n     * hosts in in-memory host map({@code this.localPeerHosts}) that do not match with the given\n     * nodegroup will be skipped for check.\n     *\n     * For existing API compatibility, keeping unused variables in signature.\n     * Only {@code nodeGroupUris} parameter is used.\n     *\n     * Sample node group URI: http://127.0.0.1:8000/core/node-groups/default\n     *\n     * @see TestNodeGroupManager#waitForConvergence()\n     */\n    public void waitForNodeGroupConvergence(Collection<URI> nodeGroupUris,\n            int healthyMemberCount,\n            Integer totalMemberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNodeGroupUri,\n            boolean waitForTimeSync) {\n\n        Set<String> nodeGroupNames = nodeGroupUris.stream()\n                .map(URI::getPath)\n                .map(UriUtils::getLastPathSegment)\n                .collect(toSet());\n        if (nodeGroupNames.size() != 1) {\n            throw new RuntimeException(\"Multiple nodegroups are not supported. \" + nodeGroupNames);\n        }\n        String nodeGroupName = nodeGroupNames.iterator().next();\n\n        Date exp = getTestExpiration();\n        Duration timeout = Duration.between(Instant.now(), exp.toInstant());\n\n        // Convert \"http://127.0.0.1:1234/core/node-groups/default\" to \"http://127.0.0.1:1234\"\n        Set<URI> baseUris = nodeGroupUris.stream()\n                .map(uri -> uri.toString().replace(uri.getPath(), \"\"))\n                .map(URI::create)\n                .collect(toSet());\n\n        // pick up hosts that match with the base uris of given node group uris\n        Set<ServiceHost> hosts = getInProcessHostMap().values().stream()\n                .filter(host -> baseUris.contains(host.getPublicUri()))\n                .collect(toSet());\n\n        // perform \"waitForConvergence()\"\n        if (hosts != null && !hosts.isEmpty()) {\n            TestNodeGroupManager manager = new TestNodeGroupManager(nodeGroupName);\n            manager.addHosts(hosts);\n            manager.setTimeout(timeout);\n            manager.waitForConvergence();\n        } else {\n            this.waitFor(\"Node group did not converge\", () -> {\n                String nodeGroupPath = ServiceUriPaths.NODE_GROUP_FACTORY + \"/\" + nodeGroupName;\n                List<Operation> nodeGroupOps = baseUris.stream()\n                        .map(u -> UriUtils.buildUri(u, nodeGroupPath))\n                        .map(Operation::createGet)\n                        .collect(toList());\n                List<NodeGroupState> nodeGroupStates = getTestRequestSender()\n                        .sendAndWait(nodeGroupOps, NodeGroupState.class);\n\n                for (NodeGroupState nodeGroupState : nodeGroupStates) {\n                    TestContext testContext = this.testCreate(1);\n                    // placeholder operation\n                    Operation parentOp = Operation.createGet(null)\n                            .setReferer(this.getUri())\n                            .setCompletion(testContext.getCompletion());\n                    try {\n                        NodeGroupUtils.checkConvergenceFromAnyHost(this, nodeGroupState, parentOp);\n                        testContext.await();\n                    } catch (Exception e) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        // To be compatible with old behavior, populate peerHostIdToNodeState same way as before\n        List<Operation> nodeGroupGetOps = nodeGroupUris.stream()\n                .map(UriUtils::buildExpandLinksQueryUri)\n                .map(Operation::createGet)\n                .collect(toList());\n        List<NodeGroupState> nodeGroupStats = this.sender.sendAndWait(nodeGroupGetOps, NodeGroupState.class);\n\n        for (NodeGroupState nodeGroupStat : nodeGroupStats) {\n            for (NodeState nodeState : nodeGroupStat.nodes.values()) {\n                if (nodeState.status == NodeStatus.AVAILABLE) {\n                    this.peerHostIdToNodeState.put(nodeState.id, nodeState);\n                }\n            }\n        }\n    }\n\n    public int calculateHealthyNodeCount(NodeGroupState r) {\n        int healthyNodeCount = 0;\n        for (NodeState ns : r.nodes.values()) {\n            if (ns.status == NodeStatus.AVAILABLE) {\n                healthyNodeCount++;\n            }\n        }\n        return healthyNodeCount;\n    }\n\n    public void getNodeState(URI nodeGroup, Map<URI, NodeGroupState> nodesPerHost) {\n        getNodeState(nodeGroup, nodesPerHost, null);\n    }\n\n    public void getNodeState(URI nodeGroup, Map<URI, NodeGroupState> nodesPerHost,\n            TestContext ctx) {\n        URI u = UriUtils.buildExpandLinksQueryUri(nodeGroup);\n        Operation get = Operation.createGet(u).setCompletion((o, e) -> {\n            NodeGroupState ngs = null;\n            if (e != null) {\n                // failure is OK, since we might have just stopped a host\n                log(\"Host %s failed GET with %s\", nodeGroup, e.getMessage());\n                ngs = new NodeGroupState();\n            } else {\n                ngs = o.getBody(NodeGroupState.class);\n            }\n            synchronized (nodesPerHost) {\n                nodesPerHost.put(nodeGroup, ngs);\n            }\n            if (ctx == null) {\n                completeIteration();\n            } else {\n                ctx.completeIteration();\n            }\n        });\n        send(get);\n    }\n\n    public void validateNodes(NodeGroupState r, int expectedNodesPerGroup,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode) {\n\n        int healthyNodes = 0;\n        NodeState localNode = null;\n        for (NodeState ns : r.nodes.values()) {\n            if (ns.status == NodeStatus.AVAILABLE) {\n                healthyNodes++;\n            }\n            assertTrue(ns.documentKind.equals(Utils.buildKind(NodeState.class)));\n            if (ns.documentSelfLink.endsWith(r.documentOwner)) {\n                localNode = ns;\n            }\n\n            assertTrue(ns.options != null);\n            EnumSet<NodeOption> expectedOptions = expectedOptionsPerNode.get(ns.groupReference);\n            if (expectedOptions == null) {\n                expectedOptions = NodeState.DEFAULT_OPTIONS;\n            }\n\n            for (NodeOption eo : expectedOptions) {\n                assertTrue(ns.options.contains(eo));\n            }\n\n            assertTrue(ns.id != null);\n            assertTrue(ns.groupReference != null);\n            assertTrue(ns.documentSelfLink.startsWith(ns.groupReference.getPath()));\n        }\n\n        assertTrue(healthyNodes >= expectedNodesPerGroup);\n        assertTrue(localNode != null);\n    }\n\n    public void doNodeGroupStatsVerification(Map<URI, URI> defaultNodeGroupsPerHost) {\n        List<Operation> ops = new ArrayList<>();\n        for (URI nodeGroup : defaultNodeGroupsPerHost.values()) {\n            Operation get = Operation.createGet(UriUtils.extendUri(nodeGroup,\n                    ServiceHost.SERVICE_URI_SUFFIX_STATS));\n            ops.add(get);\n        }\n        List<Operation> results = this.sender.sendAndWait(ops);\n        for (Operation result : results) {\n            ServiceStats stats = result.getBody(ServiceStats.class);\n            assertTrue(!stats.entries.isEmpty());\n        }\n    }\n\n    public void setNodeGroupConfig(NodeGroupConfig config) {\n        setSystemAuthorizationContext();\n        List<Operation> ops = new ArrayList<>();\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            NodeGroupState body = new NodeGroupState();\n            body.config = config;\n            body.nodes = null;\n            ops.add(Operation.createPatch(nodeGroup).setBody(body));\n        }\n        this.sender.sendAndWait(ops);\n        resetAuthorizationContext();\n    }\n\n    public void setNodeGroupQuorum(Integer quorum)\n            throws Throwable {\n        // we can issue the update to any one node and it will update\n        // everyone in the group\n\n        setSystemAuthorizationContext();\n\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            log(\"Changing quorum to %d on group %s\", quorum, nodeGroup);\n            setNodeGroupQuorum(quorum, nodeGroup);\n            // nodes might not be joined, so we need to ask each node to set quorum\n        }\n\n        Date exp = getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            setSystemAuthorizationContext();\n            for (URI n : this.peerNodeGroups.values()) {\n                NodeGroupState s = getServiceState(null, NodeGroupState.class, n);\n                for (NodeState ns : s.nodes.values()) {\n                    if (quorum != ns.membershipQuorum) {\n                        isConverged = false;\n                    }\n                }\n            }\n            resetAuthorizationContext();\n            if (isConverged) {\n\n                log(\"converged\");\n                return;\n            }\n            Thread.sleep(500);\n        }\n        waitForNodeSelectorQuorumConvergence(ServiceUriPaths.DEFAULT_NODE_SELECTOR, quorum);\n        resetAuthorizationContext();\n\n        throw new TimeoutException();\n    }\n\n    public void waitForNodeSelectorQuorumConvergence(String nodeSelectorPath, int quorum) {\n        waitFor(\"quorum not updated\", () -> {\n            for (URI peerHostUri : getNodeGroupMap().keySet()) {\n                URI nodeSelectorUri = UriUtils.buildUri(peerHostUri, nodeSelectorPath);\n                NodeSelectorState nss = getServiceState(null, NodeSelectorState.class,\n                        nodeSelectorUri);\n                if (nss.membershipQuorum != quorum) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    public void setNodeGroupQuorum(Integer quorum, URI nodeGroup) {\n        UpdateQuorumRequest body = UpdateQuorumRequest.create(true);\n\n        if (quorum != null) {\n            body.setMembershipQuorum(quorum);\n        }\n\n        this.sender.sendAndWait(Operation.createPatch(nodeGroup).setBody(body));\n    }\n\n    public <T extends ServiceDocument> void validateDocumentPartitioning(\n            Map<URI, T> provisioningTasks,\n            Class<T> type) {\n        Map<String, Map<String, Long>> taskToOwnerCount = new HashMap<>();\n\n        for (URI baseHostURI : getNodeGroupMap().keySet()) {\n            List<URI> documentsPerDcpHost = new ArrayList<>();\n            for (URI serviceUri : provisioningTasks.keySet()) {\n                URI u = UriUtils.extendUri(baseHostURI, serviceUri.getPath());\n                documentsPerDcpHost.add(u);\n            }\n\n            Map<URI, T> tasksOnThisHost = getServiceState(\n                    null,\n                    type, documentsPerDcpHost);\n\n            for (T task : tasksOnThisHost.values()) {\n                Map<String, Long> ownerCount = taskToOwnerCount.get(task.documentSelfLink);\n                if (ownerCount == null) {\n                    ownerCount = new HashMap<>();\n                    taskToOwnerCount.put(task.documentSelfLink, ownerCount);\n                }\n\n                Long count = ownerCount.get(task.documentOwner);\n                if (count == null) {\n                    count = 0L;\n                }\n                count++;\n                ownerCount.put(task.documentOwner, count);\n            }\n        }\n\n        // now verify that each task had a single owner assigned to it\n        for (Entry<String, Map<String, Long>> e : taskToOwnerCount.entrySet()) {\n            Map<String, Long> owners = e.getValue();\n            if (owners.size() > 1) {\n                throw new IllegalStateException(\"Multiple owners assigned on task \" + e.getKey());\n            }\n        }\n\n    }\n\n    public void createExampleServices(ServiceHost h, long serviceCount, List<URI> exampleURIs,\n            Long expiration) {\n        waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        ExampleServiceState initialState = new ExampleServiceState();\n        URI exampleFactoryUri = UriUtils.buildFactoryUri(h,\n                ExampleService.class);\n\n        // create example services\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < serviceCount; i++) {\n            initialState.counter = 123L;\n            if (expiration != null) {\n                initialState.documentExpirationTimeMicros = expiration;\n            }\n            initialState.name = initialState.documentSelfLink = UUID.randomUUID().toString();\n            exampleURIs.add(UriUtils.extendUri(exampleFactoryUri, initialState.documentSelfLink));\n\n            Operation createPost = Operation.createPost(exampleFactoryUri).setBody(initialState);\n            ops.add(createPost);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    public Date getTestExpiration() {\n        long duration = this.timeoutSeconds + this.testDurationSeconds;\n        return new Date(new Date().getTime()\n                + TimeUnit.SECONDS.toMillis(duration));\n    }\n\n    public boolean isStressTest() {\n        return this.isStressTest;\n    }\n\n    public void setStressTest(boolean isStressTest) {\n        this.isStressTest = isStressTest;\n        if (isStressTest) {\n            this.timeoutSeconds = 600;\n            this.setOperationTimeOutMicros(TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n        } else {\n            this.timeoutSeconds = (int) TimeUnit.MICROSECONDS.toSeconds(\n                    ServiceHostState.DEFAULT_OPERATION_TIMEOUT_MICROS);\n        }\n    }\n\n    public boolean isMultiLocationTest() {\n        return this.isMultiLocationTest;\n    }\n\n    public void setMultiLocationTest(boolean isMultiLocationTest) {\n        this.isMultiLocationTest = isMultiLocationTest;\n    }\n\n    public void toggleServiceOptions(URI serviceUri, EnumSet<ServiceOption> optionsToEnable,\n            EnumSet<ServiceOption> optionsToDisable) {\n\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = optionsToDisable;\n        updateBody.addOptions = optionsToEnable;\n\n        URI configUri = UriUtils.buildConfigUri(serviceUri);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(updateBody));\n    }\n\n    public void setOperationQueueLimit(URI serviceUri, int limit) {\n        // send a set limit configuration request\n        ServiceConfigUpdateRequest body = ServiceConfigUpdateRequest.create();\n        body.operationQueueLimit = limit;\n        URI configUri = UriUtils.buildConfigUri(serviceUri);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(body));\n\n        // verify new operation limit is set\n        ServiceConfiguration config = this.sender.sendAndWait(Operation.createGet(configUri),\n                ServiceConfiguration.class);\n        assertEquals(\"Invalid queue limit\", body.operationQueueLimit,\n                (Integer) config.operationQueueLimit);\n    }\n\n    public void toggleNegativeTestMode(boolean enable) {\n        log(\"++++++ Negative test mode %s, failure logs expected: %s\", enable, enable);\n    }\n\n    public void logNodeProcessLogs(Set<URI> keySet, String logSuffix) {\n        List<URI> logServices = new ArrayList<>();\n        for (URI host : keySet) {\n            logServices.add(UriUtils.extendUri(host, logSuffix));\n        }\n\n        Map<URI, LogServiceState> states = this.getServiceState(null, LogServiceState.class,\n                logServices);\n        for (Entry<URI, LogServiceState> entry : states.entrySet()) {\n            log(\"Process log for node %s\\n\\n%s\", entry.getKey(),\n                    Utils.toJsonHtml(entry.getValue()));\n        }\n    }\n\n    public void logNodeManagementState(Set<URI> keySet) {\n        List<URI> services = new ArrayList<>();\n        for (URI host : keySet) {\n            services.add(UriUtils.extendUri(host, ServiceUriPaths.CORE_MANAGEMENT));\n        }\n\n        Map<URI, ServiceHostState> states = this.getServiceState(null, ServiceHostState.class,\n                services);\n        for (Entry<URI, ServiceHostState> entry : states.entrySet()) {\n            log(\"Management state for node %s\\n\\n%s\", entry.getKey(),\n                    Utils.toJsonHtml(entry.getValue()));\n        }\n    }\n\n    public void tearDownInProcessPeers() {\n        for (VerificationHost h : this.localPeerHosts.values()) {\n            if (h == null) {\n                continue;\n            }\n            stopHost(h);\n        }\n    }\n\n    public void stopHost(VerificationHost host) {\n        log(\"Stopping host %s (%s)\", host.getUri(), host.getId());\n        host.tearDown();\n        this.peerHostIdToNodeState.remove(host.getId());\n        this.peerNodeGroups.remove(host.getUri());\n        this.localPeerHosts.remove(host.getUri());\n    }\n\n    public void stopHostAndPreserveState(ServiceHost host) {\n        log(\"Stopping host %s\", host.getUri());\n        // Do not delete the temporary directory with the lucene index. Notice that\n        // we do not call host.tearDown(), which will delete disk state, we simply\n        // stop the host and remove it from the peer node tracking tables\n        host.stop();\n        this.peerHostIdToNodeState.remove(host.getId());\n        this.peerNodeGroups.remove(host.getUri());\n        this.localPeerHosts.remove(host.getUri());\n    }\n\n    public boolean isLongDurationTest() {\n        return this.testDurationSeconds > 0;\n    }\n\n    public void logServiceStats(URI uri) {\n        ServiceStats stats = getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(uri));\n        if (stats == null || stats.entries == null) {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(String.format(\"Stats for %s%n\", uri));\n        sb.append(String.format(\"\\tCount\\t\\tAvg\\t\\tTotal\\t\\t\\tName%n\"));\n        for (ServiceStat st : stats.entries.values()) {\n            logStat(uri, st, sb);\n        }\n        log(sb.toString());\n    }\n\n    private void logStat(URI serviceUri, ServiceStat st, StringBuilder sb) {\n        ServiceStatLogHistogram hist = st.logHistogram;\n        st.logHistogram = null;\n\n        double total = st.accumulatedValue != 0 ? st.accumulatedValue : st.latestValue;\n        double avg = total / st.version;\n        sb.append(\n                String.format(\"\\t%08d\\t\\t%08.2f\\t%010.2f\\t%s%n\", st.version, avg, total, st.name));\n        if (hist == null) {\n            return;\n        }\n    }\n\n    /**\n     * Retrieves node group service state from all peers and logs it in JSON format\n     */\n    public void logNodeGroupState() {\n        List<Operation> ops = new ArrayList<>();\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            ops.add(Operation.createGet(nodeGroup));\n        }\n        List<NodeGroupState> stats = this.sender.sendAndWait(ops, NodeGroupState.class);\n        for (NodeGroupState stat : stats) {\n            log(\"%s\", Utils.toJsonHtml(stat));\n        }\n    }\n\n    public void setServiceMaintenanceIntervalMicros(String path, long micros) {\n        setServiceMaintenanceIntervalMicros(UriUtils.buildUri(this, path), micros);\n    }\n\n    public void setServiceMaintenanceIntervalMicros(URI u, long micros) {\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.maintenanceIntervalMicros = micros;\n        URI configUri = UriUtils.extendUri(u, ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(updateBody));\n    }\n\n    /**\n     * Toggles the operation tracing service\n     *\n     * @param baseHostURI  the uri of the tracing service\n     * @param enable state to toggle to\n     */\n    public void toggleOperationTracing(URI baseHostURI, boolean enable) {\n        ServiceHostManagementService.ConfigureOperationTracingRequest r = new ServiceHostManagementService.ConfigureOperationTracingRequest();\n        r.enable = enable ? ServiceHostManagementService.OperationTracingEnable.START\n                : ServiceHostManagementService.OperationTracingEnable.STOP;\n        r.kind = ServiceHostManagementService.ConfigureOperationTracingRequest.KIND;\n\n        this.setSystemAuthorizationContext();\n        this.sender.sendAndWait(Operation.createPatch(\n                UriUtils.extendUri(baseHostURI, ServiceHostManagementService.SELF_LINK))\n                .setBody(r));\n        this.resetAuthorizationContext();\n    }\n\n    public CompletionHandler getSuccessOrFailureCompletion() {\n        return (o, e) -> {\n            completeIteration();\n        };\n    }\n\n    public static QueryValidationServiceState buildQueryValidationState() {\n        QueryValidationServiceState newState = new QueryValidationServiceState();\n\n        newState.ignoredStringValue = \"should be ignored by index\";\n        newState.exampleValue = new ExampleServiceState();\n        newState.exampleValue.counter = 10L;\n        newState.exampleValue.name = \"example name\";\n\n        newState.nestedComplexValue = new NestedType();\n        newState.nestedComplexValue.id = UUID.randomUUID().toString();\n        newState.nestedComplexValue.longValue = Long.MIN_VALUE;\n\n        newState.listOfExampleValues = new ArrayList<>();\n        ExampleServiceState exampleItem = new ExampleServiceState();\n        exampleItem.name = \"nested name\";\n        newState.listOfExampleValues.add(exampleItem);\n\n        newState.listOfStrings = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            newState.listOfStrings.add(UUID.randomUUID().toString());\n        }\n\n        newState.arrayOfExampleValues = new ExampleServiceState[2];\n        newState.arrayOfExampleValues[0] = new ExampleServiceState();\n        newState.arrayOfExampleValues[0].name = UUID.randomUUID().toString();\n\n        newState.arrayOfStrings = new String[2];\n        newState.arrayOfStrings[0] = UUID.randomUUID().toString();\n        newState.arrayOfStrings[1] = UUID.randomUUID().toString();\n\n        newState.mapOfStrings = new HashMap<>();\n        String keyOne = \"keyOne\";\n        String keyTwo = \"keyTwo\";\n        String valueOne = UUID.randomUUID().toString();\n        String valueTwo = UUID.randomUUID().toString();\n        newState.mapOfStrings.put(keyOne, valueOne);\n        newState.mapOfStrings.put(keyTwo, valueTwo);\n\n        newState.mapOfBooleans = new HashMap<>();\n        newState.mapOfBooleans.put(\"trueKey\", true);\n        newState.mapOfBooleans.put(\"falseKey\", false);\n\n        newState.mapOfBytesArrays = new HashMap<>();\n        newState.mapOfBytesArrays.put(\"bytes\", new byte[] { 0x01, 0x02 });\n\n        newState.mapOfDoubles = new HashMap<>();\n        newState.mapOfDoubles.put(\"one\", 1.0);\n        newState.mapOfDoubles.put(\"minusOne\", -1.0);\n\n        newState.mapOfEnums = new HashMap<>();\n        newState.mapOfEnums.put(\"GET\", Service.Action.GET);\n\n        newState.mapOfLongs = new HashMap<>();\n        newState.mapOfLongs.put(\"one\", 1L);\n        newState.mapOfLongs.put(\"two\", 2L);\n\n        newState.mapOfNestedTypes = new HashMap<>();\n        newState.mapOfNestedTypes.put(\"nested\", newState.nestedComplexValue);\n\n        newState.mapOfUris = new HashMap<>();\n        newState.mapOfUris.put(\"uri\", UriUtils.buildUri(\"/foo/bar\"));\n\n        newState.ignoredArrayOfStrings = new String[2];\n        newState.ignoredArrayOfStrings[0] = UUID.randomUUID().toString();\n        newState.ignoredArrayOfStrings[1] = UUID.randomUUID().toString();\n\n        newState.binaryContent = UUID.randomUUID().toString().getBytes();\n        return newState;\n    }\n\n    public void updateServiceOptions(Collection<String> selfLinks,\n            ServiceConfigUpdateRequest cfgBody) {\n\n        List<Operation> ops = new ArrayList<>();\n        for (String link : selfLinks) {\n            URI bUri = UriUtils.buildUri(getUri(), link,\n                    ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n\n            ops.add(Operation.createPatch(bUri).setBody(cfgBody));\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    public void addPeerNode(VerificationHost h) {\n        URI localBaseURI = h.getPublicUri();\n        URI nodeGroup = UriUtils.buildUri(h.getPublicUri(), ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.peerNodeGroups.put(localBaseURI, nodeGroup);\n        this.localPeerHosts.put(localBaseURI, h);\n    }\n\n    public void addPeerNode(URI ngUri) {\n        URI hostUri = UriUtils.buildUri(ngUri.getScheme(), ngUri.getHost(), ngUri.getPort(), null,\n                null);\n        this.peerNodeGroups.put(hostUri, ngUri);\n    }\n\n    public ServiceDocumentDescription buildDescription(Class<? extends ServiceDocument> type) {\n        EnumSet<ServiceOption> options = EnumSet.noneOf(ServiceOption.class);\n        return Builder.create().buildDescription(type, options);\n    }\n\n    public void logAllDocuments(Set<URI> baseHostUris) {\n        QueryTask task = new QueryTask();\n        task.setDirect(true);\n        task.querySpec = new QuerySpecification();\n        task.querySpec.query.setTermPropertyName(\"documentSelfLink\").setTermMatchValue(\"*\");\n        task.querySpec.query.setTermMatchType(MatchType.WILDCARD);\n        task.querySpec.options = EnumSet.of(QueryOption.EXPAND_CONTENT);\n\n        List<Operation> ops = new ArrayList<>();\n        for (URI baseHost : baseHostUris) {\n            Operation queryPost = Operation\n                    .createPost(UriUtils.buildUri(baseHost, ServiceUriPaths.CORE_QUERY_TASKS))\n                    .setBody(task);\n            ops.add(queryPost);\n        }\n        List<QueryTask> queryTasks = this.sender.sendAndWait(ops, QueryTask.class);\n        for (QueryTask queryTask : queryTasks) {\n            log(Utils.toJsonHtml(queryTask));\n        }\n    }\n\n    public void setSystemAuthorizationContext() {\n        setAuthorizationContext(getSystemAuthorizationContext());\n    }\n\n    public void resetSystemAuthorizationContext() {\n        super.setAuthorizationContext(null);\n    }\n\n    @Override\n    public void addPrivilegedService(Class<? extends Service> serviceType) {\n        // Overriding just for test cases\n        super.addPrivilegedService(serviceType);\n    }\n\n    @Override\n    public void setAuthorizationContext(AuthorizationContext context) {\n        super.setAuthorizationContext(context);\n    }\n\n    public void resetAuthorizationContext() {\n        super.setAuthorizationContext(null);\n    }\n\n    /**\n     * Inject user identity into operation context.\n     *\n     * @param userServicePath user document link\n     */\n    public AuthorizationContext assumeIdentity(String userServicePath)\n            throws GeneralSecurityException {\n        return assumeIdentity(userServicePath, null);\n    }\n\n    /**\n     * Inject user identity into operation context.\n     *\n     * @param userServicePath user document link\n     * @param properties custom properties in claims\n     * @throws GeneralSecurityException any generic security exception\n     */\n    public AuthorizationContext assumeIdentity(String userServicePath,\n            Map<String, String> properties) throws GeneralSecurityException {\n        Claims.Builder builder = new Claims.Builder();\n        builder.setSubject(userServicePath);\n        builder.setProperties(properties);\n        Claims claims = builder.getResult();\n        String token = getTokenSigner().sign(claims);\n\n        AuthorizationContext.Builder ab = AuthorizationContext.Builder.create();\n        ab.setClaims(claims);\n        ab.setToken(token);\n\n        // Associate resulting authorization context with this thread\n        AuthorizationContext authContext = ab.getResult();\n        setAuthorizationContext(authContext);\n        return authContext;\n    }\n\n    public void deleteAllChildServices(URI factoryURI) {\n        deleteOrStopAllChildServices(factoryURI, false);\n    }\n\n    public void deleteOrStopAllChildServices(URI factoryURI, boolean stopOnly) {\n        ServiceDocumentQueryResult res = getFactoryState(factoryURI);\n        if (res.documentLinks.isEmpty()) {\n            return;\n        }\n        List<Operation> ops = new ArrayList<>();\n        for (String link : res.documentLinks) {\n            Operation op = Operation.createDelete(UriUtils.buildUri(factoryURI, link));\n            if (stopOnly) {\n                op.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NO_INDEX_UPDATE);\n            } else {\n                op.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                        Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n            }\n            ops.add(op);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    public <T extends ServiceDocument> ServiceDocument verifyPost(Class<T> documentType,\n            String factoryLink,\n            T state,\n            int expectedStatusCode) {\n        URI uri = UriUtils.buildUri(this, factoryLink);\n\n        Operation op = Operation.createPost(uri).setBody(state);\n        Operation response = this.sender.sendAndWait(op);\n        String message = String.format(\"Status code expected: %s, actual: %s\", expectedStatusCode,\n                response.getStatusCode());\n        assertEquals(message, expectedStatusCode, response.getStatusCode());\n\n        return response.getBody(documentType);\n    }\n\n    protected TemporaryFolder getTemporaryFolder() {\n        return this.temporaryFolder;\n    }\n\n    public void setTemporaryFolder(TemporaryFolder temporaryFolder) {\n        this.temporaryFolder = temporaryFolder;\n    }\n\n    /**\n     * Sends an operation and waits for completion. CompletionHandler on passed operation will be cleared.\n     */\n    public void sendAndWaitExpectSuccess(Operation op) {\n        // to be compatible with old behavior, clear the completion handler\n        op.setCompletion(null);\n\n        this.sender.sendAndWait(op);\n    }\n\n    public void sendAndWaitExpectFailure(Operation op) {\n        sendAndWaitExpectFailure(op, null);\n    }\n\n    public void sendAndWaitExpectFailure(Operation op, Integer expectedFailureCode) {\n\n        // to be compatible with old behavior, clear the completion handler\n        op.setCompletion(null);\n\n        FailureResponse resposne = this.sender.sendAndWaitFailure(op);\n\n        if (expectedFailureCode == null) {\n            return;\n        }\n        String msg = \"got unexpected status: \" + expectedFailureCode;\n        assertEquals(msg, (int) expectedFailureCode, resposne.op.getStatusCode());\n    }\n\n    /**\n     * Sends an operation and waits for completion.\n     */\n    public void sendAndWait(Operation op) {\n        // assume completion is attached, using our getCompletion() or\n        // getExpectedFailureCompletion()\n        testStart(1);\n        send(op);\n        testWait();\n    }\n\n    /**\n     * Sends an operation, waits for completion and return the response representation.\n     */\n    public Operation waitForResponse(Operation op) {\n        final Operation[] result = new Operation[1];\n        op.nestCompletion((o, e) -> {\n            result[0] = o;\n            completeIteration();\n        });\n\n        sendAndWait(op);\n\n        return result[0];\n    }\n\n    /**\n     * Decorates a {@link CompletionHandler} with a try/catch-all\n     * and fails the current iteration on exception. Allow for calling\n     * Assert.assert* directly in a handler.\n     *\n     * A safe handler will call completeIteration or failIteration exactly once.\n     *\n     * @param handler\n     * @return\n     */\n    public CompletionHandler getSafeHandler(CompletionHandler handler) {\n        return (o, e) -> {\n            try {\n                handler.handle(o, e);\n                completeIteration();\n            } catch (Throwable t) {\n                failIteration(t);\n            }\n        };\n    }\n\n    public CompletionHandler getSafeHandler(TestContext ctx, CompletionHandler handler) {\n        return (o, e) -> {\n            try {\n                handler.handle(o, e);\n                ctx.completeIteration();\n            } catch (Throwable t) {\n                ctx.failIteration(t);\n            }\n        };\n    }\n\n    /**\n     * Creates a new service instance of type {@code service} via a {@code HTTP POST} to the service\n     * factory URI (which is discovered automatically based on {@code service}). It passes {@code\n     * state} as the body of the {@code POST}.\n     * <p/>\n     * See javadoc for <i>handler</i> param for important details on how to properly use this\n     * method. If your test expects the service instance to be created successfully, you might use:\n     * <pre>\n     * String[] taskUri = new String[1];\n     * CompletionHandler successHandler = getCompletionWithUri(taskUri);\n     * sendFactoryPost(ExampleTaskService.class, new ExampleTaskServiceState(), successHandler);\n     * </pre>\n     *\n     * @param service the type of service to create\n     * @param state   the body of the {@code POST} to use to create the service instance\n     * @param handler the completion handler to use when creating the service instance.\n     *                <b>IMPORTANT</b>: This handler must properly call {@code host.failIteration()}\n     *                or {@code host.completeIteration()}.\n     * @param <T>     the state that represents the service instance\n     */\n    public <T extends ServiceDocument> void sendFactoryPost(Class<? extends Service> service,\n            T state, CompletionHandler handler) {\n        URI factoryURI = UriUtils.buildFactoryUri(this, service);\n        log(Level.INFO, \"Creating POST for [uri=%s] [body=%s]\", factoryURI, state);\n        Operation createPost = Operation.createPost(factoryURI)\n                .setBody(state)\n                .setCompletion(handler);\n\n        this.sender.sendAndWait(createPost);\n    }\n\n    /**\n     * Helper completion handler that:\n     * <ul>\n     * <li>Expects valid response to be returned; no exceptions when processing the operation</li>\n     * <li>Expects a {@code ServiceDocument} to be returned in the response body. The response's\n     * {@link ServiceDocument#documentSelfLink} will be stored in {@code storeUri[0]} so it can be\n     * used for test assertions and logic</li>\n     * </ul>\n     *\n     * @param storedLink The {@code documentSelfLink} of the created {@code ServiceDocument} will be\n     *                 stored in {@code storedLink[0]} so it can be used for test assertions and\n     *                 logic. This must be non-null and its length cannot be zero\n     * @return a completion handler, handy for using in methods like {@link\n     * #sendFactoryPost(Class, ServiceDocument, CompletionHandler)}\n     */\n    public CompletionHandler getCompletionWithSelflink(String[] storedLink) {\n        if (storedLink == null || storedLink.length == 0) {\n            throw new IllegalArgumentException(\n                    \"storeUri must be initialized and have room for at least one item\");\n        }\n\n        return (op, ex) -> {\n            if (ex != null) {\n                failIteration(ex);\n                return;\n            }\n\n            ServiceDocument response = op.getBody(ServiceDocument.class);\n            if (response == null) {\n                failIteration(new IllegalStateException(\n                        \"Expected non-null ServiceDocument in response body\"));\n                return;\n            }\n\n            log(Level.INFO, \"Created service instance. [selfLink=%s] [kind=%s]\",\n                    response.documentSelfLink, response.documentKind);\n            storedLink[0] = response.documentSelfLink;\n            completeIteration();\n        };\n    }\n\n    /**\n     * Helper completion handler that:\n     * <ul>\n     * <li>Expects an exception when processing the handler; it is a {@code failIteration} if an\n     * exception is <b>not</b> thrown.</li>\n     * <li>The exception will be stored in {@code storeException[0]} so it can be used for test\n     * assertions and logic.</li>\n     * </ul>\n     *\n     * @param storeException the exception that occurred in completion handler will be stored in\n     *                       {@code storeException[0]} so it can be used for test assertions and\n     *                       logic. This must be non-null and its length cannot be zero.\n     * @return a completion handler, handy for using in methods like {@link\n     * #sendFactoryPost(Class, ServiceDocument, CompletionHandler)}\n     */\n    public CompletionHandler getExpectedFailureCompletionReturningThrowable(\n            Throwable[] storeException) {\n        if (storeException == null || storeException.length == 0) {\n            throw new IllegalArgumentException(\n                    \"storeException must be initialized and have room for at least one item\");\n        }\n\n        return (op, ex) -> {\n            if (ex == null) {\n                failIteration(new IllegalStateException(\"Failure expected\"));\n            }\n            storeException[0] = ex;\n            completeIteration();\n        };\n    }\n\n    /**\n     * Helper method that waits for a query task to reach the expected stage\n     */\n    public QueryTask waitForQueryTask(URI uri, TaskState.TaskStage expectedStage) {\n\n        // If the task's state ever reaches one of these \"final\" stages, we can stop waiting...\n        List<TaskState.TaskStage> finalTaskStages = Arrays\n                .asList(TaskState.TaskStage.CANCELLED, TaskState.TaskStage.FAILED,\n                        TaskState.TaskStage.FINISHED, expectedStage);\n\n        String error = String.format(\"Task did not reach expected state %s\", expectedStage);\n        Object[] r = new Object[1];\n        final URI finalUri = uri;\n        waitFor(error, () -> {\n            QueryTask state = this.getServiceState(null, QueryTask.class, finalUri);\n            r[0] = state;\n            if (state.taskInfo != null) {\n                if (finalTaskStages.contains(state.taskInfo.stage)) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        return (QueryTask) r[0];\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FINISHED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it's {@code FINISHED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFinishedTask(Class<T> type,\n            String taskUri) {\n        return waitForTask(type, taskUri, TaskState.TaskStage.FINISHED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FINISHED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it's {@code FINISHED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFinishedTask(Class<T> type,\n            URI taskUri) {\n        return waitForTask(type, taskUri.toString(), TaskState.TaskStage.FINISHED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FAILED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it s {@code FAILED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFailedTask(Class<T> type,\n            String taskUri) {\n        return waitForTask(type, taskUri, TaskState.TaskStage.FAILED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * expectedStage}.\n     *\n     * @param type          The class type of that represents the task's state\n     * @param taskUri       the URI of the task to wait for\n     * @param expectedStage the stage we expect the task to eventually get to\n     * @param <T>           the type that represents the task's state\n     * @return the state of the task once it's {@link TaskState.TaskStage} == {@code expectedStage}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForTask(Class<T> type, String taskUri,\n            TaskState.TaskStage expectedStage) {\n        return waitForTask(type, taskUri, expectedStage, false);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * expectedStage}.\n     *\n     * @param type          The class type of that represents the task's state\n     * @param taskUri       the URI of the task to wait for\n     * @param expectedStage the stage we expect the task to eventually get to\n     * @param useQueryTask  Uses {@link QueryTask} to retrieve the current stage of the Task\n     * @param <T>           the type that represents the task's state\n     * @return the state of the task once it's {@link TaskState.TaskStage} == {@code expectedStage}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends TaskService.TaskServiceState> T waitForTask(Class<T> type, String taskUri,\n            TaskState.TaskStage expectedStage, boolean useQueryTask) {\n        URI uri = UriUtils.buildUri(taskUri);\n\n        if (!uri.isAbsolute()) {\n            uri = UriUtils.buildUri(this, taskUri);\n        }\n\n        List<TaskState.TaskStage> finalTaskStages = Arrays\n                .asList(TaskState.TaskStage.CANCELLED, TaskState.TaskStage.FAILED,\n                        TaskState.TaskStage.FINISHED);\n\n        String error = String.format(\"Task did not reach expected state %s\", expectedStage);\n        Object[] r = new Object[1];\n        final URI finalUri = uri;\n        waitFor(error, () -> {\n            T state = (useQueryTask)\n                    ? this.getServiceStateUsingQueryTask(type, taskUri)\n                    : this.getServiceState(null, type, finalUri);\n\n            r[0] = state;\n            if (state.taskInfo != null) {\n                if (expectedStage == state.taskInfo.stage) {\n                    return true;\n                }\n                if (finalTaskStages.contains(state.taskInfo.stage)) {\n                    fail(String.format(\n                            \"Task was expected to reach stage %s but reached a final stage %s\",\n                            expectedStage, state.taskInfo.stage));\n                }\n            }\n            return false;\n        });\n        return (T) r[0];\n    }\n\n    @FunctionalInterface\n    public interface WaitHandler {\n        boolean isReady() throws Throwable;\n    }\n\n    public void waitFor(String timeoutMsg, WaitHandler wh) {\n        ExceptionTestUtils.executeSafely(() -> {\n            Date exp = getTestExpiration();\n            while (new Date().before(exp)) {\n                if (wh.isReady()) {\n                    return;\n                }\n                // sleep for a tenth of the maintenance interval\n                Thread.sleep(TimeUnit.MICROSECONDS.toMillis(getMaintenanceIntervalMicros()) / 10);\n            }\n            throw new TimeoutException(timeoutMsg);\n        });\n    }\n\n    public void setSingleton(boolean enable) {\n        this.isSingleton = enable;\n    }\n\n    /*\n    * Running restart tests in VMs, in over provisioned CI will cause a restart using the same\n    * index sand box to fail, due to a file system LockHeldException.\n    * The sleep just reduces the false negative test failure rate, but it can still happen.\n    * Not much else we can do other adding some weird polling on all the index files.\n    *\n    * Returns true of host restarted, false if retry attempts expired or other exceptions where thrown\n     */\n    public static boolean restartStatefulHost(ServiceHost host) throws Throwable {\n        long exp = Utils.getNowMicrosUtc() + host.getOperationTimeoutMicros();\n\n        do {\n            Thread.sleep(2000);\n            try {\n                host.start();\n                return true;\n            } catch (Throwable e) {\n                Logger.getAnonymousLogger().warning(String\n                        .format(\"exception on host restart: %s\", e.getMessage()));\n                try {\n                    host.stop();\n                } catch (Throwable e1) {\n                    return false;\n                }\n                if (e instanceof LockObtainFailedException) {\n                    Logger.getAnonymousLogger()\n                            .warning(\"Lock held exception on host restart, retrying\");\n                    continue;\n                }\n                return false;\n            }\n        } while (Utils.getNowMicrosUtc() < exp);\n        return false;\n    }\n\n    public void waitForGC() {\n        if (!isStressTest()) {\n            return;\n        }\n        for (int k = 0; k < 10; k++) {\n            Runtime.getRuntime().gc();\n            Runtime.getRuntime().runFinalization();\n        }\n    }\n\n    public TestRequestSender getTestRequestSender() {\n        return this.sender;\n    }\n}\n", "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.services.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.lang.reflect.Field;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.concurrent.ConcurrentSkipListSet;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiPredicate;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.AuthorizationSetupHelper;\nimport com.vmware.xenon.common.CommandLineArgumentParser;\nimport com.vmware.xenon.common.FactoryService;\nimport com.vmware.xenon.common.NodeSelectorService.SelectAndForwardRequest;\nimport com.vmware.xenon.common.NodeSelectorService.SelectOwnerResponse;\nimport com.vmware.xenon.common.NodeSelectorState;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.OperationJoin;\nimport com.vmware.xenon.common.Service;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ProcessingStage;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceConfigUpdateRequest;\nimport com.vmware.xenon.common.ServiceConfiguration;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceDocumentDescription;\nimport com.vmware.xenon.common.ServiceDocumentQueryResult;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.ServiceHost.HttpScheme;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState;\nimport com.vmware.xenon.common.ServiceStats;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.StatefulService;\nimport com.vmware.xenon.common.SynchronizationTaskService;\nimport com.vmware.xenon.common.TaskState;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.common.serialization.KryoSerializers;\nimport com.vmware.xenon.common.test.AuthorizationHelper;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.RoundRobinIterator;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestProperty;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.common.test.VerificationHost.WaitHandler;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleTaskService.ExampleTaskServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService.MinimalTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.NodeGroupBroadcastResult.PeerNodeResult;\nimport com.vmware.xenon.services.common.NodeGroupService.JoinPeerRequest;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeState.NodeOption;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.ReplicationTestService.ReplicationTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.ReplicationTestService.ReplicationTestServiceState;\nimport com.vmware.xenon.services.common.ResourceGroupService.PatchQueryRequest;\nimport com.vmware.xenon.services.common.ResourceGroupService.ResourceGroupState;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.UserService.UserState;\n\npublic class TestNodeGroupService {\n\n    public static class PeriodicExampleFactoryService extends FactoryService {\n        public static final String SELF_LINK = \"test/examples-periodic\";\n\n        public PeriodicExampleFactoryService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public Service createServiceInstance() throws Throwable {\n            ExampleService s = new ExampleService();\n            s.toggleOption(ServiceOption.PERIODIC_MAINTENANCE, true);\n            return s;\n        }\n    }\n\n    public static class ExampleServiceWithCustomSelector extends StatefulService {\n\n        public ExampleServiceWithCustomSelector() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.REPLICATION, true);\n            super.toggleOption(ServiceOption.OWNER_SELECTION, true);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n\n    }\n\n    public static class ExampleFactoryServiceWithCustomSelector extends FactoryService {\n\n        public ExampleFactoryServiceWithCustomSelector() {\n            super(ExampleServiceState.class);\n            super.setPeerNodeSelectorPath(CUSTOM_GROUP_NODE_SELECTOR);\n        }\n\n        @Override\n        public Service createServiceInstance() throws Throwable {\n            return new ExampleServiceWithCustomSelector();\n        }\n\n    }\n\n    private static final String CUSTOM_EXAMPLE_SERVICE_KIND = \"xenon:examplestate\";\n    private static final String CUSTOM_NODE_GROUP_NAME = \"custom\";\n    private static final String CUSTOM_NODE_GROUP = UriUtils.buildUriPath(\n            ServiceUriPaths.NODE_GROUP_FACTORY,\n            CUSTOM_NODE_GROUP_NAME);\n    private static final String CUSTOM_GROUP_NODE_SELECTOR = UriUtils.buildUriPath(\n            ServiceUriPaths.NODE_SELECTOR_PREFIX,\n            CUSTOM_NODE_GROUP_NAME);\n\n    public static final long DEFAULT_MAINT_INTERVAL_MICROS = TimeUnit.MILLISECONDS\n            .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS);\n    private VerificationHost host;\n\n    /**\n     * Command line argument specifying number of times to run the same test method.\n     */\n    public int testIterationCount = 1;\n\n    /**\n     * Command line argument specifying default number of in process service hosts\n     */\n    public int nodeCount = 3;\n\n    /**\n     * Command line argument specifying request count\n     */\n    public int updateCount = 10;\n\n    /**\n     * Command line argument specifying service instance count\n     */\n    public int serviceCount = 10;\n\n    /**\n     * Command line argument specifying test duration\n     */\n    public long testDurationSeconds;\n\n    /**\n     * Command line argument specifying iterations per test method\n     */\n    public long iterationCount = 1;\n\n    /**\n     * Command line argument used by replication long running tests\n     */\n    public long totalOperationLimit = Long.MAX_VALUE;\n\n    private NodeGroupConfig nodeGroupConfig = new NodeGroupConfig();\n    private EnumSet<ServiceOption> postCreationServiceOptions = EnumSet.noneOf(ServiceOption.class);\n    private boolean expectFailure;\n    private long expectedFailureStartTimeMicros;\n    private List<URI> expectedFailedHosts = new ArrayList<>();\n    private String replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n    private String replicationNodeSelector = ServiceUriPaths.DEFAULT_NODE_SELECTOR;\n    private long replicationFactor;\n\n    private BiPredicate<ExampleServiceState, ExampleServiceState> exampleStateConvergenceChecker = (\n            initial, current) -> {\n        if (current.name == null) {\n            return false;\n        }\n        if (!this.host.isRemotePeerTest() &&\n                !CUSTOM_EXAMPLE_SERVICE_KIND.equals(current.documentKind)) {\n            return false;\n        }\n        return current.name.equals(initial.name);\n    };\n\n    private Function<ExampleServiceState, Void> exampleStateUpdateBodySetter = (\n            ExampleServiceState state) -> {\n        state.name = Utils.getNowMicrosUtc() + \"\";\n        return null;\n    };\n\n    private boolean isPeerSynchronizationEnabled = true;\n    private boolean isAuthorizationEnabled = false;\n    private HttpScheme replicationUriScheme;\n    private boolean skipAvailabilityChecks = false;\n    private boolean isMultiLocationTest = false;\n\n    private void setUp(int localHostCount) throws Throwable {\n        if (this.host != null) {\n            return;\n        }\n        CommandLineArgumentParser.parseFromProperties(this);\n        this.host = VerificationHost.create(0);\n        this.host.setAuthorizationEnabled(this.isAuthorizationEnabled);\n\n        VerificationHost.createAndAttachSSLClient(this.host);\n\n        if (this.replicationUriScheme == HttpScheme.HTTPS_ONLY) {\n            // disable HTTP, forcing host.getPublicUri() to return a HTTPS schemed URI. This in\n            // turn forces the node group to use HTTPS for join, replication, etc\n            this.host.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n            // the default is disable (-1) so we must set port to 0, to enable SSL and make the\n            // runtime pick a random HTTPS port\n            this.host.setSecurePort(0);\n        }\n\n        if (this.testDurationSeconds > 0) {\n            // for long running tests use the default interval to match production code\n            this.host.maintenanceIntervalMillis = TimeUnit.MICROSECONDS.toMillis(\n                    ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS);\n        }\n\n        this.host.start();\n\n        if (this.host.isAuthorizationEnabled()) {\n            this.host.setSystemAuthorizationContext();\n        }\n\n        CommandLineArgumentParser.parseFromProperties(this.host);\n        this.host.setStressTest(this.host.isStressTest);\n        this.host.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled);\n        this.host.setMultiLocationTest(this.isMultiLocationTest);\n        this.host.setUpPeerHosts(localHostCount);\n\n        for (VerificationHost h1 : this.host.getInProcessHostMap().values()) {\n            setUpPeerHostWithAdditionalServices(h1);\n        }\n\n        // If the peer hosts are remote, then we undo CUSTOM_EXAMPLE_SERVICE_KIND\n        // from the KINDS cache and use the real documentKind of ExampleService.\n        if (this.host.isRemotePeerTest()) {\n            Utils.registerKind(ExampleServiceState.class,\n                    Utils.toDocumentKind(ExampleServiceState.class));\n        }\n    }\n\n    private void setUpPeerHostWithAdditionalServices(VerificationHost h1) throws Throwable {\n        h1.setStressTest(this.host.isStressTest);\n\n        h1.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        Replication1xExampleFactoryService exampleFactory1x = new Replication1xExampleFactoryService();\n        h1.startServiceAndWait(exampleFactory1x,\n                Replication1xExampleFactoryService.SELF_LINK,\n                null);\n\n        Replication3xExampleFactoryService exampleFactory3x = new Replication3xExampleFactoryService();\n        h1.startServiceAndWait(exampleFactory3x,\n                Replication3xExampleFactoryService.SELF_LINK,\n                null);\n\n        // start the replication test factory service with OWNER_SELECTION\n        ReplicationFactoryTestService ownerSelRplFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(ownerSelRplFactory,\n                ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK,\n                null);\n\n        // start the replication test factory service with STRICT update checking\n        ReplicationFactoryTestService strictReplFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(strictReplFactory,\n                ReplicationFactoryTestService.STRICT_SELF_LINK, null);\n\n        // start the replication test factory service with simple replication, no owner selection\n        ReplicationFactoryTestService replFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(replFactory,\n                ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK, null);\n    }\n\n    private Map<URI, URI> getFactoriesPerNodeGroup(String factoryLink) {\n        Map<URI, URI> map = this.host.getNodeGroupToFactoryMap(factoryLink);\n        for (URI h : this.expectedFailedHosts) {\n            URI e = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            // do not send messages through hosts that will be stopped: this allows all messages to\n            // end the node group and the succeed or fail based on the test goals. If we let messages\n            // route through a host that we will abruptly stop, the message might timeout, which is\n            // OK for the expected failure case when quorum is not met, but will prevent is from confirming\n            // in the non eager consistency case, that all updates were written to at least one host\n            map.remove(e);\n        }\n\n        return map;\n    }\n\n    @Before\n    public void setUp() {\n        CommandLineArgumentParser.parseFromProperties(this);\n        Utils.registerKind(ExampleServiceState.class, CUSTOM_EXAMPLE_SERVICE_KIND);\n    }\n\n    private void setUpOnDemandLoad() throws Throwable {\n        setUp();\n        // we need at least 5 nodes, because we're going to stop 2\n        // nodes and we need majority quorum\n        this.nodeCount = Math.max(5, this.nodeCount);\n\n        this.isPeerSynchronizationEnabled = true;\n        this.skipAvailabilityChecks = true;\n        // create node group, join nodes and set majority quorum\n        setUp(this.nodeCount);\n        toggleOnDemandLoad();\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.host.getPeerCount() / 2 + 1);\n    }\n\n    private void toggleOnDemandLoad() {\n        for (URI nodeUri : this.host.getNodeGroupMap().keySet()) {\n            URI factoryUri = UriUtils.buildUri(nodeUri, ExampleService.FACTORY_LINK);\n            this.host.toggleServiceOptions(factoryUri, EnumSet.of(ServiceOption.ON_DEMAND_LOAD),\n                    null);\n        }\n    }\n\n    @After\n    public void tearDown() throws InterruptedException {\n        Utils.registerKind(ExampleServiceState.class,\n                Utils.toDocumentKind(ExampleServiceState.class));\n        if (this.host == null) {\n            return;\n        }\n\n        if (this.host.isRemotePeerTest()) {\n            try {\n                this.host.logNodeProcessLogs(this.host.getNodeGroupMap().keySet(),\n                        ServiceUriPaths.PROCESS_LOG);\n            } catch (Throwable e) {\n                this.host.log(\"Failure retrieving process logs: %s\", Utils.toString(e));\n            }\n\n            try {\n                this.host.logNodeManagementState(this.host.getNodeGroupMap().keySet());\n            } catch (Throwable e) {\n                this.host.log(\"Failure retrieving management state: %s\", Utils.toString(e));\n            }\n        }\n\n        this.host.tearDownInProcessPeers();\n        this.host.toggleNegativeTestMode(false);\n        this.host.tearDown();\n        this.host = null;\n\n        System.clearProperty(\n                NodeSelectorReplicationService.PROPERTY_NAME_REPLICA_NOT_FOUND_TIMEOUT_MICROS);\n    }\n\n    @Test\n    public void synchronizationCollisionWithPosts() throws Throwable {\n        // POST requests go through the FactoryService\n        // and do not get queued with Synchronization\n        // requests, so if synchronization was running\n        // while POSTs were happening for the same factory\n        // service, we could run into collisions. This test\n        // verifies that xenon handles such collisions and\n        // POST requests are always successful.\n\n        // Join the nodes with full quorum and wait for nodes to\n        // converge and synchronization to complete.\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        // Find the owner node for /core/examples. We will\n        // use it to start on-demand synchronization for\n        // this factory\n        URI factoryUri = UriUtils.buildUri(this.host.getPeerHost(), ExampleService.FACTORY_LINK);\n        waitForReplicatedFactoryServiceAvailable(factoryUri, this.replicationNodeSelector);\n\n        String taskPath = UriUtils.buildUriPath(\n                SynchronizationTaskService.FACTORY_LINK,\n                UriUtils.convertPathCharsFromLink(ExampleService.FACTORY_LINK));\n\n        VerificationHost owner = null;\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            if (peer.isOwner(ExampleService.FACTORY_LINK, ServiceUriPaths.DEFAULT_NODE_SELECTOR)) {\n                owner = peer;\n                break;\n            }\n        }\n        this.host.log(Level.INFO, \"Owner of synch-task is %s\", owner.getId());\n\n        // Get the membershipUpdateTimeMicros so that we can\n        // kick-off the synch-task on-demand.\n        URI taskUri = UriUtils.buildUri(owner, taskPath);\n        SynchronizationTaskService.State taskState = this.host.getServiceState(\n                null, SynchronizationTaskService.State.class, taskUri);\n        long membershipUpdateTimeMicros = taskState.membershipUpdateTimeMicros;\n\n        // Start posting and in the middle also start\n        // synchronization. All POSTs should succeed!\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"testing\";\n        TestContext ctx = this.host.testCreate((this.serviceCount * 10) + 1);\n        for (int i = 0; i < this.serviceCount * 10; i++) {\n            if (i == 5) {\n                SynchronizationTaskService.State task = new SynchronizationTaskService.State();\n                task.documentSelfLink = UriUtils.convertPathCharsFromLink(ExampleService.FACTORY_LINK);\n                task.factorySelfLink = ExampleService.FACTORY_LINK;\n                task.factoryStateKind = Utils.buildKind(ExampleService.ExampleServiceState.class);\n                task.membershipUpdateTimeMicros = membershipUpdateTimeMicros + 1;\n                task.nodeSelectorLink = ServiceUriPaths.DEFAULT_NODE_SELECTOR;\n                task.queryResultLimit = 1000;\n                task.taskInfo = TaskState.create();\n                task.taskInfo.isDirect = true;\n\n                Operation post = Operation\n                        .createPost(owner, SynchronizationTaskService.FACTORY_LINK)\n                        .setBody(task)\n                        .setReferer(this.host.getUri())\n                        .setCompletion(ctx.getCompletion());\n                this.host.sendRequest(post);\n            }\n            Operation post = Operation\n                    .createPost(factoryUri)\n                    .setBody(state)\n                    .setReferer(this.host.getUri())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(post);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void recognizeSelfInPeerNodesByPublicUri() throws Throwable {\n        String id = \"node-\" + VerificationHost.hostNumber.incrementAndGet();\n        String publicUri = \"http://myhostname.local:\";\n\n        // In order not to hardcode a port, 0 is used which will pick random port.\n        // The value of the random port is then used to set the initialPeerNodes and publicUri is if they\n        // used the assigned port to begin with.\n        ExampleServiceHost nodeA = new ExampleServiceHost() {\n            @Override\n            public List<URI> getInitialPeerHosts() {\n                try {\n                    Field field = ServiceHost.class.getDeclaredField(\"state\");\n                    field.setAccessible(true);\n                    ServiceHostState s = (ServiceHostState) field.get(this);\n                    s.initialPeerNodes = new String[] { publicUri + getPort() };\n                    s.publicUri = URI.create(publicUri + getPort());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n\n                return super.getInitialPeerHosts();\n            }\n        };\n        TemporaryFolder tmpFolderA = new TemporaryFolder();\n        tmpFolderA.create();\n        try {\n            String[] args = {\n                    \"--port=0\",\n                    \"--id=\" + id,\n                    \"--publicUri=\" + publicUri,\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\" + tmpFolderA.getRoot().getAbsolutePath()\n            };\n\n            nodeA.initialize(args);\n            nodeA.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n            nodeA.start();\n\n            URI nodeGroupUri = UriUtils.buildUri(nodeA, ServiceUriPaths.DEFAULT_NODE_GROUP, null);\n\n            TestRequestSender sender = new TestRequestSender(nodeA);\n            Operation op = Operation.createGet(nodeGroupUri)\n                    .setReferer(nodeA.getUri());\n\n            NodeGroupState nodeGroupState = sender.sendAndWait(op, NodeGroupState.class);\n\n            assertEquals(1, nodeGroupState.nodes.size());\n            assertEquals(1, nodeGroupState.nodes.values().iterator().next().membershipQuorum);\n        } finally {\n            tmpFolderA.delete();\n            nodeA.stop();\n        }\n    }\n\n    @Test\n    public void commandLineJoinRetries() throws Throwable {\n        this.host = VerificationHost.create(0);\n        this.host.start();\n\n        ExampleServiceHost nodeA = null;\n        TemporaryFolder tmpFolderA = new TemporaryFolder();\n        tmpFolderA.create();\n        this.setUp(1);\n        try {\n            // start a node, supplying a bogus peer. Verify we retry, up to expiration which is\n            // the operation timeout\n            nodeA = new ExampleServiceHost();\n\n            String id = \"nodeA-\" + VerificationHost.hostNumber.incrementAndGet();\n            int bogusPort = 1;\n            String[] args = {\n                    \"--port=0\",\n                    \"--id=\" + id,\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\" + tmpFolderA.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + \"http://127.0.0.1:\" + bogusPort\n            };\n\n            nodeA.initialize(args);\n            nodeA.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n            nodeA.start();\n\n            // verify we see a specific retry stat\n            URI nodeGroupUri = UriUtils.buildUri(nodeA, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            URI statsUri = UriUtils.buildStatsUri(nodeGroupUri);\n            this.host.waitFor(\"expected stat did not converge\", () -> {\n                ServiceStats stats = this.host.getServiceState(null, ServiceStats.class, statsUri);\n                ServiceStat st = stats.entries.get(NodeGroupService.STAT_NAME_JOIN_RETRY_COUNT);\n                if (st == null || st.latestValue < 1) {\n                    return false;\n                }\n                return true;\n            });\n\n        } finally {\n            if (nodeA != null) {\n                nodeA.stop();\n                tmpFolderA.delete();\n            }\n        }\n    }\n\n    @Test\n    public void synchronizationOnDemandLoad() throws Throwable {\n        // Setup peer nodes\n        setUp(this.nodeCount);\n\n        long intervalMicros = TimeUnit.MILLISECONDS.toMicros(200);\n\n        // Start the ODL Factory service on all the peers.\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            // Reduce cache clear delay to short duration\n            // to cause ODL service stops.\n            h.setServiceCacheClearDelayMicros(h.getMaintenanceIntervalMicros());\n\n            // create an on demand load factory and services\n            OnDemandLoadFactoryService.create(h);\n        }\n\n        // join the nodes and set full quorum.\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(OnDemandLoadFactoryService.SELF_LINK),\n                this.replicationNodeSelector);\n\n        // Create a few child-services.\n        VerificationHost h = this.host.getPeerHost();\n        Map<URI, ExampleServiceState> childServices = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState initialState = new ExampleServiceState();\n                    initialState.name = UUID.randomUUID().toString();\n                    o.setBody(initialState);\n                },\n                UriUtils.buildFactoryUri(h, OnDemandLoadFactoryService.class));\n\n        // Verify that each peer host reports the correct value for ODL stop count.\n        for (VerificationHost vh : this.host.getInProcessHostMap().values()) {\n            this.host.waitFor(\"ODL services did not stop as expected\",\n                    () -> checkOdlServiceStopCount(vh, this.serviceCount));\n        }\n\n        // Add a new host to the cluster.\n        VerificationHost newHost = this.host.setUpLocalPeerHost(0, h.getMaintenanceIntervalMicros(),\n                null);\n        newHost.setServiceCacheClearDelayMicros(intervalMicros);\n        OnDemandLoadFactoryService.create(newHost);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount + 1);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(OnDemandLoadFactoryService.SELF_LINK),\n                this.replicationNodeSelector);\n\n        // Do GETs on each previously created child services by calling the newly added host.\n        // This will trigger synchronization for the child services.\n        this.host.log(Level.INFO, \"Verifying synchronization for ODL services\");\n        for (Entry<URI, ExampleServiceState> childService : childServices.entrySet()) {\n            String childServicePath = childService.getKey().getPath();\n            ExampleServiceState state = this.host.getServiceState(null,\n                    ExampleServiceState.class, UriUtils.buildUri(newHost, childServicePath));\n            assertNotNull(state);\n        }\n\n        // Verify that the new peer host reports the correct value for ODL stop count.\n        this.host.waitFor(\"ODL services did not stop as expected\",\n                () -> checkOdlServiceStopCount(newHost, this.serviceCount));\n    }\n\n    private boolean checkOdlServiceStopCount(VerificationHost host, int serviceCount)\n            throws Throwable {\n        ServiceStat stopCount = host\n                .getServiceStats(host.getManagementServiceUri())\n                .get(ServiceHostManagementService.STAT_NAME_ODL_STOP_COUNT);\n        if (stopCount == null || stopCount.latestValue < serviceCount) {\n            this.host.log(Level.INFO,\n                    \"Current stopCount is %s\",\n                    (stopCount != null) ? String.valueOf(stopCount.latestValue) : \"null\");\n            return false;\n        }\n        return true;\n    }\n\n    @Test\n    public void customNodeGroupWithObservers() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            Logger.getAnonymousLogger().info(\"Iteration: \" + i);\n            verifyCustomNodeGroupWithObservers();\n            tearDown();\n        }\n    }\n\n    private void verifyCustomNodeGroupWithObservers() throws Throwable {\n        setUp(this.nodeCount);\n        // on one of the hosts create the custom group but with self as an observer. That peer should\n        // never receive replicated or broadcast requests\n        URI observerHostUri = this.host.getPeerHostUri();\n        ServiceHostState observerHostState = this.host.getServiceState(null,\n                ServiceHostState.class,\n                UriUtils.buildUri(observerHostUri, ServiceUriPaths.CORE_MANAGEMENT));\n        Map<URI, NodeState> selfStatePerNode = new HashMap<>();\n        NodeState observerSelfState = new NodeState();\n        observerSelfState.id = observerHostState.id;\n        observerSelfState.options = EnumSet.of(NodeOption.OBSERVER);\n\n        selfStatePerNode.put(observerHostUri, observerSelfState);\n        this.host.createCustomNodeGroupOnPeers(CUSTOM_NODE_GROUP_NAME, selfStatePerNode);\n\n        final String customFactoryLink = \"custom-factory\";\n        // start a node selector attached to the custom group\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            NodeSelectorState initialState = new NodeSelectorState();\n            initialState.nodeGroupLink = CUSTOM_NODE_GROUP;\n            h.startServiceAndWait(new ConsistentHashingNodeSelectorService(),\n                    CUSTOM_GROUP_NODE_SELECTOR, initialState);\n            // start the factory that is attached to the custom group selector\n            h.startServiceAndWait(ExampleFactoryServiceWithCustomSelector.class, customFactoryLink);\n        }\n\n        URI customNodeGroupServiceOnObserver = UriUtils\n                .buildUri(observerHostUri, CUSTOM_NODE_GROUP);\n        Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode = new HashMap<>();\n        expectedOptionsPerNode.put(customNodeGroupServiceOnObserver,\n                observerSelfState.options);\n\n        this.host.joinNodesAndVerifyConvergence(CUSTOM_NODE_GROUP, this.nodeCount,\n                this.nodeCount, expectedOptionsPerNode);\n        // one of the nodes is observer, so we must set quorum to 2 explicitly\n        this.host.setNodeGroupQuorum(2, customNodeGroupServiceOnObserver);\n        this.host.waitForNodeSelectorQuorumConvergence(CUSTOM_GROUP_NODE_SELECTOR, 2);\n        this.host.waitForNodeGroupIsAvailableConvergence(CUSTOM_NODE_GROUP);\n\n        int restartCount = 0;\n        // verify that the observer node shows up as OBSERVER on all peers, including self\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            URI customNodeGroupUri = UriUtils.buildUri(hostUri, CUSTOM_NODE_GROUP);\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    customNodeGroupUri);\n\n            for (NodeState ns : ngs.nodes.values()) {\n                if (ns.id.equals(observerHostState.id)) {\n                    assertTrue(ns.options.contains(NodeOption.OBSERVER));\n                } else {\n                    assertTrue(ns.options.contains(NodeOption.PEER));\n                }\n            }\n\n            ServiceStats nodeGroupStats = this.host.getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(customNodeGroupUri));\n            ServiceStat restartStat = nodeGroupStats.entries\n                    .get(NodeGroupService.STAT_NAME_RESTARTING_SERVICES_COUNT);\n            if (restartStat != null) {\n                restartCount += restartStat.latestValue;\n            }\n        }\n\n        assertEquals(\"expected different number of service restarts\", restartCount, 0);\n\n        // join all the nodes through the default group, making sure another group still works\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount, true);\n\n        URI observerFactoryUri = UriUtils.buildUri(observerHostUri, customFactoryLink);\n\n        waitForReplicatedFactoryServiceAvailable(observerFactoryUri, CUSTOM_GROUP_NODE_SELECTOR);\n\n        // create N services on the custom group, verify none of them got created on the observer.\n        // We actually post directly to the observer node, which should forward to the other nodes\n        Map<URI, ExampleServiceState> serviceStatesOnPost = this.host.doFactoryChildServiceStart(\n                null, this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState body = new ExampleServiceState();\n                    body.name = Utils.getNowMicrosUtc() + \"\";\n                    o.setBody(body);\n                },\n                observerFactoryUri);\n\n        ServiceDocumentQueryResult r = this.host.getFactoryState(observerFactoryUri);\n        assertEquals(0, r.documentLinks.size());\n\n        // do a GET on each service and confirm the owner id is never that of the observer node\n        Map<URI, ExampleServiceState> serviceStatesFromGet = this.host.getServiceState(\n                null, ExampleServiceState.class, serviceStatesOnPost.keySet());\n\n        for (ExampleServiceState s : serviceStatesFromGet.values()) {\n            if (observerHostState.id.equals(s.documentOwner)) {\n                throw new IllegalStateException(\"Observer node reported state for service\");\n            }\n        }\n\n        // create additional example services which are not associated with the custom node group\n        // and verify that they are always included in queries which target the custom node group\n        // (e.g. that the query is never executed on the OBSERVER node).\n        createExampleServices(observerHostUri);\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND).setTermMatchValue(\n                Utils.buildKind(ExampleServiceState.class));\n        QueryTask task = QueryTask.create(q).setDirect(true);\n\n        for (Entry<URI, URI> node : this.host.getNodeGroupMap().entrySet()) {\n            URI nodeUri = node.getKey();\n            URI serviceUri = UriUtils.buildUri(nodeUri, ServiceUriPaths.CORE_LOCAL_QUERY_TASKS);\n            URI forwardQueryUri = UriUtils.buildForwardRequestUri(serviceUri, null,\n                    CUSTOM_GROUP_NODE_SELECTOR);\n            TestContext ctx = this.host.testCreate(1);\n            Operation post = Operation\n                    .createPost(forwardQueryUri)\n                    .setBody(task)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            ctx.fail(e);\n                            return;\n                        }\n\n                        QueryTask rsp = o.getBody(QueryTask.class);\n                        int resultCount = rsp.results.documentLinks.size();\n                        if (resultCount != 2 * this.serviceCount) {\n                            ctx.fail(new IllegalStateException(\n                                    \"Forwarded query returned unexpected document count \" +\n                                            resultCount));\n                            return;\n                        }\n\n                        ctx.complete();\n                    });\n            this.host.send(post);\n            ctx.await();\n        }\n\n        task.querySpec.options = EnumSet.of(QueryTask.QuerySpecification.QueryOption.BROADCAST);\n        task.nodeSelectorLink = CUSTOM_GROUP_NODE_SELECTOR;\n        URI queryPostUri = UriUtils.buildUri(observerHostUri, ServiceUriPaths.CORE_QUERY_TASKS);\n        TestContext ctx = this.host.testCreate(1);\n        Operation post = Operation\n                .createPost(queryPostUri)\n                .setBody(task)\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx.fail(e);\n                        return;\n                    }\n\n                    QueryTask rsp = o.getBody(QueryTask.class);\n                    int resultCount = rsp.results.documentLinks.size();\n                    if (resultCount != 2 * this.serviceCount) {\n                        ctx.fail(new IllegalStateException(\n                                \"Broadcast query returned unexpected document count \" +\n                                        resultCount));\n                        return;\n                    }\n\n                    ctx.complete();\n                });\n        this.host.send(post);\n        ctx.await();\n\n        URI existingNodeGroup = this.host.getPeerNodeGroupUri();\n\n        // start more nodes, insert them to existing group, but with no synchronization required\n        // start some additional nodes\n        Collection<VerificationHost> existingHosts = this.host.getInProcessHostMap().values();\n        int additionalHostCount = this.nodeCount;\n        this.host.setUpPeerHosts(additionalHostCount);\n\n        List<ServiceHost> newHosts = Collections.synchronizedList(new ArrayList<>());\n        newHosts.addAll(this.host.getInProcessHostMap().values());\n        newHosts.removeAll(existingHosts);\n\n        expectedOptionsPerNode.clear();\n        // join new nodes with existing node group.\n\n        TestContext testContext = this.host.testCreate(newHosts.size());\n        for (ServiceHost h : newHosts) {\n            URI newCustomNodeGroupUri = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n            JoinPeerRequest joinBody = JoinPeerRequest.create(existingNodeGroup, null);\n            joinBody.localNodeOptions = EnumSet.of(NodeOption.PEER);\n            this.host.send(Operation.createPost(newCustomNodeGroupUri)\n                    .setBody(joinBody)\n                    .setCompletion(testContext.getCompletion()));\n            expectedOptionsPerNode.put(newCustomNodeGroupUri, joinBody.localNodeOptions);\n        }\n\n        testContext.await();\n        this.host.waitForNodeGroupConvergence(this.host.getNodeGroupMap().values(),\n                this.host.getNodeGroupMap().size(),\n                this.host.getNodeGroupMap().size(),\n                expectedOptionsPerNode, false);\n\n        restartCount = 0;\n        // do another restart check. None of the new nodes should have reported restarts\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            URI nodeGroupUri = UriUtils.buildUri(hostUri, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            ServiceStats nodeGroupStats = this.host.getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(nodeGroupUri));\n            ServiceStat restartStat = nodeGroupStats.entries\n                    .get(NodeGroupService.STAT_NAME_RESTARTING_SERVICES_COUNT);\n            if (restartStat != null) {\n                restartCount += restartStat.latestValue;\n            }\n        }\n\n        assertEquals(\"expected different number of service restarts\", 0,\n                restartCount);\n    }\n\n    @Test\n    public void verifyGossipForObservers() throws Throwable {\n        setUp(this.nodeCount);\n\n        Iterator<Entry<URI, URI>> nodeGroupIterator = this.host.getNodeGroupMap().entrySet()\n                .iterator();\n        URI observerUri = nodeGroupIterator.next().getKey();\n        String observerId = this.host.getServiceState(null,\n                ServiceHostState.class,\n                UriUtils.buildUri(observerUri, ServiceUriPaths.CORE_MANAGEMENT)).id;\n\n        // Create a custom node group. Mark one node as OBSERVER and rest as PEER\n        Map<URI, NodeState> selfStatePerNode = new HashMap<>();\n        NodeState observerSelfState = new NodeState();\n        observerSelfState.id = observerId;\n        observerSelfState.options = EnumSet.of(NodeOption.OBSERVER);\n        selfStatePerNode.put(observerUri, observerSelfState);\n        this.host.createCustomNodeGroupOnPeers(CUSTOM_NODE_GROUP_NAME, selfStatePerNode);\n\n        // Pick a PEER and join it to each node in the node-group\n        URI peerUri = nodeGroupIterator.next().getKey();\n        URI peerCustomUri = UriUtils.buildUri(peerUri, CUSTOM_NODE_GROUP);\n\n        Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode = new HashMap<>();\n        Set<URI> customNodeUris = new HashSet<>();\n\n        for (Entry<URI, URI> node : this.host.getNodeGroupMap().entrySet()) {\n            URI nodeUri = node.getKey();\n            URI nodeCustomUri = UriUtils.buildUri(nodeUri, CUSTOM_NODE_GROUP);\n\n            JoinPeerRequest request = new JoinPeerRequest();\n            request.memberGroupReference = nodeCustomUri;\n            TestContext ctx = this.host.testCreate(1);\n            Operation post = Operation\n                    .createPost(peerCustomUri)\n                    .setBody(request)\n                    .setReferer(this.host.getReferer())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(post);\n            ctx.await();\n\n            expectedOptionsPerNode.put(nodeCustomUri,\n                    EnumSet.of((nodeUri == observerUri)\n                            ? NodeOption.OBSERVER : NodeOption.PEER));\n            customNodeUris.add(nodeCustomUri);\n        }\n\n        // Verify that gossip will propagate the single OBSERVER and the PEER nodes\n        // to every node in the custom node-group.\n        this.host.waitForNodeGroupConvergence(\n                customNodeUris, this.nodeCount, this.nodeCount, expectedOptionsPerNode, false);\n    }\n\n    @Test\n    public void synchronizationOneByOneWithAbruptNodeShutdown() throws Throwable {\n        setUp(this.nodeCount);\n\n        this.replicationTargetFactoryLink = PeriodicExampleFactoryService.SELF_LINK;\n        // start the periodic example service factory on each node\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.startServiceAndWait(PeriodicExampleFactoryService.class,\n                    PeriodicExampleFactoryService.SELF_LINK);\n        }\n\n        // On one host, add some services. They exist only on this host and we expect them to synchronize\n        // across all hosts once this one joins with the group\n        VerificationHost initialHost = this.host.getPeerHost();\n        URI hostUriWithInitialState = initialHost.getUri();\n        Map<String, ExampleServiceState> exampleStatesPerSelfLink = createExampleServices(\n                hostUriWithInitialState);\n\n        URI hostWithStateNodeGroup = UriUtils.buildUri(hostUriWithInitialState,\n                ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n        // before start joins, verify isolated factory synchronization is done\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            waitForReplicatedFactoryServiceAvailable(\n                    UriUtils.buildUri(hostUri, this.replicationTargetFactoryLink),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        }\n\n        // join a node, with no state, one by one, to the host with state.\n        // The steps are:\n        // 1) set quorum to node group size + 1\n        // 2) Join new empty node with existing node group\n        // 3) verify convergence of factory state\n        // 4) repeat\n\n        List<URI> joinedHosts = new ArrayList<>();\n        Map<URI, URI> factories = new HashMap<>();\n        factories.put(hostWithStateNodeGroup, UriUtils.buildUri(hostWithStateNodeGroup,\n                this.replicationTargetFactoryLink));\n        joinedHosts.add(hostWithStateNodeGroup);\n        int fullQuorum = 1;\n\n        for (URI nodeGroupUri : this.host.getNodeGroupMap().values()) {\n            // skip host with state\n            if (hostWithStateNodeGroup.equals(nodeGroupUri)) {\n                continue;\n            }\n\n            this.host.log(\"Setting quorum to %d, already joined: %d\",\n                    fullQuorum + 1, joinedHosts.size());\n            // set quorum to expected full node group size, for the setup hosts\n            this.host.setNodeGroupQuorum(++fullQuorum);\n\n            this.host.testStart(1);\n            // join empty node, with node with state\n            this.host.joinNodeGroup(hostWithStateNodeGroup, nodeGroupUri, fullQuorum);\n            this.host.testWait();\n            joinedHosts.add(nodeGroupUri);\n            factories.put(nodeGroupUri, UriUtils.buildUri(nodeGroupUri,\n                    this.replicationTargetFactoryLink));\n            this.host.waitForNodeGroupConvergence(joinedHosts, fullQuorum, fullQuorum, true);\n            this.host.waitForNodeGroupIsAvailableConvergence(nodeGroupUri.getPath(), joinedHosts);\n\n            this.waitForReplicatedFactoryChildServiceConvergence(\n                    factories,\n                    exampleStatesPerSelfLink,\n                    this.exampleStateConvergenceChecker, exampleStatesPerSelfLink.size(),\n                    0);\n\n            // Do updates, which will verify that the services are converged in terms of ownership.\n            // Since we also synchronize on demand, if there was any discrepancy, after updates, the\n            // services will converge\n            doExampleServicePatch(exampleStatesPerSelfLink,\n                    joinedHosts.get(0));\n\n            Set<String> ownerIds = this.host.getNodeStateMap().keySet();\n            verifyDocumentOwnerAndEpoch(exampleStatesPerSelfLink, initialHost, joinedHosts, 0, 1,\n                    ownerIds.size() - 1);\n        }\n\n        doNodeStopWithUpdates(exampleStatesPerSelfLink);\n    }\n\n    private void doExampleServicePatch(Map<String, ExampleServiceState> states,\n            URI nodeGroupOnSomeHost) throws Throwable {\n        this.host.log(\"Starting PATCH to %d example services\", states.size());\n        TestContext ctx = this.host\n                .testCreate(this.updateCount * states.size());\n\n        this.setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(this.host.getTimeoutSeconds()));\n\n        for (int i = 0; i < this.updateCount; i++) {\n            for (Entry<String, ExampleServiceState> e : states.entrySet()) {\n                ExampleServiceState st = Utils.clone(e.getValue());\n                st.counter = (long) i;\n                Operation patch = Operation\n                        .createPatch(UriUtils.buildUri(nodeGroupOnSomeHost, e.getKey()))\n                        .setCompletion(ctx.getCompletion())\n                        .setBody(st);\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait(ctx);\n        this.host.log(\"Done with PATCH to %d example services\", states.size());\n    }\n\n    public void doNodeStopWithUpdates(Map<String, ExampleServiceState> exampleStatesPerSelfLink)\n            throws Throwable {\n        this.host.log(\"Starting to stop nodes and send updates\");\n        VerificationHost remainingHost = this.host.getPeerHost();\n        Collection<VerificationHost> hostsToStop = new ArrayList<>(this.host.getInProcessHostMap()\n                .values());\n        hostsToStop.remove(remainingHost);\n        List<URI> targetServices = new ArrayList<>();\n        for (String link : exampleStatesPerSelfLink.keySet()) {\n            // build the URIs using the host we plan to keep, so the maps we use below to lookup\n            // stats from URIs, work before and after node stop\n            targetServices.add(UriUtils.buildUri(remainingHost, link));\n        }\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setPeerSynchronizationTimeLimitSeconds(this.host.getTimeoutSeconds() / 3);\n        }\n\n        // capture current stats from each service\n        Map<URI, ServiceStats> prevStats = verifyMaintStatsAfterSynchronization(targetServices,\n                null);\n\n        stopHostsAndVerifyQueuing(hostsToStop, remainingHost, targetServices);\n\n        // its important to verify document ownership before we do any updates on the services.\n        // This is because we verify, that even without any on demand synchronization,\n        // the factory driven synchronization set the services in the proper state\n        Set<String> ownerIds = this.host.getNodeStateMap().keySet();\n        List<URI> remainingHosts = new ArrayList<>(this.host.getNodeGroupMap().keySet());\n        verifyDocumentOwnerAndEpoch(exampleStatesPerSelfLink,\n                this.host.getInProcessHostMap().values().iterator().next(),\n                remainingHosts, 0, 1,\n                ownerIds.size() - 1);\n\n        // confirm maintenance is back up and running on all services\n        verifyMaintStatsAfterSynchronization(targetServices, prevStats);\n\n        // nodes are stopped, do updates again, quorum is relaxed, they should work\n        doExampleServicePatch(exampleStatesPerSelfLink, remainingHost.getUri());\n\n        this.host.log(\"Done with stop nodes and send updates\");\n    }\n\n    private void verifyDynamicMaintOptionToggle(Map<String, ExampleServiceState> childStates) {\n\n        List<URI> targetServices = new ArrayList<>();\n        childStates.keySet().forEach((l) -> targetServices.add(this.host.getPeerServiceUri(l)));\n\n        List<URI> targetServiceStats = new ArrayList<>();\n        List<URI> targetServiceConfig = new ArrayList<>();\n        for (URI child : targetServices) {\n            targetServiceStats.add(UriUtils.buildStatsUri(child));\n            targetServiceConfig.add(UriUtils.buildConfigUri(child));\n        }\n\n        Map<URI, ServiceConfiguration> configPerService = this.host.getServiceState(\n                null, ServiceConfiguration.class, targetServiceConfig);\n        for (ServiceConfiguration cfg : configPerService.values()) {\n            assertTrue(!cfg.options.contains(ServiceOption.PERIODIC_MAINTENANCE));\n        }\n\n        for (URI child : targetServices) {\n            this.host.toggleServiceOptions(child,\n                    EnumSet.of(ServiceOption.PERIODIC_MAINTENANCE),\n                    null);\n        }\n\n        verifyMaintStatsAfterSynchronization(targetServices, null);\n    }\n\n    private Map<URI, ServiceStats> verifyMaintStatsAfterSynchronization(List<URI> targetServices,\n            Map<URI, ServiceStats> statsPerService) {\n\n        List<URI> targetServiceStats = new ArrayList<>();\n        List<URI> targetServiceConfig = new ArrayList<>();\n        for (URI child : targetServices) {\n            targetServiceStats.add(UriUtils.buildStatsUri(child));\n            targetServiceConfig.add(UriUtils.buildConfigUri(child));\n        }\n\n        if (statsPerService == null) {\n            statsPerService = new HashMap<>();\n        }\n        final Map<URI, ServiceStats> previousStatsPerService = statsPerService;\n        this.host.waitFor(\n                \"maintenance not enabled\",\n                () -> {\n                    Map<URI, ServiceStats> stats = this.host.getServiceState(null,\n                            ServiceStats.class, targetServiceStats);\n                    for (Entry<URI, ServiceStats> currentEntry : stats.entrySet()) {\n                        ServiceStats previousStats = previousStatsPerService.get(currentEntry\n                                .getKey());\n                        ServiceStats currentStats = currentEntry.getValue();\n                        ServiceStat previousMaintStat = previousStats == null ? new ServiceStat()\n                                : previousStats.entries\n                                .get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                        double previousValue = previousMaintStat == null ? 0L\n                                : previousMaintStat.latestValue;\n                        ServiceStat maintStat = currentStats.entries\n                                .get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                        if (maintStat == null || maintStat.latestValue <= previousValue) {\n                            return false;\n                        }\n                    }\n                    previousStatsPerService.putAll(stats);\n                    return true;\n                });\n        return statsPerService;\n    }\n\n    private Map<String, ExampleServiceState> createExampleServices(URI hostUri) throws Throwable {\n        URI factoryUri = UriUtils.buildUri(hostUri, this.replicationTargetFactoryLink);\n        this.host.log(\"POSTing children to %s\", hostUri);\n\n        // add some services on one of the peers, so we can verify the get synchronized after they all join\n        Map<URI, ExampleServiceState> exampleStates = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState s = new ExampleServiceState();\n                    s.name = UUID.randomUUID().toString();\n                    o.setBody(s);\n                }, factoryUri);\n\n        Map<String, ExampleServiceState> exampleStatesPerSelfLink = new HashMap<>();\n\n        for (ExampleServiceState s : exampleStates.values()) {\n            exampleStatesPerSelfLink.put(s.documentSelfLink, s);\n        }\n        return exampleStatesPerSelfLink;\n    }\n\n    @Test\n    public void synchronizationWithPeerNodeListAndDuplicates() throws Throwable {\n        ExampleServiceHost h = null;\n\n        TemporaryFolder tmpFolder = new TemporaryFolder();\n        tmpFolder.create();\n\n        try {\n            setUp(this.nodeCount);\n\n            // the hosts are started, but not joined. We need to relax the quorum for any updates\n            // to go through\n            this.host.setNodeGroupQuorum(1);\n\n            Map<String, ExampleServiceState> exampleStatesPerSelfLink = new HashMap<>();\n\n            // add the *same* service instance, all *all* peers, so we force synchronization and epoch\n            // change on an instance that exists everywhere\n\n            int dupServiceCount = this.serviceCount;\n            AtomicInteger counter = new AtomicInteger();\n            Map<URI, ExampleServiceState> dupStates = new HashMap<>();\n            for (VerificationHost v : this.host.getInProcessHostMap().values()) {\n                counter.set(0);\n                URI factoryUri = UriUtils.buildFactoryUri(v,\n                        ExampleService.class);\n                dupStates = this.host.doFactoryChildServiceStart(\n                        null,\n                        dupServiceCount,\n                        ExampleServiceState.class,\n                        (o) -> {\n                            ExampleServiceState s = new ExampleServiceState();\n                            s.documentSelfLink = \"duplicateExampleInstance-\"\n                                    + counter.incrementAndGet();\n                            s.name = s.documentSelfLink;\n                            o.setBody(s);\n                        }, factoryUri);\n            }\n\n            for (ExampleServiceState s : dupStates.values()) {\n                exampleStatesPerSelfLink.put(s.documentSelfLink, s);\n            }\n\n            // increment to account for link found on all nodes\n            this.serviceCount = exampleStatesPerSelfLink.size();\n\n            // create peer argument list, all the nodes join.\n            Collection<URI> peerNodeGroupUris = new ArrayList<>();\n            StringBuilder peerNodes = new StringBuilder();\n            for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n                peerNodeGroupUris.add(UriUtils.buildUri(peer, ServiceUriPaths.DEFAULT_NODE_GROUP));\n                peerNodes.append(peer.getUri().toString()).append(\",\");\n            }\n\n            CountDownLatch notifications = new CountDownLatch(this.nodeCount);\n            for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n                this.host.subscribeForNodeGroupConvergence(nodeGroup, this.nodeCount + 1,\n                        (o, e) -> {\n                            if (e != null) {\n                                this.host.log(\"Error in notificaiton: %s\", Utils.toString(e));\n                                return;\n                            }\n                            notifications.countDown();\n                        });\n            }\n\n            // now start a new Host and supply the already created peer, then observe the automatic\n            // join\n            h = new ExampleServiceHost();\n            int quorum = this.host.getPeerCount() + 1;\n\n            String mainHostId = \"main-\" + VerificationHost.hostNumber.incrementAndGet();\n            String[] args = {\n                    \"--port=0\",\n                    \"--id=\" + mainHostId,\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + peerNodes.toString()\n            };\n\n            h.initialize(args);\n\n            h.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled);\n            h.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n\n            h.start();\n            URI mainHostNodeGroupUri = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n            int totalCount = this.nodeCount + 1;\n            peerNodeGroupUris.add(mainHostNodeGroupUri);\n            this.host.waitForNodeGroupIsAvailableConvergence();\n            this.host.waitForNodeGroupConvergence(peerNodeGroupUris, totalCount,\n                    totalCount, true);\n\n            this.host.setNodeGroupQuorum(quorum, mainHostNodeGroupUri);\n            this.host.setNodeGroupQuorum(quorum);\n\n            this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n\n            int peerNodeCount = h.getInitialPeerHosts().size();\n            // include self in peers\n            assertTrue(totalCount >= peerNodeCount + 1);\n\n            // Before factory synch is complete, make sure POSTs to existing services fail,\n            // since they are not marked idempotent.\n            verifyReplicatedInConflictPost(dupStates);\n\n            // now verify all nodes synchronize and see the example service instances that existed on the single\n            // host\n            waitForReplicatedFactoryChildServiceConvergence(\n                    exampleStatesPerSelfLink,\n                    this.exampleStateConvergenceChecker,\n                    this.serviceCount, 0);\n\n            // Send some updates after the full group has formed  and verify the updates are seen by services on all nodes\n\n            doStateUpdateReplicationTest(Action.PATCH, this.serviceCount, this.updateCount, 0,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    exampleStatesPerSelfLink);\n\n            URI exampleFactoryUri = this.host.getPeerServiceUri(ExampleService.FACTORY_LINK);\n            waitForReplicatedFactoryServiceAvailable(\n                    UriUtils.buildUri(exampleFactoryUri, ExampleService.FACTORY_LINK),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        } finally {\n            this.host.log(\"test finished\");\n            if (h != null) {\n                h.stop();\n                tmpFolder.delete();\n            }\n        }\n    }\n\n    private void verifyReplicatedInConflictPost(Map<URI, ExampleServiceState> dupStates)\n            throws Throwable {\n        // Its impossible to guarantee that this runs during factory synch. It might run before,\n        // it might run during, it might run after. Since we runs 1000s of tests per day, CI\n        // will let us know if the production code works. Here, we add a small sleep so we increase\n        // chance we overlap with factory synchronization.\n        Thread.sleep(TimeUnit.MICROSECONDS.toMillis(\n                this.host.getPeerHost().getMaintenanceIntervalMicros()));\n        // Issue a POST for a service we know exists and expect failure, since the example service\n        // is not marked IDEMPOTENT. We expect CONFLICT error code, but if synchronization is active\n        // we want to confirm we dont get 500, but the 409 is preserved\n        TestContext ctx = this.host.testCreate(dupStates.size());\n        for (ExampleServiceState st : dupStates.values()) {\n            URI factoryUri = this.host.getPeerServiceUri(ExampleService.FACTORY_LINK);\n            Operation post = Operation.createPost(factoryUri).setBody(st)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_CONFLICT) {\n                                ctx.failIteration(new IllegalStateException(\n                                        \"Expected conflict status, got \" + o.getStatusCode()));\n                                return;\n                            }\n                            ctx.completeIteration();\n                            return;\n                        }\n                        ctx.failIteration(new IllegalStateException(\n                                \"Expected failure on duplicate POST\"));\n                    });\n            this.host.send(post);\n        }\n        this.host.testWait(ctx);\n    }\n\n    @Test\n    public void replicationWithQuorumAfterAbruptNodeStopOnDemandLoad() throws Throwable {\n        tearDown();\n        for (int i = 0; i < this.testIterationCount; i++) {\n\n            setUpOnDemandLoad();\n\n            int hostStopCount = 2;\n            doReplicationWithQuorumAfterAbruptNodeStop(hostStopCount);\n            this.host.log(\"Done with iteration %d\", i);\n            tearDown();\n            this.host = null;\n        }\n    }\n\n    private void doReplicationWithQuorumAfterAbruptNodeStop(int hostStopCount)\n            throws Throwable {\n        // create some documents\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n        updateExampleServiceOptions(childStates);\n\n        // stop minority number of hosts - quorum is still intact\n        int i = 0;\n        for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n            this.expectedFailedHosts.add(e.getKey());\n            this.host.stopHost(e.getValue());\n            if (++i >= hostStopCount) {\n                break;\n            }\n        }\n\n        // do some updates with strong quorum enabled\n        int expectedVersion = this.updateCount;\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                expectedVersion,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    @Test\n    public void replicationWithQuorumAfterAbruptNodeStopMultiLocation()\n            throws Throwable {\n        // we need 6 nodes, 3 in each location\n        this.nodeCount = 6;\n\n        this.isPeerSynchronizationEnabled = true;\n        this.skipAvailabilityChecks = true;\n        this.isMultiLocationTest = true;\n\n        if (this.host == null) {\n            // create node group, join nodes and set local majority quorum\n            setUp(this.nodeCount);\n            this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n            this.host.setNodeGroupQuorum(2);\n        }\n\n        // create some documents\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n        updateExampleServiceOptions(childStates);\n\n        // stop hosts in location \"L2\"\n        for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n            VerificationHost h = e.getValue();\n            if (h.getLocation().equals(VerificationHost.LOCATION2)) {\n                this.expectedFailedHosts.add(e.getKey());\n                this.host.stopHost(h);\n            }\n        }\n\n        // do some updates\n        int expectedVersion = this.updateCount;\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                expectedVersion,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    /**\n     * This test validates that if a host, joined in a peer node group, stops/fails and another\n     * host, listening on the same address:port, rejoins, the existing peer members will mark the\n     * OLD host instance as FAILED, and mark the new instance, with the new ID as HEALTHY\n     *\n     * @throws Throwable\n     */\n    @Test\n    public void nodeRestartWithSameAddressDifferentId() throws Throwable {\n        int failedNodeCount = 1;\n        int afterFailureQuorum = this.nodeCount - failedNodeCount;\n\n        setUp(this.nodeCount);\n        setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(5));\n\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        this.host.log(\"Stopping node\");\n\n        // relax quorum for convergence check\n        this.host.setNodeGroupQuorum(afterFailureQuorum);\n\n        // we should now have N nodes, that see each other. Stop one of the\n        // nodes, and verify the other host's node group deletes the entry\n        List<ServiceHostState> hostStates = stopHostsToSimulateFailure(failedNodeCount);\n        URI remainingPeerNodeGroup = this.host.getPeerNodeGroupUri();\n\n        // wait for convergence of the remaining peers, before restarting. The failed host\n        // should be marked FAILED, otherwise we will not converge\n        this.host.waitForNodeGroupConvergence(this.nodeCount - failedNodeCount);\n\n        ServiceHostState stoppedHostState = hostStates.get(0);\n\n        // start a new HOST, with a new ID, but with the same address:port as the one we stopped\n        this.host.testStart(1);\n        VerificationHost newHost = this.host.setUpLocalPeerHost(stoppedHostState.httpPort,\n                VerificationHost.FAST_MAINT_INTERVAL_MILLIS, null);\n        this.host.testWait();\n\n        // re-join the remaining peers\n        URI newHostNodeGroupService = UriUtils\n                .buildUri(newHost.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.host.testStart(1);\n        this.host.joinNodeGroup(newHostNodeGroupService, remainingPeerNodeGroup);\n        this.host.testWait();\n\n        // now wait for convergence. If the logic is correct, the old HOST, that listened on the\n        // same port as the new host, should stay in the FAILED state, but the new host should\n        // be marked as HEALTHY\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n    }\n\n    public void setMaintenanceIntervalMillis(long defaultMaintIntervalMillis) {\n        for (VerificationHost h1 : this.host.getInProcessHostMap().values()) {\n            // set short interval so failure detection and convergence happens quickly\n            h1.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(defaultMaintIntervalMillis));\n        }\n    }\n\n    @Test\n    public void synchronizationRequestQueuing() throws Throwable {\n        setUp(this.nodeCount);\n\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicationFactoryConvergence();\n\n        VerificationHost peerHost = this.host.getPeerHost();\n\n        List<URI> exampleUris = new ArrayList<>();\n        this.host.createExampleServices(peerHost, 1, exampleUris, null);\n\n        URI instanceUri = exampleUris.get(0);\n\n        ExampleServiceState synchState = new ExampleServiceState();\n        synchState.documentSelfLink = UriUtils.getLastPathSegment(instanceUri);\n\n        TestContext ctx = this.host.testCreate(this.updateCount);\n        for (int i = 0; i < this.updateCount; i++) {\n            Operation op = Operation.createPost(peerHost, ExampleService.FACTORY_LINK)\n                    .setBody(synchState)\n                    .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SYNCH_OWNER)\n                    .setReferer(this.host.getUri())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(op);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void enforceHighQuorumWithNodeConcurrentStop()\n            throws Throwable {\n        int hostRestartCount = 2;\n\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n\n        updateExampleServiceOptions(childStates);\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setPeerSynchronizationTimeLimitSeconds(1);\n        }\n\n        this.host.setNodeGroupConfig(this.nodeGroupConfig);\n        this.host.setNodeGroupQuorum((this.nodeCount + 1) / 2);\n\n        // do some replication with strong quorum enabled\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                0,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        long now = Utils.getNowMicrosUtc();\n\n        validatePerOperationReplicationQuorum(childStates, now);\n\n        // expect failure, since we will stop some hosts, break quorum\n        this.expectFailure = true;\n\n        // when quorum is not met the runtime will just queue requests until expiration, so\n        // we set expiration to something quick. Some requests will make it past queuing\n        // and will fail because replication quorum is not met\n        long opTimeoutMicros = TimeUnit.MILLISECONDS.toMicros(500);\n        setOperationTimeoutMicros(opTimeoutMicros);\n\n        int i = 0;\n        for (URI h : this.host.getInProcessHostMap().keySet()) {\n            this.expectedFailedHosts.add(h);\n            if (++i >= hostRestartCount) {\n                break;\n            }\n        }\n\n        // stop one host right away\n        stopHostsToSimulateFailure(1);\n\n        // concurrently with the PATCH requests below, stop another host\n        Runnable r = () -> {\n            stopHostsToSimulateFailure(hostRestartCount - 1);\n            // add a small bit of time slop since its feasible a host completed a operation *after* we stopped it,\n            // the netty handlers are stopped in async (not forced) mode\n            this.expectedFailureStartTimeMicros = Utils.getNowMicrosUtc()\n                    + TimeUnit.MILLISECONDS.toMicros(250);\n\n        };\n        this.host.schedule(r, 1, TimeUnit.MILLISECONDS);\n\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                this.updateCount,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        doStateUpdateReplicationTest(Action.PATCH, childStates.size(), this.updateCount,\n                this.updateCount * 2,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        doStateUpdateReplicationTest(Action.PATCH, childStates.size(), 1,\n                this.updateCount * 2,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    private void validatePerOperationReplicationQuorum(Map<String, ExampleServiceState> childStates,\n            long now) throws Throwable {\n        Random r = new Random();\n        // issue a patch, with per operation quorum set, verify it applied\n        for (Entry<String, ExampleServiceState> e : childStates.entrySet()) {\n            TestContext ctx = this.host.testCreate(1);\n            ExampleServiceState body = e.getValue();\n            body.counter = now;\n            Operation patch = Operation.createPatch(this.host.getPeerServiceUri(e.getKey()))\n                    .setCompletion(ctx.getCompletion())\n                    .setBody(body);\n\n            // add an explicit replication count header, using either the \"all\" value, or an\n            // explicit node count\n            if (r.nextBoolean()) {\n                patch.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                        Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n            } else {\n                patch.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                        this.nodeCount + \"\");\n            }\n\n            this.host.send(patch);\n            this.host.testWait(ctx);\n            // Go to each peer, directly to their index, and verify update is present. This is not\n            // proof the per operation quorum was applied \"synchronously\", before the response\n            // was sent, but over many runs, if there is a race or its applied asynchronously,\n            // we will see failures\n            for (URI hostBaseUri : this.host.getNodeGroupMap().keySet()) {\n                URI indexUri = UriUtils.buildUri(hostBaseUri, ServiceUriPaths.CORE_DOCUMENT_INDEX);\n                indexUri = UriUtils.buildIndexQueryUri(indexUri,\n                        e.getKey(), true, false, ServiceOption.PERSISTENCE);\n\n                ExampleServiceState afterState = this.host.getServiceState(null,\n                        ExampleServiceState.class, indexUri);\n                assertEquals(body.counter, afterState.counter);\n            }\n        }\n\n        this.host.toggleNegativeTestMode(true);\n        // verify that if we try to set per operation quorum too high, request will fail\n        for (Entry<String, ExampleServiceState> e : childStates.entrySet()) {\n            TestContext ctx = this.host.testCreate(1);\n            ExampleServiceState body = e.getValue();\n            body.counter = now;\n            Operation patch = Operation.createPatch(this.host.getPeerServiceUri(e.getKey()))\n                    .addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                            (this.nodeCount * 2) + \"\")\n                    .setCompletion(ctx.getExpectedFailureCompletion())\n                    .setBody(body);\n            this.host.send(patch);\n            this.host.testWait(ctx);\n            break;\n        }\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    private void setOperationTimeoutMicros(long opTimeoutMicros) {\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setOperationTimeOutMicros(opTimeoutMicros);\n        }\n        this.host.setOperationTimeOutMicros(opTimeoutMicros);\n    }\n\n    /**\n     * This test creates N local service hosts, each with K instances of a replicated service. The\n     * service will create a query task, also replicated, and self patch itself. The test makes sure\n     * all K instances, on all N hosts see the self PATCHs AND that the query tasks exist on all\n     * hosts\n     *\n     * @throws Throwable\n     */\n    @Test\n    public void replicationWithCrossServiceDependencies() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        setUp(this.nodeCount);\n\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n\n        Consumer<Operation> setBodyCallback = (o) -> {\n            ReplicationTestServiceState s = new ReplicationTestServiceState();\n            s.stringField = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n\n        URI hostUri = this.host.getPeerServiceUri(null);\n\n        URI factoryUri = UriUtils.buildUri(hostUri,\n                ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK);\n        doReplicatedServiceFactoryPost(this.serviceCount, setBodyCallback, factoryUri);\n\n        factoryUri = UriUtils.buildUri(hostUri,\n                ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK);\n        Map<URI, ReplicationTestServiceState> ownerSelectedServices = doReplicatedServiceFactoryPost(\n                this.serviceCount, setBodyCallback, factoryUri);\n\n        factoryUri = UriUtils.buildUri(hostUri, ReplicationFactoryTestService.STRICT_SELF_LINK);\n        doReplicatedServiceFactoryPost(this.serviceCount, setBodyCallback, factoryUri);\n\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        Query kindClause = new Query();\n        kindClause.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND)\n                .setTermMatchValue(Utils.buildKind(ReplicationTestServiceState.class));\n        q.query.addBooleanClause(kindClause);\n\n        Query nameClause = new Query();\n        nameClause.setTermPropertyName(\"stringField\")\n                .setTermMatchValue(\"*\")\n                .setTermMatchType(MatchType.WILDCARD);\n        q.query.addBooleanClause(nameClause);\n\n        // expect results for strict and regular service instances\n        int expectedServiceCount = this.serviceCount * 3;\n\n        Date exp = this.host.getTestExpiration();\n        while (exp.after(new Date())) {\n            // create N direct query tasks. Direct tasks complete in the context of the POST to the\n            // query task factory\n            int count = 10;\n            URI queryFactoryUri = UriUtils.extendUri(hostUri,\n                    ServiceUriPaths.CORE_QUERY_TASKS);\n            TestContext testContext = this.host.testCreate(count);\n\n            Map<String, QueryTask> taskResults = new ConcurrentSkipListMap<>();\n            for (int i = 0; i < count; i++) {\n                QueryTask qt = QueryTask.create(q);\n                qt.taskInfo.isDirect = true;\n                qt.documentSelfLink = UUID.randomUUID().toString();\n                Operation startPost = Operation\n                        .createPost(queryFactoryUri)\n                        .setBody(qt)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContext.fail(e);\n                                        return;\n                                    }\n\n                                    QueryTask rsp = o.getBody(QueryTask.class);\n                                    qt.results = rsp.results;\n                                    qt.documentOwner = rsp.documentOwner;\n                                    taskResults.put(rsp.documentSelfLink, qt);\n                                    testContext.complete();\n                                });\n\n                this.host.send(startPost);\n            }\n            testContext.await();\n            this.host.logThroughput();\n\n            boolean converged = true;\n            for (QueryTask qt : taskResults.values()) {\n                if (qt.results == null || qt.results.documentLinks == null) {\n                    throw new IllegalStateException(\"Missing results\");\n                }\n                if (qt.results.documentLinks.size() != expectedServiceCount) {\n                    this.host.log(\"%s\", Utils.toJsonHtml(qt));\n                    converged = false;\n                    break;\n                }\n            }\n\n            if (!converged) {\n                Thread.sleep(250);\n                continue;\n            }\n            break;\n        }\n\n        if (exp.before(new Date())) {\n            throw new TimeoutException();\n        }\n\n        // Negative tests: Make sure custom error response body is preserved\n        URI childUri = ownerSelectedServices.keySet().iterator().next();\n        TestContext testContext = this.host.testCreate(1);\n        ReplicationTestServiceState badRequestBody = new ReplicationTestServiceState();\n        this.host\n                .send(Operation\n                        .createPatch(childUri)\n                        .setBody(badRequestBody)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e == null) {\n                                        testContext.fail(new IllegalStateException(\n                                                \"Expected failure\"));\n                                        return;\n                                    }\n\n                                    ReplicationTestServiceErrorResponse rsp = o\n                                            .getBody(ReplicationTestServiceErrorResponse.class);\n                                    if (!ReplicationTestServiceErrorResponse.KIND\n                                            .equals(rsp.documentKind)) {\n                                        testContext.fail(new IllegalStateException(\n                                                \"Expected custom response body\"));\n                                        return;\n                                    }\n\n                                    testContext.complete();\n                                }));\n        testContext.await();\n\n        // verify that each owner selected service reports stats from the same node that reports state\n        Map<URI, ReplicationTestServiceState> latestState = this.host.getServiceState(null,\n                ReplicationTestServiceState.class, ownerSelectedServices.keySet());\n        Map<String, String> ownerIdPerLink = new HashMap<>();\n        List<URI> statsUris = new ArrayList<>();\n        for (ReplicationTestServiceState state : latestState.values()) {\n            URI statsUri = this.host.getPeerServiceUri(UriUtils.buildUriPath(\n                    state.documentSelfLink, ServiceHost.SERVICE_URI_SUFFIX_STATS));\n            ownerIdPerLink.put(state.documentSelfLink, state.documentOwner);\n            statsUris.add(statsUri);\n        }\n\n        Map<URI, ServiceStats> latestStats = this.host.getServiceState(null, ServiceStats.class,\n                statsUris);\n        for (ServiceStats perServiceStats : latestStats.values()) {\n\n            String serviceLink = UriUtils.getParentPath(perServiceStats.documentSelfLink);\n            String expectedOwnerId = ownerIdPerLink.get(serviceLink);\n            if (expectedOwnerId.equals(perServiceStats.documentOwner)) {\n                continue;\n            }\n            throw new IllegalStateException(\"owner routing issue with stats: \"\n                    + Utils.toJsonHtml(perServiceStats));\n\n        }\n\n        exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            // verify all factories report same number of children\n            for (VerificationHost peerHost : this.host.getInProcessHostMap().values()) {\n                factoryUri = UriUtils.buildUri(peerHost,\n                        ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK);\n                ServiceDocumentQueryResult rsp = this.host.getFactoryState(factoryUri);\n                if (rsp.documentLinks.size() != latestState.size()) {\n                    this.host.log(\"Factory %s reporting %d children, expected %d\", factoryUri,\n                            rsp.documentLinks.size(), latestState.size());\n                    isConverged = false;\n                    break;\n                }\n            }\n            if (!isConverged) {\n                Thread.sleep(250);\n                continue;\n            }\n            break;\n        }\n\n        if (new Date().after(exp)) {\n            throw new TimeoutException(\"factories did not converge\");\n        }\n\n        this.host.log(\"Inducing synchronization\");\n        // Induce synchronization on stable node group. No changes should be observed since\n        // all nodes should have identical state\n        this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n        // give synchronization a chance to run, its 100% asynchronous so we can't really tell when each\n        // child is done, but a small delay should be sufficient for 99.9% of test environments, even under\n        // load\n        Thread.sleep(2000);\n\n        // verify that example states did not change due to the induced synchronization\n        Map<URI, ReplicationTestServiceState> latestStateAfter = this.host.getServiceState(null,\n                ReplicationTestServiceState.class, ownerSelectedServices.keySet());\n        for (Entry<URI, ReplicationTestServiceState> afterEntry : latestStateAfter.entrySet()) {\n            ReplicationTestServiceState beforeState = latestState.get(afterEntry.getKey());\n            ReplicationTestServiceState afterState = afterEntry.getValue();\n            assertEquals(beforeState.documentVersion, afterState.documentVersion);\n        }\n\n        verifyOperationJoinAcrossPeers(latestStateAfter);\n    }\n\n    private Map<URI, ReplicationTestServiceState> doReplicatedServiceFactoryPost(int serviceCount,\n            Consumer<Operation> setBodyCallback, URI factoryUri) throws Throwable,\n            InterruptedException, TimeoutException {\n\n        ServiceDocumentDescription sdd = this.host\n                .buildDescription(ReplicationTestServiceState.class);\n        Map<URI, ReplicationTestServiceState> serviceMap = this.host.doFactoryChildServiceStart(\n                null, serviceCount, ReplicationTestServiceState.class, setBodyCallback, factoryUri);\n\n        Date expiration = this.host.getTestExpiration();\n        boolean isConverged = true;\n        Map<URI, String> uriToSignature = new HashMap<>();\n        while (new Date().before(expiration)) {\n            isConverged = true;\n            uriToSignature.clear();\n            for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n                URI baseUri = e.getKey();\n                VerificationHost h = e.getValue();\n                URI u = UriUtils.buildUri(baseUri, factoryUri.getPath());\n                u = UriUtils.buildExpandLinksQueryUri(u);\n                ServiceDocumentQueryResult r = this.host.getFactoryState(u);\n                if (r.documents.size() != serviceCount) {\n                    this.host.log(\"instance count mismatch, expected %d, got %d, from %s\",\n                            serviceCount, r.documents.size(), u);\n                    isConverged = false;\n                    break;\n                }\n\n                for (URI instanceUri : serviceMap.keySet()) {\n                    ReplicationTestServiceState initialState = serviceMap.get(instanceUri);\n                    ReplicationTestServiceState newState = Utils.fromJson(\n                            r.documents.get(instanceUri.getPath()),\n                            ReplicationTestServiceState.class);\n                    if (newState.documentVersion == 0) {\n                        this.host.log(\"version mismatch, expected %d, got %d, from %s\", 0,\n                                newState.documentVersion, instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (initialState.stringField.equals(newState.stringField)) {\n                        this.host.log(\"field mismatch, expected %s, got %s, from %s\",\n                                initialState.stringField, newState.stringField, instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (newState.queryTaskLink == null) {\n                        this.host.log(\"missing query task link from %s\", instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    // Only instances with OWNER_SELECTION patch string field with self link so bypass this check\n                    if (!newState.documentSelfLink\n                            .contains(ReplicationFactoryTestService.STRICT_SELF_LINK)\n                            && !newState.documentSelfLink\n                            .contains(ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK)\n                            && !newState.stringField.equals(newState.documentSelfLink)) {\n                        this.host.log(\"State not in final state\");\n                        isConverged = false;\n                        break;\n                    }\n\n                    String sig = uriToSignature.get(instanceUri);\n                    if (sig == null) {\n                        sig = Utils.computeSignature(newState, sdd);\n                        uriToSignature.put(instanceUri, sig);\n                    } else {\n                        String newSig = Utils.computeSignature(newState, sdd);\n                        if (!sig.equals(newSig)) {\n                            isConverged = false;\n                            this.host.log(\"signature mismatch, expected %s, got %s, from %s\",\n                                    sig, newSig, instanceUri);\n                        }\n                    }\n\n                    ProcessingStage ps = h.getServiceStage(newState.queryTaskLink);\n                    if (ps == null || ps != ProcessingStage.AVAILABLE) {\n                        this.host.log(\"missing query task service from %s\", newState.queryTaskLink,\n                                instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n                }\n\n                if (isConverged == false) {\n                    break;\n                }\n            }\n            if (isConverged == true) {\n                break;\n            }\n\n            Thread.sleep(100);\n        }\n\n        if (!isConverged) {\n            throw new TimeoutException(\"States did not converge\");\n        }\n\n        return serviceMap;\n    }\n\n    @Test\n    public void replicationWithOutOfOrderPostAndUpdates() throws Throwable {\n        // This test verifies that if a replica receives\n        // replication requests of POST and PATCH/PUT\n        // out-of-order, xenon can still handle it\n        // by doing retries for failed out-of-order\n        // updates. To verify this, we setup a node\n        // group and set quorum to just 1, so that the post\n        // returns as soon as the owner commits the post,\n        // so that we increase the chance of out-of-order\n        // update replication requests.\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(1);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicationFactoryConvergence();\n\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"testing\";\n        state.counter = 1L;\n\n        VerificationHost peer = this.host.getPeerHost();\n\n        TestContext ctx = this.host.testCreate(this.serviceCount * this.updateCount);\n        for (int i = 0; i < this.serviceCount; i++) {\n            Operation post = Operation\n                    .createPost(peer, ExampleService.FACTORY_LINK)\n                    .setBody(state)\n                    .setReferer(this.host.getUri())\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            ctx.failIteration(e);\n                            return;\n                        }\n\n                        ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n                        for (int k = 0; k < this.updateCount; k++) {\n                            ExampleServiceState update = new ExampleServiceState();\n                            state.counter = (long) k;\n                            Operation patch = Operation\n                                    .createPatch(peer, rsp.documentSelfLink)\n                                    .setBody(update)\n                                    .setReferer(this.host.getUri())\n                                    .setCompletion(ctx.getCompletion());\n                            this.host.sendRequest(patch);\n                        }\n\n                    });\n            this.host.sendRequest(post);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void replication() throws Throwable {\n        this.replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replicationSsl() throws Throwable {\n        this.replicationUriScheme = ServiceHost.HttpScheme.HTTPS_ONLY;\n        this.replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replication1x() throws Throwable {\n        this.replicationFactor = 1L;\n        this.replicationNodeSelector = ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR;\n        this.replicationTargetFactoryLink = Replication1xExampleFactoryService.SELF_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replication3x() throws Throwable {\n        this.replicationFactor = 3L;\n        this.replicationNodeSelector = ServiceUriPaths.DEFAULT_3X_NODE_SELECTOR;\n        this.replicationTargetFactoryLink = Replication3xExampleFactoryService.SELF_LINK;\n        this.nodeCount = Math.max(5, this.nodeCount);\n        doReplication();\n    }\n\n    private void doReplication() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        CommandLineArgumentParser.parseFromProperties(this);\n        Date expiration = new Date();\n        if (this.testDurationSeconds > 0) {\n            expiration = new Date(expiration.getTime()\n                    + TimeUnit.SECONDS.toMillis(this.testDurationSeconds));\n        }\n\n        Map<Action, Long> elapsedTimePerAction = new HashMap<>();\n        Map<Action, Long> countPerAction = new HashMap<>();\n\n        long totalOperations = 0;\n        int iterationCount = 0;\n        do {\n            if (this.host == null) {\n                setUp(this.nodeCount);\n                this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n                // for limited replication factor, we will still set the quorum high, and expect\n                // the limited replication selector to use the minimum between majority of replication\n                // factor, versus node group membership quorum\n                this.host.setNodeGroupQuorum(this.nodeCount);\n                // since we have disabled peer synch, trigger it explicitly so factories become available\n                this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n\n                waitForReplicatedFactoryServiceAvailable(\n                        this.host.getPeerServiceUri(this.replicationTargetFactoryLink),\n                        this.replicationNodeSelector);\n\n                waitForReplicationFactoryConvergence();\n                if (this.replicationUriScheme == ServiceHost.HttpScheme.HTTPS_ONLY) {\n                    // confirm nodes are joined using HTTPS group references\n                    for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n                        assertTrue(UriUtils.HTTPS_SCHEME.equals(nodeGroup.getScheme()));\n                    }\n                }\n\n            }\n\n            Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                    this.serviceCount, countPerAction, elapsedTimePerAction);\n            totalOperations += this.serviceCount;\n\n            if (this.testDurationSeconds == 0) {\n                // various validation tests, executed just once, ignored in long running test\n                this.host.doExampleServiceUpdateAndQueryByVersion(this.host.getPeerHostUri(),\n                        this.serviceCount);\n                verifyReplicatedForcedPostAfterDelete(childStates);\n                verifyInstantNotFoundFailureOnBadLinks();\n                verifyReplicatedIdempotentPost(childStates);\n                verifyDynamicMaintOptionToggle(childStates);\n            }\n\n            totalOperations += this.serviceCount;\n\n            if (expiration == null) {\n                expiration = this.host.getTestExpiration();\n            }\n            int expectedVersion = this.updateCount;\n\n            if (!this.host.isStressTest()\n                    && (this.host.getPeerCount() > 16\n                    || this.serviceCount * this.updateCount > 100)) {\n                this.host.setStressTest(true);\n            }\n\n            long opCount = this.serviceCount * this.updateCount;\n            childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                    this.updateCount,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n            expectedVersion += this.updateCount;\n\n            totalOperations += opCount;\n\n            childStates = doStateUpdateReplicationTest(Action.PUT, this.serviceCount,\n                    this.updateCount,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n\n            totalOperations += opCount;\n\n            Date queryExp = this.host.getTestExpiration();\n            if (expiration.after(queryExp)) {\n                queryExp = expiration;\n            }\n            while (new Date().before(queryExp)) {\n                Set<String> links = verifyReplicatedServiceCountWithBroadcastQueries();\n                if (links.size() < this.serviceCount) {\n                    this.host.log(\"Found only %d links across nodes, retrying\", links.size());\n                    Thread.sleep(500);\n                    continue;\n                }\n                break;\n            }\n\n            totalOperations += this.serviceCount;\n\n            if (queryExp.before(new Date())) {\n                throw new TimeoutException();\n            }\n\n            expectedVersion += 1;\n            doStateUpdateReplicationTest(Action.DELETE, this.serviceCount, 1,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n\n            totalOperations += this.serviceCount;\n\n            // compute the binary serialized payload, and the JSON payload size\n            ExampleServiceState st = childStates.values().iterator().next();\n            String json = Utils.toJson(st);\n            int byteCount = KryoSerializers.serializeDocument(st, 4096).position();\n            int jsonByteCount = json.getBytes(Utils.CHARSET).length;\n            // estimate total bytes transferred between nodes. The owner receives JSON from the client\n            // but then uses binary serialization to the N-1 replicas\n            long totalBytes = jsonByteCount * totalOperations\n                    + (this.nodeCount - 1) * byteCount * totalOperations;\n\n            this.host.log(\n                    \"Bytes per json:%d, per binary: %d, Total operations: %d, Total bytes:%d\",\n                    jsonByteCount,\n                    byteCount,\n                    totalOperations,\n                    totalBytes);\n\n            if (iterationCount++ < 2 && this.testDurationSeconds > 0) {\n                // ignore data during JVM warm-up, first two iterations\n                countPerAction.clear();\n                elapsedTimePerAction.clear();\n            }\n\n        } while (new Date().before(expiration) && this.totalOperationLimit > totalOperations);\n\n        logHostStats();\n        logPerActionThroughput(elapsedTimePerAction, countPerAction);\n\n        this.host.doNodeGroupStatsVerification(this.host.getNodeGroupMap());\n    }\n\n    private void logHostStats() {\n        for (URI u : this.host.getNodeGroupMap().keySet()) {\n            URI mgmtUri = UriUtils.buildUri(u, ServiceHostManagementService.SELF_LINK);\n            mgmtUri = UriUtils.buildStatsUri(mgmtUri);\n            ServiceStats stats = this.host.getServiceState(null, ServiceStats.class, mgmtUri);\n            this.host.log(\"%s: %s\", u, Utils.toJsonHtml(stats));\n        }\n    }\n\n    private void logPerActionThroughput(Map<Action, Long> elapsedTimePerAction,\n            Map<Action, Long> countPerAction) {\n        for (Action a : EnumSet.allOf(Action.class)) {\n            Long count = countPerAction.get(a);\n            if (count == null) {\n                continue;\n            }\n            Long elapsedMicros = elapsedTimePerAction.get(a);\n\n            double thpt = (count * 1.0) / (1.0 * elapsedMicros);\n            thpt *= 1000000;\n            this.host.log(\"Total ops for %s: %d, Throughput (ops/sec): %f\", a, count, thpt);\n        }\n    }\n\n    private void updatePerfDataPerAction(Action a, Long startTime, Long opCount,\n            Map<Action, Long> countPerAction, Map<Action, Long> elapsedTime) {\n        if (opCount == null || countPerAction != null) {\n            countPerAction.merge(a, opCount, (e, n) -> {\n                if (e == null) {\n                    return n;\n                }\n                return e + n;\n            });\n        }\n\n        if (startTime == null || elapsedTime == null) {\n            return;\n        }\n\n        long delta = Utils.getNowMicrosUtc() - startTime;\n        elapsedTime.merge(a, delta, (e, n) -> {\n            if (e == null) {\n                return n;\n            }\n            return e + n;\n        });\n    }\n\n    private void verifyReplicatedIdempotentPost(Map<String, ExampleServiceState> childStates)\n            throws Throwable {\n        // verify IDEMPOTENT POST conversion to PUT, with replication\n        // Since the factory is not idempotent by default, enable the option dynamically\n        Map<URI, URI> exampleFactoryUris = this.host\n                .getNodeGroupToFactoryMap(ExampleService.FACTORY_LINK);\n        for (URI factoryUri : exampleFactoryUris.values()) {\n            this.host.toggleServiceOptions(factoryUri,\n                    EnumSet.of(ServiceOption.IDEMPOTENT_POST), null);\n        }\n        TestContext ctx = this.host.testCreate(childStates.size());\n        for (Entry<String, ExampleServiceState> entry : childStates.entrySet()) {\n            Operation post = Operation\n                    .createPost(this.host.getPeerServiceUri(ExampleService.FACTORY_LINK))\n                    .setBody(entry.getValue())\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(post);\n        }\n        ctx.await();\n    }\n\n    /**\n     * Verifies that DELETE actions propagate and commit, and, that forced POST actions succeed\n     */\n    private void verifyReplicatedForcedPostAfterDelete(Map<String, ExampleServiceState> childStates)\n            throws Throwable {\n        // delete one of the children, then re-create but with a zero version, using a special\n        // directive that forces creation\n        Entry<String, ExampleServiceState> childEntry = childStates.entrySet().iterator().next();\n        TestContext ctx = this.host.testCreate(1);\n        Operation delete = Operation\n                .createDelete(this.host.getPeerServiceUri(childEntry.getKey()))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(delete);\n        ctx.await();\n\n        if (!this.host.isRemotePeerTest()) {\n            this.host.waitFor(\"services not deleted\", () -> {\n                for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n                    ProcessingStage stg = h.getServiceStage(childEntry.getKey());\n                    if (stg != null) {\n                        this.host.log(\"Service exists %s on host %s, stage %s\",\n                                childEntry.getKey(), h.toString(), stg);\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        TestContext postCtx = this.host.testCreate(1);\n        Operation opPost = Operation\n                .createPost(this.host.getPeerServiceUri(this.replicationTargetFactoryLink))\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_FORCE_INDEX_UPDATE)\n                .setBody(childEntry.getValue())\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        postCtx.failIteration(e);\n                    } else {\n                        postCtx.completeIteration();\n                    }\n                });\n        this.host.send(opPost);\n        this.host.testWait(postCtx);\n    }\n\n    private void waitForReplicationFactoryConvergence() throws Throwable {\n\n        // for code coverage, verify the convenience method on the host also reports available\n        WaitHandler wh = () -> {\n            TestContext ctx = this.host.testCreate(1);\n            boolean[] isReady = new boolean[1];\n            CompletionHandler ch = (o, e) -> {\n                if (e != null) {\n                    isReady[0] = false;\n                } else {\n                    isReady[0] = true;\n                }\n                ctx.completeIteration();\n            };\n\n            VerificationHost peerHost = this.host.getPeerHost();\n            if (peerHost == null) {\n                NodeGroupUtils.checkServiceAvailability(ch, this.host,\n                        this.host.getPeerServiceUri(this.replicationTargetFactoryLink),\n                        this.replicationNodeSelector);\n            } else {\n                peerHost.checkReplicatedServiceAvailable(ch, this.replicationTargetFactoryLink);\n            }\n            ctx.await();\n            return isReady[0];\n        };\n\n        this.host.waitFor(\"available check timeout for \" + this.replicationTargetFactoryLink, wh);\n    }\n\n    private Set<String> verifyReplicatedServiceCountWithBroadcastQueries()\n            throws Throwable {\n        // create a query task, which will execute on a randomly selected node. Since there is no guarantee the node\n        // selected to execute the query task is the one with all the replicated services, broadcast to all nodes, then\n        // join the results\n\n        URI nodeUri = this.host.getPeerHostUri();\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND).setTermMatchValue(\n                Utils.buildKind(ExampleServiceState.class));\n        QueryTask task = QueryTask.create(q).setDirect(true);\n        URI queryTaskFactoryUri = UriUtils\n                .buildUri(nodeUri, ServiceUriPaths.CORE_LOCAL_QUERY_TASKS);\n\n        // send the POST to the forwarding service on one of the nodes, with the broadcast query parameter set\n        URI forwardingService = UriUtils.buildBroadcastRequestUri(queryTaskFactoryUri,\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        Set<String> links = new HashSet<>();\n\n        TestContext testContext = this.host.testCreate(1);\n        Operation postQuery = Operation\n                .createPost(forwardingService)\n                .setBody(task)\n                .setCompletion(\n                        (o, e) -> {\n                            if (e != null) {\n                                this.host.failIteration(e);\n                                return;\n                            }\n\n                            NodeGroupBroadcastResponse rsp = o\n                                    .getBody(NodeGroupBroadcastResponse.class);\n\n                            NodeGroupBroadcastResult broadcastResponse = NodeGroupUtils.toBroadcastResult(rsp);\n                            if (broadcastResponse.hasFailure()) {\n                                testContext.fail(new IllegalStateException(\n                                        \"Failure from query tasks: \" + Utils.toJsonHtml(rsp)));\n                                return;\n                            }\n\n                            // verify broadcast requests should come from all discrete nodes\n                            Set<String> ownerIds = new HashSet<>();\n\n                            for (PeerNodeResult successResponse : broadcastResponse.successResponses) {\n                                QueryTask qt = successResponse.castBodyTo(QueryTask.class);\n                                this.host.log(\"Broadcast response from %s %s\", qt.documentSelfLink,\n                                        qt.documentOwner);\n                                ownerIds.add(qt.documentOwner);\n                                if (qt.results == null) {\n                                    this.host.log(\"Node %s had no results\", successResponse.requestUri);\n                                    continue;\n                                }\n                                for (String l : qt.results.documentLinks) {\n                                    links.add(l);\n                                }\n                            }\n\n                            testContext.completeIteration();\n                        });\n\n        this.host.send(postQuery);\n        testContext.await();\n\n        return links;\n    }\n\n    private void verifyInstantNotFoundFailureOnBadLinks() throws Throwable {\n        this.host.toggleNegativeTestMode(true);\n\n        TestContext testContext = this.host.testCreate(this.serviceCount);\n\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                testContext.complete();\n                return;\n            }\n            // strange, service exists, lets verify\n            for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n                ProcessingStage stg = h.getServiceStage(o.getUri().getPath());\n                if (stg != null) {\n                    this.host.log(\"Service exists %s on host %s, stage %s\",\n                            o.getUri().getPath(), h.toString(), stg);\n                }\n            }\n            testContext.fail(new Throwable(\"Expected service to not exist:\"\n                    + o.toString()));\n        };\n\n        // do a negative test: send request to a example child we know does not exist, but disable queuing\n        // so we get 404 right away\n        for (int i = 0; i < this.serviceCount; i++) {\n            URI factoryURI = this.host.getNodeGroupToFactoryMap(ExampleService.FACTORY_LINK)\n                    .values().iterator().next();\n            URI bogusChild = UriUtils.extendUri(factoryURI,\n                    Utils.getNowMicrosUtc() + UUID.randomUUID().toString());\n            Operation patch = Operation.createPatch(bogusChild)\n                    .setCompletion(c)\n                    .setBody(new ExampleServiceState());\n\n            this.host.send(patch);\n        }\n        testContext.await();\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    @Test\n    public void factorySynchronization() throws Throwable {\n\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n\n        factorySynchronizationNoChildren();\n\n        factoryDuplicatePost();\n    }\n\n    @Test\n    public void replicationWithAuthzCacheClear() throws Throwable {\n        this.isAuthorizationEnabled = true;\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        VerificationHost groupHost = this.host.getPeerHost();\n\n        groupHost.setSystemAuthorizationContext();\n        // wait for auth related services to be stabilized\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, UserService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, UserGroupService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, ResourceGroupService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, RoleService.FACTORY_LINK));\n\n        String fooUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"foo@vmware.com\");\n        String barUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"bar@vmware.com\");\n        String bazUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"baz@vmware.com\");\n\n\n\n        // create user, user-group, resource-group, role for foo@vmware.com\n        //   user: /core/authz/users/foo@vmware.com\n        //   user-group: /core/authz/user-groups/foo-user-group\n        //   resource-group:  /core/authz/resource-groups/foo-resource-group\n        //   role: /core/authz/roles/foo-role-1\n        TestContext testContext = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"foo@vmware.com\")\n                .setUserEmail(\"foo@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setUserGroupName(\"foo-user-group\")\n                .setResourceGroupName(\"foo-resource-group\")\n                .setRoleName(\"foo-role-1\")\n                .setCompletion(testContext.getCompletion())\n                .start();\n        testContext.await();\n\n        // create another user-group, resource-group, and role for foo@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: /core/authz/role/foo-role-2\n        TestContext ctxToCreateAnotherRole = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(fooUserLink)\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setRoleName(\"foo-role-2\")\n                .setCompletion(ctxToCreateAnotherRole.getCompletion())\n                .setupRole();\n        ctxToCreateAnotherRole.await();\n\n        // create user, user-group, resource-group, role for bar@vmware.com\n        //   user: /core/authz/users/bar@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: (not important)\n        TestContext ctxToCreateBar = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"bar@vmware.com\")\n                .setUserEmail(\"bar@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(ctxToCreateBar.getCompletion())\n                .start();\n        ctxToCreateBar.await();\n\n        // create user, user-group, resource-group, role for baz@vmware.com\n        //   user: /core/authz/users/baz@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: (not important)\n        TestContext ctxToCreateBaz = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"baz@vmware.com\")\n                .setUserEmail(\"baz@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(ctxToCreateBaz.getCompletion())\n                .start();\n        ctxToCreateBaz.await();\n\n        AuthorizationContext fooAuthContext = groupHost.assumeIdentity(fooUserLink);\n        AuthorizationContext barAuthContext = groupHost.assumeIdentity(barUserLink);\n        AuthorizationContext bazAuthContext = groupHost.assumeIdentity(bazUserLink);\n        String fooToken = fooAuthContext.getToken();\n        String barToken = barAuthContext.getToken();\n        String bazToken = bazAuthContext.getToken();\n\n        groupHost.resetSystemAuthorizationContext();\n\n        // verify GET will NOT clear cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/users/foo@vmware.com\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/user-groups/foo-user-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/resource-groups/foo-resource-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/roles/foo-role-1\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n\n        // verify deleting role should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(\n                        UriUtils.buildUri(groupHost, \"/core/authz/roles/foo-role-1\")));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify deleting user-group should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        // delete the user group associated with the user\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(\n                        UriUtils.buildUri(groupHost, \"/core/authz/user-groups/foo-user-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify creating new role should clear the auth cache (using bar@vmware.com)\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        Query q = Builder.create()\n                .addFieldClause(\n                        ExampleServiceState.FIELD_NAME_KIND,\n                        Utils.buildKind(ExampleServiceState.class))\n                .build();\n        TestContext ctxToCreateAnotherRoleForBar = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(barUserLink)\n                .setResourceGroupName(\"/core/authz/resource-groups/new-rg\")\n                .setResourceQuery(q)\n                .setRoleName(\"bar-role-2\")\n                .setCompletion(ctxToCreateAnotherRoleForBar.getCompletion())\n                .setupRole();\n        ctxToCreateAnotherRoleForBar.await();\n        groupHost.resetSystemAuthorizationContext();\n\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n        //\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n\n        // Updating the resource group should be able to handle the fact that the user group does not exist\n        String newResourceGroupLink = \"/core/authz/resource-groups/new-rg\";\n        Query updateResourceGroupQuery = Builder.create()\n                .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, \"bar\")\n                .build();\n        ResourceGroupState resourceGroupState = new ResourceGroupState();\n        resourceGroupState.query = updateResourceGroupQuery;\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPut(UriUtils.buildUri(groupHost, newResourceGroupLink))\n                        .setBody(resourceGroupState));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n        // verify patching user should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        UserState userState = new UserState();\n        userState.userGroupLinks = new HashSet<>();\n        userState.userGroupLinks.add(\"foo\");\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(groupHost, fooUserLink))\n                        .setBody(userState));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify deleting user should clear the auth cache\n        populateAuthCacheInAllPeers(bazAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(UriUtils.buildUri(groupHost, bazUserLink)));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(bazToken);\n\n        // verify patching ResourceGroup should clear the auth cache\n        // uses \"new-rg\" resource group that has associated to user bar\n        TestRequestSender sender = new TestRequestSender(this.host.getPeerHost());\n        groupHost.setSystemAuthorizationContext();\n        Operation newResourceGroupGetOp = Operation.createGet(groupHost, newResourceGroupLink);\n        ResourceGroupState newResourceGroupState = sender.sendAndWait(newResourceGroupGetOp, ResourceGroupState.class);\n        groupHost.resetSystemAuthorizationContext();\n\n        PatchQueryRequest patchBody = PatchQueryRequest.create(newResourceGroupState.query, false);\n\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(groupHost, newResourceGroupLink))\n                        .setBody(patchBody));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n    }\n\n    private void populateAuthCacheInAllPeers(AuthorizationContext authContext) throws Throwable {\n\n        // send a GET request to the ExampleService factory to populate auth cache on each peer.\n        // since factory is not OWNER_SELECTION service, request goes to the specified node.\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            peer.setAuthorizationContext(authContext);\n\n            // based on the role created in test, all users have access to ExampleService\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createGet(UriUtils.buildUri(peer, ExampleService.FACTORY_LINK)));\n        }\n\n        this.host.waitFor(\"Timeout waiting for correct auth cache state\",\n                () -> checkCacheInAllPeers(authContext.getToken(), true));\n    }\n\n    private void verifyAuthCacheHasClearedInAllPeers(String userToken) {\n        this.host.waitFor(\"Timeout waiting for correct auth cache state\",\n                () -> checkCacheInAllPeers(userToken, false));\n    }\n\n    private boolean checkCacheInAllPeers(String token, boolean expectEntries) throws Throwable {\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            peer.setSystemAuthorizationContext();\n            MinimalTestService s = new MinimalTestService();\n            peer.addPrivilegedService(MinimalTestService.class);\n            peer.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n            peer.resetSystemAuthorizationContext();\n\n            boolean contextFound = peer.getAuthorizationContext(s, token) != null;\n            if ((expectEntries && !contextFound) || (!expectEntries && contextFound)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void factoryDuplicatePost() throws Throwable, InterruptedException, TimeoutException {\n        // pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n        Consumer<Operation> setBodyCallback = (o) -> {\n            ReplicationTestServiceState s = new ReplicationTestServiceState();\n            s.stringField = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n\n        URI factoryUri = this.host\n                .getPeerServiceUri(ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK);\n        Map<URI, ReplicationTestServiceState> states = doReplicatedServiceFactoryPost(\n                this.serviceCount, setBodyCallback, factoryUri);\n\n        TestContext testContext = serviceHost.testCreate(states.size());\n        ReplicationTestServiceState initialState = new ReplicationTestServiceState();\n\n        for (URI uri : states.keySet()) {\n            initialState.documentSelfLink = uri.toString().substring(uri.toString()\n                    .lastIndexOf(UriUtils.URI_PATH_CHAR) + 1);\n            Operation createPost = Operation\n                    .createPost(factoryUri)\n                    .setBody(initialState)\n                    .setCompletion(\n                            (o, e) -> {\n                                if (o.getStatusCode() != Operation.STATUS_CODE_CONFLICT) {\n                                    testContext.fail(\n                                            new IllegalStateException(\n                                                    \"Incorrect response code received\"));\n                                    return;\n                                }\n                                testContext.complete();\n                            });\n            serviceHost.send(createPost);\n        }\n        testContext.await();\n    }\n\n    private void factorySynchronizationNoChildren() throws Throwable {\n        int factoryCount = Math.max(this.serviceCount, 25);\n        setUp(this.nodeCount);\n\n        // start many factories, in each host, so when the nodes join there will be a storm\n        // of synchronization requests between the nodes + factory instances\n        TestContext testContext = this.host.testCreate(this.nodeCount * factoryCount);\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            for (int i = 0; i < factoryCount; i++) {\n                Operation startPost = Operation.createPost(\n                        UriUtils.buildUri(h,\n                                UriUtils.buildUriPath(ExampleService.FACTORY_LINK, UUID\n                                        .randomUUID().toString())))\n                        .setCompletion(testContext.getCompletion());\n                h.startService(startPost, ExampleService.createFactory());\n            }\n        }\n        testContext.await();\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n    }\n\n    @Test\n    public void forwardingAndSelection() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        for (int i = 0; i < this.iterationCount; i++) {\n            directOwnerSelection();\n            forwardingToPeerId();\n            forwardingToKeyHashNode();\n            broadcast();\n        }\n    }\n\n    public void broadcast() throws Throwable {\n        // Do a broadcast on a local, non replicated service. Replicated services can not\n        // be used with broadcast since they will duplicate the update and potentially route\n        // to a single node\n        URI nodeGroup = this.host.getPeerNodeGroupUri();\n\n        long c = this.updateCount * this.nodeCount;\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        // we broadcast one update, per service, through one peer. We expect to see\n        // the same update across all peers, just like with replicated services\n        nodeGroup = this.host.getPeerNodeGroupUri();\n        testContext = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            URI serviceUri = UriUtils.buildUri(nodeGroup, s.documentSelfLink);\n            URI u = UriUtils.buildBroadcastRequestUri(serviceUri,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            body.id = serviceUri.getPath();\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(testContext.getCompletion())\n                    .setBody(body));\n        }\n        testContext.await();\n\n        for (URI baseHostUri : this.host.getNodeGroupMap().keySet()) {\n            List<URI> uris = new ArrayList<>();\n            for (ServiceDocument s : initialStates) {\n                URI serviceUri = UriUtils.buildUri(baseHostUri, s.documentSelfLink);\n                uris.add(serviceUri);\n            }\n            Map<URI, MinimalTestServiceState> states = this.host.getServiceState(null,\n                    MinimalTestServiceState.class, uris);\n            for (MinimalTestServiceState s : states.values()) {\n                // the PUT we issued, should have been forwarded to this service and modified its\n                // initial ID to be the same as the self link\n                if (!s.id.equals(s.documentSelfLink)) {\n                    throw new IllegalStateException(\"Service broadcast failure\");\n                }\n\n            }\n        }\n    }\n\n    public void forwardingToKeyHashNode() throws Throwable {\n        long c = this.updateCount * this.nodeCount;\n        Map<String, List<String>> ownersPerServiceLink = new HashMap<>();\n\n        // 0) Create N service instances, in each peer host. Services are NOT replicated\n        // 1) issue a forward request to owner, per service link\n        // 2) verify the request ended up on the owner the partitioning service predicted\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        URI nodeGroup = this.host.getPeerNodeGroupUri();\n        testContext = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            URI serviceUri = UriUtils.buildUri(nodeGroup, s.documentSelfLink);\n            URI u = UriUtils.buildForwardRequestUri(serviceUri,\n                    null,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            body.id = serviceUri.getPath();\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(testContext.getCompletion())\n                    .setBody(body));\n        }\n        testContext.await();\n        this.host.logThroughput();\n\n        AtomicInteger assignedLinks = new AtomicInteger();\n        TestContext testContextForPost = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            // make sure the key is the path to the service. The initial state self link is not a\n            // path ...\n            String key = UriUtils.normalizeUriPath(s.documentSelfLink);\n            s.documentSelfLink = key;\n            SelectAndForwardRequest body = new SelectAndForwardRequest();\n            body.key = key;\n            Operation post = Operation.createPost(UriUtils.buildUri(nodeGroup,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                    .setBody(body)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            testContextForPost.fail(e);\n                            return;\n                        }\n                        synchronized (ownersPerServiceLink) {\n                            SelectOwnerResponse rsp = o.getBody(SelectOwnerResponse.class);\n                            List<String> links = ownersPerServiceLink.get(rsp.ownerNodeId);\n                            if (links == null) {\n                                links = new ArrayList<>();\n                                ownersPerServiceLink.put(rsp.ownerNodeId, links);\n                            }\n                            links.add(key);\n                            ownersPerServiceLink.put(rsp.ownerNodeId, links);\n                        }\n                        assignedLinks.incrementAndGet();\n                        testContextForPost.complete();\n                    });\n            this.host.send(post);\n        }\n        testContextForPost.await();\n\n        assertTrue(assignedLinks.get() == initialStates.size());\n\n        // verify the services on the node that should be owner, has modified state\n        for (Entry<String, List<String>> e : ownersPerServiceLink.entrySet()) {\n            String nodeId = e.getKey();\n            List<String> links = e.getValue();\n            NodeState ns = this.host.getNodeStateMap().get(nodeId);\n            List<URI> uris = new ArrayList<>();\n            // make a list of URIs to the services assigned to this peer node\n            for (String l : links) {\n                uris.add(UriUtils.buildUri(ns.groupReference, l));\n            }\n\n            Map<URI, MinimalTestServiceState> states = this.host.getServiceState(null,\n                    MinimalTestServiceState.class, uris);\n            for (MinimalTestServiceState s : states.values()) {\n                // the PUT we issued, should have been forwarded to this service and modified its\n                // initial ID to be the same as the self link\n                if (!s.id.equals(s.documentSelfLink)) {\n                    throw new IllegalStateException(\"Service forwarding failure\");\n                } else {\n                }\n            }\n        }\n    }\n\n    public void forwardingToPeerId() throws Throwable {\n        long c = this.updateCount * this.nodeCount;\n        // 0) Create N service instances, in each peer host. Services are NOT replicated\n        // 1) issue a forward request to a specific peer id, per service link\n        // 2) verify the request ended up on the peer we targeted\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                s = Utils.clone(s);\n                // set the owner to be the target node. we will use this to verify it matches\n                // the id in the state, which is set through a forwarded PATCH\n                s.documentOwner = peer.getId();\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        VerificationHost peerEntryPoint = this.host.getPeerHost();\n\n        // add a custom header and make sure the service sees it in its handler, in the request\n        // headers, and we see a service response header in our response\n        String headerName = MinimalTestService.TEST_HEADER_NAME.toLowerCase();\n        UUID id = UUID.randomUUID();\n        String headerRequestValue = \"request-\" + id;\n        String headerResponseValue = \"response-\" + id;\n        TestContext testContextForPut = this.host.testCreate(initialStates.size() * this.nodeCount);\n\n        for (ServiceDocument s : initialStates) {\n            // send a PATCH the id for each document, to each peer. If it routes to the proper peer\n            // the initial state.documentOwner, will match the state.id\n\n            for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n                // For testing coverage, force the use of the same forwarding service instance.\n                // We make all request flow from one peer to others, testing both loopback p2p\n                // and true forwarding. Otherwise, the forwarding happens by directly contacting\n                // peer we want to land on!\n                URI localForwardingUri = UriUtils.buildUri(peerEntryPoint.getUri(),\n                        s.documentSelfLink);\n                // add a query to make sure it does not affect forwarding\n                localForwardingUri = UriUtils.extendUriWithQuery(localForwardingUri, \"k\", \"v\",\n                        \"k1\", \"v1\", \"k2\", \"v2\");\n                URI u = UriUtils.buildForwardToPeerUri(localForwardingUri, peer.getId(),\n                        ServiceUriPaths.DEFAULT_NODE_SELECTOR, EnumSet.noneOf(ServiceOption.class));\n                MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                        .buildMinimalTestState();\n                body.id = peer.getId();\n\n                this.host.send(Operation.createPut(u)\n                        .addRequestHeader(headerName, headerRequestValue)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContextForPut.fail(e);\n                                        return;\n                                    }\n                                    String value = o.getResponseHeader(headerName);\n                                    if (value == null || !value.equals(headerResponseValue)) {\n                                        testContextForPut.fail(new IllegalArgumentException(\n                                                \"response header not found\"));\n                                        return;\n                                    }\n                                    testContextForPut.complete();\n                                })\n                        .setBody(body));\n            }\n        }\n        testContextForPut.await();\n        this.host.logThroughput();\n\n        TestContext ctx = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation get = Operation.createGet(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        ctx.fail(e);\n                                        return;\n                                    }\n                                    MinimalTestServiceState rsp = o\n                                            .getBody(MinimalTestServiceState.class);\n                                    if (!rsp.id.equals(rsp.documentOwner)) {\n                                        ctx.fail(\n                                                new IllegalStateException(\"Expected: \"\n                                                        + rsp.documentOwner + \" was: \" + rsp.id));\n                                    } else {\n                                        ctx.complete();\n                                    }\n                                });\n                this.host.send(get);\n            }\n        }\n        ctx.await();\n\n        // Do a negative test: Send a request that will induce failure in the service handler and\n        // make sure we receive back failure, with a ServiceErrorResponse body\n\n        this.host.toggleDebuggingMode(true);\n        TestContext testCxtForPut = this.host.testCreate(this.host.getInProcessHostMap().size());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            ServiceDocument s = initialStates.get(0);\n            URI serviceUri = UriUtils.buildUri(peerEntryPoint.getUri(), s.documentSelfLink);\n            URI u = UriUtils.buildForwardToPeerUri(serviceUri, peer.getId(),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR,\n                    null);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            // setting id to null will cause validation failure.\n            body.id = null;\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e == null) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected failure\"));\n                                    return;\n                                }\n                                MinimalTestServiceErrorResponse rsp = o\n                                        .getBody(MinimalTestServiceErrorResponse.class);\n                                if (rsp.message == null || rsp.message.isEmpty()) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected error response message\"));\n                                    return;\n                                }\n\n                                if (!MinimalTestServiceErrorResponse.KIND.equals(rsp.documentKind)\n                                        || 0 != Double.compare(Math.PI, rsp.customErrorField)) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected custom error fields\"));\n                                    return;\n                                }\n                                testCxtForPut.complete();\n                            })\n                    .setBody(body));\n        }\n        testCxtForPut.await();\n        this.host.toggleDebuggingMode(false);\n    }\n\n    private void directOwnerSelection() throws Throwable {\n        Map<URI, Map<String, Long>> keyToNodeAssignmentsPerNode = new HashMap<>();\n        List<String> keys = new ArrayList<>();\n\n        long c = this.updateCount * this.nodeCount;\n        // generate N keys once, then ask each node to assign to its peers. Each node should come up\n        // with the same distribution\n\n        for (int i = 0; i < c; i++) {\n            keys.add(Utils.getNowMicrosUtc() + \"\");\n        }\n\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            keyToNodeAssignmentsPerNode.put(nodeGroup, new HashMap<>());\n        }\n\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        TestContext testContext = this.host.testCreate(c * this.nodeCount);\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            for (String key : keys) {\n                SelectAndForwardRequest body = new SelectAndForwardRequest();\n                body.key = key;\n                Operation post = Operation\n                        .createPost(UriUtils.buildUri(nodeGroup,\n                                ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                        .setBody(body)\n                        .setCompletion(\n                                (o, e) -> {\n                                    try {\n                                        synchronized (keyToNodeAssignmentsPerNode) {\n                                            SelectOwnerResponse rsp = o\n                                                    .getBody(SelectOwnerResponse.class);\n                                            Map<String, Long> assignmentsPerNode = keyToNodeAssignmentsPerNode\n                                                    .get(nodeGroup);\n                                            Long l = assignmentsPerNode.get(rsp.ownerNodeId);\n                                            if (l == null) {\n                                                l = 0L;\n                                            }\n                                            assignmentsPerNode.put(rsp.ownerNodeId, l + 1);\n                                            testContext.complete();\n                                        }\n                                    } catch (Throwable ex) {\n                                        testContext.fail(ex);\n                                    }\n                                });\n                this.host.send(post);\n            }\n        }\n        testContext.await();\n        this.host.logThroughput();\n\n        Map<String, Long> countPerNode = null;\n\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            Map<String, Long> assignmentsPerNode = keyToNodeAssignmentsPerNode.get(nodeGroup);\n            if (countPerNode == null) {\n                countPerNode = assignmentsPerNode;\n            }\n\n            this.host.log(\"Node group %s assignments: %s\", nodeGroup, assignmentsPerNode);\n\n            for (Entry<String, Long> e : assignmentsPerNode.entrySet()) {\n                // we assume that with random keys, and random node ids, each node will get at least\n                // one key.\n                assertTrue(e.getValue() > 0);\n                Long count = countPerNode.get(e.getKey());\n                if (count == null) {\n                    continue;\n                }\n                if (!count.equals(e.getValue())) {\n                    this.host.logNodeGroupState();\n                    throw new IllegalStateException(\n                            \"Node id got assigned the same key different number of times, on one of the nodes\");\n                }\n            }\n\n        }\n    }\n\n    @Test\n    public void replicationFullQuorumMissingServiceOnPeer() throws Throwable {\n        // This test verifies the following scenario:\n        // A new node joins an existing node-group with\n        // services already created. Synchronization is\n        // still in-progress and a write request arrives.\n        // If the quorum is configured to FULL, the write\n        // request will fail on the new node with not-found\n        // error, since synchronization hasn't completed.\n        // The test verifies that when this happens, the\n        // owner node will try to synchronize on-demand\n        // and retry the original update reqeust.\n\n        // Artificially setting the replica not found timeout to\n        // a lower-value, to reduce the wait time before owner\n        // retries\n        System.setProperty(\n                NodeSelectorReplicationService.PROPERTY_NAME_REPLICA_NOT_FOUND_TIMEOUT_MICROS,\n                Long.toString(TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS)));\n\n        this.host = VerificationHost.create(0);\n        this.host.setPeerSynchronizationEnabled(false);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(\n                VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n        this.host.start();\n\n        // Setup one host and create some example\n        // services on it.\n        List<URI> exampleUris = new ArrayList<>();\n        this.host.createExampleServices(this.host, this.serviceCount, exampleUris, null);\n\n        // Add a second host with synchronization disabled,\n        // Join it to the existing host.\n        VerificationHost host2 = new VerificationHost();\n\n        try {\n            TemporaryFolder tmpFolder = new TemporaryFolder();\n            tmpFolder.create();\n\n            String mainHostId = \"main-\" + VerificationHost.hostNumber.incrementAndGet();\n            String[] args = {\n                    \"--id=\" + mainHostId,\n                    \"--port=0\",\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + this.host.getUri()\n            };\n\n            host2.initialize(args);\n            host2.setPeerSynchronizationEnabled(false);\n            host2.setMaintenanceIntervalMicros(\n                    TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n            host2.start();\n\n            this.host.addPeerNode(host2);\n\n            // Wait for node-group to converge\n            List<URI> nodeGroupUris = new ArrayList<>();\n            nodeGroupUris.add(UriUtils.buildUri(this.host, ServiceUriPaths.DEFAULT_NODE_GROUP));\n            nodeGroupUris.add(UriUtils.buildUri(host2, ServiceUriPaths.DEFAULT_NODE_GROUP));\n            this.host.waitForNodeGroupConvergence(nodeGroupUris, 2, 2, true);\n\n            // Set the quorum to full.\n            this.host.setNodeGroupQuorum(2, nodeGroupUris.get(0));\n            host2.setNodeGroupQuorum(2);\n\n            // Filter the created examples to only those\n            // that are owned by host-1.\n            List<URI> host1Examples = exampleUris.stream()\n                    .filter(e -> this.host.isOwner(e.getPath(), ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                    .collect(Collectors.toList());\n\n            // Start patching all filtered examples. Because\n            // synchronization is disabled each of these\n            // example services will not exist on the new\n            // node that we added resulting in a non_found\n            // error. However, the owner will retry this\n            // after on-demand synchronization and hence\n            // patches should succeed.\n            ExampleServiceState state = new ExampleServiceState();\n            state.counter = 1L;\n\n            if (host1Examples.size() > 0) {\n                this.host.log(Level.INFO, \"Starting patches\");\n                TestContext ctx = this.host.testCreate(host1Examples.size());\n                for (URI exampleUri : host1Examples) {\n                    Operation patch = Operation\n                            .createPatch(exampleUri)\n                            .setBody(state)\n                            .setReferer(\"localhost\")\n                            .setCompletion(ctx.getCompletion());\n                    this.host.sendRequest(patch);\n                }\n                ctx.await();\n            }\n        } finally {\n            host2.tearDown();\n        }\n    }\n\n    @Test\n    public void replicationWithAuthAndNodeRestart() throws Throwable {\n        AuthorizationHelper authHelper;\n\n        this.isAuthorizationEnabled = true;\n        setUp(this.nodeCount);\n\n        authHelper = new AuthorizationHelper(this.host);\n\n        // relax quorum to allow for divergent writes, on independent nodes (not yet joined)\n\n        this.host.setSystemAuthorizationContext();\n\n        // Create the same users and roles on every peer independently\n        Map<ServiceHost, Collection<String>> roleLinksByHost = new HashMap<>();\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            String email = \"jane@doe.com\";\n            authHelper.createUserService(h, email);\n            authHelper.createRoles(h, email);\n        }\n\n        // Get roles from all nodes\n        Map<ServiceHost, Map<URI, RoleState>> roleStateByHost = getRolesByHost(roleLinksByHost);\n\n        // Join nodes to force synchronization and convergence\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n\n        // Get roles from all nodes\n        Map<ServiceHost, Map<URI, RoleState>> newRoleStateByHost = getRolesByHost(roleLinksByHost);\n\n        // Verify that every host independently advances their version & epoch\n        for (ServiceHost h : roleStateByHost.keySet()) {\n            Map<URI, RoleState> roleState = roleStateByHost.get(h);\n            for (URI u : roleState.keySet()) {\n                RoleState oldRole = roleState.get(u);\n                RoleState newRole = newRoleStateByHost.get(h).get(u);\n                assertTrue(\"version should have advanced\",\n                        newRole.documentVersion > oldRole.documentVersion);\n                assertTrue(\"epoch should have advanced\",\n                        newRole.documentEpoch > oldRole.documentEpoch);\n            }\n        }\n\n        // Verify that every host converged to the same version, epoch, and owner\n        Map<String, Long> versions = new HashMap<>();\n        Map<String, Long> epochs = new HashMap<>();\n        Map<String, String> owners = new HashMap<>();\n        for (ServiceHost h : newRoleStateByHost.keySet()) {\n            Map<URI, RoleState> roleState = newRoleStateByHost.get(h);\n            for (URI u : roleState.keySet()) {\n                RoleState newRole = roleState.get(u);\n\n                if (versions.containsKey(newRole.documentSelfLink)) {\n                    assertTrue(versions.get(newRole.documentSelfLink) == newRole.documentVersion);\n                } else {\n                    versions.put(newRole.documentSelfLink, newRole.documentVersion);\n                }\n\n                if (epochs.containsKey(newRole.documentSelfLink)) {\n                    assertTrue(Objects.equals(epochs.get(newRole.documentSelfLink),\n                            newRole.documentEpoch));\n                } else {\n                    epochs.put(newRole.documentSelfLink, newRole.documentEpoch);\n                }\n\n                if (owners.containsKey(newRole.documentSelfLink)) {\n                    assertEquals(owners.get(newRole.documentSelfLink), newRole.documentOwner);\n                } else {\n                    owners.put(newRole.documentSelfLink, newRole.documentOwner);\n                }\n            }\n        }\n\n        // create some example tasks, which delete example services. We dont have any\n        // examples services created, which is good, since we just want these tasks to\n        // go to finished state, then verify, after node restart, they all start\n        Set<String> exampleTaskLinks = new ConcurrentSkipListSet<>();\n        createReplicatedExampleTasks(exampleTaskLinks, null);\n\n        Set<String> exampleLinks = new ConcurrentSkipListSet<>();\n        verifyReplicatedAuthorizedPost(exampleLinks);\n\n        // verify restart, with authorization.\n        // stop one host\n        VerificationHost hostToStop = this.host.getInProcessHostMap().values().iterator().next();\n        stopAndRestartHost(exampleLinks, exampleTaskLinks, hostToStop);\n    }\n\n    private void createReplicatedExampleTasks(Set<String> exampleTaskLinks, String name)\n            throws Throwable {\n        URI factoryUri = UriUtils.buildFactoryUri(this.host.getPeerHost(),\n                ExampleTaskService.class);\n        this.host.setSystemAuthorizationContext();\n        // Sample body that this user is authorized to create\n        ExampleTaskServiceState exampleServiceState = new ExampleTaskServiceState();\n        if (name != null) {\n            exampleServiceState.customQueryClause = Query.Builder.create()\n                    .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, name).build();\n        }\n        this.host.log(\"creating example *task* instances\");\n        TestContext testContext = this.host.testCreate(this.serviceCount);\n        for (int i = 0; i < this.serviceCount; i++) {\n            CompletionHandler c = (o, e) -> {\n                if (e != null) {\n                    testContext.fail(e);\n                    return;\n                }\n                ExampleTaskServiceState rsp = o.getBody(ExampleTaskServiceState.class);\n                synchronized (exampleTaskLinks) {\n                    exampleTaskLinks.add(rsp.documentSelfLink);\n                }\n                testContext.complete();\n            };\n            this.host.send(Operation\n                    .createPost(factoryUri)\n                    .setBody(exampleServiceState)\n                    .setCompletion(c));\n        }\n        testContext.await();\n\n        // ensure all tasks are in finished state\n        this.host.waitFor(\"Example tasks did not finish\", () -> {\n            ServiceDocumentQueryResult rsp = this.host.getExpandedFactoryState(factoryUri);\n            for (Object o : rsp.documents.values()) {\n                ExampleTaskServiceState doc = Utils.fromJson(o, ExampleTaskServiceState.class);\n                if (TaskState.isFailed(doc.taskInfo)) {\n                    this.host.log(\"task %s failed: %s\", doc.documentSelfLink, doc.failureMessage);\n                    throw new IllegalStateException(\"task failed\");\n                }\n                if (!TaskState.isFinished(doc.taskInfo)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private void verifyReplicatedAuthorizedPost(Set<String> exampleLinks)\n            throws Throwable {\n        Collection<VerificationHost> hosts = this.host.getInProcessHostMap().values();\n        RoundRobinIterator<VerificationHost> it = new RoundRobinIterator<>(hosts);\n        int exampleServiceCount = this.serviceCount;\n\n        String userLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, \"jane@doe.com\");\n        // Verify we can assert identity and make a request to every host\n        this.host.assumeIdentity(userLink);\n\n        // Sample body that this user is authorized to create\n        ExampleServiceState exampleServiceState = new ExampleServiceState();\n        exampleServiceState.name = \"jane\";\n\n        this.host.log(\"creating example instances\");\n        TestContext testContext = this.host.testCreate(exampleServiceCount);\n        for (int i = 0; i < exampleServiceCount; i++) {\n            CompletionHandler c = (o, e) -> {\n                if (e != null) {\n                    testContext.fail(e);\n                    return;\n                }\n\n                try {\n                    // Verify the user is set as principal\n                    ExampleServiceState state = o.getBody(ExampleServiceState.class);\n                    assertEquals(state.documentAuthPrincipalLink,\n                            userLink);\n                    exampleLinks.add(state.documentSelfLink);\n                    testContext.complete();\n                } catch (Throwable e2) {\n                    testContext.fail(e2);\n                }\n            };\n            this.host.send(Operation\n                    .createPost(UriUtils.buildFactoryUri(it.next(), ExampleService.class))\n                    .setBody(exampleServiceState)\n                    .setCompletion(c));\n        }\n        testContext.await();\n\n        this.host.toggleNegativeTestMode(true);\n        // Sample body that this user is NOT authorized to create\n        ExampleServiceState invalidExampleServiceState = new ExampleServiceState();\n        invalidExampleServiceState.name = \"somebody other than jane\";\n\n        this.host.log(\"issuing non authorized request\");\n        TestContext testCtx = this.host.testCreate(exampleServiceCount);\n        for (int i = 0; i < exampleServiceCount; i++) {\n            this.host.send(Operation\n                    .createPost(UriUtils.buildFactoryUri(it.next(), ExampleService.class))\n                    .setBody(invalidExampleServiceState)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            assertEquals(Operation.STATUS_CODE_FORBIDDEN, o.getStatusCode());\n                            testCtx.complete();\n                            return;\n                        }\n\n                        testCtx.fail(new IllegalStateException(\"expected failure\"));\n                    }));\n        }\n        testCtx.await();\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    private void stopAndRestartHost(Set<String> exampleLinks, Set<String> exampleTaskLinks,\n            VerificationHost hostToStop)\n            throws Throwable, InterruptedException {\n        // relax quorum\n        this.host.setNodeGroupQuorum(this.nodeCount - 1);\n        // expire node that went away quickly to avoid alot of log spam from gossip failures\n        NodeGroupConfig cfg = new NodeGroupConfig();\n        cfg.nodeRemovalDelayMicros = TimeUnit.SECONDS.toMicros(1);\n        this.host.setNodeGroupConfig(cfg);\n\n        this.host.stopHostAndPreserveState(hostToStop);\n        this.host.waitForNodeGroupConvergence(2, 2);\n        VerificationHost existingHost = this.host.getInProcessHostMap().values().iterator().next();\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleTaskService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        // create some additional tasks on the remaining two hosts, but make sure they don't delete\n        // any example service instances, by specifying a name value we know will not match anything\n        createReplicatedExampleTasks(exampleTaskLinks, UUID.randomUUID().toString());\n\n        // delete some of the task links, to test synchronization of deleted entries on the restarted\n        // host\n        Set<String> deletedExampleLinks = deleteSomeServices(exampleLinks);\n\n        // increase quorum on existing nodes, so they wait for new node\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        hostToStop.setPort(0);\n        hostToStop.setSecurePort(0);\n        if (!VerificationHost.restartStatefulHost(hostToStop)) {\n            this.host.log(\"Failed restart of host, aborting\");\n            return;\n        }\n\n        // restart host, rejoin it\n        URI nodeGroupU = UriUtils.buildUri(hostToStop, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        URI eNodeGroupU = UriUtils.buildUri(existingHost, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.host.testStart(1);\n        this.host.setSystemAuthorizationContext();\n        this.host.joinNodeGroup(nodeGroupU, eNodeGroupU, this.nodeCount);\n        this.host.testWait();\n        this.host.addPeerNode(hostToStop);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n        // set quorum on new node as well\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        this.host.resetAuthorizationContext();\n\n        this.host.waitFor(\"Task services not started in restarted host:\" + exampleTaskLinks, () -> {\n            return checkChildServicesIfStarted(exampleTaskLinks, hostToStop) == 0;\n        });\n\n        // verify all services, not previously deleted, are restarted\n        this.host.waitFor(\"Services not started in restarted host:\" + exampleLinks, () -> {\n            return checkChildServicesIfStarted(exampleLinks, hostToStop) == 0;\n        });\n\n        int deletedCount = deletedExampleLinks.size();\n        this.host.waitFor(\"Deleted services still present in restarted host\", () -> {\n            return checkChildServicesIfStarted(deletedExampleLinks, hostToStop) == deletedCount;\n        });\n    }\n\n    private Set<String> deleteSomeServices(Set<String> exampleLinks)\n            throws Throwable {\n        int deleteCount = exampleLinks.size() / 3;\n        Iterator<String> itLinks = exampleLinks.iterator();\n        Set<String> deletedExampleLinks = new HashSet<>();\n        TestContext testContext = this.host.testCreate(deleteCount);\n        for (int i = 0; i < deleteCount; i++) {\n            String link = itLinks.next();\n            deletedExampleLinks.add(link);\n            exampleLinks.remove(link);\n            Operation delete = Operation.createDelete(this.host.getPeerServiceUri(link))\n                    .setCompletion(testContext.getCompletion());\n            this.host.send(delete);\n        }\n        testContext.await();\n        this.host.log(\"Deleted links: %s\", deletedExampleLinks);\n        return deletedExampleLinks;\n    }\n\n    private int checkChildServicesIfStarted(Set<String> exampleTaskLinks,\n            VerificationHost host) {\n        this.host.setSystemAuthorizationContext();\n        int notStartedCount = 0;\n        for (String s : exampleTaskLinks) {\n            ProcessingStage st = host.getServiceStage(s);\n            if (st == null) {\n                notStartedCount++;\n            }\n        }\n        this.host.resetAuthorizationContext();\n        if (notStartedCount > 0) {\n            this.host.log(\"%d services not started on %s (%s)\", notStartedCount,\n                    host.getPublicUri(), host.getId());\n        }\n        return notStartedCount;\n    }\n\n    private Map<ServiceHost, Map<URI, RoleState>> getRolesByHost(\n            Map<ServiceHost, Collection<String>> roleLinksByHost) throws Throwable {\n        Map<ServiceHost, Map<URI, RoleState>> roleStateByHost = new HashMap<>();\n        for (ServiceHost h : roleLinksByHost.keySet()) {\n            Collection<String> roleLinks = roleLinksByHost.get(h);\n            Collection<URI> roleURIs = new ArrayList<>();\n            for (String link : roleLinks) {\n                roleURIs.add(UriUtils.buildUri(h, link));\n            }\n\n            Map<URI, RoleState> serviceState = this.host.getServiceState(null, RoleState.class,\n                    roleURIs);\n            roleStateByHost.put(h, serviceState);\n        }\n        return roleStateByHost;\n    }\n\n    private void verifyOperationJoinAcrossPeers(Map<URI, ReplicationTestServiceState> childStates)\n            throws Throwable {\n        // do a OperationJoin across N nodes, making sure join works when forwarding is involved\n        List<Operation> joinedOps = new ArrayList<>();\n        for (ReplicationTestServiceState st : childStates.values()) {\n            Operation get = Operation.createGet(\n                    this.host.getPeerServiceUri(st.documentSelfLink)).setReferer(\n                    this.host.getReferer());\n            joinedOps.add(get);\n        }\n\n        TestContext testContext = this.host.testCreate(1);\n        OperationJoin\n                .create(joinedOps)\n                .setCompletion(\n                        (ops, exc) -> {\n                            if (exc != null) {\n                                testContext.fail(exc.values().iterator().next());\n                                return;\n                            }\n\n                            for (Operation o : ops.values()) {\n                                ReplicationTestServiceState state = o.getBody(\n                                        ReplicationTestServiceState.class);\n                                if (state.stringField == null) {\n                                    testContext.fail(new IllegalStateException());\n                                    return;\n                                }\n                            }\n                            testContext.complete();\n                        })\n                .sendWith(this.host.getPeerHost());\n        testContext.await();\n    }\n\n    public Map<String, Set<String>> computeOwnerIdsPerLink(VerificationHost joinedHost,\n            Collection<String> links)\n            throws Throwable {\n\n        TestContext testContext = this.host.testCreate(links.size());\n\n        Map<String, Set<String>> expectedOwnersPerLink = new ConcurrentSkipListMap<>();\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                testContext.fail(e);\n                return;\n            }\n\n            SelectOwnerResponse rsp = o.getBody(SelectOwnerResponse.class);\n            Set<String> eligibleNodeIds = new HashSet<>();\n            for (NodeState ns : rsp.selectedNodes) {\n                eligibleNodeIds.add(ns.id);\n            }\n            expectedOwnersPerLink.put(rsp.key, eligibleNodeIds);\n            testContext.complete();\n        };\n\n        for (String link : links) {\n            Operation selectOp = Operation.createGet(null)\n                    .setCompletion(c)\n                    .setExpiration(this.host.getOperationTimeoutMicros() + Utils.getNowMicrosUtc());\n\n            joinedHost.selectOwner(this.replicationNodeSelector, link, selectOp);\n        }\n        testContext.await();\n        return expectedOwnersPerLink;\n    }\n\n    public <T extends ServiceDocument> void verifyDocumentOwnerAndEpoch(Map<String, T> childStates,\n            VerificationHost joinedHost,\n            List<URI> joinedHostUris,\n            int minExpectedEpochRetries,\n            int maxExpectedEpochRetries, int expectedOwnerChanges)\n            throws Throwable, InterruptedException, TimeoutException {\n\n        Map<URI, NodeGroupState> joinedHostNodeGroupStates = this.host.getServiceState(null,\n                NodeGroupState.class, joinedHostUris);\n        Set<String> joinedHostOwnerIds = new HashSet<>();\n        for (NodeGroupState st : joinedHostNodeGroupStates.values()) {\n            joinedHostOwnerIds.add(st.documentOwner);\n        }\n\n        this.host.waitFor(\"ownership did not converge\", () -> {\n            Map<String, Set<String>> ownerIdsPerLink = computeOwnerIdsPerLink(joinedHost,\n                    childStates.keySet());\n            boolean isConverged = true;\n            Map<String, Set<Long>> epochsPerLink = new HashMap<>();\n            List<URI> nodeSelectorStatsUris = new ArrayList<>();\n\n            for (URI baseNodeUri : joinedHostUris) {\n                nodeSelectorStatsUris.add(UriUtils.buildUri(baseNodeUri,\n                        ServiceUriPaths.DEFAULT_NODE_SELECTOR,\n                        ServiceHost.SERVICE_URI_SUFFIX_STATS));\n\n                URI factoryUri = UriUtils.buildUri(\n                        baseNodeUri, this.replicationTargetFactoryLink);\n                ServiceDocumentQueryResult factoryRsp = this.host\n                        .getFactoryState(factoryUri);\n                if (factoryRsp.documentLinks == null\n                        || factoryRsp.documentLinks.size() != childStates.size()) {\n                    isConverged = false;\n                    // services not all started in new nodes yet;\n                    this.host.log(\"Node %s does not have all services: %s\", baseNodeUri,\n                            Utils.toJsonHtml(factoryRsp));\n                    break;\n                }\n\n                List<URI> childUris = new ArrayList<>();\n                for (String link : childStates.keySet()) {\n                    childUris.add(UriUtils.buildUri(baseNodeUri, link));\n                }\n\n                // retrieve the document state directly from each service\n                Map<URI, ServiceDocument> childDocs = this.host.getServiceState(null,\n                        ServiceDocument.class, childUris);\n\n                List<URI> childStatUris = new ArrayList<>();\n                for (ServiceDocument state : childDocs.values()) {\n\n                    if (state.documentOwner == null) {\n                        this.host.log(\"Owner not set in service on new node: %s\",\n                                Utils.toJsonHtml(state));\n                        isConverged = false;\n                        break;\n                    }\n\n                    URI statUri = UriUtils.buildUri(baseNodeUri, state.documentSelfLink,\n                            ServiceHost.SERVICE_URI_SUFFIX_STATS);\n                    childStatUris.add(statUri);\n\n                    Set<Long> epochs = epochsPerLink.get(state.documentEpoch);\n                    if (epochs == null) {\n                        epochs = new HashSet<>();\n                        epochsPerLink.put(state.documentSelfLink, epochs);\n                    }\n\n                    epochs.add(state.documentEpoch);\n                    Set<String> eligibleNodeIds = ownerIdsPerLink.get(state.documentSelfLink);\n\n                    if (!joinedHostOwnerIds.contains(state.documentOwner)) {\n                        this.host.log(\"Owner id for %s not expected: %s, valid ids: %s\",\n                                state.documentSelfLink, state.documentOwner, joinedHostOwnerIds);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (eligibleNodeIds != null && !eligibleNodeIds.contains(state.documentOwner)) {\n                        this.host.log(\"Owner id for %s not eligible: %s, eligible ids: %s\",\n                                state.documentSelfLink, state.documentOwner, joinedHostOwnerIds);\n                        isConverged = false;\n                        break;\n                    }\n                }\n\n                int nodeGroupMaintCount = 0;\n                int docOwnerToggleOffCount = 0;\n                int docOwnerToggleCount = 0;\n                // verify stats were reported by owner node, not a random peer\n                Map<URI, ServiceStats> allChildStats = this.host.getServiceState(null,\n                        ServiceStats.class, childStatUris);\n                for (ServiceStats childStats : allChildStats.values()) {\n                    String parentLink = UriUtils.getParentPath(childStats.documentSelfLink);\n                    Set<String> eligibleNodes = ownerIdsPerLink.get(parentLink);\n                    if (!eligibleNodes.contains(childStats.documentOwner)) {\n                        this.host.log(\"Stats for %s owner not expected. Is %s, should be %s\",\n                                parentLink, childStats.documentOwner,\n                                ownerIdsPerLink.get(parentLink));\n                        isConverged = false;\n                        break;\n                    }\n                    ServiceStat maintStat = childStats.entries\n                            .get(Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n                    if (maintStat != null) {\n                        nodeGroupMaintCount++;\n                    }\n                    ServiceStat docOwnerToggleOffStat = childStats.entries\n                            .get(Service.STAT_NAME_DOCUMENT_OWNER_TOGGLE_OFF_MAINT_COUNT);\n                    if (docOwnerToggleOffStat != null) {\n                        docOwnerToggleOffCount++;\n                    }\n                    ServiceStat docOwnerToggleStat = childStats.entries\n                            .get(Service.STAT_NAME_DOCUMENT_OWNER_TOGGLE_ON_MAINT_COUNT);\n                    if (docOwnerToggleStat != null) {\n                        docOwnerToggleCount++;\n                    }\n                }\n\n                this.host.log(\"Node group change maintenance observed: %d\", nodeGroupMaintCount);\n                if (nodeGroupMaintCount < expectedOwnerChanges) {\n                    isConverged = false;\n                }\n\n                this.host.log(\"Toggled off doc owner count: %d, toggle on count: %d\",\n                        docOwnerToggleOffCount, docOwnerToggleCount);\n                if (docOwnerToggleCount < childStates.size()) {\n                    isConverged = false;\n                }\n\n                // verify epochs\n                for (Set<Long> epochs : epochsPerLink.values()) {\n                    if (epochs.size() > 1) {\n                        this.host.log(\"Documents have different epochs:%s\", epochs.toString());\n                        isConverged = false;\n                    }\n                }\n\n                if (!isConverged) {\n                    break;\n                }\n            }\n\n            return isConverged;\n        });\n    }\n\n    private <T extends ServiceDocument> Map<String, T> doStateUpdateReplicationTest(Action action,\n            int childCount, int updateCount,\n            long expectedVersion,\n            Function<T, Void> updateBodySetter,\n            BiPredicate<T, T> convergenceChecker,\n            Map<String, T> initialStatesPerChild) throws Throwable {\n        return doStateUpdateReplicationTest(action, childCount, updateCount, expectedVersion,\n                updateBodySetter, convergenceChecker, initialStatesPerChild, null, null);\n    }\n\n    private <T extends ServiceDocument> Map<String, T> doStateUpdateReplicationTest(Action action,\n            int childCount, int updateCount,\n            long expectedVersion,\n            Function<T, Void> updateBodySetter,\n            BiPredicate<T, T> convergenceChecker,\n            Map<String, T> initialStatesPerChild,\n            Map<Action, Long> countsPerAction,\n            Map<Action, Long> elapsedTimePerAction) throws Throwable {\n\n        int testCount = childCount * updateCount;\n        String testName = \"Replication with \" + action;\n        TestContext testContext = this.host.testCreate(testCount);\n        testContext.setTestName(testName).logBefore();\n\n        if (!this.expectFailure) {\n            // Before we do the replication test, wait for factory availability.\n            for (URI fu : this.host.getNodeGroupToFactoryMap(this.replicationTargetFactoryLink)\n                    .values()) {\n                // confirm that /factory/available returns 200 across all nodes\n                waitForReplicatedFactoryServiceAvailable(fu, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            }\n        }\n\n        long before = Utils.getNowMicrosUtc();\n        AtomicInteger failedCount = new AtomicInteger();\n        // issue an update to each child service and verify it was reflected\n        // among\n        // peers\n        for (T initState : initialStatesPerChild.values()) {\n            // change a field in the initial state of each service but keep it\n            // the same across all updates so potential re ordering of the\n            // updates does not cause spurious test breaks\n            updateBodySetter.apply(initState);\n\n            for (int i = 0; i < updateCount; i++) {\n\n                long sentTime = 0;\n                if (this.expectFailure) {\n                    sentTime = Utils.getNowMicrosUtc();\n                }\n                URI factoryOnRandomPeerUri = this.host\n                        .getPeerServiceUri(this.replicationTargetFactoryLink);\n\n                long finalSentTime = sentTime;\n                this.host\n                        .send(Operation\n                                .createPatch(UriUtils.buildUri(factoryOnRandomPeerUri,\n                                        initState.documentSelfLink))\n                                .setAction(action)\n                                .forceRemote()\n                                .setBodyNoCloning(initState)\n                                .setCompletion(\n                                        (o, e) -> {\n                                            if (e != null) {\n                                                if (this.expectFailure) {\n                                                    failedCount.incrementAndGet();\n                                                    testContext.complete();\n                                                    return;\n                                                }\n                                                testContext.fail(e);\n                                                return;\n                                            }\n\n                                            if (this.expectFailure\n                                                    && this.expectedFailureStartTimeMicros > 0\n                                                    && finalSentTime > this.expectedFailureStartTimeMicros) {\n                                                testContext.fail(new IllegalStateException(\n                                                        \"Request should have failed: %s\"\n                                                                + o.toString()\n                                                                + \" sent at \" + finalSentTime));\n                                                return;\n                                            }\n                                            testContext.complete();\n                                        }));\n            }\n        }\n\n        testContext.await();\n        testContext.logAfter();\n\n        updatePerfDataPerAction(action, before, (long) (childCount * updateCount), countsPerAction,\n                elapsedTimePerAction);\n\n        if (this.expectFailure) {\n            this.host.log(\"Failed count: %d\", failedCount.get());\n            if (failedCount.get() == 0) {\n                throw new IllegalStateException(\n                        \"Possible false negative but expected at least one failure\");\n            }\n            return initialStatesPerChild;\n        }\n\n        // All updates sent to all children within one host, now wait for\n        // convergence\n        if (action != Action.DELETE) {\n            return waitForReplicatedFactoryChildServiceConvergence(initialStatesPerChild,\n                    convergenceChecker,\n                    childCount,\n                    expectedVersion);\n        }\n\n        // for DELETE replication, we expect the child services to be stopped\n        // across hosts and their state marked \"deleted\". So confirm no children\n        // are available\n        return waitForReplicatedFactoryChildServiceConvergence(initialStatesPerChild,\n                convergenceChecker,\n                0,\n                expectedVersion);\n    }\n\n    private Map<String, ExampleServiceState> doExampleFactoryPostReplicationTest(int childCount,\n            Map<Action, Long> countPerAction,\n            Map<Action, Long> elapsedTimePerAction)\n            throws Throwable {\n        return doExampleFactoryPostReplicationTest(childCount, null,\n                countPerAction, elapsedTimePerAction);\n    }\n\n    private Map<String, ExampleServiceState> doExampleFactoryPostReplicationTest(int childCount,\n            EnumSet<TestProperty> props,\n            Map<Action, Long> countPerAction,\n            Map<Action, Long> elapsedTimePerAction) throws Throwable {\n\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        if (this.host == null) {\n            setUp(this.nodeCount);\n            this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)) {\n            this.host.toggleNegativeTestMode(true);\n        }\n\n        String factoryPath = this.replicationTargetFactoryLink;\n        Map<String, ExampleServiceState> serviceStates = new HashMap<>();\n        long before = Utils.getNowMicrosUtc();\n        TestContext testContext = this.host.testCreate(childCount);\n        testContext.setTestName(\"POST replication\");\n        testContext.logBefore();\n        for (int i = 0; i < childCount; i++) {\n            URI factoryOnRandomPeerUri = this.host.getPeerServiceUri(factoryPath);\n            Operation post = Operation\n                    .createPost(factoryOnRandomPeerUri)\n                    .setCompletion(testContext.getCompletion());\n\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.name = \"\" + post.getId();\n            initialState.counter = Long.MIN_VALUE;\n\n            // set the self link as a hint so the child service URI is\n            // predefined instead of random\n            initialState.documentSelfLink = \"\" + post.getId();\n\n            // factory service is started on all hosts. Now issue a POST to one,\n            // to create a child service with some initial state.\n            post.setReferer(this.host.getReferer());\n            this.host.sendRequest(post.setBody(initialState));\n\n            // initial state is cloned and sent, now we can change self link per\n            // child to reflect its runtime URI, which will\n            // contain the factory service path\n            initialState.documentSelfLink = UriUtils.buildUriPath(factoryPath,\n                    initialState.documentSelfLink);\n            serviceStates.put(initialState.documentSelfLink, initialState);\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)) {\n            // do not wait for convergence of the child services. Instead\n            // proceed to the next test which is probably stopping hosts\n            // abruptly\n            return serviceStates;\n        }\n\n        testContext.await();\n        updatePerfDataPerAction(Action.POST, before, (long) this.serviceCount, countPerAction,\n                elapsedTimePerAction);\n\n        testContext.logAfter();\n\n        return waitForReplicatedFactoryChildServiceConvergence(serviceStates,\n                this.exampleStateConvergenceChecker,\n                childCount,\n                0L);\n    }\n\n    private void updateExampleServiceOptions(\n            Map<String, ExampleServiceState> statesPerSelfLink) throws Throwable {\n        if (this.postCreationServiceOptions == null || this.postCreationServiceOptions.isEmpty()) {\n            return;\n        }\n        TestContext testContext = this.host.testCreate(statesPerSelfLink.size());\n        URI nodeGroup = this.host.getNodeGroupMap().values().iterator().next();\n        for (String link : statesPerSelfLink.keySet()) {\n            URI bUri = UriUtils.buildBroadcastRequestUri(\n                    UriUtils.buildUri(nodeGroup, link, ServiceHost.SERVICE_URI_SUFFIX_CONFIG),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            ServiceConfigUpdateRequest cfgBody = ServiceConfigUpdateRequest.create();\n            cfgBody.addOptions = this.postCreationServiceOptions;\n            this.host.send(Operation.createPatch(bUri)\n                    .setBody(cfgBody)\n                    .setCompletion(testContext.getCompletion()));\n\n        }\n        testContext.await();\n    }\n\n    private <T extends ServiceDocument> Map<String, T> waitForReplicatedFactoryChildServiceConvergence(\n            Map<String, T> serviceStates,\n            BiPredicate<T, T> stateChecker,\n            int expectedChildCount, long expectedVersion)\n            throws Throwable, TimeoutException {\n        return waitForReplicatedFactoryChildServiceConvergence(\n                getFactoriesPerNodeGroup(this.replicationTargetFactoryLink),\n                serviceStates,\n                stateChecker,\n                expectedChildCount,\n                expectedVersion);\n    }\n\n    private <T extends ServiceDocument> Map<String, T> waitForReplicatedFactoryChildServiceConvergence(\n            Map<URI, URI> factories,\n            Map<String, T> serviceStates,\n            BiPredicate<T, T> stateChecker,\n            int expectedChildCount, long expectedVersion)\n            throws Throwable, TimeoutException {\n        // now poll all hosts until they converge: They all have a child service\n        // with the expected URI and it has the same state\n\n        Map<String, T> updatedStatesPerSelfLink = new HashMap<>();\n        Date expiration = new Date(new Date().getTime()\n                + TimeUnit.SECONDS.toMillis(this.host.getTimeoutSeconds()));\n        do {\n\n            URI node = factories.keySet().iterator().next();\n            AtomicInteger getFailureCount = new AtomicInteger();\n            if (expectedChildCount != 0) {\n                // issue direct GETs to the services, we do not trust the factory\n\n                for (String link : serviceStates.keySet()) {\n                    TestContext ctx = this.host.testCreate(1);\n                    Operation get = Operation.createGet(UriUtils.buildUri(node, link))\n                            .setReferer(this.host.getReferer())\n                            .setExpiration(Utils.getNowMicrosUtc() + TimeUnit.SECONDS.toMicros(5))\n                            .setCompletion(\n                                    (o, e) -> {\n                                        if (e != null) {\n                                            getFailureCount.incrementAndGet();\n                                        }\n                                        ctx.completeIteration();\n                                    });\n                    this.host.sendRequest(get);\n                    this.host.testWait(ctx);\n                }\n\n            }\n\n            if (getFailureCount.get() > 0) {\n                this.host.log(\"Child services not propagated yet. Failure count: %d\",\n                        getFailureCount.get());\n                Thread.sleep(500);\n                continue;\n            }\n\n            TestContext testContext = this.host.testCreate(factories.size());\n            Map<URI, ServiceDocumentQueryResult> childServicesPerNode = new HashMap<>();\n            for (URI remoteFactory : factories.values()) {\n                URI factoryUriWithExpand = UriUtils.buildExpandLinksQueryUri(remoteFactory);\n                Operation get = Operation.createGet(factoryUriWithExpand)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContext.complete();\n                                        return;\n                                    }\n                                    if (!o.hasBody()) {\n                                        testContext.complete();\n                                        return;\n                                    }\n                                    ServiceDocumentQueryResult r = o\n                                            .getBody(ServiceDocumentQueryResult.class);\n                                    synchronized (childServicesPerNode) {\n                                        childServicesPerNode.put(o.getUri(), r);\n                                    }\n                                    testContext.complete();\n                                });\n                this.host.send(get);\n            }\n            testContext.await();\n\n            long expectedNodeCountPerLinkMax = factories.size();\n            long expectedNodeCountPerLinkMin = expectedNodeCountPerLinkMax;\n            if (this.replicationFactor != 0) {\n                // We expect services to end up either on K nodes, or K + 1 nodes,\n                // if limited replication is enabled. The reason we might end up with services on\n                // an additional node, is because we elect an owner to synchronize an entire factory,\n                // using the factory's link, and that might end up on a node not used for any child.\n                // This will produce children on that node, giving us K+1 replication, which is acceptable\n                // given K (replication factor) << N (total nodes in group)\n                expectedNodeCountPerLinkMax = this.replicationFactor + 1;\n                expectedNodeCountPerLinkMin = this.replicationFactor;\n            }\n\n            if (expectedChildCount == 0) {\n                expectedNodeCountPerLinkMax = 0;\n                expectedNodeCountPerLinkMin = 0;\n            }\n\n            // build a service link to node map so we can tell on which node each service instance landed\n            Map<String, Set<URI>> linkToNodeMap = new HashMap<>();\n\n            boolean isConverged = true;\n            for (Entry<URI, ServiceDocumentQueryResult> entry : childServicesPerNode.entrySet()) {\n                for (String link : entry.getValue().documentLinks) {\n                    if (!serviceStates.containsKey(link)) {\n                        this.host.log(\"service %s not expected, node: %s\", link, entry.getKey());\n                        isConverged = false;\n                        continue;\n                    }\n\n                    Set<URI> hostsPerLink = linkToNodeMap.get(link);\n                    if (hostsPerLink == null) {\n                        hostsPerLink = new HashSet<>();\n                    }\n                    hostsPerLink.add(entry.getKey());\n                    linkToNodeMap.put(link, hostsPerLink);\n                }\n            }\n\n            if (!isConverged) {\n                Thread.sleep(500);\n                continue;\n            }\n\n            // each link must exist on N hosts, where N is either the replication factor, or, if not used, all nodes\n            for (Entry<String, Set<URI>> e : linkToNodeMap.entrySet()) {\n                if (e.getValue() == null && this.replicationFactor == 0) {\n                    this.host.log(\"Service %s not found on any nodes\", e.getKey());\n                    isConverged = false;\n                    continue;\n                }\n\n                if (e.getValue().size() < expectedNodeCountPerLinkMin\n                        || e.getValue().size() > expectedNodeCountPerLinkMax) {\n                    this.host.log(\"Service %s found on %d nodes, expected %d -> %d\", e.getKey(), e\n                                    .getValue().size(), expectedNodeCountPerLinkMin,\n                            expectedNodeCountPerLinkMax);\n                    isConverged = false;\n                }\n            }\n\n            if (!isConverged) {\n                Thread.sleep(500);\n                continue;\n            }\n\n            if (expectedChildCount == 0) {\n                // DELETE test, all children removed from all hosts, we are done\n                return updatedStatesPerSelfLink;\n            }\n\n            // verify /available reports correct results on the factory.\n            URI factoryUri = factories.values().iterator().next();\n            Class<?> stateType = serviceStates.values().iterator().next().getClass();\n            waitForReplicatedFactoryServiceAvailable(factoryUri,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n            // we have the correct number of services on all hosts. Now verify\n            // the state of each service matches what we expect\n\n            isConverged = true;\n\n            for (Entry<String, Set<URI>> entry : linkToNodeMap.entrySet()) {\n                String selfLink = entry.getKey();\n                int convergedNodeCount = 0;\n                for (URI nodeUri : entry.getValue()) {\n                    ServiceDocumentQueryResult childLinksAndDocsPerHost = childServicesPerNode\n                            .get(nodeUri);\n                    Object jsonState = childLinksAndDocsPerHost.documents.get(selfLink);\n                    if (jsonState == null && this.replicationFactor == 0) {\n                        this.host\n                                .log(\"Service %s not present on host %s\", selfLink, entry.getKey());\n                        continue;\n                    }\n\n                    if (jsonState == null) {\n                        continue;\n                    }\n\n                    T initialState = serviceStates.get(selfLink);\n\n                    if (initialState == null) {\n                        continue;\n                    }\n\n                    @SuppressWarnings(\"unchecked\")\n                    T stateOnNode = (T) Utils.fromJson(jsonState, stateType);\n                    if (!stateChecker.test(initialState, stateOnNode)) {\n                        this.host\n                                .log(\"State for %s not converged on node %s. Current state: %s, Initial: %s\",\n                                        selfLink, nodeUri, Utils.toJsonHtml(stateOnNode),\n                                        Utils.toJsonHtml(initialState));\n                        break;\n                    }\n\n                    if (stateOnNode.documentVersion < expectedVersion) {\n                        this.host\n                                .log(\"Version (%d, expected %d) not converged, state: %s\",\n                                        stateOnNode.documentVersion,\n                                        expectedVersion,\n                                        Utils.toJsonHtml(stateOnNode));\n                        break;\n                    }\n\n                    if (stateOnNode.documentEpoch == null) {\n                        this.host.log(\"Epoch is missing, state: %s\",\n                                Utils.toJsonHtml(stateOnNode));\n                        break;\n                    }\n\n                    // Do not check exampleState.counter, in this validation loop.\n                    // We can not compare the counter since the replication test sends the updates\n                    // in parallel, meaning some of them will get re-ordered and ignored due to\n                    // version being out of date.\n\n                    updatedStatesPerSelfLink.put(selfLink, stateOnNode);\n                    convergedNodeCount++;\n                }\n\n                if (convergedNodeCount < expectedNodeCountPerLinkMin\n                        || convergedNodeCount > expectedNodeCountPerLinkMax) {\n                    isConverged = false;\n                    break;\n                }\n            }\n\n            if (isConverged) {\n                return updatedStatesPerSelfLink;\n            }\n\n            Thread.sleep(500);\n        } while (new Date().before(expiration));\n\n        throw new TimeoutException();\n    }\n\n    private List<ServiceHostState> stopHostsToSimulateFailure(int failedNodeCount) {\n        int k = 0;\n        List<ServiceHostState> stoppedHosts = new ArrayList<>();\n        for (VerificationHost hostToStop : this.host.getInProcessHostMap().values()) {\n            this.host.log(\"Stopping host %s\", hostToStop);\n            stoppedHosts.add(hostToStop.getState());\n            this.host.stopHost(hostToStop);\n\n            k++;\n            if (k >= failedNodeCount) {\n                break;\n            }\n        }\n        return stoppedHosts;\n    }\n\n    public static class StopVerificationTestService extends StatefulService {\n\n        public Collection<URI> serviceTargets;\n\n        public AtomicInteger outboundRequestCompletion = new AtomicInteger();\n        public AtomicInteger outboundRequestFailureCompletion = new AtomicInteger();\n\n        public StopVerificationTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation deleteForStop) {\n            // send requests to replicated services, during stop to verify that the\n            // runtime prevents any outbound requests from making it out\n            for (URI uri : this.serviceTargets) {\n                ReplicationTestServiceState body = new ReplicationTestServiceState();\n                body.stringField = ReplicationTestServiceState.CLIENT_PATCH_HINT;\n                for (int i = 0; i < 10; i++) {\n                    // send patch to self, so the select owner logic gets invoked and in theory\n                    // queues or cancels the request\n                    Operation op = Operation.createPatch(this, uri.getPath()).setBody(body)\n                            .setTargetReplicated(true)\n                            .setCompletion((o, e) -> {\n                                if (e != null) {\n                                    this.outboundRequestFailureCompletion.incrementAndGet();\n                                } else {\n                                    this.outboundRequestCompletion.incrementAndGet();\n                                }\n                            });\n                    sendRequest(op);\n                }\n            }\n        }\n\n    }\n\n    private void stopHostsAndVerifyQueuing(Collection<VerificationHost> hostsToStop,\n            VerificationHost remainingHost,\n            Collection<URI> serviceTargets) throws Throwable {\n        this.host.log(\"Starting to stop hosts and verify queuing\");\n\n        // reduce node expiration for unavailable hosts so gossip warning\n        // messages do not flood the logs\n        this.nodeGroupConfig.nodeRemovalDelayMicros = remainingHost.getMaintenanceIntervalMicros();\n        this.host.setNodeGroupConfig(this.nodeGroupConfig);\n        this.setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(10));\n\n        // relax quorum to single remaining host\n        this.host.setNodeGroupQuorum(1);\n\n        // start a special test service that will attempt to send messages when it sees\n        // handleStop(). This is not expected of production code, since service authors\n        // should never have to worry about handleStop(). We rely on the fact that handleStop\n        // will be called due to node shutdown, and issue requests to replicated targets,\n        // then check if anyone of them actually made it out (they should not have)\n\n        List<StopVerificationTestService> verificationServices = new ArrayList<>();\n\n        // Do the inverse test. Remove all of the original hosts and this time, expect all the\n        // documents have owners assigned to the new hosts\n        for (VerificationHost h : hostsToStop) {\n            StopVerificationTestService s = new StopVerificationTestService();\n            verificationServices.add(s);\n            s.serviceTargets = serviceTargets;\n            h.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n            this.host.stopHost(h);\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            for (StopVerificationTestService s : verificationServices) {\n                if (s.outboundRequestCompletion.get() > 0) {\n                    throw new IllegalStateException(\"Replicated request succeeded\");\n                }\n                if (s.outboundRequestFailureCompletion.get() < serviceTargets.size()) {\n                    // We expect at least one failure per service target, if we have less\n                    // keep polling.\n                    this.host.log(\n                            \"Not converged yet: service %s on host %s has %d outbound request failures, which is lower than %d\",\n                            s.getSelfLink(), s.getHost().getId(),\n                            s.outboundRequestFailureCompletion.get(), serviceTargets.size());\n                    isConverged = false;\n                    break;\n                }\n            }\n\n            if (isConverged) {\n                this.host.log(\"Done with stop hosts and verify queuing\");\n                return;\n            }\n\n            Thread.sleep(250);\n        }\n\n        throw new TimeoutException();\n    }\n\n    private void waitForReplicatedFactoryServiceAvailable(URI uri, String nodeSelectorPath)\n            throws Throwable {\n        if (this.skipAvailabilityChecks) {\n            return;\n        }\n        if (UriUtils.isHostEqual(this.host, uri)) {\n\n            VerificationHost host = this.host;\n\n            // if uri is for in-process peers, then use the one\n            URI peerUri = UriUtils.buildUri(uri.toString().replace(uri.getPath(), \"\"));\n            VerificationHost peer = this.host.getInProcessHostMap().get(peerUri);\n            if (peer != null) {\n                host = peer;\n            }\n\n            TestContext ctx = host.testCreate(1);\n            CompletionHandler ch = (o, e) -> {\n                if (e != null) {\n                    String msg = \"Failed to check replicated factory service availability\";\n                    ctx.failIteration(new RuntimeException(msg, e));\n                    return;\n                }\n                ctx.completeIteration();\n            };\n\n            host.registerForServiceAvailability(ch, nodeSelectorPath, true, uri.getPath());\n            ctx.await();\n\n        } else {\n            // for remote host\n            this.host.waitForReplicatedFactoryServiceAvailable(uri, nodeSelectorPath);\n        }\n\n    }\n}\n"], "filenames": ["xenon-common/src/main/java/com/vmware/xenon/common/UtilityService.java", "xenon-common/src/test/java/com/vmware/xenon/common/TestAuthorization.java", "xenon-common/src/test/java/com/vmware/xenon/common/TestExampleServiceHost.java", "xenon-common/src/test/java/com/vmware/xenon/common/TestSubscriptions.java", "xenon-common/src/test/java/com/vmware/xenon/common/TestUtilityService.java", "xenon-common/src/test/java/com/vmware/xenon/common/test/AuthorizationHelper.java", "xenon-common/src/test/java/com/vmware/xenon/common/test/VerificationHost.java", "xenon-common/src/test/java/com/vmware/xenon/services/common/TestNodeGroupService.java"], "buggy_code_start_loc": [60, 515, 87, 301, 16, 32, 81, 2484], "buggy_code_end_loc": [61, 559, 88, 306, 588, 285, 1015, 2713], "fixing_code_start_loc": [60, 516, 88, 302, 17, 33, 82, 2485], "fixing_code_end_loc": [83, 588, 91, 310, 740, 313, 1025, 2714], "type": "CWE-732", "message": "VMware Xenon 1.x, prior to 1.5.4-CR7_1, 1.5.7_7, 1.5.4-CR6_2, 1.3.7-CR1_2, 1.1.0-CR0-3, 1.1.0-CR3_1,1.4.2-CR4_1, and 1.5.4_8, contains an authentication bypass vulnerability due to insufficient access controls for utility endpoints. Successful exploitation of this issue may result in information disclosure.", "other": {"cve": {"id": "CVE-2017-4952", "sourceIdentifier": "security@vmware.com", "published": "2018-05-02T14:29:00.380", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "VMware Xenon 1.x, prior to 1.5.4-CR7_1, 1.5.7_7, 1.5.4-CR6_2, 1.3.7-CR1_2, 1.1.0-CR0-3, 1.1.0-CR3_1,1.4.2-CR4_1, and 1.5.4_8, contains an authentication bypass vulnerability due to insufficient access controls for utility endpoints. Successful exploitation of this issue may result in information disclosure."}, {"lang": "es", "value": "VMware Xenon en versiones 1.x anteriores a la 1.5.4-CR7_1, 1.5.7_7, 1.5.4-CR6_2, 1.3.7-CR1_2, 1.1.0-CR0-3, 1.1.0-CR3_1,1.4.2-CR4_1 y 1.5.4_8, contiene una vulnerabilidad de omisi\u00f3n de autenticaci\u00f3n debido a los controles de acceso insuficiente para los endpoints de la utilidad. Una explotaci\u00f3n exitosa de esta vulnerabilidad podr\u00eda resultar en un escalado de privilegios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndIncluding": "1.5.3", "matchCriteriaId": "41FE1566-9CF4-4A2C-8B96-DC477B453732"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.1.0:cr0-3:*:*:*:*:*:*", "matchCriteriaId": "393C8F1B-3E97-475C-ACE0-AD60A40A3480"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.1.0:cr3_1:*:*:*:*:*:*", "matchCriteriaId": "908287BA-7E5D-4338-A3D4-39353F90B4EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.3.7:cr1_2:*:*:*:*:*:*", "matchCriteriaId": "256FB7C5-FAE1-4844-8BD1-63346EF86E59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.4.2:cr4_1:*:*:*:*:*:*", "matchCriteriaId": "FAA29AB6-196C-4894-AF9B-4AC802346227"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4:cr2:*:*:*:*:*:*", "matchCriteriaId": "718A5001-9D4B-40F2-A8DD-5B6271252F04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4:cr3:*:*:*:*:*:*", "matchCriteriaId": "14B90D4B-5381-460E-86EC-4A0245DFD29C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4:cr4:*:*:*:*:*:*", "matchCriteriaId": "A46B85FE-C297-45F1-BE2D-E2E55BE5552F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4:cr5:*:*:*:*:*:*", "matchCriteriaId": "14521FD5-177A-4C62-B3AB-6C2396A4609D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4:cr6:*:*:*:*:*:*", "matchCriteriaId": "178168B2-DF60-45B8-BB94-82151B4A10D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4:cr6_1:*:*:*:*:*:*", "matchCriteriaId": "0DB5E354-E700-47A8-A2A3-553EEC9BDAA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4:cr6_2:*:*:*:*:*:*", "matchCriteriaId": "6694BADF-CD2E-4ADD-B867-2DC0146FA901"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4:cr7:*:*:*:*:*:*", "matchCriteriaId": "AF7B077C-ADC1-4A3A-B1E6-FAB98A5EFB35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.4_8:*:*:*:*:*:*:*", "matchCriteriaId": "F9A47F10-AFF8-41B5-8BE6-9F6C2524D849"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vmware:xenon:1.5.7_7:*:*:*:*:*:*:*", "matchCriteriaId": "E14AA307-523D-4694-B50E-DB897AEA61E9"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2018/q1/153", "source": "security@vmware.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/103093", "source": "security@vmware.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/vmware/xenon/commit/055ae13603f0cc3cd7cf59f20ce314bf8db583e1", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vmware/xenon/commit/06b9947cf603ba40fd8b03bfeb2e84528a7ab592", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vmware/xenon/commit/30ae41bccf418d88b52b35a81efb3c1304b798f8", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vmware/xenon/commit/5682ef8d40569afd00fb9a5933e7706bb5b66713", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vmware/xenon/commit/756d893573414eec8635c2aba2345c4dcf10b21c", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vmware/xenon/commit/7a747d82b80cd38d2c11a0d9cdedb71c722a2c75", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vmware/xenon/commit/b1fd306047ecdac82661d636ebee801a7f2b3a0a", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vmware/xenon/commit/c23964eb57e846126daef98ef7ed15400313e977", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vmware/xenon/commit/ec30db9afada9cb52852082ce4d7d0095524f3b3", "source": "security@vmware.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vmware/xenon/commit/055ae13603f0cc3cd7cf59f20ce314bf8db583e1"}}