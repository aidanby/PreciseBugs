{"buggy_code": ["package logic\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gravitl/netmaker/database\"\n\t\"github.com/gravitl/netmaker/logic/pro\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/models/promodels\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nconst (\n\t// ALL_NETWORK_ACCESS - represents all networks\n\tALL_NETWORK_ACCESS = \"THIS_USER_HAS_ALL\"\n\n\tmaster_uname     = \"masteradministrator\"\n\tUnauthorized_Msg = \"unauthorized\"\n\tUnauthorized_Err = models.Error(Unauthorized_Msg)\n)\n\n// SecurityCheck - Check if user has appropriate permissions\nfunc SecurityCheck(reqAdmin bool, next http.Handler) http.HandlerFunc {\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvar errorResponse = models.ErrorResponse{\n\t\t\tCode: http.StatusUnauthorized, Message: Unauthorized_Msg,\n\t\t}\n\n\t\tvar params = mux.Vars(r)\n\t\tbearerToken := r.Header.Get(\"Authorization\")\n\t\t// to have a custom DNS service adding entries\n\t\t// we should refactor this, but is for the special case of an external service to query the DNS api\n\t\tif strings.Contains(r.RequestURI, \"/dns\") && strings.ToUpper(r.Method) == \"GET\" && authenticateDNSToken(bearerToken) {\n\t\t\t// do dns stuff\n\t\t\tr.Header.Set(\"user\", \"nameserver\")\n\t\t\tnetworks, _ := json.Marshal([]string{ALL_NETWORK_ACCESS})\n\t\t\tr.Header.Set(\"networks\", string(networks))\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\tvar networkName = params[\"networkname\"]\n\t\tif len(networkName) == 0 {\n\t\t\tnetworkName = params[\"network\"]\n\t\t}\n\t\tnetworks, username, err := UserPermissions(reqAdmin, networkName, bearerToken)\n\t\tif err != nil {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\t\tnetworksJson, err := json.Marshal(&networks)\n\t\tif err != nil {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\t\tr.Header.Set(\"user\", username)\n\t\tr.Header.Set(\"networks\", string(networksJson))\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n\n// NetUserSecurityCheck - Check if network user has appropriate permissions\nfunc NetUserSecurityCheck(isNodes, isClients bool, next http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvar errorResponse = models.ErrorResponse{\n\t\t\tCode: http.StatusUnauthorized, Message: \"unauthorized\",\n\t\t}\n\t\tr.Header.Set(\"ismaster\", \"no\")\n\n\t\tvar params = mux.Vars(r)\n\t\tvar netUserName = params[\"networkuser\"]\n\t\tvar network = params[\"network\"]\n\n\t\tbearerToken := r.Header.Get(\"Authorization\")\n\n\t\tvar tokenSplit = strings.Split(bearerToken, \" \")\n\t\tvar authToken = \"\"\n\n\t\tif len(tokenSplit) < 2 {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t} else {\n\t\t\tauthToken = tokenSplit[1]\n\t\t}\n\n\t\tisMasterAuthenticated := authenticateMaster(authToken)\n\t\tif isMasterAuthenticated {\n\t\t\tr.Header.Set(\"user\", \"master token user\")\n\t\t\tr.Header.Set(\"ismaster\", \"yes\")\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tuserName, _, isadmin, err := VerifyUserToken(authToken)\n\t\tif err != nil {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\t\tr.Header.Set(\"user\", userName)\n\n\t\tif isadmin {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif isNodes || isClients {\n\t\t\tnecessaryAccess := pro.NET_ADMIN\n\t\t\tif isClients {\n\t\t\t\tnecessaryAccess = pro.CLIENT_ACCESS\n\t\t\t}\n\t\t\tif isNodes {\n\t\t\t\tnecessaryAccess = pro.NODE_ACCESS\n\t\t\t}\n\t\t\tu, err := pro.GetNetworkUser(network, promodels.NetworkUserID(userName))\n\t\t\tif err != nil {\n\t\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif u.AccessLevel > necessaryAccess {\n\t\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else if netUserName != userName {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n\n// UserPermissions - checks token stuff\nfunc UserPermissions(reqAdmin bool, netname string, token string) ([]string, string, error) {\n\tvar tokenSplit = strings.Split(token, \" \")\n\tvar authToken = \"\"\n\tuserNetworks := []string{}\n\n\tif len(tokenSplit) < 2 {\n\t\treturn userNetworks, \"\", Unauthorized_Err\n\t} else {\n\t\tauthToken = tokenSplit[1]\n\t}\n\t//all endpoints here require master so not as complicated\n\tif authenticateMaster(authToken) {\n\t\treturn []string{ALL_NETWORK_ACCESS}, master_uname, nil\n\t}\n\tusername, networks, isadmin, err := VerifyUserToken(authToken)\n\tif err != nil {\n\t\treturn nil, username, Unauthorized_Err\n\t}\n\tif !isadmin && reqAdmin {\n\t\treturn nil, username, Unauthorized_Err\n\t}\n\tuserNetworks = networks\n\tif isadmin {\n\t\treturn []string{ALL_NETWORK_ACCESS}, username, nil\n\t}\n\t// check network admin access\n\tif len(netname) > 0 && (len(userNetworks) == 0 || !authenticateNetworkUser(netname, userNetworks)) {\n\t\treturn nil, username, Unauthorized_Err\n\t}\n\tif isEE && len(netname) > 0 && !pro.IsUserNetAdmin(netname, username) {\n\t\treturn nil, \"\", Unauthorized_Err\n\t}\n\treturn userNetworks, username, nil\n}\n\n// Consider a more secure way of setting master key\nfunc authenticateMaster(tokenString string) bool {\n\treturn tokenString == servercfg.GetMasterKey() && servercfg.GetMasterKey() != \"\"\n}\n\nfunc authenticateNetworkUser(network string, userNetworks []string) bool {\n\tnetworkexists, err := NetworkExists(network)\n\tif (err != nil && !database.IsEmptyRecord(err)) || !networkexists {\n\t\treturn false\n\t}\n\treturn StringSliceContains(userNetworks, network)\n}\n\n// Consider a more secure way of setting master key\nfunc authenticateDNSToken(tokenString string) bool {\n\ttokens := strings.Split(tokenString, \" \")\n\tif len(tokens) < 2 {\n\t\treturn false\n\t}\n\treturn tokens[1] == servercfg.GetDNSKey()\n}\n\nfunc ContinueIfUserMatch(next http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvar errorResponse = models.ErrorResponse{\n\t\t\tCode: http.StatusUnauthorized, Message: Unauthorized_Msg,\n\t\t}\n\t\tvar params = mux.Vars(r)\n\t\tvar requestedUser = params[\"username\"]\n\t\tif requestedUser != r.Header.Get(\"user\") {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "package servercfg\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gravitl/netmaker/config\"\n\t\"github.com/gravitl/netmaker/models\"\n)\n\n// EmqxBrokerType denotes the broker type for EMQX MQTT\nconst EmqxBrokerType = \"emqx\"\n\nvar (\n\tVersion = \"dev\"\n\tIs_EE   = false\n)\n\n// SetHost - sets the host ip\nfunc SetHost() error {\n\tremoteip, err := GetPublicIP()\n\tif err != nil {\n\t\treturn err\n\t}\n\tos.Setenv(\"SERVER_HOST\", remoteip)\n\treturn nil\n}\n\n// GetServerConfig - gets the server config into memory from file or env\nfunc GetServerConfig() config.ServerConfig {\n\tvar cfg config.ServerConfig\n\tcfg.APIConnString = GetAPIConnString()\n\tcfg.CoreDNSAddr = GetCoreDNSAddr()\n\tcfg.APIHost = GetAPIHost()\n\tcfg.APIPort = GetAPIPort()\n\tcfg.MasterKey = \"(hidden)\"\n\tcfg.DNSKey = \"(hidden)\"\n\tcfg.AllowedOrigin = GetAllowedOrigin()\n\tcfg.RestBackend = \"off\"\n\tcfg.NodeID = GetNodeID()\n\tcfg.StunPort = GetStunPort()\n\tcfg.BrokerType = GetBrokerType()\n\tcfg.EmqxRestEndpoint = GetEmqxRestEndpoint()\n\tif IsRestBackend() {\n\t\tcfg.RestBackend = \"on\"\n\t}\n\tcfg.DNSMode = \"off\"\n\tif IsDNSMode() {\n\t\tcfg.DNSMode = \"on\"\n\t}\n\tcfg.DisplayKeys = \"off\"\n\tif IsDisplayKeys() {\n\t\tcfg.DisplayKeys = \"on\"\n\t}\n\tcfg.DisableRemoteIPCheck = \"off\"\n\tif DisableRemoteIPCheck() {\n\t\tcfg.DisableRemoteIPCheck = \"on\"\n\t}\n\tcfg.Database = GetDB()\n\tcfg.Platform = GetPlatform()\n\tcfg.Version = GetVersion()\n\n\t// == auth config ==\n\tvar authInfo = GetAuthProviderInfo()\n\tcfg.AuthProvider = authInfo[0]\n\tcfg.ClientID = authInfo[1]\n\tcfg.ClientSecret = authInfo[2]\n\tcfg.FrontendURL = GetFrontendURL()\n\tcfg.Telemetry = Telemetry()\n\tcfg.Server = GetServer()\n\tcfg.StunList = GetStunListString()\n\tcfg.Verbosity = GetVerbosity()\n\tcfg.IsEE = \"no\"\n\tif Is_EE {\n\t\tcfg.IsEE = \"yes\"\n\t}\n\tcfg.DefaultProxyMode = GetDefaultProxyMode()\n\n\treturn cfg\n}\n\n// GetServerConfig - gets the server config into memory from file or env\nfunc GetServerInfo() models.ServerConfig {\n\tvar cfg models.ServerConfig\n\tcfg.Server = GetServer()\n\tcfg.MQUserName = GetMqUserName()\n\tcfg.MQPassword = GetMqPassword()\n\tcfg.API = GetAPIConnString()\n\tcfg.CoreDNSAddr = GetCoreDNSAddr()\n\tcfg.APIPort = GetAPIPort()\n\tcfg.DNSMode = \"off\"\n\tcfg.Broker = GetPublicBrokerEndpoint()\n\tif IsDNSMode() {\n\t\tcfg.DNSMode = \"on\"\n\t}\n\tcfg.Version = GetVersion()\n\tcfg.Is_EE = Is_EE\n\tcfg.StunPort = GetStunPort()\n\tcfg.StunList = GetStunList()\n\n\treturn cfg\n}\n\n// GetFrontendURL - gets the frontend url\nfunc GetFrontendURL() string {\n\tvar frontend = \"\"\n\tif os.Getenv(\"FRONTEND_URL\") != \"\" {\n\t\tfrontend = os.Getenv(\"FRONTEND_URL\")\n\t} else if config.Config.Server.FrontendURL != \"\" {\n\t\tfrontend = config.Config.Server.FrontendURL\n\t}\n\treturn frontend\n}\n\n// GetAPIConnString - gets the api connections string\nfunc GetAPIConnString() string {\n\tconn := \"\"\n\tif os.Getenv(\"SERVER_API_CONN_STRING\") != \"\" {\n\t\tconn = os.Getenv(\"SERVER_API_CONN_STRING\")\n\t} else if config.Config.Server.APIConnString != \"\" {\n\t\tconn = config.Config.Server.APIConnString\n\t}\n\treturn conn\n}\n\n// SetVersion - set version of netmaker\nfunc SetVersion(v string) {\n\tVersion = v\n}\n\n// GetVersion - version of netmaker\nfunc GetVersion() string {\n\treturn Version\n}\n\n// GetDB - gets the database type\nfunc GetDB() string {\n\tdatabase := \"sqlite\"\n\tif os.Getenv(\"DATABASE\") != \"\" {\n\t\tdatabase = os.Getenv(\"DATABASE\")\n\t} else if config.Config.Server.Database != \"\" {\n\t\tdatabase = config.Config.Server.Database\n\t}\n\treturn database\n}\n\n// GetAPIHost - gets the api host\nfunc GetAPIHost() string {\n\tserverhost := \"127.0.0.1\"\n\tremoteip, _ := GetPublicIP()\n\tif os.Getenv(\"SERVER_HTTP_HOST\") != \"\" {\n\t\tserverhost = os.Getenv(\"SERVER_HTTP_HOST\")\n\t} else if config.Config.Server.APIHost != \"\" {\n\t\tserverhost = config.Config.Server.APIHost\n\t} else if os.Getenv(\"SERVER_HOST\") != \"\" {\n\t\tserverhost = os.Getenv(\"SERVER_HOST\")\n\t} else {\n\t\tif remoteip != \"\" {\n\t\t\tserverhost = remoteip\n\t\t}\n\t}\n\treturn serverhost\n}\n\n// GetAPIPort - gets the api port\nfunc GetAPIPort() string {\n\tapiport := \"8081\"\n\tif os.Getenv(\"API_PORT\") != \"\" {\n\t\tapiport = os.Getenv(\"API_PORT\")\n\t} else if config.Config.Server.APIPort != \"\" {\n\t\tapiport = config.Config.Server.APIPort\n\t}\n\treturn apiport\n}\n\n// GetStunList - gets the stun servers\nfunc GetStunList() []models.StunServer {\n\tstunList := []models.StunServer{\n\t\tmodels.StunServer{\n\t\t\tDomain: \"stun1.netmaker.io\",\n\t\t\tPort:   3478,\n\t\t},\n\t\tmodels.StunServer{\n\t\t\tDomain: \"stun2.netmaker.io\",\n\t\t\tPort:   3478,\n\t\t},\n\t}\n\tparsed := false\n\tif os.Getenv(\"STUN_LIST\") != \"\" {\n\t\tstuns, err := parseStunList(os.Getenv(\"STUN_LIST\"))\n\t\tif err == nil {\n\t\t\tparsed = true\n\t\t\tstunList = stuns\n\t\t}\n\t}\n\tif !parsed && config.Config.Server.StunList != \"\" {\n\t\tstuns, err := parseStunList(config.Config.Server.StunList)\n\t\tif err == nil {\n\t\t\tstunList = stuns\n\t\t}\n\t}\n\treturn stunList\n}\n\n// GetStunList - gets the stun servers w/o parsing to struct\nfunc GetStunListString() string {\n\tstunList := \"stun1.netmaker.io:3478,stun2.netmaker.io:3478\"\n\tif os.Getenv(\"STUN_LIST\") != \"\" {\n\t\tstunList = os.Getenv(\"STUN_LIST\")\n\t} else if config.Config.Server.StunList != \"\" {\n\t\tstunList = config.Config.Server.StunList\n\t}\n\treturn stunList\n}\n\n// GetCoreDNSAddr - gets the core dns address\nfunc GetCoreDNSAddr() string {\n\taddr, _ := GetPublicIP()\n\tif os.Getenv(\"COREDNS_ADDR\") != \"\" {\n\t\taddr = os.Getenv(\"COREDNS_ADDR\")\n\t} else if config.Config.Server.CoreDNSAddr != \"\" {\n\t\taddr = config.Config.Server.CoreDNSAddr\n\t}\n\treturn addr\n}\n\n// GetPublicBrokerEndpoint - returns the public broker endpoint which shall be used by netclient\nfunc GetPublicBrokerEndpoint() string {\n\tif os.Getenv(\"BROKER_ENDPOINT\") != \"\" {\n\t\treturn os.Getenv(\"BROKER_ENDPOINT\")\n\t} else {\n\t\treturn config.Config.Server.Broker\n\t}\n}\n\n// GetMessageQueueEndpoint - gets the message queue endpoint\nfunc GetMessageQueueEndpoint() (string, bool) {\n\thost, _ := GetPublicIP()\n\tif os.Getenv(\"SERVER_BROKER_ENDPOINT\") != \"\" {\n\t\thost = os.Getenv(\"SERVER_BROKER_ENDPOINT\")\n\t} else if config.Config.Server.ServerBrokerEndpoint != \"\" {\n\t\thost = config.Config.Server.ServerBrokerEndpoint\n\t} else if os.Getenv(\"BROKER_ENDPOINT\") != \"\" {\n\t\thost = os.Getenv(\"BROKER_ENDPOINT\")\n\t} else if config.Config.Server.Broker != \"\" {\n\t\thost = config.Config.Server.Broker\n\t} else {\n\t\thost += \":1883\" // default\n\t}\n\treturn host, strings.Contains(host, \"wss\") || strings.Contains(host, \"ssl\") || strings.Contains(host, \"mqtts\")\n}\n\n// GetBrokerType - returns the type of MQ broker\nfunc GetBrokerType() string {\n\tif os.Getenv(\"BROKER_TYPE\") != \"\" {\n\t\treturn os.Getenv(\"BROKER_TYPE\")\n\t} else {\n\t\treturn \"mosquitto\"\n\t}\n}\n\n// GetMasterKey - gets the configured master key of server\nfunc GetMasterKey() string {\n\tkey := \"\"\n\tif os.Getenv(\"MASTER_KEY\") != \"\" {\n\t\tkey = os.Getenv(\"MASTER_KEY\")\n\t} else if config.Config.Server.MasterKey != \"\" {\n\t\tkey = config.Config.Server.MasterKey\n\t}\n\treturn key\n}\n\n// GetDNSKey - gets the configured dns key of server\nfunc GetDNSKey() string {\n\tkey := \"secretkey\"\n\tif os.Getenv(\"DNS_KEY\") != \"\" {\n\t\tkey = os.Getenv(\"DNS_KEY\")\n\t} else if config.Config.Server.DNSKey != \"\" {\n\t\tkey = config.Config.Server.DNSKey\n\t}\n\treturn key\n}\n\n// GetAllowedOrigin - get the allowed origin\nfunc GetAllowedOrigin() string {\n\tallowedorigin := \"*\"\n\tif os.Getenv(\"CORS_ALLOWED_ORIGIN\") != \"\" {\n\t\tallowedorigin = os.Getenv(\"CORS_ALLOWED_ORIGIN\")\n\t} else if config.Config.Server.AllowedOrigin != \"\" {\n\t\tallowedorigin = config.Config.Server.AllowedOrigin\n\t}\n\treturn allowedorigin\n}\n\n// IsRestBackend - checks if rest is on or off\nfunc IsRestBackend() bool {\n\tisrest := true\n\tif os.Getenv(\"REST_BACKEND\") != \"\" {\n\t\tif os.Getenv(\"REST_BACKEND\") == \"off\" {\n\t\t\tisrest = false\n\t\t}\n\t} else if config.Config.Server.RestBackend != \"\" {\n\t\tif config.Config.Server.RestBackend == \"off\" {\n\t\t\tisrest = false\n\t\t}\n\t}\n\treturn isrest\n}\n\n// IsMetricsExporter - checks if metrics exporter is on or off\nfunc IsMetricsExporter() bool {\n\texport := false\n\tif os.Getenv(\"METRICS_EXPORTER\") != \"\" {\n\t\tif os.Getenv(\"METRICS_EXPORTER\") == \"on\" {\n\t\t\texport = true\n\t\t}\n\t} else if config.Config.Server.MetricsExporter != \"\" {\n\t\tif config.Config.Server.MetricsExporter == \"on\" {\n\t\t\texport = true\n\t\t}\n\t}\n\treturn export\n}\n\n// IsMessageQueueBackend - checks if message queue is on or off\nfunc IsMessageQueueBackend() bool {\n\tismessagequeue := true\n\tif os.Getenv(\"MESSAGEQUEUE_BACKEND\") != \"\" {\n\t\tif os.Getenv(\"MESSAGEQUEUE_BACKEND\") == \"off\" {\n\t\t\tismessagequeue = false\n\t\t}\n\t} else if config.Config.Server.MessageQueueBackend != \"\" {\n\t\tif config.Config.Server.MessageQueueBackend == \"off\" {\n\t\t\tismessagequeue = false\n\t\t}\n\t}\n\treturn ismessagequeue\n}\n\n// Telemetry - checks if telemetry data should be sent\nfunc Telemetry() string {\n\ttelemetry := \"on\"\n\tif os.Getenv(\"TELEMETRY\") == \"off\" {\n\t\ttelemetry = \"off\"\n\t}\n\tif config.Config.Server.Telemetry == \"off\" {\n\t\ttelemetry = \"off\"\n\t}\n\treturn telemetry\n}\n\n// GetServer - gets the server name\nfunc GetServer() string {\n\tserver := \"\"\n\tif os.Getenv(\"SERVER_NAME\") != \"\" {\n\t\tserver = os.Getenv(\"SERVER_NAME\")\n\t} else if config.Config.Server.Server != \"\" {\n\t\tserver = config.Config.Server.Server\n\t}\n\treturn server\n}\n\nfunc GetVerbosity() int32 {\n\tvar verbosity = 0\n\tvar err error\n\tif os.Getenv(\"VERBOSITY\") != \"\" {\n\t\tverbosity, err = strconv.Atoi(os.Getenv(\"VERBOSITY\"))\n\t\tif err != nil {\n\t\t\tverbosity = 0\n\t\t}\n\t} else if config.Config.Server.Verbosity != 0 {\n\t\tverbosity = int(config.Config.Server.Verbosity)\n\t}\n\tif verbosity < 0 || verbosity > 4 {\n\t\tverbosity = 0\n\t}\n\treturn int32(verbosity)\n}\n\n// IsDNSMode - should it run with DNS\nfunc IsDNSMode() bool {\n\tisdns := true\n\tif os.Getenv(\"DNS_MODE\") != \"\" {\n\t\tif os.Getenv(\"DNS_MODE\") == \"off\" {\n\t\t\tisdns = false\n\t\t}\n\t} else if config.Config.Server.DNSMode != \"\" {\n\t\tif config.Config.Server.DNSMode == \"off\" {\n\t\t\tisdns = false\n\t\t}\n\t}\n\treturn isdns\n}\n\n// IsDisplayKeys - should server be able to display keys?\nfunc IsDisplayKeys() bool {\n\tisdisplay := true\n\tif os.Getenv(\"DISPLAY_KEYS\") != \"\" {\n\t\tif os.Getenv(\"DISPLAY_KEYS\") == \"off\" {\n\t\t\tisdisplay = false\n\t\t}\n\t} else if config.Config.Server.DisplayKeys != \"\" {\n\t\tif config.Config.Server.DisplayKeys == \"off\" {\n\t\t\tisdisplay = false\n\t\t}\n\t}\n\treturn isdisplay\n}\n\n// DisableRemoteIPCheck - disable the remote ip check\nfunc DisableRemoteIPCheck() bool {\n\tdisabled := false\n\tif os.Getenv(\"DISABLE_REMOTE_IP_CHECK\") != \"\" {\n\t\tif os.Getenv(\"DISABLE_REMOTE_IP_CHECK\") == \"on\" {\n\t\t\tdisabled = true\n\t\t}\n\t} else if config.Config.Server.DisableRemoteIPCheck != \"\" {\n\t\tif config.Config.Server.DisableRemoteIPCheck == \"on\" {\n\t\t\tdisabled = true\n\t\t}\n\t}\n\treturn disabled\n}\n\n// GetPublicIP - gets public ip\nfunc GetPublicIP() (string, error) {\n\n\tendpoint := \"\"\n\tvar err error\n\n\tiplist := []string{\"https://ip.server.gravitl.com\", \"https://ifconfig.me\", \"https://api.ipify.org\", \"https://ipinfo.io/ip\"}\n\tpublicIpService := os.Getenv(\"PUBLIC_IP_SERVICE\")\n\tif publicIpService != \"\" {\n\t\t// prepend the user-specified service so it's checked first\n\t\tiplist = append([]string{publicIpService}, iplist...)\n\t} else if config.Config.Server.PublicIPService != \"\" {\n\t\tpublicIpService = config.Config.Server.PublicIPService\n\n\t\t// prepend the user-specified service so it's checked first\n\t\tiplist = append([]string{publicIpService}, iplist...)\n\t}\n\n\tfor _, ipserver := range iplist {\n\t\tclient := &http.Client{\n\t\t\tTimeout: time.Second * 10,\n\t\t}\n\t\tresp, err := client.Get(ipserver)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tif resp.StatusCode == http.StatusOK {\n\t\t\tbodyBytes, err := io.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tendpoint = string(bodyBytes)\n\t\t\tbreak\n\t\t}\n\t}\n\tif err == nil && endpoint == \"\" {\n\t\terr = errors.New(\"public address not found\")\n\t}\n\treturn endpoint, err\n}\n\n// GetPlatform - get the system type of server\nfunc GetPlatform() string {\n\tplatform := \"linux\"\n\tif os.Getenv(\"PLATFORM\") != \"\" {\n\t\tplatform = os.Getenv(\"PLATFORM\")\n\t} else if config.Config.Server.Platform != \"\" {\n\t\tplatform = config.Config.Server.Platform\n\t}\n\treturn platform\n}\n\n// GetSQLConn - get the sql connection string\nfunc GetSQLConn() string {\n\tsqlconn := \"http://\"\n\tif os.Getenv(\"SQL_CONN\") != \"\" {\n\t\tsqlconn = os.Getenv(\"SQL_CONN\")\n\t} else if config.Config.Server.SQLConn != \"\" {\n\t\tsqlconn = config.Config.Server.SQLConn\n\t}\n\treturn sqlconn\n}\n\n// GetNodeID - gets the node id\nfunc GetNodeID() string {\n\tvar id string\n\tvar err error\n\t// id = getMacAddr()\n\tif os.Getenv(\"NODE_ID\") != \"\" {\n\t\tid = os.Getenv(\"NODE_ID\")\n\t} else if config.Config.Server.NodeID != \"\" {\n\t\tid = config.Config.Server.NodeID\n\t} else {\n\t\tid, err = os.Hostname()\n\t\tif err != nil {\n\t\t\treturn \"\"\n\t\t}\n\t}\n\treturn id\n}\n\nfunc SetNodeID(id string) {\n\tconfig.Config.Server.NodeID = id\n}\n\n// GetAuthProviderInfo = gets the oauth provider info\nfunc GetAuthProviderInfo() (pi []string) {\n\tvar authProvider = \"\"\n\n\tdefer func() {\n\t\tif authProvider == \"oidc\" {\n\t\t\tif os.Getenv(\"OIDC_ISSUER\") != \"\" {\n\t\t\t\tpi = append(pi, os.Getenv(\"OIDC_ISSUER\"))\n\t\t\t} else if config.Config.Server.OIDCIssuer != \"\" {\n\t\t\t\tpi = append(pi, config.Config.Server.OIDCIssuer)\n\t\t\t} else {\n\t\t\t\tpi = []string{\"\", \"\", \"\"}\n\t\t\t}\n\t\t}\n\t}()\n\n\tif os.Getenv(\"AUTH_PROVIDER\") != \"\" && os.Getenv(\"CLIENT_ID\") != \"\" && os.Getenv(\"CLIENT_SECRET\") != \"\" {\n\t\tauthProvider = strings.ToLower(os.Getenv(\"AUTH_PROVIDER\"))\n\t\tif authProvider == \"google\" || authProvider == \"azure-ad\" || authProvider == \"github\" || authProvider == \"oidc\" {\n\t\t\treturn []string{authProvider, os.Getenv(\"CLIENT_ID\"), os.Getenv(\"CLIENT_SECRET\")}\n\t\t} else {\n\t\t\tauthProvider = \"\"\n\t\t}\n\t} else if config.Config.Server.AuthProvider != \"\" && config.Config.Server.ClientID != \"\" && config.Config.Server.ClientSecret != \"\" {\n\t\tauthProvider = strings.ToLower(config.Config.Server.AuthProvider)\n\t\tif authProvider == \"google\" || authProvider == \"azure-ad\" || authProvider == \"github\" || authProvider == \"oidc\" {\n\t\t\treturn []string{authProvider, config.Config.Server.ClientID, config.Config.Server.ClientSecret}\n\t\t}\n\t}\n\treturn []string{\"\", \"\", \"\"}\n}\n\n// GetAzureTenant - retrieve the azure tenant ID from env variable or config file\nfunc GetAzureTenant() string {\n\tvar azureTenant = \"\"\n\tif os.Getenv(\"AZURE_TENANT\") != \"\" {\n\t\tazureTenant = os.Getenv(\"AZURE_TENANT\")\n\t} else if config.Config.Server.AzureTenant != \"\" {\n\t\tazureTenant = config.Config.Server.AzureTenant\n\t}\n\treturn azureTenant\n}\n\n// GetMqPassword - fetches the MQ password\nfunc GetMqPassword() string {\n\tpassword := \"\"\n\tif os.Getenv(\"MQ_PASSWORD\") != \"\" {\n\t\tpassword = os.Getenv(\"MQ_PASSWORD\")\n\t} else if config.Config.Server.MQPassword != \"\" {\n\t\tpassword = config.Config.Server.MQPassword\n\t}\n\treturn password\n}\n\n// GetMqUserName - fetches the MQ username\nfunc GetMqUserName() string {\n\tpassword := \"\"\n\tif os.Getenv(\"MQ_USERNAME\") != \"\" {\n\t\tpassword = os.Getenv(\"MQ_USERNAME\")\n\t} else if config.Config.Server.MQUserName != \"\" {\n\t\tpassword = config.Config.Server.MQUserName\n\t}\n\treturn password\n}\n\n// GetEmqxRestEndpoint - returns the REST API Endpoint of EMQX\nfunc GetEmqxRestEndpoint() string {\n\treturn os.Getenv(\"EMQX_REST_ENDPOINT\")\n}\n\n// IsBasicAuthEnabled - checks if basic auth has been configured to be turned off\nfunc IsBasicAuthEnabled() bool {\n\tvar enabled = true //default\n\tif os.Getenv(\"BASIC_AUTH\") != \"\" {\n\t\tenabled = os.Getenv(\"BASIC_AUTH\") == \"yes\"\n\t} else if config.Config.Server.BasicAuth != \"\" {\n\t\tenabled = config.Config.Server.BasicAuth == \"yes\"\n\t}\n\treturn enabled\n}\n\n// GetLicenseKey - retrieves pro license value from env or conf files\nfunc GetLicenseKey() string {\n\tlicenseKeyValue := os.Getenv(\"LICENSE_KEY\")\n\tif licenseKeyValue == \"\" {\n\t\tlicenseKeyValue = config.Config.Server.LicenseValue\n\t}\n\treturn licenseKeyValue\n}\n\n// GetNetmakerAccountID - get's the associated, Netmaker, account ID to verify ownership\nfunc GetNetmakerAccountID() string {\n\tnetmakerAccountID := os.Getenv(\"NETMAKER_ACCOUNT_ID\")\n\tif netmakerAccountID == \"\" {\n\t\tnetmakerAccountID = config.Config.Server.NetmakerAccountID\n\t}\n\treturn netmakerAccountID\n}\n\n// GetStunPort - Get the port to run the stun server on\nfunc GetStunPort() int {\n\tport := 3478 //default\n\tif os.Getenv(\"STUN_PORT\") != \"\" {\n\t\tportInt, err := strconv.Atoi(os.Getenv(\"STUN_PORT\"))\n\t\tif err == nil {\n\t\t\tport = portInt\n\t\t}\n\t} else if config.Config.Server.StunPort != 0 {\n\t\tport = config.Config.Server.StunPort\n\t}\n\treturn port\n}\n\n// IsProxyEnabled - is proxy on or off\nfunc IsProxyEnabled() bool {\n\tvar enabled = false //default\n\tif os.Getenv(\"PROXY\") != \"\" {\n\t\tenabled = os.Getenv(\"PROXY\") == \"on\"\n\t} else if config.Config.Server.Proxy != \"\" {\n\t\tenabled = config.Config.Server.Proxy == \"on\"\n\t}\n\treturn enabled\n}\n\n// GetDefaultProxyMode - default proxy mode for a server\nfunc GetDefaultProxyMode() config.ProxyMode {\n\tvar (\n\t\tmode config.ProxyMode\n\t\tdef  string\n\t)\n\tif os.Getenv(\"DEFAULT_PROXY_MODE\") != \"\" {\n\t\tdef = os.Getenv(\"DEFAULT_PROXY_MODE\")\n\t} else if config.Config.Server.DefaultProxyMode.Set {\n\t\treturn config.Config.Server.DefaultProxyMode\n\t}\n\tswitch strings.ToUpper(def) {\n\tcase \"ON\":\n\t\tmode.Set = true\n\t\tmode.Value = true\n\tcase \"OFF\":\n\t\tmode.Set = true\n\t\tmode.Value = false\n\t// AUTO or any other value\n\tdefault:\n\t\tmode.Set = false\n\t}\n\treturn mode\n\n}\n\n// parseStunList - turn string into slice of StunServers\nfunc parseStunList(stunString string) ([]models.StunServer, error) {\n\tvar err error\n\tstunServers := []models.StunServer{}\n\tstuns := strings.Split(stunString, \",\")\n\tif len(stuns) == 0 {\n\t\treturn stunServers, errors.New(\"no stun servers provided\")\n\t}\n\tfor _, stun := range stuns {\n\t\tstun = strings.Trim(stun, \" \")\n\t\tstunInfo := strings.Split(stun, \":\")\n\t\tif len(stunInfo) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tport, err := strconv.Atoi(stunInfo[1])\n\t\tif err != nil || port == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tstunServers = append(stunServers, models.StunServer{\n\t\t\tDomain: stunInfo[0],\n\t\t\tPort:   port,\n\t\t})\n\n\t}\n\tif len(stunServers) == 0 {\n\t\terr = errors.New(\"no stun entries parsable\")\n\t}\n\treturn stunServers, err\n}\n"], "fixing_code": ["package logic\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gravitl/netmaker/database\"\n\t\"github.com/gravitl/netmaker/logic/pro\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/models/promodels\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nconst (\n\t// ALL_NETWORK_ACCESS - represents all networks\n\tALL_NETWORK_ACCESS = \"THIS_USER_HAS_ALL\"\n\n\tmaster_uname     = \"masteradministrator\"\n\tUnauthorized_Msg = \"unauthorized\"\n\tUnauthorized_Err = models.Error(Unauthorized_Msg)\n)\n\n// SecurityCheck - Check if user has appropriate permissions\nfunc SecurityCheck(reqAdmin bool, next http.Handler) http.HandlerFunc {\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvar errorResponse = models.ErrorResponse{\n\t\t\tCode: http.StatusUnauthorized, Message: Unauthorized_Msg,\n\t\t}\n\n\t\tvar params = mux.Vars(r)\n\t\tbearerToken := r.Header.Get(\"Authorization\")\n\t\t// to have a custom DNS service adding entries\n\t\t// we should refactor this, but is for the special case of an external service to query the DNS api\n\t\tif strings.Contains(r.RequestURI, \"/dns\") && strings.ToUpper(r.Method) == \"GET\" && authenticateDNSToken(bearerToken) {\n\t\t\t// do dns stuff\n\t\t\tr.Header.Set(\"user\", \"nameserver\")\n\t\t\tnetworks, _ := json.Marshal([]string{ALL_NETWORK_ACCESS})\n\t\t\tr.Header.Set(\"networks\", string(networks))\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\tvar networkName = params[\"networkname\"]\n\t\tif len(networkName) == 0 {\n\t\t\tnetworkName = params[\"network\"]\n\t\t}\n\t\tnetworks, username, err := UserPermissions(reqAdmin, networkName, bearerToken)\n\t\tif err != nil {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\t\tnetworksJson, err := json.Marshal(&networks)\n\t\tif err != nil {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\t\tr.Header.Set(\"user\", username)\n\t\tr.Header.Set(\"networks\", string(networksJson))\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n\n// NetUserSecurityCheck - Check if network user has appropriate permissions\nfunc NetUserSecurityCheck(isNodes, isClients bool, next http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvar errorResponse = models.ErrorResponse{\n\t\t\tCode: http.StatusUnauthorized, Message: \"unauthorized\",\n\t\t}\n\t\tr.Header.Set(\"ismaster\", \"no\")\n\n\t\tvar params = mux.Vars(r)\n\t\tvar netUserName = params[\"networkuser\"]\n\t\tvar network = params[\"network\"]\n\n\t\tbearerToken := r.Header.Get(\"Authorization\")\n\n\t\tvar tokenSplit = strings.Split(bearerToken, \" \")\n\t\tvar authToken = \"\"\n\n\t\tif len(tokenSplit) < 2 {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t} else {\n\t\t\tauthToken = tokenSplit[1]\n\t\t}\n\n\t\tisMasterAuthenticated := authenticateMaster(authToken)\n\t\tif isMasterAuthenticated {\n\t\t\tr.Header.Set(\"user\", \"master token user\")\n\t\t\tr.Header.Set(\"ismaster\", \"yes\")\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tuserName, _, isadmin, err := VerifyUserToken(authToken)\n\t\tif err != nil {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\t\tr.Header.Set(\"user\", userName)\n\n\t\tif isadmin {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif isNodes || isClients {\n\t\t\tnecessaryAccess := pro.NET_ADMIN\n\t\t\tif isClients {\n\t\t\t\tnecessaryAccess = pro.CLIENT_ACCESS\n\t\t\t}\n\t\t\tif isNodes {\n\t\t\t\tnecessaryAccess = pro.NODE_ACCESS\n\t\t\t}\n\t\t\tu, err := pro.GetNetworkUser(network, promodels.NetworkUserID(userName))\n\t\t\tif err != nil {\n\t\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif u.AccessLevel > necessaryAccess {\n\t\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else if netUserName != userName {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n\n// UserPermissions - checks token stuff\nfunc UserPermissions(reqAdmin bool, netname string, token string) ([]string, string, error) {\n\tvar tokenSplit = strings.Split(token, \" \")\n\tvar authToken = \"\"\n\tuserNetworks := []string{}\n\n\tif len(tokenSplit) < 2 {\n\t\treturn userNetworks, \"\", Unauthorized_Err\n\t} else {\n\t\tauthToken = tokenSplit[1]\n\t}\n\t//all endpoints here require master so not as complicated\n\tif authenticateMaster(authToken) {\n\t\treturn []string{ALL_NETWORK_ACCESS}, master_uname, nil\n\t}\n\tusername, networks, isadmin, err := VerifyUserToken(authToken)\n\tif err != nil {\n\t\treturn nil, username, Unauthorized_Err\n\t}\n\tif !isadmin && reqAdmin {\n\t\treturn nil, username, Unauthorized_Err\n\t}\n\tuserNetworks = networks\n\tif isadmin {\n\t\treturn []string{ALL_NETWORK_ACCESS}, username, nil\n\t}\n\t// check network admin access\n\tif len(netname) > 0 && (len(userNetworks) == 0 || !authenticateNetworkUser(netname, userNetworks)) {\n\t\treturn nil, username, Unauthorized_Err\n\t}\n\tif isEE && len(netname) > 0 && !pro.IsUserNetAdmin(netname, username) {\n\t\treturn nil, \"\", Unauthorized_Err\n\t}\n\treturn userNetworks, username, nil\n}\n\n// Consider a more secure way of setting master key\nfunc authenticateMaster(tokenString string) bool {\n\treturn tokenString == servercfg.GetMasterKey() && servercfg.GetMasterKey() != \"\"\n}\n\nfunc authenticateNetworkUser(network string, userNetworks []string) bool {\n\tnetworkexists, err := NetworkExists(network)\n\tif (err != nil && !database.IsEmptyRecord(err)) || !networkexists {\n\t\treturn false\n\t}\n\treturn StringSliceContains(userNetworks, network)\n}\n\n// Consider a more secure way of setting master key\nfunc authenticateDNSToken(tokenString string) bool {\n\ttokens := strings.Split(tokenString, \" \")\n\tif len(tokens) < 2 {\n\t\treturn false\n\t}\n\treturn len(servercfg.GetDNSKey()) > 0 && tokens[1] == servercfg.GetDNSKey()\n}\n\nfunc ContinueIfUserMatch(next http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvar errorResponse = models.ErrorResponse{\n\t\t\tCode: http.StatusUnauthorized, Message: Unauthorized_Msg,\n\t\t}\n\t\tvar params = mux.Vars(r)\n\t\tvar requestedUser = params[\"username\"]\n\t\tif requestedUser != r.Header.Get(\"user\") {\n\t\t\tReturnErrorResponse(w, r, errorResponse)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "package servercfg\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gravitl/netmaker/config\"\n\t\"github.com/gravitl/netmaker/models\"\n)\n\n// EmqxBrokerType denotes the broker type for EMQX MQTT\nconst EmqxBrokerType = \"emqx\"\n\nvar (\n\tVersion = \"dev\"\n\tIs_EE   = false\n)\n\n// SetHost - sets the host ip\nfunc SetHost() error {\n\tremoteip, err := GetPublicIP()\n\tif err != nil {\n\t\treturn err\n\t}\n\tos.Setenv(\"SERVER_HOST\", remoteip)\n\treturn nil\n}\n\n// GetServerConfig - gets the server config into memory from file or env\nfunc GetServerConfig() config.ServerConfig {\n\tvar cfg config.ServerConfig\n\tcfg.APIConnString = GetAPIConnString()\n\tcfg.CoreDNSAddr = GetCoreDNSAddr()\n\tcfg.APIHost = GetAPIHost()\n\tcfg.APIPort = GetAPIPort()\n\tcfg.MasterKey = \"(hidden)\"\n\tcfg.DNSKey = \"(hidden)\"\n\tcfg.AllowedOrigin = GetAllowedOrigin()\n\tcfg.RestBackend = \"off\"\n\tcfg.NodeID = GetNodeID()\n\tcfg.StunPort = GetStunPort()\n\tcfg.BrokerType = GetBrokerType()\n\tcfg.EmqxRestEndpoint = GetEmqxRestEndpoint()\n\tif IsRestBackend() {\n\t\tcfg.RestBackend = \"on\"\n\t}\n\tcfg.DNSMode = \"off\"\n\tif IsDNSMode() {\n\t\tcfg.DNSMode = \"on\"\n\t}\n\tcfg.DisplayKeys = \"off\"\n\tif IsDisplayKeys() {\n\t\tcfg.DisplayKeys = \"on\"\n\t}\n\tcfg.DisableRemoteIPCheck = \"off\"\n\tif DisableRemoteIPCheck() {\n\t\tcfg.DisableRemoteIPCheck = \"on\"\n\t}\n\tcfg.Database = GetDB()\n\tcfg.Platform = GetPlatform()\n\tcfg.Version = GetVersion()\n\n\t// == auth config ==\n\tvar authInfo = GetAuthProviderInfo()\n\tcfg.AuthProvider = authInfo[0]\n\tcfg.ClientID = authInfo[1]\n\tcfg.ClientSecret = authInfo[2]\n\tcfg.FrontendURL = GetFrontendURL()\n\tcfg.Telemetry = Telemetry()\n\tcfg.Server = GetServer()\n\tcfg.StunList = GetStunListString()\n\tcfg.Verbosity = GetVerbosity()\n\tcfg.IsEE = \"no\"\n\tif Is_EE {\n\t\tcfg.IsEE = \"yes\"\n\t}\n\tcfg.DefaultProxyMode = GetDefaultProxyMode()\n\n\treturn cfg\n}\n\n// GetServerConfig - gets the server config into memory from file or env\nfunc GetServerInfo() models.ServerConfig {\n\tvar cfg models.ServerConfig\n\tcfg.Server = GetServer()\n\tcfg.MQUserName = GetMqUserName()\n\tcfg.MQPassword = GetMqPassword()\n\tcfg.API = GetAPIConnString()\n\tcfg.CoreDNSAddr = GetCoreDNSAddr()\n\tcfg.APIPort = GetAPIPort()\n\tcfg.DNSMode = \"off\"\n\tcfg.Broker = GetPublicBrokerEndpoint()\n\tif IsDNSMode() {\n\t\tcfg.DNSMode = \"on\"\n\t}\n\tcfg.Version = GetVersion()\n\tcfg.Is_EE = Is_EE\n\tcfg.StunPort = GetStunPort()\n\tcfg.StunList = GetStunList()\n\n\treturn cfg\n}\n\n// GetFrontendURL - gets the frontend url\nfunc GetFrontendURL() string {\n\tvar frontend = \"\"\n\tif os.Getenv(\"FRONTEND_URL\") != \"\" {\n\t\tfrontend = os.Getenv(\"FRONTEND_URL\")\n\t} else if config.Config.Server.FrontendURL != \"\" {\n\t\tfrontend = config.Config.Server.FrontendURL\n\t}\n\treturn frontend\n}\n\n// GetAPIConnString - gets the api connections string\nfunc GetAPIConnString() string {\n\tconn := \"\"\n\tif os.Getenv(\"SERVER_API_CONN_STRING\") != \"\" {\n\t\tconn = os.Getenv(\"SERVER_API_CONN_STRING\")\n\t} else if config.Config.Server.APIConnString != \"\" {\n\t\tconn = config.Config.Server.APIConnString\n\t}\n\treturn conn\n}\n\n// SetVersion - set version of netmaker\nfunc SetVersion(v string) {\n\tVersion = v\n}\n\n// GetVersion - version of netmaker\nfunc GetVersion() string {\n\treturn Version\n}\n\n// GetDB - gets the database type\nfunc GetDB() string {\n\tdatabase := \"sqlite\"\n\tif os.Getenv(\"DATABASE\") != \"\" {\n\t\tdatabase = os.Getenv(\"DATABASE\")\n\t} else if config.Config.Server.Database != \"\" {\n\t\tdatabase = config.Config.Server.Database\n\t}\n\treturn database\n}\n\n// GetAPIHost - gets the api host\nfunc GetAPIHost() string {\n\tserverhost := \"127.0.0.1\"\n\tremoteip, _ := GetPublicIP()\n\tif os.Getenv(\"SERVER_HTTP_HOST\") != \"\" {\n\t\tserverhost = os.Getenv(\"SERVER_HTTP_HOST\")\n\t} else if config.Config.Server.APIHost != \"\" {\n\t\tserverhost = config.Config.Server.APIHost\n\t} else if os.Getenv(\"SERVER_HOST\") != \"\" {\n\t\tserverhost = os.Getenv(\"SERVER_HOST\")\n\t} else {\n\t\tif remoteip != \"\" {\n\t\t\tserverhost = remoteip\n\t\t}\n\t}\n\treturn serverhost\n}\n\n// GetAPIPort - gets the api port\nfunc GetAPIPort() string {\n\tapiport := \"8081\"\n\tif os.Getenv(\"API_PORT\") != \"\" {\n\t\tapiport = os.Getenv(\"API_PORT\")\n\t} else if config.Config.Server.APIPort != \"\" {\n\t\tapiport = config.Config.Server.APIPort\n\t}\n\treturn apiport\n}\n\n// GetStunList - gets the stun servers\nfunc GetStunList() []models.StunServer {\n\tstunList := []models.StunServer{\n\t\tmodels.StunServer{\n\t\t\tDomain: \"stun1.netmaker.io\",\n\t\t\tPort:   3478,\n\t\t},\n\t\tmodels.StunServer{\n\t\t\tDomain: \"stun2.netmaker.io\",\n\t\t\tPort:   3478,\n\t\t},\n\t}\n\tparsed := false\n\tif os.Getenv(\"STUN_LIST\") != \"\" {\n\t\tstuns, err := parseStunList(os.Getenv(\"STUN_LIST\"))\n\t\tif err == nil {\n\t\t\tparsed = true\n\t\t\tstunList = stuns\n\t\t}\n\t}\n\tif !parsed && config.Config.Server.StunList != \"\" {\n\t\tstuns, err := parseStunList(config.Config.Server.StunList)\n\t\tif err == nil {\n\t\t\tstunList = stuns\n\t\t}\n\t}\n\treturn stunList\n}\n\n// GetStunList - gets the stun servers w/o parsing to struct\nfunc GetStunListString() string {\n\tstunList := \"stun1.netmaker.io:3478,stun2.netmaker.io:3478\"\n\tif os.Getenv(\"STUN_LIST\") != \"\" {\n\t\tstunList = os.Getenv(\"STUN_LIST\")\n\t} else if config.Config.Server.StunList != \"\" {\n\t\tstunList = config.Config.Server.StunList\n\t}\n\treturn stunList\n}\n\n// GetCoreDNSAddr - gets the core dns address\nfunc GetCoreDNSAddr() string {\n\taddr, _ := GetPublicIP()\n\tif os.Getenv(\"COREDNS_ADDR\") != \"\" {\n\t\taddr = os.Getenv(\"COREDNS_ADDR\")\n\t} else if config.Config.Server.CoreDNSAddr != \"\" {\n\t\taddr = config.Config.Server.CoreDNSAddr\n\t}\n\treturn addr\n}\n\n// GetPublicBrokerEndpoint - returns the public broker endpoint which shall be used by netclient\nfunc GetPublicBrokerEndpoint() string {\n\tif os.Getenv(\"BROKER_ENDPOINT\") != \"\" {\n\t\treturn os.Getenv(\"BROKER_ENDPOINT\")\n\t} else {\n\t\treturn config.Config.Server.Broker\n\t}\n}\n\n// GetMessageQueueEndpoint - gets the message queue endpoint\nfunc GetMessageQueueEndpoint() (string, bool) {\n\thost, _ := GetPublicIP()\n\tif os.Getenv(\"SERVER_BROKER_ENDPOINT\") != \"\" {\n\t\thost = os.Getenv(\"SERVER_BROKER_ENDPOINT\")\n\t} else if config.Config.Server.ServerBrokerEndpoint != \"\" {\n\t\thost = config.Config.Server.ServerBrokerEndpoint\n\t} else if os.Getenv(\"BROKER_ENDPOINT\") != \"\" {\n\t\thost = os.Getenv(\"BROKER_ENDPOINT\")\n\t} else if config.Config.Server.Broker != \"\" {\n\t\thost = config.Config.Server.Broker\n\t} else {\n\t\thost += \":1883\" // default\n\t}\n\treturn host, strings.Contains(host, \"wss\") || strings.Contains(host, \"ssl\") || strings.Contains(host, \"mqtts\")\n}\n\n// GetBrokerType - returns the type of MQ broker\nfunc GetBrokerType() string {\n\tif os.Getenv(\"BROKER_TYPE\") != \"\" {\n\t\treturn os.Getenv(\"BROKER_TYPE\")\n\t} else {\n\t\treturn \"mosquitto\"\n\t}\n}\n\n// GetMasterKey - gets the configured master key of server\nfunc GetMasterKey() string {\n\tkey := \"\"\n\tif os.Getenv(\"MASTER_KEY\") != \"\" {\n\t\tkey = os.Getenv(\"MASTER_KEY\")\n\t} else if config.Config.Server.MasterKey != \"\" {\n\t\tkey = config.Config.Server.MasterKey\n\t}\n\treturn key\n}\n\n// GetDNSKey - gets the configured dns key of server\nfunc GetDNSKey() string {\n\tkey := \"\"\n\tif os.Getenv(\"DNS_KEY\") != \"\" {\n\t\tkey = os.Getenv(\"DNS_KEY\")\n\t} else if config.Config.Server.DNSKey != \"\" {\n\t\tkey = config.Config.Server.DNSKey\n\t}\n\treturn key\n}\n\n// GetAllowedOrigin - get the allowed origin\nfunc GetAllowedOrigin() string {\n\tallowedorigin := \"*\"\n\tif os.Getenv(\"CORS_ALLOWED_ORIGIN\") != \"\" {\n\t\tallowedorigin = os.Getenv(\"CORS_ALLOWED_ORIGIN\")\n\t} else if config.Config.Server.AllowedOrigin != \"\" {\n\t\tallowedorigin = config.Config.Server.AllowedOrigin\n\t}\n\treturn allowedorigin\n}\n\n// IsRestBackend - checks if rest is on or off\nfunc IsRestBackend() bool {\n\tisrest := true\n\tif os.Getenv(\"REST_BACKEND\") != \"\" {\n\t\tif os.Getenv(\"REST_BACKEND\") == \"off\" {\n\t\t\tisrest = false\n\t\t}\n\t} else if config.Config.Server.RestBackend != \"\" {\n\t\tif config.Config.Server.RestBackend == \"off\" {\n\t\t\tisrest = false\n\t\t}\n\t}\n\treturn isrest\n}\n\n// IsMetricsExporter - checks if metrics exporter is on or off\nfunc IsMetricsExporter() bool {\n\texport := false\n\tif os.Getenv(\"METRICS_EXPORTER\") != \"\" {\n\t\tif os.Getenv(\"METRICS_EXPORTER\") == \"on\" {\n\t\t\texport = true\n\t\t}\n\t} else if config.Config.Server.MetricsExporter != \"\" {\n\t\tif config.Config.Server.MetricsExporter == \"on\" {\n\t\t\texport = true\n\t\t}\n\t}\n\treturn export\n}\n\n// IsMessageQueueBackend - checks if message queue is on or off\nfunc IsMessageQueueBackend() bool {\n\tismessagequeue := true\n\tif os.Getenv(\"MESSAGEQUEUE_BACKEND\") != \"\" {\n\t\tif os.Getenv(\"MESSAGEQUEUE_BACKEND\") == \"off\" {\n\t\t\tismessagequeue = false\n\t\t}\n\t} else if config.Config.Server.MessageQueueBackend != \"\" {\n\t\tif config.Config.Server.MessageQueueBackend == \"off\" {\n\t\t\tismessagequeue = false\n\t\t}\n\t}\n\treturn ismessagequeue\n}\n\n// Telemetry - checks if telemetry data should be sent\nfunc Telemetry() string {\n\ttelemetry := \"on\"\n\tif os.Getenv(\"TELEMETRY\") == \"off\" {\n\t\ttelemetry = \"off\"\n\t}\n\tif config.Config.Server.Telemetry == \"off\" {\n\t\ttelemetry = \"off\"\n\t}\n\treturn telemetry\n}\n\n// GetServer - gets the server name\nfunc GetServer() string {\n\tserver := \"\"\n\tif os.Getenv(\"SERVER_NAME\") != \"\" {\n\t\tserver = os.Getenv(\"SERVER_NAME\")\n\t} else if config.Config.Server.Server != \"\" {\n\t\tserver = config.Config.Server.Server\n\t}\n\treturn server\n}\n\nfunc GetVerbosity() int32 {\n\tvar verbosity = 0\n\tvar err error\n\tif os.Getenv(\"VERBOSITY\") != \"\" {\n\t\tverbosity, err = strconv.Atoi(os.Getenv(\"VERBOSITY\"))\n\t\tif err != nil {\n\t\t\tverbosity = 0\n\t\t}\n\t} else if config.Config.Server.Verbosity != 0 {\n\t\tverbosity = int(config.Config.Server.Verbosity)\n\t}\n\tif verbosity < 0 || verbosity > 4 {\n\t\tverbosity = 0\n\t}\n\treturn int32(verbosity)\n}\n\n// IsDNSMode - should it run with DNS\nfunc IsDNSMode() bool {\n\tisdns := true\n\tif os.Getenv(\"DNS_MODE\") != \"\" {\n\t\tif os.Getenv(\"DNS_MODE\") == \"off\" {\n\t\t\tisdns = false\n\t\t}\n\t} else if config.Config.Server.DNSMode != \"\" {\n\t\tif config.Config.Server.DNSMode == \"off\" {\n\t\t\tisdns = false\n\t\t}\n\t}\n\treturn isdns\n}\n\n// IsDisplayKeys - should server be able to display keys?\nfunc IsDisplayKeys() bool {\n\tisdisplay := true\n\tif os.Getenv(\"DISPLAY_KEYS\") != \"\" {\n\t\tif os.Getenv(\"DISPLAY_KEYS\") == \"off\" {\n\t\t\tisdisplay = false\n\t\t}\n\t} else if config.Config.Server.DisplayKeys != \"\" {\n\t\tif config.Config.Server.DisplayKeys == \"off\" {\n\t\t\tisdisplay = false\n\t\t}\n\t}\n\treturn isdisplay\n}\n\n// DisableRemoteIPCheck - disable the remote ip check\nfunc DisableRemoteIPCheck() bool {\n\tdisabled := false\n\tif os.Getenv(\"DISABLE_REMOTE_IP_CHECK\") != \"\" {\n\t\tif os.Getenv(\"DISABLE_REMOTE_IP_CHECK\") == \"on\" {\n\t\t\tdisabled = true\n\t\t}\n\t} else if config.Config.Server.DisableRemoteIPCheck != \"\" {\n\t\tif config.Config.Server.DisableRemoteIPCheck == \"on\" {\n\t\t\tdisabled = true\n\t\t}\n\t}\n\treturn disabled\n}\n\n// GetPublicIP - gets public ip\nfunc GetPublicIP() (string, error) {\n\n\tendpoint := \"\"\n\tvar err error\n\n\tiplist := []string{\"https://ip.server.gravitl.com\", \"https://ifconfig.me\", \"https://api.ipify.org\", \"https://ipinfo.io/ip\"}\n\tpublicIpService := os.Getenv(\"PUBLIC_IP_SERVICE\")\n\tif publicIpService != \"\" {\n\t\t// prepend the user-specified service so it's checked first\n\t\tiplist = append([]string{publicIpService}, iplist...)\n\t} else if config.Config.Server.PublicIPService != \"\" {\n\t\tpublicIpService = config.Config.Server.PublicIPService\n\n\t\t// prepend the user-specified service so it's checked first\n\t\tiplist = append([]string{publicIpService}, iplist...)\n\t}\n\n\tfor _, ipserver := range iplist {\n\t\tclient := &http.Client{\n\t\t\tTimeout: time.Second * 10,\n\t\t}\n\t\tresp, err := client.Get(ipserver)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tif resp.StatusCode == http.StatusOK {\n\t\t\tbodyBytes, err := io.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tendpoint = string(bodyBytes)\n\t\t\tbreak\n\t\t}\n\t}\n\tif err == nil && endpoint == \"\" {\n\t\terr = errors.New(\"public address not found\")\n\t}\n\treturn endpoint, err\n}\n\n// GetPlatform - get the system type of server\nfunc GetPlatform() string {\n\tplatform := \"linux\"\n\tif os.Getenv(\"PLATFORM\") != \"\" {\n\t\tplatform = os.Getenv(\"PLATFORM\")\n\t} else if config.Config.Server.Platform != \"\" {\n\t\tplatform = config.Config.Server.Platform\n\t}\n\treturn platform\n}\n\n// GetSQLConn - get the sql connection string\nfunc GetSQLConn() string {\n\tsqlconn := \"http://\"\n\tif os.Getenv(\"SQL_CONN\") != \"\" {\n\t\tsqlconn = os.Getenv(\"SQL_CONN\")\n\t} else if config.Config.Server.SQLConn != \"\" {\n\t\tsqlconn = config.Config.Server.SQLConn\n\t}\n\treturn sqlconn\n}\n\n// GetNodeID - gets the node id\nfunc GetNodeID() string {\n\tvar id string\n\tvar err error\n\t// id = getMacAddr()\n\tif os.Getenv(\"NODE_ID\") != \"\" {\n\t\tid = os.Getenv(\"NODE_ID\")\n\t} else if config.Config.Server.NodeID != \"\" {\n\t\tid = config.Config.Server.NodeID\n\t} else {\n\t\tid, err = os.Hostname()\n\t\tif err != nil {\n\t\t\treturn \"\"\n\t\t}\n\t}\n\treturn id\n}\n\nfunc SetNodeID(id string) {\n\tconfig.Config.Server.NodeID = id\n}\n\n// GetAuthProviderInfo = gets the oauth provider info\nfunc GetAuthProviderInfo() (pi []string) {\n\tvar authProvider = \"\"\n\n\tdefer func() {\n\t\tif authProvider == \"oidc\" {\n\t\t\tif os.Getenv(\"OIDC_ISSUER\") != \"\" {\n\t\t\t\tpi = append(pi, os.Getenv(\"OIDC_ISSUER\"))\n\t\t\t} else if config.Config.Server.OIDCIssuer != \"\" {\n\t\t\t\tpi = append(pi, config.Config.Server.OIDCIssuer)\n\t\t\t} else {\n\t\t\t\tpi = []string{\"\", \"\", \"\"}\n\t\t\t}\n\t\t}\n\t}()\n\n\tif os.Getenv(\"AUTH_PROVIDER\") != \"\" && os.Getenv(\"CLIENT_ID\") != \"\" && os.Getenv(\"CLIENT_SECRET\") != \"\" {\n\t\tauthProvider = strings.ToLower(os.Getenv(\"AUTH_PROVIDER\"))\n\t\tif authProvider == \"google\" || authProvider == \"azure-ad\" || authProvider == \"github\" || authProvider == \"oidc\" {\n\t\t\treturn []string{authProvider, os.Getenv(\"CLIENT_ID\"), os.Getenv(\"CLIENT_SECRET\")}\n\t\t} else {\n\t\t\tauthProvider = \"\"\n\t\t}\n\t} else if config.Config.Server.AuthProvider != \"\" && config.Config.Server.ClientID != \"\" && config.Config.Server.ClientSecret != \"\" {\n\t\tauthProvider = strings.ToLower(config.Config.Server.AuthProvider)\n\t\tif authProvider == \"google\" || authProvider == \"azure-ad\" || authProvider == \"github\" || authProvider == \"oidc\" {\n\t\t\treturn []string{authProvider, config.Config.Server.ClientID, config.Config.Server.ClientSecret}\n\t\t}\n\t}\n\treturn []string{\"\", \"\", \"\"}\n}\n\n// GetAzureTenant - retrieve the azure tenant ID from env variable or config file\nfunc GetAzureTenant() string {\n\tvar azureTenant = \"\"\n\tif os.Getenv(\"AZURE_TENANT\") != \"\" {\n\t\tazureTenant = os.Getenv(\"AZURE_TENANT\")\n\t} else if config.Config.Server.AzureTenant != \"\" {\n\t\tazureTenant = config.Config.Server.AzureTenant\n\t}\n\treturn azureTenant\n}\n\n// GetMqPassword - fetches the MQ password\nfunc GetMqPassword() string {\n\tpassword := \"\"\n\tif os.Getenv(\"MQ_PASSWORD\") != \"\" {\n\t\tpassword = os.Getenv(\"MQ_PASSWORD\")\n\t} else if config.Config.Server.MQPassword != \"\" {\n\t\tpassword = config.Config.Server.MQPassword\n\t}\n\treturn password\n}\n\n// GetMqUserName - fetches the MQ username\nfunc GetMqUserName() string {\n\tpassword := \"\"\n\tif os.Getenv(\"MQ_USERNAME\") != \"\" {\n\t\tpassword = os.Getenv(\"MQ_USERNAME\")\n\t} else if config.Config.Server.MQUserName != \"\" {\n\t\tpassword = config.Config.Server.MQUserName\n\t}\n\treturn password\n}\n\n// GetEmqxRestEndpoint - returns the REST API Endpoint of EMQX\nfunc GetEmqxRestEndpoint() string {\n\treturn os.Getenv(\"EMQX_REST_ENDPOINT\")\n}\n\n// IsBasicAuthEnabled - checks if basic auth has been configured to be turned off\nfunc IsBasicAuthEnabled() bool {\n\tvar enabled = true //default\n\tif os.Getenv(\"BASIC_AUTH\") != \"\" {\n\t\tenabled = os.Getenv(\"BASIC_AUTH\") == \"yes\"\n\t} else if config.Config.Server.BasicAuth != \"\" {\n\t\tenabled = config.Config.Server.BasicAuth == \"yes\"\n\t}\n\treturn enabled\n}\n\n// GetLicenseKey - retrieves pro license value from env or conf files\nfunc GetLicenseKey() string {\n\tlicenseKeyValue := os.Getenv(\"LICENSE_KEY\")\n\tif licenseKeyValue == \"\" {\n\t\tlicenseKeyValue = config.Config.Server.LicenseValue\n\t}\n\treturn licenseKeyValue\n}\n\n// GetNetmakerAccountID - get's the associated, Netmaker, account ID to verify ownership\nfunc GetNetmakerAccountID() string {\n\tnetmakerAccountID := os.Getenv(\"NETMAKER_ACCOUNT_ID\")\n\tif netmakerAccountID == \"\" {\n\t\tnetmakerAccountID = config.Config.Server.NetmakerAccountID\n\t}\n\treturn netmakerAccountID\n}\n\n// GetStunPort - Get the port to run the stun server on\nfunc GetStunPort() int {\n\tport := 3478 //default\n\tif os.Getenv(\"STUN_PORT\") != \"\" {\n\t\tportInt, err := strconv.Atoi(os.Getenv(\"STUN_PORT\"))\n\t\tif err == nil {\n\t\t\tport = portInt\n\t\t}\n\t} else if config.Config.Server.StunPort != 0 {\n\t\tport = config.Config.Server.StunPort\n\t}\n\treturn port\n}\n\n// IsProxyEnabled - is proxy on or off\nfunc IsProxyEnabled() bool {\n\tvar enabled = false //default\n\tif os.Getenv(\"PROXY\") != \"\" {\n\t\tenabled = os.Getenv(\"PROXY\") == \"on\"\n\t} else if config.Config.Server.Proxy != \"\" {\n\t\tenabled = config.Config.Server.Proxy == \"on\"\n\t}\n\treturn enabled\n}\n\n// GetDefaultProxyMode - default proxy mode for a server\nfunc GetDefaultProxyMode() config.ProxyMode {\n\tvar (\n\t\tmode config.ProxyMode\n\t\tdef  string\n\t)\n\tif os.Getenv(\"DEFAULT_PROXY_MODE\") != \"\" {\n\t\tdef = os.Getenv(\"DEFAULT_PROXY_MODE\")\n\t} else if config.Config.Server.DefaultProxyMode.Set {\n\t\treturn config.Config.Server.DefaultProxyMode\n\t}\n\tswitch strings.ToUpper(def) {\n\tcase \"ON\":\n\t\tmode.Set = true\n\t\tmode.Value = true\n\tcase \"OFF\":\n\t\tmode.Set = true\n\t\tmode.Value = false\n\t// AUTO or any other value\n\tdefault:\n\t\tmode.Set = false\n\t}\n\treturn mode\n\n}\n\n// parseStunList - turn string into slice of StunServers\nfunc parseStunList(stunString string) ([]models.StunServer, error) {\n\tvar err error\n\tstunServers := []models.StunServer{}\n\tstuns := strings.Split(stunString, \",\")\n\tif len(stuns) == 0 {\n\t\treturn stunServers, errors.New(\"no stun servers provided\")\n\t}\n\tfor _, stun := range stuns {\n\t\tstun = strings.Trim(stun, \" \")\n\t\tstunInfo := strings.Split(stun, \":\")\n\t\tif len(stunInfo) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tport, err := strconv.Atoi(stunInfo[1])\n\t\tif err != nil || port == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tstunServers = append(stunServers, models.StunServer{\n\t\t\tDomain: stunInfo[0],\n\t\t\tPort:   port,\n\t\t})\n\n\t}\n\tif len(stunServers) == 0 {\n\t\terr = errors.New(\"no stun entries parsable\")\n\t}\n\treturn stunServers, err\n}\n"], "filenames": ["logic/security.go", "servercfg/serverconf.go"], "buggy_code_start_loc": [190, 280], "buggy_code_end_loc": [191, 281], "fixing_code_start_loc": [190, 280], "fixing_code_end_loc": [191, 281], "type": "CWE-798", "message": "Netmaker makes networks with WireGuard. Prior to versions 0.17.1 and 0.18.6, hardcoded DNS key usage has been found in Netmaker allowing unauth users to interact with DNS API endpoints. The issue is patched in 0.17.1 and fixed in 0.18.6.  If users are using 0.17.1, they should run `docker pull gravitl/netmaker:v0.17.1` and `docker-compose up -d`. This will switch them to the patched users. If users are using v0.18.0-0.18.5, they should upgrade to v0.18.6 or later. As a workaround, someone who is using version 0.17.1 can pull the latest docker image of the backend and restart the server.", "other": {"cve": {"id": "CVE-2023-32077", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-24T22:15:08.077", "lastModified": "2023-08-30T18:18:07.060", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netmaker makes networks with WireGuard. Prior to versions 0.17.1 and 0.18.6, hardcoded DNS key usage has been found in Netmaker allowing unauth users to interact with DNS API endpoints. The issue is patched in 0.17.1 and fixed in 0.18.6.  If users are using 0.17.1, they should run `docker pull gravitl/netmaker:v0.17.1` and `docker-compose up -d`. This will switch them to the patched users. If users are using v0.18.0-0.18.5, they should upgrade to v0.18.6 or later. As a workaround, someone who is using version 0.17.1 can pull the latest docker image of the backend and restart the server."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-798"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gravitl:netmaker:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.17.1", "matchCriteriaId": "D271FC17-56AA-4851-846B-D7D174EBFB45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gravitl:netmaker:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.18.0", "versionEndIncluding": "0.18.5", "matchCriteriaId": "249015D8-1590-4B85-A3F7-6F5F360CF0AD"}]}]}], "references": [{"url": "https://github.com/gravitl/netmaker/commit/1621c27c1d176b639e9768b2acad7693e387fd51", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/gravitl/netmaker/commit/9362c39a9a822f0e07361aa7c77af2610597e657", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/gravitl/netmaker/pull/2170", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/gravitl/netmaker/security/advisories/GHSA-8x8h-hcq8-jwwx", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gravitl/netmaker/commit/1621c27c1d176b639e9768b2acad7693e387fd51"}}