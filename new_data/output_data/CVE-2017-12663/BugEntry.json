{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            M   M   AAA   PPPP                               %\n%                            MM MM  A   A  P   P                              %\n%                            M M M  AAAAA  PPPP                               %\n%                            M   M  A   A  P                                  %\n%                            M   M  A   A  P                                  %\n%                                                                             %\n%                                                                             %\n%                  Read/Write Image Colormaps As An Image File.               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteMAPImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A P I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMAPImage() reads an image of raw RGB colormap and colormap index\n%  bytes and returns it.  It allocates the memory necessary for the new Image\n%  structure and returns a pointer to the new image.\n%\n%  The format of the ReadMAPImage method is:\n%\n%      Image *ReadMAPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMAPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    depth,\n    packet_size,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *colormap,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize image structure.\n  */\n  image->storage_class=PseudoClass;\n  status=AcquireImageColormap(image,(size_t)\n    (image->offset != 0 ? image->offset : 256),exception);\n  if (status == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  depth=GetImageQuantumDepth(image,MagickTrue);\n  packet_size=(size_t) (depth/8);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*pixels));\n  packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);\n  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*\n    sizeof(*colormap));\n  if ((pixels == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Read image colormap.\n  */\n  count=ReadBlob(image,packet_size*image->colors,colormap);\n  if (count != (ssize_t) (packet_size*image->colors))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  p=colormap;\n  if (image->depth <= 8)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n  else\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      quantum=(*p++ << 8);\n      quantum|=(*p++);\n      image->colormap[i].red=(Quantum) quantum;\n      quantum=(*p++ << 8);\n      quantum|=(*p++);\n      image->colormap[i].green=(Quantum) quantum;\n      quantum=(*p++ << 8);\n      quantum|=(*p++);\n      image->colormap[i].blue=(Quantum) quantum;\n    }\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read image pixels.\n  */\n  packet_size=(size_t) (depth/8);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    count=ReadBlob(image,(size_t) packet_size*image->columns,pixels);\n    if (count != (ssize_t) (packet_size*image->columns))\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      index=ConstrainColormapIndex(image,*p,exception);\n      p++;\n      if (image->colors > 256)\n        {\n          index=ConstrainColormapIndex(image,((size_t) index << 8)+(*p),\n            exception);\n          p++;\n        }\n      SetPixelIndex(image,index,q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (y < (ssize_t) image->rows)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M A P I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMAPImage() adds attributes for the MAP image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMAPImage method is:\n%\n%      size_t RegisterMAPImage(void)\n%\n*/\nModuleExport size_t RegisterMAPImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MAP\",\"MAP\",\"Colormap intensities and indices\");\n  entry->decoder=(DecodeImageHandler *) ReadMAPImage;\n  entry->encoder=(EncodeImageHandler *) WriteMAPImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->format_type=ExplicitFormatType;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M A P I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMAPImage() removes format registrations made by the\n%  MAP module from the list of supported formats.\n%\n%  The format of the UnregisterMAPImage method is:\n%\n%      UnregisterMAPImage(void)\n%\n*/\nModuleExport void UnregisterMAPImage(void)\n{\n  (void) UnregisterMagickInfo(\"MAP\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M A P I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMAPImage() writes an image to a file as red, green, and blue\n%  colormap bytes followed by the colormap indexes.\n%\n%  The format of the WriteMAPImage method is:\n%\n%      MagickBooleanType WriteMAPImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    depth,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Allocate colormap.\n  */\n  if (IsPaletteImage(image) == MagickFalse)\n    (void) SetImageType(image,PaletteType,exception);\n  depth=GetImageQuantumDepth(image,MagickTrue);\n  packet_size=(size_t) (depth/8);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*pixels));\n  packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);\n  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*\n    sizeof(*colormap));\n  if ((pixels == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Write colormap to file.\n  */\n  q=colormap;\n  q=colormap;\n  if (image->colors <= 256)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n    }\n  else\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) & 0xff);;\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) & 0xff);\n    }\n  (void) WriteBlob(image,packet_size*image->colors,colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  /*\n    Write image pixels to file.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    q=pixels;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->colors > 256)\n        *q++=(unsigned char) ((size_t) GetPixelIndex(image,p) >> 8);\n      *q++=(unsigned char) GetPixelIndex(image,p);\n      p+=GetPixelChannels(image);\n    }\n    (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            M   M   AAA   PPPP                               %\n%                            MM MM  A   A  P   P                              %\n%                            M M M  AAAAA  PPPP                               %\n%                            M   M  A   A  P                                  %\n%                            M   M  A   A  P                                  %\n%                                                                             %\n%                                                                             %\n%                  Read/Write Image Colormaps As An Image File.               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteMAPImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A P I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMAPImage() reads an image of raw RGB colormap and colormap index\n%  bytes and returns it.  It allocates the memory necessary for the new Image\n%  structure and returns a pointer to the new image.\n%\n%  The format of the ReadMAPImage method is:\n%\n%      Image *ReadMAPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMAPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    depth,\n    packet_size,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *colormap,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize image structure.\n  */\n  image->storage_class=PseudoClass;\n  status=AcquireImageColormap(image,(size_t)\n    (image->offset != 0 ? image->offset : 256),exception);\n  if (status == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  depth=GetImageQuantumDepth(image,MagickTrue);\n  packet_size=(size_t) (depth/8);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*pixels));\n  packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);\n  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*\n    sizeof(*colormap));\n  if ((pixels == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Read image colormap.\n  */\n  count=ReadBlob(image,packet_size*image->colors,colormap);\n  if (count != (ssize_t) (packet_size*image->colors))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  p=colormap;\n  if (image->depth <= 8)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n  else\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      quantum=(*p++ << 8);\n      quantum|=(*p++);\n      image->colormap[i].red=(Quantum) quantum;\n      quantum=(*p++ << 8);\n      quantum|=(*p++);\n      image->colormap[i].green=(Quantum) quantum;\n      quantum=(*p++ << 8);\n      quantum|=(*p++);\n      image->colormap[i].blue=(Quantum) quantum;\n    }\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read image pixels.\n  */\n  packet_size=(size_t) (depth/8);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    count=ReadBlob(image,(size_t) packet_size*image->columns,pixels);\n    if (count != (ssize_t) (packet_size*image->columns))\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      index=ConstrainColormapIndex(image,*p,exception);\n      p++;\n      if (image->colors > 256)\n        {\n          index=ConstrainColormapIndex(image,((size_t) index << 8)+(*p),\n            exception);\n          p++;\n        }\n      SetPixelIndex(image,index,q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (y < (ssize_t) image->rows)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M A P I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMAPImage() adds attributes for the MAP image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMAPImage method is:\n%\n%      size_t RegisterMAPImage(void)\n%\n*/\nModuleExport size_t RegisterMAPImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"MAP\",\"MAP\",\"Colormap intensities and indices\");\n  entry->decoder=(DecodeImageHandler *) ReadMAPImage;\n  entry->encoder=(EncodeImageHandler *) WriteMAPImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->format_type=ExplicitFormatType;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M A P I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMAPImage() removes format registrations made by the\n%  MAP module from the list of supported formats.\n%\n%  The format of the UnregisterMAPImage method is:\n%\n%      UnregisterMAPImage(void)\n%\n*/\nModuleExport void UnregisterMAPImage(void)\n{\n  (void) UnregisterMagickInfo(\"MAP\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M A P I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMAPImage() writes an image to a file as red, green, and blue\n%  colormap bytes followed by the colormap indexes.\n%\n%  The format of the WriteMAPImage method is:\n%\n%      MagickBooleanType WriteMAPImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    depth,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Allocate colormap.\n  */\n  if (IsPaletteImage(image) == MagickFalse)\n    (void) SetImageType(image,PaletteType,exception);\n  depth=GetImageQuantumDepth(image,MagickTrue);\n  packet_size=(size_t) (depth/8);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*pixels));\n  packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);\n  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*\n    sizeof(*colormap));\n  if ((pixels == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    {\n      if (colormap != (unsigned char *) NULL)\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      if (pixels != (unsigned char *) NULL)\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Write colormap to file.\n  */\n  q=colormap;\n  if (image->colors <= 256)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n    }\n  else\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &\n        0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &\n        0xff);\n    }\n  (void) WriteBlob(image,packet_size*image->colors,colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  /*\n    Write image pixels to file.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    q=pixels;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->colors > 256)\n        *q++=(unsigned char) ((size_t) GetPixelIndex(image,p) >> 8);\n      *q++=(unsigned char) GetPixelIndex(image,p);\n      p+=GetPixelChannels(image);\n    }\n    (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/map.c"], "buggy_code_start_loc": [400], "buggy_code_end_loc": [422], "fixing_code_start_loc": [400], "fixing_code_end_loc": [429], "type": "CWE-772", "message": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteMAPImage in coders/map.c.", "other": {"cve": {"id": "CVE-2017-12663", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-07T21:29:00.237", "lastModified": "2020-10-14T18:34:37.690", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteMAPImage in coders/map.c."}, {"lang": "es", "value": "ImageMagick 7.0.6-2 tiene una vulnerabilidad de filtrado de memoria en WriteMAPImage en coders/map.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-2:*:*:*:*:*:*:*", "matchCriteriaId": "7E47D35D-B2EB-4957-A0C8-7DE54233997F"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/1dc0ac5016f1c4d50b100a086526d6a2453a5444", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/573", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/1dc0ac5016f1c4d50b100a086526d6a2453a5444"}}