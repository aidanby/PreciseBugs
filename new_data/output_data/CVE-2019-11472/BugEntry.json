{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X  W   W  DDDD                               %\n%                             X X   W   W  D   D                              %\n%                              X    W   W  D   D                              %\n%                             X X   W W W  D   D                              %\n%                            X   X   W W   DDDD                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write X Windows System Window Dump Format               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n#if defined(MAGICKCORE_X11_DELEGATE)\n#include \"magick/xwindow-private.h\"\n#if !defined(vms)\n#include <X11/XWDFile.h>\n#else\n#include \"XWDFile.h\"\n#endif\n#endif\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_X11_DELEGATE)\nstatic MagickBooleanType\n  WriteXWDImage(const ImageInfo *,Image *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X W D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXWD() returns MagickTrue if the image format type, identified by the\n%  magick string, is XWD.\n%\n%  The format of the IsXWD method is:\n%\n%      MagickBooleanType IsXWD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsXWD(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick+1,\"\\000\\000\",2) == 0)\n    {\n      if (memcmp(magick+4,\"\\007\\000\\000\",3) == 0)\n        return(MagickTrue);\n      if (memcmp(magick+5,\"\\000\\000\\007\",3) == 0)\n        return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_X11_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X W D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXWDImage() reads an X Window System window dump image file and\n%  returns it.  It allocates the memory necessary for the new Image structure\n%  and returns a pointer to the new image.\n%\n%  The format of the ReadXWDImage method is:\n%\n%      Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n    ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n  if (header.header_size < sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((header.bits_per_pixel == 0) || (header.bits_per_pixel > 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (header.bitmap_unit > 32)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (header.ncolors > 256)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  switch (header.visual_class)\n  {\n    case StaticGray:\n    case GrayScale:\n    case StaticColor:\n    case PseudoColor:\n    case TrueColor:\n    case DirectColor:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.pixmap_format)\n  {\n    case XYBitmap:\n    case XYPixmap:\n    case ZPixmap:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  length=(size_t) (header.header_size-sz_XWDheader);\n  if ((length+1) != ((size_t) ((CARD32) (length+1))))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) || \n      (ximage->format < 0) || (ximage->byte_order < 0) ||\n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n      XWDColor\n        color;\n\n      length=(size_t) header.ncolors;\n      if (length > ((~0UL)/sizeof(*colors)))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n          authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                red_shift) & red_mask);\n              SetPixelRed(q,ScaleShortToQuantum(colors[(ssize_t) index].red));\n              index=ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                green_shift) & green_mask);\n              SetPixelGreen(q,ScaleShortToQuantum(colors[(ssize_t)\n                index].green));\n              index=ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                blue_shift) & blue_mask);\n              SetPixelBlue(q,ScaleShortToQuantum(colors[(ssize_t) index].blue));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short) color));\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short) color));\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short) color));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleShortToQuantum(colors[i].red);\n          image->colormap[i].green=ScaleShortToQuantum(colors[i].green);\n          image->colormap[i].blue=ScaleShortToQuantum(colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,(ssize_t) XGetPixel(ximage,(int)\n              x,(int) y));\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X W D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXWDImage() adds properties for the XWD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXWDImage method is:\n%\n%      size_t RegisterXWDImage(void)\n%\n*/\nModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"XWD\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"X Windows system window dump (color)\");\n  entry->module=ConstantString(\"XWD\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X W D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXWDImage() removes format registrations made by the\n%  XWD module from the list of supported formats.\n%\n%  The format of the UnregisterXWDImage method is:\n%\n%      UnregisterXWDImage(void)\n%\n*/\nModuleExport void UnregisterXWDImage(void)\n{\n  (void) UnregisterMagickInfo(\"XWD\");\n}\n\f\n#if defined(MAGICKCORE_X11_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e X W D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteXWDImage() writes an image to a file in X window dump\n%  rasterfile format.\n%\n%  The format of the WriteXWDImage method is:\n%\n%      MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    bytes_per_line,\n    length,\n    scanline_pad;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  XWDFileHeader\n    xwd_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns != (CARD32) image->columns) ||\n      (image->rows != (CARD32) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  if ((image->storage_class == PseudoClass) && (image->colors > 256))\n    (void) SetImageType(image,TrueColorType);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Initialize XWD file header.\n  */\n  (void) memset(&xwd_info,0,sizeof(xwd_info));\n  xwd_info.header_size=(CARD32) sz_XWDheader;\n  value=GetImageProperty(image,\"comment\");\n  if (value != (const char *) NULL)\n    xwd_info.header_size+=(CARD32) strlen(value);\n  xwd_info.header_size++;\n  xwd_info.file_version=(CARD32) XWD_FILE_VERSION;\n  xwd_info.pixmap_format=(CARD32) ZPixmap;\n  xwd_info.pixmap_depth=(CARD32) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.pixmap_width=(CARD32) image->columns;\n  xwd_info.pixmap_height=(CARD32) image->rows;\n  xwd_info.xoffset=(CARD32) 0;\n  xwd_info.byte_order=(CARD32) MSBFirst;\n  xwd_info.bitmap_unit=(CARD32) (image->storage_class == DirectClass ? 32 : 8);\n  xwd_info.bitmap_bit_order=(CARD32) MSBFirst;\n  xwd_info.bitmap_pad=(CARD32) (image->storage_class == DirectClass ? 32 : 8);\n  bits_per_pixel=(size_t) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.bits_per_pixel=(CARD32) bits_per_pixel;\n  bytes_per_line=(CARD32) ((((xwd_info.bits_per_pixel*\n    xwd_info.pixmap_width)+((xwd_info.bitmap_pad)-1))/\n    (xwd_info.bitmap_pad))*((xwd_info.bitmap_pad) >> 3));\n  xwd_info.bytes_per_line=(CARD32) bytes_per_line;\n  xwd_info.visual_class=(CARD32)\n    (image->storage_class == DirectClass ? DirectColor : PseudoColor);\n  xwd_info.red_mask=(CARD32)\n    (image->storage_class == DirectClass ? 0xff0000 : 0);\n  xwd_info.green_mask=(CARD32)\n    (image->storage_class == DirectClass ? 0xff00 : 0);\n  xwd_info.blue_mask=(CARD32) (image->storage_class == DirectClass ? 0xff : 0);\n  xwd_info.bits_per_rgb=(CARD32) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.colormap_entries=(CARD32)\n    (image->storage_class == DirectClass ? 256 : image->colors);\n  xwd_info.ncolors=(unsigned int)\n    (image->storage_class == DirectClass ? 0 : image->colors);\n  xwd_info.window_width=(CARD32) image->columns;\n  xwd_info.window_height=(CARD32) image->rows;\n  xwd_info.window_x=0;\n  xwd_info.window_y=0;\n  xwd_info.window_bdrwidth=(CARD32) 0;\n  /*\n    Write XWD header.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &xwd_info,sizeof(xwd_info));\n  (void) WriteBlob(image,sz_XWDheader,(unsigned char *) &xwd_info);\n  if (value != (const char *) NULL)\n    (void) WriteBlob(image,strlen(value),(unsigned char *) value);\n  (void) WriteBlob(image,1,(const unsigned char *) \"\\0\");\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      XColor\n        *colors;\n\n      XWDColor\n        color;\n\n      /*\n        Dump colormap to file.\n      */\n      (void) memset(&color,0,sizeof(color));\n      colors=(XColor *) AcquireQuantumMemory((size_t) image->colors,\n        sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        colors[i].pixel=(unsigned long) i;\n        colors[i].red=ScaleQuantumToShort(image->colormap[i].red);\n        colors[i].green=ScaleQuantumToShort(image->colormap[i].green);\n        colors[i].blue=ScaleQuantumToShort(image->colormap[i].blue);\n        colors[i].flags=(char) (DoRed | DoGreen | DoBlue);\n        colors[i].pad='\\0';\n        if ((int) (*(char *) &lsb_first) != 0)\n          {\n            MSBOrderLong((unsigned char *) &colors[i].pixel,\n              sizeof(colors[i].pixel));\n            MSBOrderShort((unsigned char *) &colors[i].red,3*\n              sizeof(colors[i].red));\n          }\n      }\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        color.pixel=(CARD32) colors[i].pixel;\n        color.red=colors[i].red;\n        color.green=colors[i].green;\n        color.blue=colors[i].blue;\n        color.flags=(CARD8) colors[i].flags;\n        count=WriteBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != (ssize_t) sz_XWDColor)\n          break;\n      }\n      colors=(XColor *) RelinquishMagickMemory(colors);\n    }\n  /*\n    Allocate memory for pixels.\n  */\n  length=3*bytes_per_line;\n  if (image->storage_class == PseudoClass)\n    length=bytes_per_line;\n  pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(pixels,0,length);\n  /*\n    Convert MIFF to XWD raster pixels.\n  */\n  scanline_pad=(bytes_per_line-((image->columns*bits_per_pixel) >> 3));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    q=pixels;\n    if (image->storage_class == PseudoClass)\n      {\n        indexes=GetVirtualIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns; x++)\n          *q++=(unsigned char) GetPixelIndex(indexes+x);\n      }\n    else\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        *q++=ScaleQuantumToChar(GetPixelRed(p));\n        *q++=ScaleQuantumToChar(GetPixelGreen(p));\n        *q++=ScaleQuantumToChar(GetPixelBlue(p));\n        p++;\n      }\n    for (x=0; x < (ssize_t) scanline_pad; x++)\n      *q++='\\0';\n    length=(size_t) (q-pixels);\n    count=WriteBlob(image,length,pixels);\n    if (count != (ssize_t) length)\n      break;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(y < (ssize_t) image->rows ? MagickFalse :  MagickTrue);\n}\n#endif\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X  W   W  DDDD                               %\n%                             X X   W   W  D   D                              %\n%                              X    W   W  D   D                              %\n%                             X X   W W W  D   D                              %\n%                            X   X   W W   DDDD                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write X Windows System Window Dump Format               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n#if defined(MAGICKCORE_X11_DELEGATE)\n#include \"magick/xwindow-private.h\"\n#if !defined(vms)\n#include <X11/XWDFile.h>\n#else\n#include \"XWDFile.h\"\n#endif\n#endif\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_X11_DELEGATE)\nstatic MagickBooleanType\n  WriteXWDImage(const ImageInfo *,Image *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X W D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXWD() returns MagickTrue if the image format type, identified by the\n%  magick string, is XWD.\n%\n%  The format of the IsXWD method is:\n%\n%      MagickBooleanType IsXWD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsXWD(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick+1,\"\\000\\000\",2) == 0)\n    {\n      if (memcmp(magick+4,\"\\007\\000\\000\",3) == 0)\n        return(MagickTrue);\n      if (memcmp(magick+5,\"\\000\\000\\007\",3) == 0)\n        return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_X11_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X W D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXWDImage() reads an X Window System window dump image file and\n%  returns it.  It allocates the memory necessary for the new Image structure\n%  and returns a pointer to the new image.\n%\n%  The format of the ReadXWDImage method is:\n%\n%      Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n    ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n  if (header.header_size < sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((header.bits_per_pixel == 0) || (header.bits_per_pixel > 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((header.bitmap_bit_order != MSBFirst) &&\n      (header.bitmap_bit_order != LSBFirst))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (header.bitmap_unit > 32)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (header.ncolors > 256)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  switch (header.visual_class)\n  {\n    case StaticGray:\n    case GrayScale:\n    case StaticColor:\n    case PseudoColor:\n    case TrueColor:\n    case DirectColor:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.pixmap_format)\n  {\n    case XYBitmap:\n    case XYPixmap:\n    case ZPixmap:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  length=(size_t) (header.header_size-sz_XWDheader);\n  if ((length+1) != ((size_t) ((CARD32) (length+1))))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) || \n      (ximage->format < 0) || (ximage->byte_order < 0) ||\n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n      XWDColor\n        color;\n\n      length=(size_t) header.ncolors;\n      if (length > ((~0UL)/sizeof(*colors)))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n          authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                red_shift) & red_mask);\n              SetPixelRed(q,ScaleShortToQuantum(colors[(ssize_t) index].red));\n              index=ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                green_shift) & green_mask);\n              SetPixelGreen(q,ScaleShortToQuantum(colors[(ssize_t)\n                index].green));\n              index=ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                blue_shift) & blue_mask);\n              SetPixelBlue(q,ScaleShortToQuantum(colors[(ssize_t) index].blue));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short) color));\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short) color));\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short) color));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleShortToQuantum(colors[i].red);\n          image->colormap[i].green=ScaleShortToQuantum(colors[i].green);\n          image->colormap[i].blue=ScaleShortToQuantum(colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,(ssize_t) XGetPixel(ximage,(int)\n              x,(int) y));\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X W D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXWDImage() adds properties for the XWD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXWDImage method is:\n%\n%      size_t RegisterXWDImage(void)\n%\n*/\nModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"XWD\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"X Windows system window dump (color)\");\n  entry->module=ConstantString(\"XWD\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X W D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXWDImage() removes format registrations made by the\n%  XWD module from the list of supported formats.\n%\n%  The format of the UnregisterXWDImage method is:\n%\n%      UnregisterXWDImage(void)\n%\n*/\nModuleExport void UnregisterXWDImage(void)\n{\n  (void) UnregisterMagickInfo(\"XWD\");\n}\n\f\n#if defined(MAGICKCORE_X11_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e X W D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteXWDImage() writes an image to a file in X window dump\n%  rasterfile format.\n%\n%  The format of the WriteXWDImage method is:\n%\n%      MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    bytes_per_line,\n    length,\n    scanline_pad;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  XWDFileHeader\n    xwd_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns != (CARD32) image->columns) ||\n      (image->rows != (CARD32) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  if ((image->storage_class == PseudoClass) && (image->colors > 256))\n    (void) SetImageType(image,TrueColorType);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Initialize XWD file header.\n  */\n  (void) memset(&xwd_info,0,sizeof(xwd_info));\n  xwd_info.header_size=(CARD32) sz_XWDheader;\n  value=GetImageProperty(image,\"comment\");\n  if (value != (const char *) NULL)\n    xwd_info.header_size+=(CARD32) strlen(value);\n  xwd_info.header_size++;\n  xwd_info.file_version=(CARD32) XWD_FILE_VERSION;\n  xwd_info.pixmap_format=(CARD32) ZPixmap;\n  xwd_info.pixmap_depth=(CARD32) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.pixmap_width=(CARD32) image->columns;\n  xwd_info.pixmap_height=(CARD32) image->rows;\n  xwd_info.xoffset=(CARD32) 0;\n  xwd_info.byte_order=(CARD32) MSBFirst;\n  xwd_info.bitmap_unit=(CARD32) (image->storage_class == DirectClass ? 32 : 8);\n  xwd_info.bitmap_bit_order=(CARD32) MSBFirst;\n  xwd_info.bitmap_pad=(CARD32) (image->storage_class == DirectClass ? 32 : 8);\n  bits_per_pixel=(size_t) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.bits_per_pixel=(CARD32) bits_per_pixel;\n  bytes_per_line=(CARD32) ((((xwd_info.bits_per_pixel*\n    xwd_info.pixmap_width)+((xwd_info.bitmap_pad)-1))/\n    (xwd_info.bitmap_pad))*((xwd_info.bitmap_pad) >> 3));\n  xwd_info.bytes_per_line=(CARD32) bytes_per_line;\n  xwd_info.visual_class=(CARD32)\n    (image->storage_class == DirectClass ? DirectColor : PseudoColor);\n  xwd_info.red_mask=(CARD32)\n    (image->storage_class == DirectClass ? 0xff0000 : 0);\n  xwd_info.green_mask=(CARD32)\n    (image->storage_class == DirectClass ? 0xff00 : 0);\n  xwd_info.blue_mask=(CARD32) (image->storage_class == DirectClass ? 0xff : 0);\n  xwd_info.bits_per_rgb=(CARD32) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.colormap_entries=(CARD32)\n    (image->storage_class == DirectClass ? 256 : image->colors);\n  xwd_info.ncolors=(unsigned int)\n    (image->storage_class == DirectClass ? 0 : image->colors);\n  xwd_info.window_width=(CARD32) image->columns;\n  xwd_info.window_height=(CARD32) image->rows;\n  xwd_info.window_x=0;\n  xwd_info.window_y=0;\n  xwd_info.window_bdrwidth=(CARD32) 0;\n  /*\n    Write XWD header.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &xwd_info,sizeof(xwd_info));\n  (void) WriteBlob(image,sz_XWDheader,(unsigned char *) &xwd_info);\n  if (value != (const char *) NULL)\n    (void) WriteBlob(image,strlen(value),(unsigned char *) value);\n  (void) WriteBlob(image,1,(const unsigned char *) \"\\0\");\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      XColor\n        *colors;\n\n      XWDColor\n        color;\n\n      /*\n        Dump colormap to file.\n      */\n      (void) memset(&color,0,sizeof(color));\n      colors=(XColor *) AcquireQuantumMemory((size_t) image->colors,\n        sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        colors[i].pixel=(unsigned long) i;\n        colors[i].red=ScaleQuantumToShort(image->colormap[i].red);\n        colors[i].green=ScaleQuantumToShort(image->colormap[i].green);\n        colors[i].blue=ScaleQuantumToShort(image->colormap[i].blue);\n        colors[i].flags=(char) (DoRed | DoGreen | DoBlue);\n        colors[i].pad='\\0';\n        if ((int) (*(char *) &lsb_first) != 0)\n          {\n            MSBOrderLong((unsigned char *) &colors[i].pixel,\n              sizeof(colors[i].pixel));\n            MSBOrderShort((unsigned char *) &colors[i].red,3*\n              sizeof(colors[i].red));\n          }\n      }\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        color.pixel=(CARD32) colors[i].pixel;\n        color.red=colors[i].red;\n        color.green=colors[i].green;\n        color.blue=colors[i].blue;\n        color.flags=(CARD8) colors[i].flags;\n        count=WriteBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != (ssize_t) sz_XWDColor)\n          break;\n      }\n      colors=(XColor *) RelinquishMagickMemory(colors);\n    }\n  /*\n    Allocate memory for pixels.\n  */\n  length=3*bytes_per_line;\n  if (image->storage_class == PseudoClass)\n    length=bytes_per_line;\n  pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(pixels,0,length);\n  /*\n    Convert MIFF to XWD raster pixels.\n  */\n  scanline_pad=(bytes_per_line-((image->columns*bits_per_pixel) >> 3));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    q=pixels;\n    if (image->storage_class == PseudoClass)\n      {\n        indexes=GetVirtualIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns; x++)\n          *q++=(unsigned char) GetPixelIndex(indexes+x);\n      }\n    else\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        *q++=ScaleQuantumToChar(GetPixelRed(p));\n        *q++=ScaleQuantumToChar(GetPixelGreen(p));\n        *q++=ScaleQuantumToChar(GetPixelBlue(p));\n        p++;\n      }\n    for (x=0; x < (ssize_t) scanline_pad; x++)\n      *q++='\\0';\n    length=(size_t) (q-pixels);\n    count=WriteBlob(image,length,pixels);\n    if (count != (ssize_t) length)\n      break;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(y < (ssize_t) image->rows ? MagickFalse :  MagickTrue);\n}\n#endif\n"], "filenames": ["coders/xwd.c"], "buggy_code_start_loc": [248], "buggy_code_end_loc": [248], "fixing_code_start_loc": [249], "fixing_code_end_loc": [252], "type": "CWE-369", "message": "ReadXWDImage in coders/xwd.c in the XWD image parsing component of ImageMagick 7.0.8-41 Q16 allows attackers to cause a denial-of-service (divide-by-zero error) by crafting an XWD image file in which the header indicates neither LSB first nor MSB first.", "other": {"cve": {"id": "CVE-2019-11472", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-23T14:29:00.837", "lastModified": "2020-08-19T02:15:14.503", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ReadXWDImage in coders/xwd.c in the XWD image parsing component of ImageMagick 7.0.8-41 Q16 allows attackers to cause a denial-of-service (divide-by-zero error) by crafting an XWD image file in which the header indicates neither LSB first nor MSB first."}, {"lang": "es", "value": "ReadXWDImage en coders/xwd.c en el componente de an\u00e1lisis de im\u00e1genes XWD de ImageMagick 7.0.8-41 Q16 permite a los atacantes causar una denegaci\u00f3n de servicio (error de divisi\u00f3n por cero) al crear un archivo de imagen XWD en el que el encabezado indica ni LSB primero ni MSB primero."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-41:q16:*:*:*:*:*:*", "matchCriteriaId": "34C2A939-19C7-4BC0-8DE5-E3D612C99B0E"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00057.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00001.html", "source": "cve@mitre.org"}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1546", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/f663dfb8431c97d95682a2b533cca1c8233d21b4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00030.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PF62B5PJA2JDUOCKJGUQO3SPL74BEYSV/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WHIKB4TP6KBJWT2UIPWL5MWMG5QXKGEJ/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4034-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick6/commit/f663dfb8431c97d95682a2b533cca1c8233d21b4"}}