{"buggy_code": ["/****************************************************************************\n *\n *  Copyright (C) 2006,2007 A.Kleine\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n ****************************************************************************/\n\n#define _GNU_SOURCE 1\n\n//#define DEBUGSTACK\n#define DECOMP_SWITCH\n// #define DEBUGSWITCH\n\n//#define STATEMENT_CLASS  \n//  I have uncommented some buggy class recognition stuff in decompileIF()\n//  to make work simple code lines like:  \"if(!a) trace(a);\"   - ak, November 2006\n\n//  To do: add some free()-calls for allocated blocks\n\n#include <assert.h>\n\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#include \"read.h\"\n#include \"action.h\"\n#include \"swftypes.h\"\n#include \"../src/blocks/error.h\"\n#include \"vasprintf.h\"\n\n\nstatic char **pool;\nstatic unsigned short poolcounter;\nstruct SWF_ACTIONPUSHPARAM *regs[256];\n\nstatic char *getName(struct SWF_ACTIONPUSHPARAM *act);\n\nstatic int offseoloop;\t// offset wherever a break can jump to (loops and switch)\n\nstatic void\ndumpRegs()\n{\nint i;\nfor(i=0;i<6;i++)\n\tif( regs[i] )\n\t\tprintf(\"reg[%d] %s\\n\", i, getName(regs[i]));\n}\n\n/*\n * Start Package \n *\n * A package to build up a string that can be returned to the caller\n * ak/2006: Extended for temporary swichting to a 2nd buffer\n */\n#define USE_LIB 1\n\nstatic int strsize=0;\nstatic int strmaxsize=0;\nstatic char *dcstr=NULL;\nstatic char *dcptr=NULL;\n\n#define DCSTRSIZE 40960\n#define PARAM_STRSIZE 512\nvoid\ndcinit()\n{\n\tstrsize = 1; // We start with empty string, i.e. \\0\n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}\n\nvoid\ndcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n\n}\n\nvoid\ndcputs(const char *s)\n{\n\tint len=strlen(s);\n\tdcchkstr(len);\n\tstrcat(dcptr,s);\n\tdcptr+=len;\n\tstrsize+=len;\n}\n\nvoid\ndcputchar(char c)\n{\n\tdcchkstr(1);\n\n\t*dcptr++=c;\n\t*dcptr='\\000';\n\tstrsize++;\n}\n\nint\ndcprintf(char *format, ...)\n{\n\tchar *s;\n\tsize_t size;\n\tint ret;\n\n\tva_list args;\n\tva_start(args,format);\n\tret = vasprintf(&s,format,args);\n\tdcputs(s);\n\tsize=strlen(s);\n\tfree(s);\n\treturn size;\n}\n\nchar *\ndcgetstr()\n{\n\tchar *ret;\n\tret = dcstr;\n\tdcstr=NULL;\n\tstrmaxsize=0;\n\treturn ret;\n}\n\nstruct strbufinfo\n{\n\tint size;\n\tint maxsize;\n\tchar *str;\n\tchar *ptr;\n};\n\n\nstatic struct strbufinfo setTempString(void)\n{\n\tstruct strbufinfo current;\n\tcurrent.size=strsize;\n\tcurrent.maxsize=strmaxsize;\n\tcurrent.str=dcstr;\n\tcurrent.ptr=dcptr;\n\tdcinit();\n\treturn current;\n}\n\nstatic void setOrigString(struct strbufinfo old)\n{\n\tfree(dcstr);\t\t\t\t/* not needed anymore */\n\tstrsize=old.size;\n\tstrmaxsize=old.maxsize;\n\tdcstr=old.str;\n\tdcptr=old.ptr;\n}\n\n// a variant of setOrigString()\n// but for further usage of 2nd buffer\n//\nstatic char *\nswitchToOrigString(struct strbufinfo old)\n{\n\tchar *tmp=dcstr;\n\tstrsize=old.size;\n\tstrmaxsize=old.maxsize;\n\tdcstr=old.str;\n\tdcptr=old.ptr;\n\treturn tmp;\n}\n\n#if USE_LIB\n#define puts(s) dcputs(s)\n#define putchar(c) dcputchar(c)\n#define printf dcprintf\n#endif\n\n#define INDENT { int ii=gIndent; while(--ii>=0) { putchar(' '); putchar(' '); } }\n\n/* String used for terminating lines (see println) */\nstatic const char* newlinestring = \"\\\\\\n\";\n\n/* Set the newline character. By default it is an escaped NL. */\nvoid\nsetNewLineString(const char* ch)\n{\n\tnewlinestring = ch;\n}\n\n/* Print a line with a terminating newline, which can be set by\n * setNewLineString()\n */\nstatic void\nprintln(const char* fmt, ...)\n{\n\tchar *tmp;\n\tint written;\n\n\tva_list ap;\n\tva_start (ap, fmt);\n\twritten = vasprintf (&tmp, fmt, ap);\n\n\tdcprintf(\"%s%s\", tmp, newlinestring);\n\n\tfree(tmp);\n}\n\n\n/* End Package */\n\n/*\n * Start Package \n *\n * A package to maintain escaped characters strings\n * [ BSC == BackSlashCounter ]\n */\n#define BSC 2\nstatic int strlenext(char *str)\n{\n\tint i=0;\n\twhile (*str)\n\t{\n\t\ti++;\n\t\tif (*str=='\\'') i+=BSC;\n\t\t\tstr++;\t\n\t}\n\treturn i;\n}\n\nstatic char* strcpyext(char *dest,char *src)\n{\n\tchar *r=dest;\n\twhile (*src)\n\t{\n\t\tif (*src=='\\'')\n\t\t{\n\t\t\t*dest++='\\\\';\n#if BSC == 2\n\t\t\t*dest++='\\\\';\n#endif\n\t\t}\n\t\t*dest++=*src++;\n\t}\n\t*dest='\\0';\n\treturn r;\n}\n\nstatic char* strcatext(char *dest,char *src)\n{\n\tchar *r=dest;\n\twhile (*dest)\n\t\tdest++;\n\tstrcpyext(dest,src);\n\treturn r;\n}\n/* End Package */\n\n/*\n * Start Package \n *\n * A package to maintain a representation of the Flash VM stack\n */\n\nstruct _stack {\n\tchar type;\n\tstruct SWF_ACTIONPUSHPARAM *val;\n\tstruct _stack *next;\n};\n\nstruct _stack *Stack;\n\nenum\n{\n\tPUSH_STRING = 0,\n\tPUSH_FLOAT = 1,\n\tPUSH_NULL = 2,\n\tPUSH_UNDEF = 3,\n\tPUSH_REGISTER = 4,\n\tPUSH_BOOLEAN = 5,\n\tPUSH_DOUBLE = 6,\n\tPUSH_INT = 7,\n\tPUSH_CONSTANT = 8,\n\tPUSH_CONSTANT16 = 9,\n\tPUSH_VARIABLE = 10,\n};\n\nstatic char *\ngetString(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n#ifdef DEBUG\n\tprintf(\"*getString* type=%d\\n\",act->Type);\n#endif\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_STRING: \n\t\tif (!act->p.String) /* Not a NULL string */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getString with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlen(act->p.String)+3); /* 2 \"'\"s and a NULL */\n\t\tstrcpy(t,\"'\");\n\t\tstrcat(t,act->p.String);\n\t\tstrcat(t,\"'\");\n\t\treturn t;\n\tcase PUSH_NULL: /* NULL */\n\t\treturn \"null\";\n\tcase PUSH_UNDEF: /* Undefined */\n\t\treturn \"undefined\";\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\tif( regs[act->p.RegisterNumber] &&\n\t\t    regs[act->p.RegisterNumber]->Type != 4 &&\n\t\t    regs[act->p.RegisterNumber]->Type != 7 )\n\t\t{\n\t\t\treturn getName(regs[act->p.RegisterNumber]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt=malloc(5); /* Rddd */\n\t\t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n\t\t\treturn t;\n\t\t}\n\tcase PUSH_BOOLEAN: /* BOOLEAN */\n\t\tif( act->p.Boolean )\n\t\t\treturn \"true\";\n\t\telse\n\t\t\treturn \"false\";\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t{\n\t\tchar length_finder[1];\n\t\tint needed_length = snprintf(length_finder, 1, \"%g\", act->p.Double) + 1;\n\t\tif (needed_length <= 0)\n\t\t{\n\t\t        SWF_warn(\"WARNING: could not evaluate size of buffer (memory issue ?).\\n\");\n\t\t        break;\n\t\t}\n\n\t\tt = malloc(needed_length);\n\t\tsprintf(t, \"%g\", act->p.Double );\n\t\treturn t;\n\t}\n\tcase PUSH_INT: /* INTEGER */\n\t\tt=malloc(10); /* 32-bit decimal */\n\t\tsprintf(t,\"%ld\", act->p.Integer );\n\t\treturn t;\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+3); /* 2 \"'\"s and a NULL */\n\t\tstrcpy(t,\"'\");\n\t\tstrcatext(t,pool[act->p.Constant8]);\n\t\tstrcat(t,\"'\");\n\t\treturn t;\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+3); /* 2 '\\\"'s and a NULL */\n\t\tstrcpy(t,\"'\");\n\t\tstrcatext(t,pool[act->p.Constant16]);\n\t\tstrcat(t,\"'\");\n\t\treturn t;\n\n\tcase 12:\n\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n\tcase PUSH_VARIABLE: /* VARIABLE */\n\t\treturn act->p.String;\n\tdefault: \n\t\tfprintf (stderr,\"  Can't get string for type: %d\\n\", act->Type);\n\t\tbreak;\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\n\treturn t;\n}\n\nstatic char *\ngetName(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n\n\tswitch( act->Type ) \t\n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif (!act->p.String) /* Not a NULL string */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(act->p.String)) /* Not a zero length string */\n\t\t{\n\t\t        t=malloc(strlen(act->p.String)+3);\n\t\t        strcpyext(t,act->p.String);\n\t\t        return t;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *return_string = \"this\";\n\t                t=malloc(strlen(return_string)+1); /* string length + \\0 */\n\t                strcpyext(t,return_string);\n\t\t\treturn t;\n\t\t}\n#if 0\n\t  case 4: /* REGISTER */\n\t\tt=malloc(5); /* Rddd */\n  \t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n  \t\treturn t;\n#endif\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+1);\n\t\tstrcpyext(t,pool[act->p.Constant8]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\n\treturn t;\n}\n\nstatic int\ngetInt(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */\n\t\treturn ((int)act->p.Float);\n\tcase PUSH_NULL: /* NULL */\n\t\treturn 0;\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\treturn getInt(regs[act->p.RegisterNumber]);\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\treturn (int)act->p.Double;\n\tcase PUSH_INT: /* INTEGER */\n\t\treturn act->p.Integer;\n\tdefault: \n\t\tfprintf (stderr,\"  Can't get int for type: %d\\n\", act->Type);\n\t}\n\treturn 0;\n}\n\nstatic char *\ngetProperty(Property prop)\n{\n\tswitch(prop)\n\t{\n\tcase SWF_SETPROPERTY_X: \treturn(\"_x\"); break;\n\tcase SWF_SETPROPERTY_Y:\n\tcase PROPERTY_Y:\t\treturn(\"_y\"); break;\n\tcase PROPERTY_XMOUSE:\t\treturn(\"_xMouse\"); break;\n\tcase PROPERTY_YMOUSE:\t\treturn(\"_yMouse\"); break;\n\tcase SWF_SETPROPERTY_XSCALE:\n\tcase PROPERTY_XSCALE:\t   \treturn(\"_xScale\"); break;\n\tcase SWF_SETPROPERTY_YSCALE:\n\tcase PROPERTY_YSCALE:\t   \treturn(\"_yScale\"); break;\n\tcase PROPERTY_CURRENTFRAME:\treturn(\"_currentFrame\"); break;\n\tcase PROPERTY_TOTALFRAMES:\treturn(\"_totalFrames\"); break;\n\tcase SWF_SETPROPERTY_ALPHA:\n\tcase PROPERTY_ALPHA:\t\treturn(\"_alpha\"); break;\n\tcase SWF_SETPROPERTY_VISIBILITY:\n\tcase PROPERTY_VISIBLE:\t\treturn(\"_visible\"); break;\n\tcase PROPERTY_WIDTH:\t\treturn(\"_width\"); break;\n\tcase PROPERTY_HEIGHT:\t\treturn(\"_height\"); break;\n\tcase SWF_SETPROPERTY_ROTATION:\n\tcase PROPERTY_ROTATION:\t\treturn(\"_rotation\"); break;\n\tcase PROPERTY_TARGET:\t\treturn(\"_target\"); break;\n\tcase PROPERTY_FRAMESLOADED:\treturn(\"_framesLoaded\"); break;\n\tcase SWF_SETPROPERTY_NAME:\n\tcase PROPERTY_NAME:\t\treturn(\"_name\"); break;\n\tcase PROPERTY_DROPTARGET:\treturn(\"_dropTarget\"); break;\n\tcase PROPERTY_URL:\t\treturn(\"_url\"); break;\n\tcase SWF_SETPROPERTY_HIGHQUALITY:\n\tcase PROPERTY_HIGHQUALITY:\treturn(\"_quality\"); break;\n\tcase SWF_SETPROPERTY_SHOWFOCUSRECT:\n\tcase PROPERTY_FOCUSRECT:\treturn(\"_focusRect\"); break;\n\tcase SWF_SETPROPERTY_SOUNDBUFFERTIME:\n\tcase PROPERTY_SOUNDBUFTIME:\treturn(\"_soundBufTime\"); break;\n\tcase SWF_SETPROPERTY_WTHIT:\n\tcase PROPERTY_WTHIT:\t\treturn(\"_WTHIT!?\"); break;\n\tdefault:\t\t\treturn(\"unknown property!\"); break;\n\t}\n}\n\nstruct SWF_ACTIONPUSHPARAM *\nnewVar(char *var)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; \n\tv->p.String = var;\n\treturn v;\n}\n\nstruct SWF_ACTIONPUSHPARAM *\nnewVar2(char *var,char *var2)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE;\n\tv->p.String = malloc(strlen(var)+strlen(var2)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\treturn v;\n}\n\n\nstruct SWF_ACTIONPUSHPARAM *\nnewVar3(char *var,char *var2, char *var3)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; /* VARIABLE */\n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\treturn v;\n}\n\nstruct SWF_ACTIONPUSHPARAM *\nnewVar5(char *var,char *var2, char *var3,char *var4,char *var5)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; /* VARIABLE */\n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(var5)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tstrcat(v->p.String,var5);\n\treturn v;\n}\n\nvoid\npush(struct SWF_ACTIONPUSHPARAM *val)\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*push* type=%d\\n\",val->Type);\n#endif\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = val->Type;\n\tt->val = val;\n\tt->next = Stack;\n\tStack = t;\n}\n\n\nvoid\npushdup()\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushdup*\\n\");\n#endif\n\tif(Stack == NULL)\n\t{\n\t\tSWF_warn(\"WARNING: pushdup on empty stack. This might be wrong!\\n\");\n\t\treturn;\n\t}\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = Stack->type;\n\n\t// If element is a string, perform deep copy of Stack->val->p\n\tif (Stack->val->Type == PUSH_STRING) {\n\t\tt->val = calloc(1, sizeof(struct SWF_ACTIONPUSHPARAM));\n\t\t*t->val = *Stack->val;\n\n\t\tint len = strlen(Stack->val->p.String) + 1; // NULL terminated\n\t\tt->val->p.String = calloc(len, sizeof(char));\n\t\tstrcpy(t->val->p.String, Stack->val->p.String);\n\t} else {\n\t\tt->val =  Stack->val;\n\t}\n\n\tt->next = Stack;\n\tStack = t;\n}\n\n\nvoid\npushvar(struct SWF_ACTIONPUSHPARAM *val)\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushvar*\\n\");\n#endif\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = 'v'; // ???\n\tt->val = val;\n\tt->next = Stack;\n\tStack = t;\n}\n\nstruct SWF_ACTIONPUSHPARAM * pop()\n{\n\tstruct _stack *t;\n\tstruct SWF_ACTIONPUSHPARAM * ret;\n\n#ifdef DEBUG\n\tprintf(\"*pop*\\n\");\n#endif\n#ifdef DEBUGSTACK\t\t/* continue w stack dummy */\n\tif( Stack == NULL ) push(newVar(\"// *** pop(): INTERNAL STACK ERROR FOUND ***\"));\n#else\n\tif( Stack == NULL ) SWF_error(\"Stack blown!! - pop\");\n#endif\n\tt=Stack;\n\tStack=t->next;\n\tret=t->val;\n\treturn ret;\n}\n\nstruct SWF_ACTIONPUSHPARAM * peek()\n{\n#ifdef DEBUG\n\tprintf(\"*peek*\\n\");\n#endif\n#ifdef DEBUGSTACK\t\t/* continue w stack dummy */\n\tif( Stack == NULL ) push(newVar(\"// *** peek(): INTERNAL STACK ERROR FOUND ***\"));\n#else\n\tif( Stack == NULL ) SWF_error(\"Stack blown!! - peek\");\n#endif\n\treturn Stack->val;\n}\n\nvoid\nstackswap()\n{\n#ifdef DEBUG\n\tprintf(\"*stackswap*\\n\");\n#endif\n\tstruct SWF_ACTIONPUSHPARAM *p = peek();\t\t/* peek() includes error handling */\n\tchar type = Stack->type;\n\n        if (Stack->next == NULL) {\n#if DEBUG\n\t\tSWF_warn(\"stackswap: can't swap (stack contains only one element)\\n\");\n#endif\n                return;\n        }\n\n\tStack->type = Stack->next->type;\n\tStack->val  = Stack->next->val;\n\tStack->next->type = type;\n\tStack->next->val  = p;\n}\n\n\nstatic struct SWF_ACTIONPUSHPARAM *\nnewVar_N(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\t\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops=getString(pop());\n\t\twhile ( strlen(v->p.String)+ 2 + strlen(pops) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}\n\n// similar to newVar_N(), \n// but pops 2 items from stack per counter,\n// and second of them we are interested in getName() instead of getString()\nstatic struct SWF_ACTIONPUSHPARAM *\nnewVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\t\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}\n\n/* End Package */\n\nstatic int gIndent;\nstatic void decompileActions(int n, SWF_ACTION *actions,int indent);\nchar * decompile5Action(int n, SWF_ACTION *actions,int indent);\n\n/******************************************************************************/\n/******************************************************************************/\n/******************************************************************************/\n/******************************************************************************/\n/******************************************************************************/\n\n\n#define SanityCheck(curact,test,msg ) \\\n    if(!(test) ) SWF_error( \"SanityCheck failed in %s\\n %s\\n\", #curact, msg );\n\n#define OUT_BEGIN(block) \\\n\t                struct block *sact = (struct block *)act;\n#define OUT_BEGIN2(block) \\\n\t                struct block *sact = (struct block *)&(actions[n]);\n\nstatic void\ndecompileCONSTANTPOOL (SWF_ACTION *act)\n{\n\tOUT_BEGIN(SWF_ACTIONCONSTANTPOOL);\n\tpool=sact->ConstantPool;\n\tpoolcounter = sact->Count;\n}\n\nstatic void\ndecompileWAITFORFRAME (SWF_ACTION *act)\n{\n\tOUT_BEGIN(SWF_ACTIONWAITFORFRAME);\n\n\tINDENT\n\tprintln(\"WaitForFrame(%d,%d);\", sact->Frame,sact->SkipCount);\n}\n\nstatic void\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *act, int wantstring)\n{\n\tchar *t;\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif( wantstring ) printf (\"'%s'\", act->p.String);\n\t\telse printf (\"%s\", act->p.String);\n\t\tbreak;\n\tcase PUSH_FLOAT: /* FLOAT */\n\t\tprintf (\"%f\", act->p.Float);\n\t\tbreak;\n\tcase PUSH_NULL: /* NULL */\n\t\tprintf (\"NULL\" );\n\t\tbreak;\n\tcase PUSH_UNDEF: /* Undefined */\n\t\tprintf (\"undefined\" );\n\t\tbreak;\n\tcase PUSH_REGISTER: /* Register */\n\t\tif( regs[act->p.RegisterNumber] ) {\n\t\t\tprintf (\"%s\", getName(act));\n\t\t} else {\n\t\t\tprintf (\"R%d\", (int)act->p.RegisterNumber);\n\t\t}\n\t\tbreak;\n\tcase PUSH_BOOLEAN: /* BOOLEAN */\n\t\tprintf (\"%s\", act->p.Boolean?\"true\":\"false\");\n\t\tbreak;\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\tprintf (\"%g\", act->p.Double);\n\t\tbreak;\n\tcase PUSH_INT: /* INTEGER */\n\t\tprintf (\"%ld\", act->p.Integer);\n\t\tbreak;\n\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif( wantstring ) t=getString(act);\n\t  \telse t=getName(act);\n\t  \tputs(t);  \n\t  \tfree(t);  \n\t  \tbreak;\n\n#if 0\n\t  case 8: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant8]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant8]);\n\t\tbreak;\n\t  case 9: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant16]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant16]);\n\t\tbreak;\n#endif\n\tcase 12:\n\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n\tcase PUSH_VARIABLE: /* VARIABLE */\n\t\tprintf (\"%s\", act->p.String);\n\t\tbreak;\n\tdefault: \n\t\tprintf (\"  Unknown type: %d\\n\", act->Type);\n\t}\n}\n\nstatic void\ndecompileGETURL (SWF_ACTION *act)\n{\n\tOUT_BEGIN(SWF_ACTIONGETURL);\n\n\tINDENT\n\tprintln(\"getUrl('%s',%s);\", sact->UrlString, sact->TargetString);\n}\n\nstatic int\ndecompileGETURL2 (SWF_ACTION *act)\n{\n\tstruct SWF_ACTIONPUSHPARAM *a,*b;\n\tOUT_BEGIN(SWF_ACTIONGETURL2);\n\tINDENT\n\n\ta = pop();\n\tb = pop();\n\n\tif (sact->f.FlagBits.SendVarsMethod==3)\n\t\tputs(\"loadVariables(\");\n\telse \n\t{\n\t\tif (sact->f.FlagBits.SendVarsMethod==2)\n\t\t\tputs(\"loadVariablesNum(\");\n\t\telse\n\t\t{\n\t\t\tif (sact->f.FlagBits.SendVarsMethod==1) \n\t\t\t\tputs(\"loadMovie(\");\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (*getName(a)=='_')\t// found a _level\n\t\t\t\t\tputs(\"loadMovieNum(\");\t\n\t\t\t\telse\n\t\t\t\t\tputs(\"getURL(\");\n\t\t\t}\n\t\t}\n\t}\n\tdecompilePUSHPARAM (b, 1);\n\tputs(\",\");\n\tdecompilePUSHPARAM (a, 1);\n\tif  (sact->f.FlagBits.LoadVariableFlag)\n\t\tputs(\",'GET'\");\n\tif (sact->f.FlagBits.LoadTargetFlag)\n\t\tputs(\",'POST'\");\n\tprintln(\");\");\n\treturn 0;\n}\n\nstatic inline int OpCode(SWF_ACTION *actions, int n, int maxn)\n{\n\tif(!n || n >= maxn)\n\t{\n#if DEBUG\n\t\tSWF_warn(\"OpCode: want %i, max %i\\n\", n, maxn);\n#endif\n\t\treturn -999;\n\t} else if (n < 1) {\n\n#if DEBUG\n\t\tSWF_warn(\"OpCode: want %i < 1\\n\", n);\n#endif\n\t\treturn -998;\n        }\n\treturn actions[n].SWF_ACTIONRECORD.ActionCode;\n}\n\nstatic int\nisStoreOp(int n, SWF_ACTION *actions,int maxn)\n{\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\tcase SWFACTION_STOREREGISTER:\n\tcase SWFACTION_SETVARIABLE:\n\tcase SWFACTION_SETMEMBER:\n\tcase SWFACTION_CASTOP:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int \ndecompileGOTOFRAME(int n, SWF_ACTION *actions,int maxn,int islabel)\n{\n\tint i=0;\n\tstruct SWF_ACTIONGOTOLABEL *sactv2;\n\tOUT_BEGIN2(SWF_ACTIONGOTOFRAME);\n\tsactv2 = (struct SWF_ACTIONGOTOLABEL*)sact;\n\tINDENT\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_PLAY)\n\t{\n\t\ti=1;\n\t\tputs(\"gotoAndPlay(\");\n\t}\n\telse\n\t{\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_STOP)\n\t\t\ti=1;\n\t\tputs(\"gotoAndStop(\");\n\t}\n\t\n\tif (islabel)\n\t\tprintln(\"'%s');\", sactv2->FrameLabel);\n\telse\n\t\tprintln(\"%d);\", sact->Frame+1); /* GOTOFRAME arg is 0-based */\n\treturn i;\n}\n\nstatic int \ndecompileGOTOFRAME2(int n, SWF_ACTION *actions, int maxn)\n{\n\tint i=0;\n\tOUT_BEGIN2(SWF_ACTIONGOTOFRAME2);\n\tINDENT\n\tif (n+1 < maxn)\n\t{\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_PLAY ||\n\t\t    OpCode(actions, n+1, maxn) == SWFACTION_STOP)\n\t\t\ti=1;\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_PLAY)\n\t\t\tputs(\"gotoAndPlay(\");\n\t\telse\n\t\t{\n\t\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_STOP)\n\t\t\t\tputs(\"gotoAndStop(\");\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sact->f.FlagBits.PlayFlag)\n\t\t\t\t\tputs(\"gotoAndPlay(\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"gotoAndStop(\");\n\t\t\t}\n\t\t}\n\t}\n\telse \n\t{\n\t\tif (sact->f.FlagBits.PlayFlag)\n\t\t\tputs(\"gotoAndPlay(\");\n\t\telse\n\t\t\tputs(\"gotoAndStop(\");\n\t}\n\tdecompilePUSHPARAM(pop(),0);\n\tprintln(\");\");\n\treturn i;\n}\n\n\nstatic int precedence(int op1,int op2)\n{\n\tstatic unsigned char ops[]= { \t\t// array of opcodes w rising precedence\n//\tSWFACTION_SETVARIABLE,\t\t// TAKE CARE: array is incomplete\n//\tSWFACTION_TRACE,\n\t// missing ops are considered with low precedence\n\t\tSWFACTION_LOGICALOR,\n\t\tSWFACTION_LOGICALAND,\n\t\tSWFACTION_BITWISEOR,\n\t\tSWFACTION_BITWISEXOR,\n\t\tSWFACTION_BITWISEAND,\n\t\tSWFACTION_STRICTEQUALS,\n\t\tSWFACTION_EQUALS2,\n\t\tSWFACTION_EQUAL,\n\t\tSWFACTION_GREATER,\n\t\tSWFACTION_LESSTHAN,\n\t\tSWFACTION_LESS2,\t\n\t\tSWFACTION_SHIFTRIGHT,\n\t\tSWFACTION_SHIFTRIGHT2,\n\t\tSWFACTION_SHIFTLEFT,\n\t\tSWFACTION_ADD,\n\t\tSWFACTION_ADD2,\n\t\tSWFACTION_SUBTRACT,\n\t\tSWFACTION_MODULO,\n\t\tSWFACTION_MULTIPLY,\n\t\tSWFACTION_DIVIDE,\n\t\tSWFACTION_LOGICALNOT,\n\t\tSWFACTION_PUSH\t\t\t// FIXME: need more analysis on code after PUSH\n\t};\n\tunsigned char* f=memchr(ops,op1,sizeof(ops));\n\tunsigned char* s=memchr(ops,op2,sizeof(ops));\n#ifdef DEBUG\n\tprintf(\"1op=%d 2op=%d  result=%d\\n\",op1,op2,f>s);\n\tif (!f) printf(\"opcode=%d NOT in precedence list\\n\",op1);\n\tif (!s) printf(\"opcode=%d NOT in precedence list\\n\",op2);\n#endif\n\treturn f>s;\n}\n\n#ifdef DECOMP_SWITCH\nstatic int\ncheck_switch(int firstcode)\n{\n\treturn (firstcode == SWFACTION_PUSH || firstcode == SWFACTION_JUMP);\n}\n#endif\n\n\nstatic int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n\nstatic int\nisLogicalOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\tcase SWFACTION_LESSTHAN:\n\tcase SWFACTION_LOGICALAND:\n\tcase SWFACTION_LOGICALOR:\n\tcase SWFACTION_LOGICALNOT:\n\tcase SWFACTION_STRINGEQ:\n\tcase SWFACTION_STRINGCOMPARE:\n\tcase SWFACTION_LESS2:\n\tcase SWFACTION_EQUALS2:\n\tcase SWFACTION_EQUAL:\n\tcase SWFACTION_BITWISEAND:\n\tcase SWFACTION_BITWISEOR:\n\tcase SWFACTION_BITWISEXOR:\n\tcase SWFACTION_STRICTEQUALS:\n\tcase SWFACTION_GREATER:\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t*/\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int \nisLogicalOp2(int n, SWF_ACTION *actions,int maxn)\n{\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\tcase SWFACTION_LOGICALNOT:\n\tcase SWFACTION_PUSHDUP:\n\tcase SWFACTION_IF:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nstackVal(int n, SWF_ACTION *actions)\n{\n\tif (!n) \n\t\treturn 0;\n\n\tswitch((actions[n-1]).SWF_ACTIONRECORD.ActionCode)\n\t{\n\tcase SWFACTION_LOGICALNOT:\n\tcase SWFACTION_DECREMENT:\n\tcase SWFACTION_INCREMENT:\n\tcase SWFACTION_RANDOMNUMBER:\n\tcase SWFACTION_TOSTRING:\n\tcase SWFACTION_TONUMBER:\n\tcase SWFACTION_ORD:\n\tcase SWFACTION_CHR:\n\tcase SWFACTION_MBORD:\n\tcase SWFACTION_MBCHR:\n\tcase SWFACTION_INT:\n\tcase SWFACTION_GETVARIABLE:\n\tcase SWFACTION_SUBSTRING:\n\tcase SWFACTION_MBSUBSTRING:\n\tcase SWFACTION_GETMEMBER:\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\tcase SWFACTION_SUBTRACT:\n\tcase SWFACTION_MULTIPLY:\n\tcase SWFACTION_DIVIDE:\n\tcase SWFACTION_MODULO:\n\tcase SWFACTION_BITWISEAND:\n\tcase SWFACTION_BITWISEOR:\n\tcase SWFACTION_BITWISEXOR:\n\tcase SWFACTION_LESSTHAN:\n\tcase SWFACTION_LOGICALAND:\n\tcase SWFACTION_LOGICALOR:\n\tcase SWFACTION_STRINGEQ:\n\tcase SWFACTION_STRINGCOMPARE:\n\tcase SWFACTION_LESS2:\n\tcase SWFACTION_EQUALS2:\n\tcase SWFACTION_EQUAL:\n\tcase SWFACTION_STRICTEQUALS:\n\tcase SWFACTION_GREATER:\n\tcase SWFACTION_STRINGGREATER:\n\tcase SWFACTION_STRINGCONCAT:\n\tcase SWFACTION_SHIFTLEFT:\n\tcase SWFACTION_SHIFTRIGHT:\n\tcase SWFACTION_SHIFTRIGHT2:\n\tcase SWFACTION_INSTANCEOF:\n\tcase SWFACTION_CALLMETHOD:\n\tcase SWFACTION_CALLFUNCTION:\n\tcase SWFACTION_GETTIME:\n\tcase SWFACTION_GETPROPERTY:\n\tcase SWFACTION_PUSH:\n\tcase SWFACTION_DELETE:\n\tcase SWFACTION_DELETE2:\n\tcase SWFACTION_MBLENGTH:\n\tcase SWFACTION_STRINGLENGTH:\n\tcase SWFACTION_CASTOP:\n\tcase SWFACTION_TYPEOF:\n\tcase SWFACTION_PUSHDUP:\n\t\treturn 1;\n\tdefault:\n\treturn 0;\n\t}\n}\n\nstatic int\ndecompileLogicalNot(int n, SWF_ACTION *actions, int maxn)\n{\n#ifdef STATEMENT_CLASS\n\tif(OpCode(actions, n-1, maxn) == SWFACTION_GETVARIABLE &&\n\t   OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t   OpCode(actions, n+2, maxn) == SWFACTION_IF ) \n\t{\n\t\t/* It's a class statement  -- skip over both NOTs */\n\t\treturn 1;\n\t}\n#endif\n\tif(OpCode(actions, n+1, maxn) != SWFACTION_IF )\n\t\tpush(newVar2(\"!\",getString(pop())));\n\treturn 0;\n}\n\nstatic void\ndecompilePUSH (SWF_ACTION *act)\n{\n\tint i;\n\tOUT_BEGIN(SWF_ACTIONPUSH);\n\n\tSanityCheck(SWF_PUSH,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH,\n\t\t\"not a PUSH\")\n\n\tfor(i=0;i<sact->NumParam;i++)\n\t\tpush(&(sact->Params[i]));\n}\n\nstatic void\ndecompilePUSHDUP (SWF_ACTION *act)\n{\n\tSanityCheck(SWF_PUSHDUP,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSHDUP,\n\t\t\"not a PUSHDUP\")\n\tpushdup();\n}\n\nstatic void\ndecompileSTACKSWAP (SWF_ACTION *act)\n{\n\tSanityCheck(SWF_STACKSWAP,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_STACKSWAP,\n\t\t\"not a STACKSWAP\")\n\tstackswap();\n}\n\nstatic int\ndecompileSETPROPERTY(int n, SWF_ACTION *actions,int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *val, *idx, *obj;\n\n\tINDENT\n\tval = pop();\n\tidx = pop();\n\tobj = pop();\n#ifdef DEBUG\n\tprintf(\"*setProp* objName %s (type=%d) Prop (type=%d) =%x\\n\",\n\t       getName(obj), obj->Type, idx->Type,getInt(idx));\n#endif\n\tif (obj->Type == PUSH_VARIABLE)\n\t\tputs(\"eval(\");\n\t\n\tdecompilePUSHPARAM(obj,0);\n\tif (obj->Type == PUSH_VARIABLE)\n\t\tputs(\")\");\n\t\n\tputs(\".\");\n\tputs(getProperty(getInt(idx)));\n\tprintf(\" = \" );\n\tdecompilePUSHPARAM(val,0);\n\tprintln(\";\");\n\treturn 0;\n}\n\nstatic int\ndecompileGETPROPERTY(int n, SWF_ACTION *actions,int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *idx, *obj;\n\n\tINDENT\n\tidx = pop();\n\tobj = pop();\n#ifdef DEBUG\n\tprintf(\"*GETProp* objName %s (type=%d) Prop (type=%d) =%x\\n\",\n\t       getName(obj), obj->Type, idx->Type,getInt(idx));\n#endif\n\tif (obj->Type == PUSH_VARIABLE)\n\t\tpush( newVar5(\"eval(\",getName(obj),\".\",getProperty(getInt(idx)),\")\"));\n\telse\n\t\tpush( newVar3( getName(obj),\".\",getProperty(getInt(idx))));\n\treturn 0;\n}\n\nstatic int\ndecompileTRACE(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"trace(\");\n\tdecompilePUSHPARAM(pop(),1);\n\tprintln(\");\");\n\treturn 0;\n}\n\nstatic int\ndecompileCALLFRAME(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"callFrame(\");\n\tdecompilePUSHPARAM(pop(),1);\n\tprintln(\");\");\n\treturn 0;\n}\n\nstatic int\ndecompileGETTIME(int n, SWF_ACTION *actions, int maxn)\n{\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\tINDENT\n\t\tprintln(\"getTimer();\");\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\tpush(newVar(\"getTimer()\"));\n\t\treturn 0;\n\t}\n}\n\nstatic int\ndecompileINCR_DECR(int n, SWF_ACTION *actions, int maxn, int is_incr)\n{\n\tint is_postop;\n\tstruct SWF_ACTIONPUSHPARAM *var=pop();\n\tchar *dblop=is_incr ? \"++\":\"--\";\n\n\tif((OpCode(actions, n, maxn) == SWFACTION_PUSHDUP\n\t     || OpCode(actions, n+1, maxn) == SWFACTION_PUSHDUP \n\t     || OpCode(actions, n+1, maxn) == SWFACTION_SETVARIABLE)\n\t     || ( OpCode(actions, n-1, maxn) == SWFACTION_GETVARIABLE\n\t          &&  OpCode(actions, n+1, maxn) == SWFACTION_STOREREGISTER\n\t          &&  OpCode(actions, n+1, maxn) == SWFACTION_SETVARIABLE))\n\t{\n\t\tis_postop=(OpCode(actions, n-1, maxn) == SWFACTION_PUSHDUP)?1:0;\n\t\tif (is_postop)\n\t\t\tvar = newVar2(getString(var),dblop);\n\t\telse\n\t\t\tvar = newVar2(dblop,getString(var));\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_SETVARIABLE)\n\t\t{\n\t\t\tvar->Type=11;\t/* later trigger printing variable inc/dec */\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar->Type=12;\t/* later be quiet, see decompileSETVARIABLE() */\n\t\t\tif (is_postop)\n\t\t\t{\n\t\t\t\tpop();\n\t\t\t\tpush(var);\t/* will duplicate stacktop */\n\t\t\t}\n\t\t}\n\t\tpush(var);\n\t}\n\telse\n\t{\n\t\tif((OpCode(actions, n-1, maxn) == SWFACTION_GETMEMBER &&\n\t\t    OpCode(actions, n+1, maxn) == SWFACTION_STOREREGISTER &&\n\t\t    OpCode(actions, n+2, maxn) == SWFACTION_SETMEMBER ) ||\n\t\t   (OpCode(actions, n-1, maxn) == SWFACTION_STOREREGISTER &&\n\t    \t    OpCode(actions, n+1, maxn) == SWFACTION_SETMEMBER &&\n\t\t    OpCode(actions, n+2, maxn) == SWFACTION_PUSH ) ||\n\t\t   (OpCode(actions, n-1, maxn) == SWFACTION_PUSH &&\n\t\t    OpCode(actions, n+1, maxn) == SWFACTION_SETMEMBER)  ||\n\t\t   (OpCode(actions, n-3, maxn) == SWFACTION_GETMEMBER &&\n\t\t    OpCode(actions, n-2, maxn) == SWFACTION_PUSH &&\n\t\t    OpCode(actions, n-1, maxn) == SWFACTION_GETMEMBER &&\n\t\t    OpCode(actions, n+1, maxn) == SWFACTION_SETMEMBER &&\n\t    \t((struct SWF_ACTIONPUSH *)&actions[n-2].SWF_ACTIONRECORD)->NumParam >= 4 \n\t    \t\t/* 4: a pair of get/set - FIXME: add more analysis about stack here */))\n\t\t{\t\t// incr/decr object variables with side effects\n\t\t\tis_postop= (OpCode(actions, n+1, maxn) == SWFACTION_SETMEMBER)?1:0;\n\t\t\tif (is_postop)\n\t\t\t\tvar = newVar2(getString(var),dblop);\n\t\t\telse\n\t\t\t\tvar = newVar2(dblop,getString(var));\n\t\t\tif (is_postop && OpCode(actions, n-1, maxn) == SWFACTION_PUSH) \n\t\t\t\tpop();\n\t\t\tif(OpCode(actions, n+1, maxn) == SWFACTION_GETMEMBER) \n\t\t\t\tpop();\n\t\t\t\n\t\t\tpop();\n\t\t\tpop();\n\t\t\tvar->Type=12;\t// to be quiet later in ...SETMEMBER()\n\t\t\tregs[0]=var;\t// FIXME: r0 perhaps a ming special\n\t\t\tpush(var);\n\t\t\tpush(var);\n\t\t\tpush(var);\n\t\t\n\t\t\tif (is_postop && OpCode(actions, n-1, maxn) == SWFACTION_PUSH ) \n\t\t\t\tpush(var);\n\t\t\tif (is_postop && OpCode(actions, n-1, maxn) == SWFACTION_GETMEMBER ) \n\t\t\t\tpush(var);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(OpCode(actions, n-1, maxn) == SWFACTION_PUSH &&\n\t\t\t   OpCode(actions, n+1, maxn) == SWFACTION_STOREREGISTER &&\n\t\t\t   regs[actions[n+1].SWF_ACTIONSTOREREGISTER.Register]->Type == PUSH_VARIABLE)\n\t\t\t{\n\t\t\t\tvar = newVar2(dblop,getString(var));\n\t\t\t\tif ((OpCode(actions, n+2, maxn) == SWFACTION_POP \n\t\t\t\t     && actions[n-1].SWF_ACTIONPUSH.NumParam==1) \n\t\t\t\t    || OpCode(actions, n+3, maxn) == SWFACTION_POP)\n\t\t\t\t{\n\t\t\t\t\tvar->Type=11;\t// later print inc/dec\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar->Type=12;\t// later be quiet in ..STOREREGISTER()\n\t\t\t\t\tif (actions[n-1].SWF_ACTIONPUSH.NumParam>1) \n\t\t\t\t\t{\n\t\t\t\t\t\tpop();\n\t\t\t\t\t\tpush(var);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpush(var);\n\t\t\t}\n\t\t\telse\t\t// fallback to old incr/decr code\n\t\t\t{\t\t// FIXME: this is bad designed for handling side effect code\n\t\t\t\tINDENT\t//        like post-incrementing a function argument etc.\n\t\t\t\tdecompilePUSHPARAM(var,0);\n\t\t\t\tputs(dblop);\n\t\t\t\tprintln(\";\");\n\t\t\t\tpush(var);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileSTOREREGISTER(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *data;\n\tOUT_BEGIN2(SWF_ACTIONSTOREREGISTER);\n\tdata=peek();\n\n\tif (!regs[sact->Register] || sact->Register==0 )\t// ===internal===\n\t{\n\t\tregs[sact->Register] = data;\n\t}\n\telse\t\t\t\t\t\t// ===user visible level===\n\t{\n\t\tif ( regs[sact->Register]->Type == PUSH_VARIABLE) // V7: a named function parameter in register\n\t\t{\t\t\t\t\t\t// V7: a local var in register\n\t\t\tif (data->Type==12)\n\t\t\t\tdata->Type = PUSH_VARIABLE;\t\t\t// do nothing, but only once\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar *l=getName(regs[sact->Register]);\n\t\t\t\tchar *r=getName(data);\n\t\t\t\tif (strcmp(l,r))\n\t\t\t\t{\n\t\t\t\t\tINDENT\n\t\t\t\t\tif (data->Type==11)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintln(\"%s;\", r);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%s = \",l);\n\t\t\t\t\t\tdecompilePUSHPARAM(data,1);\n\t\t\t\t\t\tprintln(\";\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileNEWOBJECT(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *obj, *nparam;\n\tobj = pop();\n\tnparam=pop();\n\tpush(newVar_N(\"new \",\"\",getName(obj),\"(\", nparam->p.Integer,\")\"));\n\treturn 0;\n}\n\nstatic int\ndecompileNEWMETHOD(int n, SWF_ACTION *actions, int maxn)\n{\n\tchar *t;\n\tstruct SWF_ACTIONPUSHPARAM *meth, *nparam, *obj;\n\tmeth = pop();\n\tobj = pop();\n\tnparam=pop();\n\n\tt=malloc(strlen( getName(obj) ) +2);\n\tstrcpy(t,getName(obj));\n\tstrcat(t,\".\");\n\n\tpush(newVar_N(\"new \",t,getName(meth),\"(\", nparam->p.Integer,\")\"));\n\tfree (t);\n\treturn 0;\n}\n\n\nstatic int\ndecompileGETMEMBER(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *obj, *mem, *var;\n\tchar *vname, *varname,*memname;\n\tint len;\n\n\tmem=pop();\n\tvar=pop();\n\tvarname=getName(var);\n\tmemname=getName(mem);\n#ifdef DEBUG\n\tprintf(\"*getMember* varName %s (type=%d)  memName=%s (type=%d)\\n\",\n\t       varname,var->Type, memname,mem->Type);\n#endif\n\tlen = strlen(varname)+strlen(memname);\n\tif (mem->Type == PUSH_INT || mem->Type == PUSH_DOUBLE || mem->Type == PUSH_VARIABLE\n\t    || mem->Type == PUSH_REGISTER || mem->Type == 12 )\n\t{\n\t\tvname = malloc(len+3);\n\t\tstrcpy(vname,varname);\n\t\tstrcat(vname,\"[\");\n\t\tstrcat(vname,memname);\n\t\tstrcat(vname,\"]\");\n\t}\n\telse\n\t{\n\t\tvname = malloc(len+2);\n\t\tstrcpy(vname,varname);\n\t\tstrcat(vname,\".\");\n\t\tstrcat(vname,memname);\n\t} \n\tobj = newVar(vname);\n\tpushvar(obj);\n\n\treturn 0;\n}\n\n\nstatic int\ndecompileSETMEMBER(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *val, *var, *obj;\n\tval = pop();\n\tvar = pop();\n\tobj = pop();\n\n#ifdef DEBUG\n\tprintf(\"*SETMember* varName %s (type=%d)  objName=%s (type=%d)\\n\",getName(var),var->Type, getName(obj),obj->Type);\n#endif\n\tif (obj->Type == 12)\t\t\t\t/* do nothing: inline inc/dec using side effect */\n\t{\n\t\tobj->Type = PUSH_VARIABLE;\t\t/* ...but only once */\n\t\treturn 0;\n\t}\n\tINDENT\n\tif (obj->Type == 11)\t\t\t\t/* simply output variable and inc/dec op */\n\t{\n\t\tdecompilePUSHPARAM(obj,0);\n\t\tprintln(\";\");\n\t\treturn 0;\n\t}\n\n\tdecompilePUSHPARAM(obj,0);\n\tif (var->Type == PUSH_INT || var->Type == PUSH_DOUBLE || var->Type == PUSH_VARIABLE\n\t    || var->Type == PUSH_REGISTER || var->Type == 12 )\n\t{\n\t\tputs(\"[\");\n\t}\n\telse\n\t{\n\t\tputs(\".\");\n\t\tif (OpCode(actions, n-1, maxn) == SWFACTION_STOREREGISTER)\n\t\t{\n\t\t\tstruct SWF_ACTIONSTOREREGISTER *sactv2 = (struct SWF_ACTIONSTOREREGISTER*)&actions[n-1];\n\t\t\tif (sactv2->Register==0)\n\t\t\t\tregs[0]=newVar3(getName(obj),\".\",getName(var));\t\t// easter 07: some sugar for mtc et al.\n\t\t}\n\t}\n\tdecompilePUSHPARAM(var,0);\n\tif (var->Type == PUSH_INT || var->Type == PUSH_DOUBLE || var->Type == PUSH_VARIABLE\n\t\t|| var->Type == PUSH_REGISTER || var->Type == 12 )\n\t{\n\t\tputs(\"]\");\n\t}\n\tprintf(\" = \" );\n\n\n\tif ( OpCode(actions, n-1, maxn) == SWFACTION_STOREREGISTER ) {\n\t\tstruct SWF_ACTIONSTOREREGISTER *sr =\n\t\t\t(struct SWF_ACTIONSTOREREGISTER*)&actions[n-1];\n\t\tprintf(\"R%d\", sr->Register);\n\t}\n\telse if (val->Type != PUSH_VARIABLE) {\n\t\t/* later it will be a switch{} */\n\t\tdecompilePUSHPARAM(val,1);\n\t}\n\telse {\n\t\tdecompilePUSHPARAM(val,0);\n\t}\n\tprintln(\";\");\n\treturn 0;\n}\n\nstatic int\ndecompileGETVARIABLE(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *var;\n\n\tvar = pop();\n#ifdef DEBUG\n\tprintf(\"*GETVariable* varName %s (type=%d)\\n\",getName(var),var->Type);\n#endif\n\tif (var->Type == PUSH_VARIABLE)\n\t\tpushvar(newVar3(\"eval(\",getName(var),\")\"));\n\telse\n\t\tpushvar(newVar(getName(var)));\n\n\treturn 0;\n}\n\nstatic int\ndecompileSETVARIABLE(int n, SWF_ACTION *actions,int maxn,int islocalvar)\n{\n\tstruct SWF_ACTIONPUSHPARAM *val, *var;\n\n\tval = pop();\n\tvar = pop();\n\tif (val->Type!=12)\n\t{\n\t\tINDENT\n\t}\n#ifdef DEBUG\n\tprintf(\"*SETVariable* varName %s (type=%d)  valName=%s (type=%d)\\n\",\n\t       getName(var),var->Type, getName(val),val->Type);\n#endif\n\tif (val->Type!=12 && islocalvar)\n\t{\n\t\tputs(\"var \");\n\t}\n\tif (gIndent<0)\t/* the ENUM workaround:  */\n\t{\t\t\t/* in \"for (xx in yy) { }\" we need xx, but nothing else */\n\t\tputs(getName(var));\n\t\treturn 0;\n\t}\n\n\n\tswitch (val->Type)\n\t{\n\tcase 10:\t\n\t\tputs(getName(var));\t\t// Variable (NEVER as string)\n\t\tprintf(\" = \" );\n\t\tdecompilePUSHPARAM(val,0);\n\t\tprintln(\";\");\n\t\tbreak;\t\t\n\tcase 11:\t\t\t\t/* simply output variable and inc/dec op */\n\t\tputs(getName(val));\n\t\tprintln(\";\");\n\t\tbreak;\n\tcase 12:\t\t\t\t/* do nothing: inline increment/decrement (using side effect only) */\n\t\tval->Type = PUSH_VARIABLE;     \t\t// but print next time  e.g. in y=++x;\n\t\tbreak;\n\tdefault:\t\n\t\tputs(getName(var));\n\t\tprintf(\" = \" );\n\t\tdecompilePUSHPARAM(val,1);\t// for certain types parameter 1 does not care\n\t\tprintln(\";\");\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileRETURN(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *var=pop();\n\tINDENT\n\tprintf(\"return \");\n\tif (var->Type== PUSH_REGISTER && var->p.RegisterNumber==0)\t/* REGISTER 0 used as helper variable */\n\t\tputs(getName(regs[0]));\n\telse\n\t\tdecompilePUSHPARAM(var,1);                                                                                             \n\tprintln(\";\");\n\treturn 0;\n}\n\nstatic int\ndecompileJUMP(int n, SWF_ACTION *actions, int maxn)\n{\n\tint i=0,j=0;\n\tint offSave;\n\tstruct SWF_ACTIONIF *sactif;\n\tOUT_BEGIN2(SWF_ACTIONJUMP);\n\tsactif=NULL;\n\n\tif(isLogicalOp(n+1, actions, maxn) ||\n\t   (OpCode(actions, n+1, maxn) == SWFACTION_PUSH && isLogicalOp(n+2, actions, maxn)))\n\t{\n\t\t/* Probably the start of a do {} while(), so skip it */\n\t\treturn 0;\n\t}\n\n\t/* Probably the end of a switch{}, so skip it */\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t\treturn 1;\n\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_JUMP) \n\t{\n\t\tif (actions[n+1].SWF_ACTIONJUMP.BranchOffset==0)\n\t\t\treturn 1;\n\t}\n\n\tfor(i=0; n + 1 + i < maxn && (actions[(n+1)+i].SWF_ACTIONRECORD.Offset < (actions[n+1].SWF_ACTIONRECORD.Offset+actions[n ].SWF_ACTIONJUMP.BranchOffset)); i++)\n\t{\n#if 0\n\t\tprintf(\"/* for PART3 OP 0x%x */\\n\",actions[n+1+i].SWF_ACTIONRECORD.ActionCode);\n#endif\n\t\t; // NOOP\n\t}\n\n\tif (i)\n\t{\n\t\tfor (j=0; n+j+i<maxn; j++)\n\t\t{\n#if 0\n\t\t\t printf(\"/* FOR part2 OP 0x%x */\\n\",actions[n+i+j].SWF_ACTIONRECORD.ActionCode)\n\t\t\t// at least one should push on stack\n#endif\n\t \n\t\t\tif (OpCode(actions, n+i+j, maxn) == SWFACTION_IF)\n\t\t\t{\n\t\t\t\tsactif = (struct SWF_ACTIONIF *)&(actions[n+i+j]);\n\t\t\t\t/* chk whether last jump does lead us back to start of loop */\n\t\t\t\tif (sactif->Actions[sactif->numActions-1].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP\n\t\t\t\t    && sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.BranchOffset+\n\t\t\t\t    sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.Offset==\n\t\t\t\t    actions[n].SWF_ACTIONRECORD.Offset )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsactif=NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sactif)\n\t{\n\t\tINDENT\n\t\tputs(\"while(\");\n\t\tdecompileActions(j-1, &actions[n+1+i], gIndent);\n\t\tputs(getName(pop()));\n\t\tprintln(\"){         /* original FOR loop rewritten to WHILE */\");\n\t\toffSave=offseoloop;\n\t\tif (n+i+j+1<maxn)\t\t\t\t\t\t// see part2 above\n\t\t\toffseoloop=actions[n+i+j+1].SWF_ACTIONRECORD.Offset;\n\t\telse\n\t\t\toffseoloop=actions[n+i+j].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(sactif->numActions-1, sactif->Actions,gIndent+1);\n\t\tdecompileActions(i, &actions[n+1], gIndent+1);\n\t\toffseoloop=offSave;\n\t\tINDENT\n\t\tprintln(\"};\");\n\t\treturn i+j; \n\t}\n\t\n\tif (sact->BranchOffset>0)\n\t{\n\t\tif ( stackVal(n,actions) == 1 && n+1==maxn)\n\t\t{\t// leaving block @last op with value on stack: a return x;\n\t\t\treturn decompileRETURN(n, actions,maxn);\n\t\t}\n\t\tif (n+2 < maxn && OpCode(actions, n+1, maxn) == SWFACTION_PUSH && \n\t\t\tactions[n+2].SWF_ACTIONRECORD.Offset == actions[n+1].SWF_ACTIONRECORD.Offset+sact->BranchOffset)\n\t\t{\n\t\t\treturn 1; \t// jump to short to be a 'break': but an internal jump over a push\n\t\t}\t\t\t// to do: add some control flow analysis\n\t\t\n\t\tINDENT\n\t\t\n\t\tif (offseoloop==actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5)\n\t\t\tputs(\"break;\" );\n\t\telse\n\t\t\tputs(\"return;\" );\n\t\t\n\t\tprintln(\"\\t\\t\\t// offs_end_of_loop=%d  offs_jmp_dest=%d\",\n\t\t        offseoloop, actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5);\n\t}\n\telse\n\t{\n\t\tif (sact->BranchOffset<0)\n\t\t{\n\t\t\tINDENT\n\t\t\tprintln(\"continue;     /*------*/\");\n\t\t}\n\t}\n\t/* error(\"Unhandled JUMP\"); */\n\treturn 0;\n}\n\nstatic int\ndecompileDEFINELOCAL2(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *var;\n\n\tINDENT\n\tvar = pop();\n\tputs(\"var \");\n\tputs(getName(var));\n\tprintln(\";\");\n\n\treturn 0;\n}\n\nstatic int \ndecompileENUMERATE(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n\tint i=0;\n\twhile (i < maxn && i < 5 && OpCode(actions, n+i, maxn))\n\t\ti++;\n\t\n\tINDENT  \n\tprintln(\"/* a for-var-in  loop should follow below: */\" );\n\treturn i-1;\t\t// preserve some code for decompileIF()... \n} \t\t\t\t// ... and let decompileIF() do all the dirty work ;-)\n\n\n#ifdef DECOMP_SWITCH\n\n// [recursive] estimate size of buffer needed for decompiling 'switch' \n// [ only call by decompileIF() ]\n//\nstatic int\ncountAllSwitchActions (union SWF_ACTION *actions, union SWF_ACTION *pre)\n{\n\tint i,j=1;\n\tif (actions->SWF_ACTIONRECORD.ActionCode==SWFACTION_IF && pre->SWF_ACTIONRECORD.ActionCode==SWFACTION_STRICTEQUALS )\n\t{\n\t\tfor(i=0; i < ((struct SWF_ACTIONIF*)actions)->numActions; i++)\n\t\t{\n\t\t\tj+=countAllSwitchActions(&((struct SWF_ACTIONIF*)actions)->Actions[i],pre);\n\t\t\tpre=&((struct SWF_ACTIONIF*)actions)->Actions[i];\n\t\t}\n\t}                  \n\treturn j;\n}\n\n\n// [recursive] copy all actions in a 'flat' buffer by \n// unpackung all if-actions that are part of the switch operation\n// [ only call by decompileIF() ]\n//\nstatic union SWF_ACTION *\ngetAllSwitchActions(union SWF_ACTION *dest, union SWF_ACTION *actions, union SWF_ACTION *pre)\n{\n#ifdef DEBUGSWITCH\n\tprintln(\"SWCODE: %p %d %s   %s\",\n\t        dest, actions->SWF_ACTIONRECORD.Offset, \n\t        actionName(actions->SWF_ACTIONRECORD.ActionCode),\n\t        actionName(pre->SWF_ACTIONRECORD.ActionCode));\n#endif\n\n\t*dest++=*actions;\n\tif (actions->SWF_ACTIONRECORD.ActionCode==SWFACTION_IF \n\t    && pre->SWF_ACTIONRECORD.ActionCode==SWFACTION_STRICTEQUALS )\n\t{\n\t\tint i;\n\t\tstruct SWF_ACTIONIF *sactv2 = (struct SWF_ACTIONIF*)actions;\n\t\tfor(i=0; i< sactv2->numActions; i++)\n\t\t{\n\t\t\tdest=getAllSwitchActions(dest,&sactv2->Actions[i],pre);\n\t\t\tpre=&((struct SWF_ACTIONIF*)actions)->Actions[i];\n\t\t}\n\t}\n\treturn dest;\n}\n\n// looks similar other decompileXXXX() but \n// can't called by decompileAction()\n// [ do only call by decompileIF() ]\n//\nstatic int\ndecompile_SWITCH(int n, SWF_ACTION *actions, int maxn, int off1end)\n{\n\tint i,j;\n\tint start;\t\t// base action index for case value and code\n\tint ccsize=0;\t\t// size of code for case value\n\tint cvsize=0;\t\t// size of case value\n\tint maxoff=0;\t\t// action offset AFTER switch\n\tint n_maxoff=0;\t\t// array index of maxoff\n\tint pend=0;\t\t// control pending output\n\tint xsize=0;\t\t// ret val\n\tint jmpsize=0;\t\t// debug helper\n\tint lastoff=0;\t\t// debug helper\n\tint n_firstactions=maxn;// array index of 1st case actions code\n\tint lastcasestart=0;\t// offs where last \"case x:\" begins\n\tchar *defa=\"[last]\";\t// debug helper for early \"default:\" \n\tchar *tmp=NULL;\t\t// helper for pending output\n\tstruct strbufinfo origbuf;\t// pending output buffer\n\tstruct _stack *StackSave;\n\tstruct SWF_ACTIONPUSHPARAM *swcopy,*sw=pop();\n\tstruct SWF_ACTIONPUSHPARAM *compare=pop();\n\tint offSave;\n\tfor (i=0; i<n_firstactions; i++) // seek last op in 1st if\n\t{\n\t\tif (actions[i+1].SWF_ACTIONRECORD.Offset==off1end)\n\t\t{\n\t\t\t// println(\"found #off end first= %d\",i+1);\n\t\t\tif (OpCode(actions, i, maxn) == SWFACTION_JUMP)\n\t\t\t{\n\t\t\t\tmaxoff=actions[i].SWF_ACTIONJUMP.BranchOffset+actions[i].SWF_ACTIONJUMP.Offset+5;\n\t\t\t\tj=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// SanityCheck(decompile_SWITCH,0,\"no jump found where expected\");\n\t\t\t}\n\t\t\tbreak;\n\t\t} \n\t}\n\t\n\tif (!maxoff)\n\t{\n\t\tfor (i=maxn-1;i>=0;i--)\t\t\t// seek from end of block last op of switch{}\n\t\t{\n\t\t\tif (OpCode(actions, i, maxn) == SWFACTION_JUMP && !actions[i].SWF_ACTIONJUMP.BranchOffset)\n\t\t\t{\n\t\t\t\tmaxoff=actions[i].SWF_ACTIONRECORD.Offset+5;\n\t\t\t\tj=2;\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\t}\n\n\tfor (i=0;i<maxn;i++)\t\n\t{\n\t\tif (actions[i].SWF_ACTIONRECORD.Offset>=maxoff)\n\t\t{\n\t\t\tn_maxoff=i;\t\t// part of block is switch\n\t\t\tbreak;\n\t\t}\n\t}\n\t\t\n\tif (!n_maxoff) \n\t\tn_maxoff=maxn;\t\t\t// whole block is switch\n\n\tINDENT\n\tprintln(\"switch( %s ) {\t\t\t// end switch at %d (index %d) / found via meth %d)\",\n\t        getString(sw), maxoff,n_maxoff,j);\n\t\t\n\tpush(sw);\n\tpush(compare);\n\n\ti=1;\n\tdo \t\t\t\t\t// here we go into main loop\n\t{\n\t\tif((OpCode(actions, i, maxn) == SWFACTION_IF\n\t\t   && OpCode(actions, i-1, maxn) == SWFACTION_STRICTEQUALS )\n\t\t   ||(OpCode(actions, i, maxn) == SWFACTION_JUMP\n\t\t   && OpCode(actions, i-1, maxn) == SWFACTION_IF) )\n\t\t{\n\t\t\tstart=i;\n\t\t\twhile (start<maxn \n\t\t\t       && actions[start].SWF_ACTIONRECORD.Offset < actions[i].SWF_ACTIONRECORD.Offset+5+actions[i].SWF_ACTIONJUMP.BranchOffset\n)\t\t\t{\n\t\t\t\tstart++;\t\t// count actions until start of \"case x:\"\n\t\t\t}\n\t\t\tif (n_firstactions==maxn) // if not done store earliest \"case x: \"actions\n\t\t\t{\n\t\t\t\tn_firstactions=start;\t// same as array index\n\t\t\t}\n\n\t\t\tfor (ccsize=0; ccsize+start<n_maxoff; ccsize++)\t// count actions belonging to \"case x:\"\n\t\t\t{\n#ifdef DEBUGSWITCH\n\t\t\t\tprintln(\"in ccsize: ccsize=%d  off=%d %s\",\n\t\t\t\t        ccsize,actions[ccsize+start].SWF_ACTIONRECORD.Offset,\n\t\t\t\t        actionName(OpCode(actions, ccsize+start, maxn)));\n#endif\n\t\t\t\tif (OpCode(actions, ccsize+start, maxn) == SWFACTION_JUMP)\n\t\t\t\t{\n\t\t\t\t\tif (maxoff == actions[ccsize+start].SWF_ACTIONJUMP.Offset+5 + actions[ccsize+start].SWF_ACTIONJUMP.BranchOffset)\n\t\t\t\t\t{\n\t\t\t\t\t\tjmpsize= actions[ccsize+start].SWF_ACTIONJUMP.BranchOffset;\n\t\t\t\t\t\tlastoff= actions[ccsize+start].SWF_ACTIONJUMP.Offset;\n\t\t\t\t\t\tccsize++; // the jmp itself\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n#if USE_LIB\n\t\t\tif (tmp && (start!=pend)) // output pending buffer if neccessary\n\t\t\t{\n\t\t\t\tputs(tmp);\n\t\t\t}\n\t\t\t\n\t\t\tif (tmp)\n\t\t\t{\n\t\t\t\tfree(tmp);\n\t\t\t\ttmp=NULL;\n\t\t\t}\n\t\t\tpend=start;\n#endif\n\t\t\tif (OpCode(actions, i, maxn) == SWFACTION_JUMP)\n\t\t\t{\n\t\t\t\tif (ccsize<=1)\n\t\t\t\t\tbreak;\t// ready\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tINDENT\n\t\t\t\t\tif (actions[start].SWF_ACTIONRECORD.Offset>lastcasestart)\n\t\t\t\t\t\txsize+=ccsize;        \n\t\t\t\t\telse\n\t\t\t\t\t\tdefa=\"[early]\";\n\t\t\t\t\t\tprintln(\"default:\t\t\t// at %d %s start=%d ccsize=%d\",\n\t\t\t\t\t\t        actions[start].SWF_ACTIONRECORD.Offset,defa, start, ccsize);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tINDENT\n\t\t\t\txsize=ccsize;\n\t\t\t\tlastcasestart=actions[start].SWF_ACTIONRECORD.Offset;\n\t\t\t\tprintln(\"case %s:\t\t\t// at %d  start=%d ccsize=%d jmp=%d+%d+5\",\n\t\t\t        getString(pop()), lastcasestart, start, ccsize, lastoff,jmpsize);\n\t\t\t\tswcopy=pop();\n\t\t\t\t//   SanityCheck(decompile_SWITCH,!strcmp(getName(swcopy),getName(sw)),\"sw0 != sw\");\n\t\t\t}\n\n#if USE_LIB\n\t\t\torigbuf=setTempString(); // switch to temp buffer\n#endif\n\t\t\tStackSave=Stack;\n\t\t\toffSave=offseoloop;\n\t\t\toffseoloop=maxoff;\n\t\t\tdecompileActions( ccsize, &actions[start],gIndent+1);\n\t\t\toffseoloop=offSave;\n\t\t\tStack=StackSave;\n#if USE_LIB\n\t\t\ttmp=switchToOrigString(origbuf);\n#endif\n\n\t\t\tif (OpCode(actions, i, maxn) == SWFACTION_JUMP)\t\t// after \"default:\"\n\t\t\t{\n\t\t\t\tbreak;     \t\t\t\t\t\t\t// ready\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (OpCode(actions, i+1, maxn) != SWFACTION_JUMP) \t// not before \"default:\" or end\n\t\t\t\t{\n\t\t\t\t\ti++; // the 'if' itself\n\t\t\t\t\tcvsize=0;\n\t\t\t\t\twhile (i+cvsize < n_firstactions \n\t\t\t\t\t       && OpCode(actions, i+cvsize, maxn) != SWFACTION_STRICTEQUALS)\n\t\t\t\t\t{\n#ifdef DEBUGSWITCH\n\t\t\t\t\t\tprintln(\"in  cvsize=%d  %d %s\",\n\t\t\t\t\t\t        cvsize, actions[i+cvsize].SWF_ACTIONRECORD.Offset,\n\t\t\t\t\t\t        actionName(OpCode(actions, i+cvsize, maxn)));\n#endif\n\t\t\t\t\t\t\tcvsize++;\t// count \"case X:\" code size\n\t\t\t\t\t}\n\t\t\t\t\tdecompileActions( cvsize, &actions[i],gIndent+1); // at least one push on stack expected\n\t\t\t\t\ti+=cvsize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (++i < n_firstactions);\n\n#if USE_LIB\n\tif (tmp)\n\t{\n\t\tputs(tmp);\t\t// print last pending output\n\t\tfree(tmp);\n\t}\n#endif\t\n\tINDENT\n\tprintln(\"}\t\t\t\t\t// switch ret value =%d\",xsize);\n\treturn xsize;\n}\n#endif\n\nstatic int\ndecompileIF(int n, SWF_ACTION *actions, int maxn)\n{\n\tint offSave;\n\tint j,i=0;\n\tstruct strbufinfo origbuf;\n\tOUT_BEGIN2(SWF_ACTIONIF);\n\n        if (sact->numActions < 1) {\n            return 0;\n        }\n\n\t/*\n\t* IF is used in various way to implement different types\n\t* of loops. We try to detect these different types of loops\n\t* here.\n\t*/\n\n#ifdef STATEMENT_CLASS\n\tif((OpCode(actions, n-1, maxn) == SWFACTION_LOGICALNOT) &&\n\t   (OpCode(actions, n-2, maxn) == SWFACTION_LOGICALNOT) &&\n\t   (OpCode(actions, n-3, maxn) == SWFACTION_GETVARIABLE) &&\n\t   (OpCode(actions, n-4, maxn) == SWFACTION_PUSH) ) \n\t{\n\t    /* It's really a class definition */\n\t\tINDENT\n\t\tputs(\"class \");\n\t\tdecompilePUSHPARAM(newVar(getName(pop())),0);\n\t\tprintln(\" {\" );\n\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\treturn 0;\n\t}\n\n\tif( \n\t   (OpCode(actions, n-1, maxn) == SWFACTION_LOGICALNOT) &&\n\t   (OpCode(actions, n-2, maxn) == SWFACTION_LOGICALNOT) &&\n\t   (OpCode(actions, n-3, maxn) == SWFACTION_GETMEMBER) &&\n\t   (OpCode(actions, n-4, maxn) == SWFACTION_PUSH) ) \n\t{\n\t    /* It's really a class definition */\n\t\tINDENT\n\t\tprintln(\" {\");\n\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\treturn 0;\n\t}\n#endif\n\t/*\n\t * do {} while() loops have a JUMP at the end of the if clause\n\t * that points to a JUMP above the IF statement.\n\t */\n\tif(n && isLogicalOp(n-1, actions, maxn) &&\n\t   (sact->Actions[sact->numActions-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_JUMP) &&\n\t   ( (sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.Offset +\n\t      sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset) < actions[n].SWF_ACTIONRECORD.Offset) &&\n\t      isLogicalOp(sact->numActions-2, sact->Actions, maxn) ) \n\t{\n\t\tINDENT\n\t\tprintln(\"do {\");\n\t\toffSave=offseoloop;\n\t\toffseoloop=actions[n].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(sact->numActions-1, sact->Actions,gIndent+1);\n\t\toffseoloop=offSave;\n\t\tINDENT\n\t\tputs(\"while( \");\n\t\tputs(getName(pop()));\n\t\tputs(\");\");\n\t\treturn 0;\n\t}\n\n\t/* ak,2006\n\t * lots of \"do {} while()\" have simply a CONDITIONED JUMP back at the end of the loop\n\t */\n\tif( actions[n].SWF_ACTIONJUMP.BranchOffset < 0 ) \n\t{\n\t\tINDENT\n\t\tprintln(\"do {                  /* 2nd type */ \");\n\t\toffSave=offseoloop;\n\t\toffseoloop=actions[n  ].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\toffseoloop=offSave;\n\t\tINDENT\n\t\tputs(\"} while( \");\n\t\tputs(getName(pop()));\n\t\tprintln(\");\");\n\t\treturn 0;\n\t}\n\n\tj=0;\n\twhile (OpCode(actions, n-j, maxn) != SWFACTION_ENUMERATE  && \n\t        OpCode(actions, n-j, maxn) != SWFACTION_ENUMERATE2 && j<n && j<5) \n\t{\n\t\tj++;\t\t// check for a pending ENUMERATE\n\t}\n\t\n\tif ((OpCode(actions, n-j, maxn) == SWFACTION_ENUMERATE ||\n\t     OpCode(actions, n-j, maxn) == SWFACTION_ENUMERATE2 ) && \n\t      OpCode(actions, n-j+1, maxn) == SWFACTION_STOREREGISTER )\n\t{\n\t\tstruct SWF_ACTIONPUSHPARAM *var;\n\t\tint x;\n\t\tvar = pop();\n\t\tINDENT\n\t\tputs(\"for ( \");\n\t\t// check for an usual special case w register Rx\n\t\tif (sact->Actions[1].SWF_ACTIONRECORD.ActionCode == SWFACTION_STOREREGISTER)\n\t\t{\n\t\t\tstruct SWF_ACTIONSTOREREGISTER *sactv2 = (struct SWF_ACTIONSTOREREGISTER*)&sact->Actions[1];\n\t\t\tputs(\"var \");\n\t\t\tputs(getName(regs[sactv2->Register]));\n\t\t\tx=3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdecompileActions( 2 , sact->Actions,-1);   /* -1 == the ENUM workaround */\n\t\t\tx=2;\n\t\t}\n\t\tputs(\" in \");\n\t\tputs(getName(var));\n\t\tprintln(\" ) {\");\n\t\tif(n+1 >= maxn)\n\t\t{\n\t\t\tSWF_warn(\"Warning: %s:%i: something is wrong here\\n\", __FILE__, __LINE__);\n\t\t}\n\t\telse \n\t\t{\n\t\t\toffSave=offseoloop;\n\t\t\toffseoloop=actions[n+1].SWF_ACTIONRECORD.Offset;\n\t\t\tdecompileActions(sact->numActions-1-x, &sact->Actions[x],gIndent+1);\n\t\t\toffseoloop=offSave;\n\t\t}\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * while() loops have a JUMP at the end of the if clause that jumps backwards\n\t * But also \"continue\" statements could jump backwards.\n\t */\n\t\n\tif( isLogicalOp(n-1, actions, maxn) &&\n\t    ( (sact->Actions[sact->numActions-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_JUMP) &&\n\t       sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset < 0) ) \n\t{\n\t\tif(0)\t    dumpRegs();\n\t\tINDENT\n\t\t/* if on a level >0 we can check for any outer loop \n\t\t   To do: get the level on a better way than using gIndent */\n\t\tif (gIndent\t\n\t\t    && OpCode(actions, maxn-1, maxn) == SWFACTION_JUMP\n\t  \t    && actions[maxn-1].SWF_ACTIONJUMP.Offset+actions[maxn].SWF_ACTIONJUMP.BranchOffset==\n\t               sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.Offset+sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset)\n\t\t{      \n\t\t   /* this jump leads from a block to start of a loop on outer block:\n\t\t       it is an 'if' later followed by last action 'continue' */\n\t\t   SWF_warn(\"WARNING: this might be wrong (%s:%i)\\n\", __FILE__, __LINE__);\n\t\t   puts(\"if ( \");\n\t\t   puts(getName(pop()));\n\t\t   println(\" ) {\");\n\t\t   decompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\t}\n\t\telse\t/* while(){}  as usual */\n\t\t{\n\t\t\tputs(\"while( \");\n\t\t\tputs(getName(pop()));\n\t\t\tprintln(\" ) {\");\n\t\t\toffSave=offseoloop;\n\t\t\toffseoloop=actions[n+1].SWF_ACTIONRECORD.Offset;\n\t\t\tdecompileActions(sact->numActions-1, sact->Actions,gIndent+1);\n\t\t\toffseoloop=offSave;\n\t\t}\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\treturn 0;\n\t}\n\t{ // WTF ???\n#define SOME_IF_DEBUG 0\t/* coders only */\n\t\tint has_else_or_break= ((sact->Actions[sact->numActions-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_JUMP) &&\n\t\t\t(sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset > 0 )) ? 1:0;\n\t\tint has_lognot=(OpCode(actions, n-1, maxn) == SWFACTION_LOGICALNOT) ? 1:0;\n\t\tint else_action_cnt=0,is_logor=0,is_logand=0,sbi,sbe;\n\n\t\t/* before emitting any \"if\"/\"else\" characters let's check \n\t\t\tfor a ternary operation  cond?a:b \n\t\t*/\n\t\tif (has_else_or_break)\n\t\t{\n\t\t\tint limit=actions[n+1].SWF_ACTIONRECORD.Offset + sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset;\n\t\t\t/* Count the number of action records that are part of\n\t\t\t * the else clause, and then decompile only that many.\n\t\t\t */\n\t\t\tfor(else_action_cnt=0;\n\t\t\t    else_action_cnt+n+1<maxn && actions[n+1+else_action_cnt].SWF_ACTIONRECORD.Offset < limit;\n\t\t\t    else_action_cnt++)\n\t\t\t{\n#if SOME_IF_DEBUG\n\t\t\t\tprintln(\"/* ELSE OP 0x%x at %d*/\", OpCode(actions, n+1+else_action_cnt, maxn),\n\t\t\t\tactions[n+1+else_action_cnt].SWF_ACTIONRECORD.Offset)\n#endif\n\t\t\t\t;\n\t\t\t}  \n\t\t}\n\t\ti=else_action_cnt; \t\t// =return value\n\t\tsbi=stackVal (sact->numActions-1,sact->Actions);\n\t\tsbe=stackVal (else_action_cnt,&actions[n+1]);\n\n\t\t// check against opcodes we do not expect in a ternary operation\n\t\tif (sbi==1 && sbe==1)\n\t   \t{\n\t\t\tfor (j=0;j<sact->numActions-1;j++)\n\t\t\t{\n\t\t\t\tif (sact->Actions[j].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP) // perhaps more ops\n\t\t\t\t{\n\t\t\t\t\tsbi=i=has_else_or_break=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0;j<else_action_cnt;j++)\n\t\t\t{\n\t\t\t\tif (OpCode(actions, n+j, maxn) == SWFACTION_JUMP) // perhaps more ops\n\t\t\t\t{\n\t\t\t\t\tsbe=i=has_else_or_break=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if SOME_IF_DEBUG\n\t\tprintf(\"sbi=%d   sbe=%d\\n\", sbi,sbe);\n#endif\n\t\tif (sbi==1 && sbe==1)\n\t\t{\n#if SOME_IF_DEBUG\n\t\t\tprintln(\"/* ****Found ternary ternary operation  \\\"cond ? a : b\\\"    **** */\");\n\t\t\tprintf(\"If   Actions=%d\\n\",sact->numActions-1);\n\t\t\tprintf(\"Else Actions=%d\\n\",else_action_cnt);\n#endif\n\t\t\tstruct strbufinfo origbuf;\n#if USE_LIB\n\t\t\torigbuf=setTempString();\t/* switch to a temporary string buffer */\n#endif\n\t\t\tputs(\"(\");\n\t\t\tputs(getName(pop()));\n\t\t\tputs(\" ? \");\n\t\t\tdecompileActions(else_action_cnt  , &actions[n+1],0);\n\t\t\tputs(getName(pop()));\n\t\t\tputs(\" : \");\n\t\t\tdecompileActions(sact->numActions-1, sact->Actions,0);\n\t\t\tputs(getName(pop()));\n\t\t\tputs(\")\");\n#if USE_LIB\n\t\t\tpush (newVar(dcgetstr()));\t/* push for later assignment */\n\t\t\tsetOrigString(origbuf);\t\t/* switch back to orig buffer */\n#else\n\t\t\tpush (newVar(\"/* ternary op: see code above */\"));\n#endif\n\t\t} \n\t\telse\n\t\t{\n\t\t/* at this point let's check for conditioned jumps that are NOT 'if':\n\t      \tcurrently that is code for the locical operations  && and ||\n\t   \t*/\n\t\t\tif (OpCode(actions, n-1, maxn) == SWFACTION_PUSHDUP)\n\t\t\t\tis_logor=1;\n\t\t\t\n\t\t\tif (OpCode(actions, n-2, maxn)== SWFACTION_PUSHDUP\n\t\t\t    && OpCode(actions, n-1, maxn) == SWFACTION_LOGICALNOT)\n\t\t\t{\n\t\t\t\tis_logand=1;\n\t\t\t}\n\n\t\tif (is_logor || is_logand)    \n\t\t{\n#if SOME_IF_DEBUG\n\t\t\tprintln(\"\");\n\t\t\tprintln(\"/* detected LOGICAL %s: %d actions*/\", is_logor ? \"OR\":\"AND\",sact->numActions);\n#endif\n#if USE_LIB\n\t\t\torigbuf=setTempString();\t/* switch to a temporary string buffer */\n#endif\n\n\t\t\tputs(getName(pop()));\t/* get left side of logical or */\n\t\t\tputs(is_logor ? \" || \":\" && \");\n\t\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\t\tputs(getName(pop()));\t/* get right side of logical or */\n#if USE_LIB\n\t\t\tpush(newVar(dcgetstr()));\n\t\t\tsetOrigString(origbuf);\t/* switch back to orig buffer */\n#else\n\t\t\tpush (newVar(\"/* see logical term lines above */\")); \n#endif\n\t\t\treturn 0;\n\t\t}\n#ifdef DECOMP_SWITCH\n\t\tif ( OpCode(actions, n-1, maxn) == SWFACTION_STRICTEQUALS\n\t\t     && check_switch(sact->Actions[0].SWF_ACTIONRECORD.ActionCode) )\n\t\t{\n\t\t\tunion SWF_ACTION *xact,*xact0;\n\t\t\tfor(i=n-1,j=0; i< maxn ;i++)\t// n-1 due adding 1st SWFACTION_STRICTEQUALS in buffer\t\n\t\t\t{\n\t\t\t\tj+=countAllSwitchActions(&actions[i],&actions[i-1]); \t\t// FIRST count size of code\n\t\t\t}\n\t\t\txact0=xact = (union SWF_ACTION *) calloc (j,sizeof (SWF_ACTION));\n\t\t\tINDENT\n\t\t\tprintln(\"// checking %d actions for switch(){}\",j);\n\t\t\tfor(i=n-1; i< maxn ;i++)\n\t\t\t{\n\t\t\t\txact=getAllSwitchActions(xact,&actions[i],&actions[i-1]);\t// SECOND copy into xtra buffer\n\t\t\t}\n\t\t\tj=decompile_SWITCH(0,xact0,j,actions[n+1].SWF_ACTIONRECORD.Offset);\t// THIRD decompile xtra buffer\n\t\t\tfree(xact0);\n\t\t\treturn j;\n\t\t}\n#endif\n\t\t/* it seems we have a found the REAL 'if' statement,\n\t\tso it's right time to print the \"if\" just NOW!\n\t\t*/\n\t\tINDENT\n\t\tputs(\"if( \");\n\t\tputs(getName(pop()));\t/* the condition itself */\n\t\tprintln(\" ) {\");\n\t\tif ( has_else_or_break )\n\t\t{\n\t\t\tint limit=actions[n+1].SWF_ACTIONRECORD.Offset + sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset;\n\t\t\t// limit == dest of jmp == offset next op after 'if' + jumpdist at end of 'if'\n\t\t\tint lastopsize=actions[maxn-1].SWF_ACTIONRECORD.Length;\n\t\t\tif (OpCode(actions, maxn-1, maxn) == SWFACTION_IF)\n\t\t\t\tlastopsize+=actions[maxn-1].SWF_ACTIONIF.BranchOffset + 3; /* +3 see parser.c: \"Action + Length bytes not included in the length\" */\n\t\t\t\n\t\t\tif (offseoloop \n\t\t\t    &&  ! (has_lognot\n\t\t\t    && OpCode(actions, n-2, maxn) == SWFACTION_EQUALS2 \n\t\t\t    && OpCode(actions, n-3, maxn) == SWFACTION_PUSH\n\t\t\t    && OpCode(actions, n-4, maxn) == SWFACTION_PUSHDUP)\n\t\t\t    && limit > actions[maxn-1].SWF_ACTIONRECORD.Offset+lastopsize)\n\t\t\t{\n\t\t\t\t/* the jump leads outside this limit, so it is a simple 'if'\n\t\t\t\twith a 'break' or 'return' at the end, and there is NO else clause.\n\t\t\t\t*/  \n\t\t\t\tINDENT\n\t\t\t\tprintln(\"// offs_endjump_dest=%d  offs_after_blk %d\",\n\t\t\t\t        limit, actions[maxn-1].SWF_ACTIONRECORD.Offset+lastopsize);\n\t\t\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\t\t\ti=0;\t\t\t/* found break/return but no else and thus return 0 */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* There is an else clause also! \n\t\t\t\t(action counter is set above)\n\t\t\t\t*/\n\t\t\t\tstruct _stack *StackSave=Stack;\t/* decompile if and else blocks at same stack base */\n\t\t\t\tif  (has_lognot)\n\t\t\t\t{\n\t\t\t\t\tdecompileActions(sact->numActions-1, sact->Actions,gIndent+1);\n\t\t\t\t\tINDENT\n\t\t\t\t\tprintln(\"} else {\");\n\t\t\t\t}\t      \n\t\t\t\tStack=StackSave;\n\t\t\t\tdecompileActions(else_action_cnt  , &actions[n+1],gIndent+1);\n\t\t\t\tif  (!has_lognot)\t\t/* the missing if-part just NOW */\n\t\t\t\t{\n\t\t\t\t\tStack=StackSave;\n\t\t\t\t\tINDENT\n\t\t\t\t\tprintln (\"} else {\" );\n\t\t\t\t\tdecompileActions(sact->numActions-1, sact->Actions,gIndent+1);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\t/* It's a simple if() {} */\n\t\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\t}\n\t\tINDENT\n\t\tprintln(\"}\");\n\t} // WTF ???\n\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileINITOBJECT(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *nparam;\n\tnparam=pop();\n\tpush(newVar_N2(\"\",\"\",\"\",\"{\", nparam->p.Integer,\"}\"));\n\treturn 0;\n}\n\nstatic int\ndecompileWITH(int n, SWF_ACTION *actions, int maxn)\n{\n\tOUT_BEGIN2(SWF_ACTIONWITH);\n\n\tINDENT\n\tputs(\"with(\");\n\tdecompilePUSHPARAM(pop(),0);\n\tputs(\")\");\n\tprintln(\" {\" );\n\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\tINDENT\n\tprintln(\"}\" );\n\n\treturn 1;\n}\n\nstatic int\ndecompileTRY(int n, SWF_ACTION *actions, int maxn)\n{\n#ifdef DEBUG\n\tstruct _stack *StackSave=Stack;\n#endif    \n\tOUT_BEGIN2(SWF_ACTIONTRY);\n\tINDENT\n\tprintln(\"try {\");\n\tdecompileActions(sact->numTryActs, sact->TryActs,gIndent+1);\n\tINDENT\n\tprintln(\"}\");\n#ifdef DEBUG\n\tif (Stack!=StackSave)\n\t{\n\t\tprintln(\"/* Stack problem in try{} code above */\");\n\t\tStack=StackSave;\n\t}\n#endif\n\tif (sact->numCatchActs)    \n\t{\n\t\tstruct SWF_ACTIONPUSHPARAM *rsave=NULL;\n\t\tINDENT\n\t\tif( ! sact->CatchInRegisterFlag)\n\t\t\tprintln(\"catch (%s) {\",sact->CatchName);\n\t\telse\n\t\t{\n\t\t\tchar *t=malloc(5); /* Rddd */\n\t\t\tsprintf(t,\"R%d\", sact->CatchRegister );\n\t\t\trsave=regs[sact->CatchRegister];\n\t\t\tregs[sact->CatchRegister] = newVar(t);\n\t\t\tprintln(\"catch (%s) {\",t);\n\t\t}\n\t\tdecompileActions(sact->numCatchActs, sact->CatchActs,gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\tif (rsave)\n\t\t\tregs[sact->CatchRegister]=rsave;\n#ifdef DEBUG\n\t\tif (Stack!=StackSave)\n\t\t{\n\t\t\tprintln(\"/* Stack problem in catch{} code above */\");\n\t\t\tStack=StackSave;\n\t\t}\n#endif\n\t} \n\tif (sact->numFinallyActs)\n\t{\n\t\tINDENT\n\t\tprintln(\"finally () {\");\n\t\tdecompileActions(sact->numFinallyActs, sact->FinallyActs,gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\");\n#ifdef DEBUG\n\t\tif (Stack!=StackSave)\n\t\t{\n\t\t\tprintln(\"/* Stack problem in finally{} code above */\");\n\t\t\tStack=StackSave;\n\t\t}\n#endif\n\t}\n\treturn 0;\n}\n\n\nstatic int\ndecompileDEFINEFUNCTION(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n\tint i,j,k,m,r;\n\tstruct SWF_ACTIONPUSHPARAM *myregs[ 256 ];\n\tstruct _stack *StackSave;    \n\tstruct SWF_ACTIONDEFINEFUNCTION2 *sactv2;\n\tstruct strbufinfo origbuf;\n\tOUT_BEGIN2(SWF_ACTIONDEFINEFUNCTION);\n\tsactv2 = (struct SWF_ACTIONDEFINEFUNCTION2*)sact;\n\n#ifdef DEBUG\n\tif(n+1 < maxn)\n\t{\n\t\tprintln(\"/* function followed by OP %x */\", \n\t\t        OpCode(actions, n+1, maxn));\n\t}\n#endif\n#if USE_LIB\n\tif (isStoreOp(n+1, actions,maxn) \n\t    || (  *sact->FunctionName==0 && !is_type2 )\n\t    || (*sactv2->FunctionName==0 && is_type2  ))\n\t{\n\t\torigbuf=setTempString();\t/* switch to a temporary string buffer */\n\t}\n#endif\n\tputs(\"function \");\n\tif (is_type2)\n\t{\n\t\tfor(j=1;j<sactv2->RegisterCount;j++) \n\t\t{\n\t\t\tmyregs[j]=regs[j];\n\t\t\tregs[j]=NULL;\n\t\t}\n\t\tr=1;\n\t\tif (sactv2->PreloadThisFlag)\tregs[r++]=newVar(\"this\");\n\t\tif (sactv2->PreloadArgumentsFlag)\tregs[r++]=newVar(\"arguments\");\n\t\tif (sactv2->PreloadSuperFlag)\tregs[r++]=newVar(\"super\");\n\t\tif (sactv2->PreloadRootFlag)\tregs[r++]=newVar(\"root\");\n\t\tif (sactv2->PreloadParentFlag)\tregs[r++]=newVar(\"parent\");\n\t\tif (sactv2->PreloadGlobalFlag)\tregs[r++]=newVar(\"global\");\n\n\t\tputs(sactv2->FunctionName);\n\t\tputs(\"(\");\n\n\t\tfor(i=0,m=0;i<sactv2->NumParams;i++) \n\t\t{\n\t\t\tputs(sactv2->Params[i].ParamName);\n\t\t\tif ( sactv2->Params[i].Register)\n\t\t\t{\n\t\t\t\t printf(\" /*=R%d*/ \",sactv2->Params[i].Register);\n\t\t\t\t regs[sactv2->Params[i].Register] = newVar(sactv2->Params[i].ParamName);\n\t\t\t\t m++;\t\t\t\t\t// do not count 'void' etc\n\t\t\t}\n\t\t\tif( sactv2->NumParams > i+1 ) puts(\",\");\n\t\t}\n\t\tprintln(\") {\" );\n\t\tif (r+m < sactv2->RegisterCount)\n\t\t{\n\t\t\tINDENT\n\t\t\tputs(\"  var \");\n\t\t}\n\t\tfor(k=r;r<sactv2->RegisterCount;r++)\n\t\t{\n\t\t\tif (!regs[r])\n\t\t\t{\n\t\t\t\tchar *t=malloc(5); /* Rddd */\n\t\t\t\tsprintf(t,\"R%d\", r );\n\t\t\t\tputs (t);\n\t\t\t\tif (k++ < sactv2->RegisterCount- m -1)\n\t\t\t\t\tputs(\", \");\n\t\t\t\telse\n\t\t\t\t\tprintln(\";\" );\n\t\t\t\tregs[r]=newVar(t);\n\t\t\t}\n\t\t}\n\t\tStackSave=Stack;\n\t\tdecompileActions(sactv2->numActions, sactv2->Actions,gIndent+1);\n#ifdef DEBUG\n\t\tif (Stack!=StackSave)\n\t\t{\n\t\t\tprintln(\"/* Stack problem in function code above */\");\n\t\t}\n#endif\n\t\tStack=StackSave;\n\t\tfor(j=1;j<sactv2->RegisterCount;j++) \n\t\t\tregs[j]=myregs[j];\n\t}\n\telse\n\t{\n\t\tputs(sact->FunctionName);\n\t\tputs(\"(\");\n\t\tfor(i=0;i<sact->NumParams;i++) {\n\t\t\tputs(sact->Params[i]);\n\t\t\tif( sact->NumParams > i+1 ) puts(\",\");\n\t\t}\n\t\tprintln(\") {\" );\n\t\tk=0;\n\t\tif (sact->Actions[0].SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH)\n\t\t{\n\t\t\tstruct SWF_ACTIONPUSH *sactPush=(struct SWF_ACTIONPUSH *)sact->Actions;\n\t\t\tfor(i=0;i<sactPush->NumParam;i++)\n\t\t\t{\n\t\t\t\tif ((&(sactPush->Params[i]))->Type == PUSH_REGISTER) \n\t\t\t\t\tk++;\t/* REGISTER */\n\t\t\t}\n\t\t\tif (k)\n\t\t\t{\n\t\t\t\tINDENT\n\t\t\t\tputs(\"  var \");\n\t\t\t\tfor(i=1;i<=k;i++)\n\t\t\t\t{\n\t\t\t\t\tchar *t=malloc(5); /* Rddd */\n\t\t\t\t\tsprintf(t,\"R%d\", i );\n\t\t\t\t\tputs (t);\n\t\t\t\t\tif (i < k)\n\t\t\t\t\t\tputs(\", \");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintln(\";\" );\n\t\t\t\t\tregs[i]=newVar(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=k;j++) \n\t\t\tmyregs[j]=regs[j];\n\t\tStackSave=Stack;\n\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n#ifdef DEBUG\n\t\tif (Stack!=StackSave)\n\t\t{\n\t\t\tprintln(\"/* Stack problem in function code above */\");\n\t\t}\n#endif\n\t\tStack=StackSave;\n\t\tfor(j=1;j<=k;j++) \n\t\t\tregs[j]=myregs[j];\n\t}\n\tINDENT\n\tif (isStoreOp(n+1, actions,maxn) \n\t    || ( *sact->FunctionName==0 && !is_type2 )\n\t    || (*sactv2->FunctionName==0 && is_type2 ))\n\t{\n\t\tputs(\"}\");\n#if USE_LIB\n\t\tpush (newVar(dcgetstr()));\t/* push func body for later assignment */\n\t\tsetOrigString(origbuf);\t\t/* switch back to orig buffer */\n#else\n\t\tpush (newVar(\"/* see function code above */\"));\t/* workaround only if LIB is not in use */\n#endif\n\t}\n\telse\n\t\tprintln(\"}\" );\n\treturn 0;\n}\n\nstatic int\ndecompileCALLMETHOD(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *meth, *obj, *nparam;\n\tmeth=pop();\n\tobj=pop();\n\tnparam=pop();\n\tif (nparam->p.Integer>25)\n\t{\n\t\tINDENT\n\t\tprintln(\"// Problem getting method arguments (%d ignored) below:\",\n\t\t        nparam->p.Integer);\n\t\tnparam->p.Integer=0;\n\t}\n#ifdef DEBUG\n\tprintf(\"*CALLMethod* objName=%s (type=%d) methName=%s (type=%d)\\n\",\n\t\tgetName(obj), obj->Type, getName(meth), meth->Type);\n#endif\n\tif (meth->Type == PUSH_UNDEF) \t/* just undefined, like in \"super();\" */\n\t\tpush(newVar_N(getName(obj),\"\",\"\",\"(\", nparam->p.Integer,\")\"));\n\telse\n\t{\n\t\tif (meth->Type == PUSH_INT || meth->Type == PUSH_DOUBLE || meth->Type == PUSH_VARIABLE\n\t\t    || meth->Type == PUSH_REGISTER || meth->Type == 12 )\n\t\t{\n\t\t\tpush(newVar_N(getName(obj),\"[\",getName(meth),\"](\", nparam->p.Integer,\")\"));\n\t\t}\n\t\telse\n\t\t\tpush(newVar_N(getName(obj),\".\",getName(meth),\"(\", nparam->p.Integer,\")\"));\n\t}\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call method and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileCALLFUNCTION(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *meth, *nparam;\n\n\tSanityCheck(SWF_CALLMETHOD, OpCode(actions, n-1, maxn) == SWFACTION_PUSH,\n\t\t\"CALLMETHOD not preceeded by PUSH\")\n\n\tmeth=pop();\n\tnparam=pop();\n\tif (nparam->p.Integer>25)\n\t{\n\t\tINDENT\n\t\tprintln(\"// Problem getting function arguments (%d ignored) below:\",\n\t\t\tnparam->p.Integer);\n\t\tnparam->p.Integer=0;\n\t}\n\tpush(newVar_N(\"\",\"\",getName(meth),\"(\", nparam->p.Integer,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompile_Null_ArgBuiltInFunctionCall(int n, SWF_ACTION *actions, int maxn, char *functionname)\n{\n\tINDENT\n\tputs(functionname);\t\t// only used for cases w/o return value\n\tprintln(\"();\" );\n\treturn 0;\n}\n\nstatic int\ndecompileSingleArgBuiltInFunctionCall(int n, SWF_ACTION *actions, int maxn, char *functionname)\n{\n\tpush(newVar_N(\"\",\"\",functionname,\"(\", 1,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileSTARTDRAG(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"startDrag(\");\n\tdecompilePUSHPARAM(pop(),1);\n\tputs(\",\");\n\tdecompilePUSHPARAM(pop(),0);\n\tputs(\",\");\n\tdecompilePUSHPARAM(pop(),0);\t//\n\tprintln(\");\" );\n\treturn 0;\n}\n\nstatic int\ndecompileSUBSTRING(int n, SWF_ACTION *actions,int maxn)\n{\n\tpush(newVar_N(\"\",\"\",\"substr\",\"(\", 3,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileSTRINGCONCAT(int n, SWF_ACTION *actions, int maxn)\n{\n\tpush(newVar_N(\"\",\"\",\"concat\",\"(\", 2,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileTHROW(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"throw \");\n\tputs(getName(pop()));\n\tprintln(\";\");\n\treturn 0;\n}\n\nstatic int\ndecompileREMOVECLIP(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"removeMovieClip(\");\n\tputs(getName(pop()));\n\tprintln(\");\" );\n\treturn 0;\n}\n\nstatic int \ndecompileDUPLICATECLIP(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *a, *b;\n\n\tINDENT\n\ta = pop();\n\tb = pop();\n\n\tputs(\"duplicateMovieClip(\");\n\tputs(getString(pop()));\n\tputs(\",\");\n\tputs(getString(b));\n\tputs(\",\");\n\tputs(getString(a));\n\tprintln(\");\" );\n\treturn 0;\n}\n\nstatic int\ndecompileINITARRAY(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *nparam;\n\tnparam=pop();\n\tpush(newVar_N(\"\",\"\",\"\",\"[\", nparam->p.Integer,\"]\"));\n\treturn 0;\n}\n\nstatic int\ndecompileEXTENDS(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *baseclass;\n\n\tbaseclass=pop();\n#if 0\n\t/* It's useless to open a class body when there's no\n\t * other code supporting it. */\n\tprintf(\"class \");\n\tputs(getName(pop()));\n\tprintf(\" extends \");\n\tputs(getName(baseclass));\n\tprintln(\" {\" );\n#else\n\t/* We'll do it with asm{} */\n\tprintln(\"asm {\");\n\tprintln(\" push '%s'\", getName(pop()));\n\tprintln(\" getvariable\");\n\tprintln(\" push '%s'\", getName(baseclass));\n\tprintln(\" getvariable\");\n\tprintln(\" extends\");\n\tprintln(\"};\");\n#endif\n\n\treturn 0;\n}\n\nstatic int\ndecompileDELETE(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n\tif (is_type2)\n\t\tpush(newVar3(\"delete(\",getName(pop()),\")\"));\n\telse\n\t\tpush(newVar_N(\"delete(\",getName(pop()),\".\",getName(pop()), 0,\")\"));\n\n\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call delete() with its args and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileSETTARGET(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n\tint action_cnt=0;\n\tchar *name;\n\tOUT_BEGIN2(SWF_ACTIONSETTARGET);\n\tname = is_type2 ? getString(pop()) : sact->TargetName;\n\tif (*name)\n\t{\n\t\tINDENT\n\t\tprintln(\"tellTarget('%s') {\" ,name);\n\t\twhile(action_cnt+n<maxn)\n\t\t{\n\t\t\tif (OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_SETTARGET\n\t\t\t    || OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_SETTARGET2\n\t\t\t    || OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_DEFINEFUNCTION\n\t\t\t    || OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_DEFINEFUNCTION2\n\t\t\t    || OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_END) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taction_cnt++;\n\t\t}\n\t\tdecompileActions(action_cnt,&actions[n+1],gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\" );\n\t}\n\treturn action_cnt;\n}\n\nstatic int\ndecompileIMPLEMENTS(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *nparam;\n\tint i;\n\tINDENT;\n\tputs(getName(pop()));\n\tprintf(\" implements \");\n\tnparam=pop();\n\tfor(i=0;i<nparam->p.Integer;i++) \n\t{\n\t\tputs(getName(pop()));\n\t}\n\tprintln(\" ;\");\n\treturn 0;\n}\n\nstatic int\ndecompileCAST(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *iparam=pop();\n\tstruct SWF_ACTIONPUSHPARAM *tparam=pop();\n\tpush(newVar_N( getName(tparam),\"(\",getName(iparam),\"\", 0,\")\")); \n\treturn 0;\n}\n\nint\ndecompileAction(int n, SWF_ACTION *actions, int maxn)\n{\n\tif( n > maxn ) SWF_error(\"Action overflow!!\");\n\n#ifdef DEBUG\n\tfprintf(stderr,\"%d:\\tACTION[%3.3d]: %s\\n\",\n\t        actions[n].SWF_ACTIONRECORD.Offset, n, \n\t        actionName(actions[n].SWF_ACTIONRECORD.ActionCode));\n#endif\n\n\tswitch(actions[n].SWF_ACTIONRECORD.ActionCode)\n\t{\n\tcase SWFACTION_END:\n\t\treturn 0;\n\n\tcase SWFACTION_CONSTANTPOOL:\n\t\tdecompileCONSTANTPOOL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GOTOLABEL:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,1);\n\n\tcase SWFACTION_GOTOFRAME:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,0);\n\n\tcase SWFACTION_GOTOFRAME2:\n\t\treturn decompileGOTOFRAME2(n, actions, maxn);\n\n\tcase SWFACTION_WAITFORFRAME:\n\t\tdecompileWAITFORFRAME(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL2:\n\t\tdecompileGETURL2(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL:\n\t\tdecompileGETURL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSH:\n\t\tdecompilePUSH(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSHDUP:\n\t\tdecompilePUSHDUP(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_STACKSWAP:\n\t\tdecompileSTACKSWAP(&actions[n]);\t\n\t\treturn 0;\n\n\tcase SWFACTION_SETPROPERTY:\n\t\tdecompileSETPROPERTY(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETPROPERTY:\n\t\tdecompileGETPROPERTY(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETTIME:\n\t\treturn decompileGETTIME(n, actions, maxn);\n\n\tcase SWFACTION_TRACE:\n\t\tdecompileTRACE(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_CALLFRAME:\n\t\tdecompileCALLFRAME(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_EXTENDS:\n\t\tdecompileEXTENDS(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_INITOBJECT:\n\t\tdecompileINITOBJECT(n, actions, maxn);\n\t\treturn 0;\t        \n\n\tcase SWFACTION_NEWOBJECT:\n\t\tdecompileNEWOBJECT(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_NEWMETHOD:\n\t\tdecompileNEWMETHOD(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompileGETMEMBER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_SETMEMBER:\n\t\tdecompileSETMEMBER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETVARIABLE:\n\t\tdecompileGETVARIABLE(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_SETVARIABLE:\n\t\tdecompileSETVARIABLE(n, actions, maxn, 0);\n\t\treturn 0;\n\n\tcase SWFACTION_DEFINELOCAL:\n\t\tdecompileSETVARIABLE(n, actions, maxn, 1);\n\t\treturn 0;\n\n\tcase SWFACTION_DEFINELOCAL2:\n\t\tdecompileDEFINELOCAL2(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_DECREMENT:\n\t\treturn decompileINCR_DECR(n, actions, maxn, 0);\n\n\tcase SWFACTION_INCREMENT:\n\t\treturn decompileINCR_DECR(n, actions, maxn,1);\n\n\tcase SWFACTION_STOREREGISTER:\n\t\tdecompileSTOREREGISTER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_JUMP:\n\t\treturn decompileJUMP(n, actions, maxn);\n\n\tcase SWFACTION_RETURN:\n\t\tdecompileRETURN(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_LOGICALNOT:\n\t\treturn decompileLogicalNot(n, actions, maxn);\n\n\tcase SWFACTION_IF:\n\t\treturn decompileIF(n, actions, maxn);\n\n\tcase SWFACTION_WITH:\n\t\tdecompileWITH(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_ENUMERATE:\n\t\treturn decompileENUMERATE(n, actions, maxn, 0);\n\n\tcase SWFACTION_ENUMERATE2 :\n\t\treturn decompileENUMERATE(n, actions, maxn,1);\n\n\tcase SWFACTION_INITARRAY:\n\t\treturn decompileINITARRAY(n, actions, maxn);\n\n\tcase SWFACTION_DEFINEFUNCTION:\t\n\t\treturn decompileDEFINEFUNCTION(n, actions, maxn,0);\n\n\tcase SWFACTION_DEFINEFUNCTION2:\n\t\treturn decompileDEFINEFUNCTION(n, actions, maxn,1);\n\n\tcase SWFACTION_CALLFUNCTION:\n\t\treturn decompileCALLFUNCTION(n, actions, maxn);\n\n\tcase SWFACTION_CALLMETHOD:\n\t\treturn decompileCALLMETHOD(n, actions, maxn);\n\n\tcase SWFACTION_INSTANCEOF:\n\tcase SWFACTION_SHIFTLEFT:\n\tcase SWFACTION_SHIFTRIGHT:\n\tcase SWFACTION_SHIFTRIGHT2:        \n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\tcase SWFACTION_SUBTRACT:\n\tcase SWFACTION_MULTIPLY:\n\tcase SWFACTION_DIVIDE:\n\tcase SWFACTION_MODULO:\n\tcase SWFACTION_BITWISEAND:\n\tcase SWFACTION_BITWISEOR:\n\tcase SWFACTION_BITWISEXOR:\n\tcase SWFACTION_EQUAL:\n\tcase SWFACTION_EQUALS2:\n\tcase SWFACTION_LESS2:\n\tcase SWFACTION_LOGICALAND:\n\tcase SWFACTION_LOGICALOR:\n\tcase SWFACTION_GREATER:\n\tcase SWFACTION_LESSTHAN:\n\tcase SWFACTION_STRINGEQ:\n\tcase SWFACTION_STRINGCOMPARE:\n\tcase SWFACTION_STRICTEQUALS:\n\t\treturn decompileArithmeticOp(n, actions, maxn);\n\n\tcase SWFACTION_POP:\n\t\tpop();\n\t\treturn 0;\n\n\tcase SWFACTION_STARTDRAG:\n\t\treturn decompileSTARTDRAG(n, actions, maxn);\n\n\tcase SWFACTION_DELETE:\n\t\treturn decompileDELETE(n, actions, maxn,0);\n\n\tcase SWFACTION_DELETE2:\n\t\treturn decompileDELETE(n, actions, maxn,1);\n\n\tcase SWFACTION_TARGETPATH:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"targetPath\");\n\n\tcase SWFACTION_TYPEOF:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"typeof\");\n\n\tcase SWFACTION_ORD:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"ord\");\n\n\tcase SWFACTION_CHR:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"chr\");\n\n\tcase SWFACTION_INT:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"int\");\n\n\tcase SWFACTION_TOSTRING:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"String\");     \n\n\tcase SWFACTION_TONUMBER:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"Number\");\n\n\tcase SWFACTION_RANDOMNUMBER:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"random\");\n\n\tcase SWFACTION_STRINGLENGTH:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"length\");\n\n\tcase SWFACTION_PLAY:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"play\");\n\n\tcase SWFACTION_STOP:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stop\");\n\n\tcase SWFACTION_NEXTFRAME:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"nextFrame\");\n\n\tcase SWFACTION_PREVFRAME:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"prevFrame\");\n\n\tcase SWFACTION_ENDDRAG:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stopDrag\");\n\n\tcase SWFACTION_STOPSOUNDS:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stopAllSounds\");   \n\n\tcase SWFACTION_TOGGLEQUALITY:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"toggleHighQuality\");      \n\n\tcase SWFACTION_MBSUBSTRING:\n\tcase SWFACTION_SUBSTRING:\n\t\treturn decompileSUBSTRING(n, actions, maxn);\n\n\tcase SWFACTION_STRINGCONCAT:\n\t\treturn decompileSTRINGCONCAT(n, actions, maxn);\n\n\tcase SWFACTION_REMOVECLIP:\n\t\treturn decompileREMOVECLIP(n, actions, maxn);\n\n\tcase SWFACTION_DUPLICATECLIP:\n\t\treturn decompileDUPLICATECLIP(n, actions, maxn);\n\n\tcase SWFACTION_SETTARGET:\n\t\treturn decompileSETTARGET(n, actions, maxn,0);\n\n\tcase SWFACTION_SETTARGET2:\n\t\treturn decompileSETTARGET(n, actions, maxn,1);\n\n\tcase SWFACTION_IMPLEMENTSOP:\n\t\treturn decompileIMPLEMENTS(n, actions, maxn);\n\n\tcase SWFACTION_CASTOP:\n\t\treturn decompileCAST(n, actions, maxn);\n\n\tcase SWFACTION_THROW:\n\t\treturn decompileTHROW(n, actions, maxn);\n\n\tcase SWFACTION_TRY:\n\t\treturn decompileTRY(n, actions, maxn);\n\n\tdefault:\n\t\toutputSWF_ACTION(n,&actions[n]);\n\t\treturn 0;\n\t}\n}\n\nstatic void\ndecompileActions(int n, SWF_ACTION *actions, int indent)\n{\n\tint i, svindent;\n\n\tsvindent = gIndent;\n\tgIndent = indent;\n\t\n\tfor(i=0;i<n;i++) {\n\t\ti+=decompileAction(i, actions, n);\n\t}\n\tgIndent = svindent;\n}\n\nchar *\ndecompile5Action(int n, SWF_ACTION *actions,int indent)\n{\n\tint j;\n\tif( !n  )\n\t\treturn NULL;\n\n\tpool = NULL;\n\tpoolcounter = 0;\n\n\tdcinit();\n\n\tfor(j=0;j<256;j++) regs[j]=0;\n\tregs[1] = newVar(\"R1\");\n\tregs[2] = newVar(\"R2\");\n\tregs[3] = newVar(\"R3\");\n\tregs[4] = newVar(\"R4\");\n\n\tdecompileActions(n, actions, indent);\n#ifdef DEBUGSTACK\n\tif( Stack != NULL && *dcstr) \n\t{ \n\t\tint i=0;\n\t\tprintln(\"/* -----------------------------------------------------------------\");\n\t\tprintln(\"NOTE: some stuff left on the stack at the end of a block of actions:\");\n\t\twhile (Stack)\n\t\t{\n\t\t\ti++;\n\t\t\tprintf(\"%d.:\\t%s\",i, getString(pop()));\n\t\t\tprintln(\"\");\n\t\t}\n\t\tprintln(\"*/\");\n\t}\n#else\n\tif( Stack != NULL ) \n\t\tfprintf(stderr,\n\t\t\"Stuff left on the stack at the end of a block of actions!?!?!?\\n\");\n\twhile (Stack)\n\t{\n\t\tpop();\n\t}\n#endif\n\treturn dcgetstr();\n}\n\n"], "fixing_code": ["/****************************************************************************\n *\n *  Copyright (C) 2006,2007 A.Kleine\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n ****************************************************************************/\n\n#define _GNU_SOURCE 1\n\n//#define DEBUGSTACK\n#define DECOMP_SWITCH\n// #define DEBUGSWITCH\n\n//#define STATEMENT_CLASS  \n//  I have uncommented some buggy class recognition stuff in decompileIF()\n//  to make work simple code lines like:  \"if(!a) trace(a);\"   - ak, November 2006\n\n//  To do: add some free()-calls for allocated blocks\n\n#include <assert.h>\n\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#include \"read.h\"\n#include \"action.h\"\n#include \"swftypes.h\"\n#include \"../src/blocks/error.h\"\n#include \"vasprintf.h\"\n\n\nstatic char **pool;\nstatic unsigned short poolcounter;\nstruct SWF_ACTIONPUSHPARAM *regs[256];\n\nstatic char *getName(struct SWF_ACTIONPUSHPARAM *act);\n\nstatic int offseoloop;\t// offset wherever a break can jump to (loops and switch)\n\nstatic void\ndumpRegs()\n{\nint i;\nfor(i=0;i<6;i++)\n\tif( regs[i] )\n\t\tprintf(\"reg[%d] %s\\n\", i, getName(regs[i]));\n}\n\n/*\n * Start Package \n *\n * A package to build up a string that can be returned to the caller\n * ak/2006: Extended for temporary swichting to a 2nd buffer\n */\n#define USE_LIB 1\n\nstatic int strsize=0;\nstatic int strmaxsize=0;\nstatic char *dcstr=NULL;\nstatic char *dcptr=NULL;\n\n#define DCSTRSIZE 40960\n#define PARAM_STRSIZE 512\nvoid\ndcinit()\n{\n\tstrsize = 1; // We start with empty string, i.e. \\0\n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}\n\nvoid\ndcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n\n}\n\nvoid\ndcputs(const char *s)\n{\n\tint len=strlen(s);\n\tdcchkstr(len);\n\tstrcat(dcptr,s);\n\tdcptr+=len;\n\tstrsize+=len;\n}\n\nvoid\ndcputchar(char c)\n{\n\tdcchkstr(1);\n\n\t*dcptr++=c;\n\t*dcptr='\\000';\n\tstrsize++;\n}\n\nint\ndcprintf(char *format, ...)\n{\n\tchar *s;\n\tsize_t size;\n\tint ret;\n\n\tva_list args;\n\tva_start(args,format);\n\tret = vasprintf(&s,format,args);\n\tdcputs(s);\n\tsize=strlen(s);\n\tfree(s);\n\treturn size;\n}\n\nchar *\ndcgetstr()\n{\n\tchar *ret;\n\tret = dcstr;\n\tdcstr=NULL;\n\tstrmaxsize=0;\n\treturn ret;\n}\n\nstruct strbufinfo\n{\n\tint size;\n\tint maxsize;\n\tchar *str;\n\tchar *ptr;\n};\n\n\nstatic struct strbufinfo setTempString(void)\n{\n\tstruct strbufinfo current;\n\tcurrent.size=strsize;\n\tcurrent.maxsize=strmaxsize;\n\tcurrent.str=dcstr;\n\tcurrent.ptr=dcptr;\n\tdcinit();\n\treturn current;\n}\n\nstatic void setOrigString(struct strbufinfo old)\n{\n\tfree(dcstr);\t\t\t\t/* not needed anymore */\n\tstrsize=old.size;\n\tstrmaxsize=old.maxsize;\n\tdcstr=old.str;\n\tdcptr=old.ptr;\n}\n\n// a variant of setOrigString()\n// but for further usage of 2nd buffer\n//\nstatic char *\nswitchToOrigString(struct strbufinfo old)\n{\n\tchar *tmp=dcstr;\n\tstrsize=old.size;\n\tstrmaxsize=old.maxsize;\n\tdcstr=old.str;\n\tdcptr=old.ptr;\n\treturn tmp;\n}\n\n#if USE_LIB\n#define puts(s) dcputs(s)\n#define putchar(c) dcputchar(c)\n#define printf dcprintf\n#endif\n\n#define INDENT { int ii=gIndent; while(--ii>=0) { putchar(' '); putchar(' '); } }\n\n/* String used for terminating lines (see println) */\nstatic const char* newlinestring = \"\\\\\\n\";\n\n/* Set the newline character. By default it is an escaped NL. */\nvoid\nsetNewLineString(const char* ch)\n{\n\tnewlinestring = ch;\n}\n\n/* Print a line with a terminating newline, which can be set by\n * setNewLineString()\n */\nstatic void\nprintln(const char* fmt, ...)\n{\n\tchar *tmp;\n\tint written;\n\n\tva_list ap;\n\tva_start (ap, fmt);\n\twritten = vasprintf (&tmp, fmt, ap);\n\n\tdcprintf(\"%s%s\", tmp, newlinestring);\n\n\tfree(tmp);\n}\n\n\n/* End Package */\n\n/*\n * Start Package \n *\n * A package to maintain escaped characters strings\n * [ BSC == BackSlashCounter ]\n */\n#define BSC 2\nstatic int strlenext(char *str)\n{\n\tint i=0;\n\twhile (*str)\n\t{\n\t\ti++;\n\t\tif (*str=='\\'') i+=BSC;\n\t\t\tstr++;\t\n\t}\n\treturn i;\n}\n\nstatic char* strcpyext(char *dest,char *src)\n{\n\tchar *r=dest;\n\twhile (*src)\n\t{\n\t\tif (*src=='\\'')\n\t\t{\n\t\t\t*dest++='\\\\';\n#if BSC == 2\n\t\t\t*dest++='\\\\';\n#endif\n\t\t}\n\t\t*dest++=*src++;\n\t}\n\t*dest='\\0';\n\treturn r;\n}\n\nstatic char* strcatext(char *dest,char *src)\n{\n\tchar *r=dest;\n\twhile (*dest)\n\t\tdest++;\n\tstrcpyext(dest,src);\n\treturn r;\n}\n/* End Package */\n\n/*\n * Start Package \n *\n * A package to maintain a representation of the Flash VM stack\n */\n\nstruct _stack {\n\tchar type;\n\tstruct SWF_ACTIONPUSHPARAM *val;\n\tstruct _stack *next;\n};\n\nstruct _stack *Stack;\n\nenum\n{\n\tPUSH_STRING = 0,\n\tPUSH_FLOAT = 1,\n\tPUSH_NULL = 2,\n\tPUSH_UNDEF = 3,\n\tPUSH_REGISTER = 4,\n\tPUSH_BOOLEAN = 5,\n\tPUSH_DOUBLE = 6,\n\tPUSH_INT = 7,\n\tPUSH_CONSTANT = 8,\n\tPUSH_CONSTANT16 = 9,\n\tPUSH_VARIABLE = 10,\n};\n\nstatic char *\ngetString(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n#ifdef DEBUG\n\tprintf(\"*getString* type=%d\\n\",act->Type);\n#endif\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_STRING: \n\t\tif (!act->p.String) /* Not a NULL string */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getString with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlen(act->p.String)+3); /* 2 \"'\"s and a NULL */\n\t\tstrcpy(t,\"'\");\n\t\tstrcat(t,act->p.String);\n\t\tstrcat(t,\"'\");\n\t\treturn t;\n\tcase PUSH_NULL: /* NULL */\n\t\treturn \"null\";\n\tcase PUSH_UNDEF: /* Undefined */\n\t\treturn \"undefined\";\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\tif( regs[act->p.RegisterNumber] &&\n\t\t    regs[act->p.RegisterNumber]->Type != 4 &&\n\t\t    regs[act->p.RegisterNumber]->Type != 7 )\n\t\t{\n\t\t\treturn getName(regs[act->p.RegisterNumber]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt=malloc(5); /* Rddd */\n\t\t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n\t\t\treturn t;\n\t\t}\n\tcase PUSH_BOOLEAN: /* BOOLEAN */\n\t\tif( act->p.Boolean )\n\t\t\treturn \"true\";\n\t\telse\n\t\t\treturn \"false\";\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t{\n\t\tchar length_finder[1];\n\t\tint needed_length = snprintf(length_finder, 1, \"%g\", act->p.Double) + 1;\n\t\tif (needed_length <= 0)\n\t\t{\n\t\t        SWF_warn(\"WARNING: could not evaluate size of buffer (memory issue ?).\\n\");\n\t\t        break;\n\t\t}\n\n\t\tt = malloc(needed_length);\n\t\tsprintf(t, \"%g\", act->p.Double );\n\t\treturn t;\n\t}\n\tcase PUSH_INT: /* INTEGER */\n\t\tt=malloc(10); /* 32-bit decimal */\n\t\tsprintf(t,\"%ld\", act->p.Integer );\n\t\treturn t;\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+3); /* 2 \"'\"s and a NULL */\n\t\tstrcpy(t,\"'\");\n\t\tstrcatext(t,pool[act->p.Constant8]);\n\t\tstrcat(t,\"'\");\n\t\treturn t;\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+3); /* 2 '\\\"'s and a NULL */\n\t\tstrcpy(t,\"'\");\n\t\tstrcatext(t,pool[act->p.Constant16]);\n\t\tstrcat(t,\"'\");\n\t\treturn t;\n\n\tcase 12:\n\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n\tcase PUSH_VARIABLE: /* VARIABLE */\n\t\treturn act->p.String;\n\tdefault: \n\t\tfprintf (stderr,\"  Can't get string for type: %d\\n\", act->Type);\n\t\tbreak;\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\n\treturn t;\n}\n\nstatic char *\ngetName(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n\n\tswitch( act->Type ) \t\n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif (!act->p.String) /* Not a NULL string */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(act->p.String)) /* Not a zero length string */\n\t\t{\n\t\t        t=malloc(strlen(act->p.String)+3);\n\t\t        strcpyext(t,act->p.String);\n\t\t        return t;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *return_string = \"this\";\n\t                t=malloc(strlen(return_string)+1); /* string length + \\0 */\n\t                strcpyext(t,return_string);\n\t\t\treturn t;\n\t\t}\n#if 0\n\t  case 4: /* REGISTER */\n\t\tt=malloc(5); /* Rddd */\n  \t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n  \t\treturn t;\n#endif\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+1);\n\t\tstrcpyext(t,pool[act->p.Constant8]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\n\treturn t;\n}\n\nstatic int\ngetInt(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */\n\t\treturn ((int)act->p.Float);\n\tcase PUSH_NULL: /* NULL */\n\t\treturn 0;\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\treturn getInt(regs[act->p.RegisterNumber]);\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\treturn (int)act->p.Double;\n\tcase PUSH_INT: /* INTEGER */\n\t\treturn act->p.Integer;\n\tdefault: \n\t\tfprintf (stderr,\"  Can't get int for type: %d\\n\", act->Type);\n\t}\n\treturn 0;\n}\n\nstatic char *\ngetProperty(Property prop)\n{\n\tswitch(prop)\n\t{\n\tcase SWF_SETPROPERTY_X: \treturn(\"_x\"); break;\n\tcase SWF_SETPROPERTY_Y:\n\tcase PROPERTY_Y:\t\treturn(\"_y\"); break;\n\tcase PROPERTY_XMOUSE:\t\treturn(\"_xMouse\"); break;\n\tcase PROPERTY_YMOUSE:\t\treturn(\"_yMouse\"); break;\n\tcase SWF_SETPROPERTY_XSCALE:\n\tcase PROPERTY_XSCALE:\t   \treturn(\"_xScale\"); break;\n\tcase SWF_SETPROPERTY_YSCALE:\n\tcase PROPERTY_YSCALE:\t   \treturn(\"_yScale\"); break;\n\tcase PROPERTY_CURRENTFRAME:\treturn(\"_currentFrame\"); break;\n\tcase PROPERTY_TOTALFRAMES:\treturn(\"_totalFrames\"); break;\n\tcase SWF_SETPROPERTY_ALPHA:\n\tcase PROPERTY_ALPHA:\t\treturn(\"_alpha\"); break;\n\tcase SWF_SETPROPERTY_VISIBILITY:\n\tcase PROPERTY_VISIBLE:\t\treturn(\"_visible\"); break;\n\tcase PROPERTY_WIDTH:\t\treturn(\"_width\"); break;\n\tcase PROPERTY_HEIGHT:\t\treturn(\"_height\"); break;\n\tcase SWF_SETPROPERTY_ROTATION:\n\tcase PROPERTY_ROTATION:\t\treturn(\"_rotation\"); break;\n\tcase PROPERTY_TARGET:\t\treturn(\"_target\"); break;\n\tcase PROPERTY_FRAMESLOADED:\treturn(\"_framesLoaded\"); break;\n\tcase SWF_SETPROPERTY_NAME:\n\tcase PROPERTY_NAME:\t\treturn(\"_name\"); break;\n\tcase PROPERTY_DROPTARGET:\treturn(\"_dropTarget\"); break;\n\tcase PROPERTY_URL:\t\treturn(\"_url\"); break;\n\tcase SWF_SETPROPERTY_HIGHQUALITY:\n\tcase PROPERTY_HIGHQUALITY:\treturn(\"_quality\"); break;\n\tcase SWF_SETPROPERTY_SHOWFOCUSRECT:\n\tcase PROPERTY_FOCUSRECT:\treturn(\"_focusRect\"); break;\n\tcase SWF_SETPROPERTY_SOUNDBUFFERTIME:\n\tcase PROPERTY_SOUNDBUFTIME:\treturn(\"_soundBufTime\"); break;\n\tcase SWF_SETPROPERTY_WTHIT:\n\tcase PROPERTY_WTHIT:\t\treturn(\"_WTHIT!?\"); break;\n\tdefault:\t\t\treturn(\"unknown property!\"); break;\n\t}\n}\n\nstruct SWF_ACTIONPUSHPARAM *\nnewVar(char *var)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; \n\tv->p.String = var;\n\treturn v;\n}\n\nstruct SWF_ACTIONPUSHPARAM *\nnewVar2(char *var,char *var2)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE;\n\tv->p.String = malloc(strlen(var)+strlen(var2)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\treturn v;\n}\n\n\nstruct SWF_ACTIONPUSHPARAM *\nnewVar3(char *var,char *var2, char *var3)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; /* VARIABLE */\n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\treturn v;\n}\n\nstruct SWF_ACTIONPUSHPARAM *\nnewVar5(char *var,char *var2, char *var3,char *var4,char *var5)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; /* VARIABLE */\n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(var5)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tstrcat(v->p.String,var5);\n\treturn v;\n}\n\nvoid\npush(struct SWF_ACTIONPUSHPARAM *val)\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*push* type=%d\\n\",val->Type);\n#endif\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = val->Type;\n\tt->val = val;\n\tt->next = Stack;\n\tStack = t;\n}\n\n\nvoid\npushdup()\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushdup*\\n\");\n#endif\n\tif(Stack == NULL)\n\t{\n\t\tSWF_warn(\"WARNING: pushdup on empty stack. This might be wrong!\\n\");\n\t\treturn;\n\t}\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = Stack->type;\n\n\t// If element is a string, perform deep copy of Stack->val->p\n\tif (Stack->val->Type == PUSH_STRING) {\n\t\tt->val = calloc(1, sizeof(struct SWF_ACTIONPUSHPARAM));\n\t\t*t->val = *Stack->val;\n\n\t\tint len = strlen(Stack->val->p.String) + 1; // NULL terminated\n\t\tt->val->p.String = calloc(len, sizeof(char));\n\t\tstrcpy(t->val->p.String, Stack->val->p.String);\n\t} else {\n\t\tt->val =  Stack->val;\n\t}\n\n\tt->next = Stack;\n\tStack = t;\n}\n\n\nvoid\npushvar(struct SWF_ACTIONPUSHPARAM *val)\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushvar*\\n\");\n#endif\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = 'v'; // ???\n\tt->val = val;\n\tt->next = Stack;\n\tStack = t;\n}\n\nstruct SWF_ACTIONPUSHPARAM * pop()\n{\n\tstruct _stack *t;\n\tstruct SWF_ACTIONPUSHPARAM * ret;\n\n#ifdef DEBUG\n\tprintf(\"*pop*\\n\");\n#endif\n#ifdef DEBUGSTACK\t\t/* continue w stack dummy */\n\tif( Stack == NULL ) push(newVar(\"// *** pop(): INTERNAL STACK ERROR FOUND ***\"));\n#else\n\tif( Stack == NULL ) SWF_error(\"Stack blown!! - pop\");\n#endif\n\tt=Stack;\n\tStack=t->next;\n\tret=t->val;\n\treturn ret;\n}\n\nstruct SWF_ACTIONPUSHPARAM * peek()\n{\n#ifdef DEBUG\n\tprintf(\"*peek*\\n\");\n#endif\n#ifdef DEBUGSTACK\t\t/* continue w stack dummy */\n\tif( Stack == NULL ) push(newVar(\"// *** peek(): INTERNAL STACK ERROR FOUND ***\"));\n#else\n\tif( Stack == NULL ) SWF_error(\"Stack blown!! - peek\");\n#endif\n\treturn Stack->val;\n}\n\nvoid\nstackswap()\n{\n#ifdef DEBUG\n\tprintf(\"*stackswap*\\n\");\n#endif\n\tstruct SWF_ACTIONPUSHPARAM *p = peek();\t\t/* peek() includes error handling */\n\tchar type = Stack->type;\n\n        if (Stack->next == NULL) {\n#if DEBUG\n\t\tSWF_warn(\"stackswap: can't swap (stack contains only one element)\\n\");\n#endif\n                return;\n        }\n\n\tStack->type = Stack->next->type;\n\tStack->val  = Stack->next->val;\n\tStack->next->type = type;\n\tStack->next->val  = p;\n}\n\n\nstatic struct SWF_ACTIONPUSHPARAM *\nnewVar_N(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\t\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops=getString(pop());\n\t\twhile ( strlen(v->p.String)+ 2 + strlen(pops) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}\n\n// similar to newVar_N(), \n// but pops 2 items from stack per counter,\n// and second of them we are interested in getName() instead of getString()\nstatic struct SWF_ACTIONPUSHPARAM *\nnewVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\t\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}\n\n/* End Package */\n\nstatic int gIndent;\nstatic void decompileActions(int n, SWF_ACTION *actions,int indent);\nchar * decompile5Action(int n, SWF_ACTION *actions,int indent);\n\n/******************************************************************************/\n/******************************************************************************/\n/******************************************************************************/\n/******************************************************************************/\n/******************************************************************************/\n\n\n#define SanityCheck(curact,test,msg ) \\\n    if(!(test) ) SWF_error( \"SanityCheck failed in %s\\n %s\\n\", #curact, msg );\n\n#define OUT_BEGIN(block) \\\n\t                struct block *sact = (struct block *)act;\n#define OUT_BEGIN2(block) \\\n\t                struct block *sact = (struct block *)&(actions[n]);\n\nstatic void\ndecompileCONSTANTPOOL (SWF_ACTION *act)\n{\n\tOUT_BEGIN(SWF_ACTIONCONSTANTPOOL);\n\tpool=sact->ConstantPool;\n\tpoolcounter = sact->Count;\n}\n\nstatic void\ndecompileWAITFORFRAME (SWF_ACTION *act)\n{\n\tOUT_BEGIN(SWF_ACTIONWAITFORFRAME);\n\n\tINDENT\n\tprintln(\"WaitForFrame(%d,%d);\", sact->Frame,sact->SkipCount);\n}\n\nstatic void\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *act, int wantstring)\n{\n\tchar *t;\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif( wantstring ) printf (\"'%s'\", act->p.String);\n\t\telse printf (\"%s\", act->p.String);\n\t\tbreak;\n\tcase PUSH_FLOAT: /* FLOAT */\n\t\tprintf (\"%f\", act->p.Float);\n\t\tbreak;\n\tcase PUSH_NULL: /* NULL */\n\t\tprintf (\"NULL\" );\n\t\tbreak;\n\tcase PUSH_UNDEF: /* Undefined */\n\t\tprintf (\"undefined\" );\n\t\tbreak;\n\tcase PUSH_REGISTER: /* Register */\n\t\tif( regs[act->p.RegisterNumber] ) {\n\t\t\tprintf (\"%s\", getName(act));\n\t\t} else {\n\t\t\tprintf (\"R%d\", (int)act->p.RegisterNumber);\n\t\t}\n\t\tbreak;\n\tcase PUSH_BOOLEAN: /* BOOLEAN */\n\t\tprintf (\"%s\", act->p.Boolean?\"true\":\"false\");\n\t\tbreak;\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\tprintf (\"%g\", act->p.Double);\n\t\tbreak;\n\tcase PUSH_INT: /* INTEGER */\n\t\tprintf (\"%ld\", act->p.Integer);\n\t\tbreak;\n\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif( wantstring ) t=getString(act);\n\t  \telse t=getName(act);\n\t  \tputs(t);  \n\t  \tfree(t);  \n\t  \tbreak;\n\n#if 0\n\t  case 8: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant8]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant8]);\n\t\tbreak;\n\t  case 9: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant16]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant16]);\n\t\tbreak;\n#endif\n\tcase 12:\n\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n\tcase PUSH_VARIABLE: /* VARIABLE */\n\t\tprintf (\"%s\", act->p.String);\n\t\tbreak;\n\tdefault: \n\t\tprintf (\"  Unknown type: %d\\n\", act->Type);\n\t}\n}\n\nstatic void\ndecompileGETURL (SWF_ACTION *act)\n{\n\tOUT_BEGIN(SWF_ACTIONGETURL);\n\n\tINDENT\n\tprintln(\"getUrl('%s',%s);\", sact->UrlString, sact->TargetString);\n}\n\nstatic int\ndecompileGETURL2 (SWF_ACTION *act)\n{\n\tstruct SWF_ACTIONPUSHPARAM *a,*b;\n\tOUT_BEGIN(SWF_ACTIONGETURL2);\n\tINDENT\n\n\ta = pop();\n\tb = pop();\n\n\tif (sact->f.FlagBits.SendVarsMethod==3)\n\t\tputs(\"loadVariables(\");\n\telse \n\t{\n\t\tif (sact->f.FlagBits.SendVarsMethod==2)\n\t\t\tputs(\"loadVariablesNum(\");\n\t\telse\n\t\t{\n\t\t\tif (sact->f.FlagBits.SendVarsMethod==1) \n\t\t\t\tputs(\"loadMovie(\");\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (*getName(a)=='_')\t// found a _level\n\t\t\t\t\tputs(\"loadMovieNum(\");\t\n\t\t\t\telse\n\t\t\t\t\tputs(\"getURL(\");\n\t\t\t}\n\t\t}\n\t}\n\tdecompilePUSHPARAM (b, 1);\n\tputs(\",\");\n\tdecompilePUSHPARAM (a, 1);\n\tif  (sact->f.FlagBits.LoadVariableFlag)\n\t\tputs(\",'GET'\");\n\tif (sact->f.FlagBits.LoadTargetFlag)\n\t\tputs(\",'POST'\");\n\tprintln(\");\");\n\treturn 0;\n}\n\nstatic inline int OpCode(SWF_ACTION *actions, int n, int maxn)\n{\n\tif(!n || n >= maxn)\n\t{\n#if DEBUG\n\t\tSWF_warn(\"OpCode: want %i, max %i\\n\", n, maxn);\n#endif\n\t\treturn -999;\n\t} else if (n < 1) {\n\n#if DEBUG\n\t\tSWF_warn(\"OpCode: want %i < 1\\n\", n);\n#endif\n\t\treturn -998;\n        }\n\treturn actions[n].SWF_ACTIONRECORD.ActionCode;\n}\n\nstatic int\nisStoreOp(int n, SWF_ACTION *actions,int maxn)\n{\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\tcase SWFACTION_STOREREGISTER:\n\tcase SWFACTION_SETVARIABLE:\n\tcase SWFACTION_SETMEMBER:\n\tcase SWFACTION_CASTOP:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int \ndecompileGOTOFRAME(int n, SWF_ACTION *actions,int maxn,int islabel)\n{\n\tint i=0;\n\tstruct SWF_ACTIONGOTOLABEL *sactv2;\n\tOUT_BEGIN2(SWF_ACTIONGOTOFRAME);\n\tsactv2 = (struct SWF_ACTIONGOTOLABEL*)sact;\n\tINDENT\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_PLAY)\n\t{\n\t\ti=1;\n\t\tputs(\"gotoAndPlay(\");\n\t}\n\telse\n\t{\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_STOP)\n\t\t\ti=1;\n\t\tputs(\"gotoAndStop(\");\n\t}\n\t\n\tif (islabel)\n\t\tprintln(\"'%s');\", sactv2->FrameLabel);\n\telse\n\t\tprintln(\"%d);\", sact->Frame+1); /* GOTOFRAME arg is 0-based */\n\treturn i;\n}\n\nstatic int \ndecompileGOTOFRAME2(int n, SWF_ACTION *actions, int maxn)\n{\n\tint i=0;\n\tOUT_BEGIN2(SWF_ACTIONGOTOFRAME2);\n\tINDENT\n\tif (n+1 < maxn)\n\t{\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_PLAY ||\n\t\t    OpCode(actions, n+1, maxn) == SWFACTION_STOP)\n\t\t\ti=1;\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_PLAY)\n\t\t\tputs(\"gotoAndPlay(\");\n\t\telse\n\t\t{\n\t\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_STOP)\n\t\t\t\tputs(\"gotoAndStop(\");\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sact->f.FlagBits.PlayFlag)\n\t\t\t\t\tputs(\"gotoAndPlay(\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"gotoAndStop(\");\n\t\t\t}\n\t\t}\n\t}\n\telse \n\t{\n\t\tif (sact->f.FlagBits.PlayFlag)\n\t\t\tputs(\"gotoAndPlay(\");\n\t\telse\n\t\t\tputs(\"gotoAndStop(\");\n\t}\n\tdecompilePUSHPARAM(pop(),0);\n\tprintln(\");\");\n\treturn i;\n}\n\n\nstatic int precedence(int op1,int op2)\n{\n\tstatic unsigned char ops[]= { \t\t// array of opcodes w rising precedence\n//\tSWFACTION_SETVARIABLE,\t\t// TAKE CARE: array is incomplete\n//\tSWFACTION_TRACE,\n\t// missing ops are considered with low precedence\n\t\tSWFACTION_LOGICALOR,\n\t\tSWFACTION_LOGICALAND,\n\t\tSWFACTION_BITWISEOR,\n\t\tSWFACTION_BITWISEXOR,\n\t\tSWFACTION_BITWISEAND,\n\t\tSWFACTION_STRICTEQUALS,\n\t\tSWFACTION_EQUALS2,\n\t\tSWFACTION_EQUAL,\n\t\tSWFACTION_GREATER,\n\t\tSWFACTION_LESSTHAN,\n\t\tSWFACTION_LESS2,\t\n\t\tSWFACTION_SHIFTRIGHT,\n\t\tSWFACTION_SHIFTRIGHT2,\n\t\tSWFACTION_SHIFTLEFT,\n\t\tSWFACTION_ADD,\n\t\tSWFACTION_ADD2,\n\t\tSWFACTION_SUBTRACT,\n\t\tSWFACTION_MODULO,\n\t\tSWFACTION_MULTIPLY,\n\t\tSWFACTION_DIVIDE,\n\t\tSWFACTION_LOGICALNOT,\n\t\tSWFACTION_PUSH\t\t\t// FIXME: need more analysis on code after PUSH\n\t};\n\tunsigned char* f=memchr(ops,op1,sizeof(ops));\n\tunsigned char* s=memchr(ops,op2,sizeof(ops));\n#ifdef DEBUG\n\tprintf(\"1op=%d 2op=%d  result=%d\\n\",op1,op2,f>s);\n\tif (!f) printf(\"opcode=%d NOT in precedence list\\n\",op1);\n\tif (!s) printf(\"opcode=%d NOT in precedence list\\n\",op2);\n#endif\n\treturn f>s;\n}\n\n#ifdef DECOMP_SWITCH\nstatic int\ncheck_switch(int firstcode)\n{\n\treturn (firstcode == SWFACTION_PUSH || firstcode == SWFACTION_JUMP);\n}\n#endif\n\n\nstatic int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n\nstatic int\nisLogicalOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\tcase SWFACTION_LESSTHAN:\n\tcase SWFACTION_LOGICALAND:\n\tcase SWFACTION_LOGICALOR:\n\tcase SWFACTION_LOGICALNOT:\n\tcase SWFACTION_STRINGEQ:\n\tcase SWFACTION_STRINGCOMPARE:\n\tcase SWFACTION_LESS2:\n\tcase SWFACTION_EQUALS2:\n\tcase SWFACTION_EQUAL:\n\tcase SWFACTION_BITWISEAND:\n\tcase SWFACTION_BITWISEOR:\n\tcase SWFACTION_BITWISEXOR:\n\tcase SWFACTION_STRICTEQUALS:\n\tcase SWFACTION_GREATER:\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t*/\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int \nisLogicalOp2(int n, SWF_ACTION *actions,int maxn)\n{\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\tcase SWFACTION_LOGICALNOT:\n\tcase SWFACTION_PUSHDUP:\n\tcase SWFACTION_IF:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nstackVal(int n, SWF_ACTION *actions)\n{\n\tif (!n) \n\t\treturn 0;\n\n\tswitch((actions[n-1]).SWF_ACTIONRECORD.ActionCode)\n\t{\n\tcase SWFACTION_LOGICALNOT:\n\tcase SWFACTION_DECREMENT:\n\tcase SWFACTION_INCREMENT:\n\tcase SWFACTION_RANDOMNUMBER:\n\tcase SWFACTION_TOSTRING:\n\tcase SWFACTION_TONUMBER:\n\tcase SWFACTION_ORD:\n\tcase SWFACTION_CHR:\n\tcase SWFACTION_MBORD:\n\tcase SWFACTION_MBCHR:\n\tcase SWFACTION_INT:\n\tcase SWFACTION_GETVARIABLE:\n\tcase SWFACTION_SUBSTRING:\n\tcase SWFACTION_MBSUBSTRING:\n\tcase SWFACTION_GETMEMBER:\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\tcase SWFACTION_SUBTRACT:\n\tcase SWFACTION_MULTIPLY:\n\tcase SWFACTION_DIVIDE:\n\tcase SWFACTION_MODULO:\n\tcase SWFACTION_BITWISEAND:\n\tcase SWFACTION_BITWISEOR:\n\tcase SWFACTION_BITWISEXOR:\n\tcase SWFACTION_LESSTHAN:\n\tcase SWFACTION_LOGICALAND:\n\tcase SWFACTION_LOGICALOR:\n\tcase SWFACTION_STRINGEQ:\n\tcase SWFACTION_STRINGCOMPARE:\n\tcase SWFACTION_LESS2:\n\tcase SWFACTION_EQUALS2:\n\tcase SWFACTION_EQUAL:\n\tcase SWFACTION_STRICTEQUALS:\n\tcase SWFACTION_GREATER:\n\tcase SWFACTION_STRINGGREATER:\n\tcase SWFACTION_STRINGCONCAT:\n\tcase SWFACTION_SHIFTLEFT:\n\tcase SWFACTION_SHIFTRIGHT:\n\tcase SWFACTION_SHIFTRIGHT2:\n\tcase SWFACTION_INSTANCEOF:\n\tcase SWFACTION_CALLMETHOD:\n\tcase SWFACTION_CALLFUNCTION:\n\tcase SWFACTION_GETTIME:\n\tcase SWFACTION_GETPROPERTY:\n\tcase SWFACTION_PUSH:\n\tcase SWFACTION_DELETE:\n\tcase SWFACTION_DELETE2:\n\tcase SWFACTION_MBLENGTH:\n\tcase SWFACTION_STRINGLENGTH:\n\tcase SWFACTION_CASTOP:\n\tcase SWFACTION_TYPEOF:\n\tcase SWFACTION_PUSHDUP:\n\t\treturn 1;\n\tdefault:\n\treturn 0;\n\t}\n}\n\nstatic int\ndecompileLogicalNot(int n, SWF_ACTION *actions, int maxn)\n{\n#ifdef STATEMENT_CLASS\n\tif(OpCode(actions, n-1, maxn) == SWFACTION_GETVARIABLE &&\n\t   OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t   OpCode(actions, n+2, maxn) == SWFACTION_IF ) \n\t{\n\t\t/* It's a class statement  -- skip over both NOTs */\n\t\treturn 1;\n\t}\n#endif\n\tif(OpCode(actions, n+1, maxn) != SWFACTION_IF )\n\t\tpush(newVar2(\"!\",getString(pop())));\n\treturn 0;\n}\n\nstatic void\ndecompilePUSH (SWF_ACTION *act)\n{\n\tint i;\n\tOUT_BEGIN(SWF_ACTIONPUSH);\n\n\tSanityCheck(SWF_PUSH,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH,\n\t\t\"not a PUSH\")\n\n\tfor(i=0;i<sact->NumParam;i++)\n\t\tpush(&(sact->Params[i]));\n}\n\nstatic void\ndecompilePUSHDUP (SWF_ACTION *act)\n{\n\tSanityCheck(SWF_PUSHDUP,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSHDUP,\n\t\t\"not a PUSHDUP\")\n\tpushdup();\n}\n\nstatic void\ndecompileSTACKSWAP (SWF_ACTION *act)\n{\n\tSanityCheck(SWF_STACKSWAP,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_STACKSWAP,\n\t\t\"not a STACKSWAP\")\n\tstackswap();\n}\n\nstatic int\ndecompileSETPROPERTY(int n, SWF_ACTION *actions,int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *val, *idx, *obj;\n\n\tINDENT\n\tval = pop();\n\tidx = pop();\n\tobj = pop();\n#ifdef DEBUG\n\tprintf(\"*setProp* objName %s (type=%d) Prop (type=%d) =%x\\n\",\n\t       getName(obj), obj->Type, idx->Type,getInt(idx));\n#endif\n\tif (obj->Type == PUSH_VARIABLE)\n\t\tputs(\"eval(\");\n\t\n\tdecompilePUSHPARAM(obj,0);\n\tif (obj->Type == PUSH_VARIABLE)\n\t\tputs(\")\");\n\t\n\tputs(\".\");\n\tputs(getProperty(getInt(idx)));\n\tprintf(\" = \" );\n\tdecompilePUSHPARAM(val,0);\n\tprintln(\";\");\n\treturn 0;\n}\n\nstatic int\ndecompileGETPROPERTY(int n, SWF_ACTION *actions,int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *idx, *obj;\n\n\tINDENT\n\tidx = pop();\n\tobj = pop();\n#ifdef DEBUG\n\tprintf(\"*GETProp* objName %s (type=%d) Prop (type=%d) =%x\\n\",\n\t       getName(obj), obj->Type, idx->Type,getInt(idx));\n#endif\n\tif (obj->Type == PUSH_VARIABLE)\n\t\tpush( newVar5(\"eval(\",getName(obj),\".\",getProperty(getInt(idx)),\")\"));\n\telse\n\t\tpush( newVar3( getName(obj),\".\",getProperty(getInt(idx))));\n\treturn 0;\n}\n\nstatic int\ndecompileTRACE(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"trace(\");\n\tdecompilePUSHPARAM(pop(),1);\n\tprintln(\");\");\n\treturn 0;\n}\n\nstatic int\ndecompileCALLFRAME(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"callFrame(\");\n\tdecompilePUSHPARAM(pop(),1);\n\tprintln(\");\");\n\treturn 0;\n}\n\nstatic int\ndecompileGETTIME(int n, SWF_ACTION *actions, int maxn)\n{\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\tINDENT\n\t\tprintln(\"getTimer();\");\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\tpush(newVar(\"getTimer()\"));\n\t\treturn 0;\n\t}\n}\n\nstatic int\ndecompileINCR_DECR(int n, SWF_ACTION *actions, int maxn, int is_incr)\n{\n\tint is_postop;\n\tstruct SWF_ACTIONPUSHPARAM *var=pop();\n\tchar *dblop=is_incr ? \"++\":\"--\";\n\n\tif((OpCode(actions, n, maxn) == SWFACTION_PUSHDUP\n\t     || OpCode(actions, n+1, maxn) == SWFACTION_PUSHDUP \n\t     || OpCode(actions, n+1, maxn) == SWFACTION_SETVARIABLE)\n\t     || ( OpCode(actions, n-1, maxn) == SWFACTION_GETVARIABLE\n\t          &&  OpCode(actions, n+1, maxn) == SWFACTION_STOREREGISTER\n\t          &&  OpCode(actions, n+1, maxn) == SWFACTION_SETVARIABLE))\n\t{\n\t\tis_postop=(OpCode(actions, n-1, maxn) == SWFACTION_PUSHDUP)?1:0;\n\t\tif (is_postop)\n\t\t\tvar = newVar2(getString(var),dblop);\n\t\telse\n\t\t\tvar = newVar2(dblop,getString(var));\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_SETVARIABLE)\n\t\t{\n\t\t\tvar->Type=11;\t/* later trigger printing variable inc/dec */\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar->Type=12;\t/* later be quiet, see decompileSETVARIABLE() */\n\t\t\tif (is_postop)\n\t\t\t{\n\t\t\t\tpop();\n\t\t\t\tpush(var);\t/* will duplicate stacktop */\n\t\t\t}\n\t\t}\n\t\tpush(var);\n\t}\n\telse\n\t{\n\t\tif((OpCode(actions, n-1, maxn) == SWFACTION_GETMEMBER &&\n\t\t    OpCode(actions, n+1, maxn) == SWFACTION_STOREREGISTER &&\n\t\t    OpCode(actions, n+2, maxn) == SWFACTION_SETMEMBER ) ||\n\t\t   (OpCode(actions, n-1, maxn) == SWFACTION_STOREREGISTER &&\n\t    \t    OpCode(actions, n+1, maxn) == SWFACTION_SETMEMBER &&\n\t\t    OpCode(actions, n+2, maxn) == SWFACTION_PUSH ) ||\n\t\t   (OpCode(actions, n-1, maxn) == SWFACTION_PUSH &&\n\t\t    OpCode(actions, n+1, maxn) == SWFACTION_SETMEMBER)  ||\n\t\t   (OpCode(actions, n-3, maxn) == SWFACTION_GETMEMBER &&\n\t\t    OpCode(actions, n-2, maxn) == SWFACTION_PUSH &&\n\t\t    OpCode(actions, n-1, maxn) == SWFACTION_GETMEMBER &&\n\t\t    OpCode(actions, n+1, maxn) == SWFACTION_SETMEMBER &&\n\t    \t((struct SWF_ACTIONPUSH *)&actions[n-2].SWF_ACTIONRECORD)->NumParam >= 4 \n\t    \t\t/* 4: a pair of get/set - FIXME: add more analysis about stack here */))\n\t\t{\t\t// incr/decr object variables with side effects\n\t\t\tis_postop= (OpCode(actions, n+1, maxn) == SWFACTION_SETMEMBER)?1:0;\n\t\t\tif (is_postop)\n\t\t\t\tvar = newVar2(getString(var),dblop);\n\t\t\telse\n\t\t\t\tvar = newVar2(dblop,getString(var));\n\t\t\tif (is_postop && OpCode(actions, n-1, maxn) == SWFACTION_PUSH) \n\t\t\t\tpop();\n\t\t\tif(OpCode(actions, n+1, maxn) == SWFACTION_GETMEMBER) \n\t\t\t\tpop();\n\t\t\t\n\t\t\tpop();\n\t\t\tpop();\n\t\t\tvar->Type=12;\t// to be quiet later in ...SETMEMBER()\n\t\t\tregs[0]=var;\t// FIXME: r0 perhaps a ming special\n\t\t\tpush(var);\n\t\t\tpush(var);\n\t\t\tpush(var);\n\t\t\n\t\t\tif (is_postop && OpCode(actions, n-1, maxn) == SWFACTION_PUSH ) \n\t\t\t\tpush(var);\n\t\t\tif (is_postop && OpCode(actions, n-1, maxn) == SWFACTION_GETMEMBER ) \n\t\t\t\tpush(var);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(OpCode(actions, n-1, maxn) == SWFACTION_PUSH &&\n\t\t\t   OpCode(actions, n+1, maxn) == SWFACTION_STOREREGISTER &&\n\t\t\t   regs[actions[n+1].SWF_ACTIONSTOREREGISTER.Register]->Type == PUSH_VARIABLE)\n\t\t\t{\n\t\t\t\tvar = newVar2(dblop,getString(var));\n\t\t\t\tif ((OpCode(actions, n+2, maxn) == SWFACTION_POP \n\t\t\t\t     && actions[n-1].SWF_ACTIONPUSH.NumParam==1) \n\t\t\t\t    || OpCode(actions, n+3, maxn) == SWFACTION_POP)\n\t\t\t\t{\n\t\t\t\t\tvar->Type=11;\t// later print inc/dec\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar->Type=12;\t// later be quiet in ..STOREREGISTER()\n\t\t\t\t\tif (actions[n-1].SWF_ACTIONPUSH.NumParam>1) \n\t\t\t\t\t{\n\t\t\t\t\t\tpop();\n\t\t\t\t\t\tpush(var);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpush(var);\n\t\t\t}\n\t\t\telse\t\t// fallback to old incr/decr code\n\t\t\t{\t\t// FIXME: this is bad designed for handling side effect code\n\t\t\t\tINDENT\t//        like post-incrementing a function argument etc.\n\t\t\t\tdecompilePUSHPARAM(var,0);\n\t\t\t\tputs(dblop);\n\t\t\t\tprintln(\";\");\n\t\t\t\tpush(var);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileSTOREREGISTER(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *data;\n\tOUT_BEGIN2(SWF_ACTIONSTOREREGISTER);\n\tdata=peek();\n\n\tif (!regs[sact->Register] || sact->Register==0 )\t// ===internal===\n\t{\n\t\tregs[sact->Register] = data;\n\t}\n\telse\t\t\t\t\t\t// ===user visible level===\n\t{\n\t\tif ( regs[sact->Register]->Type == PUSH_VARIABLE) // V7: a named function parameter in register\n\t\t{\t\t\t\t\t\t// V7: a local var in register\n\t\t\tif (data->Type==12)\n\t\t\t\tdata->Type = PUSH_VARIABLE;\t\t\t// do nothing, but only once\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar *l=getName(regs[sact->Register]);\n\t\t\t\tchar *r=getName(data);\n\t\t\t\tif (strcmp(l,r))\n\t\t\t\t{\n\t\t\t\t\tINDENT\n\t\t\t\t\tif (data->Type==11)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintln(\"%s;\", r);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%s = \",l);\n\t\t\t\t\t\tdecompilePUSHPARAM(data,1);\n\t\t\t\t\t\tprintln(\";\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileNEWOBJECT(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *obj, *nparam;\n\tobj = pop();\n\tnparam=pop();\n\tpush(newVar_N(\"new \",\"\",getName(obj),\"(\", nparam->p.Integer,\")\"));\n\treturn 0;\n}\n\nstatic int\ndecompileNEWMETHOD(int n, SWF_ACTION *actions, int maxn)\n{\n\tchar *t;\n\tstruct SWF_ACTIONPUSHPARAM *meth, *nparam, *obj;\n\tmeth = pop();\n\tobj = pop();\n\tnparam=pop();\n\n\tt=malloc(strlen( getName(obj) ) +2);\n\tstrcpy(t,getName(obj));\n\tstrcat(t,\".\");\n\n\tpush(newVar_N(\"new \",t,getName(meth),\"(\", nparam->p.Integer,\")\"));\n\tfree (t);\n\treturn 0;\n}\n\n\nstatic int\ndecompileGETMEMBER(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *obj, *mem, *var;\n\tchar *vname, *varname,*memname;\n\tint len;\n\n\tmem=pop();\n\tvar=pop();\n\tvarname=getName(var);\n\tmemname=getName(mem);\n#ifdef DEBUG\n\tprintf(\"*getMember* varName %s (type=%d)  memName=%s (type=%d)\\n\",\n\t       varname,var->Type, memname,mem->Type);\n#endif\n\tlen = strlen(varname)+strlen(memname);\n\tif (mem->Type == PUSH_INT || mem->Type == PUSH_DOUBLE || mem->Type == PUSH_VARIABLE\n\t    || mem->Type == PUSH_REGISTER || mem->Type == 12 )\n\t{\n\t\tvname = malloc(len+3);\n\t\tstrcpy(vname,varname);\n\t\tstrcat(vname,\"[\");\n\t\tstrcat(vname,memname);\n\t\tstrcat(vname,\"]\");\n\t}\n\telse\n\t{\n\t\tvname = malloc(len+2);\n\t\tstrcpy(vname,varname);\n\t\tstrcat(vname,\".\");\n\t\tstrcat(vname,memname);\n\t} \n\tobj = newVar(vname);\n\tpushvar(obj);\n\n\treturn 0;\n}\n\n\nstatic int\ndecompileSETMEMBER(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *val, *var, *obj;\n\tval = pop();\n\tvar = pop();\n\tobj = pop();\n\n#ifdef DEBUG\n\tprintf(\"*SETMember* varName %s (type=%d)  objName=%s (type=%d)\\n\",getName(var),var->Type, getName(obj),obj->Type);\n#endif\n\tif (obj->Type == 12)\t\t\t\t/* do nothing: inline inc/dec using side effect */\n\t{\n\t\tobj->Type = PUSH_VARIABLE;\t\t/* ...but only once */\n\t\treturn 0;\n\t}\n\tINDENT\n\tif (obj->Type == 11)\t\t\t\t/* simply output variable and inc/dec op */\n\t{\n\t\tdecompilePUSHPARAM(obj,0);\n\t\tprintln(\";\");\n\t\treturn 0;\n\t}\n\n\tdecompilePUSHPARAM(obj,0);\n\tif (var->Type == PUSH_INT || var->Type == PUSH_DOUBLE || var->Type == PUSH_VARIABLE\n\t    || var->Type == PUSH_REGISTER || var->Type == 12 )\n\t{\n\t\tputs(\"[\");\n\t}\n\telse\n\t{\n\t\tputs(\".\");\n\t\tif (OpCode(actions, n-1, maxn) == SWFACTION_STOREREGISTER)\n\t\t{\n\t\t\tstruct SWF_ACTIONSTOREREGISTER *sactv2 = (struct SWF_ACTIONSTOREREGISTER*)&actions[n-1];\n\t\t\tif (sactv2->Register==0)\n\t\t\t\tregs[0]=newVar3(getName(obj),\".\",getName(var));\t\t// easter 07: some sugar for mtc et al.\n\t\t}\n\t}\n\tdecompilePUSHPARAM(var,0);\n\tif (var->Type == PUSH_INT || var->Type == PUSH_DOUBLE || var->Type == PUSH_VARIABLE\n\t\t|| var->Type == PUSH_REGISTER || var->Type == 12 )\n\t{\n\t\tputs(\"]\");\n\t}\n\tprintf(\" = \" );\n\n\n\tif ( OpCode(actions, n-1, maxn) == SWFACTION_STOREREGISTER ) {\n\t\tstruct SWF_ACTIONSTOREREGISTER *sr =\n\t\t\t(struct SWF_ACTIONSTOREREGISTER*)&actions[n-1];\n\t\tprintf(\"R%d\", sr->Register);\n\t}\n\telse if (val->Type != PUSH_VARIABLE) {\n\t\t/* later it will be a switch{} */\n\t\tdecompilePUSHPARAM(val,1);\n\t}\n\telse {\n\t\tdecompilePUSHPARAM(val,0);\n\t}\n\tprintln(\";\");\n\treturn 0;\n}\n\nstatic int\ndecompileGETVARIABLE(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *var;\n\n\tvar = pop();\n#ifdef DEBUG\n\tprintf(\"*GETVariable* varName %s (type=%d)\\n\",getName(var),var->Type);\n#endif\n\tif (var->Type == PUSH_VARIABLE)\n\t\tpushvar(newVar3(\"eval(\",getName(var),\")\"));\n\telse\n\t\tpushvar(newVar(getName(var)));\n\n\treturn 0;\n}\n\nstatic int\ndecompileSETVARIABLE(int n, SWF_ACTION *actions,int maxn,int islocalvar)\n{\n\tstruct SWF_ACTIONPUSHPARAM *val, *var;\n\n\tval = pop();\n\tvar = pop();\n\tif (val->Type!=12)\n\t{\n\t\tINDENT\n\t}\n#ifdef DEBUG\n\tprintf(\"*SETVariable* varName %s (type=%d)  valName=%s (type=%d)\\n\",\n\t       getName(var),var->Type, getName(val),val->Type);\n#endif\n\tif (val->Type!=12 && islocalvar)\n\t{\n\t\tputs(\"var \");\n\t}\n\tif (gIndent<0)\t/* the ENUM workaround:  */\n\t{\t\t\t/* in \"for (xx in yy) { }\" we need xx, but nothing else */\n\t\tputs(getName(var));\n\t\treturn 0;\n\t}\n\n\n\tswitch (val->Type)\n\t{\n\tcase 10:\t\n\t\tputs(getName(var));\t\t// Variable (NEVER as string)\n\t\tprintf(\" = \" );\n\t\tdecompilePUSHPARAM(val,0);\n\t\tprintln(\";\");\n\t\tbreak;\t\t\n\tcase 11:\t\t\t\t/* simply output variable and inc/dec op */\n\t\tputs(getName(val));\n\t\tprintln(\";\");\n\t\tbreak;\n\tcase 12:\t\t\t\t/* do nothing: inline increment/decrement (using side effect only) */\n\t\tval->Type = PUSH_VARIABLE;     \t\t// but print next time  e.g. in y=++x;\n\t\tbreak;\n\tdefault:\t\n\t\tputs(getName(var));\n\t\tprintf(\" = \" );\n\t\tdecompilePUSHPARAM(val,1);\t// for certain types parameter 1 does not care\n\t\tprintln(\";\");\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileRETURN(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *var=pop();\n\tINDENT\n\tprintf(\"return \");\n\tif (var->Type== PUSH_REGISTER && var->p.RegisterNumber==0)\t/* REGISTER 0 used as helper variable */\n\t\tputs(getName(regs[0]));\n\telse\n\t\tdecompilePUSHPARAM(var,1);                                                                                             \n\tprintln(\";\");\n\treturn 0;\n}\n\nstatic int\ndecompileJUMP(int n, SWF_ACTION *actions, int maxn)\n{\n\tint i=0,j=0;\n\tint offSave;\n\tstruct SWF_ACTIONIF *sactif;\n\tOUT_BEGIN2(SWF_ACTIONJUMP);\n\tsactif=NULL;\n\n\tif(isLogicalOp(n+1, actions, maxn) ||\n\t   (OpCode(actions, n+1, maxn) == SWFACTION_PUSH && isLogicalOp(n+2, actions, maxn)))\n\t{\n\t\t/* Probably the start of a do {} while(), so skip it */\n\t\treturn 0;\n\t}\n\n\t/* Probably the end of a switch{}, so skip it */\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t\treturn 1;\n\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_JUMP) \n\t{\n\t\tif (actions[n+1].SWF_ACTIONJUMP.BranchOffset==0)\n\t\t\treturn 1;\n\t}\n\n\tfor(i=0; n + 1 + i < maxn && (actions[(n+1)+i].SWF_ACTIONRECORD.Offset < (actions[n+1].SWF_ACTIONRECORD.Offset+actions[n ].SWF_ACTIONJUMP.BranchOffset)); i++)\n\t{\n#if 0\n\t\tprintf(\"/* for PART3 OP 0x%x */\\n\",actions[n+1+i].SWF_ACTIONRECORD.ActionCode);\n#endif\n\t\t; // NOOP\n\t}\n\n\tif (i)\n\t{\n\t\tfor (j=0; n+j+i<maxn; j++)\n\t\t{\n#if 0\n\t\t\t printf(\"/* FOR part2 OP 0x%x */\\n\",actions[n+i+j].SWF_ACTIONRECORD.ActionCode)\n\t\t\t// at least one should push on stack\n#endif\n\t \n\t\t\tif (OpCode(actions, n+i+j, maxn) == SWFACTION_IF)\n\t\t\t{\n\t\t\t\tsactif = (struct SWF_ACTIONIF *)&(actions[n+i+j]);\n\t\t\t\t/* chk whether last jump does lead us back to start of loop */\n\t\t\t\tif (sactif->Actions[sactif->numActions-1].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP\n\t\t\t\t    && sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.BranchOffset+\n\t\t\t\t    sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.Offset==\n\t\t\t\t    actions[n].SWF_ACTIONRECORD.Offset )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsactif=NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sactif)\n\t{\n\t\tINDENT\n\t\tputs(\"while(\");\n\t\tdecompileActions(j-1, &actions[n+1+i], gIndent);\n\t\tputs(getName(pop()));\n\t\tprintln(\"){         /* original FOR loop rewritten to WHILE */\");\n\t\toffSave=offseoloop;\n\t\tif (n+i+j+1<maxn)\t\t\t\t\t\t// see part2 above\n\t\t\toffseoloop=actions[n+i+j+1].SWF_ACTIONRECORD.Offset;\n\t\telse\n\t\t\toffseoloop=actions[n+i+j].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(sactif->numActions-1, sactif->Actions,gIndent+1);\n\t\tdecompileActions(i, &actions[n+1], gIndent+1);\n\t\toffseoloop=offSave;\n\t\tINDENT\n\t\tprintln(\"};\");\n\t\treturn i+j; \n\t}\n\t\n\tif (sact->BranchOffset>0)\n\t{\n\t\tif ( stackVal(n,actions) == 1 && n+1==maxn)\n\t\t{\t// leaving block @last op with value on stack: a return x;\n\t\t\treturn decompileRETURN(n, actions,maxn);\n\t\t}\n\t\tif (n+2 < maxn && OpCode(actions, n+1, maxn) == SWFACTION_PUSH && \n\t\t\tactions[n+2].SWF_ACTIONRECORD.Offset == actions[n+1].SWF_ACTIONRECORD.Offset+sact->BranchOffset)\n\t\t{\n\t\t\treturn 1; \t// jump to short to be a 'break': but an internal jump over a push\n\t\t}\t\t\t// to do: add some control flow analysis\n\t\t\n\t\tINDENT\n\t\t\n\t\tif (offseoloop==actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5)\n\t\t\tputs(\"break;\" );\n\t\telse\n\t\t\tputs(\"return;\" );\n\t\t\n\t\tprintln(\"\\t\\t\\t// offs_end_of_loop=%d  offs_jmp_dest=%d\",\n\t\t        offseoloop, actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5);\n\t}\n\telse\n\t{\n\t\tif (sact->BranchOffset<0)\n\t\t{\n\t\t\tINDENT\n\t\t\tprintln(\"continue;     /*------*/\");\n\t\t}\n\t}\n\t/* error(\"Unhandled JUMP\"); */\n\treturn 0;\n}\n\nstatic int\ndecompileDEFINELOCAL2(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *var;\n\n\tINDENT\n\tvar = pop();\n\tputs(\"var \");\n\tputs(getName(var));\n\tprintln(\";\");\n\n\treturn 0;\n}\n\nstatic int \ndecompileENUMERATE(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n\tint i=0;\n\twhile (i < maxn && i < 5 && OpCode(actions, n+i, maxn))\n\t\ti++;\n\t\n\tINDENT  \n\tprintln(\"/* a for-var-in  loop should follow below: */\" );\n\treturn i-1;\t\t// preserve some code for decompileIF()... \n} \t\t\t\t// ... and let decompileIF() do all the dirty work ;-)\n\n\n#ifdef DECOMP_SWITCH\n\n// [recursive] estimate size of buffer needed for decompiling 'switch' \n// [ only call by decompileIF() ]\n//\nstatic int\ncountAllSwitchActions (union SWF_ACTION *actions, union SWF_ACTION *pre)\n{\n\tint i,j=1;\n\tif (actions->SWF_ACTIONRECORD.ActionCode==SWFACTION_IF && pre->SWF_ACTIONRECORD.ActionCode==SWFACTION_STRICTEQUALS )\n\t{\n\t\tfor(i=0; i < ((struct SWF_ACTIONIF*)actions)->numActions; i++)\n\t\t{\n\t\t\tj+=countAllSwitchActions(&((struct SWF_ACTIONIF*)actions)->Actions[i],pre);\n\t\t\tpre=&((struct SWF_ACTIONIF*)actions)->Actions[i];\n\t\t}\n\t}                  \n\treturn j;\n}\n\n\n// [recursive] copy all actions in a 'flat' buffer by \n// unpackung all if-actions that are part of the switch operation\n// [ only call by decompileIF() ]\n//\nstatic union SWF_ACTION *\ngetAllSwitchActions(union SWF_ACTION *dest, union SWF_ACTION *actions, union SWF_ACTION *pre)\n{\n#ifdef DEBUGSWITCH\n\tprintln(\"SWCODE: %p %d %s   %s\",\n\t        dest, actions->SWF_ACTIONRECORD.Offset, \n\t        actionName(actions->SWF_ACTIONRECORD.ActionCode),\n\t        actionName(pre->SWF_ACTIONRECORD.ActionCode));\n#endif\n\n\t*dest++=*actions;\n\tif (actions->SWF_ACTIONRECORD.ActionCode==SWFACTION_IF \n\t    && pre->SWF_ACTIONRECORD.ActionCode==SWFACTION_STRICTEQUALS )\n\t{\n\t\tint i;\n\t\tstruct SWF_ACTIONIF *sactv2 = (struct SWF_ACTIONIF*)actions;\n\t\tfor(i=0; i< sactv2->numActions; i++)\n\t\t{\n\t\t\tdest=getAllSwitchActions(dest,&sactv2->Actions[i],pre);\n\t\t\tpre=&((struct SWF_ACTIONIF*)actions)->Actions[i];\n\t\t}\n\t}\n\treturn dest;\n}\n\n// looks similar other decompileXXXX() but \n// can't called by decompileAction()\n// [ do only call by decompileIF() ]\n//\nstatic int\ndecompile_SWITCH(int n, SWF_ACTION *actions, int maxn, int off1end)\n{\n\tint i,j;\n\tint start;\t\t// base action index for case value and code\n\tint ccsize=0;\t\t// size of code for case value\n\tint cvsize=0;\t\t// size of case value\n\tint maxoff=0;\t\t// action offset AFTER switch\n\tint n_maxoff=0;\t\t// array index of maxoff\n\tint pend=0;\t\t// control pending output\n\tint xsize=0;\t\t// ret val\n\tint jmpsize=0;\t\t// debug helper\n\tint lastoff=0;\t\t// debug helper\n\tint n_firstactions=maxn;// array index of 1st case actions code\n\tint lastcasestart=0;\t// offs where last \"case x:\" begins\n\tchar *defa=\"[last]\";\t// debug helper for early \"default:\" \n\tchar *tmp=NULL;\t\t// helper for pending output\n\tstruct strbufinfo origbuf;\t// pending output buffer\n\tstruct _stack *StackSave;\n\tstruct SWF_ACTIONPUSHPARAM *swcopy,*sw=pop();\n\tstruct SWF_ACTIONPUSHPARAM *compare=pop();\n\tint offSave;\n\tfor (i=0; i<n_firstactions; i++) // seek last op in 1st if\n\t{\n\t\tif (actions[i+1].SWF_ACTIONRECORD.Offset==off1end)\n\t\t{\n\t\t\t// println(\"found #off end first= %d\",i+1);\n\t\t\tif (OpCode(actions, i, maxn) == SWFACTION_JUMP)\n\t\t\t{\n\t\t\t\tmaxoff=actions[i].SWF_ACTIONJUMP.BranchOffset+actions[i].SWF_ACTIONJUMP.Offset+5;\n\t\t\t\tj=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// SanityCheck(decompile_SWITCH,0,\"no jump found where expected\");\n\t\t\t}\n\t\t\tbreak;\n\t\t} \n\t}\n\t\n\tif (!maxoff)\n\t{\n\t\tfor (i=maxn-1;i>=0;i--)\t\t\t// seek from end of block last op of switch{}\n\t\t{\n\t\t\tif (OpCode(actions, i, maxn) == SWFACTION_JUMP && !actions[i].SWF_ACTIONJUMP.BranchOffset)\n\t\t\t{\n\t\t\t\tmaxoff=actions[i].SWF_ACTIONRECORD.Offset+5;\n\t\t\t\tj=2;\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\t}\n\n\tfor (i=0;i<maxn;i++)\t\n\t{\n\t\tif (actions[i].SWF_ACTIONRECORD.Offset>=maxoff)\n\t\t{\n\t\t\tn_maxoff=i;\t\t// part of block is switch\n\t\t\tbreak;\n\t\t}\n\t}\n\t\t\n\tif (!n_maxoff) \n\t\tn_maxoff=maxn;\t\t\t// whole block is switch\n\n\tINDENT\n\tprintln(\"switch( %s ) {\t\t\t// end switch at %d (index %d) / found via meth %d)\",\n\t        getString(sw), maxoff,n_maxoff,j);\n\t\t\n\tpush(sw);\n\tpush(compare);\n\n\ti=1;\n\tdo \t\t\t\t\t// here we go into main loop\n\t{\n\t\tif((OpCode(actions, i, maxn) == SWFACTION_IF\n\t\t   && OpCode(actions, i-1, maxn) == SWFACTION_STRICTEQUALS )\n\t\t   ||(OpCode(actions, i, maxn) == SWFACTION_JUMP\n\t\t   && OpCode(actions, i-1, maxn) == SWFACTION_IF) )\n\t\t{\n\t\t\tstart=i;\n\t\t\twhile (start<maxn \n\t\t\t       && actions[start].SWF_ACTIONRECORD.Offset < actions[i].SWF_ACTIONRECORD.Offset+5+actions[i].SWF_ACTIONJUMP.BranchOffset\n)\t\t\t{\n\t\t\t\tstart++;\t\t// count actions until start of \"case x:\"\n\t\t\t}\n\t\t\tif (n_firstactions==maxn) // if not done store earliest \"case x: \"actions\n\t\t\t{\n\t\t\t\tn_firstactions=start;\t// same as array index\n\t\t\t}\n\n\t\t\tfor (ccsize=0; ccsize+start<n_maxoff; ccsize++)\t// count actions belonging to \"case x:\"\n\t\t\t{\n#ifdef DEBUGSWITCH\n\t\t\t\tprintln(\"in ccsize: ccsize=%d  off=%d %s\",\n\t\t\t\t        ccsize,actions[ccsize+start].SWF_ACTIONRECORD.Offset,\n\t\t\t\t        actionName(OpCode(actions, ccsize+start, maxn)));\n#endif\n\t\t\t\tif (OpCode(actions, ccsize+start, maxn) == SWFACTION_JUMP)\n\t\t\t\t{\n\t\t\t\t\tif (maxoff == actions[ccsize+start].SWF_ACTIONJUMP.Offset+5 + actions[ccsize+start].SWF_ACTIONJUMP.BranchOffset)\n\t\t\t\t\t{\n\t\t\t\t\t\tjmpsize= actions[ccsize+start].SWF_ACTIONJUMP.BranchOffset;\n\t\t\t\t\t\tlastoff= actions[ccsize+start].SWF_ACTIONJUMP.Offset;\n\t\t\t\t\t\tccsize++; // the jmp itself\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n#if USE_LIB\n\t\t\tif (tmp && (start!=pend)) // output pending buffer if neccessary\n\t\t\t{\n\t\t\t\tputs(tmp);\n\t\t\t}\n\t\t\t\n\t\t\tif (tmp)\n\t\t\t{\n\t\t\t\tfree(tmp);\n\t\t\t\ttmp=NULL;\n\t\t\t}\n\t\t\tpend=start;\n#endif\n\t\t\tif (OpCode(actions, i, maxn) == SWFACTION_JUMP)\n\t\t\t{\n\t\t\t\tif (ccsize<=1)\n\t\t\t\t\tbreak;\t// ready\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tINDENT\n\t\t\t\t\tif (actions[start].SWF_ACTIONRECORD.Offset>lastcasestart)\n\t\t\t\t\t\txsize+=ccsize;        \n\t\t\t\t\telse\n\t\t\t\t\t\tdefa=\"[early]\";\n\t\t\t\t\t\tprintln(\"default:\t\t\t// at %d %s start=%d ccsize=%d\",\n\t\t\t\t\t\t        actions[start].SWF_ACTIONRECORD.Offset,defa, start, ccsize);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tINDENT\n\t\t\t\txsize=ccsize;\n\t\t\t\tlastcasestart=actions[start].SWF_ACTIONRECORD.Offset;\n\t\t\t\tprintln(\"case %s:\t\t\t// at %d  start=%d ccsize=%d jmp=%d+%d+5\",\n\t\t\t        getString(pop()), lastcasestart, start, ccsize, lastoff,jmpsize);\n\t\t\t\tswcopy=pop();\n\t\t\t\t//   SanityCheck(decompile_SWITCH,!strcmp(getName(swcopy),getName(sw)),\"sw0 != sw\");\n\t\t\t}\n\n#if USE_LIB\n\t\t\torigbuf=setTempString(); // switch to temp buffer\n#endif\n\t\t\tStackSave=Stack;\n\t\t\toffSave=offseoloop;\n\t\t\toffseoloop=maxoff;\n\t\t\tdecompileActions( ccsize, &actions[start],gIndent+1);\n\t\t\toffseoloop=offSave;\n\t\t\tStack=StackSave;\n#if USE_LIB\n\t\t\ttmp=switchToOrigString(origbuf);\n#endif\n\n\t\t\tif (OpCode(actions, i, maxn) == SWFACTION_JUMP)\t\t// after \"default:\"\n\t\t\t{\n\t\t\t\tbreak;     \t\t\t\t\t\t\t// ready\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (OpCode(actions, i+1, maxn) != SWFACTION_JUMP) \t// not before \"default:\" or end\n\t\t\t\t{\n\t\t\t\t\ti++; // the 'if' itself\n\t\t\t\t\tcvsize=0;\n\t\t\t\t\twhile (i+cvsize < n_firstactions \n\t\t\t\t\t       && OpCode(actions, i+cvsize, maxn) != SWFACTION_STRICTEQUALS)\n\t\t\t\t\t{\n#ifdef DEBUGSWITCH\n\t\t\t\t\t\tprintln(\"in  cvsize=%d  %d %s\",\n\t\t\t\t\t\t        cvsize, actions[i+cvsize].SWF_ACTIONRECORD.Offset,\n\t\t\t\t\t\t        actionName(OpCode(actions, i+cvsize, maxn)));\n#endif\n\t\t\t\t\t\t\tcvsize++;\t// count \"case X:\" code size\n\t\t\t\t\t}\n\t\t\t\t\tdecompileActions( cvsize, &actions[i],gIndent+1); // at least one push on stack expected\n\t\t\t\t\ti+=cvsize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (++i < n_firstactions);\n\n#if USE_LIB\n\tif (tmp)\n\t{\n\t\tputs(tmp);\t\t// print last pending output\n\t\tfree(tmp);\n\t}\n#endif\t\n\tINDENT\n\tprintln(\"}\t\t\t\t\t// switch ret value =%d\",xsize);\n\treturn xsize;\n}\n#endif\n\nstatic int\ndecompileIF(int n, SWF_ACTION *actions, int maxn)\n{\n\tint offSave;\n\tint j,i=0;\n\tstruct strbufinfo origbuf;\n\tOUT_BEGIN2(SWF_ACTIONIF);\n\n        if (sact->numActions < 1) {\n            return 0;\n        }\n\n\t/*\n\t* IF is used in various way to implement different types\n\t* of loops. We try to detect these different types of loops\n\t* here.\n\t*/\n\n#ifdef STATEMENT_CLASS\n\tif((OpCode(actions, n-1, maxn) == SWFACTION_LOGICALNOT) &&\n\t   (OpCode(actions, n-2, maxn) == SWFACTION_LOGICALNOT) &&\n\t   (OpCode(actions, n-3, maxn) == SWFACTION_GETVARIABLE) &&\n\t   (OpCode(actions, n-4, maxn) == SWFACTION_PUSH) ) \n\t{\n\t    /* It's really a class definition */\n\t\tINDENT\n\t\tputs(\"class \");\n\t\tdecompilePUSHPARAM(newVar(getName(pop())),0);\n\t\tprintln(\" {\" );\n\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\treturn 0;\n\t}\n\n\tif( \n\t   (OpCode(actions, n-1, maxn) == SWFACTION_LOGICALNOT) &&\n\t   (OpCode(actions, n-2, maxn) == SWFACTION_LOGICALNOT) &&\n\t   (OpCode(actions, n-3, maxn) == SWFACTION_GETMEMBER) &&\n\t   (OpCode(actions, n-4, maxn) == SWFACTION_PUSH) ) \n\t{\n\t    /* It's really a class definition */\n\t\tINDENT\n\t\tprintln(\" {\");\n\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\treturn 0;\n\t}\n#endif\n\t/*\n\t * do {} while() loops have a JUMP at the end of the if clause\n\t * that points to a JUMP above the IF statement.\n\t */\n\tif(n && isLogicalOp(n-1, actions, maxn) &&\n\t   (sact->Actions[sact->numActions-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_JUMP) &&\n\t   ( (sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.Offset +\n\t      sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset) < actions[n].SWF_ACTIONRECORD.Offset) &&\n\t      isLogicalOp(sact->numActions-2, sact->Actions, maxn) ) \n\t{\n\t\tINDENT\n\t\tprintln(\"do {\");\n\t\toffSave=offseoloop;\n\t\toffseoloop=actions[n].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(sact->numActions-1, sact->Actions,gIndent+1);\n\t\toffseoloop=offSave;\n\t\tINDENT\n\t\tputs(\"while( \");\n\t\tputs(getName(pop()));\n\t\tputs(\");\");\n\t\treturn 0;\n\t}\n\n\t/* ak,2006\n\t * lots of \"do {} while()\" have simply a CONDITIONED JUMP back at the end of the loop\n\t */\n\tif( actions[n].SWF_ACTIONJUMP.BranchOffset < 0 ) \n\t{\n\t\tINDENT\n\t\tprintln(\"do {                  /* 2nd type */ \");\n\t\toffSave=offseoloop;\n\t\toffseoloop=actions[n  ].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\toffseoloop=offSave;\n\t\tINDENT\n\t\tputs(\"} while( \");\n\t\tputs(getName(pop()));\n\t\tprintln(\");\");\n\t\treturn 0;\n\t}\n\n\tj=0;\n\twhile (OpCode(actions, n-j, maxn) != SWFACTION_ENUMERATE  && \n\t        OpCode(actions, n-j, maxn) != SWFACTION_ENUMERATE2 && j<n && j<5) \n\t{\n\t\tj++;\t\t// check for a pending ENUMERATE\n\t}\n\t\n\tif ((OpCode(actions, n-j, maxn) == SWFACTION_ENUMERATE ||\n\t     OpCode(actions, n-j, maxn) == SWFACTION_ENUMERATE2 ) && \n\t      OpCode(actions, n-j+1, maxn) == SWFACTION_STOREREGISTER )\n\t{\n\t\tstruct SWF_ACTIONPUSHPARAM *var;\n\t\tint x;\n\t\tvar = pop();\n\t\tINDENT\n\t\tputs(\"for ( \");\n\t\t// check for an usual special case w register Rx\n\t\tif (sact->Actions[1].SWF_ACTIONRECORD.ActionCode == SWFACTION_STOREREGISTER)\n\t\t{\n\t\t\tstruct SWF_ACTIONSTOREREGISTER *sactv2 = (struct SWF_ACTIONSTOREREGISTER*)&sact->Actions[1];\n\t\t\tputs(\"var \");\n\t\t\tputs(getName(regs[sactv2->Register]));\n\t\t\tx=3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdecompileActions( 2 , sact->Actions,-1);   /* -1 == the ENUM workaround */\n\t\t\tx=2;\n\t\t}\n\t\tputs(\" in \");\n\t\tputs(getName(var));\n\t\tprintln(\" ) {\");\n\t\tif(n+1 >= maxn)\n\t\t{\n\t\t\tSWF_warn(\"Warning: %s:%i: something is wrong here\\n\", __FILE__, __LINE__);\n\t\t}\n\t\telse \n\t\t{\n\t\t\toffSave=offseoloop;\n\t\t\toffseoloop=actions[n+1].SWF_ACTIONRECORD.Offset;\n\t\t\tdecompileActions(sact->numActions-1-x, &sact->Actions[x],gIndent+1);\n\t\t\toffseoloop=offSave;\n\t\t}\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * while() loops have a JUMP at the end of the if clause that jumps backwards\n\t * But also \"continue\" statements could jump backwards.\n\t */\n\t\n\tif( isLogicalOp(n-1, actions, maxn) &&\n\t    ( (sact->Actions[sact->numActions-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_JUMP) &&\n\t       sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset < 0) ) \n\t{\n\t\tif(0)\t    dumpRegs();\n\t\tINDENT\n\t\t/* if on a level >0 we can check for any outer loop \n\t\t   To do: get the level on a better way than using gIndent */\n\t\tif (gIndent\t\n\t\t    && OpCode(actions, maxn-1, maxn) == SWFACTION_JUMP\n\t  \t    && actions[maxn-1].SWF_ACTIONJUMP.Offset+actions[maxn].SWF_ACTIONJUMP.BranchOffset==\n\t               sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.Offset+sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset)\n\t\t{      \n\t\t   /* this jump leads from a block to start of a loop on outer block:\n\t\t       it is an 'if' later followed by last action 'continue' */\n\t\t   SWF_warn(\"WARNING: this might be wrong (%s:%i)\\n\", __FILE__, __LINE__);\n\t\t   puts(\"if ( \");\n\t\t   puts(getName(pop()));\n\t\t   println(\" ) {\");\n\t\t   decompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\t}\n\t\telse\t/* while(){}  as usual */\n\t\t{\n\t\t\tputs(\"while( \");\n\t\t\tputs(getName(pop()));\n\t\t\tprintln(\" ) {\");\n\t\t\toffSave=offseoloop;\n\t\t\toffseoloop=actions[n+1].SWF_ACTIONRECORD.Offset;\n\t\t\tdecompileActions(sact->numActions-1, sact->Actions,gIndent+1);\n\t\t\toffseoloop=offSave;\n\t\t}\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\treturn 0;\n\t}\n\t{ // WTF ???\n#define SOME_IF_DEBUG 0\t/* coders only */\n\t\tint has_else_or_break= ((sact->Actions[sact->numActions-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_JUMP) &&\n\t\t\t(sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset > 0 )) ? 1:0;\n\t\tint has_lognot=(OpCode(actions, n-1, maxn) == SWFACTION_LOGICALNOT) ? 1:0;\n\t\tint else_action_cnt=0,is_logor=0,is_logand=0,sbi,sbe;\n\n\t\t/* before emitting any \"if\"/\"else\" characters let's check \n\t\t\tfor a ternary operation  cond?a:b \n\t\t*/\n\t\tif (has_else_or_break)\n\t\t{\n\t\t\tint limit=actions[n+1].SWF_ACTIONRECORD.Offset + sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset;\n\t\t\t/* Count the number of action records that are part of\n\t\t\t * the else clause, and then decompile only that many.\n\t\t\t */\n\t\t\tfor(else_action_cnt=0;\n\t\t\t    else_action_cnt+n+1<maxn && actions[n+1+else_action_cnt].SWF_ACTIONRECORD.Offset < limit;\n\t\t\t    else_action_cnt++)\n\t\t\t{\n#if SOME_IF_DEBUG\n\t\t\t\tprintln(\"/* ELSE OP 0x%x at %d*/\", OpCode(actions, n+1+else_action_cnt, maxn),\n\t\t\t\tactions[n+1+else_action_cnt].SWF_ACTIONRECORD.Offset)\n#endif\n\t\t\t\t;\n\t\t\t}  \n\t\t}\n\t\ti=else_action_cnt; \t\t// =return value\n\t\tsbi=stackVal (sact->numActions-1,sact->Actions);\n\t\tsbe=stackVal (else_action_cnt,&actions[n+1]);\n\n\t\t// check against opcodes we do not expect in a ternary operation\n\t\tif (sbi==1 && sbe==1)\n\t   \t{\n\t\t\tfor (j=0;j<sact->numActions-1;j++)\n\t\t\t{\n\t\t\t\tif (sact->Actions[j].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP) // perhaps more ops\n\t\t\t\t{\n\t\t\t\t\tsbi=i=has_else_or_break=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0;j<else_action_cnt;j++)\n\t\t\t{\n\t\t\t\tif (OpCode(actions, n+j, maxn) == SWFACTION_JUMP) // perhaps more ops\n\t\t\t\t{\n\t\t\t\t\tsbe=i=has_else_or_break=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if SOME_IF_DEBUG\n\t\tprintf(\"sbi=%d   sbe=%d\\n\", sbi,sbe);\n#endif\n\t\tif (sbi==1 && sbe==1)\n\t\t{\n#if SOME_IF_DEBUG\n\t\t\tprintln(\"/* ****Found ternary ternary operation  \\\"cond ? a : b\\\"    **** */\");\n\t\t\tprintf(\"If   Actions=%d\\n\",sact->numActions-1);\n\t\t\tprintf(\"Else Actions=%d\\n\",else_action_cnt);\n#endif\n\t\t\tstruct strbufinfo origbuf;\n#if USE_LIB\n\t\t\torigbuf=setTempString();\t/* switch to a temporary string buffer */\n#endif\n\t\t\tputs(\"(\");\n\t\t\tputs(getName(pop()));\n\t\t\tputs(\" ? \");\n\t\t\tdecompileActions(else_action_cnt  , &actions[n+1],0);\n\t\t\tputs(getName(pop()));\n\t\t\tputs(\" : \");\n\t\t\tdecompileActions(sact->numActions-1, sact->Actions,0);\n\t\t\tputs(getName(pop()));\n\t\t\tputs(\")\");\n#if USE_LIB\n\t\t\tpush (newVar(dcgetstr()));\t/* push for later assignment */\n\t\t\tsetOrigString(origbuf);\t\t/* switch back to orig buffer */\n#else\n\t\t\tpush (newVar(\"/* ternary op: see code above */\"));\n#endif\n\t\t} \n\t\telse\n\t\t{\n\t\t/* at this point let's check for conditioned jumps that are NOT 'if':\n\t      \tcurrently that is code for the locical operations  && and ||\n\t   \t*/\n\t\t\tif (OpCode(actions, n-1, maxn) == SWFACTION_PUSHDUP)\n\t\t\t\tis_logor=1;\n\t\t\t\n\t\t\tif (OpCode(actions, n-2, maxn)== SWFACTION_PUSHDUP\n\t\t\t    && OpCode(actions, n-1, maxn) == SWFACTION_LOGICALNOT)\n\t\t\t{\n\t\t\t\tis_logand=1;\n\t\t\t}\n\n\t\tif (is_logor || is_logand)    \n\t\t{\n#if SOME_IF_DEBUG\n\t\t\tprintln(\"\");\n\t\t\tprintln(\"/* detected LOGICAL %s: %d actions*/\", is_logor ? \"OR\":\"AND\",sact->numActions);\n#endif\n#if USE_LIB\n\t\t\torigbuf=setTempString();\t/* switch to a temporary string buffer */\n#endif\n\n\t\t\tputs(getName(pop()));\t/* get left side of logical or */\n\t\t\tputs(is_logor ? \" || \":\" && \");\n\t\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\t\tputs(getName(pop()));\t/* get right side of logical or */\n#if USE_LIB\n\t\t\tpush(newVar(dcgetstr()));\n\t\t\tsetOrigString(origbuf);\t/* switch back to orig buffer */\n#else\n\t\t\tpush (newVar(\"/* see logical term lines above */\")); \n#endif\n\t\t\treturn 0;\n\t\t}\n#ifdef DECOMP_SWITCH\n\t\tif ( OpCode(actions, n-1, maxn) == SWFACTION_STRICTEQUALS\n\t\t     && check_switch(sact->Actions[0].SWF_ACTIONRECORD.ActionCode) )\n\t\t{\n\t\t\tunion SWF_ACTION *xact,*xact0;\n\t\t\tfor(i=n-1,j=0; i< maxn ;i++)\t// n-1 due adding 1st SWFACTION_STRICTEQUALS in buffer\t\n\t\t\t{\n\t\t\t\tj+=countAllSwitchActions(&actions[i],&actions[i-1]); \t\t// FIRST count size of code\n\t\t\t}\n\t\t\txact0=xact = (union SWF_ACTION *) calloc (j,sizeof (SWF_ACTION));\n\t\t\tINDENT\n\t\t\tprintln(\"// checking %d actions for switch(){}\",j);\n\t\t\tfor(i=n-1; i< maxn ;i++)\n\t\t\t{\n\t\t\t\txact=getAllSwitchActions(xact,&actions[i],&actions[i-1]);\t// SECOND copy into xtra buffer\n\t\t\t}\n\t\t\tj=decompile_SWITCH(0,xact0,j,actions[n+1].SWF_ACTIONRECORD.Offset);\t// THIRD decompile xtra buffer\n\t\t\tfree(xact0);\n\t\t\treturn j;\n\t\t}\n#endif\n\t\t/* it seems we have a found the REAL 'if' statement,\n\t\tso it's right time to print the \"if\" just NOW!\n\t\t*/\n\t\tINDENT\n\t\tputs(\"if( \");\n\t\tputs(getName(pop()));\t/* the condition itself */\n\t\tprintln(\" ) {\");\n\t\tif ( has_else_or_break )\n\t\t{\n\t\t\tint limit=actions[n+1].SWF_ACTIONRECORD.Offset + sact->Actions[sact->numActions-1].SWF_ACTIONJUMP.BranchOffset;\n\t\t\t// limit == dest of jmp == offset next op after 'if' + jumpdist at end of 'if'\n\t\t\tint lastopsize=actions[maxn-1].SWF_ACTIONRECORD.Length;\n\t\t\tif (OpCode(actions, maxn-1, maxn) == SWFACTION_IF)\n\t\t\t\tlastopsize+=actions[maxn-1].SWF_ACTIONIF.BranchOffset + 3; /* +3 see parser.c: \"Action + Length bytes not included in the length\" */\n\t\t\t\n\t\t\tif (offseoloop \n\t\t\t    &&  ! (has_lognot\n\t\t\t    && OpCode(actions, n-2, maxn) == SWFACTION_EQUALS2 \n\t\t\t    && OpCode(actions, n-3, maxn) == SWFACTION_PUSH\n\t\t\t    && OpCode(actions, n-4, maxn) == SWFACTION_PUSHDUP)\n\t\t\t    && limit > actions[maxn-1].SWF_ACTIONRECORD.Offset+lastopsize)\n\t\t\t{\n\t\t\t\t/* the jump leads outside this limit, so it is a simple 'if'\n\t\t\t\twith a 'break' or 'return' at the end, and there is NO else clause.\n\t\t\t\t*/  \n\t\t\t\tINDENT\n\t\t\t\tprintln(\"// offs_endjump_dest=%d  offs_after_blk %d\",\n\t\t\t\t        limit, actions[maxn-1].SWF_ACTIONRECORD.Offset+lastopsize);\n\t\t\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\t\t\ti=0;\t\t\t/* found break/return but no else and thus return 0 */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* There is an else clause also! \n\t\t\t\t(action counter is set above)\n\t\t\t\t*/\n\t\t\t\tstruct _stack *StackSave=Stack;\t/* decompile if and else blocks at same stack base */\n\t\t\t\tif  (has_lognot)\n\t\t\t\t{\n\t\t\t\t\tdecompileActions(sact->numActions-1, sact->Actions,gIndent+1);\n\t\t\t\t\tINDENT\n\t\t\t\t\tprintln(\"} else {\");\n\t\t\t\t}\t      \n\t\t\t\tStack=StackSave;\n\t\t\t\tdecompileActions(else_action_cnt  , &actions[n+1],gIndent+1);\n\t\t\t\tif  (!has_lognot)\t\t/* the missing if-part just NOW */\n\t\t\t\t{\n\t\t\t\t\tStack=StackSave;\n\t\t\t\t\tINDENT\n\t\t\t\t\tprintln (\"} else {\" );\n\t\t\t\t\tdecompileActions(sact->numActions-1, sact->Actions,gIndent+1);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\t/* It's a simple if() {} */\n\t\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\t\t}\n\t\tINDENT\n\t\tprintln(\"}\");\n\t} // WTF ???\n\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileINITOBJECT(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *nparam;\n\tnparam=pop();\n\tpush(newVar_N2(\"\",\"\",\"\",\"{\", nparam->p.Integer,\"}\"));\n\treturn 0;\n}\n\nstatic int\ndecompileWITH(int n, SWF_ACTION *actions, int maxn)\n{\n\tOUT_BEGIN2(SWF_ACTIONWITH);\n\n\tINDENT\n\tputs(\"with(\");\n\tdecompilePUSHPARAM(pop(),0);\n\tputs(\")\");\n\tprintln(\" {\" );\n\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n\tINDENT\n\tprintln(\"}\" );\n\n\treturn 1;\n}\n\nstatic int\ndecompileTRY(int n, SWF_ACTION *actions, int maxn)\n{\n#ifdef DEBUG\n\tstruct _stack *StackSave=Stack;\n#endif    \n\tOUT_BEGIN2(SWF_ACTIONTRY);\n\tINDENT\n\tprintln(\"try {\");\n\tdecompileActions(sact->numTryActs, sact->TryActs,gIndent+1);\n\tINDENT\n\tprintln(\"}\");\n#ifdef DEBUG\n\tif (Stack!=StackSave)\n\t{\n\t\tprintln(\"/* Stack problem in try{} code above */\");\n\t\tStack=StackSave;\n\t}\n#endif\n\tif (sact->numCatchActs)    \n\t{\n\t\tstruct SWF_ACTIONPUSHPARAM *rsave=NULL;\n\t\tINDENT\n\t\tif( ! sact->CatchInRegisterFlag)\n\t\t\tprintln(\"catch (%s) {\",sact->CatchName);\n\t\telse\n\t\t{\n\t\t\tchar *t=malloc(5); /* Rddd */\n\t\t\tsprintf(t,\"R%d\", sact->CatchRegister );\n\t\t\trsave=regs[sact->CatchRegister];\n\t\t\tregs[sact->CatchRegister] = newVar(t);\n\t\t\tprintln(\"catch (%s) {\",t);\n\t\t}\n\t\tdecompileActions(sact->numCatchActs, sact->CatchActs,gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\");\n\t\tif (rsave)\n\t\t\tregs[sact->CatchRegister]=rsave;\n#ifdef DEBUG\n\t\tif (Stack!=StackSave)\n\t\t{\n\t\t\tprintln(\"/* Stack problem in catch{} code above */\");\n\t\t\tStack=StackSave;\n\t\t}\n#endif\n\t} \n\tif (sact->numFinallyActs)\n\t{\n\t\tINDENT\n\t\tprintln(\"finally () {\");\n\t\tdecompileActions(sact->numFinallyActs, sact->FinallyActs,gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\");\n#ifdef DEBUG\n\t\tif (Stack!=StackSave)\n\t\t{\n\t\t\tprintln(\"/* Stack problem in finally{} code above */\");\n\t\t\tStack=StackSave;\n\t\t}\n#endif\n\t}\n\treturn 0;\n}\n\n\nstatic int\ndecompileDEFINEFUNCTION(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n\tint i,j,k,m,r;\n\tstruct SWF_ACTIONPUSHPARAM *myregs[ 256 ];\n\tstruct _stack *StackSave;    \n\tstruct SWF_ACTIONDEFINEFUNCTION2 *sactv2;\n\tstruct strbufinfo origbuf;\n\tOUT_BEGIN2(SWF_ACTIONDEFINEFUNCTION);\n\tsactv2 = (struct SWF_ACTIONDEFINEFUNCTION2*)sact;\n\n#ifdef DEBUG\n\tif(n+1 < maxn)\n\t{\n\t\tprintln(\"/* function followed by OP %x */\", \n\t\t        OpCode(actions, n+1, maxn));\n\t}\n#endif\n#if USE_LIB\n\tif (isStoreOp(n+1, actions,maxn) \n\t    || (  *sact->FunctionName==0 && !is_type2 )\n\t    || (*sactv2->FunctionName==0 && is_type2  ))\n\t{\n\t\torigbuf=setTempString();\t/* switch to a temporary string buffer */\n\t}\n#endif\n\tputs(\"function \");\n\tif (is_type2)\n\t{\n\t\tfor(j=1;j<sactv2->RegisterCount;j++) \n\t\t{\n\t\t\tmyregs[j]=regs[j];\n\t\t\tregs[j]=NULL;\n\t\t}\n\t\tr=1;\n\t\tif (sactv2->PreloadThisFlag)\tregs[r++]=newVar(\"this\");\n\t\tif (sactv2->PreloadArgumentsFlag)\tregs[r++]=newVar(\"arguments\");\n\t\tif (sactv2->PreloadSuperFlag)\tregs[r++]=newVar(\"super\");\n\t\tif (sactv2->PreloadRootFlag)\tregs[r++]=newVar(\"root\");\n\t\tif (sactv2->PreloadParentFlag)\tregs[r++]=newVar(\"parent\");\n\t\tif (sactv2->PreloadGlobalFlag)\tregs[r++]=newVar(\"global\");\n\n\t\tputs(sactv2->FunctionName);\n\t\tputs(\"(\");\n\n\t\tfor(i=0,m=0;i<sactv2->NumParams;i++) \n\t\t{\n\t\t\tputs(sactv2->Params[i].ParamName);\n\t\t\tif ( sactv2->Params[i].Register)\n\t\t\t{\n\t\t\t\t printf(\" /*=R%d*/ \",sactv2->Params[i].Register);\n\t\t\t\t regs[sactv2->Params[i].Register] = newVar(sactv2->Params[i].ParamName);\n\t\t\t\t m++;\t\t\t\t\t// do not count 'void' etc\n\t\t\t}\n\t\t\tif( sactv2->NumParams > i+1 ) puts(\",\");\n\t\t}\n\t\tprintln(\") {\" );\n\t\tif (r+m < sactv2->RegisterCount)\n\t\t{\n\t\t\tINDENT\n\t\t\tputs(\"  var \");\n\t\t}\n\t\tfor(k=r;r<sactv2->RegisterCount;r++)\n\t\t{\n\t\t\tif (!regs[r])\n\t\t\t{\n\t\t\t\tchar *t=malloc(5); /* Rddd */\n\t\t\t\tsprintf(t,\"R%d\", r );\n\t\t\t\tputs (t);\n\t\t\t\tif (k++ < sactv2->RegisterCount- m -1)\n\t\t\t\t\tputs(\", \");\n\t\t\t\telse\n\t\t\t\t\tprintln(\";\" );\n\t\t\t\tregs[r]=newVar(t);\n\t\t\t}\n\t\t}\n\t\tStackSave=Stack;\n\t\tdecompileActions(sactv2->numActions, sactv2->Actions,gIndent+1);\n#ifdef DEBUG\n\t\tif (Stack!=StackSave)\n\t\t{\n\t\t\tprintln(\"/* Stack problem in function code above */\");\n\t\t}\n#endif\n\t\tStack=StackSave;\n\t\tfor(j=1;j<sactv2->RegisterCount;j++) \n\t\t\tregs[j]=myregs[j];\n\t}\n\telse\n\t{\n\t\tputs(sact->FunctionName);\n\t\tputs(\"(\");\n\t\tfor(i=0;i<sact->NumParams;i++) {\n\t\t\tputs(sact->Params[i]);\n\t\t\tif( sact->NumParams > i+1 ) puts(\",\");\n\t\t}\n\t\tprintln(\") {\" );\n\t\tk=0;\n\t\tif (sact->Actions[0].SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH)\n\t\t{\n\t\t\tstruct SWF_ACTIONPUSH *sactPush=(struct SWF_ACTIONPUSH *)sact->Actions;\n\t\t\tfor(i=0;i<sactPush->NumParam;i++)\n\t\t\t{\n\t\t\t\tif ((&(sactPush->Params[i]))->Type == PUSH_REGISTER) \n\t\t\t\t\tk++;\t/* REGISTER */\n\t\t\t}\n\t\t\tif (k)\n\t\t\t{\n\t\t\t\tINDENT\n\t\t\t\tputs(\"  var \");\n\t\t\t\tfor(i=1;i<=k;i++)\n\t\t\t\t{\n\t\t\t\t\tchar *t=malloc(5); /* Rddd */\n\t\t\t\t\tsprintf(t,\"R%d\", i );\n\t\t\t\t\tputs (t);\n\t\t\t\t\tif (i < k)\n\t\t\t\t\t\tputs(\", \");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintln(\";\" );\n\t\t\t\t\tregs[i]=newVar(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=k;j++) \n\t\t\tmyregs[j]=regs[j];\n\t\tStackSave=Stack;\n\t\tdecompileActions(sact->numActions, sact->Actions,gIndent+1);\n#ifdef DEBUG\n\t\tif (Stack!=StackSave)\n\t\t{\n\t\t\tprintln(\"/* Stack problem in function code above */\");\n\t\t}\n#endif\n\t\tStack=StackSave;\n\t\tfor(j=1;j<=k;j++) \n\t\t\tregs[j]=myregs[j];\n\t}\n\tINDENT\n\tif (isStoreOp(n+1, actions,maxn) \n\t    || ( *sact->FunctionName==0 && !is_type2 )\n\t    || (*sactv2->FunctionName==0 && is_type2 ))\n\t{\n\t\tputs(\"}\");\n#if USE_LIB\n\t\tpush (newVar(dcgetstr()));\t/* push func body for later assignment */\n\t\tsetOrigString(origbuf);\t\t/* switch back to orig buffer */\n#else\n\t\tpush (newVar(\"/* see function code above */\"));\t/* workaround only if LIB is not in use */\n#endif\n\t}\n\telse\n\t\tprintln(\"}\" );\n\treturn 0;\n}\n\nstatic int\ndecompileCALLMETHOD(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *meth, *obj, *nparam;\n\tmeth=pop();\n\tobj=pop();\n\tnparam=pop();\n\tif (nparam->p.Integer>25)\n\t{\n\t\tINDENT\n\t\tprintln(\"// Problem getting method arguments (%d ignored) below:\",\n\t\t        nparam->p.Integer);\n\t\tnparam->p.Integer=0;\n\t}\n#ifdef DEBUG\n\tprintf(\"*CALLMethod* objName=%s (type=%d) methName=%s (type=%d)\\n\",\n\t\tgetName(obj), obj->Type, getName(meth), meth->Type);\n#endif\n\tif (meth->Type == PUSH_UNDEF) \t/* just undefined, like in \"super();\" */\n\t\tpush(newVar_N(getName(obj),\"\",\"\",\"(\", nparam->p.Integer,\")\"));\n\telse\n\t{\n\t\tif (meth->Type == PUSH_INT || meth->Type == PUSH_DOUBLE || meth->Type == PUSH_VARIABLE\n\t\t    || meth->Type == PUSH_REGISTER || meth->Type == 12 )\n\t\t{\n\t\t\tpush(newVar_N(getName(obj),\"[\",getName(meth),\"](\", nparam->p.Integer,\")\"));\n\t\t}\n\t\telse\n\t\t\tpush(newVar_N(getName(obj),\".\",getName(meth),\"(\", nparam->p.Integer,\")\"));\n\t}\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call method and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileCALLFUNCTION(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *meth, *nparam;\n\n\tSanityCheck(SWF_CALLMETHOD, OpCode(actions, n-1, maxn) == SWFACTION_PUSH,\n\t\t\"CALLMETHOD not preceeded by PUSH\")\n\n\tmeth=pop();\n\tnparam=pop();\n\tif (nparam->p.Integer>25)\n\t{\n\t\tINDENT\n\t\tprintln(\"// Problem getting function arguments (%d ignored) below:\",\n\t\t\tnparam->p.Integer);\n\t\tnparam->p.Integer=0;\n\t}\n\tpush(newVar_N(\"\",\"\",getName(meth),\"(\", nparam->p.Integer,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompile_Null_ArgBuiltInFunctionCall(int n, SWF_ACTION *actions, int maxn, char *functionname)\n{\n\tINDENT\n\tputs(functionname);\t\t// only used for cases w/o return value\n\tprintln(\"();\" );\n\treturn 0;\n}\n\nstatic int\ndecompileSingleArgBuiltInFunctionCall(int n, SWF_ACTION *actions, int maxn, char *functionname)\n{\n\tpush(newVar_N(\"\",\"\",functionname,\"(\", 1,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileSTARTDRAG(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"startDrag(\");\n\tdecompilePUSHPARAM(pop(),1);\n\tputs(\",\");\n\tdecompilePUSHPARAM(pop(),0);\n\tputs(\",\");\n\tdecompilePUSHPARAM(pop(),0);\t//\n\tprintln(\");\" );\n\treturn 0;\n}\n\nstatic int\ndecompileSUBSTRING(int n, SWF_ACTION *actions,int maxn)\n{\n\tpush(newVar_N(\"\",\"\",\"substr\",\"(\", 3,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileSTRINGCONCAT(int n, SWF_ACTION *actions, int maxn)\n{\n\tpush(newVar_N(\"\",\"\",\"concat\",\"(\", 2,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileTHROW(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"throw \");\n\tputs(getName(pop()));\n\tprintln(\";\");\n\treturn 0;\n}\n\nstatic int\ndecompileREMOVECLIP(int n, SWF_ACTION *actions, int maxn)\n{\n\tINDENT\n\tputs(\"removeMovieClip(\");\n\tputs(getName(pop()));\n\tprintln(\");\" );\n\treturn 0;\n}\n\nstatic int \ndecompileDUPLICATECLIP(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *a, *b;\n\n\tINDENT\n\ta = pop();\n\tb = pop();\n\n\tputs(\"duplicateMovieClip(\");\n\tputs(getString(pop()));\n\tputs(\",\");\n\tputs(getString(b));\n\tputs(\",\");\n\tputs(getString(a));\n\tprintln(\");\" );\n\treturn 0;\n}\n\nstatic int\ndecompileINITARRAY(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *nparam;\n\tnparam=pop();\n\tpush(newVar_N(\"\",\"\",\"\",\"[\", nparam->p.Integer,\"]\"));\n\treturn 0;\n}\n\nstatic int\ndecompileEXTENDS(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *baseclass;\n\n\tbaseclass=pop();\n#if 0\n\t/* It's useless to open a class body when there's no\n\t * other code supporting it. */\n\tprintf(\"class \");\n\tputs(getName(pop()));\n\tprintf(\" extends \");\n\tputs(getName(baseclass));\n\tprintln(\" {\" );\n#else\n\t/* We'll do it with asm{} */\n\tprintln(\"asm {\");\n\tprintln(\" push '%s'\", getName(pop()));\n\tprintln(\" getvariable\");\n\tprintln(\" push '%s'\", getName(baseclass));\n\tprintln(\" getvariable\");\n\tprintln(\" extends\");\n\tprintln(\"};\");\n#endif\n\n\treturn 0;\n}\n\nstatic int\ndecompileDELETE(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n\tif (is_type2)\n\t\tpush(newVar3(\"delete(\",getName(pop()),\")\"));\n\telse\n\t\tpush(newVar_N(\"delete(\",getName(pop()),\".\",getName(pop()), 0,\")\"));\n\n\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call delete() with its args and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ndecompileSETTARGET(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n\tint action_cnt=0;\n\tchar *name;\n\tOUT_BEGIN2(SWF_ACTIONSETTARGET);\n\tname = is_type2 ? getString(pop()) : sact->TargetName;\n\tif (*name)\n\t{\n\t\tINDENT\n\t\tprintln(\"tellTarget('%s') {\" ,name);\n\t\twhile(action_cnt+n<maxn)\n\t\t{\n\t\t\tif (OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_SETTARGET\n\t\t\t    || OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_SETTARGET2\n\t\t\t    || OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_DEFINEFUNCTION\n\t\t\t    || OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_DEFINEFUNCTION2\n\t\t\t    || OpCode(actions, n+1+action_cnt, maxn)==SWFACTION_END) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taction_cnt++;\n\t\t}\n\t\tdecompileActions(action_cnt,&actions[n+1],gIndent+1);\n\t\tINDENT\n\t\tprintln(\"}\" );\n\t}\n\treturn action_cnt;\n}\n\nstatic int\ndecompileIMPLEMENTS(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *nparam;\n\tint i;\n\tINDENT;\n\tputs(getName(pop()));\n\tprintf(\" implements \");\n\tnparam=pop();\n\tfor(i=0;i<nparam->p.Integer;i++) \n\t{\n\t\tputs(getName(pop()));\n\t}\n\tprintln(\" ;\");\n\treturn 0;\n}\n\nstatic int\ndecompileCAST(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *iparam=pop();\n\tstruct SWF_ACTIONPUSHPARAM *tparam=pop();\n\tpush(newVar_N( getName(tparam),\"(\",getName(iparam),\"\", 0,\")\")); \n\treturn 0;\n}\n\nint\ndecompileAction(int n, SWF_ACTION *actions, int maxn)\n{\n\n#ifdef DEBUG\n\tfprintf(stderr,\"%d:\\tACTION[%3.3d]: %s\\n\",\n\t        actions[n].SWF_ACTIONRECORD.Offset, n, \n\t        actionName(actions[n].SWF_ACTIONRECORD.ActionCode));\n#endif\n\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\tcase SWFACTION_END:\n\t\treturn 0;\n\n\tcase SWFACTION_CONSTANTPOOL:\n\t\tdecompileCONSTANTPOOL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GOTOLABEL:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,1);\n\n\tcase SWFACTION_GOTOFRAME:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,0);\n\n\tcase SWFACTION_GOTOFRAME2:\n\t\treturn decompileGOTOFRAME2(n, actions, maxn);\n\n\tcase SWFACTION_WAITFORFRAME:\n\t\tdecompileWAITFORFRAME(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL2:\n\t\tdecompileGETURL2(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL:\n\t\tdecompileGETURL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSH:\n\t\tdecompilePUSH(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSHDUP:\n\t\tdecompilePUSHDUP(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_STACKSWAP:\n\t\tdecompileSTACKSWAP(&actions[n]);\t\n\t\treturn 0;\n\n\tcase SWFACTION_SETPROPERTY:\n\t\tdecompileSETPROPERTY(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETPROPERTY:\n\t\tdecompileGETPROPERTY(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETTIME:\n\t\treturn decompileGETTIME(n, actions, maxn);\n\n\tcase SWFACTION_TRACE:\n\t\tdecompileTRACE(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_CALLFRAME:\n\t\tdecompileCALLFRAME(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_EXTENDS:\n\t\tdecompileEXTENDS(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_INITOBJECT:\n\t\tdecompileINITOBJECT(n, actions, maxn);\n\t\treturn 0;\t        \n\n\tcase SWFACTION_NEWOBJECT:\n\t\tdecompileNEWOBJECT(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_NEWMETHOD:\n\t\tdecompileNEWMETHOD(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompileGETMEMBER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_SETMEMBER:\n\t\tdecompileSETMEMBER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETVARIABLE:\n\t\tdecompileGETVARIABLE(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_SETVARIABLE:\n\t\tdecompileSETVARIABLE(n, actions, maxn, 0);\n\t\treturn 0;\n\n\tcase SWFACTION_DEFINELOCAL:\n\t\tdecompileSETVARIABLE(n, actions, maxn, 1);\n\t\treturn 0;\n\n\tcase SWFACTION_DEFINELOCAL2:\n\t\tdecompileDEFINELOCAL2(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_DECREMENT:\n\t\treturn decompileINCR_DECR(n, actions, maxn, 0);\n\n\tcase SWFACTION_INCREMENT:\n\t\treturn decompileINCR_DECR(n, actions, maxn,1);\n\n\tcase SWFACTION_STOREREGISTER:\n\t\tdecompileSTOREREGISTER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_JUMP:\n\t\treturn decompileJUMP(n, actions, maxn);\n\n\tcase SWFACTION_RETURN:\n\t\tdecompileRETURN(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_LOGICALNOT:\n\t\treturn decompileLogicalNot(n, actions, maxn);\n\n\tcase SWFACTION_IF:\n\t\treturn decompileIF(n, actions, maxn);\n\n\tcase SWFACTION_WITH:\n\t\tdecompileWITH(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_ENUMERATE:\n\t\treturn decompileENUMERATE(n, actions, maxn, 0);\n\n\tcase SWFACTION_ENUMERATE2 :\n\t\treturn decompileENUMERATE(n, actions, maxn,1);\n\n\tcase SWFACTION_INITARRAY:\n\t\treturn decompileINITARRAY(n, actions, maxn);\n\n\tcase SWFACTION_DEFINEFUNCTION:\t\n\t\treturn decompileDEFINEFUNCTION(n, actions, maxn,0);\n\n\tcase SWFACTION_DEFINEFUNCTION2:\n\t\treturn decompileDEFINEFUNCTION(n, actions, maxn,1);\n\n\tcase SWFACTION_CALLFUNCTION:\n\t\treturn decompileCALLFUNCTION(n, actions, maxn);\n\n\tcase SWFACTION_CALLMETHOD:\n\t\treturn decompileCALLMETHOD(n, actions, maxn);\n\n\tcase SWFACTION_INSTANCEOF:\n\tcase SWFACTION_SHIFTLEFT:\n\tcase SWFACTION_SHIFTRIGHT:\n\tcase SWFACTION_SHIFTRIGHT2:        \n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\tcase SWFACTION_SUBTRACT:\n\tcase SWFACTION_MULTIPLY:\n\tcase SWFACTION_DIVIDE:\n\tcase SWFACTION_MODULO:\n\tcase SWFACTION_BITWISEAND:\n\tcase SWFACTION_BITWISEOR:\n\tcase SWFACTION_BITWISEXOR:\n\tcase SWFACTION_EQUAL:\n\tcase SWFACTION_EQUALS2:\n\tcase SWFACTION_LESS2:\n\tcase SWFACTION_LOGICALAND:\n\tcase SWFACTION_LOGICALOR:\n\tcase SWFACTION_GREATER:\n\tcase SWFACTION_LESSTHAN:\n\tcase SWFACTION_STRINGEQ:\n\tcase SWFACTION_STRINGCOMPARE:\n\tcase SWFACTION_STRICTEQUALS:\n\t\treturn decompileArithmeticOp(n, actions, maxn);\n\n\tcase SWFACTION_POP:\n\t\tpop();\n\t\treturn 0;\n\n\tcase SWFACTION_STARTDRAG:\n\t\treturn decompileSTARTDRAG(n, actions, maxn);\n\n\tcase SWFACTION_DELETE:\n\t\treturn decompileDELETE(n, actions, maxn,0);\n\n\tcase SWFACTION_DELETE2:\n\t\treturn decompileDELETE(n, actions, maxn,1);\n\n\tcase SWFACTION_TARGETPATH:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"targetPath\");\n\n\tcase SWFACTION_TYPEOF:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"typeof\");\n\n\tcase SWFACTION_ORD:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"ord\");\n\n\tcase SWFACTION_CHR:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"chr\");\n\n\tcase SWFACTION_INT:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"int\");\n\n\tcase SWFACTION_TOSTRING:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"String\");     \n\n\tcase SWFACTION_TONUMBER:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"Number\");\n\n\tcase SWFACTION_RANDOMNUMBER:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"random\");\n\n\tcase SWFACTION_STRINGLENGTH:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"length\");\n\n\tcase SWFACTION_PLAY:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"play\");\n\n\tcase SWFACTION_STOP:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stop\");\n\n\tcase SWFACTION_NEXTFRAME:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"nextFrame\");\n\n\tcase SWFACTION_PREVFRAME:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"prevFrame\");\n\n\tcase SWFACTION_ENDDRAG:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stopDrag\");\n\n\tcase SWFACTION_STOPSOUNDS:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stopAllSounds\");   \n\n\tcase SWFACTION_TOGGLEQUALITY:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"toggleHighQuality\");      \n\n\tcase SWFACTION_MBSUBSTRING:\n\tcase SWFACTION_SUBSTRING:\n\t\treturn decompileSUBSTRING(n, actions, maxn);\n\n\tcase SWFACTION_STRINGCONCAT:\n\t\treturn decompileSTRINGCONCAT(n, actions, maxn);\n\n\tcase SWFACTION_REMOVECLIP:\n\t\treturn decompileREMOVECLIP(n, actions, maxn);\n\n\tcase SWFACTION_DUPLICATECLIP:\n\t\treturn decompileDUPLICATECLIP(n, actions, maxn);\n\n\tcase SWFACTION_SETTARGET:\n\t\treturn decompileSETTARGET(n, actions, maxn,0);\n\n\tcase SWFACTION_SETTARGET2:\n\t\treturn decompileSETTARGET(n, actions, maxn,1);\n\n\tcase SWFACTION_IMPLEMENTSOP:\n\t\treturn decompileIMPLEMENTS(n, actions, maxn);\n\n\tcase SWFACTION_CASTOP:\n\t\treturn decompileCAST(n, actions, maxn);\n\n\tcase SWFACTION_THROW:\n\t\treturn decompileTHROW(n, actions, maxn);\n\n\tcase SWFACTION_TRY:\n\t\treturn decompileTRY(n, actions, maxn);\n\n\tdefault:\n\t\toutputSWF_ACTION(n,&actions[n]);\n\t\treturn 0;\n\t}\n}\n\nstatic void\ndecompileActions(int n, SWF_ACTION *actions, int indent)\n{\n\tint i, svindent;\n\n\tsvindent = gIndent;\n\tgIndent = indent;\n\t\n\tfor(i=0;i<n;i++) {\n\t\ti+=decompileAction(i, actions, n);\n\t}\n\tgIndent = svindent;\n}\n\nchar *\ndecompile5Action(int n, SWF_ACTION *actions,int indent)\n{\n\tint j;\n\tif( !n  )\n\t\treturn NULL;\n\n\tpool = NULL;\n\tpoolcounter = 0;\n\n\tdcinit();\n\n\tfor(j=0;j<256;j++) regs[j]=0;\n\tregs[1] = newVar(\"R1\");\n\tregs[2] = newVar(\"R2\");\n\tregs[3] = newVar(\"R3\");\n\tregs[4] = newVar(\"R4\");\n\n\tdecompileActions(n, actions, indent);\n#ifdef DEBUGSTACK\n\tif( Stack != NULL && *dcstr) \n\t{ \n\t\tint i=0;\n\t\tprintln(\"/* -----------------------------------------------------------------\");\n\t\tprintln(\"NOTE: some stuff left on the stack at the end of a block of actions:\");\n\t\twhile (Stack)\n\t\t{\n\t\t\ti++;\n\t\t\tprintf(\"%d.:\\t%s\",i, getString(pop()));\n\t\t\tprintln(\"\");\n\t\t}\n\t\tprintln(\"*/\");\n\t}\n#else\n\tif( Stack != NULL ) \n\t\tfprintf(stderr,\n\t\t\"Stuff left on the stack at the end of a block of actions!?!?!?\\n\");\n\twhile (Stack)\n\t{\n\t\tpop();\n\t}\n#endif\n\treturn dcgetstr();\n}\n\n"], "filenames": ["util/decompile.c"], "buggy_code_start_loc": [3205], "buggy_code_end_loc": [3214], "fixing_code_start_loc": [3204], "fixing_code_end_loc": [3213], "type": "CWE-119", "message": "Ming (aka libming) 0.4.8 has a heap buffer overflow and underflow in the decompileCAST function in util/decompile.c in libutil.a. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted SWF file.", "other": {"cve": {"id": "CVE-2019-12982", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-26T18:15:10.587", "lastModified": "2020-10-14T17:27:46.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ming (aka libming) 0.4.8 has a heap buffer overflow and underflow in the decompileCAST function in util/decompile.c in libutil.a. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted SWF file."}, {"lang": "es", "value": "Ming (aka libming) versi\u00f3n 0.4.8 tiene un desbordamiento y subdesbordamiento de b\u00fafer de mont\u00f3n en la funci\u00f3n decompileCAST en util/decompile.c en libutil.a. Los atacantes remotos podr\u00edan aprovechar esta vulnerabilidad para provocar una denegaci\u00f3n de servicio a trav\u00e9s de un archivo SWF dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libming:libming:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "DD92BC79-2548-4C6F-9BDD-26C12BDF68AC"}]}]}], "references": [{"url": "https://github.com/libming/libming/commit/da9d86eab55cbf608d5c916b8b690f5b76bca462", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libming/libming/commit/da9d86eab55cbf608d5c916b8b690f5b76bca462"}}