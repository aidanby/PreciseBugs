{"buggy_code": ["<?php\n/**\n * SEOmatic plugin for Craft CMS 3.x\n *\n * A turnkey SEO implementation for Craft CMS that is comprehensive, powerful,\n * and flexible\n *\n * @link      https://nystudio107.com\n * @copyright Copyright (c) 2017 nystudio107\n */\n\nnamespace nystudio107\\seomatic\\services;\n\nuse Craft;\nuse craft\\base\\Component;\nuse craft\\elements\\Asset;\nuse craft\\elements\\db\\MatrixBlockQuery;\nuse craft\\elements\\db\\TagQuery;\nuse craft\\helpers\\Template;\nuse craft\\web\\twig\\variables\\Paginate;\nuse nystudio107\\seomatic\\base\\InheritableSettingsModel;\nuse nystudio107\\seomatic\\helpers\\DynamicMeta as DynamicMetaHelper;\nuse nystudio107\\seomatic\\helpers\\ImageTransform as ImageTransformHelper;\nuse nystudio107\\seomatic\\helpers\\Schema as SchemaHelper;\nuse nystudio107\\seomatic\\helpers\\Text as TextHelper;\nuse nystudio107\\seomatic\\helpers\\UrlHelper;\nuse nystudio107\\seomatic\\models\\MetaBundle;\nuse nystudio107\\seomatic\\Seomatic;\nuse yii\\base\\Exception;\nuse yii\\base\\InvalidConfigException;\n\n/**\n * @author    nystudio107\n * @package   Seomatic\n * @since     3.0.0\n */\nclass Helper extends Component\n{\n    // Constants\n    // =========================================================================\n\n    const TWITTER_TRANSFORM_MAP = [\n            'summary' => 'twitter-summary',\n            'summary_large_image' => 'twitter-large',\n            'app' => 'twitter-large',\n            'player' => 'twitter-large',\n        ];\n\n    // Public Methods\n    // =========================================================================\n\n    /**\n     * Sanitize user input by decoding any HTML Entities, URL decoding the text,\n     * then removing any newlines, stripping tags, stripping Twig tags, and changing\n     * single {}'s into ()'s\n     *\n     * @param $str\n     * @return string\n     */\n    public static function sanitizeUserInput($str): string\n    {\n        return TextHelper::sanitizeUserInput($str);\n    }\n\n    /**\n     * Return the appropriate Twitter Transform based on the current $metaGlobalVars->twitterCard\n     *\n     * @return string\n     */\n    public static function twitterTransform(): string\n    {\n        $transform = 'twitter-summary';\n        $metaGlobalVars = Seomatic::$plugin->metaContainers->metaGlobalVars;\n        if ($metaGlobalVars) {\n            $transform = self::TWITTER_TRANSFORM_MAP[$metaGlobalVars->twitterCard] ?? $transform;\n        }\n\n        return $transform;\n    }\n\n    /**\n     * Return the proper content for the `query-input` JSON-LD property\n     *\n     * @return string\n     */\n    public static function siteLinksQueryInput(): string\n    {\n        $result = '';\n\n        $metaSiteVars = Seomatic::$plugin->metaContainers->metaSiteVars;\n        if ($metaSiteVars && !empty($metaSiteVars->siteLinksQueryInput)) {\n            $result = 'required name='.$metaSiteVars->siteLinksQueryInput;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return whether this is a preview request of any kind\n     *\n     * @return bool\n     */\n    public static function isPreview(): bool\n    {\n        $isPreview = false;\n        $request = Craft::$app->getRequest();\n        if (Seomatic::$craft32) {\n            $isPreview = $request->getIsPreview();\n        }\n        $isLivePreview = $request->getIsLivePreview();\n\n        return ($isPreview || $isLivePreview);\n    }\n\n    /**\n     * Return the Same As Links info as an array or null\n     *\n     * @param string $handle\n     * @return array|null\n     */\n    public static function sameAsByHandle(string $handle) {\n        $result = null;\n\n        $sameAs = Seomatic::$plugin->metaContainers->metaSiteVars->sameAsLinks;\n        if (!empty($sameAs) && !empty($handle)) {\n            foreach ($sameAs as $sameAsInfo) {\n                if (!empty($sameAsInfo) && is_array($sameAsInfo) && !empty($sameAsInfo['handle'])) {\n                    if ($sameAsInfo['handle'] === $handle) {\n                        return $sameAsInfo;\n                    }\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return the canonical URL for the request, with the query string stripped\n     *\n     * @return string\n     */\n    public static function safeCanonicalUrl(): string\n    {\n        $url = '';\n        try {\n            $url = Craft::$app->getRequest()->getPathInfo();\n        } catch (InvalidConfigException $e) {\n            Craft::error($e->getMessage(), __METHOD__);\n        }\n        $url = DynamicMetaHelper::sanitizeUrl($url);\n\n        return UrlHelper::absoluteUrlWithProtocol($url);\n    }\n\n    /**\n     * Return the site URL for a given URL. This gives SEOmatic a chance to override it\n     *\n     * @param string $path\n     * @param array|string|null $params\n     * @param string|null $scheme\n     * @param int|null $siteId\n     * @return string\n     * @throws Exception if|null $siteId is invalid\n     */\n    public static function siteUrl(string $path = '', $params = null, string $scheme = null, int $siteId = null): string\n    {\n        return UrlHelper::siteUrl($path);\n    }\n\n    /**\n     * Paginate based on the passed in Paginate variable as returned from the\n     * Twig {% paginate %} tag:\n     * https://docs.craftcms.com/v3/templating/tags/paginate.html#the-pageInfo-variable\n     *\n     * @param Paginate $pageInfo\n     */\n    public static function paginate(Paginate $pageInfo)\n    {\n        DynamicMetaHelper::paginate($pageInfo);\n    }\n\n    /**\n     * Truncates the string to a given length. If $substring is provided, and\n     * truncating occurs, the string is further truncated so that the substring\n     * may be appended without exceeding the desired length.\n     *\n     * @param  string $string    The string to truncate\n     * @param  int    $length    Desired length of the truncated string\n     * @param  string $substring The substring to append if it can fit\n     *\n     * @return string with the resulting $str after truncating\n     */\n    public static function truncate($string, $length, $substring = '\u2026'): string\n    {\n        return TextHelper::truncate($string, $length, $substring);\n    }\n\n    /**\n     * Truncates the string to a given length, while ensuring that it does not\n     * split words. If $substring is provided, and truncating occurs, the\n     * string is further truncated so that the substring may be appended without\n     * exceeding the desired length.\n     *\n     * @param  string $string    The string to truncate\n     * @param  int    $length    Desired length of the truncated string\n     * @param  string $substring The substring to append if it can fit\n     *\n     * @return string with the resulting $str after truncating\n     */\n    public static function truncateOnWord($string, $length, $substring = '\u2026'): string\n    {\n        return TextHelper::truncateOnWord($string, $length, $substring);\n    }\n\n    /**\n     * Return a list of localized URLs that are in the current site's group\n     * The current URI is used if $uri is null. Similarly, the current site is\n     * used if $siteId is null.\n     * The resulting array of arrays has `id`, `language`, `ogLanguage`,\n     * `hreflangLanguage`, and `url` as keys.\n     *\n     * @param string|null $uri\n     * @param int|null    $siteId\n     *\n     * @return array\n     */\n    public static function getLocalizedUrls(string $uri = null, int $siteId = null): array\n    {\n        return DynamicMetaHelper::getLocalizedUrls($uri, $siteId);\n    }\n\n    /**\n     * Allow setting the X-Robots-Tag and Link headers on static files as per:\n     * https://moz.com/blog/how-to-advanced-relcanonical-http-headers\n     *\n     * @param        $url\n     * @param string $robots\n     * @param string $canonical\n     * @param bool   $inline\n     *\n     * @return \\Twig\\Markup\n     * @throws \\yii\\base\\Exception\n     */\n    public static function seoFileLink($url, $robots = '', $canonical = '', $inline = true): \\Twig\\Markup\n    {\n        // Get the file name\n        $path = parse_url($url, PHP_URL_PATH);\n        $fileName = pathinfo($path, PATHINFO_BASENAME);\n        // Set some defaults\n        $robots = empty($robots) ? 'all' : $robots;\n        $canonical = empty($canonical) ? $url : $canonical;\n        $inlineStr = $inline === true ? '1' : '0';\n        // Compose the base64 encoded URL\n        $seoFileLink = 'seomatic/seo-file-link/'\n            .base64_encode($url)\n            .'/'\n            .base64_encode($robots)\n            .'/'\n            .base64_encode($canonical)\n            .'/'\n            .$inlineStr\n            .'/'\n            .$fileName;\n\n        return Template::raw(UrlHelper::siteUrl($seoFileLink));\n    }\n\n    /**\n     * Load the appropriate meta containers for the given $uri and optional\n     * $siteId\n     *\n     * @param string   $uri\n     * @param int|null $siteId\n     */\n    public static function loadMetadataForUri(string $uri = '', int $siteId = null)\n    {\n        Seomatic::$plugin->metaContainers->loadMetaContainers($uri, $siteId);\n    }\n\n    /**\n     * Get the URL to the $siteId's sitemap index\n     *\n     * @param int|null $siteId\n     *\n     * @return string\n     */\n    public static function sitemapIndexForSiteId(int $siteId = null): string\n    {\n        return Seomatic::$plugin->sitemaps->sitemapIndexUrlForSiteId($siteId);\n    }\n\n    /**\n     * Return a sitemap for each site in the same site group\n     *\n     * @return string\n     */\n    public static function sitemapIndex(): string\n    {\n        return Seomatic::$plugin->sitemaps->sitemapIndex();\n    }\n\n    /**\n     * Return a sitemap for each site in the same site group\n     *\n     * @deprecated use sitemapIndex() instead\n     * @return string\n     */\n    public static function siteGroupSitemaps(): string\n    {\n        return Seomatic::$plugin->sitemaps->sitemapIndex();\n    }\n\n    /**\n     * @param string   $sourceType\n     * @param string   $sourceHandle\n     * @param int|null $siteId\n     *\n     * @return string\n     */\n    public static function sitemapUrlForBundle(string $sourceType, string $sourceHandle, int $siteId = null): string\n    {\n        return Seomatic::$plugin->sitemaps->sitemapUrlForBundle($sourceType, $sourceHandle, $siteId);\n    }\n\n    /**\n     * Extract plain old text from a field\n     *\n     * @param $field\n     *\n     * @return string\n     */\n    public static function extractTextFromField($field = null): string\n    {\n        return TextHelper::extractTextFromField($field);\n    }\n\n    /**\n     * Extract concatenated text from all of the tags in the $tagElement and\n     * return as a comma-delimited string\n     *\n     * @param TagQuery $tagQuery\n     *\n     * @return string\n     */\n    public static function extractTextFromTags($tagQuery = null): string\n    {\n        return TextHelper::extractTextFromTags($tagQuery);\n    }\n\n    /**\n     * Extract text from all of the blocks in a matrix field, concatenating it\n     * together.\n     *\n     * @param MatrixBlockQuery $matrixQuery\n     * @param string           $fieldHandle\n     *\n     * @return string\n     */\n    public static function extractTextFromMatrix($matrixQuery = null, $fieldHandle = ''): string\n    {\n        return TextHelper::extractTextFromMatrix($matrixQuery, $fieldHandle);\n    }\n\n    /**\n     * Return the most important keywords extracted from the text as a comma-\n     * delimited string\n     *\n     * @param string $text\n     * @param int    $limit\n     * @param bool   $useStopWords\n     *\n     * @return string\n     */\n    public static function extractKeywords($text = '', $limit = 15, $useStopWords = true): string\n    {\n        return TextHelper::extractKeywords($text, $limit, $useStopWords);\n    }\n\n    /**\n     * Extract a summary consisting of the 3 most important sentences from the\n     * text\n     *\n     * @param string $text\n     * @param bool   $useStopWords\n     *\n     * @return string\n     */\n    public static function extractSummary($text = '', $useStopWords = true): string\n    {\n        return TextHelper::extractSummary($text, $useStopWords);\n    }\n\n    /**\n     * Return a period-delimited schema.org path from the $settings\n     *\n     * @param $settings\n     *\n     * @return string\n     */\n    public static function getEntityPath($settings): string\n    {\n        return SchemaHelper::getEntityPath($settings);\n    }\n\n    /**\n     * Return a flattened, indented menu of the given $path\n     *\n     * @param string $path\n     *\n     * @return array\n     */\n    public static function getTypeMenu($path): array\n    {\n        return SchemaHelper::getTypeMenu($path);\n    }\n\n    /**\n     * Return a single menu of schemas starting at $path\n     *\n     * @param string $path\n     *\n     * @return array\n     */\n    public static function getSingleTypeMenu($path): array\n    {\n        return SchemaHelper::getSingleTypeMenu($path);\n    }\n\n    /**\n     * Transform the $asset for social media sites in $transformName and\n     * optional $siteId\n     *\n     * @param int|Asset $asset         the Asset or Asset ID\n     * @param string    $transformName the name of the transform to apply\n     * @param int|null  $siteId\n     * @param string    $transformMode\n     *\n     * @return string URL to the transformed image\n     */\n    public function socialTransform($asset, $transformName = '', $siteId = null, $transformMode = null): string\n    {\n        return ImageTransformHelper::socialTransform($asset, $transformName, $siteId, $transformMode);\n    }\n\n    /**\n     * Get the width of the transformed social image for $transformName and\n     * optional $siteId\n     *\n     * @param int|Asset $asset         the Asset or Asset ID\n     * @param string    $transformName the name of the transform to apply\n     * @param int|null  $siteId\n     * @param string    $transformMode\n     *\n     * @return string URL to the transformed image\n     */\n    public function socialTransformWidth(\n        $asset,\n        $transformName = '',\n        $siteId = null,\n        $transformMode = null\n    ): string {\n        return ImageTransformHelper::socialTransformWidth($asset, $transformName, $siteId, $transformMode);\n    }\n\n    /**\n     * Get the height of the transformed social image for $transformName and\n     * optional $siteId\n     *\n     * @param int|Asset $asset         the Asset or Asset ID\n     * @param string    $transformName the name of the transform to apply\n     * @param int|null  $siteId\n     * @param string    $transformMode\n     *\n     * @return string URL to the transformed image\n     */\n    public function socialTransformHeight(\n        $asset,\n        $transformName = '',\n        $siteId = null,\n        $transformMode = null\n    ): string {\n        return ImageTransformHelper::socialTransformHeight($asset, $transformName, $siteId, $transformMode);\n    }\n\n    /**\n     * Return whether we are running Craft 3.1 or later\n     *\n     * @return bool\n     */\n    public function craft31(): bool\n    {\n        return Seomatic::$craft31;\n    }\n\n    /**\n     * Return whether we are running Craft 3.2 or later\n     *\n     * @return bool\n     */\n    public function craft32(): bool\n    {\n        return Seomatic::$craft32;\n    }\n\n    /**\n     * Return whether we are running Craft 3.3 or later\n     *\n     * @return bool\n     */\n    public function craft33(): bool\n    {\n        return Seomatic::$craft33;\n    }\n\n    /**\n     * Given a list of meta bundles in order of descending distance, return the bundle that has inheritable value.\n     *\n     * @param array $inheritedValues\n     * @param string $settingName\n     * @param string $collectionName The name off the collection to search\n     * @return MetaBundle|null\n     * @since 3.4.0\n     */\n    public function findInheritableBundle(array $inheritedValues, string $settingName, string $collectionName = \"metaGlobalVars\")\n    {\n        if (in_array($collectionName, ['metaGlobalVars', 'metaSitemapVars'], true)) {\n            foreach ($inheritedValues as $bundle) {\n                /** @var $bundle MetaBundle */\n                if (isset($bundle->{$collectionName}[$settingName])) {\n                    if (is_bool($bundle->{$collectionName}[$settingName]) || !empty($bundle->{$collectionName}[$settingName])) {\n                        return $bundle;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Return true if a setting is inherited.\n     *\n     * @param InheritableSettingsModel $settingCollection\n     * @param $settingName\n     * @return bool\n     * @since 3.4.0\n     */\n    public function isInherited(InheritableSettingsModel $settingCollection, $settingName)\n    {\n        $explicitInherit = array_key_exists($settingName, (array)$settingCollection->inherited);\n        $explicitOverride = array_key_exists($settingName, (array)$settingCollection->overrides);\n\n        if ($explicitInherit || $explicitOverride) {\n            return $explicitInherit && !$explicitOverride;\n        }\n\n        return empty($settingCollection->{$settingName});\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * SEOmatic plugin for Craft CMS 3.x\n *\n * A turnkey SEO implementation for Craft CMS that is comprehensive, powerful,\n * and flexible\n *\n * @link      https://nystudio107.com\n * @copyright Copyright (c) 2017 nystudio107\n */\n\nnamespace nystudio107\\seomatic\\services;\n\nuse Craft;\nuse craft\\base\\Component;\nuse craft\\elements\\Asset;\nuse craft\\elements\\db\\MatrixBlockQuery;\nuse craft\\elements\\db\\TagQuery;\nuse craft\\helpers\\Template;\nuse craft\\web\\twig\\variables\\Paginate;\nuse nystudio107\\seomatic\\base\\InheritableSettingsModel;\nuse nystudio107\\seomatic\\helpers\\DynamicMeta as DynamicMetaHelper;\nuse nystudio107\\seomatic\\helpers\\ImageTransform as ImageTransformHelper;\nuse nystudio107\\seomatic\\helpers\\Schema as SchemaHelper;\nuse nystudio107\\seomatic\\helpers\\Text as TextHelper;\nuse nystudio107\\seomatic\\helpers\\UrlHelper;\nuse nystudio107\\seomatic\\models\\MetaBundle;\nuse nystudio107\\seomatic\\Seomatic;\nuse yii\\base\\Exception;\nuse yii\\base\\InvalidConfigException;\n\n/**\n * @author    nystudio107\n * @package   Seomatic\n * @since     3.0.0\n */\nclass Helper extends Component\n{\n    // Constants\n    // =========================================================================\n\n    const TWITTER_TRANSFORM_MAP = [\n            'summary' => 'twitter-summary',\n            'summary_large_image' => 'twitter-large',\n            'app' => 'twitter-large',\n            'player' => 'twitter-large',\n        ];\n\n    // Public Methods\n    // =========================================================================\n\n    /**\n     * Sanitize user input by decoding any HTML Entities, URL decoding the text,\n     * then removing any newlines, stripping tags, stripping Twig tags, and changing\n     * single {}'s into ()'s\n     *\n     * @param $str\n     * @return string\n     */\n    public static function sanitizeUserInput($str): string\n    {\n        return TextHelper::sanitizeUserInput($str);\n    }\n\n    /**\n     * Return the appropriate Twitter Transform based on the current $metaGlobalVars->twitterCard\n     *\n     * @return string\n     */\n    public static function twitterTransform(): string\n    {\n        $transform = 'twitter-summary';\n        $metaGlobalVars = Seomatic::$plugin->metaContainers->metaGlobalVars;\n        if ($metaGlobalVars) {\n            $transform = self::TWITTER_TRANSFORM_MAP[$metaGlobalVars->twitterCard] ?? $transform;\n        }\n\n        return $transform;\n    }\n\n    /**\n     * Return the proper content for the `query-input` JSON-LD property\n     *\n     * @return string\n     */\n    public static function siteLinksQueryInput(): string\n    {\n        $result = '';\n\n        $metaSiteVars = Seomatic::$plugin->metaContainers->metaSiteVars;\n        if ($metaSiteVars && !empty($metaSiteVars->siteLinksQueryInput)) {\n            $result = 'required name='.$metaSiteVars->siteLinksQueryInput;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return whether this is a preview request of any kind\n     *\n     * @return bool\n     */\n    public static function isPreview(): bool\n    {\n        $isPreview = false;\n        $request = Craft::$app->getRequest();\n        if (Seomatic::$craft32) {\n            $isPreview = $request->getIsPreview();\n        }\n        $isLivePreview = $request->getIsLivePreview();\n\n        return ($isPreview || $isLivePreview);\n    }\n\n    /**\n     * Return the Same As Links info as an array or null\n     *\n     * @param string $handle\n     * @return array|null\n     */\n    public static function sameAsByHandle(string $handle) {\n        $result = null;\n\n        $sameAs = Seomatic::$plugin->metaContainers->metaSiteVars->sameAsLinks;\n        if (!empty($sameAs) && !empty($handle)) {\n            foreach ($sameAs as $sameAsInfo) {\n                if (!empty($sameAsInfo) && is_array($sameAsInfo) && !empty($sameAsInfo['handle'])) {\n                    if ($sameAsInfo['handle'] === $handle) {\n                        return $sameAsInfo;\n                    }\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return the canonical URL for the request, with the query string stripped\n     *\n     * @return string\n     */\n    public static function safeCanonicalUrl(): string\n    {\n        $url = '';\n        try {\n            $url = Craft::$app->getRequest()->getPathInfo();\n        } catch (InvalidConfigException $e) {\n            Craft::error($e->getMessage(), __METHOD__);\n        }\n\n        return DynamicMetaHelper::sanitizeUrl(UrlHelper::absoluteUrlWithProtocol($url));\n    }\n\n    /**\n     * Return the site URL for a given URL. This gives SEOmatic a chance to override it\n     *\n     * @param string $path\n     * @param array|string|null $params\n     * @param string|null $scheme\n     * @param int|null $siteId\n     * @return string\n     * @throws Exception if|null $siteId is invalid\n     */\n    public static function siteUrl(string $path = '', $params = null, string $scheme = null, int $siteId = null): string\n    {\n        return UrlHelper::siteUrl($path);\n    }\n\n    /**\n     * Paginate based on the passed in Paginate variable as returned from the\n     * Twig {% paginate %} tag:\n     * https://docs.craftcms.com/v3/templating/tags/paginate.html#the-pageInfo-variable\n     *\n     * @param Paginate $pageInfo\n     */\n    public static function paginate(Paginate $pageInfo)\n    {\n        DynamicMetaHelper::paginate($pageInfo);\n    }\n\n    /**\n     * Truncates the string to a given length. If $substring is provided, and\n     * truncating occurs, the string is further truncated so that the substring\n     * may be appended without exceeding the desired length.\n     *\n     * @param  string $string    The string to truncate\n     * @param  int    $length    Desired length of the truncated string\n     * @param  string $substring The substring to append if it can fit\n     *\n     * @return string with the resulting $str after truncating\n     */\n    public static function truncate($string, $length, $substring = '\u2026'): string\n    {\n        return TextHelper::truncate($string, $length, $substring);\n    }\n\n    /**\n     * Truncates the string to a given length, while ensuring that it does not\n     * split words. If $substring is provided, and truncating occurs, the\n     * string is further truncated so that the substring may be appended without\n     * exceeding the desired length.\n     *\n     * @param  string $string    The string to truncate\n     * @param  int    $length    Desired length of the truncated string\n     * @param  string $substring The substring to append if it can fit\n     *\n     * @return string with the resulting $str after truncating\n     */\n    public static function truncateOnWord($string, $length, $substring = '\u2026'): string\n    {\n        return TextHelper::truncateOnWord($string, $length, $substring);\n    }\n\n    /**\n     * Return a list of localized URLs that are in the current site's group\n     * The current URI is used if $uri is null. Similarly, the current site is\n     * used if $siteId is null.\n     * The resulting array of arrays has `id`, `language`, `ogLanguage`,\n     * `hreflangLanguage`, and `url` as keys.\n     *\n     * @param string|null $uri\n     * @param int|null    $siteId\n     *\n     * @return array\n     */\n    public static function getLocalizedUrls(string $uri = null, int $siteId = null): array\n    {\n        return DynamicMetaHelper::getLocalizedUrls($uri, $siteId);\n    }\n\n    /**\n     * Allow setting the X-Robots-Tag and Link headers on static files as per:\n     * https://moz.com/blog/how-to-advanced-relcanonical-http-headers\n     *\n     * @param        $url\n     * @param string $robots\n     * @param string $canonical\n     * @param bool   $inline\n     *\n     * @return \\Twig\\Markup\n     * @throws \\yii\\base\\Exception\n     */\n    public static function seoFileLink($url, $robots = '', $canonical = '', $inline = true): \\Twig\\Markup\n    {\n        // Get the file name\n        $path = parse_url($url, PHP_URL_PATH);\n        $fileName = pathinfo($path, PATHINFO_BASENAME);\n        // Set some defaults\n        $robots = empty($robots) ? 'all' : $robots;\n        $canonical = empty($canonical) ? $url : $canonical;\n        $inlineStr = $inline === true ? '1' : '0';\n        // Compose the base64 encoded URL\n        $seoFileLink = 'seomatic/seo-file-link/'\n            .base64_encode($url)\n            .'/'\n            .base64_encode($robots)\n            .'/'\n            .base64_encode($canonical)\n            .'/'\n            .$inlineStr\n            .'/'\n            .$fileName;\n\n        return Template::raw(UrlHelper::siteUrl($seoFileLink));\n    }\n\n    /**\n     * Load the appropriate meta containers for the given $uri and optional\n     * $siteId\n     *\n     * @param string   $uri\n     * @param int|null $siteId\n     */\n    public static function loadMetadataForUri(string $uri = '', int $siteId = null)\n    {\n        Seomatic::$plugin->metaContainers->loadMetaContainers($uri, $siteId);\n    }\n\n    /**\n     * Get the URL to the $siteId's sitemap index\n     *\n     * @param int|null $siteId\n     *\n     * @return string\n     */\n    public static function sitemapIndexForSiteId(int $siteId = null): string\n    {\n        return Seomatic::$plugin->sitemaps->sitemapIndexUrlForSiteId($siteId);\n    }\n\n    /**\n     * Return a sitemap for each site in the same site group\n     *\n     * @return string\n     */\n    public static function sitemapIndex(): string\n    {\n        return Seomatic::$plugin->sitemaps->sitemapIndex();\n    }\n\n    /**\n     * Return a sitemap for each site in the same site group\n     *\n     * @deprecated use sitemapIndex() instead\n     * @return string\n     */\n    public static function siteGroupSitemaps(): string\n    {\n        return Seomatic::$plugin->sitemaps->sitemapIndex();\n    }\n\n    /**\n     * @param string   $sourceType\n     * @param string   $sourceHandle\n     * @param int|null $siteId\n     *\n     * @return string\n     */\n    public static function sitemapUrlForBundle(string $sourceType, string $sourceHandle, int $siteId = null): string\n    {\n        return Seomatic::$plugin->sitemaps->sitemapUrlForBundle($sourceType, $sourceHandle, $siteId);\n    }\n\n    /**\n     * Extract plain old text from a field\n     *\n     * @param $field\n     *\n     * @return string\n     */\n    public static function extractTextFromField($field = null): string\n    {\n        return TextHelper::extractTextFromField($field);\n    }\n\n    /**\n     * Extract concatenated text from all of the tags in the $tagElement and\n     * return as a comma-delimited string\n     *\n     * @param TagQuery $tagQuery\n     *\n     * @return string\n     */\n    public static function extractTextFromTags($tagQuery = null): string\n    {\n        return TextHelper::extractTextFromTags($tagQuery);\n    }\n\n    /**\n     * Extract text from all of the blocks in a matrix field, concatenating it\n     * together.\n     *\n     * @param MatrixBlockQuery $matrixQuery\n     * @param string           $fieldHandle\n     *\n     * @return string\n     */\n    public static function extractTextFromMatrix($matrixQuery = null, $fieldHandle = ''): string\n    {\n        return TextHelper::extractTextFromMatrix($matrixQuery, $fieldHandle);\n    }\n\n    /**\n     * Return the most important keywords extracted from the text as a comma-\n     * delimited string\n     *\n     * @param string $text\n     * @param int    $limit\n     * @param bool   $useStopWords\n     *\n     * @return string\n     */\n    public static function extractKeywords($text = '', $limit = 15, $useStopWords = true): string\n    {\n        return TextHelper::extractKeywords($text, $limit, $useStopWords);\n    }\n\n    /**\n     * Extract a summary consisting of the 3 most important sentences from the\n     * text\n     *\n     * @param string $text\n     * @param bool   $useStopWords\n     *\n     * @return string\n     */\n    public static function extractSummary($text = '', $useStopWords = true): string\n    {\n        return TextHelper::extractSummary($text, $useStopWords);\n    }\n\n    /**\n     * Return a period-delimited schema.org path from the $settings\n     *\n     * @param $settings\n     *\n     * @return string\n     */\n    public static function getEntityPath($settings): string\n    {\n        return SchemaHelper::getEntityPath($settings);\n    }\n\n    /**\n     * Return a flattened, indented menu of the given $path\n     *\n     * @param string $path\n     *\n     * @return array\n     */\n    public static function getTypeMenu($path): array\n    {\n        return SchemaHelper::getTypeMenu($path);\n    }\n\n    /**\n     * Return a single menu of schemas starting at $path\n     *\n     * @param string $path\n     *\n     * @return array\n     */\n    public static function getSingleTypeMenu($path): array\n    {\n        return SchemaHelper::getSingleTypeMenu($path);\n    }\n\n    /**\n     * Transform the $asset for social media sites in $transformName and\n     * optional $siteId\n     *\n     * @param int|Asset $asset         the Asset or Asset ID\n     * @param string    $transformName the name of the transform to apply\n     * @param int|null  $siteId\n     * @param string    $transformMode\n     *\n     * @return string URL to the transformed image\n     */\n    public function socialTransform($asset, $transformName = '', $siteId = null, $transformMode = null): string\n    {\n        return ImageTransformHelper::socialTransform($asset, $transformName, $siteId, $transformMode);\n    }\n\n    /**\n     * Get the width of the transformed social image for $transformName and\n     * optional $siteId\n     *\n     * @param int|Asset $asset         the Asset or Asset ID\n     * @param string    $transformName the name of the transform to apply\n     * @param int|null  $siteId\n     * @param string    $transformMode\n     *\n     * @return string URL to the transformed image\n     */\n    public function socialTransformWidth(\n        $asset,\n        $transformName = '',\n        $siteId = null,\n        $transformMode = null\n    ): string {\n        return ImageTransformHelper::socialTransformWidth($asset, $transformName, $siteId, $transformMode);\n    }\n\n    /**\n     * Get the height of the transformed social image for $transformName and\n     * optional $siteId\n     *\n     * @param int|Asset $asset         the Asset or Asset ID\n     * @param string    $transformName the name of the transform to apply\n     * @param int|null  $siteId\n     * @param string    $transformMode\n     *\n     * @return string URL to the transformed image\n     */\n    public function socialTransformHeight(\n        $asset,\n        $transformName = '',\n        $siteId = null,\n        $transformMode = null\n    ): string {\n        return ImageTransformHelper::socialTransformHeight($asset, $transformName, $siteId, $transformMode);\n    }\n\n    /**\n     * Return whether we are running Craft 3.1 or later\n     *\n     * @return bool\n     */\n    public function craft31(): bool\n    {\n        return Seomatic::$craft31;\n    }\n\n    /**\n     * Return whether we are running Craft 3.2 or later\n     *\n     * @return bool\n     */\n    public function craft32(): bool\n    {\n        return Seomatic::$craft32;\n    }\n\n    /**\n     * Return whether we are running Craft 3.3 or later\n     *\n     * @return bool\n     */\n    public function craft33(): bool\n    {\n        return Seomatic::$craft33;\n    }\n\n    /**\n     * Given a list of meta bundles in order of descending distance, return the bundle that has inheritable value.\n     *\n     * @param array $inheritedValues\n     * @param string $settingName\n     * @param string $collectionName The name off the collection to search\n     * @return MetaBundle|null\n     * @since 3.4.0\n     */\n    public function findInheritableBundle(array $inheritedValues, string $settingName, string $collectionName = \"metaGlobalVars\")\n    {\n        if (in_array($collectionName, ['metaGlobalVars', 'metaSitemapVars'], true)) {\n            foreach ($inheritedValues as $bundle) {\n                /** @var $bundle MetaBundle */\n                if (isset($bundle->{$collectionName}[$settingName])) {\n                    if (is_bool($bundle->{$collectionName}[$settingName]) || !empty($bundle->{$collectionName}[$settingName])) {\n                        return $bundle;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Return true if a setting is inherited.\n     *\n     * @param InheritableSettingsModel $settingCollection\n     * @param $settingName\n     * @return bool\n     * @since 3.4.0\n     */\n    public function isInherited(InheritableSettingsModel $settingCollection, $settingName)\n    {\n        $explicitInherit = array_key_exists($settingName, (array)$settingCollection->inherited);\n        $explicitOverride = array_key_exists($settingName, (array)$settingCollection->overrides);\n\n        if ($explicitInherit || $explicitOverride) {\n            return $explicitInherit && !$explicitOverride;\n        }\n\n        return empty($settingCollection->{$settingName});\n    }\n}\n"], "filenames": ["src/services/Helper.php"], "buggy_code_start_loc": [151], "buggy_code_end_loc": [154], "fixing_code_start_loc": [151], "fixing_code_end_loc": [153], "type": "CWE-94", "message": "In the SEOmatic plugin up to 3.4.11 for Craft CMS 3, it is possible for unauthenticated attackers to perform a Server-Side Template Injection, allowing for remote code execution.", "other": {"cve": {"id": "CVE-2021-41749", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-12T11:15:07.663", "lastModified": "2022-06-17T19:05:43.813", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the SEOmatic plugin up to 3.4.11 for Craft CMS 3, it is possible for unauthenticated attackers to perform a Server-Side Template Injection, allowing for remote code execution."}, {"lang": "es", "value": "En el plugin SEOmatic versiones hasta 3.4.11 para Craft CMS 3, es posible que atacantes no autenticados lleven a cabo un ataque de tipo Server-Side Template Injection, permitiendo una ejecuci\u00f3n de c\u00f3digo remota"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nystudio107:seomatic:*:*:*:*:*:craft_cms:*:*", "versionEndIncluding": "3.4.11", "matchCriteriaId": "8C0190D8-190B-482D-9B7F-4C9C3783760A"}]}]}], "references": [{"url": "https://github.com/nystudio107/craft-seomatic/blob/develop/CHANGELOG.md", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/nystudio107/craft-seomatic/commit/3fee7d50147cdf3f999cfc1e04cbc3fb3d9f2f7d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nystudio107/craft-seomatic/commit/3fee7d50147cdf3f999cfc1e04cbc3fb3d9f2f7d"}}