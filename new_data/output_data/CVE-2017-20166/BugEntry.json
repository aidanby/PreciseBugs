{"buggy_code": ["Code.require_file \"../support/types.exs\", __DIR__\n\ndefmodule Ecto.Integration.RepoTest do\n  use Ecto.Integration.Case, async: Application.get_env(:ecto, :async_integration_tests, true)\n\n  alias Ecto.Integration.TestRepo\n  import Ecto.Query\n\n  alias Ecto.Integration.Post\n  alias Ecto.Integration.User\n  alias Ecto.Integration.Comment\n  alias Ecto.Integration.Permalink\n  alias Ecto.Integration.Custom\n  alias Ecto.Integration.Barebone\n  alias Ecto.Integration.CompositePk\n  alias Ecto.Integration.PostUsecTimestamps\n  alias Ecto.Integration.PostUserCompositePk\n\n  test \"returns already started for started repos\" do\n    assert {:error, {:already_started, _}} = TestRepo.start_link\n  end\n\n  test \"fetch empty\" do\n    assert TestRepo.all(Post) == []\n    assert TestRepo.all(from p in Post) == []\n  end\n\n  test \"fetch with in\" do\n    TestRepo.insert!(%Post{title: \"hello\"})\n\n    # Works without the query cache.\n    assert_raise Ecto.Query.CastError, fn ->\n      TestRepo.all(from p in Post, where: p.title in ^nil)\n    end\n\n    assert [] = TestRepo.all from p in Post, where: p.title in []\n    assert [] = TestRepo.all from p in Post, where: p.title in [\"1\", \"2\", \"3\"]\n    assert [] = TestRepo.all from p in Post, where: p.title in ^[]\n\n    assert [_] = TestRepo.all from p in Post, where: not p.title in []\n    assert [_] = TestRepo.all from p in Post, where: p.title in [\"1\", \"hello\", \"3\"]\n    assert [_] = TestRepo.all from p in Post, where: p.title in [\"1\", ^\"hello\", \"3\"]\n    assert [_] = TestRepo.all from p in Post, where: p.title in ^[\"1\", \"hello\", \"3\"]\n\n    # Still doesn't work after the query cache.\n    assert_raise Ecto.Query.CastError, fn ->\n      TestRepo.all(from p in Post, where: p.title in ^nil)\n    end\n  end\n\n  test \"fetch without schema\" do\n    %Post{} = TestRepo.insert!(%Post{title: \"title1\"})\n    %Post{} = TestRepo.insert!(%Post{title: \"title2\"})\n\n    assert [\"title1\", \"title2\"] =\n      TestRepo.all(from(p in \"posts\", order_by: p.title, select: p.title))\n\n    assert [_] =\n      TestRepo.all(from(p in \"posts\", where: p.title == \"title1\", select: p.id))\n  end\n\n  @tag :invalid_prefix\n  test \"fetch with invalid prefix\" do\n    assert catch_error(TestRepo.all(\"posts\", prefix: \"oops\"))\n  end\n\n  test \"insert, update and delete\" do\n    post = %Post{title: \"insert, update, delete\", text: \"fetch empty\"}\n    meta = post.__meta__\n\n    assert %Post{} = inserted = TestRepo.insert!(post)\n    assert %Post{} = updated = TestRepo.update!(Ecto.Changeset.change(inserted, text: \"new\"))\n\n    deleted_meta = put_in meta.state, :deleted\n    assert %Post{__meta__: ^deleted_meta} = TestRepo.delete!(updated)\n\n    loaded_meta = put_in meta.state, :loaded\n    assert %Post{__meta__: ^loaded_meta} = TestRepo.insert!(post)\n\n    post = TestRepo.one(Post)\n    assert post.__meta__.state == :loaded\n    assert post.inserted_at\n  end\n\n  test \"insert, update and delete with field source\" do\n    permalink = %Permalink{url: \"url\"}\n    assert %Permalink{url: \"url\"} = inserted =\n           TestRepo.insert!(permalink)\n    assert %Permalink{url: \"new\"} = updated =\n           TestRepo.update!(Ecto.Changeset.change(inserted, url: \"new\"))\n    assert %Permalink{url: \"new\"} =\n           TestRepo.delete!(updated)\n  end\n\n  @tag :composite_pk\n  test \"insert, update and delete with composite pk\" do\n    c1 = TestRepo.insert!(%CompositePk{a: 1, b: 2, name: \"first\"})\n    c2 = TestRepo.insert!(%CompositePk{a: 1, b: 3, name: \"second\"})\n\n    assert CompositePk |> first |> TestRepo.one == c1\n    assert CompositePk |> last |> TestRepo.one == c2\n\n    changeset = Ecto.Changeset.cast(c1, %{name: \"first change\"}, ~w(name))\n    c1 = TestRepo.update!(changeset)\n    assert TestRepo.get_by!(CompositePk, %{a: 1, b: 2}) == c1\n\n    TestRepo.delete!(c2)\n    assert TestRepo.all(CompositePk) == [c1]\n\n    assert_raise ArgumentError, ~r\"to have exactly one primary key\", fn ->\n      TestRepo.get(CompositePk, [])\n    end\n\n    assert_raise ArgumentError, ~r\"to have exactly one primary key\", fn ->\n      TestRepo.get!(CompositePk, [1, 2])\n    end\n  end\n\n  @tag :composite_pk\n  test \"insert, update and delete with associated composite pk\" do\n    user = TestRepo.insert!(%User{})\n    post = TestRepo.insert!(%Post{title: \"post title\", text: \"post text\"})\n\n    user_post = TestRepo.insert!(%PostUserCompositePk{user_id: user.id, post_id: post.id})\n    assert TestRepo.get_by!(PostUserCompositePk, [user_id: user.id, post_id: post.id]) == user_post\n    TestRepo.delete!(user_post)\n    assert TestRepo.all(PostUserCompositePk) == []\n  end\n\n  @tag :invalid_prefix\n  test \"insert, update and delete with invalid prefix\" do\n    post = TestRepo.insert!(%Post{})\n    changeset = Ecto.Changeset.change(post, title: \"foo\")\n    assert catch_error(TestRepo.insert(%Post{}, prefix: \"oops\"))\n    assert catch_error(TestRepo.update(changeset, prefix: \"oops\"))\n    assert catch_error(TestRepo.delete(changeset, prefix: \"oops\"))\n  end\n\n  test \"insert and update with changeset\" do\n    # On insert we merge the fields and changes\n    changeset = Ecto.Changeset.cast(%Post{text: \"x\", title: \"wrong\"},\n                                    %{\"title\" => \"hello\", \"temp\" => \"unknown\"}, ~w(title temp))\n\n    post = TestRepo.insert!(changeset)\n    assert %Post{text: \"x\", title: \"hello\", temp: \"unknown\"} = post\n    assert %Post{text: \"x\", title: \"hello\", temp: \"temp\"} = TestRepo.get!(Post, post.id)\n\n    # On update we merge only fields, direct schema changes are discarded\n    changeset = Ecto.Changeset.cast(%{post | text: \"y\"},\n                                    %{\"title\" => \"world\", \"temp\" => \"unknown\"}, ~w(title temp))\n\n    assert %Post{text: \"y\", title: \"world\", temp: \"unknown\"} = TestRepo.update!(changeset)\n    assert %Post{text: \"x\", title: \"world\", temp: \"temp\"} = TestRepo.get!(Post, post.id)\n  end\n\n  test \"insert and update with empty changeset\" do\n    # On insert we merge the fields and changes\n    changeset = Ecto.Changeset.cast(%Permalink{}, %{}, ~w())\n    assert %Permalink{} = permalink = TestRepo.insert!(changeset)\n\n    # Assert we can update the same value twice,\n    # without changes, without triggering stale errors.\n    changeset = Ecto.Changeset.cast(permalink, %{}, ~w())\n    assert TestRepo.update!(changeset) == permalink\n    assert TestRepo.update!(changeset) == permalink\n  end\n\n  @tag :no_primary_key\n  test \"insert with no primary key\" do\n    assert %Barebone{num: nil} = TestRepo.insert!(%Barebone{})\n    assert %Barebone{num: 13} = TestRepo.insert!(%Barebone{num: 13})\n  end\n\n  @tag :read_after_writes\n  test \"insert and update with changeset read after writes\" do\n    defmodule RAW do\n      use Ecto.Schema\n\n      schema \"comments\" do\n        field :text, :string\n        field :lock_version, :integer, read_after_writes: true\n      end\n    end\n\n    changeset = Ecto.Changeset.cast(struct(RAW, %{}), %{}, ~w())\n\n    # If the field is nil, we will not send it\n    # and read the value back from the database.\n    assert %{id: cid, lock_version: 1} = raw = TestRepo.insert!(changeset)\n\n    # Set the counter to 11, so we can read it soon\n    TestRepo.update_all from(u in RAW, where: u.id == ^cid), set: [lock_version: 11]\n\n    # We will read back on update too\n    changeset = Ecto.Changeset.cast(raw, %{\"text\" => \"0\"}, ~w(text))\n    assert %{id: ^cid, lock_version: 11, text: \"0\"} = TestRepo.update!(changeset)\n  end\n\n  test \"insert autogenerates for custom type\" do\n    post = TestRepo.insert!(%Post{uuid: nil})\n    assert byte_size(post.uuid) == 36\n    assert TestRepo.get_by(Post, uuid: post.uuid) == post\n  end\n\n  @tag :id_type\n  test \"insert autogenerates for custom id type\" do\n    defmodule ID do\n      use Ecto.Schema\n\n      @primary_key {:id, Elixir.Custom.Permalink, autogenerate: true}\n      schema \"posts\" do\n      end\n    end\n\n    id = TestRepo.insert!(struct(ID, id: nil))\n    assert id.id\n    assert TestRepo.get_by(ID, id: \"#{id.id}-hello\") == id\n  end\n\n  @tag :id_type\n  @tag :assigns_id_type\n  test \"insert with user-assigned primary key\" do\n    assert %Post{id: 1} = TestRepo.insert!(%Post{id: 1})\n  end\n\n  @tag :id_type\n  @tag :assigns_id_type\n  test \"insert and update with user-assigned primary key in changeset\" do\n    changeset = Ecto.Changeset.cast(%Post{id: 11}, %{\"id\" => \"13\"}, ~w(id))\n    assert %Post{id: 13} = post = TestRepo.insert!(changeset)\n\n    changeset = Ecto.Changeset.cast(post, %{\"id\" => \"15\"}, ~w(id))\n    assert %Post{id: 15} = TestRepo.update!(changeset)\n  end\n\n  @tag :uses_usec\n  test \"insert and fetch a schema with timestamps with usec\" do\n    p1 = TestRepo.insert!(%PostUsecTimestamps{title: \"hello\"})\n    assert [p1] == TestRepo.all(PostUsecTimestamps)\n  end\n\n  test \"insert and fetch a schema with utc timestamps\" do\n    datetime = System.system_time(:seconds) * 1_000_000 |> DateTime.from_unix!(:microseconds)\n    TestRepo.insert!(%User{inserted_at: datetime})\n    assert [%{inserted_at: ^datetime}] = TestRepo.all(User)\n  end\n\n  test \"optimistic locking in update/delete operations\" do\n    import Ecto.Changeset, only: [cast: 3, optimistic_lock: 2]\n    base_post = TestRepo.insert!(%Comment{})\n\n    cs_ok =\n      base_post\n      |> cast(%{\"text\" => \"foo.bar\"}, ~w(text))\n      |> optimistic_lock(:lock_version)\n    TestRepo.update!(cs_ok)\n\n    cs_stale = optimistic_lock(base_post, :lock_version)\n    assert_raise Ecto.StaleEntryError, fn -> TestRepo.update!(cs_stale) end\n    assert_raise Ecto.StaleEntryError, fn -> TestRepo.delete!(cs_stale) end\n  end\n\n  @tag :unique_constraint\n  test \"unique constraint\" do\n    changeset = Ecto.Changeset.change(%Post{}, uuid: Ecto.UUID.generate())\n    {:ok, _}  = TestRepo.insert(changeset)\n\n    exception =\n      assert_raise Ecto.ConstraintError, ~r/constraint error when attempting to insert struct/, fn ->\n        changeset\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"unique: posts_uuid_index\"\n    assert exception.message =~ \"The changeset has not defined any constraint.\"\n\n    message = ~r/constraint error when attempting to insert struct/\n    exception =\n      assert_raise Ecto.ConstraintError, message, fn ->\n        changeset\n        |> Ecto.Changeset.unique_constraint(:uuid, name: :posts_email_changeset)\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"unique: posts_email_changeset\"\n\n    {:error, changeset} =\n      changeset\n      |> Ecto.Changeset.unique_constraint(:uuid)\n      |> TestRepo.insert()\n    assert changeset.errors == [uuid: {\"has already been taken\", []}]\n    assert changeset.data.__meta__.state == :built\n  end\n\n  @tag :unique_constraint\n  test \"unique constraint from association\" do\n    uuid = Ecto.UUID.generate()\n    post = & %Post{} |> Ecto.Changeset.change(uuid: &1) |> Ecto.Changeset.unique_constraint(:uuid)\n\n    {:error, changeset} =\n      TestRepo.insert %User{\n        comments: [%Comment{}],\n        permalink: %Permalink{},\n        posts: [post.(uuid), post.(uuid), post.(Ecto.UUID.generate)]\n      }\n\n    [_, p2, _] = changeset.changes.posts\n    assert p2.errors == [uuid: {\"has already been taken\", []}]\n  end\n\n  @tag :id_type\n  @tag :unique_constraint\n  test \"unique constraint with binary_id\" do\n    changeset = Ecto.Changeset.change(%Custom{}, uuid: Ecto.UUID.generate())\n    {:ok, _}  = TestRepo.insert(changeset)\n\n    {:error, changeset} =\n      changeset\n      |> Ecto.Changeset.unique_constraint(:uuid)\n      |> TestRepo.insert()\n    assert changeset.errors == [uuid: {\"has already been taken\", []}]\n    assert changeset.data.__meta__.state == :built\n  end\n\n  test \"unique pseudo-constraint violation error message with join table at the repository\" do\n    post =\n      TestRepo.insert!(%Post{title: \"some post\"})\n      |> TestRepo.preload(:unique_users)\n\n    user =\n      TestRepo.insert!(%User{name: \"some user\"})\n\n    # Violate the unique composite index\n    {:error, changeset} =\n      post\n      |> Ecto.Changeset.change\n      |> Ecto.Changeset.put_assoc(:unique_users, [user, user])\n      |> TestRepo.update\n\n    errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)\n    assert errors == %{unique_users: [%{}, %{id: [\"has already been taken\"]}]}\n    refute changeset.valid?\n  end\n\n  @tag :join\n  @tag :unique_constraint\n  test \"unique constraint violation error message with join table in single changeset\" do\n    post =\n      TestRepo.insert!(%Post{title: \"some post\"})\n      |> TestRepo.preload(:constraint_users)\n\n    user =\n      TestRepo.insert!(%User{name: \"some user\"})\n\n    # Violate the unique composite index\n    {:error, changeset} =\n      post\n      |> Ecto.Changeset.change\n      |> Ecto.Changeset.put_assoc(:constraint_users, [user, user])\n      |> Ecto.Changeset.unique_constraint(:user,\n          name: :posts_users_composite_pk_post_id_user_id_index,\n          message: \"has already been assigned\")\n      |> TestRepo.update\n\n    errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)\n    assert errors == %{constraint_users: [%{}, %{user: [\"has already been assigned\"]}]}\n\n    refute changeset.valid?\n  end\n\n  @tag :join\n  @tag :unique_constraint\n  test \"unique constraint violation error message with join table and separate changesets\" do\n    post =\n      TestRepo.insert!(%Post{title: \"some post\"})\n      |> TestRepo.preload(:constraint_users)\n\n    user = TestRepo.insert!(%User{name: \"some user\"})\n\n    post\n    |> Ecto.Changeset.change\n    |> Ecto.Changeset.put_assoc(:constraint_users, [user])\n    |> TestRepo.update\n\n    # Violate the unique composite index\n    {:error, changeset} =\n      post\n      |> Ecto.Changeset.change\n      |> Ecto.Changeset.put_assoc(:constraint_users, [user])\n      |> Ecto.Changeset.unique_constraint(:user,\n          name: :posts_users_composite_pk_post_id_user_id_index,\n          message: \"has already been assigned\")\n      |> TestRepo.update\n\n    errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)\n    assert errors == %{constraint_users: [%{user: [\"has already been assigned\"]}]}\n\n    refute changeset.valid?\n  end\n\n  @tag :foreign_key_constraint\n  test \"foreign key constraint\" do\n    changeset = Ecto.Changeset.change(%Comment{post_id: 0})\n\n    exception =\n      assert_raise Ecto.ConstraintError, ~r/constraint error when attempting to insert struct/, fn ->\n        changeset\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"foreign_key: comments_post_id_fkey\"\n    assert exception.message =~ \"The changeset has not defined any constraint.\"\n\n    message = ~r/constraint error when attempting to insert struct/\n    exception =\n      assert_raise Ecto.ConstraintError, message, fn ->\n        changeset\n        |> Ecto.Changeset.foreign_key_constraint(:post_id, name: :comments_post_id_other)\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"foreign_key: comments_post_id_other\"\n\n    {:error, changeset} =\n      changeset\n      |> Ecto.Changeset.foreign_key_constraint(:post_id)\n      |> TestRepo.insert()\n    assert changeset.errors == [post_id: {\"does not exist\", []}]\n  end\n\n  @tag :foreign_key_constraint\n  test \"assoc constraint\" do\n    changeset = Ecto.Changeset.change(%Comment{post_id: 0})\n\n    exception =\n      assert_raise Ecto.ConstraintError, ~r/constraint error when attempting to insert struct/, fn ->\n        changeset\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"foreign_key: comments_post_id_fkey\"\n    assert exception.message =~ \"The changeset has not defined any constraint.\"\n\n    message = ~r/constraint error when attempting to insert struct/\n    exception =\n      assert_raise Ecto.ConstraintError, message, fn ->\n        changeset\n        |> Ecto.Changeset.assoc_constraint(:post, name: :comments_post_id_other)\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"foreign_key: comments_post_id_other\"\n\n    {:error, changeset} =\n      changeset\n      |> Ecto.Changeset.assoc_constraint(:post)\n      |> TestRepo.insert()\n    assert changeset.errors == [post: {\"does not exist\", []}]\n  end\n\n  @tag :foreign_key_constraint\n  test \"no assoc constraint error\" do\n    user = TestRepo.insert!(%User{})\n    TestRepo.insert!(%Permalink{user_id: user.id})\n\n    exception =\n      assert_raise Ecto.ConstraintError, ~r/constraint error when attempting to delete struct/, fn ->\n        TestRepo.delete!(user)\n      end\n\n    assert exception.message =~ \"foreign_key: permalinks_user_id_fkey\"\n    assert exception.message =~ \"The changeset has not defined any constraint.\"\n  end\n\n  @tag :foreign_key_constraint\n  test \"no assoc constraint with changeset mismatch\" do\n    user = TestRepo.insert!(%User{})\n    TestRepo.insert!(%Permalink{user_id: user.id})\n\n    message = ~r/constraint error when attempting to delete struct/\n    exception =\n      assert_raise Ecto.ConstraintError, message, fn ->\n        user\n        |> Ecto.Changeset.change\n        |> Ecto.Changeset.no_assoc_constraint(:permalink, name: :permalinks_user_id_pther)\n        |> TestRepo.delete()\n      end\n\n    assert exception.message =~ \"foreign_key: permalinks_user_id_pther\"\n  end\n\n  @tag :foreign_key_constraint\n  test \"no assoc constraint with changeset match\" do\n    user = TestRepo.insert!(%User{})\n    TestRepo.insert!(%Permalink{user_id: user.id})\n\n    {:error, changeset} =\n      user\n      |> Ecto.Changeset.change\n      |> Ecto.Changeset.no_assoc_constraint(:permalink)\n      |> TestRepo.delete()\n    assert changeset.errors == [permalink: {\"is still associated with this entry\", []}]\n  end\n\n  test \"insert and update with failing child foreign key\" do\n    defmodule Order do\n      use Ecto.Integration.Schema\n      import Ecto.Changeset\n\n      schema \"orders\" do\n        embeds_one :item, Ecto.Integration.Item\n        belongs_to :comment, Ecto.Integration.Comment\n      end\n\n      def changeset(order, params) do\n        order\n        |> cast(params, [:comment_id])\n        |> cast_embed(:item, with: &item_changeset/2)\n        |> cast_assoc(:comment, with: &comment_changeset/2)\n      end\n\n      def item_changeset(item, params) do\n        item\n        |> cast(params, [:price])\n      end\n\n      def comment_changeset(comment, params) do\n        comment\n        |> cast(params, [:post_id, :text])\n        |> cast_assoc(:post)\n        |> assoc_constraint(:post)\n      end\n    end\n\n    changeset = Order.changeset(struct(Order, %{}), %{item: %{price: 10}, comment: %{text: \"1\", post_id: 0}})\n\n    assert %Ecto.Changeset{} = changeset.changes.item\n\n    {:error, changeset} = TestRepo.insert(changeset)\n    assert %Ecto.Changeset{} = changeset.changes.item\n\n    order = TestRepo.insert!(Order.changeset(struct(Order, %{}), %{}))\n    |> TestRepo.preload([:comment])\n\n    changeset = Order.changeset(order, %{item: %{price: 10}, comment: %{text: \"1\", post_id: 0}})\n\n    assert %Ecto.Changeset{} = changeset.changes.item\n\n    {:error, changeset} = TestRepo.update(changeset)\n    assert %Ecto.Changeset{} = changeset.changes.item\n  end\n\n  test \"unsafe_validate_unique/3\" do\n    {:ok, inserted_post} = TestRepo.insert(%Post{title: \"Greetings\", text: \"hi\"})\n    new_post_changeset = Post.changeset(%Post{}, %{title: \"Greetings\", text: \"ho\"})\n\n    changeset = Ecto.Changeset.unsafe_validate_unique(new_post_changeset, [:title], TestRepo)\n    assert changeset.errors[:title] ==\n           {\"has already been taken\", validation: :unsafe_unique, fields: [:title]}\n\n    changeset = Ecto.Changeset.unsafe_validate_unique(new_post_changeset, [:title, :text], TestRepo)\n    assert changeset.errors[:title] == nil\n\n    update_changeset = Post.changeset(inserted_post, %{text: \"ho\"})\n    changeset = Ecto.Changeset.unsafe_validate_unique(update_changeset, [:title], TestRepo)\n    assert changeset.errors[:title] == nil # cannot conflict with itself\n  end\n\n  test \"get(!)\" do\n    post1 = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    post2 = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n\n    assert post1 == TestRepo.get(Post, post1.id)\n    assert post2 == TestRepo.get(Post, to_string post2.id) # With casting\n\n    assert post1 == TestRepo.get!(Post, post1.id)\n    assert post2 == TestRepo.get!(Post, to_string post2.id) # With casting\n\n    TestRepo.delete!(post1)\n\n    assert nil   == TestRepo.get(Post, post1.id)\n    assert_raise Ecto.NoResultsError, fn ->\n      TestRepo.get!(Post, post1.id)\n    end\n  end\n\n  test \"get(!) with custom source\" do\n    custom = Ecto.put_meta(%Custom{}, source: \"posts\")\n    custom = TestRepo.insert!(custom)\n    bid    = custom.bid\n    assert %Custom{bid: ^bid, __meta__: %{source: {nil, \"posts\"}}} =\n           TestRepo.get(from(c in {\"posts\", Custom}), bid)\n  end\n\n  test \"get(!) with binary_id\" do\n    custom = TestRepo.insert!(%Custom{})\n    bid = custom.bid\n    assert %Custom{bid: ^bid} = TestRepo.get(Custom, bid)\n  end\n\n  test \"get_by(!)\" do\n    post1 = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    post2 = TestRepo.insert!(%Post{title: \"2\", text: \"hello\"})\n    post3 = TestRepo.insert!(%Post{title: \"3\", text: nil})\n\n    assert post1 == TestRepo.get_by(Post, id: post1.id)\n    assert post1 == TestRepo.get_by(Post, text: post1.text)\n    assert post1 == TestRepo.get_by(Post, id: post1.id, text: post1.text)\n    assert post2 == TestRepo.get_by(Post, id: to_string(post2.id)) # With casting\n    assert nil   == TestRepo.get_by(Post, text: \"hey\")\n    assert nil   == TestRepo.get_by(Post, id: post2.id, text: \"hey\")\n    assert post3 == TestRepo.get_by(Post, text: nil)\n\n    assert post1 == TestRepo.get_by!(Post, id: post1.id)\n    assert post1 == TestRepo.get_by!(Post, text: post1.text)\n    assert post1 == TestRepo.get_by!(Post, id: post1.id, text: post1.text)\n    assert post2 == TestRepo.get_by!(Post, id: to_string(post2.id)) # With casting\n    assert post3 == TestRepo.get_by!(Post, text: nil)\n\n    assert post1 == TestRepo.get_by!(Post, %{id: post1.id})\n\n    assert_raise Ecto.NoResultsError, fn ->\n      TestRepo.get_by!(Post, id: post2.id, text: \"hey\")\n    end\n  end\n\n  test \"first, last and one(!)\" do\n    post1 = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    post2 = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n\n    assert post1 == Post |> first |> TestRepo.one\n    assert post2 == Post |> last |> TestRepo.one\n\n    query = from p in Post, order_by: p.title\n    assert post1 == query |> first |> TestRepo.one\n    assert post2 == query |> last |> TestRepo.one\n\n    query = from p in Post, order_by: [desc: p.title], limit: 10\n    assert post2 == query |> first |> TestRepo.one\n    assert post1 == query |> last |> TestRepo.one\n\n    query = from p in Post, where: is_nil(p.id)\n    refute query |> first |> TestRepo.one\n    refute query |> first |> TestRepo.one\n    assert_raise Ecto.NoResultsError, fn -> query |> first |> TestRepo.one! end\n    assert_raise Ecto.NoResultsError, fn -> query |> last |> TestRepo.one! end\n  end\n\n  test \"aggregate\" do\n    assert TestRepo.aggregate(Post, :max, :visits) == nil\n\n    TestRepo.insert!(%Post{visits: 10})\n    TestRepo.insert!(%Post{visits: 12})\n    TestRepo.insert!(%Post{visits: 14})\n    TestRepo.insert!(%Post{visits: 14})\n\n    # Barebones\n    assert TestRepo.aggregate(Post, :max, :visits) == 14\n    assert TestRepo.aggregate(Post, :min, :visits) == 10\n    assert TestRepo.aggregate(Post, :count, :visits) == 4\n    assert \"50\" = to_string(TestRepo.aggregate(Post, :sum, :visits))\n    assert \"12.5\" <> _ = to_string(TestRepo.aggregate(Post, :avg, :visits))\n\n    # With order_by\n    query = from Post, order_by: [asc: :visits]\n    assert TestRepo.aggregate(query, :max, :visits) == 14\n\n    # With order_by and limit\n    query = from Post, order_by: [asc: :visits], limit: 2\n    assert TestRepo.aggregate(query, :max, :visits) == 12\n\n    # With distinct\n    query = from Post, order_by: [asc: :visits], distinct: true\n    assert TestRepo.aggregate(query, :count, :visits) == 3\n  end\n\n  test \"insert all\" do\n    assert {2, nil} = TestRepo.insert_all(\"comments\", [[text: \"1\"], %{text: \"2\", lock_version: 2}])\n    assert {2, nil} = TestRepo.insert_all({\"comments\", Comment}, [[text: \"3\"], %{text: \"4\", lock_version: 2}])\n    assert [%Comment{text: \"1\", lock_version: 1},\n            %Comment{text: \"2\", lock_version: 2},\n            %Comment{text: \"3\", lock_version: 1},\n            %Comment{text: \"4\", lock_version: 2}] = TestRepo.all(Comment)\n\n    assert {2, nil} = TestRepo.insert_all(Post, [[], []])\n    assert [%Post{}, %Post{}] = TestRepo.all(Post)\n\n    assert {0, nil} = TestRepo.insert_all(\"posts\", [])\n    assert {0, nil} = TestRepo.insert_all({\"posts\", Post}, [])\n  end\n\n  @tag :invalid_prefix\n  test \"insert all with invalid prefix\" do\n    assert catch_error(TestRepo.insert_all(Post, [[], []], prefix: \"oops\"))\n  end\n\n  @tag :returning\n  test \"insert all with returning with schema\" do\n    assert {0, []} = TestRepo.insert_all(Comment, [], returning: true)\n    assert {0, nil} = TestRepo.insert_all(Comment, [], returning: false)\n\n    {2, [c1, c2]} = TestRepo.insert_all(Comment, [[text: \"1\"], [text: \"2\"]], returning: [:id, :text])\n    assert %Comment{text: \"1\", __meta__: %{state: :loaded}} = c1\n    assert %Comment{text: \"2\", __meta__: %{state: :loaded}} = c2\n\n    {2, [c1, c2]} = TestRepo.insert_all(Comment, [[text: \"3\"], [text: \"4\"]], returning: true)\n    assert %Comment{text: \"3\", __meta__: %{state: :loaded}} = c1\n    assert %Comment{text: \"4\", __meta__: %{state: :loaded}} = c2\n  end\n\n  @tag :returning\n  test \"insert all with returning with schema with field source\" do\n    assert {0, []} = TestRepo.insert_all(Permalink, [], returning: true)\n    assert {0, nil} = TestRepo.insert_all(Permalink, [], returning: false)\n\n    {2, [c1, c2]} = TestRepo.insert_all(Permalink, [[url: \"1\"], [url: \"2\"]], returning: [:id, :url])\n    assert %Permalink{url: \"1\", __meta__: %{state: :loaded}} = c1\n    assert %Permalink{url: \"2\", __meta__: %{state: :loaded}} = c2\n\n    {2, [c1, c2]} = TestRepo.insert_all(Permalink, [[url: \"3\"], [url: \"4\"]], returning: true)\n    assert %Permalink{url: \"3\", __meta__: %{state: :loaded}} = c1\n    assert %Permalink{url: \"4\", __meta__: %{state: :loaded}} = c2\n  end\n\n  @tag :returning\n  test \"insert all with returning without schema\" do\n    {2, [c1, c2]} = TestRepo.insert_all(\"comments\", [[text: \"1\"], [text: \"2\"]], returning: [:id, :text])\n    assert %{id: _, text: \"1\"} = c1\n    assert %{id: _, text: \"2\"} = c2\n\n    assert_raise ArgumentError, fn ->\n      TestRepo.insert_all(\"comments\", [[text: \"1\"], [text: \"2\"]], returning: true)\n    end\n  end\n\n  test \"insert all with dumping\" do\n    datetime = ~N[2014-01-16 20:26:51.000000]\n    assert {2, nil} = TestRepo.insert_all(Post, [%{inserted_at: datetime}, %{title: \"date\"}])\n    assert [%Post{inserted_at: ^datetime, title: nil},\n            %Post{inserted_at: nil, title: \"date\"}] = TestRepo.all(Post)\n  end\n\n  test \"insert all autogenerates for binary_id type\" do\n    custom = TestRepo.insert!(%Custom{bid: nil})\n    assert custom.bid\n    assert TestRepo.get(Custom, custom.bid)\n    assert TestRepo.delete!(custom)\n    refute TestRepo.get(Custom, custom.bid)\n\n    uuid = Ecto.UUID.generate\n    assert {2, nil} = TestRepo.insert_all(Custom, [%{uuid: uuid}, %{bid: custom.bid}])\n    assert [%Custom{bid: bid2, uuid: nil},\n            %Custom{bid: bid1, uuid: ^uuid}] = Enum.sort_by(TestRepo.all(Custom), & &1.uuid)\n    assert bid1 && bid2\n    assert custom.bid != bid1\n    assert custom.bid == bid2\n  end\n\n  test \"update all\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    assert {3, nil} = TestRepo.update_all(Post, set: [title: \"x\"])\n\n    assert %Post{title: \"x\"} = TestRepo.get(Post, id1)\n    assert %Post{title: \"x\"} = TestRepo.get(Post, id2)\n    assert %Post{title: \"x\"} = TestRepo.get(Post, id3)\n\n    assert {3, nil} = TestRepo.update_all(\"posts\", [set: [title: nil]], returning: false)\n\n    assert %Post{title: nil} = TestRepo.get(Post, id1)\n    assert %Post{title: nil} = TestRepo.get(Post, id2)\n    assert %Post{title: nil} = TestRepo.get(Post, id3)\n  end\n\n  @tag :invalid_prefix\n  test \"update all with invalid prefix\" do\n    assert catch_error(TestRepo.update_all(Post, [set: [title: \"x\"]], prefix: \"oops\"))\n  end\n\n  @tag :returning\n  test \"update all with returning with schema\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    assert {3, posts} = TestRepo.update_all(Post, [set: [title: \"x\"]], returning: true)\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert %Post{id: ^id1, title: \"x\"} = p1\n    assert %Post{id: ^id2, title: \"x\"} = p2\n    assert %Post{id: ^id3, title: \"x\"} = p3\n\n    assert {3, posts} = TestRepo.update_all(Post, [set: [visits: 11]], returning: [:id, :visits])\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert %Post{id: ^id1, title: nil, visits: 11} = p1\n    assert %Post{id: ^id2, title: nil, visits: 11} = p2\n    assert %Post{id: ^id3, title: nil, visits: 11} = p3\n  end\n\n  @tag :returning\n  test \"update all with returning without schema\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    assert {3, posts} = TestRepo.update_all(\"posts\", [set: [title: \"x\"]], returning: [:id, :title])\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert p1 == %{id: id1, title: \"x\"}\n    assert p2 == %{id: id2, title: \"x\"}\n    assert p3 == %{id: id3, title: \"x\"}\n  end\n\n  test \"update all with filter\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    query = from(p in Post, where: p.title == \"1\" or p.title == \"2\",\n                            update: [set: [text: ^\"y\"]])\n    assert {2, nil} = TestRepo.update_all(query, set: [title: \"x\"])\n\n    assert %Post{title: \"x\", text: \"y\"} = TestRepo.get(Post, id1)\n    assert %Post{title: \"x\", text: \"y\"} = TestRepo.get(Post, id2)\n    assert %Post{title: \"3\", text: nil} = TestRepo.get(Post, id3)\n  end\n\n  test \"update all no entries\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    query = from(p in Post, where: p.title == \"4\")\n    assert {0, nil} = TestRepo.update_all(query, set: [title: \"x\"])\n\n    assert %Post{title: \"1\"} = TestRepo.get(Post, id1)\n    assert %Post{title: \"2\"} = TestRepo.get(Post, id2)\n    assert %Post{title: \"3\"} = TestRepo.get(Post, id3)\n  end\n\n  test \"update all increment syntax\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\", visits: 0})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\", visits: 1})\n\n    # Positive\n    query = from p in Post, where: not is_nil(p.id), update: [inc: [visits: 2]]\n    assert {2, nil} = TestRepo.update_all(query, [])\n\n    assert %Post{visits: 2} = TestRepo.get(Post, id1)\n    assert %Post{visits: 3} = TestRepo.get(Post, id2)\n\n    # Negative\n    query = from p in Post, where: not is_nil(p.id), update: [inc: [visits: -1]]\n    assert {2, nil} = TestRepo.update_all(query, [])\n\n    assert %Post{visits: 1} = TestRepo.get(Post, id1)\n    assert %Post{visits: 2} = TestRepo.get(Post, id2)\n  end\n\n  @tag :id_type\n  test \"update all with casting and dumping on id type field\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{})\n    assert {1, nil} = TestRepo.update_all(Post, set: [counter: to_string(id1)])\n    assert %Post{counter: ^id1} = TestRepo.get(Post, id1)\n  end\n\n  test \"update all with casting and dumping\" do\n    text = \"hai\"\n    datetime = ~N[2014-01-16 20:26:51.000000]\n    assert %Post{id: id} = TestRepo.insert!(%Post{})\n\n    assert {1, nil} = TestRepo.update_all(Post, set: [text: text, inserted_at: datetime])\n    assert %Post{text: \"hai\", inserted_at: ^datetime} = TestRepo.get(Post, id)\n  end\n\n  test \"delete all\" do\n    assert %Post{} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    assert {3, nil} = TestRepo.delete_all(Post, returning: false)\n    assert [] = TestRepo.all(Post)\n  end\n\n  @tag :invalid_prefix\n  test \"delete all with invalid prefix\" do\n    assert catch_error(TestRepo.delete_all(Post, prefix: \"oops\"))\n  end\n\n  @tag :returning\n  test \"delete all with returning with schema\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    assert {3, posts} = TestRepo.delete_all(Post, returning: true)\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert %Post{id: ^id1, title: \"1\"} = p1\n    assert %Post{id: ^id2, title: \"2\"} = p2\n    assert %Post{id: ^id3, title: \"3\"} = p3\n  end\n\n  @tag :returning\n  test \"delete all with returning without schema\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    assert {3, posts} = TestRepo.delete_all(\"posts\", returning: [:id, :title])\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert p1 == %{id: id1, title: \"1\"}\n    assert p2 == %{id: id2, title: \"2\"}\n    assert p3 == %{id: id3, title: \"3\"}\n  end\n\n  test \"delete all with filter\" do\n    assert %Post{} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    query = from(p in Post, where: p.title == \"1\" or p.title == \"2\")\n    assert {2, nil} = TestRepo.delete_all(query)\n    assert [%Post{}] = TestRepo.all(Post)\n  end\n\n  test \"delete all no entries\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    query = from(p in Post, where: p.title == \"4\")\n    assert {0, nil} = TestRepo.delete_all(query)\n    assert %Post{title: \"1\"} = TestRepo.get(Post, id1)\n    assert %Post{title: \"2\"} = TestRepo.get(Post, id2)\n    assert %Post{title: \"3\"} = TestRepo.get(Post, id3)\n  end\n\n  test \"virtual field\" do\n    assert %Post{id: id} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert TestRepo.get(Post, id).temp == \"temp\"\n  end\n\n  ## Query syntax\n\n  defmodule Foo do\n    defstruct [:title]\n  end\n\n  describe \"query select\" do\n    test \"expressions\" do\n      %Post{} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n\n      assert [{\"1\", \"hai\"}] ==\n             TestRepo.all(from p in Post, select: {p.title, p.text})\n\n      assert [[\"1\", \"hai\"]] ==\n             TestRepo.all(from p in Post, select: [p.title, p.text])\n\n      assert [%{:title => \"1\", 3 => \"hai\", \"text\" => \"hai\"}] ==\n             TestRepo.all(from p in Post, select: %{\n               :title => p.title,\n               \"text\" => p.text,\n               3 => p.text\n             })\n\n      assert [%{:title => \"1\", \"1\" => \"hai\", \"text\" => \"hai\"}] ==\n             TestRepo.all(from p in Post, select: %{\n               :title  => p.title,\n               p.title => p.text,\n               \"text\"  => p.text\n             })\n\n      assert [%Foo{title: \"1\"}] ==\n             TestRepo.all(from p in Post, select: %Foo{title: p.title})\n    end\n\n    test \"map update\" do\n      %Post{} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n\n      assert [%Post{:title => \"new title\", text: \"hai\"}] =\n             TestRepo.all(from p in Post, select: %{p | title: \"new title\"})\n\n      assert [%Post{title: \"new title\", text: \"hai\"}] =\n        TestRepo.all(from p in Post, select: %Post{p | title: \"new title\"})\n\n      assert_raise KeyError, fn ->\n        TestRepo.all(from p in Post, select: %{p | unknown: \"new title\"})\n      end\n\n      assert_raise BadMapError, fn ->\n        TestRepo.all(from p in Post, select: %{p.title | title: \"new title\"})\n      end\n\n      assert_raise BadStructError, fn ->\n        TestRepo.all(from p in Post, select: %Foo{p | title: p.title})\n      end\n    end\n\n    test \"take with structs\" do\n      %{id: pid1} = TestRepo.insert!(%Post{title: \"1\"})\n      %{id: pid2} = TestRepo.insert!(%Post{title: \"2\"})\n      %{id: pid3} = TestRepo.insert!(%Post{title: \"3\"})\n\n      [p1, p2, p3] = Post |> select([p], struct(p, [:title])) |> order_by([:title]) |> TestRepo.all\n      refute p1.id\n      assert p1.title == \"1\"\n      assert match?(%Post{}, p1)\n      refute p2.id\n      assert p2.title == \"2\"\n      assert match?(%Post{}, p2)\n      refute p3.id\n      assert p3.title == \"3\"\n      assert match?(%Post{}, p3)\n\n      [p1, p2, p3] = Post |> select([:id]) |> order_by([:id]) |> TestRepo.all\n      assert %Post{id: ^pid1} = p1\n      assert %Post{id: ^pid2} = p2\n      assert %Post{id: ^pid3} = p3\n    end\n\n    test \"take with maps\" do\n      %{id: pid1} = TestRepo.insert!(%Post{title: \"1\"})\n      %{id: pid2} = TestRepo.insert!(%Post{title: \"2\"})\n      %{id: pid3} = TestRepo.insert!(%Post{title: \"3\"})\n\n      [p1, p2, p3] = \"posts\" |> select([p], map(p, [:title])) |> order_by([:title]) |> TestRepo.all\n      assert p1 == %{title: \"1\"}\n      assert p2 == %{title: \"2\"}\n      assert p3 == %{title: \"3\"}\n\n      [p1, p2, p3] = \"posts\" |> select([:id]) |> order_by([:id]) |> TestRepo.all\n      assert p1 == %{id: pid1}\n      assert p2 == %{id: pid2}\n      assert p3 == %{id: pid3}\n    end\n\n    test \"take with assocs\" do\n      %{id: pid} = TestRepo.insert!(%Post{title: \"post\"})\n      TestRepo.insert!(%Comment{post_id: pid, text: \"comment\"})\n      fields = [:id, :title, comments: [:text, :post_id]]\n\n      [p] = Post |> preload(:comments) |> select([p], ^fields) |> TestRepo.all\n      assert %Post{title: \"post\"} = p\n      assert [%Comment{text: \"comment\"}] = p.comments\n\n      [p] = Post |> preload(:comments) |> select([p], struct(p, ^fields)) |> TestRepo.all\n      assert %Post{title: \"post\"} = p\n      assert [%Comment{text: \"comment\"}] = p.comments\n\n      [p] = Post |> preload(:comments) |> select([p], map(p, ^fields)) |> TestRepo.all\n      assert p == %{id: pid, title: \"post\", comments: [%{text: \"comment\", post_id: pid}]}\n    end\n\n    test \"take with single nil column\" do\n      %Post{} = TestRepo.insert!(%Post{title: \"1\", counter: nil})\n      assert %{counter: nil} =\n             TestRepo.one(from p in Post, where: p.title == \"1\", select: [:counter])\n    end\n\n    test \"take with nil assoc\" do\n      %{id: cid} = TestRepo.insert!(%Comment{text: \"comment\"})\n      fields = [:id, :text, post: [:title]]\n\n      [c] = Comment |> preload(:post) |> select([c], ^fields) |> TestRepo.all\n      assert %Comment{id: ^cid, text: \"comment\", post: nil} = c\n\n      [c] = Comment |> preload(:post) |> select([c], struct(c, ^fields)) |> TestRepo.all\n      assert %Comment{id: ^cid, text: \"comment\", post: nil} = c\n\n      [c] = Comment |> preload(:post) |> select([c], map(c, ^fields)) |> TestRepo.all\n      assert c == %{id: cid, text: \"comment\", post: nil}\n    end\n\n    test \"field source\" do\n      TestRepo.insert!(%Permalink{url: \"url\"})\n      assert [\"url\"] = Permalink |> select([p], p.url) |> TestRepo.all()\n      assert [1] = Permalink |> select([p], count(p.url)) |> TestRepo.all()\n    end\n\n    test \"merge\" do\n      %Post{} = TestRepo.insert!(%Post{title: \"1\", counter: nil})\n\n      # Merge on source\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], merge(p, %{title: \"2\"})) |> TestRepo.all()\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], p) |> select_merge([p], %{title: \"2\"}) |> TestRepo.all()\n\n      # Merge on struct\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], merge(%Post{title: p.title}, %Post{title: \"2\"})) |> TestRepo.all()\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], %Post{title: p.title}) |> select_merge([p], %Post{title: \"2\"}) |> TestRepo.all()\n\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], merge(%Post{title: p.title}, %{title: \"2\"})) |> TestRepo.all()\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], %Post{title: p.title}) |> select_merge([p], %{title: \"2\"}) |> TestRepo.all()\n\n      # Merge on map\n      assert [%{title: \"2\"}] =\n             Post |> select([p], merge(%{title: p.title}, %{title: \"2\"})) |> TestRepo.all()\n      assert [%{title: \"2\"}] =\n             Post |> select([p], %{title: p.title}) |> select_merge([p], %{title: \"2\"}) |> TestRepo.all()\n\n      # Merge errors\n      assert_raise ArgumentError,\n                   ~r/can only merge with a struct on the right side when both sides represent the same struct/, fn ->\n        Post |> select([p], merge(%{title: p.title}, %Post{title: \"2\"})) |> TestRepo.all()\n      end\n\n      assert_raise ArgumentError,\n                   ~r/cannot merge because the left side is not a map/, fn ->\n        Post |> select([p], merge(p.title, %{title: \"2\"})) |> TestRepo.all()\n      end\n\n      assert_raise ArgumentError,\n                   ~r/cannot merge because the right side is not a map/, fn ->\n        Post |> select([p], merge(%{title: \"2\"}, p.title)) |> TestRepo.all()\n      end\n    end\n  end\n\n  test \"query count distinct\" do\n    TestRepo.insert!(%Post{title: \"1\"})\n    TestRepo.insert!(%Post{title: \"1\"})\n    TestRepo.insert!(%Post{title: \"2\"})\n\n    assert [3] == Post |> select([p], count(p.title)) |> TestRepo.all\n    assert [2] == Post |> select([p], count(p.title, :distinct)) |> TestRepo.all\n  end\n\n  test \"query where interpolation\" do\n    post1 = TestRepo.insert!(%Post{text: \"x\", title: \"hello\"})\n    post2 = TestRepo.insert!(%Post{text: \"y\", title: \"goodbye\"})\n\n    assert [post1, post2] == Post |> where([], []) |> TestRepo.all |> Enum.sort_by(& &1.id)\n    assert [post1]        == Post |> where([], [title: \"hello\"]) |> TestRepo.all\n    assert [post1]        == Post |> where([], [title: \"hello\", id: ^post1.id]) |> TestRepo.all\n\n    params0 = []\n    params1 = [title: \"hello\"]\n    params2 = [title: \"hello\", id: post1.id]\n    assert [post1, post2]  == (from Post, where: ^params0) |> TestRepo.all |> Enum.sort_by(& &1.id)\n    assert [post1]         == (from Post, where: ^params1) |> TestRepo.all\n    assert [post1]         == (from Post, where: ^params2) |> TestRepo.all\n\n    post3 = TestRepo.insert!(%Post{text: \"y\", title: \"goodbye\", uuid: nil})\n    params3 = [title: \"goodbye\", uuid: post3.uuid]\n    assert [post3] == (from Post, where: ^params3) |> TestRepo.all\n  end\n\n  ## Logging\n\n  test \"log entry logged on query\" do\n    log = fn entry ->\n      assert %Ecto.LogEntry{result: {:ok, _}} = entry\n      assert is_integer(entry.query_time) and entry.query_time >= 0\n      assert is_integer(entry.decode_time) and entry.query_time >= 0\n      assert is_integer(entry.queue_time) and entry.queue_time >= 0\n      send(self(), :logged)\n    end\n    Process.put(:on_log, log)\n\n    _ = TestRepo.all(Post)\n    assert_received :logged\n  end\n\n  test \"log entry not logged when log is false\" do\n    Process.put(:on_log, fn _ -> flunk(\"logged\") end)\n    TestRepo.insert!(%Post{title: \"1\"}, [log: false])\n  end\n\n  describe \"upsert via insert\" do\n    @describetag :upsert\n\n    test \"on conflict raise\" do\n      {:ok, inserted} = TestRepo.insert(%Post{title: \"first\"}, on_conflict: :raise)\n      assert catch_error(TestRepo.insert(%Post{id: inserted.id, title: \"second\"}, on_conflict: :raise))\n    end\n\n    test \"on conflict ignore\" do\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :nothing)\n      assert inserted.id\n      assert inserted.__meta__.state == :loaded\n\n      {:ok, not_inserted} = TestRepo.insert(post, on_conflict: :nothing)\n      assert not_inserted.id == nil\n      assert not_inserted.__meta__.state == :loaded\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict and associations\" do\n      on_conflict = [set: [title: \"second\"]]\n      post = %Post{uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\",\n                   title: \"first\", comments: [%Comment{}]}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert inserted.id\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict with inc\" do\n      uuid = \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"\n      post = %Post{title: \"first\", uuid: uuid}\n      {:ok, _} = TestRepo.insert(post)\n      post = %{title: \"upsert\", uuid: uuid}\n      TestRepo.insert_all(Post, [post], on_conflict: [inc: [visits: 1]], conflict_target: :uuid)\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict ignore and conflict target\" do\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:uuid])\n      assert inserted.id\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:id]))\n\n      # Error on conflict target\n      {:ok, not_inserted} = TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:uuid])\n      assert not_inserted.id == nil\n    end\n\n    @tag :without_conflict_target\n    test \"on conflict keyword list\" do\n      on_conflict = [set: [title: \"second\"]]\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict)\n      assert inserted.id\n\n      {:ok, updated} = TestRepo.insert(post, on_conflict: on_conflict)\n      assert updated.id == inserted.id\n      assert updated.title != \"second\"\n      assert TestRepo.get!(Post, inserted.id).title == \"second\"\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict keyword list and conflict target\" do\n      on_conflict = [set: [title: \"second\"]]\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert inserted.id\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:id]))\n\n      {:ok, updated} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert updated.id == inserted.id\n      assert updated.title != \"second\"\n      assert TestRepo.get!(Post, inserted.id).title == \"second\"\n    end\n\n    @tag :returning\n    @tag :with_conflict_target\n    test \"on conflict keyword list and conflict target and returning\" do\n      {:ok, c1} = TestRepo.insert(%Post{})\n      {:ok, c2} = TestRepo.insert(%Post{id: c1.id}, on_conflict: [set: [id: c1.id]], conflict_target: [:id], returning: [:id, :uuid])\n      {:ok, c3} = TestRepo.insert(%Post{id: c1.id}, on_conflict: [set: [id: c1.id]], conflict_target: [:id], returning: true)\n      {:ok, c4} = TestRepo.insert(%Post{id: c1.id}, on_conflict: [set: [id: c1.id]], conflict_target: [:id], returning: false)\n\n      assert c2.uuid == c1.uuid\n      assert c3.uuid == c1.uuid\n      assert c4.uuid != c1.uuid\n    end\n\n    @tag :with_conflict_target\n    @tag :with_conflict_target_on_constraint\n    test \"on conflict keyword list and conflict target on constraint\" do\n      on_conflict = [set: [title: \"new\"]]\n      post = %Post{title: \"old\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: {:constraint, :posts_pkey})\n      assert inserted.id\n\n      {:ok, updated} = TestRepo.insert(%{post | id: inserted.id}, on_conflict: on_conflict, conflict_target: {:constraint, :posts_pkey})\n      assert updated.id == inserted.id\n      assert updated.title != \"new\"\n      assert TestRepo.get!(Post, inserted.id).title == \"new\"\n    end\n\n    @tag :returning\n    @tag :with_conflict_target\n    test \"on conflict keyword list and conflict target and returning and field source\" do\n      TestRepo.insert!(%Permalink{url: \"old\"})\n      {:ok, c1} = TestRepo.insert(%Permalink{url: \"old\"},\n                                  on_conflict: [set: [url: \"new1\"]],\n                                  conflict_target: [:url],\n                                  returning: [:url])\n\n      TestRepo.insert!(%Permalink{url: \"old\"})\n      {:ok, c2} = TestRepo.insert(%Permalink{url: \"old\"},\n                                  on_conflict: [set: [url: \"new2\"]],\n                                  conflict_target: [:url],\n                                  returning: true)\n\n      assert c1.url == \"new1\"\n      assert c2.url == \"new2\"\n    end\n\n    @tag :returning\n    @tag :with_conflict_target\n    test \"on conflict ignore and returning\" do\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:uuid])\n      assert inserted.id\n\n      {:ok, not_inserted} = TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:uuid], returning: true)\n      assert not_inserted.id == nil\n    end\n\n    @tag :without_conflict_target\n    test \"on conflict query\" do\n      on_conflict = from Post, update: [set: [title: \"second\"]]\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict)\n      assert inserted.id\n\n      {:ok, updated} = TestRepo.insert(post, on_conflict: on_conflict)\n      assert updated.id == inserted.id\n      assert updated.title != \"second\"\n      assert TestRepo.get!(Post, inserted.id).title == \"second\"\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict query and conflict target\" do\n      on_conflict = from Post, update: [set: [title: \"second\"]]\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert inserted.id\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:id]))\n\n      {:ok, updated} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert updated.id == inserted.id\n      assert updated.title != \"second\"\n      assert TestRepo.get!(Post, inserted.id).title == \"second\"\n    end\n\n    @tag :without_conflict_target\n    test \"on conflict replace_all\" do\n      post = %Post{title: \"first\", text: \"text\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :replace_all)\n      assert inserted.id\n\n      # Error on non-conflict target\n      post = %Post{id: inserted.id, title: \"updated\",\n                   text: \"updated\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n\n      # Error on conflict target\n      post = TestRepo.insert!(post, on_conflict: :replace_all)\n      assert post.title == \"updated\"\n      assert post.text == \"updated\"\n\n      assert TestRepo.all(from p in Post, select: p.title) == [\"updated\"]\n      assert TestRepo.all(from p in Post, select: p.text) == [\"updated\"]\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [1]\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict replace_all and conflict target\" do\n      post = %Post{title: \"first\", text: \"text\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :replace_all, conflict_target: :id)\n      assert inserted.id\n\n      # Error on non-conflict target\n      post = %Post{id: inserted.id, title: \"updated\",\n                   text: \"updated\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n\n      # Error on conflict target\n      post = TestRepo.insert!(post, on_conflict: :replace_all, conflict_target: :id)\n      assert post.title == \"updated\"\n      assert post.text == \"updated\"\n\n      assert TestRepo.all(from p in Post, select: p.title) == [\"updated\"]\n      assert TestRepo.all(from p in Post, select: p.text) == [\"updated\"]\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [1]\n    end\n  end\n\n  describe \"upsert via insert_all\" do\n    @describetag :upsert_all\n\n    test \"on conflict raise\" do\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      {1, nil} = TestRepo.insert_all(Post, [post], on_conflict: :raise)\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: :raise))\n    end\n\n    test \"on conflict ignore\" do\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      assert TestRepo.insert_all(Post, [post], on_conflict: :nothing) == {1, nil}\n\n      # PG returns 0, MySQL returns 1\n      {entries, nil} = TestRepo.insert_all(Post, [post], on_conflict: :nothing)\n      assert entries == 0 or entries == 1\n\n      assert length(TestRepo.all(Post)) == 1\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict ignore and conflict target\" do\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      assert TestRepo.insert_all(Post, [post], on_conflict: :nothing, conflict_target: [:uuid]) ==\n             {1, nil}\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: :nothing, conflict_target: [:id]))\n\n      # Error on conflict target\n      assert TestRepo.insert_all(Post, [post], on_conflict: :nothing, conflict_target: [:uuid]) ==\n             {0, nil}\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict keyword list and conflict target\" do\n      on_conflict = [set: [title: \"second\"]]\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      {1, nil} = TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:uuid])\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:id]))\n\n      # Error on conflict target\n      assert TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n      assert TestRepo.all(from p in Post, select: p.title) == [\"second\"]\n    end\n\n    @tag :with_conflict_target\n    @tag :returning\n    test \"on conflict keyword list and conflict target and returning and source field\" do\n      on_conflict = [set: [url: \"new\"]]\n      permalink = [url: \"old\"]\n\n      assert {1, [%Permalink{url: \"old\"}]} =\n             TestRepo.insert_all(Permalink, [permalink],\n                                 on_conflict: on_conflict, conflict_target: [:url], returning: [:url])\n\n      assert {1, [%Permalink{url: \"new\"}]} =\n             TestRepo.insert_all(Permalink, [permalink],\n                                 on_conflict: on_conflict, conflict_target: [:url], returning: [:url])\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict query and conflict target\" do\n      on_conflict = from Post, update: [set: [title: \"second\"]]\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      assert TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:id]))\n\n      # Error on conflict target\n      assert TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n      assert TestRepo.all(from p in Post, select: p.title) == [\"second\"]\n    end\n\n    @tag :returning\n    @tag :with_conflict_target\n    test \"on conflict query and conflict target and returning\" do\n      on_conflict = from Post, update: [set: [title: \"second\"]]\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      {1, [%{id: id}]} = TestRepo.insert_all(Post, [post], on_conflict: on_conflict,\n                                            conflict_target: [:uuid], returning: [:id])\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: on_conflict,\n                                             conflict_target: [:id], returning: [:id]))\n\n      # Error on conflict target\n      {1, [%Post{id: ^id, title: \"second\"}]} =\n        TestRepo.insert_all(Post, [post], on_conflict: on_conflict,\n                            conflict_target: [:uuid], returning: [:id, :title])\n    end\n\n    @tag :with_conflict_target\n    test \"source (without an ecto schema) on conflict query and conflict target\" do\n      on_conflict = [set: [title: \"second\"]]\n      {:ok, uuid} = Ecto.UUID.dump(\"6fa459ea-ee8a-3ca4-894e-db77e160355e\")\n      post = [title: \"first\", uuid: uuid]\n      assert TestRepo.insert_all(\"posts\", [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(\"posts\", [post], on_conflict: on_conflict, conflict_target: [:id]))\n\n      # Error on conflict target\n      assert TestRepo.insert_all(\"posts\", [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n      assert TestRepo.all(from p in Post, select: p.title) == [\"second\"]\n    end\n\n    @tag :without_conflict_target\n    test \"on conflict replace_all\" do\n      post_first = %Post{title: \"first\", public: true}\n      post_second = %Post{title: \"second\", public: false}\n\n      {:ok, inserted_first} = TestRepo.insert(post_first, on_conflict: :replace_all)\n      {:ok, inserted_second} = TestRepo.insert(post_second, on_conflict: :replace_all)\n\n      assert inserted_first.id\n      assert inserted_second.id\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [2]\n\n      # multiple record change value\n      changes = [%{id: inserted_first.id, title: \"first_updated\", text: \"first_updated\"},\n                 %{id: inserted_second.id, title: \"second_updated\", text: \"second_updated\"}]\n\n      TestRepo.insert_all(Post, changes, on_conflict: :replace_all)\n\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [2]\n\n      updated_first =  TestRepo.get(Post, inserted_first.id)\n      assert updated_first.title == \"first_updated\"\n      assert updated_first.text == \"first_updated\"\n\n      updated_first =  TestRepo.get(Post, inserted_second.id)\n      assert updated_first.title == \"second_updated\"\n      assert updated_first.text == \"second_updated\"\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict replace_all and conflict_target\" do\n      post_first = %Post{title: \"first\", public: true}\n      post_second = %Post{title: \"second\", public: false}\n\n      {:ok, inserted_first} = TestRepo.insert(post_first, on_conflict: :replace_all, conflict_target: :id)\n      {:ok, inserted_second} = TestRepo.insert(post_second, on_conflict: :replace_all, conflict_target: :id)\n\n      assert inserted_first.id\n      assert inserted_second.id\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [2]\n\n      # multiple record change value\n      changes = [%{id: inserted_first.id, title: \"first_updated\", text: \"first_updated\"},\n                 %{id: inserted_second.id, title: \"second_updated\", text: \"second_updated\"}]\n\n      TestRepo.insert_all(Post, changes, on_conflict: :replace_all, conflict_target: :id)\n\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [2]\n\n      updated_first =  TestRepo.get(Post, inserted_first.id)\n      assert updated_first.title == \"first_updated\"\n      assert updated_first.text == \"first_updated\"\n\n\n      updated_first =  TestRepo.get(Post, inserted_second.id)\n      assert updated_first.title == \"second_updated\"\n      assert updated_first.text == \"second_updated\"\n    end\n  end\nend\n", "defmodule Ecto.Repo.Queryable do\n  # The module invoked by user defined repos\n  # for query related functionality.\n  @moduledoc false\n\n  @dialyzer {:no_opaque, transaction: 4}\n\n  alias Ecto.Query\n  alias Ecto.Queryable\n  alias Ecto.Query.Planner\n  alias Ecto.Query.SelectExpr\n\n  require Ecto.Query\n\n  def transaction(adapter, repo, fun, opts) when is_function(fun, 0) do\n    adapter.transaction(repo, opts, fun)\n  end\n\n  def transaction(adapter, repo, %Ecto.Multi{} = multi, opts) do\n    wrap   = &adapter.transaction(repo, opts, &1)\n    return = &adapter.rollback(repo, &1)\n\n    case Ecto.Multi.__apply__(multi, repo, wrap, return) do\n      {:ok, values} ->\n        {:ok, values}\n      {:error, {key, error_value, values}} ->\n        {:error, key, error_value, values}\n    end\n  end\n\n  def all(repo, adapter, queryable, opts) when is_list(opts) do\n    query =\n      queryable\n      |> Ecto.Queryable.to_query\n      |> Ecto.Query.Planner.returning(true)\n      |> attach_prefix(opts)\n    execute(:all, repo, adapter, query, opts) |> elem(1)\n  end\n\n  def stream(repo, adapter, queryable, opts) when is_list(opts) do\n    query =\n      queryable\n      |> Ecto.Queryable.to_query\n      |> Ecto.Query.Planner.returning(true)\n      |> attach_prefix(opts)\n    stream(:all, repo, adapter, query, opts)\n  end\n\n  def get(repo, adapter, queryable, id, opts) do\n    one(repo, adapter, query_for_get(repo, queryable, id), opts)\n  end\n\n  def get!(repo, adapter, queryable, id, opts) do\n    one!(repo, adapter, query_for_get(repo, queryable, id), opts)\n  end\n\n  def get_by(repo, adapter, queryable, clauses, opts) do\n    one(repo, adapter, query_for_get_by(repo, queryable, clauses), opts)\n  end\n\n  def get_by!(repo, adapter, queryable, clauses, opts) do\n    one!(repo, adapter, query_for_get_by(repo, queryable, clauses), opts)\n  end\n\n  def aggregate(repo, adapter, queryable, aggregate, field, opts) do\n    one!(repo, adapter, query_for_aggregate(queryable, aggregate, field), opts)\n  end\n\n  def one(repo, adapter, queryable, opts) do\n    case all(repo, adapter, queryable, opts) do\n      [one] -> one\n      []    -> nil\n      other -> raise Ecto.MultipleResultsError, queryable: queryable, count: length(other)\n    end\n  end\n\n  def one!(repo, adapter, queryable, opts) do\n    case all(repo, adapter, queryable, opts) do\n      [one] -> one\n      []    -> raise Ecto.NoResultsError, queryable: queryable\n      other -> raise Ecto.MultipleResultsError, queryable: queryable, count: length(other)\n    end\n  end\n\n  def update_all(repo, adapter, queryable, [], opts) when is_list(opts) do\n    update_all(repo, adapter, queryable, opts)\n  end\n\n  def update_all(repo, adapter, queryable, updates, opts) when is_list(opts) do\n    query = Query.from queryable, update: ^updates\n    update_all(repo, adapter, query, opts)\n  end\n\n  defp update_all(repo, adapter, queryable, opts) do\n    query =\n      queryable\n      |> Ecto.Queryable.to_query\n      |> Ecto.Query.Planner.assert_no_select!(:update_all)\n      |> Ecto.Query.Planner.returning(opts[:returning] || false)\n      |> attach_prefix(opts)\n    execute(:update_all, repo, adapter, query, opts)\n  end\n\n  def delete_all(repo, adapter, queryable, opts) when is_list(opts) do\n    query =\n      queryable\n      |> Ecto.Queryable.to_query\n      |> Ecto.Query.Planner.assert_no_select!(:delete_all)\n      |> Ecto.Query.Planner.returning(opts[:returning] || false)\n      |> attach_prefix(opts)\n    execute(:delete_all, repo, adapter, query, opts)\n  end\n\n  ## Helpers\n\n  defp attach_prefix(query, opts) do\n    case Keyword.fetch(opts, :prefix) do\n      {:ok, prefix} -> %{query | prefix: prefix}\n      :error -> query\n    end\n  end\n\n  defp execute(operation, repo, adapter, query, opts) when is_list(opts) do\n    {meta, prepared, params} = Planner.query(query, operation, repo, adapter, 0)\n\n    case meta do\n      %{select: nil} ->\n        adapter.execute(repo, meta, prepared, params, nil, opts)\n      %{select: select, prefix: prefix, sources: sources, preloads: preloads} ->\n        %{preprocess: preprocess, postprocess: postprocess, take: take, assocs: assocs} = select\n        all_nil? = tuple_size(sources) != 1\n        preprocessor = &preprocess(&1, preprocess, all_nil?, prefix, adapter)\n        {count, rows} = adapter.execute(repo, meta, prepared, params, preprocessor, opts)\n        postprocessor = postprocessor(postprocess, take, prefix, adapter)\n\n        {count,\n          rows\n          |> Ecto.Repo.Assoc.query(assocs, sources)\n          |> Ecto.Repo.Preloader.query(repo, preloads, take, postprocessor, opts)}\n    end\n  end\n\n  defp stream(operation, repo, adapter, query, opts) do\n    {meta, prepared, params} = Planner.query(query, operation, repo, adapter, 0)\n\n    case meta do\n      %{select: nil} ->\n        repo\n        |> adapter.stream(meta, prepared, params, nil, opts)\n        |> Stream.flat_map(fn {_, nil} -> [] end)\n      %{select: select, prefix: prefix, sources: sources, preloads: preloads} ->\n        %{preprocess: preprocess, postprocess: postprocess, take: take, assocs: assocs} = select\n        all_nil? = tuple_size(sources) != 1\n        preprocessor = &preprocess(&1, preprocess, all_nil?, prefix, adapter)\n        stream = adapter.stream(repo, meta, prepared, params, preprocessor, opts)\n        postprocessor = postprocessor(postprocess, take, prefix, adapter)\n\n        Stream.flat_map(stream, fn {_, rows} ->\n          rows\n          |> Ecto.Repo.Assoc.query(assocs, sources)\n          |> Ecto.Repo.Preloader.query(repo, preloads, take, postprocessor, opts)\n        end)\n    end\n  end\n\n  defp preprocess(row, [], _all_nil?, _prefix, _adapter) do\n    row\n  end\n  defp preprocess(row, [{:source, source_schema, fields} | sources], all_nil?, prefix, adapter) do\n    {entry, rest} = process_source(source_schema, fields, row, all_nil?, prefix, adapter)\n    [entry | preprocess(rest, sources, true, prefix, adapter)]\n  end\n  defp preprocess(row, [source | sources], all_nil?, prefix, adapter) do\n    {entry, rest} = process(row, source, nil, prefix, adapter)\n    [entry | preprocess(rest, sources, all_nil?, prefix, adapter)]\n  end\n\n  defp postprocessor({:from, :any, postprocess}, _take, prefix, adapter) do\n    fn [from | row] ->\n      row |> process(postprocess, from, prefix, adapter) |> elem(0)\n    end\n  end\n  defp postprocessor({:from, :map, postprocess}, take, prefix, adapter) do\n    fn [from | row] ->\n      row |> process(postprocess, to_map(from, take), prefix, adapter) |> elem(0)\n    end\n  end\n  defp postprocessor(postprocess, _take, prefix, adapter) do\n    fn row -> row |> process(postprocess, nil, prefix, adapter) |> elem(0) end\n  end\n\n  defp process(row, {:merge, left, right}, from, prefix, adapter) do\n    {left, row} = process(row, left, from, prefix, adapter)\n    {right, row} = process(row, right, from, prefix, adapter)\n\n    data =\n      case {left, right} do\n        {%{__struct__: struct}, %{__struct__: struct}} ->\n          right\n          |> Map.from_struct()\n          |> Enum.reduce(left, fn {key, value}, acc -> %{acc | key => value} end)\n        {_, %{__struct__: _}} ->\n          raise ArgumentError, \"can only merge with a struct on the right side when both sides \" <>\n                               \"represent the same struct. Left side is #{inspect left} and \" <>\n                               \"right side is #{inspect right}\"\n        {%{__struct__: _}, %{}} ->\n          Enum.reduce(right, left, fn {key, value}, acc -> %{acc | key => value} end)\n        {%{}, %{}} ->\n          Map.merge(left, right)\n        {_, %{}} ->\n          raise ArgumentError, \"cannot merge because the left side is not a map, got: #{inspect left}\"\n        {%{}, _} ->\n          raise ArgumentError, \"cannot merge because the right side is not a map, got: #{inspect right}\"\n      end\n\n    {data, row}\n  end\n  defp process(row, {:struct, struct, data, args}, from, prefix, adapter) do\n    case process(row, data, from, prefix, adapter) do\n      {%{__struct__: ^struct} = data, row} ->\n        process_update(data, args, row, from, prefix, adapter)\n      {data, _row} ->\n        raise BadStructError, struct: struct, term: data\n    end\n  end\n  defp process(row, {:struct, struct, args}, from, prefix, adapter) do\n    {fields, row} = process_kv(args, row, from, prefix, adapter)\n    {Map.merge(struct.__struct__(), Map.new(fields)), row}\n  end\n  defp process(row, {:map, data, args}, from, prefix, adapter) do\n    {data, row} = process(row, data, from, prefix, adapter)\n    process_update(data, args, row, from, prefix, adapter)\n  end\n  defp process(row, {:map, args}, from, prefix, adapter) do\n    {args, row} = process_kv(args, row, from, prefix, adapter)\n    {Map.new(args), row}\n  end\n  defp process(row, {:list, args}, from, prefix, adapter) do\n    process_args(args, row, from, prefix, adapter)\n  end\n  defp process(row, {:tuple, args}, from, prefix, adapter) do\n    {args, row} = process_args(args, row, from, prefix, adapter)\n    {List.to_tuple(args), row}\n  end\n  defp process(row, {:source, :from}, from, _prefix, _adapter) do\n    {from, row}\n  end\n  defp process(row, {:source, source_schema, fields}, _from, prefix, adapter) do\n    process_source(source_schema, fields, row, true, prefix, adapter)\n  end\n  defp process([value | row], {:value, :any}, _from, _prefix, _adapter) do\n    {value, row}\n  end\n  defp process([value | row], {:value, type}, _from, _prefix, adapter) do\n    {load!(type, value, nil, nil, adapter), row}\n  end\n  defp process(row, value, _from, _prefix, _adapter)\n       when is_binary(value) or is_number(value) or is_atom(value) do\n    {value, row}\n  end\n\n  defp process_update(data, args, row, from, prefix, adapter) do\n    {args, row} = process_kv(args, row, from, prefix, adapter)\n    data = Enum.reduce(args, data, fn {key, value}, acc -> %{acc | key => value} end)\n    {data, row}\n  end\n\n  defp process_source({source, schema}, types, row, all_nil?, prefix, adapter) do\n    case split_values(types, row, [], all_nil?) do\n      {nil, row} ->\n        {nil, row}\n      {values, row} ->\n        struct = if schema, do: schema.__struct__(), else: %{}\n        loader = &Ecto.Type.adapter_load(adapter, &1, &2)\n        {Ecto.Schema.__safe_load__(struct, types, values, prefix, source, loader), row}\n    end\n  end\n\n  defp split_values([_ | types], [nil | values], acc, all_nil?) do\n    split_values(types, values, [nil | acc], all_nil?)\n  end\n  defp split_values([_ | types], [value | values], acc, _all_nil?) do\n    split_values(types, values, [value | acc], false)\n  end\n  defp split_values([], values, _acc, true) do\n    {nil, values}\n  end\n  defp split_values([], values, acc, false) do\n    {Enum.reverse(acc), values}\n  end\n\n  defp process_args(args, row, from, prefix, adapter) do\n    Enum.map_reduce(args, row, fn arg, row ->\n      process(row, arg, from, prefix, adapter)\n    end)\n  end\n\n  defp process_kv(kv, row, from, prefix, adapter) do\n    Enum.map_reduce(kv, row, fn {key, value}, row ->\n      {key, row} = process(row, key, from, prefix, adapter)\n      {value, row} = process(row, value, from, prefix, adapter)\n      {{key, value}, row}\n    end)\n  end\n\n  defp load!(type, value, field, struct, adapter) do\n    case Ecto.Type.adapter_load(adapter, type, value) do\n      {:ok, value} ->\n        value\n      :error ->\n        field = field && \" for field #{inspect field}\"\n        struct = struct && \" in #{inspect struct}\"\n        raise ArgumentError, \"cannot load `#{inspect value}` as type #{inspect type}#{field}#{struct}\"\n    end\n  end\n\n  defp to_map(nil, _fields) do\n    nil\n  end\n  defp to_map(value, fields) when is_list(value) do\n    Enum.map(value, &to_map(&1, fields))\n  end\n  defp to_map(value, fields) do\n    for field <- fields, into: %{} do\n      case field do\n        {k, v} -> {k, to_map(Map.fetch!(value, k), List.wrap(v))}\n        k -> {k, Map.fetch!(value, k)}\n      end\n    end\n  end\n\n  defp query_for_get(repo, _queryable, nil) do\n    raise ArgumentError, \"cannot perform #{inspect repo}.get/2 because the given value is nil\"\n  end\n\n  defp query_for_get(repo, queryable, id) do\n    query  = Queryable.to_query(queryable)\n    schema = assert_schema!(query)\n    case schema.__schema__(:primary_key) do\n      [pk] ->\n        Query.from(x in query, where: field(x, ^pk) == ^id)\n      pks ->\n        raise ArgumentError,\n          \"#{inspect repo}.get/2 requires the schema #{inspect schema} \" <>\n          \"to have exactly one primary key, got: #{inspect pks}\"\n    end\n  end\n\n  defp query_for_get_by(_repo, queryable, clauses) do\n    Enum.reduce(clauses, queryable, fn\n      ({key, nil}, query) ->\n        Query.where(query, [x], is_nil(field(x, ^key)))\n      ({key, value}, query) ->\n        Query.where(query, [x], field(x, ^key) == ^value)\n    end)\n  end\n\n  defp query_for_aggregate(queryable, aggregate, field) do\n    query = %{Queryable.to_query(queryable) | preloads: [], assocs: []}\n    ast   = field(0, field)\n\n    query =\n      case query do\n        %{group_bys: [_|_]} ->\n          raise Ecto.QueryError, message: \"cannot aggregate on query with group_by\", query: query\n        %{distinct: nil, limit: nil, offset: nil} ->\n          %{query | order_bys: []}\n        _ ->\n          select = %SelectExpr{expr: ast, file: __ENV__.file, line: __ENV__.line}\n          %{query | select: select}\n          |> Query.subquery()\n          |> Queryable.Ecto.SubQuery.to_query()\n      end\n\n    %{query | select: %SelectExpr{expr: {aggregate, [], [ast]},\n                                  file: __ENV__.file, line: __ENV__.line}}\n  end\n\n  defp field(ix, field) when is_integer(ix) and is_atom(field) do\n    {{:., [], [{:&, [], [ix]}, field]}, [], []}\n  end\n\n  defp assert_schema!(%{from: {_source, schema}}) when schema != nil, do: schema\n  defp assert_schema!(query) do\n    raise Ecto.QueryError,\n      query: query,\n      message: \"expected a from expression with a schema\"\n  end\nend\n", "defmodule Ecto.RepoTest do\n  use ExUnit.Case, async: true\n\n  import Ecto.Query\n  import Ecto, only: [put_meta: 2]\n  require Ecto.TestRepo, as: TestRepo\n\n  defmodule MySchema do\n    use Ecto.Schema\n\n    schema \"my_schema\" do\n      field :x, :string\n      field :y, :binary, source: :yyy\n      field :z, :string, default: \"z\"\n      field :array, {:array, :string}\n      field :map, {:map, :string}\n      belongs_to :another, MySchema.Another\n    end\n  end\n\n  defmodule MySchemaNoPK do\n    use Ecto.Schema\n\n    @primary_key false\n    schema \"my_schema\" do\n      field :x, :string\n    end\n  end\n\n  test \"defines child_spec/1\" do\n    assert TestRepo.child_spec([]) == %{\n      id: TestRepo,\n      start: {TestRepo, :start_link, [[]]},\n      type: :supervisor\n    }\n  end\n\n  test \"needs schema with primary key field\" do\n    schema = %MySchemaNoPK{x: \"abc\"}\n\n    assert_raise Ecto.NoPrimaryKeyFieldError, fn ->\n      TestRepo.update!(schema |> Ecto.Changeset.change, force: true)\n    end\n\n    assert_raise Ecto.NoPrimaryKeyFieldError, fn ->\n      TestRepo.delete!(schema)\n    end\n  end\n\n  test \"works with primary key value\" do\n    schema = %MySchema{id: 1, x: \"abc\"}\n    TestRepo.get(MySchema, 123)\n    TestRepo.get_by(MySchema, x: \"abc\")\n    TestRepo.update!(schema |> Ecto.Changeset.change, force: true)\n    TestRepo.delete!(schema)\n  end\n\n  test \"works with custom source schema\" do\n    schema = %MySchema{id: 1, x: \"abc\"} |> put_meta(source: \"custom_schema\")\n    TestRepo.update!(schema |> Ecto.Changeset.change, force: true)\n    TestRepo.delete!(schema)\n\n    to_insert = %MySchema{x: \"abc\"} |> put_meta(source: \"custom_schema\")\n    TestRepo.insert!(to_insert)\n  end\n\n  test \"fails without primary key value\" do\n    schema = %MySchema{x: \"abc\"}\n\n    assert_raise Ecto.NoPrimaryKeyValueError, fn ->\n      TestRepo.update!(schema |> Ecto.Changeset.change, force: true)\n    end\n\n    assert_raise Ecto.NoPrimaryKeyValueError, fn ->\n      schema\n      |> Ecto.Changeset.change()\n      |> TestRepo.update()\n    end\n\n    assert_raise Ecto.NoPrimaryKeyValueError, fn ->\n      TestRepo.delete!(schema)\n    end\n  end\n\n  test \"validates schema types\" do\n    schema = %MySchema{x: 123}\n\n    assert_raise Ecto.ChangeError, fn ->\n      TestRepo.insert!(schema)\n    end\n  end\n\n  test \"validates get\" do\n    TestRepo.get(MySchema, 123)\n\n    message = \"cannot perform Ecto.TestRepo.get/2 because the given value is nil\"\n    assert_raise ArgumentError, message, fn ->\n      TestRepo.get(MySchema, nil)\n    end\n\n    message = ~r\"value `:atom` in `where` cannot be cast to type :id in query\"\n    assert_raise Ecto.Query.CastError, message, fn ->\n      TestRepo.get(MySchema, :atom)\n    end\n\n    message = ~r\"expected a from expression with a schema in query\"\n    assert_raise Ecto.QueryError, message, fn ->\n      TestRepo.get(%Ecto.Query{}, :atom)\n    end\n  end\n\n  test \"validates get_by\" do\n    TestRepo.get_by(MySchema, id: 123)\n    TestRepo.get_by(MySchema, %{id: 123})\n    TestRepo.get_by(MySchema, id: nil)\n\n    message = ~r\"value `:atom` in `where` cannot be cast to type :id in query\"\n    assert_raise Ecto.Query.CastError, message, fn ->\n      TestRepo.get_by(MySchema, id: :atom)\n    end\n  end\n\n  test \"stream emits row values lazily\" do\n    stream = TestRepo.stream(MySchema)\n    refute_received :stream_execute\n    assert Enum.to_list(stream) == [1]\n    assert_received :stream_execute\n    assert Enum.take(stream, 0) == []\n    refute_received :stream_execute\n  end\n\n  test \"validates update_all\" do\n    # Success\n    TestRepo.update_all(MySchema, set: [x: \"321\"])\n\n    query = from(e in MySchema, where: e.x == \"123\", update: [set: [x: \"321\"]])\n    TestRepo.update_all(query, [])\n\n    # Failures\n    assert_raise ArgumentError, ~r/:returning expects at least one field to be given/, fn ->\n      TestRepo.update_all MySchema, [set: [x: \"321\"]], returning: []\n    end\n\n    assert_raise Ecto.QueryError, fn ->\n      TestRepo.update_all from(e in MySchema, select: e), set: [x: \"321\"]\n    end\n\n    assert_raise Ecto.QueryError, fn ->\n      TestRepo.update_all from(e in MySchema, order_by: e.x), set: [x: \"321\"]\n    end\n  end\n\n  test \"validates delete_all\" do\n    # Success\n    TestRepo.delete_all(MySchema)\n\n    query = from(e in MySchema, where: e.x == \"123\")\n    TestRepo.delete_all(query)\n\n    # Failures\n    assert_raise ArgumentError, ~r/:returning expects at least one field to be given/, fn ->\n      TestRepo.delete_all MySchema, returning: []\n    end\n\n    assert_raise Ecto.QueryError, fn ->\n      TestRepo.delete_all from(e in MySchema, select: e)\n    end\n\n    assert_raise Ecto.QueryError, fn ->\n      TestRepo.delete_all from(e in MySchema, order_by: e.x)\n    end\n  end\n\n  ## Changesets\n\n  test \"insert, update, insert_or_update and delete accepts changesets\" do\n    valid = Ecto.Changeset.cast(%MySchema{id: 1}, %{}, [])\n    assert {:ok, %MySchema{}} = TestRepo.insert(valid)\n    assert {:ok, %MySchema{}} = TestRepo.update(valid)\n    assert {:ok, %MySchema{}} = TestRepo.insert_or_update(valid)\n    assert {:ok, %MySchema{}} = TestRepo.delete(valid)\n  end\n\n  test \"insert, update, insert_or_update and delete sets schema prefix\" do\n    valid = Ecto.Changeset.cast(%MySchema{id: 1}, %{x: \"foo\"}, [:x])\n\n    assert {:ok, schema} = TestRepo.insert(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n\n    assert {:ok, schema} = TestRepo.update(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n\n    assert {:ok, schema} = TestRepo.delete(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n  end\n\n  test \"insert, update, and delete sets schema prefix from changeset repo opts\" do\n    valid =\n      %MySchema{id: 1}\n      |> Ecto.Changeset.cast(%{x: \"foo\"}, [:x])\n      |> Map.put(:repo_opts, [prefix: \"public\"])\n\n    assert {:ok, schema} = TestRepo.insert(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n\n    assert {:ok, schema} = TestRepo.update(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n\n    assert {:ok, schema} = TestRepo.delete(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n  end\n\n  test \"insert, update, insert_or_update and delete errors on invalid changeset\" do\n    invalid = %Ecto.Changeset{valid?: false, data: %MySchema{}}\n\n    insert = %{invalid | action: :insert, repo: TestRepo}\n    assert {:error, ^insert} = TestRepo.insert(invalid)\n    assert {:error, ^insert} = TestRepo.insert_or_update(invalid)\n\n    update = %{invalid | action: :update, repo: TestRepo}\n    assert {:error, ^update} = TestRepo.update(invalid)\n\n    delete = %{invalid | action: :delete, repo: TestRepo}\n    assert {:error, ^delete} = TestRepo.delete(invalid)\n\n    ignore = %{invalid | action: :ignore, repo: TestRepo}\n    assert {:error, ^insert} = TestRepo.insert(ignore)\n    assert {:error, ^update} = TestRepo.update(ignore)\n    assert {:error, ^delete} = TestRepo.delete(ignore)\n\n    assert_raise ArgumentError, ~r\"a valid changeset with action :ignore was given to Ecto.TestRepo.insert/2\", fn ->\n      TestRepo.insert(%{ignore | valid?: true})\n    end\n  end\n\n  test \"insert!, update! and delete! accepts changesets\" do\n    valid = Ecto.Changeset.cast(%MySchema{id: 1}, %{}, [])\n    assert %MySchema{} = TestRepo.insert!(valid)\n    assert %MySchema{} = TestRepo.update!(valid)\n    assert %MySchema{} = TestRepo.insert_or_update!(valid)\n    assert %MySchema{} = TestRepo.delete!(valid)\n  end\n\n  test \"insert!, update!, insert_or_update! and delete! fail on invalid changeset\" do\n    invalid = %Ecto.Changeset{valid?: false, data: %MySchema{}, types: %{}}\n\n    assert_raise Ecto.InvalidChangesetError,\n                 ~r\"could not perform insert because changeset is invalid\", fn ->\n      TestRepo.insert!(invalid)\n    end\n\n    assert_raise Ecto.InvalidChangesetError,\n                 ~r\"could not perform update because changeset is invalid\", fn ->\n      TestRepo.update!(invalid)\n    end\n\n    assert_raise Ecto.InvalidChangesetError,\n                 ~r\"could not perform insert because changeset is invalid\", fn ->\n      TestRepo.insert_or_update!(invalid)\n    end\n\n    assert_raise Ecto.InvalidChangesetError,\n                 ~r\"could not perform delete because changeset is invalid\", fn ->\n      TestRepo.delete!(invalid)\n    end\n  end\n\n  test \"insert!, update! and delete! fail on changeset without data\" do\n    invalid = %Ecto.Changeset{valid?: true, data: nil}\n\n    assert_raise ArgumentError, \"cannot insert a changeset without :data\", fn ->\n      TestRepo.insert!(invalid)\n    end\n\n    assert_raise ArgumentError, \"cannot update a changeset without :data\", fn ->\n      TestRepo.update!(invalid)\n    end\n\n    assert_raise ArgumentError, \"cannot delete a changeset without :data\", fn ->\n      TestRepo.delete!(invalid)\n    end\n  end\n\n  test \"insert!, update!, insert_or_update! and delete! fail on changeset with wrong action\" do\n    invalid = %Ecto.Changeset{valid?: true, data: %MySchema{id: 123}, action: :other}\n\n    assert_raise ArgumentError, \"a changeset with action :other was given to Ecto.TestRepo.insert/2\", fn ->\n      TestRepo.insert!(invalid)\n    end\n\n    assert_raise ArgumentError, \"a changeset with action :other was given to Ecto.TestRepo.update/2\", fn ->\n      TestRepo.update!(invalid)\n    end\n\n    assert_raise ArgumentError, \"a changeset with action :other was given to Ecto.TestRepo.insert/2\", fn ->\n      TestRepo.insert_or_update!(invalid)\n    end\n\n    assert_raise ArgumentError, \"a changeset with action :other was given to Ecto.TestRepo.delete/2\", fn ->\n      TestRepo.delete!(invalid)\n    end\n  end\n\n  test \"insert_or_update uses the correct action\" do\n    built  = Ecto.Changeset.cast(%MySchema{y: \"built\"}, %{}, [])\n    loaded =\n      %MySchema{y: \"loaded\"}\n      |> TestRepo.insert!\n      |> Ecto.Changeset.cast(%{y: \"updated\"}, [:y])\n    assert_received {:insert, _}\n\n    TestRepo.insert_or_update built\n    assert_received {:insert, _}\n\n    TestRepo.insert_or_update loaded\n    assert_received {:update, _}\n  end\n\n  test \"insert_or_update fails on invalid states\" do\n    deleted =\n      %MySchema{y: \"deleted\"}\n      |> TestRepo.insert!\n      |> TestRepo.delete!\n      |> Ecto.Changeset.cast(%{y: \"updated\"}, [:y])\n\n    assert_raise ArgumentError, ~r/the changeset has an invalid state/, fn ->\n      TestRepo.insert_or_update deleted\n    end\n  end\n\n  test \"insert_or_update fails when being passed a struct\" do\n    assert_raise ArgumentError, ~r/giving a struct to .* is not supported/, fn ->\n      TestRepo.insert_or_update %MySchema{}\n    end\n  end\n\n  defp prepare_changeset() do\n    %MySchema{id: 1}\n    |> Ecto.Changeset.cast(%{x: \"one\"}, [:x])\n    |> Ecto.Changeset.prepare_changes(fn %{repo: repo} = changeset ->\n          Process.put(:ecto_repo, repo)\n          Process.put(:ecto_counter, 1)\n          changeset\n        end)\n    |> Ecto.Changeset.prepare_changes(fn changeset ->\n          Process.put(:ecto_counter, 2)\n          changeset\n        end)\n  end\n\n  test \"insert runs prepare callbacks in transaction\" do\n    changeset = prepare_changeset()\n    TestRepo.insert!(changeset)\n    assert_received {:transaction, _}\n    assert Process.get(:ecto_repo) == TestRepo\n    assert Process.get(:ecto_counter) == 2\n  end\n\n  test \"update runs prepare callbacks in transaction\" do\n    changeset = prepare_changeset()\n    TestRepo.update!(changeset)\n    assert_received {:transaction, _}\n    assert Process.get(:ecto_repo) == TestRepo\n    assert Process.get(:ecto_counter) == 2\n  end\n\n  test \"delete runs prepare callbacks in transaction\" do\n    changeset = prepare_changeset()\n    TestRepo.delete!(changeset)\n    assert_received {:transaction, _}\n    assert Process.get(:ecto_repo) == TestRepo\n    assert Process.get(:ecto_counter) == 2\n  end\n\n  describe \"changeset constraints\" do\n    test \"are mapped to repo constraint violations\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [unique: \"custom_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo, name: \"custom_foo_index\")\n      assert {:error, changeset} = TestRepo.insert(changeset)\n      refute changeset.valid?\n    end\n\n    test \"are mapped to repo constraint violation using suffix match\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [unique: \"foo_table_custom_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo, name: \"custom_foo_index\", match: :suffix)\n      assert {:error, changeset} = TestRepo.insert(changeset)\n      refute changeset.valid?\n    end\n\n    test \"are mapped to repo constraint violation using prefix match\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [unique: \"foo_table_custom_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo, name: \"foo_table_custom_foo\", match: :prefix)\n      assert {:error, changeset} = TestRepo.insert(changeset)\n      refute changeset.valid?\n    end\n\n    test \"may fail to map to repo constraint violation on name\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [unique: \"foo_table_custom_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo, name: \"custom_foo_index\")\n      assert_raise Ecto.ConstraintError, fn ->\n        TestRepo.insert(changeset)\n      end\n    end\n\n    test \"may fail to map to repo constraint violation on index type\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [invalid_constraint_type: \"my_schema_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo)\n      assert_raise Ecto.ConstraintError, fn ->\n        TestRepo.insert(changeset)\n      end\n    end\n  end\n\n  describe \"on conflict\" do\n    test \"raises on unknown on_conflict value\" do\n      assert_raise ArgumentError, \"unknown value for :on_conflict, got: :who_knows\", fn ->\n        TestRepo.insert(%MySchema{id: 1}, on_conflict: :who_knows)\n      end\n    end\n\n    test \"raises on non-empty conflict_target with on_conflict raise\" do\n      assert_raise ArgumentError, \":conflict_target option is forbidden when :on_conflict is :raise\", fn ->\n        TestRepo.insert(%MySchema{id: 1}, on_conflict: :raise, conflict_target: [:id])\n      end\n    end\n\n    test \"raises on query mismatch\" do\n      assert_raise ArgumentError, ~r\"cannot run on_conflict: query\", fn ->\n        query = from p in \"posts\"\n        TestRepo.insert(%MySchema{id: 1}, on_conflict: query)\n      end\n    end\n  end\n\n  describe \"preload\" do\n    test \"if first argument of preload is nil, it should return nil\" do\n      assert TestRepo.preload(nil, []) == nil\n    end\n  end\n\n  describe \"insert_all\" do\n    test \"raises when on associations\" do\n      assert_raise ArgumentError, fn ->\n        TestRepo.insert_all MySchema, [%{another: nil}]\n      end\n    end\n  end\n\n  test \"load/2\" do\n    # string fields\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, %{\"x\" => \"abc\"})\n\n    # atom fields\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, %{x: \"abc\"})\n\n    # keyword list\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, [x: \"abc\"])\n\n    # atom fields and values\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, {[:x], [\"abc\"]})\n\n    # string fields and values\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, {[\"x\"], [\"abc\"]})\n\n    # default value\n    assert %MySchema{x: \"abc\", z: \"z\"} =\n           TestRepo.load(MySchema, %{x: \"abc\"})\n\n    # source field\n    assert %MySchema{y: \"abc\"} =\n           TestRepo.load(MySchema, %{yyy: \"abc\"})\n\n    # array field\n    assert %MySchema{array: [\"one\", \"two\"]} =\n           TestRepo.load(MySchema, %{array: [\"one\", \"two\"]})\n\n    # map field with atoms\n    assert %MySchema{map: %{color: \"red\"}} =\n           TestRepo.load(MySchema, %{map: %{color: \"red\"}})\n\n    # map field with strings\n    assert %MySchema{map: %{\"color\" => \"red\"}} =\n           TestRepo.load(MySchema, %{map: %{\"color\" => \"red\"}})\n\n    # nil\n    assert %MySchema{x: nil} =\n           TestRepo.load(MySchema, %{x: nil})\n\n    # invalid field is ignored\n    assert %MySchema{} =\n           TestRepo.load(MySchema, %{bad: \"bad\"})\n\n    # invalid value\n    assert_raise ArgumentError, \"cannot load `0` as type :string for field `x` in schema Ecto.RepoTest.MySchema\", fn ->\n      TestRepo.load(MySchema, %{x: 0})\n    end\n\n    # schemaless\n    assert TestRepo.load(%{x: :string}, %{x: \"abc\", bad: \"bad\"}) ==\n           %{x: \"abc\"}\n  end\n\n  defmodule NoTransactionAdapter do\n    defmacro __before_compile__(_opts), do: :ok\n  end\n\n  defmodule NoTransactionRepo do\n    use Ecto.Repo, otp_app: :ecto, adapter: NoTransactionAdapter\n  end\n\n  test \"no transaction functions generated on repo, without adapter support\" do\n    refute function_exported?(NoTransactionRepo, :transaction, 2)\n    refute function_exported?(NoTransactionRepo, :in_transaction?, 2)\n    refute function_exported?(NoTransactionRepo, :rollback, 1)\n  end\nend\n"], "fixing_code": ["Code.require_file \"../support/types.exs\", __DIR__\n\ndefmodule Ecto.Integration.RepoTest do\n  use Ecto.Integration.Case, async: Application.get_env(:ecto, :async_integration_tests, true)\n\n  alias Ecto.Integration.TestRepo\n  import Ecto.Query\n\n  alias Ecto.Integration.Post\n  alias Ecto.Integration.User\n  alias Ecto.Integration.Comment\n  alias Ecto.Integration.Permalink\n  alias Ecto.Integration.Custom\n  alias Ecto.Integration.Barebone\n  alias Ecto.Integration.CompositePk\n  alias Ecto.Integration.PostUsecTimestamps\n  alias Ecto.Integration.PostUserCompositePk\n\n  test \"returns already started for started repos\" do\n    assert {:error, {:already_started, _}} = TestRepo.start_link\n  end\n\n  test \"fetch empty\" do\n    assert TestRepo.all(Post) == []\n    assert TestRepo.all(from p in Post) == []\n  end\n\n  test \"fetch with in\" do\n    TestRepo.insert!(%Post{title: \"hello\"})\n\n    # Works without the query cache.\n    assert_raise Ecto.Query.CastError, fn ->\n      TestRepo.all(from p in Post, where: p.title in ^nil)\n    end\n\n    assert [] = TestRepo.all from p in Post, where: p.title in []\n    assert [] = TestRepo.all from p in Post, where: p.title in [\"1\", \"2\", \"3\"]\n    assert [] = TestRepo.all from p in Post, where: p.title in ^[]\n\n    assert [_] = TestRepo.all from p in Post, where: not p.title in []\n    assert [_] = TestRepo.all from p in Post, where: p.title in [\"1\", \"hello\", \"3\"]\n    assert [_] = TestRepo.all from p in Post, where: p.title in [\"1\", ^\"hello\", \"3\"]\n    assert [_] = TestRepo.all from p in Post, where: p.title in ^[\"1\", \"hello\", \"3\"]\n\n    # Still doesn't work after the query cache.\n    assert_raise Ecto.Query.CastError, fn ->\n      TestRepo.all(from p in Post, where: p.title in ^nil)\n    end\n  end\n\n  test \"fetch without schema\" do\n    %Post{} = TestRepo.insert!(%Post{title: \"title1\"})\n    %Post{} = TestRepo.insert!(%Post{title: \"title2\"})\n\n    assert [\"title1\", \"title2\"] =\n      TestRepo.all(from(p in \"posts\", order_by: p.title, select: p.title))\n\n    assert [_] =\n      TestRepo.all(from(p in \"posts\", where: p.title == \"title1\", select: p.id))\n  end\n\n  @tag :invalid_prefix\n  test \"fetch with invalid prefix\" do\n    assert catch_error(TestRepo.all(\"posts\", prefix: \"oops\"))\n  end\n\n  test \"insert, update and delete\" do\n    post = %Post{title: \"insert, update, delete\", text: \"fetch empty\"}\n    meta = post.__meta__\n\n    assert %Post{} = inserted = TestRepo.insert!(post)\n    assert %Post{} = updated = TestRepo.update!(Ecto.Changeset.change(inserted, text: \"new\"))\n\n    deleted_meta = put_in meta.state, :deleted\n    assert %Post{__meta__: ^deleted_meta} = TestRepo.delete!(updated)\n\n    loaded_meta = put_in meta.state, :loaded\n    assert %Post{__meta__: ^loaded_meta} = TestRepo.insert!(post)\n\n    post = TestRepo.one(Post)\n    assert post.__meta__.state == :loaded\n    assert post.inserted_at\n  end\n\n  test \"insert, update and delete with field source\" do\n    permalink = %Permalink{url: \"url\"}\n    assert %Permalink{url: \"url\"} = inserted =\n           TestRepo.insert!(permalink)\n    assert %Permalink{url: \"new\"} = updated =\n           TestRepo.update!(Ecto.Changeset.change(inserted, url: \"new\"))\n    assert %Permalink{url: \"new\"} =\n           TestRepo.delete!(updated)\n  end\n\n  @tag :composite_pk\n  test \"insert, update and delete with composite pk\" do\n    c1 = TestRepo.insert!(%CompositePk{a: 1, b: 2, name: \"first\"})\n    c2 = TestRepo.insert!(%CompositePk{a: 1, b: 3, name: \"second\"})\n\n    assert CompositePk |> first |> TestRepo.one == c1\n    assert CompositePk |> last |> TestRepo.one == c2\n\n    changeset = Ecto.Changeset.cast(c1, %{name: \"first change\"}, ~w(name))\n    c1 = TestRepo.update!(changeset)\n    assert TestRepo.get_by!(CompositePk, %{a: 1, b: 2}) == c1\n\n    TestRepo.delete!(c2)\n    assert TestRepo.all(CompositePk) == [c1]\n\n    assert_raise ArgumentError, ~r\"to have exactly one primary key\", fn ->\n      TestRepo.get(CompositePk, [])\n    end\n\n    assert_raise ArgumentError, ~r\"to have exactly one primary key\", fn ->\n      TestRepo.get!(CompositePk, [1, 2])\n    end\n  end\n\n  @tag :composite_pk\n  test \"insert, update and delete with associated composite pk\" do\n    user = TestRepo.insert!(%User{})\n    post = TestRepo.insert!(%Post{title: \"post title\", text: \"post text\"})\n\n    user_post = TestRepo.insert!(%PostUserCompositePk{user_id: user.id, post_id: post.id})\n    assert TestRepo.get_by!(PostUserCompositePk, [user_id: user.id, post_id: post.id]) == user_post\n    TestRepo.delete!(user_post)\n    assert TestRepo.all(PostUserCompositePk) == []\n  end\n\n  @tag :invalid_prefix\n  test \"insert, update and delete with invalid prefix\" do\n    post = TestRepo.insert!(%Post{})\n    changeset = Ecto.Changeset.change(post, title: \"foo\")\n    assert catch_error(TestRepo.insert(%Post{}, prefix: \"oops\"))\n    assert catch_error(TestRepo.update(changeset, prefix: \"oops\"))\n    assert catch_error(TestRepo.delete(changeset, prefix: \"oops\"))\n  end\n\n  test \"insert and update with changeset\" do\n    # On insert we merge the fields and changes\n    changeset = Ecto.Changeset.cast(%Post{text: \"x\", title: \"wrong\"},\n                                    %{\"title\" => \"hello\", \"temp\" => \"unknown\"}, ~w(title temp))\n\n    post = TestRepo.insert!(changeset)\n    assert %Post{text: \"x\", title: \"hello\", temp: \"unknown\"} = post\n    assert %Post{text: \"x\", title: \"hello\", temp: \"temp\"} = TestRepo.get!(Post, post.id)\n\n    # On update we merge only fields, direct schema changes are discarded\n    changeset = Ecto.Changeset.cast(%{post | text: \"y\"},\n                                    %{\"title\" => \"world\", \"temp\" => \"unknown\"}, ~w(title temp))\n\n    assert %Post{text: \"y\", title: \"world\", temp: \"unknown\"} = TestRepo.update!(changeset)\n    assert %Post{text: \"x\", title: \"world\", temp: \"temp\"} = TestRepo.get!(Post, post.id)\n  end\n\n  test \"insert and update with empty changeset\" do\n    # On insert we merge the fields and changes\n    changeset = Ecto.Changeset.cast(%Permalink{}, %{}, ~w())\n    assert %Permalink{} = permalink = TestRepo.insert!(changeset)\n\n    # Assert we can update the same value twice,\n    # without changes, without triggering stale errors.\n    changeset = Ecto.Changeset.cast(permalink, %{}, ~w())\n    assert TestRepo.update!(changeset) == permalink\n    assert TestRepo.update!(changeset) == permalink\n  end\n\n  @tag :no_primary_key\n  test \"insert with no primary key\" do\n    assert %Barebone{num: nil} = TestRepo.insert!(%Barebone{})\n    assert %Barebone{num: 13} = TestRepo.insert!(%Barebone{num: 13})\n  end\n\n  @tag :read_after_writes\n  test \"insert and update with changeset read after writes\" do\n    defmodule RAW do\n      use Ecto.Schema\n\n      schema \"comments\" do\n        field :text, :string\n        field :lock_version, :integer, read_after_writes: true\n      end\n    end\n\n    changeset = Ecto.Changeset.cast(struct(RAW, %{}), %{}, ~w())\n\n    # If the field is nil, we will not send it\n    # and read the value back from the database.\n    assert %{id: cid, lock_version: 1} = raw = TestRepo.insert!(changeset)\n\n    # Set the counter to 11, so we can read it soon\n    TestRepo.update_all from(u in RAW, where: u.id == ^cid), set: [lock_version: 11]\n\n    # We will read back on update too\n    changeset = Ecto.Changeset.cast(raw, %{\"text\" => \"0\"}, ~w(text))\n    assert %{id: ^cid, lock_version: 11, text: \"0\"} = TestRepo.update!(changeset)\n  end\n\n  test \"insert autogenerates for custom type\" do\n    post = TestRepo.insert!(%Post{uuid: nil})\n    assert byte_size(post.uuid) == 36\n    assert TestRepo.get_by(Post, uuid: post.uuid) == post\n  end\n\n  @tag :id_type\n  test \"insert autogenerates for custom id type\" do\n    defmodule ID do\n      use Ecto.Schema\n\n      @primary_key {:id, Elixir.Custom.Permalink, autogenerate: true}\n      schema \"posts\" do\n      end\n    end\n\n    id = TestRepo.insert!(struct(ID, id: nil))\n    assert id.id\n    assert TestRepo.get_by(ID, id: \"#{id.id}-hello\") == id\n  end\n\n  @tag :id_type\n  @tag :assigns_id_type\n  test \"insert with user-assigned primary key\" do\n    assert %Post{id: 1} = TestRepo.insert!(%Post{id: 1})\n  end\n\n  @tag :id_type\n  @tag :assigns_id_type\n  test \"insert and update with user-assigned primary key in changeset\" do\n    changeset = Ecto.Changeset.cast(%Post{id: 11}, %{\"id\" => \"13\"}, ~w(id))\n    assert %Post{id: 13} = post = TestRepo.insert!(changeset)\n\n    changeset = Ecto.Changeset.cast(post, %{\"id\" => \"15\"}, ~w(id))\n    assert %Post{id: 15} = TestRepo.update!(changeset)\n  end\n\n  @tag :uses_usec\n  test \"insert and fetch a schema with timestamps with usec\" do\n    p1 = TestRepo.insert!(%PostUsecTimestamps{title: \"hello\"})\n    assert [p1] == TestRepo.all(PostUsecTimestamps)\n  end\n\n  test \"insert and fetch a schema with utc timestamps\" do\n    datetime = System.system_time(:seconds) * 1_000_000 |> DateTime.from_unix!(:microseconds)\n    TestRepo.insert!(%User{inserted_at: datetime})\n    assert [%{inserted_at: ^datetime}] = TestRepo.all(User)\n  end\n\n  test \"optimistic locking in update/delete operations\" do\n    import Ecto.Changeset, only: [cast: 3, optimistic_lock: 2]\n    base_post = TestRepo.insert!(%Comment{})\n\n    cs_ok =\n      base_post\n      |> cast(%{\"text\" => \"foo.bar\"}, ~w(text))\n      |> optimistic_lock(:lock_version)\n    TestRepo.update!(cs_ok)\n\n    cs_stale = optimistic_lock(base_post, :lock_version)\n    assert_raise Ecto.StaleEntryError, fn -> TestRepo.update!(cs_stale) end\n    assert_raise Ecto.StaleEntryError, fn -> TestRepo.delete!(cs_stale) end\n  end\n\n  @tag :unique_constraint\n  test \"unique constraint\" do\n    changeset = Ecto.Changeset.change(%Post{}, uuid: Ecto.UUID.generate())\n    {:ok, _}  = TestRepo.insert(changeset)\n\n    exception =\n      assert_raise Ecto.ConstraintError, ~r/constraint error when attempting to insert struct/, fn ->\n        changeset\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"unique: posts_uuid_index\"\n    assert exception.message =~ \"The changeset has not defined any constraint.\"\n\n    message = ~r/constraint error when attempting to insert struct/\n    exception =\n      assert_raise Ecto.ConstraintError, message, fn ->\n        changeset\n        |> Ecto.Changeset.unique_constraint(:uuid, name: :posts_email_changeset)\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"unique: posts_email_changeset\"\n\n    {:error, changeset} =\n      changeset\n      |> Ecto.Changeset.unique_constraint(:uuid)\n      |> TestRepo.insert()\n    assert changeset.errors == [uuid: {\"has already been taken\", []}]\n    assert changeset.data.__meta__.state == :built\n  end\n\n  @tag :unique_constraint\n  test \"unique constraint from association\" do\n    uuid = Ecto.UUID.generate()\n    post = & %Post{} |> Ecto.Changeset.change(uuid: &1) |> Ecto.Changeset.unique_constraint(:uuid)\n\n    {:error, changeset} =\n      TestRepo.insert %User{\n        comments: [%Comment{}],\n        permalink: %Permalink{},\n        posts: [post.(uuid), post.(uuid), post.(Ecto.UUID.generate)]\n      }\n\n    [_, p2, _] = changeset.changes.posts\n    assert p2.errors == [uuid: {\"has already been taken\", []}]\n  end\n\n  @tag :id_type\n  @tag :unique_constraint\n  test \"unique constraint with binary_id\" do\n    changeset = Ecto.Changeset.change(%Custom{}, uuid: Ecto.UUID.generate())\n    {:ok, _}  = TestRepo.insert(changeset)\n\n    {:error, changeset} =\n      changeset\n      |> Ecto.Changeset.unique_constraint(:uuid)\n      |> TestRepo.insert()\n    assert changeset.errors == [uuid: {\"has already been taken\", []}]\n    assert changeset.data.__meta__.state == :built\n  end\n\n  test \"unique pseudo-constraint violation error message with join table at the repository\" do\n    post =\n      TestRepo.insert!(%Post{title: \"some post\"})\n      |> TestRepo.preload(:unique_users)\n\n    user =\n      TestRepo.insert!(%User{name: \"some user\"})\n\n    # Violate the unique composite index\n    {:error, changeset} =\n      post\n      |> Ecto.Changeset.change\n      |> Ecto.Changeset.put_assoc(:unique_users, [user, user])\n      |> TestRepo.update\n\n    errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)\n    assert errors == %{unique_users: [%{}, %{id: [\"has already been taken\"]}]}\n    refute changeset.valid?\n  end\n\n  @tag :join\n  @tag :unique_constraint\n  test \"unique constraint violation error message with join table in single changeset\" do\n    post =\n      TestRepo.insert!(%Post{title: \"some post\"})\n      |> TestRepo.preload(:constraint_users)\n\n    user =\n      TestRepo.insert!(%User{name: \"some user\"})\n\n    # Violate the unique composite index\n    {:error, changeset} =\n      post\n      |> Ecto.Changeset.change\n      |> Ecto.Changeset.put_assoc(:constraint_users, [user, user])\n      |> Ecto.Changeset.unique_constraint(:user,\n          name: :posts_users_composite_pk_post_id_user_id_index,\n          message: \"has already been assigned\")\n      |> TestRepo.update\n\n    errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)\n    assert errors == %{constraint_users: [%{}, %{user: [\"has already been assigned\"]}]}\n\n    refute changeset.valid?\n  end\n\n  @tag :join\n  @tag :unique_constraint\n  test \"unique constraint violation error message with join table and separate changesets\" do\n    post =\n      TestRepo.insert!(%Post{title: \"some post\"})\n      |> TestRepo.preload(:constraint_users)\n\n    user = TestRepo.insert!(%User{name: \"some user\"})\n\n    post\n    |> Ecto.Changeset.change\n    |> Ecto.Changeset.put_assoc(:constraint_users, [user])\n    |> TestRepo.update\n\n    # Violate the unique composite index\n    {:error, changeset} =\n      post\n      |> Ecto.Changeset.change\n      |> Ecto.Changeset.put_assoc(:constraint_users, [user])\n      |> Ecto.Changeset.unique_constraint(:user,\n          name: :posts_users_composite_pk_post_id_user_id_index,\n          message: \"has already been assigned\")\n      |> TestRepo.update\n\n    errors = Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)\n    assert errors == %{constraint_users: [%{user: [\"has already been assigned\"]}]}\n\n    refute changeset.valid?\n  end\n\n  @tag :foreign_key_constraint\n  test \"foreign key constraint\" do\n    changeset = Ecto.Changeset.change(%Comment{post_id: 0})\n\n    exception =\n      assert_raise Ecto.ConstraintError, ~r/constraint error when attempting to insert struct/, fn ->\n        changeset\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"foreign_key: comments_post_id_fkey\"\n    assert exception.message =~ \"The changeset has not defined any constraint.\"\n\n    message = ~r/constraint error when attempting to insert struct/\n    exception =\n      assert_raise Ecto.ConstraintError, message, fn ->\n        changeset\n        |> Ecto.Changeset.foreign_key_constraint(:post_id, name: :comments_post_id_other)\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"foreign_key: comments_post_id_other\"\n\n    {:error, changeset} =\n      changeset\n      |> Ecto.Changeset.foreign_key_constraint(:post_id)\n      |> TestRepo.insert()\n    assert changeset.errors == [post_id: {\"does not exist\", []}]\n  end\n\n  @tag :foreign_key_constraint\n  test \"assoc constraint\" do\n    changeset = Ecto.Changeset.change(%Comment{post_id: 0})\n\n    exception =\n      assert_raise Ecto.ConstraintError, ~r/constraint error when attempting to insert struct/, fn ->\n        changeset\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"foreign_key: comments_post_id_fkey\"\n    assert exception.message =~ \"The changeset has not defined any constraint.\"\n\n    message = ~r/constraint error when attempting to insert struct/\n    exception =\n      assert_raise Ecto.ConstraintError, message, fn ->\n        changeset\n        |> Ecto.Changeset.assoc_constraint(:post, name: :comments_post_id_other)\n        |> TestRepo.insert()\n      end\n\n    assert exception.message =~ \"foreign_key: comments_post_id_other\"\n\n    {:error, changeset} =\n      changeset\n      |> Ecto.Changeset.assoc_constraint(:post)\n      |> TestRepo.insert()\n    assert changeset.errors == [post: {\"does not exist\", []}]\n  end\n\n  @tag :foreign_key_constraint\n  test \"no assoc constraint error\" do\n    user = TestRepo.insert!(%User{})\n    TestRepo.insert!(%Permalink{user_id: user.id})\n\n    exception =\n      assert_raise Ecto.ConstraintError, ~r/constraint error when attempting to delete struct/, fn ->\n        TestRepo.delete!(user)\n      end\n\n    assert exception.message =~ \"foreign_key: permalinks_user_id_fkey\"\n    assert exception.message =~ \"The changeset has not defined any constraint.\"\n  end\n\n  @tag :foreign_key_constraint\n  test \"no assoc constraint with changeset mismatch\" do\n    user = TestRepo.insert!(%User{})\n    TestRepo.insert!(%Permalink{user_id: user.id})\n\n    message = ~r/constraint error when attempting to delete struct/\n    exception =\n      assert_raise Ecto.ConstraintError, message, fn ->\n        user\n        |> Ecto.Changeset.change\n        |> Ecto.Changeset.no_assoc_constraint(:permalink, name: :permalinks_user_id_pther)\n        |> TestRepo.delete()\n      end\n\n    assert exception.message =~ \"foreign_key: permalinks_user_id_pther\"\n  end\n\n  @tag :foreign_key_constraint\n  test \"no assoc constraint with changeset match\" do\n    user = TestRepo.insert!(%User{})\n    TestRepo.insert!(%Permalink{user_id: user.id})\n\n    {:error, changeset} =\n      user\n      |> Ecto.Changeset.change\n      |> Ecto.Changeset.no_assoc_constraint(:permalink)\n      |> TestRepo.delete()\n    assert changeset.errors == [permalink: {\"is still associated with this entry\", []}]\n  end\n\n  test \"insert and update with failing child foreign key\" do\n    defmodule Order do\n      use Ecto.Integration.Schema\n      import Ecto.Changeset\n\n      schema \"orders\" do\n        embeds_one :item, Ecto.Integration.Item\n        belongs_to :comment, Ecto.Integration.Comment\n      end\n\n      def changeset(order, params) do\n        order\n        |> cast(params, [:comment_id])\n        |> cast_embed(:item, with: &item_changeset/2)\n        |> cast_assoc(:comment, with: &comment_changeset/2)\n      end\n\n      def item_changeset(item, params) do\n        item\n        |> cast(params, [:price])\n      end\n\n      def comment_changeset(comment, params) do\n        comment\n        |> cast(params, [:post_id, :text])\n        |> cast_assoc(:post)\n        |> assoc_constraint(:post)\n      end\n    end\n\n    changeset = Order.changeset(struct(Order, %{}), %{item: %{price: 10}, comment: %{text: \"1\", post_id: 0}})\n\n    assert %Ecto.Changeset{} = changeset.changes.item\n\n    {:error, changeset} = TestRepo.insert(changeset)\n    assert %Ecto.Changeset{} = changeset.changes.item\n\n    order = TestRepo.insert!(Order.changeset(struct(Order, %{}), %{}))\n    |> TestRepo.preload([:comment])\n\n    changeset = Order.changeset(order, %{item: %{price: 10}, comment: %{text: \"1\", post_id: 0}})\n\n    assert %Ecto.Changeset{} = changeset.changes.item\n\n    {:error, changeset} = TestRepo.update(changeset)\n    assert %Ecto.Changeset{} = changeset.changes.item\n  end\n\n  test \"unsafe_validate_unique/3\" do\n    {:ok, inserted_post} = TestRepo.insert(%Post{title: \"Greetings\", text: \"hi\"})\n    new_post_changeset = Post.changeset(%Post{}, %{title: \"Greetings\", text: \"ho\"})\n\n    changeset = Ecto.Changeset.unsafe_validate_unique(new_post_changeset, [:title], TestRepo)\n    assert changeset.errors[:title] ==\n           {\"has already been taken\", validation: :unsafe_unique, fields: [:title]}\n\n    changeset = Ecto.Changeset.unsafe_validate_unique(new_post_changeset, [:title, :text], TestRepo)\n    assert changeset.errors[:title] == nil\n\n    update_changeset = Post.changeset(inserted_post, %{text: \"ho\"})\n    changeset = Ecto.Changeset.unsafe_validate_unique(update_changeset, [:title], TestRepo)\n    assert changeset.errors[:title] == nil # cannot conflict with itself\n  end\n\n  test \"get(!)\" do\n    post1 = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    post2 = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n\n    assert post1 == TestRepo.get(Post, post1.id)\n    assert post2 == TestRepo.get(Post, to_string post2.id) # With casting\n\n    assert post1 == TestRepo.get!(Post, post1.id)\n    assert post2 == TestRepo.get!(Post, to_string post2.id) # With casting\n\n    TestRepo.delete!(post1)\n\n    assert nil   == TestRepo.get(Post, post1.id)\n    assert_raise Ecto.NoResultsError, fn ->\n      TestRepo.get!(Post, post1.id)\n    end\n  end\n\n  test \"get(!) with custom source\" do\n    custom = Ecto.put_meta(%Custom{}, source: \"posts\")\n    custom = TestRepo.insert!(custom)\n    bid    = custom.bid\n    assert %Custom{bid: ^bid, __meta__: %{source: {nil, \"posts\"}}} =\n           TestRepo.get(from(c in {\"posts\", Custom}), bid)\n  end\n\n  test \"get(!) with binary_id\" do\n    custom = TestRepo.insert!(%Custom{})\n    bid = custom.bid\n    assert %Custom{bid: ^bid} = TestRepo.get(Custom, bid)\n  end\n\n  test \"get_by(!)\" do\n    post1 = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    post2 = TestRepo.insert!(%Post{title: \"2\", text: \"hello\"})\n\n    assert post1 == TestRepo.get_by(Post, id: post1.id)\n    assert post1 == TestRepo.get_by(Post, text: post1.text)\n    assert post1 == TestRepo.get_by(Post, id: post1.id, text: post1.text)\n    assert post2 == TestRepo.get_by(Post, id: to_string(post2.id)) # With casting\n    assert nil   == TestRepo.get_by(Post, text: \"hey\")\n    assert nil   == TestRepo.get_by(Post, id: post2.id, text: \"hey\")\n\n    assert post1 == TestRepo.get_by!(Post, id: post1.id)\n    assert post1 == TestRepo.get_by!(Post, text: post1.text)\n    assert post1 == TestRepo.get_by!(Post, id: post1.id, text: post1.text)\n    assert post2 == TestRepo.get_by!(Post, id: to_string(post2.id)) # With casting\n\n    assert post1 == TestRepo.get_by!(Post, %{id: post1.id})\n\n    assert_raise Ecto.NoResultsError, fn ->\n      TestRepo.get_by!(Post, id: post2.id, text: \"hey\")\n    end\n  end\n\n  test \"first, last and one(!)\" do\n    post1 = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    post2 = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n\n    assert post1 == Post |> first |> TestRepo.one\n    assert post2 == Post |> last |> TestRepo.one\n\n    query = from p in Post, order_by: p.title\n    assert post1 == query |> first |> TestRepo.one\n    assert post2 == query |> last |> TestRepo.one\n\n    query = from p in Post, order_by: [desc: p.title], limit: 10\n    assert post2 == query |> first |> TestRepo.one\n    assert post1 == query |> last |> TestRepo.one\n\n    query = from p in Post, where: is_nil(p.id)\n    refute query |> first |> TestRepo.one\n    refute query |> first |> TestRepo.one\n    assert_raise Ecto.NoResultsError, fn -> query |> first |> TestRepo.one! end\n    assert_raise Ecto.NoResultsError, fn -> query |> last |> TestRepo.one! end\n  end\n\n  test \"aggregate\" do\n    assert TestRepo.aggregate(Post, :max, :visits) == nil\n\n    TestRepo.insert!(%Post{visits: 10})\n    TestRepo.insert!(%Post{visits: 12})\n    TestRepo.insert!(%Post{visits: 14})\n    TestRepo.insert!(%Post{visits: 14})\n\n    # Barebones\n    assert TestRepo.aggregate(Post, :max, :visits) == 14\n    assert TestRepo.aggregate(Post, :min, :visits) == 10\n    assert TestRepo.aggregate(Post, :count, :visits) == 4\n    assert \"50\" = to_string(TestRepo.aggregate(Post, :sum, :visits))\n    assert \"12.5\" <> _ = to_string(TestRepo.aggregate(Post, :avg, :visits))\n\n    # With order_by\n    query = from Post, order_by: [asc: :visits]\n    assert TestRepo.aggregate(query, :max, :visits) == 14\n\n    # With order_by and limit\n    query = from Post, order_by: [asc: :visits], limit: 2\n    assert TestRepo.aggregate(query, :max, :visits) == 12\n\n    # With distinct\n    query = from Post, order_by: [asc: :visits], distinct: true\n    assert TestRepo.aggregate(query, :count, :visits) == 3\n  end\n\n  test \"insert all\" do\n    assert {2, nil} = TestRepo.insert_all(\"comments\", [[text: \"1\"], %{text: \"2\", lock_version: 2}])\n    assert {2, nil} = TestRepo.insert_all({\"comments\", Comment}, [[text: \"3\"], %{text: \"4\", lock_version: 2}])\n    assert [%Comment{text: \"1\", lock_version: 1},\n            %Comment{text: \"2\", lock_version: 2},\n            %Comment{text: \"3\", lock_version: 1},\n            %Comment{text: \"4\", lock_version: 2}] = TestRepo.all(Comment)\n\n    assert {2, nil} = TestRepo.insert_all(Post, [[], []])\n    assert [%Post{}, %Post{}] = TestRepo.all(Post)\n\n    assert {0, nil} = TestRepo.insert_all(\"posts\", [])\n    assert {0, nil} = TestRepo.insert_all({\"posts\", Post}, [])\n  end\n\n  @tag :invalid_prefix\n  test \"insert all with invalid prefix\" do\n    assert catch_error(TestRepo.insert_all(Post, [[], []], prefix: \"oops\"))\n  end\n\n  @tag :returning\n  test \"insert all with returning with schema\" do\n    assert {0, []} = TestRepo.insert_all(Comment, [], returning: true)\n    assert {0, nil} = TestRepo.insert_all(Comment, [], returning: false)\n\n    {2, [c1, c2]} = TestRepo.insert_all(Comment, [[text: \"1\"], [text: \"2\"]], returning: [:id, :text])\n    assert %Comment{text: \"1\", __meta__: %{state: :loaded}} = c1\n    assert %Comment{text: \"2\", __meta__: %{state: :loaded}} = c2\n\n    {2, [c1, c2]} = TestRepo.insert_all(Comment, [[text: \"3\"], [text: \"4\"]], returning: true)\n    assert %Comment{text: \"3\", __meta__: %{state: :loaded}} = c1\n    assert %Comment{text: \"4\", __meta__: %{state: :loaded}} = c2\n  end\n\n  @tag :returning\n  test \"insert all with returning with schema with field source\" do\n    assert {0, []} = TestRepo.insert_all(Permalink, [], returning: true)\n    assert {0, nil} = TestRepo.insert_all(Permalink, [], returning: false)\n\n    {2, [c1, c2]} = TestRepo.insert_all(Permalink, [[url: \"1\"], [url: \"2\"]], returning: [:id, :url])\n    assert %Permalink{url: \"1\", __meta__: %{state: :loaded}} = c1\n    assert %Permalink{url: \"2\", __meta__: %{state: :loaded}} = c2\n\n    {2, [c1, c2]} = TestRepo.insert_all(Permalink, [[url: \"3\"], [url: \"4\"]], returning: true)\n    assert %Permalink{url: \"3\", __meta__: %{state: :loaded}} = c1\n    assert %Permalink{url: \"4\", __meta__: %{state: :loaded}} = c2\n  end\n\n  @tag :returning\n  test \"insert all with returning without schema\" do\n    {2, [c1, c2]} = TestRepo.insert_all(\"comments\", [[text: \"1\"], [text: \"2\"]], returning: [:id, :text])\n    assert %{id: _, text: \"1\"} = c1\n    assert %{id: _, text: \"2\"} = c2\n\n    assert_raise ArgumentError, fn ->\n      TestRepo.insert_all(\"comments\", [[text: \"1\"], [text: \"2\"]], returning: true)\n    end\n  end\n\n  test \"insert all with dumping\" do\n    datetime = ~N[2014-01-16 20:26:51.000000]\n    assert {2, nil} = TestRepo.insert_all(Post, [%{inserted_at: datetime}, %{title: \"date\"}])\n    assert [%Post{inserted_at: ^datetime, title: nil},\n            %Post{inserted_at: nil, title: \"date\"}] = TestRepo.all(Post)\n  end\n\n  test \"insert all autogenerates for binary_id type\" do\n    custom = TestRepo.insert!(%Custom{bid: nil})\n    assert custom.bid\n    assert TestRepo.get(Custom, custom.bid)\n    assert TestRepo.delete!(custom)\n    refute TestRepo.get(Custom, custom.bid)\n\n    uuid = Ecto.UUID.generate\n    assert {2, nil} = TestRepo.insert_all(Custom, [%{uuid: uuid}, %{bid: custom.bid}])\n    assert [%Custom{bid: bid2, uuid: nil},\n            %Custom{bid: bid1, uuid: ^uuid}] = Enum.sort_by(TestRepo.all(Custom), & &1.uuid)\n    assert bid1 && bid2\n    assert custom.bid != bid1\n    assert custom.bid == bid2\n  end\n\n  test \"update all\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    assert {3, nil} = TestRepo.update_all(Post, set: [title: \"x\"])\n\n    assert %Post{title: \"x\"} = TestRepo.get(Post, id1)\n    assert %Post{title: \"x\"} = TestRepo.get(Post, id2)\n    assert %Post{title: \"x\"} = TestRepo.get(Post, id3)\n\n    assert {3, nil} = TestRepo.update_all(\"posts\", [set: [title: nil]], returning: false)\n\n    assert %Post{title: nil} = TestRepo.get(Post, id1)\n    assert %Post{title: nil} = TestRepo.get(Post, id2)\n    assert %Post{title: nil} = TestRepo.get(Post, id3)\n  end\n\n  @tag :invalid_prefix\n  test \"update all with invalid prefix\" do\n    assert catch_error(TestRepo.update_all(Post, [set: [title: \"x\"]], prefix: \"oops\"))\n  end\n\n  @tag :returning\n  test \"update all with returning with schema\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    assert {3, posts} = TestRepo.update_all(Post, [set: [title: \"x\"]], returning: true)\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert %Post{id: ^id1, title: \"x\"} = p1\n    assert %Post{id: ^id2, title: \"x\"} = p2\n    assert %Post{id: ^id3, title: \"x\"} = p3\n\n    assert {3, posts} = TestRepo.update_all(Post, [set: [visits: 11]], returning: [:id, :visits])\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert %Post{id: ^id1, title: nil, visits: 11} = p1\n    assert %Post{id: ^id2, title: nil, visits: 11} = p2\n    assert %Post{id: ^id3, title: nil, visits: 11} = p3\n  end\n\n  @tag :returning\n  test \"update all with returning without schema\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    assert {3, posts} = TestRepo.update_all(\"posts\", [set: [title: \"x\"]], returning: [:id, :title])\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert p1 == %{id: id1, title: \"x\"}\n    assert p2 == %{id: id2, title: \"x\"}\n    assert p3 == %{id: id3, title: \"x\"}\n  end\n\n  test \"update all with filter\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    query = from(p in Post, where: p.title == \"1\" or p.title == \"2\",\n                            update: [set: [text: ^\"y\"]])\n    assert {2, nil} = TestRepo.update_all(query, set: [title: \"x\"])\n\n    assert %Post{title: \"x\", text: \"y\"} = TestRepo.get(Post, id1)\n    assert %Post{title: \"x\", text: \"y\"} = TestRepo.get(Post, id2)\n    assert %Post{title: \"3\", text: nil} = TestRepo.get(Post, id3)\n  end\n\n  test \"update all no entries\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\"})\n\n    query = from(p in Post, where: p.title == \"4\")\n    assert {0, nil} = TestRepo.update_all(query, set: [title: \"x\"])\n\n    assert %Post{title: \"1\"} = TestRepo.get(Post, id1)\n    assert %Post{title: \"2\"} = TestRepo.get(Post, id2)\n    assert %Post{title: \"3\"} = TestRepo.get(Post, id3)\n  end\n\n  test \"update all increment syntax\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\", visits: 0})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\", visits: 1})\n\n    # Positive\n    query = from p in Post, where: not is_nil(p.id), update: [inc: [visits: 2]]\n    assert {2, nil} = TestRepo.update_all(query, [])\n\n    assert %Post{visits: 2} = TestRepo.get(Post, id1)\n    assert %Post{visits: 3} = TestRepo.get(Post, id2)\n\n    # Negative\n    query = from p in Post, where: not is_nil(p.id), update: [inc: [visits: -1]]\n    assert {2, nil} = TestRepo.update_all(query, [])\n\n    assert %Post{visits: 1} = TestRepo.get(Post, id1)\n    assert %Post{visits: 2} = TestRepo.get(Post, id2)\n  end\n\n  @tag :id_type\n  test \"update all with casting and dumping on id type field\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{})\n    assert {1, nil} = TestRepo.update_all(Post, set: [counter: to_string(id1)])\n    assert %Post{counter: ^id1} = TestRepo.get(Post, id1)\n  end\n\n  test \"update all with casting and dumping\" do\n    text = \"hai\"\n    datetime = ~N[2014-01-16 20:26:51.000000]\n    assert %Post{id: id} = TestRepo.insert!(%Post{})\n\n    assert {1, nil} = TestRepo.update_all(Post, set: [text: text, inserted_at: datetime])\n    assert %Post{text: \"hai\", inserted_at: ^datetime} = TestRepo.get(Post, id)\n  end\n\n  test \"delete all\" do\n    assert %Post{} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    assert {3, nil} = TestRepo.delete_all(Post, returning: false)\n    assert [] = TestRepo.all(Post)\n  end\n\n  @tag :invalid_prefix\n  test \"delete all with invalid prefix\" do\n    assert catch_error(TestRepo.delete_all(Post, prefix: \"oops\"))\n  end\n\n  @tag :returning\n  test \"delete all with returning with schema\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    assert {3, posts} = TestRepo.delete_all(Post, returning: true)\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert %Post{id: ^id1, title: \"1\"} = p1\n    assert %Post{id: ^id2, title: \"2\"} = p2\n    assert %Post{id: ^id3, title: \"3\"} = p3\n  end\n\n  @tag :returning\n  test \"delete all with returning without schema\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    assert {3, posts} = TestRepo.delete_all(\"posts\", returning: [:id, :title])\n\n    [p1, p2, p3] = Enum.sort_by(posts, & &1.id)\n    assert p1 == %{id: id1, title: \"1\"}\n    assert p2 == %{id: id2, title: \"2\"}\n    assert p3 == %{id: id3, title: \"3\"}\n  end\n\n  test \"delete all with filter\" do\n    assert %Post{} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    query = from(p in Post, where: p.title == \"1\" or p.title == \"2\")\n    assert {2, nil} = TestRepo.delete_all(query)\n    assert [%Post{}] = TestRepo.all(Post)\n  end\n\n  test \"delete all no entries\" do\n    assert %Post{id: id1} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert %Post{id: id2} = TestRepo.insert!(%Post{title: \"2\", text: \"hai\"})\n    assert %Post{id: id3} = TestRepo.insert!(%Post{title: \"3\", text: \"hai\"})\n\n    query = from(p in Post, where: p.title == \"4\")\n    assert {0, nil} = TestRepo.delete_all(query)\n    assert %Post{title: \"1\"} = TestRepo.get(Post, id1)\n    assert %Post{title: \"2\"} = TestRepo.get(Post, id2)\n    assert %Post{title: \"3\"} = TestRepo.get(Post, id3)\n  end\n\n  test \"virtual field\" do\n    assert %Post{id: id} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n    assert TestRepo.get(Post, id).temp == \"temp\"\n  end\n\n  ## Query syntax\n\n  defmodule Foo do\n    defstruct [:title]\n  end\n\n  describe \"query select\" do\n    test \"expressions\" do\n      %Post{} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n\n      assert [{\"1\", \"hai\"}] ==\n             TestRepo.all(from p in Post, select: {p.title, p.text})\n\n      assert [[\"1\", \"hai\"]] ==\n             TestRepo.all(from p in Post, select: [p.title, p.text])\n\n      assert [%{:title => \"1\", 3 => \"hai\", \"text\" => \"hai\"}] ==\n             TestRepo.all(from p in Post, select: %{\n               :title => p.title,\n               \"text\" => p.text,\n               3 => p.text\n             })\n\n      assert [%{:title => \"1\", \"1\" => \"hai\", \"text\" => \"hai\"}] ==\n             TestRepo.all(from p in Post, select: %{\n               :title  => p.title,\n               p.title => p.text,\n               \"text\"  => p.text\n             })\n\n      assert [%Foo{title: \"1\"}] ==\n             TestRepo.all(from p in Post, select: %Foo{title: p.title})\n    end\n\n    test \"map update\" do\n      %Post{} = TestRepo.insert!(%Post{title: \"1\", text: \"hai\"})\n\n      assert [%Post{:title => \"new title\", text: \"hai\"}] =\n             TestRepo.all(from p in Post, select: %{p | title: \"new title\"})\n\n      assert [%Post{title: \"new title\", text: \"hai\"}] =\n        TestRepo.all(from p in Post, select: %Post{p | title: \"new title\"})\n\n      assert_raise KeyError, fn ->\n        TestRepo.all(from p in Post, select: %{p | unknown: \"new title\"})\n      end\n\n      assert_raise BadMapError, fn ->\n        TestRepo.all(from p in Post, select: %{p.title | title: \"new title\"})\n      end\n\n      assert_raise BadStructError, fn ->\n        TestRepo.all(from p in Post, select: %Foo{p | title: p.title})\n      end\n    end\n\n    test \"take with structs\" do\n      %{id: pid1} = TestRepo.insert!(%Post{title: \"1\"})\n      %{id: pid2} = TestRepo.insert!(%Post{title: \"2\"})\n      %{id: pid3} = TestRepo.insert!(%Post{title: \"3\"})\n\n      [p1, p2, p3] = Post |> select([p], struct(p, [:title])) |> order_by([:title]) |> TestRepo.all\n      refute p1.id\n      assert p1.title == \"1\"\n      assert match?(%Post{}, p1)\n      refute p2.id\n      assert p2.title == \"2\"\n      assert match?(%Post{}, p2)\n      refute p3.id\n      assert p3.title == \"3\"\n      assert match?(%Post{}, p3)\n\n      [p1, p2, p3] = Post |> select([:id]) |> order_by([:id]) |> TestRepo.all\n      assert %Post{id: ^pid1} = p1\n      assert %Post{id: ^pid2} = p2\n      assert %Post{id: ^pid3} = p3\n    end\n\n    test \"take with maps\" do\n      %{id: pid1} = TestRepo.insert!(%Post{title: \"1\"})\n      %{id: pid2} = TestRepo.insert!(%Post{title: \"2\"})\n      %{id: pid3} = TestRepo.insert!(%Post{title: \"3\"})\n\n      [p1, p2, p3] = \"posts\" |> select([p], map(p, [:title])) |> order_by([:title]) |> TestRepo.all\n      assert p1 == %{title: \"1\"}\n      assert p2 == %{title: \"2\"}\n      assert p3 == %{title: \"3\"}\n\n      [p1, p2, p3] = \"posts\" |> select([:id]) |> order_by([:id]) |> TestRepo.all\n      assert p1 == %{id: pid1}\n      assert p2 == %{id: pid2}\n      assert p3 == %{id: pid3}\n    end\n\n    test \"take with assocs\" do\n      %{id: pid} = TestRepo.insert!(%Post{title: \"post\"})\n      TestRepo.insert!(%Comment{post_id: pid, text: \"comment\"})\n      fields = [:id, :title, comments: [:text, :post_id]]\n\n      [p] = Post |> preload(:comments) |> select([p], ^fields) |> TestRepo.all\n      assert %Post{title: \"post\"} = p\n      assert [%Comment{text: \"comment\"}] = p.comments\n\n      [p] = Post |> preload(:comments) |> select([p], struct(p, ^fields)) |> TestRepo.all\n      assert %Post{title: \"post\"} = p\n      assert [%Comment{text: \"comment\"}] = p.comments\n\n      [p] = Post |> preload(:comments) |> select([p], map(p, ^fields)) |> TestRepo.all\n      assert p == %{id: pid, title: \"post\", comments: [%{text: \"comment\", post_id: pid}]}\n    end\n\n    test \"take with single nil column\" do\n      %Post{} = TestRepo.insert!(%Post{title: \"1\", counter: nil})\n      assert %{counter: nil} =\n             TestRepo.one(from p in Post, where: p.title == \"1\", select: [:counter])\n    end\n\n    test \"take with nil assoc\" do\n      %{id: cid} = TestRepo.insert!(%Comment{text: \"comment\"})\n      fields = [:id, :text, post: [:title]]\n\n      [c] = Comment |> preload(:post) |> select([c], ^fields) |> TestRepo.all\n      assert %Comment{id: ^cid, text: \"comment\", post: nil} = c\n\n      [c] = Comment |> preload(:post) |> select([c], struct(c, ^fields)) |> TestRepo.all\n      assert %Comment{id: ^cid, text: \"comment\", post: nil} = c\n\n      [c] = Comment |> preload(:post) |> select([c], map(c, ^fields)) |> TestRepo.all\n      assert c == %{id: cid, text: \"comment\", post: nil}\n    end\n\n    test \"field source\" do\n      TestRepo.insert!(%Permalink{url: \"url\"})\n      assert [\"url\"] = Permalink |> select([p], p.url) |> TestRepo.all()\n      assert [1] = Permalink |> select([p], count(p.url)) |> TestRepo.all()\n    end\n\n    test \"merge\" do\n      %Post{} = TestRepo.insert!(%Post{title: \"1\", counter: nil})\n\n      # Merge on source\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], merge(p, %{title: \"2\"})) |> TestRepo.all()\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], p) |> select_merge([p], %{title: \"2\"}) |> TestRepo.all()\n\n      # Merge on struct\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], merge(%Post{title: p.title}, %Post{title: \"2\"})) |> TestRepo.all()\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], %Post{title: p.title}) |> select_merge([p], %Post{title: \"2\"}) |> TestRepo.all()\n\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], merge(%Post{title: p.title}, %{title: \"2\"})) |> TestRepo.all()\n      assert [%Post{title: \"2\"}] =\n             Post |> select([p], %Post{title: p.title}) |> select_merge([p], %{title: \"2\"}) |> TestRepo.all()\n\n      # Merge on map\n      assert [%{title: \"2\"}] =\n             Post |> select([p], merge(%{title: p.title}, %{title: \"2\"})) |> TestRepo.all()\n      assert [%{title: \"2\"}] =\n             Post |> select([p], %{title: p.title}) |> select_merge([p], %{title: \"2\"}) |> TestRepo.all()\n\n      # Merge errors\n      assert_raise ArgumentError,\n                   ~r/can only merge with a struct on the right side when both sides represent the same struct/, fn ->\n        Post |> select([p], merge(%{title: p.title}, %Post{title: \"2\"})) |> TestRepo.all()\n      end\n\n      assert_raise ArgumentError,\n                   ~r/cannot merge because the left side is not a map/, fn ->\n        Post |> select([p], merge(p.title, %{title: \"2\"})) |> TestRepo.all()\n      end\n\n      assert_raise ArgumentError,\n                   ~r/cannot merge because the right side is not a map/, fn ->\n        Post |> select([p], merge(%{title: \"2\"}, p.title)) |> TestRepo.all()\n      end\n    end\n  end\n\n  test \"query count distinct\" do\n    TestRepo.insert!(%Post{title: \"1\"})\n    TestRepo.insert!(%Post{title: \"1\"})\n    TestRepo.insert!(%Post{title: \"2\"})\n\n    assert [3] == Post |> select([p], count(p.title)) |> TestRepo.all\n    assert [2] == Post |> select([p], count(p.title, :distinct)) |> TestRepo.all\n  end\n\n  test \"query where interpolation\" do\n    post1 = TestRepo.insert!(%Post{text: \"x\", title: \"hello\"})\n    post2 = TestRepo.insert!(%Post{text: \"y\", title: \"goodbye\"})\n\n    assert [post1, post2] == Post |> where([], []) |> TestRepo.all |> Enum.sort_by(& &1.id)\n    assert [post1]        == Post |> where([], [title: \"hello\"]) |> TestRepo.all\n    assert [post1]        == Post |> where([], [title: \"hello\", id: ^post1.id]) |> TestRepo.all\n\n    params0 = []\n    params1 = [title: \"hello\"]\n    params2 = [title: \"hello\", id: post1.id]\n    assert [post1, post2]  == (from Post, where: ^params0) |> TestRepo.all |> Enum.sort_by(& &1.id)\n    assert [post1]         == (from Post, where: ^params1) |> TestRepo.all\n    assert [post1]         == (from Post, where: ^params2) |> TestRepo.all\n\n    post3 = TestRepo.insert!(%Post{text: \"y\", title: \"goodbye\", uuid: nil})\n    params3 = [title: \"goodbye\", uuid: post3.uuid]\n    assert [post3] == (from Post, where: ^params3) |> TestRepo.all\n  end\n\n  ## Logging\n\n  test \"log entry logged on query\" do\n    log = fn entry ->\n      assert %Ecto.LogEntry{result: {:ok, _}} = entry\n      assert is_integer(entry.query_time) and entry.query_time >= 0\n      assert is_integer(entry.decode_time) and entry.query_time >= 0\n      assert is_integer(entry.queue_time) and entry.queue_time >= 0\n      send(self(), :logged)\n    end\n    Process.put(:on_log, log)\n\n    _ = TestRepo.all(Post)\n    assert_received :logged\n  end\n\n  test \"log entry not logged when log is false\" do\n    Process.put(:on_log, fn _ -> flunk(\"logged\") end)\n    TestRepo.insert!(%Post{title: \"1\"}, [log: false])\n  end\n\n  describe \"upsert via insert\" do\n    @describetag :upsert\n\n    test \"on conflict raise\" do\n      {:ok, inserted} = TestRepo.insert(%Post{title: \"first\"}, on_conflict: :raise)\n      assert catch_error(TestRepo.insert(%Post{id: inserted.id, title: \"second\"}, on_conflict: :raise))\n    end\n\n    test \"on conflict ignore\" do\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :nothing)\n      assert inserted.id\n      assert inserted.__meta__.state == :loaded\n\n      {:ok, not_inserted} = TestRepo.insert(post, on_conflict: :nothing)\n      assert not_inserted.id == nil\n      assert not_inserted.__meta__.state == :loaded\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict and associations\" do\n      on_conflict = [set: [title: \"second\"]]\n      post = %Post{uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\",\n                   title: \"first\", comments: [%Comment{}]}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert inserted.id\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict with inc\" do\n      uuid = \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"\n      post = %Post{title: \"first\", uuid: uuid}\n      {:ok, _} = TestRepo.insert(post)\n      post = %{title: \"upsert\", uuid: uuid}\n      TestRepo.insert_all(Post, [post], on_conflict: [inc: [visits: 1]], conflict_target: :uuid)\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict ignore and conflict target\" do\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:uuid])\n      assert inserted.id\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:id]))\n\n      # Error on conflict target\n      {:ok, not_inserted} = TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:uuid])\n      assert not_inserted.id == nil\n    end\n\n    @tag :without_conflict_target\n    test \"on conflict keyword list\" do\n      on_conflict = [set: [title: \"second\"]]\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict)\n      assert inserted.id\n\n      {:ok, updated} = TestRepo.insert(post, on_conflict: on_conflict)\n      assert updated.id == inserted.id\n      assert updated.title != \"second\"\n      assert TestRepo.get!(Post, inserted.id).title == \"second\"\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict keyword list and conflict target\" do\n      on_conflict = [set: [title: \"second\"]]\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert inserted.id\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:id]))\n\n      {:ok, updated} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert updated.id == inserted.id\n      assert updated.title != \"second\"\n      assert TestRepo.get!(Post, inserted.id).title == \"second\"\n    end\n\n    @tag :returning\n    @tag :with_conflict_target\n    test \"on conflict keyword list and conflict target and returning\" do\n      {:ok, c1} = TestRepo.insert(%Post{})\n      {:ok, c2} = TestRepo.insert(%Post{id: c1.id}, on_conflict: [set: [id: c1.id]], conflict_target: [:id], returning: [:id, :uuid])\n      {:ok, c3} = TestRepo.insert(%Post{id: c1.id}, on_conflict: [set: [id: c1.id]], conflict_target: [:id], returning: true)\n      {:ok, c4} = TestRepo.insert(%Post{id: c1.id}, on_conflict: [set: [id: c1.id]], conflict_target: [:id], returning: false)\n\n      assert c2.uuid == c1.uuid\n      assert c3.uuid == c1.uuid\n      assert c4.uuid != c1.uuid\n    end\n\n    @tag :with_conflict_target\n    @tag :with_conflict_target_on_constraint\n    test \"on conflict keyword list and conflict target on constraint\" do\n      on_conflict = [set: [title: \"new\"]]\n      post = %Post{title: \"old\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: {:constraint, :posts_pkey})\n      assert inserted.id\n\n      {:ok, updated} = TestRepo.insert(%{post | id: inserted.id}, on_conflict: on_conflict, conflict_target: {:constraint, :posts_pkey})\n      assert updated.id == inserted.id\n      assert updated.title != \"new\"\n      assert TestRepo.get!(Post, inserted.id).title == \"new\"\n    end\n\n    @tag :returning\n    @tag :with_conflict_target\n    test \"on conflict keyword list and conflict target and returning and field source\" do\n      TestRepo.insert!(%Permalink{url: \"old\"})\n      {:ok, c1} = TestRepo.insert(%Permalink{url: \"old\"},\n                                  on_conflict: [set: [url: \"new1\"]],\n                                  conflict_target: [:url],\n                                  returning: [:url])\n\n      TestRepo.insert!(%Permalink{url: \"old\"})\n      {:ok, c2} = TestRepo.insert(%Permalink{url: \"old\"},\n                                  on_conflict: [set: [url: \"new2\"]],\n                                  conflict_target: [:url],\n                                  returning: true)\n\n      assert c1.url == \"new1\"\n      assert c2.url == \"new2\"\n    end\n\n    @tag :returning\n    @tag :with_conflict_target\n    test \"on conflict ignore and returning\" do\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:uuid])\n      assert inserted.id\n\n      {:ok, not_inserted} = TestRepo.insert(post, on_conflict: :nothing, conflict_target: [:uuid], returning: true)\n      assert not_inserted.id == nil\n    end\n\n    @tag :without_conflict_target\n    test \"on conflict query\" do\n      on_conflict = from Post, update: [set: [title: \"second\"]]\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict)\n      assert inserted.id\n\n      {:ok, updated} = TestRepo.insert(post, on_conflict: on_conflict)\n      assert updated.id == inserted.id\n      assert updated.title != \"second\"\n      assert TestRepo.get!(Post, inserted.id).title == \"second\"\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict query and conflict target\" do\n      on_conflict = from Post, update: [set: [title: \"second\"]]\n      post = %Post{title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert inserted.id\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:id]))\n\n      {:ok, updated} = TestRepo.insert(post, on_conflict: on_conflict, conflict_target: [:uuid])\n      assert updated.id == inserted.id\n      assert updated.title != \"second\"\n      assert TestRepo.get!(Post, inserted.id).title == \"second\"\n    end\n\n    @tag :without_conflict_target\n    test \"on conflict replace_all\" do\n      post = %Post{title: \"first\", text: \"text\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :replace_all)\n      assert inserted.id\n\n      # Error on non-conflict target\n      post = %Post{id: inserted.id, title: \"updated\",\n                   text: \"updated\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n\n      # Error on conflict target\n      post = TestRepo.insert!(post, on_conflict: :replace_all)\n      assert post.title == \"updated\"\n      assert post.text == \"updated\"\n\n      assert TestRepo.all(from p in Post, select: p.title) == [\"updated\"]\n      assert TestRepo.all(from p in Post, select: p.text) == [\"updated\"]\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [1]\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict replace_all and conflict target\" do\n      post = %Post{title: \"first\", text: \"text\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n      {:ok, inserted} = TestRepo.insert(post, on_conflict: :replace_all, conflict_target: :id)\n      assert inserted.id\n\n      # Error on non-conflict target\n      post = %Post{id: inserted.id, title: \"updated\",\n                   text: \"updated\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"}\n\n      # Error on conflict target\n      post = TestRepo.insert!(post, on_conflict: :replace_all, conflict_target: :id)\n      assert post.title == \"updated\"\n      assert post.text == \"updated\"\n\n      assert TestRepo.all(from p in Post, select: p.title) == [\"updated\"]\n      assert TestRepo.all(from p in Post, select: p.text) == [\"updated\"]\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [1]\n    end\n  end\n\n  describe \"upsert via insert_all\" do\n    @describetag :upsert_all\n\n    test \"on conflict raise\" do\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      {1, nil} = TestRepo.insert_all(Post, [post], on_conflict: :raise)\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: :raise))\n    end\n\n    test \"on conflict ignore\" do\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      assert TestRepo.insert_all(Post, [post], on_conflict: :nothing) == {1, nil}\n\n      # PG returns 0, MySQL returns 1\n      {entries, nil} = TestRepo.insert_all(Post, [post], on_conflict: :nothing)\n      assert entries == 0 or entries == 1\n\n      assert length(TestRepo.all(Post)) == 1\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict ignore and conflict target\" do\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      assert TestRepo.insert_all(Post, [post], on_conflict: :nothing, conflict_target: [:uuid]) ==\n             {1, nil}\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: :nothing, conflict_target: [:id]))\n\n      # Error on conflict target\n      assert TestRepo.insert_all(Post, [post], on_conflict: :nothing, conflict_target: [:uuid]) ==\n             {0, nil}\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict keyword list and conflict target\" do\n      on_conflict = [set: [title: \"second\"]]\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      {1, nil} = TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:uuid])\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:id]))\n\n      # Error on conflict target\n      assert TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n      assert TestRepo.all(from p in Post, select: p.title) == [\"second\"]\n    end\n\n    @tag :with_conflict_target\n    @tag :returning\n    test \"on conflict keyword list and conflict target and returning and source field\" do\n      on_conflict = [set: [url: \"new\"]]\n      permalink = [url: \"old\"]\n\n      assert {1, [%Permalink{url: \"old\"}]} =\n             TestRepo.insert_all(Permalink, [permalink],\n                                 on_conflict: on_conflict, conflict_target: [:url], returning: [:url])\n\n      assert {1, [%Permalink{url: \"new\"}]} =\n             TestRepo.insert_all(Permalink, [permalink],\n                                 on_conflict: on_conflict, conflict_target: [:url], returning: [:url])\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict query and conflict target\" do\n      on_conflict = from Post, update: [set: [title: \"second\"]]\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      assert TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:id]))\n\n      # Error on conflict target\n      assert TestRepo.insert_all(Post, [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n      assert TestRepo.all(from p in Post, select: p.title) == [\"second\"]\n    end\n\n    @tag :returning\n    @tag :with_conflict_target\n    test \"on conflict query and conflict target and returning\" do\n      on_conflict = from Post, update: [set: [title: \"second\"]]\n      post = [title: \"first\", uuid: \"6fa459ea-ee8a-3ca4-894e-db77e160355e\"]\n      {1, [%{id: id}]} = TestRepo.insert_all(Post, [post], on_conflict: on_conflict,\n                                            conflict_target: [:uuid], returning: [:id])\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(Post, [post], on_conflict: on_conflict,\n                                             conflict_target: [:id], returning: [:id]))\n\n      # Error on conflict target\n      {1, [%Post{id: ^id, title: \"second\"}]} =\n        TestRepo.insert_all(Post, [post], on_conflict: on_conflict,\n                            conflict_target: [:uuid], returning: [:id, :title])\n    end\n\n    @tag :with_conflict_target\n    test \"source (without an ecto schema) on conflict query and conflict target\" do\n      on_conflict = [set: [title: \"second\"]]\n      {:ok, uuid} = Ecto.UUID.dump(\"6fa459ea-ee8a-3ca4-894e-db77e160355e\")\n      post = [title: \"first\", uuid: uuid]\n      assert TestRepo.insert_all(\"posts\", [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n\n      # Error on non-conflict target\n      assert catch_error(TestRepo.insert_all(\"posts\", [post], on_conflict: on_conflict, conflict_target: [:id]))\n\n      # Error on conflict target\n      assert TestRepo.insert_all(\"posts\", [post], on_conflict: on_conflict, conflict_target: [:uuid]) ==\n             {1, nil}\n      assert TestRepo.all(from p in Post, select: p.title) == [\"second\"]\n    end\n\n    @tag :without_conflict_target\n    test \"on conflict replace_all\" do\n      post_first = %Post{title: \"first\", public: true}\n      post_second = %Post{title: \"second\", public: false}\n\n      {:ok, inserted_first} = TestRepo.insert(post_first, on_conflict: :replace_all)\n      {:ok, inserted_second} = TestRepo.insert(post_second, on_conflict: :replace_all)\n\n      assert inserted_first.id\n      assert inserted_second.id\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [2]\n\n      # multiple record change value\n      changes = [%{id: inserted_first.id, title: \"first_updated\", text: \"first_updated\"},\n                 %{id: inserted_second.id, title: \"second_updated\", text: \"second_updated\"}]\n\n      TestRepo.insert_all(Post, changes, on_conflict: :replace_all)\n\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [2]\n\n      updated_first =  TestRepo.get(Post, inserted_first.id)\n      assert updated_first.title == \"first_updated\"\n      assert updated_first.text == \"first_updated\"\n\n      updated_first =  TestRepo.get(Post, inserted_second.id)\n      assert updated_first.title == \"second_updated\"\n      assert updated_first.text == \"second_updated\"\n    end\n\n    @tag :with_conflict_target\n    test \"on conflict replace_all and conflict_target\" do\n      post_first = %Post{title: \"first\", public: true}\n      post_second = %Post{title: \"second\", public: false}\n\n      {:ok, inserted_first} = TestRepo.insert(post_first, on_conflict: :replace_all, conflict_target: :id)\n      {:ok, inserted_second} = TestRepo.insert(post_second, on_conflict: :replace_all, conflict_target: :id)\n\n      assert inserted_first.id\n      assert inserted_second.id\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [2]\n\n      # multiple record change value\n      changes = [%{id: inserted_first.id, title: \"first_updated\", text: \"first_updated\"},\n                 %{id: inserted_second.id, title: \"second_updated\", text: \"second_updated\"}]\n\n      TestRepo.insert_all(Post, changes, on_conflict: :replace_all, conflict_target: :id)\n\n      assert TestRepo.all(from p in Post, select: count(p.id)) == [2]\n\n      updated_first =  TestRepo.get(Post, inserted_first.id)\n      assert updated_first.title == \"first_updated\"\n      assert updated_first.text == \"first_updated\"\n\n\n      updated_first =  TestRepo.get(Post, inserted_second.id)\n      assert updated_first.title == \"second_updated\"\n      assert updated_first.text == \"second_updated\"\n    end\n  end\nend\n", "defmodule Ecto.Repo.Queryable do\n  # The module invoked by user defined repos\n  # for query related functionality.\n  @moduledoc false\n\n  @dialyzer {:no_opaque, transaction: 4}\n\n  alias Ecto.Query\n  alias Ecto.Queryable\n  alias Ecto.Query.Planner\n  alias Ecto.Query.SelectExpr\n\n  require Ecto.Query\n\n  def transaction(adapter, repo, fun, opts) when is_function(fun, 0) do\n    adapter.transaction(repo, opts, fun)\n  end\n\n  def transaction(adapter, repo, %Ecto.Multi{} = multi, opts) do\n    wrap   = &adapter.transaction(repo, opts, &1)\n    return = &adapter.rollback(repo, &1)\n\n    case Ecto.Multi.__apply__(multi, repo, wrap, return) do\n      {:ok, values} ->\n        {:ok, values}\n      {:error, {key, error_value, values}} ->\n        {:error, key, error_value, values}\n    end\n  end\n\n  def all(repo, adapter, queryable, opts) when is_list(opts) do\n    query =\n      queryable\n      |> Ecto.Queryable.to_query\n      |> Ecto.Query.Planner.returning(true)\n      |> attach_prefix(opts)\n    execute(:all, repo, adapter, query, opts) |> elem(1)\n  end\n\n  def stream(repo, adapter, queryable, opts) when is_list(opts) do\n    query =\n      queryable\n      |> Ecto.Queryable.to_query\n      |> Ecto.Query.Planner.returning(true)\n      |> attach_prefix(opts)\n    stream(:all, repo, adapter, query, opts)\n  end\n\n  def get(repo, adapter, queryable, id, opts) do\n    one(repo, adapter, query_for_get(repo, queryable, id), opts)\n  end\n\n  def get!(repo, adapter, queryable, id, opts) do\n    one!(repo, adapter, query_for_get(repo, queryable, id), opts)\n  end\n\n  def get_by(repo, adapter, queryable, clauses, opts) do\n    one(repo, adapter, query_for_get_by(repo, queryable, clauses), opts)\n  end\n\n  def get_by!(repo, adapter, queryable, clauses, opts) do\n    one!(repo, adapter, query_for_get_by(repo, queryable, clauses), opts)\n  end\n\n  def aggregate(repo, adapter, queryable, aggregate, field, opts) do\n    one!(repo, adapter, query_for_aggregate(queryable, aggregate, field), opts)\n  end\n\n  def one(repo, adapter, queryable, opts) do\n    case all(repo, adapter, queryable, opts) do\n      [one] -> one\n      []    -> nil\n      other -> raise Ecto.MultipleResultsError, queryable: queryable, count: length(other)\n    end\n  end\n\n  def one!(repo, adapter, queryable, opts) do\n    case all(repo, adapter, queryable, opts) do\n      [one] -> one\n      []    -> raise Ecto.NoResultsError, queryable: queryable\n      other -> raise Ecto.MultipleResultsError, queryable: queryable, count: length(other)\n    end\n  end\n\n  def update_all(repo, adapter, queryable, [], opts) when is_list(opts) do\n    update_all(repo, adapter, queryable, opts)\n  end\n\n  def update_all(repo, adapter, queryable, updates, opts) when is_list(opts) do\n    query = Query.from queryable, update: ^updates\n    update_all(repo, adapter, query, opts)\n  end\n\n  defp update_all(repo, adapter, queryable, opts) do\n    query =\n      queryable\n      |> Ecto.Queryable.to_query\n      |> Ecto.Query.Planner.assert_no_select!(:update_all)\n      |> Ecto.Query.Planner.returning(opts[:returning] || false)\n      |> attach_prefix(opts)\n    execute(:update_all, repo, adapter, query, opts)\n  end\n\n  def delete_all(repo, adapter, queryable, opts) when is_list(opts) do\n    query =\n      queryable\n      |> Ecto.Queryable.to_query\n      |> Ecto.Query.Planner.assert_no_select!(:delete_all)\n      |> Ecto.Query.Planner.returning(opts[:returning] || false)\n      |> attach_prefix(opts)\n    execute(:delete_all, repo, adapter, query, opts)\n  end\n\n  ## Helpers\n\n  defp attach_prefix(query, opts) do\n    case Keyword.fetch(opts, :prefix) do\n      {:ok, prefix} -> %{query | prefix: prefix}\n      :error -> query\n    end\n  end\n\n  defp execute(operation, repo, adapter, query, opts) when is_list(opts) do\n    {meta, prepared, params} = Planner.query(query, operation, repo, adapter, 0)\n\n    case meta do\n      %{select: nil} ->\n        adapter.execute(repo, meta, prepared, params, nil, opts)\n      %{select: select, prefix: prefix, sources: sources, preloads: preloads} ->\n        %{preprocess: preprocess, postprocess: postprocess, take: take, assocs: assocs} = select\n        all_nil? = tuple_size(sources) != 1\n        preprocessor = &preprocess(&1, preprocess, all_nil?, prefix, adapter)\n        {count, rows} = adapter.execute(repo, meta, prepared, params, preprocessor, opts)\n        postprocessor = postprocessor(postprocess, take, prefix, adapter)\n\n        {count,\n          rows\n          |> Ecto.Repo.Assoc.query(assocs, sources)\n          |> Ecto.Repo.Preloader.query(repo, preloads, take, postprocessor, opts)}\n    end\n  end\n\n  defp stream(operation, repo, adapter, query, opts) do\n    {meta, prepared, params} = Planner.query(query, operation, repo, adapter, 0)\n\n    case meta do\n      %{select: nil} ->\n        repo\n        |> adapter.stream(meta, prepared, params, nil, opts)\n        |> Stream.flat_map(fn {_, nil} -> [] end)\n      %{select: select, prefix: prefix, sources: sources, preloads: preloads} ->\n        %{preprocess: preprocess, postprocess: postprocess, take: take, assocs: assocs} = select\n        all_nil? = tuple_size(sources) != 1\n        preprocessor = &preprocess(&1, preprocess, all_nil?, prefix, adapter)\n        stream = adapter.stream(repo, meta, prepared, params, preprocessor, opts)\n        postprocessor = postprocessor(postprocess, take, prefix, adapter)\n\n        Stream.flat_map(stream, fn {_, rows} ->\n          rows\n          |> Ecto.Repo.Assoc.query(assocs, sources)\n          |> Ecto.Repo.Preloader.query(repo, preloads, take, postprocessor, opts)\n        end)\n    end\n  end\n\n  defp preprocess(row, [], _all_nil?, _prefix, _adapter) do\n    row\n  end\n  defp preprocess(row, [{:source, source_schema, fields} | sources], all_nil?, prefix, adapter) do\n    {entry, rest} = process_source(source_schema, fields, row, all_nil?, prefix, adapter)\n    [entry | preprocess(rest, sources, true, prefix, adapter)]\n  end\n  defp preprocess(row, [source | sources], all_nil?, prefix, adapter) do\n    {entry, rest} = process(row, source, nil, prefix, adapter)\n    [entry | preprocess(rest, sources, all_nil?, prefix, adapter)]\n  end\n\n  defp postprocessor({:from, :any, postprocess}, _take, prefix, adapter) do\n    fn [from | row] ->\n      row |> process(postprocess, from, prefix, adapter) |> elem(0)\n    end\n  end\n  defp postprocessor({:from, :map, postprocess}, take, prefix, adapter) do\n    fn [from | row] ->\n      row |> process(postprocess, to_map(from, take), prefix, adapter) |> elem(0)\n    end\n  end\n  defp postprocessor(postprocess, _take, prefix, adapter) do\n    fn row -> row |> process(postprocess, nil, prefix, adapter) |> elem(0) end\n  end\n\n  defp process(row, {:merge, left, right}, from, prefix, adapter) do\n    {left, row} = process(row, left, from, prefix, adapter)\n    {right, row} = process(row, right, from, prefix, adapter)\n\n    data =\n      case {left, right} do\n        {%{__struct__: struct}, %{__struct__: struct}} ->\n          right\n          |> Map.from_struct()\n          |> Enum.reduce(left, fn {key, value}, acc -> %{acc | key => value} end)\n        {_, %{__struct__: _}} ->\n          raise ArgumentError, \"can only merge with a struct on the right side when both sides \" <>\n                               \"represent the same struct. Left side is #{inspect left} and \" <>\n                               \"right side is #{inspect right}\"\n        {%{__struct__: _}, %{}} ->\n          Enum.reduce(right, left, fn {key, value}, acc -> %{acc | key => value} end)\n        {%{}, %{}} ->\n          Map.merge(left, right)\n        {_, %{}} ->\n          raise ArgumentError, \"cannot merge because the left side is not a map, got: #{inspect left}\"\n        {%{}, _} ->\n          raise ArgumentError, \"cannot merge because the right side is not a map, got: #{inspect right}\"\n      end\n\n    {data, row}\n  end\n  defp process(row, {:struct, struct, data, args}, from, prefix, adapter) do\n    case process(row, data, from, prefix, adapter) do\n      {%{__struct__: ^struct} = data, row} ->\n        process_update(data, args, row, from, prefix, adapter)\n      {data, _row} ->\n        raise BadStructError, struct: struct, term: data\n    end\n  end\n  defp process(row, {:struct, struct, args}, from, prefix, adapter) do\n    {fields, row} = process_kv(args, row, from, prefix, adapter)\n    {Map.merge(struct.__struct__(), Map.new(fields)), row}\n  end\n  defp process(row, {:map, data, args}, from, prefix, adapter) do\n    {data, row} = process(row, data, from, prefix, adapter)\n    process_update(data, args, row, from, prefix, adapter)\n  end\n  defp process(row, {:map, args}, from, prefix, adapter) do\n    {args, row} = process_kv(args, row, from, prefix, adapter)\n    {Map.new(args), row}\n  end\n  defp process(row, {:list, args}, from, prefix, adapter) do\n    process_args(args, row, from, prefix, adapter)\n  end\n  defp process(row, {:tuple, args}, from, prefix, adapter) do\n    {args, row} = process_args(args, row, from, prefix, adapter)\n    {List.to_tuple(args), row}\n  end\n  defp process(row, {:source, :from}, from, _prefix, _adapter) do\n    {from, row}\n  end\n  defp process(row, {:source, source_schema, fields}, _from, prefix, adapter) do\n    process_source(source_schema, fields, row, true, prefix, adapter)\n  end\n  defp process([value | row], {:value, :any}, _from, _prefix, _adapter) do\n    {value, row}\n  end\n  defp process([value | row], {:value, type}, _from, _prefix, adapter) do\n    {load!(type, value, nil, nil, adapter), row}\n  end\n  defp process(row, value, _from, _prefix, _adapter)\n       when is_binary(value) or is_number(value) or is_atom(value) do\n    {value, row}\n  end\n\n  defp process_update(data, args, row, from, prefix, adapter) do\n    {args, row} = process_kv(args, row, from, prefix, adapter)\n    data = Enum.reduce(args, data, fn {key, value}, acc -> %{acc | key => value} end)\n    {data, row}\n  end\n\n  defp process_source({source, schema}, types, row, all_nil?, prefix, adapter) do\n    case split_values(types, row, [], all_nil?) do\n      {nil, row} ->\n        {nil, row}\n      {values, row} ->\n        struct = if schema, do: schema.__struct__(), else: %{}\n        loader = &Ecto.Type.adapter_load(adapter, &1, &2)\n        {Ecto.Schema.__safe_load__(struct, types, values, prefix, source, loader), row}\n    end\n  end\n\n  defp split_values([_ | types], [nil | values], acc, all_nil?) do\n    split_values(types, values, [nil | acc], all_nil?)\n  end\n  defp split_values([_ | types], [value | values], acc, _all_nil?) do\n    split_values(types, values, [value | acc], false)\n  end\n  defp split_values([], values, _acc, true) do\n    {nil, values}\n  end\n  defp split_values([], values, acc, false) do\n    {Enum.reverse(acc), values}\n  end\n\n  defp process_args(args, row, from, prefix, adapter) do\n    Enum.map_reduce(args, row, fn arg, row ->\n      process(row, arg, from, prefix, adapter)\n    end)\n  end\n\n  defp process_kv(kv, row, from, prefix, adapter) do\n    Enum.map_reduce(kv, row, fn {key, value}, row ->\n      {key, row} = process(row, key, from, prefix, adapter)\n      {value, row} = process(row, value, from, prefix, adapter)\n      {{key, value}, row}\n    end)\n  end\n\n  defp load!(type, value, field, struct, adapter) do\n    case Ecto.Type.adapter_load(adapter, type, value) do\n      {:ok, value} ->\n        value\n      :error ->\n        field = field && \" for field #{inspect field}\"\n        struct = struct && \" in #{inspect struct}\"\n        raise ArgumentError, \"cannot load `#{inspect value}` as type #{inspect type}#{field}#{struct}\"\n    end\n  end\n\n  defp to_map(nil, _fields) do\n    nil\n  end\n  defp to_map(value, fields) when is_list(value) do\n    Enum.map(value, &to_map(&1, fields))\n  end\n  defp to_map(value, fields) do\n    for field <- fields, into: %{} do\n      case field do\n        {k, v} -> {k, to_map(Map.fetch!(value, k), List.wrap(v))}\n        k -> {k, Map.fetch!(value, k)}\n      end\n    end\n  end\n\n  defp query_for_get(repo, _queryable, nil) do\n    raise ArgumentError, \"cannot perform #{inspect repo}.get/2 because the given value is nil\"\n  end\n\n  defp query_for_get(repo, queryable, id) do\n    query  = Queryable.to_query(queryable)\n    schema = assert_schema!(query)\n    case schema.__schema__(:primary_key) do\n      [pk] ->\n        Query.from(x in query, where: field(x, ^pk) == ^id)\n      pks ->\n        raise ArgumentError,\n          \"#{inspect repo}.get/2 requires the schema #{inspect schema} \" <>\n          \"to have exactly one primary key, got: #{inspect pks}\"\n    end\n  end\n\n  defp query_for_get_by(_repo, queryable, clauses) do\n    Query.where(queryable, [], ^Enum.to_list(clauses))\n  end\n\n  defp query_for_aggregate(queryable, aggregate, field) do\n    query = %{Queryable.to_query(queryable) | preloads: [], assocs: []}\n    ast   = field(0, field)\n\n    query =\n      case query do\n        %{group_bys: [_|_]} ->\n          raise Ecto.QueryError, message: \"cannot aggregate on query with group_by\", query: query\n        %{distinct: nil, limit: nil, offset: nil} ->\n          %{query | order_bys: []}\n        _ ->\n          select = %SelectExpr{expr: ast, file: __ENV__.file, line: __ENV__.line}\n          %{query | select: select}\n          |> Query.subquery()\n          |> Queryable.Ecto.SubQuery.to_query()\n      end\n\n    %{query | select: %SelectExpr{expr: {aggregate, [], [ast]},\n                                  file: __ENV__.file, line: __ENV__.line}}\n  end\n\n  defp field(ix, field) when is_integer(ix) and is_atom(field) do\n    {{:., [], [{:&, [], [ix]}, field]}, [], []}\n  end\n\n  defp assert_schema!(%{from: {_source, schema}}) when schema != nil, do: schema\n  defp assert_schema!(query) do\n    raise Ecto.QueryError,\n      query: query,\n      message: \"expected a from expression with a schema\"\n  end\nend\n", "defmodule Ecto.RepoTest do\n  use ExUnit.Case, async: true\n\n  import Ecto.Query\n  import Ecto, only: [put_meta: 2]\n  require Ecto.TestRepo, as: TestRepo\n\n  defmodule MySchema do\n    use Ecto.Schema\n\n    schema \"my_schema\" do\n      field :x, :string\n      field :y, :binary, source: :yyy\n      field :z, :string, default: \"z\"\n      field :array, {:array, :string}\n      field :map, {:map, :string}\n      belongs_to :another, MySchema.Another\n    end\n  end\n\n  defmodule MySchemaNoPK do\n    use Ecto.Schema\n\n    @primary_key false\n    schema \"my_schema\" do\n      field :x, :string\n    end\n  end\n\n  test \"defines child_spec/1\" do\n    assert TestRepo.child_spec([]) == %{\n      id: TestRepo,\n      start: {TestRepo, :start_link, [[]]},\n      type: :supervisor\n    }\n  end\n\n  test \"needs schema with primary key field\" do\n    schema = %MySchemaNoPK{x: \"abc\"}\n\n    assert_raise Ecto.NoPrimaryKeyFieldError, fn ->\n      TestRepo.update!(schema |> Ecto.Changeset.change, force: true)\n    end\n\n    assert_raise Ecto.NoPrimaryKeyFieldError, fn ->\n      TestRepo.delete!(schema)\n    end\n  end\n\n  test \"works with primary key value\" do\n    schema = %MySchema{id: 1, x: \"abc\"}\n    TestRepo.get(MySchema, 123)\n    TestRepo.get_by(MySchema, x: \"abc\")\n    TestRepo.update!(schema |> Ecto.Changeset.change, force: true)\n    TestRepo.delete!(schema)\n  end\n\n  test \"works with custom source schema\" do\n    schema = %MySchema{id: 1, x: \"abc\"} |> put_meta(source: \"custom_schema\")\n    TestRepo.update!(schema |> Ecto.Changeset.change, force: true)\n    TestRepo.delete!(schema)\n\n    to_insert = %MySchema{x: \"abc\"} |> put_meta(source: \"custom_schema\")\n    TestRepo.insert!(to_insert)\n  end\n\n  test \"fails without primary key value\" do\n    schema = %MySchema{x: \"abc\"}\n\n    assert_raise Ecto.NoPrimaryKeyValueError, fn ->\n      TestRepo.update!(schema |> Ecto.Changeset.change, force: true)\n    end\n\n    assert_raise Ecto.NoPrimaryKeyValueError, fn ->\n      schema\n      |> Ecto.Changeset.change()\n      |> TestRepo.update()\n    end\n\n    assert_raise Ecto.NoPrimaryKeyValueError, fn ->\n      TestRepo.delete!(schema)\n    end\n  end\n\n  test \"validates schema types\" do\n    schema = %MySchema{x: 123}\n\n    assert_raise Ecto.ChangeError, fn ->\n      TestRepo.insert!(schema)\n    end\n  end\n\n  test \"validates get\" do\n    TestRepo.get(MySchema, 123)\n\n    message = \"cannot perform Ecto.TestRepo.get/2 because the given value is nil\"\n    assert_raise ArgumentError, message, fn ->\n      TestRepo.get(MySchema, nil)\n    end\n\n    message = ~r\"value `:atom` in `where` cannot be cast to type :id in query\"\n    assert_raise Ecto.Query.CastError, message, fn ->\n      TestRepo.get(MySchema, :atom)\n    end\n\n    message = ~r\"expected a from expression with a schema in query\"\n    assert_raise Ecto.QueryError, message, fn ->\n      TestRepo.get(%Ecto.Query{}, :atom)\n    end\n  end\n\n  test \"validates get_by\" do\n    TestRepo.get_by(MySchema, id: 123)\n    TestRepo.get_by(MySchema, %{id: 123})\n\n    message = ~r\"value `:atom` in `where` cannot be cast to type :id in query\"\n    assert_raise Ecto.Query.CastError, message, fn ->\n      TestRepo.get_by(MySchema, id: :atom)\n    end\n  end\n\n  test \"stream emits row values lazily\" do\n    stream = TestRepo.stream(MySchema)\n    refute_received :stream_execute\n    assert Enum.to_list(stream) == [1]\n    assert_received :stream_execute\n    assert Enum.take(stream, 0) == []\n    refute_received :stream_execute\n  end\n\n  test \"validates update_all\" do\n    # Success\n    TestRepo.update_all(MySchema, set: [x: \"321\"])\n\n    query = from(e in MySchema, where: e.x == \"123\", update: [set: [x: \"321\"]])\n    TestRepo.update_all(query, [])\n\n    # Failures\n    assert_raise ArgumentError, ~r/:returning expects at least one field to be given/, fn ->\n      TestRepo.update_all MySchema, [set: [x: \"321\"]], returning: []\n    end\n\n    assert_raise Ecto.QueryError, fn ->\n      TestRepo.update_all from(e in MySchema, select: e), set: [x: \"321\"]\n    end\n\n    assert_raise Ecto.QueryError, fn ->\n      TestRepo.update_all from(e in MySchema, order_by: e.x), set: [x: \"321\"]\n    end\n  end\n\n  test \"validates delete_all\" do\n    # Success\n    TestRepo.delete_all(MySchema)\n\n    query = from(e in MySchema, where: e.x == \"123\")\n    TestRepo.delete_all(query)\n\n    # Failures\n    assert_raise ArgumentError, ~r/:returning expects at least one field to be given/, fn ->\n      TestRepo.delete_all MySchema, returning: []\n    end\n\n    assert_raise Ecto.QueryError, fn ->\n      TestRepo.delete_all from(e in MySchema, select: e)\n    end\n\n    assert_raise Ecto.QueryError, fn ->\n      TestRepo.delete_all from(e in MySchema, order_by: e.x)\n    end\n  end\n\n  ## Changesets\n\n  test \"insert, update, insert_or_update and delete accepts changesets\" do\n    valid = Ecto.Changeset.cast(%MySchema{id: 1}, %{}, [])\n    assert {:ok, %MySchema{}} = TestRepo.insert(valid)\n    assert {:ok, %MySchema{}} = TestRepo.update(valid)\n    assert {:ok, %MySchema{}} = TestRepo.insert_or_update(valid)\n    assert {:ok, %MySchema{}} = TestRepo.delete(valid)\n  end\n\n  test \"insert, update, insert_or_update and delete sets schema prefix\" do\n    valid = Ecto.Changeset.cast(%MySchema{id: 1}, %{x: \"foo\"}, [:x])\n\n    assert {:ok, schema} = TestRepo.insert(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n\n    assert {:ok, schema} = TestRepo.update(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n\n    assert {:ok, schema} = TestRepo.delete(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n  end\n\n  test \"insert, update, and delete sets schema prefix from changeset repo opts\" do\n    valid =\n      %MySchema{id: 1}\n      |> Ecto.Changeset.cast(%{x: \"foo\"}, [:x])\n      |> Map.put(:repo_opts, [prefix: \"public\"])\n\n    assert {:ok, schema} = TestRepo.insert(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n\n    assert {:ok, schema} = TestRepo.update(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n\n    assert {:ok, schema} = TestRepo.delete(valid, prefix: \"public\")\n    {schema_prefix, _} = schema.__meta__.source\n    assert schema_prefix == \"public\"\n  end\n\n  test \"insert, update, insert_or_update and delete errors on invalid changeset\" do\n    invalid = %Ecto.Changeset{valid?: false, data: %MySchema{}}\n\n    insert = %{invalid | action: :insert, repo: TestRepo}\n    assert {:error, ^insert} = TestRepo.insert(invalid)\n    assert {:error, ^insert} = TestRepo.insert_or_update(invalid)\n\n    update = %{invalid | action: :update, repo: TestRepo}\n    assert {:error, ^update} = TestRepo.update(invalid)\n\n    delete = %{invalid | action: :delete, repo: TestRepo}\n    assert {:error, ^delete} = TestRepo.delete(invalid)\n\n    ignore = %{invalid | action: :ignore, repo: TestRepo}\n    assert {:error, ^insert} = TestRepo.insert(ignore)\n    assert {:error, ^update} = TestRepo.update(ignore)\n    assert {:error, ^delete} = TestRepo.delete(ignore)\n\n    assert_raise ArgumentError, ~r\"a valid changeset with action :ignore was given to Ecto.TestRepo.insert/2\", fn ->\n      TestRepo.insert(%{ignore | valid?: true})\n    end\n  end\n\n  test \"insert!, update! and delete! accepts changesets\" do\n    valid = Ecto.Changeset.cast(%MySchema{id: 1}, %{}, [])\n    assert %MySchema{} = TestRepo.insert!(valid)\n    assert %MySchema{} = TestRepo.update!(valid)\n    assert %MySchema{} = TestRepo.insert_or_update!(valid)\n    assert %MySchema{} = TestRepo.delete!(valid)\n  end\n\n  test \"insert!, update!, insert_or_update! and delete! fail on invalid changeset\" do\n    invalid = %Ecto.Changeset{valid?: false, data: %MySchema{}, types: %{}}\n\n    assert_raise Ecto.InvalidChangesetError,\n                 ~r\"could not perform insert because changeset is invalid\", fn ->\n      TestRepo.insert!(invalid)\n    end\n\n    assert_raise Ecto.InvalidChangesetError,\n                 ~r\"could not perform update because changeset is invalid\", fn ->\n      TestRepo.update!(invalid)\n    end\n\n    assert_raise Ecto.InvalidChangesetError,\n                 ~r\"could not perform insert because changeset is invalid\", fn ->\n      TestRepo.insert_or_update!(invalid)\n    end\n\n    assert_raise Ecto.InvalidChangesetError,\n                 ~r\"could not perform delete because changeset is invalid\", fn ->\n      TestRepo.delete!(invalid)\n    end\n  end\n\n  test \"insert!, update! and delete! fail on changeset without data\" do\n    invalid = %Ecto.Changeset{valid?: true, data: nil}\n\n    assert_raise ArgumentError, \"cannot insert a changeset without :data\", fn ->\n      TestRepo.insert!(invalid)\n    end\n\n    assert_raise ArgumentError, \"cannot update a changeset without :data\", fn ->\n      TestRepo.update!(invalid)\n    end\n\n    assert_raise ArgumentError, \"cannot delete a changeset without :data\", fn ->\n      TestRepo.delete!(invalid)\n    end\n  end\n\n  test \"insert!, update!, insert_or_update! and delete! fail on changeset with wrong action\" do\n    invalid = %Ecto.Changeset{valid?: true, data: %MySchema{id: 123}, action: :other}\n\n    assert_raise ArgumentError, \"a changeset with action :other was given to Ecto.TestRepo.insert/2\", fn ->\n      TestRepo.insert!(invalid)\n    end\n\n    assert_raise ArgumentError, \"a changeset with action :other was given to Ecto.TestRepo.update/2\", fn ->\n      TestRepo.update!(invalid)\n    end\n\n    assert_raise ArgumentError, \"a changeset with action :other was given to Ecto.TestRepo.insert/2\", fn ->\n      TestRepo.insert_or_update!(invalid)\n    end\n\n    assert_raise ArgumentError, \"a changeset with action :other was given to Ecto.TestRepo.delete/2\", fn ->\n      TestRepo.delete!(invalid)\n    end\n  end\n\n  test \"insert_or_update uses the correct action\" do\n    built  = Ecto.Changeset.cast(%MySchema{y: \"built\"}, %{}, [])\n    loaded =\n      %MySchema{y: \"loaded\"}\n      |> TestRepo.insert!\n      |> Ecto.Changeset.cast(%{y: \"updated\"}, [:y])\n    assert_received {:insert, _}\n\n    TestRepo.insert_or_update built\n    assert_received {:insert, _}\n\n    TestRepo.insert_or_update loaded\n    assert_received {:update, _}\n  end\n\n  test \"insert_or_update fails on invalid states\" do\n    deleted =\n      %MySchema{y: \"deleted\"}\n      |> TestRepo.insert!\n      |> TestRepo.delete!\n      |> Ecto.Changeset.cast(%{y: \"updated\"}, [:y])\n\n    assert_raise ArgumentError, ~r/the changeset has an invalid state/, fn ->\n      TestRepo.insert_or_update deleted\n    end\n  end\n\n  test \"insert_or_update fails when being passed a struct\" do\n    assert_raise ArgumentError, ~r/giving a struct to .* is not supported/, fn ->\n      TestRepo.insert_or_update %MySchema{}\n    end\n  end\n\n  defp prepare_changeset() do\n    %MySchema{id: 1}\n    |> Ecto.Changeset.cast(%{x: \"one\"}, [:x])\n    |> Ecto.Changeset.prepare_changes(fn %{repo: repo} = changeset ->\n          Process.put(:ecto_repo, repo)\n          Process.put(:ecto_counter, 1)\n          changeset\n        end)\n    |> Ecto.Changeset.prepare_changes(fn changeset ->\n          Process.put(:ecto_counter, 2)\n          changeset\n        end)\n  end\n\n  test \"insert runs prepare callbacks in transaction\" do\n    changeset = prepare_changeset()\n    TestRepo.insert!(changeset)\n    assert_received {:transaction, _}\n    assert Process.get(:ecto_repo) == TestRepo\n    assert Process.get(:ecto_counter) == 2\n  end\n\n  test \"update runs prepare callbacks in transaction\" do\n    changeset = prepare_changeset()\n    TestRepo.update!(changeset)\n    assert_received {:transaction, _}\n    assert Process.get(:ecto_repo) == TestRepo\n    assert Process.get(:ecto_counter) == 2\n  end\n\n  test \"delete runs prepare callbacks in transaction\" do\n    changeset = prepare_changeset()\n    TestRepo.delete!(changeset)\n    assert_received {:transaction, _}\n    assert Process.get(:ecto_repo) == TestRepo\n    assert Process.get(:ecto_counter) == 2\n  end\n\n  describe \"changeset constraints\" do\n    test \"are mapped to repo constraint violations\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [unique: \"custom_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo, name: \"custom_foo_index\")\n      assert {:error, changeset} = TestRepo.insert(changeset)\n      refute changeset.valid?\n    end\n\n    test \"are mapped to repo constraint violation using suffix match\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [unique: \"foo_table_custom_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo, name: \"custom_foo_index\", match: :suffix)\n      assert {:error, changeset} = TestRepo.insert(changeset)\n      refute changeset.valid?\n    end\n\n    test \"are mapped to repo constraint violation using prefix match\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [unique: \"foo_table_custom_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo, name: \"foo_table_custom_foo\", match: :prefix)\n      assert {:error, changeset} = TestRepo.insert(changeset)\n      refute changeset.valid?\n    end\n\n    test \"may fail to map to repo constraint violation on name\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [unique: \"foo_table_custom_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo, name: \"custom_foo_index\")\n      assert_raise Ecto.ConstraintError, fn ->\n        TestRepo.insert(changeset)\n      end\n    end\n\n    test \"may fail to map to repo constraint violation on index type\" do\n      my_schema = %MySchema{id: 1}\n      changeset =\n        put_in(my_schema.__meta__.context, {:invalid, [invalid_constraint_type: \"my_schema_foo_index\"]})\n        |> Ecto.Changeset.change(x: \"foo\")\n        |> Ecto.Changeset.unique_constraint(:foo)\n      assert_raise Ecto.ConstraintError, fn ->\n        TestRepo.insert(changeset)\n      end\n    end\n  end\n\n  describe \"on conflict\" do\n    test \"raises on unknown on_conflict value\" do\n      assert_raise ArgumentError, \"unknown value for :on_conflict, got: :who_knows\", fn ->\n        TestRepo.insert(%MySchema{id: 1}, on_conflict: :who_knows)\n      end\n    end\n\n    test \"raises on non-empty conflict_target with on_conflict raise\" do\n      assert_raise ArgumentError, \":conflict_target option is forbidden when :on_conflict is :raise\", fn ->\n        TestRepo.insert(%MySchema{id: 1}, on_conflict: :raise, conflict_target: [:id])\n      end\n    end\n\n    test \"raises on query mismatch\" do\n      assert_raise ArgumentError, ~r\"cannot run on_conflict: query\", fn ->\n        query = from p in \"posts\"\n        TestRepo.insert(%MySchema{id: 1}, on_conflict: query)\n      end\n    end\n  end\n\n  describe \"preload\" do\n    test \"if first argument of preload is nil, it should return nil\" do\n      assert TestRepo.preload(nil, []) == nil\n    end\n  end\n\n  describe \"insert_all\" do\n    test \"raises when on associations\" do\n      assert_raise ArgumentError, fn ->\n        TestRepo.insert_all MySchema, [%{another: nil}]\n      end\n    end\n  end\n\n  test \"load/2\" do\n    # string fields\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, %{\"x\" => \"abc\"})\n\n    # atom fields\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, %{x: \"abc\"})\n\n    # keyword list\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, [x: \"abc\"])\n\n    # atom fields and values\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, {[:x], [\"abc\"]})\n\n    # string fields and values\n    assert %MySchema{x: \"abc\"} =\n           TestRepo.load(MySchema, {[\"x\"], [\"abc\"]})\n\n    # default value\n    assert %MySchema{x: \"abc\", z: \"z\"} =\n           TestRepo.load(MySchema, %{x: \"abc\"})\n\n    # source field\n    assert %MySchema{y: \"abc\"} =\n           TestRepo.load(MySchema, %{yyy: \"abc\"})\n\n    # array field\n    assert %MySchema{array: [\"one\", \"two\"]} =\n           TestRepo.load(MySchema, %{array: [\"one\", \"two\"]})\n\n    # map field with atoms\n    assert %MySchema{map: %{color: \"red\"}} =\n           TestRepo.load(MySchema, %{map: %{color: \"red\"}})\n\n    # map field with strings\n    assert %MySchema{map: %{\"color\" => \"red\"}} =\n           TestRepo.load(MySchema, %{map: %{\"color\" => \"red\"}})\n\n    # nil\n    assert %MySchema{x: nil} =\n           TestRepo.load(MySchema, %{x: nil})\n\n    # invalid field is ignored\n    assert %MySchema{} =\n           TestRepo.load(MySchema, %{bad: \"bad\"})\n\n    # invalid value\n    assert_raise ArgumentError, \"cannot load `0` as type :string for field `x` in schema Ecto.RepoTest.MySchema\", fn ->\n      TestRepo.load(MySchema, %{x: 0})\n    end\n\n    # schemaless\n    assert TestRepo.load(%{x: :string}, %{x: \"abc\", bad: \"bad\"}) ==\n           %{x: \"abc\"}\n  end\n\n  defmodule NoTransactionAdapter do\n    defmacro __before_compile__(_opts), do: :ok\n  end\n\n  defmodule NoTransactionRepo do\n    use Ecto.Repo, otp_app: :ecto, adapter: NoTransactionAdapter\n  end\n\n  test \"no transaction functions generated on repo, without adapter support\" do\n    refute function_exported?(NoTransactionRepo, :transaction, 2)\n    refute function_exported?(NoTransactionRepo, :in_transaction?, 2)\n    refute function_exported?(NoTransactionRepo, :rollback, 1)\n  end\nend\n"], "filenames": ["integration_test/cases/repo.exs", "lib/ecto/repo/queryable.ex", "test/ecto/repo_test.exs"], "buggy_code_start_loc": [604, 350, 115], "buggy_code_end_loc": [619, 356, 116], "fixing_code_start_loc": [603, 350, 114], "fixing_code_end_loc": [615, 351, 114], "type": "NVD-CWE-Other", "message": "Ecto 2.2.0 lacks a certain protection mechanism associated with the interaction between is_nil and raise.", "other": {"cve": {"id": "CVE-2017-20166", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-10T06:15:09.610", "lastModified": "2023-01-13T15:42:47.973", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ecto 2.2.0 lacks a certain protection mechanism associated with the interaction between is_nil and raise."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ecto_project:ecto:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "4558BE90-7F21-4524-A1DB-3D1DF8F1FFA4"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-2xxx-fhc8-9qvq", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/elixir-ecto/ecto/commit/db55b0cba6525c24ebddc88ef9ae0c1c00620250", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/elixir-ecto/ecto/pull/2125", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#!topic/elixir-ecto/0m4NPfg_MMU", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/elixir-ecto/ecto/commit/db55b0cba6525c24ebddc88ef9ae0c1c00620250"}}