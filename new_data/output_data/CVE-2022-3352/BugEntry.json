{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * buffer.c: functions for dealing with the buffer structure\n */\n\n/*\n * The buffer list is a double linked list of all buffers.\n * Each buffer can be in one of these states:\n * never loaded: BF_NEVERLOADED is set, only the file name is valid\n *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n *\t hidden: b_nwindows == 0, loaded but not displayed in a window\n *\t normal: loaded and displayed in a window\n *\n * Instead of storing file names all over the place, each file name is\n * stored in the buffer list. It can be referenced by a number.\n *\n * The current implementation remembers all file names ever used.\n */\n\n#include \"vim.h\"\n\n\n#ifdef FEAT_EVAL\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n# define MAX_STL_EVAL_DEPTH 100\n#endif\n\nstatic void\tenter_buffer(buf_T *buf);\nstatic void\tbuflist_getfpos(void);\nstatic char_u\t*buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);\nstatic char_u\t*fname_match(regmatch_T *rmp, char_u *name, int ignore_case);\n#ifdef UNIX\nstatic buf_T\t*buflist_findname_stat(char_u *ffname, stat_T *st);\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);\nstatic int\tbuf_same_ino(buf_T *buf, stat_T *stp);\n#else\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname);\n#endif\nstatic int\tvalue_changed(char_u *str, char_u **last);\nstatic int\tappend_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);\nstatic void\tfree_buffer(buf_T *);\nstatic void\tfree_buffer_stuff(buf_T *buf, int free_options);\nstatic int\tbt_nofileread(buf_T *buf);\n\n#ifdef UNIX\n# define dev_T dev_t\n#else\n# define dev_T unsigned\n#endif\n\n#define FOR_ALL_BUFS_FROM_LAST(buf) \\\n    for ((buf) = lastbuf; (buf) != NULL; (buf) = (buf)->b_prev)\n\n#if defined(FEAT_QUICKFIX)\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\n#endif\n\n// Number of times free_buffer() was called.\nstatic int\tbuf_free_count = 0;\n\nstatic int\ttop_file_num = 1;\t// highest file number\nstatic garray_T buf_reuse = GA_EMPTY;\t// file numbers to recycle\n\n/*\n * Return the highest possible buffer number.\n */\n    int\nget_highest_fnum(void)\n{\n    return top_file_num - 1;\n}\n\n/*\n * Read data from buffer for retrying.\n */\n    static int\nread_buffer(\n    int\t\tread_stdin,\t    // read file from stdin, otherwise fifo\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    linenr_T\tline_count;\n\n    // Read from the buffer which the text is already filled in and append at\n    // the end.  This makes it possible to retry when 'fileformat' or\n    // 'fileencoding' was guessed wrong.\n    line_count = curbuf->b_ml.ml_line_count;\n    retval = readfile(\n\t    read_stdin ? NULL : curbuf->b_ffname,\n\t    read_stdin ? NULL : curbuf->b_fname,\n\t    line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t    flags | READ_BUFFER);\n    if (retval == OK)\n    {\n\t// Delete the binary lines.\n\twhile (--line_count >= 0)\n\t    ml_delete((linenr_T)1);\n    }\n    else\n    {\n\t// Delete the converted lines.\n\twhile (curbuf->b_ml.ml_line_count > line_count)\n\t    ml_delete(line_count);\n    }\n    // Put the cursor on the first line.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n\n    if (read_stdin)\n    {\n\t// Set or reset 'modified' before executing autocommands, so that\n\t// it can be changed there.\n\tif (!readonlymode && !BUFEMPTY())\n\t    changed();\n\telse if (retval == OK)\n\t    unchanged(curbuf, FALSE, TRUE);\n\n\tif (retval == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);\n#endif\n\t}\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Ensure buffer \"buf\" is loaded.  Does not trigger the swap-exists action.\n */\n    void\nbuffer_ensure_loaded(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\taco_save_T\taco;\n\n\taucmd_prepbuf(&aco, buf);\n\tif (swap_exists_action != SEA_READONLY)\n\t    swap_exists_action = SEA_NONE;\n\topen_buffer(FALSE, NULL, 0);\n\taucmd_restbuf(&aco);\n    }\n}\n#endif\n\n/*\n * Open current buffer, that is: open the memfile and read the file into\n * memory.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nopen_buffer(\n    int\t\tread_stdin,\t    // read file from stdin\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags_arg)\t    // extra flags for readfile()\n{\n    int\t\tflags = flags_arg;\n    int\t\tretval = OK;\n    bufref_T\told_curbuf;\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    int\t\tread_fifo = FALSE;\n\n    // The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n    // When re-entering the same buffer, it should not change, because the\n    // user may have reset the flag by hand.\n    if (readonlymode && curbuf->b_ffname != NULL\n\t\t\t\t\t&& (curbuf->b_flags & BF_NEVERLOADED))\n\tcurbuf->b_p_ro = TRUE;\n\n    if (ml_open(curbuf) == FAIL)\n    {\n\t// There MUST be a memfile, otherwise we can't do anything\n\t// If we can't create one for the current buffer, take another buffer\n\tclose_buffer(NULL, curbuf, 0, FALSE, FALSE);\n\tFOR_ALL_BUFFERS(curbuf)\n\t    if (curbuf->b_ml.ml_mfp != NULL)\n\t\tbreak;\n\t// If there is no memfile at all, exit.\n\t// This is OK, since there are no changes to lose.\n\tif (curbuf == NULL)\n\t{\n\t    emsg(_(e_cannot_allocate_any_buffer_exiting));\n\n\t    // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n\t    // will work.\n\t    v_dying = 2;\n\t    getout(2);\n\t}\n\n\temsg(_(e_cannot_allocate_buffer_using_other_one));\n\tenter_buffer(curbuf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n\treturn FAIL;\n    }\n\n    // The autocommands in readfile() may change the buffer, but only AFTER\n    // reading the file.\n    set_bufref(&old_curbuf, curbuf);\n    modified_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    // A buffer without an actual file should not use the buffer name to read a\n    // file.\n    if (bt_nofileread(curbuf))\n\tflags |= READ_NOFILE;\n\n    // Read the file if there is one.\n    if (curbuf->b_ffname != NULL\n#ifdef FEAT_NETBEANS_INTG\n\t    && netbeansReadFile\n#endif\n       )\n    {\n\tint old_msg_silent = msg_silent;\n#ifdef UNIX\n\tint save_bin = curbuf->b_p_bin;\n\tint perm;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tint oldFire = netbeansFireChanges;\n\n\tnetbeansFireChanges = 0;\n#endif\n#ifdef UNIX\n\tperm = mch_getperm(curbuf->b_ffname);\n\tif (perm >= 0 && (S_ISFIFO(perm)\n\t\t      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n\t\t      || (S_ISCHR(perm) && is_dev_fd_file(curbuf->b_ffname))\n# endif\n\t\t    ))\n\t\tread_fifo = TRUE;\n\tif (read_fifo)\n\t    curbuf->b_p_bin = TRUE;\n#endif\n\tif (shortmess(SHM_FILEINFO))\n\t    msg_silent = 1;\n\tretval = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t\t  flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n\tif (read_fifo)\n\t{\n\t    curbuf->b_p_bin = save_bin;\n\t    if (retval == OK)\n\t\tretval = read_buffer(FALSE, eap, flags);\n\t}\n#endif\n\tmsg_silent = old_msg_silent;\n#ifdef FEAT_NETBEANS_INTG\n\tnetbeansFireChanges = oldFire;\n#endif\n\t// Help buffer is filtered.\n\tif (bt_help(curbuf))\n\t    fix_help_buffer();\n    }\n    else if (read_stdin)\n    {\n\tint\tsave_bin = curbuf->b_p_bin;\n\n\t// First read the text in binary mode into the buffer.\n\t// Then read from that same buffer and append at the end.  This makes\n\t// it possible to retry when 'fileformat' or 'fileencoding' was\n\t// guessed wrong.\n\tcurbuf->b_p_bin = TRUE;\n\tretval = readfile(NULL, NULL, (linenr_T)0,\n\t\t  (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n\t\t  flags | (READ_NEW + READ_STDIN));\n\tcurbuf->b_p_bin = save_bin;\n\tif (retval == OK)\n\t    retval = read_buffer(TRUE, eap, flags);\n    }\n\n    // if first time loading this buffer, init b_chartab[]\n    if (curbuf->b_flags & BF_NEVERLOADED)\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\n\tparse_cino(curbuf);\n    }\n\n    // Set/reset the Changed flag first, autocmds may change the buffer.\n    // Apply the automatic commands, before processing the modelines.\n    // So the modelines have priority over autocommands.\n    //\n    // When reading stdin, the buffer contents always needs writing, so set\n    // the changed flag.  Unless in readonly mode: \"ls | gview -\".\n    // When interrupted and 'cpoptions' contains 'i' set changed flag.\n    if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n\t\t|| modified_was_set\t// \":set modified\" used in autocmd\n#ifdef FEAT_EVAL\n\t\t|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n#endif\n       )\n\tchanged();\n    else if (retval == OK && !read_stdin && !read_fifo)\n\tunchanged(curbuf, FALSE, TRUE);\n    save_file_ff(curbuf);\t\t// keep this fileformat\n\n    // Set last_changedtick to avoid triggering a TextChanged autocommand right\n    // after it was added.\n    curbuf->b_last_changedtick = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\n    // require \"!\" to overwrite the file, because it wasn't read completely\n#ifdef FEAT_EVAL\n    if (aborting())\n#else\n    if (got_int)\n#endif\n\tcurbuf->b_flags |= BF_READERR;\n\n#ifdef FEAT_FOLDING\n    // Need to update automatic folding.  Do this before the autocommands,\n    // they may use the fold info.\n    foldUpdateAll(curwin);\n#endif\n\n    // need to set w_topline, unless some autocommand already did that.\n    if (!(curwin->w_valid & VALID_TOPLINE))\n    {\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n    }\n#ifdef FEAT_EVAL\n    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);\n#else\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n    if (retval == OK)\n    {\n\t// The autocommands may have changed the current buffer.  Apply the\n\t// modelines to the correct buffer, if it still exists and is loaded.\n\tif (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    aco_save_T\taco;\n\n\t    // Go to the buffer that was opened.\n\t    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n\t    do_modelines(0);\n\t    curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n\t    if ((flags & READ_NOWINENTER) == 0)\n#ifdef FEAT_EVAL\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Store \"buf\" in \"bufref\" and set the free count.\n */\n    void\nset_bufref(bufref_T *bufref, buf_T *buf)\n{\n    bufref->br_buf = buf;\n    bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n    bufref->br_buf_free_count = buf_free_count;\n}\n\n/*\n * Return TRUE if \"bufref->br_buf\" points to the same buffer as when\n * set_bufref() was called and it is a valid buffer.\n * Only goes through the buffer list if buf_free_count changed.\n * Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n * the same allocated memory, but it's a different buffer.\n */\n    int\nbufref_valid(bufref_T *bufref)\n{\n    return bufref->br_buf_free_count == buf_free_count\n\t? TRUE : buf_valid(bufref->br_buf)\n\t\t\t\t  && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/*\n * Return TRUE if \"buf\" points to a valid buffer (in the buffer list).\n * This can be slow if there are many buffers, prefer using bufref_valid().\n */\n    int\nbuf_valid(buf_T *buf)\n{\n    buf_T\t*bp;\n\n    // Assume that we more often have a recent buffer, start with the last\n    // one.\n    FOR_ALL_BUFS_FROM_LAST(bp)\n\tif (bp == buf)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * A hash table used to quickly lookup a buffer by its number.\n */\nstatic hashtab_T buf_hashtab;\n\n    static void\nbuf_hashtab_add(buf_T *buf)\n{\n    sprintf((char *)buf->b_key, \"%x\", buf->b_fnum);\n    if (hash_add(&buf_hashtab, buf->b_key) == FAIL)\n\temsg(_(e_buffer_cannot_be_registered));\n}\n\n    static void\nbuf_hashtab_remove(buf_T *buf)\n{\n    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);\n\n    if (!HASHITEM_EMPTY(hi))\n\thash_remove(&buf_hashtab, hi);\n}\n\n/*\n * Return TRUE when buffer \"buf\" can be unloaded.\n * Give an error message and return FALSE when the buffer is locked or the\n * screen is being redrawn and the buffer is in a window.\n */\n    static int\ncan_unload_buffer(buf_T *buf)\n{\n    int\t    can_unload = !buf->b_locked;\n\n    if (can_unload && updating_screen)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str), buf->b_fname);\n    return can_unload;\n}\n\n/*\n * Close the link to a buffer.\n * \"action\" is used when there is no longer a window for the buffer.\n * It can be:\n * 0\t\t\tbuffer becomes hidden\n * DOBUF_UNLOAD\t\tbuffer is unloaded\n * DOBUF_DELETE\t\tbuffer is unloaded and removed from buffer list\n * DOBUF_WIPE\t\tbuffer is unloaded and really deleted\n * DOBUF_WIPE_REUSE\tidem, and add to buf_reuse list\n * When doing all but the first one on the current buffer, the caller should\n * get a new buffer very soon!\n *\n * The 'bufhidden' option can force freeing and deleting.\n *\n * When \"abort_if_last\" is TRUE then do not close the buffer if autocommands\n * cause there to be only one window with this buffer.  e.g. when \":quit\" is\n * supposed to close the window but autocommands close all other windows.\n *\n * When \"ignore_abort\" is TRUE don't abort even when aborting() returns TRUE.\n *\n * Return TRUE when we got to the end and b_nwindows was decremented.\n */\n    int\nclose_buffer(\n    win_T\t*win,\t\t// if not NULL, set b_last_cursor\n    buf_T\t*buf,\n    int\t\taction,\n    int\t\tabort_if_last,\n    int\t\tignore_abort)\n{\n    int\t\tis_curbuf;\n    int\t\tnwindows;\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n    int\t\tunload_buf = (action != 0);\n    int\t\twipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n    int\t\tdel_buf = (action == DOBUF_DEL || wipe_buf);\n\n    CHECK_CURBUF;\n\n    // Force unloading or deleting when 'bufhidden' says so.\n    // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n    // \"hide\" (otherwise we could never free or delete a buffer).\n    if (buf->b_p_bh[0] == 'd')\t\t// 'bufhidden' == \"delete\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'w')\t// 'bufhidden' == \"wipe\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n\twipe_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'u')\t// 'bufhidden' == \"unload\"\n\tunload_buf = TRUE;\n\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))\n    {\n\tCHECK_CURBUF;\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (wipe_buf || unload_buf)\n\t    {\n\t\tif (!can_unload_buffer(buf))\n\t\t    return FALSE;\n\n\t\t// Wiping out or unloading a terminal buffer kills the job.\n\t\tfree_terminal(buf);\n\t    }\n\t    else\n\t    {\n\t\t// The job keeps running, hide the buffer.\n\t\tdel_buf = FALSE;\n\t\tunload_buf = FALSE;\n\t    }\n\t}\n\telse if (buf->b_p_bh[0] == 'h' && !del_buf)\n\t{\n\t    // Hide a terminal buffer.\n\t    unload_buf = FALSE;\n\t}\n\telse\n\t{\n\t    // A terminal buffer is wiped out if the job has finished.\n\t    del_buf = TRUE;\n\t    unload_buf = TRUE;\n\t    wipe_buf = TRUE;\n\t}\n\tCHECK_CURBUF;\n    }\n#endif\n\n    // Disallow deleting the buffer when it is locked (already being closed or\n    // halfway a command that relies on it). Unloading is allowed.\n    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))\n\treturn FALSE;\n\n    // check no autocommands closed the window\n    if (win != NULL && win_valid_any_tab(win))\n    {\n\t// Set b_last_cursor when closing the last window for the buffer.\n\t// Remember the last cursor position and window options of the buffer.\n\t// This used to be only for the current window, but then options like\n\t// 'foldmethod' may be lost with a \":only\" command.\n\tif (buf->b_nwindows == 1)\n\t    set_last_cursor(win);\n\tbuflist_setfpos(buf, win,\n\t\t    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n\t\t    win->w_cursor.col, TRUE);\n    }\n\n    set_bufref(&bufref, buf);\n\n    // When the buffer is no longer in a window, trigger BufWinLeave\n    if (buf->b_nwindows == 1)\n    {\n\t++buf->b_locked;\n\t++buf->b_locked_split;\n\tif (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t{\n\t    // Autocommands deleted the buffer.\naucmd_abort:\n\t    emsg(_(e_autocommands_caused_command_to_abort));\n\t    return FALSE;\n\t}\n\t--buf->b_locked;\n\t--buf->b_locked_split;\n\tif (abort_if_last && one_window())\n\t    // Autocommands made this the only window.\n\t    goto aucmd_abort;\n\n\t// When the buffer becomes hidden, but is not unloaded, trigger\n\t// BufHidden\n\tif (!unload_buf)\n\t{\n\t    ++buf->b_locked;\n\t    ++buf->b_locked_split;\n\t    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\t// Autocommands deleted the buffer.\n\t\tgoto aucmd_abort;\n\t    --buf->b_locked;\n\t    --buf->b_locked_split;\n\t    if (abort_if_last && one_window())\n\t\t// Autocommands made this the only window.\n\t\tgoto aucmd_abort;\n\t}\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (!ignore_abort && aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n    nwindows = buf->b_nwindows;\n\n    // decrease the link count from windows (unless not in any window)\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n#ifdef FEAT_DIFF\n    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)\n\tdiff_buf_delete(buf);\t// Clear 'diff' for hidden buffer.\n#endif\n\n    // Return when a window is displaying the buffer or when it's not\n    // unloaded.\n    if (buf->b_nwindows > 0 || !unload_buf)\n\treturn FALSE;\n\n    // Always remove the buffer when there is no file name.\n    if (buf->b_ffname == NULL)\n\tdel_buf = TRUE;\n\n    // When closing the current buffer stop Visual mode before freeing\n    // anything.\n    if (buf == curbuf && VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Free all things allocated for this buffer.\n    // Also calls the \"BufDelete\" autocommands when del_buf is TRUE.\n    //\n    // Remember if we are closing the current buffer.  Restore the number of\n    // windows, so that autocommands in buf_freeall() don't get confused.\n    is_curbuf = (buf == curbuf);\n    buf->b_nwindows = nwindows;\n\n    buf_freeall(buf, (del_buf ? BFA_DEL : 0)\n\t\t   + (wipe_buf ? BFA_WIPE : 0)\n\t\t   + (ignore_abort ? BFA_IGNORE_ABORT : 0));\n\n    // Autocommands may have deleted the buffer.\n    if (!bufref_valid(&bufref))\n\treturn FALSE;\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if (!ignore_abort && aborting())\n\treturn FALSE;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause the previous curbuf to be deleted unexpectedly.  But\n    // in some cases it's OK to delete the curbuf, because a new one is\n    // obtained anyway.  Therefore only return if curbuf changed to the\n    // deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn FALSE;\n\n    if (win_valid_any_tab(win) && win->w_buffer == buf)\n\twin->w_buffer = NULL;  // make sure we don't use the buffer now\n\n    // Autocommands may have opened or closed windows for this buffer.\n    // Decrement the count for the close we do here.\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n    /*\n     * Remove the buffer from the list.\n     */\n    if (wipe_buf)\n    {\n\t// Do not wipe out the buffer if it is used in a window.\n\tif (buf->b_nwindows > 0)\n\t    return FALSE;\n\n\tif (action == DOBUF_WIPE_REUSE)\n\t{\n\t    // we can re-use this buffer number, store it\n\t    if (buf_reuse.ga_itemsize == 0)\n\t\tga_init2(&buf_reuse, sizeof(int), 50);\n\t    if (ga_grow(&buf_reuse, 1) == OK)\n\t\t((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;\n\t}\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf->b_prev == NULL)\n\t    firstbuf = buf->b_next;\n\telse\n\t    buf->b_prev->b_next = buf->b_next;\n\tif (buf->b_next == NULL)\n\t    lastbuf = buf->b_prev;\n\telse\n\t    buf->b_next->b_prev = buf->b_prev;\n\tfree_buffer(buf);\n    }\n    else\n    {\n\tif (del_buf)\n\t{\n\t    // Free all internal variables and reset option values, to make\n\t    // \":bdel\" compatible with Vim 5.7.\n\t    free_buffer_stuff(buf, TRUE);\n\n\t    // Make it look like a new buffer.\n\t    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n\t    // Init the options when loaded again.\n\t    buf->b_p_initialized = FALSE;\n\t}\n\tbuf_clear_file(buf);\n\tif (del_buf)\n\t    buf->b_p_bl = FALSE;\n    }\n    // NOTE: at this point \"curbuf\" may be invalid!\n    return TRUE;\n}\n\n/*\n * Make buffer not contain a file.\n */\n    void\nbuf_clear_file(buf_T *buf)\n{\n    buf->b_ml.ml_line_count = 1;\n    unchanged(buf, TRUE, TRUE);\n    buf->b_shortname = FALSE;\n    buf->b_p_eol = TRUE;\n    buf->b_start_eol = TRUE;\n    buf->b_p_bomb = FALSE;\n    buf->b_start_bomb = FALSE;\n    buf->b_ml.ml_mfp = NULL;\n    buf->b_ml.ml_flags = ML_EMPTY;\t\t// empty buffer\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_deleted_all_lines(buf);\n#endif\n}\n\n/*\n * buf_freeall() - free all things allocated for a buffer that are related to\n * the file.  Careful: get here with \"curwin\" NULL when exiting.\n * flags:\n * BFA_DEL\t     buffer is going to be deleted\n * BFA_WIPE\t     buffer is going to be wiped out\n * BFA_KEEP_UNDO     do not free undo information\n * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE\n */\n    void\nbuf_freeall(buf_T *buf, int flags)\n{\n    int\t\tis_curbuf = (buf == curbuf);\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n\n    // Make sure the buffer isn't closed by autocommands.\n    ++buf->b_locked;\n    ++buf->b_locked_split;\n    set_bufref(&bufref, buf);\n    if (buf->b_ml.ml_mfp != NULL)\n    {\n\tif (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if ((flags & BFA_DEL) && buf->b_p_bl)\n    {\n\tif (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t   FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if (flags & BFA_WIPE)\n    {\n\tif (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    --buf->b_locked;\n    --buf->b_locked_split;\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if ((flags & BFA_IGNORE_ABORT) == 0 && aborting())\n\treturn;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause curbuf to be deleted unexpectedly.  But in some cases\n    // it's OK to delete the curbuf, because a new one is obtained anyway.\n    // Therefore only return if curbuf changed to the deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn;\n#ifdef FEAT_DIFF\n    diff_buf_delete(buf);\t    // Can't use 'diff' for unloaded buffer.\n#endif\n#ifdef FEAT_SYN_HL\n    // Remove any ownsyntax, unless exiting.\n    if (curwin != NULL && curwin->w_buffer == buf)\n\treset_synblock(curwin);\n#endif\n\n#ifdef FEAT_FOLDING\n    // No folds in an empty buffer.\n    {\n\twin_T\t\t*win;\n\ttabpage_T\t*tp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t    if (win->w_buffer == buf)\n\t\tclearFolding(win);\n    }\n#endif\n\n#ifdef FEAT_TCL\n    tcl_buffer_free(buf);\n#endif\n    ml_close(buf, TRUE);\t    // close and delete the memline/memfile\n    buf->b_ml.ml_line_count = 0;    // no lines in buffer\n    if ((flags & BFA_KEEP_UNDO) == 0)\n    {\n\tu_blockfree(buf);\t    // free the memory allocated for undo\n\tu_clearall(buf);\t    // reset all undo information\n    }\n#ifdef FEAT_SYN_HL\n    syntax_clear(&buf->b_s);\t    // reset syntax info\n#endif\n#ifdef FEAT_PROP_POPUP\n    clear_buf_prop_types(buf);\n#endif\n    buf->b_flags &= ~BF_READERR;    // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\n    static void\nfree_buffer(buf_T *buf)\n{\n    ++buf_free_count;\n    free_buffer_stuff(buf, TRUE);\n#ifdef FEAT_EVAL\n    // b:changedtick uses an item in buf_T, remove it now\n    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di);\n    unref_var_dict(buf->b_vars);\n    remove_listeners(buf);\n#endif\n#ifdef FEAT_LUA\n    lua_buffer_free(buf);\n#endif\n#ifdef FEAT_MZSCHEME\n    mzscheme_buffer_free(buf);\n#endif\n#ifdef FEAT_PERL\n    perl_buf_free(buf);\n#endif\n#ifdef FEAT_PYTHON\n    python_buffer_free(buf);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_buffer_free(buf);\n#endif\n#ifdef FEAT_RUBY\n    ruby_buffer_free(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    channel_buffer_free(buf);\n#endif\n#ifdef FEAT_TERMINAL\n    free_terminal(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    vim_free(buf->b_prompt_text);\n    free_callback(&buf->b_prompt_callback);\n    free_callback(&buf->b_prompt_interrupt);\n#endif\n\n    buf_hashtab_remove(buf);\n\n    aubuflocal_remove(buf);\n\n    if (autocmd_busy)\n    {\n\t// Do not free the buffer structure while autocommands are executing,\n\t// it's still needed. Free it when autocmd_busy is reset.\n\tbuf->b_next = au_pending_free_buf;\n\tau_pending_free_buf = buf;\n    }\n    else\n    {\n\tvim_free(buf);\n\tif (curbuf == buf)\n\t    curbuf = NULL;  // make clear it's not to be used\n    }\n}\n\n/*\n * Initializes b:changedtick.\n */\n    static void\ninit_changedtick(buf_T *buf)\n{\n    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;\n\n    di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;\n    di->di_tv.v_type = VAR_NUMBER;\n    di->di_tv.v_lock = VAR_FIXED;\n    di->di_tv.vval.v_number = 0;\n\n#ifdef FEAT_EVAL\n    STRCPY(buf->b_ct_di.di_key, \"changedtick\");\n    (void)dict_add(buf->b_vars, di);\n#endif\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\n    static void\nclear_wininfo(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    while (buf->b_wininfo != NULL)\n    {\n\twip = buf->b_wininfo;\n\tbuf->b_wininfo = wip->wi_next;\n\tfree_wininfo(wip);\n    }\n}\n\n/*\n * Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n */\n    static void\nfree_buffer_stuff(\n    buf_T\t*buf,\n    int\t\tfree_options)\t\t// free options as well\n{\n    if (free_options)\n    {\n\tclear_wininfo(buf);\t\t// including window-local options\n\tfree_buf_options(buf, TRUE);\n#ifdef FEAT_SPELL\n\tga_clear(&buf->b_s.b_langp);\n#endif\n    }\n#ifdef FEAT_EVAL\n    {\n\tvarnumber_T tick = CHANGEDTICK(buf);\n\n\tvars_clear(&buf->b_vars->dv_hashtab); // free all buffer variables\n\thash_init(&buf->b_vars->dv_hashtab);\n\tinit_changedtick(buf);\n\tCHANGEDTICK(buf) = tick;\n\tremove_listeners(buf);\n    }\n#endif\n    uc_clear(&buf->b_ucmds);\t\t// clear local user commands\n#ifdef FEAT_SIGNS\n    buf_delete_signs(buf, (char_u *)\"*\");\t// delete any signs\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_file_killed(buf);\n#endif\n#ifdef FEAT_PROP_POPUP\n    ga_clear_strings(&buf->b_textprop_text);\n#endif\n    map_clear_mode(buf, MAP_ALL_MODES, TRUE, FALSE);  // clear local mappings\n    map_clear_mode(buf, MAP_ALL_MODES, TRUE, TRUE);   // clear local abbrevs\n    VIM_CLEAR(buf->b_start_fenc);\n}\n\n/*\n * Free one wininfo_T.\n */\n    void\nfree_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\n    void\ngoto_buffer(\n    exarg_T\t*eap,\n    int\t\tstart,\n    int\t\tdir,\n    int\t\tcount)\n{\n    bufref_T\told_curbuf;\n    int\t\tsave_sea = swap_exists_action;\n\n    set_bufref(&old_curbuf, curbuf);\n\n    if (swap_exists_action == SEA_NONE)\n\tswap_exists_action = SEA_DIALOG;\n    (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n\t\t\t\t\t     start, dir, count, eap->forceit);\n    if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a window.\n\tenter_cleanup(&cs);\n#endif\n\n\t// Quitting means closing the split window, nothing else.\n\twin_close(curwin, TRUE);\n\tswap_exists_action = save_sea;\n\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else\n\thandle_swap_exists(&old_curbuf);\n}\n\n/*\n * Handle the situation of swap_exists_action being set.\n * It is allowed for \"old_curbuf\" to be NULL or invalid.\n */\n    void\nhandle_swap_exists(bufref_T *old_curbuf)\n{\n#if defined(FEAT_EVAL)\n    cleanup_T\tcs;\n#endif\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    buf_T\t*buf;\n\n    if (swap_exists_action == SEA_QUIT)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Quit at ATTENTION prompt.  Go back to previous\n\t// buffer.  If that buffer is gone or the same as the current one,\n\t// open a new, empty buffer.\n\tswap_exists_action = SEA_NONE;\t// don't want it again\n\tswap_exists_did_quit = TRUE;\n\tclose_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE, FALSE);\n\tif (old_curbuf == NULL || !bufref_valid(old_curbuf)\n\t\t\t\t\t      || old_curbuf->br_buf == curbuf)\n\t{\n\t    // Block autocommands here because curwin->w_buffer is NULL.\n\t    block_autocmds();\n\t    buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n\t    unblock_autocmds();\n\t}\n\telse\n\t    buf = old_curbuf->br_buf;\n\tif (buf != NULL)\n\t{\n\t    int old_msg_silent = msg_silent;\n\n\t    if (shortmess(SHM_FILEINFO))\n\t\tmsg_silent = 1;  // prevent fileinfo message\n\t    enter_buffer(buf);\n\t    // restore msg_silent, so that the command line will be shown\n\t    msg_silent = old_msg_silent;\n\n#ifdef FEAT_SYN_HL\n\t    if (old_tw != curbuf->b_p_tw)\n\t\tcheck_colorcolumn(curwin);\n#endif\n\t}\n\t// If \"old_curbuf\" is NULL we are in big trouble here...\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else if (swap_exists_action == SEA_RECOVER)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Recover at ATTENTION prompt.\n\tmsg_scroll = TRUE;\n\tml_recover(FALSE);\n\tmsg_puts(\"\\n\");\t// don't overwrite the last message\n\tcmdline_row = msg_row;\n\tdo_modelines(0);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    swap_exists_action = SEA_NONE;\n}\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\n    static int\nempty_curbuf(\n    int close_others,\n    int forceit,\n    int action)\n{\n    int\t    retval;\n    buf_T   *buf = curbuf;\n    bufref_T bufref;\n\n    if (action == DOBUF_UNLOAD)\n    {\n\temsg(_(e_cannot_unload_last_buffer));\n\treturn FAIL;\n    }\n\n    set_bufref(&bufref, buf);\n    if (close_others)\n\t// Close any other windows on this buffer, then make it empty.\n\tclose_windows(buf, TRUE);\n\n    setpcmark();\n    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n\t\t\t\t\t  forceit ? ECMD_FORCEIT : 0, curwin);\n\n    // do_ecmd() may create a new buffer, then we have to delete\n    // the old one.  But do_ecmd() may have done that already, check\n    // if the buffer still exists.\n    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)\n\tclose_buffer(NULL, buf, action, FALSE, FALSE);\n    if (!close_others)\n\tneed_fileinfo = FALSE;\n    return retval;\n}\n\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n * action == DOBUF_WIPE_REUSE idem, and add number to \"buf_reuse\"\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\n    static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf) && !bt_terminal(buf))\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl || bt_quickfix(buf))\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n\t\t\t    && !bt_quickfix(buf))\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf && !bt_quickfix(buf))\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}\n\n    int\ndo_buffer(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tforceit)\t// TRUE when using !\n{\n    return do_buffer_ext(action, start, dir, count,\n\t\t\t\t\t\t  forceit ? DOBUF_FORCEIT : 0);\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\n    char *\ndo_bufdel(\n    int\t\tcommand,\n    char_u\t*arg,\t\t// pointer to extra arguments\n    int\t\taddr_count,\n    int\t\tstart_bnr,\t// first buffer number in a range\n    int\t\tend_bnr,\t// buffer nr or last buffer nr in a range\n    int\t\tforceit)\n{\n    int\t\tdo_current = 0;\t// delete current buffer?\n    int\t\tdeleted = 0;\t// number of buffers deleted\n    char\t*errormsg = NULL; // return value\n    int\t\tbnr;\t\t// buffer number\n    char_u\t*p;\n\n    if (addr_count == 0)\n    {\n\t(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n    }\n    else\n    {\n\tif (addr_count == 2)\n\t{\n\t    if (*arg)\t\t// both range and argument is not allowed\n\t\treturn ex_errmsg(e_trailing_characters_str, arg);\n\t    bnr = start_bnr;\n\t}\n\telse\t// addr_count == 1\n\t    bnr = end_bnr;\n\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    // Delete the current buffer last, otherwise when the\n\t    // current buffer is deleted, the next buffer becomes\n\t    // the current one and will be loaded, which may then\n\t    // also be deleted, etc.\n\t    if (bnr == curbuf->b_fnum)\n\t\tdo_current = bnr;\n\t    else if (do_buffer_ext(command, DOBUF_FIRST, FORWARD, bnr,\n\t\t\t  DOBUF_NOPOPUP | (forceit ? DOBUF_FORCEIT : 0)) == OK)\n\t\t++deleted;\n\n\t    // find next buffer number to delete/unload\n\t    if (addr_count == 2)\n\t    {\n\t\tif (++bnr > end_bnr)\n\t\t    break;\n\t    }\n\t    else    // addr_count == 1\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (*arg == NUL)\n\t\t    break;\n\t\tif (!VIM_ISDIGIT(*arg))\n\t\t{\n\t\t    p = skiptowhite_esc(arg);\n\t\t    bnr = buflist_findpat(arg, p,\n\t\t\t  command == DOBUF_WIPE || command == DOBUF_WIPE_REUSE,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t    if (bnr < 0)\t    // failed\n\t\t\tbreak;\n\t\t    arg = p;\n\t\t}\n\t\telse\n\t\t    bnr = getdigits(&arg);\n\t    }\n\t}\n\tif (!got_int && do_current && do_buffer(command, DOBUF_FIRST,\n\t\t\t\t\t  FORWARD, do_current, forceit) == OK)\n\t    ++deleted;\n\n\tif (deleted == 0)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_unloaded));\n\t    else if (command == DOBUF_DEL)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_deleted));\n\t    else\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_wiped_out));\n\t    errormsg = (char *)IObuff;\n\t}\n\telse if (deleted >= p_report)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tsmsg(NGETTEXT(\"%d buffer unloaded\",\n\t\t\t    \"%d buffers unloaded\", deleted), deleted);\n\t    else if (command == DOBUF_DEL)\n\t\tsmsg(NGETTEXT(\"%d buffer deleted\",\n\t\t\t    \"%d buffers deleted\", deleted), deleted);\n\t    else\n\t\tsmsg(NGETTEXT(\"%d buffer wiped out\",\n\t\t\t    \"%d buffers wiped out\", deleted), deleted);\n\t}\n    }\n\n\n    return errormsg;\n}\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n * DOBUF_WIPE_REUSE wipe it out and add to \"buf_reuse\"\n */\n    void\nset_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n    int\t\tvalid;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t    && ((State & MODE_INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    valid = buf_valid(buf);\n    if ((valid && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\t// If the buffer is not valid but curwin->w_buffer is NULL we must\n\t// enter some buffer.  Using the last one is hopefully OK.\n\tif (!valid)\n\t    enter_buffer(lastbuf);\n\telse\n\t    enter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\n    static void\nenter_buffer(buf_T *buf)\n{\n    // when closing the current buffer stop Visual mode\n    if (VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Get the buffer in the current window.\n    curwin->w_buffer = buf;\n    curbuf = buf;\n    ++curbuf->b_nwindows;\n\n    // Copy buffer and window local option values.  Not for a help buffer.\n    buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n    if (!buf->b_help)\n\tget_winopts(buf);\n#ifdef FEAT_FOLDING\n    else\n\t// Remove all folds in the window.\n\tclearFolding(curwin);\n    foldUpdateAll(curwin);\t// update folds (later).\n#endif\n\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff)\n\tdiff_buf_add(curbuf);\n#endif\n\n#ifdef FEAT_SYN_HL\n    curwin->w_s = &(curbuf->b_s);\n#endif\n\n    // Cursor on first line by default.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n    curwin->w_topline_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,\n\t\t\t\t\t      curbuf->b_last_cursor.col, TRUE);\n\n    // Make sure the buffer is loaded.\n    if (curbuf->b_ml.ml_mfp == NULL)\t// need to load the file\n    {\n\t// If there is no filetype, allow for detecting one.  Esp. useful for\n\t// \":ball\" used in an autocommand.  If there already is a filetype we\n\t// might prefer to keep it.\n\tif (*curbuf->b_p_ft == NUL)\n\t    did_filetype = FALSE;\n\n\topen_buffer(FALSE, NULL, 0);\n    }\n    else\n    {\n\tif (!msg_silent && !shortmess(SHM_FILEINFO))\n\t    need_fileinfo = TRUE;\t// display file info after redraw\n\n\t// check if file changed\n\t(void)buf_check_timestamp(curbuf, FALSE);\n\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n\tapply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    // If autocommands did not change the cursor position, restore cursor lnum\n    // and possibly cursor col.\n    if (curwin->w_cursor.lnum == 1 && inindent(0))\n\tbuflist_getfpos();\n\n    check_arg_idx(curwin);\t\t// check for valid arg_idx\n    maketitle();\n\t// when autocmds didn't change it\n    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)\n\tscroll_cursor_halfway(FALSE);\t// redisplay at correct position\n\n#ifdef FEAT_NETBEANS_INTG\n    // Send fileOpened event because we've changed buffers.\n    netbeans_file_activated(curbuf);\n#endif\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n#ifdef FEAT_SPELL\n    // May need to set the spell language.  Can only do this after the buffer\n    // has been properly setup.\n    if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    redraw_later(UPD_NOT_VALID);\n}\n\n#if defined(FEAT_AUTOCHDIR) || defined(PROTO)\n/*\n * Change to the directory of the current buffer.\n * Don't do this while still starting up.\n */\n    void\ndo_autochdir(void)\n{\n    if ((starting == 0 || test_autochdir)\n\t    && curbuf->b_ffname != NULL\n\t    && vim_chdirfile(curbuf->b_ffname, \"auto\") == OK)\n    {\n\tshorten_fnames(TRUE);\n\tlast_chdir_reason = \"autochdir\";\n    }\n}\n#endif\n\n    void\nno_write_message(void)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(curbuf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change_add_bang_to_override));\n}\n\n    void\nno_write_message_nobang(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change));\n}\n\n/*\n * functions for dealing with the buffer list\n */\n\n/*\n * Return TRUE if the current buffer is empty, unnamed, unmodified and used in\n * only one window.  That means it can be re-used.\n */\n    int\ncurbuf_reusable(void)\n{\n    return (curbuf != NULL\n\t&& curbuf->b_ffname == NULL\n\t&& curbuf->b_nwindows <= 1\n\t&& (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY())\n\t&& !bt_quickfix(curbuf)\n\t&& !curbufIsChanged());\n}\n\n/*\n * Add a file name to the buffer list.  Return a pointer to the buffer.\n * If the same file name already exists return a pointer to that buffer.\n * If it does not exist, or if fname == NULL, a new entry is created.\n * If (flags & BLN_CURBUF) is TRUE, may use current buffer.\n * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.\n * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.\n * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.\n * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer\n *\t\t\t\t    if the buffer already exists.\n * If (flags & BLN_REUSE) is TRUE, may use buffer number from \"buf_reuse\".\n * This is the ONLY way to create a new buffer.\n */\n    buf_T *\nbuflist_new(\n    char_u\t*ffname_arg,\t// full path of fname or relative\n    char_u\t*sfname_arg,\t// short fname or NULL\n    linenr_T\tlnum,\t\t// preferred cursor line\n    int\t\tflags)\t\t// BLN_ defines\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*buf;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (top_file_num == 1)\n\thash_init(&buf_hashtab);\n\n    fname_expand(curbuf, &ffname, &sfname);\t// will allocate ffname\n\n    /*\n     * If the file name already exists in the list, update the entry.\n     */\n#ifdef UNIX\n    // On Unix we can use inode numbers when the file exists.  Works better\n    // for hard links.\n    if (sfname == NULL || mch_stat((char *)sfname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n#endif\n    if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW)) && (buf =\n#ifdef UNIX\n\t\tbuflist_findname_stat(ffname, &st)\n#else\n\t\tbuflist_findname(ffname)\n#endif\n\t\t) != NULL)\n    {\n\tvim_free(ffname);\n\tif (lnum != 0)\n\t    buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n\t\t\t\t\t\t      lnum, (colnr_T)0, FALSE);\n\n\tif ((flags & BLN_NOOPT) == 0)\n\t    // copy the options now, if 'cpo' doesn't have 's' and not done\n\t    // already\n\t    buf_copy_options(buf, 0);\n\n\tif ((flags & BLN_LISTED) && !buf->b_p_bl)\n\t{\n\t    bufref_T bufref;\n\n\t    buf->b_p_bl = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    if (!(flags & BLN_DUMMY))\n\t    {\n\t\tif (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t\t&& !bufref_valid(&bufref))\n\t\t    return NULL;\n\t    }\n\t}\n\treturn buf;\n    }\n\n    /*\n     * If the current buffer has no name and no contents, use the current\n     * buffer.\tOtherwise: Need to allocate a new buffer structure.\n     *\n     * This is the ONLY place where a new buffer structure is allocated!\n     * (A spell file buffer is allocated in spell.c, but that's not a normal\n     * buffer.)\n     */\n    buf = NULL;\n    if ((flags & BLN_CURBUF) && curbuf_reusable())\n    {\n\tbuf = curbuf;\n\t// It's like this buffer is deleted.  Watch out for autocommands that\n\t// change curbuf!  If that happens, allocate a new buffer anyway.\n\tbuf_freeall(buf, BFA_WIPE | BFA_DEL);\n\tif (buf != curbuf)   // autocommands deleted the buffer!\n\t    return NULL;\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#endif\n    }\n    if (buf != curbuf || curbuf == NULL)\n    {\n\tbuf = ALLOC_CLEAR_ONE(buf_T);\n\tif (buf == NULL)\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#ifdef FEAT_EVAL\n\t// init b: variables\n\tbuf->b_vars = dict_alloc_id(aid_newbuf_bvars);\n\tif (buf->b_vars == NULL)\n\t{\n\t    vim_free(ffname);\n\t    vim_free(buf);\n\t    return NULL;\n\t}\n\tinit_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n#endif\n\tinit_changedtick(buf);\n    }\n\n    if (ffname != NULL)\n    {\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = vim_strsave(sfname);\n    }\n\n    clear_wininfo(buf);\n    buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);\n\n    if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))\n\t    || buf->b_wininfo == NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf != curbuf)\n\t    free_buffer(buf);\n\treturn NULL;\n    }\n\n    if (buf == curbuf)\n    {\n\tfree_buffer_stuff(buf, FALSE);\t// delete local variables et al.\n\n\t// Init the options.\n\tbuf->b_p_initialized = FALSE;\n\tbuf_copy_options(buf, BCO_ENTER);\n\n#ifdef FEAT_KEYMAP\n\t// need to reload lmaps and set b:keymap_name\n\tcurbuf->b_kmap_state |= KEYMAP_INIT;\n#endif\n    }\n    else\n    {\n\t// put the new buffer at the end of the buffer list\n\tbuf->b_next = NULL;\n\tif (firstbuf == NULL)\t\t// buffer list is empty\n\t{\n\t    buf->b_prev = NULL;\n\t    firstbuf = buf;\n\t}\n\telse\t\t\t\t// append new buffer at end of list\n\t{\n\t    lastbuf->b_next = buf;\n\t    buf->b_prev = lastbuf;\n\t}\n\tlastbuf = buf;\n\n\tif ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)\n\t{\n\t    // Recycle a previously used buffer number.  Used for buffers which\n\t    // are normally hidden, e.g. in a popup window.  Avoids that the\n\t    // buffer number grows rapidly.\n\t    --buf_reuse.ga_len;\n\t    buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];\n\n\t    // Move buffer to the right place in the buffer list.\n\t    while (buf->b_prev != NULL && buf->b_fnum < buf->b_prev->b_fnum)\n\t    {\n\t\tbuf_T\t*prev = buf->b_prev;\n\n\t\tprev->b_next = buf->b_next;\n\t\tif (prev->b_next != NULL)\n\t\t    prev->b_next->b_prev = prev;\n\t\tbuf->b_next = prev;\n\t\tbuf->b_prev = prev->b_prev;\n\t\tif (buf->b_prev != NULL)\n\t\t    buf->b_prev->b_next = buf;\n\t\tprev->b_prev = buf;\n\t\tif (lastbuf == buf)\n\t\t    lastbuf = prev;\n\t\tif (firstbuf == prev)\n\t\t    firstbuf = buf;\n\t    }\n\t}\n\telse\n\t    buf->b_fnum = top_file_num++;\n\tif (top_file_num < 0)\t\t// wrap around (may cause duplicates)\n\t{\n\t    emsg(_(\"W14: Warning: List of file names overflow\"));\n\t    if (emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(3001L, TRUE);\t// make sure it is noticed\n\t    }\n\t    top_file_num = 1;\n\t}\n\tbuf_hashtab_add(buf);\n\n\t// Always copy the options from the current buffer.\n\tbuf_copy_options(buf, BCO_ALWAYS);\n    }\n\n    buf->b_wininfo->wi_fpos.lnum = lnum;\n    buf->b_wininfo->wi_win = curwin;\n\n#ifdef FEAT_SYN_HL\n    hash_init(&buf->b_s.b_keywtab);\n    hash_init(&buf->b_s.b_keywtab_ic);\n#endif\n\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n    buf->b_u_synced = TRUE;\n    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n    if (flags & BLN_DUMMY)\n\tbuf->b_flags |= BF_DUMMY;\n    buf_clear_file(buf);\n    clrallmarks(buf);\t\t\t// clear marks\n    fmarks_check_names(buf);\t\t// check file marks for this file\n    buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;\t// init 'buflisted'\n    if (!(flags & BLN_DUMMY))\n    {\n\tbufref_T bufref;\n\n\t// Tricky: these autocommands may change the buffer list.  They could\n\t// also split the window with re-using the one empty buffer. This may\n\t// result in unexpectedly losing the empty buffer.\n\tset_bufref(&bufref, buf);\n\tif (apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    return NULL;\n\tif (flags & BLN_LISTED)\n\t{\n\t    if (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\treturn NULL;\n\t}\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n    }\n\n    return buf;\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is TRUE also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\n    void\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    VIM_CLEAR(buf->b_p_vsts_array);\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n    clear_string_option(&buf->b_p_sua);\n    clear_string_option(&buf->b_p_ft);\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n    clear_string_option(&buf->b_p_cinsd);\n    clear_string_option(&buf->b_p_cinw);\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n    clear_string_option(&buf->b_p_qe);\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    clear_string_option(&buf->b_p_lw);\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n\n/*\n * Get alternate file \"n\".\n * Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n *\tAlso set cursor column to altfpos.col if 'startofline' is not set.\n * if (options & GETF_SETMARK) call setpcmark()\n * if (options & GETF_ALT) we are jumping to an alternate file.\n * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n *\n * Return FAIL for failure, OK for success.\n */\n    int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_or_buf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}\n\n/*\n * go to the last know line number for the current buffer\n */\n    static void\nbuflist_getfpos(void)\n{\n    pos_T\t*fpos;\n\n    fpos = buflist_findfpos(curbuf);\n\n    curwin->w_cursor.lnum = fpos->lnum;\n    check_cursor_lnum();\n\n    if (p_sol)\n\tcurwin->w_cursor.col = 0;\n    else\n    {\n\tcurwin->w_cursor.col = fpos->col;\n\tcheck_cursor_col();\n\tcurwin->w_cursor.coladd = 0;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname_exp(char_u *fname)\n{\n    char_u\t*ffname;\n    buf_T\t*buf = NULL;\n\n    // First make the name into a full path name\n    ffname = FullName_save(fname,\n#ifdef UNIX\n\t    TRUE\t    // force expansion, get rid of symbolic links\n#else\n\t    FALSE\n#endif\n\t    );\n    if (ffname != NULL)\n    {\n\tbuf = buflist_findname(ffname);\n\tvim_free(ffname);\n    }\n    return buf;\n}\n#endif\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname(char_u *ffname)\n{\n#ifdef UNIX\n    stat_T\tst;\n\n    if (mch_stat((char *)ffname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n    return buflist_findname_stat(ffname, &st);\n}\n\n/*\n * Same as buflist_findname(), but pass the stat structure to avoid getting it\n * twice for the same file.\n * Returns NULL if not found.\n */\n    static buf_T *\nbuflist_findname_stat(\n    char_u\t*ffname,\n    stat_T\t*stp)\n{\n#endif\n    buf_T\t*buf;\n\n    // Start at the last buffer, expect to find a match sooner.\n    FOR_ALL_BUFS_FROM_LAST(buf)\n\tif ((buf->b_flags & BF_DUMMY) == 0 && !otherfile_buf(buf, ffname\n#ifdef UNIX\n\t\t    , stp\n#endif\n\t\t    ))\n\t    return buf;\n    return NULL;\n}\n\n/*\n * Find file in buffer list by a regexp pattern.\n * Return fnum of the found buffer.\n * Return < 0 for error.\n */\n    int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}\n\n#ifdef FEAT_VIMINFO\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n#endif\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n\n/*\n * Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n */\n    static char_u *\nbuflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL && rmp->regprog != NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n\n/*\n * Try matching the regexp in \"rmp->regprog\" with file name \"name\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n * Return \"name\" when there is a match, NULL when not.\n */\n    static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    // extra check for valid arguments\n    if (name != NULL && rmp->regprog != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n\n/*\n * Find a file in the buffer list by buffer number.\n */\n    buf_T *\nbuflist_findnr(int nr)\n{\n    char_u\tkey[VIM_SIZEOF_INT * 2 + 1];\n    hashitem_T\t*hi;\n\n    if (nr == 0)\n\tnr = curwin->w_alt_fnum;\n    sprintf((char *)key, \"%x\", nr);\n    hi = hash_find(&buf_hashtab, key);\n\n    if (!HASHITEM_EMPTY(hi))\n\treturn (buf_T *)(hi->hi_key\n\t\t\t     - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));\n    return NULL;\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\n    char_u *\nbuflist_nr2name(\n    int\t\tn,\n    int\t\tfullname,\n    int\t\thelptail)\t// for help buffers return tail only\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n\treturn NULL;\n    return home_replace_save(helptail ? buf : NULL,\n\t\t\t\t     fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/*\n * Set the \"lnum\" and \"col\" for the buffer \"buf\" and the current window.\n * When \"copy_options\" is TRUE save the local window option values.\n * When \"lnum\" is 0 only do the options.\n */\n    void\nbuflist_setfpos(\n    buf_T\t*buf,\n    win_T\t*win,\t\t// may be NULL when using :badd\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    int\t\tcopy_options)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == win)\n\t    break;\n    if (wip == NULL)\n    {\n\t// allocate a new entry\n\twip = ALLOC_CLEAR_ONE(wininfo_T);\n\tif (wip == NULL)\n\t    return;\n\twip->wi_win = win;\n\tif (lnum == 0)\t\t// set lnum even when it's 0\n\t    lnum = 1;\n    }\n    else\n    {\n\t// remove the entry from the list\n\tif (wip->wi_prev)\n\t    wip->wi_prev->wi_next = wip->wi_next;\n\telse\n\t    buf->b_wininfo = wip->wi_next;\n\tif (wip->wi_next)\n\t    wip->wi_next->wi_prev = wip->wi_prev;\n\tif (copy_options && wip->wi_optset)\n\t{\n\t    clear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\t    deleteFoldRecurse(&wip->wi_folds);\n#endif\n\t}\n    }\n    if (lnum != 0)\n    {\n\twip->wi_fpos.lnum = lnum;\n\twip->wi_fpos.col = col;\n    }\n    if (win != NULL)\n\twip->wi_changelistidx = win->w_changelistidx;\n    if (copy_options && win != NULL)\n    {\n\t// Save the window-specific option values.\n\tcopy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n#ifdef FEAT_FOLDING\n\twip->wi_fold_manual = win->w_fold_manual;\n\tcloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n#endif\n\twip->wi_optset = TRUE;\n    }\n\n    // insert the entry in front of the list\n    wip->wi_next = buf->b_wininfo;\n    buf->b_wininfo = wip;\n    wip->wi_prev = NULL;\n    if (wip->wi_next)\n\twip->wi_next->wi_prev = wip;\n}\n\n#ifdef FEAT_DIFF\n/*\n * Return TRUE when \"wip\" has 'diff' set and the diff is only for another tab\n * page.  That's because a diff is local to a tab page.\n */\n    static int\nwininfo_other_tab_diff(wininfo_T *wip)\n{\n    win_T\t*wp;\n\n    if (wip->wi_opt.wo_diff)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    // return FALSE when it's a window in the current tab page, thus\n\t    // the buffer was in diff mode here\n\t    if (wip->wi_win == wp)\n\t\treturn FALSE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Find info for the current window in buffer \"buf\".\n * If not found, return the info for the most recently used window.\n * When \"need_options\" is TRUE skip entries where wi_optset is FALSE.\n * When \"skip_diff_buffer\" is TRUE avoid windows with 'diff' set that is in\n * another tab page.\n * Returns NULL when there isn't any info.\n */\n    static wininfo_T *\nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\n    void\nget_winopts(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    clear_winopt(&curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n    clearFolding(curwin);\n#endif\n\n    wip = find_wininfo(buf, TRUE, TRUE);\n    if (wip != NULL && wip->wi_win != NULL\n\t    && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)\n    {\n\t// The buffer is currently displayed in the window: use the actual\n\t// option values instead of the saved (possibly outdated) values.\n\twin_T *wp = wip->wi_win;\n\n\tcopy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wp->w_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n#endif\n    }\n    else if (wip != NULL && wip->wi_optset)\n    {\n\t// the buffer was displayed in the current window earlier\n\tcopy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wip->wi_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n#endif\n    }\n    else\n\tcopy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n    if (wip != NULL)\n\tcurwin->w_changelistidx = wip->wi_changelistidx;\n\n#ifdef FEAT_FOLDING\n    // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n    if (p_fdls >= 0)\n\tcurwin->w_p_fdl = p_fdls;\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\n    pos_T *\nbuflist_findfpos(buf_T *buf)\n{\n    wininfo_T\t*wip;\n    static pos_T no_position = {1, 0, 0};\n\n    wip = find_wininfo(buf, FALSE, FALSE);\n    if (wip != NULL)\n\treturn &(wip->wi_fpos);\n    else\n\treturn &no_position;\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\n    linenr_T\nbuflist_findlnum(buf_T *buf)\n{\n    return buflist_findfpos(buf)->lnum;\n}\n\n/*\n * List all known file names (for :files and :buffers command).\n */\n    void\nbuflist_list(exarg_T *eap)\n{\n    buf_T\t*buf = firstbuf;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tro_char;\n    int\t\tchanged_char;\n#ifdef FEAT_TERMINAL\n    int\t\tjob_running;\n    int\t\tjob_none_open;\n#endif\n\n#ifdef FEAT_VIMINFO\n    garray_T\tbuflist;\n    buf_T\t**buflist_data = NULL, **p;\n\n    if (vim_strchr(eap->arg, 't'))\n    {\n\tga_init2(&buflist, sizeof(buf_T *), 50);\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (ga_grow(&buflist, 1) == OK)\n\t\t((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n\t}\n\n\tqsort(buflist.ga_data, (size_t)buflist.ga_len,\n\t\tsizeof(buf_T *), buf_compare);\n\n\tbuflist_data = (buf_T **)buflist.ga_data;\n\tbuf = *buflist_data;\n    }\n    p = buflist_data;\n\n    for (; buf != NULL && !got_int; buf = buflist_data != NULL\n\t    ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n\t    : buf->b_next)\n#else\n    for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next)\n#endif\n    {\n#ifdef FEAT_TERMINAL\n\tjob_running = term_job_running(buf->b_term);\n\tjob_none_open = term_none_open(buf->b_term);\n#endif\n\t// skip unlisted buffers, unless ! was used\n\tif ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))\n\t\t|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl)\n\t\t|| (vim_strchr(eap->arg, '+')\n\t\t\t&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n\t\t|| (vim_strchr(eap->arg, 'a')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n\t\t|| (vim_strchr(eap->arg, 'h')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n#ifdef FEAT_TERMINAL\n\t\t|| (vim_strchr(eap->arg, 'R')\n\t\t\t&& (!job_running || (job_running && job_none_open)))\n\t\t|| (vim_strchr(eap->arg, '?')\n\t\t\t&& (!job_running || (job_running && !job_none_open)))\n\t\t|| (vim_strchr(eap->arg, 'F')\n\t\t\t&& (job_running || buf->b_term == NULL))\n#endif\n\t\t|| (vim_strchr(eap->arg, '-') && buf->b_p_ma)\n\t\t|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro)\n\t\t|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n\t\t|| (vim_strchr(eap->arg, '%') && buf != curbuf)\n\t\t|| (vim_strchr(eap->arg, '#')\n\t\t      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))\n\t    continue;\n\tif (buf_spname(buf) != NULL)\n\t    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n\telse\n\t    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n\tif (message_filtered(NameBuff))\n\t    continue;\n\n\tchanged_char = (buf->b_flags & BF_READERR) ? 'x'\n\t\t\t\t\t     : (bufIsChanged(buf) ? '+' : ' ');\n#ifdef FEAT_TERMINAL\n\tif (job_running)\n\t{\n\t    if (job_none_open)\n\t\tro_char = '?';\n\t    else\n\t\tro_char = 'R';\n\t    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid\n\t\t\t\t // closing, but it's not actually changed.\n\t}\n\telse if (buf->b_term != NULL)\n\t    ro_char = 'F';\n\telse\n#endif\n\t    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');\n\n\tmsg_putchar('\\n');\n\tlen = vim_snprintf((char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n\t\tbuf->b_fnum,\n\t\tbuf->b_p_bl ? ' ' : 'u',\n\t\tbuf == curbuf ? '%' :\n\t\t\t(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n\t\tbuf->b_ml.ml_mfp == NULL ? ' ' :\n\t\t\t(buf->b_nwindows == 0 ? 'h' : 'a'),\n\t\tro_char,\n\t\tchanged_char,\n\t\tNameBuff);\n\tif (len > IOSIZE - 20)\n\t    len = IOSIZE - 20;\n\n\t// put \"line 999\" in column 40 or after the file name\n\ti = 40 - vim_strsize(IObuff);\n\tdo\n\t    IObuff[len++] = ' ';\n\twhile (--i > 0 && len < IOSIZE - 18);\n#ifdef FEAT_VIMINFO\n\tif (vim_strchr(eap->arg, 't') && buf->b_last_used)\n\t    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n\t\t    _(\"line %ld\"), buf == curbuf ? curwin->w_cursor.lnum\n\t\t\t\t\t       : (long)buflist_findlnum(buf));\n\tmsg_outtrans(IObuff);\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n    }\n\n#ifdef FEAT_VIMINFO\n    if (buflist_data)\n\tga_clear(&buflist);\n#endif\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\n    int\nbuflist_name_nr(\n    int\t\tfnum,\n    char_u\t**fname,\n    linenr_T\t*lnum)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL || buf->b_fname == NULL)\n\treturn FAIL;\n\n    *fname = buf->b_fname;\n    *lnum = buflist_findlnum(buf);\n\n    return OK;\n}\n\n/*\n * Set the file name for \"buf\"' to \"ffname_arg\", short file name to\n * \"sfname_arg\".\n * The file name with the full path is also remembered, for when :cd is used.\n * Returns FAIL for failure (file name already in use by other buffer)\n *\tOK otherwise.\n */\n    int\nsetfname(\n    buf_T\t*buf,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tmessage)\t// give message when buffer already exists\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*obuf = NULL;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (ffname == NULL || *ffname == NUL)\n    {\n\t// Removing the name.\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n#ifdef UNIX\n\tst.st_dev = (dev_T)-1;\n#endif\n    }\n    else\n    {\n\tfname_expand(buf, &ffname, &sfname); // will allocate ffname\n\tif (ffname == NULL)\t\t    // out of memory\n\t    return FAIL;\n\n\t/*\n\t * If the file name is already used in another buffer:\n\t * - if the buffer is loaded, fail\n\t * - if the buffer is not loaded, delete it from the list\n\t */\n#ifdef UNIX\n\tif (mch_stat((char *)ffname, &st) < 0)\n\t    st.st_dev = (dev_T)-1;\n#endif\n\tif (!(buf->b_flags & BF_DUMMY))\n#ifdef UNIX\n\t    obuf = buflist_findname_stat(ffname, &st);\n#else\n\t    obuf = buflist_findname(ffname);\n#endif\n\tif (obuf != NULL && obuf != buf)\n\t{\n\t    win_T\t*win;\n\t    tabpage_T   *tab;\n\t    int\t\tin_use = FALSE;\n\n\t    // during startup a window may use a buffer that is not loaded yet\n\t    FOR_ALL_TAB_WINDOWS(tab, win)\n\t\tif (win->w_buffer == obuf)\n\t\t    in_use = TRUE;\n\n\t    // it's loaded or used in a window, fail\n\t    if (obuf->b_ml.ml_mfp != NULL || in_use)\n\t    {\n\t\tif (message)\n\t\t    emsg(_(e_buffer_with_this_name_already_exists));\n\t\tvim_free(ffname);\n\t\treturn FAIL;\n\t    }\n\t    // delete from the list\n\t    close_buffer(NULL, obuf, DOBUF_WIPE, FALSE, FALSE);\n\t}\n\tsfname = vim_strsave(sfname);\n\tif (ffname == NULL || sfname == NULL)\n\t{\n\t    vim_free(sfname);\n\t    vim_free(ffname);\n\t    return FAIL;\n\t}\n#ifdef USE_FNAME_CASE\n\tfname_case(sfname, 0);    // set correct case for short file name\n#endif\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = sfname;\n    }\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n\n    buf->b_shortname = FALSE;\n\n    buf_name_changed(buf);\n    return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\n    void\nbuf_set_name(int fnum, char_u *name)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf != NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = vim_strsave(name);\n\tbuf->b_sfname = NULL;\n\t// Allocate ffname and expand into full path.  Also resolves .lnk\n\t// files on Win32.\n\tfname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n\tbuf->b_fname = buf->b_sfname;\n    }\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\n    void\nbuf_name_changed(buf_T *buf)\n{\n    /*\n     * If the file name changed, also change the name of the swapfile\n     */\n    if (buf->b_ml.ml_mfp != NULL)\n\tml_setname(buf);\n\n#ifdef FEAT_TERMINAL\n    if (buf->b_term != NULL)\n\tterm_clear_status_text(buf->b_term);\n#endif\n\n    if (curwin->w_buffer == buf)\n\tcheck_arg_idx(curwin);\t// check file name for arg list\n    maketitle();\t\t// set window title\n    status_redraw_all();\t// status lines need to be redrawn\n    fmarks_check_names(buf);\t// check named file marks\n    ml_timestamp(buf);\t\t// reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\n    buf_T *\nsetaltfname(\n    char_u\t*ffname,\n    char_u\t*sfname,\n    linenr_T\tlnum)\n{\n    buf_T\t*buf;\n\n    // Create a buffer.  'buflisted' is not set if it's a new buffer\n    buf = buflist_new(ffname, sfname, lnum, 0);\n    if (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = buf->b_fnum;\n    return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\n    char_u  *\ngetaltfname(\n    int\t\terrmsg)\t\t// give error message\n{\n    char_u\t*fname;\n    linenr_T\tdummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) == FAIL)\n    {\n\tif (errmsg)\n\t    emsg(_(e_no_alternate_file));\n\treturn NULL;\n    }\n    return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\n    int\nbuflist_add(char_u *fname, int flags)\n{\n    buf_T\t*buf;\n\n    buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n    if (buf != NULL)\n\treturn buf->b_fnum;\n    return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\n    void\nbuflist_slash_adjust(void)\n{\n    buf_T\t*bp;\n\n    FOR_ALL_BUFFERS(bp)\n    {\n\tif (bp->b_ffname != NULL)\n\t    slash_adjust(bp->b_ffname);\n\tif (bp->b_sfname != NULL)\n\t    slash_adjust(bp->b_sfname);\n    }\n}\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\n    void\nbuflist_altfpos(win_T *win)\n{\n    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);\n}\n\n/*\n * Return TRUE if 'ffname' is not the same file as current file.\n * Fname must have a full path (expanded by mch_FullName()).\n */\n    int\notherfile(char_u *ffname)\n{\n    return otherfile_buf(curbuf, ffname\n#ifdef UNIX\n\t    , NULL\n#endif\n\t    );\n}\n\n    static int\notherfile_buf(\n    buf_T\t\t*buf,\n    char_u\t\t*ffname\n#ifdef UNIX\n    , stat_T\t\t*stp\n#endif\n    )\n{\n    // no name is different\n    if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)\n\treturn TRUE;\n    if (fnamecmp(ffname, buf->b_ffname) == 0)\n\treturn FALSE;\n#ifdef UNIX\n    {\n\tstat_T\t    st;\n\n\t// If no stat_T given, get it now\n\tif (stp == NULL)\n\t{\n\t    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)\n\t\tst.st_dev = (dev_T)-1;\n\t    stp = &st;\n\t}\n\t// Use dev/ino to check if the files are the same, even when the names\n\t// are different (possible with links).  Still need to compare the\n\t// name above, for when the file doesn't exist yet.\n\t// Problem: The dev/ino changes when a file is deleted (and created\n\t// again) and remains the same when renamed/moved.  We don't want to\n\t// mch_stat() each buffer each time, that would be too slow.  Get the\n\t// dev/ino again when they appear to match, but not when they appear\n\t// to be different: Could skip a buffer when it's actually the same\n\t// file.\n\tif (buf_same_ino(buf, stp))\n\t{\n\t    buf_setino(buf);\n\t    if (buf_same_ino(buf, stp))\n\t\treturn FALSE;\n\t}\n    }\n#endif\n    return TRUE;\n}\n\n#if defined(UNIX) || defined(PROTO)\n/*\n * Set inode and device number for a buffer.\n * Must always be called when b_fname is changed!.\n */\n    void\nbuf_setino(buf_T *buf)\n{\n    stat_T\tst;\n\n    if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n    else\n\tbuf->b_dev_valid = FALSE;\n}\n\n/*\n * Return TRUE if dev/ino in buffer \"buf\" matches with \"stp\".\n */\n    static int\nbuf_same_ino(\n    buf_T\t*buf,\n    stat_T\t*stp)\n{\n    return (buf->b_dev_valid\n\t    && stp->st_dev == buf->b_dev\n\t    && stp->st_ino == buf->b_ino);\n}\n#endif\n\n/*\n * Print info about the current buffer.\n */\n    void\nfileinfo(\n    int fullname,\t    // when non-zero print full path\n    int shorthelp,\n    int\tdont_truncate)\n{\n    char_u\t*name;\n    int\t\tn;\n    char\t*p;\n    char\t*buffer;\n    size_t\tlen;\n\n    buffer = alloc(IOSIZE);\n    if (buffer == NULL)\n\treturn;\n\n    if (fullname > 1)\t    // 2 CTRL-G: include buffer number\n    {\n\tvim_snprintf(buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n\tp = buffer + STRLEN(buffer);\n    }\n    else\n\tp = buffer;\n\n    *p++ = '\"';\n    if (buf_spname(curbuf) != NULL)\n\tvim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);\n    else\n    {\n\tif (!fullname && curbuf->b_fname != NULL)\n\t    name = curbuf->b_fname;\n\telse\n\t    name = curbuf->b_ffname;\n\thome_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,\n\t\t\t\t\t  (int)(IOSIZE - (p - buffer)), TRUE);\n    }\n\n    vim_snprintf_add(buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n\t    curbufIsChanged() ? (shortmess(SHM_MOD)\n\t\t\t\t\t  ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n\t    (curbuf->b_flags & BF_NOTEDITED) && !bt_dontwrite(curbuf)\n\t\t\t\t\t? _(\"[Not edited]\") : \"\",\n\t    (curbuf->b_flags & BF_NEW) && !bt_dontwrite(curbuf)\n\t\t\t\t\t   ? new_file_message() : \"\",\n\t    (curbuf->b_flags & BF_READERR) ? _(\"[Read errors]\") : \"\",\n\t    curbuf->b_p_ro ? (shortmess(SHM_RO) ? _(\"[RO]\")\n\t\t\t\t\t\t      : _(\"[readonly]\")) : \"\",\n\t    (curbufIsChanged() || (curbuf->b_flags & BF_WRITE_MASK)\n\t\t\t\t\t\t\t  || curbuf->b_p_ro) ?\n\t\t\t\t\t\t\t\t    \" \" : \"\");\n    // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n    // causes an overflow, thus for large numbers divide instead.\n    if (curwin->w_cursor.lnum > 1000000L)\n\tn = (int)(((long)curwin->w_cursor.lnum) /\n\t\t\t\t   ((long)curbuf->b_ml.ml_line_count / 100L));\n    else\n\tn = (int)(((long)curwin->w_cursor.lnum * 100L) /\n\t\t\t\t\t    (long)curbuf->b_ml.ml_line_count);\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tvim_snprintf_add(buffer, IOSIZE, \"%s\", _(no_lines_msg));\n#ifdef FEAT_CMDL_INFO\n    else if (p_ru)\n\t// Current line and column are already on the screen -- webb\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\tNGETTEXT(\"%ld line --%d%%--\", \"%ld lines --%d%%--\",\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count),\n\t\t(long)curbuf->b_ml.ml_line_count, n);\n#endif\n    else\n    {\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\t_(\"line %ld of %ld --%d%%-- col \"),\n\t\t(long)curwin->w_cursor.lnum,\n\t\t(long)curbuf->b_ml.ml_line_count,\n\t\tn);\n\tvalidate_virtcol();\n\tlen = STRLEN(buffer);\n\tcol_print((char_u *)buffer + len, IOSIZE - len,\n\t\t   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n    }\n\n    (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,\n\t\t\t\t\t\t\t !shortmess(SHM_FILE));\n\n    if (dont_truncate)\n    {\n\t// Temporarily set msg_scroll to avoid the message being truncated.\n\t// First call msg_start() to get the message in the right place.\n\tmsg_start();\n\tn = msg_scroll;\n\tmsg_scroll = TRUE;\n\tmsg(buffer);\n\tmsg_scroll = n;\n    }\n    else\n    {\n\tp = msg_trunc_attr(buffer, FALSE, 0);\n\tif (restart_edit != 0 || (msg_scrolled && !need_wait_return))\n\t    // Need to repeat the message after redrawing when:\n\t    // - When restart_edit is set (otherwise there will be a delay\n\t    //   before redrawing).\n\t    // - When the screen was scrolled but there is no wait-return\n\t    //   prompt.\n\t    set_keep_msg((char_u *)p, 0);\n    }\n\n    vim_free(buffer);\n}\n\n    void\ncol_print(\n    char_u  *buf,\n    size_t  buflen,\n    int\t    col,\n    int\t    vcol)\n{\n    if (col == vcol)\n\tvim_snprintf((char *)buf, buflen, \"%d\", col);\n    else\n\tvim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n/*\n * Put the file name in the title bar and icon of the window.\n */\n    void\nmaketitle(void)\n{\n    char_u\t*p;\n    char_u\t*title_str = NULL;\n    char_u\t*icon_str = NULL;\n    int\t\tmaxlen = 0;\n    int\t\tlen;\n    int\t\tmustset;\n    char_u\tbuf[IOSIZE];\n    int\t\toff;\n\n    if (!redrawing())\n    {\n\t// Postpone updating the title when 'lazyredraw' is set.\n\tneed_maketitle = TRUE;\n\treturn;\n    }\n\n    need_maketitle = FALSE;\n    if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)\n\treturn;  // nothing to do\n\n    if (p_title)\n    {\n\tif (p_titlelen > 0)\n\t{\n\t    maxlen = p_titlelen * Columns / 100;\n\t    if (maxlen < 10)\n\t\tmaxlen = 10;\n\t}\n\n\ttitle_str = buf;\n\tif (*p_titlestring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_TITLE)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"titlestring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, title_str, sizeof(buf),\n\t\t\t\t\t      p_titlestring, use_sandbox,\n\t\t\t\t\t      0, maxlen, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"titlestring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ttitle_str = p_titlestring;\n\t}\n\telse\n\t{\n\t    // format: \"fname + (path) (1 of 2) - VIM\"\n\n#define SPACE_FOR_FNAME (IOSIZE - 100)\n#define SPACE_FOR_DIR   (IOSIZE - 20)\n#define SPACE_FOR_ARGNR (IOSIZE - 10)  // at least room for \" - VIM\"\n\t    if (curbuf->b_fname == NULL)\n\t\tvim_strncpy(buf, (char_u *)_(\"[No Name]\"), SPACE_FOR_FNAME);\n#ifdef FEAT_TERMINAL\n\t    else if (curbuf->b_term != NULL)\n\t    {\n\t\tvim_strncpy(buf, term_get_status_text(curbuf->b_term),\n\t\t\t\t\t\t\t      SPACE_FOR_FNAME);\n\t    }\n#endif\n\t    else\n\t    {\n\t\tp = transstr(gettail(curbuf->b_fname));\n\t\tvim_strncpy(buf, p, SPACE_FOR_FNAME);\n\t\tvim_free(p);\n\t    }\n\n#ifdef FEAT_TERMINAL\n\t    if (curbuf->b_term == NULL)\n#endif\n\t\tswitch (bufIsChanged(curbuf)\n\t\t\t+ (curbuf->b_p_ro * 2)\n\t\t\t+ (!curbuf->b_p_ma * 4))\n\t\t{\n\t\t    case 1: STRCAT(buf, \" +\"); break;\n\t\t    case 2: STRCAT(buf, \" =\"); break;\n\t\t    case 3: STRCAT(buf, \" =+\"); break;\n\t\t    case 4:\n\t\t    case 6: STRCAT(buf, \" -\"); break;\n\t\t    case 5:\n\t\t    case 7: STRCAT(buf, \" -+\"); break;\n\t\t}\n\n\t    if (curbuf->b_fname != NULL\n#ifdef FEAT_TERMINAL\n\t\t    && curbuf->b_term == NULL\n#endif\n\t\t    )\n\t    {\n\t\t// Get path of file, replace home dir with ~\n\t\toff = (int)STRLEN(buf);\n\t\tbuf[off++] = ' ';\n\t\tbuf[off++] = '(';\n\t\thome_replace(curbuf, curbuf->b_ffname,\n\t\t\t\t\tbuf + off, SPACE_FOR_DIR - off, TRUE);\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// avoid \"c:/name\" to be reduced to \"c\"\n\t\tif (isalpha(buf[off]) && buf[off + 1] == ':')\n\t\t    off += 2;\n#endif\n\t\t// remove the file name\n\t\tp = gettail_sep(buf + off);\n\t\tif (p == buf + off)\n\t\t{\n\t\t    // must be a help buffer\n\t\t    vim_strncpy(buf + off, (char_u *)_(\"help\"),\n\t\t\t\t\t   (size_t)(SPACE_FOR_DIR - off - 1));\n\t\t}\n\t\telse\n\t\t    *p = NUL;\n\n\t\t// Translate unprintable chars and concatenate.  Keep some\n\t\t// room for the server name.  When there is no room (very long\n\t\t// file name) use (...).\n\t\tif (off < SPACE_FOR_DIR)\n\t\t{\n\t\t    p = transstr(buf + off);\n\t\t    vim_strncpy(buf + off, p, (size_t)(SPACE_FOR_DIR - off));\n\t\t    vim_free(p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf + off, (char_u *)\"...\",\n\t\t\t\t\t     (size_t)(SPACE_FOR_ARGNR - off));\n\t\t}\n\t\tSTRCAT(buf, \")\");\n\t    }\n\n\t    append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);\n\n#if defined(FEAT_CLIENTSERVER)\n\t    if (serverName != NULL)\n\t    {\n\t\tSTRCAT(buf, \" - \");\n\t\tvim_strcat(buf, serverName, IOSIZE);\n\t    }\n\t    else\n#endif\n\t\tSTRCAT(buf, \" - VIM\");\n\n\t    if (maxlen > 0)\n\t    {\n\t\t// make it shorter by removing a bit in the middle\n\t\tif (vim_strsize(buf) > maxlen)\n\t\t    trunc_string(buf, buf, maxlen, IOSIZE);\n\t    }\n\t}\n    }\n    mustset = value_changed(title_str, &lasttitle);\n\n    if (p_icon)\n    {\n\ticon_str = buf;\n\tif (*p_iconstring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_ICON)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"iconstring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, icon_str, sizeof(buf),\n\t\t\t\t\t\t    p_iconstring, use_sandbox,\n\t\t\t\t\t\t    0, 0, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"iconstring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ticon_str = p_iconstring;\n\t}\n\telse\n\t{\n\t    if (buf_spname(curbuf) != NULL)\n\t\tp = buf_spname(curbuf);\n\t    else\t\t    // use file name only in icon\n\t\tp = gettail(curbuf->b_ffname);\n\t    *icon_str = NUL;\n\t    // Truncate name at 100 bytes.\n\t    len = (int)STRLEN(p);\n\t    if (len > 100)\n\t    {\n\t\tlen -= 100;\n\t\tif (has_mbyte)\n\t\t    len += (*mb_tail_off)(p, p + len) + 1;\n\t\tp += len;\n\t    }\n\t    STRCPY(icon_str, p);\n\t    trans_characters(icon_str, IOSIZE);\n\t}\n    }\n\n    mustset |= value_changed(icon_str, &lasticon);\n\n    if (mustset)\n\tresettitle();\n}\n\n/*\n * Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n * from \"str\" if it does.\n * Return TRUE if resettitle() is to be called.\n */\n    static int\nvalue_changed(char_u *str, char_u **last)\n{\n    if ((str == NULL) != (*last == NULL)\n\t    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))\n    {\n\tvim_free(*last);\n\tif (str == NULL)\n\t{\n\t    *last = NULL;\n\t    mch_restore_title(\n\t\t  last == &lasttitle ? SAVE_RESTORE_TITLE : SAVE_RESTORE_ICON);\n\t}\n\telse\n\t{\n\t    *last = vim_strsave(str);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Put current window title back (used after calling a shell)\n */\n    void\nresettitle(void)\n{\n    mch_settitle(lasttitle, lasticon);\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_titles(void)\n{\n    vim_free(lasttitle);\n    vim_free(lasticon);\n}\n# endif\n\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n\n/*\n * Used for building in the status line.\n */\ntypedef struct\n{\n    char_u\t*stl_start;\n    int\t\tstl_minwid;\n    int\t\tstl_maxwid;\n    enum {\n\tNormal,\n\tEmpty,\n\tGroup,\n\tMiddle,\n\tHighlight,\n\tTabPage,\n\tTrunc\n    }\t\tstl_type;\n} stl_item_T;\n\nstatic size_t\t\tstl_items_len = 20; // Initial value, grows as needed.\nstatic stl_item_T      *stl_items = NULL;\nstatic int\t       *stl_groupitem = NULL;\nstatic stl_hlrec_T     *stl_hltab = NULL;\nstatic stl_hlrec_T     *stl_tabtab = NULL;\n\n/*\n * Build a string from the status line items in \"fmt\".\n * Return length of string in screen cells.\n *\n * Normally works for window \"wp\", except when working for 'tabline' then it\n * is \"curwin\".\n *\n * Items are drawn interspersed with the text that surrounds it\n * Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation\n * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n *\n * If maxwidth is not zero, the string will be filled at any middle marker\n * or truncated if too long, fillchar is used for all whitespace.\n */\n    int\nbuild_stl_str_hl(\n    win_T\t*wp,\n    char_u\t*out,\t\t// buffer to write into != NameBuff\n    size_t\toutlen,\t\t// length of out[]\n    char_u\t*fmt,\n    int\t\tuse_sandbox UNUSED, // \"fmt\" was set insecurely, use sandbox\n    int\t\tfillchar,\n    int\t\tmaxwidth,\n    stl_hlrec_T **hltab,\t// return: HL attributes (can be NULL)\n    stl_hlrec_T **tabtab)\t// return: tab page nrs (can be NULL)\n{\n    linenr_T\tlnum;\n    size_t\tlen;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*t;\n    int\t\tbyteval;\n#ifdef FEAT_EVAL\n    win_T\t*save_curwin;\n    buf_T\t*save_curbuf;\n    int\t\tsave_VIsual_active;\n#endif\n    int\t\tempty_line;\n    colnr_T\tvirtcol;\n    long\tl;\n    long\tn;\n    int\t\tprevchar_isflag;\n    int\t\tprevchar_isitem;\n    int\t\titemisflag;\n    int\t\tfillable;\n    char_u\t*str;\n    long\tnum;\n    int\t\twidth;\n    int\t\titemcnt;\n    int\t\tcuritem;\n    int\t\tgroup_end_userhl;\n    int\t\tgroup_start_userhl;\n    int\t\tgroupdepth;\n#ifdef FEAT_EVAL\n    int\t\tevaldepth;\n#endif\n    int\t\tminwid;\n    int\t\tmaxwid;\n    int\t\tzeropad;\n    char_u\tbase;\n    char_u\topt;\n#define TMPLEN 70\n    char_u\tbuf_tmp[TMPLEN];\n    char_u\twin_tmp[TMPLEN];\n    char_u\t*usefmt = fmt;\n    stl_hlrec_T *sp;\n    int\t\tsave_redraw_not_allowed = redraw_not_allowed;\n    int\t\tsave_KeyTyped = KeyTyped;\n\n    // When inside update_screen() we do not want redrawing a statusline,\n    // ruler, title, etc. to trigger another redraw, it may cause an endless\n    // loop.\n    if (updating_screen)\n\tredraw_not_allowed = TRUE;\n\n    if (stl_items == NULL)\n    {\n\tstl_items = ALLOC_MULT(stl_item_T, stl_items_len);\n\tstl_groupitem = ALLOC_MULT(int, stl_items_len);\n\n\t// Allocate one more, because the last element is used to indicate the\n\t// end of the list.\n\tstl_hltab  = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n\tstl_tabtab = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * When the format starts with \"%!\" then evaluate it as an expression and\n     * use the result as the actual format string.\n     */\n    if (fmt[0] == '%' && fmt[1] == '!')\n    {\n\ttypval_T\ttv;\n\n\ttv.v_type = VAR_NUMBER;\n\ttv.vval.v_number = wp->w_id;\n\tset_var((char_u *)\"g:statusline_winid\", &tv, FALSE);\n\n\tusefmt = eval_to_string_safe(fmt + 2, use_sandbox, FALSE);\n\tif (usefmt == NULL)\n\t    usefmt = fmt;\n\n\tdo_unlet((char_u *)\"g:statusline_winid\", TRUE);\n    }\n#endif\n\n    if (fillchar == 0)\n\tfillchar = ' ';\n\n    // The cursor in windows other than the current one isn't always\n    // up-to-date, esp. because of autocommands and timers.\n    lnum = wp->w_cursor.lnum;\n    if (lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\twp->w_cursor.lnum = lnum;\n    }\n\n    // Get line & check if empty (cursorpos will show \"0-1\").  Note that\n    // p will become invalid when getting another buffer line.\n    p = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    empty_line = (*p == NUL);\n\n    // Get the byte value now, in case we need it below. This is more efficient\n    // than making a copy of the line.\n    len = STRLEN(p);\n    if (wp->w_cursor.col > (colnr_T)len)\n    {\n\t// Line may have changed since checking the cursor column, or the lnum\n\t// was adjusted above.\n\twp->w_cursor.col = (colnr_T)len;\n\twp->w_cursor.coladd = 0;\n\tbyteval = 0;\n    }\n    else\n\tbyteval = (*mb_ptr2char)(p + wp->w_cursor.col);\n\n    groupdepth = 0;\n#ifdef FEAT_EVAL\n    evaldepth = 0;\n#endif\n    p = out;\n    curitem = 0;\n    prevchar_isflag = TRUE;\n    prevchar_isitem = FALSE;\n    for (s = usefmt; *s != NUL; )\n    {\n\tif (curitem == (int)stl_items_len)\n\t{\n\t    size_t\tnew_len = stl_items_len * 3 / 2;\n\t    stl_item_T\t*new_items;\n\t    int\t\t*new_groupitem;\n\t    stl_hlrec_T\t*new_hlrec;\n\n\t    new_items = vim_realloc(stl_items, sizeof(stl_item_T) * new_len);\n\t    if (new_items == NULL)\n\t\tbreak;\n\t    stl_items = new_items;\n\t    new_groupitem = vim_realloc(stl_groupitem, sizeof(int) * new_len);\n\t    if (new_groupitem == NULL)\n\t\tbreak;\n\t    stl_groupitem = new_groupitem;\n\t    new_hlrec = vim_realloc(stl_hltab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_hltab = new_hlrec;\n\t    new_hlrec = vim_realloc(stl_tabtab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_tabtab = new_hlrec;\n\t    stl_items_len = new_len;\n\t}\n\n\tif (*s != '%')\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\n\t/*\n\t * Handle up to the next '%' or the end.\n\t */\n\twhile (*s != NUL && *s != '%' && p + 1 < out + outlen)\n\t    *p++ = *s++;\n\tif (*s == NUL || p + 1 >= out + outlen)\n\t    break;\n\n\t/*\n\t * Handle one '%' item.\n\t */\n\ts++;\n\tif (*s == NUL)  // ignore trailing %\n\t    break;\n\tif (*s == '%')\n\t{\n\t    if (p + 1 >= out + outlen)\n\t\tbreak;\n\t    *p++ = *s++;\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\t    continue;\n\t}\n\tif (*s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    if (groupdepth > 0)\n\t\tcontinue;\n\t    stl_items[curitem].stl_type = Middle;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == STL_TRUNCMARK)\n\t{\n\t    s++;\n\t    stl_items[curitem].stl_type = Trunc;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (groupdepth < 1)\n\t\tcontinue;\n\t    groupdepth--;\n\n\t    t = stl_items[stl_groupitem[groupdepth]].stl_start;\n\t    *p = NUL;\n\t    l = vim_strsize(t);\n\t    if (curitem > stl_groupitem[groupdepth] + 1\n\t\t    && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)\n\t    {\n\t\t// remove group if all items are empty and highlight group\n\t\t// doesn't change\n\t\tgroup_start_userhl = group_end_userhl = 0;\n\t\tfor (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t    {\n\t\t\tgroup_start_userhl = group_end_userhl =\n\t\t\t\t\t\t       stl_items[n].stl_minwid;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tfor (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Normal)\n\t\t\tbreak;\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t\tgroup_end_userhl = stl_items[n].stl_minwid;\n\t\t}\n\t\tif (n == curitem && group_start_userhl == group_end_userhl)\n\t\t{\n\t\t    // empty group\n\t\t    p = t;\n\t\t    l = 0;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t    {\n\t\t\t// do not use the highlighting from the removed group\n\t\t\tif (stl_items[n].stl_type == Highlight)\n\t\t\t    stl_items[n].stl_type = Empty;\n\t\t\t// adjust the start position of TabPage to the next\n\t\t\t// item position\n\t\t\tif (stl_items[n].stl_type == TabPage)\n\t\t\t    stl_items[n].stl_start = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t    {\n\t\t// truncate, remove n bytes of text at the start\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // Find the first character that should be included.\n\t\t    n = 0;\n\t\t    while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t\t    {\n\t\t\tl -= ptr2cells(t + n);\n\t\t\tn += (*mb_ptr2len)(t + n);\n\t\t    }\n\t\t}\n\t\telse\n\t\t    n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]\n\t\t\t\t\t\t\t       .stl_maxwid + 1;\n\n\t\t*t = '<';\n\t\tmch_memmove(t + 1, t + n, (size_t)(p - (t + n)));\n\t\tp = p - n + 1;\n\n\t\t// Fill up space left over by half a double-wide char.\n\t\twhile (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\n\t\t// correct the start of the items for the truncation\n\t\tfor (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)\n\t\t{\n\t\t    // Minus one for the leading '<' added above.\n\t\t    stl_items[l].stl_start -= n - 1;\n\t\t    if (stl_items[l].stl_start < t)\n\t\t\tstl_items[l].stl_start = t;\n\t\t}\n\t    }\n\t    else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)\n\t    {\n\t\t// fill\n\t\tn = stl_items[stl_groupitem[groupdepth]].stl_minwid;\n\t\tif (n < 0)\n\t\t{\n\t\t    // fill by appending characters\n\t\t    n = 0 - n;\n\t\t    while (l++ < n && p + 1 < out + outlen)\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // fill by inserting characters\n\t\t    l = (n - l) * MB_CHAR2LEN(fillchar);\n\t\t    mch_memmove(t + l, t, (size_t)(p - t));\n\t\t    if (p + l >= out + outlen)\n\t\t\tl = (long)((out + outlen) - p - 1);\n\t\t    p += l;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t\tstl_items[n].stl_start += l;\n\t\t    for ( ; l > 0; l--)\n\t\t\tMB_CHAR2BYTES(fillchar, t);\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tminwid = 0;\n\tmaxwid = 9999;\n\tzeropad = FALSE;\n\tl = 1;\n\tif (*s == '0')\n\t{\n\t    s++;\n\t    zeropad = TRUE;\n\t}\n\tif (*s == '-')\n\t{\n\t    s++;\n\t    l = -1;\n\t}\n\tif (VIM_ISDIGIT(*s))\n\t{\n\t    minwid = (int)getdigits(&s);\n\t    if (minwid < 0)\t// overflow\n\t\tminwid = 0;\n\t}\n\tif (*s == STL_USER_HL)\n\t{\n\t    stl_items[curitem].stl_type = Highlight;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == STL_TABPAGENR || *s == STL_TABCLOSENR)\n\t{\n\t    if (*s == STL_TABCLOSENR)\n\t    {\n\t\tif (minwid == 0)\n\t\t{\n\t\t    // %X ends the close label, go back to the previously\n\t\t    // define tab label nr.\n\t\t    for (n = curitem - 1; n >= 0; --n)\n\t\t\tif (stl_items[n].stl_type == TabPage\n\t\t\t\t\t       && stl_items[n].stl_minwid >= 0)\n\t\t\t{\n\t\t\t    minwid = stl_items[n].stl_minwid;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t    // close nrs are stored as negative values\n\t\t    minwid = - minwid;\n\t    }\n\t    stl_items[curitem].stl_type = TabPage;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    if (VIM_ISDIGIT(*s))\n\t    {\n\t\tmaxwid = (int)getdigits(&s);\n\t\tif (maxwid <= 0)\t// overflow\n\t\t    maxwid = 50;\n\t    }\n\t}\n\tminwid = (minwid > 50 ? 50 : minwid) * l;\n\tif (*s == '(')\n\t{\n\t    stl_groupitem[groupdepth++] = curitem;\n\t    stl_items[curitem].stl_type = Group;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    stl_items[curitem].stl_maxwid = maxwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n#ifdef FEAT_EVAL\n\t// Denotes end of expanded %{} block\n\tif (*s == '}' && evaldepth > 0)\n\t{\n\t    s++;\n\t    evaldepth--;\n\t    continue;\n\t}\n#endif\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\topt = *s++;\n\n\t// OK - now for the real work\n\tbase = 'D';\n\titemisflag = FALSE;\n\tfillable = TRUE;\n\tnum = -1;\n\tstr = NULL;\n\tswitch (opt)\n\t{\n\tcase STL_FILEPATH:\n\tcase STL_FULLPATH:\n\tcase STL_FILENAME:\n\t    fillable = FALSE;\t// don't change ' ' to fillchar\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(NameBuff, buf_spname(wp->w_buffer), MAXPATHL - 1);\n\t    else\n\t    {\n\t\tt = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n\t\t\t\t\t  : wp->w_buffer->b_fname;\n\t\thome_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);\n\t    }\n\t    trans_characters(NameBuff, MAXPATHL);\n\t    if (opt != STL_FILENAME)\n\t\tstr = NameBuff;\n\t    else\n\t\tstr = gettail(NameBuff);\n\t    break;\n\n\tcase STL_VIM_EXPR: // '{'\n\t{\n#ifdef FEAT_EVAL\n\t    char_u *block_start = s - 1;\n#endif\n\t    int reevaluate = (*s == '%');\n\n\t    if (reevaluate)\n\t\ts++;\n\t    itemisflag = TRUE;\n\t    t = p;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%'))\n\t\t\t\t\t  && *s != NUL && p + 1 < out + outlen)\n\t\t*p++ = *s++;\n\t    if (*s != '}')\t// missing '}' or out of space\n\t\tbreak;\n\t    s++;\n\t    if (reevaluate)\n\t\tp[-1] = 0; // remove the % at the end of %{% expr %}\n\t    else\n\t\t*p = 0;\n\t    p = t;\n#ifdef FEAT_EVAL\n\t    vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),\n\t\t\t\t\t\t\t \"%d\", curbuf->b_fnum);\n\t    set_internal_string_var((char_u *)\"g:actual_curbuf\", buf_tmp);\n\t    vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->w_id);\n\t    set_internal_string_var((char_u *)\"g:actual_curwin\", win_tmp);\n\n\t    save_curbuf = curbuf;\n\t    save_curwin = curwin;\n\t    save_VIsual_active = VIsual_active;\n\t    curwin = wp;\n\t    curbuf = wp->w_buffer;\n\t    // Visual mode is only valid in the current window.\n\t    if (curwin != save_curwin)\n\t\tVIsual_active = FALSE;\n\n\t    str = eval_to_string_safe(p, use_sandbox, FALSE);\n\n\t    curwin = save_curwin;\n\t    curbuf = save_curbuf;\n\t    VIsual_active = save_VIsual_active;\n\t    do_unlet((char_u *)\"g:actual_curbuf\", TRUE);\n\t    do_unlet((char_u *)\"g:actual_curwin\", TRUE);\n\n\t    if (str != NULL && *str != 0)\n\t    {\n\t\tif (*skipdigits(str) == NUL)\n\t\t{\n\t\t    num = atoi((char *)str);\n\t\t    VIM_CLEAR(str);\n\t\t    itemisflag = FALSE;\n\t\t}\n\t    }\n\n\t    // If the output of the expression needs to be evaluated\n\t    // replace the %{} block with the result of evaluation\n\t    if (reevaluate && str != NULL && *str != 0\n\t\t    && strchr((const char *)str, '%') != NULL\n\t\t    && evaldepth < MAX_STL_EVAL_DEPTH)\n\t    {\n\t\tsize_t parsed_usefmt = (size_t)(block_start - usefmt);\n\t\tsize_t str_length = strlen((const char *)str);\n\t\tsize_t fmt_length = strlen((const char *)s);\n\t\tsize_t new_fmt_len = parsed_usefmt\n\t\t\t\t\t\t + str_length + fmt_length + 3;\n\t\tchar_u *new_fmt = (char_u *)alloc(new_fmt_len * sizeof(char_u));\n\t\tchar_u *new_fmt_p = new_fmt;\n\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n\t\t\t\t\t\t\t       + parsed_usefmt;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n\t\t\t\t\t\t\t\t  + str_length;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , s, fmt_length)\n\t\t\t\t\t\t\t\t  + fmt_length;\n\t\t*new_fmt_p = 0;\n\t\tnew_fmt_p = NULL;\n\n\t\tif (usefmt != fmt)\n\t\t    vim_free(usefmt);\n\t\tVIM_CLEAR(str);\n\t\tusefmt = new_fmt;\n\t\ts = usefmt + parsed_usefmt;\n\t\tevaldepth++;\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\tcase STL_LINE:\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t  ? 0L : (long)(wp->w_cursor.lnum);\n\t    break;\n\n\tcase STL_NUMLINES:\n\t    num = wp->w_buffer->b_ml.ml_line_count;\n\t    break;\n\n\tcase STL_COLUMN:\n\t    num = (State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t\t       ? 0 : (int)wp->w_cursor.col + 1;\n\t    break;\n\n\tcase STL_VIRTCOL:\n\tcase STL_VIRTCOL_ALT:\n\t    virtcol = wp->w_virtcol + 1;\n\t    // Don't display %V if it's the same as %c.\n\t    if (opt == STL_VIRTCOL_ALT\n\t\t    && (virtcol == (colnr_T)((State & MODE_INSERT) == 0\n\t\t\t       && empty_line ? 0 : (int)wp->w_cursor.col + 1)))\n\t\tbreak;\n\t    num = (long)virtcol;\n\t    break;\n\n\tcase STL_PERCENTAGE:\n\t    num = (int)(((long)wp->w_cursor.lnum * 100L) /\n\t\t\t(long)wp->w_buffer->b_ml.ml_line_count);\n\t    break;\n\n\tcase STL_ALTPERCENT:\n\t    str = buf_tmp;\n\t    get_rel_pos(wp, str, TMPLEN);\n\t    break;\n\n\tcase STL_ARGLISTSTAT:\n\t    fillable = FALSE;\n\t    buf_tmp[0] = 0;\n\t    if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), FALSE))\n\t\tstr = buf_tmp;\n\t    break;\n\n\tcase STL_KEYMAP:\n\t    fillable = FALSE;\n\t    if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN))\n\t\tstr = buf_tmp;\n\t    break;\n\tcase STL_PAGENUM:\n#if defined(FEAT_PRINTER) || defined(FEAT_GUI_TABLINE)\n\t    num = printer_page_num;\n#else\n\t    num = 0;\n#endif\n\t    break;\n\n\tcase STL_BUFNO:\n\t    num = wp->w_buffer->b_fnum;\n\t    break;\n\n\tcase STL_OFFSET_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_OFFSET:\n#ifdef FEAT_BYTEOFF\n\t    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL);\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0\n\t\t       ? 0L : l + 1 + ((State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t? 0 : (int)wp->w_cursor.col);\n#endif\n\t    break;\n\n\tcase STL_BYTEVAL_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_BYTEVAL:\n\t    num = byteval;\n\t    if (num == NL)\n\t\tnum = 0;\n\t    else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC)\n\t\tnum = NL;\n\t    break;\n\n\tcase STL_ROFLAG:\n\tcase STL_ROFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_p_ro)\n\t\tstr = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n\t    break;\n\n\tcase STL_HELPFLAG:\n\tcase STL_HELPFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_help)\n\t\tstr = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n\t\t\t\t\t\t\t       : _(\"[Help]\"));\n\t    break;\n\n\tcase STL_FILETYPE:\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n\tcase STL_FILETYPE_ALT:\n\t    itemisflag = TRUE;\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tfor (t = buf_tmp; *t != 0; t++)\n\t\t    *t = TOUPPER_LOC(*t);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n#if defined(FEAT_QUICKFIX)\n\tcase STL_PREVIEWFLAG:\n\tcase STL_PREVIEWFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_p_pvw)\n\t\tstr = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n\t\t\t\t\t\t\t    : _(\"[Preview]\"));\n\t    break;\n\n\tcase STL_QUICKFIX:\n\t    if (bt_quickfix(wp->w_buffer))\n\t\tstr = (char_u *)(wp->w_llist_ref\n\t\t\t    ? _(msg_loclist)\n\t\t\t    : _(msg_qflist));\n\t    break;\n#endif\n\n\tcase STL_MODIFIED:\n\tcase STL_MODIFIED_ALT:\n\t    itemisflag = TRUE;\n\t    switch ((opt == STL_MODIFIED_ALT)\n\t\t    + bufIsChanged(wp->w_buffer) * 2\n\t\t    + (!wp->w_buffer->b_p_ma) * 4)\n\t    {\n\t\tcase 2: str = (char_u *)\"[+]\"; break;\n\t\tcase 3: str = (char_u *)\",+\"; break;\n\t\tcase 4: str = (char_u *)\"[-]\"; break;\n\t\tcase 5: str = (char_u *)\",-\"; break;\n\t\tcase 6: str = (char_u *)\"[+-]\"; break;\n\t\tcase 7: str = (char_u *)\",+-\"; break;\n\t    }\n\t    break;\n\n\tcase STL_HIGHLIGHT:\n\t    t = s;\n\t    while (*s != '#' && *s != NUL)\n\t\t++s;\n\t    if (*s == '#')\n\t    {\n\t\tstl_items[curitem].stl_type = Highlight;\n\t\tstl_items[curitem].stl_start = p;\n\t\tstl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));\n\t\tcuritem++;\n\t    }\n\t    if (*s != NUL)\n\t\t++s;\n\t    continue;\n\t}\n\n\tstl_items[curitem].stl_start = p;\n\tstl_items[curitem].stl_type = Normal;\n\tif (str != NULL && *str)\n\t{\n\t    t = str;\n\t    if (itemisflag)\n\t    {\n\t\tif ((t[0] && t[1])\n\t\t\t&& ((!prevchar_isitem && *t == ',')\n\t\t\t      || (prevchar_isflag && *t == ' ')))\n\t\t    t++;\n\t\tprevchar_isflag = TRUE;\n\t    }\n\t    l = vim_strsize(t);\n\t    if (l > 0)\n\t\tprevchar_isitem = TRUE;\n\t    if (l > maxwid)\n\t    {\n\t\twhile (l >= maxwid)\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tl -= ptr2cells(t);\n\t\t\tt += (*mb_ptr2len)(t);\n\t\t    }\n\t\t    else\n\t\t\tl -= byte2cells(*t++);\n\t\tif (p + 1 >= out + outlen)\n\t\t    break;\n\t\t*p++ = '<';\n\t    }\n\t    if (minwid > 0)\n\t    {\n\t\tfor (; l < minwid && p + 1 < out + outlen; l++)\n\t\t{\n\t\t    // Don't put a \"-\" in front of a digit.\n\t\t    if (l + 1 == minwid && fillchar == '-' && VIM_ISDIGIT(*t))\n\t\t\t*p++ = ' ';\n\t\t    else\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\tminwid = 0;\n\t    }\n\t    else\n\t\tminwid *= -1;\n\t    for (; *t && p + 1 < out + outlen; t++)\n\t    {\n\t\t// Change a space by fillchar, unless fillchar is '-' and a\n\t\t// digit follows.\n\t\tif (fillable && *t == ' '\n\t\t\t\t&& (!VIM_ISDIGIT(*(t + 1)) || fillchar != '-'))\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\t\telse\n\t\t    *p++ = *t;\n\t    }\n\t    for (; l < minwid && p + 1 < out + outlen; l++)\n\t\tMB_CHAR2BYTES(fillchar, p);\n\t}\n\telse if (num >= 0)\n\t{\n\t    int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));\n\t    char_u nstr[20];\n\n\t    if (p + 20 >= out + outlen)\n\t\tbreak;\t\t// not sufficient space\n\t    prevchar_isitem = TRUE;\n\t    t = nstr;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t    {\n\t\t*t++ = '-';\n\t\tminwid--;\n\t    }\n\t    *t++ = '%';\n\t    if (zeropad)\n\t\t*t++ = '0';\n\t    *t++ = '*';\n\t    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');\n\t    *t = 0;\n\n\t    for (n = num, l = 1; n >= nbase; n /= nbase)\n\t\tl++;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t\tl++;\n\t    if (l > maxwid)\n\t    {\n\t\tl += 2;\n\t\tn = l - maxwid;\n\t\twhile (l-- > maxwid)\n\t\t    num /= nbase;\n\t\t*t++ = '>';\n\t\t*t++ = '%';\n\t\t*t = t[-3];\n\t\t*++t = 0;\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t   0, num, n);\n\t    }\n\t    else\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t minwid, num);\n\t    p += STRLEN(p);\n\t}\n\telse\n\t    stl_items[curitem].stl_type = Empty;\n\n\tif (num >= 0 || (!itemisflag && str != NULL && *str != NUL))\n\t    prevchar_isflag = FALSE;\t    // Item not NULL, but not a flag\n\t\t\t\t\t    //\n\tif (opt == STL_VIM_EXPR)\n\t    vim_free(str);\n\tcuritem++;\n    }\n    *p = NUL;\n    itemcnt = curitem;\n\n#ifdef FEAT_EVAL\n    if (usefmt != fmt)\n\tvim_free(usefmt);\n#endif\n\n    width = vim_strsize(out);\n    if (maxwidth > 0 && width > maxwidth)\n    {\n\t// Result is too long, must truncate somewhere.\n\tl = 0;\n\tif (itemcnt == 0)\n\t    s = out;\n\telse\n\t{\n\t    for ( ; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_type == Trunc)\n\t\t{\n\t\t    // Truncate at %< item.\n\t\t    s = stl_items[l].stl_start;\n\t\t    break;\n\t\t}\n\t    if (l == itemcnt)\n\t    {\n\t\t// No %< item, truncate first item.\n\t\ts = stl_items[0].stl_start;\n\t\tl = 0;\n\t    }\n\t}\n\n\tif (width - vim_strsize(s) >= maxwidth)\n\t{\n\t    // Truncation mark is beyond max length\n\t    if (has_mbyte)\n\t    {\n\t\ts = out;\n\t\twidth = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    width += ptr2cells(s);\n\t\t    if (width >= maxwidth)\n\t\t\tbreak;\n\t\t    s += (*mb_ptr2len)(s);\n\t\t}\n\t\t// Fill up for half a double-wide character.\n\t\twhile (++width < maxwidth)\n\t\t    MB_CHAR2BYTES(fillchar, s);\n\t    }\n\t    else\n\t\ts = out + maxwidth - 1;\n\t    for (l = 0; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_start > s)\n\t\t    break;\n\t    itemcnt = l;\n\t    *s++ = '>';\n\t    *s = 0;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tn = 0;\n\t\twhile (width >= maxwidth)\n\t\t{\n\t\t    width -= ptr2cells(s + n);\n\t\t    n += (*mb_ptr2len)(s + n);\n\t\t}\n\t    }\n\t    else\n\t\tn = width - maxwidth + 1;\n\t    p = s + n;\n\t    STRMOVE(s + 1, p);\n\t    *s = '<';\n\n\t    // Fill up for half a double-wide character.\n\t    while (++width < maxwidth)\n\t    {\n\t\ts = s + STRLEN(s);\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t\t*s = NUL;\n\t    }\n\n\t    --n;\t// count the '<'\n\t    for (; l < itemcnt; l++)\n\t    {\n\t\tif (stl_items[l].stl_start - n >= s)\n\t\t    stl_items[l].stl_start -= n;\n\t\telse\n\t\t    stl_items[l].stl_start = s;\n\t    }\n\t}\n\twidth = maxwidth;\n    }\n    else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)\n    {\n\t// Apply STL_MIDDLE if any\n\tfor (l = 0; l < itemcnt; l++)\n\t    if (stl_items[l].stl_type == Middle)\n\t\tbreak;\n\tif (l < itemcnt)\n\t{\n\t    int middlelength = (maxwidth - width) * MB_CHAR2LEN(fillchar);\n\t    p = stl_items[l].stl_start + middlelength;\n\t    STRMOVE(p, stl_items[l].stl_start);\n\t    for (s = stl_items[l].stl_start; s < p;)\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t    for (l++; l < itemcnt; l++)\n\t\tstl_items[l].stl_start += middlelength;\n\t    width = maxwidth;\n\t}\n    }\n\n    // Store the info about highlighting.\n    if (hltab != NULL)\n    {\n\t*hltab = stl_hltab;\n\tsp = stl_hltab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == Highlight)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // Store the info about tab pages labels.\n    if (tabtab != NULL)\n    {\n\t*tabtab = stl_tabtab;\n\tsp = stl_tabtab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == TabPage)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    redraw_not_allowed = save_redraw_not_allowed;\n\n    // A user function may reset KeyTyped, restore it.\n    KeyTyped = save_KeyTyped;\n\n    return width;\n}\n#endif // FEAT_STL_OPT\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \\\n\t    || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\n    void\nget_rel_pos(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    long\tabove; // number of lines above window\n    long\tbelow; // number of lines below window\n\n    if (buflen < 3) // need at least 3 chars for writing\n\treturn;\n    above = wp->w_topline - 1;\n#ifdef FEAT_DIFF\n    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n    if (wp->w_topline == 1 && wp->w_topfill >= 1)\n\tabove = 0;  // All buffer lines are displayed and there is an\n\t\t    // indication of filler lines, that can be considered\n\t\t    // seeing all lines.\n#endif\n    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n    if (below <= 0)\n\tvim_strncpy(buf, (char_u *)(above == 0 ? _(\"All\") : _(\"Bot\")),\n\t\t\t\t\t\t\t(size_t)(buflen - 1));\n    else if (above <= 0)\n\tvim_strncpy(buf, (char_u *)_(\"Top\"), (size_t)(buflen - 1));\n    else\n\tvim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n\t\t\t\t    ? (int)(above / ((above + below) / 100L))\n\t\t\t\t    : (int)(above * 100L / (above + below)));\n}\n#endif\n\n/*\n * Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n * Return TRUE if it was appended.\n */\n    static int\nappend_arg_number(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen,\n    int\t\tadd_file)\t// Add \"file\" before the arg number\n{\n    char_u\t*p;\n\n    if (ARGCOUNT <= 1)\t\t// nothing to do\n\treturn FALSE;\n\n    p = buf + STRLEN(buf);\t// go to the end of the buffer\n    if (p - buf + 35 >= buflen)\t// getting too long\n\treturn FALSE;\n    *p++ = ' ';\n    *p++ = '(';\n    if (add_file)\n    {\n\tSTRCPY(p, \"file \");\n\tp += 5;\n    }\n    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n\t\twp->w_arg_idx_invalid ? \"(%d) of %d)\"\n\t\t\t\t  : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n    return TRUE;\n}\n\n/*\n * If fname is not a full path, make it a full path.\n * Returns pointer to allocated memory (NULL for failure).\n */\n    char_u  *\nfix_fname(char_u  *fname)\n{\n    /*\n     * Force expanding the path always for Unix, because symbolic links may\n     * mess up the full path name, even though it starts with a '/'.\n     * Also expand when there is \"..\" in the file name, try to remove it,\n     * because \"c:/src/../README\" is equal to \"c:/README\".\n     * Similarly \"c:/src//file\" is equal to \"c:/src/file\".\n     * For MS-Windows also expand names like \"longna~1\" to \"longname\".\n     */\n#ifdef UNIX\n    return FullName_save(fname, TRUE);\n#else\n    if (!vim_isAbsName(fname)\n\t    || strstr((char *)fname, \"..\") != NULL\n\t    || strstr((char *)fname, \"//\") != NULL\n# ifdef BACKSLASH_IN_FILENAME\n\t    || strstr((char *)fname, \"\\\\\\\\\") != NULL\n# endif\n# if defined(MSWIN)\n\t    || vim_strchr(fname, '~') != NULL\n# endif\n\t    )\n\treturn FullName_save(fname, FALSE);\n\n    fname = vim_strsave(fname);\n\n# ifdef USE_FNAME_CASE\n    if (fname != NULL)\n\tfname_case(fname, 0);\t// set correct case for file name\n# endif\n\n    return fname;\n#endif\n}\n\n/*\n * Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n * \"*ffname\" becomes a pointer to allocated memory (or NULL).\n * When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n * allocated memory.\n * The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n * Note that the resulting \"*ffname\" pointer should be considered not allocated.\n */\n    void\nfname_expand(\n    buf_T\t*buf UNUSED,\n    char_u\t**ffname,\n    char_u\t**sfname)\n{\n    if (*ffname == NULL)\t    // no file name given, nothing to do\n\treturn;\n    if (*sfname == NULL)\t    // no short file name given, use ffname\n\t*sfname = *ffname;\n    *ffname = fix_fname(*ffname);   // expand to full path\n\n#ifdef FEAT_SHORTCUT\n    if (!buf->b_p_bin)\n    {\n\tchar_u  *rfname;\n\n\t// If the file name is a shortcut file, use the file it links to.\n\trfname = mch_resolve_path(*ffname, FALSE);\n\tif (rfname != NULL)\n\t{\n\t    vim_free(*ffname);\n\t    *ffname = rfname;\n\t    *sfname = rfname;\n\t}\n    }\n#endif\n}\n\n/*\n * Open a window for a number of buffers.\n */\n    void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t\t|| ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t    ? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t     - tabline_height()\n\t\t\t    : wp->w_width != Columns)\n\t\t\t|| (had_tab > 0 && wp != firstwin))\n\t\t    && !ONE_WINDOW\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n\t\t    && !win_unlisted(wp))\n\t    {\n\t\tif (win_close(wp, FALSE) == FAIL)\n\t\t    break;\n\t\t// Just in case an autocommand does something strange with\n\t\t// windows: start all over...\n\t\twpnext = firstwin;\n\t\ttpnext = first_tabpage;\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}\n\n\nstatic int  chk_modeline(linenr_T, int);\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\n    void\ndo_modelines(int flags)\n{\n    linenr_T\tlnum;\n    int\t\tnmlines;\n    static int\tentered = 0;\n\n    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)\n\treturn;\n\n    // Disallow recursive entry here.  Can happen when executing a modeline\n    // triggers an autocommand, which reloads modelines with a \":do\".\n    if (entered)\n\treturn;\n\n    ++entered;\n    for (lnum = 1; curbuf->b_p_ml && lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n\t\t\t\t\t\t\t\t       ++lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n\n    for (lnum = curbuf->b_ml.ml_line_count; curbuf->b_p_ml && lnum > 0 && lnum > nmlines\n\t\t       && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n    --entered;\n}\n\n#include \"version.h\"\t\t// for version number\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\n    static int\nchk_modeline(\n    linenr_T\tlnum,\n    int\t\tflags)\t\t// Same as for do_modelines().\n{\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*linecopy;\t\t// local copy of any modeline found\n    int\t\tprev;\n    int\t\tvers;\n    int\t\tend;\n    int\t\tretval = OK;\n    sctx_T\tsave_current_sctx;\n\n    ESTACK_CHECK_DECLARATION\n\n    prev = -1;\n    for (s = ml_get(lnum); *s != NUL; ++s)\n    {\n\tif (prev == -1 || vim_isspace(prev))\n\t{\n\t    if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n\t\t    || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n\t\tbreak;\n\t    // Accept both \"vim\" and \"Vim\".\n\t    if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')\n\t    {\n\t\tif (s[3] == '<' || s[3] == '=' || s[3] == '>')\n\t\t    e = s + 4;\n\t\telse\n\t\t    e = s + 3;\n\t\tvers = getdigits(&e);\n\t\tif (*e == ':'\n\t\t\t&& (s[0] != 'V'\n\t\t\t\t  || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n\t\t\t&& (s[3] == ':'\n\t\t\t    || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n\t\t\t    || (VIM_VERSION_100 < vers && s[3] == '<')\n\t\t\t    || (VIM_VERSION_100 > vers && s[3] == '>')\n\t\t\t    || (VIM_VERSION_100 == vers && s[3] == '=')))\n\t\t    break;\n\t    }\n\t}\n\tprev = *s;\n    }\n\n    if (*s)\n    {\n\tdo\t\t\t\t// skip over \"ex:\", \"vi:\" or \"vim:\"\n\t    ++s;\n\twhile (s[-1] != ':');\n\n\ts = linecopy = vim_strsave(s);\t// copy the line, it will change\n\tif (linecopy == NULL)\n\t    return FAIL;\n\n\t// prepare for emsg()\n\testack_push(ETYPE_MODELINE, (char_u *)\"modelines\", lnum);\n\tESTACK_CHECK_SETUP\n\n\tend = FALSE;\n\twhile (end == FALSE)\n\t{\n\t    s = skipwhite(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\n\t    /*\n\t     * Find end of set command: ':' or end of line.\n\t     * Skip over \"\\:\", replacing it with \":\".\n\t     */\n\t    for (e = s; *e != ':' && *e != NUL; ++e)\n\t\tif (e[0] == '\\\\' && e[1] == ':')\n\t\t    STRMOVE(e, e + 1);\n\t    if (*e == NUL)\n\t\tend = TRUE;\n\n\t    /*\n\t     * If there is a \"set\" command, require a terminating ':' and\n\t     * ignore the stuff after the ':'.\n\t     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n\t     * \"vi:opt opt opt: foo\" -- foo interpreted\n\t     * Accept \"se\" for compatibility with Elvis.\n\t     */\n\t    if (STRNCMP(s, \"set \", (size_t)4) == 0\n\t\t    || STRNCMP(s, \"se \", (size_t)3) == 0)\n\t    {\n\t\tif (*e != ':')\t\t// no terminating ':'?\n\t\t    break;\n\t\tend = TRUE;\n\t\ts = vim_strchr(s, ' ') + 1;\n\t    }\n\t    *e = NUL;\t\t\t// truncate the set command\n\n\t    if (*s != NUL)\t\t// skip over an empty \"::\"\n\t    {\n\t\tint secure_save = secure;\n\n\t\tsave_current_sctx = current_sctx;\n\t\tcurrent_sctx.sc_version = 1;\n#ifdef FEAT_EVAL\n\t\tcurrent_sctx.sc_sid = SID_MODELINE;\n\t\tcurrent_sctx.sc_seq = 0;\n\t\tcurrent_sctx.sc_lnum = lnum;\n#endif\n\n\t\t// Make sure no risky things are executed as a side effect.\n\t\tsecure = 1;\n\n\t\tretval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n\t\tsecure = secure_save;\n\t\tcurrent_sctx = save_current_sctx;\n\t\tif (retval == FAIL)\t\t// stop if error found\n\t\t    break;\n\t    }\n\t    s = e + 1;\t\t\t// advance to next part\n\t}\n\n\tESTACK_CHECK_NOW\n\testack_pop();\n\tvim_free(linecopy);\n    }\n    return retval;\n}\n\n/*\n * Return TRUE if \"buf\" is a normal buffer, 'buftype' is empty.\n */\n    int\nbt_normal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n/*\n * Return TRUE if \"buf\" is the quickfix buffer.\n */\n    int\nbt_quickfix(buf_T *buf UNUSED)\n{\n#ifdef FEAT_QUICKFIX\n    return buf != NULL && buf->b_p_bt[0] == 'q';\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return TRUE if \"buf\" is a terminal buffer.\n */\n    int\nbt_terminal(buf_T *buf UNUSED)\n{\n#if defined(FEAT_TERMINAL)\n    return buf != NULL && buf->b_p_bt[0] == 't';\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return TRUE if \"buf\" is a help buffer.\n */\n    int\nbt_help(buf_T *buf)\n{\n    return buf != NULL && buf->b_help;\n}\n\n/*\n * Return TRUE if \"buf\" is a prompt buffer.\n */\n    int\nbt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a buffer for a popup window.\n */\n    int\nbt_popup(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt != NULL\n\t&& buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer name may not be a file name, at least not for\n * writing the buffer.\n */\n    int\nbt_nofilename(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 'a'\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"quickfix\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer is not to be read from a file.\n */\n    static int\nbt_nofileread(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'q'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" has 'buftype' set to \"nofile\".\n */\n    int\nbt_nofile(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\" or \"prompt\"\n * buffer.\n */\n    int\nbt_dontwrite(buf_T *buf)\n{\n    return buf != NULL && (buf->b_p_bt[0] == 'n'\n\t\t || buf->b_p_bt[0] == 't'\n\t\t || buf->b_p_bt[0] == 'p');\n}\n\n    int\nbt_dontwrite_msg(buf_T *buf)\n{\n    if (bt_dontwrite(buf))\n    {\n\temsg(_(e_cannot_write_buftype_option_is_set));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if the buffer should be hidden, according to 'hidden', \":hide\"\n * and 'bufhidden'.\n */\n    int\nbuf_hide(buf_T *buf)\n{\n    // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n    switch (buf->b_p_bh[0])\n    {\n\tcase 'u':\t\t    // \"unload\"\n\tcase 'w':\t\t    // \"wipe\"\n\tcase 'd': return FALSE;\t    // \"delete\"\n\tcase 'h': return TRUE;\t    // \"hide\"\n    }\n    return (p_hid || (cmdmod.cmod_flags & CMOD_HIDE));\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\n    char_u *\nbuf_spname(buf_T *buf)\n{\n#if defined(FEAT_QUICKFIX)\n    if (bt_quickfix(buf))\n    {\n\t/*\n\t * Differentiate between the quickfix and location list buffers using\n\t * the buffer number stored in the global quickfix stack.\n\t */\n\tif (buf->b_fnum == qf_stack_get_bufnr())\n\t    return (char_u *)_(msg_qflist);\n\telse\n\t    return (char_u *)_(msg_loclist);\n    }\n#endif\n\n    // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n    // contains the name as specified by the user.\n    if (bt_nofilename(buf))\n    {\n#ifdef FEAT_TERMINAL\n\tif (buf->b_term != NULL)\n\t    return term_get_status_text(buf->b_term);\n#endif\n\tif (buf->b_fname != NULL)\n\t    return buf->b_fname;\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(buf))\n\t    return (char_u *)_(\"[Prompt]\");\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (bt_popup(buf))\n\t    return (char_u *)_(\"[Popup]\");\n#endif\n\treturn (char_u *)_(\"[Scratch]\");\n    }\n\n    if (buf->b_fname == NULL)\n\treturn buf_get_fname(buf);\n    return NULL;\n}\n\n/*\n * Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\n */\n    char_u *\nbuf_get_fname(buf_T *buf)\n{\n    if (buf->b_fname == NULL)\n\treturn (char_u *)_(\"[No Name]\");\n    return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\n    void\nset_buflisted(int on)\n{\n    if (on != curbuf->b_p_bl)\n    {\n\tcurbuf->b_p_bl = on;\n\tif (on)\n\t    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n\telse\n\t    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n/*\n * Read the file for \"buf\" again and check if the contents changed.\n * Return TRUE if it changed or this could not be checked.\n */\n    int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // set curwin/curbuf to buf and save a few things\n    aucmd_prepbuf(&aco, newbuf);\n\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\n    void\nwipe_buffer(\n    buf_T\t*buf,\n    int\t\taucmd)\t    // When TRUE trigger autocommands.\n{\n    if (buf->b_fnum == top_file_num - 1)\n\t--top_file_num;\n\n    if (!aucmd)\t\t    // Don't trigger BufDelete autocommands here.\n\tblock_autocmds();\n\n    close_buffer(NULL, buf, DOBUF_WIPE, FALSE, TRUE);\n\n    if (!aucmd)\n\tunblock_autocmds();\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spell.c: code for spell checking\n *\n * See spellfile.c for the Vim spell file format.\n *\n * The spell checking mechanism uses a tree (aka trie).  Each node in the tree\n * has a list of bytes that can appear (siblings).  For each byte there is a\n * pointer to the node with the byte that follows in the word (child).\n *\n * A NUL byte is used where the word may end.  The bytes are sorted, so that\n * binary searching can be used and the NUL bytes are at the start.  The\n * number of possible bytes is stored before the list of bytes.\n *\n * The tree uses two arrays: \"byts\" stores the characters, \"idxs\" stores\n * either the next index or flags.  The tree starts at index 0.  For example,\n * to lookup \"vi\" this sequence is followed:\n *\ti = 0\n *\tlen = byts[i]\n *\tn = where \"v\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tn = where \"i\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tfind that byts[i + 1] is 0, idxs[i + 1] has flags for \"vi\".\n *\n * There are two word trees: one with case-folded words and one with words in\n * original case.  The second one is only used for keep-case words and is\n * usually small.\n *\n * There is one additional tree for when not all prefixes are applied when\n * generating the .spl file.  This tree stores all the possible prefixes, as\n * if they were words.  At each word (prefix) end the prefix nr is stored, the\n * following word must support this prefix nr.  And the condition nr is\n * stored, used to lookup the condition that the word must match with.\n *\n * Thanks to Olaf Seibert for providing an example implementation of this tree\n * and the compression mechanism.\n * LZ trie ideas:\n *\thttp://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf\n * More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html\n *\n * Matching involves checking the caps type: Onecap ALLCAP KeepCap.\n *\n * Why doesn't Vim use aspell/ispell/myspell/etc.?\n * See \":help develop-spell\".\n */\n\n#define IN_SPELL_C\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#define REGION_ALL 0xff\t\t// word valid in all regions\n\n// Result values.  Lower number is accepted over higher one.\n#define SP_BANNED\t(-1)\n#define SP_OK\t\t0\n#define SP_RARE\t\t1\n#define SP_LOCAL\t2\n#define SP_BAD\t\t3\n\n/*\n * Structure to store info for word matching.\n */\ntypedef struct matchinf_S\n{\n    langp_T\t*mi_lp;\t\t\t// info for language and region\n\n    // pointers to original text to be checked\n    char_u\t*mi_word;\t\t// start of word being checked\n    char_u\t*mi_end;\t\t// end of matching word so far\n    char_u\t*mi_fend;\t\t// next char to be added to mi_fword\n    char_u\t*mi_cend;\t\t// char after what was used for\n\t\t\t\t\t// mi_capflags\n\n    // case-folded text\n    char_u\tmi_fword[MAXWLEN + 1];\t// mi_word case-folded\n    int\t\tmi_fwordlen;\t\t// nr of valid bytes in mi_fword\n\n    // for when checking word after a prefix\n    int\t\tmi_prefarridx;\t\t// index in sl_pidxs with list of\n\t\t\t\t\t// affixID/condition\n    int\t\tmi_prefcnt;\t\t// number of entries at mi_prefarridx\n    int\t\tmi_prefixlen;\t\t// byte length of prefix\n    int\t\tmi_cprefixlen;\t\t// byte length of prefix in original\n\t\t\t\t\t// case\n\n    // for when checking a compound word\n    int\t\tmi_compoff;\t\t// start of following word offset\n    char_u\tmi_compflags[MAXWLEN];\t// flags for compound words used\n    int\t\tmi_complen;\t\t// nr of compound words used\n    int\t\tmi_compextra;\t\t// nr of COMPOUNDROOT words\n\n    // others\n    int\t\tmi_result;\t\t// result so far: SP_BAD, SP_OK, etc.\n    int\t\tmi_capflags;\t\t// WF_ONECAP WF_ALLCAP WF_KEEPCAP\n    win_T\t*mi_win;\t\t// buffer being checked\n\n    // for NOBREAK\n    int\t\tmi_result2;\t\t// \"mi_resul\" without following word\n    char_u\t*mi_end2;\t\t// \"mi_end\" without following word\n} matchinf_T;\n\n\nstatic int spell_mb_isword_class(int cl, win_T *wp);\n\n// mode values for find_word\n#define FIND_FOLDWORD\t    0\t// find word case-folded\n#define FIND_KEEPWORD\t    1\t// find keep-case word\n#define FIND_PREFIX\t    2\t// find word after prefix\n#define FIND_COMPOUND\t    3\t// find case-folded compound word\n#define FIND_KEEPCOMPOUND   4\t// find keep-case compound word\n\nstatic void find_word(matchinf_T *mip, int mode);\nstatic void find_prefix(matchinf_T *mip, int mode);\nstatic int fold_more(matchinf_T *mip);\nstatic void spell_load_cb(char_u *fname, void *cookie);\nstatic int count_syllables(slang_T *slang, char_u *word);\nstatic void clear_midword(win_T *buf);\nstatic void use_midword(slang_T *lp, win_T *buf);\nstatic int find_region(char_u *rp, char_u *region);\nstatic void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res);\nstatic void dump_word(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T lnum);\nstatic linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T startlnum);\n\n/*\n * Main spell-checking function.\n * \"ptr\" points to a character that could be the start of a word.\n * \"*attrp\" is set to the highlight index for a badly spelled word.  For a\n * non-word or when it's OK it remains unchanged.\n * This must only be called when 'spelllang' is not empty.\n *\n * \"capcol\" is used to check for a Capitalised word after the end of a\n * sentence.  If it's zero then perform the check.  Return the column where to\n * check next, or -1 when no sentence end was found.  If it's NULL then don't\n * worry.\n *\n * Returns the length of the word in bytes, also when it's OK, so that the\n * caller can skip over the word.\n */\n    int\nspell_check(\n    win_T\t*wp,\t\t// current window\n    char_u\t*ptr,\n    hlf_T\t*attrp,\n    int\t\t*capcol,\t// column to check for Capital\n    int\t\tdocount)\t// count good words\n{\n    matchinf_T\tmi;\t\t// Most things are put in \"mi\" so that it can\n\t\t\t\t// be passed to functions quickly.\n    int\t\tnrlen = 0;\t// found a number first\n    int\t\tc;\n    int\t\twrongcaplen = 0;\n    int\t\tlpi;\n    int\t\tcount_word = docount;\n    int\t\tuse_camel_case = *wp->w_s->b_p_spo != NUL;\n    int\t\tcamel_case = 0;\n\n    // A word never starts at a space or a control character.  Return quickly\n    // then, skipping over the character.\n    if (*ptr <= ' ')\n\treturn 1;\n\n    // Return here when loading language files failed.\n    if (wp->w_s->b_langp.ga_len == 0)\n\treturn 1;\n\n    CLEAR_FIELD(mi);\n\n    // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and\n    // 0X99FF.  But always do check spelling to find \"3GPP\" and \"11\n    // julifeest\".\n    if (*ptr >= '0' && *ptr <= '9')\n    {\n\tif (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B'))\n\t    mi.mi_end = skipbin(ptr + 2);\n\telse if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X'))\n\t    mi.mi_end = skiphex(ptr + 2);\n\telse\n\t    mi.mi_end = skipdigits(ptr);\n\tnrlen = (int)(mi.mi_end - ptr);\n    }\n\n    // Find the normal end of the word (until the next non-word character).\n    mi.mi_word = ptr;\n    mi.mi_fend = ptr;\n    if (spell_iswordp(mi.mi_fend, wp))\n    {\n\tint prev_upper;\n\tint this_upper = FALSE;  // init for gcc\n\n\tif (use_camel_case)\n\t{\n\t    c = PTR2CHAR(mi.mi_fend);\n\t    this_upper = SPELL_ISUPPER(c);\n\t}\n\n\tdo\n\t{\n\t    MB_PTR_ADV(mi.mi_fend);\n\t    if (use_camel_case)\n\t    {\n\t\tprev_upper = this_upper;\n\t\tc = PTR2CHAR(mi.mi_fend);\n\t\tthis_upper = SPELL_ISUPPER(c);\n\t\tcamel_case = !prev_upper && this_upper;\n\t    }\n\t} while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp)\n\t\t\t\t\t\t\t       && !camel_case);\n\n\tif (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL)\n\t{\n\t    // Check word starting with capital letter.\n\t    c = PTR2CHAR(ptr);\n\t    if (!SPELL_ISUPPER(c))\n\t\twrongcaplen = (int)(mi.mi_fend - ptr);\n\t}\n    }\n    if (capcol != NULL)\n\t*capcol = -1;\n\n    // We always use the characters up to the next non-word character,\n    // also for bad words.\n    mi.mi_end = mi.mi_fend;\n\n    // Check caps type later.\n    mi.mi_capflags = 0;\n    mi.mi_cend = NULL;\n    mi.mi_win = wp;\n\n    // case-fold the word with one non-word character, so that we can check\n    // for the word end.\n    if (*mi.mi_fend != NUL)\n\tMB_PTR_ADV(mi.mi_fend);\n\n    (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,\n\t\t\t\t\t\t\t     MAXWLEN + 1);\n    mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);\n\n    if (camel_case && mi.mi_fwordlen > 0)\n\t// Introduce a fake word end space into the folded word.\n\tmi.mi_fword[mi.mi_fwordlen - 1] = ' ';\n\n    // The word is bad unless we recognize it.\n    mi.mi_result = SP_BAD;\n    mi.mi_result2 = SP_BAD;\n\n    /*\n     * Loop over the languages specified in 'spelllang'.\n     * We check them all, because a word may be matched longer in another\n     * language.\n     */\n    for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi)\n    {\n\tmi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);\n\n\t// If reloading fails the language is still in the list but everything\n\t// has been cleared.\n\tif (mi.mi_lp->lp_slang->sl_fidxs == NULL)\n\t    continue;\n\n\t// Check for a matching word in case-folded words.\n\tfind_word(&mi, FIND_FOLDWORD);\n\n\t// Check for a matching word in keep-case words.\n\tfind_word(&mi, FIND_KEEPWORD);\n\n\t// Check for matching prefixes.\n\tfind_prefix(&mi, FIND_FOLDWORD);\n\n\t// For a NOBREAK language, may want to use a word without a following\n\t// word as a backup.\n\tif (mi.mi_lp->lp_slang->sl_nobreak && mi.mi_result == SP_BAD\n\t\t\t\t\t\t   && mi.mi_result2 != SP_BAD)\n\t{\n\t    mi.mi_result = mi.mi_result2;\n\t    mi.mi_end = mi.mi_end2;\n\t}\n\n\t// Count the word in the first language where it's found to be OK.\n\tif (count_word && mi.mi_result == SP_OK)\n\t{\n\t    count_common_word(mi.mi_lp->lp_slang, ptr,\n\t\t\t\t\t\t   (int)(mi.mi_end - ptr), 1);\n\t    count_word = FALSE;\n\t}\n    }\n\n    if (mi.mi_result != SP_OK)\n    {\n\t// If we found a number skip over it.  Allows for \"42nd\".  Do flag\n\t// rare and local words, e.g., \"3GPP\".\n\tif (nrlen > 0)\n\t{\n\t    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t\treturn nrlen;\n\t}\n\n\t// When we are at a non-word character there is no error, just\n\t// skip over the character (try looking for a word after it).\n\telse if (!spell_iswordp_nmw(ptr, wp))\n\t{\n\t    if (capcol != NULL && wp->w_s->b_cap_prog != NULL)\n\t    {\n\t\tregmatch_T\tregmatch;\n\t\tint\t\tr;\n\n\t\t// Check for end of sentence.\n\t\tregmatch.regprog = wp->w_s->b_cap_prog;\n\t\tregmatch.rm_ic = FALSE;\n\t\tr = vim_regexec(&regmatch, ptr, 0);\n\t\twp->w_s->b_cap_prog = regmatch.regprog;\n\t\tif (r)\n\t\t    *capcol = (int)(regmatch.endp[0] - ptr);\n\t    }\n\n\t    if (has_mbyte)\n\t\treturn (*mb_ptr2len)(ptr);\n\t    return 1;\n\t}\n\telse if (mi.mi_end == ptr)\n\t    // Always include at least one character.  Required for when there\n\t    // is a mixup in \"midword\".\n\t    MB_PTR_ADV(mi.mi_end);\n\telse if (mi.mi_result == SP_BAD\n\t\t&& LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak)\n\t{\n\t    char_u\t*p, *fp;\n\t    int\t\tsave_result = mi.mi_result;\n\n\t    // First language in 'spelllang' is NOBREAK.  Find first position\n\t    // at which any word would be valid.\n\t    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, 0);\n\t    if (mi.mi_lp->lp_slang->sl_fidxs != NULL)\n\t    {\n\t\tp = mi.mi_word;\n\t\tfp = mi.mi_fword;\n\t\tfor (;;)\n\t\t{\n\t\t    MB_PTR_ADV(p);\n\t\t    MB_PTR_ADV(fp);\n\t\t    if (p >= mi.mi_end)\n\t\t\tbreak;\n\t\t    mi.mi_compoff = (int)(fp - mi.mi_fword);\n\t\t    find_word(&mi, FIND_COMPOUND);\n\t\t    if (mi.mi_result != SP_BAD)\n\t\t    {\n\t\t\tmi.mi_end = p;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tmi.mi_result = save_result;\n\t    }\n\t}\n\n\tif (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t    *attrp = HLF_SPB;\n\telse if (mi.mi_result == SP_RARE)\n\t    *attrp = HLF_SPR;\n\telse\n\t    *attrp = HLF_SPL;\n    }\n\n    if (wrongcaplen > 0 && (mi.mi_result == SP_OK || mi.mi_result == SP_RARE))\n    {\n\t// Report SpellCap only when the word isn't badly spelled.\n\t*attrp = HLF_SPC;\n\treturn wrongcaplen;\n    }\n\n    return (int)(mi.mi_end - ptr);\n}\n\n/*\n * Check if the word at \"mip->mi_word\" is in the tree.\n * When \"mode\" is FIND_FOLDWORD check in fold-case word tree.\n * When \"mode\" is FIND_KEEPWORD check in keep-case word tree.\n * When \"mode\" is FIND_PREFIX check for word after prefix in fold-case word\n * tree.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_word(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tendlen[MAXWLEN];    // length at possible word endings\n    idx_T\tendidx[MAXWLEN];    // possible word endings\n    int\t\tendidxcnt = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tres = SP_BAD;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    unsigned\tflags;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tword_ends;\n    int\t\tprefix_found;\n    int\t\tnobreak_result;\n\n    if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND)\n    {\n\t// Check for word with matching case in keep-case tree.\n\tptr = mip->mi_word;\n\tflen = 9999;\t\t    // no case folding, always enough bytes\n\tbyts = slang->sl_kbyts;\n\tidxs = slang->sl_kidxs;\n\n\tif (mode == FIND_KEEPCOMPOUND)\n\t    // Skip over the previously found word(s).\n\t    wlen += mip->mi_compoff;\n    }\n    else\n    {\n\t// Check for case-folded in case-folded tree.\n\tptr = mip->mi_fword;\n\tflen = mip->mi_fwordlen;    // available case-folded bytes\n\tbyts = slang->sl_fbyts;\n\tidxs = slang->sl_fidxs;\n\n\tif (mode == FIND_PREFIX)\n\t{\n\t    // Skip over the prefix.\n\t    wlen = mip->mi_prefixlen;\n\t    flen -= mip->mi_prefixlen;\n\t}\n\telse if (mode == FIND_COMPOUND)\n\t{\n\t    // Skip over the previously found word(s).\n\t    wlen = mip->mi_compoff;\n\t    flen -= mip->mi_compoff;\n\t}\n\n    }\n\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the word could end here.\n\t// Remember this index, we first check for the longest word.\n\tif (byts[arridx] == 0)\n\t{\n\t    if (endidxcnt == MAXWLEN)\n\t    {\n\t\t// Must be a corrupted spell file.\n\t\temsg(_(e_format_error_in_spell_file));\n\t\treturn;\n\t    }\n\t    endlen[endidxcnt] = wlen;\n\t    endidx[endidxcnt++] = arridx++;\n\t    --len;\n\n\t    // Skip over the zeros, there can be several flag/region\n\t    // combinations.\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tif (c == TAB)\t    // <Tab> is handled like <Space>\n\t    c = ' ';\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n\n\t// One space in the good word may stand for several spaces in the\n\t// checked word.\n\tif (c == ' ')\n\t{\n\t    for (;;)\n\t    {\n\t\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t\t    flen = fold_more(mip);\n\t\tif (ptr[wlen] != ' ' && ptr[wlen] != TAB)\n\t\t    break;\n\t\t++wlen;\n\t\t--flen;\n\t    }\n\t}\n    }\n\n    /*\n     * Verify that one of the possible endings is valid.  Try the longest\n     * first.\n     */\n    while (endidxcnt > 0)\n    {\n\t--endidxcnt;\n\tarridx = endidx[endidxcnt];\n\twlen = endlen[endidxcnt];\n\n\tif ((*mb_head_off)(ptr, ptr + wlen) > 0)\n\t    continue;\t    // not at first byte of character\n\tif (spell_iswordp(ptr + wlen, mip->mi_win))\n\t{\n\t    if (slang->sl_compprog == NULL && !slang->sl_nobreak)\n\t\tcontinue;\t    // next char is a word character\n\t    word_ends = FALSE;\n\t}\n\telse\n\t    word_ends = TRUE;\n\t// The prefix flag is before compound flags.  Once a valid prefix flag\n\t// has been found we try compound flags.\n\tprefix_found = FALSE;\n\n\tif (mode != FIND_KEEPWORD && has_mbyte)\n\t{\n\t    // Compute byte length in original word, length may change\n\t    // when folding case.  This can be slow, take a shortcut when the\n\t    // case-folded word is equal to the keep-case word.\n\t    p = mip->mi_word;\n\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t    {\n\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t    MB_PTR_ADV(p);\n\t\twlen = (int)(p - mip->mi_word);\n\t    }\n\t}\n\n\t// Check flags and region.  For FIND_PREFIX check the condition and\n\t// prefix ID.\n\t// Repeat this if there are more flags/region alternatives until there\n\t// is a match.\n\tres = SP_BAD;\n\tfor (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;\n\t\t\t\t\t\t\t      --len, ++arridx)\n\t{\n\t    flags = idxs[arridx];\n\n\t    // For the fold-case tree check that the case of the checked word\n\t    // matches with what the word in the tree requires.\n\t    // For keep-case tree the case is always right.  For prefixes we\n\t    // don't bother to check.\n\t    if (mode == FIND_FOLDWORD)\n\t    {\n\t\tif (mip->mi_cend != mip->mi_word + wlen)\n\t\t{\n\t\t    // mi_capflags was set for a different word length, need\n\t\t    // to do it again.\n\t\t    mip->mi_cend = mip->mi_word + wlen;\n\t\t    mip->mi_capflags = captype(mip->mi_word, mip->mi_cend);\n\t\t}\n\n\t\tif (mip->mi_capflags == WF_KEEPCAP\n\t\t\t\t|| !spell_valid_case(mip->mi_capflags, flags))\n\t\t    continue;\n\t    }\n\n\t    // When mode is FIND_PREFIX the word must support the prefix:\n\t    // check the prefix ID and the condition.  Do that for the list at\n\t    // mip->mi_prefarridx that find_prefix() filled.\n\t    else if (mode == FIND_PREFIX && !prefix_found)\n\t    {\n\t\tc = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,\n\t\t\t\t    flags,\n\t\t\t\t    mip->mi_word + mip->mi_cprefixlen, slang,\n\t\t\t\t    FALSE);\n\t\tif (c == 0)\n\t\t    continue;\n\n\t\t// Use the WF_RARE flag for a rare prefix.\n\t\tif (c & WF_RAREPFX)\n\t\t    flags |= WF_RARE;\n\t\tprefix_found = TRUE;\n\t    }\n\n\t    if (slang->sl_nobreak)\n\t    {\n\t\tif ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)\n\t\t\t&& (flags & WF_BANNED) == 0)\n\t\t{\n\t\t    // NOBREAK: found a valid following word.  That's all we\n\t\t    // need to know, so return.\n\t\t    mip->mi_result = SP_OK;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND\n\t\t\t\t\t\t\t\t|| !word_ends))\n\t    {\n\t\t// If there is no compound flag or the word is shorter than\n\t\t// COMPOUNDMIN reject it quickly.\n\t\t// Makes you wonder why someone puts a compound flag on a word\n\t\t// that's too short...  Myspell compatibility requires this\n\t\t// anyway.\n\t\tif (((unsigned)flags >> 24) == 0\n\t\t\t     || wlen - mip->mi_compoff < slang->sl_compminlen)\n\t\t    continue;\n\t\t// For multi-byte chars check character length against\n\t\t// COMPOUNDMIN.\n\t\tif (has_mbyte\n\t\t\t&& slang->sl_compminlen > 0\n\t\t\t&& mb_charlen_len(mip->mi_word + mip->mi_compoff,\n\t\t\t\twlen - mip->mi_compoff) < slang->sl_compminlen)\n\t\t\tcontinue;\n\n\t\t// Limit the number of compound words to COMPOUNDWORDMAX if no\n\t\t// maximum for syllables is specified.\n\t\tif (!word_ends && mip->mi_complen + mip->mi_compextra + 2\n\t\t\t\t\t\t\t   > slang->sl_compmax\n\t\t\t\t\t   && slang->sl_compsylmax == MAXWLEN)\n\t\t    continue;\n\n\t\t// Don't allow compounding on a side where an affix was added,\n\t\t// unless COMPOUNDPERMITFLAG was used.\n\t\tif (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))\n\t\t    continue;\n\t\tif (!word_ends && (flags & WF_NOCOMPAFT))\n\t\t    continue;\n\n\t\t// Quickly check if compounding is possible with this flag.\n\t\tif (!byte_in_str(mip->mi_complen == 0\n\t\t\t\t\t? slang->sl_compstartflags\n\t\t\t\t\t: slang->sl_compallflags,\n\t\t\t\t\t    ((unsigned)flags >> 24)))\n\t\t    continue;\n\n\t\t// If there is a match with a CHECKCOMPOUNDPATTERN rule\n\t\t// discard the compound word.\n\t\tif (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))\n\t\t    continue;\n\n\t\tif (mode == FIND_COMPOUND)\n\t\t{\n\t\t    int\t    capflags;\n\n\t\t    // Need to check the caps type of the appended compound\n\t\t    // word.\n\t\t    if (has_mbyte && STRNCMP(ptr, mip->mi_word,\n\t\t\t\t\t\t\tmip->mi_compoff) != 0)\n\t\t    {\n\t\t\t// case folding may have changed the length\n\t\t\tp = mip->mi_word;\n\t\t\tfor (s = ptr; s < ptr + mip->mi_compoff; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t    }\n\t\t    else\n\t\t\tp = mip->mi_word + mip->mi_compoff;\n\t\t    capflags = captype(p, mip->mi_word + wlen);\n\t\t    if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP\n\t\t\t\t\t\t && (flags & WF_FIXCAP) != 0))\n\t\t\tcontinue;\n\n\t\t    if (capflags != WF_ALLCAP)\n\t\t    {\n\t\t\t// When the character before the word is a word\n\t\t\t// character we do not accept a Onecap word.  We do\n\t\t\t// accept a no-caps word, even when the dictionary\n\t\t\t// word specifies ONECAP.\n\t\t\tMB_PTR_BACK(mip->mi_word, p);\n\t\t\tif (spell_iswordp_nmw(p, mip->mi_win)\n\t\t\t\t? capflags == WF_ONECAP\n\t\t\t\t: (flags & WF_ONECAP) != 0\n\t\t\t\t\t\t     && capflags != WF_ONECAP)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\t// If the word ends the sequence of compound flags of the\n\t\t// words must match with one of the COMPOUNDRULE items and\n\t\t// the number of syllables must not be too large.\n\t\tmip->mi_compflags[mip->mi_complen] = ((unsigned)flags >> 24);\n\t\tmip->mi_compflags[mip->mi_complen + 1] = NUL;\n\t\tif (word_ends)\n\t\t{\n\t\t    char_u\tfword[MAXWLEN];\n\n\t\t    if (slang->sl_compsylmax < MAXWLEN)\n\t\t    {\n\t\t\t// \"fword\" is only needed for checking syllables.\n\t\t\tif (ptr == mip->mi_word)\n\t\t\t    (void)spell_casefold(mip->mi_win,\n\t\t\t\t\t\t    ptr, wlen, fword, MAXWLEN);\n\t\t\telse\n\t\t\t    vim_strncpy(fword, ptr, endlen[endidxcnt]);\n\t\t    }\n\t\t    if (!can_compound(slang, fword, mip->mi_compflags))\n\t\t\tcontinue;\n\t\t}\n\t\telse if (slang->sl_comprules != NULL\n\t\t\t     && !match_compoundrule(slang, mip->mi_compflags))\n\t\t    // The compound flags collected so far do not match any\n\t\t    // COMPOUNDRULE, discard the compounded word.\n\t\t    continue;\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.\n\t    else if (flags & WF_NEEDCOMP)\n\t\tcontinue;\n\n\t    nobreak_result = SP_OK;\n\n\t    if (!word_ends)\n\t    {\n\t\tint\tsave_result = mip->mi_result;\n\t\tchar_u\t*save_end = mip->mi_end;\n\t\tlangp_T\t*save_lp = mip->mi_lp;\n\t\tint\tlpi;\n\n\t\t// Check that a valid word follows.  If there is one and we\n\t\t// are compounding, it will set \"mi_result\", thus we are\n\t\t// always finished here.  For NOBREAK we only check that a\n\t\t// valid word follows.\n\t\t// Recursive!\n\t\tif (slang->sl_nobreak)\n\t\t    mip->mi_result = SP_BAD;\n\n\t\t// Find following word in case-folded tree.\n\t\tmip->mi_compoff = endlen[endidxcnt];\n\t\tif (has_mbyte && mode == FIND_KEEPWORD)\n\t\t{\n\t\t    // Compute byte length in case-folded word from \"wlen\":\n\t\t    // byte length in keep-case word.  Length may change when\n\t\t    // folding case.  This can be slow, take a shortcut when\n\t\t    // the case-folded word is equal to the keep-case word.\n\t\t    p = mip->mi_fword;\n\t\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t\t    {\n\t\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t\tmip->mi_compoff = (int)(p - mip->mi_fword);\n\t\t    }\n\t\t}\n#if 0 // Disabled, see below\n\t\tc = mip->mi_compoff;\n#endif\n\t\t++mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    ++mip->mi_compextra;\n\n\t\t// For NOBREAK we need to try all NOBREAK languages, at least\n\t\t// to find the \".add\" file(s).\n\t\tfor (lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi)\n\t\t{\n\t\t    if (slang->sl_nobreak)\n\t\t    {\n\t\t\tmip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);\n\t\t\tif (mip->mi_lp->lp_slang->sl_fidxs == NULL\n\t\t\t\t\t || !mip->mi_lp->lp_slang->sl_nobreak)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    find_word(mip, FIND_COMPOUND);\n\n\t\t    // When NOBREAK any word that matches is OK.  Otherwise we\n\t\t    // need to find the longest match, thus try with keep-case\n\t\t    // and prefix too.\n\t\t    if (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t    {\n\t\t\t// Find following word in keep-case tree.\n\t\t\tmip->mi_compoff = wlen;\n\t\t\tfind_word(mip, FIND_KEEPCOMPOUND);\n\n#if 0\t    // Disabled, a prefix must not appear halfway a compound word,\n\t    // unless the COMPOUNDPERMITFLAG is used and then it can't be a\n\t    // postponed prefix.\n\t\t\tif (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t\t{\n\t\t\t    // Check for following word with prefix.\n\t\t\t    mip->mi_compoff = c;\n\t\t\t    find_prefix(mip, FIND_COMPOUND);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t    if (!slang->sl_nobreak)\n\t\t\tbreak;\n\t\t}\n\t\t--mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    --mip->mi_compextra;\n\t\tmip->mi_lp = save_lp;\n\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    nobreak_result = mip->mi_result;\n\t\t    mip->mi_result = save_result;\n\t\t    mip->mi_end = save_end;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (mip->mi_result == SP_OK)\n\t\t\tbreak;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    if (flags & WF_BANNED)\n\t\tres = SP_BANNED;\n\t    else if (flags & WF_REGION)\n\t    {\n\t\t// Check region.\n\t\tif ((mip->mi_lp->lp_region & (flags >> 16)) != 0)\n\t\t    res = SP_OK;\n\t\telse\n\t\t    res = SP_LOCAL;\n\t    }\n\t    else if (flags & WF_RARE)\n\t\tres = SP_RARE;\n\t    else\n\t\tres = SP_OK;\n\n\t    // Always use the longest match and the best result.  For NOBREAK\n\t    // we separately keep the longest match without a following good\n\t    // word as a fall-back.\n\t    if (nobreak_result == SP_BAD)\n\t    {\n\t\tif (mip->mi_result2 > res)\n\t\t{\n\t\t    mip->mi_result2 = res;\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t\t}\n\t\telse if (mip->mi_result2 == res\n\t\t\t\t\t&& mip->mi_end2 < mip->mi_word + wlen)\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result > res)\n\t    {\n\t\tmip->mi_result = res;\n\t\tmip->mi_end = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)\n\t\tmip->mi_end = mip->mi_word + wlen;\n\n\t    if (mip->mi_result == SP_OK)\n\t\tbreak;\n\t}\n\n\tif (mip->mi_result == SP_OK)\n\t    break;\n    }\n}\n\n/*\n * Return TRUE if there is a match between the word ptr[wlen] and\n * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another\n * word.\n * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the\n * end of ptr[wlen] and the second part matches after it.\n */\n    int\nmatch_checkcompoundpattern(\n    char_u\t*ptr,\n    int\t\twlen,\n    garray_T\t*gap)  // &sl_comppat\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n\n    for (i = 0; i + 1 < gap->ga_len; i += 2)\n    {\n\tp = ((char_u **)gap->ga_data)[i + 1];\n\tif (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)\n\t{\n\t    // Second part matches at start of following compound word, now\n\t    // check if first part matches at end of previous word.\n\t    p = ((char_u **)gap->ga_data)[i];\n\t    len = (int)STRLEN(p);\n\t    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"flags\" is a valid sequence of compound flags and \"word\"\n * does not have too many syllables.\n */\n    int\ncan_compound(slang_T *slang, char_u *word, char_u *flags)\n{\n    char_u\tuflags[MAXWLEN * 2];\n    int\t\ti;\n    char_u\t*p;\n\n    if (slang->sl_compprog == NULL)\n\treturn FALSE;\n    if (enc_utf8)\n    {\n\t// Need to convert the single byte flags to utf8 characters.\n\tp = uflags;\n\tfor (i = 0; flags[i] != NUL; ++i)\n\t    p += utf_char2bytes(flags[i], p);\n\t*p = NUL;\n\tp = uflags;\n    }\n    else\n\tp = flags;\n    if (!vim_regexec_prog(&slang->sl_compprog, FALSE, p, 0))\n\treturn FALSE;\n\n    // Count the number of syllables.  This may be slow, do it last.  If there\n    // are too many syllables AND the number of compound words is above\n    // COMPOUNDWORDMAX then compounding is not allowed.\n    if (slang->sl_compsylmax < MAXWLEN\n\t\t       && count_syllables(slang, word) > slang->sl_compsylmax)\n\treturn (int)STRLEN(flags) < slang->sl_compmax;\n    return TRUE;\n}\n\n/*\n * Return TRUE if the compound flags in compflags[] match the start of any\n * compound rule.  This is used to stop trying a compound if the flags\n * collected so far can't possibly match any compound rule.\n * Caller must check that slang->sl_comprules is not NULL.\n */\n    int\nmatch_compoundrule(slang_T *slang, char_u *compflags)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n\n    // loop over all the COMPOUNDRULE entries\n    for (p = slang->sl_comprules; *p != NUL; ++p)\n    {\n\t// loop over the flags in the compound word we have made, match\n\t// them against the current rule entry\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = compflags[i];\n\t    if (c == NUL)\n\t\t// found a rule that matches for the flags we have so far\n\t\treturn TRUE;\n\t    if (*p == '/' || *p == NUL)\n\t\tbreak;  // end of rule, it's too short\n\t    if (*p == '[')\n\t    {\n\t\tint match = FALSE;\n\n\t\t// compare against all the flags in []\n\t\t++p;\n\t\twhile (*p != ']' && *p != NUL)\n\t\t    if (*p++ == c)\n\t\t\tmatch = TRUE;\n\t\tif (!match)\n\t\t    break;  // none matches\n\t    }\n\t    else if (*p != c)\n\t\tbreak;  // flag of word doesn't match flag in pattern\n\t    ++p;\n\t}\n\n\t// Skip to the next \"/\", where the next pattern starts.\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    break;\n    }\n\n    // Checked all the rules and none of them match the flags, so there\n    // can't possibly be a compound starting with these flags.\n    return FALSE;\n}\n\n/*\n * Return non-zero if the prefix indicated by \"arridx\" matches with the prefix\n * ID in \"flags\" for the word \"word\".\n * The WF_RAREPFX flag is included in the return value for a rare prefix.\n */\n    int\nvalid_word_prefix(\n    int\t\ttotprefcnt,\t// nr of prefix IDs\n    int\t\tarridx,\t\t// idx in sl_pidxs[]\n    int\t\tflags,\n    char_u\t*word,\n    slang_T\t*slang,\n    int\t\tcond_req)\t// only use prefixes with a condition\n{\n    int\t\tprefcnt;\n    int\t\tpidx;\n    regprog_T\t**rp;\n    int\t\tprefid;\n\n    prefid = (unsigned)flags >> 24;\n    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)\n    {\n\tpidx = slang->sl_pidxs[arridx + prefcnt];\n\n\t// Check the prefix ID.\n\tif (prefid != (pidx & 0xff))\n\t    continue;\n\n\t// Check if the prefix doesn't combine and the word already has a\n\t// suffix.\n\tif ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n\t    continue;\n\n\t// Check the condition, if there is one.  The condition index is\n\t// stored in the two bytes above the prefix ID byte.\n\trp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n\tif (*rp != NULL)\n\t{\n\t    if (!vim_regexec_prog(rp, FALSE, word, 0))\n\t\tcontinue;\n\t}\n\telse if (cond_req)\n\t    continue;\n\n\t// It's a match!  Return the WF_ flags.\n\treturn pidx;\n    }\n    return 0;\n}\n\n/*\n * Check if the word at \"mip->mi_word\" has a matching prefix.\n * If it does, then check the following word.\n *\n * If \"mode\" is \"FIND_COMPOUND\" then do the same after another word, find a\n * prefix in a compound word.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_prefix(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    char_u\t*byts;\n    idx_T\t*idxs;\n\n    byts = slang->sl_pbyts;\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    // We use the case-folded word here, since prefixes are always\n    // case-folded.\n    ptr = mip->mi_fword;\n    flen = mip->mi_fwordlen;    // available case-folded bytes\n    if (mode == FIND_COMPOUND)\n    {\n\t// Skip over the previously found word(s).\n\tptr += mip->mi_compoff;\n\tflen -= mip->mi_compoff;\n    }\n    idxs = slang->sl_pidxs;\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen == 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the prefix could end here.\n\t// Check if the following word matches and supports the prefix.\n\tif (byts[arridx] == 0)\n\t{\n\t    // There can be several prefixes with different conditions.  We\n\t    // try them all, since we don't know which one will give the\n\t    // longest match.  The word is the same each time, pass the list\n\t    // of possible prefixes to find_word().\n\t    mip->mi_prefarridx = arridx;\n\t    mip->mi_prefcnt = len;\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    mip->mi_prefcnt -= len;\n\n\t    // Find the word that comes after the prefix.\n\t    mip->mi_prefixlen = wlen;\n\t    if (mode == FIND_COMPOUND)\n\t\t// Skip over the previously found word(s).\n\t\tmip->mi_prefixlen += mip->mi_compoff;\n\n\t    if (has_mbyte)\n\t    {\n\t\t// Case-folded length may differ from original length.\n\t\tmip->mi_cprefixlen = nofold_len(mip->mi_fword,\n\t\t\t\t\t     mip->mi_prefixlen, mip->mi_word);\n\t    }\n\t    else\n\t\tmip->mi_cprefixlen = mip->mi_prefixlen;\n\t    find_word(mip, FIND_PREFIX);\n\n\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n    }\n}\n\n/*\n * Need to fold at least one more character.  Do until next non-word character\n * for efficiency.  Include the non-word character too.\n * Return the length of the folded chars in bytes.\n */\n    static int\nfold_more(matchinf_T *mip)\n{\n    int\t\tflen;\n    char_u\t*p;\n\n    p = mip->mi_fend;\n    do\n\tMB_PTR_ADV(mip->mi_fend);\n    while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));\n\n    // Include the non-word character so that we can check for the word end.\n    if (*mip->mi_fend != NUL)\n\tMB_PTR_ADV(mip->mi_fend);\n\n    (void)spell_casefold(mip->mi_win, p, (int)(mip->mi_fend - p),\n\t\t\t     mip->mi_fword + mip->mi_fwordlen,\n\t\t\t     MAXWLEN - mip->mi_fwordlen);\n    flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);\n    mip->mi_fwordlen += flen;\n    return flen;\n}\n\n/*\n * Check case flags for a word.  Return TRUE if the word has the requested\n * case.\n */\n    int\nspell_valid_case(\n    int\t    wordflags,\t    // flags for the checked word.\n    int\t    treeflags)\t    // flags for the word in the spell tree\n{\n    return ((wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)\n\t    || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0\n\t\t&& ((treeflags & WF_ONECAP) == 0\n\t\t\t\t\t   || (wordflags & WF_ONECAP) != 0)));\n}\n\n/*\n * Return TRUE if spell checking is enabled for \"wp\".\n */\n    int\nspell_check_window(win_T *wp)\n{\n    return wp->w_p_spell\n\t\t&& *wp->w_s->b_p_spl != NUL\n\t\t&& wp->w_s->b_langp.ga_len > 0\n\t\t&& *(char **)(wp->w_s->b_langp.ga_data) != NULL;\n}\n\n/*\n * Return TRUE and give an error if spell checking is not enabled.\n */\n    static int\nno_spell_checking(win_T *wp)\n{\n    if (spell_check_window(wp))\n\treturn FALSE;\n    emsg(_(e_spell_checking_is_not_possible));\n    return TRUE;\n}\n\n/*\n * Move to next spell error.\n * \"curline\" is FALSE for \"[s\", \"]s\", \"[S\" and \"]S\".\n * \"curline\" is TRUE to find word under/after cursor in the same line.\n * For Insert mode completion \"dir\" is BACKWARD and \"curline\" is TRUE: move\n * to after badly spelled word before the cursor.\n * Return 0 if not found, length of the badly spelled word otherwise.\n */\n    int\nspell_move_to(\n    win_T\t*wp,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tallwords,\t// TRUE for \"[s\"/\"]s\", FALSE for \"[S\"/\"]S\"\n    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr = 0;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n    int\t\tfound_one = FALSE;\n    int\t\twrapped = FALSE;\n\n    if (no_spell_checking(wp))\n\treturn 0;\n\n    /*\n     * Start looking for bad word at the start of the line, because we can't\n     * start halfway a word, we don't know where it starts or ends.\n     *\n     * When searching backwards, we continue in the line to find the last\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tint empty_line;\n\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t}\n\n\t// In first line check first word for Capital.\n\tif (lnum == 1)\n\t    capcol = 0;\n\n\t// For checking first word with a capital skip white space.\n\tif (capcol == 0)\n\t    capcol = getwhitecols(line);\n\telse if (curline && wp == curwin)\n\t{\n\t    // For spellbadword(): check if first word needs a capital.\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.  Note: this ml_get_buf() may make \"line\" invalid, check\n\t// for empty line first.\n\tempty_line = *skipwhite(line) == NUL;\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // we wrapped around the end of the buffer.\n\t    if (dir == BACKWARD\n\t\t    && lnum == wp->w_cursor.lnum\n\t\t    && !wrapped\n\t\t    && (colnr_T)(p - buf) >= wp->w_cursor.col)\n\t\tbreak;\n\n\t    // start of word\n\t    attr = HLF_COUNT;\n\t    len = spell_check(wp, p, &attr, &capcol, FALSE);\n\n\t    if (attr != HLF_COUNT)\n\t    {\n\t\t// We found a bad word.  Check the attribute.\n\t\tif (allwords || attr == HLF_SPB)\n\t\t{\n\t\t    // When searching forward only accept a bad word after\n\t\t    // the cursor.\n\t\t    if (dir == BACKWARD\n\t\t\t    || lnum != wp->w_cursor.lnum\n\t\t\t    || (wrapped\n\t\t\t\t|| (colnr_T)(curline ? p - buf + len\n\t\t\t\t\t\t     : p - buf)\n\t\t\t\t\t\t  > wp->w_cursor.col))\n\t\t    {\n#ifdef FEAT_SYN_HL\n\t\t\tif (has_syntax)\n\t\t\t{\n\t\t\t    col = (int)(p - buf);\n\t\t\t    (void)syn_get_id(wp, lnum, (colnr_T)col,\n\t\t\t\t\t\t    FALSE, &can_spell, FALSE);\n\t\t\t    if (!can_spell)\n\t\t\t\tattr = HLF_COUNT;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    can_spell = TRUE;\n\n\t\t\tif (can_spell)\n\t\t\t{\n\t\t\t    found_one = TRUE;\n\t\t\t    found_pos.lnum = lnum;\n\t\t\t    found_pos.col = (int)(p - buf);\n\t\t\t    found_pos.coladd = 0;\n\t\t\t    if (dir == FORWARD)\n\t\t\t    {\n\t\t\t\t// No need to search further.\n\t\t\t\twp->w_cursor = found_pos;\n\t\t\t\tvim_free(buf);\n\t\t\t\tif (attrp != NULL)\n\t\t\t\t    *attrp = attr;\n\t\t\t\treturn len;\n\t\t\t    }\n\t\t\t    else if (curline)\n\t\t\t\t// Insert mode completion: put cursor after\n\t\t\t\t// the bad word.\n\t\t\t\tfound_pos.col += len;\n\t\t\t    found_len = len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfound_one = TRUE;\n\t\t}\n\t    }\n\n\t    // advance to character after the word\n\t    p += len;\n\t    capcol -= len;\n\t}\n\n\tif (dir == BACKWARD && found_pos.lnum != 0)\n\t{\n\t    // Use the last match in the line (before the cursor).\n\t    wp->w_cursor = found_pos;\n\t    vim_free(buf);\n\t    return found_len;\n\t}\n\n\tif (curline)\n\t    break;\t// only check cursor line\n\n\t// If we are back at the starting line and searched it again there\n\t// is no match, give up.\n\tif (lnum == wp->w_cursor.lnum && wrapped)\n\t    break;\n\n\t// Advance to next line.\n\tif (dir == BACKWARD)\n\t{\n\t    if (lnum > 1)\n\t\t--lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the end of the buffer.  May search the\n\t\t// starting line again and accept the last match.\n\t\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    capcol = -1;\n\t}\n\telse\n\t{\n\t    if (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t\t++lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the start of the buffer.  May search the\n\t\t// starting line again and accept the first match.\n\t\tlnum = 1;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\n\t    // If we are back at the starting line and there is no match then\n\t    // give up.\n\t    if (lnum == wp->w_cursor.lnum && !found_one)\n\t\tbreak;\n\n\t    // Skip the characters at the start of the next line that were\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (empty_line)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}\n\n/*\n * For spell checking: concatenate the start of the following line \"line\" into\n * \"buf\", blanking-out special characters.  Copy less than \"maxlen\" bytes.\n * Keep the blanks at the start of the next line, this is used in win_line()\n * to skip those bytes if the word was OK.\n */\n    void\nspell_cat_line(char_u *buf, char_u *line, int maxlen)\n{\n    char_u\t*p;\n    int\t\tn;\n\n    p = skipwhite(line);\n    while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)\n\tp = skipwhite(p + 1);\n\n    if (*p != NUL)\n    {\n\t// Only worth concatenating if there is something else than spaces to\n\t// concatenate.\n\tn = (int)(p - line) + 1;\n\tif (n < maxlen - 1)\n\t{\n\t    vim_memset(buf, ' ', n);\n\t    vim_strncpy(buf +  n, p, maxlen - 1 - n);\n\t}\n    }\n}\n\n/*\n * Structure used for the cookie argument of do_in_runtimepath().\n */\ntypedef struct spelload_S\n{\n    char_u  sl_lang[MAXWLEN + 1];\t// language name\n    slang_T *sl_slang;\t\t\t// resulting slang_T struct\n    int\t    sl_nobreak;\t\t\t// NOBREAK language found\n} spelload_T;\n\n/*\n * Load word list(s) for \"lang\" from Vim spell file(s).\n * \"lang\" must be the language without the region: e.g., \"en\".\n */\n    static void\nspell_load_lang(char_u *lang)\n{\n    char_u\tfname_enc[85];\n    int\t\tr;\n    spelload_T\tsl;\n    int\t\tround;\n\n    // Copy the language name to pass it to spell_load_cb() as a cookie.\n    // It's truncated when an error is detected.\n    STRCPY(sl.sl_lang, lang);\n    sl.sl_slang = NULL;\n    sl.sl_nobreak = FALSE;\n\n    // We may retry when no spell file is found for the language, an\n    // autocommand may load it then.\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Find the first spell file for \"lang\" in 'runtimepath' and load it.\n\t */\n\tvim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\"spell/%s_%s.spl\",\n#else\n\t\t\t\t\t\"spell/%s.%s.spl\",\n#endif\n\t\t\t\t\t\t\t   lang, spell_enc());\n\tr = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\tif (r == FAIL && *sl.sl_lang != NUL)\n\t{\n\t    // Try loading the ASCII version.\n\t    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\t  \"spell/%s_ascii.spl\",\n#else\n\t\t\t\t\t\t  \"spell/%s.ascii.spl\",\n#endif\n\t\t\t\t\t\t\t\t\tlang);\n\t    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\t    if (r == FAIL && *sl.sl_lang != NUL && round == 1\n\t\t    && apply_autocmds(EVENT_SPELLFILEMISSING, lang,\n\t\t\t\t\t      curbuf->b_fname, FALSE, curbuf))\n\t\tcontinue;\n\t    break;\n\t}\n\tbreak;\n    }\n\n    if (r == FAIL)\n    {\n\tsmsg(\n#ifdef VMS\n\t_(\"Warning: Cannot find word list \\\"%s_%s.spl\\\" or \\\"%s_ascii.spl\\\"\"),\n#else\n\t_(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),\n#endif\n\t\t\t\t\t\t     lang, spell_enc(), lang);\n    }\n    else if (sl.sl_slang != NULL)\n    {\n\t// At least one file was loaded, now load ALL the additions.\n\tSTRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n\tdo_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl);\n    }\n}\n\n/*\n * Return the encoding used for spell checking: Use 'encoding', except that we\n * use \"latin1\" for \"latin9\".  And limit to 60 characters (just in case).\n */\n    char_u *\nspell_enc(void)\n{\n\n    if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)\n\treturn p_enc;\n    return (char_u *)\"latin1\";\n}\n\n/*\n * Get the name of the .spl file for the internal wordlist into\n * \"fname[MAXPATHL]\".\n */\n    static void\nint_wordlist_spl(char_u *fname)\n{\n    vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t\t\t\t\t  int_wordlist, spell_enc());\n}\n\n/*\n * Allocate a new slang_T for language \"lang\".  \"lang\" can be NULL.\n * Caller must fill \"sl_next\".\n */\n    slang_T *\nslang_alloc(char_u *lang)\n{\n    slang_T *lp;\n\n    lp = ALLOC_CLEAR_ONE(slang_T);\n    if (lp != NULL)\n    {\n\tif (lang != NULL)\n\t    lp->sl_name = vim_strsave(lang);\n\tga_init2(&lp->sl_rep, sizeof(fromto_T), 10);\n\tga_init2(&lp->sl_repsal, sizeof(fromto_T), 10);\n\tlp->sl_compmax = MAXWLEN;\n\tlp->sl_compsylmax = MAXWLEN;\n\thash_init(&lp->sl_wordcount);\n    }\n\n    return lp;\n}\n\n/*\n * Free the contents of an slang_T and the structure itself.\n */\n    void\nslang_free(slang_T *lp)\n{\n    vim_free(lp->sl_name);\n    vim_free(lp->sl_fname);\n    slang_clear(lp);\n    vim_free(lp);\n}\n\n/*\n * Clear an slang_T so that the file can be reloaded.\n */\n    void\nslang_clear(slang_T *lp)\n{\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    salitem_T\t*smp;\n    int\t\ti;\n    int\t\tround;\n\n    VIM_CLEAR(lp->sl_fbyts);\n    VIM_CLEAR(lp->sl_kbyts);\n    VIM_CLEAR(lp->sl_pbyts);\n\n    VIM_CLEAR(lp->sl_fidxs);\n    VIM_CLEAR(lp->sl_kidxs);\n    VIM_CLEAR(lp->sl_pidxs);\n\n    for (round = 1; round <= 2; ++round)\n    {\n\tgap = round == 1 ? &lp->sl_rep : &lp->sl_repsal;\n\twhile (gap->ga_len > 0)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(ftp->ft_from);\n\t    vim_free(ftp->ft_to);\n\t}\n\tga_clear(gap);\n    }\n\n    gap = &lp->sl_sal;\n    if (lp->sl_sofo)\n    {\n\t// \"ga_len\" is set to 1 without adding an item for latin1\n\tif (gap->ga_data != NULL)\n\t    // SOFOFROM and SOFOTO items: free lists of wide characters.\n\t    for (i = 0; i < gap->ga_len; ++i)\n\t\tvim_free(((int **)gap->ga_data)[i]);\n    }\n    else\n\t// SAL items: free salitem_T items\n\twhile (gap->ga_len > 0)\n\t{\n\t    smp = &((salitem_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(smp->sm_lead);\n\t    // Don't free sm_oneof and sm_rules, they point into sm_lead.\n\t    vim_free(smp->sm_to);\n\t    vim_free(smp->sm_lead_w);\n\t    vim_free(smp->sm_oneof_w);\n\t    vim_free(smp->sm_to_w);\n\t}\n    ga_clear(gap);\n\n    for (i = 0; i < lp->sl_prefixcnt; ++i)\n\tvim_regfree(lp->sl_prefprog[i]);\n    lp->sl_prefixcnt = 0;\n    VIM_CLEAR(lp->sl_prefprog);\n\n    VIM_CLEAR(lp->sl_info);\n\n    VIM_CLEAR(lp->sl_midword);\n\n    vim_regfree(lp->sl_compprog);\n    lp->sl_compprog = NULL;\n    VIM_CLEAR(lp->sl_comprules);\n    VIM_CLEAR(lp->sl_compstartflags);\n    VIM_CLEAR(lp->sl_compallflags);\n\n    VIM_CLEAR(lp->sl_syllable);\n    ga_clear(&lp->sl_syl_items);\n\n    ga_clear_strings(&lp->sl_comppat);\n\n    hash_clear_all(&lp->sl_wordcount, WC_KEY_OFF);\n    hash_init(&lp->sl_wordcount);\n\n    hash_clear_all(&lp->sl_map_hash, 0);\n\n    // Clear info from .sug file.\n    slang_clear_sug(lp);\n\n    lp->sl_compmax = MAXWLEN;\n    lp->sl_compminlen = 0;\n    lp->sl_compsylmax = MAXWLEN;\n    lp->sl_regions[0] = NUL;\n}\n\n/*\n * Clear the info from the .sug file in \"lp\".\n */\n    void\nslang_clear_sug(slang_T *lp)\n{\n    VIM_CLEAR(lp->sl_sbyts);\n    VIM_CLEAR(lp->sl_sidxs);\n    close_spellbuf(lp->sl_sugbuf);\n    lp->sl_sugbuf = NULL;\n    lp->sl_sugloaded = FALSE;\n    lp->sl_sugtime = 0;\n}\n\n/*\n * Load one spell file and store the info into a slang_T.\n * Invoked through do_in_runtimepath().\n */\n    static void\nspell_load_cb(char_u *fname, void *cookie)\n{\n    spelload_T\t*slp = (spelload_T *)cookie;\n    slang_T\t*slang;\n\n    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);\n    if (slang != NULL)\n    {\n\t// When a previously loaded file has NOBREAK also use it for the\n\t// \".add\" files.\n\tif (slp->sl_nobreak && slang->sl_add)\n\t    slang->sl_nobreak = TRUE;\n\telse if (slang->sl_nobreak)\n\t    slp->sl_nobreak = TRUE;\n\n\tslp->sl_slang = slang;\n    }\n}\n\n\n/*\n * Add a word to the hashtable of common words.\n * If it's already there then the counter is increased.\n */\n    void\ncount_common_word(\n    slang_T\t*lp,\n    char_u\t*word,\n    int\t\tlen,\t    // word length, -1 for up to NUL\n    int\t\tcount)\t    // 1 to count once, 10 to init\n{\n    hash_T\thash;\n    hashitem_T\t*hi;\n    wordcount_T\t*wc;\n    char_u\tbuf[MAXWLEN];\n    char_u\t*p;\n\n    if (len == -1)\n\tp = word;\n    else if (len >= MAXWLEN)\n\treturn;\n    else\n    {\n\tvim_strncpy(buf, word, len);\n\tp = buf;\n    }\n\n    hash = hash_hash(p);\n    hi = hash_lookup(&lp->sl_wordcount, p, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\twc = alloc(sizeof(wordcount_T) + STRLEN(p));\n\tif (wc == NULL)\n\t    return;\n\tSTRCPY(wc->wc_word, p);\n\twc->wc_count = count;\n\thash_add_item(&lp->sl_wordcount, hi, wc->wc_word, hash);\n    }\n    else\n    {\n\twc = HI2WC(hi);\n\tif ((wc->wc_count += count) < (unsigned)count)\t// check for overflow\n\t    wc->wc_count = MAXWORDCOUNT;\n    }\n}\n\n/*\n * Return TRUE if byte \"n\" appears in \"str\".\n * Like strchr() but independent of locale.\n */\n    int\nbyte_in_str(char_u *str, int n)\n{\n    char_u\t*p;\n\n    for (p = str; *p != NUL; ++p)\n\tif (*p == n)\n\t    return TRUE;\n    return FALSE;\n}\n\n#define SY_MAXLEN   30\ntypedef struct syl_item_S\n{\n    char_u\tsy_chars[SY_MAXLEN];\t    // the sequence of chars\n    int\t\tsy_len;\n} syl_item_T;\n\n/*\n * Truncate \"slang->sl_syllable\" at the first slash and put the following items\n * in \"slang->sl_syl_items\".\n */\n    int\ninit_syl_tab(slang_T *slang)\n{\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tl;\n    syl_item_T\t*syl;\n\n    ga_init2(&slang->sl_syl_items, sizeof(syl_item_T), 4);\n    p = vim_strchr(slang->sl_syllable, '/');\n    while (p != NULL)\n    {\n\t*p++ = NUL;\n\tif (*p == NUL)\t    // trailing slash\n\t    break;\n\ts = p;\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    l = (int)STRLEN(s);\n\telse\n\t    l = (int)(p - s);\n\tif (l >= SY_MAXLEN)\n\t    return SP_FORMERROR;\n\tif (ga_grow(&slang->sl_syl_items, 1) == FAIL)\n\t    return SP_OTHERERROR;\n\tsyl = ((syl_item_T *)slang->sl_syl_items.ga_data)\n\t\t\t\t\t       + slang->sl_syl_items.ga_len++;\n\tvim_strncpy(syl->sy_chars, s, l);\n\tsyl->sy_len = l;\n    }\n    return OK;\n}\n\n/*\n * Count the number of syllables in \"word\".\n * When \"word\" contains spaces the syllables after the last space are counted.\n * Returns zero if syllables are not defines.\n */\n    static int\ncount_syllables(slang_T *slang, char_u *word)\n{\n    int\t\tcnt = 0;\n    int\t\tskip = FALSE;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ti;\n    syl_item_T\t*syl;\n    int\t\tc;\n\n    if (slang->sl_syllable == NULL)\n\treturn 0;\n\n    for (p = word; *p != NUL; p += len)\n    {\n\t// When running into a space reset counter.\n\tif (*p == ' ')\n\t{\n\t    len = 1;\n\t    cnt = 0;\n\t    continue;\n\t}\n\n\t// Find longest match of syllable items.\n\tlen = 0;\n\tfor (i = 0; i < slang->sl_syl_items.ga_len; ++i)\n\t{\n\t    syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;\n\t    if (syl->sy_len > len\n\t\t\t       && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)\n\t\tlen = syl->sy_len;\n\t}\n\tif (len != 0)\t// found a match, count syllable\n\t{\n\t    ++cnt;\n\t    skip = FALSE;\n\t}\n\telse\n\t{\n\t    // No recognized syllable item, at least a syllable char then?\n\t    c = mb_ptr2char(p);\n\t    len = (*mb_ptr2len)(p);\n\t    if (vim_strchr(slang->sl_syllable, c) == NULL)\n\t\tskip = FALSE;\t    // No, search for next syllable\n\t    else if (!skip)\n\t    {\n\t\t++cnt;\t\t    // Yes, count it\n\t\tskip = TRUE;\t    // don't count following syllable chars\n\t    }\n\t}\n    }\n    return cnt;\n}\n\n/*\n * Parse 'spelllang' and set w_s->b_langp accordingly.\n * Returns NULL if it's OK, an untranslated error message otherwise.\n */\n    char *\ndid_set_spelllang(win_T *wp)\n{\n    garray_T\tga;\n    char_u\t*splp;\n    char_u\t*region;\n    char_u\tregion_cp[3];\n    int\t\tfilename;\n    int\t\tregion_mask;\n    slang_T\t*slang;\n    int\t\tc;\n    char_u\tlang[MAXWLEN + 1];\n    char_u\tspf_name[MAXPATHL];\n    int\t\tlen;\n    char_u\t*p;\n    int\t\tround;\n    char_u\t*spf;\n    char_u\t*use_region = NULL;\n    int\t\tdont_use_region = FALSE;\n    int\t\tnobreak = FALSE;\n    int\t\ti, j;\n    langp_T\t*lp, *lp2;\n    static int\trecursive = FALSE;\n    char\t*ret_msg = NULL;\n    char_u\t*spl_copy;\n    bufref_T\tbufref;\n\n    set_bufref(&bufref, wp->w_buffer);\n\n    // We don't want to do this recursively.  May happen when a language is\n    // not available and the SpellFileMissing autocommand opens a new buffer\n    // in which 'spell' is set.\n    if (recursive)\n\treturn NULL;\n    recursive = TRUE;\n\n    ga_init2(&ga, sizeof(langp_T), 2);\n    clear_midword(wp);\n\n    // Make a copy of 'spelllang', the SpellFileMissing autocommands may change\n    // it under our fingers.\n    spl_copy = vim_strsave(wp->w_s->b_p_spl);\n    if (spl_copy == NULL)\n\tgoto theend;\n\n    wp->w_s->b_cjk = 0;\n\n    // Loop over comma separated language names.\n    for (splp = spl_copy; *splp != NUL; )\n    {\n\t// Get one language name.\n\tcopy_option_part(&splp, lang, MAXWLEN, \",\");\n\tregion = NULL;\n\tlen = (int)STRLEN(lang);\n\n\tif (!valid_spelllang(lang))\n\t    continue;\n\n\tif (STRCMP(lang, \"cjk\") == 0)\n\t{\n\t    wp->w_s->b_cjk = 1;\n\t    continue;\n\t}\n\n\t// If the name ends in \".spl\" use it as the name of the spell file.\n\t// If there is a region name let \"region\" point to it and remove it\n\t// from the name.\n\tif (len > 4 && fnamecmp(lang + len - 4, \".spl\") == 0)\n\t{\n\t    filename = TRUE;\n\n\t    // Locate a region and remove it from the file name.\n\t    p = vim_strchr(gettail(lang), '_');\n\t    if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2])\n\t\t\t\t\t\t      && !ASCII_ISALPHA(p[3]))\n\t    {\n\t\tvim_strncpy(region_cp, p + 1, 2);\n\t\tmch_memmove(p, p + 3, len - (p - lang) - 2);\n\t\tregion = region_cp;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t\t    break;\n\t}\n\telse\n\t{\n\t    filename = FALSE;\n\t    if (len > 3 && lang[len - 3] == '_')\n\t    {\n\t\tregion = lang + len - 2;\n\t\tlen -= 3;\n\t\tlang[len] = NUL;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (STRICMP(lang, slang->sl_name) == 0)\n\t\t    break;\n\t}\n\n\tif (region != NULL)\n\t{\n\t    // If the region differs from what was used before then don't\n\t    // use it for 'spellfile'.\n\t    if (use_region != NULL && STRCMP(region, use_region) != 0)\n\t\tdont_use_region = TRUE;\n\t    use_region = region;\n\t}\n\n\t// If not found try loading the language now.\n\tif (slang == NULL)\n\t{\n\t    if (filename)\n\t\t(void)spell_load_file(lang, lang, NULL, FALSE);\n\t    else\n\t    {\n\t\tspell_load_lang(lang);\n\t\t// SpellFileMissing autocommands may do anything, including\n\t\t// destroying the buffer we are using...\n\t\tif (!bufref_valid(&bufref))\n\t\t{\n\t\t    ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer);\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Loop over the languages, there can be several files for \"lang\".\n\t */\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t    == FPC_SAME\n\t\t\t : STRICMP(lang, slang->sl_name) == 0)\n\t    {\n\t\tregion_mask = REGION_ALL;\n\t\tif (!filename && region != NULL)\n\t\t{\n\t\t    // find region in sl_regions\n\t\t    c = find_region(slang->sl_regions, region);\n\t\t    if (c == REGION_ALL)\n\t\t    {\n\t\t\tif (slang->sl_add)\n\t\t\t{\n\t\t\t    if (*slang->sl_regions != NUL)\n\t\t\t\t// This addition file is for other regions.\n\t\t\t\tregion_mask = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t    // This is probably an error.  Give a warning and\n\t\t\t    // accept the words anyway.\n\t\t\t    smsg(_(\"Warning: region %s not supported\"),\n\t\t\t\t\t\t\t\t      region);\n\t\t    }\n\t\t    else\n\t\t\tregion_mask = 1 << c;\n\t\t}\n\n\t\tif (region_mask != 0)\n\t\t{\n\t\t    if (ga_grow(&ga, 1) == FAIL)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tret_msg = e_out_of_memory;\n\t\t\tgoto theend;\n\t\t    }\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t    ++ga.ga_len;\n\t\t    use_midword(slang, wp);\n\t\t    if (slang->sl_nobreak)\n\t\t\tnobreak = TRUE;\n\t\t}\n\t    }\n    }\n\n    // round 0: load int_wordlist, if possible.\n    // round 1: load first name in 'spellfile'.\n    // round 2: load second name in 'spellfile.\n    // etc.\n    spf = curwin->w_s->b_p_spf;\n    for (round = 0; round == 0 || *spf != NUL; ++round)\n    {\n\tif (round == 0)\n\t{\n\t    // Internal wordlist, if there is one.\n\t    if (int_wordlist == NULL)\n\t\tcontinue;\n\t    int_wordlist_spl(spf_name);\n\t}\n\telse\n\t{\n\t    // One entry in 'spellfile'.\n\t    copy_option_part(&spf, spf_name, MAXPATHL - 5, \",\");\n\t    STRCAT(spf_name, \".spl\");\n\n\t    // If it was already found above then skip it.\n\t    for (c = 0; c < ga.ga_len; ++c)\n\t    {\n\t\tp = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;\n\t\tif (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\t    break;\n\t    }\n\t    if (c < ga.ga_len)\n\t\tcontinue;\n\t}\n\n\t// Check if it was loaded already.\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\tbreak;\n\tif (slang == NULL)\n\t{\n\t    // Not loaded, try loading it now.  The language name includes the\n\t    // region name, the region is ignored otherwise.  for int_wordlist\n\t    // use an arbitrary name.\n\t    if (round == 0)\n\t\tSTRCPY(lang, \"internal wordlist\");\n\t    else\n\t    {\n\t\tvim_strncpy(lang, gettail(spf_name), MAXWLEN);\n\t\tp = vim_strchr(lang, '.');\n\t\tif (p != NULL)\n\t\t    *p = NUL;\t// truncate at \".encoding.add\"\n\t    }\n\t    slang = spell_load_file(spf_name, lang, NULL, TRUE);\n\n\t    // If one of the languages has NOBREAK we assume the addition\n\t    // files also have this.\n\t    if (slang != NULL && nobreak)\n\t\tslang->sl_nobreak = TRUE;\n\t}\n\tif (slang != NULL && ga_grow(&ga, 1) == OK)\n\t{\n\t    region_mask = REGION_ALL;\n\t    if (use_region != NULL && !dont_use_region)\n\t    {\n\t\t// find region in sl_regions\n\t\tc = find_region(slang->sl_regions, use_region);\n\t\tif (c != REGION_ALL)\n\t\t    region_mask = 1 << c;\n\t\telse if (*slang->sl_regions != NUL)\n\t\t    // This spell file is for other regions.\n\t\t    region_mask = 0;\n\t    }\n\n\t    if (region_mask != 0)\n\t    {\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t++ga.ga_len;\n\t\tuse_midword(slang, wp);\n\t    }\n\t}\n    }\n\n    // Everything is fine, store the new b_langp value.\n    ga_clear(&wp->w_s->b_langp);\n    wp->w_s->b_langp = ga;\n\n    // For each language figure out what language to use for sound folding and\n    // REP items.  If the language doesn't support it itself use another one\n    // with the same name.  E.g. for \"en-math\" use \"en\".\n    for (i = 0; i < ga.ga_len; ++i)\n    {\n\tlp = LANGP_ENTRY(ga, i);\n\n\t// sound folding\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t    // language does sound folding itself\n\t    lp->lp_sallang = lp->lp_slang;\n\telse\n\t    // find first similar language that does sound folding\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_sal.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_sallang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n\n\t// REP items\n\tif (lp->lp_slang->sl_rep.ga_len > 0)\n\t    // language has REP items itself\n\t    lp->lp_replang = lp->lp_slang;\n\telse\n\t    // find first similar language that has REP items\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_rep.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_replang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n\ntheend:\n    vim_free(spl_copy);\n    recursive = FALSE;\n    return ret_msg;\n}\n\n/*\n * Clear the midword characters for buffer \"buf\".\n */\n    static void\nclear_midword(win_T *wp)\n{\n    CLEAR_FIELD(wp->w_s->b_spell_ismw);\n    VIM_CLEAR(wp->w_s->b_spell_ismw_mb);\n}\n\n/*\n * Use the \"sl_midword\" field of language \"lp\" for buffer \"buf\".\n * They add up to any currently used midword characters.\n */\n    static void\nuse_midword(slang_T *lp, win_T *wp)\n{\n    char_u\t*p;\n\n    if (lp->sl_midword == NULL)\t    // there aren't any\n\treturn;\n\n    for (p = lp->sl_midword; *p != NUL; )\n\tif (has_mbyte)\n\t{\n\t    int\t    c, l, n;\n\t    char_u  *bp;\n\n\t    c = mb_ptr2char(p);\n\t    l = (*mb_ptr2len)(p);\n\t    if (c < 256 && l <= 2)\n\t\twp->w_s->b_spell_ismw[c] = TRUE;\n\t    else if (wp->w_s->b_spell_ismw_mb == NULL)\n\t\t// First multi-byte char in \"b_spell_ismw_mb\".\n\t\twp->w_s->b_spell_ismw_mb = vim_strnsave(p, l);\n\t    else\n\t    {\n\t\t// Append multi-byte chars to \"b_spell_ismw_mb\".\n\t\tn = (int)STRLEN(wp->w_s->b_spell_ismw_mb);\n\t\tbp = vim_strnsave(wp->w_s->b_spell_ismw_mb, n + l);\n\t\tif (bp != NULL)\n\t\t{\n\t\t    vim_free(wp->w_s->b_spell_ismw_mb);\n\t\t    wp->w_s->b_spell_ismw_mb = bp;\n\t\t    vim_strncpy(bp + n, p, l);\n\t\t}\n\t    }\n\t    p += l;\n\t}\n\telse\n\t    wp->w_s->b_spell_ismw[*p++] = TRUE;\n}\n\n/*\n * Find the region \"region[2]\" in \"rp\" (points to \"sl_regions\").\n * Each region is simply stored as the two characters of its name.\n * Returns the index if found (first is 0), REGION_ALL if not found.\n */\n    static int\nfind_region(char_u *rp, char_u *region)\n{\n    int\t\ti;\n\n    for (i = 0; ; i += 2)\n    {\n\tif (rp[i] == NUL)\n\t    return REGION_ALL;\n\tif (rp[i] == region[0] && rp[i + 1] == region[1])\n\t    break;\n    }\n    return i / 2;\n}\n\n/*\n * Return case type of word:\n * w word\t0\n * Word\t\tWF_ONECAP\n * W WORD\tWF_ALLCAP\n * WoRd\twOrd\tWF_KEEPCAP\n */\n    int\ncaptype(\n    char_u\t*word,\n    char_u\t*end)\t    // When NULL use up to NUL byte.\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tfirstcap;\n    int\t\tallcap;\n    int\t\tpast_second = FALSE;\t// past second word char\n\n    // find first letter\n    for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p))\n\tif (end == NULL ? *p == NUL : p >= end)\n\t    return 0;\t    // only non-word characters, illegal word\n    if (has_mbyte)\n\tc = mb_ptr2char_adv(&p);\n    else\n\tc = *p++;\n    firstcap = allcap = SPELL_ISUPPER(c);\n\n    /*\n     * Need to check all letters to find a word with mixed upper/lower.\n     * But a word with an upper char only at start is a ONECAP.\n     */\n    for ( ; end == NULL ? *p != NUL : p < end; MB_PTR_ADV(p))\n\tif (spell_iswordp_nmw(p, curwin))\n\t{\n\t    c = PTR2CHAR(p);\n\t    if (!SPELL_ISUPPER(c))\n\t    {\n\t\t// UUl -> KEEPCAP\n\t\tif (past_second && allcap)\n\t\t    return WF_KEEPCAP;\n\t\tallcap = FALSE;\n\t    }\n\t    else if (!allcap)\n\t\t// UlU -> KEEPCAP\n\t\treturn WF_KEEPCAP;\n\t    past_second = TRUE;\n\t}\n\n    if (allcap)\n\treturn WF_ALLCAP;\n    if (firstcap)\n\treturn WF_ONECAP;\n    return 0;\n}\n\n/*\n * Delete the internal wordlist and its .spl file.\n */\n    void\nspell_delete_wordlist(void)\n{\n    char_u\tfname[MAXPATHL];\n\n    if (int_wordlist != NULL)\n    {\n\tmch_remove(int_wordlist);\n\tint_wordlist_spl(fname);\n\tmch_remove(fname);\n\tVIM_CLEAR(int_wordlist);\n    }\n}\n\n/*\n * Free all languages.\n */\n    void\nspell_free_all(void)\n{\n    slang_T\t*slang;\n    buf_T\t*buf;\n\n    // Go through all buffers and handle 'spelllang'. <VN>\n    FOR_ALL_BUFFERS(buf)\n\tga_clear(&buf->b_s.b_langp);\n\n    while (first_lang != NULL)\n    {\n\tslang = first_lang;\n\tfirst_lang = slang->sl_next;\n\tslang_free(slang);\n    }\n\n    spell_delete_wordlist();\n\n    VIM_CLEAR(repl_to);\n    VIM_CLEAR(repl_from);\n}\n\n/*\n * Clear all spelling tables and reload them.\n * Used after 'encoding' is set and when \":mkspell\" was used.\n */\n    void\nspell_reload(void)\n{\n    win_T\t*wp;\n\n    // Initialize the table for spell_iswordp().\n    init_spell_chartab();\n\n    // Unload all allocated memory.\n    spell_free_all();\n\n    // Go through all buffers and handle 'spelllang'.\n    FOR_ALL_WINDOWS(wp)\n    {\n\t// Only load the wordlists when 'spelllang' is set and there is a\n\t// window for this buffer in which 'spell' is set.\n\tif (*wp->w_s->b_p_spl != NUL)\n\t{\n\t\tif (wp->w_p_spell)\n\t\t{\n\t\t    (void)did_set_spelllang(wp);\n\t\t    break;\n\t\t}\n\t}\n    }\n}\n\n/*\n * Open a spell buffer.  This is a nameless buffer that is not in the buffer\n * list and only contains text lines.  Can use a swapfile to reduce memory\n * use.\n * Most other fields are invalid!  Esp. watch out for string options being\n * NULL and there is no undo info.\n * Returns NULL when out of memory.\n */\n    buf_T *\nopen_spellbuf(void)\n{\n    buf_T\t*buf;\n\n    buf = ALLOC_CLEAR_ONE(buf_T);\n    if (buf != NULL)\n    {\n\tbuf->b_spell = TRUE;\n\tbuf->b_p_swf = TRUE;\t// may create a swap file\n#ifdef FEAT_CRYPT\n\tbuf->b_p_key = empty_option;\n#endif\n\tml_open(buf);\n\tml_open_file(buf);\t// create swap file now\n    }\n    return buf;\n}\n\n/*\n * Close the buffer used for spell info.\n */\n    void\nclose_spellbuf(buf_T *buf)\n{\n    if (buf != NULL)\n    {\n\tml_close(buf, TRUE);\n\tvim_free(buf);\n    }\n}\n\n/*\n * Init the chartab used for spelling for ASCII.\n */\n    void\nclear_spell_chartab(spelltab_T *sp)\n{\n    int\t\ti;\n\n    // Init everything to FALSE (zero).\n    CLEAR_FIELD(sp->st_isw);\n    CLEAR_FIELD(sp->st_isu);\n    for (i = 0; i < 256; ++i)\n    {\n\tsp->st_fold[i] = i;\n\tsp->st_upper[i] = i;\n    }\n\n    // We include digits.  A word shouldn't start with a digit, but handling\n    // that is done separately.\n    for (i = '0'; i <= '9'; ++i)\n\tsp->st_isw[i] = TRUE;\n    for (i = 'A'; i <= 'Z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_isu[i] = TRUE;\n\tsp->st_fold[i] = i + 0x20;\n    }\n    for (i = 'a'; i <= 'z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_upper[i] = i - 0x20;\n    }\n}\n\n/*\n * Init the chartab used for spelling.  Only depends on 'encoding'.\n * Called once while starting up and when 'encoding' changes.\n * The default is to use isalpha(), but the spell file should define the word\n * characters to make it possible that 'encoding' differs from the current\n * locale.  For utf-8 we don't use isalpha() but our own functions.\n */\n    void\ninit_spell_chartab(void)\n{\n    int\t    i;\n\n    did_set_spelltab = FALSE;\n    clear_spell_chartab(&spelltab);\n    if (enc_dbcs)\n    {\n\t// DBCS: assume double-wide characters are word characters.\n\tfor (i = 128; i <= 255; ++i)\n\t    if (MB_BYTE2LEN(i) == 2)\n\t\tspelltab.st_isw[i] = TRUE;\n    }\n    else if (enc_utf8)\n    {\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    int f = utf_fold(i);\n\t    int u = utf_toupper(i);\n\n\t    spelltab.st_isu[i] = utf_isupper(i);\n\t    spelltab.st_isw[i] = spelltab.st_isu[i] || utf_islower(i);\n\t    // The folded/upper-cased value is different between latin1 and\n\t    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1\n\t    // value for utf-8 to avoid this.\n\t    spelltab.st_fold[i] = (f < 256) ? f : i;\n\t    spelltab.st_upper[i] = (u < 256) ? u : i;\n\t}\n    }\n    else\n    {\n\t// Rough guess: use locale-dependent library functions.\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (MB_ISUPPER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_isu[i] = TRUE;\n\t\tspelltab.st_fold[i] = MB_TOLOWER(i);\n\t    }\n\t    else if (MB_ISLOWER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_upper[i] = MB_TOUPPER(i);\n\t    }\n\t}\n    }\n}\n\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * As a special case we see \"midword\" characters as word character when it is\n * followed by a word character.  This finds they'there but not 'they there'.\n * Thus this only works properly when past the first character of the word.\n */\n    int\nspell_iswordp(\n    char_u\t*p,\n    win_T\t*wp)\t    // buffer used\n{\n    char_u\t*s;\n    int\t\tl;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tl = mb_ptr2len(p);\n\ts = p;\n\tif (l == 1)\n\t{\n\t    // be quick for ASCII\n\t    if (wp->w_s->b_spell_ismw[*p])\n\t\ts = p + 1;\t\t// skip a mid-word character\n\t}\n\telse\n\t{\n\t    c = mb_ptr2char(p);\n\t    if (c < 256 ? wp->w_s->b_spell_ismw[c]\n\t\t    : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t   && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL))\n\t\ts = p + l;\n\t}\n\n\tc = mb_ptr2char(s);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(s), wp);\n\treturn spelltab.st_isw[c];\n    }\n\n    return spelltab.st_isw[wp->w_s->b_spell_ismw[*p] ? p[1] : p[0]];\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Unlike spell_iswordp() this doesn't check for \"midword\" characters.\n */\n    int\nspell_iswordp_nmw(char_u *p, win_T *wp)\n{\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tc = mb_ptr2char(p);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(p), wp);\n\treturn spelltab.st_isw[c];\n    }\n    return spelltab.st_isw[*p];\n}\n\n/*\n * Return TRUE if word class indicates a word character.\n * Only for characters above 255.\n * Unicode subscript and superscript are not considered word characters.\n * See also dbcs_class() and utf_class() in mbyte.c.\n */\n    static int\nspell_mb_isword_class(int cl, win_T *wp)\n{\n    if (wp->w_s->b_cjk)\n\t// East Asian characters are not considered word characters.\n\treturn cl == 2 || cl == 0x2800;\n    return cl >= 2 && cl != 0x2070 && cl != 0x2080 && cl != 3;\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Wide version of spell_iswordp().\n */\n    static int\nspell_iswordp_w(int *p, win_T *wp)\n{\n    int\t\t*s;\n\n    if (*p < 256 ? wp->w_s->b_spell_ismw[*p]\n\t\t : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t     && vim_strchr(wp->w_s->b_spell_ismw_mb, *p) != NULL))\n\ts = p + 1;\n    else\n\ts = p;\n\n    if (*s > 255)\n    {\n\tif (enc_utf8)\n\t    return spell_mb_isword_class(utf_class(*s), wp);\n\tif (enc_dbcs)\n\t    return spell_mb_isword_class(\n\t\t\t\tdbcs_class((unsigned)*s >> 8, *s & 0xff), wp);\n\treturn 0;\n    }\n    return spelltab.st_isw[*s];\n}\n\n/*\n * Case-fold \"str[len]\" into \"buf[buflen]\".  The result is NUL terminated.\n * Uses the character definitions from the .spl file.\n * When using a multi-byte 'encoding' the length may change!\n * Returns FAIL when something wrong.\n */\n    int\nspell_casefold(\n    win_T\t*wp,\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    int\t\ti;\n\n    if (len >= buflen)\n    {\n\tbuf[0] = NUL;\n\treturn FAIL;\t\t// result will not fit\n    }\n\n    if (has_mbyte)\n    {\n\tint\touti = 0;\n\tchar_u\t*p;\n\tint\tc;\n\n\t// Fold one character at a time.\n\tfor (p = str; p < str + len; )\n\t{\n\t    if (outi + MB_MAXBYTES > buflen)\n\t    {\n\t\tbuf[outi] = NUL;\n\t\treturn FAIL;\n\t    }\n\t    c = mb_cptr2char_adv(&p);\n\n\t    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except\n\t    // when it is the last character in a word, then it folds to\n\t    // 0x03C2.\n\t    if (c == 0x03a3 || c == 0x03c2)\n\t    {\n\t\tif (p == str + len || !spell_iswordp(p, wp))\n\t\t    c = 0x03c2;\n\t\telse\n\t\t    c = 0x03c3;\n\t    }\n\t    else\n\t\tc = SPELL_TOFOLD(c);\n\n\t    outi += mb_char2bytes(c, buf + outi);\n\t}\n\tbuf[outi] = NUL;\n    }\n    else\n    {\n\t// Be quick for non-multibyte encodings.\n\tfor (i = 0; i < len; ++i)\n\t    buf[i] = spelltab.st_fold[str[i]];\n\tbuf[i] = NUL;\n    }\n\n    return OK;\n}\n\n/*\n * Check if the word at line \"lnum\" column \"col\" is required to start with a\n * capital.  This uses 'spellcapcheck' of the current buffer.\n */\n    int\ncheck_need_cap(linenr_T lnum, colnr_T col)\n{\n    int\t\tneed_cap = FALSE;\n    char_u\t*line;\n    char_u\t*line_copy = NULL;\n    char_u\t*p;\n    colnr_T\tendcol;\n    regmatch_T\tregmatch;\n\n    if (curwin->w_s->b_cap_prog == NULL)\n\treturn FALSE;\n\n    line = ml_get_curline();\n    endcol = 0;\n    if (getwhitecols(line) >= (int)col)\n    {\n\t// At start of line, check if previous line is empty or sentence\n\t// ends there.\n\tif (lnum == 1)\n\t    need_cap = TRUE;\n\telse\n\t{\n\t    line = ml_get(lnum - 1);\n\t    if (*skipwhite(line) == NUL)\n\t\tneed_cap = TRUE;\n\t    else\n\t    {\n\t\t// Append a space in place of the line break.\n\t\tline_copy = concat_str(line, (char_u *)\" \");\n\t\tline = line_copy;\n\t\tendcol = (colnr_T)STRLEN(line);\n\t    }\n\t}\n    }\n    else\n\tendcol = col;\n\n    if (endcol > 0)\n    {\n\t// Check if sentence ends before the bad word.\n\tregmatch.regprog = curwin->w_s->b_cap_prog;\n\tregmatch.rm_ic = FALSE;\n\tp = line + endcol;\n\tfor (;;)\n\t{\n\t    MB_PTR_BACK(line, p);\n\t    if (p == line || spell_iswordp_nmw(p, curwin))\n\t\tbreak;\n\t    if (vim_regexec(&regmatch, p, 0)\n\t\t\t\t\t && regmatch.endp[0] == line + endcol)\n\t    {\n\t\tneed_cap = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tcurwin->w_s->b_cap_prog = regmatch.regprog;\n    }\n\n    vim_free(line_copy);\n\n    return need_cap;\n}\n\n\n/*\n * \":spellrepall\"\n */\n    void\nex_spellrepall(exarg_T *eap UNUSED)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*frompat;\n    int\t\taddlen;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tsave_ws = p_ws;\n    linenr_T\tprev_lnum = 0;\n\n    if (repl_from == NULL || repl_to == NULL)\n    {\n\temsg(_(e_no_previous_spell_replacement));\n\treturn;\n    }\n    addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));\n\n    frompat = alloc(STRLEN(repl_from) + 7);\n    if (frompat == NULL)\n\treturn;\n    sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);\n    p_ws = FALSE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    curwin->w_cursor.lnum = 0;\n    while (!got_int)\n    {\n\tif (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0\n\t\t\t\t\t\t   || u_save_cursor() == FAIL)\n\t    break;\n\n\t// Only replace when the right word isn't there yet.  This happens\n\t// when changing \"etc\" to \"etc.\".\n\tline = ml_get_curline();\n\tif (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,\n\t\t\t\t\t       repl_to, STRLEN(repl_to)) != 0)\n\t{\n\t    p = alloc(STRLEN(line) + addlen + 1);\n\t    if (p == NULL)\n\t\tbreak;\n\t    mch_memmove(p, line, curwin->w_cursor.col);\n\t    STRCPY(p + curwin->w_cursor.col, repl_to);\n\t    STRCAT(p, line + curwin->w_cursor.col + STRLEN(repl_from));\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\t    if (curbuf->b_has_textprop && addlen != 0)\n\t\tadjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t\t curwin->w_cursor.col, addlen, APC_SUBSTITUTE);\n\n\t    if (curwin->w_cursor.lnum != prev_lnum)\n\t    {\n\t\t++sub_nlines;\n\t\tprev_lnum = curwin->w_cursor.lnum;\n\t    }\n\t    ++sub_nsubs;\n\t}\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(repl_to);\n    }\n\n    p_ws = save_ws;\n    curwin->w_cursor = pos;\n    vim_free(frompat);\n\n    if (sub_nsubs == 0)\n\tsemsg(_(e_not_found_str), repl_from);\n    else\n\tdo_sub_msg(FALSE);\n}\n\n/*\n * Make a copy of \"word\", with the first letter upper or lower cased, to\n * \"wcopy[MAXWLEN]\".  \"word\" must not be empty.\n * The result is NUL terminated.\n */\n    void\nonecap_copy(\n    char_u\t*word,\n    char_u\t*wcopy,\n    int\t\tupper)\t    // TRUE: first letter made upper case\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tl;\n\n    p = word;\n    if (has_mbyte)\n\tc = mb_cptr2char_adv(&p);\n    else\n\tc = *p++;\n    if (upper)\n\tc = SPELL_TOUPPER(c);\n    else\n\tc = SPELL_TOFOLD(c);\n    if (has_mbyte)\n\tl = mb_char2bytes(c, wcopy);\n    else\n    {\n\tl = 1;\n\twcopy[0] = c;\n    }\n    vim_strncpy(wcopy + l, p, MAXWLEN - l - 1);\n}\n\n/*\n * Make a copy of \"word\" with all the letters upper cased into\n * \"wcopy[MAXWLEN]\".  The result is NUL terminated.\n */\n    void\nallcap_copy(char_u *word, char_u *wcopy)\n{\n    char_u\t*s;\n    char_u\t*d;\n    int\t\tc;\n\n    d = wcopy;\n    for (s = word; *s != NUL; )\n    {\n\tif (has_mbyte)\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\n\t// We only change 0xdf to SS when we are certain latin1 is used.  It\n\t// would cause weird errors in other 8-bit encodings.\n\tif (enc_latin1like && c == 0xdf)\n\t{\n\t    c = 'S';\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n\telse\n\t    c = SPELL_TOUPPER(c);\n\n\tif (has_mbyte)\n\t{\n\t    if (d - wcopy >= MAXWLEN - MB_MAXBYTES)\n\t\tbreak;\n\t    d += mb_char2bytes(c, d);\n\t}\n\telse\n\t{\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n    }\n    *d = NUL;\n}\n\n/*\n * Case-folding may change the number of bytes: Count nr of chars in\n * fword[flen] and return the byte length of that many chars in \"word\".\n */\n    int\nnofold_len(char_u *fword, int flen, char_u *word)\n{\n    char_u\t*p;\n    int\t\ti = 0;\n\n    for (p = fword; p < fword + flen; MB_PTR_ADV(p))\n\t++i;\n    for (p = word; i > 0; MB_PTR_ADV(p))\n\t--i;\n    return (int)(p - word);\n}\n\n/*\n * Copy \"fword\" to \"cword\", fixing case according to \"flags\".\n */\n    void\nmake_case_word(char_u *fword, char_u *cword, int flags)\n{\n    if (flags & WF_ALLCAP)\n\t// Make it all upper-case\n\tallcap_copy(fword, cword);\n    else if (flags & WF_ONECAP)\n\t// Make the first letter upper-case\n\tonecap_copy(fword, cword, TRUE);\n    else\n\t// Use goodword as-is.\n\tSTRCPY(cword, fword);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Soundfold a string, for soundfold().\n * Result is in allocated memory, NULL for an error.\n */\n    char_u *\neval_soundfold(char_u *word)\n{\n    langp_T\t*lp;\n    char_u\tsound[MAXWLEN];\n    int\t\tlpi;\n\n    if (curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t// Use the sound-folding of the first language that supports it.\n\tfor (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n\t{\n\t    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\t    if (lp->lp_slang->sl_sal.ga_len > 0)\n\t    {\n\t\t// soundfold the word\n\t\tspell_soundfold(lp->lp_slang, word, FALSE, sound);\n\t\treturn vim_strsave(sound);\n\t    }\n\t}\n\n    // No language with sound folding, return word as-is.\n    return vim_strsave(word);\n}\n#endif\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n *\n * There are many ways to turn a word into a sound-a-like representation.  The\n * oldest is Soundex (1918!).   A nice overview can be found in \"Approximate\n * swedish name matching - survey and test of different algorithms\" by Klas\n * Erikson.\n *\n * We support two methods:\n * 1. SOFOFROM/SOFOTO do a simple character mapping.\n * 2. SAL items define a more advanced sound-folding (and much slower).\n */\n    void\nspell_soundfold(\n    slang_T\t*slang,\n    char_u\t*inword,\n    int\t\tfolded,\t    // \"inword\" is already case-folded\n    char_u\t*res)\n{\n    char_u\tfword[MAXWLEN];\n    char_u\t*word;\n\n    if (slang->sl_sofo)\n\t// SOFOFROM and SOFOTO used\n\tspell_soundfold_sofo(slang, inword, res);\n    else\n    {\n\t// SAL items used.  Requires the word to be case-folded.\n\tif (folded)\n\t    word = inword;\n\telse\n\t{\n\t    (void)spell_casefold(curwin,\n\t\t\t\t  inword, (int)STRLEN(inword), fword, MAXWLEN);\n\t    word = fword;\n\t}\n\n\tif (has_mbyte)\n\t    spell_soundfold_wsal(slang, word, res);\n\telse\n\t    spell_soundfold_sal(slang, word, res);\n    }\n}\n\n/*\n * Perform sound folding of \"inword\" into \"res\" according to SOFOFROM and\n * SOFOTO lines.\n */\n    static void\nspell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)\n{\n    char_u\t*s;\n    int\t\tri = 0;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tint\tprevc = 0;\n\tint\t*ip;\n\n\t// The sl_sal_first[] table contains the translation for chars up to\n\t// 255, sl_sal the rest.\n\tfor (s = inword; *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&s);\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else if (c < 256)\n\t\tc = slang->sl_sal_first[c];\n\t    else\n\t    {\n\t\tip = ((int **)slang->sl_sal.ga_data)[c & 0xff];\n\t\tif (ip == NULL)\t\t// empty list, can't match\n\t\t    c = NUL;\n\t\telse\n\t\t    for (;;)\t\t// find \"c\" in the list\n\t\t    {\n\t\t\tif (*ip == 0)\t// not found\n\t\t\t{\n\t\t\t    c = NUL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (*ip == c)\t// match!\n\t\t\t{\n\t\t\t    c = ip[1];\n\t\t\t    break;\n\t\t\t}\n\t\t\tip += 2;\n\t\t    }\n\t    }\n\n\t    if (c != NUL && c != prevc)\n\t    {\n\t\tri += mb_char2bytes(c, res + ri);\n\t\tif (ri + MB_MAXBYTES > MAXWLEN)\n\t\t    break;\n\t\tprevc = c;\n\t    }\n\t}\n    }\n    else\n    {\n\t// The sl_sal_first[] table contains the translation.\n\tfor (s = inword; (c = *s) != NUL; ++s)\n\t{\n\t    if (VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else\n\t\tc = slang->sl_sal_first[c];\n\t    if (c != NUL && (ri == 0 || res[ri - 1] != c))\n\t\tres[ri++] = c;\n\t}\n    }\n\n    res[ri] = NUL;\n}\n\n    static void\nspell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp;\n    char_u\tword[MAXWLEN];\n    char_u\t*s = inword;\n    char_u\t*t;\n    char_u\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n\n    // Remove accents, if wanted.  We actually remove all non-word characters.\n    // But keep white space.  We need a copy, the word may be changed here.\n    if (slang->sl_rem_accents)\n    {\n\tt = word;\n\twhile (*s != NUL)\n\t{\n\t    if (VIM_ISWHITE(*s))\n\t    {\n\t\t*t++ = ' ';\n\t\ts = skipwhite(s);\n\t    }\n\t    else\n\t    {\n\t\tif (spell_iswordp_nmw(s, curwin))\n\t\t    *t++ = *s;\n\t\t++s;\n\t    }\n\t}\n\t*t = NUL;\n    }\n    else\n\tvim_strncpy(word, s, MAXWLEN - 1);\n\n    smp = (salitem_T *)slang->sl_sal.ga_data;\n\n    /*\n     * This comes from Aspell phonet.cpp.  Converted from C++ to C.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // check all rules for the same letter\n\t    for (; (s = smp[n].sm_lead)[0] == c; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != s[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != s[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t      || spell_iswordp(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// test follow-up rule for \"word[i + k]\"\n\t\t\tfor ( ; (s = smp[n0].sm_lead)[0] == c0; ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    //\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != s[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != s[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t    && !spell_iswordp(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && smp[n0].sm_lead[0] == c0)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    s = smp[n].sm_to;\n\t\t    if (s == NULL)\n\t\t\ts = (char_u *)\"\";\n\t\t    pf = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(pf, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && *s != NUL && (res[reslen - 1] == c\n\t\t\t\t\t\t    || res[reslen - 1] == *s))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\twhile (*s != NUL && word[i + k0] != NUL)\n\t\t\t{\n\t\t\t    word[i + k0] = *s;\n\t\t\t    k0++;\n\t\t\t    s++;\n\t\t\t}\n\t\t\tif (k > k0)\n\t\t\t    STRMOVE(word + i + k0, word + i + k);\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\twhile (*s != NUL && s[1] != NUL && reslen < MAXWLEN)\n\t\t\t{\n\t\t\t    if (reslen == 0 || res[reslen - 1] != *s)\n\t\t\t\tres[reslen++] = *s;\n\t\t\t    s++;\n\t\t\t}\n\t\t\t// new \"actual letter\"\n\t\t\tc = *s;\n\t\t\tif (strstr((char *)pf, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\tres[reslen++] = c;\n\t\t\t    STRMOVE(word, word + i + 1);\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || res[reslen - 1] != c))\n\t\t// condense only double letters\n\t\tres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    res[reslen] = NUL;\n}\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n * Multi-byte version of spell_soundfold().\n */\n    static void\nspell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp = (salitem_T *)slang->sl_sal.ga_data;\n    int\t\tword[MAXWLEN];\n    int\t\twres[MAXWLEN];\n    int\t\tl;\n    char_u\t*s;\n    int\t\t*ws;\n    char_u\t*t;\n    int\t\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n    int\t\tdid_white = FALSE;\n    int\t\twordlen;\n\n\n    /*\n     * Convert the multi-byte string to a wide-character string.\n     * Remove accents, if wanted.  We actually remove all non-word characters.\n     * But keep white space.\n     */\n    wordlen = 0;\n    for (s = inword; *s != NUL; )\n    {\n\tt = s;\n\tc = mb_cptr2char_adv(&s);\n\tif (slang->sl_rem_accents)\n\t{\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t    {\n\t\tif (did_white)\n\t\t    continue;\n\t\tc = ' ';\n\t\tdid_white = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tdid_white = FALSE;\n\t\tif (!spell_iswordp_nmw(t, curwin))\n\t\t    continue;\n\t    }\n\t}\n\tword[wordlen++] = c;\n    }\n    word[wordlen] = NUL;\n\n    /*\n     * This algorithm comes from Aspell phonet.cpp.\n     * Converted from C++ to C.  Added support for multi-byte chars.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c & 0xff];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // Check all rules for the same index byte.\n\t    // If c is 0x300 need extra check for the end of the array, as\n\t    // (c & 0xff) is NUL.\n\t    for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)\n\t\t\t\t\t\t\t && ws[0] != NUL; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tif (c != ws[0])\n\t\t    continue;\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != ws[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != ws[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof_w) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t    || spell_iswordp_w(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp_w(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0 & 0xff];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// Test follow-up rule for \"word[i + k]\"; loop over\n\t\t\t// all entries with the same index byte.\n\t\t\tfor ( ; ((ws = smp[n0].sm_lead_w)[0] & 0xff)\n\t\t\t\t\t\t\t == (c0 & 0xff); ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    if (c0 != ws[0])\n\t\t\t\tcontinue;\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != ws[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != ws[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof_w) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t && !spell_iswordp_w(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)\n\t\t\t\t\t\t\t       == (c0 & 0xff))\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    ws = smp[n].sm_to_w;\n\t\t    s = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(s, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && ws != NULL && *ws != NUL\n\t\t\t\t&& (wres[reslen - 1] == c\n\t\t\t\t\t\t    || wres[reslen - 1] == *ws))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && word[i + k0] != NUL)\n\t\t\t    {\n\t\t\t\tword[i + k0] = *ws;\n\t\t\t\tk0++;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\tif (k > k0)\n\t\t\t    mch_memmove(word + i + k0, word + i + k,\n\t\t\t\t    sizeof(int) * (wordlen - (i + k) + 1));\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && ws[1] != NUL\n\t\t\t\t\t\t\t  && reslen < MAXWLEN)\n\t\t\t    {\n\t\t\t\tif (reslen == 0 || wres[reslen - 1] != *ws)\n\t\t\t\t    wres[reslen++] = *ws;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\t// new \"actual letter\"\n\t\t\tif (ws == NULL)\n\t\t\t    c = NUL;\n\t\t\telse\n\t\t\t    c = *ws;\n\t\t\tif (strstr((char *)s, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\twres[reslen++] = c;\n\t\t\t    mch_memmove(word, word + i + 1,\n\t\t\t\t       sizeof(int) * (wordlen - (i + 1) + 1));\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || wres[reslen - 1] != c))\n\t\t// condense only double letters\n\t\twres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    // Convert wide characters in \"wres\" to a multi-byte string in \"res\".\n    l = 0;\n    for (n = 0; n < reslen; ++n)\n    {\n\tl += mb_char2bytes(wres[n], res + l);\n\tif (l + MB_MAXBYTES > MAXWLEN)\n\t    break;\n    }\n    res[l] = NUL;\n}\n\n/*\n * \":spellinfo\"\n */\n    void\nex_spellinfo(exarg_T *eap UNUSED)\n{\n    int\t\tlpi;\n    langp_T\t*lp;\n    char_u\t*p;\n\n    if (no_spell_checking(curwin))\n\treturn;\n\n    msg_start();\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tmsg_puts(\"file: \");\n\tmsg_puts((char *)lp->lp_slang->sl_fname);\n\tmsg_putchar('\\n');\n\tp = lp->lp_slang->sl_info;\n\tif (p != NULL)\n\t{\n\t    msg_puts((char *)p);\n\t    msg_putchar('\\n');\n\t}\n    }\n    msg_end();\n}\n\n#define DUMPFLAG_KEEPCASE   1\t// round 2: keep-case tree\n#define DUMPFLAG_COUNT\t    2\t// include word count\n#define DUMPFLAG_ICASE\t    4\t// ignore case when finding matches\n#define DUMPFLAG_ONECAP\t    8\t// pattern starts with capital\n#define DUMPFLAG_ALLCAP\t    16\t// pattern is all capitals\n\n/*\n * \":spelldump\"\n */\n    void\nex_spelldump(exarg_T *eap)\n{\n    char_u  *spl;\n    long    dummy;\n\n    if (no_spell_checking(curwin))\n\treturn;\n    (void)get_option_value((char_u*)\"spl\", &dummy, &spl, NULL, OPT_LOCAL);\n\n    // Create a new empty buffer in a new window.\n    do_cmdline_cmd((char_u *)\"new\");\n\n    // enable spelling locally in the new window\n    set_option_value_give_err((char_u*)\"spell\", TRUE, (char_u*)\"\", OPT_LOCAL);\n    set_option_value_give_err((char_u*)\"spl\",  dummy, spl, OPT_LOCAL);\n    vim_free(spl);\n\n    if (!BUFEMPTY())\n\treturn;\n\n    spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);\n\n    // Delete the empty line that we started with.\n    if (curbuf->b_ml.ml_line_count > 1)\n\tml_delete(curbuf->b_ml.ml_line_count);\n\n    redraw_later(UPD_NOT_VALID);\n}\n\n/*\n * Go through all possible words and:\n * 1. When \"pat\" is NULL: dump a list of all words in the current buffer.\n *\t\"ic\" and \"dir\" are not used.\n * 2. When \"pat\" is not NULL: add matching words to insert mode completion.\n */\n    void\nspell_dump_compl(\n    char_u\t*pat,\t    // leading part of the word\n    int\t\tic,\t    // ignore case\n    int\t\t*dir,\t    // direction for adding matches\n    int\t\tdumpflags_arg)\t// DUMPFLAG_*\n{\n    langp_T\t*lp;\n    slang_T\t*slang;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tword[MAXWLEN];\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = 0;\n    int\t\tround;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tflags;\n    char_u\t*region_names = NULL;\t    // region names being used\n    int\t\tdo_region = TRUE;\t    // dump region names and numbers\n    char_u\t*p;\n    int\t\tlpi;\n    int\t\tdumpflags = dumpflags_arg;\n    int\t\tpatlen;\n\n    // When ignoring case or when the pattern starts with capital pass this on\n    // to dump_word().\n    if (pat != NULL)\n    {\n\tif (ic)\n\t    dumpflags |= DUMPFLAG_ICASE;\n\telse\n\t{\n\t    n = captype(pat, NULL);\n\t    if (n == WF_ONECAP)\n\t\tdumpflags |= DUMPFLAG_ONECAP;\n\t    else if (n == WF_ALLCAP && (int)STRLEN(pat) > mb_ptr2len(pat))\n\t\tdumpflags |= DUMPFLAG_ALLCAP;\n\t}\n    }\n\n    // Find out if we can support regions: All languages must support the same\n    // regions or none at all.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tp = lp->lp_slang->sl_regions;\n\tif (p[0] != 0)\n\t{\n\t    if (region_names == NULL)\t    // first language with regions\n\t\tregion_names = p;\n\t    else if (STRCMP(region_names, p) != 0)\n\t    {\n\t\tdo_region = FALSE;\t    // region names are different\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (do_region && region_names != NULL)\n    {\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n    }\n    else\n\tdo_region = FALSE;\n\n    /*\n     * Loop over all files loaded for the entries in 'spelllang'.\n     */\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_fbyts == NULL)\t    // reloading failed\n\t    continue;\n\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n\n\t// When matching with a pattern and there are no prefixes only use\n\t// parts of the tree that match \"pat\".\n\tif (pat != NULL && slang->sl_pbyts == NULL)\n\t    patlen = (int)STRLEN(pat);\n\telse\n\t    patlen = -1;\n\n\t// round 1: case-folded tree\n\t// round 2: keep-case tree\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t    {\n\t\tdumpflags &= ~DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_fbyts;\n\t\tidxs = slang->sl_fidxs;\n\t    }\n\t    else\n\t    {\n\t\tdumpflags |= DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_kbyts;\n\t\tidxs = slang->sl_kidxs;\n\t    }\n\t    if (byts == NULL)\n\t\tcontinue;\t\t// array is empty\n\n\t    depth = 0;\n\t    arridx[0] = 0;\n\t    curi[0] = 1;\n\t    while (depth >= 0 && !got_int\n\t\t\t\t  && (pat == NULL || !ins_compl_interrupted()))\n\t    {\n\t\tif (curi[depth] > byts[arridx[depth]])\n\t\t{\n\t\t    // Done all bytes at this node, go up one level.\n\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n\t\t    {\n\t\t\t// End of word or reached maximum length, deal with the\n\t\t\t// word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))\n\t\t\t{\n\t\t\t    word[depth] = NUL;\n\t\t\t    if (!do_region)\n\t\t\t\tflags &= ~WF_REGION;\n\n\t\t\t    // Dump the basic word if there is no prefix or\n\t\t\t    // when it's the first one.\n\t\t\t    c = (unsigned)flags >> 24;\n\t\t\t    if (c == 0 || curi[depth] == 2)\n\t\t\t    {\n\t\t\t\tdump_word(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t\tif (pat == NULL)\n\t\t\t\t    ++lnum;\n\t\t\t    }\n\n\t\t\t    // Apply the prefix, if there is one.\n\t\t\t    if (c != 0)\n\t\t\t\tlnum = dump_prefixes(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Normal char, go one level deeper.\n\t\t\tword[depth++] = c;\n\t\t\tarridx[depth] = idxs[n];\n\t\t\tcuri[depth] = 1;\n\n\t\t\t// Check if this character matches with the pattern.\n\t\t\t// If not skip the whole tree below it.\n\t\t\t// Always ignore case here, dump_word() will check\n\t\t\t// proper case later.  This isn't exactly right when\n\t\t\t// length changes for multi-byte characters with\n\t\t\t// ignore case...\n\t\t\tif (depth <= patlen\n\t\t\t\t\t&& MB_STRNICMP(word, pat, depth) != 0)\n\t\t\t    --depth;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Dump one word: apply case modifications and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n */\n    static void\ndump_word(\n    slang_T\t*slang,\n    char_u\t*word,\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\twordflags,\n    linenr_T\tlnum)\n{\n    int\t\tkeepcap = FALSE;\n    char_u\t*p;\n    char_u\t*tw;\n    char_u\tcword[MAXWLEN];\n    char_u\tbadword[MAXWLEN + 10];\n    int\t\ti;\n    int\t\tflags = wordflags;\n\n    if (dumpflags & DUMPFLAG_ONECAP)\n\tflags |= WF_ONECAP;\n    if (dumpflags & DUMPFLAG_ALLCAP)\n\tflags |= WF_ALLCAP;\n\n    if ((dumpflags & DUMPFLAG_KEEPCASE) == 0 && (flags & WF_CAPMASK) != 0)\n    {\n\t// Need to fix case according to \"flags\".\n\tmake_case_word(word, cword, flags);\n\tp = cword;\n    }\n    else\n    {\n\tp = word;\n\tif ((dumpflags & DUMPFLAG_KEEPCASE)\n\t\t&& ((captype(word, NULL) & WF_KEEPCAP) == 0\n\t\t\t\t\t\t || (flags & WF_FIXCAP) != 0))\n\t    keepcap = TRUE;\n    }\n    tw = p;\n\n    if (pat == NULL)\n    {\n\t// Add flags and regions after a slash.\n\tif ((flags & (WF_BANNED | WF_RARE | WF_REGION)) || keepcap)\n\t{\n\t    STRCPY(badword, p);\n\t    STRCAT(badword, \"/\");\n\t    if (keepcap)\n\t\tSTRCAT(badword, \"=\");\n\t    if (flags & WF_BANNED)\n\t\tSTRCAT(badword, \"!\");\n\t    else if (flags & WF_RARE)\n\t\tSTRCAT(badword, \"?\");\n\t    if (flags & WF_REGION)\n\t\tfor (i = 0; i < 7; ++i)\n\t\t    if (flags & (0x10000 << i))\n\t\t\tsprintf((char *)badword + STRLEN(badword), \"%d\", i + 1);\n\t    p = badword;\n\t}\n\n\tif (dumpflags & DUMPFLAG_COUNT)\n\t{\n\t    hashitem_T  *hi;\n\n\t    // Include the word count for \":spelldump!\".\n\t    hi = hash_find(&slang->sl_wordcount, tw);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",\n\t\t\t\t\t\t     tw, HI2WC(hi)->wc_count);\n\t\tp = IObuff;\n\t    }\n\t}\n\n\tml_append(lnum, p, (colnr_T)0, FALSE);\n    }\n    else if (((dumpflags & DUMPFLAG_ICASE)\n\t\t    ? MB_STRNICMP(p, pat, STRLEN(pat)) == 0\n\t\t    : STRNCMP(p, pat, STRLEN(pat)) == 0)\n\t\t&& ins_compl_add_infercase(p, (int)STRLEN(p),\n\t\t\t\t\t  p_ic, NULL, *dir, FALSE) == OK)\n\t// if dir was BACKWARD then honor it just once\n\t*dir = FORWARD;\n}\n\n/*\n * For \":spelldump\": Find matching prefixes for \"word\".  Prepend each to\n * \"word\" and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n * Return the updated line number.\n */\n    static linenr_T\ndump_prefixes(\n    slang_T\t*slang,\n    char_u\t*word,\t    // case-folded word\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\tflags,\t    // flags with prefix ID\n    linenr_T\tstartlnum)\n{\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tprefix[MAXWLEN];\n    char_u\tword_up[MAXWLEN];\n    int\t\thas_word_up = FALSE;\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = startlnum;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tlen;\n    int\t\ti;\n\n    // If the word starts with a lower-case letter make the word with an\n    // upper-case letter in word_up[].\n    c = PTR2CHAR(word);\n    if (SPELL_TOUPPER(c) != c)\n    {\n\tonecap_copy(word, word_up, TRUE);\n\thas_word_up = TRUE;\n    }\n\n    byts = slang->sl_pbyts;\n    idxs = slang->sl_pidxs;\n    if (byts != NULL)\t\t// array not is empty\n    {\n\t/*\n\t * Loop over all prefixes, building them byte-by-byte in prefix[].\n\t * When at the end of a prefix check that it supports \"flags\".\n\t */\n\tdepth = 0;\n\tarridx[0] = 0;\n\tcuri[0] = 1;\n\twhile (depth >= 0 && !got_int)\n\t{\n\t    n = arridx[depth];\n\t    len = byts[n];\n\t    if (curi[depth] > len)\n\t    {\n\t\t// Done all bytes at this node, go up one level.\n\t\t--depth;\n\t\tline_breakcheck();\n\t    }\n\t    else\n\t    {\n\t\t// Do one more byte at this node.\n\t\tn += curi[depth];\n\t\t++curi[depth];\n\t\tc = byts[n];\n\t\tif (c == 0)\n\t\t{\n\t\t    // End of prefix, find out how many IDs there are.\n\t\t    for (i = 1; i < len; ++i)\n\t\t\tif (byts[n + i] != 0)\n\t\t\t    break;\n\t\t    curi[depth] += i - 1;\n\n\t\t    c = valid_word_prefix(i, n, flags, word, slang, FALSE);\n\t\t    if (c != 0)\n\t\t    {\n\t\t\tvim_strncpy(prefix + depth, word, MAXWLEN - depth - 1);\n\t\t\tdump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t(c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\tif (lnum != 0)\n\t\t\t    ++lnum;\n\t\t    }\n\n\t\t    // Check for prefix that matches the word when the\n\t\t    // first letter is upper-case, but only if the prefix has\n\t\t    // a condition.\n\t\t    if (has_word_up)\n\t\t    {\n\t\t\tc = valid_word_prefix(i, n, flags, word_up, slang,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t\tif (c != 0)\n\t\t\t{\n\t\t\t    vim_strncpy(prefix + depth, word_up,\n\t\t\t\t\t\t\t MAXWLEN - depth - 1);\n\t\t\t    dump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t    (c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\t    if (lnum != 0)\n\t\t\t\t++lnum;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Normal char, go one level deeper.\n\t\t    prefix[depth++] = c;\n\t\t    arridx[depth] = idxs[n];\n\t\t    curi[depth] = 1;\n\t\t}\n\t    }\n\t}\n    }\n\n    return lnum;\n}\n\n/*\n * Move \"p\" to the end of word \"start\".\n * Uses the spell-checking word characters.\n */\n    char_u *\nspell_to_word_end(char_u *start, win_T *win)\n{\n    char_u  *p = start;\n\n    while (*p != NUL && spell_iswordp(p, win))\n\tMB_PTR_ADV(p);\n    return p;\n}\n\n/*\n * For Insert mode completion CTRL-X s:\n * Find start of the word in front of column \"startcol\".\n * We don't check if it is badly spelled, with completion we can only change\n * the word in front of the cursor.\n * Returns the column number of the word.\n */\n    int\nspell_word_start(int startcol)\n{\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcol = 0;\n\n    if (no_spell_checking(curwin))\n\treturn startcol;\n\n    // Find a word character before \"startcol\".\n    line = ml_get_curline();\n    for (p = line + startcol; p > line; )\n    {\n\tMB_PTR_BACK(line, p);\n\tif (spell_iswordp_nmw(p, curwin))\n\t    break;\n    }\n\n    // Go back to start of the word.\n    while (p > line)\n    {\n\tcol = (int)(p - line);\n\tMB_PTR_BACK(line, p);\n\tif (!spell_iswordp(p, curwin))\n\t    break;\n\tcol = 0;\n    }\n\n    return col;\n}\n\n/*\n * Need to check for 'spellcapcheck' now, the word is removed before\n * expand_spelling() is called.  Therefore the ugly global variable.\n */\nstatic int spell_expand_need_cap;\n\n    void\nspell_expand_check_cap(colnr_T col)\n{\n    spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);\n}\n\n/*\n * Get list of spelling suggestions.\n * Used for Insert mode completion CTRL-X ?.\n * Returns the number of matches.  The matches are in \"matchp[]\", array of\n * allocated strings.\n */\n    int\nexpand_spelling(\n    linenr_T\tlnum UNUSED,\n    char_u\t*pat,\n    char_u\t***matchp)\n{\n    garray_T\tga;\n\n    spell_suggest_list(&ga, pat, 100, spell_expand_need_cap, TRUE);\n    *matchp = ga.ga_data;\n    return ga.ga_len;\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spelllang' value.\n */\n    int\nvalid_spelllang(char_u *val)\n{\n    return valid_name(val, \".-_,@\");\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spellfile' value.\n */\n    int\nvalid_spellfile(char_u *val)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!vim_is_fname_char(*s))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Handle side effects of setting 'spell'.\n * Return an error message or NULL for success.\n */\n    char *\ndid_set_spell_option(int is_spellfile)\n{\n    char    *errmsg = NULL;\n    win_T   *wp;\n    int\t    l;\n\n    if (is_spellfile)\n    {\n\tl = (int)STRLEN(curwin->w_s->b_p_spf);\n\tif (l > 0 && (l < 4\n\t\t\t|| STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0))\n\t    errmsg = e_invalid_argument;\n    }\n\n    if (errmsg == NULL)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == curbuf && wp->w_p_spell)\n\t    {\n\t\terrmsg = did_set_spelllang(wp);\n\t\tbreak;\n\t    }\n    }\n    return errmsg;\n}\n\n/*\n * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n * Return error message when failed, NULL when OK.\n */\n    char *\ncompile_cap_prog(synblock_T *synblock)\n{\n    regprog_T   *rp = synblock->b_cap_prog;\n    char_u\t*re;\n\n    if (synblock->b_p_spc == NULL || *synblock->b_p_spc == NUL)\n\tsynblock->b_cap_prog = NULL;\n    else\n    {\n\t// Prepend a ^ so that we only match at one column\n\tre = concat_str((char_u *)\"^\", synblock->b_p_spc);\n\tif (re != NULL)\n\t{\n\t    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n\t    vim_free(re);\n\t    if (synblock->b_cap_prog == NULL)\n\t    {\n\t\tsynblock->b_cap_prog = rp; // restore the previous program\n\t\treturn e_invalid_argument;\n\t    }\n\t}\n    }\n\n    vim_regfree(rp);\n    return NULL;\n}\n\n#endif  // FEAT_SPELL\n", "\" Tests for autocommands\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\nsource screendump.vim\nimport './vim9.vim' as v9\n\nfunc s:cleanup_buffers() abort\n  for bnr in range(1, bufnr('$'))\n    if bufloaded(bnr) && bufnr('%') != bnr\n      execute 'bd! ' . bnr\n    endif\n  endfor\nendfunc\n\nfunc Test_vim_did_enter()\n  call assert_false(v:vim_did_enter)\n\n  \" This script will never reach the main loop, can't check if v:vim_did_enter\n  \" becomes one.\nendfunc\n\n\" Test for the CursorHold autocmd\nfunc Test_CursorHold_autocmd()\n  CheckRunVimInTerminal\n  call writefile(['one', 'two', 'three'], 'XoneTwoThree', 'D')\n  let before =<< trim END\n    set updatetime=10\n    au CursorHold * call writefile([line('.')], 'XCHoutput', 'a')\n  END\n  call writefile(before, 'XCHinit', 'D')\n  let buf = RunVimInTerminal('-S XCHinit XoneTwoThree', {})\n  call term_sendkeys(buf, \"G\")\n  call term_wait(buf, 50)\n  call term_sendkeys(buf, \"gg\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1'], readfile('XCHoutput')[-1:-1])})\n  call term_sendkeys(buf, \"j\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1', '2'], readfile('XCHoutput')[-2:-1])})\n  call term_sendkeys(buf, \"j\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1', '2', '3'], readfile('XCHoutput')[-3:-1])})\n  call StopVimInTerminal(buf)\n\n  call delete('XCHoutput')\nendfunc\n\nif has('timers')\n\n  func ExitInsertMode(id)\n    call feedkeys(\"\\<Esc>\")\n  endfunc\n\n  func Test_cursorhold_insert()\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(200, 'ExitInsertMode')\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_with_timer_interrupt()\n    CheckFeature job\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    \" Confirm the timer invoked in exit_cb of the job doesn't disturb\n    \" CursorHoldI event.\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=100\n    call job_start(has('win32') ? 'cmd /c echo:' : 'echo',\n          \\ {'exit_cb': {-> timer_start(200, 'ExitInsertMode')}})\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_x()\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(100, 'ExitInsertMode')\n    \" CursorHoldI does not trigger after CTRL-X\n    call feedkeys(\"a\\<C-X>\", 'x!')\n    call assert_equal(0, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_g_U()\n    au CursorHoldI * :\n    set updatetime=20\n    new\n    call timer_start(100, { -> feedkeys(\"\\<Left>foo\\<Esc>\", 't') })\n    call feedkeys(\"i()\\<C-g>U\", 'tx!')\n    sleep 200m\n    call assert_equal('(foo)', getline(1))\n    undo\n    call assert_equal('', getline(1))\n\n    bwipe!\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_OptionSet_modeline()\n    call test_override('starting', 1)\n    au! OptionSet\n    augroup set_tabstop\n      au OptionSet tabstop call timer_start(1, {-> execute(\"echo 'Handler called'\", \"\")})\n    augroup END\n    call writefile(['vim: set ts=7 sw=5 :', 'something'], 'XoptionsetModeline', 'D')\n    set modeline\n    let v:errmsg = ''\n    call assert_fails('split XoptionsetModeline', 'E12:')\n    call assert_equal(7, &ts)\n    call assert_equal('', v:errmsg)\n\n    augroup set_tabstop\n      au!\n    augroup END\n    bwipe!\n    set ts&\n    call test_override('starting', 0)\n  endfunc\n\nendif \"has('timers')\n\nfunc Test_bufunload()\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li = []\n  new\n  setlocal bufhidden=\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li = []\n  new\n  setlocal bufhidden=delete\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li = []\n  new\n  setlocal bufhidden=unload\n  bwipeout\n  call assert_equal([\"bufunload\", \"bufdelete\", \"bufwipeout\"], s:li)\n\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2005 or older)\nfunc Test_autocmd_bufunload_with_tabnext()\n  tabedit\n  tabfirst\n\n  augroup test_autocmd_bufunload_with_tabnext_group\n    autocmd!\n    autocmd BufUnload <buffer> tabnext\n  augroup END\n\n  quit\n  call assert_equal(2, tabpagenr('$'))\n\n  autocmd! test_autocmd_bufunload_with_tabnext_group\n  augroup! test_autocmd_bufunload_with_tabnext_group\n  tablast\n  quit\nendfunc\n\nfunc Test_argdelete_in_next()\n  au BufNew,BufEnter,BufLeave,BufWinEnter * argdel\n  call assert_fails('next a b', 'E1156:')\n  au! BufNew,BufEnter,BufLeave,BufWinEnter *\nendfunc\n\nfunc Test_autocmd_bufwinleave_with_tabfirst()\n  tabedit\n  augroup sample\n    autocmd!\n    autocmd BufWinLeave <buffer> tabfirst\n  augroup END\n  call setline(1, ['a', 'b', 'c'])\n  edit! a.txt\n  tabclose\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_01()\n  split aa.txt\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  call assert_fails('edit bb.txt', 'E937:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! aa.txt\n  bwipe! bb.txt\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_02()\n  setlocal buftype=nowrite\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  normal! i1\n  call assert_fails('edit a.txt', 'E517:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! a.txt\nendfunc\n\nfunc Test_autocmd_dummy_wipeout()\n  \" prepare files\n  call writefile([''], 'Xdummywipetest1.txt', 'D')\n  call writefile([''], 'Xdummywipetest2.txt', 'D')\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li = []\n  split Xdummywipetest1.txt\n  silent! vimgrep /notmatched/ Xdummywipetest*\n  call assert_equal([\"bufunload\", \"bufwipeout\"], s:li)\n\n  bwipeout\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\nfunc Test_win_tab_autocmd()\n  let g:record = []\n\n  augroup testing\n    au WinNew * call add(g:record, 'WinNew')\n    au WinClosed * call add(g:record, 'WinClosed')\n    au WinEnter * call add(g:record, 'WinEnter') \n    au WinLeave * call add(g:record, 'WinLeave') \n    au TabNew * call add(g:record, 'TabNew')\n    au TabClosed * call add(g:record, 'TabClosed')\n    au TabEnter * call add(g:record, 'TabEnter')\n    au TabLeave * call add(g:record, 'TabLeave')\n  augroup END\n\n  split\n  tabnew\n  close\n  close\n\n  call assert_equal([\n\t\\ 'WinLeave', 'WinNew', 'WinEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinClosed', 'TabClosed', 'WinEnter', 'TabEnter',\n\t\\ 'WinLeave', 'WinClosed', 'WinEnter'\n\t\\ ], g:record)\n\n  let g:record = []\n  tabnew somefile\n  tabnext\n  bwipe somefile\n\n  call assert_equal([\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter',\n\t\\ 'WinClosed', 'TabClosed'\n\t\\ ], g:record)\n\n  augroup testing\n    au!\n  augroup END\n  unlet g:record\nendfunc\n\nfunc Test_WinScrolled()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    for ii in range(1, 18)\n      call setline(ii, repeat(nr2char(96 + ii), ii * 2))\n    endfor\n    let win_id = win_getid()\n    let g:matched = v:false\n    execute 'au WinScrolled' win_id 'let g:matched = v:true'\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n    au WinScrolled * let g:amatch = str2nr(expand('<amatch>'))\n    au WinScrolled * let g:afile = str2nr(expand('<afile>'))\n  END\n  call writefile(lines, 'Xtest_winscrolled', 'D')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled', {'rows': 6})\n\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^0 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll left/right in Normal mode.\n  call term_sendkeys(buf, \"zlzh:echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll up/down in Normal mode.\n  call term_sendkeys(buf, \"\\<c-e>\\<c-y>:echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^4 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll up/down in Insert mode.\n  call term_sendkeys(buf, \"Mi\\<c-x>\\<c-e>\\<Esc>i\\<c-x>\\<c-y>\\<Esc>\")\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^6 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll the window horizontally to focus the last letter of the third line\n  \" containing only six characters. Moving to the previous and shorter lines\n  \" should trigger another autocommand as Vim has to make them visible.\n  call term_sendkeys(buf, \"5zl2k\")\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^8 ', term_getline(buf, 6))}, 1000)\n\n  \" Ensure the command was triggered for the specified window ID.\n  call term_sendkeys(buf, \":echo g:matched\\<CR>\")\n  call WaitForAssert({-> assert_match('^v:true ', term_getline(buf, 6))}, 1000)\n\n  \" Ensure the expansion of <amatch> and <afile> matches the window ID.\n  call term_sendkeys(buf, \":echo g:amatch == win_id && g:afile == win_id\\<CR>\")\n  call WaitForAssert({-> assert_match('^v:true ', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_WinScrolled_mouse()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    set mouse=a term=xterm ttymouse=sgr mousetime=200 clipboard=\n    call setline(1, ['foo']->repeat(32))\n    split\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n  END\n  call writefile(lines, 'Xtest_winscrolled_mouse', 'D')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_mouse', {'rows': 10})\n\n  \" With the upper split focused, send a scroll-down event to the unfocused one.\n  call test_setmouse(7, 1)\n  call term_sendkeys(buf, \"\\<ScrollWheelDown>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 10))}, 1000)\n\n  \" Again, but this time while we're in insert mode.\n  call term_sendkeys(buf, \"i\\<ScrollWheelDown>\\<Esc>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2', term_getline(buf, 10))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_WinScrolled_close_curwin()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    call setline(1, ['aaa', 'bbb'])\n    vsplit\n    au WinScrolled * close\n    au VimLeave * call writefile(['123456'], 'Xtestout')\n  END\n  call writefile(lines, 'Xtest_winscrolled_close_curwin', 'D')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_close_curwin', {'rows': 6})\n\n  \" This was using freed memory\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n\n  call assert_equal(['123456'], readfile('Xtestout'))\n\n  call delete('Xtestout')\nendfunc\n\nfunc Test_WinScrolled_long_wrapped()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set scrolloff=0\n    let height = winheight(0)\n    let width = winwidth(0)\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n    call setline(1, repeat('foo', height * width))\n    call cursor(1, height * width)\n  END\n  call writefile(lines, 'Xtest_winscrolled_long_wrapped', 'D')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_long_wrapped', {'rows': 6})\n\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^0 ', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, 'gj')\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^1 ', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, '0')\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2 ', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, '$')\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^3 ', term_getline(buf, 6))}, 1000)\nendfunc\n\nfunc Test_WinClosed()\n  \" Test that the pattern is matched against the closed window's ID, and both\n  \" <amatch> and <afile> are set to it.\n  new\n  let winid = win_getid()\n  let g:matched = v:false\n  augroup test-WinClosed\n    autocmd!\n    execute 'autocmd WinClosed' winid 'let g:matched = v:true'\n    autocmd WinClosed * let g:amatch = str2nr(expand('<amatch>'))\n    autocmd WinClosed * let g:afile = str2nr(expand('<afile>'))\n  augroup END\n  close\n  call assert_true(g:matched)\n  call assert_equal(winid, g:amatch)\n  call assert_equal(winid, g:afile)\n\n  \" Test that WinClosed is non-recursive.\n  new\n  new\n  call assert_equal(3, winnr('$'))\n  let g:triggered = 0\n  augroup test-WinClosed\n    autocmd!\n    autocmd WinClosed * let g:triggered += 1\n    autocmd WinClosed * 2 wincmd c\n  augroup END\n  close\n  call assert_equal(1, winnr('$'))\n  call assert_equal(1, g:triggered)\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\n  unlet g:matched\n  unlet g:amatch\n  unlet g:afile\n  unlet g:triggered\nendfunc\n\nfunc Test_WinClosed_throws()\n  vnew\n  let bnr = bufnr()\n  call assert_equal(1, bufloaded(bnr))\n  augroup test-WinClosed\n    autocmd WinClosed * throw 'foo'\n  augroup END\n  try\n    close\n  catch /.*/\n  endtry\n  call assert_equal(0, bufloaded(bnr))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\nendfunc\n\nfunc Test_WinClosed_throws_with_tabs()\n  tabnew\n  let bnr = bufnr()\n  call assert_equal(1, bufloaded(bnr))\n  augroup test-WinClosed\n    autocmd WinClosed * throw 'foo'\n  augroup END\n  try\n    close\n  catch /.*/\n  endtry\n  call assert_equal(0, bufloaded(bnr))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\nendfunc\n\n\" This used to trigger WinClosed twice for the same window, and the window's\n\" buffer was NULL in the second autocommand.\nfunc Test_WinClosed_switch_tab()\n  edit Xa\n  split Xb\n  split Xc\n  tab split\n  new\n  augroup test-WinClosed\n    autocmd WinClosed * tabprev | bwipe!\n  augroup END\n  close\n  \" Check that the tabline has been fully removed\n  call assert_equal([1, 1], win_screenpos(0))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\n  %bwipe!\nendfunc\n\nfunc s:AddAnAutocmd()\n  augroup vimBarTest\n    au BufReadCmd * echo 'hello'\n  augroup END\n  call assert_equal(3, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc Test_early_bar()\n  \" test that a bar is recognized before the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest | au! | let done = 77 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(77, done)\n\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!| let done = 88 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(88, done)\n\n  \" test that a bar is recognized after the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!BufReadCmd| let done = 99 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(99, done)\n\n  \" test that a bar is recognized after the {group}\n  call s:AddAnAutocmd()\n  au! vimBarTest|echo 'hello'\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc RemoveGroup()\n  autocmd! StartOK\n  augroup! StartOK\nendfunc\n\nfunc Test_augroup_warning()\n  augroup TheWarning\n    au VimEnter * echo 'entering'\n  augroup END\n  call assert_match(\"TheWarning.*VimEnter\", execute('au VimEnter'))\n  redir => res\n  augroup! TheWarning\n  redir END\n  call assert_match(\"W19:\", res)\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n\n  \" check \"Another\" does not take the pace of the deleted entry\n  augroup Another\n  augroup END\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n  augroup! Another\n\n  \" no warning for postpone aucmd delete\n  augroup StartOK\n    au VimEnter * call RemoveGroup()\n  augroup END\n  call assert_match(\"StartOK.*VimEnter\", execute('au VimEnter'))\n  redir => res\n  doautocmd VimEnter\n  redir END\n  call assert_notmatch(\"W19:\", res)\n  au! VimEnter\n\n  call assert_fails('augroup!', 'E471:')\nendfunc\n\nfunc Test_BufReadCmdHelp()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h\n  help\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_BufReadCmdHelpJump()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h{\n  \" } to fix highlighting\n  call assert_fails('help', 'E434:')\n\n  au! BufReadCmd\nendfunc\n\n\" BufReadCmd is triggered for a \"nofile\" buffer. Check all values.\nfunc Test_BufReadCmdNofile()\n  for val in ['nofile',\n            \\ 'nowrite',\n            \\ 'acwrite',\n            \\ 'quickfix',\n            \\ 'help',\n            \\ 'terminal',\n            \\ 'prompt',\n            \\ 'popup',\n            \\ ]\n    new somefile\n    exe 'set buftype=' .. val\n    au BufReadCmd somefile call setline(1, 'triggered')\n    edit\n    call assert_equal('triggered', getline(1))\n\n    au! BufReadCmd\n    bwipe!\n  endfor\nendfunc\n\nfunc Test_augroup_deleted()\n  \" This caused a crash before E936 was introduced\n  augroup x\n    call assert_fails('augroup! x', 'E936:')\n    au VimEnter * echo\n  augroup end\n  augroup! x\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n  au! VimEnter\nendfunc\n\n\" Tests for autocommands on :close command.\n\" This used to be in test13.\nfunc Test_three_windows()\n  \" Clean up buffers, because in some cases this function fails.\n  call s:cleanup_buffers()\n\n  \" Write three files and open them, each in a window.\n  \" Then go to next window, with autocommand that deletes the previous one.\n  \" Do this twice, writing the file.\n  e! Xtestje1\n  call setline(1, 'testje1')\n  w\n  sp Xtestje2\n  call setline(1, 'testje2')\n  w\n  sp Xtestje3\n  call setline(1, 'testje3')\n  w\n  wincmd w\n  au WinLeave Xtestje2 bwipe\n  wincmd w\n  call assert_equal('Xtestje1', expand('%'))\n\n  au WinLeave Xtestje1 bwipe Xtestje3\n  close\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test deleting the buffer on a Unload event.  If this goes wrong there\n  \" will be the ATTENTION prompt.\n  e Xtestje1\n  au!\n  au! BufUnload Xtestje1 bwipe\n  call assert_fails('e Xtestje3', 'E937:')\n  call assert_equal('Xtestje3', expand('%'))\n\n  e Xtestje2\n  sp Xtestje1\n  call assert_fails('e', 'E937:')\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test changing buffers in a BufWipeout autocommand.  If this goes wrong\n  \" there are ml_line errors and/or a Crash.\n  au!\n  only\n  e Xanother\n  e Xtestje1\n  bwipe Xtestje2\n  bwipe Xtestje3\n  au BufWipeout Xtestje1 buf Xtestje1\n  bwipe\n  call assert_equal('Xanother', expand('%'))\n\n  only\n  help\n  wincmd w\n  1quit\n  call assert_equal('Xanother', expand('%'))\n\n  au!\n  enew\n  call delete('Xtestje1')\n  call delete('Xtestje2')\n  call delete('Xtestje3')\nendfunc\n\nfunc Test_BufEnter()\n  au! BufEnter\n  au Bufenter * let val = val . '+'\n  let g:val = ''\n  split NewFile\n  call assert_equal('+', g:val)\n  bwipe!\n  call assert_equal('++', g:val)\n\n  \" Also get BufEnter when editing a directory\n  call mkdir('Xbufenterdir', 'D')\n  split Xbufenterdir\n  call assert_equal('+++', g:val)\n\n  \" On MS-Windows we can't edit the directory, make sure we wipe the right\n  \" buffer.\n  bwipe! Xbufenterdir\n  au! BufEnter\n\n  \" Editing a \"nofile\" buffer doesn't read the file but does trigger BufEnter\n  \" for historic reasons.  Also test other 'buftype' values.\n  for val in ['nofile',\n            \\ 'nowrite',\n            \\ 'acwrite',\n            \\ 'quickfix',\n            \\ 'help',\n            \\ 'terminal',\n            \\ 'prompt',\n            \\ 'popup',\n            \\ ]\n    new somefile\n    exe 'set buftype=' .. val\n    au BufEnter somefile call setline(1, 'some text')\n    edit\n    call assert_equal('some text', getline(1))\n    bwipe!\n    au! BufEnter\n  endfor\nendfunc\n\n\" Closing a window might cause an endless loop\n\" E814 for older Vims\nfunc Test_autocmd_bufwipe_in_SessLoadPost()\n  edit Xtest\n  tabnew\n  file Xsomething\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    call test_override('ui_delay', 10)\n    set nocp noswapfile\n    let v:swapchoice = \"e\"\n    augroup test_autocmd_sessionload\n    autocmd!\n    autocmd SessionLoadPost * exe bufnr(\"Xsomething\") . \"bw!\"\n    augroup END\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"XerrorsBwipe\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc', 'D')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  sleep 100m\n  let errors = join(readfile('XerrorsBwipe'))\n  call assert_match('E814:', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'XerrorsBwipe']\n    call delete(file)\n  endfor\nendfunc\n\n\" Using :blast and :ball for many events caused a crash, because b_nwindows was\n\" not incremented correctly.\nfunc Test_autocmd_blast_badd()\n  let content =<< trim [CODE]\n      au BufNew,BufAdd,BufWinEnter,BufEnter,BufLeave,BufWinLeave,BufUnload,VimEnter foo* blast\n      edit foo1\n      au BufNew,BufAdd,BufWinEnter,BufEnter,BufLeave,BufWinLeave,BufUnload,VimEnter foo* ball\n      edit foo2\n      call writefile(['OK'], 'XerrorsBlast')\n      qall\n  [CODE]\n\n  call writefile(content, 'XblastBall', 'D')\n  call system(GetVimCommand() .. ' --clean -S XblastBall')\n  sleep 100m\n  call assert_match('OK', readfile('XerrorsBlast')->join())\n\n  call delete('XerrorsBlast')\nendfunc\n\n\" SEGV occurs in older versions.\nfunc Test_autocmd_bufwipe_in_SessLoadPost2()\n  tabnew\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    set nocp noswapfile\n    function! DeleteInactiveBufs()\n      tabfirst\n      let tabblist = []\n      for i in range(1, tabpagenr(''$''))\n        call extend(tabblist, tabpagebuflist(i))\n      endfor\n      for b in range(1, bufnr(''$''))\n        if bufexists(b) && buflisted(b) && (index(tabblist, b) == -1 || bufname(b) =~# ''^$'')\n          exec ''bwipeout '' . b\n        endif\n      endfor\n      echomsg \"SessionLoadPost DONE\"\n    endfunction\n    au SessionLoadPost * call DeleteInactiveBufs()\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"XerrorsPost\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc', 'D')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  sleep 100m\n  let errors = join(readfile('XerrorsPost'))\n  \" This probably only ever matches on unix.\n  call assert_notmatch('Caught deadly signal SEGV', errors)\n  call assert_match('SessionLoadPost DONE', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'XerrorsPost']\n    call delete(file)\n  endfor\nendfunc\n\nfunc Test_empty_doau()\n  doau \\|\nendfunc\n\nfunc s:AutoCommandOptionSet(match)\n  let template = \"Option: <%s>, OldVal: <%s>, OldValLocal: <%s>, OldValGlobal: <%s>, NewVal: <%s>, Scope: <%s>, Command: <%s>\\n\"\n  let item     = remove(g:options, 0)\n  let expected = printf(template, item[0], item[1], item[2], item[3], item[4], item[5], item[6])\n  let actual   = printf(template, a:match, v:option_old, v:option_oldlocal, v:option_oldglobal, v:option_new, v:option_type, v:option_command)\n  let g:opt    = [expected, actual]\n  \"call assert_equal(expected, actual)\nendfunc\n\nfunc Test_OptionSet()\n  CheckOption autochdir\n\n  badd test_autocmd.vim\n\n  call test_override('starting', 1)\n  set nocp\n  au OptionSet * :call s:AutoCommandOptionSet(expand(\"<amatch>\"))\n\n  \" 1: Setting number option\"\n  let g:options = [['number', 0, 0, 0, 1, 'global', 'set']]\n  set nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 2: Setting local number option\"\n  let g:options = [['number', 1, 1, '', 0, 'local', 'setlocal']]\n  setlocal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 3: Setting global number option\"\n  let g:options = [['number', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 4: Setting local autoindent option\"\n  let g:options = [['autoindent', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 5: Setting global autoindent option\"\n  let g:options = [['autoindent', 0, '', 0, 1, 'global', 'setglobal']]\n  setglobal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6: Setting global autoindent option\"\n  let g:options = [['autoindent', 1, 1, 1, 0, 'global', 'set']]\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6a: Setting global autoindent option\"\n  let g:options = [['autoindent', 1, 1, 0, 0, 'global', 'set']]\n  noa setlocal ai\n  noa setglobal noai\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" Should not print anything, use :noa\n  \" 7: don't trigger OptionSet\"\n  let g:options = [['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 8: Setting several global list and number option\"\n  let g:options = [['list', 0, 0, 0, 1, 'global', 'set'], ['number', 0, 0, 0, 1, 'global', 'set']]\n  set list nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 9: don't trigger OptionSet\"\n  let g:options = [['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nolist nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 10: Setting global acd\"\n  let g:options = [['autochdir', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal acd\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 11: Setting global autoread (also sets local value)\"\n  let g:options = [['autoread', 0, 0, 0, 1, 'global', 'set']]\n  set ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 12: Setting local autoread\"\n  let g:options = [['autoread', 1, 1, '', 1, 'local', 'setlocal']]\n  setlocal ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 13: Setting global autoread\"\n  let g:options = [['autoread', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal invar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 14: Setting option backspace through :let\"\n  let g:options = [['backspace', '', '', '', 'eol,indent,start', 'global', 'set']]\n  let &bs = \"eol,indent,start\"\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 15: Setting option backspace through setbufvar()\"\n  let g:options = [['backup', 0, 0, '', 1, 'local', 'setlocal']]\n  \" try twice, first time, shouldn't trigger because option name is invalid,\n  \" second time, it should trigger\n  let bnum = bufnr('%')\n  call assert_fails(\"call setbufvar(bnum, '&l:bk', 1)\", 'E355:')\n  \" should trigger, use correct option name\n  call setbufvar(bnum, '&backup', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 16: Setting number option using setwinvar\"\n  let g:options = [['number', 0, 0, '', 1, 'local', 'setlocal']]\n  call setwinvar(0, '&number', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 17: Setting key option, shouldn't trigger\"\n  let g:options = [['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']]\n  setlocal key=blah\n  setlocal key=\n  call assert_equal([['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 18a: Setting string global option\"\n  let oldval = &backupext\n  let g:options = [['backupext', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set backupext=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18b: Resetting string global option\"\n  let g:options = [['backupext', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set backupext&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18c: Setting global string global option\"\n  let g:options = [['backupext', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal backupext=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18d: Setting local string global option\"\n  \" As this is a global option this sets the global value even though\n  \" :setlocal is used!\n  noa set backupext& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['backupext', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal backupext=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18e: Setting again string global option\"\n  noa setglobal backupext=ext_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal backupext=ext_local \" Sets the global(!) value!\n  let g:options = [['backupext', 'ext_local', 'ext_local', 'ext_local', 'fuu', 'global', 'set']]\n  set backupext=fuu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 19a: Setting string global-local (to buffer) option\"\n  let oldval = &tags\n  let g:options = [['tags', oldval, oldval, oldval, 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19b: Resetting string global-local (to buffer) option\"\n  let g:options = [['tags', 'tagpath', 'tagpath', 'tagpath', oldval, 'global', 'set']]\n  set tags&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19c: Setting global string global-local (to buffer) option \"\n  let g:options = [['tags', oldval, '', oldval, 'tagpath1', 'global', 'setglobal']]\n  setglobal tags=tagpath1\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19d: Setting local string global-local (to buffer) option\"\n  let g:options = [['tags', 'tagpath1', 'tagpath1', '', 'tagpath2', 'local', 'setlocal']]\n  setlocal tags=tagpath2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19e: Setting again string global-local (to buffer) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags=tag_local\n  let g:options = [['tags', 'tag_global', 'tag_local', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19f: Setting string global-local (to buffer) option to an empty string\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa set tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags= \" empty string\n  let g:options = [['tags', 'tag_global', '', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 20a: Setting string local (to buffer) option\"\n  let oldval = &spelllang\n  let g:options = [['spelllang', oldval, oldval, oldval, 'elvish,klingon', 'global', 'set']]\n  set spelllang=elvish,klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20b: Resetting string local (to buffer) option\"\n  let g:options = [['spelllang', 'elvish,klingon', 'elvish,klingon', 'elvish,klingon', oldval, 'global', 'set']]\n  set spelllang&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20c: Setting global string local (to buffer) option\"\n  let g:options = [['spelllang', oldval, '', oldval, 'elvish', 'global', 'setglobal']]\n  setglobal spelllang=elvish\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20d: Setting local string local (to buffer) option\"\n  noa set spelllang& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['spelllang', oldval, oldval, '', 'klingon', 'local', 'setlocal']]\n  setlocal spelllang=klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20e: Setting again string local (to buffer) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal spelllang=spellglobal \" Reset global and local value (without triggering autocmd)\n  noa setlocal spelllang=spelllocal\n  let g:options = [['spelllang', 'spelllocal', 'spelllocal', 'spellglobal', 'foo', 'global', 'set']]\n  set spelllang=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 21a: Setting string global-local (to window) option\"\n  let oldval = &statusline\n  let g:options = [['statusline', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21b: Resetting string global-local (to window) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  let g:options = [['statusline', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set statusline&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21c: Setting global string global-local (to window) option\"\n  let g:options = [['statusline', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal statusline=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21d: Setting local string global-local (to window) option\"\n  noa set statusline& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['statusline', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal statusline=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21e: Setting again string global-local (to window) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal statusline=bar \" Reset global and local value (without triggering autocmd)\n  noa setlocal statusline=baz\n  let g:options = [['statusline', 'bar', 'baz', 'bar', 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 22a: Setting string local (to window) option\"\n  let oldval = &foldignore\n  let g:options = [['foldignore', oldval, oldval, oldval, 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22b: Resetting string local (to window) option\"\n  let g:options = [['foldignore', 'fo', 'fo', 'fo', oldval, 'global', 'set']]\n  set foldignore&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22c: Setting global string local (to window) option\"\n  let g:options = [['foldignore', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal foldignore=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22d: Setting local string local (to window) option\"\n  noa set foldignore& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['foldignore', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal foldignore=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22e: Setting again string local (to window) option\"\n  noa setglobal foldignore=glob \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldignore=loc\n  let g:options = [['foldignore', 'loc', 'loc', 'glob', 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 23a: Setting global number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '', '1', '2', 'global', 'setglobal']]\n  setglobal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23b: Setting local number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23c: Setting again number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '1', '1', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23d: Setting again number global option\"\n  noa set cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cmdheight', '8', '8', '8', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 24a: Setting global number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24b: Setting local number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24c: Setting again number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '1', '1', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24d: Setting again global number global-local (to buffer) option\"\n  noa set undolevels=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['undolevels', '8', '8', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 25a: Setting global number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25b: Setting local number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25c: Setting again number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '1', '1', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25d: Setting again global number local (to buffer) option\"\n  noa set wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['wrapmargin', '8', '8', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 26: Setting number global-local (to window) option.\n  \" Such option does currently not exist.\n\n\n  \" 27a: Setting global number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27b: Setting local number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27c: Setting again number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '1', '1', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27d: Setting again global number local (to window) option\"\n  noa set foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['foldcolumn', '8', '8', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 28a: Setting global boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '', '1', '0', 'global', 'setglobal']]\n  setglobal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28b: Setting local boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28c: Setting again boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '1', '1', '0', 'global', 'set']]\n  set nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28d: Setting again global boolean global option\"\n  noa set nowrapscan \" Reset global and local value (without triggering autocmd)\n  let g:options = [['wrapscan', '0', '0', '0', '1', 'global', 'set']]\n  set wrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 29a: Setting global boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29b: Setting local boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal noautoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29c: Setting again boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '1', '1', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29d: Setting again global boolean global-local (to buffer) option\"\n  noa set noautoread \" Reset global and local value (without triggering autocmd)\n  let g:options = [['autoread', '0', '0', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 30a: Setting global boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30b: Setting local boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30c: Setting again boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '1', '1', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30d: Setting again global boolean local (to buffer) option\"\n  noa set nocindent \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cindent', '0', '0', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 31: Setting boolean global-local (to window) option\n  \" Currently no such option exists.\n\n\n  \" 32a: Setting global boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32b: Setting local boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32c: Setting again boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '1', '1', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32d: Setting again global boolean local (to window) option\"\n  noa set nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cursorcolumn', '0', '0', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 33: Test autocommands when an option value is converted internally.\n  noa set backspace=1 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['backspace', 'indent,eol', 'indent,eol', 'indent,eol', '2', 'global', 'set']]\n  set backspace=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" Cleanup\n  au! OptionSet\n  \" set tags&\n  for opt in ['nu', 'ai', 'acd', 'ar', 'bs', 'backup', 'cul', 'cp', 'backupext', 'tags', 'spelllang', 'statusline', 'foldignore', 'cmdheight', 'undolevels', 'wrapmargin', 'foldcolumn', 'wrapscan', 'autoread', 'cindent', 'cursorcolumn']\n    exe printf(\":set %s&vim\", opt)\n  endfor\n  call test_override('starting', 0)\n  delfunc! AutoCommandOptionSet\nendfunc\n\nfunc Test_OptionSet_diffmode()\n  call test_override('starting', 1)\n  \" 18: Changing an option when entering diff mode\n  new\n  au OptionSet diff :let &l:cul = v:option_new\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  diffoff\n  call assert_equal(0, &l:cul)\n  call assert_equal(1, getwinvar(2, '&l:cul'))\n  bw!\n\n  call assert_equal(1, &l:cul)\n  diffoff!\n  call assert_equal(0, &l:cul)\n  call assert_equal(0, getwinvar(1, '&l:cul'))\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\nendfunc\n\nfunc Test_OptionSet_diffmode_close()\n  call test_override('starting', 1)\n  \" 19: Try to close the current window when entering diff mode\n  \" should not segfault\n  new\n  au OptionSet diff close\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_fails(':diffthis', 'E788:')\n  call assert_equal(1, &diff)\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_fails(':diffthis', 'E788:')\n  call assert_equal(1, &diff)\n  set diffopt-=closeoff\n  bw!\n  call assert_fails(':diffoff!', 'E788:')\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\n  \"delfunc! AutoCommandOptionSet\nendfunc\n\n\" Test for Bufleave autocommand that deletes the buffer we are about to edit.\nfunc Test_BufleaveWithDelete()\n  new | edit XbufLeave1\n\n  augroup test_bufleavewithdelete\n      autocmd!\n      autocmd BufLeave XbufLeave1 bwipe XbufLeave2\n  augroup END\n\n  call assert_fails('edit XbufLeave2', 'E143:')\n  call assert_equal('XbufLeave1', bufname('%'))\n\n  autocmd! test_bufleavewithdelete BufLeave XbufLeave1\n  augroup! test_bufleavewithdelete\n\n  new\n  bwipe! XbufLeave1\nendfunc\n\n\" Test for autocommand that changes the buffer list, when doing \":ball\".\nfunc Test_Acmd_BufAll()\n  enew!\n  %bwipe!\n  call writefile(['Test file Xxx1'], 'Xxx1', 'D')\n  call writefile(['Test file Xxx2'], 'Xxx2', 'D')\n  call writefile(['Test file Xxx3'], 'Xxx3', 'D')\n\n  \" Add three files to the buffer list\n  split Xxx1\n  close\n  split Xxx2\n  close\n  split Xxx3\n  close\n\n  \" Wipe the buffer when the buffer is opened\n  au BufReadPost Xxx2 bwipe\n\n  call append(0, 'Test file Xxx4')\n  ball\n\n  call assert_equal(2, winnr('$'))\n  call assert_equal('Xxx1', bufname(winbufnr(winnr('$'))))\n  wincmd t\n\n  au! BufReadPost\n  %bwipe!\n  enew! | only\nendfunc\n\n\" Test for autocommand that changes current buffer on BufEnter event.\n\" Check if modelines are interpreted for the correct buffer.\nfunc Test_Acmd_BufEnter()\n  %bwipe!\n  call writefile(['start of test file Xxx1',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx1'], 'Xxx1', 'D')\n  call writefile(['start of test file Xxx2',\n\t      \\ 'vim: set noai :',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx2'], 'Xxx2', 'D')\n\n  au BufEnter Xxx2 brew\n  set ai modeline modelines=3\n  edit Xxx1\n  \" edit Xxx2, autocmd will do :brew\n  edit Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" Append text with autoindent to this file\n  normal othis should be auto-indented\n  call assert_equal(\"\\<Tab>this should be auto-indented\", getline('.'))\n  call assert_equal(3, line('.'))\n  \" Remove autocmd and edit Xxx2 again\n  au! BufEnter Xxx2\n  buf! Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" append text without autoindent to Xxx\n  normal othis should be in column 1\n  call assert_equal(\"this should be in column 1\", getline('.'))\n  call assert_equal(4, line('.'))\n\n  %bwipe!\n  set ai&vim modeline&vim modelines&vim\nendfunc\n\n\" Test for issue #57\n\" do not move cursor on <c-o> when autoindent is set\nfunc Test_ai_CTRL_O()\n  enew!\n  set ai\n  let save_fo = &fo\n  set fo+=r\n  exe \"normal o# abcdef\\<Esc>2hi\\<CR>\\<C-O>d0\\<Esc>\"\n  exe \"normal o# abcdef\\<Esc>2hi\\<C-O>d0\\<Esc>\"\n  call assert_equal(['# abc', 'def', 'def'], getline(2, 4))\n\n  set ai&vim\n  let &fo = save_fo\n  enew!\nendfunc\n\n\" Test for autocommand that deletes the current buffer on BufLeave event.\n\" Also test deleting the last buffer, should give a new, empty buffer.\nfunc Test_BufLeave_Wipe()\n  %bwipe!\n  let content = ['start of test file Xxx',\n\t      \\ 'this is a test',\n\t      \\ 'end of test file Xxx']\n  call writefile(content, 'Xxx1', 'D')\n  call writefile(content, 'Xxx2', 'D')\n\n  au BufLeave Xxx2 bwipe\n  edit Xxx1\n  split Xxx2\n  \" delete buffer Xxx2, we should be back to Xxx1\n  bwipe\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal(1, winnr('$'))\n\n  \" Create an alternate buffer\n  %write! test.out\n  call assert_equal('test.out', bufname('#'))\n  \" delete alternate buffer\n  bwipe test.out\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal('', bufname('#'))\n\n  au BufLeave Xxx1 bwipe\n  \" delete current buffer, get an empty one\n  bwipe!\n  call assert_equal(1, line('$'))\n  call assert_equal('', bufname('%'))\n  let g:bufinfo = getbufinfo()\n  call assert_equal(1, len(g:bufinfo))\n\n  call delete('test.out')\n  %bwipe\n  au! BufLeave\n\n  \" check that bufinfo doesn't contain a pointer to freed memory\n  call test_garbagecollect_now()\nendfunc\n\nfunc Test_QuitPre()\n  edit Xfoo\n  let winid = win_getid(winnr())\n  split Xbar\n  au! QuitPre * let g:afile = expand('<afile>')\n  \" Close the other window, <afile> should be correct.\n  exe win_id2win(winid) . 'q'\n  call assert_equal('Xfoo', g:afile)\n\n  unlet g:afile\n  bwipe Xfoo\n  bwipe Xbar\nendfunc\n\nfunc Test_Cmdline()\n  au! CmdlineChanged : let g:text = getcmdline()\n  let g:text = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(\"echom 'hello'\", g:text)\n  au! CmdlineChanged\n\n  au! CmdlineChanged : let g:entered = expand('<afile>')\n  let g:entered = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  au! CmdlineChanged\n\n  au! CmdlineEnter : let g:entered = expand('<afile>')\n  au! CmdlineLeave : let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  call feedkeys(\":echo 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  call assert_equal(':', g:left)\n  au! CmdlineEnter\n  au! CmdlineLeave\n\n  let save_shellslash = &shellslash\n  set noshellslash\n  au! CmdlineEnter / let g:entered = expand('<afile>')\n  au! CmdlineLeave / let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  new\n  call setline(1, 'hello')\n  call feedkeys(\"/hello\\<CR>\", 'xt')\n  call assert_equal('/', g:entered)\n  call assert_equal('/', g:left)\n  bwipe!\n  au! CmdlineEnter\n  au! CmdlineLeave\n  let &shellslash = save_shellslash\nendfunc\n\n\" Test for BufWritePre autocommand that deletes or unloads the buffer.\nfunc Test_BufWritePre()\n  %bwipe\n  au BufWritePre Xxx1 bunload\n  au BufWritePre Xxx2 bwipe\n\n  call writefile(['start of Xxx1', 'test', 'end of Xxx1'], 'Xxx1', 'D')\n  call writefile(['start of Xxx2', 'test', 'end of Xxx2'], 'Xxx2', 'D')\n\n  edit Xtest\n  e! Xxx2\n  bdel Xtest\n  e Xxx1\n  \" write it, will unload it and give an error msg\n  call assert_fails('w', 'E203:')\n  call assert_equal('Xxx2', bufname('%'))\n  edit Xtest\n  e! Xxx2\n  bwipe Xtest\n  \" write it, will delete the buffer and give an error msg\n  call assert_fails('w', 'E203:')\n  call assert_equal('Xxx1', bufname('%'))\n  au! BufWritePre\nendfunc\n\n\" Test for BufUnload autocommand that unloads all the other buffers\nfunc Test_bufunload_all()\n  let g:test_is_flaky = 1\n  call writefile(['Test file Xxx1'], 'Xxx1', 'D')\"\n  call writefile(['Test file Xxx2'], 'Xxx2', 'D')\"\n\n  let content =<< trim [CODE]\n    func UnloadAllBufs()\n      let i = 1\n      while i <= bufnr('$')\n        if i != bufnr('%') && bufloaded(i)\n          exe  i . 'bunload'\n        endif\n        let i += 1\n      endwhile\n    endfunc\n    au BufUnload * call UnloadAllBufs()\n    au VimLeave * call writefile(['Test Finished'], 'Xout')\n    edit Xxx1\n    split Xxx2\n    q\n  [CODE]\n\n  call writefile(content, 'Xbunloadtest', 'D')\n\n  call delete('Xout')\n  call system(GetVimCommandClean() .. ' -N --not-a-term -S Xbunloadtest')\n  call assert_true(filereadable('Xout'))\n\n  call delete('Xout')\nendfunc\n\n\" Some tests for buffer-local autocommands\nfunc Test_buflocal_autocmd()\n  let g:bname = ''\n  edit xx\n  au BufLeave <buffer> let g:bname = expand(\"%\")\n  \" here, autocommand for xx should trigger.\n  \" but autocommand shall not apply to buffer named <buffer>.\n  edit somefile\n  call assert_equal('xx', g:bname)\n  let g:bname = ''\n  \" here, autocommand shall be auto-deleted\n  bwipe xx\n  \" autocmd should not trigger\n  edit xx\n  call assert_equal('', g:bname)\n  \" autocmd should not trigger\n  edit somefile\n  call assert_equal('', g:bname)\n  enew\n  unlet g:bname\nendfunc\n\n\" Test for \"*Cmd\" autocommands\nfunc Test_Cmd_Autocmds()\n  call writefile(['start of Xxx', \"\\tabc2\", 'end of Xxx'], 'Xxx', 'D')\n\n  enew!\n  au BufReadCmd XtestA 0r Xxx|$del\n  edit XtestA\t\t\t\" will read text of Xxd instead\n  call assert_equal('start of Xxx', getline(1))\n\n  au BufWriteCmd XtestA call append(line(\"$\"), \"write\")\n  write\t\t\t\t\" will append a line to the file\n  call assert_equal('write', getline('$'))\n  call assert_fails('read XtestA', 'E484:')\t\" should not read anything\n  call assert_equal('write', getline(4))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tend of Xxx\n  \" 4\twrite\n\n  au FileReadCmd XtestB '[r Xxx\n  2r XtestB\t\t\t\" will read Xxx below line 2 instead\n  call assert_equal('start of Xxx', getline(3))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc2\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n\n  au FileWriteCmd XtestC '[,']copy $\n  normal 4GA1\n  4,5w XtestC\t\t\t\" will copy lines 4 and 5 to the end\n  call assert_equal(\"\\tabc21\", getline(8))\n  call assert_fails('r XtestC', 'E484:')\t\" should not read anything\n  call assert_equal(\"end of Xxx\", getline(9))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc21\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n  \" 8\t\tabc21\n  \" 9\tend of Xxx\n\n  let g:lines = []\n  au FileAppendCmd XtestD call extend(g:lines, getline(line(\"'[\"), line(\"']\")))\n  w >>XtestD\t\t\t\" will add lines to 'lines'\n  call assert_equal(9, len(g:lines))\n  call assert_fails('$r XtestD', 'E484:')\t\" should not read anything\n  call assert_equal(9, line('$'))\n  call assert_equal('end of Xxx', getline('$'))\n\n  au BufReadCmd XtestE 0r Xxx|$del\n  sp XtestE\t\t\t\" split window with test.out\n  call assert_equal('end of Xxx', getline(3))\n\n  let g:lines = []\n  exe \"normal 2Goasdf\\<Esc>\\<C-W>\\<C-W>\"\n  au BufWriteCmd XtestE call extend(g:lines, getline(0, '$'))\n  wall\t\t\t\t\" will write other window to 'lines'\n  call assert_equal(4, len(g:lines), g:lines)\n  call assert_equal('asdf', g:lines[2])\n\n  au! BufReadCmd\n  au! BufWriteCmd\n  au! FileReadCmd\n  au! FileWriteCmd\n  au! FileAppendCmd\n  %bwipe!\n  enew!\nendfunc\n\nfunc s:ReadFile()\n  setl noswapfile nomodified\n  let filename = resolve(expand(\"<afile>:p\"))\n  execute 'read' fnameescape(filename)\n  1d_\n  exe 'file' fnameescape(filename)\n  setl buftype=acwrite\nendfunc\n\nfunc s:WriteFile()\n  let filename = resolve(expand(\"<afile>:p\"))\n  setl buftype=\n  noautocmd execute 'write' fnameescape(filename)\n  setl buftype=acwrite\n  setl nomodified\nendfunc\n\nfunc Test_BufReadCmd()\n  autocmd BufReadCmd *.test call s:ReadFile()\n  autocmd BufWriteCmd *.test call s:WriteFile()\n\n  call writefile(['one', 'two', 'three'], 'Xcmd.test', 'D')\n  edit Xcmd.test\n  call assert_match('Xcmd.test\" line 1 of 3', execute('file'))\n  normal! Gofour\n  write\n  call assert_equal(['one', 'two', 'three', 'four'], readfile('Xcmd.test'))\n\n  bwipe!\n  au! BufReadCmd\n  au! BufWriteCmd\nendfunc\n\nfunc Test_BufWriteCmd()\n  autocmd BufWriteCmd Xbufwritecmd let g:written = 1\n  new\n  file Xbufwritecmd\n  set buftype=acwrite\n  call mkdir('Xbufwritecmd', 'D')\n  write\n  \" BufWriteCmd should be triggered even if a directory has the same name\n  call assert_equal(1, g:written)\n  unlet g:written\n  au! BufWriteCmd\n  bwipe!\nendfunc\n\nfunc SetChangeMarks(start, end)\n  exe a:start .. 'mark ['\n  exe a:end .. 'mark ]'\nendfunc\n\n\" Verify the effects of autocmds on '[ and ']\nfunc Test_change_mark_in_autocmds()\n  edit! Xtest\n  call feedkeys(\"ia\\<CR>b\\<CR>c\\<CR>d\\<C-g>u\\<Esc>\", 'xtn')\n\n  call SetChangeMarks(2, 3)\n  write\n  call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n\n  call SetChangeMarks(2, 3)\n  au BufWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write\n  au! BufWritePre\n\n  if has('unix')\n    write XtestFilter\n    write >> XtestFilter\n\n    call SetChangeMarks(2, 3)\n    \" Marks are set to the entire range of the write\n    au FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    \" '[ is adjusted to just before the line that will receive the filtered\n    \" data\n    au FilterReadPre * call assert_equal([4, 4], [line(\"'[\"), line(\"']\")])\n    \" The filtered data is read into the buffer, and the source lines are\n    \" still present, so the range is after the source lines\n    au FilterReadPost * call assert_equal([5, 12], [line(\"'[\"), line(\"']\")])\n    %!cat XtestFilter\n    \" After the filtered data is read, the original lines are deleted\n    call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call SetChangeMarks(1, 4)\n    au FilterWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPre * call assert_equal([3, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n    2,3!cat XtestFilter\n    call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call delete('XtestFilter')\n  endif\n\n  call SetChangeMarks(1, 4)\n  au FileWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write Xtest2\n  au! FileWritePre\n\n  call SetChangeMarks(2, 3)\n  au FileAppendPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 4)\n  au FileAppendPre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 1)\n  au FileReadPre * call assert_equal([3, 1], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n  3read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n  0read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n  1read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  bwipe!\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_Filter_noshelltemp()\n  CheckExecutable cat\n\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  let shelltemp = &shelltemp\n  set shelltemp\n\n  let g:filter_au = 0\n  au FilterWritePre * let g:filter_au += 1\n  au FilterReadPre * let g:filter_au += 1\n  au FilterReadPost * let g:filter_au += 1\n  %!cat\n  call assert_equal(3, g:filter_au)\n\n  if has('filterpipe')\n    set noshelltemp\n\n    let g:filter_au = 0\n    au FilterWritePre * let g:filter_au += 1\n    au FilterReadPre * let g:filter_au += 1\n    au FilterReadPost * let g:filter_au += 1\n    %!cat\n    call assert_equal(0, g:filter_au)\n  endif\n\n  au! FilterWritePre,FilterReadPre,FilterReadPost\n  let &shelltemp = shelltemp\n  bwipe!\nendfunc\n\nfunc Test_TextYankPost()\n  enew!\n  call setline(1, ['foo'])\n\n  let g:event = []\n  au TextYankPost * let g:event = copy(v:event)\n\n  call assert_equal({}, v:event)\n  call assert_fails('let v:event = {}', 'E46:')\n  call assert_fails('let v:event.mykey = 0', 'E742:')\n\n  norm \"ayiw\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: 'a', operator: 'y',\n        \\   regtype: 'v', visual: v:false, inclusive: v:true},\n        \\ g:event)\n  norm y_\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: '',  operator: 'y', regtype: 'V',\n        \\   visual: v:false, inclusive: v:false},\n        \\ g:event)\n  norm Vy\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: '',  operator: 'y', regtype: 'V',\n        \\   visual: v:true, inclusive: v:true},\n        \\ g:event)\n  call feedkeys(\"\\<C-V>y\", 'x')\n  call assert_equal(\n        \\ #{regcontents: ['f'], regname: '',  operator: 'y', regtype: \"\\x161\",\n        \\   visual: v:true, inclusive: v:true},\n        \\ g:event)\n  norm \"xciwbar\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: 'x', operator: 'c', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n  norm \"bdiw\n  call assert_equal(\n        \\ #{regcontents: ['bar'], regname: 'b', operator: 'd', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n\n  call setline(1, 'foobar')\n  \" exclusive motion\n  norm $\"ay0\n  call assert_equal(\n        \\ #{regcontents: ['fooba'], regname: 'a', operator: 'y', regtype: 'v',\n        \\   visual: v:false, inclusive: v:false},\n        \\ g:event)\n  \" inclusive motion\n  norm 0\"ay$\n  call assert_equal(\n        \\ #{regcontents: ['foobar'], regname: 'a', operator: 'y', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n\n  call assert_equal({}, v:event)\n\n  if has('clipboard_working') && !has('gui_running')\n    \" Test that when the visual selection is automatically copied to clipboard\n    \" register a TextYankPost is emitted\n    call setline(1, ['foobar'])\n\n    let @* = ''\n    set clipboard=autoselect\n    exe \"norm! ggviw\\<Esc>\"\n    call assert_equal(\n          \\ #{regcontents: ['foobar'], regname: '*', operator: 'y',\n          \\   regtype: 'v', visual: v:true, inclusive: v:false},\n          \\ g:event)\n\n    let @+ = ''\n    set clipboard=autoselectplus\n    exe \"norm! ggviw\\<Esc>\"\n    call assert_equal(\n          \\ #{regcontents: ['foobar'], regname: '+', operator: 'y',\n          \\   regtype: 'v', visual: v:true, inclusive: v:false},\n          \\ g:event)\n\n    set clipboard&vim\n  endif\n\n  au! TextYankPost\n  unlet g:event\n  bwipe!\nendfunc\n\nfunc Test_autocommand_all_events()\n  call assert_fails('au * * bwipe', 'E1155:')\n  call assert_fails('au * x bwipe', 'E1155:')\n  call assert_fails('au! * x bwipe', 'E1155:')\nendfunc\n\nfunc Test_autocmd_user()\n  au User MyEvent let s:res = [expand(\"<afile>\"), expand(\"<amatch>\")]\n  doautocmd User MyEvent\n  call assert_equal(['MyEvent', 'MyEvent'], s:res)\n  au! User\n  unlet s:res\nendfunc\n\nfunction s:Before_test_dirchanged()\n  augroup test_dirchanged\n    autocmd!\n  augroup END\n  let s:li = []\n  let s:dir_this = getcwd()\n  let s:dir_foo = s:dir_this . '/Xfoo'\n  call mkdir(s:dir_foo)\n  let s:dir_bar = s:dir_this . '/Xbar'\n  call mkdir(s:dir_bar)\nendfunc\n\nfunction s:After_test_dirchanged()\n  call chdir(s:dir_this)\n  call delete(s:dir_foo, 'd')\n  call delete(s:dir_bar, 'd')\n  augroup test_dirchanged\n    autocmd!\n  augroup END\nendfunc\n\nfunction Test_dirchanged_global()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChangedPre global call add(s:li, expand(\"<amatch>\") .. \" pre cd \" .. v:event.directory)\n  autocmd test_dirchanged DirChanged global call add(s:li, \"cd:\")\n  autocmd test_dirchanged DirChanged global call add(s:li, expand(\"<afile>\"))\n  call chdir(s:dir_foo)\n  let expected = [\"global pre cd \" .. s:dir_foo, \"cd:\", s:dir_foo]\n  call assert_equal(expected, s:li)\n  call chdir(s:dir_foo)\n  call assert_equal(expected, s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal(expected, s:li)\n\n  exe 'cd ' .. s:dir_foo\n  exe 'cd ' .. s:dir_bar\n  autocmd! test_dirchanged DirChanged global let g:result = expand(\"<afile>\")\n  cd -\n  call assert_equal(s:dir_foo, substitute(g:result, '\\\\', '/', 'g'))\n\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_local()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChanged window call add(s:li, \"lcd:\")\n  autocmd test_dirchanged DirChanged window call add(s:li, expand(\"<afile>\"))\n  call chdir(s:dir_foo)\n  call assert_equal([], s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_auto()\n  CheckOption autochdir\n  call s:Before_test_dirchanged()\n  call test_autochdir()\n  autocmd test_dirchanged DirChangedPre auto call add(s:li, \"pre cd \" .. v:event.directory)\n  autocmd test_dirchanged DirChanged auto call add(s:li, \"auto:\")\n  autocmd test_dirchanged DirChanged auto call add(s:li, expand(\"<afile>\"))\n  set acd\n  cd ..\n  call assert_equal([], s:li)\n  exe 'edit ' . s:dir_foo . '/Xautofile'\n  call assert_equal(s:dir_foo, getcwd())\n  let expected = [\"pre cd \" .. s:dir_foo, \"auto:\", s:dir_foo]\n  call assert_equal(expected, s:li)\n  set noacd\n  bwipe!\n  call s:After_test_dirchanged()\nendfunc\n\n\" Test TextChangedI and TextChangedP\nfunc Test_ChangedP()\n  new\n  call setline(1, ['foo', 'bar', 'foobar'])\n  call test_override(\"char_avail\", 1)\n  set complete=. completeopt=menuone\n\n  func! TextChangedAutocmd(char)\n    let g:autocmd .= a:char\n  endfunc\n\n  \" TextChanged will not be triggered, only check that it isn't.\n  au! TextChanged <buffer> :call TextChangedAutocmd('N')\n  au! TextChangedI <buffer> :call TextChangedAutocmd('I')\n  au! TextChangedP <buffer> :call TextChangedAutocmd('P')\n\n  call cursor(3, 1)\n  let g:autocmd = ''\n  call feedkeys(\"o\\<esc>\", 'tnix')\n  call assert_equal('I', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\", 'tnix')\n  call assert_equal('II', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\", 'tnix')\n  call assert_equal('IIP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPPP', g:autocmd)\n\n  call assert_equal(['foo', 'bar', 'foobar', 'foo'], getline(1, '$'))\n  \" TODO: how should it handle completeopt=noinsert,noselect?\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged\n  au! TextChangedI\n  au! TextChangedP\n  delfu TextChangedAutocmd\n  unlet! g:autocmd\n  set complete&vim completeopt&vim\n\n  bw!\nendfunc\n\nlet g:setline_handled = v:false\nfunc SetLineOne()\n  if !g:setline_handled\n    call setline(1, \"(x)\")\n    let g:setline_handled = v:true\n  endif\nendfunc\n\nfunc Test_TextChangedI_with_setline()\n  new\n  call test_override('char_avail', 1)\n  autocmd TextChangedI <buffer> call SetLineOne()\n  call feedkeys(\"i(\\<CR>\\<Esc>\", 'tx')\n  call assert_equal('(', getline(1))\n  call assert_equal('x)', getline(2))\n  undo\n  call assert_equal('', getline(1))\n  call assert_equal('', getline(2))\n\n  call test_override('char_avail', 0)\n  bwipe!\nendfunc\n\nfunc Test_Changed_FirstTime()\n  CheckFeature terminal\n  CheckNotGui\n  \" Starting a terminal to run Vim is always considered flaky.\n  let g:test_is_flaky = 1\n\n  \" Prepare file for TextChanged event.\n  call writefile([''], 'Xchanged.txt', 'D')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile'], {'term_rows': 3})\n  call assert_equal('running', term_getstatus(buf))\n  \" Wait for the ruler (in the status line) to be shown.\n  \" In ConPTY, there is additional character which is drawn up to the width of\n  \" the screen.\n  if has('conpty')\n    call WaitForAssert({-> assert_match('\\<All.*$', term_getline(buf, 3))})\n  else\n    call WaitForAssert({-> assert_match('\\<All$', term_getline(buf, 3))})\n  endif\n  \" It's only adding autocmd, so that no event occurs.\n  call term_sendkeys(buf, \":au! TextChanged <buffer> call writefile(['No'], 'Xchanged.txt')\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-\\\\>\\<C-N>:qa!\\<cr>\")\n  call WaitForAssert({-> assert_equal('finished', term_getstatus(buf))})\n  call assert_equal([''], readfile('Xchanged.txt'))\n\n  \" clean up\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested()\n  let g:did_nested = 0\n  augroup Testing\n    au WinNew * edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(0, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" old nested argument still works\n  augroup Testing\n    au!\n    au WinNew * nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" New ++nested argument works\n  augroup Testing\n    au!\n    au WinNew * ++nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" nested without ++ does not work in Vim9 script\n  call assert_fails('vim9cmd au WinNew * nested echo fails', 'E1078:')\n\n  augroup Testing\n    au!\n  augroup END\n\n  call assert_fails('au WinNew * ++nested ++nested echo bad', 'E983:')\n  call assert_fails('au WinNew * nested nested echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_nested_cursor_invalid()\n  set laststatus=0\n  copen\n  cclose\n  call setline(1, ['foo', 'bar', 'baz'])\n  3\n  augroup nested_inv\n    autocmd User foo ++nested copen\n    autocmd BufAdd * let &laststatus = 2 - &laststatus\n  augroup END\n  doautocmd User foo\n\n  augroup nested_inv\n    au!\n  augroup END\n  set laststatus&\n  cclose\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested_keeps_cursor_pos()\n  enew\n  call setline(1, 'foo')\n  autocmd User foo ++nested normal! $a\n  autocmd InsertLeave * :\n  doautocmd User foo\n  call assert_equal([0, 1, 3, 0], getpos('.'))\n\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested_switch_window()\n  \" run this in a separate Vim so that SafeState works\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      vim9script\n      ['()']->writefile('Xautofile')\n      autocmd VimEnter * ++nested edit Xautofile | split\n      autocmd BufReadPost * autocmd SafeState * ++once foldclosed('.')\n      autocmd WinEnter * matchadd('ErrorMsg', 'pat')\n  END\n  call writefile(lines, 'Xautoscript', 'D')\n  let buf = RunVimInTerminal('-S Xautoscript', {'rows': 10})\n  call VerifyScreenDump(buf, 'Test_autocmd_nested_switch', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xautofile')\nendfunc\n\nfunc Test_autocmd_once()\n  \" Without ++once WinNew triggers twice\n  let g:did_split = 0\n  augroup Testing\n    au WinNew * let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(2, g:did_split)\n  call assert_true(exists('#WinNew'))\n  close\n  close\n\n  \" With ++once WinNew triggers once\n  let g:did_split = 0\n  augroup Testing\n    au!\n    au WinNew * ++once let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(1, g:did_split)\n  call assert_false(exists('#WinNew'))\n  close\n  close\n\n  call assert_fails('au WinNew * ++once ++once echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_bufreadpre()\n  new\n  let b:bufreadpre = 1\n  call append(0, range(1000))\n  w! XAutocmdBufReadPre.txt\n  autocmd BufReadPre <buffer> :let b:bufreadpre += 1\n  norm! 500gg\n  sp\n  norm! 1000gg\n  wincmd p\n  let g:wsv1 = winsaveview()\n  wincmd p\n  let g:wsv2 = winsaveview()\n  \" triggers BufReadPre, should not move the cursor in either window\n  \" The topline may change one line in a large window.\n  edit\n  call assert_inrange(g:wsv2.topline - 1, g:wsv2.topline + 1, winsaveview().topline)\n  call assert_equal(g:wsv2.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  \" Now set the cursor position in an BufReadPre autocommand\n  \" (even though the position will be invalid, this should make Vim reset the\n  \" cursor position in the other window.\n  wincmd p\n  set cpo+=g\n  \" won't do anything, but try to set the cursor on an invalid lnum\n  autocmd BufReadPre <buffer> :norm! 70gg\n  \" triggers BufReadPre, should not move the cursor in either window\n  e\n  call assert_equal(1, winsaveview().topline)\n  call assert_equal(1, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  close\n  close\n  call delete('XAutocmdBufReadPre.txt')\n  set cpo-=g\nendfunc\n\n\" FileChangedShell tested in test_filechanged.vim\n\n\" Tests for the following autocommands:\n\" - FileWritePre\twriting a compressed file\n\" - FileReadPost\treading a compressed file\n\" - BufNewFile\t\treading a file template\n\" - BufReadPre\t\tdecompressing the file to be read\n\" - FilterReadPre\tsubstituting characters in the temp file\n\" - FilterReadPost\tsubstituting characters after filtering\n\" - FileReadPre\t\tset options for decompression\n\" - FileReadPost\tdecompress the file\nfunc Test_ReadWrite_Autocmds()\n  \" Run this test only on Unix-like systems and if gzip is available\n  CheckUnix\n  CheckExecutable gzip\n\n  \" Make $GZIP empty, \"-v\" would cause trouble.\n  let $GZIP = \"\"\n\n  \" Use a FileChangedShell autocommand to avoid a prompt for 'Xtestfile.gz'\n  \" being modified outside of Vim (noticed on Solaris).\n  au FileChangedShell * echo 'caught FileChangedShell'\n\n  \" Test for the FileReadPost, FileWritePre and FileWritePost autocmds\n  augroup Test1\n    au!\n    au FileWritePre    *.gz   '[,']!gzip\n    au FileWritePost   *.gz   undo\n    au FileReadPost    *.gz   '[,']!gzip -d\n  augroup END\n\n  new\n  set bin\n  call append(0, [\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ])\n  1,9write! Xtestfile.gz\n  enew! | close\n\n  new\n  \" Read and decompress the testfile\n  0read Xtestfile.gz\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  enew! | close\n\n  augroup Test1\n    au!\n  augroup END\n\n  \" Test for the FileAppendPre and FileAppendPost autocmds\n  augroup Test2\n    au!\n    au BufNewFile      *.c    read Xtest.c\n    au FileAppendPre   *.out  '[,']s/new/NEW/\n    au FileAppendPost  *.out  !cat Xtest.c >> test.out\n  augroup END\n\n  call writefile(['/*', ' * Here is a new .c file', ' */'], 'Xtest.c', 'D')\n  new foo.c\t\t\t\" should load Xtest.c\n  call assert_equal(['/*', ' * Here is a new .c file', ' */'], getline(2, 4))\n  w! >> test.out\t\t\" append it to the output file\n\n  let contents = readfile('test.out')\n  call assert_equal(' * Here is a NEW .c file', contents[2])\n  call assert_equal(' * Here is a new .c file', contents[5])\n\n  call delete('test.out')\n  enew! | close\n  augroup Test2\n    au!\n  augroup END\n\n  \" Test for the BufReadPre and BufReadPost autocmds\n  augroup Test3\n    au!\n    \" setup autocommands to decompress before reading and re-compress\n    \" afterwards\n    au BufReadPre  *.gz  exe '!gzip -d ' . shellescape(expand(\"<afile>\"))\n    au BufReadPre  *.gz  call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au BufReadPost *.gz  call rename(expand(\"<afile>\"), expand(\"<afile>:r\"))\n    au BufReadPost *.gz  exe '!gzip ' . shellescape(expand(\"<afile>:r\"))\n  augroup END\n\n  e! Xtestfile.gz\t\t\" Edit compressed file\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n\n  w! >> test.out\t\t\" Append it to the output file\n\n  augroup Test3\n    au!\n  augroup END\n\n  \" Test for the FilterReadPre and FilterReadPost autocmds.\n  set shelltemp\t\t\t\" need temp files here\n  augroup Test4\n    au!\n    au FilterReadPre   *.out  call rename(expand(\"<afile>\"), expand(\"<afile>\") . \".t\")\n    au FilterReadPre   *.out  exe 'silent !sed s/e/E/ ' . shellescape(expand(\"<afile>\")) . \".t >\" . shellescape(expand(\"<afile>\"))\n    au FilterReadPre   *.out  exe 'silent !rm ' . shellescape(expand(\"<afile>\")) . '.t'\n    au FilterReadPost  *.out  '[,']s/x/X/g\n  augroup END\n\n  e! test.out\t\t\t\" Edit the output file\n  1,$!cat\n  call assert_equal([\n\t      \\ 'linE 2\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 3\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 4\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 5\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 6\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 7\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 8\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 9\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 10 AbcdefghijklmnopqrstuvwXyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('test.out'))\n\n  augroup Test4\n    au!\n  augroup END\n  set shelltemp&vim\n\n  \" Test for the FileReadPre and FileReadPost autocmds.\n  augroup Test5\n    au!\n    au FileReadPre *.gz exe 'silent !gzip -d ' . shellescape(expand(\"<afile>\"))\n    au FileReadPre *.gz call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au FileReadPost *.gz '[,']s/l/L/\n  augroup END\n\n  new\n  0r Xtestfile.gz\t\t\" Read compressed file\n  call assert_equal([\n\t      \\ 'Line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('Xtestfile.gz'))\n\n  augroup Test5\n    au!\n  augroup END\n\n  au! FileChangedShell\n  call delete('Xtestfile.gz')\n  call delete('test.out')\nendfunc\n\nfunc Test_throw_in_BufWritePre()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call assert_false(filereadable('Xthefile'))\n  augroup throwing\n    au BufWritePre X* throw 'do not write'\n  augroup END\n  try\n    w Xthefile\n  catch\n    let caught = 1\n  endtry\n  call assert_equal(1, caught)\n  call assert_false(filereadable('Xthefile'))\n\n  bwipe!\n  au! throwing\nendfunc\n\nfunc Test_autocmd_in_try_block()\n  call mkdir('Xintrydir', 'R')\n  au BufEnter * let g:fname = expand('%')\n  try\n    edit Xintrydir/\n  endtry\n  call assert_match('Xintrydir', g:fname)\n\n  unlet g:fname\n  au! BufEnter\nendfunc\n\nfunc Test_autocmd_SafeState()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n\tlet g:safe = 0\n\tlet g:again = ''\n\tau SafeState * let g:safe += 1\n\tau SafeStateAgain * let g:again ..= 'x'\n\tfunc CallTimer()\n\t  call timer_start(10, {id -> execute('let g:again ..= \"t\"')})\n\tendfunc\n  END\n  call writefile(lines, 'XSafeState', 'D')\n  let buf = RunVimInTerminal('-S XSafeState', #{rows: 6})\n\n  \" Sometimes we loop to handle a K_IGNORE, SafeState may be triggered once or\n  \" more often.\n  call term_sendkeys(buf, \":echo g:safe\\<CR>\")\n  call WaitForAssert({-> assert_match('^\\d ', term_getline(buf, 6))}, 1000)\n\n  \" SafeStateAgain should be invoked at least three times\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('^xxx', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \":let g:again = ''\\<CR>:call CallTimer()\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('xtx', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_autocmd_CmdWinEnter()\n  CheckRunVimInTerminal\n  CheckFeature cmdwin\n\n  let lines =<< trim END\n    augroup vimHints | au! | augroup END\n    let b:dummy_var = 'This is a dummy'\n    autocmd CmdWinEnter * quit\n    let winnr = winnr('$')\n  END\n  let filename = 'XCmdWinEnter'\n  call writefile(lines, filename)\n  let buf = RunVimInTerminal('-S '.filename, #{rows: 6})\n\n  call term_sendkeys(buf, \"q:\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo b:dummy_var\\<cr>\")\n  call WaitForAssert({-> assert_match('^This is a dummy', term_getline(buf, 6))}, 2000)\n  call term_sendkeys(buf, \":echo &buftype\\<cr>\")\n  call WaitForAssert({-> assert_notmatch('^nofile', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":echo winnr\\<cr>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 6))}, 1000)\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete(filename)\nendfunc\n\nfunc Test_autocmd_was_using_freed_memory()\n  CheckFeature quickfix\n\n  pedit xx\n  n x\n  augroup winenter\n    au WinEnter * if winnr('$') > 2 | quit | endif\n  augroup END\n  split\n\n  augroup winenter\n    au! WinEnter\n  augroup END\n\n  bwipe xx\n  bwipe x\n  pclose\nendfunc\n\nfunc Test_BufWrite_lockmarks()\n  let g:test_is_flaky = 1\n  edit! Xtest\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  \" :lockmarks preserves the marks\n  call SetChangeMarks(2, 3)\n  lockmarks write\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  \" *WritePre autocmds get the correct line range, but lockmarks preserves the\n  \" original values for the user\n  augroup lockmarks\n    au!\n    au BufWritePre,FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    au FileWritePre * call assert_equal([3, 4], [line(\"'[\"), line(\"']\")])\n  augroup END\n\n  lockmarks write\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  if executable('cat')\n    lockmarks %!cat\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  endif\n\n  lockmarks 3,4write Xtest2\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  au! lockmarks\n  augroup! lockmarks\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_FileType_spell()\n  if !isdirectory('/tmp')\n    throw \"Skipped: requires /tmp directory\"\n  endif\n\n  \" this was crashing with an invalid free()\n  setglobal spellfile=/tmp/en.utf-8.add\n  augroup crash\n    autocmd!\n    autocmd BufNewFile,BufReadPost crashfile setf somefiletype\n    autocmd BufNewFile,BufReadPost crashfile set ft=anotherfiletype\n    autocmd FileType anotherfiletype setlocal spell\n  augroup END\n  func! NoCrash() abort\n    edit /tmp/crashfile\n  endfunc\n  call NoCrash()\n\n  au! crash\n  setglobal spellfile=\nendfunc\n\n\" Test closing a window or editing another buffer from a FileChangedRO handler\n\" in a readonly buffer\nfunc Test_FileChangedRO_winclose()\n  call test_override('ui_delay', 10)\n\n  augroup FileChangedROTest\n    au!\n    autocmd FileChangedRO * quit\n  augroup END\n  new\n  set readonly\n  call assert_fails('normal i', 'E788:')\n  close\n  augroup! FileChangedROTest\n\n  augroup FileChangedROTest\n    au!\n    autocmd FileChangedRO * edit Xrofile\n  augroup END\n  new\n  set readonly\n  call assert_fails('normal i', 'E788:')\n  close\n  augroup! FileChangedROTest\n  call test_override('ALL', 0)\nendfunc\n\nfunc LogACmd()\n  call add(g:logged, line('$'))\nendfunc\n\nfunc Test_TermChanged()\n  CheckNotGui\n\n  enew!\n  tabnew\n  call setline(1, ['a', 'b', 'c', 'd'])\n  $\n  au TermChanged * call LogACmd()\n  let g:logged = []\n  let term_save = &term\n  set term=xterm\n  call assert_equal([1, 4], g:logged)\n\n  au! TermChanged\n  let &term = term_save\n  bwipe!\nendfunc\n\n\" Test for FileReadCmd autocmd\nfunc Test_autocmd_FileReadCmd()\n  func ReadFileCmd()\n    call append(line('$'), \"v:cmdarg = \" .. v:cmdarg)\n  endfunc\n  augroup FileReadCmdTest\n    au!\n    au FileReadCmd Xtest call ReadFileCmd()\n  augroup END\n\n  new\n  read ++bin Xtest\n  read ++nobin Xtest\n  read ++edit Xtest\n  read ++bad=keep Xtest\n  read ++bad=drop Xtest\n  read ++bad=- Xtest\n  read ++ff=unix Xtest\n  read ++ff=dos Xtest\n  read ++ff=mac Xtest\n  read ++enc=utf-8 Xtest\n\n  call assert_equal(['',\n        \\ 'v:cmdarg =  ++bin',\n        \\ 'v:cmdarg =  ++nobin',\n        \\ 'v:cmdarg =  ++edit',\n        \\ 'v:cmdarg =  ++bad=keep',\n        \\ 'v:cmdarg =  ++bad=drop',\n        \\ 'v:cmdarg =  ++bad=-',\n        \\ 'v:cmdarg =  ++ff=unix',\n        \\ 'v:cmdarg =  ++ff=dos',\n        \\ 'v:cmdarg =  ++ff=mac',\n        \\ 'v:cmdarg =  ++enc=utf-8'], getline(1, '$'))\n\n  close!\n  augroup FileReadCmdTest\n    au!\n  augroup END\n  delfunc ReadFileCmd\nendfunc\n\n\" Test for passing invalid arguments to autocmd\nfunc Test_autocmd_invalid_args()\n  \" Additional character after * for event\n  call assert_fails('autocmd *a Xinvfile set ff=unix', 'E215:')\n  augroup Test\n  augroup END\n  \" Invalid autocmd event\n  call assert_fails('autocmd Bufabc Xinvfile set ft=vim', 'E216:')\n  \" Invalid autocmd event in a autocmd group\n  call assert_fails('autocmd Test Bufabc Xinvfile set ft=vim', 'E216:')\n  augroup! Test\n  \" Execute all autocmds\n  call assert_fails('doautocmd * BufEnter', 'E217:')\n  call assert_fails('augroup! x1a2b3', 'E367:')\n  call assert_fails('autocmd BufNew <buffer=999> pwd', 'E680:')\n  call assert_fails('autocmd BufNew \\) set ff=unix', 'E55:')\nendfunc\n\n\" Test for deep nesting of autocmds\nfunc Test_autocmd_deep_nesting()\n  autocmd BufEnter Xdeepfile doautocmd BufEnter Xdeepfile\n  call assert_fails('doautocmd BufEnter Xdeepfile', 'E218:')\n  autocmd! BufEnter Xdeepfile\nendfunc\n\n\" Tests for SigUSR1 autocmd event, which is only available on posix systems.\nfunc Test_autocmd_sigusr1()\n  CheckUnix\n  \" FIXME: should this work on MacOS M1?\n  CheckNotMacM1\n  CheckExecutable /bin/kill\n\n  let g:sigusr1_passed = 0\n  au SigUSR1 * let g:sigusr1_passed = 1\n  call system('/bin/kill -s usr1 ' . getpid())\n  call WaitForAssert({-> assert_true(g:sigusr1_passed)})\n\n  au! SigUSR1\n  unlet g:sigusr1_passed\nendfunc\n\n\" Test for BufReadPre autocmd deleting the file\nfunc Test_BufReadPre_delfile()\n  augroup TestAuCmd\n    au!\n    autocmd BufReadPre XbufreadPre call delete('XbufreadPre')\n  augroup END\n  call writefile([], 'XbufreadPre', 'D')\n  call assert_fails('new XbufreadPre', 'E200:')\n  call assert_equal('XbufreadPre', @%)\n  call assert_equal(1, &readonly)\n\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for BufReadPre autocmd changing the current buffer\nfunc Test_BufReadPre_changebuf()\n  augroup TestAuCmd\n    au!\n    autocmd BufReadPre Xchangebuf edit Xsomeotherfile\n  augroup END\n  call writefile([], 'Xchangebuf', 'D')\n  call assert_fails('new Xchangebuf', 'E201:')\n  call assert_equal('Xsomeotherfile', @%)\n  call assert_equal(1, &readonly)\n\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for BufWipeouti autocmd changing the current buffer when reading a file\n\" in an empty buffer with 'f' flag in 'cpo'\nfunc Test_BufDelete_changebuf()\n  new\n  augroup TestAuCmd\n    au!\n    autocmd BufWipeout * let bufnr = bufadd('somefile') | exe \"b \" .. bufnr\n  augroup END\n  let save_cpo = &cpo\n  set cpo+=f\n  call assert_fails('r Xchangebuf', ['E812:', 'E484:'])\n  call assert_equal('somefile', @%)\n  let &cpo = save_cpo\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for the temporary internal window used to execute autocmds\nfunc Test_autocmd_window()\n  %bw!\n  edit one.txt\n  tabnew two.txt\n  vnew three.txt\n  tabnew four.txt\n  tabprevious\n  let g:blist = []\n  augroup aucmd_win_test1\n    au!\n    au BufEnter * call add(g:blist, [expand('<afile>'),\n          \\ win_gettype(bufwinnr(expand('<afile>')))])\n  augroup END\n\n  doautoall BufEnter\n  call assert_equal([\n        \\ ['one.txt', 'autocmd'],\n        \\ ['two.txt', ''],\n        \\ ['four.txt', 'autocmd'],\n        \\ ['three.txt', ''],\n        \\ ], g:blist)\n\n  augroup aucmd_win_test1\n    au!\n  augroup END\n  augroup! aucmd_win_test1\n  %bw!\nendfunc\n\n\" Test for trying to close the temporary window used for executing an autocmd\nfunc Test_close_autocmd_window()\n  %bw!\n  edit one.txt\n  tabnew two.txt\n  augroup aucmd_win_test2\n    au!\n    au BufEnter * if expand('<afile>') == 'one.txt' | 1close | endif\n  augroup END\n\n  call assert_fails('doautoall BufEnter', 'E813:')\n\n  augroup aucmd_win_test2\n    au!\n  augroup END\n  augroup! aucmd_win_test2\n  %bwipe!\nendfunc\n\n\" Test for trying to close the tab that has the temporary window for exeucing\n\" an autocmd.\nfunc Test_close_autocmd_tab()\n  edit one.txt\n  tabnew two.txt\n   augroup aucmd_win_test\n    au!\n    au BufEnter * if expand('<afile>') == 'one.txt' | tabfirst | tabonly | endif\n  augroup END\n\n  call assert_fails('doautoall BufEnter', 'E813:')\n\n  tabonly\n  augroup aucmd_win_test\n    au!\n  augroup END\n  augroup! aucmd_win_test\n  %bwipe!\nendfunc\n\nfunc Test_Visual_doautoall_redraw()\n  call setline(1, ['a', 'b'])\n  new \n  wincmd p\n  call feedkeys(\"G\\<C-V>\", 'txn')\n  autocmd User Explode ++once redraw\n  doautoall User Explode\n  %bwipe!\nendfunc\n\n\" This was using freed memory.\nfunc Test_BufNew_arglocal()\n  arglocal\n  au BufNew * arglocal\n  call assert_fails('drop xx', 'E1156:')\n\n  au! BufNew\nendfunc\n\nfunc Test_autocmd_closes_window()\n  au BufNew,BufWinLeave * e %e\n  file yyy\n  au BufNew,BufWinLeave * ball\n  n xxx\n\n  %bwipe\n  au! BufNew\n  au! BufWinLeave\nendfunc\n\nfunc Test_autocmd_quit_psearch()\n  sn aa bb\n  augroup aucmd_win_test\n    au!\n    au BufEnter,BufLeave,BufNew,WinEnter,WinLeave,WinNew * if winnr('$') > 1 | q | endif\n  augroup END\n  ps /\n\n  augroup aucmd_win_test\n    au!\n  augroup END\n  new\n  pclose\nendfunc\n\n\" Fuzzer found some strange combination that caused a crash.\nfunc Test_autocmd_normal_mess()\n  \" For unknown reason this hangs on MS-Windows\n  CheckNotMSWindows\n\n  augroup aucmd_normal_test\n    au BufLeave,BufWinLeave,BufHidden,BufUnload,BufDelete,BufWipeout * norm 7q/qc\n  augroup END\n  call assert_fails('o4', 'E1159')\n  silent! H\n  call assert_fails('e xx', 'E1159')\n  normal G\n\n  augroup aucmd_normal_test\n    au!\n  augroup END\nendfunc\n\nfunc Test_autocmd_closing_cmdwin()\n  \" For unknown reason this hangs on MS-Windows\n  CheckNotMSWindows\n\n  au BufWinLeave * nested q\n  call assert_fails(\"norm 7q?\\n\", 'E855:')\n\n  au! BufWinLeave\n  new\n  only\nendfunc\n\nfunc Test_autocmd_vimgrep()\n  augroup aucmd_vimgrep\n    au QuickfixCmdPre,BufNew,BufReadCmd * sb\n    au QuickfixCmdPre,BufNew,BufReadCmd * q9\n  augroup END\n  call assert_fails('lv ?a? foo', 'E926:')\n\n  augroup aucmd_vimgrep\n    au!\n  augroup END\nendfunc\n\nfunc Test_autocmd_with_block()\n  augroup block_testing\n    au BufReadPost *.xml {\n            setlocal matchpairs+=<:>\n            /<start\n          }\n    au CursorHold * {\n        autocmd BufReadPre * ++once echo 'one' | echo 'two'\n        g:gotSafeState = 77\n      }\n  augroup END\n\n  let expected = \"\\n--- Autocommands ---\\nblock_testing  BufRead\\n    *.xml     {^@            setlocal matchpairs+=<:>^@            /<start^@          }\"\n  call assert_equal(expected, execute('au BufReadPost *.xml'))\n\n  doautocmd CursorHold\n  call assert_equal(77, g:gotSafeState)\n  unlet g:gotSafeState\n\n  augroup block_testing\n    au!\n    autocmd CursorHold * {\n      if true\n        # comment\n        && true\n\n        && true\n        g:done = 'yes'\n      endif\n      }\n  augroup END\n  doautocmd CursorHold\n  call assert_equal('yes', g:done)\n\n  unlet g:done\n  augroup block_testing\n    au!\n  augroup END\nendfunc\n\n\" Test TextChangedI and TextChanged\nfunc Test_Changed_ChangedI()\n  new\n  call test_override(\"char_avail\", 1)\n  let [g:autocmd_i, g:autocmd_n] = ['','']\n\n  func! TextChangedAutocmdI(char)\n    let g:autocmd_{tolower(a:char)} = a:char .. b:changedtick\n  endfunc\n\n  augroup Test_TextChanged\n    au!\n    au TextChanged  <buffer> :call TextChangedAutocmdI('N')\n    au TextChangedI <buffer> :call TextChangedAutocmdI('I')\n  augroup END\n\n  call feedkeys(\"ifoo\\<esc>\", 'tnix')\n  \" TODO: Test test does not seem to trigger TextChanged autocommand, this\n  \" requires running Vim in a terminal window.\n  \" call assert_equal('N3', g:autocmd_n)\n  call assert_equal('I3', g:autocmd_i)\n\n  call feedkeys(\"yyp\", 'tnix')\n  \" TODO: Test test does not seem to trigger TextChanged autocommand.\n  \" call assert_equal('N4', g:autocmd_n)\n  call assert_equal('I3', g:autocmd_i)\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged  <buffer>\n  au! TextChangedI <buffer>\n  augroup! Test_TextChanged\n  delfu TextChangedAutocmdI\n  unlet! g:autocmd_i g:autocmd_n\n\n  bw!\nendfunc\n\nfunc Test_closing_autocmd_window()\n  let lines =<< trim END\n      edit Xa.txt\n      tabnew Xb.txt\n      autocmd BufEnter Xa.txt unhide 1\n      doautoall BufEnter\n  END\n  call v9.CheckScriptFailure(lines, 'E814:')\n  au! BufEnter\n  only!\n  bwipe Xa.txt\n  bwipe Xb.txt\nendfunc\n\nfunc Test_bufwipeout_changes_window()\n  \" This should not crash, but we don't have any expectations about what\n  \" happens, changing window in BufWipeout has unpredictable results.\n  tabedit\n  let g:window_id = win_getid()\n  topleft new\n  setlocal bufhidden=wipe\n  autocmd BufWipeout <buffer> call win_gotoid(g:window_id)\n  tabprevious\n  +tabclose\n\n  unlet g:window_id\n  au! BufWipeout\n  %bwipe!\nendfunc\n\nfunc Test_v_event_readonly()\n  autocmd CompleteChanged * let v:event.width = 0\n  call assert_fails(\"normal! i\\<C-X>\\<C-V>\", 'E46:')\n  au! CompleteChanged\n\n  autocmd DirChangedPre * let v:event.directory = ''\n  call assert_fails('cd .', 'E46:')\n  au! DirChangedPre\n\n  autocmd ModeChanged * let v:event.new_mode = ''\n  call assert_fails('normal! cc', 'E46:')\n  au! ModeChanged\n\n  autocmd TextYankPost * let v:event.operator = ''\n  call assert_fails('normal! yy', 'E46:')\n  au! TextYankPost\nendfunc\n\n\" Test for ModeChanged pattern\nfunc Test_mode_changes()\n  let g:index = 0\n  let g:mode_seq = ['n', 'i', 'n', 'v', 'V', 'i', 'ix', 'i', 'ic', 'i', 'n', 'no', 'n', 'V', 'v', 's', 'n']\n  func! TestMode()\n    call assert_equal(g:mode_seq[g:index], get(v:event, \"old_mode\"))\n    call assert_equal(g:mode_seq[g:index + 1], get(v:event, \"new_mode\"))\n    call assert_equal(mode(1), get(v:event, \"new_mode\"))\n    let g:index += 1\n  endfunc\n\n  au ModeChanged * :call TestMode()\n  let g:n_to_any = 0\n  au ModeChanged n:* let g:n_to_any += 1\n  call feedkeys(\"i\\<esc>vVca\\<CR>\\<C-X>\\<C-L>\\<esc>ggdG\", 'tnix')\n\n  let g:V_to_v = 0\n  au ModeChanged V:v let g:V_to_v += 1\n  call feedkeys(\"Vv\\<C-G>\\<esc>\", 'tnix')\n  call assert_equal(len(filter(g:mode_seq[1:], {idx, val -> val == 'n'})), g:n_to_any)\n  call assert_equal(1, g:V_to_v)\n  call assert_equal(len(g:mode_seq) - 1, g:index)\n\n  let g:n_to_i = 0\n  au ModeChanged n:i let g:n_to_i += 1\n  let g:n_to_niI = 0\n  au ModeChanged i:niI let g:n_to_niI += 1\n  let g:niI_to_i = 0\n  au ModeChanged niI:i let g:niI_to_i += 1\n  let g:nany_to_i = 0\n  au ModeChanged n*:i let g:nany_to_i += 1\n  let g:i_to_n = 0\n  au ModeChanged i:n let g:i_to_n += 1\n  let g:nori_to_any = 0\n  au ModeChanged [ni]:* let g:nori_to_any += 1\n  let g:i_to_any = 0\n  au ModeChanged i:* let g:i_to_any += 1\n  let g:index = 0\n  let g:mode_seq = ['n', 'i', 'niI', 'i', 'n']\n  call feedkeys(\"a\\<C-O>l\\<esc>\", 'tnix')\n  call assert_equal(len(g:mode_seq) - 1, g:index)\n  call assert_equal(1, g:n_to_i)\n  call assert_equal(1, g:n_to_niI)\n  call assert_equal(1, g:niI_to_i)\n  call assert_equal(2, g:nany_to_i)\n  call assert_equal(1, g:i_to_n)\n  call assert_equal(2, g:i_to_any)\n  call assert_equal(3, g:nori_to_any)\n\n  if has('terminal')\n    let g:mode_seq += ['c', 'n', 't', 'nt', 'c', 'nt', 'n']\n    call feedkeys(\":term\\<CR>\\<C-W>N:bd!\\<CR>\", 'tnix')\n    call assert_equal(len(g:mode_seq) - 1, g:index)\n    call assert_equal(1, g:n_to_i)\n    call assert_equal(1, g:n_to_niI)\n    call assert_equal(1, g:niI_to_i)\n    call assert_equal(2, g:nany_to_i)\n    call assert_equal(1, g:i_to_n)\n    call assert_equal(2, g:i_to_any)\n    call assert_equal(5, g:nori_to_any)\n  endif\n\n  if has('cmdwin')\n    let g:n_to_c = 0\n    au ModeChanged n:c let g:n_to_c += 1\n    let g:c_to_n = 0\n    au ModeChanged c:n let g:c_to_n += 1\n    let g:mode_seq += ['c', 'n', 'c', 'n']\n    call feedkeys(\"q:\\<C-C>\\<Esc>\", 'tnix')\n    call assert_equal(len(g:mode_seq) - 1, g:index)\n    call assert_equal(2, g:n_to_c)\n    call assert_equal(2, g:c_to_n)\n    unlet g:n_to_c\n    unlet g:c_to_n\n  endif\n\n  au! ModeChanged\n  delfunc TestMode\n  unlet! g:mode_seq\n  unlet! g:index\n  unlet! g:n_to_any\n  unlet! g:V_to_v\n  unlet! g:n_to_i\n  unlet! g:n_to_niI\n  unlet! g:niI_to_i\n  unlet! g:nany_to_i\n  unlet! g:i_to_n\n  unlet! g:nori_to_any\n  unlet! g:i_to_any\nendfunc\n\nfunc Test_recursive_ModeChanged()\n  au! ModeChanged * norm 0u\n  sil! norm \u0016\n  au! ModeChanged\nendfunc\n\nfunc Test_ModeChanged_starts_visual()\n  \" This was triggering ModeChanged before setting VIsual, causing a crash.\n  au! ModeChanged * norm 0u\n  sil! norm \u0016\n\n  au! ModeChanged\nendfunc\n\nfunc Test_noname_autocmd()\n  augroup test_noname_autocmd_group\n    autocmd!\n    autocmd BufEnter * call add(s:li, [\"BufEnter\", expand(\"<afile>\")])\n    autocmd BufDelete * call add(s:li, [\"BufDelete\", expand(\"<afile>\")])\n    autocmd BufLeave * call add(s:li, [\"BufLeave\", expand(\"<afile>\")])\n    autocmd BufUnload * call add(s:li, [\"BufUnload\", expand(\"<afile>\")])\n    autocmd BufWipeout * call add(s:li, [\"BufWipeout\", expand(\"<afile>\")])\n  augroup END\n\n  let s:li = []\n  edit foo\n  call assert_equal([['BufUnload', ''], ['BufDelete', ''], ['BufWipeout', ''], ['BufEnter', 'foo']], s:li)\n\n  au! test_noname_autocmd_group\n  augroup! test_noname_autocmd_group\nendfunc\n\n\" Test for the autocmd_get() function\nfunc Test_autocmd_get()\n  augroup TestAutoCmdFns\n    au!\n    autocmd BufAdd *.vim echo \"bufadd-vim\"\n    autocmd BufAdd *.py echo \"bufadd-py\"\n    autocmd BufHidden *.vim echo \"bufhidden\"\n  augroup END\n  augroup TestAutoCmdFns2\n    autocmd BufAdd *.vim echo \"bufadd-vim-2\"\n    autocmd BufRead *.a1b2c3 echo \"bufadd-vim-2\"\n  augroup END\n\n  let l = autocmd_get()\n  call assert_true(l->len() > 0)\n\n  \" Test for getting all the autocmds in a group\n  let expected = [\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufadd-py\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.py', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufhidden\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false,\n        \\  once: v:false, event: 'BufHidden'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for getting autocmds for all the patterns in a group\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: '*'}))\n\n  \" Test for getting autocmds for an event in a group\n  let expected = [\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufadd-py\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.py', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufAdd'}))\n\n  \" Test for getting the autocmds for all the events in a group for particular\n  \" pattern\n  call assert_equal([{'cmd': 'echo \"bufadd-py\"', 'group': 'TestAutoCmdFns',\n        \\ 'pattern': '*.py', 'nested': v:false, 'once': v:false,\n        \\ 'event': 'BufAdd'}],\n        \\ autocmd_get(#{group: 'TestAutoCmdFns', event: '*', pattern: '*.py'}))\n\n  \" Test for getting the autocmds for an events in a group for particular\n  \" pattern\n  let l = autocmd_get(#{group: 'TestAutoCmdFns', event: 'BufAdd',\n        \\ pattern: '*.vim'})\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'}], l)\n\n  \" Test for getting the autocmds for a pattern in a group\n  let l = autocmd_get(#{group: 'TestAutoCmdFns', pattern: '*.vim'})\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufhidden\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false,\n        \\  once: v:false, event: 'BufHidden'}], l)\n\n  \" Test for getting the autocmds for a pattern in all the groups\n  let l = autocmd_get(#{pattern: '*.a1b2c3'})\n  call assert_equal([{'cmd': 'echo \"bufadd-vim-2\"', 'group': 'TestAutoCmdFns2',\n        \\ 'pattern': '*.a1b2c3', 'nested': v:false, 'once': v:false,\n        \\ 'event': 'BufRead'}], l)\n\n  \" Test for getting autocmds for a pattern without any autocmds\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ pattern: '*.abc'}))\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufAdd', pattern: '*.abc'}))\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufWipeout'}))\n  call assert_fails(\"call autocmd_get(#{group: 'abc', event: 'BufAdd'})\",\n        \\ 'E367:')\n  let cmd = \"echo autocmd_get(#{group: 'TestAutoCmdFns', event: 'abc'})\"\n  call assert_fails(cmd, 'E216:')\n  call assert_fails(\"call autocmd_get(#{group: 'abc'})\", 'E367:')\n  call assert_fails(\"echo autocmd_get(#{event: 'abc'})\", 'E216:')\n\n  augroup TestAutoCmdFns\n    au!\n  augroup END\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for nested and once autocmds\n  augroup TestAutoCmdFns\n    au!\n    autocmd VimSuspend * ++nested echo \"suspend\"\n    autocmd VimResume * ++once echo \"resume\"\n  augroup END\n\n  let expected = [\n        \\ {'cmd': 'echo \"suspend\"', 'group': 'TestAutoCmdFns', 'pattern': '*',\n        \\ 'nested': v:true, 'once': v:false, 'event': 'VimSuspend'},\n        \\ {'cmd': 'echo \"resume\"', 'group': 'TestAutoCmdFns', 'pattern': '*',\n        \\  'nested': v:false, 'once': v:true, 'event': 'VimResume'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for buffer-local autocmd\n  augroup TestAutoCmdFns\n    au!\n    autocmd TextYankPost <buffer> echo \"textyankpost\"\n  augroup END\n\n  let expected = [\n        \\ {'cmd': 'echo \"textyankpost\"', 'group': 'TestAutoCmdFns',\n        \\  'pattern': '<buffer=' .. bufnr() .. '>', 'nested': v:false,\n        \\  'once': v:false, 'bufnr': bufnr(), 'event': 'TextYankPost'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  augroup TestAutoCmdFns\n    au!\n  augroup END\n  augroup! TestAutoCmdFns\n  augroup TestAutoCmdFns2\n    au!\n  augroup END\n  augroup! TestAutoCmdFns2\n\n  call assert_fails(\"echo autocmd_get(#{group: []})\", 'E730:')\n  call assert_fails(\"echo autocmd_get(#{event: {}})\", 'E731:')\n  call assert_fails(\"echo autocmd_get([])\", 'E1206:')\nendfunc\n\n\" Test for the autocmd_add() function\nfunc Test_autocmd_add()\n  \" Define a single autocmd in a group\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"', once: v:true, nested: v:true}])\n  call assert_equal([#{cmd: 'echo \"bufadd\"', group: 'TestAcSet',\n        \\ pattern: '*.sh', nested: v:true, once: v:true,\n        \\ event: 'BufAdd'}], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Define two autocmds in the same group\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"'},\n        \\ #{group: 'TestAcSet', event: 'BufEnter', pattern: '*.sh',\n        \\   cmd: 'echo \"bufenter\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false, once: v:false, event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufenter\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false, once: v:false, event: 'BufEnter'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Define a buffer-local autocmd\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'CursorHold',\n        \\ bufnr: bufnr(), cmd: 'echo \"cursorhold\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"cursorhold\"', group: 'TestAcSet',\n        \\   pattern: '<buffer=' .. bufnr() .. '>', nested: v:false,\n        \\   once: v:false, bufnr: bufnr(), event: 'CursorHold'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Use an invalid buffer number\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufEnter',\n        \\ bufnr: -1, cmd: 'echo \"bufenter\"'}])\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ pattern: '*.py', cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ pattern: ['*.py', '*.c'], cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufRead', bufnr: [],\n        \\ cmd: 'echo \"bufread\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E745:')\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Add two commands to the same group, event and pattern\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufUnload',\n        \\ pattern: 'abc', cmd: 'echo \"cmd1\"'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufUnload',\n        \\ pattern: 'abc', cmd: 'echo \"cmd2\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"cmd1\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufUnload'},\n        \\ #{cmd: 'echo \"cmd2\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufUnload'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" When adding a new autocmd, if the autocmd 'group' is not specified, then\n  \" the current autocmd group should be used.\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  augroup TestAcSet\n    call autocmd_add([#{event: 'BufHidden', pattern: 'abc', cmd: 'echo \"abc\"'}])\n  augroup END\n  call assert_equal([\n        \\ #{cmd: 'echo \"abc\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufHidden'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for replacing a cmd for an event in a group\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{replace: v:true, group: 'TestAcSet', event: 'BufEnter',\n        \\ pattern: '*.py', cmd: 'echo \"bufenter\"'}])\n  call autocmd_add([#{replace: v:true, group: 'TestAcSet', event: 'BufEnter',\n        \\ pattern: '*.py', cmd: 'echo \"bufenter\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufenter\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for adding a command for an unsupported autocmd event\n  let l = [#{group: 'TestAcSet', event: 'abc', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n\n  \" Test for using a list of events and patterns\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  let l = [#{group: 'TestAcSet', event: ['BufEnter', 'BufLeave'],\n        \\ pattern: ['*.py', '*.sh'], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufLeave'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false,  once: v:false, event: 'BufLeave'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for invalid values for 'event' item\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  let l = [#{group: 'TestAcSet', event: test_null_string(),\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: test_null_list(),\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E714:')\n  let l = [#{group: 'TestAcSet', event: {},\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E777:')\n  let l = [#{group: 'TestAcSet', event: [{}],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: [test_null_string()],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: 'BufEnter,BufLeave',\n        \\ pattern: '*.py', cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n  let l = [#{group: 'TestAcSet', event: [],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: [\"\"],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n  let l = [#{group: 'TestAcSet', event: \"\",\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for invalid values for 'pattern' item\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: test_null_string(), cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: test_null_list(), cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E714:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: {}, cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E777:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [{}], cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [test_null_string()], cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [\"\"], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: \"\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  let l = [#{group: 'TestAcSet', event: 'BufEnter,abc,BufLeave',\n        \\ pattern: '*.py', cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n\n  call assert_fails(\"call autocmd_add({})\", 'E1211:')\n  call assert_equal(v:false,  autocmd_add(test_null_list()))\n  call assert_true(autocmd_add([[]]))\n  call assert_true(autocmd_add([test_null_dict()]))\n\n  augroup TestAcSet\n    au!\n  augroup END\n\n  call autocmd_add([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd'}])\n  call autocmd_add([#{group: 'TestAcSet', pat: '*.sh'}])\n  call autocmd_add([#{group: 'TestAcSet', cmd: 'echo \"a\"'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pat: '*.sh'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', cmd: 'echo \"a\"'}])\n  call autocmd_add([#{group: 'TestAcSet', pat: '*.sh', cmd: 'echo \"a\"'}])\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  augroup! TestAcSet\nendfunc\n\n\" Test for deleting autocmd events and groups\nfunc Test_autocmd_delete()\n  \" Delete an event in an autocmd group\n  augroup TestAcSet\n    au!\n    au BufAdd *.sh echo \"bufadd\"\n    au BufEnter *.sh echo \"bufenter\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet', event: 'BufAdd'}])\n  call assert_equal([#{cmd: 'echo \"bufenter\"', group: 'TestAcSet',\n        \\ pattern: '*.sh', nested: v:false, once: v:false,\n        \\ event: 'BufEnter'}], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Delete all the events in an autocmd group\n  augroup TestAcSet\n    au BufAdd *.sh echo \"bufadd\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet', event: '*'}])\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Delete a non-existing autocmd group\n  call assert_fails(\"call autocmd_delete([#{group: 'abc'}])\", 'E367:')\n  \" Delete a non-existing autocmd event\n  let l = [#{group: 'TestAcSet', event: 'abc'}]\n  call assert_fails(\"call autocmd_delete(l)\", 'E216:')\n  \" Delete a non-existing autocmd pattern\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', pat: 'abc'}]\n  call assert_true(autocmd_delete(l))\n  \" Delete an autocmd for a non-existing buffer\n  let l = [#{event: '*', bufnr: 9999, cmd: 'echo \"x\"'}]\n  call assert_fails('call autocmd_delete(l)', 'E680:')\n\n  \" Delete an autocmd group\n  augroup TestAcSet\n    au!\n    au BufAdd *.sh echo \"bufadd\"\n    au BufEnter *.sh echo \"bufenter\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call assert_fails(\"call autocmd_get(#{group: 'TestAcSet'})\", 'E367:')\n\n  call assert_true(autocmd_delete([[]]))\n  call assert_true(autocmd_delete([test_null_dict()]))\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * buffer.c: functions for dealing with the buffer structure\n */\n\n/*\n * The buffer list is a double linked list of all buffers.\n * Each buffer can be in one of these states:\n * never loaded: BF_NEVERLOADED is set, only the file name is valid\n *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n *\t hidden: b_nwindows == 0, loaded but not displayed in a window\n *\t normal: loaded and displayed in a window\n *\n * Instead of storing file names all over the place, each file name is\n * stored in the buffer list. It can be referenced by a number.\n *\n * The current implementation remembers all file names ever used.\n */\n\n#include \"vim.h\"\n\n\n#ifdef FEAT_EVAL\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n# define MAX_STL_EVAL_DEPTH 100\n#endif\n\nstatic void\tenter_buffer(buf_T *buf);\nstatic void\tbuflist_getfpos(void);\nstatic char_u\t*buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);\nstatic char_u\t*fname_match(regmatch_T *rmp, char_u *name, int ignore_case);\n#ifdef UNIX\nstatic buf_T\t*buflist_findname_stat(char_u *ffname, stat_T *st);\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);\nstatic int\tbuf_same_ino(buf_T *buf, stat_T *stp);\n#else\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname);\n#endif\nstatic int\tvalue_changed(char_u *str, char_u **last);\nstatic int\tappend_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);\nstatic void\tfree_buffer(buf_T *);\nstatic void\tfree_buffer_stuff(buf_T *buf, int free_options);\nstatic int\tbt_nofileread(buf_T *buf);\n\n#ifdef UNIX\n# define dev_T dev_t\n#else\n# define dev_T unsigned\n#endif\n\n#define FOR_ALL_BUFS_FROM_LAST(buf) \\\n    for ((buf) = lastbuf; (buf) != NULL; (buf) = (buf)->b_prev)\n\n#if defined(FEAT_QUICKFIX)\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\n#endif\n\n// Number of times free_buffer() was called.\nstatic int\tbuf_free_count = 0;\n\nstatic int\ttop_file_num = 1;\t// highest file number\nstatic garray_T buf_reuse = GA_EMPTY;\t// file numbers to recycle\n\n/*\n * Return the highest possible buffer number.\n */\n    int\nget_highest_fnum(void)\n{\n    return top_file_num - 1;\n}\n\n/*\n * Read data from buffer for retrying.\n */\n    static int\nread_buffer(\n    int\t\tread_stdin,\t    // read file from stdin, otherwise fifo\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    linenr_T\tline_count;\n\n    // Read from the buffer which the text is already filled in and append at\n    // the end.  This makes it possible to retry when 'fileformat' or\n    // 'fileencoding' was guessed wrong.\n    line_count = curbuf->b_ml.ml_line_count;\n    retval = readfile(\n\t    read_stdin ? NULL : curbuf->b_ffname,\n\t    read_stdin ? NULL : curbuf->b_fname,\n\t    line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t    flags | READ_BUFFER);\n    if (retval == OK)\n    {\n\t// Delete the binary lines.\n\twhile (--line_count >= 0)\n\t    ml_delete((linenr_T)1);\n    }\n    else\n    {\n\t// Delete the converted lines.\n\twhile (curbuf->b_ml.ml_line_count > line_count)\n\t    ml_delete(line_count);\n    }\n    // Put the cursor on the first line.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n\n    if (read_stdin)\n    {\n\t// Set or reset 'modified' before executing autocommands, so that\n\t// it can be changed there.\n\tif (!readonlymode && !BUFEMPTY())\n\t    changed();\n\telse if (retval == OK)\n\t    unchanged(curbuf, FALSE, TRUE);\n\n\tif (retval == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);\n#endif\n\t}\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Ensure buffer \"buf\" is loaded.  Does not trigger the swap-exists action.\n */\n    void\nbuffer_ensure_loaded(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\taco_save_T\taco;\n\n\taucmd_prepbuf(&aco, buf);\n\tif (swap_exists_action != SEA_READONLY)\n\t    swap_exists_action = SEA_NONE;\n\topen_buffer(FALSE, NULL, 0);\n\taucmd_restbuf(&aco);\n    }\n}\n#endif\n\n/*\n * Open current buffer, that is: open the memfile and read the file into\n * memory.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nopen_buffer(\n    int\t\tread_stdin,\t    // read file from stdin\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags_arg)\t    // extra flags for readfile()\n{\n    int\t\tflags = flags_arg;\n    int\t\tretval = OK;\n    bufref_T\told_curbuf;\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    int\t\tread_fifo = FALSE;\n\n    // The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n    // When re-entering the same buffer, it should not change, because the\n    // user may have reset the flag by hand.\n    if (readonlymode && curbuf->b_ffname != NULL\n\t\t\t\t\t&& (curbuf->b_flags & BF_NEVERLOADED))\n\tcurbuf->b_p_ro = TRUE;\n\n    if (ml_open(curbuf) == FAIL)\n    {\n\t// There MUST be a memfile, otherwise we can't do anything\n\t// If we can't create one for the current buffer, take another buffer\n\tclose_buffer(NULL, curbuf, 0, FALSE, FALSE);\n\tFOR_ALL_BUFFERS(curbuf)\n\t    if (curbuf->b_ml.ml_mfp != NULL)\n\t\tbreak;\n\t// If there is no memfile at all, exit.\n\t// This is OK, since there are no changes to lose.\n\tif (curbuf == NULL)\n\t{\n\t    emsg(_(e_cannot_allocate_any_buffer_exiting));\n\n\t    // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n\t    // will work.\n\t    v_dying = 2;\n\t    getout(2);\n\t}\n\n\temsg(_(e_cannot_allocate_buffer_using_other_one));\n\tenter_buffer(curbuf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n\treturn FAIL;\n    }\n\n    // The autocommands in readfile() may change the buffer, but only AFTER\n    // reading the file.\n    set_bufref(&old_curbuf, curbuf);\n    modified_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    // A buffer without an actual file should not use the buffer name to read a\n    // file.\n    if (bt_nofileread(curbuf))\n\tflags |= READ_NOFILE;\n\n    // Read the file if there is one.\n    if (curbuf->b_ffname != NULL\n#ifdef FEAT_NETBEANS_INTG\n\t    && netbeansReadFile\n#endif\n       )\n    {\n\tint old_msg_silent = msg_silent;\n#ifdef UNIX\n\tint save_bin = curbuf->b_p_bin;\n\tint perm;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tint oldFire = netbeansFireChanges;\n\n\tnetbeansFireChanges = 0;\n#endif\n#ifdef UNIX\n\tperm = mch_getperm(curbuf->b_ffname);\n\tif (perm >= 0 && (S_ISFIFO(perm)\n\t\t      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n\t\t      || (S_ISCHR(perm) && is_dev_fd_file(curbuf->b_ffname))\n# endif\n\t\t    ))\n\t\tread_fifo = TRUE;\n\tif (read_fifo)\n\t    curbuf->b_p_bin = TRUE;\n#endif\n\tif (shortmess(SHM_FILEINFO))\n\t    msg_silent = 1;\n\tretval = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t\t  flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n\tif (read_fifo)\n\t{\n\t    curbuf->b_p_bin = save_bin;\n\t    if (retval == OK)\n\t\tretval = read_buffer(FALSE, eap, flags);\n\t}\n#endif\n\tmsg_silent = old_msg_silent;\n#ifdef FEAT_NETBEANS_INTG\n\tnetbeansFireChanges = oldFire;\n#endif\n\t// Help buffer is filtered.\n\tif (bt_help(curbuf))\n\t    fix_help_buffer();\n    }\n    else if (read_stdin)\n    {\n\tint\tsave_bin = curbuf->b_p_bin;\n\n\t// First read the text in binary mode into the buffer.\n\t// Then read from that same buffer and append at the end.  This makes\n\t// it possible to retry when 'fileformat' or 'fileencoding' was\n\t// guessed wrong.\n\tcurbuf->b_p_bin = TRUE;\n\tretval = readfile(NULL, NULL, (linenr_T)0,\n\t\t  (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n\t\t  flags | (READ_NEW + READ_STDIN));\n\tcurbuf->b_p_bin = save_bin;\n\tif (retval == OK)\n\t    retval = read_buffer(TRUE, eap, flags);\n    }\n\n    // if first time loading this buffer, init b_chartab[]\n    if (curbuf->b_flags & BF_NEVERLOADED)\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\n\tparse_cino(curbuf);\n    }\n\n    // Set/reset the Changed flag first, autocmds may change the buffer.\n    // Apply the automatic commands, before processing the modelines.\n    // So the modelines have priority over autocommands.\n    //\n    // When reading stdin, the buffer contents always needs writing, so set\n    // the changed flag.  Unless in readonly mode: \"ls | gview -\".\n    // When interrupted and 'cpoptions' contains 'i' set changed flag.\n    if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n\t\t|| modified_was_set\t// \":set modified\" used in autocmd\n#ifdef FEAT_EVAL\n\t\t|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n#endif\n       )\n\tchanged();\n    else if (retval == OK && !read_stdin && !read_fifo)\n\tunchanged(curbuf, FALSE, TRUE);\n    save_file_ff(curbuf);\t\t// keep this fileformat\n\n    // Set last_changedtick to avoid triggering a TextChanged autocommand right\n    // after it was added.\n    curbuf->b_last_changedtick = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\n    // require \"!\" to overwrite the file, because it wasn't read completely\n#ifdef FEAT_EVAL\n    if (aborting())\n#else\n    if (got_int)\n#endif\n\tcurbuf->b_flags |= BF_READERR;\n\n#ifdef FEAT_FOLDING\n    // Need to update automatic folding.  Do this before the autocommands,\n    // they may use the fold info.\n    foldUpdateAll(curwin);\n#endif\n\n    // need to set w_topline, unless some autocommand already did that.\n    if (!(curwin->w_valid & VALID_TOPLINE))\n    {\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n    }\n#ifdef FEAT_EVAL\n    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);\n#else\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n    if (retval == OK)\n    {\n\t// The autocommands may have changed the current buffer.  Apply the\n\t// modelines to the correct buffer, if it still exists and is loaded.\n\tif (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    aco_save_T\taco;\n\n\t    // Go to the buffer that was opened.\n\t    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n\t    do_modelines(0);\n\t    curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n\t    if ((flags & READ_NOWINENTER) == 0)\n#ifdef FEAT_EVAL\n\t\tapply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Store \"buf\" in \"bufref\" and set the free count.\n */\n    void\nset_bufref(bufref_T *bufref, buf_T *buf)\n{\n    bufref->br_buf = buf;\n    bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n    bufref->br_buf_free_count = buf_free_count;\n}\n\n/*\n * Return TRUE if \"bufref->br_buf\" points to the same buffer as when\n * set_bufref() was called and it is a valid buffer.\n * Only goes through the buffer list if buf_free_count changed.\n * Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n * the same allocated memory, but it's a different buffer.\n */\n    int\nbufref_valid(bufref_T *bufref)\n{\n    return bufref->br_buf_free_count == buf_free_count\n\t? TRUE : buf_valid(bufref->br_buf)\n\t\t\t\t  && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/*\n * Return TRUE if \"buf\" points to a valid buffer (in the buffer list).\n * This can be slow if there are many buffers, prefer using bufref_valid().\n */\n    int\nbuf_valid(buf_T *buf)\n{\n    buf_T\t*bp;\n\n    // Assume that we more often have a recent buffer, start with the last\n    // one.\n    FOR_ALL_BUFS_FROM_LAST(bp)\n\tif (bp == buf)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * A hash table used to quickly lookup a buffer by its number.\n */\nstatic hashtab_T buf_hashtab;\n\n    static void\nbuf_hashtab_add(buf_T *buf)\n{\n    sprintf((char *)buf->b_key, \"%x\", buf->b_fnum);\n    if (hash_add(&buf_hashtab, buf->b_key) == FAIL)\n\temsg(_(e_buffer_cannot_be_registered));\n}\n\n    static void\nbuf_hashtab_remove(buf_T *buf)\n{\n    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);\n\n    if (!HASHITEM_EMPTY(hi))\n\thash_remove(&buf_hashtab, hi);\n}\n\n/*\n * Return TRUE when buffer \"buf\" can be unloaded.\n * Give an error message and return FALSE when the buffer is locked or the\n * screen is being redrawn and the buffer is in a window.\n */\n    static int\ncan_unload_buffer(buf_T *buf)\n{\n    int\t    can_unload = !buf->b_locked;\n\n    if (can_unload && updating_screen)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n    {\n\tchar_u *fname = buf->b_fname != NULL ? buf->b_fname : buf->b_ffname;\n\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),\n\t\t\t\tfname != NULL ? fname : (char_u *)\"[No Name]\");\n    }\n    return can_unload;\n}\n\n/*\n * Close the link to a buffer.\n * \"action\" is used when there is no longer a window for the buffer.\n * It can be:\n * 0\t\t\tbuffer becomes hidden\n * DOBUF_UNLOAD\t\tbuffer is unloaded\n * DOBUF_DELETE\t\tbuffer is unloaded and removed from buffer list\n * DOBUF_WIPE\t\tbuffer is unloaded and really deleted\n * DOBUF_WIPE_REUSE\tidem, and add to buf_reuse list\n * When doing all but the first one on the current buffer, the caller should\n * get a new buffer very soon!\n *\n * The 'bufhidden' option can force freeing and deleting.\n *\n * When \"abort_if_last\" is TRUE then do not close the buffer if autocommands\n * cause there to be only one window with this buffer.  e.g. when \":quit\" is\n * supposed to close the window but autocommands close all other windows.\n *\n * When \"ignore_abort\" is TRUE don't abort even when aborting() returns TRUE.\n *\n * Return TRUE when we got to the end and b_nwindows was decremented.\n */\n    int\nclose_buffer(\n    win_T\t*win,\t\t// if not NULL, set b_last_cursor\n    buf_T\t*buf,\n    int\t\taction,\n    int\t\tabort_if_last,\n    int\t\tignore_abort)\n{\n    int\t\tis_curbuf;\n    int\t\tnwindows;\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n    int\t\tunload_buf = (action != 0);\n    int\t\twipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n    int\t\tdel_buf = (action == DOBUF_DEL || wipe_buf);\n\n    CHECK_CURBUF;\n\n    // Force unloading or deleting when 'bufhidden' says so.\n    // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n    // \"hide\" (otherwise we could never free or delete a buffer).\n    if (buf->b_p_bh[0] == 'd')\t\t// 'bufhidden' == \"delete\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'w')\t// 'bufhidden' == \"wipe\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n\twipe_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'u')\t// 'bufhidden' == \"unload\"\n\tunload_buf = TRUE;\n\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))\n    {\n\tCHECK_CURBUF;\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (wipe_buf || unload_buf)\n\t    {\n\t\tif (!can_unload_buffer(buf))\n\t\t    return FALSE;\n\n\t\t// Wiping out or unloading a terminal buffer kills the job.\n\t\tfree_terminal(buf);\n\t    }\n\t    else\n\t    {\n\t\t// The job keeps running, hide the buffer.\n\t\tdel_buf = FALSE;\n\t\tunload_buf = FALSE;\n\t    }\n\t}\n\telse if (buf->b_p_bh[0] == 'h' && !del_buf)\n\t{\n\t    // Hide a terminal buffer.\n\t    unload_buf = FALSE;\n\t}\n\telse\n\t{\n\t    // A terminal buffer is wiped out if the job has finished.\n\t    del_buf = TRUE;\n\t    unload_buf = TRUE;\n\t    wipe_buf = TRUE;\n\t}\n\tCHECK_CURBUF;\n    }\n#endif\n\n    // Disallow deleting the buffer when it is locked (already being closed or\n    // halfway a command that relies on it). Unloading is allowed.\n    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))\n\treturn FALSE;\n\n    // check no autocommands closed the window\n    if (win != NULL && win_valid_any_tab(win))\n    {\n\t// Set b_last_cursor when closing the last window for the buffer.\n\t// Remember the last cursor position and window options of the buffer.\n\t// This used to be only for the current window, but then options like\n\t// 'foldmethod' may be lost with a \":only\" command.\n\tif (buf->b_nwindows == 1)\n\t    set_last_cursor(win);\n\tbuflist_setfpos(buf, win,\n\t\t    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n\t\t    win->w_cursor.col, TRUE);\n    }\n\n    set_bufref(&bufref, buf);\n\n    // When the buffer is no longer in a window, trigger BufWinLeave\n    if (buf->b_nwindows == 1)\n    {\n\t++buf->b_locked;\n\t++buf->b_locked_split;\n\tif (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t{\n\t    // Autocommands deleted the buffer.\naucmd_abort:\n\t    emsg(_(e_autocommands_caused_command_to_abort));\n\t    return FALSE;\n\t}\n\t--buf->b_locked;\n\t--buf->b_locked_split;\n\tif (abort_if_last && one_window())\n\t    // Autocommands made this the only window.\n\t    goto aucmd_abort;\n\n\t// When the buffer becomes hidden, but is not unloaded, trigger\n\t// BufHidden\n\tif (!unload_buf)\n\t{\n\t    ++buf->b_locked;\n\t    ++buf->b_locked_split;\n\t    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\t// Autocommands deleted the buffer.\n\t\tgoto aucmd_abort;\n\t    --buf->b_locked;\n\t    --buf->b_locked_split;\n\t    if (abort_if_last && one_window())\n\t\t// Autocommands made this the only window.\n\t\tgoto aucmd_abort;\n\t}\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (!ignore_abort && aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n    nwindows = buf->b_nwindows;\n\n    // decrease the link count from windows (unless not in any window)\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n#ifdef FEAT_DIFF\n    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)\n\tdiff_buf_delete(buf);\t// Clear 'diff' for hidden buffer.\n#endif\n\n    // Return when a window is displaying the buffer or when it's not\n    // unloaded.\n    if (buf->b_nwindows > 0 || !unload_buf)\n\treturn FALSE;\n\n    // Always remove the buffer when there is no file name.\n    if (buf->b_ffname == NULL)\n\tdel_buf = TRUE;\n\n    // When closing the current buffer stop Visual mode before freeing\n    // anything.\n    if (buf == curbuf && VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Free all things allocated for this buffer.\n    // Also calls the \"BufDelete\" autocommands when del_buf is TRUE.\n    //\n    // Remember if we are closing the current buffer.  Restore the number of\n    // windows, so that autocommands in buf_freeall() don't get confused.\n    is_curbuf = (buf == curbuf);\n    buf->b_nwindows = nwindows;\n\n    buf_freeall(buf, (del_buf ? BFA_DEL : 0)\n\t\t   + (wipe_buf ? BFA_WIPE : 0)\n\t\t   + (ignore_abort ? BFA_IGNORE_ABORT : 0));\n\n    // Autocommands may have deleted the buffer.\n    if (!bufref_valid(&bufref))\n\treturn FALSE;\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if (!ignore_abort && aborting())\n\treturn FALSE;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause the previous curbuf to be deleted unexpectedly.  But\n    // in some cases it's OK to delete the curbuf, because a new one is\n    // obtained anyway.  Therefore only return if curbuf changed to the\n    // deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn FALSE;\n\n    if (win_valid_any_tab(win) && win->w_buffer == buf)\n\twin->w_buffer = NULL;  // make sure we don't use the buffer now\n\n    // Autocommands may have opened or closed windows for this buffer.\n    // Decrement the count for the close we do here.\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n    /*\n     * Remove the buffer from the list.\n     */\n    if (wipe_buf)\n    {\n\t// Do not wipe out the buffer if it is used in a window.\n\tif (buf->b_nwindows > 0)\n\t    return FALSE;\n\n\tif (action == DOBUF_WIPE_REUSE)\n\t{\n\t    // we can re-use this buffer number, store it\n\t    if (buf_reuse.ga_itemsize == 0)\n\t\tga_init2(&buf_reuse, sizeof(int), 50);\n\t    if (ga_grow(&buf_reuse, 1) == OK)\n\t\t((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;\n\t}\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf->b_prev == NULL)\n\t    firstbuf = buf->b_next;\n\telse\n\t    buf->b_prev->b_next = buf->b_next;\n\tif (buf->b_next == NULL)\n\t    lastbuf = buf->b_prev;\n\telse\n\t    buf->b_next->b_prev = buf->b_prev;\n\tfree_buffer(buf);\n    }\n    else\n    {\n\tif (del_buf)\n\t{\n\t    // Free all internal variables and reset option values, to make\n\t    // \":bdel\" compatible with Vim 5.7.\n\t    free_buffer_stuff(buf, TRUE);\n\n\t    // Make it look like a new buffer.\n\t    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n\t    // Init the options when loaded again.\n\t    buf->b_p_initialized = FALSE;\n\t}\n\tbuf_clear_file(buf);\n\tif (del_buf)\n\t    buf->b_p_bl = FALSE;\n    }\n    // NOTE: at this point \"curbuf\" may be invalid!\n    return TRUE;\n}\n\n/*\n * Make buffer not contain a file.\n */\n    void\nbuf_clear_file(buf_T *buf)\n{\n    buf->b_ml.ml_line_count = 1;\n    unchanged(buf, TRUE, TRUE);\n    buf->b_shortname = FALSE;\n    buf->b_p_eol = TRUE;\n    buf->b_start_eol = TRUE;\n    buf->b_p_bomb = FALSE;\n    buf->b_start_bomb = FALSE;\n    buf->b_ml.ml_mfp = NULL;\n    buf->b_ml.ml_flags = ML_EMPTY;\t\t// empty buffer\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_deleted_all_lines(buf);\n#endif\n}\n\n/*\n * buf_freeall() - free all things allocated for a buffer that are related to\n * the file.  Careful: get here with \"curwin\" NULL when exiting.\n * flags:\n * BFA_DEL\t     buffer is going to be deleted\n * BFA_WIPE\t     buffer is going to be wiped out\n * BFA_KEEP_UNDO     do not free undo information\n * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE\n */\n    void\nbuf_freeall(buf_T *buf, int flags)\n{\n    int\t\tis_curbuf = (buf == curbuf);\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n\n    // Make sure the buffer isn't closed by autocommands.\n    ++buf->b_locked;\n    ++buf->b_locked_split;\n    set_bufref(&bufref, buf);\n    if (buf->b_ml.ml_mfp != NULL)\n    {\n\tif (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if ((flags & BFA_DEL) && buf->b_p_bl)\n    {\n\tif (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t   FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if (flags & BFA_WIPE)\n    {\n\tif (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    --buf->b_locked;\n    --buf->b_locked_split;\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if ((flags & BFA_IGNORE_ABORT) == 0 && aborting())\n\treturn;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause curbuf to be deleted unexpectedly.  But in some cases\n    // it's OK to delete the curbuf, because a new one is obtained anyway.\n    // Therefore only return if curbuf changed to the deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn;\n#ifdef FEAT_DIFF\n    diff_buf_delete(buf);\t    // Can't use 'diff' for unloaded buffer.\n#endif\n#ifdef FEAT_SYN_HL\n    // Remove any ownsyntax, unless exiting.\n    if (curwin != NULL && curwin->w_buffer == buf)\n\treset_synblock(curwin);\n#endif\n\n#ifdef FEAT_FOLDING\n    // No folds in an empty buffer.\n    {\n\twin_T\t\t*win;\n\ttabpage_T\t*tp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t    if (win->w_buffer == buf)\n\t\tclearFolding(win);\n    }\n#endif\n\n#ifdef FEAT_TCL\n    tcl_buffer_free(buf);\n#endif\n    ml_close(buf, TRUE);\t    // close and delete the memline/memfile\n    buf->b_ml.ml_line_count = 0;    // no lines in buffer\n    if ((flags & BFA_KEEP_UNDO) == 0)\n    {\n\tu_blockfree(buf);\t    // free the memory allocated for undo\n\tu_clearall(buf);\t    // reset all undo information\n    }\n#ifdef FEAT_SYN_HL\n    syntax_clear(&buf->b_s);\t    // reset syntax info\n#endif\n#ifdef FEAT_PROP_POPUP\n    clear_buf_prop_types(buf);\n#endif\n    buf->b_flags &= ~BF_READERR;    // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\n    static void\nfree_buffer(buf_T *buf)\n{\n    ++buf_free_count;\n    free_buffer_stuff(buf, TRUE);\n#ifdef FEAT_EVAL\n    // b:changedtick uses an item in buf_T, remove it now\n    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di);\n    unref_var_dict(buf->b_vars);\n    remove_listeners(buf);\n#endif\n#ifdef FEAT_LUA\n    lua_buffer_free(buf);\n#endif\n#ifdef FEAT_MZSCHEME\n    mzscheme_buffer_free(buf);\n#endif\n#ifdef FEAT_PERL\n    perl_buf_free(buf);\n#endif\n#ifdef FEAT_PYTHON\n    python_buffer_free(buf);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_buffer_free(buf);\n#endif\n#ifdef FEAT_RUBY\n    ruby_buffer_free(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    channel_buffer_free(buf);\n#endif\n#ifdef FEAT_TERMINAL\n    free_terminal(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    vim_free(buf->b_prompt_text);\n    free_callback(&buf->b_prompt_callback);\n    free_callback(&buf->b_prompt_interrupt);\n#endif\n\n    buf_hashtab_remove(buf);\n\n    aubuflocal_remove(buf);\n\n    if (autocmd_busy)\n    {\n\t// Do not free the buffer structure while autocommands are executing,\n\t// it's still needed. Free it when autocmd_busy is reset.\n\tbuf->b_next = au_pending_free_buf;\n\tau_pending_free_buf = buf;\n    }\n    else\n    {\n\tvim_free(buf);\n\tif (curbuf == buf)\n\t    curbuf = NULL;  // make clear it's not to be used\n    }\n}\n\n/*\n * Initializes b:changedtick.\n */\n    static void\ninit_changedtick(buf_T *buf)\n{\n    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;\n\n    di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;\n    di->di_tv.v_type = VAR_NUMBER;\n    di->di_tv.v_lock = VAR_FIXED;\n    di->di_tv.vval.v_number = 0;\n\n#ifdef FEAT_EVAL\n    STRCPY(buf->b_ct_di.di_key, \"changedtick\");\n    (void)dict_add(buf->b_vars, di);\n#endif\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\n    static void\nclear_wininfo(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    while (buf->b_wininfo != NULL)\n    {\n\twip = buf->b_wininfo;\n\tbuf->b_wininfo = wip->wi_next;\n\tfree_wininfo(wip);\n    }\n}\n\n/*\n * Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n */\n    static void\nfree_buffer_stuff(\n    buf_T\t*buf,\n    int\t\tfree_options)\t\t// free options as well\n{\n    if (free_options)\n    {\n\tclear_wininfo(buf);\t\t// including window-local options\n\tfree_buf_options(buf, TRUE);\n#ifdef FEAT_SPELL\n\tga_clear(&buf->b_s.b_langp);\n#endif\n    }\n#ifdef FEAT_EVAL\n    {\n\tvarnumber_T tick = CHANGEDTICK(buf);\n\n\tvars_clear(&buf->b_vars->dv_hashtab); // free all buffer variables\n\thash_init(&buf->b_vars->dv_hashtab);\n\tinit_changedtick(buf);\n\tCHANGEDTICK(buf) = tick;\n\tremove_listeners(buf);\n    }\n#endif\n    uc_clear(&buf->b_ucmds);\t\t// clear local user commands\n#ifdef FEAT_SIGNS\n    buf_delete_signs(buf, (char_u *)\"*\");\t// delete any signs\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_file_killed(buf);\n#endif\n#ifdef FEAT_PROP_POPUP\n    ga_clear_strings(&buf->b_textprop_text);\n#endif\n    map_clear_mode(buf, MAP_ALL_MODES, TRUE, FALSE);  // clear local mappings\n    map_clear_mode(buf, MAP_ALL_MODES, TRUE, TRUE);   // clear local abbrevs\n    VIM_CLEAR(buf->b_start_fenc);\n}\n\n/*\n * Free one wininfo_T.\n */\n    void\nfree_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\n    void\ngoto_buffer(\n    exarg_T\t*eap,\n    int\t\tstart,\n    int\t\tdir,\n    int\t\tcount)\n{\n    bufref_T\told_curbuf;\n    int\t\tsave_sea = swap_exists_action;\n\n    set_bufref(&old_curbuf, curbuf);\n\n    if (swap_exists_action == SEA_NONE)\n\tswap_exists_action = SEA_DIALOG;\n    (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n\t\t\t\t\t     start, dir, count, eap->forceit);\n    if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a window.\n\tenter_cleanup(&cs);\n#endif\n\n\t// Quitting means closing the split window, nothing else.\n\twin_close(curwin, TRUE);\n\tswap_exists_action = save_sea;\n\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else\n\thandle_swap_exists(&old_curbuf);\n}\n\n/*\n * Handle the situation of swap_exists_action being set.\n * It is allowed for \"old_curbuf\" to be NULL or invalid.\n */\n    void\nhandle_swap_exists(bufref_T *old_curbuf)\n{\n#if defined(FEAT_EVAL)\n    cleanup_T\tcs;\n#endif\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    buf_T\t*buf;\n\n    if (swap_exists_action == SEA_QUIT)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Quit at ATTENTION prompt.  Go back to previous\n\t// buffer.  If that buffer is gone or the same as the current one,\n\t// open a new, empty buffer.\n\tswap_exists_action = SEA_NONE;\t// don't want it again\n\tswap_exists_did_quit = TRUE;\n\tclose_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE, FALSE);\n\tif (old_curbuf == NULL || !bufref_valid(old_curbuf)\n\t\t\t\t\t      || old_curbuf->br_buf == curbuf)\n\t{\n\t    // Block autocommands here because curwin->w_buffer is NULL.\n\t    block_autocmds();\n\t    buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n\t    unblock_autocmds();\n\t}\n\telse\n\t    buf = old_curbuf->br_buf;\n\tif (buf != NULL)\n\t{\n\t    int old_msg_silent = msg_silent;\n\n\t    if (shortmess(SHM_FILEINFO))\n\t\tmsg_silent = 1;  // prevent fileinfo message\n\t    enter_buffer(buf);\n\t    // restore msg_silent, so that the command line will be shown\n\t    msg_silent = old_msg_silent;\n\n#ifdef FEAT_SYN_HL\n\t    if (old_tw != curbuf->b_p_tw)\n\t\tcheck_colorcolumn(curwin);\n#endif\n\t}\n\t// If \"old_curbuf\" is NULL we are in big trouble here...\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else if (swap_exists_action == SEA_RECOVER)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Recover at ATTENTION prompt.\n\tmsg_scroll = TRUE;\n\tml_recover(FALSE);\n\tmsg_puts(\"\\n\");\t// don't overwrite the last message\n\tcmdline_row = msg_row;\n\tdo_modelines(0);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    swap_exists_action = SEA_NONE;\n}\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\n    static int\nempty_curbuf(\n    int close_others,\n    int forceit,\n    int action)\n{\n    int\t    retval;\n    buf_T   *buf = curbuf;\n    bufref_T bufref;\n\n    if (action == DOBUF_UNLOAD)\n    {\n\temsg(_(e_cannot_unload_last_buffer));\n\treturn FAIL;\n    }\n\n    set_bufref(&bufref, buf);\n    if (close_others)\n\t// Close any other windows on this buffer, then make it empty.\n\tclose_windows(buf, TRUE);\n\n    setpcmark();\n    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n\t\t\t\t\t  forceit ? ECMD_FORCEIT : 0, curwin);\n\n    // do_ecmd() may create a new buffer, then we have to delete\n    // the old one.  But do_ecmd() may have done that already, check\n    // if the buffer still exists.\n    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)\n\tclose_buffer(NULL, buf, action, FALSE, FALSE);\n    if (!close_others)\n\tneed_fileinfo = FALSE;\n    return retval;\n}\n\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n * action == DOBUF_WIPE_REUSE idem, and add number to \"buf_reuse\"\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\n    static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf) && !bt_terminal(buf))\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl || bt_quickfix(buf))\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n\t\t\t    && !bt_quickfix(buf))\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf && !bt_quickfix(buf))\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}\n\n    int\ndo_buffer(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tforceit)\t// TRUE when using !\n{\n    return do_buffer_ext(action, start, dir, count,\n\t\t\t\t\t\t  forceit ? DOBUF_FORCEIT : 0);\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\n    char *\ndo_bufdel(\n    int\t\tcommand,\n    char_u\t*arg,\t\t// pointer to extra arguments\n    int\t\taddr_count,\n    int\t\tstart_bnr,\t// first buffer number in a range\n    int\t\tend_bnr,\t// buffer nr or last buffer nr in a range\n    int\t\tforceit)\n{\n    int\t\tdo_current = 0;\t// delete current buffer?\n    int\t\tdeleted = 0;\t// number of buffers deleted\n    char\t*errormsg = NULL; // return value\n    int\t\tbnr;\t\t// buffer number\n    char_u\t*p;\n\n    if (addr_count == 0)\n    {\n\t(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n    }\n    else\n    {\n\tif (addr_count == 2)\n\t{\n\t    if (*arg)\t\t// both range and argument is not allowed\n\t\treturn ex_errmsg(e_trailing_characters_str, arg);\n\t    bnr = start_bnr;\n\t}\n\telse\t// addr_count == 1\n\t    bnr = end_bnr;\n\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    // Delete the current buffer last, otherwise when the\n\t    // current buffer is deleted, the next buffer becomes\n\t    // the current one and will be loaded, which may then\n\t    // also be deleted, etc.\n\t    if (bnr == curbuf->b_fnum)\n\t\tdo_current = bnr;\n\t    else if (do_buffer_ext(command, DOBUF_FIRST, FORWARD, bnr,\n\t\t\t  DOBUF_NOPOPUP | (forceit ? DOBUF_FORCEIT : 0)) == OK)\n\t\t++deleted;\n\n\t    // find next buffer number to delete/unload\n\t    if (addr_count == 2)\n\t    {\n\t\tif (++bnr > end_bnr)\n\t\t    break;\n\t    }\n\t    else    // addr_count == 1\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (*arg == NUL)\n\t\t    break;\n\t\tif (!VIM_ISDIGIT(*arg))\n\t\t{\n\t\t    p = skiptowhite_esc(arg);\n\t\t    bnr = buflist_findpat(arg, p,\n\t\t\t  command == DOBUF_WIPE || command == DOBUF_WIPE_REUSE,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t    if (bnr < 0)\t    // failed\n\t\t\tbreak;\n\t\t    arg = p;\n\t\t}\n\t\telse\n\t\t    bnr = getdigits(&arg);\n\t    }\n\t}\n\tif (!got_int && do_current && do_buffer(command, DOBUF_FIRST,\n\t\t\t\t\t  FORWARD, do_current, forceit) == OK)\n\t    ++deleted;\n\n\tif (deleted == 0)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_unloaded));\n\t    else if (command == DOBUF_DEL)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_deleted));\n\t    else\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_wiped_out));\n\t    errormsg = (char *)IObuff;\n\t}\n\telse if (deleted >= p_report)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tsmsg(NGETTEXT(\"%d buffer unloaded\",\n\t\t\t    \"%d buffers unloaded\", deleted), deleted);\n\t    else if (command == DOBUF_DEL)\n\t\tsmsg(NGETTEXT(\"%d buffer deleted\",\n\t\t\t    \"%d buffers deleted\", deleted), deleted);\n\t    else\n\t\tsmsg(NGETTEXT(\"%d buffer wiped out\",\n\t\t\t    \"%d buffers wiped out\", deleted), deleted);\n\t}\n    }\n\n\n    return errormsg;\n}\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n * DOBUF_WIPE_REUSE wipe it out and add to \"buf_reuse\"\n */\n    void\nset_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n    int\t\tvalid;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t    && ((State & MODE_INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    valid = buf_valid(buf);\n    if ((valid && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\t// If the buffer is not valid but curwin->w_buffer is NULL we must\n\t// enter some buffer.  Using the last one is hopefully OK.\n\tif (!valid)\n\t    enter_buffer(lastbuf);\n\telse\n\t    enter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\n    static void\nenter_buffer(buf_T *buf)\n{\n    // when closing the current buffer stop Visual mode\n    if (VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Get the buffer in the current window.\n    curwin->w_buffer = buf;\n    curbuf = buf;\n    ++curbuf->b_nwindows;\n\n    // Copy buffer and window local option values.  Not for a help buffer.\n    buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n    if (!buf->b_help)\n\tget_winopts(buf);\n#ifdef FEAT_FOLDING\n    else\n\t// Remove all folds in the window.\n\tclearFolding(curwin);\n    foldUpdateAll(curwin);\t// update folds (later).\n#endif\n\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff)\n\tdiff_buf_add(curbuf);\n#endif\n\n#ifdef FEAT_SYN_HL\n    curwin->w_s = &(curbuf->b_s);\n#endif\n\n    // Cursor on first line by default.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n    curwin->w_topline_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,\n\t\t\t\t\t      curbuf->b_last_cursor.col, TRUE);\n\n    // Make sure the buffer is loaded.\n    if (curbuf->b_ml.ml_mfp == NULL)\t// need to load the file\n    {\n\t// If there is no filetype, allow for detecting one.  Esp. useful for\n\t// \":ball\" used in an autocommand.  If there already is a filetype we\n\t// might prefer to keep it.\n\tif (*curbuf->b_p_ft == NUL)\n\t    did_filetype = FALSE;\n\n\topen_buffer(FALSE, NULL, 0);\n    }\n    else\n    {\n\tif (!msg_silent && !shortmess(SHM_FILEINFO))\n\t    need_fileinfo = TRUE;\t// display file info after redraw\n\n\t// check if file changed\n\t(void)buf_check_timestamp(curbuf, FALSE);\n\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n\tapply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    // If autocommands did not change the cursor position, restore cursor lnum\n    // and possibly cursor col.\n    if (curwin->w_cursor.lnum == 1 && inindent(0))\n\tbuflist_getfpos();\n\n    check_arg_idx(curwin);\t\t// check for valid arg_idx\n    maketitle();\n\t// when autocmds didn't change it\n    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)\n\tscroll_cursor_halfway(FALSE);\t// redisplay at correct position\n\n#ifdef FEAT_NETBEANS_INTG\n    // Send fileOpened event because we've changed buffers.\n    netbeans_file_activated(curbuf);\n#endif\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n#ifdef FEAT_SPELL\n    // May need to set the spell language.  Can only do this after the buffer\n    // has been properly setup.\n    if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    redraw_later(UPD_NOT_VALID);\n}\n\n#if defined(FEAT_AUTOCHDIR) || defined(PROTO)\n/*\n * Change to the directory of the current buffer.\n * Don't do this while still starting up.\n */\n    void\ndo_autochdir(void)\n{\n    if ((starting == 0 || test_autochdir)\n\t    && curbuf->b_ffname != NULL\n\t    && vim_chdirfile(curbuf->b_ffname, \"auto\") == OK)\n    {\n\tshorten_fnames(TRUE);\n\tlast_chdir_reason = \"autochdir\";\n    }\n}\n#endif\n\n    void\nno_write_message(void)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(curbuf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change_add_bang_to_override));\n}\n\n    void\nno_write_message_nobang(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change));\n}\n\n/*\n * functions for dealing with the buffer list\n */\n\n/*\n * Return TRUE if the current buffer is empty, unnamed, unmodified and used in\n * only one window.  That means it can be re-used.\n */\n    int\ncurbuf_reusable(void)\n{\n    return (curbuf != NULL\n\t&& curbuf->b_ffname == NULL\n\t&& curbuf->b_nwindows <= 1\n\t&& (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY())\n\t&& !bt_quickfix(curbuf)\n\t&& !curbufIsChanged());\n}\n\n/*\n * Add a file name to the buffer list.  Return a pointer to the buffer.\n * If the same file name already exists return a pointer to that buffer.\n * If it does not exist, or if fname == NULL, a new entry is created.\n * If (flags & BLN_CURBUF) is TRUE, may use current buffer.\n * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.\n * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.\n * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.\n * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer\n *\t\t\t\t    if the buffer already exists.\n * If (flags & BLN_REUSE) is TRUE, may use buffer number from \"buf_reuse\".\n * This is the ONLY way to create a new buffer.\n */\n    buf_T *\nbuflist_new(\n    char_u\t*ffname_arg,\t// full path of fname or relative\n    char_u\t*sfname_arg,\t// short fname or NULL\n    linenr_T\tlnum,\t\t// preferred cursor line\n    int\t\tflags)\t\t// BLN_ defines\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*buf;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (top_file_num == 1)\n\thash_init(&buf_hashtab);\n\n    fname_expand(curbuf, &ffname, &sfname);\t// will allocate ffname\n\n    /*\n     * If the file name already exists in the list, update the entry.\n     */\n#ifdef UNIX\n    // On Unix we can use inode numbers when the file exists.  Works better\n    // for hard links.\n    if (sfname == NULL || mch_stat((char *)sfname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n#endif\n    if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW)) && (buf =\n#ifdef UNIX\n\t\tbuflist_findname_stat(ffname, &st)\n#else\n\t\tbuflist_findname(ffname)\n#endif\n\t\t) != NULL)\n    {\n\tvim_free(ffname);\n\tif (lnum != 0)\n\t    buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n\t\t\t\t\t\t      lnum, (colnr_T)0, FALSE);\n\n\tif ((flags & BLN_NOOPT) == 0)\n\t    // copy the options now, if 'cpo' doesn't have 's' and not done\n\t    // already\n\t    buf_copy_options(buf, 0);\n\n\tif ((flags & BLN_LISTED) && !buf->b_p_bl)\n\t{\n\t    bufref_T bufref;\n\n\t    buf->b_p_bl = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    if (!(flags & BLN_DUMMY))\n\t    {\n\t\tif (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t\t&& !bufref_valid(&bufref))\n\t\t    return NULL;\n\t    }\n\t}\n\treturn buf;\n    }\n\n    /*\n     * If the current buffer has no name and no contents, use the current\n     * buffer.\tOtherwise: Need to allocate a new buffer structure.\n     *\n     * This is the ONLY place where a new buffer structure is allocated!\n     * (A spell file buffer is allocated in spell.c, but that's not a normal\n     * buffer.)\n     */\n    buf = NULL;\n    if ((flags & BLN_CURBUF) && curbuf_reusable())\n    {\n\tbuf = curbuf;\n\t// It's like this buffer is deleted.  Watch out for autocommands that\n\t// change curbuf!  If that happens, allocate a new buffer anyway.\n\tbuf_freeall(buf, BFA_WIPE | BFA_DEL);\n\tif (buf != curbuf)   // autocommands deleted the buffer!\n\t    return NULL;\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#endif\n    }\n    if (buf != curbuf || curbuf == NULL)\n    {\n\tbuf = ALLOC_CLEAR_ONE(buf_T);\n\tif (buf == NULL)\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#ifdef FEAT_EVAL\n\t// init b: variables\n\tbuf->b_vars = dict_alloc_id(aid_newbuf_bvars);\n\tif (buf->b_vars == NULL)\n\t{\n\t    vim_free(ffname);\n\t    vim_free(buf);\n\t    return NULL;\n\t}\n\tinit_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n#endif\n\tinit_changedtick(buf);\n    }\n\n    if (ffname != NULL)\n    {\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = vim_strsave(sfname);\n    }\n\n    clear_wininfo(buf);\n    buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);\n\n    if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))\n\t    || buf->b_wininfo == NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf != curbuf)\n\t    free_buffer(buf);\n\treturn NULL;\n    }\n\n    if (buf == curbuf)\n    {\n\tfree_buffer_stuff(buf, FALSE);\t// delete local variables et al.\n\n\t// Init the options.\n\tbuf->b_p_initialized = FALSE;\n\tbuf_copy_options(buf, BCO_ENTER);\n\n#ifdef FEAT_KEYMAP\n\t// need to reload lmaps and set b:keymap_name\n\tcurbuf->b_kmap_state |= KEYMAP_INIT;\n#endif\n    }\n    else\n    {\n\t// put the new buffer at the end of the buffer list\n\tbuf->b_next = NULL;\n\tif (firstbuf == NULL)\t\t// buffer list is empty\n\t{\n\t    buf->b_prev = NULL;\n\t    firstbuf = buf;\n\t}\n\telse\t\t\t\t// append new buffer at end of list\n\t{\n\t    lastbuf->b_next = buf;\n\t    buf->b_prev = lastbuf;\n\t}\n\tlastbuf = buf;\n\n\tif ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)\n\t{\n\t    // Recycle a previously used buffer number.  Used for buffers which\n\t    // are normally hidden, e.g. in a popup window.  Avoids that the\n\t    // buffer number grows rapidly.\n\t    --buf_reuse.ga_len;\n\t    buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];\n\n\t    // Move buffer to the right place in the buffer list.\n\t    while (buf->b_prev != NULL && buf->b_fnum < buf->b_prev->b_fnum)\n\t    {\n\t\tbuf_T\t*prev = buf->b_prev;\n\n\t\tprev->b_next = buf->b_next;\n\t\tif (prev->b_next != NULL)\n\t\t    prev->b_next->b_prev = prev;\n\t\tbuf->b_next = prev;\n\t\tbuf->b_prev = prev->b_prev;\n\t\tif (buf->b_prev != NULL)\n\t\t    buf->b_prev->b_next = buf;\n\t\tprev->b_prev = buf;\n\t\tif (lastbuf == buf)\n\t\t    lastbuf = prev;\n\t\tif (firstbuf == prev)\n\t\t    firstbuf = buf;\n\t    }\n\t}\n\telse\n\t    buf->b_fnum = top_file_num++;\n\tif (top_file_num < 0)\t\t// wrap around (may cause duplicates)\n\t{\n\t    emsg(_(\"W14: Warning: List of file names overflow\"));\n\t    if (emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(3001L, TRUE);\t// make sure it is noticed\n\t    }\n\t    top_file_num = 1;\n\t}\n\tbuf_hashtab_add(buf);\n\n\t// Always copy the options from the current buffer.\n\tbuf_copy_options(buf, BCO_ALWAYS);\n    }\n\n    buf->b_wininfo->wi_fpos.lnum = lnum;\n    buf->b_wininfo->wi_win = curwin;\n\n#ifdef FEAT_SYN_HL\n    hash_init(&buf->b_s.b_keywtab);\n    hash_init(&buf->b_s.b_keywtab_ic);\n#endif\n\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n    buf->b_u_synced = TRUE;\n    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n    if (flags & BLN_DUMMY)\n\tbuf->b_flags |= BF_DUMMY;\n    buf_clear_file(buf);\n    clrallmarks(buf);\t\t\t// clear marks\n    fmarks_check_names(buf);\t\t// check file marks for this file\n    buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;\t// init 'buflisted'\n    if (!(flags & BLN_DUMMY))\n    {\n\tbufref_T bufref;\n\n\t// Tricky: these autocommands may change the buffer list.  They could\n\t// also split the window with re-using the one empty buffer. This may\n\t// result in unexpectedly losing the empty buffer.\n\tset_bufref(&bufref, buf);\n\tif (apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    return NULL;\n\tif (flags & BLN_LISTED)\n\t{\n\t    if (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\treturn NULL;\n\t}\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n    }\n\n    return buf;\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is TRUE also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\n    void\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    VIM_CLEAR(buf->b_p_vsts_array);\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n    clear_string_option(&buf->b_p_sua);\n    clear_string_option(&buf->b_p_ft);\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n    clear_string_option(&buf->b_p_cinsd);\n    clear_string_option(&buf->b_p_cinw);\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n    clear_string_option(&buf->b_p_qe);\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    clear_string_option(&buf->b_p_lw);\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n\n/*\n * Get alternate file \"n\".\n * Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n *\tAlso set cursor column to altfpos.col if 'startofline' is not set.\n * if (options & GETF_SETMARK) call setpcmark()\n * if (options & GETF_ALT) we are jumping to an alternate file.\n * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n *\n * Return FAIL for failure, OK for success.\n */\n    int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_or_buf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}\n\n/*\n * go to the last know line number for the current buffer\n */\n    static void\nbuflist_getfpos(void)\n{\n    pos_T\t*fpos;\n\n    fpos = buflist_findfpos(curbuf);\n\n    curwin->w_cursor.lnum = fpos->lnum;\n    check_cursor_lnum();\n\n    if (p_sol)\n\tcurwin->w_cursor.col = 0;\n    else\n    {\n\tcurwin->w_cursor.col = fpos->col;\n\tcheck_cursor_col();\n\tcurwin->w_cursor.coladd = 0;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname_exp(char_u *fname)\n{\n    char_u\t*ffname;\n    buf_T\t*buf = NULL;\n\n    // First make the name into a full path name\n    ffname = FullName_save(fname,\n#ifdef UNIX\n\t    TRUE\t    // force expansion, get rid of symbolic links\n#else\n\t    FALSE\n#endif\n\t    );\n    if (ffname != NULL)\n    {\n\tbuf = buflist_findname(ffname);\n\tvim_free(ffname);\n    }\n    return buf;\n}\n#endif\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname(char_u *ffname)\n{\n#ifdef UNIX\n    stat_T\tst;\n\n    if (mch_stat((char *)ffname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n    return buflist_findname_stat(ffname, &st);\n}\n\n/*\n * Same as buflist_findname(), but pass the stat structure to avoid getting it\n * twice for the same file.\n * Returns NULL if not found.\n */\n    static buf_T *\nbuflist_findname_stat(\n    char_u\t*ffname,\n    stat_T\t*stp)\n{\n#endif\n    buf_T\t*buf;\n\n    // Start at the last buffer, expect to find a match sooner.\n    FOR_ALL_BUFS_FROM_LAST(buf)\n\tif ((buf->b_flags & BF_DUMMY) == 0 && !otherfile_buf(buf, ffname\n#ifdef UNIX\n\t\t    , stp\n#endif\n\t\t    ))\n\t    return buf;\n    return NULL;\n}\n\n/*\n * Find file in buffer list by a regexp pattern.\n * Return fnum of the found buffer.\n * Return < 0 for error.\n */\n    int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}\n\n#ifdef FEAT_VIMINFO\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n#endif\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n\n/*\n * Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n */\n    static char_u *\nbuflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL && rmp->regprog != NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n\n/*\n * Try matching the regexp in \"rmp->regprog\" with file name \"name\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n * Return \"name\" when there is a match, NULL when not.\n */\n    static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    // extra check for valid arguments\n    if (name != NULL && rmp->regprog != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n\n/*\n * Find a file in the buffer list by buffer number.\n */\n    buf_T *\nbuflist_findnr(int nr)\n{\n    char_u\tkey[VIM_SIZEOF_INT * 2 + 1];\n    hashitem_T\t*hi;\n\n    if (nr == 0)\n\tnr = curwin->w_alt_fnum;\n    sprintf((char *)key, \"%x\", nr);\n    hi = hash_find(&buf_hashtab, key);\n\n    if (!HASHITEM_EMPTY(hi))\n\treturn (buf_T *)(hi->hi_key\n\t\t\t     - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));\n    return NULL;\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\n    char_u *\nbuflist_nr2name(\n    int\t\tn,\n    int\t\tfullname,\n    int\t\thelptail)\t// for help buffers return tail only\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n\treturn NULL;\n    return home_replace_save(helptail ? buf : NULL,\n\t\t\t\t     fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/*\n * Set the \"lnum\" and \"col\" for the buffer \"buf\" and the current window.\n * When \"copy_options\" is TRUE save the local window option values.\n * When \"lnum\" is 0 only do the options.\n */\n    void\nbuflist_setfpos(\n    buf_T\t*buf,\n    win_T\t*win,\t\t// may be NULL when using :badd\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    int\t\tcopy_options)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == win)\n\t    break;\n    if (wip == NULL)\n    {\n\t// allocate a new entry\n\twip = ALLOC_CLEAR_ONE(wininfo_T);\n\tif (wip == NULL)\n\t    return;\n\twip->wi_win = win;\n\tif (lnum == 0)\t\t// set lnum even when it's 0\n\t    lnum = 1;\n    }\n    else\n    {\n\t// remove the entry from the list\n\tif (wip->wi_prev)\n\t    wip->wi_prev->wi_next = wip->wi_next;\n\telse\n\t    buf->b_wininfo = wip->wi_next;\n\tif (wip->wi_next)\n\t    wip->wi_next->wi_prev = wip->wi_prev;\n\tif (copy_options && wip->wi_optset)\n\t{\n\t    clear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\t    deleteFoldRecurse(&wip->wi_folds);\n#endif\n\t}\n    }\n    if (lnum != 0)\n    {\n\twip->wi_fpos.lnum = lnum;\n\twip->wi_fpos.col = col;\n    }\n    if (win != NULL)\n\twip->wi_changelistidx = win->w_changelistidx;\n    if (copy_options && win != NULL)\n    {\n\t// Save the window-specific option values.\n\tcopy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n#ifdef FEAT_FOLDING\n\twip->wi_fold_manual = win->w_fold_manual;\n\tcloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n#endif\n\twip->wi_optset = TRUE;\n    }\n\n    // insert the entry in front of the list\n    wip->wi_next = buf->b_wininfo;\n    buf->b_wininfo = wip;\n    wip->wi_prev = NULL;\n    if (wip->wi_next)\n\twip->wi_next->wi_prev = wip;\n}\n\n#ifdef FEAT_DIFF\n/*\n * Return TRUE when \"wip\" has 'diff' set and the diff is only for another tab\n * page.  That's because a diff is local to a tab page.\n */\n    static int\nwininfo_other_tab_diff(wininfo_T *wip)\n{\n    win_T\t*wp;\n\n    if (wip->wi_opt.wo_diff)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    // return FALSE when it's a window in the current tab page, thus\n\t    // the buffer was in diff mode here\n\t    if (wip->wi_win == wp)\n\t\treturn FALSE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Find info for the current window in buffer \"buf\".\n * If not found, return the info for the most recently used window.\n * When \"need_options\" is TRUE skip entries where wi_optset is FALSE.\n * When \"skip_diff_buffer\" is TRUE avoid windows with 'diff' set that is in\n * another tab page.\n * Returns NULL when there isn't any info.\n */\n    static wininfo_T *\nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\n    void\nget_winopts(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    clear_winopt(&curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n    clearFolding(curwin);\n#endif\n\n    wip = find_wininfo(buf, TRUE, TRUE);\n    if (wip != NULL && wip->wi_win != NULL\n\t    && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)\n    {\n\t// The buffer is currently displayed in the window: use the actual\n\t// option values instead of the saved (possibly outdated) values.\n\twin_T *wp = wip->wi_win;\n\n\tcopy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wp->w_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n#endif\n    }\n    else if (wip != NULL && wip->wi_optset)\n    {\n\t// the buffer was displayed in the current window earlier\n\tcopy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wip->wi_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n#endif\n    }\n    else\n\tcopy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n    if (wip != NULL)\n\tcurwin->w_changelistidx = wip->wi_changelistidx;\n\n#ifdef FEAT_FOLDING\n    // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n    if (p_fdls >= 0)\n\tcurwin->w_p_fdl = p_fdls;\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\n    pos_T *\nbuflist_findfpos(buf_T *buf)\n{\n    wininfo_T\t*wip;\n    static pos_T no_position = {1, 0, 0};\n\n    wip = find_wininfo(buf, FALSE, FALSE);\n    if (wip != NULL)\n\treturn &(wip->wi_fpos);\n    else\n\treturn &no_position;\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\n    linenr_T\nbuflist_findlnum(buf_T *buf)\n{\n    return buflist_findfpos(buf)->lnum;\n}\n\n/*\n * List all known file names (for :files and :buffers command).\n */\n    void\nbuflist_list(exarg_T *eap)\n{\n    buf_T\t*buf = firstbuf;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tro_char;\n    int\t\tchanged_char;\n#ifdef FEAT_TERMINAL\n    int\t\tjob_running;\n    int\t\tjob_none_open;\n#endif\n\n#ifdef FEAT_VIMINFO\n    garray_T\tbuflist;\n    buf_T\t**buflist_data = NULL, **p;\n\n    if (vim_strchr(eap->arg, 't'))\n    {\n\tga_init2(&buflist, sizeof(buf_T *), 50);\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (ga_grow(&buflist, 1) == OK)\n\t\t((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n\t}\n\n\tqsort(buflist.ga_data, (size_t)buflist.ga_len,\n\t\tsizeof(buf_T *), buf_compare);\n\n\tbuflist_data = (buf_T **)buflist.ga_data;\n\tbuf = *buflist_data;\n    }\n    p = buflist_data;\n\n    for (; buf != NULL && !got_int; buf = buflist_data != NULL\n\t    ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n\t    : buf->b_next)\n#else\n    for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next)\n#endif\n    {\n#ifdef FEAT_TERMINAL\n\tjob_running = term_job_running(buf->b_term);\n\tjob_none_open = term_none_open(buf->b_term);\n#endif\n\t// skip unlisted buffers, unless ! was used\n\tif ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))\n\t\t|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl)\n\t\t|| (vim_strchr(eap->arg, '+')\n\t\t\t&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n\t\t|| (vim_strchr(eap->arg, 'a')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n\t\t|| (vim_strchr(eap->arg, 'h')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n#ifdef FEAT_TERMINAL\n\t\t|| (vim_strchr(eap->arg, 'R')\n\t\t\t&& (!job_running || (job_running && job_none_open)))\n\t\t|| (vim_strchr(eap->arg, '?')\n\t\t\t&& (!job_running || (job_running && !job_none_open)))\n\t\t|| (vim_strchr(eap->arg, 'F')\n\t\t\t&& (job_running || buf->b_term == NULL))\n#endif\n\t\t|| (vim_strchr(eap->arg, '-') && buf->b_p_ma)\n\t\t|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro)\n\t\t|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n\t\t|| (vim_strchr(eap->arg, '%') && buf != curbuf)\n\t\t|| (vim_strchr(eap->arg, '#')\n\t\t      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))\n\t    continue;\n\tif (buf_spname(buf) != NULL)\n\t    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n\telse\n\t    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n\tif (message_filtered(NameBuff))\n\t    continue;\n\n\tchanged_char = (buf->b_flags & BF_READERR) ? 'x'\n\t\t\t\t\t     : (bufIsChanged(buf) ? '+' : ' ');\n#ifdef FEAT_TERMINAL\n\tif (job_running)\n\t{\n\t    if (job_none_open)\n\t\tro_char = '?';\n\t    else\n\t\tro_char = 'R';\n\t    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid\n\t\t\t\t // closing, but it's not actually changed.\n\t}\n\telse if (buf->b_term != NULL)\n\t    ro_char = 'F';\n\telse\n#endif\n\t    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');\n\n\tmsg_putchar('\\n');\n\tlen = vim_snprintf((char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n\t\tbuf->b_fnum,\n\t\tbuf->b_p_bl ? ' ' : 'u',\n\t\tbuf == curbuf ? '%' :\n\t\t\t(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n\t\tbuf->b_ml.ml_mfp == NULL ? ' ' :\n\t\t\t(buf->b_nwindows == 0 ? 'h' : 'a'),\n\t\tro_char,\n\t\tchanged_char,\n\t\tNameBuff);\n\tif (len > IOSIZE - 20)\n\t    len = IOSIZE - 20;\n\n\t// put \"line 999\" in column 40 or after the file name\n\ti = 40 - vim_strsize(IObuff);\n\tdo\n\t    IObuff[len++] = ' ';\n\twhile (--i > 0 && len < IOSIZE - 18);\n#ifdef FEAT_VIMINFO\n\tif (vim_strchr(eap->arg, 't') && buf->b_last_used)\n\t    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n\t\t    _(\"line %ld\"), buf == curbuf ? curwin->w_cursor.lnum\n\t\t\t\t\t       : (long)buflist_findlnum(buf));\n\tmsg_outtrans(IObuff);\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n    }\n\n#ifdef FEAT_VIMINFO\n    if (buflist_data)\n\tga_clear(&buflist);\n#endif\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\n    int\nbuflist_name_nr(\n    int\t\tfnum,\n    char_u\t**fname,\n    linenr_T\t*lnum)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL || buf->b_fname == NULL)\n\treturn FAIL;\n\n    *fname = buf->b_fname;\n    *lnum = buflist_findlnum(buf);\n\n    return OK;\n}\n\n/*\n * Set the file name for \"buf\"' to \"ffname_arg\", short file name to\n * \"sfname_arg\".\n * The file name with the full path is also remembered, for when :cd is used.\n * Returns FAIL for failure (file name already in use by other buffer)\n *\tOK otherwise.\n */\n    int\nsetfname(\n    buf_T\t*buf,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tmessage)\t// give message when buffer already exists\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*obuf = NULL;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (ffname == NULL || *ffname == NUL)\n    {\n\t// Removing the name.\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n#ifdef UNIX\n\tst.st_dev = (dev_T)-1;\n#endif\n    }\n    else\n    {\n\tfname_expand(buf, &ffname, &sfname); // will allocate ffname\n\tif (ffname == NULL)\t\t    // out of memory\n\t    return FAIL;\n\n\t/*\n\t * If the file name is already used in another buffer:\n\t * - if the buffer is loaded, fail\n\t * - if the buffer is not loaded, delete it from the list\n\t */\n#ifdef UNIX\n\tif (mch_stat((char *)ffname, &st) < 0)\n\t    st.st_dev = (dev_T)-1;\n#endif\n\tif (!(buf->b_flags & BF_DUMMY))\n#ifdef UNIX\n\t    obuf = buflist_findname_stat(ffname, &st);\n#else\n\t    obuf = buflist_findname(ffname);\n#endif\n\tif (obuf != NULL && obuf != buf)\n\t{\n\t    win_T\t*win;\n\t    tabpage_T   *tab;\n\t    int\t\tin_use = FALSE;\n\n\t    // during startup a window may use a buffer that is not loaded yet\n\t    FOR_ALL_TAB_WINDOWS(tab, win)\n\t\tif (win->w_buffer == obuf)\n\t\t    in_use = TRUE;\n\n\t    // it's loaded or used in a window, fail\n\t    if (obuf->b_ml.ml_mfp != NULL || in_use)\n\t    {\n\t\tif (message)\n\t\t    emsg(_(e_buffer_with_this_name_already_exists));\n\t\tvim_free(ffname);\n\t\treturn FAIL;\n\t    }\n\t    // delete from the list\n\t    close_buffer(NULL, obuf, DOBUF_WIPE, FALSE, FALSE);\n\t}\n\tsfname = vim_strsave(sfname);\n\tif (ffname == NULL || sfname == NULL)\n\t{\n\t    vim_free(sfname);\n\t    vim_free(ffname);\n\t    return FAIL;\n\t}\n#ifdef USE_FNAME_CASE\n\tfname_case(sfname, 0);    // set correct case for short file name\n#endif\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = sfname;\n    }\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n\n    buf->b_shortname = FALSE;\n\n    buf_name_changed(buf);\n    return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\n    void\nbuf_set_name(int fnum, char_u *name)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf != NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = vim_strsave(name);\n\tbuf->b_sfname = NULL;\n\t// Allocate ffname and expand into full path.  Also resolves .lnk\n\t// files on Win32.\n\tfname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n\tbuf->b_fname = buf->b_sfname;\n    }\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\n    void\nbuf_name_changed(buf_T *buf)\n{\n    /*\n     * If the file name changed, also change the name of the swapfile\n     */\n    if (buf->b_ml.ml_mfp != NULL)\n\tml_setname(buf);\n\n#ifdef FEAT_TERMINAL\n    if (buf->b_term != NULL)\n\tterm_clear_status_text(buf->b_term);\n#endif\n\n    if (curwin->w_buffer == buf)\n\tcheck_arg_idx(curwin);\t// check file name for arg list\n    maketitle();\t\t// set window title\n    status_redraw_all();\t// status lines need to be redrawn\n    fmarks_check_names(buf);\t// check named file marks\n    ml_timestamp(buf);\t\t// reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\n    buf_T *\nsetaltfname(\n    char_u\t*ffname,\n    char_u\t*sfname,\n    linenr_T\tlnum)\n{\n    buf_T\t*buf;\n\n    // Create a buffer.  'buflisted' is not set if it's a new buffer\n    buf = buflist_new(ffname, sfname, lnum, 0);\n    if (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = buf->b_fnum;\n    return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\n    char_u  *\ngetaltfname(\n    int\t\terrmsg)\t\t// give error message\n{\n    char_u\t*fname;\n    linenr_T\tdummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) == FAIL)\n    {\n\tif (errmsg)\n\t    emsg(_(e_no_alternate_file));\n\treturn NULL;\n    }\n    return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\n    int\nbuflist_add(char_u *fname, int flags)\n{\n    buf_T\t*buf;\n\n    buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n    if (buf != NULL)\n\treturn buf->b_fnum;\n    return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\n    void\nbuflist_slash_adjust(void)\n{\n    buf_T\t*bp;\n\n    FOR_ALL_BUFFERS(bp)\n    {\n\tif (bp->b_ffname != NULL)\n\t    slash_adjust(bp->b_ffname);\n\tif (bp->b_sfname != NULL)\n\t    slash_adjust(bp->b_sfname);\n    }\n}\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\n    void\nbuflist_altfpos(win_T *win)\n{\n    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);\n}\n\n/*\n * Return TRUE if 'ffname' is not the same file as current file.\n * Fname must have a full path (expanded by mch_FullName()).\n */\n    int\notherfile(char_u *ffname)\n{\n    return otherfile_buf(curbuf, ffname\n#ifdef UNIX\n\t    , NULL\n#endif\n\t    );\n}\n\n    static int\notherfile_buf(\n    buf_T\t\t*buf,\n    char_u\t\t*ffname\n#ifdef UNIX\n    , stat_T\t\t*stp\n#endif\n    )\n{\n    // no name is different\n    if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)\n\treturn TRUE;\n    if (fnamecmp(ffname, buf->b_ffname) == 0)\n\treturn FALSE;\n#ifdef UNIX\n    {\n\tstat_T\t    st;\n\n\t// If no stat_T given, get it now\n\tif (stp == NULL)\n\t{\n\t    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)\n\t\tst.st_dev = (dev_T)-1;\n\t    stp = &st;\n\t}\n\t// Use dev/ino to check if the files are the same, even when the names\n\t// are different (possible with links).  Still need to compare the\n\t// name above, for when the file doesn't exist yet.\n\t// Problem: The dev/ino changes when a file is deleted (and created\n\t// again) and remains the same when renamed/moved.  We don't want to\n\t// mch_stat() each buffer each time, that would be too slow.  Get the\n\t// dev/ino again when they appear to match, but not when they appear\n\t// to be different: Could skip a buffer when it's actually the same\n\t// file.\n\tif (buf_same_ino(buf, stp))\n\t{\n\t    buf_setino(buf);\n\t    if (buf_same_ino(buf, stp))\n\t\treturn FALSE;\n\t}\n    }\n#endif\n    return TRUE;\n}\n\n#if defined(UNIX) || defined(PROTO)\n/*\n * Set inode and device number for a buffer.\n * Must always be called when b_fname is changed!.\n */\n    void\nbuf_setino(buf_T *buf)\n{\n    stat_T\tst;\n\n    if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n    else\n\tbuf->b_dev_valid = FALSE;\n}\n\n/*\n * Return TRUE if dev/ino in buffer \"buf\" matches with \"stp\".\n */\n    static int\nbuf_same_ino(\n    buf_T\t*buf,\n    stat_T\t*stp)\n{\n    return (buf->b_dev_valid\n\t    && stp->st_dev == buf->b_dev\n\t    && stp->st_ino == buf->b_ino);\n}\n#endif\n\n/*\n * Print info about the current buffer.\n */\n    void\nfileinfo(\n    int fullname,\t    // when non-zero print full path\n    int shorthelp,\n    int\tdont_truncate)\n{\n    char_u\t*name;\n    int\t\tn;\n    char\t*p;\n    char\t*buffer;\n    size_t\tlen;\n\n    buffer = alloc(IOSIZE);\n    if (buffer == NULL)\n\treturn;\n\n    if (fullname > 1)\t    // 2 CTRL-G: include buffer number\n    {\n\tvim_snprintf(buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n\tp = buffer + STRLEN(buffer);\n    }\n    else\n\tp = buffer;\n\n    *p++ = '\"';\n    if (buf_spname(curbuf) != NULL)\n\tvim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);\n    else\n    {\n\tif (!fullname && curbuf->b_fname != NULL)\n\t    name = curbuf->b_fname;\n\telse\n\t    name = curbuf->b_ffname;\n\thome_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,\n\t\t\t\t\t  (int)(IOSIZE - (p - buffer)), TRUE);\n    }\n\n    vim_snprintf_add(buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n\t    curbufIsChanged() ? (shortmess(SHM_MOD)\n\t\t\t\t\t  ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n\t    (curbuf->b_flags & BF_NOTEDITED) && !bt_dontwrite(curbuf)\n\t\t\t\t\t? _(\"[Not edited]\") : \"\",\n\t    (curbuf->b_flags & BF_NEW) && !bt_dontwrite(curbuf)\n\t\t\t\t\t   ? new_file_message() : \"\",\n\t    (curbuf->b_flags & BF_READERR) ? _(\"[Read errors]\") : \"\",\n\t    curbuf->b_p_ro ? (shortmess(SHM_RO) ? _(\"[RO]\")\n\t\t\t\t\t\t      : _(\"[readonly]\")) : \"\",\n\t    (curbufIsChanged() || (curbuf->b_flags & BF_WRITE_MASK)\n\t\t\t\t\t\t\t  || curbuf->b_p_ro) ?\n\t\t\t\t\t\t\t\t    \" \" : \"\");\n    // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n    // causes an overflow, thus for large numbers divide instead.\n    if (curwin->w_cursor.lnum > 1000000L)\n\tn = (int)(((long)curwin->w_cursor.lnum) /\n\t\t\t\t   ((long)curbuf->b_ml.ml_line_count / 100L));\n    else\n\tn = (int)(((long)curwin->w_cursor.lnum * 100L) /\n\t\t\t\t\t    (long)curbuf->b_ml.ml_line_count);\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tvim_snprintf_add(buffer, IOSIZE, \"%s\", _(no_lines_msg));\n#ifdef FEAT_CMDL_INFO\n    else if (p_ru)\n\t// Current line and column are already on the screen -- webb\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\tNGETTEXT(\"%ld line --%d%%--\", \"%ld lines --%d%%--\",\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count),\n\t\t(long)curbuf->b_ml.ml_line_count, n);\n#endif\n    else\n    {\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\t_(\"line %ld of %ld --%d%%-- col \"),\n\t\t(long)curwin->w_cursor.lnum,\n\t\t(long)curbuf->b_ml.ml_line_count,\n\t\tn);\n\tvalidate_virtcol();\n\tlen = STRLEN(buffer);\n\tcol_print((char_u *)buffer + len, IOSIZE - len,\n\t\t   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n    }\n\n    (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,\n\t\t\t\t\t\t\t !shortmess(SHM_FILE));\n\n    if (dont_truncate)\n    {\n\t// Temporarily set msg_scroll to avoid the message being truncated.\n\t// First call msg_start() to get the message in the right place.\n\tmsg_start();\n\tn = msg_scroll;\n\tmsg_scroll = TRUE;\n\tmsg(buffer);\n\tmsg_scroll = n;\n    }\n    else\n    {\n\tp = msg_trunc_attr(buffer, FALSE, 0);\n\tif (restart_edit != 0 || (msg_scrolled && !need_wait_return))\n\t    // Need to repeat the message after redrawing when:\n\t    // - When restart_edit is set (otherwise there will be a delay\n\t    //   before redrawing).\n\t    // - When the screen was scrolled but there is no wait-return\n\t    //   prompt.\n\t    set_keep_msg((char_u *)p, 0);\n    }\n\n    vim_free(buffer);\n}\n\n    void\ncol_print(\n    char_u  *buf,\n    size_t  buflen,\n    int\t    col,\n    int\t    vcol)\n{\n    if (col == vcol)\n\tvim_snprintf((char *)buf, buflen, \"%d\", col);\n    else\n\tvim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n/*\n * Put the file name in the title bar and icon of the window.\n */\n    void\nmaketitle(void)\n{\n    char_u\t*p;\n    char_u\t*title_str = NULL;\n    char_u\t*icon_str = NULL;\n    int\t\tmaxlen = 0;\n    int\t\tlen;\n    int\t\tmustset;\n    char_u\tbuf[IOSIZE];\n    int\t\toff;\n\n    if (!redrawing())\n    {\n\t// Postpone updating the title when 'lazyredraw' is set.\n\tneed_maketitle = TRUE;\n\treturn;\n    }\n\n    need_maketitle = FALSE;\n    if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)\n\treturn;  // nothing to do\n\n    if (p_title)\n    {\n\tif (p_titlelen > 0)\n\t{\n\t    maxlen = p_titlelen * Columns / 100;\n\t    if (maxlen < 10)\n\t\tmaxlen = 10;\n\t}\n\n\ttitle_str = buf;\n\tif (*p_titlestring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_TITLE)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"titlestring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, title_str, sizeof(buf),\n\t\t\t\t\t      p_titlestring, use_sandbox,\n\t\t\t\t\t      0, maxlen, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"titlestring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ttitle_str = p_titlestring;\n\t}\n\telse\n\t{\n\t    // format: \"fname + (path) (1 of 2) - VIM\"\n\n#define SPACE_FOR_FNAME (IOSIZE - 100)\n#define SPACE_FOR_DIR   (IOSIZE - 20)\n#define SPACE_FOR_ARGNR (IOSIZE - 10)  // at least room for \" - VIM\"\n\t    if (curbuf->b_fname == NULL)\n\t\tvim_strncpy(buf, (char_u *)_(\"[No Name]\"), SPACE_FOR_FNAME);\n#ifdef FEAT_TERMINAL\n\t    else if (curbuf->b_term != NULL)\n\t    {\n\t\tvim_strncpy(buf, term_get_status_text(curbuf->b_term),\n\t\t\t\t\t\t\t      SPACE_FOR_FNAME);\n\t    }\n#endif\n\t    else\n\t    {\n\t\tp = transstr(gettail(curbuf->b_fname));\n\t\tvim_strncpy(buf, p, SPACE_FOR_FNAME);\n\t\tvim_free(p);\n\t    }\n\n#ifdef FEAT_TERMINAL\n\t    if (curbuf->b_term == NULL)\n#endif\n\t\tswitch (bufIsChanged(curbuf)\n\t\t\t+ (curbuf->b_p_ro * 2)\n\t\t\t+ (!curbuf->b_p_ma * 4))\n\t\t{\n\t\t    case 1: STRCAT(buf, \" +\"); break;\n\t\t    case 2: STRCAT(buf, \" =\"); break;\n\t\t    case 3: STRCAT(buf, \" =+\"); break;\n\t\t    case 4:\n\t\t    case 6: STRCAT(buf, \" -\"); break;\n\t\t    case 5:\n\t\t    case 7: STRCAT(buf, \" -+\"); break;\n\t\t}\n\n\t    if (curbuf->b_fname != NULL\n#ifdef FEAT_TERMINAL\n\t\t    && curbuf->b_term == NULL\n#endif\n\t\t    )\n\t    {\n\t\t// Get path of file, replace home dir with ~\n\t\toff = (int)STRLEN(buf);\n\t\tbuf[off++] = ' ';\n\t\tbuf[off++] = '(';\n\t\thome_replace(curbuf, curbuf->b_ffname,\n\t\t\t\t\tbuf + off, SPACE_FOR_DIR - off, TRUE);\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// avoid \"c:/name\" to be reduced to \"c\"\n\t\tif (isalpha(buf[off]) && buf[off + 1] == ':')\n\t\t    off += 2;\n#endif\n\t\t// remove the file name\n\t\tp = gettail_sep(buf + off);\n\t\tif (p == buf + off)\n\t\t{\n\t\t    // must be a help buffer\n\t\t    vim_strncpy(buf + off, (char_u *)_(\"help\"),\n\t\t\t\t\t   (size_t)(SPACE_FOR_DIR - off - 1));\n\t\t}\n\t\telse\n\t\t    *p = NUL;\n\n\t\t// Translate unprintable chars and concatenate.  Keep some\n\t\t// room for the server name.  When there is no room (very long\n\t\t// file name) use (...).\n\t\tif (off < SPACE_FOR_DIR)\n\t\t{\n\t\t    p = transstr(buf + off);\n\t\t    vim_strncpy(buf + off, p, (size_t)(SPACE_FOR_DIR - off));\n\t\t    vim_free(p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf + off, (char_u *)\"...\",\n\t\t\t\t\t     (size_t)(SPACE_FOR_ARGNR - off));\n\t\t}\n\t\tSTRCAT(buf, \")\");\n\t    }\n\n\t    append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);\n\n#if defined(FEAT_CLIENTSERVER)\n\t    if (serverName != NULL)\n\t    {\n\t\tSTRCAT(buf, \" - \");\n\t\tvim_strcat(buf, serverName, IOSIZE);\n\t    }\n\t    else\n#endif\n\t\tSTRCAT(buf, \" - VIM\");\n\n\t    if (maxlen > 0)\n\t    {\n\t\t// make it shorter by removing a bit in the middle\n\t\tif (vim_strsize(buf) > maxlen)\n\t\t    trunc_string(buf, buf, maxlen, IOSIZE);\n\t    }\n\t}\n    }\n    mustset = value_changed(title_str, &lasttitle);\n\n    if (p_icon)\n    {\n\ticon_str = buf;\n\tif (*p_iconstring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_ICON)\n\t    {\n\t\tint\tuse_sandbox = FALSE;\n\t\tint\tcalled_emsg_before = called_emsg;\n\n# ifdef FEAT_EVAL\n\t\tuse_sandbox = was_set_insecurely((char_u *)\"iconstring\", 0);\n# endif\n\t\tbuild_stl_str_hl(curwin, icon_str, sizeof(buf),\n\t\t\t\t\t\t    p_iconstring, use_sandbox,\n\t\t\t\t\t\t    0, 0, NULL, NULL);\n\t\tif (called_emsg > called_emsg_before)\n\t\t    set_string_option_direct((char_u *)\"iconstring\", -1,\n\t\t\t\t\t   (char_u *)\"\", OPT_FREE, SID_ERROR);\n\t    }\n\t    else\n#endif\n\t\ticon_str = p_iconstring;\n\t}\n\telse\n\t{\n\t    if (buf_spname(curbuf) != NULL)\n\t\tp = buf_spname(curbuf);\n\t    else\t\t    // use file name only in icon\n\t\tp = gettail(curbuf->b_ffname);\n\t    *icon_str = NUL;\n\t    // Truncate name at 100 bytes.\n\t    len = (int)STRLEN(p);\n\t    if (len > 100)\n\t    {\n\t\tlen -= 100;\n\t\tif (has_mbyte)\n\t\t    len += (*mb_tail_off)(p, p + len) + 1;\n\t\tp += len;\n\t    }\n\t    STRCPY(icon_str, p);\n\t    trans_characters(icon_str, IOSIZE);\n\t}\n    }\n\n    mustset |= value_changed(icon_str, &lasticon);\n\n    if (mustset)\n\tresettitle();\n}\n\n/*\n * Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n * from \"str\" if it does.\n * Return TRUE if resettitle() is to be called.\n */\n    static int\nvalue_changed(char_u *str, char_u **last)\n{\n    if ((str == NULL) != (*last == NULL)\n\t    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))\n    {\n\tvim_free(*last);\n\tif (str == NULL)\n\t{\n\t    *last = NULL;\n\t    mch_restore_title(\n\t\t  last == &lasttitle ? SAVE_RESTORE_TITLE : SAVE_RESTORE_ICON);\n\t}\n\telse\n\t{\n\t    *last = vim_strsave(str);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Put current window title back (used after calling a shell)\n */\n    void\nresettitle(void)\n{\n    mch_settitle(lasttitle, lasticon);\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_titles(void)\n{\n    vim_free(lasttitle);\n    vim_free(lasticon);\n}\n# endif\n\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n\n/*\n * Used for building in the status line.\n */\ntypedef struct\n{\n    char_u\t*stl_start;\n    int\t\tstl_minwid;\n    int\t\tstl_maxwid;\n    enum {\n\tNormal,\n\tEmpty,\n\tGroup,\n\tMiddle,\n\tHighlight,\n\tTabPage,\n\tTrunc\n    }\t\tstl_type;\n} stl_item_T;\n\nstatic size_t\t\tstl_items_len = 20; // Initial value, grows as needed.\nstatic stl_item_T      *stl_items = NULL;\nstatic int\t       *stl_groupitem = NULL;\nstatic stl_hlrec_T     *stl_hltab = NULL;\nstatic stl_hlrec_T     *stl_tabtab = NULL;\n\n/*\n * Build a string from the status line items in \"fmt\".\n * Return length of string in screen cells.\n *\n * Normally works for window \"wp\", except when working for 'tabline' then it\n * is \"curwin\".\n *\n * Items are drawn interspersed with the text that surrounds it\n * Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation\n * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n *\n * If maxwidth is not zero, the string will be filled at any middle marker\n * or truncated if too long, fillchar is used for all whitespace.\n */\n    int\nbuild_stl_str_hl(\n    win_T\t*wp,\n    char_u\t*out,\t\t// buffer to write into != NameBuff\n    size_t\toutlen,\t\t// length of out[]\n    char_u\t*fmt,\n    int\t\tuse_sandbox UNUSED, // \"fmt\" was set insecurely, use sandbox\n    int\t\tfillchar,\n    int\t\tmaxwidth,\n    stl_hlrec_T **hltab,\t// return: HL attributes (can be NULL)\n    stl_hlrec_T **tabtab)\t// return: tab page nrs (can be NULL)\n{\n    linenr_T\tlnum;\n    size_t\tlen;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*t;\n    int\t\tbyteval;\n#ifdef FEAT_EVAL\n    win_T\t*save_curwin;\n    buf_T\t*save_curbuf;\n    int\t\tsave_VIsual_active;\n#endif\n    int\t\tempty_line;\n    colnr_T\tvirtcol;\n    long\tl;\n    long\tn;\n    int\t\tprevchar_isflag;\n    int\t\tprevchar_isitem;\n    int\t\titemisflag;\n    int\t\tfillable;\n    char_u\t*str;\n    long\tnum;\n    int\t\twidth;\n    int\t\titemcnt;\n    int\t\tcuritem;\n    int\t\tgroup_end_userhl;\n    int\t\tgroup_start_userhl;\n    int\t\tgroupdepth;\n#ifdef FEAT_EVAL\n    int\t\tevaldepth;\n#endif\n    int\t\tminwid;\n    int\t\tmaxwid;\n    int\t\tzeropad;\n    char_u\tbase;\n    char_u\topt;\n#define TMPLEN 70\n    char_u\tbuf_tmp[TMPLEN];\n    char_u\twin_tmp[TMPLEN];\n    char_u\t*usefmt = fmt;\n    stl_hlrec_T *sp;\n    int\t\tsave_redraw_not_allowed = redraw_not_allowed;\n    int\t\tsave_KeyTyped = KeyTyped;\n\n    // When inside update_screen() we do not want redrawing a statusline,\n    // ruler, title, etc. to trigger another redraw, it may cause an endless\n    // loop.\n    if (updating_screen)\n\tredraw_not_allowed = TRUE;\n\n    if (stl_items == NULL)\n    {\n\tstl_items = ALLOC_MULT(stl_item_T, stl_items_len);\n\tstl_groupitem = ALLOC_MULT(int, stl_items_len);\n\n\t// Allocate one more, because the last element is used to indicate the\n\t// end of the list.\n\tstl_hltab  = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n\tstl_tabtab = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * When the format starts with \"%!\" then evaluate it as an expression and\n     * use the result as the actual format string.\n     */\n    if (fmt[0] == '%' && fmt[1] == '!')\n    {\n\ttypval_T\ttv;\n\n\ttv.v_type = VAR_NUMBER;\n\ttv.vval.v_number = wp->w_id;\n\tset_var((char_u *)\"g:statusline_winid\", &tv, FALSE);\n\n\tusefmt = eval_to_string_safe(fmt + 2, use_sandbox, FALSE);\n\tif (usefmt == NULL)\n\t    usefmt = fmt;\n\n\tdo_unlet((char_u *)\"g:statusline_winid\", TRUE);\n    }\n#endif\n\n    if (fillchar == 0)\n\tfillchar = ' ';\n\n    // The cursor in windows other than the current one isn't always\n    // up-to-date, esp. because of autocommands and timers.\n    lnum = wp->w_cursor.lnum;\n    if (lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\twp->w_cursor.lnum = lnum;\n    }\n\n    // Get line & check if empty (cursorpos will show \"0-1\").  Note that\n    // p will become invalid when getting another buffer line.\n    p = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    empty_line = (*p == NUL);\n\n    // Get the byte value now, in case we need it below. This is more efficient\n    // than making a copy of the line.\n    len = STRLEN(p);\n    if (wp->w_cursor.col > (colnr_T)len)\n    {\n\t// Line may have changed since checking the cursor column, or the lnum\n\t// was adjusted above.\n\twp->w_cursor.col = (colnr_T)len;\n\twp->w_cursor.coladd = 0;\n\tbyteval = 0;\n    }\n    else\n\tbyteval = (*mb_ptr2char)(p + wp->w_cursor.col);\n\n    groupdepth = 0;\n#ifdef FEAT_EVAL\n    evaldepth = 0;\n#endif\n    p = out;\n    curitem = 0;\n    prevchar_isflag = TRUE;\n    prevchar_isitem = FALSE;\n    for (s = usefmt; *s != NUL; )\n    {\n\tif (curitem == (int)stl_items_len)\n\t{\n\t    size_t\tnew_len = stl_items_len * 3 / 2;\n\t    stl_item_T\t*new_items;\n\t    int\t\t*new_groupitem;\n\t    stl_hlrec_T\t*new_hlrec;\n\n\t    new_items = vim_realloc(stl_items, sizeof(stl_item_T) * new_len);\n\t    if (new_items == NULL)\n\t\tbreak;\n\t    stl_items = new_items;\n\t    new_groupitem = vim_realloc(stl_groupitem, sizeof(int) * new_len);\n\t    if (new_groupitem == NULL)\n\t\tbreak;\n\t    stl_groupitem = new_groupitem;\n\t    new_hlrec = vim_realloc(stl_hltab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_hltab = new_hlrec;\n\t    new_hlrec = vim_realloc(stl_tabtab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_tabtab = new_hlrec;\n\t    stl_items_len = new_len;\n\t}\n\n\tif (*s != '%')\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\n\t/*\n\t * Handle up to the next '%' or the end.\n\t */\n\twhile (*s != NUL && *s != '%' && p + 1 < out + outlen)\n\t    *p++ = *s++;\n\tif (*s == NUL || p + 1 >= out + outlen)\n\t    break;\n\n\t/*\n\t * Handle one '%' item.\n\t */\n\ts++;\n\tif (*s == NUL)  // ignore trailing %\n\t    break;\n\tif (*s == '%')\n\t{\n\t    if (p + 1 >= out + outlen)\n\t\tbreak;\n\t    *p++ = *s++;\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\t    continue;\n\t}\n\tif (*s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    if (groupdepth > 0)\n\t\tcontinue;\n\t    stl_items[curitem].stl_type = Middle;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == STL_TRUNCMARK)\n\t{\n\t    s++;\n\t    stl_items[curitem].stl_type = Trunc;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (groupdepth < 1)\n\t\tcontinue;\n\t    groupdepth--;\n\n\t    t = stl_items[stl_groupitem[groupdepth]].stl_start;\n\t    *p = NUL;\n\t    l = vim_strsize(t);\n\t    if (curitem > stl_groupitem[groupdepth] + 1\n\t\t    && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)\n\t    {\n\t\t// remove group if all items are empty and highlight group\n\t\t// doesn't change\n\t\tgroup_start_userhl = group_end_userhl = 0;\n\t\tfor (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t    {\n\t\t\tgroup_start_userhl = group_end_userhl =\n\t\t\t\t\t\t       stl_items[n].stl_minwid;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tfor (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Normal)\n\t\t\tbreak;\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t\tgroup_end_userhl = stl_items[n].stl_minwid;\n\t\t}\n\t\tif (n == curitem && group_start_userhl == group_end_userhl)\n\t\t{\n\t\t    // empty group\n\t\t    p = t;\n\t\t    l = 0;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t    {\n\t\t\t// do not use the highlighting from the removed group\n\t\t\tif (stl_items[n].stl_type == Highlight)\n\t\t\t    stl_items[n].stl_type = Empty;\n\t\t\t// adjust the start position of TabPage to the next\n\t\t\t// item position\n\t\t\tif (stl_items[n].stl_type == TabPage)\n\t\t\t    stl_items[n].stl_start = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t    {\n\t\t// truncate, remove n bytes of text at the start\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // Find the first character that should be included.\n\t\t    n = 0;\n\t\t    while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t\t    {\n\t\t\tl -= ptr2cells(t + n);\n\t\t\tn += (*mb_ptr2len)(t + n);\n\t\t    }\n\t\t}\n\t\telse\n\t\t    n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]\n\t\t\t\t\t\t\t       .stl_maxwid + 1;\n\n\t\t*t = '<';\n\t\tmch_memmove(t + 1, t + n, (size_t)(p - (t + n)));\n\t\tp = p - n + 1;\n\n\t\t// Fill up space left over by half a double-wide char.\n\t\twhile (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\n\t\t// correct the start of the items for the truncation\n\t\tfor (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)\n\t\t{\n\t\t    // Minus one for the leading '<' added above.\n\t\t    stl_items[l].stl_start -= n - 1;\n\t\t    if (stl_items[l].stl_start < t)\n\t\t\tstl_items[l].stl_start = t;\n\t\t}\n\t    }\n\t    else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)\n\t    {\n\t\t// fill\n\t\tn = stl_items[stl_groupitem[groupdepth]].stl_minwid;\n\t\tif (n < 0)\n\t\t{\n\t\t    // fill by appending characters\n\t\t    n = 0 - n;\n\t\t    while (l++ < n && p + 1 < out + outlen)\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // fill by inserting characters\n\t\t    l = (n - l) * MB_CHAR2LEN(fillchar);\n\t\t    mch_memmove(t + l, t, (size_t)(p - t));\n\t\t    if (p + l >= out + outlen)\n\t\t\tl = (long)((out + outlen) - p - 1);\n\t\t    p += l;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t\tstl_items[n].stl_start += l;\n\t\t    for ( ; l > 0; l--)\n\t\t\tMB_CHAR2BYTES(fillchar, t);\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tminwid = 0;\n\tmaxwid = 9999;\n\tzeropad = FALSE;\n\tl = 1;\n\tif (*s == '0')\n\t{\n\t    s++;\n\t    zeropad = TRUE;\n\t}\n\tif (*s == '-')\n\t{\n\t    s++;\n\t    l = -1;\n\t}\n\tif (VIM_ISDIGIT(*s))\n\t{\n\t    minwid = (int)getdigits(&s);\n\t    if (minwid < 0)\t// overflow\n\t\tminwid = 0;\n\t}\n\tif (*s == STL_USER_HL)\n\t{\n\t    stl_items[curitem].stl_type = Highlight;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == STL_TABPAGENR || *s == STL_TABCLOSENR)\n\t{\n\t    if (*s == STL_TABCLOSENR)\n\t    {\n\t\tif (minwid == 0)\n\t\t{\n\t\t    // %X ends the close label, go back to the previously\n\t\t    // define tab label nr.\n\t\t    for (n = curitem - 1; n >= 0; --n)\n\t\t\tif (stl_items[n].stl_type == TabPage\n\t\t\t\t\t       && stl_items[n].stl_minwid >= 0)\n\t\t\t{\n\t\t\t    minwid = stl_items[n].stl_minwid;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t    // close nrs are stored as negative values\n\t\t    minwid = - minwid;\n\t    }\n\t    stl_items[curitem].stl_type = TabPage;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    if (VIM_ISDIGIT(*s))\n\t    {\n\t\tmaxwid = (int)getdigits(&s);\n\t\tif (maxwid <= 0)\t// overflow\n\t\t    maxwid = 50;\n\t    }\n\t}\n\tminwid = (minwid > 50 ? 50 : minwid) * l;\n\tif (*s == '(')\n\t{\n\t    stl_groupitem[groupdepth++] = curitem;\n\t    stl_items[curitem].stl_type = Group;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    stl_items[curitem].stl_maxwid = maxwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n#ifdef FEAT_EVAL\n\t// Denotes end of expanded %{} block\n\tif (*s == '}' && evaldepth > 0)\n\t{\n\t    s++;\n\t    evaldepth--;\n\t    continue;\n\t}\n#endif\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\topt = *s++;\n\n\t// OK - now for the real work\n\tbase = 'D';\n\titemisflag = FALSE;\n\tfillable = TRUE;\n\tnum = -1;\n\tstr = NULL;\n\tswitch (opt)\n\t{\n\tcase STL_FILEPATH:\n\tcase STL_FULLPATH:\n\tcase STL_FILENAME:\n\t    fillable = FALSE;\t// don't change ' ' to fillchar\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(NameBuff, buf_spname(wp->w_buffer), MAXPATHL - 1);\n\t    else\n\t    {\n\t\tt = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n\t\t\t\t\t  : wp->w_buffer->b_fname;\n\t\thome_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);\n\t    }\n\t    trans_characters(NameBuff, MAXPATHL);\n\t    if (opt != STL_FILENAME)\n\t\tstr = NameBuff;\n\t    else\n\t\tstr = gettail(NameBuff);\n\t    break;\n\n\tcase STL_VIM_EXPR: // '{'\n\t{\n#ifdef FEAT_EVAL\n\t    char_u *block_start = s - 1;\n#endif\n\t    int reevaluate = (*s == '%');\n\n\t    if (reevaluate)\n\t\ts++;\n\t    itemisflag = TRUE;\n\t    t = p;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%'))\n\t\t\t\t\t  && *s != NUL && p + 1 < out + outlen)\n\t\t*p++ = *s++;\n\t    if (*s != '}')\t// missing '}' or out of space\n\t\tbreak;\n\t    s++;\n\t    if (reevaluate)\n\t\tp[-1] = 0; // remove the % at the end of %{% expr %}\n\t    else\n\t\t*p = 0;\n\t    p = t;\n#ifdef FEAT_EVAL\n\t    vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),\n\t\t\t\t\t\t\t \"%d\", curbuf->b_fnum);\n\t    set_internal_string_var((char_u *)\"g:actual_curbuf\", buf_tmp);\n\t    vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->w_id);\n\t    set_internal_string_var((char_u *)\"g:actual_curwin\", win_tmp);\n\n\t    save_curbuf = curbuf;\n\t    save_curwin = curwin;\n\t    save_VIsual_active = VIsual_active;\n\t    curwin = wp;\n\t    curbuf = wp->w_buffer;\n\t    // Visual mode is only valid in the current window.\n\t    if (curwin != save_curwin)\n\t\tVIsual_active = FALSE;\n\n\t    str = eval_to_string_safe(p, use_sandbox, FALSE);\n\n\t    curwin = save_curwin;\n\t    curbuf = save_curbuf;\n\t    VIsual_active = save_VIsual_active;\n\t    do_unlet((char_u *)\"g:actual_curbuf\", TRUE);\n\t    do_unlet((char_u *)\"g:actual_curwin\", TRUE);\n\n\t    if (str != NULL && *str != 0)\n\t    {\n\t\tif (*skipdigits(str) == NUL)\n\t\t{\n\t\t    num = atoi((char *)str);\n\t\t    VIM_CLEAR(str);\n\t\t    itemisflag = FALSE;\n\t\t}\n\t    }\n\n\t    // If the output of the expression needs to be evaluated\n\t    // replace the %{} block with the result of evaluation\n\t    if (reevaluate && str != NULL && *str != 0\n\t\t    && strchr((const char *)str, '%') != NULL\n\t\t    && evaldepth < MAX_STL_EVAL_DEPTH)\n\t    {\n\t\tsize_t parsed_usefmt = (size_t)(block_start - usefmt);\n\t\tsize_t str_length = strlen((const char *)str);\n\t\tsize_t fmt_length = strlen((const char *)s);\n\t\tsize_t new_fmt_len = parsed_usefmt\n\t\t\t\t\t\t + str_length + fmt_length + 3;\n\t\tchar_u *new_fmt = (char_u *)alloc(new_fmt_len * sizeof(char_u));\n\t\tchar_u *new_fmt_p = new_fmt;\n\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n\t\t\t\t\t\t\t       + parsed_usefmt;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n\t\t\t\t\t\t\t\t  + str_length;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , s, fmt_length)\n\t\t\t\t\t\t\t\t  + fmt_length;\n\t\t*new_fmt_p = 0;\n\t\tnew_fmt_p = NULL;\n\n\t\tif (usefmt != fmt)\n\t\t    vim_free(usefmt);\n\t\tVIM_CLEAR(str);\n\t\tusefmt = new_fmt;\n\t\ts = usefmt + parsed_usefmt;\n\t\tevaldepth++;\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\tcase STL_LINE:\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t  ? 0L : (long)(wp->w_cursor.lnum);\n\t    break;\n\n\tcase STL_NUMLINES:\n\t    num = wp->w_buffer->b_ml.ml_line_count;\n\t    break;\n\n\tcase STL_COLUMN:\n\t    num = (State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t\t       ? 0 : (int)wp->w_cursor.col + 1;\n\t    break;\n\n\tcase STL_VIRTCOL:\n\tcase STL_VIRTCOL_ALT:\n\t    virtcol = wp->w_virtcol + 1;\n\t    // Don't display %V if it's the same as %c.\n\t    if (opt == STL_VIRTCOL_ALT\n\t\t    && (virtcol == (colnr_T)((State & MODE_INSERT) == 0\n\t\t\t       && empty_line ? 0 : (int)wp->w_cursor.col + 1)))\n\t\tbreak;\n\t    num = (long)virtcol;\n\t    break;\n\n\tcase STL_PERCENTAGE:\n\t    num = (int)(((long)wp->w_cursor.lnum * 100L) /\n\t\t\t(long)wp->w_buffer->b_ml.ml_line_count);\n\t    break;\n\n\tcase STL_ALTPERCENT:\n\t    str = buf_tmp;\n\t    get_rel_pos(wp, str, TMPLEN);\n\t    break;\n\n\tcase STL_ARGLISTSTAT:\n\t    fillable = FALSE;\n\t    buf_tmp[0] = 0;\n\t    if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), FALSE))\n\t\tstr = buf_tmp;\n\t    break;\n\n\tcase STL_KEYMAP:\n\t    fillable = FALSE;\n\t    if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN))\n\t\tstr = buf_tmp;\n\t    break;\n\tcase STL_PAGENUM:\n#if defined(FEAT_PRINTER) || defined(FEAT_GUI_TABLINE)\n\t    num = printer_page_num;\n#else\n\t    num = 0;\n#endif\n\t    break;\n\n\tcase STL_BUFNO:\n\t    num = wp->w_buffer->b_fnum;\n\t    break;\n\n\tcase STL_OFFSET_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_OFFSET:\n#ifdef FEAT_BYTEOFF\n\t    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL);\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0\n\t\t       ? 0L : l + 1 + ((State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t? 0 : (int)wp->w_cursor.col);\n#endif\n\t    break;\n\n\tcase STL_BYTEVAL_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_BYTEVAL:\n\t    num = byteval;\n\t    if (num == NL)\n\t\tnum = 0;\n\t    else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC)\n\t\tnum = NL;\n\t    break;\n\n\tcase STL_ROFLAG:\n\tcase STL_ROFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_p_ro)\n\t\tstr = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n\t    break;\n\n\tcase STL_HELPFLAG:\n\tcase STL_HELPFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_help)\n\t\tstr = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n\t\t\t\t\t\t\t       : _(\"[Help]\"));\n\t    break;\n\n\tcase STL_FILETYPE:\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n\tcase STL_FILETYPE_ALT:\n\t    itemisflag = TRUE;\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tfor (t = buf_tmp; *t != 0; t++)\n\t\t    *t = TOUPPER_LOC(*t);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n#if defined(FEAT_QUICKFIX)\n\tcase STL_PREVIEWFLAG:\n\tcase STL_PREVIEWFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_p_pvw)\n\t\tstr = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n\t\t\t\t\t\t\t    : _(\"[Preview]\"));\n\t    break;\n\n\tcase STL_QUICKFIX:\n\t    if (bt_quickfix(wp->w_buffer))\n\t\tstr = (char_u *)(wp->w_llist_ref\n\t\t\t    ? _(msg_loclist)\n\t\t\t    : _(msg_qflist));\n\t    break;\n#endif\n\n\tcase STL_MODIFIED:\n\tcase STL_MODIFIED_ALT:\n\t    itemisflag = TRUE;\n\t    switch ((opt == STL_MODIFIED_ALT)\n\t\t    + bufIsChanged(wp->w_buffer) * 2\n\t\t    + (!wp->w_buffer->b_p_ma) * 4)\n\t    {\n\t\tcase 2: str = (char_u *)\"[+]\"; break;\n\t\tcase 3: str = (char_u *)\",+\"; break;\n\t\tcase 4: str = (char_u *)\"[-]\"; break;\n\t\tcase 5: str = (char_u *)\",-\"; break;\n\t\tcase 6: str = (char_u *)\"[+-]\"; break;\n\t\tcase 7: str = (char_u *)\",+-\"; break;\n\t    }\n\t    break;\n\n\tcase STL_HIGHLIGHT:\n\t    t = s;\n\t    while (*s != '#' && *s != NUL)\n\t\t++s;\n\t    if (*s == '#')\n\t    {\n\t\tstl_items[curitem].stl_type = Highlight;\n\t\tstl_items[curitem].stl_start = p;\n\t\tstl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));\n\t\tcuritem++;\n\t    }\n\t    if (*s != NUL)\n\t\t++s;\n\t    continue;\n\t}\n\n\tstl_items[curitem].stl_start = p;\n\tstl_items[curitem].stl_type = Normal;\n\tif (str != NULL && *str)\n\t{\n\t    t = str;\n\t    if (itemisflag)\n\t    {\n\t\tif ((t[0] && t[1])\n\t\t\t&& ((!prevchar_isitem && *t == ',')\n\t\t\t      || (prevchar_isflag && *t == ' ')))\n\t\t    t++;\n\t\tprevchar_isflag = TRUE;\n\t    }\n\t    l = vim_strsize(t);\n\t    if (l > 0)\n\t\tprevchar_isitem = TRUE;\n\t    if (l > maxwid)\n\t    {\n\t\twhile (l >= maxwid)\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tl -= ptr2cells(t);\n\t\t\tt += (*mb_ptr2len)(t);\n\t\t    }\n\t\t    else\n\t\t\tl -= byte2cells(*t++);\n\t\tif (p + 1 >= out + outlen)\n\t\t    break;\n\t\t*p++ = '<';\n\t    }\n\t    if (minwid > 0)\n\t    {\n\t\tfor (; l < minwid && p + 1 < out + outlen; l++)\n\t\t{\n\t\t    // Don't put a \"-\" in front of a digit.\n\t\t    if (l + 1 == minwid && fillchar == '-' && VIM_ISDIGIT(*t))\n\t\t\t*p++ = ' ';\n\t\t    else\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\tminwid = 0;\n\t    }\n\t    else\n\t\tminwid *= -1;\n\t    for (; *t && p + 1 < out + outlen; t++)\n\t    {\n\t\t// Change a space by fillchar, unless fillchar is '-' and a\n\t\t// digit follows.\n\t\tif (fillable && *t == ' '\n\t\t\t\t&& (!VIM_ISDIGIT(*(t + 1)) || fillchar != '-'))\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\t\telse\n\t\t    *p++ = *t;\n\t    }\n\t    for (; l < minwid && p + 1 < out + outlen; l++)\n\t\tMB_CHAR2BYTES(fillchar, p);\n\t}\n\telse if (num >= 0)\n\t{\n\t    int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));\n\t    char_u nstr[20];\n\n\t    if (p + 20 >= out + outlen)\n\t\tbreak;\t\t// not sufficient space\n\t    prevchar_isitem = TRUE;\n\t    t = nstr;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t    {\n\t\t*t++ = '-';\n\t\tminwid--;\n\t    }\n\t    *t++ = '%';\n\t    if (zeropad)\n\t\t*t++ = '0';\n\t    *t++ = '*';\n\t    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');\n\t    *t = 0;\n\n\t    for (n = num, l = 1; n >= nbase; n /= nbase)\n\t\tl++;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t\tl++;\n\t    if (l > maxwid)\n\t    {\n\t\tl += 2;\n\t\tn = l - maxwid;\n\t\twhile (l-- > maxwid)\n\t\t    num /= nbase;\n\t\t*t++ = '>';\n\t\t*t++ = '%';\n\t\t*t = t[-3];\n\t\t*++t = 0;\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t   0, num, n);\n\t    }\n\t    else\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t minwid, num);\n\t    p += STRLEN(p);\n\t}\n\telse\n\t    stl_items[curitem].stl_type = Empty;\n\n\tif (num >= 0 || (!itemisflag && str != NULL && *str != NUL))\n\t    prevchar_isflag = FALSE;\t    // Item not NULL, but not a flag\n\t\t\t\t\t    //\n\tif (opt == STL_VIM_EXPR)\n\t    vim_free(str);\n\tcuritem++;\n    }\n    *p = NUL;\n    itemcnt = curitem;\n\n#ifdef FEAT_EVAL\n    if (usefmt != fmt)\n\tvim_free(usefmt);\n#endif\n\n    width = vim_strsize(out);\n    if (maxwidth > 0 && width > maxwidth)\n    {\n\t// Result is too long, must truncate somewhere.\n\tl = 0;\n\tif (itemcnt == 0)\n\t    s = out;\n\telse\n\t{\n\t    for ( ; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_type == Trunc)\n\t\t{\n\t\t    // Truncate at %< item.\n\t\t    s = stl_items[l].stl_start;\n\t\t    break;\n\t\t}\n\t    if (l == itemcnt)\n\t    {\n\t\t// No %< item, truncate first item.\n\t\ts = stl_items[0].stl_start;\n\t\tl = 0;\n\t    }\n\t}\n\n\tif (width - vim_strsize(s) >= maxwidth)\n\t{\n\t    // Truncation mark is beyond max length\n\t    if (has_mbyte)\n\t    {\n\t\ts = out;\n\t\twidth = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    width += ptr2cells(s);\n\t\t    if (width >= maxwidth)\n\t\t\tbreak;\n\t\t    s += (*mb_ptr2len)(s);\n\t\t}\n\t\t// Fill up for half a double-wide character.\n\t\twhile (++width < maxwidth)\n\t\t    MB_CHAR2BYTES(fillchar, s);\n\t    }\n\t    else\n\t\ts = out + maxwidth - 1;\n\t    for (l = 0; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_start > s)\n\t\t    break;\n\t    itemcnt = l;\n\t    *s++ = '>';\n\t    *s = 0;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tn = 0;\n\t\twhile (width >= maxwidth)\n\t\t{\n\t\t    width -= ptr2cells(s + n);\n\t\t    n += (*mb_ptr2len)(s + n);\n\t\t}\n\t    }\n\t    else\n\t\tn = width - maxwidth + 1;\n\t    p = s + n;\n\t    STRMOVE(s + 1, p);\n\t    *s = '<';\n\n\t    // Fill up for half a double-wide character.\n\t    while (++width < maxwidth)\n\t    {\n\t\ts = s + STRLEN(s);\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t\t*s = NUL;\n\t    }\n\n\t    --n;\t// count the '<'\n\t    for (; l < itemcnt; l++)\n\t    {\n\t\tif (stl_items[l].stl_start - n >= s)\n\t\t    stl_items[l].stl_start -= n;\n\t\telse\n\t\t    stl_items[l].stl_start = s;\n\t    }\n\t}\n\twidth = maxwidth;\n    }\n    else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)\n    {\n\t// Apply STL_MIDDLE if any\n\tfor (l = 0; l < itemcnt; l++)\n\t    if (stl_items[l].stl_type == Middle)\n\t\tbreak;\n\tif (l < itemcnt)\n\t{\n\t    int middlelength = (maxwidth - width) * MB_CHAR2LEN(fillchar);\n\t    p = stl_items[l].stl_start + middlelength;\n\t    STRMOVE(p, stl_items[l].stl_start);\n\t    for (s = stl_items[l].stl_start; s < p;)\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t    for (l++; l < itemcnt; l++)\n\t\tstl_items[l].stl_start += middlelength;\n\t    width = maxwidth;\n\t}\n    }\n\n    // Store the info about highlighting.\n    if (hltab != NULL)\n    {\n\t*hltab = stl_hltab;\n\tsp = stl_hltab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == Highlight)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // Store the info about tab pages labels.\n    if (tabtab != NULL)\n    {\n\t*tabtab = stl_tabtab;\n\tsp = stl_tabtab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == TabPage)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    redraw_not_allowed = save_redraw_not_allowed;\n\n    // A user function may reset KeyTyped, restore it.\n    KeyTyped = save_KeyTyped;\n\n    return width;\n}\n#endif // FEAT_STL_OPT\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \\\n\t    || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\n    void\nget_rel_pos(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    long\tabove; // number of lines above window\n    long\tbelow; // number of lines below window\n\n    if (buflen < 3) // need at least 3 chars for writing\n\treturn;\n    above = wp->w_topline - 1;\n#ifdef FEAT_DIFF\n    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n    if (wp->w_topline == 1 && wp->w_topfill >= 1)\n\tabove = 0;  // All buffer lines are displayed and there is an\n\t\t    // indication of filler lines, that can be considered\n\t\t    // seeing all lines.\n#endif\n    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n    if (below <= 0)\n\tvim_strncpy(buf, (char_u *)(above == 0 ? _(\"All\") : _(\"Bot\")),\n\t\t\t\t\t\t\t(size_t)(buflen - 1));\n    else if (above <= 0)\n\tvim_strncpy(buf, (char_u *)_(\"Top\"), (size_t)(buflen - 1));\n    else\n\tvim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n\t\t\t\t    ? (int)(above / ((above + below) / 100L))\n\t\t\t\t    : (int)(above * 100L / (above + below)));\n}\n#endif\n\n/*\n * Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n * Return TRUE if it was appended.\n */\n    static int\nappend_arg_number(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen,\n    int\t\tadd_file)\t// Add \"file\" before the arg number\n{\n    char_u\t*p;\n\n    if (ARGCOUNT <= 1)\t\t// nothing to do\n\treturn FALSE;\n\n    p = buf + STRLEN(buf);\t// go to the end of the buffer\n    if (p - buf + 35 >= buflen)\t// getting too long\n\treturn FALSE;\n    *p++ = ' ';\n    *p++ = '(';\n    if (add_file)\n    {\n\tSTRCPY(p, \"file \");\n\tp += 5;\n    }\n    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n\t\twp->w_arg_idx_invalid ? \"(%d) of %d)\"\n\t\t\t\t  : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n    return TRUE;\n}\n\n/*\n * If fname is not a full path, make it a full path.\n * Returns pointer to allocated memory (NULL for failure).\n */\n    char_u  *\nfix_fname(char_u  *fname)\n{\n    /*\n     * Force expanding the path always for Unix, because symbolic links may\n     * mess up the full path name, even though it starts with a '/'.\n     * Also expand when there is \"..\" in the file name, try to remove it,\n     * because \"c:/src/../README\" is equal to \"c:/README\".\n     * Similarly \"c:/src//file\" is equal to \"c:/src/file\".\n     * For MS-Windows also expand names like \"longna~1\" to \"longname\".\n     */\n#ifdef UNIX\n    return FullName_save(fname, TRUE);\n#else\n    if (!vim_isAbsName(fname)\n\t    || strstr((char *)fname, \"..\") != NULL\n\t    || strstr((char *)fname, \"//\") != NULL\n# ifdef BACKSLASH_IN_FILENAME\n\t    || strstr((char *)fname, \"\\\\\\\\\") != NULL\n# endif\n# if defined(MSWIN)\n\t    || vim_strchr(fname, '~') != NULL\n# endif\n\t    )\n\treturn FullName_save(fname, FALSE);\n\n    fname = vim_strsave(fname);\n\n# ifdef USE_FNAME_CASE\n    if (fname != NULL)\n\tfname_case(fname, 0);\t// set correct case for file name\n# endif\n\n    return fname;\n#endif\n}\n\n/*\n * Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n * \"*ffname\" becomes a pointer to allocated memory (or NULL).\n * When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n * allocated memory.\n * The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n * Note that the resulting \"*ffname\" pointer should be considered not allocated.\n */\n    void\nfname_expand(\n    buf_T\t*buf UNUSED,\n    char_u\t**ffname,\n    char_u\t**sfname)\n{\n    if (*ffname == NULL)\t    // no file name given, nothing to do\n\treturn;\n    if (*sfname == NULL)\t    // no short file name given, use ffname\n\t*sfname = *ffname;\n    *ffname = fix_fname(*ffname);   // expand to full path\n\n#ifdef FEAT_SHORTCUT\n    if (!buf->b_p_bin)\n    {\n\tchar_u  *rfname;\n\n\t// If the file name is a shortcut file, use the file it links to.\n\trfname = mch_resolve_path(*ffname, FALSE);\n\tif (rfname != NULL)\n\t{\n\t    vim_free(*ffname);\n\t    *ffname = rfname;\n\t    *sfname = rfname;\n\t}\n    }\n#endif\n}\n\n/*\n * Open a window for a number of buffers.\n */\n    void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t\t|| ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t    ? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t     - tabline_height()\n\t\t\t    : wp->w_width != Columns)\n\t\t\t|| (had_tab > 0 && wp != firstwin))\n\t\t    && !ONE_WINDOW\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n\t\t    && !win_unlisted(wp))\n\t    {\n\t\tif (win_close(wp, FALSE) == FAIL)\n\t\t    break;\n\t\t// Just in case an autocommand does something strange with\n\t\t// windows: start all over...\n\t\twpnext = firstwin;\n\t\ttpnext = first_tabpage;\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}\n\n\nstatic int  chk_modeline(linenr_T, int);\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\n    void\ndo_modelines(int flags)\n{\n    linenr_T\tlnum;\n    int\t\tnmlines;\n    static int\tentered = 0;\n\n    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)\n\treturn;\n\n    // Disallow recursive entry here.  Can happen when executing a modeline\n    // triggers an autocommand, which reloads modelines with a \":do\".\n    if (entered)\n\treturn;\n\n    ++entered;\n    for (lnum = 1; curbuf->b_p_ml && lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n\t\t\t\t\t\t\t\t       ++lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n\n    for (lnum = curbuf->b_ml.ml_line_count; curbuf->b_p_ml && lnum > 0 && lnum > nmlines\n\t\t       && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n    --entered;\n}\n\n#include \"version.h\"\t\t// for version number\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\n    static int\nchk_modeline(\n    linenr_T\tlnum,\n    int\t\tflags)\t\t// Same as for do_modelines().\n{\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*linecopy;\t\t// local copy of any modeline found\n    int\t\tprev;\n    int\t\tvers;\n    int\t\tend;\n    int\t\tretval = OK;\n    sctx_T\tsave_current_sctx;\n\n    ESTACK_CHECK_DECLARATION\n\n    prev = -1;\n    for (s = ml_get(lnum); *s != NUL; ++s)\n    {\n\tif (prev == -1 || vim_isspace(prev))\n\t{\n\t    if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n\t\t    || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n\t\tbreak;\n\t    // Accept both \"vim\" and \"Vim\".\n\t    if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')\n\t    {\n\t\tif (s[3] == '<' || s[3] == '=' || s[3] == '>')\n\t\t    e = s + 4;\n\t\telse\n\t\t    e = s + 3;\n\t\tvers = getdigits(&e);\n\t\tif (*e == ':'\n\t\t\t&& (s[0] != 'V'\n\t\t\t\t  || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n\t\t\t&& (s[3] == ':'\n\t\t\t    || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n\t\t\t    || (VIM_VERSION_100 < vers && s[3] == '<')\n\t\t\t    || (VIM_VERSION_100 > vers && s[3] == '>')\n\t\t\t    || (VIM_VERSION_100 == vers && s[3] == '=')))\n\t\t    break;\n\t    }\n\t}\n\tprev = *s;\n    }\n\n    if (*s)\n    {\n\tdo\t\t\t\t// skip over \"ex:\", \"vi:\" or \"vim:\"\n\t    ++s;\n\twhile (s[-1] != ':');\n\n\ts = linecopy = vim_strsave(s);\t// copy the line, it will change\n\tif (linecopy == NULL)\n\t    return FAIL;\n\n\t// prepare for emsg()\n\testack_push(ETYPE_MODELINE, (char_u *)\"modelines\", lnum);\n\tESTACK_CHECK_SETUP\n\n\tend = FALSE;\n\twhile (end == FALSE)\n\t{\n\t    s = skipwhite(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\n\t    /*\n\t     * Find end of set command: ':' or end of line.\n\t     * Skip over \"\\:\", replacing it with \":\".\n\t     */\n\t    for (e = s; *e != ':' && *e != NUL; ++e)\n\t\tif (e[0] == '\\\\' && e[1] == ':')\n\t\t    STRMOVE(e, e + 1);\n\t    if (*e == NUL)\n\t\tend = TRUE;\n\n\t    /*\n\t     * If there is a \"set\" command, require a terminating ':' and\n\t     * ignore the stuff after the ':'.\n\t     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n\t     * \"vi:opt opt opt: foo\" -- foo interpreted\n\t     * Accept \"se\" for compatibility with Elvis.\n\t     */\n\t    if (STRNCMP(s, \"set \", (size_t)4) == 0\n\t\t    || STRNCMP(s, \"se \", (size_t)3) == 0)\n\t    {\n\t\tif (*e != ':')\t\t// no terminating ':'?\n\t\t    break;\n\t\tend = TRUE;\n\t\ts = vim_strchr(s, ' ') + 1;\n\t    }\n\t    *e = NUL;\t\t\t// truncate the set command\n\n\t    if (*s != NUL)\t\t// skip over an empty \"::\"\n\t    {\n\t\tint secure_save = secure;\n\n\t\tsave_current_sctx = current_sctx;\n\t\tcurrent_sctx.sc_version = 1;\n#ifdef FEAT_EVAL\n\t\tcurrent_sctx.sc_sid = SID_MODELINE;\n\t\tcurrent_sctx.sc_seq = 0;\n\t\tcurrent_sctx.sc_lnum = lnum;\n#endif\n\n\t\t// Make sure no risky things are executed as a side effect.\n\t\tsecure = 1;\n\n\t\tretval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n\t\tsecure = secure_save;\n\t\tcurrent_sctx = save_current_sctx;\n\t\tif (retval == FAIL)\t\t// stop if error found\n\t\t    break;\n\t    }\n\t    s = e + 1;\t\t\t// advance to next part\n\t}\n\n\tESTACK_CHECK_NOW\n\testack_pop();\n\tvim_free(linecopy);\n    }\n    return retval;\n}\n\n/*\n * Return TRUE if \"buf\" is a normal buffer, 'buftype' is empty.\n */\n    int\nbt_normal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n/*\n * Return TRUE if \"buf\" is the quickfix buffer.\n */\n    int\nbt_quickfix(buf_T *buf UNUSED)\n{\n#ifdef FEAT_QUICKFIX\n    return buf != NULL && buf->b_p_bt[0] == 'q';\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return TRUE if \"buf\" is a terminal buffer.\n */\n    int\nbt_terminal(buf_T *buf UNUSED)\n{\n#if defined(FEAT_TERMINAL)\n    return buf != NULL && buf->b_p_bt[0] == 't';\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return TRUE if \"buf\" is a help buffer.\n */\n    int\nbt_help(buf_T *buf)\n{\n    return buf != NULL && buf->b_help;\n}\n\n/*\n * Return TRUE if \"buf\" is a prompt buffer.\n */\n    int\nbt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a buffer for a popup window.\n */\n    int\nbt_popup(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt != NULL\n\t&& buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer name may not be a file name, at least not for\n * writing the buffer.\n */\n    int\nbt_nofilename(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 'a'\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"quickfix\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer is not to be read from a file.\n */\n    static int\nbt_nofileread(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'q'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" has 'buftype' set to \"nofile\".\n */\n    int\nbt_nofile(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\" or \"prompt\"\n * buffer.\n */\n    int\nbt_dontwrite(buf_T *buf)\n{\n    return buf != NULL && (buf->b_p_bt[0] == 'n'\n\t\t || buf->b_p_bt[0] == 't'\n\t\t || buf->b_p_bt[0] == 'p');\n}\n\n    int\nbt_dontwrite_msg(buf_T *buf)\n{\n    if (bt_dontwrite(buf))\n    {\n\temsg(_(e_cannot_write_buftype_option_is_set));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if the buffer should be hidden, according to 'hidden', \":hide\"\n * and 'bufhidden'.\n */\n    int\nbuf_hide(buf_T *buf)\n{\n    // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n    switch (buf->b_p_bh[0])\n    {\n\tcase 'u':\t\t    // \"unload\"\n\tcase 'w':\t\t    // \"wipe\"\n\tcase 'd': return FALSE;\t    // \"delete\"\n\tcase 'h': return TRUE;\t    // \"hide\"\n    }\n    return (p_hid || (cmdmod.cmod_flags & CMOD_HIDE));\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\n    char_u *\nbuf_spname(buf_T *buf)\n{\n#if defined(FEAT_QUICKFIX)\n    if (bt_quickfix(buf))\n    {\n\t/*\n\t * Differentiate between the quickfix and location list buffers using\n\t * the buffer number stored in the global quickfix stack.\n\t */\n\tif (buf->b_fnum == qf_stack_get_bufnr())\n\t    return (char_u *)_(msg_qflist);\n\telse\n\t    return (char_u *)_(msg_loclist);\n    }\n#endif\n\n    // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n    // contains the name as specified by the user.\n    if (bt_nofilename(buf))\n    {\n#ifdef FEAT_TERMINAL\n\tif (buf->b_term != NULL)\n\t    return term_get_status_text(buf->b_term);\n#endif\n\tif (buf->b_fname != NULL)\n\t    return buf->b_fname;\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(buf))\n\t    return (char_u *)_(\"[Prompt]\");\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (bt_popup(buf))\n\t    return (char_u *)_(\"[Popup]\");\n#endif\n\treturn (char_u *)_(\"[Scratch]\");\n    }\n\n    if (buf->b_fname == NULL)\n\treturn buf_get_fname(buf);\n    return NULL;\n}\n\n/*\n * Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\n */\n    char_u *\nbuf_get_fname(buf_T *buf)\n{\n    if (buf->b_fname == NULL)\n\treturn (char_u *)_(\"[No Name]\");\n    return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\n    void\nset_buflisted(int on)\n{\n    if (on != curbuf->b_p_bl)\n    {\n\tcurbuf->b_p_bl = on;\n\tif (on)\n\t    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n\telse\n\t    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n/*\n * Read the file for \"buf\" again and check if the contents changed.\n * Return TRUE if it changed or this could not be checked.\n */\n    int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // set curwin/curbuf to buf and save a few things\n    aucmd_prepbuf(&aco, newbuf);\n\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\n    void\nwipe_buffer(\n    buf_T\t*buf,\n    int\t\taucmd)\t    // When TRUE trigger autocommands.\n{\n    if (buf->b_fnum == top_file_num - 1)\n\t--top_file_num;\n\n    if (!aucmd)\t\t    // Don't trigger BufDelete autocommands here.\n\tblock_autocmds();\n\n    close_buffer(NULL, buf, DOBUF_WIPE, FALSE, TRUE);\n\n    if (!aucmd)\n\tunblock_autocmds();\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spell.c: code for spell checking\n *\n * See spellfile.c for the Vim spell file format.\n *\n * The spell checking mechanism uses a tree (aka trie).  Each node in the tree\n * has a list of bytes that can appear (siblings).  For each byte there is a\n * pointer to the node with the byte that follows in the word (child).\n *\n * A NUL byte is used where the word may end.  The bytes are sorted, so that\n * binary searching can be used and the NUL bytes are at the start.  The\n * number of possible bytes is stored before the list of bytes.\n *\n * The tree uses two arrays: \"byts\" stores the characters, \"idxs\" stores\n * either the next index or flags.  The tree starts at index 0.  For example,\n * to lookup \"vi\" this sequence is followed:\n *\ti = 0\n *\tlen = byts[i]\n *\tn = where \"v\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tn = where \"i\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tfind that byts[i + 1] is 0, idxs[i + 1] has flags for \"vi\".\n *\n * There are two word trees: one with case-folded words and one with words in\n * original case.  The second one is only used for keep-case words and is\n * usually small.\n *\n * There is one additional tree for when not all prefixes are applied when\n * generating the .spl file.  This tree stores all the possible prefixes, as\n * if they were words.  At each word (prefix) end the prefix nr is stored, the\n * following word must support this prefix nr.  And the condition nr is\n * stored, used to lookup the condition that the word must match with.\n *\n * Thanks to Olaf Seibert for providing an example implementation of this tree\n * and the compression mechanism.\n * LZ trie ideas:\n *\thttp://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf\n * More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html\n *\n * Matching involves checking the caps type: Onecap ALLCAP KeepCap.\n *\n * Why doesn't Vim use aspell/ispell/myspell/etc.?\n * See \":help develop-spell\".\n */\n\n#define IN_SPELL_C\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#define REGION_ALL 0xff\t\t// word valid in all regions\n\n// Result values.  Lower number is accepted over higher one.\n#define SP_BANNED\t(-1)\n#define SP_OK\t\t0\n#define SP_RARE\t\t1\n#define SP_LOCAL\t2\n#define SP_BAD\t\t3\n\n/*\n * Structure to store info for word matching.\n */\ntypedef struct matchinf_S\n{\n    langp_T\t*mi_lp;\t\t\t// info for language and region\n\n    // pointers to original text to be checked\n    char_u\t*mi_word;\t\t// start of word being checked\n    char_u\t*mi_end;\t\t// end of matching word so far\n    char_u\t*mi_fend;\t\t// next char to be added to mi_fword\n    char_u\t*mi_cend;\t\t// char after what was used for\n\t\t\t\t\t// mi_capflags\n\n    // case-folded text\n    char_u\tmi_fword[MAXWLEN + 1];\t// mi_word case-folded\n    int\t\tmi_fwordlen;\t\t// nr of valid bytes in mi_fword\n\n    // for when checking word after a prefix\n    int\t\tmi_prefarridx;\t\t// index in sl_pidxs with list of\n\t\t\t\t\t// affixID/condition\n    int\t\tmi_prefcnt;\t\t// number of entries at mi_prefarridx\n    int\t\tmi_prefixlen;\t\t// byte length of prefix\n    int\t\tmi_cprefixlen;\t\t// byte length of prefix in original\n\t\t\t\t\t// case\n\n    // for when checking a compound word\n    int\t\tmi_compoff;\t\t// start of following word offset\n    char_u\tmi_compflags[MAXWLEN];\t// flags for compound words used\n    int\t\tmi_complen;\t\t// nr of compound words used\n    int\t\tmi_compextra;\t\t// nr of COMPOUNDROOT words\n\n    // others\n    int\t\tmi_result;\t\t// result so far: SP_BAD, SP_OK, etc.\n    int\t\tmi_capflags;\t\t// WF_ONECAP WF_ALLCAP WF_KEEPCAP\n    win_T\t*mi_win;\t\t// buffer being checked\n\n    // for NOBREAK\n    int\t\tmi_result2;\t\t// \"mi_resul\" without following word\n    char_u\t*mi_end2;\t\t// \"mi_end\" without following word\n} matchinf_T;\n\n\nstatic int spell_mb_isword_class(int cl, win_T *wp);\n\n// mode values for find_word\n#define FIND_FOLDWORD\t    0\t// find word case-folded\n#define FIND_KEEPWORD\t    1\t// find keep-case word\n#define FIND_PREFIX\t    2\t// find word after prefix\n#define FIND_COMPOUND\t    3\t// find case-folded compound word\n#define FIND_KEEPCOMPOUND   4\t// find keep-case compound word\n\nstatic void find_word(matchinf_T *mip, int mode);\nstatic void find_prefix(matchinf_T *mip, int mode);\nstatic int fold_more(matchinf_T *mip);\nstatic void spell_load_cb(char_u *fname, void *cookie);\nstatic int count_syllables(slang_T *slang, char_u *word);\nstatic void clear_midword(win_T *buf);\nstatic void use_midword(slang_T *lp, win_T *buf);\nstatic int find_region(char_u *rp, char_u *region);\nstatic void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res);\nstatic void dump_word(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T lnum);\nstatic linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T startlnum);\n\n/*\n * Main spell-checking function.\n * \"ptr\" points to a character that could be the start of a word.\n * \"*attrp\" is set to the highlight index for a badly spelled word.  For a\n * non-word or when it's OK it remains unchanged.\n * This must only be called when 'spelllang' is not empty.\n *\n * \"capcol\" is used to check for a Capitalised word after the end of a\n * sentence.  If it's zero then perform the check.  Return the column where to\n * check next, or -1 when no sentence end was found.  If it's NULL then don't\n * worry.\n *\n * Returns the length of the word in bytes, also when it's OK, so that the\n * caller can skip over the word.\n */\n    int\nspell_check(\n    win_T\t*wp,\t\t// current window\n    char_u\t*ptr,\n    hlf_T\t*attrp,\n    int\t\t*capcol,\t// column to check for Capital\n    int\t\tdocount)\t// count good words\n{\n    matchinf_T\tmi;\t\t// Most things are put in \"mi\" so that it can\n\t\t\t\t// be passed to functions quickly.\n    int\t\tnrlen = 0;\t// found a number first\n    int\t\tc;\n    int\t\twrongcaplen = 0;\n    int\t\tlpi;\n    int\t\tcount_word = docount;\n    int\t\tuse_camel_case = *wp->w_s->b_p_spo != NUL;\n    int\t\tcamel_case = 0;\n\n    // A word never starts at a space or a control character.  Return quickly\n    // then, skipping over the character.\n    if (*ptr <= ' ')\n\treturn 1;\n\n    // Return here when loading language files failed.\n    if (wp->w_s->b_langp.ga_len == 0)\n\treturn 1;\n\n    CLEAR_FIELD(mi);\n\n    // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and\n    // 0X99FF.  But always do check spelling to find \"3GPP\" and \"11\n    // julifeest\".\n    if (*ptr >= '0' && *ptr <= '9')\n    {\n\tif (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B'))\n\t    mi.mi_end = skipbin(ptr + 2);\n\telse if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X'))\n\t    mi.mi_end = skiphex(ptr + 2);\n\telse\n\t    mi.mi_end = skipdigits(ptr);\n\tnrlen = (int)(mi.mi_end - ptr);\n    }\n\n    // Find the normal end of the word (until the next non-word character).\n    mi.mi_word = ptr;\n    mi.mi_fend = ptr;\n    if (spell_iswordp(mi.mi_fend, wp))\n    {\n\tint prev_upper;\n\tint this_upper = FALSE;  // init for gcc\n\n\tif (use_camel_case)\n\t{\n\t    c = PTR2CHAR(mi.mi_fend);\n\t    this_upper = SPELL_ISUPPER(c);\n\t}\n\n\tdo\n\t{\n\t    MB_PTR_ADV(mi.mi_fend);\n\t    if (use_camel_case)\n\t    {\n\t\tprev_upper = this_upper;\n\t\tc = PTR2CHAR(mi.mi_fend);\n\t\tthis_upper = SPELL_ISUPPER(c);\n\t\tcamel_case = !prev_upper && this_upper;\n\t    }\n\t} while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp)\n\t\t\t\t\t\t\t       && !camel_case);\n\n\tif (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL)\n\t{\n\t    // Check word starting with capital letter.\n\t    c = PTR2CHAR(ptr);\n\t    if (!SPELL_ISUPPER(c))\n\t\twrongcaplen = (int)(mi.mi_fend - ptr);\n\t}\n    }\n    if (capcol != NULL)\n\t*capcol = -1;\n\n    // We always use the characters up to the next non-word character,\n    // also for bad words.\n    mi.mi_end = mi.mi_fend;\n\n    // Check caps type later.\n    mi.mi_capflags = 0;\n    mi.mi_cend = NULL;\n    mi.mi_win = wp;\n\n    // case-fold the word with one non-word character, so that we can check\n    // for the word end.\n    if (*mi.mi_fend != NUL)\n\tMB_PTR_ADV(mi.mi_fend);\n\n    (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,\n\t\t\t\t\t\t\t     MAXWLEN + 1);\n    mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);\n\n    if (camel_case && mi.mi_fwordlen > 0)\n\t// Introduce a fake word end space into the folded word.\n\tmi.mi_fword[mi.mi_fwordlen - 1] = ' ';\n\n    // The word is bad unless we recognize it.\n    mi.mi_result = SP_BAD;\n    mi.mi_result2 = SP_BAD;\n\n    /*\n     * Loop over the languages specified in 'spelllang'.\n     * We check them all, because a word may be matched longer in another\n     * language.\n     */\n    for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi)\n    {\n\tmi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);\n\n\t// If reloading fails the language is still in the list but everything\n\t// has been cleared.\n\tif (mi.mi_lp->lp_slang->sl_fidxs == NULL)\n\t    continue;\n\n\t// Check for a matching word in case-folded words.\n\tfind_word(&mi, FIND_FOLDWORD);\n\n\t// Check for a matching word in keep-case words.\n\tfind_word(&mi, FIND_KEEPWORD);\n\n\t// Check for matching prefixes.\n\tfind_prefix(&mi, FIND_FOLDWORD);\n\n\t// For a NOBREAK language, may want to use a word without a following\n\t// word as a backup.\n\tif (mi.mi_lp->lp_slang->sl_nobreak && mi.mi_result == SP_BAD\n\t\t\t\t\t\t   && mi.mi_result2 != SP_BAD)\n\t{\n\t    mi.mi_result = mi.mi_result2;\n\t    mi.mi_end = mi.mi_end2;\n\t}\n\n\t// Count the word in the first language where it's found to be OK.\n\tif (count_word && mi.mi_result == SP_OK)\n\t{\n\t    count_common_word(mi.mi_lp->lp_slang, ptr,\n\t\t\t\t\t\t   (int)(mi.mi_end - ptr), 1);\n\t    count_word = FALSE;\n\t}\n    }\n\n    if (mi.mi_result != SP_OK)\n    {\n\t// If we found a number skip over it.  Allows for \"42nd\".  Do flag\n\t// rare and local words, e.g., \"3GPP\".\n\tif (nrlen > 0)\n\t{\n\t    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t\treturn nrlen;\n\t}\n\n\t// When we are at a non-word character there is no error, just\n\t// skip over the character (try looking for a word after it).\n\telse if (!spell_iswordp_nmw(ptr, wp))\n\t{\n\t    if (capcol != NULL && wp->w_s->b_cap_prog != NULL)\n\t    {\n\t\tregmatch_T\tregmatch;\n\t\tint\t\tr;\n\n\t\t// Check for end of sentence.\n\t\tregmatch.regprog = wp->w_s->b_cap_prog;\n\t\tregmatch.rm_ic = FALSE;\n\t\tr = vim_regexec(&regmatch, ptr, 0);\n\t\twp->w_s->b_cap_prog = regmatch.regprog;\n\t\tif (r)\n\t\t    *capcol = (int)(regmatch.endp[0] - ptr);\n\t    }\n\n\t    if (has_mbyte)\n\t\treturn (*mb_ptr2len)(ptr);\n\t    return 1;\n\t}\n\telse if (mi.mi_end == ptr)\n\t    // Always include at least one character.  Required for when there\n\t    // is a mixup in \"midword\".\n\t    MB_PTR_ADV(mi.mi_end);\n\telse if (mi.mi_result == SP_BAD\n\t\t&& LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak)\n\t{\n\t    char_u\t*p, *fp;\n\t    int\t\tsave_result = mi.mi_result;\n\n\t    // First language in 'spelllang' is NOBREAK.  Find first position\n\t    // at which any word would be valid.\n\t    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, 0);\n\t    if (mi.mi_lp->lp_slang->sl_fidxs != NULL)\n\t    {\n\t\tp = mi.mi_word;\n\t\tfp = mi.mi_fword;\n\t\tfor (;;)\n\t\t{\n\t\t    MB_PTR_ADV(p);\n\t\t    MB_PTR_ADV(fp);\n\t\t    if (p >= mi.mi_end)\n\t\t\tbreak;\n\t\t    mi.mi_compoff = (int)(fp - mi.mi_fword);\n\t\t    find_word(&mi, FIND_COMPOUND);\n\t\t    if (mi.mi_result != SP_BAD)\n\t\t    {\n\t\t\tmi.mi_end = p;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tmi.mi_result = save_result;\n\t    }\n\t}\n\n\tif (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t    *attrp = HLF_SPB;\n\telse if (mi.mi_result == SP_RARE)\n\t    *attrp = HLF_SPR;\n\telse\n\t    *attrp = HLF_SPL;\n    }\n\n    if (wrongcaplen > 0 && (mi.mi_result == SP_OK || mi.mi_result == SP_RARE))\n    {\n\t// Report SpellCap only when the word isn't badly spelled.\n\t*attrp = HLF_SPC;\n\treturn wrongcaplen;\n    }\n\n    return (int)(mi.mi_end - ptr);\n}\n\n/*\n * Check if the word at \"mip->mi_word\" is in the tree.\n * When \"mode\" is FIND_FOLDWORD check in fold-case word tree.\n * When \"mode\" is FIND_KEEPWORD check in keep-case word tree.\n * When \"mode\" is FIND_PREFIX check for word after prefix in fold-case word\n * tree.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_word(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tendlen[MAXWLEN];    // length at possible word endings\n    idx_T\tendidx[MAXWLEN];    // possible word endings\n    int\t\tendidxcnt = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tres = SP_BAD;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    unsigned\tflags;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tword_ends;\n    int\t\tprefix_found;\n    int\t\tnobreak_result;\n\n    if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND)\n    {\n\t// Check for word with matching case in keep-case tree.\n\tptr = mip->mi_word;\n\tflen = 9999;\t\t    // no case folding, always enough bytes\n\tbyts = slang->sl_kbyts;\n\tidxs = slang->sl_kidxs;\n\n\tif (mode == FIND_KEEPCOMPOUND)\n\t    // Skip over the previously found word(s).\n\t    wlen += mip->mi_compoff;\n    }\n    else\n    {\n\t// Check for case-folded in case-folded tree.\n\tptr = mip->mi_fword;\n\tflen = mip->mi_fwordlen;    // available case-folded bytes\n\tbyts = slang->sl_fbyts;\n\tidxs = slang->sl_fidxs;\n\n\tif (mode == FIND_PREFIX)\n\t{\n\t    // Skip over the prefix.\n\t    wlen = mip->mi_prefixlen;\n\t    flen -= mip->mi_prefixlen;\n\t}\n\telse if (mode == FIND_COMPOUND)\n\t{\n\t    // Skip over the previously found word(s).\n\t    wlen = mip->mi_compoff;\n\t    flen -= mip->mi_compoff;\n\t}\n\n    }\n\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the word could end here.\n\t// Remember this index, we first check for the longest word.\n\tif (byts[arridx] == 0)\n\t{\n\t    if (endidxcnt == MAXWLEN)\n\t    {\n\t\t// Must be a corrupted spell file.\n\t\temsg(_(e_format_error_in_spell_file));\n\t\treturn;\n\t    }\n\t    endlen[endidxcnt] = wlen;\n\t    endidx[endidxcnt++] = arridx++;\n\t    --len;\n\n\t    // Skip over the zeros, there can be several flag/region\n\t    // combinations.\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tif (c == TAB)\t    // <Tab> is handled like <Space>\n\t    c = ' ';\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n\n\t// One space in the good word may stand for several spaces in the\n\t// checked word.\n\tif (c == ' ')\n\t{\n\t    for (;;)\n\t    {\n\t\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t\t    flen = fold_more(mip);\n\t\tif (ptr[wlen] != ' ' && ptr[wlen] != TAB)\n\t\t    break;\n\t\t++wlen;\n\t\t--flen;\n\t    }\n\t}\n    }\n\n    /*\n     * Verify that one of the possible endings is valid.  Try the longest\n     * first.\n     */\n    while (endidxcnt > 0)\n    {\n\t--endidxcnt;\n\tarridx = endidx[endidxcnt];\n\twlen = endlen[endidxcnt];\n\n\tif ((*mb_head_off)(ptr, ptr + wlen) > 0)\n\t    continue;\t    // not at first byte of character\n\tif (spell_iswordp(ptr + wlen, mip->mi_win))\n\t{\n\t    if (slang->sl_compprog == NULL && !slang->sl_nobreak)\n\t\tcontinue;\t    // next char is a word character\n\t    word_ends = FALSE;\n\t}\n\telse\n\t    word_ends = TRUE;\n\t// The prefix flag is before compound flags.  Once a valid prefix flag\n\t// has been found we try compound flags.\n\tprefix_found = FALSE;\n\n\tif (mode != FIND_KEEPWORD && has_mbyte)\n\t{\n\t    // Compute byte length in original word, length may change\n\t    // when folding case.  This can be slow, take a shortcut when the\n\t    // case-folded word is equal to the keep-case word.\n\t    p = mip->mi_word;\n\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t    {\n\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t    MB_PTR_ADV(p);\n\t\twlen = (int)(p - mip->mi_word);\n\t    }\n\t}\n\n\t// Check flags and region.  For FIND_PREFIX check the condition and\n\t// prefix ID.\n\t// Repeat this if there are more flags/region alternatives until there\n\t// is a match.\n\tres = SP_BAD;\n\tfor (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;\n\t\t\t\t\t\t\t      --len, ++arridx)\n\t{\n\t    flags = idxs[arridx];\n\n\t    // For the fold-case tree check that the case of the checked word\n\t    // matches with what the word in the tree requires.\n\t    // For keep-case tree the case is always right.  For prefixes we\n\t    // don't bother to check.\n\t    if (mode == FIND_FOLDWORD)\n\t    {\n\t\tif (mip->mi_cend != mip->mi_word + wlen)\n\t\t{\n\t\t    // mi_capflags was set for a different word length, need\n\t\t    // to do it again.\n\t\t    mip->mi_cend = mip->mi_word + wlen;\n\t\t    mip->mi_capflags = captype(mip->mi_word, mip->mi_cend);\n\t\t}\n\n\t\tif (mip->mi_capflags == WF_KEEPCAP\n\t\t\t\t|| !spell_valid_case(mip->mi_capflags, flags))\n\t\t    continue;\n\t    }\n\n\t    // When mode is FIND_PREFIX the word must support the prefix:\n\t    // check the prefix ID and the condition.  Do that for the list at\n\t    // mip->mi_prefarridx that find_prefix() filled.\n\t    else if (mode == FIND_PREFIX && !prefix_found)\n\t    {\n\t\tc = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,\n\t\t\t\t    flags,\n\t\t\t\t    mip->mi_word + mip->mi_cprefixlen, slang,\n\t\t\t\t    FALSE);\n\t\tif (c == 0)\n\t\t    continue;\n\n\t\t// Use the WF_RARE flag for a rare prefix.\n\t\tif (c & WF_RAREPFX)\n\t\t    flags |= WF_RARE;\n\t\tprefix_found = TRUE;\n\t    }\n\n\t    if (slang->sl_nobreak)\n\t    {\n\t\tif ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)\n\t\t\t&& (flags & WF_BANNED) == 0)\n\t\t{\n\t\t    // NOBREAK: found a valid following word.  That's all we\n\t\t    // need to know, so return.\n\t\t    mip->mi_result = SP_OK;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND\n\t\t\t\t\t\t\t\t|| !word_ends))\n\t    {\n\t\t// If there is no compound flag or the word is shorter than\n\t\t// COMPOUNDMIN reject it quickly.\n\t\t// Makes you wonder why someone puts a compound flag on a word\n\t\t// that's too short...  Myspell compatibility requires this\n\t\t// anyway.\n\t\tif (((unsigned)flags >> 24) == 0\n\t\t\t     || wlen - mip->mi_compoff < slang->sl_compminlen)\n\t\t    continue;\n\t\t// For multi-byte chars check character length against\n\t\t// COMPOUNDMIN.\n\t\tif (has_mbyte\n\t\t\t&& slang->sl_compminlen > 0\n\t\t\t&& mb_charlen_len(mip->mi_word + mip->mi_compoff,\n\t\t\t\twlen - mip->mi_compoff) < slang->sl_compminlen)\n\t\t\tcontinue;\n\n\t\t// Limit the number of compound words to COMPOUNDWORDMAX if no\n\t\t// maximum for syllables is specified.\n\t\tif (!word_ends && mip->mi_complen + mip->mi_compextra + 2\n\t\t\t\t\t\t\t   > slang->sl_compmax\n\t\t\t\t\t   && slang->sl_compsylmax == MAXWLEN)\n\t\t    continue;\n\n\t\t// Don't allow compounding on a side where an affix was added,\n\t\t// unless COMPOUNDPERMITFLAG was used.\n\t\tif (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))\n\t\t    continue;\n\t\tif (!word_ends && (flags & WF_NOCOMPAFT))\n\t\t    continue;\n\n\t\t// Quickly check if compounding is possible with this flag.\n\t\tif (!byte_in_str(mip->mi_complen == 0\n\t\t\t\t\t? slang->sl_compstartflags\n\t\t\t\t\t: slang->sl_compallflags,\n\t\t\t\t\t    ((unsigned)flags >> 24)))\n\t\t    continue;\n\n\t\t// If there is a match with a CHECKCOMPOUNDPATTERN rule\n\t\t// discard the compound word.\n\t\tif (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))\n\t\t    continue;\n\n\t\tif (mode == FIND_COMPOUND)\n\t\t{\n\t\t    int\t    capflags;\n\n\t\t    // Need to check the caps type of the appended compound\n\t\t    // word.\n\t\t    if (has_mbyte && STRNCMP(ptr, mip->mi_word,\n\t\t\t\t\t\t\tmip->mi_compoff) != 0)\n\t\t    {\n\t\t\t// case folding may have changed the length\n\t\t\tp = mip->mi_word;\n\t\t\tfor (s = ptr; s < ptr + mip->mi_compoff; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t    }\n\t\t    else\n\t\t\tp = mip->mi_word + mip->mi_compoff;\n\t\t    capflags = captype(p, mip->mi_word + wlen);\n\t\t    if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP\n\t\t\t\t\t\t && (flags & WF_FIXCAP) != 0))\n\t\t\tcontinue;\n\n\t\t    if (capflags != WF_ALLCAP)\n\t\t    {\n\t\t\t// When the character before the word is a word\n\t\t\t// character we do not accept a Onecap word.  We do\n\t\t\t// accept a no-caps word, even when the dictionary\n\t\t\t// word specifies ONECAP.\n\t\t\tMB_PTR_BACK(mip->mi_word, p);\n\t\t\tif (spell_iswordp_nmw(p, mip->mi_win)\n\t\t\t\t? capflags == WF_ONECAP\n\t\t\t\t: (flags & WF_ONECAP) != 0\n\t\t\t\t\t\t     && capflags != WF_ONECAP)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\t// If the word ends the sequence of compound flags of the\n\t\t// words must match with one of the COMPOUNDRULE items and\n\t\t// the number of syllables must not be too large.\n\t\tmip->mi_compflags[mip->mi_complen] = ((unsigned)flags >> 24);\n\t\tmip->mi_compflags[mip->mi_complen + 1] = NUL;\n\t\tif (word_ends)\n\t\t{\n\t\t    char_u\tfword[MAXWLEN];\n\n\t\t    if (slang->sl_compsylmax < MAXWLEN)\n\t\t    {\n\t\t\t// \"fword\" is only needed for checking syllables.\n\t\t\tif (ptr == mip->mi_word)\n\t\t\t    (void)spell_casefold(mip->mi_win,\n\t\t\t\t\t\t    ptr, wlen, fword, MAXWLEN);\n\t\t\telse\n\t\t\t    vim_strncpy(fword, ptr, endlen[endidxcnt]);\n\t\t    }\n\t\t    if (!can_compound(slang, fword, mip->mi_compflags))\n\t\t\tcontinue;\n\t\t}\n\t\telse if (slang->sl_comprules != NULL\n\t\t\t     && !match_compoundrule(slang, mip->mi_compflags))\n\t\t    // The compound flags collected so far do not match any\n\t\t    // COMPOUNDRULE, discard the compounded word.\n\t\t    continue;\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.\n\t    else if (flags & WF_NEEDCOMP)\n\t\tcontinue;\n\n\t    nobreak_result = SP_OK;\n\n\t    if (!word_ends)\n\t    {\n\t\tint\tsave_result = mip->mi_result;\n\t\tchar_u\t*save_end = mip->mi_end;\n\t\tlangp_T\t*save_lp = mip->mi_lp;\n\t\tint\tlpi;\n\n\t\t// Check that a valid word follows.  If there is one and we\n\t\t// are compounding, it will set \"mi_result\", thus we are\n\t\t// always finished here.  For NOBREAK we only check that a\n\t\t// valid word follows.\n\t\t// Recursive!\n\t\tif (slang->sl_nobreak)\n\t\t    mip->mi_result = SP_BAD;\n\n\t\t// Find following word in case-folded tree.\n\t\tmip->mi_compoff = endlen[endidxcnt];\n\t\tif (has_mbyte && mode == FIND_KEEPWORD)\n\t\t{\n\t\t    // Compute byte length in case-folded word from \"wlen\":\n\t\t    // byte length in keep-case word.  Length may change when\n\t\t    // folding case.  This can be slow, take a shortcut when\n\t\t    // the case-folded word is equal to the keep-case word.\n\t\t    p = mip->mi_fword;\n\t\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t\t    {\n\t\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t\tmip->mi_compoff = (int)(p - mip->mi_fword);\n\t\t    }\n\t\t}\n#if 0 // Disabled, see below\n\t\tc = mip->mi_compoff;\n#endif\n\t\t++mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    ++mip->mi_compextra;\n\n\t\t// For NOBREAK we need to try all NOBREAK languages, at least\n\t\t// to find the \".add\" file(s).\n\t\tfor (lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi)\n\t\t{\n\t\t    if (slang->sl_nobreak)\n\t\t    {\n\t\t\tmip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);\n\t\t\tif (mip->mi_lp->lp_slang->sl_fidxs == NULL\n\t\t\t\t\t || !mip->mi_lp->lp_slang->sl_nobreak)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    find_word(mip, FIND_COMPOUND);\n\n\t\t    // When NOBREAK any word that matches is OK.  Otherwise we\n\t\t    // need to find the longest match, thus try with keep-case\n\t\t    // and prefix too.\n\t\t    if (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t    {\n\t\t\t// Find following word in keep-case tree.\n\t\t\tmip->mi_compoff = wlen;\n\t\t\tfind_word(mip, FIND_KEEPCOMPOUND);\n\n#if 0\t    // Disabled, a prefix must not appear halfway a compound word,\n\t    // unless the COMPOUNDPERMITFLAG is used and then it can't be a\n\t    // postponed prefix.\n\t\t\tif (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t\t{\n\t\t\t    // Check for following word with prefix.\n\t\t\t    mip->mi_compoff = c;\n\t\t\t    find_prefix(mip, FIND_COMPOUND);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t    if (!slang->sl_nobreak)\n\t\t\tbreak;\n\t\t}\n\t\t--mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    --mip->mi_compextra;\n\t\tmip->mi_lp = save_lp;\n\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    nobreak_result = mip->mi_result;\n\t\t    mip->mi_result = save_result;\n\t\t    mip->mi_end = save_end;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (mip->mi_result == SP_OK)\n\t\t\tbreak;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    if (flags & WF_BANNED)\n\t\tres = SP_BANNED;\n\t    else if (flags & WF_REGION)\n\t    {\n\t\t// Check region.\n\t\tif ((mip->mi_lp->lp_region & (flags >> 16)) != 0)\n\t\t    res = SP_OK;\n\t\telse\n\t\t    res = SP_LOCAL;\n\t    }\n\t    else if (flags & WF_RARE)\n\t\tres = SP_RARE;\n\t    else\n\t\tres = SP_OK;\n\n\t    // Always use the longest match and the best result.  For NOBREAK\n\t    // we separately keep the longest match without a following good\n\t    // word as a fall-back.\n\t    if (nobreak_result == SP_BAD)\n\t    {\n\t\tif (mip->mi_result2 > res)\n\t\t{\n\t\t    mip->mi_result2 = res;\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t\t}\n\t\telse if (mip->mi_result2 == res\n\t\t\t\t\t&& mip->mi_end2 < mip->mi_word + wlen)\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result > res)\n\t    {\n\t\tmip->mi_result = res;\n\t\tmip->mi_end = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)\n\t\tmip->mi_end = mip->mi_word + wlen;\n\n\t    if (mip->mi_result == SP_OK)\n\t\tbreak;\n\t}\n\n\tif (mip->mi_result == SP_OK)\n\t    break;\n    }\n}\n\n/*\n * Return TRUE if there is a match between the word ptr[wlen] and\n * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another\n * word.\n * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the\n * end of ptr[wlen] and the second part matches after it.\n */\n    int\nmatch_checkcompoundpattern(\n    char_u\t*ptr,\n    int\t\twlen,\n    garray_T\t*gap)  // &sl_comppat\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n\n    for (i = 0; i + 1 < gap->ga_len; i += 2)\n    {\n\tp = ((char_u **)gap->ga_data)[i + 1];\n\tif (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)\n\t{\n\t    // Second part matches at start of following compound word, now\n\t    // check if first part matches at end of previous word.\n\t    p = ((char_u **)gap->ga_data)[i];\n\t    len = (int)STRLEN(p);\n\t    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"flags\" is a valid sequence of compound flags and \"word\"\n * does not have too many syllables.\n */\n    int\ncan_compound(slang_T *slang, char_u *word, char_u *flags)\n{\n    char_u\tuflags[MAXWLEN * 2];\n    int\t\ti;\n    char_u\t*p;\n\n    if (slang->sl_compprog == NULL)\n\treturn FALSE;\n    if (enc_utf8)\n    {\n\t// Need to convert the single byte flags to utf8 characters.\n\tp = uflags;\n\tfor (i = 0; flags[i] != NUL; ++i)\n\t    p += utf_char2bytes(flags[i], p);\n\t*p = NUL;\n\tp = uflags;\n    }\n    else\n\tp = flags;\n    if (!vim_regexec_prog(&slang->sl_compprog, FALSE, p, 0))\n\treturn FALSE;\n\n    // Count the number of syllables.  This may be slow, do it last.  If there\n    // are too many syllables AND the number of compound words is above\n    // COMPOUNDWORDMAX then compounding is not allowed.\n    if (slang->sl_compsylmax < MAXWLEN\n\t\t       && count_syllables(slang, word) > slang->sl_compsylmax)\n\treturn (int)STRLEN(flags) < slang->sl_compmax;\n    return TRUE;\n}\n\n/*\n * Return TRUE if the compound flags in compflags[] match the start of any\n * compound rule.  This is used to stop trying a compound if the flags\n * collected so far can't possibly match any compound rule.\n * Caller must check that slang->sl_comprules is not NULL.\n */\n    int\nmatch_compoundrule(slang_T *slang, char_u *compflags)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n\n    // loop over all the COMPOUNDRULE entries\n    for (p = slang->sl_comprules; *p != NUL; ++p)\n    {\n\t// loop over the flags in the compound word we have made, match\n\t// them against the current rule entry\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = compflags[i];\n\t    if (c == NUL)\n\t\t// found a rule that matches for the flags we have so far\n\t\treturn TRUE;\n\t    if (*p == '/' || *p == NUL)\n\t\tbreak;  // end of rule, it's too short\n\t    if (*p == '[')\n\t    {\n\t\tint match = FALSE;\n\n\t\t// compare against all the flags in []\n\t\t++p;\n\t\twhile (*p != ']' && *p != NUL)\n\t\t    if (*p++ == c)\n\t\t\tmatch = TRUE;\n\t\tif (!match)\n\t\t    break;  // none matches\n\t    }\n\t    else if (*p != c)\n\t\tbreak;  // flag of word doesn't match flag in pattern\n\t    ++p;\n\t}\n\n\t// Skip to the next \"/\", where the next pattern starts.\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    break;\n    }\n\n    // Checked all the rules and none of them match the flags, so there\n    // can't possibly be a compound starting with these flags.\n    return FALSE;\n}\n\n/*\n * Return non-zero if the prefix indicated by \"arridx\" matches with the prefix\n * ID in \"flags\" for the word \"word\".\n * The WF_RAREPFX flag is included in the return value for a rare prefix.\n */\n    int\nvalid_word_prefix(\n    int\t\ttotprefcnt,\t// nr of prefix IDs\n    int\t\tarridx,\t\t// idx in sl_pidxs[]\n    int\t\tflags,\n    char_u\t*word,\n    slang_T\t*slang,\n    int\t\tcond_req)\t// only use prefixes with a condition\n{\n    int\t\tprefcnt;\n    int\t\tpidx;\n    regprog_T\t**rp;\n    int\t\tprefid;\n\n    prefid = (unsigned)flags >> 24;\n    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)\n    {\n\tpidx = slang->sl_pidxs[arridx + prefcnt];\n\n\t// Check the prefix ID.\n\tif (prefid != (pidx & 0xff))\n\t    continue;\n\n\t// Check if the prefix doesn't combine and the word already has a\n\t// suffix.\n\tif ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n\t    continue;\n\n\t// Check the condition, if there is one.  The condition index is\n\t// stored in the two bytes above the prefix ID byte.\n\trp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n\tif (*rp != NULL)\n\t{\n\t    if (!vim_regexec_prog(rp, FALSE, word, 0))\n\t\tcontinue;\n\t}\n\telse if (cond_req)\n\t    continue;\n\n\t// It's a match!  Return the WF_ flags.\n\treturn pidx;\n    }\n    return 0;\n}\n\n/*\n * Check if the word at \"mip->mi_word\" has a matching prefix.\n * If it does, then check the following word.\n *\n * If \"mode\" is \"FIND_COMPOUND\" then do the same after another word, find a\n * prefix in a compound word.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_prefix(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    char_u\t*byts;\n    idx_T\t*idxs;\n\n    byts = slang->sl_pbyts;\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    // We use the case-folded word here, since prefixes are always\n    // case-folded.\n    ptr = mip->mi_fword;\n    flen = mip->mi_fwordlen;    // available case-folded bytes\n    if (mode == FIND_COMPOUND)\n    {\n\t// Skip over the previously found word(s).\n\tptr += mip->mi_compoff;\n\tflen -= mip->mi_compoff;\n    }\n    idxs = slang->sl_pidxs;\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen == 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the prefix could end here.\n\t// Check if the following word matches and supports the prefix.\n\tif (byts[arridx] == 0)\n\t{\n\t    // There can be several prefixes with different conditions.  We\n\t    // try them all, since we don't know which one will give the\n\t    // longest match.  The word is the same each time, pass the list\n\t    // of possible prefixes to find_word().\n\t    mip->mi_prefarridx = arridx;\n\t    mip->mi_prefcnt = len;\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    mip->mi_prefcnt -= len;\n\n\t    // Find the word that comes after the prefix.\n\t    mip->mi_prefixlen = wlen;\n\t    if (mode == FIND_COMPOUND)\n\t\t// Skip over the previously found word(s).\n\t\tmip->mi_prefixlen += mip->mi_compoff;\n\n\t    if (has_mbyte)\n\t    {\n\t\t// Case-folded length may differ from original length.\n\t\tmip->mi_cprefixlen = nofold_len(mip->mi_fword,\n\t\t\t\t\t     mip->mi_prefixlen, mip->mi_word);\n\t    }\n\t    else\n\t\tmip->mi_cprefixlen = mip->mi_prefixlen;\n\t    find_word(mip, FIND_PREFIX);\n\n\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n    }\n}\n\n/*\n * Need to fold at least one more character.  Do until next non-word character\n * for efficiency.  Include the non-word character too.\n * Return the length of the folded chars in bytes.\n */\n    static int\nfold_more(matchinf_T *mip)\n{\n    int\t\tflen;\n    char_u\t*p;\n\n    p = mip->mi_fend;\n    do\n\tMB_PTR_ADV(mip->mi_fend);\n    while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));\n\n    // Include the non-word character so that we can check for the word end.\n    if (*mip->mi_fend != NUL)\n\tMB_PTR_ADV(mip->mi_fend);\n\n    (void)spell_casefold(mip->mi_win, p, (int)(mip->mi_fend - p),\n\t\t\t     mip->mi_fword + mip->mi_fwordlen,\n\t\t\t     MAXWLEN - mip->mi_fwordlen);\n    flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);\n    mip->mi_fwordlen += flen;\n    return flen;\n}\n\n/*\n * Check case flags for a word.  Return TRUE if the word has the requested\n * case.\n */\n    int\nspell_valid_case(\n    int\t    wordflags,\t    // flags for the checked word.\n    int\t    treeflags)\t    // flags for the word in the spell tree\n{\n    return ((wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)\n\t    || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0\n\t\t&& ((treeflags & WF_ONECAP) == 0\n\t\t\t\t\t   || (wordflags & WF_ONECAP) != 0)));\n}\n\n/*\n * Return TRUE if spell checking is enabled for \"wp\".\n */\n    int\nspell_check_window(win_T *wp)\n{\n    return wp->w_p_spell\n\t\t&& *wp->w_s->b_p_spl != NUL\n\t\t&& wp->w_s->b_langp.ga_len > 0\n\t\t&& *(char **)(wp->w_s->b_langp.ga_data) != NULL;\n}\n\n/*\n * Return TRUE and give an error if spell checking is not enabled.\n */\n    static int\nno_spell_checking(win_T *wp)\n{\n    if (spell_check_window(wp))\n\treturn FALSE;\n    emsg(_(e_spell_checking_is_not_possible));\n    return TRUE;\n}\n\n/*\n * Move to next spell error.\n * \"curline\" is FALSE for \"[s\", \"]s\", \"[S\" and \"]S\".\n * \"curline\" is TRUE to find word under/after cursor in the same line.\n * For Insert mode completion \"dir\" is BACKWARD and \"curline\" is TRUE: move\n * to after badly spelled word before the cursor.\n * Return 0 if not found, length of the badly spelled word otherwise.\n */\n    int\nspell_move_to(\n    win_T\t*wp,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tallwords,\t// TRUE for \"[s\"/\"]s\", FALSE for \"[S\"/\"]S\"\n    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr = 0;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n    int\t\tfound_one = FALSE;\n    int\t\twrapped = FALSE;\n\n    if (no_spell_checking(wp))\n\treturn 0;\n\n    /*\n     * Start looking for bad word at the start of the line, because we can't\n     * start halfway a word, we don't know where it starts or ends.\n     *\n     * When searching backwards, we continue in the line to find the last\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tint empty_line;\n\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t}\n\n\t// In first line check first word for Capital.\n\tif (lnum == 1)\n\t    capcol = 0;\n\n\t// For checking first word with a capital skip white space.\n\tif (capcol == 0)\n\t    capcol = getwhitecols(line);\n\telse if (curline && wp == curwin)\n\t{\n\t    // For spellbadword(): check if first word needs a capital.\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.  Note: this ml_get_buf() may make \"line\" invalid, check\n\t// for empty line first.\n\tempty_line = *skipwhite(line) == NUL;\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // we wrapped around the end of the buffer.\n\t    if (dir == BACKWARD\n\t\t    && lnum == wp->w_cursor.lnum\n\t\t    && !wrapped\n\t\t    && (colnr_T)(p - buf) >= wp->w_cursor.col)\n\t\tbreak;\n\n\t    // start of word\n\t    attr = HLF_COUNT;\n\t    len = spell_check(wp, p, &attr, &capcol, FALSE);\n\n\t    if (attr != HLF_COUNT)\n\t    {\n\t\t// We found a bad word.  Check the attribute.\n\t\tif (allwords || attr == HLF_SPB)\n\t\t{\n\t\t    // When searching forward only accept a bad word after\n\t\t    // the cursor.\n\t\t    if (dir == BACKWARD\n\t\t\t    || lnum != wp->w_cursor.lnum\n\t\t\t    || (wrapped\n\t\t\t\t|| (colnr_T)(curline ? p - buf + len\n\t\t\t\t\t\t     : p - buf)\n\t\t\t\t\t\t  > wp->w_cursor.col))\n\t\t    {\n#ifdef FEAT_SYN_HL\n\t\t\tif (has_syntax)\n\t\t\t{\n\t\t\t    col = (int)(p - buf);\n\t\t\t    (void)syn_get_id(wp, lnum, (colnr_T)col,\n\t\t\t\t\t\t    FALSE, &can_spell, FALSE);\n\t\t\t    if (!can_spell)\n\t\t\t\tattr = HLF_COUNT;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    can_spell = TRUE;\n\n\t\t\tif (can_spell)\n\t\t\t{\n\t\t\t    found_one = TRUE;\n\t\t\t    found_pos.lnum = lnum;\n\t\t\t    found_pos.col = (int)(p - buf);\n\t\t\t    found_pos.coladd = 0;\n\t\t\t    if (dir == FORWARD)\n\t\t\t    {\n\t\t\t\t// No need to search further.\n\t\t\t\twp->w_cursor = found_pos;\n\t\t\t\tvim_free(buf);\n\t\t\t\tif (attrp != NULL)\n\t\t\t\t    *attrp = attr;\n\t\t\t\treturn len;\n\t\t\t    }\n\t\t\t    else if (curline)\n\t\t\t\t// Insert mode completion: put cursor after\n\t\t\t\t// the bad word.\n\t\t\t\tfound_pos.col += len;\n\t\t\t    found_len = len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfound_one = TRUE;\n\t\t}\n\t    }\n\n\t    // advance to character after the word\n\t    p += len;\n\t    capcol -= len;\n\t}\n\n\tif (dir == BACKWARD && found_pos.lnum != 0)\n\t{\n\t    // Use the last match in the line (before the cursor).\n\t    wp->w_cursor = found_pos;\n\t    vim_free(buf);\n\t    return found_len;\n\t}\n\n\tif (curline)\n\t    break;\t// only check cursor line\n\n\t// If we are back at the starting line and searched it again there\n\t// is no match, give up.\n\tif (lnum == wp->w_cursor.lnum && wrapped)\n\t    break;\n\n\t// Advance to next line.\n\tif (dir == BACKWARD)\n\t{\n\t    if (lnum > 1)\n\t\t--lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the end of the buffer.  May search the\n\t\t// starting line again and accept the last match.\n\t\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    capcol = -1;\n\t}\n\telse\n\t{\n\t    if (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t\t++lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the start of the buffer.  May search the\n\t\t// starting line again and accept the first match.\n\t\tlnum = 1;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\n\t    // If we are back at the starting line and there is no match then\n\t    // give up.\n\t    if (lnum == wp->w_cursor.lnum && !found_one)\n\t\tbreak;\n\n\t    // Skip the characters at the start of the next line that were\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (empty_line)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}\n\n/*\n * For spell checking: concatenate the start of the following line \"line\" into\n * \"buf\", blanking-out special characters.  Copy less than \"maxlen\" bytes.\n * Keep the blanks at the start of the next line, this is used in win_line()\n * to skip those bytes if the word was OK.\n */\n    void\nspell_cat_line(char_u *buf, char_u *line, int maxlen)\n{\n    char_u\t*p;\n    int\t\tn;\n\n    p = skipwhite(line);\n    while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)\n\tp = skipwhite(p + 1);\n\n    if (*p != NUL)\n    {\n\t// Only worth concatenating if there is something else than spaces to\n\t// concatenate.\n\tn = (int)(p - line) + 1;\n\tif (n < maxlen - 1)\n\t{\n\t    vim_memset(buf, ' ', n);\n\t    vim_strncpy(buf +  n, p, maxlen - 1 - n);\n\t}\n    }\n}\n\n/*\n * Structure used for the cookie argument of do_in_runtimepath().\n */\ntypedef struct spelload_S\n{\n    char_u  sl_lang[MAXWLEN + 1];\t// language name\n    slang_T *sl_slang;\t\t\t// resulting slang_T struct\n    int\t    sl_nobreak;\t\t\t// NOBREAK language found\n} spelload_T;\n\n/*\n * Load word list(s) for \"lang\" from Vim spell file(s).\n * \"lang\" must be the language without the region: e.g., \"en\".\n */\n    static void\nspell_load_lang(char_u *lang)\n{\n    char_u\tfname_enc[85];\n    int\t\tr;\n    spelload_T\tsl;\n    int\t\tround;\n\n    // Copy the language name to pass it to spell_load_cb() as a cookie.\n    // It's truncated when an error is detected.\n    STRCPY(sl.sl_lang, lang);\n    sl.sl_slang = NULL;\n    sl.sl_nobreak = FALSE;\n\n    // Disallow deleting the current buffer.  Autocommands can do weird things\n    // and cause \"lang\" to be freed.\n    ++curbuf->b_locked;\n\n    // We may retry when no spell file is found for the language, an\n    // autocommand may load it then.\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Find the first spell file for \"lang\" in 'runtimepath' and load it.\n\t */\n\tvim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\"spell/%s_%s.spl\",\n#else\n\t\t\t\t\t\"spell/%s.%s.spl\",\n#endif\n\t\t\t\t\t\t\t   lang, spell_enc());\n\tr = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\tif (r == FAIL && *sl.sl_lang != NUL)\n\t{\n\t    // Try loading the ASCII version.\n\t    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\t  \"spell/%s_ascii.spl\",\n#else\n\t\t\t\t\t\t  \"spell/%s.ascii.spl\",\n#endif\n\t\t\t\t\t\t\t\t\tlang);\n\t    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\t    if (r == FAIL && *sl.sl_lang != NUL && round == 1\n\t\t    && apply_autocmds(EVENT_SPELLFILEMISSING, lang,\n\t\t\t\t\t      curbuf->b_fname, FALSE, curbuf))\n\t\tcontinue;\n\t    break;\n\t}\n\tbreak;\n    }\n\n    if (r == FAIL)\n    {\n\tsmsg(\n#ifdef VMS\n\t_(\"Warning: Cannot find word list \\\"%s_%s.spl\\\" or \\\"%s_ascii.spl\\\"\"),\n#else\n\t_(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),\n#endif\n\t\t\t\t\t\t     lang, spell_enc(), lang);\n    }\n    else if (sl.sl_slang != NULL)\n    {\n\t// At least one file was loaded, now load ALL the additions.\n\tSTRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n\tdo_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl);\n    }\n\n    --curbuf->b_locked;\n}\n\n/*\n * Return the encoding used for spell checking: Use 'encoding', except that we\n * use \"latin1\" for \"latin9\".  And limit to 60 characters (just in case).\n */\n    char_u *\nspell_enc(void)\n{\n\n    if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)\n\treturn p_enc;\n    return (char_u *)\"latin1\";\n}\n\n/*\n * Get the name of the .spl file for the internal wordlist into\n * \"fname[MAXPATHL]\".\n */\n    static void\nint_wordlist_spl(char_u *fname)\n{\n    vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t\t\t\t\t  int_wordlist, spell_enc());\n}\n\n/*\n * Allocate a new slang_T for language \"lang\".  \"lang\" can be NULL.\n * Caller must fill \"sl_next\".\n */\n    slang_T *\nslang_alloc(char_u *lang)\n{\n    slang_T *lp;\n\n    lp = ALLOC_CLEAR_ONE(slang_T);\n    if (lp != NULL)\n    {\n\tif (lang != NULL)\n\t    lp->sl_name = vim_strsave(lang);\n\tga_init2(&lp->sl_rep, sizeof(fromto_T), 10);\n\tga_init2(&lp->sl_repsal, sizeof(fromto_T), 10);\n\tlp->sl_compmax = MAXWLEN;\n\tlp->sl_compsylmax = MAXWLEN;\n\thash_init(&lp->sl_wordcount);\n    }\n\n    return lp;\n}\n\n/*\n * Free the contents of an slang_T and the structure itself.\n */\n    void\nslang_free(slang_T *lp)\n{\n    vim_free(lp->sl_name);\n    vim_free(lp->sl_fname);\n    slang_clear(lp);\n    vim_free(lp);\n}\n\n/*\n * Clear an slang_T so that the file can be reloaded.\n */\n    void\nslang_clear(slang_T *lp)\n{\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    salitem_T\t*smp;\n    int\t\ti;\n    int\t\tround;\n\n    VIM_CLEAR(lp->sl_fbyts);\n    VIM_CLEAR(lp->sl_kbyts);\n    VIM_CLEAR(lp->sl_pbyts);\n\n    VIM_CLEAR(lp->sl_fidxs);\n    VIM_CLEAR(lp->sl_kidxs);\n    VIM_CLEAR(lp->sl_pidxs);\n\n    for (round = 1; round <= 2; ++round)\n    {\n\tgap = round == 1 ? &lp->sl_rep : &lp->sl_repsal;\n\twhile (gap->ga_len > 0)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(ftp->ft_from);\n\t    vim_free(ftp->ft_to);\n\t}\n\tga_clear(gap);\n    }\n\n    gap = &lp->sl_sal;\n    if (lp->sl_sofo)\n    {\n\t// \"ga_len\" is set to 1 without adding an item for latin1\n\tif (gap->ga_data != NULL)\n\t    // SOFOFROM and SOFOTO items: free lists of wide characters.\n\t    for (i = 0; i < gap->ga_len; ++i)\n\t\tvim_free(((int **)gap->ga_data)[i]);\n    }\n    else\n\t// SAL items: free salitem_T items\n\twhile (gap->ga_len > 0)\n\t{\n\t    smp = &((salitem_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(smp->sm_lead);\n\t    // Don't free sm_oneof and sm_rules, they point into sm_lead.\n\t    vim_free(smp->sm_to);\n\t    vim_free(smp->sm_lead_w);\n\t    vim_free(smp->sm_oneof_w);\n\t    vim_free(smp->sm_to_w);\n\t}\n    ga_clear(gap);\n\n    for (i = 0; i < lp->sl_prefixcnt; ++i)\n\tvim_regfree(lp->sl_prefprog[i]);\n    lp->sl_prefixcnt = 0;\n    VIM_CLEAR(lp->sl_prefprog);\n\n    VIM_CLEAR(lp->sl_info);\n\n    VIM_CLEAR(lp->sl_midword);\n\n    vim_regfree(lp->sl_compprog);\n    lp->sl_compprog = NULL;\n    VIM_CLEAR(lp->sl_comprules);\n    VIM_CLEAR(lp->sl_compstartflags);\n    VIM_CLEAR(lp->sl_compallflags);\n\n    VIM_CLEAR(lp->sl_syllable);\n    ga_clear(&lp->sl_syl_items);\n\n    ga_clear_strings(&lp->sl_comppat);\n\n    hash_clear_all(&lp->sl_wordcount, WC_KEY_OFF);\n    hash_init(&lp->sl_wordcount);\n\n    hash_clear_all(&lp->sl_map_hash, 0);\n\n    // Clear info from .sug file.\n    slang_clear_sug(lp);\n\n    lp->sl_compmax = MAXWLEN;\n    lp->sl_compminlen = 0;\n    lp->sl_compsylmax = MAXWLEN;\n    lp->sl_regions[0] = NUL;\n}\n\n/*\n * Clear the info from the .sug file in \"lp\".\n */\n    void\nslang_clear_sug(slang_T *lp)\n{\n    VIM_CLEAR(lp->sl_sbyts);\n    VIM_CLEAR(lp->sl_sidxs);\n    close_spellbuf(lp->sl_sugbuf);\n    lp->sl_sugbuf = NULL;\n    lp->sl_sugloaded = FALSE;\n    lp->sl_sugtime = 0;\n}\n\n/*\n * Load one spell file and store the info into a slang_T.\n * Invoked through do_in_runtimepath().\n */\n    static void\nspell_load_cb(char_u *fname, void *cookie)\n{\n    spelload_T\t*slp = (spelload_T *)cookie;\n    slang_T\t*slang;\n\n    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);\n    if (slang != NULL)\n    {\n\t// When a previously loaded file has NOBREAK also use it for the\n\t// \".add\" files.\n\tif (slp->sl_nobreak && slang->sl_add)\n\t    slang->sl_nobreak = TRUE;\n\telse if (slang->sl_nobreak)\n\t    slp->sl_nobreak = TRUE;\n\n\tslp->sl_slang = slang;\n    }\n}\n\n\n/*\n * Add a word to the hashtable of common words.\n * If it's already there then the counter is increased.\n */\n    void\ncount_common_word(\n    slang_T\t*lp,\n    char_u\t*word,\n    int\t\tlen,\t    // word length, -1 for up to NUL\n    int\t\tcount)\t    // 1 to count once, 10 to init\n{\n    hash_T\thash;\n    hashitem_T\t*hi;\n    wordcount_T\t*wc;\n    char_u\tbuf[MAXWLEN];\n    char_u\t*p;\n\n    if (len == -1)\n\tp = word;\n    else if (len >= MAXWLEN)\n\treturn;\n    else\n    {\n\tvim_strncpy(buf, word, len);\n\tp = buf;\n    }\n\n    hash = hash_hash(p);\n    hi = hash_lookup(&lp->sl_wordcount, p, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\twc = alloc(sizeof(wordcount_T) + STRLEN(p));\n\tif (wc == NULL)\n\t    return;\n\tSTRCPY(wc->wc_word, p);\n\twc->wc_count = count;\n\thash_add_item(&lp->sl_wordcount, hi, wc->wc_word, hash);\n    }\n    else\n    {\n\twc = HI2WC(hi);\n\tif ((wc->wc_count += count) < (unsigned)count)\t// check for overflow\n\t    wc->wc_count = MAXWORDCOUNT;\n    }\n}\n\n/*\n * Return TRUE if byte \"n\" appears in \"str\".\n * Like strchr() but independent of locale.\n */\n    int\nbyte_in_str(char_u *str, int n)\n{\n    char_u\t*p;\n\n    for (p = str; *p != NUL; ++p)\n\tif (*p == n)\n\t    return TRUE;\n    return FALSE;\n}\n\n#define SY_MAXLEN   30\ntypedef struct syl_item_S\n{\n    char_u\tsy_chars[SY_MAXLEN];\t    // the sequence of chars\n    int\t\tsy_len;\n} syl_item_T;\n\n/*\n * Truncate \"slang->sl_syllable\" at the first slash and put the following items\n * in \"slang->sl_syl_items\".\n */\n    int\ninit_syl_tab(slang_T *slang)\n{\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tl;\n    syl_item_T\t*syl;\n\n    ga_init2(&slang->sl_syl_items, sizeof(syl_item_T), 4);\n    p = vim_strchr(slang->sl_syllable, '/');\n    while (p != NULL)\n    {\n\t*p++ = NUL;\n\tif (*p == NUL)\t    // trailing slash\n\t    break;\n\ts = p;\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    l = (int)STRLEN(s);\n\telse\n\t    l = (int)(p - s);\n\tif (l >= SY_MAXLEN)\n\t    return SP_FORMERROR;\n\tif (ga_grow(&slang->sl_syl_items, 1) == FAIL)\n\t    return SP_OTHERERROR;\n\tsyl = ((syl_item_T *)slang->sl_syl_items.ga_data)\n\t\t\t\t\t       + slang->sl_syl_items.ga_len++;\n\tvim_strncpy(syl->sy_chars, s, l);\n\tsyl->sy_len = l;\n    }\n    return OK;\n}\n\n/*\n * Count the number of syllables in \"word\".\n * When \"word\" contains spaces the syllables after the last space are counted.\n * Returns zero if syllables are not defines.\n */\n    static int\ncount_syllables(slang_T *slang, char_u *word)\n{\n    int\t\tcnt = 0;\n    int\t\tskip = FALSE;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ti;\n    syl_item_T\t*syl;\n    int\t\tc;\n\n    if (slang->sl_syllable == NULL)\n\treturn 0;\n\n    for (p = word; *p != NUL; p += len)\n    {\n\t// When running into a space reset counter.\n\tif (*p == ' ')\n\t{\n\t    len = 1;\n\t    cnt = 0;\n\t    continue;\n\t}\n\n\t// Find longest match of syllable items.\n\tlen = 0;\n\tfor (i = 0; i < slang->sl_syl_items.ga_len; ++i)\n\t{\n\t    syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;\n\t    if (syl->sy_len > len\n\t\t\t       && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)\n\t\tlen = syl->sy_len;\n\t}\n\tif (len != 0)\t// found a match, count syllable\n\t{\n\t    ++cnt;\n\t    skip = FALSE;\n\t}\n\telse\n\t{\n\t    // No recognized syllable item, at least a syllable char then?\n\t    c = mb_ptr2char(p);\n\t    len = (*mb_ptr2len)(p);\n\t    if (vim_strchr(slang->sl_syllable, c) == NULL)\n\t\tskip = FALSE;\t    // No, search for next syllable\n\t    else if (!skip)\n\t    {\n\t\t++cnt;\t\t    // Yes, count it\n\t\tskip = TRUE;\t    // don't count following syllable chars\n\t    }\n\t}\n    }\n    return cnt;\n}\n\n/*\n * Parse 'spelllang' and set w_s->b_langp accordingly.\n * Returns NULL if it's OK, an untranslated error message otherwise.\n */\n    char *\ndid_set_spelllang(win_T *wp)\n{\n    garray_T\tga;\n    char_u\t*splp;\n    char_u\t*region;\n    char_u\tregion_cp[3];\n    int\t\tfilename;\n    int\t\tregion_mask;\n    slang_T\t*slang;\n    int\t\tc;\n    char_u\tlang[MAXWLEN + 1];\n    char_u\tspf_name[MAXPATHL];\n    int\t\tlen;\n    char_u\t*p;\n    int\t\tround;\n    char_u\t*spf;\n    char_u\t*use_region = NULL;\n    int\t\tdont_use_region = FALSE;\n    int\t\tnobreak = FALSE;\n    int\t\ti, j;\n    langp_T\t*lp, *lp2;\n    static int\trecursive = FALSE;\n    char\t*ret_msg = NULL;\n    char_u\t*spl_copy;\n    bufref_T\tbufref;\n\n    set_bufref(&bufref, wp->w_buffer);\n\n    // We don't want to do this recursively.  May happen when a language is\n    // not available and the SpellFileMissing autocommand opens a new buffer\n    // in which 'spell' is set.\n    if (recursive)\n\treturn NULL;\n    recursive = TRUE;\n\n    ga_init2(&ga, sizeof(langp_T), 2);\n    clear_midword(wp);\n\n    // Make a copy of 'spelllang', the SpellFileMissing autocommands may change\n    // it under our fingers.\n    spl_copy = vim_strsave(wp->w_s->b_p_spl);\n    if (spl_copy == NULL)\n\tgoto theend;\n\n    wp->w_s->b_cjk = 0;\n\n    // Loop over comma separated language names.\n    for (splp = spl_copy; *splp != NUL; )\n    {\n\t// Get one language name.\n\tcopy_option_part(&splp, lang, MAXWLEN, \",\");\n\tregion = NULL;\n\tlen = (int)STRLEN(lang);\n\n\tif (!valid_spelllang(lang))\n\t    continue;\n\n\tif (STRCMP(lang, \"cjk\") == 0)\n\t{\n\t    wp->w_s->b_cjk = 1;\n\t    continue;\n\t}\n\n\t// If the name ends in \".spl\" use it as the name of the spell file.\n\t// If there is a region name let \"region\" point to it and remove it\n\t// from the name.\n\tif (len > 4 && fnamecmp(lang + len - 4, \".spl\") == 0)\n\t{\n\t    filename = TRUE;\n\n\t    // Locate a region and remove it from the file name.\n\t    p = vim_strchr(gettail(lang), '_');\n\t    if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2])\n\t\t\t\t\t\t      && !ASCII_ISALPHA(p[3]))\n\t    {\n\t\tvim_strncpy(region_cp, p + 1, 2);\n\t\tmch_memmove(p, p + 3, len - (p - lang) - 2);\n\t\tregion = region_cp;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t\t    break;\n\t}\n\telse\n\t{\n\t    filename = FALSE;\n\t    if (len > 3 && lang[len - 3] == '_')\n\t    {\n\t\tregion = lang + len - 2;\n\t\tlen -= 3;\n\t\tlang[len] = NUL;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (STRICMP(lang, slang->sl_name) == 0)\n\t\t    break;\n\t}\n\n\tif (region != NULL)\n\t{\n\t    // If the region differs from what was used before then don't\n\t    // use it for 'spellfile'.\n\t    if (use_region != NULL && STRCMP(region, use_region) != 0)\n\t\tdont_use_region = TRUE;\n\t    use_region = region;\n\t}\n\n\t// If not found try loading the language now.\n\tif (slang == NULL)\n\t{\n\t    if (filename)\n\t\t(void)spell_load_file(lang, lang, NULL, FALSE);\n\t    else\n\t    {\n\t\tspell_load_lang(lang);\n\t\t// SpellFileMissing autocommands may do anything, including\n\t\t// destroying the buffer we are using...\n\t\tif (!bufref_valid(&bufref))\n\t\t{\n\t\t    ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer);\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Loop over the languages, there can be several files for \"lang\".\n\t */\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t    == FPC_SAME\n\t\t\t : STRICMP(lang, slang->sl_name) == 0)\n\t    {\n\t\tregion_mask = REGION_ALL;\n\t\tif (!filename && region != NULL)\n\t\t{\n\t\t    // find region in sl_regions\n\t\t    c = find_region(slang->sl_regions, region);\n\t\t    if (c == REGION_ALL)\n\t\t    {\n\t\t\tif (slang->sl_add)\n\t\t\t{\n\t\t\t    if (*slang->sl_regions != NUL)\n\t\t\t\t// This addition file is for other regions.\n\t\t\t\tregion_mask = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t    // This is probably an error.  Give a warning and\n\t\t\t    // accept the words anyway.\n\t\t\t    smsg(_(\"Warning: region %s not supported\"),\n\t\t\t\t\t\t\t\t      region);\n\t\t    }\n\t\t    else\n\t\t\tregion_mask = 1 << c;\n\t\t}\n\n\t\tif (region_mask != 0)\n\t\t{\n\t\t    if (ga_grow(&ga, 1) == FAIL)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tret_msg = e_out_of_memory;\n\t\t\tgoto theend;\n\t\t    }\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t    ++ga.ga_len;\n\t\t    use_midword(slang, wp);\n\t\t    if (slang->sl_nobreak)\n\t\t\tnobreak = TRUE;\n\t\t}\n\t    }\n    }\n\n    // round 0: load int_wordlist, if possible.\n    // round 1: load first name in 'spellfile'.\n    // round 2: load second name in 'spellfile.\n    // etc.\n    spf = curwin->w_s->b_p_spf;\n    for (round = 0; round == 0 || *spf != NUL; ++round)\n    {\n\tif (round == 0)\n\t{\n\t    // Internal wordlist, if there is one.\n\t    if (int_wordlist == NULL)\n\t\tcontinue;\n\t    int_wordlist_spl(spf_name);\n\t}\n\telse\n\t{\n\t    // One entry in 'spellfile'.\n\t    copy_option_part(&spf, spf_name, MAXPATHL - 5, \",\");\n\t    STRCAT(spf_name, \".spl\");\n\n\t    // If it was already found above then skip it.\n\t    for (c = 0; c < ga.ga_len; ++c)\n\t    {\n\t\tp = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;\n\t\tif (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\t    break;\n\t    }\n\t    if (c < ga.ga_len)\n\t\tcontinue;\n\t}\n\n\t// Check if it was loaded already.\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\tbreak;\n\tif (slang == NULL)\n\t{\n\t    // Not loaded, try loading it now.  The language name includes the\n\t    // region name, the region is ignored otherwise.  for int_wordlist\n\t    // use an arbitrary name.\n\t    if (round == 0)\n\t\tSTRCPY(lang, \"internal wordlist\");\n\t    else\n\t    {\n\t\tvim_strncpy(lang, gettail(spf_name), MAXWLEN);\n\t\tp = vim_strchr(lang, '.');\n\t\tif (p != NULL)\n\t\t    *p = NUL;\t// truncate at \".encoding.add\"\n\t    }\n\t    slang = spell_load_file(spf_name, lang, NULL, TRUE);\n\n\t    // If one of the languages has NOBREAK we assume the addition\n\t    // files also have this.\n\t    if (slang != NULL && nobreak)\n\t\tslang->sl_nobreak = TRUE;\n\t}\n\tif (slang != NULL && ga_grow(&ga, 1) == OK)\n\t{\n\t    region_mask = REGION_ALL;\n\t    if (use_region != NULL && !dont_use_region)\n\t    {\n\t\t// find region in sl_regions\n\t\tc = find_region(slang->sl_regions, use_region);\n\t\tif (c != REGION_ALL)\n\t\t    region_mask = 1 << c;\n\t\telse if (*slang->sl_regions != NUL)\n\t\t    // This spell file is for other regions.\n\t\t    region_mask = 0;\n\t    }\n\n\t    if (region_mask != 0)\n\t    {\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t++ga.ga_len;\n\t\tuse_midword(slang, wp);\n\t    }\n\t}\n    }\n\n    // Everything is fine, store the new b_langp value.\n    ga_clear(&wp->w_s->b_langp);\n    wp->w_s->b_langp = ga;\n\n    // For each language figure out what language to use for sound folding and\n    // REP items.  If the language doesn't support it itself use another one\n    // with the same name.  E.g. for \"en-math\" use \"en\".\n    for (i = 0; i < ga.ga_len; ++i)\n    {\n\tlp = LANGP_ENTRY(ga, i);\n\n\t// sound folding\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t    // language does sound folding itself\n\t    lp->lp_sallang = lp->lp_slang;\n\telse\n\t    // find first similar language that does sound folding\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_sal.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_sallang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n\n\t// REP items\n\tif (lp->lp_slang->sl_rep.ga_len > 0)\n\t    // language has REP items itself\n\t    lp->lp_replang = lp->lp_slang;\n\telse\n\t    // find first similar language that has REP items\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_rep.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_replang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n\ntheend:\n    vim_free(spl_copy);\n    recursive = FALSE;\n    return ret_msg;\n}\n\n/*\n * Clear the midword characters for buffer \"buf\".\n */\n    static void\nclear_midword(win_T *wp)\n{\n    CLEAR_FIELD(wp->w_s->b_spell_ismw);\n    VIM_CLEAR(wp->w_s->b_spell_ismw_mb);\n}\n\n/*\n * Use the \"sl_midword\" field of language \"lp\" for buffer \"buf\".\n * They add up to any currently used midword characters.\n */\n    static void\nuse_midword(slang_T *lp, win_T *wp)\n{\n    char_u\t*p;\n\n    if (lp->sl_midword == NULL)\t    // there aren't any\n\treturn;\n\n    for (p = lp->sl_midword; *p != NUL; )\n\tif (has_mbyte)\n\t{\n\t    int\t    c, l, n;\n\t    char_u  *bp;\n\n\t    c = mb_ptr2char(p);\n\t    l = (*mb_ptr2len)(p);\n\t    if (c < 256 && l <= 2)\n\t\twp->w_s->b_spell_ismw[c] = TRUE;\n\t    else if (wp->w_s->b_spell_ismw_mb == NULL)\n\t\t// First multi-byte char in \"b_spell_ismw_mb\".\n\t\twp->w_s->b_spell_ismw_mb = vim_strnsave(p, l);\n\t    else\n\t    {\n\t\t// Append multi-byte chars to \"b_spell_ismw_mb\".\n\t\tn = (int)STRLEN(wp->w_s->b_spell_ismw_mb);\n\t\tbp = vim_strnsave(wp->w_s->b_spell_ismw_mb, n + l);\n\t\tif (bp != NULL)\n\t\t{\n\t\t    vim_free(wp->w_s->b_spell_ismw_mb);\n\t\t    wp->w_s->b_spell_ismw_mb = bp;\n\t\t    vim_strncpy(bp + n, p, l);\n\t\t}\n\t    }\n\t    p += l;\n\t}\n\telse\n\t    wp->w_s->b_spell_ismw[*p++] = TRUE;\n}\n\n/*\n * Find the region \"region[2]\" in \"rp\" (points to \"sl_regions\").\n * Each region is simply stored as the two characters of its name.\n * Returns the index if found (first is 0), REGION_ALL if not found.\n */\n    static int\nfind_region(char_u *rp, char_u *region)\n{\n    int\t\ti;\n\n    for (i = 0; ; i += 2)\n    {\n\tif (rp[i] == NUL)\n\t    return REGION_ALL;\n\tif (rp[i] == region[0] && rp[i + 1] == region[1])\n\t    break;\n    }\n    return i / 2;\n}\n\n/*\n * Return case type of word:\n * w word\t0\n * Word\t\tWF_ONECAP\n * W WORD\tWF_ALLCAP\n * WoRd\twOrd\tWF_KEEPCAP\n */\n    int\ncaptype(\n    char_u\t*word,\n    char_u\t*end)\t    // When NULL use up to NUL byte.\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tfirstcap;\n    int\t\tallcap;\n    int\t\tpast_second = FALSE;\t// past second word char\n\n    // find first letter\n    for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p))\n\tif (end == NULL ? *p == NUL : p >= end)\n\t    return 0;\t    // only non-word characters, illegal word\n    if (has_mbyte)\n\tc = mb_ptr2char_adv(&p);\n    else\n\tc = *p++;\n    firstcap = allcap = SPELL_ISUPPER(c);\n\n    /*\n     * Need to check all letters to find a word with mixed upper/lower.\n     * But a word with an upper char only at start is a ONECAP.\n     */\n    for ( ; end == NULL ? *p != NUL : p < end; MB_PTR_ADV(p))\n\tif (spell_iswordp_nmw(p, curwin))\n\t{\n\t    c = PTR2CHAR(p);\n\t    if (!SPELL_ISUPPER(c))\n\t    {\n\t\t// UUl -> KEEPCAP\n\t\tif (past_second && allcap)\n\t\t    return WF_KEEPCAP;\n\t\tallcap = FALSE;\n\t    }\n\t    else if (!allcap)\n\t\t// UlU -> KEEPCAP\n\t\treturn WF_KEEPCAP;\n\t    past_second = TRUE;\n\t}\n\n    if (allcap)\n\treturn WF_ALLCAP;\n    if (firstcap)\n\treturn WF_ONECAP;\n    return 0;\n}\n\n/*\n * Delete the internal wordlist and its .spl file.\n */\n    void\nspell_delete_wordlist(void)\n{\n    char_u\tfname[MAXPATHL];\n\n    if (int_wordlist != NULL)\n    {\n\tmch_remove(int_wordlist);\n\tint_wordlist_spl(fname);\n\tmch_remove(fname);\n\tVIM_CLEAR(int_wordlist);\n    }\n}\n\n/*\n * Free all languages.\n */\n    void\nspell_free_all(void)\n{\n    slang_T\t*slang;\n    buf_T\t*buf;\n\n    // Go through all buffers and handle 'spelllang'. <VN>\n    FOR_ALL_BUFFERS(buf)\n\tga_clear(&buf->b_s.b_langp);\n\n    while (first_lang != NULL)\n    {\n\tslang = first_lang;\n\tfirst_lang = slang->sl_next;\n\tslang_free(slang);\n    }\n\n    spell_delete_wordlist();\n\n    VIM_CLEAR(repl_to);\n    VIM_CLEAR(repl_from);\n}\n\n/*\n * Clear all spelling tables and reload them.\n * Used after 'encoding' is set and when \":mkspell\" was used.\n */\n    void\nspell_reload(void)\n{\n    win_T\t*wp;\n\n    // Initialize the table for spell_iswordp().\n    init_spell_chartab();\n\n    // Unload all allocated memory.\n    spell_free_all();\n\n    // Go through all buffers and handle 'spelllang'.\n    FOR_ALL_WINDOWS(wp)\n    {\n\t// Only load the wordlists when 'spelllang' is set and there is a\n\t// window for this buffer in which 'spell' is set.\n\tif (*wp->w_s->b_p_spl != NUL)\n\t{\n\t\tif (wp->w_p_spell)\n\t\t{\n\t\t    (void)did_set_spelllang(wp);\n\t\t    break;\n\t\t}\n\t}\n    }\n}\n\n/*\n * Open a spell buffer.  This is a nameless buffer that is not in the buffer\n * list and only contains text lines.  Can use a swapfile to reduce memory\n * use.\n * Most other fields are invalid!  Esp. watch out for string options being\n * NULL and there is no undo info.\n * Returns NULL when out of memory.\n */\n    buf_T *\nopen_spellbuf(void)\n{\n    buf_T\t*buf;\n\n    buf = ALLOC_CLEAR_ONE(buf_T);\n    if (buf != NULL)\n    {\n\tbuf->b_spell = TRUE;\n\tbuf->b_p_swf = TRUE;\t// may create a swap file\n#ifdef FEAT_CRYPT\n\tbuf->b_p_key = empty_option;\n#endif\n\tml_open(buf);\n\tml_open_file(buf);\t// create swap file now\n    }\n    return buf;\n}\n\n/*\n * Close the buffer used for spell info.\n */\n    void\nclose_spellbuf(buf_T *buf)\n{\n    if (buf != NULL)\n    {\n\tml_close(buf, TRUE);\n\tvim_free(buf);\n    }\n}\n\n/*\n * Init the chartab used for spelling for ASCII.\n */\n    void\nclear_spell_chartab(spelltab_T *sp)\n{\n    int\t\ti;\n\n    // Init everything to FALSE (zero).\n    CLEAR_FIELD(sp->st_isw);\n    CLEAR_FIELD(sp->st_isu);\n    for (i = 0; i < 256; ++i)\n    {\n\tsp->st_fold[i] = i;\n\tsp->st_upper[i] = i;\n    }\n\n    // We include digits.  A word shouldn't start with a digit, but handling\n    // that is done separately.\n    for (i = '0'; i <= '9'; ++i)\n\tsp->st_isw[i] = TRUE;\n    for (i = 'A'; i <= 'Z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_isu[i] = TRUE;\n\tsp->st_fold[i] = i + 0x20;\n    }\n    for (i = 'a'; i <= 'z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_upper[i] = i - 0x20;\n    }\n}\n\n/*\n * Init the chartab used for spelling.  Only depends on 'encoding'.\n * Called once while starting up and when 'encoding' changes.\n * The default is to use isalpha(), but the spell file should define the word\n * characters to make it possible that 'encoding' differs from the current\n * locale.  For utf-8 we don't use isalpha() but our own functions.\n */\n    void\ninit_spell_chartab(void)\n{\n    int\t    i;\n\n    did_set_spelltab = FALSE;\n    clear_spell_chartab(&spelltab);\n    if (enc_dbcs)\n    {\n\t// DBCS: assume double-wide characters are word characters.\n\tfor (i = 128; i <= 255; ++i)\n\t    if (MB_BYTE2LEN(i) == 2)\n\t\tspelltab.st_isw[i] = TRUE;\n    }\n    else if (enc_utf8)\n    {\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    int f = utf_fold(i);\n\t    int u = utf_toupper(i);\n\n\t    spelltab.st_isu[i] = utf_isupper(i);\n\t    spelltab.st_isw[i] = spelltab.st_isu[i] || utf_islower(i);\n\t    // The folded/upper-cased value is different between latin1 and\n\t    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1\n\t    // value for utf-8 to avoid this.\n\t    spelltab.st_fold[i] = (f < 256) ? f : i;\n\t    spelltab.st_upper[i] = (u < 256) ? u : i;\n\t}\n    }\n    else\n    {\n\t// Rough guess: use locale-dependent library functions.\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (MB_ISUPPER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_isu[i] = TRUE;\n\t\tspelltab.st_fold[i] = MB_TOLOWER(i);\n\t    }\n\t    else if (MB_ISLOWER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_upper[i] = MB_TOUPPER(i);\n\t    }\n\t}\n    }\n}\n\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * As a special case we see \"midword\" characters as word character when it is\n * followed by a word character.  This finds they'there but not 'they there'.\n * Thus this only works properly when past the first character of the word.\n */\n    int\nspell_iswordp(\n    char_u\t*p,\n    win_T\t*wp)\t    // buffer used\n{\n    char_u\t*s;\n    int\t\tl;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tl = mb_ptr2len(p);\n\ts = p;\n\tif (l == 1)\n\t{\n\t    // be quick for ASCII\n\t    if (wp->w_s->b_spell_ismw[*p])\n\t\ts = p + 1;\t\t// skip a mid-word character\n\t}\n\telse\n\t{\n\t    c = mb_ptr2char(p);\n\t    if (c < 256 ? wp->w_s->b_spell_ismw[c]\n\t\t    : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t   && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL))\n\t\ts = p + l;\n\t}\n\n\tc = mb_ptr2char(s);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(s), wp);\n\treturn spelltab.st_isw[c];\n    }\n\n    return spelltab.st_isw[wp->w_s->b_spell_ismw[*p] ? p[1] : p[0]];\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Unlike spell_iswordp() this doesn't check for \"midword\" characters.\n */\n    int\nspell_iswordp_nmw(char_u *p, win_T *wp)\n{\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tc = mb_ptr2char(p);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(p), wp);\n\treturn spelltab.st_isw[c];\n    }\n    return spelltab.st_isw[*p];\n}\n\n/*\n * Return TRUE if word class indicates a word character.\n * Only for characters above 255.\n * Unicode subscript and superscript are not considered word characters.\n * See also dbcs_class() and utf_class() in mbyte.c.\n */\n    static int\nspell_mb_isword_class(int cl, win_T *wp)\n{\n    if (wp->w_s->b_cjk)\n\t// East Asian characters are not considered word characters.\n\treturn cl == 2 || cl == 0x2800;\n    return cl >= 2 && cl != 0x2070 && cl != 0x2080 && cl != 3;\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Wide version of spell_iswordp().\n */\n    static int\nspell_iswordp_w(int *p, win_T *wp)\n{\n    int\t\t*s;\n\n    if (*p < 256 ? wp->w_s->b_spell_ismw[*p]\n\t\t : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t     && vim_strchr(wp->w_s->b_spell_ismw_mb, *p) != NULL))\n\ts = p + 1;\n    else\n\ts = p;\n\n    if (*s > 255)\n    {\n\tif (enc_utf8)\n\t    return spell_mb_isword_class(utf_class(*s), wp);\n\tif (enc_dbcs)\n\t    return spell_mb_isword_class(\n\t\t\t\tdbcs_class((unsigned)*s >> 8, *s & 0xff), wp);\n\treturn 0;\n    }\n    return spelltab.st_isw[*s];\n}\n\n/*\n * Case-fold \"str[len]\" into \"buf[buflen]\".  The result is NUL terminated.\n * Uses the character definitions from the .spl file.\n * When using a multi-byte 'encoding' the length may change!\n * Returns FAIL when something wrong.\n */\n    int\nspell_casefold(\n    win_T\t*wp,\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    int\t\ti;\n\n    if (len >= buflen)\n    {\n\tbuf[0] = NUL;\n\treturn FAIL;\t\t// result will not fit\n    }\n\n    if (has_mbyte)\n    {\n\tint\touti = 0;\n\tchar_u\t*p;\n\tint\tc;\n\n\t// Fold one character at a time.\n\tfor (p = str; p < str + len; )\n\t{\n\t    if (outi + MB_MAXBYTES > buflen)\n\t    {\n\t\tbuf[outi] = NUL;\n\t\treturn FAIL;\n\t    }\n\t    c = mb_cptr2char_adv(&p);\n\n\t    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except\n\t    // when it is the last character in a word, then it folds to\n\t    // 0x03C2.\n\t    if (c == 0x03a3 || c == 0x03c2)\n\t    {\n\t\tif (p == str + len || !spell_iswordp(p, wp))\n\t\t    c = 0x03c2;\n\t\telse\n\t\t    c = 0x03c3;\n\t    }\n\t    else\n\t\tc = SPELL_TOFOLD(c);\n\n\t    outi += mb_char2bytes(c, buf + outi);\n\t}\n\tbuf[outi] = NUL;\n    }\n    else\n    {\n\t// Be quick for non-multibyte encodings.\n\tfor (i = 0; i < len; ++i)\n\t    buf[i] = spelltab.st_fold[str[i]];\n\tbuf[i] = NUL;\n    }\n\n    return OK;\n}\n\n/*\n * Check if the word at line \"lnum\" column \"col\" is required to start with a\n * capital.  This uses 'spellcapcheck' of the current buffer.\n */\n    int\ncheck_need_cap(linenr_T lnum, colnr_T col)\n{\n    int\t\tneed_cap = FALSE;\n    char_u\t*line;\n    char_u\t*line_copy = NULL;\n    char_u\t*p;\n    colnr_T\tendcol;\n    regmatch_T\tregmatch;\n\n    if (curwin->w_s->b_cap_prog == NULL)\n\treturn FALSE;\n\n    line = ml_get_curline();\n    endcol = 0;\n    if (getwhitecols(line) >= (int)col)\n    {\n\t// At start of line, check if previous line is empty or sentence\n\t// ends there.\n\tif (lnum == 1)\n\t    need_cap = TRUE;\n\telse\n\t{\n\t    line = ml_get(lnum - 1);\n\t    if (*skipwhite(line) == NUL)\n\t\tneed_cap = TRUE;\n\t    else\n\t    {\n\t\t// Append a space in place of the line break.\n\t\tline_copy = concat_str(line, (char_u *)\" \");\n\t\tline = line_copy;\n\t\tendcol = (colnr_T)STRLEN(line);\n\t    }\n\t}\n    }\n    else\n\tendcol = col;\n\n    if (endcol > 0)\n    {\n\t// Check if sentence ends before the bad word.\n\tregmatch.regprog = curwin->w_s->b_cap_prog;\n\tregmatch.rm_ic = FALSE;\n\tp = line + endcol;\n\tfor (;;)\n\t{\n\t    MB_PTR_BACK(line, p);\n\t    if (p == line || spell_iswordp_nmw(p, curwin))\n\t\tbreak;\n\t    if (vim_regexec(&regmatch, p, 0)\n\t\t\t\t\t && regmatch.endp[0] == line + endcol)\n\t    {\n\t\tneed_cap = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tcurwin->w_s->b_cap_prog = regmatch.regprog;\n    }\n\n    vim_free(line_copy);\n\n    return need_cap;\n}\n\n\n/*\n * \":spellrepall\"\n */\n    void\nex_spellrepall(exarg_T *eap UNUSED)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*frompat;\n    int\t\taddlen;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tsave_ws = p_ws;\n    linenr_T\tprev_lnum = 0;\n\n    if (repl_from == NULL || repl_to == NULL)\n    {\n\temsg(_(e_no_previous_spell_replacement));\n\treturn;\n    }\n    addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));\n\n    frompat = alloc(STRLEN(repl_from) + 7);\n    if (frompat == NULL)\n\treturn;\n    sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);\n    p_ws = FALSE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    curwin->w_cursor.lnum = 0;\n    while (!got_int)\n    {\n\tif (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0\n\t\t\t\t\t\t   || u_save_cursor() == FAIL)\n\t    break;\n\n\t// Only replace when the right word isn't there yet.  This happens\n\t// when changing \"etc\" to \"etc.\".\n\tline = ml_get_curline();\n\tif (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,\n\t\t\t\t\t       repl_to, STRLEN(repl_to)) != 0)\n\t{\n\t    p = alloc(STRLEN(line) + addlen + 1);\n\t    if (p == NULL)\n\t\tbreak;\n\t    mch_memmove(p, line, curwin->w_cursor.col);\n\t    STRCPY(p + curwin->w_cursor.col, repl_to);\n\t    STRCAT(p, line + curwin->w_cursor.col + STRLEN(repl_from));\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\t    if (curbuf->b_has_textprop && addlen != 0)\n\t\tadjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t\t curwin->w_cursor.col, addlen, APC_SUBSTITUTE);\n\n\t    if (curwin->w_cursor.lnum != prev_lnum)\n\t    {\n\t\t++sub_nlines;\n\t\tprev_lnum = curwin->w_cursor.lnum;\n\t    }\n\t    ++sub_nsubs;\n\t}\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(repl_to);\n    }\n\n    p_ws = save_ws;\n    curwin->w_cursor = pos;\n    vim_free(frompat);\n\n    if (sub_nsubs == 0)\n\tsemsg(_(e_not_found_str), repl_from);\n    else\n\tdo_sub_msg(FALSE);\n}\n\n/*\n * Make a copy of \"word\", with the first letter upper or lower cased, to\n * \"wcopy[MAXWLEN]\".  \"word\" must not be empty.\n * The result is NUL terminated.\n */\n    void\nonecap_copy(\n    char_u\t*word,\n    char_u\t*wcopy,\n    int\t\tupper)\t    // TRUE: first letter made upper case\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tl;\n\n    p = word;\n    if (has_mbyte)\n\tc = mb_cptr2char_adv(&p);\n    else\n\tc = *p++;\n    if (upper)\n\tc = SPELL_TOUPPER(c);\n    else\n\tc = SPELL_TOFOLD(c);\n    if (has_mbyte)\n\tl = mb_char2bytes(c, wcopy);\n    else\n    {\n\tl = 1;\n\twcopy[0] = c;\n    }\n    vim_strncpy(wcopy + l, p, MAXWLEN - l - 1);\n}\n\n/*\n * Make a copy of \"word\" with all the letters upper cased into\n * \"wcopy[MAXWLEN]\".  The result is NUL terminated.\n */\n    void\nallcap_copy(char_u *word, char_u *wcopy)\n{\n    char_u\t*s;\n    char_u\t*d;\n    int\t\tc;\n\n    d = wcopy;\n    for (s = word; *s != NUL; )\n    {\n\tif (has_mbyte)\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\n\t// We only change 0xdf to SS when we are certain latin1 is used.  It\n\t// would cause weird errors in other 8-bit encodings.\n\tif (enc_latin1like && c == 0xdf)\n\t{\n\t    c = 'S';\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n\telse\n\t    c = SPELL_TOUPPER(c);\n\n\tif (has_mbyte)\n\t{\n\t    if (d - wcopy >= MAXWLEN - MB_MAXBYTES)\n\t\tbreak;\n\t    d += mb_char2bytes(c, d);\n\t}\n\telse\n\t{\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n    }\n    *d = NUL;\n}\n\n/*\n * Case-folding may change the number of bytes: Count nr of chars in\n * fword[flen] and return the byte length of that many chars in \"word\".\n */\n    int\nnofold_len(char_u *fword, int flen, char_u *word)\n{\n    char_u\t*p;\n    int\t\ti = 0;\n\n    for (p = fword; p < fword + flen; MB_PTR_ADV(p))\n\t++i;\n    for (p = word; i > 0; MB_PTR_ADV(p))\n\t--i;\n    return (int)(p - word);\n}\n\n/*\n * Copy \"fword\" to \"cword\", fixing case according to \"flags\".\n */\n    void\nmake_case_word(char_u *fword, char_u *cword, int flags)\n{\n    if (flags & WF_ALLCAP)\n\t// Make it all upper-case\n\tallcap_copy(fword, cword);\n    else if (flags & WF_ONECAP)\n\t// Make the first letter upper-case\n\tonecap_copy(fword, cword, TRUE);\n    else\n\t// Use goodword as-is.\n\tSTRCPY(cword, fword);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Soundfold a string, for soundfold().\n * Result is in allocated memory, NULL for an error.\n */\n    char_u *\neval_soundfold(char_u *word)\n{\n    langp_T\t*lp;\n    char_u\tsound[MAXWLEN];\n    int\t\tlpi;\n\n    if (curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t// Use the sound-folding of the first language that supports it.\n\tfor (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n\t{\n\t    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\t    if (lp->lp_slang->sl_sal.ga_len > 0)\n\t    {\n\t\t// soundfold the word\n\t\tspell_soundfold(lp->lp_slang, word, FALSE, sound);\n\t\treturn vim_strsave(sound);\n\t    }\n\t}\n\n    // No language with sound folding, return word as-is.\n    return vim_strsave(word);\n}\n#endif\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n *\n * There are many ways to turn a word into a sound-a-like representation.  The\n * oldest is Soundex (1918!).   A nice overview can be found in \"Approximate\n * swedish name matching - survey and test of different algorithms\" by Klas\n * Erikson.\n *\n * We support two methods:\n * 1. SOFOFROM/SOFOTO do a simple character mapping.\n * 2. SAL items define a more advanced sound-folding (and much slower).\n */\n    void\nspell_soundfold(\n    slang_T\t*slang,\n    char_u\t*inword,\n    int\t\tfolded,\t    // \"inword\" is already case-folded\n    char_u\t*res)\n{\n    char_u\tfword[MAXWLEN];\n    char_u\t*word;\n\n    if (slang->sl_sofo)\n\t// SOFOFROM and SOFOTO used\n\tspell_soundfold_sofo(slang, inword, res);\n    else\n    {\n\t// SAL items used.  Requires the word to be case-folded.\n\tif (folded)\n\t    word = inword;\n\telse\n\t{\n\t    (void)spell_casefold(curwin,\n\t\t\t\t  inword, (int)STRLEN(inword), fword, MAXWLEN);\n\t    word = fword;\n\t}\n\n\tif (has_mbyte)\n\t    spell_soundfold_wsal(slang, word, res);\n\telse\n\t    spell_soundfold_sal(slang, word, res);\n    }\n}\n\n/*\n * Perform sound folding of \"inword\" into \"res\" according to SOFOFROM and\n * SOFOTO lines.\n */\n    static void\nspell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)\n{\n    char_u\t*s;\n    int\t\tri = 0;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tint\tprevc = 0;\n\tint\t*ip;\n\n\t// The sl_sal_first[] table contains the translation for chars up to\n\t// 255, sl_sal the rest.\n\tfor (s = inword; *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&s);\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else if (c < 256)\n\t\tc = slang->sl_sal_first[c];\n\t    else\n\t    {\n\t\tip = ((int **)slang->sl_sal.ga_data)[c & 0xff];\n\t\tif (ip == NULL)\t\t// empty list, can't match\n\t\t    c = NUL;\n\t\telse\n\t\t    for (;;)\t\t// find \"c\" in the list\n\t\t    {\n\t\t\tif (*ip == 0)\t// not found\n\t\t\t{\n\t\t\t    c = NUL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (*ip == c)\t// match!\n\t\t\t{\n\t\t\t    c = ip[1];\n\t\t\t    break;\n\t\t\t}\n\t\t\tip += 2;\n\t\t    }\n\t    }\n\n\t    if (c != NUL && c != prevc)\n\t    {\n\t\tri += mb_char2bytes(c, res + ri);\n\t\tif (ri + MB_MAXBYTES > MAXWLEN)\n\t\t    break;\n\t\tprevc = c;\n\t    }\n\t}\n    }\n    else\n    {\n\t// The sl_sal_first[] table contains the translation.\n\tfor (s = inword; (c = *s) != NUL; ++s)\n\t{\n\t    if (VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else\n\t\tc = slang->sl_sal_first[c];\n\t    if (c != NUL && (ri == 0 || res[ri - 1] != c))\n\t\tres[ri++] = c;\n\t}\n    }\n\n    res[ri] = NUL;\n}\n\n    static void\nspell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp;\n    char_u\tword[MAXWLEN];\n    char_u\t*s = inword;\n    char_u\t*t;\n    char_u\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n\n    // Remove accents, if wanted.  We actually remove all non-word characters.\n    // But keep white space.  We need a copy, the word may be changed here.\n    if (slang->sl_rem_accents)\n    {\n\tt = word;\n\twhile (*s != NUL)\n\t{\n\t    if (VIM_ISWHITE(*s))\n\t    {\n\t\t*t++ = ' ';\n\t\ts = skipwhite(s);\n\t    }\n\t    else\n\t    {\n\t\tif (spell_iswordp_nmw(s, curwin))\n\t\t    *t++ = *s;\n\t\t++s;\n\t    }\n\t}\n\t*t = NUL;\n    }\n    else\n\tvim_strncpy(word, s, MAXWLEN - 1);\n\n    smp = (salitem_T *)slang->sl_sal.ga_data;\n\n    /*\n     * This comes from Aspell phonet.cpp.  Converted from C++ to C.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // check all rules for the same letter\n\t    for (; (s = smp[n].sm_lead)[0] == c; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != s[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != s[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t      || spell_iswordp(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// test follow-up rule for \"word[i + k]\"\n\t\t\tfor ( ; (s = smp[n0].sm_lead)[0] == c0; ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    //\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != s[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != s[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t    && !spell_iswordp(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && smp[n0].sm_lead[0] == c0)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    s = smp[n].sm_to;\n\t\t    if (s == NULL)\n\t\t\ts = (char_u *)\"\";\n\t\t    pf = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(pf, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && *s != NUL && (res[reslen - 1] == c\n\t\t\t\t\t\t    || res[reslen - 1] == *s))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\twhile (*s != NUL && word[i + k0] != NUL)\n\t\t\t{\n\t\t\t    word[i + k0] = *s;\n\t\t\t    k0++;\n\t\t\t    s++;\n\t\t\t}\n\t\t\tif (k > k0)\n\t\t\t    STRMOVE(word + i + k0, word + i + k);\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\twhile (*s != NUL && s[1] != NUL && reslen < MAXWLEN)\n\t\t\t{\n\t\t\t    if (reslen == 0 || res[reslen - 1] != *s)\n\t\t\t\tres[reslen++] = *s;\n\t\t\t    s++;\n\t\t\t}\n\t\t\t// new \"actual letter\"\n\t\t\tc = *s;\n\t\t\tif (strstr((char *)pf, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\tres[reslen++] = c;\n\t\t\t    STRMOVE(word, word + i + 1);\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || res[reslen - 1] != c))\n\t\t// condense only double letters\n\t\tres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    res[reslen] = NUL;\n}\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n * Multi-byte version of spell_soundfold().\n */\n    static void\nspell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp = (salitem_T *)slang->sl_sal.ga_data;\n    int\t\tword[MAXWLEN];\n    int\t\twres[MAXWLEN];\n    int\t\tl;\n    char_u\t*s;\n    int\t\t*ws;\n    char_u\t*t;\n    int\t\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n    int\t\tdid_white = FALSE;\n    int\t\twordlen;\n\n\n    /*\n     * Convert the multi-byte string to a wide-character string.\n     * Remove accents, if wanted.  We actually remove all non-word characters.\n     * But keep white space.\n     */\n    wordlen = 0;\n    for (s = inword; *s != NUL; )\n    {\n\tt = s;\n\tc = mb_cptr2char_adv(&s);\n\tif (slang->sl_rem_accents)\n\t{\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t    {\n\t\tif (did_white)\n\t\t    continue;\n\t\tc = ' ';\n\t\tdid_white = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tdid_white = FALSE;\n\t\tif (!spell_iswordp_nmw(t, curwin))\n\t\t    continue;\n\t    }\n\t}\n\tword[wordlen++] = c;\n    }\n    word[wordlen] = NUL;\n\n    /*\n     * This algorithm comes from Aspell phonet.cpp.\n     * Converted from C++ to C.  Added support for multi-byte chars.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c & 0xff];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // Check all rules for the same index byte.\n\t    // If c is 0x300 need extra check for the end of the array, as\n\t    // (c & 0xff) is NUL.\n\t    for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)\n\t\t\t\t\t\t\t && ws[0] != NUL; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tif (c != ws[0])\n\t\t    continue;\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != ws[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != ws[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof_w) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t    || spell_iswordp_w(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp_w(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0 & 0xff];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// Test follow-up rule for \"word[i + k]\"; loop over\n\t\t\t// all entries with the same index byte.\n\t\t\tfor ( ; ((ws = smp[n0].sm_lead_w)[0] & 0xff)\n\t\t\t\t\t\t\t == (c0 & 0xff); ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    if (c0 != ws[0])\n\t\t\t\tcontinue;\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != ws[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != ws[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof_w) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t && !spell_iswordp_w(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)\n\t\t\t\t\t\t\t       == (c0 & 0xff))\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    ws = smp[n].sm_to_w;\n\t\t    s = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(s, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && ws != NULL && *ws != NUL\n\t\t\t\t&& (wres[reslen - 1] == c\n\t\t\t\t\t\t    || wres[reslen - 1] == *ws))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && word[i + k0] != NUL)\n\t\t\t    {\n\t\t\t\tword[i + k0] = *ws;\n\t\t\t\tk0++;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\tif (k > k0)\n\t\t\t    mch_memmove(word + i + k0, word + i + k,\n\t\t\t\t    sizeof(int) * (wordlen - (i + k) + 1));\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && ws[1] != NUL\n\t\t\t\t\t\t\t  && reslen < MAXWLEN)\n\t\t\t    {\n\t\t\t\tif (reslen == 0 || wres[reslen - 1] != *ws)\n\t\t\t\t    wres[reslen++] = *ws;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\t// new \"actual letter\"\n\t\t\tif (ws == NULL)\n\t\t\t    c = NUL;\n\t\t\telse\n\t\t\t    c = *ws;\n\t\t\tif (strstr((char *)s, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\twres[reslen++] = c;\n\t\t\t    mch_memmove(word, word + i + 1,\n\t\t\t\t       sizeof(int) * (wordlen - (i + 1) + 1));\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || wres[reslen - 1] != c))\n\t\t// condense only double letters\n\t\twres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    // Convert wide characters in \"wres\" to a multi-byte string in \"res\".\n    l = 0;\n    for (n = 0; n < reslen; ++n)\n    {\n\tl += mb_char2bytes(wres[n], res + l);\n\tif (l + MB_MAXBYTES > MAXWLEN)\n\t    break;\n    }\n    res[l] = NUL;\n}\n\n/*\n * \":spellinfo\"\n */\n    void\nex_spellinfo(exarg_T *eap UNUSED)\n{\n    int\t\tlpi;\n    langp_T\t*lp;\n    char_u\t*p;\n\n    if (no_spell_checking(curwin))\n\treturn;\n\n    msg_start();\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tmsg_puts(\"file: \");\n\tmsg_puts((char *)lp->lp_slang->sl_fname);\n\tmsg_putchar('\\n');\n\tp = lp->lp_slang->sl_info;\n\tif (p != NULL)\n\t{\n\t    msg_puts((char *)p);\n\t    msg_putchar('\\n');\n\t}\n    }\n    msg_end();\n}\n\n#define DUMPFLAG_KEEPCASE   1\t// round 2: keep-case tree\n#define DUMPFLAG_COUNT\t    2\t// include word count\n#define DUMPFLAG_ICASE\t    4\t// ignore case when finding matches\n#define DUMPFLAG_ONECAP\t    8\t// pattern starts with capital\n#define DUMPFLAG_ALLCAP\t    16\t// pattern is all capitals\n\n/*\n * \":spelldump\"\n */\n    void\nex_spelldump(exarg_T *eap)\n{\n    char_u  *spl;\n    long    dummy;\n\n    if (no_spell_checking(curwin))\n\treturn;\n    (void)get_option_value((char_u*)\"spl\", &dummy, &spl, NULL, OPT_LOCAL);\n\n    // Create a new empty buffer in a new window.\n    do_cmdline_cmd((char_u *)\"new\");\n\n    // enable spelling locally in the new window\n    set_option_value_give_err((char_u*)\"spell\", TRUE, (char_u*)\"\", OPT_LOCAL);\n    set_option_value_give_err((char_u*)\"spl\",  dummy, spl, OPT_LOCAL);\n    vim_free(spl);\n\n    if (!BUFEMPTY())\n\treturn;\n\n    spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);\n\n    // Delete the empty line that we started with.\n    if (curbuf->b_ml.ml_line_count > 1)\n\tml_delete(curbuf->b_ml.ml_line_count);\n\n    redraw_later(UPD_NOT_VALID);\n}\n\n/*\n * Go through all possible words and:\n * 1. When \"pat\" is NULL: dump a list of all words in the current buffer.\n *\t\"ic\" and \"dir\" are not used.\n * 2. When \"pat\" is not NULL: add matching words to insert mode completion.\n */\n    void\nspell_dump_compl(\n    char_u\t*pat,\t    // leading part of the word\n    int\t\tic,\t    // ignore case\n    int\t\t*dir,\t    // direction for adding matches\n    int\t\tdumpflags_arg)\t// DUMPFLAG_*\n{\n    langp_T\t*lp;\n    slang_T\t*slang;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tword[MAXWLEN];\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = 0;\n    int\t\tround;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tflags;\n    char_u\t*region_names = NULL;\t    // region names being used\n    int\t\tdo_region = TRUE;\t    // dump region names and numbers\n    char_u\t*p;\n    int\t\tlpi;\n    int\t\tdumpflags = dumpflags_arg;\n    int\t\tpatlen;\n\n    // When ignoring case or when the pattern starts with capital pass this on\n    // to dump_word().\n    if (pat != NULL)\n    {\n\tif (ic)\n\t    dumpflags |= DUMPFLAG_ICASE;\n\telse\n\t{\n\t    n = captype(pat, NULL);\n\t    if (n == WF_ONECAP)\n\t\tdumpflags |= DUMPFLAG_ONECAP;\n\t    else if (n == WF_ALLCAP && (int)STRLEN(pat) > mb_ptr2len(pat))\n\t\tdumpflags |= DUMPFLAG_ALLCAP;\n\t}\n    }\n\n    // Find out if we can support regions: All languages must support the same\n    // regions or none at all.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tp = lp->lp_slang->sl_regions;\n\tif (p[0] != 0)\n\t{\n\t    if (region_names == NULL)\t    // first language with regions\n\t\tregion_names = p;\n\t    else if (STRCMP(region_names, p) != 0)\n\t    {\n\t\tdo_region = FALSE;\t    // region names are different\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (do_region && region_names != NULL)\n    {\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n    }\n    else\n\tdo_region = FALSE;\n\n    /*\n     * Loop over all files loaded for the entries in 'spelllang'.\n     */\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_fbyts == NULL)\t    // reloading failed\n\t    continue;\n\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n\n\t// When matching with a pattern and there are no prefixes only use\n\t// parts of the tree that match \"pat\".\n\tif (pat != NULL && slang->sl_pbyts == NULL)\n\t    patlen = (int)STRLEN(pat);\n\telse\n\t    patlen = -1;\n\n\t// round 1: case-folded tree\n\t// round 2: keep-case tree\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t    {\n\t\tdumpflags &= ~DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_fbyts;\n\t\tidxs = slang->sl_fidxs;\n\t    }\n\t    else\n\t    {\n\t\tdumpflags |= DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_kbyts;\n\t\tidxs = slang->sl_kidxs;\n\t    }\n\t    if (byts == NULL)\n\t\tcontinue;\t\t// array is empty\n\n\t    depth = 0;\n\t    arridx[0] = 0;\n\t    curi[0] = 1;\n\t    while (depth >= 0 && !got_int\n\t\t\t\t  && (pat == NULL || !ins_compl_interrupted()))\n\t    {\n\t\tif (curi[depth] > byts[arridx[depth]])\n\t\t{\n\t\t    // Done all bytes at this node, go up one level.\n\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n\t\t    {\n\t\t\t// End of word or reached maximum length, deal with the\n\t\t\t// word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))\n\t\t\t{\n\t\t\t    word[depth] = NUL;\n\t\t\t    if (!do_region)\n\t\t\t\tflags &= ~WF_REGION;\n\n\t\t\t    // Dump the basic word if there is no prefix or\n\t\t\t    // when it's the first one.\n\t\t\t    c = (unsigned)flags >> 24;\n\t\t\t    if (c == 0 || curi[depth] == 2)\n\t\t\t    {\n\t\t\t\tdump_word(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t\tif (pat == NULL)\n\t\t\t\t    ++lnum;\n\t\t\t    }\n\n\t\t\t    // Apply the prefix, if there is one.\n\t\t\t    if (c != 0)\n\t\t\t\tlnum = dump_prefixes(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Normal char, go one level deeper.\n\t\t\tword[depth++] = c;\n\t\t\tarridx[depth] = idxs[n];\n\t\t\tcuri[depth] = 1;\n\n\t\t\t// Check if this character matches with the pattern.\n\t\t\t// If not skip the whole tree below it.\n\t\t\t// Always ignore case here, dump_word() will check\n\t\t\t// proper case later.  This isn't exactly right when\n\t\t\t// length changes for multi-byte characters with\n\t\t\t// ignore case...\n\t\t\tif (depth <= patlen\n\t\t\t\t\t&& MB_STRNICMP(word, pat, depth) != 0)\n\t\t\t    --depth;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Dump one word: apply case modifications and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n */\n    static void\ndump_word(\n    slang_T\t*slang,\n    char_u\t*word,\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\twordflags,\n    linenr_T\tlnum)\n{\n    int\t\tkeepcap = FALSE;\n    char_u\t*p;\n    char_u\t*tw;\n    char_u\tcword[MAXWLEN];\n    char_u\tbadword[MAXWLEN + 10];\n    int\t\ti;\n    int\t\tflags = wordflags;\n\n    if (dumpflags & DUMPFLAG_ONECAP)\n\tflags |= WF_ONECAP;\n    if (dumpflags & DUMPFLAG_ALLCAP)\n\tflags |= WF_ALLCAP;\n\n    if ((dumpflags & DUMPFLAG_KEEPCASE) == 0 && (flags & WF_CAPMASK) != 0)\n    {\n\t// Need to fix case according to \"flags\".\n\tmake_case_word(word, cword, flags);\n\tp = cword;\n    }\n    else\n    {\n\tp = word;\n\tif ((dumpflags & DUMPFLAG_KEEPCASE)\n\t\t&& ((captype(word, NULL) & WF_KEEPCAP) == 0\n\t\t\t\t\t\t || (flags & WF_FIXCAP) != 0))\n\t    keepcap = TRUE;\n    }\n    tw = p;\n\n    if (pat == NULL)\n    {\n\t// Add flags and regions after a slash.\n\tif ((flags & (WF_BANNED | WF_RARE | WF_REGION)) || keepcap)\n\t{\n\t    STRCPY(badword, p);\n\t    STRCAT(badword, \"/\");\n\t    if (keepcap)\n\t\tSTRCAT(badword, \"=\");\n\t    if (flags & WF_BANNED)\n\t\tSTRCAT(badword, \"!\");\n\t    else if (flags & WF_RARE)\n\t\tSTRCAT(badword, \"?\");\n\t    if (flags & WF_REGION)\n\t\tfor (i = 0; i < 7; ++i)\n\t\t    if (flags & (0x10000 << i))\n\t\t\tsprintf((char *)badword + STRLEN(badword), \"%d\", i + 1);\n\t    p = badword;\n\t}\n\n\tif (dumpflags & DUMPFLAG_COUNT)\n\t{\n\t    hashitem_T  *hi;\n\n\t    // Include the word count for \":spelldump!\".\n\t    hi = hash_find(&slang->sl_wordcount, tw);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",\n\t\t\t\t\t\t     tw, HI2WC(hi)->wc_count);\n\t\tp = IObuff;\n\t    }\n\t}\n\n\tml_append(lnum, p, (colnr_T)0, FALSE);\n    }\n    else if (((dumpflags & DUMPFLAG_ICASE)\n\t\t    ? MB_STRNICMP(p, pat, STRLEN(pat)) == 0\n\t\t    : STRNCMP(p, pat, STRLEN(pat)) == 0)\n\t\t&& ins_compl_add_infercase(p, (int)STRLEN(p),\n\t\t\t\t\t  p_ic, NULL, *dir, FALSE) == OK)\n\t// if dir was BACKWARD then honor it just once\n\t*dir = FORWARD;\n}\n\n/*\n * For \":spelldump\": Find matching prefixes for \"word\".  Prepend each to\n * \"word\" and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n * Return the updated line number.\n */\n    static linenr_T\ndump_prefixes(\n    slang_T\t*slang,\n    char_u\t*word,\t    // case-folded word\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\tflags,\t    // flags with prefix ID\n    linenr_T\tstartlnum)\n{\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tprefix[MAXWLEN];\n    char_u\tword_up[MAXWLEN];\n    int\t\thas_word_up = FALSE;\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = startlnum;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tlen;\n    int\t\ti;\n\n    // If the word starts with a lower-case letter make the word with an\n    // upper-case letter in word_up[].\n    c = PTR2CHAR(word);\n    if (SPELL_TOUPPER(c) != c)\n    {\n\tonecap_copy(word, word_up, TRUE);\n\thas_word_up = TRUE;\n    }\n\n    byts = slang->sl_pbyts;\n    idxs = slang->sl_pidxs;\n    if (byts != NULL)\t\t// array not is empty\n    {\n\t/*\n\t * Loop over all prefixes, building them byte-by-byte in prefix[].\n\t * When at the end of a prefix check that it supports \"flags\".\n\t */\n\tdepth = 0;\n\tarridx[0] = 0;\n\tcuri[0] = 1;\n\twhile (depth >= 0 && !got_int)\n\t{\n\t    n = arridx[depth];\n\t    len = byts[n];\n\t    if (curi[depth] > len)\n\t    {\n\t\t// Done all bytes at this node, go up one level.\n\t\t--depth;\n\t\tline_breakcheck();\n\t    }\n\t    else\n\t    {\n\t\t// Do one more byte at this node.\n\t\tn += curi[depth];\n\t\t++curi[depth];\n\t\tc = byts[n];\n\t\tif (c == 0)\n\t\t{\n\t\t    // End of prefix, find out how many IDs there are.\n\t\t    for (i = 1; i < len; ++i)\n\t\t\tif (byts[n + i] != 0)\n\t\t\t    break;\n\t\t    curi[depth] += i - 1;\n\n\t\t    c = valid_word_prefix(i, n, flags, word, slang, FALSE);\n\t\t    if (c != 0)\n\t\t    {\n\t\t\tvim_strncpy(prefix + depth, word, MAXWLEN - depth - 1);\n\t\t\tdump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t(c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\tif (lnum != 0)\n\t\t\t    ++lnum;\n\t\t    }\n\n\t\t    // Check for prefix that matches the word when the\n\t\t    // first letter is upper-case, but only if the prefix has\n\t\t    // a condition.\n\t\t    if (has_word_up)\n\t\t    {\n\t\t\tc = valid_word_prefix(i, n, flags, word_up, slang,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t\tif (c != 0)\n\t\t\t{\n\t\t\t    vim_strncpy(prefix + depth, word_up,\n\t\t\t\t\t\t\t MAXWLEN - depth - 1);\n\t\t\t    dump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t    (c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\t    if (lnum != 0)\n\t\t\t\t++lnum;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Normal char, go one level deeper.\n\t\t    prefix[depth++] = c;\n\t\t    arridx[depth] = idxs[n];\n\t\t    curi[depth] = 1;\n\t\t}\n\t    }\n\t}\n    }\n\n    return lnum;\n}\n\n/*\n * Move \"p\" to the end of word \"start\".\n * Uses the spell-checking word characters.\n */\n    char_u *\nspell_to_word_end(char_u *start, win_T *win)\n{\n    char_u  *p = start;\n\n    while (*p != NUL && spell_iswordp(p, win))\n\tMB_PTR_ADV(p);\n    return p;\n}\n\n/*\n * For Insert mode completion CTRL-X s:\n * Find start of the word in front of column \"startcol\".\n * We don't check if it is badly spelled, with completion we can only change\n * the word in front of the cursor.\n * Returns the column number of the word.\n */\n    int\nspell_word_start(int startcol)\n{\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcol = 0;\n\n    if (no_spell_checking(curwin))\n\treturn startcol;\n\n    // Find a word character before \"startcol\".\n    line = ml_get_curline();\n    for (p = line + startcol; p > line; )\n    {\n\tMB_PTR_BACK(line, p);\n\tif (spell_iswordp_nmw(p, curwin))\n\t    break;\n    }\n\n    // Go back to start of the word.\n    while (p > line)\n    {\n\tcol = (int)(p - line);\n\tMB_PTR_BACK(line, p);\n\tif (!spell_iswordp(p, curwin))\n\t    break;\n\tcol = 0;\n    }\n\n    return col;\n}\n\n/*\n * Need to check for 'spellcapcheck' now, the word is removed before\n * expand_spelling() is called.  Therefore the ugly global variable.\n */\nstatic int spell_expand_need_cap;\n\n    void\nspell_expand_check_cap(colnr_T col)\n{\n    spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);\n}\n\n/*\n * Get list of spelling suggestions.\n * Used for Insert mode completion CTRL-X ?.\n * Returns the number of matches.  The matches are in \"matchp[]\", array of\n * allocated strings.\n */\n    int\nexpand_spelling(\n    linenr_T\tlnum UNUSED,\n    char_u\t*pat,\n    char_u\t***matchp)\n{\n    garray_T\tga;\n\n    spell_suggest_list(&ga, pat, 100, spell_expand_need_cap, TRUE);\n    *matchp = ga.ga_data;\n    return ga.ga_len;\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spelllang' value.\n */\n    int\nvalid_spelllang(char_u *val)\n{\n    return valid_name(val, \".-_,@\");\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spellfile' value.\n */\n    int\nvalid_spellfile(char_u *val)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!vim_is_fname_char(*s))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Handle side effects of setting 'spell'.\n * Return an error message or NULL for success.\n */\n    char *\ndid_set_spell_option(int is_spellfile)\n{\n    char    *errmsg = NULL;\n    win_T   *wp;\n    int\t    l;\n\n    if (is_spellfile)\n    {\n\tl = (int)STRLEN(curwin->w_s->b_p_spf);\n\tif (l > 0 && (l < 4\n\t\t\t|| STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0))\n\t    errmsg = e_invalid_argument;\n    }\n\n    if (errmsg == NULL)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == curbuf && wp->w_p_spell)\n\t    {\n\t\terrmsg = did_set_spelllang(wp);\n\t\tbreak;\n\t    }\n    }\n    return errmsg;\n}\n\n/*\n * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n * Return error message when failed, NULL when OK.\n */\n    char *\ncompile_cap_prog(synblock_T *synblock)\n{\n    regprog_T   *rp = synblock->b_cap_prog;\n    char_u\t*re;\n\n    if (synblock->b_p_spc == NULL || *synblock->b_p_spc == NUL)\n\tsynblock->b_cap_prog = NULL;\n    else\n    {\n\t// Prepend a ^ so that we only match at one column\n\tre = concat_str((char_u *)\"^\", synblock->b_p_spc);\n\tif (re != NULL)\n\t{\n\t    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n\t    vim_free(re);\n\t    if (synblock->b_cap_prog == NULL)\n\t    {\n\t\tsynblock->b_cap_prog = rp; // restore the previous program\n\t\treturn e_invalid_argument;\n\t    }\n\t}\n    }\n\n    vim_regfree(rp);\n    return NULL;\n}\n\n#endif  // FEAT_SPELL\n", "\" Tests for autocommands\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\nsource screendump.vim\nimport './vim9.vim' as v9\n\nfunc s:cleanup_buffers() abort\n  for bnr in range(1, bufnr('$'))\n    if bufloaded(bnr) && bufnr('%') != bnr\n      execute 'bd! ' . bnr\n    endif\n  endfor\nendfunc\n\nfunc Test_vim_did_enter()\n  call assert_false(v:vim_did_enter)\n\n  \" This script will never reach the main loop, can't check if v:vim_did_enter\n  \" becomes one.\nendfunc\n\n\" Test for the CursorHold autocmd\nfunc Test_CursorHold_autocmd()\n  CheckRunVimInTerminal\n  call writefile(['one', 'two', 'three'], 'XoneTwoThree', 'D')\n  let before =<< trim END\n    set updatetime=10\n    au CursorHold * call writefile([line('.')], 'XCHoutput', 'a')\n  END\n  call writefile(before, 'XCHinit', 'D')\n  let buf = RunVimInTerminal('-S XCHinit XoneTwoThree', {})\n  call term_sendkeys(buf, \"G\")\n  call term_wait(buf, 50)\n  call term_sendkeys(buf, \"gg\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1'], readfile('XCHoutput')[-1:-1])})\n  call term_sendkeys(buf, \"j\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1', '2'], readfile('XCHoutput')[-2:-1])})\n  call term_sendkeys(buf, \"j\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1', '2', '3'], readfile('XCHoutput')[-3:-1])})\n  call StopVimInTerminal(buf)\n\n  call delete('XCHoutput')\nendfunc\n\nif has('timers')\n\n  func ExitInsertMode(id)\n    call feedkeys(\"\\<Esc>\")\n  endfunc\n\n  func Test_cursorhold_insert()\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(200, 'ExitInsertMode')\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_with_timer_interrupt()\n    CheckFeature job\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    \" Confirm the timer invoked in exit_cb of the job doesn't disturb\n    \" CursorHoldI event.\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=100\n    call job_start(has('win32') ? 'cmd /c echo:' : 'echo',\n          \\ {'exit_cb': {-> timer_start(200, 'ExitInsertMode')}})\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_x()\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(100, 'ExitInsertMode')\n    \" CursorHoldI does not trigger after CTRL-X\n    call feedkeys(\"a\\<C-X>\", 'x!')\n    call assert_equal(0, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_g_U()\n    au CursorHoldI * :\n    set updatetime=20\n    new\n    call timer_start(100, { -> feedkeys(\"\\<Left>foo\\<Esc>\", 't') })\n    call feedkeys(\"i()\\<C-g>U\", 'tx!')\n    sleep 200m\n    call assert_equal('(foo)', getline(1))\n    undo\n    call assert_equal('', getline(1))\n\n    bwipe!\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_OptionSet_modeline()\n    call test_override('starting', 1)\n    au! OptionSet\n    augroup set_tabstop\n      au OptionSet tabstop call timer_start(1, {-> execute(\"echo 'Handler called'\", \"\")})\n    augroup END\n    call writefile(['vim: set ts=7 sw=5 :', 'something'], 'XoptionsetModeline', 'D')\n    set modeline\n    let v:errmsg = ''\n    call assert_fails('split XoptionsetModeline', 'E12:')\n    call assert_equal(7, &ts)\n    call assert_equal('', v:errmsg)\n\n    augroup set_tabstop\n      au!\n    augroup END\n    bwipe!\n    set ts&\n    call test_override('starting', 0)\n  endfunc\n\nendif \"has('timers')\n\nfunc Test_bufunload()\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li = []\n  new\n  setlocal bufhidden=\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li = []\n  new\n  setlocal bufhidden=delete\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li = []\n  new\n  setlocal bufhidden=unload\n  bwipeout\n  call assert_equal([\"bufunload\", \"bufdelete\", \"bufwipeout\"], s:li)\n\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2005 or older)\nfunc Test_autocmd_bufunload_with_tabnext()\n  tabedit\n  tabfirst\n\n  augroup test_autocmd_bufunload_with_tabnext_group\n    autocmd!\n    autocmd BufUnload <buffer> tabnext\n  augroup END\n\n  quit\n  call assert_equal(2, tabpagenr('$'))\n\n  autocmd! test_autocmd_bufunload_with_tabnext_group\n  augroup! test_autocmd_bufunload_with_tabnext_group\n  tablast\n  quit\nendfunc\n\nfunc Test_argdelete_in_next()\n  au BufNew,BufEnter,BufLeave,BufWinEnter * argdel\n  call assert_fails('next a b', 'E1156:')\n  au! BufNew,BufEnter,BufLeave,BufWinEnter *\nendfunc\n\nfunc Test_autocmd_bufwinleave_with_tabfirst()\n  tabedit\n  augroup sample\n    autocmd!\n    autocmd BufWinLeave <buffer> tabfirst\n  augroup END\n  call setline(1, ['a', 'b', 'c'])\n  edit! a.txt\n  tabclose\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_01()\n  split aa.txt\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  call assert_fails('edit bb.txt', 'E937:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! aa.txt\n  bwipe! bb.txt\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_02()\n  setlocal buftype=nowrite\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  normal! i1\n  call assert_fails('edit a.txt', 'E517:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! a.txt\nendfunc\n\nfunc Test_autocmd_dummy_wipeout()\n  \" prepare files\n  call writefile([''], 'Xdummywipetest1.txt', 'D')\n  call writefile([''], 'Xdummywipetest2.txt', 'D')\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li = []\n  split Xdummywipetest1.txt\n  silent! vimgrep /notmatched/ Xdummywipetest*\n  call assert_equal([\"bufunload\", \"bufwipeout\"], s:li)\n\n  bwipeout\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\nfunc Test_win_tab_autocmd()\n  let g:record = []\n\n  augroup testing\n    au WinNew * call add(g:record, 'WinNew')\n    au WinClosed * call add(g:record, 'WinClosed')\n    au WinEnter * call add(g:record, 'WinEnter') \n    au WinLeave * call add(g:record, 'WinLeave') \n    au TabNew * call add(g:record, 'TabNew')\n    au TabClosed * call add(g:record, 'TabClosed')\n    au TabEnter * call add(g:record, 'TabEnter')\n    au TabLeave * call add(g:record, 'TabLeave')\n  augroup END\n\n  split\n  tabnew\n  close\n  close\n\n  call assert_equal([\n\t\\ 'WinLeave', 'WinNew', 'WinEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinClosed', 'TabClosed', 'WinEnter', 'TabEnter',\n\t\\ 'WinLeave', 'WinClosed', 'WinEnter'\n\t\\ ], g:record)\n\n  let g:record = []\n  tabnew somefile\n  tabnext\n  bwipe somefile\n\n  call assert_equal([\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter',\n\t\\ 'WinClosed', 'TabClosed'\n\t\\ ], g:record)\n\n  augroup testing\n    au!\n  augroup END\n  unlet g:record\nendfunc\n\nfunc Test_WinScrolled()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    for ii in range(1, 18)\n      call setline(ii, repeat(nr2char(96 + ii), ii * 2))\n    endfor\n    let win_id = win_getid()\n    let g:matched = v:false\n    execute 'au WinScrolled' win_id 'let g:matched = v:true'\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n    au WinScrolled * let g:amatch = str2nr(expand('<amatch>'))\n    au WinScrolled * let g:afile = str2nr(expand('<afile>'))\n  END\n  call writefile(lines, 'Xtest_winscrolled', 'D')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled', {'rows': 6})\n\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^0 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll left/right in Normal mode.\n  call term_sendkeys(buf, \"zlzh:echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll up/down in Normal mode.\n  call term_sendkeys(buf, \"\\<c-e>\\<c-y>:echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^4 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll up/down in Insert mode.\n  call term_sendkeys(buf, \"Mi\\<c-x>\\<c-e>\\<Esc>i\\<c-x>\\<c-y>\\<Esc>\")\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^6 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll the window horizontally to focus the last letter of the third line\n  \" containing only six characters. Moving to the previous and shorter lines\n  \" should trigger another autocommand as Vim has to make them visible.\n  call term_sendkeys(buf, \"5zl2k\")\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^8 ', term_getline(buf, 6))}, 1000)\n\n  \" Ensure the command was triggered for the specified window ID.\n  call term_sendkeys(buf, \":echo g:matched\\<CR>\")\n  call WaitForAssert({-> assert_match('^v:true ', term_getline(buf, 6))}, 1000)\n\n  \" Ensure the expansion of <amatch> and <afile> matches the window ID.\n  call term_sendkeys(buf, \":echo g:amatch == win_id && g:afile == win_id\\<CR>\")\n  call WaitForAssert({-> assert_match('^v:true ', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_WinScrolled_mouse()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    set mouse=a term=xterm ttymouse=sgr mousetime=200 clipboard=\n    call setline(1, ['foo']->repeat(32))\n    split\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n  END\n  call writefile(lines, 'Xtest_winscrolled_mouse', 'D')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_mouse', {'rows': 10})\n\n  \" With the upper split focused, send a scroll-down event to the unfocused one.\n  call test_setmouse(7, 1)\n  call term_sendkeys(buf, \"\\<ScrollWheelDown>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 10))}, 1000)\n\n  \" Again, but this time while we're in insert mode.\n  call term_sendkeys(buf, \"i\\<ScrollWheelDown>\\<Esc>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2', term_getline(buf, 10))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_WinScrolled_close_curwin()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    call setline(1, ['aaa', 'bbb'])\n    vsplit\n    au WinScrolled * close\n    au VimLeave * call writefile(['123456'], 'Xtestout')\n  END\n  call writefile(lines, 'Xtest_winscrolled_close_curwin', 'D')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_close_curwin', {'rows': 6})\n\n  \" This was using freed memory\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n\n  call assert_equal(['123456'], readfile('Xtestout'))\n\n  call delete('Xtestout')\nendfunc\n\nfunc Test_WinScrolled_long_wrapped()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set scrolloff=0\n    let height = winheight(0)\n    let width = winwidth(0)\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n    call setline(1, repeat('foo', height * width))\n    call cursor(1, height * width)\n  END\n  call writefile(lines, 'Xtest_winscrolled_long_wrapped', 'D')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_long_wrapped', {'rows': 6})\n\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^0 ', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, 'gj')\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^1 ', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, '0')\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2 ', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, '$')\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^3 ', term_getline(buf, 6))}, 1000)\nendfunc\n\nfunc Test_WinClosed()\n  \" Test that the pattern is matched against the closed window's ID, and both\n  \" <amatch> and <afile> are set to it.\n  new\n  let winid = win_getid()\n  let g:matched = v:false\n  augroup test-WinClosed\n    autocmd!\n    execute 'autocmd WinClosed' winid 'let g:matched = v:true'\n    autocmd WinClosed * let g:amatch = str2nr(expand('<amatch>'))\n    autocmd WinClosed * let g:afile = str2nr(expand('<afile>'))\n  augroup END\n  close\n  call assert_true(g:matched)\n  call assert_equal(winid, g:amatch)\n  call assert_equal(winid, g:afile)\n\n  \" Test that WinClosed is non-recursive.\n  new\n  new\n  call assert_equal(3, winnr('$'))\n  let g:triggered = 0\n  augroup test-WinClosed\n    autocmd!\n    autocmd WinClosed * let g:triggered += 1\n    autocmd WinClosed * 2 wincmd c\n  augroup END\n  close\n  call assert_equal(1, winnr('$'))\n  call assert_equal(1, g:triggered)\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\n  unlet g:matched\n  unlet g:amatch\n  unlet g:afile\n  unlet g:triggered\nendfunc\n\nfunc Test_WinClosed_throws()\n  vnew\n  let bnr = bufnr()\n  call assert_equal(1, bufloaded(bnr))\n  augroup test-WinClosed\n    autocmd WinClosed * throw 'foo'\n  augroup END\n  try\n    close\n  catch /.*/\n  endtry\n  call assert_equal(0, bufloaded(bnr))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\nendfunc\n\nfunc Test_WinClosed_throws_with_tabs()\n  tabnew\n  let bnr = bufnr()\n  call assert_equal(1, bufloaded(bnr))\n  augroup test-WinClosed\n    autocmd WinClosed * throw 'foo'\n  augroup END\n  try\n    close\n  catch /.*/\n  endtry\n  call assert_equal(0, bufloaded(bnr))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\nendfunc\n\n\" This used to trigger WinClosed twice for the same window, and the window's\n\" buffer was NULL in the second autocommand.\nfunc Test_WinClosed_switch_tab()\n  edit Xa\n  split Xb\n  split Xc\n  tab split\n  new\n  augroup test-WinClosed\n    autocmd WinClosed * tabprev | bwipe!\n  augroup END\n  close\n  \" Check that the tabline has been fully removed\n  call assert_equal([1, 1], win_screenpos(0))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\n  %bwipe!\nendfunc\n\nfunc s:AddAnAutocmd()\n  augroup vimBarTest\n    au BufReadCmd * echo 'hello'\n  augroup END\n  call assert_equal(3, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc Test_early_bar()\n  \" test that a bar is recognized before the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest | au! | let done = 77 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(77, done)\n\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!| let done = 88 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(88, done)\n\n  \" test that a bar is recognized after the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!BufReadCmd| let done = 99 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(99, done)\n\n  \" test that a bar is recognized after the {group}\n  call s:AddAnAutocmd()\n  au! vimBarTest|echo 'hello'\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc RemoveGroup()\n  autocmd! StartOK\n  augroup! StartOK\nendfunc\n\nfunc Test_augroup_warning()\n  augroup TheWarning\n    au VimEnter * echo 'entering'\n  augroup END\n  call assert_match(\"TheWarning.*VimEnter\", execute('au VimEnter'))\n  redir => res\n  augroup! TheWarning\n  redir END\n  call assert_match(\"W19:\", res)\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n\n  \" check \"Another\" does not take the pace of the deleted entry\n  augroup Another\n  augroup END\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n  augroup! Another\n\n  \" no warning for postpone aucmd delete\n  augroup StartOK\n    au VimEnter * call RemoveGroup()\n  augroup END\n  call assert_match(\"StartOK.*VimEnter\", execute('au VimEnter'))\n  redir => res\n  doautocmd VimEnter\n  redir END\n  call assert_notmatch(\"W19:\", res)\n  au! VimEnter\n\n  call assert_fails('augroup!', 'E471:')\nendfunc\n\nfunc Test_BufReadCmdHelp()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h\n  help\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_BufReadCmdHelpJump()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h{\n  \" } to fix highlighting\n  call assert_fails('help', 'E434:')\n\n  au! BufReadCmd\nendfunc\n\n\" BufReadCmd is triggered for a \"nofile\" buffer. Check all values.\nfunc Test_BufReadCmdNofile()\n  for val in ['nofile',\n            \\ 'nowrite',\n            \\ 'acwrite',\n            \\ 'quickfix',\n            \\ 'help',\n            \\ 'terminal',\n            \\ 'prompt',\n            \\ 'popup',\n            \\ ]\n    new somefile\n    exe 'set buftype=' .. val\n    au BufReadCmd somefile call setline(1, 'triggered')\n    edit\n    call assert_equal('triggered', getline(1))\n\n    au! BufReadCmd\n    bwipe!\n  endfor\nendfunc\n\nfunc Test_augroup_deleted()\n  \" This caused a crash before E936 was introduced\n  augroup x\n    call assert_fails('augroup! x', 'E936:')\n    au VimEnter * echo\n  augroup end\n  augroup! x\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n  au! VimEnter\nendfunc\n\n\" Tests for autocommands on :close command.\n\" This used to be in test13.\nfunc Test_three_windows()\n  \" Clean up buffers, because in some cases this function fails.\n  call s:cleanup_buffers()\n\n  \" Write three files and open them, each in a window.\n  \" Then go to next window, with autocommand that deletes the previous one.\n  \" Do this twice, writing the file.\n  e! Xtestje1\n  call setline(1, 'testje1')\n  w\n  sp Xtestje2\n  call setline(1, 'testje2')\n  w\n  sp Xtestje3\n  call setline(1, 'testje3')\n  w\n  wincmd w\n  au WinLeave Xtestje2 bwipe\n  wincmd w\n  call assert_equal('Xtestje1', expand('%'))\n\n  au WinLeave Xtestje1 bwipe Xtestje3\n  close\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test deleting the buffer on a Unload event.  If this goes wrong there\n  \" will be the ATTENTION prompt.\n  e Xtestje1\n  au!\n  au! BufUnload Xtestje1 bwipe\n  call assert_fails('e Xtestje3', 'E937:')\n  call assert_equal('Xtestje3', expand('%'))\n\n  e Xtestje2\n  sp Xtestje1\n  call assert_fails('e', 'E937:')\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test changing buffers in a BufWipeout autocommand.  If this goes wrong\n  \" there are ml_line errors and/or a Crash.\n  au!\n  only\n  e Xanother\n  e Xtestje1\n  bwipe Xtestje2\n  bwipe Xtestje3\n  au BufWipeout Xtestje1 buf Xtestje1\n  bwipe\n  call assert_equal('Xanother', expand('%'))\n\n  only\n  help\n  wincmd w\n  1quit\n  call assert_equal('Xanother', expand('%'))\n\n  au!\n  enew\n  call delete('Xtestje1')\n  call delete('Xtestje2')\n  call delete('Xtestje3')\nendfunc\n\nfunc Test_BufEnter()\n  au! BufEnter\n  au Bufenter * let val = val . '+'\n  let g:val = ''\n  split NewFile\n  call assert_equal('+', g:val)\n  bwipe!\n  call assert_equal('++', g:val)\n\n  \" Also get BufEnter when editing a directory\n  call mkdir('Xbufenterdir', 'D')\n  split Xbufenterdir\n  call assert_equal('+++', g:val)\n\n  \" On MS-Windows we can't edit the directory, make sure we wipe the right\n  \" buffer.\n  bwipe! Xbufenterdir\n  au! BufEnter\n\n  \" Editing a \"nofile\" buffer doesn't read the file but does trigger BufEnter\n  \" for historic reasons.  Also test other 'buftype' values.\n  for val in ['nofile',\n            \\ 'nowrite',\n            \\ 'acwrite',\n            \\ 'quickfix',\n            \\ 'help',\n            \\ 'terminal',\n            \\ 'prompt',\n            \\ 'popup',\n            \\ ]\n    new somefile\n    exe 'set buftype=' .. val\n    au BufEnter somefile call setline(1, 'some text')\n    edit\n    call assert_equal('some text', getline(1))\n    bwipe!\n    au! BufEnter\n  endfor\nendfunc\n\n\" Closing a window might cause an endless loop\n\" E814 for older Vims\nfunc Test_autocmd_bufwipe_in_SessLoadPost()\n  edit Xtest\n  tabnew\n  file Xsomething\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    call test_override('ui_delay', 10)\n    set nocp noswapfile\n    let v:swapchoice = \"e\"\n    augroup test_autocmd_sessionload\n    autocmd!\n    autocmd SessionLoadPost * exe bufnr(\"Xsomething\") . \"bw!\"\n    augroup END\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"XerrorsBwipe\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc', 'D')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  sleep 100m\n  let errors = join(readfile('XerrorsBwipe'))\n  call assert_match('E814:', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'XerrorsBwipe']\n    call delete(file)\n  endfor\nendfunc\n\n\" Using :blast and :ball for many events caused a crash, because b_nwindows was\n\" not incremented correctly.\nfunc Test_autocmd_blast_badd()\n  let content =<< trim [CODE]\n      au BufNew,BufAdd,BufWinEnter,BufEnter,BufLeave,BufWinLeave,BufUnload,VimEnter foo* blast\n      edit foo1\n      au BufNew,BufAdd,BufWinEnter,BufEnter,BufLeave,BufWinLeave,BufUnload,VimEnter foo* ball\n      edit foo2\n      call writefile(['OK'], 'XerrorsBlast')\n      qall\n  [CODE]\n\n  call writefile(content, 'XblastBall', 'D')\n  call system(GetVimCommand() .. ' --clean -S XblastBall')\n  sleep 100m\n  call assert_match('OK', readfile('XerrorsBlast')->join())\n\n  call delete('XerrorsBlast')\nendfunc\n\n\" SEGV occurs in older versions.\nfunc Test_autocmd_bufwipe_in_SessLoadPost2()\n  tabnew\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    set nocp noswapfile\n    function! DeleteInactiveBufs()\n      tabfirst\n      let tabblist = []\n      for i in range(1, tabpagenr(''$''))\n        call extend(tabblist, tabpagebuflist(i))\n      endfor\n      for b in range(1, bufnr(''$''))\n        if bufexists(b) && buflisted(b) && (index(tabblist, b) == -1 || bufname(b) =~# ''^$'')\n          exec ''bwipeout '' . b\n        endif\n      endfor\n      echomsg \"SessionLoadPost DONE\"\n    endfunction\n    au SessionLoadPost * call DeleteInactiveBufs()\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"XerrorsPost\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc', 'D')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  sleep 100m\n  let errors = join(readfile('XerrorsPost'))\n  \" This probably only ever matches on unix.\n  call assert_notmatch('Caught deadly signal SEGV', errors)\n  call assert_match('SessionLoadPost DONE', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'XerrorsPost']\n    call delete(file)\n  endfor\nendfunc\n\nfunc Test_empty_doau()\n  doau \\|\nendfunc\n\nfunc s:AutoCommandOptionSet(match)\n  let template = \"Option: <%s>, OldVal: <%s>, OldValLocal: <%s>, OldValGlobal: <%s>, NewVal: <%s>, Scope: <%s>, Command: <%s>\\n\"\n  let item     = remove(g:options, 0)\n  let expected = printf(template, item[0], item[1], item[2], item[3], item[4], item[5], item[6])\n  let actual   = printf(template, a:match, v:option_old, v:option_oldlocal, v:option_oldglobal, v:option_new, v:option_type, v:option_command)\n  let g:opt    = [expected, actual]\n  \"call assert_equal(expected, actual)\nendfunc\n\nfunc Test_OptionSet()\n  CheckOption autochdir\n\n  badd test_autocmd.vim\n\n  call test_override('starting', 1)\n  set nocp\n  au OptionSet * :call s:AutoCommandOptionSet(expand(\"<amatch>\"))\n\n  \" 1: Setting number option\"\n  let g:options = [['number', 0, 0, 0, 1, 'global', 'set']]\n  set nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 2: Setting local number option\"\n  let g:options = [['number', 1, 1, '', 0, 'local', 'setlocal']]\n  setlocal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 3: Setting global number option\"\n  let g:options = [['number', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 4: Setting local autoindent option\"\n  let g:options = [['autoindent', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 5: Setting global autoindent option\"\n  let g:options = [['autoindent', 0, '', 0, 1, 'global', 'setglobal']]\n  setglobal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6: Setting global autoindent option\"\n  let g:options = [['autoindent', 1, 1, 1, 0, 'global', 'set']]\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6a: Setting global autoindent option\"\n  let g:options = [['autoindent', 1, 1, 0, 0, 'global', 'set']]\n  noa setlocal ai\n  noa setglobal noai\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" Should not print anything, use :noa\n  \" 7: don't trigger OptionSet\"\n  let g:options = [['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 8: Setting several global list and number option\"\n  let g:options = [['list', 0, 0, 0, 1, 'global', 'set'], ['number', 0, 0, 0, 1, 'global', 'set']]\n  set list nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 9: don't trigger OptionSet\"\n  let g:options = [['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nolist nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 10: Setting global acd\"\n  let g:options = [['autochdir', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal acd\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 11: Setting global autoread (also sets local value)\"\n  let g:options = [['autoread', 0, 0, 0, 1, 'global', 'set']]\n  set ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 12: Setting local autoread\"\n  let g:options = [['autoread', 1, 1, '', 1, 'local', 'setlocal']]\n  setlocal ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 13: Setting global autoread\"\n  let g:options = [['autoread', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal invar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 14: Setting option backspace through :let\"\n  let g:options = [['backspace', '', '', '', 'eol,indent,start', 'global', 'set']]\n  let &bs = \"eol,indent,start\"\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 15: Setting option backspace through setbufvar()\"\n  let g:options = [['backup', 0, 0, '', 1, 'local', 'setlocal']]\n  \" try twice, first time, shouldn't trigger because option name is invalid,\n  \" second time, it should trigger\n  let bnum = bufnr('%')\n  call assert_fails(\"call setbufvar(bnum, '&l:bk', 1)\", 'E355:')\n  \" should trigger, use correct option name\n  call setbufvar(bnum, '&backup', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 16: Setting number option using setwinvar\"\n  let g:options = [['number', 0, 0, '', 1, 'local', 'setlocal']]\n  call setwinvar(0, '&number', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 17: Setting key option, shouldn't trigger\"\n  let g:options = [['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']]\n  setlocal key=blah\n  setlocal key=\n  call assert_equal([['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 18a: Setting string global option\"\n  let oldval = &backupext\n  let g:options = [['backupext', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set backupext=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18b: Resetting string global option\"\n  let g:options = [['backupext', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set backupext&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18c: Setting global string global option\"\n  let g:options = [['backupext', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal backupext=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18d: Setting local string global option\"\n  \" As this is a global option this sets the global value even though\n  \" :setlocal is used!\n  noa set backupext& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['backupext', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal backupext=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18e: Setting again string global option\"\n  noa setglobal backupext=ext_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal backupext=ext_local \" Sets the global(!) value!\n  let g:options = [['backupext', 'ext_local', 'ext_local', 'ext_local', 'fuu', 'global', 'set']]\n  set backupext=fuu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 19a: Setting string global-local (to buffer) option\"\n  let oldval = &tags\n  let g:options = [['tags', oldval, oldval, oldval, 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19b: Resetting string global-local (to buffer) option\"\n  let g:options = [['tags', 'tagpath', 'tagpath', 'tagpath', oldval, 'global', 'set']]\n  set tags&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19c: Setting global string global-local (to buffer) option \"\n  let g:options = [['tags', oldval, '', oldval, 'tagpath1', 'global', 'setglobal']]\n  setglobal tags=tagpath1\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19d: Setting local string global-local (to buffer) option\"\n  let g:options = [['tags', 'tagpath1', 'tagpath1', '', 'tagpath2', 'local', 'setlocal']]\n  setlocal tags=tagpath2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19e: Setting again string global-local (to buffer) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags=tag_local\n  let g:options = [['tags', 'tag_global', 'tag_local', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19f: Setting string global-local (to buffer) option to an empty string\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa set tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags= \" empty string\n  let g:options = [['tags', 'tag_global', '', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 20a: Setting string local (to buffer) option\"\n  let oldval = &spelllang\n  let g:options = [['spelllang', oldval, oldval, oldval, 'elvish,klingon', 'global', 'set']]\n  set spelllang=elvish,klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20b: Resetting string local (to buffer) option\"\n  let g:options = [['spelllang', 'elvish,klingon', 'elvish,klingon', 'elvish,klingon', oldval, 'global', 'set']]\n  set spelllang&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20c: Setting global string local (to buffer) option\"\n  let g:options = [['spelllang', oldval, '', oldval, 'elvish', 'global', 'setglobal']]\n  setglobal spelllang=elvish\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20d: Setting local string local (to buffer) option\"\n  noa set spelllang& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['spelllang', oldval, oldval, '', 'klingon', 'local', 'setlocal']]\n  setlocal spelllang=klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20e: Setting again string local (to buffer) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal spelllang=spellglobal \" Reset global and local value (without triggering autocmd)\n  noa setlocal spelllang=spelllocal\n  let g:options = [['spelllang', 'spelllocal', 'spelllocal', 'spellglobal', 'foo', 'global', 'set']]\n  set spelllang=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 21a: Setting string global-local (to window) option\"\n  let oldval = &statusline\n  let g:options = [['statusline', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21b: Resetting string global-local (to window) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  let g:options = [['statusline', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set statusline&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21c: Setting global string global-local (to window) option\"\n  let g:options = [['statusline', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal statusline=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21d: Setting local string global-local (to window) option\"\n  noa set statusline& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['statusline', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal statusline=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21e: Setting again string global-local (to window) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal statusline=bar \" Reset global and local value (without triggering autocmd)\n  noa setlocal statusline=baz\n  let g:options = [['statusline', 'bar', 'baz', 'bar', 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 22a: Setting string local (to window) option\"\n  let oldval = &foldignore\n  let g:options = [['foldignore', oldval, oldval, oldval, 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22b: Resetting string local (to window) option\"\n  let g:options = [['foldignore', 'fo', 'fo', 'fo', oldval, 'global', 'set']]\n  set foldignore&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22c: Setting global string local (to window) option\"\n  let g:options = [['foldignore', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal foldignore=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22d: Setting local string local (to window) option\"\n  noa set foldignore& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['foldignore', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal foldignore=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22e: Setting again string local (to window) option\"\n  noa setglobal foldignore=glob \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldignore=loc\n  let g:options = [['foldignore', 'loc', 'loc', 'glob', 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 23a: Setting global number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '', '1', '2', 'global', 'setglobal']]\n  setglobal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23b: Setting local number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23c: Setting again number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '1', '1', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23d: Setting again number global option\"\n  noa set cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cmdheight', '8', '8', '8', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 24a: Setting global number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24b: Setting local number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24c: Setting again number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '1', '1', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24d: Setting again global number global-local (to buffer) option\"\n  noa set undolevels=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['undolevels', '8', '8', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 25a: Setting global number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25b: Setting local number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25c: Setting again number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '1', '1', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25d: Setting again global number local (to buffer) option\"\n  noa set wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['wrapmargin', '8', '8', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 26: Setting number global-local (to window) option.\n  \" Such option does currently not exist.\n\n\n  \" 27a: Setting global number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27b: Setting local number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27c: Setting again number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '1', '1', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27d: Setting again global number local (to window) option\"\n  noa set foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['foldcolumn', '8', '8', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 28a: Setting global boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '', '1', '0', 'global', 'setglobal']]\n  setglobal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28b: Setting local boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28c: Setting again boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '1', '1', '0', 'global', 'set']]\n  set nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28d: Setting again global boolean global option\"\n  noa set nowrapscan \" Reset global and local value (without triggering autocmd)\n  let g:options = [['wrapscan', '0', '0', '0', '1', 'global', 'set']]\n  set wrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 29a: Setting global boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29b: Setting local boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal noautoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29c: Setting again boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '1', '1', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29d: Setting again global boolean global-local (to buffer) option\"\n  noa set noautoread \" Reset global and local value (without triggering autocmd)\n  let g:options = [['autoread', '0', '0', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 30a: Setting global boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30b: Setting local boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30c: Setting again boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '1', '1', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30d: Setting again global boolean local (to buffer) option\"\n  noa set nocindent \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cindent', '0', '0', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 31: Setting boolean global-local (to window) option\n  \" Currently no such option exists.\n\n\n  \" 32a: Setting global boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32b: Setting local boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32c: Setting again boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '1', '1', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32d: Setting again global boolean local (to window) option\"\n  noa set nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cursorcolumn', '0', '0', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 33: Test autocommands when an option value is converted internally.\n  noa set backspace=1 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['backspace', 'indent,eol', 'indent,eol', 'indent,eol', '2', 'global', 'set']]\n  set backspace=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" Cleanup\n  au! OptionSet\n  \" set tags&\n  for opt in ['nu', 'ai', 'acd', 'ar', 'bs', 'backup', 'cul', 'cp', 'backupext', 'tags', 'spelllang', 'statusline', 'foldignore', 'cmdheight', 'undolevels', 'wrapmargin', 'foldcolumn', 'wrapscan', 'autoread', 'cindent', 'cursorcolumn']\n    exe printf(\":set %s&vim\", opt)\n  endfor\n  call test_override('starting', 0)\n  delfunc! AutoCommandOptionSet\nendfunc\n\nfunc Test_OptionSet_diffmode()\n  call test_override('starting', 1)\n  \" 18: Changing an option when entering diff mode\n  new\n  au OptionSet diff :let &l:cul = v:option_new\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  diffoff\n  call assert_equal(0, &l:cul)\n  call assert_equal(1, getwinvar(2, '&l:cul'))\n  bw!\n\n  call assert_equal(1, &l:cul)\n  diffoff!\n  call assert_equal(0, &l:cul)\n  call assert_equal(0, getwinvar(1, '&l:cul'))\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\nendfunc\n\nfunc Test_OptionSet_diffmode_close()\n  call test_override('starting', 1)\n  \" 19: Try to close the current window when entering diff mode\n  \" should not segfault\n  new\n  au OptionSet diff close\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_fails(':diffthis', 'E788:')\n  call assert_equal(1, &diff)\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_fails(':diffthis', 'E788:')\n  call assert_equal(1, &diff)\n  set diffopt-=closeoff\n  bw!\n  call assert_fails(':diffoff!', 'E788:')\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\n  \"delfunc! AutoCommandOptionSet\nendfunc\n\n\" Test for Bufleave autocommand that deletes the buffer we are about to edit.\nfunc Test_BufleaveWithDelete()\n  new | edit XbufLeave1\n\n  augroup test_bufleavewithdelete\n      autocmd!\n      autocmd BufLeave XbufLeave1 bwipe XbufLeave2\n  augroup END\n\n  call assert_fails('edit XbufLeave2', 'E143:')\n  call assert_equal('XbufLeave1', bufname('%'))\n\n  autocmd! test_bufleavewithdelete BufLeave XbufLeave1\n  augroup! test_bufleavewithdelete\n\n  new\n  bwipe! XbufLeave1\nendfunc\n\n\" Test for autocommand that changes the buffer list, when doing \":ball\".\nfunc Test_Acmd_BufAll()\n  enew!\n  %bwipe!\n  call writefile(['Test file Xxx1'], 'Xxx1', 'D')\n  call writefile(['Test file Xxx2'], 'Xxx2', 'D')\n  call writefile(['Test file Xxx3'], 'Xxx3', 'D')\n\n  \" Add three files to the buffer list\n  split Xxx1\n  close\n  split Xxx2\n  close\n  split Xxx3\n  close\n\n  \" Wipe the buffer when the buffer is opened\n  au BufReadPost Xxx2 bwipe\n\n  call append(0, 'Test file Xxx4')\n  ball\n\n  call assert_equal(2, winnr('$'))\n  call assert_equal('Xxx1', bufname(winbufnr(winnr('$'))))\n  wincmd t\n\n  au! BufReadPost\n  %bwipe!\n  enew! | only\nendfunc\n\n\" Test for autocommand that changes current buffer on BufEnter event.\n\" Check if modelines are interpreted for the correct buffer.\nfunc Test_Acmd_BufEnter()\n  %bwipe!\n  call writefile(['start of test file Xxx1',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx1'], 'Xxx1', 'D')\n  call writefile(['start of test file Xxx2',\n\t      \\ 'vim: set noai :',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx2'], 'Xxx2', 'D')\n\n  au BufEnter Xxx2 brew\n  set ai modeline modelines=3\n  edit Xxx1\n  \" edit Xxx2, autocmd will do :brew\n  edit Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" Append text with autoindent to this file\n  normal othis should be auto-indented\n  call assert_equal(\"\\<Tab>this should be auto-indented\", getline('.'))\n  call assert_equal(3, line('.'))\n  \" Remove autocmd and edit Xxx2 again\n  au! BufEnter Xxx2\n  buf! Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" append text without autoindent to Xxx\n  normal othis should be in column 1\n  call assert_equal(\"this should be in column 1\", getline('.'))\n  call assert_equal(4, line('.'))\n\n  %bwipe!\n  set ai&vim modeline&vim modelines&vim\nendfunc\n\n\" Test for issue #57\n\" do not move cursor on <c-o> when autoindent is set\nfunc Test_ai_CTRL_O()\n  enew!\n  set ai\n  let save_fo = &fo\n  set fo+=r\n  exe \"normal o# abcdef\\<Esc>2hi\\<CR>\\<C-O>d0\\<Esc>\"\n  exe \"normal o# abcdef\\<Esc>2hi\\<C-O>d0\\<Esc>\"\n  call assert_equal(['# abc', 'def', 'def'], getline(2, 4))\n\n  set ai&vim\n  let &fo = save_fo\n  enew!\nendfunc\n\n\" Test for autocommand that deletes the current buffer on BufLeave event.\n\" Also test deleting the last buffer, should give a new, empty buffer.\nfunc Test_BufLeave_Wipe()\n  %bwipe!\n  let content = ['start of test file Xxx',\n\t      \\ 'this is a test',\n\t      \\ 'end of test file Xxx']\n  call writefile(content, 'Xxx1', 'D')\n  call writefile(content, 'Xxx2', 'D')\n\n  au BufLeave Xxx2 bwipe\n  edit Xxx1\n  split Xxx2\n  \" delete buffer Xxx2, we should be back to Xxx1\n  bwipe\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal(1, winnr('$'))\n\n  \" Create an alternate buffer\n  %write! test.out\n  call assert_equal('test.out', bufname('#'))\n  \" delete alternate buffer\n  bwipe test.out\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal('', bufname('#'))\n\n  au BufLeave Xxx1 bwipe\n  \" delete current buffer, get an empty one\n  bwipe!\n  call assert_equal(1, line('$'))\n  call assert_equal('', bufname('%'))\n  let g:bufinfo = getbufinfo()\n  call assert_equal(1, len(g:bufinfo))\n\n  call delete('test.out')\n  %bwipe\n  au! BufLeave\n\n  \" check that bufinfo doesn't contain a pointer to freed memory\n  call test_garbagecollect_now()\nendfunc\n\nfunc Test_QuitPre()\n  edit Xfoo\n  let winid = win_getid(winnr())\n  split Xbar\n  au! QuitPre * let g:afile = expand('<afile>')\n  \" Close the other window, <afile> should be correct.\n  exe win_id2win(winid) . 'q'\n  call assert_equal('Xfoo', g:afile)\n\n  unlet g:afile\n  bwipe Xfoo\n  bwipe Xbar\nendfunc\n\nfunc Test_Cmdline()\n  au! CmdlineChanged : let g:text = getcmdline()\n  let g:text = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(\"echom 'hello'\", g:text)\n  au! CmdlineChanged\n\n  au! CmdlineChanged : let g:entered = expand('<afile>')\n  let g:entered = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  au! CmdlineChanged\n\n  au! CmdlineEnter : let g:entered = expand('<afile>')\n  au! CmdlineLeave : let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  call feedkeys(\":echo 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  call assert_equal(':', g:left)\n  au! CmdlineEnter\n  au! CmdlineLeave\n\n  let save_shellslash = &shellslash\n  set noshellslash\n  au! CmdlineEnter / let g:entered = expand('<afile>')\n  au! CmdlineLeave / let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  new\n  call setline(1, 'hello')\n  call feedkeys(\"/hello\\<CR>\", 'xt')\n  call assert_equal('/', g:entered)\n  call assert_equal('/', g:left)\n  bwipe!\n  au! CmdlineEnter\n  au! CmdlineLeave\n  let &shellslash = save_shellslash\nendfunc\n\n\" Test for BufWritePre autocommand that deletes or unloads the buffer.\nfunc Test_BufWritePre()\n  %bwipe\n  au BufWritePre Xxx1 bunload\n  au BufWritePre Xxx2 bwipe\n\n  call writefile(['start of Xxx1', 'test', 'end of Xxx1'], 'Xxx1', 'D')\n  call writefile(['start of Xxx2', 'test', 'end of Xxx2'], 'Xxx2', 'D')\n\n  edit Xtest\n  e! Xxx2\n  bdel Xtest\n  e Xxx1\n  \" write it, will unload it and give an error msg\n  call assert_fails('w', 'E203:')\n  call assert_equal('Xxx2', bufname('%'))\n  edit Xtest\n  e! Xxx2\n  bwipe Xtest\n  \" write it, will delete the buffer and give an error msg\n  call assert_fails('w', 'E203:')\n  call assert_equal('Xxx1', bufname('%'))\n  au! BufWritePre\nendfunc\n\n\" Test for BufUnload autocommand that unloads all the other buffers\nfunc Test_bufunload_all()\n  let g:test_is_flaky = 1\n  call writefile(['Test file Xxx1'], 'Xxx1', 'D')\"\n  call writefile(['Test file Xxx2'], 'Xxx2', 'D')\"\n\n  let content =<< trim [CODE]\n    func UnloadAllBufs()\n      let i = 1\n      while i <= bufnr('$')\n        if i != bufnr('%') && bufloaded(i)\n          exe  i . 'bunload'\n        endif\n        let i += 1\n      endwhile\n    endfunc\n    au BufUnload * call UnloadAllBufs()\n    au VimLeave * call writefile(['Test Finished'], 'Xout')\n    edit Xxx1\n    split Xxx2\n    q\n  [CODE]\n\n  call writefile(content, 'Xbunloadtest', 'D')\n\n  call delete('Xout')\n  call system(GetVimCommandClean() .. ' -N --not-a-term -S Xbunloadtest')\n  call assert_true(filereadable('Xout'))\n\n  call delete('Xout')\nendfunc\n\n\" Some tests for buffer-local autocommands\nfunc Test_buflocal_autocmd()\n  let g:bname = ''\n  edit xx\n  au BufLeave <buffer> let g:bname = expand(\"%\")\n  \" here, autocommand for xx should trigger.\n  \" but autocommand shall not apply to buffer named <buffer>.\n  edit somefile\n  call assert_equal('xx', g:bname)\n  let g:bname = ''\n  \" here, autocommand shall be auto-deleted\n  bwipe xx\n  \" autocmd should not trigger\n  edit xx\n  call assert_equal('', g:bname)\n  \" autocmd should not trigger\n  edit somefile\n  call assert_equal('', g:bname)\n  enew\n  unlet g:bname\nendfunc\n\n\" Test for \"*Cmd\" autocommands\nfunc Test_Cmd_Autocmds()\n  call writefile(['start of Xxx', \"\\tabc2\", 'end of Xxx'], 'Xxx', 'D')\n\n  enew!\n  au BufReadCmd XtestA 0r Xxx|$del\n  edit XtestA\t\t\t\" will read text of Xxd instead\n  call assert_equal('start of Xxx', getline(1))\n\n  au BufWriteCmd XtestA call append(line(\"$\"), \"write\")\n  write\t\t\t\t\" will append a line to the file\n  call assert_equal('write', getline('$'))\n  call assert_fails('read XtestA', 'E484:')\t\" should not read anything\n  call assert_equal('write', getline(4))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tend of Xxx\n  \" 4\twrite\n\n  au FileReadCmd XtestB '[r Xxx\n  2r XtestB\t\t\t\" will read Xxx below line 2 instead\n  call assert_equal('start of Xxx', getline(3))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc2\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n\n  au FileWriteCmd XtestC '[,']copy $\n  normal 4GA1\n  4,5w XtestC\t\t\t\" will copy lines 4 and 5 to the end\n  call assert_equal(\"\\tabc21\", getline(8))\n  call assert_fails('r XtestC', 'E484:')\t\" should not read anything\n  call assert_equal(\"end of Xxx\", getline(9))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc21\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n  \" 8\t\tabc21\n  \" 9\tend of Xxx\n\n  let g:lines = []\n  au FileAppendCmd XtestD call extend(g:lines, getline(line(\"'[\"), line(\"']\")))\n  w >>XtestD\t\t\t\" will add lines to 'lines'\n  call assert_equal(9, len(g:lines))\n  call assert_fails('$r XtestD', 'E484:')\t\" should not read anything\n  call assert_equal(9, line('$'))\n  call assert_equal('end of Xxx', getline('$'))\n\n  au BufReadCmd XtestE 0r Xxx|$del\n  sp XtestE\t\t\t\" split window with test.out\n  call assert_equal('end of Xxx', getline(3))\n\n  let g:lines = []\n  exe \"normal 2Goasdf\\<Esc>\\<C-W>\\<C-W>\"\n  au BufWriteCmd XtestE call extend(g:lines, getline(0, '$'))\n  wall\t\t\t\t\" will write other window to 'lines'\n  call assert_equal(4, len(g:lines), g:lines)\n  call assert_equal('asdf', g:lines[2])\n\n  au! BufReadCmd\n  au! BufWriteCmd\n  au! FileReadCmd\n  au! FileWriteCmd\n  au! FileAppendCmd\n  %bwipe!\n  enew!\nendfunc\n\nfunc s:ReadFile()\n  setl noswapfile nomodified\n  let filename = resolve(expand(\"<afile>:p\"))\n  execute 'read' fnameescape(filename)\n  1d_\n  exe 'file' fnameescape(filename)\n  setl buftype=acwrite\nendfunc\n\nfunc s:WriteFile()\n  let filename = resolve(expand(\"<afile>:p\"))\n  setl buftype=\n  noautocmd execute 'write' fnameescape(filename)\n  setl buftype=acwrite\n  setl nomodified\nendfunc\n\nfunc Test_BufReadCmd()\n  autocmd BufReadCmd *.test call s:ReadFile()\n  autocmd BufWriteCmd *.test call s:WriteFile()\n\n  call writefile(['one', 'two', 'three'], 'Xcmd.test', 'D')\n  edit Xcmd.test\n  call assert_match('Xcmd.test\" line 1 of 3', execute('file'))\n  normal! Gofour\n  write\n  call assert_equal(['one', 'two', 'three', 'four'], readfile('Xcmd.test'))\n\n  bwipe!\n  au! BufReadCmd\n  au! BufWriteCmd\nendfunc\n\nfunc Test_BufWriteCmd()\n  autocmd BufWriteCmd Xbufwritecmd let g:written = 1\n  new\n  file Xbufwritecmd\n  set buftype=acwrite\n  call mkdir('Xbufwritecmd', 'D')\n  write\n  \" BufWriteCmd should be triggered even if a directory has the same name\n  call assert_equal(1, g:written)\n  unlet g:written\n  au! BufWriteCmd\n  bwipe!\nendfunc\n\nfunc SetChangeMarks(start, end)\n  exe a:start .. 'mark ['\n  exe a:end .. 'mark ]'\nendfunc\n\n\" Verify the effects of autocmds on '[ and ']\nfunc Test_change_mark_in_autocmds()\n  edit! Xtest\n  call feedkeys(\"ia\\<CR>b\\<CR>c\\<CR>d\\<C-g>u\\<Esc>\", 'xtn')\n\n  call SetChangeMarks(2, 3)\n  write\n  call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n\n  call SetChangeMarks(2, 3)\n  au BufWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write\n  au! BufWritePre\n\n  if has('unix')\n    write XtestFilter\n    write >> XtestFilter\n\n    call SetChangeMarks(2, 3)\n    \" Marks are set to the entire range of the write\n    au FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    \" '[ is adjusted to just before the line that will receive the filtered\n    \" data\n    au FilterReadPre * call assert_equal([4, 4], [line(\"'[\"), line(\"']\")])\n    \" The filtered data is read into the buffer, and the source lines are\n    \" still present, so the range is after the source lines\n    au FilterReadPost * call assert_equal([5, 12], [line(\"'[\"), line(\"']\")])\n    %!cat XtestFilter\n    \" After the filtered data is read, the original lines are deleted\n    call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call SetChangeMarks(1, 4)\n    au FilterWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPre * call assert_equal([3, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n    2,3!cat XtestFilter\n    call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call delete('XtestFilter')\n  endif\n\n  call SetChangeMarks(1, 4)\n  au FileWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write Xtest2\n  au! FileWritePre\n\n  call SetChangeMarks(2, 3)\n  au FileAppendPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 4)\n  au FileAppendPre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 1)\n  au FileReadPre * call assert_equal([3, 1], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n  3read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n  0read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n  1read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  bwipe!\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_Filter_noshelltemp()\n  CheckExecutable cat\n\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  let shelltemp = &shelltemp\n  set shelltemp\n\n  let g:filter_au = 0\n  au FilterWritePre * let g:filter_au += 1\n  au FilterReadPre * let g:filter_au += 1\n  au FilterReadPost * let g:filter_au += 1\n  %!cat\n  call assert_equal(3, g:filter_au)\n\n  if has('filterpipe')\n    set noshelltemp\n\n    let g:filter_au = 0\n    au FilterWritePre * let g:filter_au += 1\n    au FilterReadPre * let g:filter_au += 1\n    au FilterReadPost * let g:filter_au += 1\n    %!cat\n    call assert_equal(0, g:filter_au)\n  endif\n\n  au! FilterWritePre,FilterReadPre,FilterReadPost\n  let &shelltemp = shelltemp\n  bwipe!\nendfunc\n\nfunc Test_TextYankPost()\n  enew!\n  call setline(1, ['foo'])\n\n  let g:event = []\n  au TextYankPost * let g:event = copy(v:event)\n\n  call assert_equal({}, v:event)\n  call assert_fails('let v:event = {}', 'E46:')\n  call assert_fails('let v:event.mykey = 0', 'E742:')\n\n  norm \"ayiw\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: 'a', operator: 'y',\n        \\   regtype: 'v', visual: v:false, inclusive: v:true},\n        \\ g:event)\n  norm y_\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: '',  operator: 'y', regtype: 'V',\n        \\   visual: v:false, inclusive: v:false},\n        \\ g:event)\n  norm Vy\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: '',  operator: 'y', regtype: 'V',\n        \\   visual: v:true, inclusive: v:true},\n        \\ g:event)\n  call feedkeys(\"\\<C-V>y\", 'x')\n  call assert_equal(\n        \\ #{regcontents: ['f'], regname: '',  operator: 'y', regtype: \"\\x161\",\n        \\   visual: v:true, inclusive: v:true},\n        \\ g:event)\n  norm \"xciwbar\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: 'x', operator: 'c', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n  norm \"bdiw\n  call assert_equal(\n        \\ #{regcontents: ['bar'], regname: 'b', operator: 'd', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n\n  call setline(1, 'foobar')\n  \" exclusive motion\n  norm $\"ay0\n  call assert_equal(\n        \\ #{regcontents: ['fooba'], regname: 'a', operator: 'y', regtype: 'v',\n        \\   visual: v:false, inclusive: v:false},\n        \\ g:event)\n  \" inclusive motion\n  norm 0\"ay$\n  call assert_equal(\n        \\ #{regcontents: ['foobar'], regname: 'a', operator: 'y', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n\n  call assert_equal({}, v:event)\n\n  if has('clipboard_working') && !has('gui_running')\n    \" Test that when the visual selection is automatically copied to clipboard\n    \" register a TextYankPost is emitted\n    call setline(1, ['foobar'])\n\n    let @* = ''\n    set clipboard=autoselect\n    exe \"norm! ggviw\\<Esc>\"\n    call assert_equal(\n          \\ #{regcontents: ['foobar'], regname: '*', operator: 'y',\n          \\   regtype: 'v', visual: v:true, inclusive: v:false},\n          \\ g:event)\n\n    let @+ = ''\n    set clipboard=autoselectplus\n    exe \"norm! ggviw\\<Esc>\"\n    call assert_equal(\n          \\ #{regcontents: ['foobar'], regname: '+', operator: 'y',\n          \\   regtype: 'v', visual: v:true, inclusive: v:false},\n          \\ g:event)\n\n    set clipboard&vim\n  endif\n\n  au! TextYankPost\n  unlet g:event\n  bwipe!\nendfunc\n\nfunc Test_autocommand_all_events()\n  call assert_fails('au * * bwipe', 'E1155:')\n  call assert_fails('au * x bwipe', 'E1155:')\n  call assert_fails('au! * x bwipe', 'E1155:')\nendfunc\n\nfunc Test_autocmd_user()\n  au User MyEvent let s:res = [expand(\"<afile>\"), expand(\"<amatch>\")]\n  doautocmd User MyEvent\n  call assert_equal(['MyEvent', 'MyEvent'], s:res)\n  au! User\n  unlet s:res\nendfunc\n\nfunction s:Before_test_dirchanged()\n  augroup test_dirchanged\n    autocmd!\n  augroup END\n  let s:li = []\n  let s:dir_this = getcwd()\n  let s:dir_foo = s:dir_this . '/Xfoo'\n  call mkdir(s:dir_foo)\n  let s:dir_bar = s:dir_this . '/Xbar'\n  call mkdir(s:dir_bar)\nendfunc\n\nfunction s:After_test_dirchanged()\n  call chdir(s:dir_this)\n  call delete(s:dir_foo, 'd')\n  call delete(s:dir_bar, 'd')\n  augroup test_dirchanged\n    autocmd!\n  augroup END\nendfunc\n\nfunction Test_dirchanged_global()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChangedPre global call add(s:li, expand(\"<amatch>\") .. \" pre cd \" .. v:event.directory)\n  autocmd test_dirchanged DirChanged global call add(s:li, \"cd:\")\n  autocmd test_dirchanged DirChanged global call add(s:li, expand(\"<afile>\"))\n  call chdir(s:dir_foo)\n  let expected = [\"global pre cd \" .. s:dir_foo, \"cd:\", s:dir_foo]\n  call assert_equal(expected, s:li)\n  call chdir(s:dir_foo)\n  call assert_equal(expected, s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal(expected, s:li)\n\n  exe 'cd ' .. s:dir_foo\n  exe 'cd ' .. s:dir_bar\n  autocmd! test_dirchanged DirChanged global let g:result = expand(\"<afile>\")\n  cd -\n  call assert_equal(s:dir_foo, substitute(g:result, '\\\\', '/', 'g'))\n\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_local()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChanged window call add(s:li, \"lcd:\")\n  autocmd test_dirchanged DirChanged window call add(s:li, expand(\"<afile>\"))\n  call chdir(s:dir_foo)\n  call assert_equal([], s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_auto()\n  CheckOption autochdir\n  call s:Before_test_dirchanged()\n  call test_autochdir()\n  autocmd test_dirchanged DirChangedPre auto call add(s:li, \"pre cd \" .. v:event.directory)\n  autocmd test_dirchanged DirChanged auto call add(s:li, \"auto:\")\n  autocmd test_dirchanged DirChanged auto call add(s:li, expand(\"<afile>\"))\n  set acd\n  cd ..\n  call assert_equal([], s:li)\n  exe 'edit ' . s:dir_foo . '/Xautofile'\n  call assert_equal(s:dir_foo, getcwd())\n  let expected = [\"pre cd \" .. s:dir_foo, \"auto:\", s:dir_foo]\n  call assert_equal(expected, s:li)\n  set noacd\n  bwipe!\n  call s:After_test_dirchanged()\nendfunc\n\n\" Test TextChangedI and TextChangedP\nfunc Test_ChangedP()\n  new\n  call setline(1, ['foo', 'bar', 'foobar'])\n  call test_override(\"char_avail\", 1)\n  set complete=. completeopt=menuone\n\n  func! TextChangedAutocmd(char)\n    let g:autocmd .= a:char\n  endfunc\n\n  \" TextChanged will not be triggered, only check that it isn't.\n  au! TextChanged <buffer> :call TextChangedAutocmd('N')\n  au! TextChangedI <buffer> :call TextChangedAutocmd('I')\n  au! TextChangedP <buffer> :call TextChangedAutocmd('P')\n\n  call cursor(3, 1)\n  let g:autocmd = ''\n  call feedkeys(\"o\\<esc>\", 'tnix')\n  call assert_equal('I', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\", 'tnix')\n  call assert_equal('II', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\", 'tnix')\n  call assert_equal('IIP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPPP', g:autocmd)\n\n  call assert_equal(['foo', 'bar', 'foobar', 'foo'], getline(1, '$'))\n  \" TODO: how should it handle completeopt=noinsert,noselect?\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged\n  au! TextChangedI\n  au! TextChangedP\n  delfu TextChangedAutocmd\n  unlet! g:autocmd\n  set complete&vim completeopt&vim\n\n  bw!\nendfunc\n\nlet g:setline_handled = v:false\nfunc SetLineOne()\n  if !g:setline_handled\n    call setline(1, \"(x)\")\n    let g:setline_handled = v:true\n  endif\nendfunc\n\nfunc Test_TextChangedI_with_setline()\n  new\n  call test_override('char_avail', 1)\n  autocmd TextChangedI <buffer> call SetLineOne()\n  call feedkeys(\"i(\\<CR>\\<Esc>\", 'tx')\n  call assert_equal('(', getline(1))\n  call assert_equal('x)', getline(2))\n  undo\n  call assert_equal('', getline(1))\n  call assert_equal('', getline(2))\n\n  call test_override('char_avail', 0)\n  bwipe!\nendfunc\n\nfunc Test_Changed_FirstTime()\n  CheckFeature terminal\n  CheckNotGui\n  \" Starting a terminal to run Vim is always considered flaky.\n  let g:test_is_flaky = 1\n\n  \" Prepare file for TextChanged event.\n  call writefile([''], 'Xchanged.txt', 'D')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile'], {'term_rows': 3})\n  call assert_equal('running', term_getstatus(buf))\n  \" Wait for the ruler (in the status line) to be shown.\n  \" In ConPTY, there is additional character which is drawn up to the width of\n  \" the screen.\n  if has('conpty')\n    call WaitForAssert({-> assert_match('\\<All.*$', term_getline(buf, 3))})\n  else\n    call WaitForAssert({-> assert_match('\\<All$', term_getline(buf, 3))})\n  endif\n  \" It's only adding autocmd, so that no event occurs.\n  call term_sendkeys(buf, \":au! TextChanged <buffer> call writefile(['No'], 'Xchanged.txt')\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-\\\\>\\<C-N>:qa!\\<cr>\")\n  call WaitForAssert({-> assert_equal('finished', term_getstatus(buf))})\n  call assert_equal([''], readfile('Xchanged.txt'))\n\n  \" clean up\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested()\n  let g:did_nested = 0\n  augroup Testing\n    au WinNew * edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(0, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" old nested argument still works\n  augroup Testing\n    au!\n    au WinNew * nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" New ++nested argument works\n  augroup Testing\n    au!\n    au WinNew * ++nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" nested without ++ does not work in Vim9 script\n  call assert_fails('vim9cmd au WinNew * nested echo fails', 'E1078:')\n\n  augroup Testing\n    au!\n  augroup END\n\n  call assert_fails('au WinNew * ++nested ++nested echo bad', 'E983:')\n  call assert_fails('au WinNew * nested nested echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_nested_cursor_invalid()\n  set laststatus=0\n  copen\n  cclose\n  call setline(1, ['foo', 'bar', 'baz'])\n  3\n  augroup nested_inv\n    autocmd User foo ++nested copen\n    autocmd BufAdd * let &laststatus = 2 - &laststatus\n  augroup END\n  doautocmd User foo\n\n  augroup nested_inv\n    au!\n  augroup END\n  set laststatus&\n  cclose\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested_keeps_cursor_pos()\n  enew\n  call setline(1, 'foo')\n  autocmd User foo ++nested normal! $a\n  autocmd InsertLeave * :\n  doautocmd User foo\n  call assert_equal([0, 1, 3, 0], getpos('.'))\n\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested_switch_window()\n  \" run this in a separate Vim so that SafeState works\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      vim9script\n      ['()']->writefile('Xautofile')\n      autocmd VimEnter * ++nested edit Xautofile | split\n      autocmd BufReadPost * autocmd SafeState * ++once foldclosed('.')\n      autocmd WinEnter * matchadd('ErrorMsg', 'pat')\n  END\n  call writefile(lines, 'Xautoscript', 'D')\n  let buf = RunVimInTerminal('-S Xautoscript', {'rows': 10})\n  call VerifyScreenDump(buf, 'Test_autocmd_nested_switch', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xautofile')\nendfunc\n\nfunc Test_autocmd_once()\n  \" Without ++once WinNew triggers twice\n  let g:did_split = 0\n  augroup Testing\n    au WinNew * let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(2, g:did_split)\n  call assert_true(exists('#WinNew'))\n  close\n  close\n\n  \" With ++once WinNew triggers once\n  let g:did_split = 0\n  augroup Testing\n    au!\n    au WinNew * ++once let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(1, g:did_split)\n  call assert_false(exists('#WinNew'))\n  close\n  close\n\n  call assert_fails('au WinNew * ++once ++once echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_bufreadpre()\n  new\n  let b:bufreadpre = 1\n  call append(0, range(1000))\n  w! XAutocmdBufReadPre.txt\n  autocmd BufReadPre <buffer> :let b:bufreadpre += 1\n  norm! 500gg\n  sp\n  norm! 1000gg\n  wincmd p\n  let g:wsv1 = winsaveview()\n  wincmd p\n  let g:wsv2 = winsaveview()\n  \" triggers BufReadPre, should not move the cursor in either window\n  \" The topline may change one line in a large window.\n  edit\n  call assert_inrange(g:wsv2.topline - 1, g:wsv2.topline + 1, winsaveview().topline)\n  call assert_equal(g:wsv2.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  \" Now set the cursor position in an BufReadPre autocommand\n  \" (even though the position will be invalid, this should make Vim reset the\n  \" cursor position in the other window.\n  wincmd p\n  set cpo+=g\n  \" won't do anything, but try to set the cursor on an invalid lnum\n  autocmd BufReadPre <buffer> :norm! 70gg\n  \" triggers BufReadPre, should not move the cursor in either window\n  e\n  call assert_equal(1, winsaveview().topline)\n  call assert_equal(1, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  close\n  close\n  call delete('XAutocmdBufReadPre.txt')\n  set cpo-=g\nendfunc\n\n\" FileChangedShell tested in test_filechanged.vim\n\n\" Tests for the following autocommands:\n\" - FileWritePre\twriting a compressed file\n\" - FileReadPost\treading a compressed file\n\" - BufNewFile\t\treading a file template\n\" - BufReadPre\t\tdecompressing the file to be read\n\" - FilterReadPre\tsubstituting characters in the temp file\n\" - FilterReadPost\tsubstituting characters after filtering\n\" - FileReadPre\t\tset options for decompression\n\" - FileReadPost\tdecompress the file\nfunc Test_ReadWrite_Autocmds()\n  \" Run this test only on Unix-like systems and if gzip is available\n  CheckUnix\n  CheckExecutable gzip\n\n  \" Make $GZIP empty, \"-v\" would cause trouble.\n  let $GZIP = \"\"\n\n  \" Use a FileChangedShell autocommand to avoid a prompt for 'Xtestfile.gz'\n  \" being modified outside of Vim (noticed on Solaris).\n  au FileChangedShell * echo 'caught FileChangedShell'\n\n  \" Test for the FileReadPost, FileWritePre and FileWritePost autocmds\n  augroup Test1\n    au!\n    au FileWritePre    *.gz   '[,']!gzip\n    au FileWritePost   *.gz   undo\n    au FileReadPost    *.gz   '[,']!gzip -d\n  augroup END\n\n  new\n  set bin\n  call append(0, [\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ])\n  1,9write! Xtestfile.gz\n  enew! | close\n\n  new\n  \" Read and decompress the testfile\n  0read Xtestfile.gz\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  enew! | close\n\n  augroup Test1\n    au!\n  augroup END\n\n  \" Test for the FileAppendPre and FileAppendPost autocmds\n  augroup Test2\n    au!\n    au BufNewFile      *.c    read Xtest.c\n    au FileAppendPre   *.out  '[,']s/new/NEW/\n    au FileAppendPost  *.out  !cat Xtest.c >> test.out\n  augroup END\n\n  call writefile(['/*', ' * Here is a new .c file', ' */'], 'Xtest.c', 'D')\n  new foo.c\t\t\t\" should load Xtest.c\n  call assert_equal(['/*', ' * Here is a new .c file', ' */'], getline(2, 4))\n  w! >> test.out\t\t\" append it to the output file\n\n  let contents = readfile('test.out')\n  call assert_equal(' * Here is a NEW .c file', contents[2])\n  call assert_equal(' * Here is a new .c file', contents[5])\n\n  call delete('test.out')\n  enew! | close\n  augroup Test2\n    au!\n  augroup END\n\n  \" Test for the BufReadPre and BufReadPost autocmds\n  augroup Test3\n    au!\n    \" setup autocommands to decompress before reading and re-compress\n    \" afterwards\n    au BufReadPre  *.gz  exe '!gzip -d ' . shellescape(expand(\"<afile>\"))\n    au BufReadPre  *.gz  call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au BufReadPost *.gz  call rename(expand(\"<afile>\"), expand(\"<afile>:r\"))\n    au BufReadPost *.gz  exe '!gzip ' . shellescape(expand(\"<afile>:r\"))\n  augroup END\n\n  e! Xtestfile.gz\t\t\" Edit compressed file\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n\n  w! >> test.out\t\t\" Append it to the output file\n\n  augroup Test3\n    au!\n  augroup END\n\n  \" Test for the FilterReadPre and FilterReadPost autocmds.\n  set shelltemp\t\t\t\" need temp files here\n  augroup Test4\n    au!\n    au FilterReadPre   *.out  call rename(expand(\"<afile>\"), expand(\"<afile>\") . \".t\")\n    au FilterReadPre   *.out  exe 'silent !sed s/e/E/ ' . shellescape(expand(\"<afile>\")) . \".t >\" . shellescape(expand(\"<afile>\"))\n    au FilterReadPre   *.out  exe 'silent !rm ' . shellescape(expand(\"<afile>\")) . '.t'\n    au FilterReadPost  *.out  '[,']s/x/X/g\n  augroup END\n\n  e! test.out\t\t\t\" Edit the output file\n  1,$!cat\n  call assert_equal([\n\t      \\ 'linE 2\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 3\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 4\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 5\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 6\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 7\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 8\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 9\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 10 AbcdefghijklmnopqrstuvwXyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('test.out'))\n\n  augroup Test4\n    au!\n  augroup END\n  set shelltemp&vim\n\n  \" Test for the FileReadPre and FileReadPost autocmds.\n  augroup Test5\n    au!\n    au FileReadPre *.gz exe 'silent !gzip -d ' . shellescape(expand(\"<afile>\"))\n    au FileReadPre *.gz call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au FileReadPost *.gz '[,']s/l/L/\n  augroup END\n\n  new\n  0r Xtestfile.gz\t\t\" Read compressed file\n  call assert_equal([\n\t      \\ 'Line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('Xtestfile.gz'))\n\n  augroup Test5\n    au!\n  augroup END\n\n  au! FileChangedShell\n  call delete('Xtestfile.gz')\n  call delete('test.out')\nendfunc\n\nfunc Test_throw_in_BufWritePre()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call assert_false(filereadable('Xthefile'))\n  augroup throwing\n    au BufWritePre X* throw 'do not write'\n  augroup END\n  try\n    w Xthefile\n  catch\n    let caught = 1\n  endtry\n  call assert_equal(1, caught)\n  call assert_false(filereadable('Xthefile'))\n\n  bwipe!\n  au! throwing\nendfunc\n\nfunc Test_autocmd_in_try_block()\n  call mkdir('Xintrydir', 'R')\n  au BufEnter * let g:fname = expand('%')\n  try\n    edit Xintrydir/\n  endtry\n  call assert_match('Xintrydir', g:fname)\n\n  unlet g:fname\n  au! BufEnter\nendfunc\n\nfunc Test_autocmd_SafeState()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n\tlet g:safe = 0\n\tlet g:again = ''\n\tau SafeState * let g:safe += 1\n\tau SafeStateAgain * let g:again ..= 'x'\n\tfunc CallTimer()\n\t  call timer_start(10, {id -> execute('let g:again ..= \"t\"')})\n\tendfunc\n  END\n  call writefile(lines, 'XSafeState', 'D')\n  let buf = RunVimInTerminal('-S XSafeState', #{rows: 6})\n\n  \" Sometimes we loop to handle a K_IGNORE, SafeState may be triggered once or\n  \" more often.\n  call term_sendkeys(buf, \":echo g:safe\\<CR>\")\n  call WaitForAssert({-> assert_match('^\\d ', term_getline(buf, 6))}, 1000)\n\n  \" SafeStateAgain should be invoked at least three times\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('^xxx', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \":let g:again = ''\\<CR>:call CallTimer()\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('xtx', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_autocmd_CmdWinEnter()\n  CheckRunVimInTerminal\n  CheckFeature cmdwin\n\n  let lines =<< trim END\n    augroup vimHints | au! | augroup END\n    let b:dummy_var = 'This is a dummy'\n    autocmd CmdWinEnter * quit\n    let winnr = winnr('$')\n  END\n  let filename = 'XCmdWinEnter'\n  call writefile(lines, filename)\n  let buf = RunVimInTerminal('-S '.filename, #{rows: 6})\n\n  call term_sendkeys(buf, \"q:\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo b:dummy_var\\<cr>\")\n  call WaitForAssert({-> assert_match('^This is a dummy', term_getline(buf, 6))}, 2000)\n  call term_sendkeys(buf, \":echo &buftype\\<cr>\")\n  call WaitForAssert({-> assert_notmatch('^nofile', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":echo winnr\\<cr>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 6))}, 1000)\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete(filename)\nendfunc\n\nfunc Test_autocmd_was_using_freed_memory()\n  CheckFeature quickfix\n\n  pedit xx\n  n x\n  augroup winenter\n    au WinEnter * if winnr('$') > 2 | quit | endif\n  augroup END\n  split\n\n  augroup winenter\n    au! WinEnter\n  augroup END\n\n  bwipe xx\n  bwipe x\n  pclose\nendfunc\n\nfunc Test_BufWrite_lockmarks()\n  let g:test_is_flaky = 1\n  edit! Xtest\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  \" :lockmarks preserves the marks\n  call SetChangeMarks(2, 3)\n  lockmarks write\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  \" *WritePre autocmds get the correct line range, but lockmarks preserves the\n  \" original values for the user\n  augroup lockmarks\n    au!\n    au BufWritePre,FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    au FileWritePre * call assert_equal([3, 4], [line(\"'[\"), line(\"']\")])\n  augroup END\n\n  lockmarks write\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  if executable('cat')\n    lockmarks %!cat\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  endif\n\n  lockmarks 3,4write Xtest2\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  au! lockmarks\n  augroup! lockmarks\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_FileType_spell()\n  if !isdirectory('/tmp')\n    throw \"Skipped: requires /tmp directory\"\n  endif\n\n  \" this was crashing with an invalid free()\n  setglobal spellfile=/tmp/en.utf-8.add\n  augroup crash\n    autocmd!\n    autocmd BufNewFile,BufReadPost crashfile setf somefiletype\n    autocmd BufNewFile,BufReadPost crashfile set ft=anotherfiletype\n    autocmd FileType anotherfiletype setlocal spell\n  augroup END\n  func! NoCrash() abort\n    edit /tmp/crashfile\n  endfunc\n  call NoCrash()\n\n  au! crash\n  setglobal spellfile=\nendfunc\n\n\" this was wiping out the current buffer and using freed memory\nfunc Test_SpellFileMissing_bwipe()\n  next 0\n  au SpellFileMissing 0 bwipe\n  call assert_fails('set spell spelllang=0', 'E937:')\n\n  au! SpellFileMissing\n  bwipe\nendfunc\n\n\" Test closing a window or editing another buffer from a FileChangedRO handler\n\" in a readonly buffer\nfunc Test_FileChangedRO_winclose()\n  call test_override('ui_delay', 10)\n\n  augroup FileChangedROTest\n    au!\n    autocmd FileChangedRO * quit\n  augroup END\n  new\n  set readonly\n  call assert_fails('normal i', 'E788:')\n  close\n  augroup! FileChangedROTest\n\n  augroup FileChangedROTest\n    au!\n    autocmd FileChangedRO * edit Xrofile\n  augroup END\n  new\n  set readonly\n  call assert_fails('normal i', 'E788:')\n  close\n  augroup! FileChangedROTest\n  call test_override('ALL', 0)\nendfunc\n\nfunc LogACmd()\n  call add(g:logged, line('$'))\nendfunc\n\nfunc Test_TermChanged()\n  CheckNotGui\n\n  enew!\n  tabnew\n  call setline(1, ['a', 'b', 'c', 'd'])\n  $\n  au TermChanged * call LogACmd()\n  let g:logged = []\n  let term_save = &term\n  set term=xterm\n  call assert_equal([1, 4], g:logged)\n\n  au! TermChanged\n  let &term = term_save\n  bwipe!\nendfunc\n\n\" Test for FileReadCmd autocmd\nfunc Test_autocmd_FileReadCmd()\n  func ReadFileCmd()\n    call append(line('$'), \"v:cmdarg = \" .. v:cmdarg)\n  endfunc\n  augroup FileReadCmdTest\n    au!\n    au FileReadCmd Xtest call ReadFileCmd()\n  augroup END\n\n  new\n  read ++bin Xtest\n  read ++nobin Xtest\n  read ++edit Xtest\n  read ++bad=keep Xtest\n  read ++bad=drop Xtest\n  read ++bad=- Xtest\n  read ++ff=unix Xtest\n  read ++ff=dos Xtest\n  read ++ff=mac Xtest\n  read ++enc=utf-8 Xtest\n\n  call assert_equal(['',\n        \\ 'v:cmdarg =  ++bin',\n        \\ 'v:cmdarg =  ++nobin',\n        \\ 'v:cmdarg =  ++edit',\n        \\ 'v:cmdarg =  ++bad=keep',\n        \\ 'v:cmdarg =  ++bad=drop',\n        \\ 'v:cmdarg =  ++bad=-',\n        \\ 'v:cmdarg =  ++ff=unix',\n        \\ 'v:cmdarg =  ++ff=dos',\n        \\ 'v:cmdarg =  ++ff=mac',\n        \\ 'v:cmdarg =  ++enc=utf-8'], getline(1, '$'))\n\n  close!\n  augroup FileReadCmdTest\n    au!\n  augroup END\n  delfunc ReadFileCmd\nendfunc\n\n\" Test for passing invalid arguments to autocmd\nfunc Test_autocmd_invalid_args()\n  \" Additional character after * for event\n  call assert_fails('autocmd *a Xinvfile set ff=unix', 'E215:')\n  augroup Test\n  augroup END\n  \" Invalid autocmd event\n  call assert_fails('autocmd Bufabc Xinvfile set ft=vim', 'E216:')\n  \" Invalid autocmd event in a autocmd group\n  call assert_fails('autocmd Test Bufabc Xinvfile set ft=vim', 'E216:')\n  augroup! Test\n  \" Execute all autocmds\n  call assert_fails('doautocmd * BufEnter', 'E217:')\n  call assert_fails('augroup! x1a2b3', 'E367:')\n  call assert_fails('autocmd BufNew <buffer=999> pwd', 'E680:')\n  call assert_fails('autocmd BufNew \\) set ff=unix', 'E55:')\nendfunc\n\n\" Test for deep nesting of autocmds\nfunc Test_autocmd_deep_nesting()\n  autocmd BufEnter Xdeepfile doautocmd BufEnter Xdeepfile\n  call assert_fails('doautocmd BufEnter Xdeepfile', 'E218:')\n  autocmd! BufEnter Xdeepfile\nendfunc\n\n\" Tests for SigUSR1 autocmd event, which is only available on posix systems.\nfunc Test_autocmd_sigusr1()\n  CheckUnix\n  \" FIXME: should this work on MacOS M1?\n  CheckNotMacM1\n  CheckExecutable /bin/kill\n\n  let g:sigusr1_passed = 0\n  au SigUSR1 * let g:sigusr1_passed = 1\n  call system('/bin/kill -s usr1 ' . getpid())\n  call WaitForAssert({-> assert_true(g:sigusr1_passed)})\n\n  au! SigUSR1\n  unlet g:sigusr1_passed\nendfunc\n\n\" Test for BufReadPre autocmd deleting the file\nfunc Test_BufReadPre_delfile()\n  augroup TestAuCmd\n    au!\n    autocmd BufReadPre XbufreadPre call delete('XbufreadPre')\n  augroup END\n  call writefile([], 'XbufreadPre', 'D')\n  call assert_fails('new XbufreadPre', 'E200:')\n  call assert_equal('XbufreadPre', @%)\n  call assert_equal(1, &readonly)\n\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for BufReadPre autocmd changing the current buffer\nfunc Test_BufReadPre_changebuf()\n  augroup TestAuCmd\n    au!\n    autocmd BufReadPre Xchangebuf edit Xsomeotherfile\n  augroup END\n  call writefile([], 'Xchangebuf', 'D')\n  call assert_fails('new Xchangebuf', 'E201:')\n  call assert_equal('Xsomeotherfile', @%)\n  call assert_equal(1, &readonly)\n\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for BufWipeouti autocmd changing the current buffer when reading a file\n\" in an empty buffer with 'f' flag in 'cpo'\nfunc Test_BufDelete_changebuf()\n  new\n  augroup TestAuCmd\n    au!\n    autocmd BufWipeout * let bufnr = bufadd('somefile') | exe \"b \" .. bufnr\n  augroup END\n  let save_cpo = &cpo\n  set cpo+=f\n  call assert_fails('r Xchangebuf', ['E812:', 'E484:'])\n  call assert_equal('somefile', @%)\n  let &cpo = save_cpo\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for the temporary internal window used to execute autocmds\nfunc Test_autocmd_window()\n  %bw!\n  edit one.txt\n  tabnew two.txt\n  vnew three.txt\n  tabnew four.txt\n  tabprevious\n  let g:blist = []\n  augroup aucmd_win_test1\n    au!\n    au BufEnter * call add(g:blist, [expand('<afile>'),\n          \\ win_gettype(bufwinnr(expand('<afile>')))])\n  augroup END\n\n  doautoall BufEnter\n  call assert_equal([\n        \\ ['one.txt', 'autocmd'],\n        \\ ['two.txt', ''],\n        \\ ['four.txt', 'autocmd'],\n        \\ ['three.txt', ''],\n        \\ ], g:blist)\n\n  augroup aucmd_win_test1\n    au!\n  augroup END\n  augroup! aucmd_win_test1\n  %bw!\nendfunc\n\n\" Test for trying to close the temporary window used for executing an autocmd\nfunc Test_close_autocmd_window()\n  %bw!\n  edit one.txt\n  tabnew two.txt\n  augroup aucmd_win_test2\n    au!\n    au BufEnter * if expand('<afile>') == 'one.txt' | 1close | endif\n  augroup END\n\n  call assert_fails('doautoall BufEnter', 'E813:')\n\n  augroup aucmd_win_test2\n    au!\n  augroup END\n  augroup! aucmd_win_test2\n  %bwipe!\nendfunc\n\n\" Test for trying to close the tab that has the temporary window for exeucing\n\" an autocmd.\nfunc Test_close_autocmd_tab()\n  edit one.txt\n  tabnew two.txt\n   augroup aucmd_win_test\n    au!\n    au BufEnter * if expand('<afile>') == 'one.txt' | tabfirst | tabonly | endif\n  augroup END\n\n  call assert_fails('doautoall BufEnter', 'E813:')\n\n  tabonly\n  augroup aucmd_win_test\n    au!\n  augroup END\n  augroup! aucmd_win_test\n  %bwipe!\nendfunc\n\nfunc Test_Visual_doautoall_redraw()\n  call setline(1, ['a', 'b'])\n  new \n  wincmd p\n  call feedkeys(\"G\\<C-V>\", 'txn')\n  autocmd User Explode ++once redraw\n  doautoall User Explode\n  %bwipe!\nendfunc\n\n\" This was using freed memory.\nfunc Test_BufNew_arglocal()\n  arglocal\n  au BufNew * arglocal\n  call assert_fails('drop xx', 'E1156:')\n\n  au! BufNew\nendfunc\n\nfunc Test_autocmd_closes_window()\n  au BufNew,BufWinLeave * e %e\n  file yyy\n  au BufNew,BufWinLeave * ball\n  n xxx\n\n  %bwipe\n  au! BufNew\n  au! BufWinLeave\nendfunc\n\nfunc Test_autocmd_quit_psearch()\n  sn aa bb\n  augroup aucmd_win_test\n    au!\n    au BufEnter,BufLeave,BufNew,WinEnter,WinLeave,WinNew * if winnr('$') > 1 | q | endif\n  augroup END\n  ps /\n\n  augroup aucmd_win_test\n    au!\n  augroup END\n  new\n  pclose\nendfunc\n\n\" Fuzzer found some strange combination that caused a crash.\nfunc Test_autocmd_normal_mess()\n  \" For unknown reason this hangs on MS-Windows\n  CheckNotMSWindows\n\n  augroup aucmd_normal_test\n    au BufLeave,BufWinLeave,BufHidden,BufUnload,BufDelete,BufWipeout * norm 7q/qc\n  augroup END\n  call assert_fails('o4', 'E1159')\n  silent! H\n  call assert_fails('e xx', 'E1159')\n  normal G\n\n  augroup aucmd_normal_test\n    au!\n  augroup END\nendfunc\n\nfunc Test_autocmd_closing_cmdwin()\n  \" For unknown reason this hangs on MS-Windows\n  CheckNotMSWindows\n\n  au BufWinLeave * nested q\n  call assert_fails(\"norm 7q?\\n\", 'E855:')\n\n  au! BufWinLeave\n  new\n  only\nendfunc\n\nfunc Test_autocmd_vimgrep()\n  augroup aucmd_vimgrep\n    au QuickfixCmdPre,BufNew,BufReadCmd * sb\n    au QuickfixCmdPre,BufNew,BufReadCmd * q9\n  augroup END\n  call assert_fails('lv ?a? foo', 'E926:')\n\n  augroup aucmd_vimgrep\n    au!\n  augroup END\nendfunc\n\nfunc Test_autocmd_with_block()\n  augroup block_testing\n    au BufReadPost *.xml {\n            setlocal matchpairs+=<:>\n            /<start\n          }\n    au CursorHold * {\n        autocmd BufReadPre * ++once echo 'one' | echo 'two'\n        g:gotSafeState = 77\n      }\n  augroup END\n\n  let expected = \"\\n--- Autocommands ---\\nblock_testing  BufRead\\n    *.xml     {^@            setlocal matchpairs+=<:>^@            /<start^@          }\"\n  call assert_equal(expected, execute('au BufReadPost *.xml'))\n\n  doautocmd CursorHold\n  call assert_equal(77, g:gotSafeState)\n  unlet g:gotSafeState\n\n  augroup block_testing\n    au!\n    autocmd CursorHold * {\n      if true\n        # comment\n        && true\n\n        && true\n        g:done = 'yes'\n      endif\n      }\n  augroup END\n  doautocmd CursorHold\n  call assert_equal('yes', g:done)\n\n  unlet g:done\n  augroup block_testing\n    au!\n  augroup END\nendfunc\n\n\" Test TextChangedI and TextChanged\nfunc Test_Changed_ChangedI()\n  new\n  call test_override(\"char_avail\", 1)\n  let [g:autocmd_i, g:autocmd_n] = ['','']\n\n  func! TextChangedAutocmdI(char)\n    let g:autocmd_{tolower(a:char)} = a:char .. b:changedtick\n  endfunc\n\n  augroup Test_TextChanged\n    au!\n    au TextChanged  <buffer> :call TextChangedAutocmdI('N')\n    au TextChangedI <buffer> :call TextChangedAutocmdI('I')\n  augroup END\n\n  call feedkeys(\"ifoo\\<esc>\", 'tnix')\n  \" TODO: Test test does not seem to trigger TextChanged autocommand, this\n  \" requires running Vim in a terminal window.\n  \" call assert_equal('N3', g:autocmd_n)\n  call assert_equal('I3', g:autocmd_i)\n\n  call feedkeys(\"yyp\", 'tnix')\n  \" TODO: Test test does not seem to trigger TextChanged autocommand.\n  \" call assert_equal('N4', g:autocmd_n)\n  call assert_equal('I3', g:autocmd_i)\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged  <buffer>\n  au! TextChangedI <buffer>\n  augroup! Test_TextChanged\n  delfu TextChangedAutocmdI\n  unlet! g:autocmd_i g:autocmd_n\n\n  bw!\nendfunc\n\nfunc Test_closing_autocmd_window()\n  let lines =<< trim END\n      edit Xa.txt\n      tabnew Xb.txt\n      autocmd BufEnter Xa.txt unhide 1\n      doautoall BufEnter\n  END\n  call v9.CheckScriptFailure(lines, 'E814:')\n  au! BufEnter\n  only!\n  bwipe Xa.txt\n  bwipe Xb.txt\nendfunc\n\nfunc Test_bufwipeout_changes_window()\n  \" This should not crash, but we don't have any expectations about what\n  \" happens, changing window in BufWipeout has unpredictable results.\n  tabedit\n  let g:window_id = win_getid()\n  topleft new\n  setlocal bufhidden=wipe\n  autocmd BufWipeout <buffer> call win_gotoid(g:window_id)\n  tabprevious\n  +tabclose\n\n  unlet g:window_id\n  au! BufWipeout\n  %bwipe!\nendfunc\n\nfunc Test_v_event_readonly()\n  autocmd CompleteChanged * let v:event.width = 0\n  call assert_fails(\"normal! i\\<C-X>\\<C-V>\", 'E46:')\n  au! CompleteChanged\n\n  autocmd DirChangedPre * let v:event.directory = ''\n  call assert_fails('cd .', 'E46:')\n  au! DirChangedPre\n\n  autocmd ModeChanged * let v:event.new_mode = ''\n  call assert_fails('normal! cc', 'E46:')\n  au! ModeChanged\n\n  autocmd TextYankPost * let v:event.operator = ''\n  call assert_fails('normal! yy', 'E46:')\n  au! TextYankPost\nendfunc\n\n\" Test for ModeChanged pattern\nfunc Test_mode_changes()\n  let g:index = 0\n  let g:mode_seq = ['n', 'i', 'n', 'v', 'V', 'i', 'ix', 'i', 'ic', 'i', 'n', 'no', 'n', 'V', 'v', 's', 'n']\n  func! TestMode()\n    call assert_equal(g:mode_seq[g:index], get(v:event, \"old_mode\"))\n    call assert_equal(g:mode_seq[g:index + 1], get(v:event, \"new_mode\"))\n    call assert_equal(mode(1), get(v:event, \"new_mode\"))\n    let g:index += 1\n  endfunc\n\n  au ModeChanged * :call TestMode()\n  let g:n_to_any = 0\n  au ModeChanged n:* let g:n_to_any += 1\n  call feedkeys(\"i\\<esc>vVca\\<CR>\\<C-X>\\<C-L>\\<esc>ggdG\", 'tnix')\n\n  let g:V_to_v = 0\n  au ModeChanged V:v let g:V_to_v += 1\n  call feedkeys(\"Vv\\<C-G>\\<esc>\", 'tnix')\n  call assert_equal(len(filter(g:mode_seq[1:], {idx, val -> val == 'n'})), g:n_to_any)\n  call assert_equal(1, g:V_to_v)\n  call assert_equal(len(g:mode_seq) - 1, g:index)\n\n  let g:n_to_i = 0\n  au ModeChanged n:i let g:n_to_i += 1\n  let g:n_to_niI = 0\n  au ModeChanged i:niI let g:n_to_niI += 1\n  let g:niI_to_i = 0\n  au ModeChanged niI:i let g:niI_to_i += 1\n  let g:nany_to_i = 0\n  au ModeChanged n*:i let g:nany_to_i += 1\n  let g:i_to_n = 0\n  au ModeChanged i:n let g:i_to_n += 1\n  let g:nori_to_any = 0\n  au ModeChanged [ni]:* let g:nori_to_any += 1\n  let g:i_to_any = 0\n  au ModeChanged i:* let g:i_to_any += 1\n  let g:index = 0\n  let g:mode_seq = ['n', 'i', 'niI', 'i', 'n']\n  call feedkeys(\"a\\<C-O>l\\<esc>\", 'tnix')\n  call assert_equal(len(g:mode_seq) - 1, g:index)\n  call assert_equal(1, g:n_to_i)\n  call assert_equal(1, g:n_to_niI)\n  call assert_equal(1, g:niI_to_i)\n  call assert_equal(2, g:nany_to_i)\n  call assert_equal(1, g:i_to_n)\n  call assert_equal(2, g:i_to_any)\n  call assert_equal(3, g:nori_to_any)\n\n  if has('terminal')\n    let g:mode_seq += ['c', 'n', 't', 'nt', 'c', 'nt', 'n']\n    call feedkeys(\":term\\<CR>\\<C-W>N:bd!\\<CR>\", 'tnix')\n    call assert_equal(len(g:mode_seq) - 1, g:index)\n    call assert_equal(1, g:n_to_i)\n    call assert_equal(1, g:n_to_niI)\n    call assert_equal(1, g:niI_to_i)\n    call assert_equal(2, g:nany_to_i)\n    call assert_equal(1, g:i_to_n)\n    call assert_equal(2, g:i_to_any)\n    call assert_equal(5, g:nori_to_any)\n  endif\n\n  if has('cmdwin')\n    let g:n_to_c = 0\n    au ModeChanged n:c let g:n_to_c += 1\n    let g:c_to_n = 0\n    au ModeChanged c:n let g:c_to_n += 1\n    let g:mode_seq += ['c', 'n', 'c', 'n']\n    call feedkeys(\"q:\\<C-C>\\<Esc>\", 'tnix')\n    call assert_equal(len(g:mode_seq) - 1, g:index)\n    call assert_equal(2, g:n_to_c)\n    call assert_equal(2, g:c_to_n)\n    unlet g:n_to_c\n    unlet g:c_to_n\n  endif\n\n  au! ModeChanged\n  delfunc TestMode\n  unlet! g:mode_seq\n  unlet! g:index\n  unlet! g:n_to_any\n  unlet! g:V_to_v\n  unlet! g:n_to_i\n  unlet! g:n_to_niI\n  unlet! g:niI_to_i\n  unlet! g:nany_to_i\n  unlet! g:i_to_n\n  unlet! g:nori_to_any\n  unlet! g:i_to_any\nendfunc\n\nfunc Test_recursive_ModeChanged()\n  au! ModeChanged * norm 0u\n  sil! norm \u0016\n  au! ModeChanged\nendfunc\n\nfunc Test_ModeChanged_starts_visual()\n  \" This was triggering ModeChanged before setting VIsual, causing a crash.\n  au! ModeChanged * norm 0u\n  sil! norm \u0016\n\n  au! ModeChanged\nendfunc\n\nfunc Test_noname_autocmd()\n  augroup test_noname_autocmd_group\n    autocmd!\n    autocmd BufEnter * call add(s:li, [\"BufEnter\", expand(\"<afile>\")])\n    autocmd BufDelete * call add(s:li, [\"BufDelete\", expand(\"<afile>\")])\n    autocmd BufLeave * call add(s:li, [\"BufLeave\", expand(\"<afile>\")])\n    autocmd BufUnload * call add(s:li, [\"BufUnload\", expand(\"<afile>\")])\n    autocmd BufWipeout * call add(s:li, [\"BufWipeout\", expand(\"<afile>\")])\n  augroup END\n\n  let s:li = []\n  edit foo\n  call assert_equal([['BufUnload', ''], ['BufDelete', ''], ['BufWipeout', ''], ['BufEnter', 'foo']], s:li)\n\n  au! test_noname_autocmd_group\n  augroup! test_noname_autocmd_group\nendfunc\n\n\" Test for the autocmd_get() function\nfunc Test_autocmd_get()\n  augroup TestAutoCmdFns\n    au!\n    autocmd BufAdd *.vim echo \"bufadd-vim\"\n    autocmd BufAdd *.py echo \"bufadd-py\"\n    autocmd BufHidden *.vim echo \"bufhidden\"\n  augroup END\n  augroup TestAutoCmdFns2\n    autocmd BufAdd *.vim echo \"bufadd-vim-2\"\n    autocmd BufRead *.a1b2c3 echo \"bufadd-vim-2\"\n  augroup END\n\n  let l = autocmd_get()\n  call assert_true(l->len() > 0)\n\n  \" Test for getting all the autocmds in a group\n  let expected = [\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufadd-py\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.py', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufhidden\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false,\n        \\  once: v:false, event: 'BufHidden'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for getting autocmds for all the patterns in a group\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: '*'}))\n\n  \" Test for getting autocmds for an event in a group\n  let expected = [\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufadd-py\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.py', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufAdd'}))\n\n  \" Test for getting the autocmds for all the events in a group for particular\n  \" pattern\n  call assert_equal([{'cmd': 'echo \"bufadd-py\"', 'group': 'TestAutoCmdFns',\n        \\ 'pattern': '*.py', 'nested': v:false, 'once': v:false,\n        \\ 'event': 'BufAdd'}],\n        \\ autocmd_get(#{group: 'TestAutoCmdFns', event: '*', pattern: '*.py'}))\n\n  \" Test for getting the autocmds for an events in a group for particular\n  \" pattern\n  let l = autocmd_get(#{group: 'TestAutoCmdFns', event: 'BufAdd',\n        \\ pattern: '*.vim'})\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'}], l)\n\n  \" Test for getting the autocmds for a pattern in a group\n  let l = autocmd_get(#{group: 'TestAutoCmdFns', pattern: '*.vim'})\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufhidden\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false,\n        \\  once: v:false, event: 'BufHidden'}], l)\n\n  \" Test for getting the autocmds for a pattern in all the groups\n  let l = autocmd_get(#{pattern: '*.a1b2c3'})\n  call assert_equal([{'cmd': 'echo \"bufadd-vim-2\"', 'group': 'TestAutoCmdFns2',\n        \\ 'pattern': '*.a1b2c3', 'nested': v:false, 'once': v:false,\n        \\ 'event': 'BufRead'}], l)\n\n  \" Test for getting autocmds for a pattern without any autocmds\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ pattern: '*.abc'}))\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufAdd', pattern: '*.abc'}))\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufWipeout'}))\n  call assert_fails(\"call autocmd_get(#{group: 'abc', event: 'BufAdd'})\",\n        \\ 'E367:')\n  let cmd = \"echo autocmd_get(#{group: 'TestAutoCmdFns', event: 'abc'})\"\n  call assert_fails(cmd, 'E216:')\n  call assert_fails(\"call autocmd_get(#{group: 'abc'})\", 'E367:')\n  call assert_fails(\"echo autocmd_get(#{event: 'abc'})\", 'E216:')\n\n  augroup TestAutoCmdFns\n    au!\n  augroup END\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for nested and once autocmds\n  augroup TestAutoCmdFns\n    au!\n    autocmd VimSuspend * ++nested echo \"suspend\"\n    autocmd VimResume * ++once echo \"resume\"\n  augroup END\n\n  let expected = [\n        \\ {'cmd': 'echo \"suspend\"', 'group': 'TestAutoCmdFns', 'pattern': '*',\n        \\ 'nested': v:true, 'once': v:false, 'event': 'VimSuspend'},\n        \\ {'cmd': 'echo \"resume\"', 'group': 'TestAutoCmdFns', 'pattern': '*',\n        \\  'nested': v:false, 'once': v:true, 'event': 'VimResume'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for buffer-local autocmd\n  augroup TestAutoCmdFns\n    au!\n    autocmd TextYankPost <buffer> echo \"textyankpost\"\n  augroup END\n\n  let expected = [\n        \\ {'cmd': 'echo \"textyankpost\"', 'group': 'TestAutoCmdFns',\n        \\  'pattern': '<buffer=' .. bufnr() .. '>', 'nested': v:false,\n        \\  'once': v:false, 'bufnr': bufnr(), 'event': 'TextYankPost'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  augroup TestAutoCmdFns\n    au!\n  augroup END\n  augroup! TestAutoCmdFns\n  augroup TestAutoCmdFns2\n    au!\n  augroup END\n  augroup! TestAutoCmdFns2\n\n  call assert_fails(\"echo autocmd_get(#{group: []})\", 'E730:')\n  call assert_fails(\"echo autocmd_get(#{event: {}})\", 'E731:')\n  call assert_fails(\"echo autocmd_get([])\", 'E1206:')\nendfunc\n\n\" Test for the autocmd_add() function\nfunc Test_autocmd_add()\n  \" Define a single autocmd in a group\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"', once: v:true, nested: v:true}])\n  call assert_equal([#{cmd: 'echo \"bufadd\"', group: 'TestAcSet',\n        \\ pattern: '*.sh', nested: v:true, once: v:true,\n        \\ event: 'BufAdd'}], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Define two autocmds in the same group\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"'},\n        \\ #{group: 'TestAcSet', event: 'BufEnter', pattern: '*.sh',\n        \\   cmd: 'echo \"bufenter\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false, once: v:false, event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufenter\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false, once: v:false, event: 'BufEnter'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Define a buffer-local autocmd\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'CursorHold',\n        \\ bufnr: bufnr(), cmd: 'echo \"cursorhold\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"cursorhold\"', group: 'TestAcSet',\n        \\   pattern: '<buffer=' .. bufnr() .. '>', nested: v:false,\n        \\   once: v:false, bufnr: bufnr(), event: 'CursorHold'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Use an invalid buffer number\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufEnter',\n        \\ bufnr: -1, cmd: 'echo \"bufenter\"'}])\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ pattern: '*.py', cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ pattern: ['*.py', '*.c'], cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufRead', bufnr: [],\n        \\ cmd: 'echo \"bufread\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E745:')\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Add two commands to the same group, event and pattern\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufUnload',\n        \\ pattern: 'abc', cmd: 'echo \"cmd1\"'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufUnload',\n        \\ pattern: 'abc', cmd: 'echo \"cmd2\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"cmd1\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufUnload'},\n        \\ #{cmd: 'echo \"cmd2\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufUnload'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" When adding a new autocmd, if the autocmd 'group' is not specified, then\n  \" the current autocmd group should be used.\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  augroup TestAcSet\n    call autocmd_add([#{event: 'BufHidden', pattern: 'abc', cmd: 'echo \"abc\"'}])\n  augroup END\n  call assert_equal([\n        \\ #{cmd: 'echo \"abc\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufHidden'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for replacing a cmd for an event in a group\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{replace: v:true, group: 'TestAcSet', event: 'BufEnter',\n        \\ pattern: '*.py', cmd: 'echo \"bufenter\"'}])\n  call autocmd_add([#{replace: v:true, group: 'TestAcSet', event: 'BufEnter',\n        \\ pattern: '*.py', cmd: 'echo \"bufenter\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufenter\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for adding a command for an unsupported autocmd event\n  let l = [#{group: 'TestAcSet', event: 'abc', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n\n  \" Test for using a list of events and patterns\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  let l = [#{group: 'TestAcSet', event: ['BufEnter', 'BufLeave'],\n        \\ pattern: ['*.py', '*.sh'], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufLeave'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false,  once: v:false, event: 'BufLeave'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for invalid values for 'event' item\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  let l = [#{group: 'TestAcSet', event: test_null_string(),\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: test_null_list(),\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E714:')\n  let l = [#{group: 'TestAcSet', event: {},\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E777:')\n  let l = [#{group: 'TestAcSet', event: [{}],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: [test_null_string()],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: 'BufEnter,BufLeave',\n        \\ pattern: '*.py', cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n  let l = [#{group: 'TestAcSet', event: [],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: [\"\"],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n  let l = [#{group: 'TestAcSet', event: \"\",\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for invalid values for 'pattern' item\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: test_null_string(), cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: test_null_list(), cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E714:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: {}, cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E777:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [{}], cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [test_null_string()], cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [\"\"], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: \"\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  let l = [#{group: 'TestAcSet', event: 'BufEnter,abc,BufLeave',\n        \\ pattern: '*.py', cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n\n  call assert_fails(\"call autocmd_add({})\", 'E1211:')\n  call assert_equal(v:false,  autocmd_add(test_null_list()))\n  call assert_true(autocmd_add([[]]))\n  call assert_true(autocmd_add([test_null_dict()]))\n\n  augroup TestAcSet\n    au!\n  augroup END\n\n  call autocmd_add([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd'}])\n  call autocmd_add([#{group: 'TestAcSet', pat: '*.sh'}])\n  call autocmd_add([#{group: 'TestAcSet', cmd: 'echo \"a\"'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pat: '*.sh'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', cmd: 'echo \"a\"'}])\n  call autocmd_add([#{group: 'TestAcSet', pat: '*.sh', cmd: 'echo \"a\"'}])\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  augroup! TestAcSet\nendfunc\n\n\" Test for deleting autocmd events and groups\nfunc Test_autocmd_delete()\n  \" Delete an event in an autocmd group\n  augroup TestAcSet\n    au!\n    au BufAdd *.sh echo \"bufadd\"\n    au BufEnter *.sh echo \"bufenter\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet', event: 'BufAdd'}])\n  call assert_equal([#{cmd: 'echo \"bufenter\"', group: 'TestAcSet',\n        \\ pattern: '*.sh', nested: v:false, once: v:false,\n        \\ event: 'BufEnter'}], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Delete all the events in an autocmd group\n  augroup TestAcSet\n    au BufAdd *.sh echo \"bufadd\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet', event: '*'}])\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Delete a non-existing autocmd group\n  call assert_fails(\"call autocmd_delete([#{group: 'abc'}])\", 'E367:')\n  \" Delete a non-existing autocmd event\n  let l = [#{group: 'TestAcSet', event: 'abc'}]\n  call assert_fails(\"call autocmd_delete(l)\", 'E216:')\n  \" Delete a non-existing autocmd pattern\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', pat: 'abc'}]\n  call assert_true(autocmd_delete(l))\n  \" Delete an autocmd for a non-existing buffer\n  let l = [#{event: '*', bufnr: 9999, cmd: 'echo \"x\"'}]\n  call assert_fails('call autocmd_delete(l)', 'E680:')\n\n  \" Delete an autocmd group\n  augroup TestAcSet\n    au!\n    au BufAdd *.sh echo \"bufadd\"\n    au BufEnter *.sh echo \"bufenter\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call assert_fails(\"call autocmd_get(#{group: 'TestAcSet'})\", 'E367:')\n\n  call assert_true(autocmd_delete([[]]))\n  call assert_true(autocmd_delete([test_null_dict()]))\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/buffer.c", "src/spell.c", "src/testdir/test_autocmd.vim", "src/version.c"], "buggy_code_start_loc": [471, 1570, 2882, 701], "buggy_code_end_loc": [472, 1623, 2882, 701], "fixing_code_start_loc": [471, 1571, 2883, 702], "fixing_code_end_loc": [477, 1630, 2893, 704], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0614.", "other": {"cve": {"id": "CVE-2022-3352", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-29T12:15:09.710", "lastModified": "2023-05-03T12:16:22.020", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0614."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 9.0.0614"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0614", "matchCriteriaId": "9CC0B016-0E02-4246-A94A-F359AEE2F0FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/ef976323e770315b5fca544efb6b2faa25674d15", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/d058f182-a49b-40c7-9234-43d4c5a29f60", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/ef976323e770315b5fca544efb6b2faa25674d15"}}