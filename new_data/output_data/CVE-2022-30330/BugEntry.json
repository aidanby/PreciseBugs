{"buggy_code": ["/*\n * Copyright (C) 2018 Keepkey\n *\n * This library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef EMULATOR\n#include <libopencm3/stm32/flash.h>\n#else\n#include <stdint.h>\n#include <stdbool.h>\n#endif\n\n#include <stdint.h>\n#include <string.h>\n#include \"keepkey/board/supervise.h\"\n#include \"keepkey/board/memory.h\"\n#include \"keepkey/board/keepkey_flash.h\"\n\n#ifndef EMULATOR\n\n/// Return context from user isr processing\nvoid svc_busr_return(void) {\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_BUSR_RET) : \"memory\");\n}\n\n/// Return context from user isr processing\nvoid svc_tusr_return(void) {\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_TUSR_RET) : \"memory\");\n}\n\n/// Enable interrupts\nvoid svc_enable_interrupts(void) {\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_ENA_INTR) : \"memory\");\n}\n\n/// Return context from user isr processing\nvoid svc_disable_interrupts(void) {\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_DIS_INTR) : \"memory\");\n}\n\n/// \\brief Erase a flash sector.\n/// @param sector sector number 0..11\nvoid svc_flash_erase_sector(uint32_t sector) {\n  _param_1 = sector;\n  _param_2 = 0;\n  _param_3 = 0;\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_FLASH_ERASE) : \"memory\");\n}\n\nbool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {\n  _param_1 = beginAddr;\n  _param_2 = data;\n  _param_3 = align;\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_FLASH_PGM_BLK) : \"memory\");\n  return !!_param_1;\n}\n\nbool svc_flash_pgm_word(uint32_t beginAddr, uint32_t data) {\n  _param_1 = beginAddr;\n  _param_2 = data;\n  _param_3 = 0;\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_FLASH_PGM_WORD) : \"memory\");\n  return !!_param_1;\n}\n\nvoid svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Erase the sector.\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  // Return flash status.\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}\n\nvoid svhandler_flash_pgm_blk(void) {\n  uint32_t beginAddr = _param_1;\n  uint32_t data = _param_2;\n  uint32_t length = _param_3;\n\n  // Protect from overflow.\n  if (beginAddr + length < beginAddr) return;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&\n       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n\n  if (((beginAddr >= BLDR_FLASH_SECT_START) &&\n       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program(beginAddr, (uint8_t *)data, length);\n\n  // Return flash status.\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // Lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}\n\nvoid svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // Lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}\n\nvoid svc_handler_main(uint32_t *stack) {\n  uint8_t svc_number = ((uint8_t *)stack[6])[-2];\n  switch (svc_number) {\n    case SVC_BUSR_RET:\n      svhandler_button_usr_return();\n      break;\n    case SVC_TUSR_RET:\n      svhandler_timer_usr_return();\n      break;\n    case SVC_ENA_INTR:\n      svhandler_enable_interrupts();\n      break;\n    case SVC_DIS_INTR:\n      svhandler_disable_interrupts();\n      break;\n    case SVC_FLASH_ERASE:\n      svhandler_flash_erase_sector();\n      break;\n    case SVC_FLASH_PGM_BLK:\n      svhandler_flash_pgm_blk();\n      break;\n    case SVC_FLASH_PGM_WORD:\n      svhandler_flash_pgm_word();\n      break;\n    case SVC_FIRMWARE_PRIV:\n    case SVC_FIRMWARE_UNPRIV:\n      svhandler_start_firmware(svc_number);\n      break;\n    default:\n      stack[0] = 0xffffffff;\n      break;\n  }\n}\n\n#endif\n"], "fixing_code": ["/*\n * Copyright (C) 2018 Keepkey\n *\n * This library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef EMULATOR\n#include <libopencm3/stm32/flash.h>\n#else\n#include <stdint.h>\n#include <stdbool.h>\n#endif\n\n#include <stdint.h>\n#include <string.h>\n#include \"keepkey/board/supervise.h\"\n#include \"keepkey/board/memory.h\"\n#include \"keepkey/board/keepkey_flash.h\"\n\n#ifndef EMULATOR\n\nbool do_memory_ranges_overlap(size_t range1Start, size_t range1End, size_t range2Start, size_t range2End) {\n  if (range1Start <= range2Start) {\n    return range2Start < range1End;\n  } else {\n    return range1Start < range2End;\n  }\n}\n\nbool allow_svhandler_flash_sector(const FlashSector* sector) {\n  return sector->use == FLASH_STORAGE1 ||\n         sector->use == FLASH_STORAGE2 ||\n         sector->use == FLASH_STORAGE3 ||\n         sector->use == FLASH_UNUSED0 ||\n         sector->use == FLASH_APP;\n}\n\nbool allow_svhandler_flash_sector_num(int sector) {\n  for (const FlashSector *s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (s->sector == sector) return allow_svhandler_flash_sector(s);\n  }\n  return false;\n}\n\nbool allow_svhandler_flash_range(size_t start, size_t end) {\n  // Protect from overflow.\n  if (start > end) return false;\n\n  // Disallow non-flash writes.\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n\n  // Disallow writes to any sectors which aren't allowed.\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n\n  // Ensure writes start and end in allowed sectors. As long as flash_sector_map consists of\n  // contiguous sectors, this will ensure no writes can target flash outside the map.\n  if (!startAllowed || !endAllowed) return false;\n\n  return true;\n}\n\n/// Return context from user isr processing\nvoid svc_busr_return(void) {\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_BUSR_RET) : \"memory\");\n}\n\n/// Return context from user isr processing\nvoid svc_tusr_return(void) {\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_TUSR_RET) : \"memory\");\n}\n\n/// Enable interrupts\nvoid svc_enable_interrupts(void) {\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_ENA_INTR) : \"memory\");\n}\n\n/// Return context from user isr processing\nvoid svc_disable_interrupts(void) {\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_DIS_INTR) : \"memory\");\n}\n\n/// \\brief Erase a flash sector.\n/// @param sector sector number 0..11\nvoid svc_flash_erase_sector(uint32_t sector) {\n  _param_1 = sector;\n  _param_2 = 0;\n  _param_3 = 0;\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_FLASH_ERASE) : \"memory\");\n}\n\nbool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {\n  _param_1 = beginAddr;\n  _param_2 = data;\n  _param_3 = align;\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_FLASH_PGM_BLK) : \"memory\");\n  return !!_param_1;\n}\n\nbool svc_flash_pgm_word(uint32_t beginAddr, uint32_t data) {\n  _param_1 = beginAddr;\n  _param_2 = data;\n  _param_3 = 0;\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_FLASH_PGM_WORD) : \"memory\");\n  return !!_param_1;\n}\n\nvoid svhandler_flash_erase_sector(void) {\n  uint8_t sector = _param_1;\n\n  // Verify requested sector is allowed.\n  if (!allow_svhandler_flash_sector_num(sector)) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Erase the sector.\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  // Return flash status.\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}\n\nvoid svhandler_flash_pgm_blk(void) {\n  uint32_t beginAddr = _param_1;\n  uint32_t data = _param_2;\n  uint32_t length = _param_3;\n\n  // Verify requested address range is allowed.\n  if (!allow_svhandler_flash_range(beginAddr, beginAddr + length)) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program(beginAddr, (uint8_t *)data, length);\n\n  // Return flash status.\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // Lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}\n\nvoid svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Verify requested address range is allowed.\n  if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t))) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // Lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}\n\nvoid svc_handler_main(uint32_t *stack) {\n  uint8_t svc_number = ((uint8_t *)stack[6])[-2];\n  switch (svc_number) {\n    case SVC_BUSR_RET:\n      svhandler_button_usr_return();\n      break;\n    case SVC_TUSR_RET:\n      svhandler_timer_usr_return();\n      break;\n    case SVC_ENA_INTR:\n      svhandler_enable_interrupts();\n      break;\n    case SVC_DIS_INTR:\n      svhandler_disable_interrupts();\n      break;\n    case SVC_FLASH_ERASE:\n      svhandler_flash_erase_sector();\n      break;\n    case SVC_FLASH_PGM_BLK:\n      svhandler_flash_pgm_blk();\n      break;\n    case SVC_FLASH_PGM_WORD:\n      svhandler_flash_pgm_word();\n      break;\n    case SVC_FIRMWARE_PRIV:\n    case SVC_FIRMWARE_UNPRIV:\n      svhandler_start_firmware(svc_number);\n      break;\n    default:\n      stack[0] = 0xffffffff;\n      break;\n  }\n}\n\n#endif\n"], "filenames": ["lib/board/supervise.c"], "buggy_code_start_loc": [32], "buggy_code_end_loc": [170], "fixing_code_start_loc": [33], "fixing_code_end_loc": [199], "type": "CWE-668", "message": "In the KeepKey firmware before 7.3.2,Flaws in the supervisor interface can be exploited to bypass important security restrictions on firmware operations. Using these flaws, malicious firmware code can elevate privileges, permanently make the device inoperable or overwrite the trusted bootloader code to compromise the hardware wallet across reboots or storage wipes.", "other": {"cve": {"id": "CVE-2022-30330", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-07T04:15:09.253", "lastModified": "2022-09-30T02:27:24.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the KeepKey firmware before 7.3.2,Flaws in the supervisor interface can be exploited to bypass important security restrictions on firmware operations. Using these flaws, malicious firmware code can elevate privileges, permanently make the device inoperable or overwrite the trusted bootloader code to compromise the hardware wallet across reboots or storage wipes."}, {"lang": "es", "value": "En el firmware KeepKey anterior a la versi\u00f3n 7.3.2, se pueden aprovechar los fallos de la interfaz del supervisor para eludir importantes restricciones de seguridad en las operaciones del firmware. Utilizando estos defectos, un c\u00f3digo de firmware malicioso puede elevar los privilegios, inutilizar permanentemente el dispositivo o sobrescribir el c\u00f3digo del cargador de arranque de confianza para comprometer la cartera de hardware a trav\u00e9s de reinicios o borrados de almacenamiento"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:keepkey:keepkey_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.3.2", "matchCriteriaId": "B3EC3E07-7599-414F-A2C5-4CC654E1145B"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:keepkey:keepkey:-:*:*:*:*:*:*:*", "matchCriteriaId": "31C93828-4A0A-4B05-BFE3-9B795EAA0872"}]}]}], "references": [{"url": "https://blog.inhq.net/posts/keepkey-CVE-2022-30330/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/keepkey/keepkey-firmware/commit/447c1f038a31378ab9589965c098467d9ea6cccc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/keepkey/keepkey-firmware/releases/tag/v7.3.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keepkey/keepkey-firmware/commit/447c1f038a31378ab9589965c098467d9ea6cccc"}}