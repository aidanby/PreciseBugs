{"buggy_code": ["<?php\n/**\n * XML-RPC protocol support for WordPress\n *\n * @package WordPress\n * @subpackage Publishing\n */\n\n/**\n * WordPress XMLRPC server implementation.\n *\n * Implements compatibility for Blogger API, MetaWeblog API, MovableType, and\n * pingback. Additional WordPress API for managing comments, pages, posts,\n * options, etc.\n *\n * As of WordPress 3.5.0, XML-RPC is enabled by default. It can be disabled\n * via the xmlrpc_enabled filter found in wp_xmlrpc_server::login().\n *\n * @package WordPress\n * @subpackage Publishing\n * @since 1.5.0\n */\nclass wp_xmlrpc_server extends IXR_Server {\n\t/**\n\t * Methods.\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $methods;\n\n\t/**\n\t * Blog options.\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $blog_options;\n\n\t/**\n\t * IXR_Error instance.\n\t *\n\t * @access public\n\t * @var IXR_Error\n\t */\n\tpublic $error;\n\n\t/**\n\t * Register all of the XMLRPC methods that XMLRPC server understands.\n\t *\n\t * Sets up server and method property. Passes XMLRPC\n\t * methods through the 'xmlrpc_methods' filter to allow plugins to extend\n\t * or replace XMLRPC methods.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function __construct() {\n\t\t$this->methods = array(\n\t\t\t// WordPress API\n\t\t\t'wp.getUsersBlogs'\t\t=> 'this:wp_getUsersBlogs',\n\t\t\t'wp.newPost'\t\t\t=> 'this:wp_newPost',\n\t\t\t'wp.editPost'\t\t\t=> 'this:wp_editPost',\n\t\t\t'wp.deletePost'\t\t\t=> 'this:wp_deletePost',\n\t\t\t'wp.getPost'\t\t\t=> 'this:wp_getPost',\n\t\t\t'wp.getPosts'\t\t\t=> 'this:wp_getPosts',\n\t\t\t'wp.newTerm'\t\t\t=> 'this:wp_newTerm',\n\t\t\t'wp.editTerm'\t\t\t=> 'this:wp_editTerm',\n\t\t\t'wp.deleteTerm'\t\t\t=> 'this:wp_deleteTerm',\n\t\t\t'wp.getTerm'\t\t\t=> 'this:wp_getTerm',\n\t\t\t'wp.getTerms'\t\t\t=> 'this:wp_getTerms',\n\t\t\t'wp.getTaxonomy'\t\t=> 'this:wp_getTaxonomy',\n\t\t\t'wp.getTaxonomies'\t\t=> 'this:wp_getTaxonomies',\n\t\t\t'wp.getUser'\t\t\t=> 'this:wp_getUser',\n\t\t\t'wp.getUsers'\t\t\t=> 'this:wp_getUsers',\n\t\t\t'wp.getProfile'\t\t\t=> 'this:wp_getProfile',\n\t\t\t'wp.editProfile'\t\t=> 'this:wp_editProfile',\n\t\t\t'wp.getPage'\t\t\t=> 'this:wp_getPage',\n\t\t\t'wp.getPages'\t\t\t=> 'this:wp_getPages',\n\t\t\t'wp.newPage'\t\t\t=> 'this:wp_newPage',\n\t\t\t'wp.deletePage'\t\t\t=> 'this:wp_deletePage',\n\t\t\t'wp.editPage'\t\t\t=> 'this:wp_editPage',\n\t\t\t'wp.getPageList'\t\t=> 'this:wp_getPageList',\n\t\t\t'wp.getAuthors'\t\t\t=> 'this:wp_getAuthors',\n\t\t\t'wp.getCategories'\t\t=> 'this:mw_getCategories',\t\t// Alias\n\t\t\t'wp.getTags'\t\t\t=> 'this:wp_getTags',\n\t\t\t'wp.newCategory'\t\t=> 'this:wp_newCategory',\n\t\t\t'wp.deleteCategory'\t\t=> 'this:wp_deleteCategory',\n\t\t\t'wp.suggestCategories'\t=> 'this:wp_suggestCategories',\n\t\t\t'wp.uploadFile'\t\t\t=> 'this:mw_newMediaObject',\t// Alias\n\t\t\t'wp.deleteFile'\t\t\t=> 'this:wp_deletePost',\t\t// Alias\n\t\t\t'wp.getCommentCount'\t=> 'this:wp_getCommentCount',\n\t\t\t'wp.getPostStatusList'\t=> 'this:wp_getPostStatusList',\n\t\t\t'wp.getPageStatusList'\t=> 'this:wp_getPageStatusList',\n\t\t\t'wp.getPageTemplates'\t=> 'this:wp_getPageTemplates',\n\t\t\t'wp.getOptions'\t\t\t=> 'this:wp_getOptions',\n\t\t\t'wp.setOptions'\t\t\t=> 'this:wp_setOptions',\n\t\t\t'wp.getComment'\t\t\t=> 'this:wp_getComment',\n\t\t\t'wp.getComments'\t\t=> 'this:wp_getComments',\n\t\t\t'wp.deleteComment'\t\t=> 'this:wp_deleteComment',\n\t\t\t'wp.editComment'\t\t=> 'this:wp_editComment',\n\t\t\t'wp.newComment'\t\t\t=> 'this:wp_newComment',\n\t\t\t'wp.getCommentStatusList' => 'this:wp_getCommentStatusList',\n\t\t\t'wp.getMediaItem'\t\t=> 'this:wp_getMediaItem',\n\t\t\t'wp.getMediaLibrary'\t=> 'this:wp_getMediaLibrary',\n\t\t\t'wp.getPostFormats'     => 'this:wp_getPostFormats',\n\t\t\t'wp.getPostType'\t\t=> 'this:wp_getPostType',\n\t\t\t'wp.getPostTypes'\t\t=> 'this:wp_getPostTypes',\n\t\t\t'wp.getRevisions'\t\t=> 'this:wp_getRevisions',\n\t\t\t'wp.restoreRevision'\t=> 'this:wp_restoreRevision',\n\n\t\t\t// Blogger API\n\t\t\t'blogger.getUsersBlogs' => 'this:blogger_getUsersBlogs',\n\t\t\t'blogger.getUserInfo' => 'this:blogger_getUserInfo',\n\t\t\t'blogger.getPost' => 'this:blogger_getPost',\n\t\t\t'blogger.getRecentPosts' => 'this:blogger_getRecentPosts',\n\t\t\t'blogger.newPost' => 'this:blogger_newPost',\n\t\t\t'blogger.editPost' => 'this:blogger_editPost',\n\t\t\t'blogger.deletePost' => 'this:blogger_deletePost',\n\n\t\t\t// MetaWeblog API (with MT extensions to structs)\n\t\t\t'metaWeblog.newPost' => 'this:mw_newPost',\n\t\t\t'metaWeblog.editPost' => 'this:mw_editPost',\n\t\t\t'metaWeblog.getPost' => 'this:mw_getPost',\n\t\t\t'metaWeblog.getRecentPosts' => 'this:mw_getRecentPosts',\n\t\t\t'metaWeblog.getCategories' => 'this:mw_getCategories',\n\t\t\t'metaWeblog.newMediaObject' => 'this:mw_newMediaObject',\n\n\t\t\t// MetaWeblog API aliases for Blogger API\n\t\t\t// see http://www.xmlrpc.com/stories/storyReader$2460\n\t\t\t'metaWeblog.deletePost' => 'this:blogger_deletePost',\n\t\t\t'metaWeblog.getUsersBlogs' => 'this:blogger_getUsersBlogs',\n\n\t\t\t// MovableType API\n\t\t\t'mt.getCategoryList' => 'this:mt_getCategoryList',\n\t\t\t'mt.getRecentPostTitles' => 'this:mt_getRecentPostTitles',\n\t\t\t'mt.getPostCategories' => 'this:mt_getPostCategories',\n\t\t\t'mt.setPostCategories' => 'this:mt_setPostCategories',\n\t\t\t'mt.supportedMethods' => 'this:mt_supportedMethods',\n\t\t\t'mt.supportedTextFilters' => 'this:mt_supportedTextFilters',\n\t\t\t'mt.getTrackbackPings' => 'this:mt_getTrackbackPings',\n\t\t\t'mt.publishPost' => 'this:mt_publishPost',\n\n\t\t\t// PingBack\n\t\t\t'pingback.ping' => 'this:pingback_ping',\n\t\t\t'pingback.extensions.getPingbacks' => 'this:pingback_extensions_getPingbacks',\n\n\t\t\t'demo.sayHello' => 'this:sayHello',\n\t\t\t'demo.addTwoNumbers' => 'this:addTwoNumbers'\n\t\t);\n\n\t\t$this->initialise_blog_option_info();\n\n\t\t/**\n\t\t * Filter the methods exposed by the XML-RPC server.\n\t\t *\n\t\t * This filter can be used to add new methods, and remove built-in methods.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param array $methods An array of XML-RPC methods.\n\t\t */\n\t\t$this->methods = apply_filters( 'xmlrpc_methods', $this->methods );\n\t}\n\n\t/**\n\t * Make private/protected methods readable for backwards compatibility.\n\t *\n\t * @since 4.0.0\n\t * @access public\n\t *\n\t * @param callable $name      Method to call.\n\t * @param array    $arguments Arguments to pass when calling.\n\t * @return array|IXR_Error|false Return value of the callback, false otherwise.\n\t */\n\tpublic function __call( $name, $arguments ) {\n\t\tif ( '_multisite_getUsersBlogs' === $name ) {\n\t\t\treturn call_user_func_array( array( $this, $name ), $arguments );\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @access public\n\t */\n\tpublic function serve_request() {\n\t\t$this->IXR_Server($this->methods);\n\t}\n\n\t/**\n\t * Test XMLRPC API by saying, \"Hello!\" to client.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return string Hello string response.\n\t */\n\tpublic function sayHello() {\n\t\treturn 'Hello!';\n\t}\n\n\t/**\n\t * Test XMLRPC API by adding two numbers for client.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int $number1 A number to add.\n\t *     @type int $number2 A second number to add.\n\t * }\n\t * @return int Sum of the two given numbers.\n\t */\n\tpublic function addTwoNumbers( $args ) {\n\t\t$number1 = $args[0];\n\t\t$number2 = $args[1];\n\t\treturn $number1 + $number2;\n\t}\n\n\t/**\n\t * Log user in.\n\t *\n\t * @since 2.8.0\n\t *\n\t * @param string $username User's username.\n\t * @param string $password User's password.\n\t * @return WP_User|bool WP_User object if authentication passed, false otherwise\n\t */\n\tpublic function login( $username, $password ) {\n\t\t/*\n\t\t * Respect old get_option() filters left for back-compat when the 'enable_xmlrpc'\n\t\t * option was deprecated in 3.5.0. Use the 'xmlrpc_enabled' hook instead.\n\t\t */\n\t\t$enabled = apply_filters( 'pre_option_enable_xmlrpc', false );\n\t\tif ( false === $enabled ) {\n\t\t\t$enabled = apply_filters( 'option_enable_xmlrpc', true );\n\t\t}\n\n\t\t/**\n\t\t * Filter whether XML-RPC is enabled.\n\t\t *\n\t\t * This is the proper filter for turning off XML-RPC.\n\t\t *\n\t\t * @since 3.5.0\n\t\t *\n\t\t * @param bool $enabled Whether XML-RPC is enabled. Default true.\n\t\t */\n\t\t$enabled = apply_filters( 'xmlrpc_enabled', $enabled );\n\n\t\tif ( ! $enabled ) {\n\t\t\t$this->error = new IXR_Error( 405, sprintf( __( 'XML-RPC services are disabled on this site.' ) ) );\n\t\t\treturn false;\n\t\t}\n\n\t\t$user = wp_authenticate($username, $password);\n\n\t\tif (is_wp_error($user)) {\n\t\t\t$this->error = new IXR_Error( 403, __( 'Incorrect username or password.' ) );\n\n\t\t\t/**\n\t\t\t * Filter the XML-RPC user login error message.\n\t\t\t *\n\t\t\t * @since 3.5.0\n\t\t\t *\n\t\t\t * @param string  $error The XML-RPC error message.\n\t\t\t * @param WP_User $user  WP_User object.\n\t\t\t */\n\t\t\t$this->error = apply_filters( 'xmlrpc_login_error', $this->error, $user );\n\t\t\treturn false;\n\t\t}\n\n\t\twp_set_current_user( $user->ID );\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Check user's credentials. Deprecated.\n\t *\n\t * @since 1.5.0\n\t * @deprecated 2.8.0\n\t * @deprecated use wp_xmlrpc_server::login\n\t * @see wp_xmlrpc_server::login\n\t *\n\t * @param string $username User's username.\n\t * @param string $password User's password.\n\t * @return bool Whether authentication passed.\n\t */\n\tpublic function login_pass_ok( $username, $password ) {\n\t\treturn (bool) $this->login( $username, $password );\n\t}\n\n\t/**\n\t * Escape string or array of strings for database.\n\t *\n\t * @since 1.5.2\n\t *\n\t * @param string|array $data Escape single string or array of strings.\n\t * @return string|void Returns with string is passed, alters by-reference\n\t *                     when array is passed.\n\t */\n\tpublic function escape( &$data ) {\n\t\tif ( ! is_array( $data ) )\n\t\t\treturn wp_slash( $data );\n\n\t\tforeach ( $data as &$v ) {\n\t\t\tif ( is_array( $v ) )\n\t\t\t\t$this->escape( $v );\n\t\t\telseif ( ! is_object( $v ) )\n\t\t\t\t$v = wp_slash( $v );\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve custom fields for post.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param int $post_id Post ID.\n\t * @return array Custom fields, if exist.\n\t */\n\tpublic function get_custom_fields($post_id) {\n\t\t$post_id = (int) $post_id;\n\n\t\t$custom_fields = array();\n\n\t\tforeach ( (array) has_meta($post_id) as $meta ) {\n\t\t\t// Don't expose protected fields.\n\t\t\tif ( ! current_user_can( 'edit_post_meta', $post_id , $meta['meta_key'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$custom_fields[] = array(\n\t\t\t\t\"id\"    => $meta['meta_id'],\n\t\t\t\t\"key\"   => $meta['meta_key'],\n\t\t\t\t\"value\" => $meta['meta_value']\n\t\t\t);\n\t\t}\n\n\t\treturn $custom_fields;\n\t}\n\n\t/**\n\t * Set custom fields for post.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param int $post_id Post ID.\n\t * @param array $fields Custom fields.\n\t */\n\tpublic function set_custom_fields($post_id, $fields) {\n\t\t$post_id = (int) $post_id;\n\n\t\tforeach ( (array) $fields as $meta ) {\n\t\t\tif ( isset($meta['id']) ) {\n\t\t\t\t$meta['id'] = (int) $meta['id'];\n\t\t\t\t$pmeta = get_metadata_by_mid( 'post', $meta['id'] );\n\t\t\t\tif ( isset($meta['key']) ) {\n\t\t\t\t\t$meta['key'] = wp_unslash( $meta['key'] );\n\t\t\t\t\tif ( $meta['key'] !== $pmeta->meta_key )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t$meta['value'] = wp_unslash( $meta['value'] );\n\t\t\t\t\tif ( current_user_can( 'edit_post_meta', $post_id, $meta['key'] ) )\n\t\t\t\t\t\tupdate_metadata_by_mid( 'post', $meta['id'], $meta['value'] );\n\t\t\t\t} elseif ( current_user_can( 'delete_post_meta', $post_id, $pmeta->meta_key ) ) {\n\t\t\t\t\tdelete_metadata_by_mid( 'post', $meta['id'] );\n\t\t\t\t}\n\t\t\t} elseif ( current_user_can( 'add_post_meta', $post_id, wp_unslash( $meta['key'] ) ) ) {\n\t\t\t\tadd_post_meta( $post_id, $meta['key'], $meta['value'] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set up blog options property.\n\t *\n\t * Passes property through {@see 'xmlrpc_blog_options'} filter.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @global string $wp_version\n\t */\n\tpublic function initialise_blog_option_info() {\n\t\tglobal $wp_version;\n\n\t\t$this->blog_options = array(\n\t\t\t// Read only options\n\t\t\t'software_name'     => array(\n\t\t\t\t'desc'          => __( 'Software Name' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => 'WordPress'\n\t\t\t),\n\t\t\t'software_version'  => array(\n\t\t\t\t'desc'          => __( 'Software Version' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => $wp_version\n\t\t\t),\n\t\t\t'blog_url'          => array(\n\t\t\t\t'desc'          => __( 'WordPress Address (URL)' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'siteurl'\n\t\t\t),\n\t\t\t'home_url'          => array(\n\t\t\t\t'desc'          => __( 'Site Address (URL)' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'home'\n\t\t\t),\n\t\t\t'login_url'          => array(\n\t\t\t\t'desc'          => __( 'Login Address (URL)' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => wp_login_url( )\n\t\t\t),\n\t\t\t'admin_url'          => array(\n\t\t\t\t'desc'          => __( 'The URL to the admin area' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => get_admin_url( )\n\t\t\t),\n\t\t\t'image_default_link_type' => array(\n\t\t\t\t'desc'          => __( 'Image default link type' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'image_default_link_type'\n\t\t\t),\n\t\t\t'image_default_size' => array(\n\t\t\t\t'desc'          => __( 'Image default size' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'image_default_size'\n\t\t\t),\n\t\t\t'image_default_align' => array(\n\t\t\t\t'desc'          => __( 'Image default align' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'image_default_align'\n\t\t\t),\n\t\t\t'template'          => array(\n\t\t\t\t'desc'          => __( 'Template' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'template'\n\t\t\t),\n\t\t\t'stylesheet'        => array(\n\t\t\t\t'desc'          => __( 'Stylesheet' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'stylesheet'\n\t\t\t),\n\t\t\t'post_thumbnail'    => array(\n\t\t\t\t'desc'          => __('Post Thumbnail'),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => current_theme_supports( 'post-thumbnails' )\n\t\t\t),\n\n\t\t\t// Updatable options\n\t\t\t'time_zone'         => array(\n\t\t\t\t'desc'          => __( 'Time Zone' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'gmt_offset'\n\t\t\t),\n\t\t\t'blog_title'        => array(\n\t\t\t\t'desc'          => __( 'Site Title' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'blogname'\n\t\t\t),\n\t\t\t'blog_tagline'      => array(\n\t\t\t\t'desc'          => __( 'Site Tagline' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'blogdescription'\n\t\t\t),\n\t\t\t'date_format'       => array(\n\t\t\t\t'desc'          => __( 'Date Format' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'date_format'\n\t\t\t),\n\t\t\t'time_format'       => array(\n\t\t\t\t'desc'          => __( 'Time Format' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'time_format'\n\t\t\t),\n\t\t\t'users_can_register' => array(\n\t\t\t\t'desc'          => __( 'Allow new users to sign up' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'users_can_register'\n\t\t\t),\n\t\t\t'thumbnail_size_w'  => array(\n\t\t\t\t'desc'          => __( 'Thumbnail Width' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'thumbnail_size_w'\n\t\t\t),\n\t\t\t'thumbnail_size_h'  => array(\n\t\t\t\t'desc'          => __( 'Thumbnail Height' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'thumbnail_size_h'\n\t\t\t),\n\t\t\t'thumbnail_crop'    => array(\n\t\t\t\t'desc'          => __( 'Crop thumbnail to exact dimensions' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'thumbnail_crop'\n\t\t\t),\n\t\t\t'medium_size_w'     => array(\n\t\t\t\t'desc'          => __( 'Medium size image width' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'medium_size_w'\n\t\t\t),\n\t\t\t'medium_size_h'     => array(\n\t\t\t\t'desc'          => __( 'Medium size image height' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'medium_size_h'\n\t\t\t),\n\t\t\t'large_size_w'      => array(\n\t\t\t\t'desc'          => __( 'Large size image width' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'large_size_w'\n\t\t\t),\n\t\t\t'large_size_h'      => array(\n\t\t\t\t'desc'          => __( 'Large size image height' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'large_size_h'\n\t\t\t),\n\t\t\t'default_comment_status' => array(\n\t\t\t\t'desc'          => __( 'Allow people to post comments on new articles' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'default_comment_status'\n\t\t\t),\n\t\t\t'default_ping_status' => array(\n\t\t\t\t'desc'          => __( 'Allow link notifications from other blogs (pingbacks and trackbacks) on new articles' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'default_ping_status'\n\t\t\t)\n\t\t);\n\n\t\t/**\n\t\t * Filter the XML-RPC blog options property.\n\t\t *\n\t\t * @since 2.6.0\n\t\t *\n\t\t * @param array $blog_options An array of XML-RPC blog options.\n\t\t */\n\t\t$this->blog_options = apply_filters( 'xmlrpc_blog_options', $this->blog_options );\n\t}\n\n\t/**\n\t * Retrieve the blogs of the user.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t * }\n\t * @return array|IXR_Error Array contains:\n\t *  - 'isAdmin'\n\t *  - 'url'\n\t *  - 'blogid'\n\t *  - 'blogName'\n\t *  - 'xmlrpc' - url of xmlrpc endpoint\n\t */\n\tpublic function wp_getUsersBlogs( $args ) {\n\t\t// If this isn't on WPMU then just use blogger_getUsersBlogs\n\t\tif ( !is_multisite() ) {\n\t\t\tarray_unshift( $args, 1 );\n\t\t\treturn $this->blogger_getUsersBlogs( $args );\n\t\t}\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[0];\n\t\t$password = $args[1];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/**\n\t\t * Fires after the XML-RPC user has been authenticated but before the rest of\n\t\t * the method logic begins.\n\t\t *\n\t\t * All built-in XML-RPC methods use the action xmlrpc_call, with a parameter\n\t\t * equal to the method's name, e.g., wp.getUsersBlogs, wp.newPost, etc.\n\t\t *\n\t\t * @since 2.5.0\n\t\t *\n\t\t * @param string $name The method name.\n\t\t */\n\t\tdo_action( 'xmlrpc_call', 'wp.getUsersBlogs' );\n\n\t\t$blogs = (array) get_blogs_of_user( $user->ID );\n\t\t$struct = array();\n\n\t\tforeach ( $blogs as $blog ) {\n\t\t\t// Don't include blogs that aren't hosted at this site.\n\t\t\tif ( $blog->site_id != get_current_site()->id )\n\t\t\t\tcontinue;\n\n\t\t\t$blog_id = $blog->userblog_id;\n\n\t\t\tswitch_to_blog( $blog_id );\n\n\t\t\t$is_admin = current_user_can( 'manage_options' );\n\n\t\t\t$struct[] = array(\n\t\t\t\t'isAdmin'\t\t=> $is_admin,\n\t\t\t\t'url'\t\t\t=> home_url( '/' ),\n\t\t\t\t'blogid'\t\t=> (string) $blog_id,\n\t\t\t\t'blogName'\t\t=> get_option( 'blogname' ),\n\t\t\t\t'xmlrpc'\t\t=> site_url( 'xmlrpc.php', 'rpc' ),\n\t\t\t);\n\n\t\t\trestore_current_blog();\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Checks if the method received at least the minimum number of arguments.\n\t *\n\t * @since 3.4.0\n\t * @access protected\n\t *\n\t * @param string|array $args Sanitize single string or array of strings.\n\t * @param int $count         Minimum number of arguments.\n\t * @return bool if `$args` contains at least $count arguments.\n\t */\n\tprotected function minimum_args( $args, $count ) {\n\t\tif ( count( $args ) < $count ) {\n\t\t\t$this->error = new IXR_Error( 400, __( 'Insufficient arguments passed to this XML-RPC method.' ) );\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prepares taxonomy data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $taxonomy The unprepared taxonomy data.\n\t * @param array $fields    The subset of taxonomy fields to return.\n\t * @return array The prepared taxonomy data.\n\t */\n\tprotected function _prepare_taxonomy( $taxonomy, $fields ) {\n\t\t$_taxonomy = array(\n\t\t\t'name' => $taxonomy->name,\n\t\t\t'label' => $taxonomy->label,\n\t\t\t'hierarchical' => (bool) $taxonomy->hierarchical,\n\t\t\t'public' => (bool) $taxonomy->public,\n\t\t\t'show_ui' => (bool) $taxonomy->show_ui,\n\t\t\t'_builtin' => (bool) $taxonomy->_builtin,\n\t\t);\n\n\t\tif ( in_array( 'labels', $fields ) )\n\t\t\t$_taxonomy['labels'] = (array) $taxonomy->labels;\n\n\t\tif ( in_array( 'cap', $fields ) )\n\t\t\t$_taxonomy['cap'] = (array) $taxonomy->cap;\n\n\t\tif ( in_array( 'menu', $fields ) )\n\t\t\t$_taxonomy['show_in_menu'] = (bool) $_taxonomy->show_in_menu;\n\n\t\tif ( in_array( 'object_type', $fields ) )\n\t\t\t$_taxonomy['object_type'] = array_unique( (array) $taxonomy->object_type );\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given taxonomy.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array  $_taxonomy An array of taxonomy data.\n\t\t * @param object $taxonomy  Taxonomy object.\n\t\t * @param array  $fields    The subset of taxonomy fields to return.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_taxonomy', $_taxonomy, $taxonomy, $fields );\n\t}\n\n\t/**\n\t * Prepares term data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param array|object $term The unprepared term data.\n\t * @return array The prepared term data.\n\t */\n\tprotected function _prepare_term( $term ) {\n\t\t$_term = $term;\n\t\tif ( ! is_array( $_term ) )\n\t\t\t$_term = get_object_vars( $_term );\n\n\t\t// For integers which may be larger than XML-RPC supports ensure we return strings.\n\t\t$_term['term_id'] = strval( $_term['term_id'] );\n\t\t$_term['term_group'] = strval( $_term['term_group'] );\n\t\t$_term['term_taxonomy_id'] = strval( $_term['term_taxonomy_id'] );\n\t\t$_term['parent'] = strval( $_term['parent'] );\n\n\t\t// Count we are happy to return as an integer because people really shouldn't use terms that much.\n\t\t$_term['count'] = intval( $_term['count'] );\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given term.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array        $_term An array of term data.\n\t\t * @param array|object $term  Term object or array.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_term', $_term, $term );\n\t}\n\n\t/**\n\t * Convert a WordPress date string to an IXR_Date object.\n\t *\n\t * @access protected\n\t *\n\t * @param string $date Date string to convert.\n\t * @return IXR_Date IXR_Date object.\n\t */\n\tprotected function _convert_date( $date ) {\n\t\tif ( $date === '0000-00-00 00:00:00' ) {\n\t\t\treturn new IXR_Date( '00000000T00:00:00Z' );\n\t\t}\n\t\treturn new IXR_Date( mysql2date( 'Ymd\\TH:i:s', $date, false ) );\n\t}\n\n\t/**\n\t * Convert a WordPress GMT date string to an IXR_Date object.\n\t *\n\t * @access protected\n\t *\n\t * @param string $date_gmt WordPress GMT date string.\n\t * @param string $date     Date string.\n\t * @return IXR_Date IXR_Date object.\n\t */\n\tprotected function _convert_date_gmt( $date_gmt, $date ) {\n\t\tif ( $date !== '0000-00-00 00:00:00' && $date_gmt === '0000-00-00 00:00:00' ) {\n\t\t\treturn new IXR_Date( get_gmt_from_date( mysql2date( 'Y-m-d H:i:s', $date, false ), 'Ymd\\TH:i:s' ) );\n\t\t}\n\t\treturn $this->_convert_date( $date_gmt );\n\t}\n\n\t/**\n\t * Prepares post data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param array $post   The unprepared post data.\n\t * @param array $fields The subset of post type fields to return.\n\t * @return array The prepared post data.\n\t */\n\tprotected function _prepare_post( $post, $fields ) {\n\t\t// Holds the data for this post. built up based on $fields.\n\t\t$_post = array( 'post_id' => strval( $post['ID'] ) );\n\n\t\t// Prepare common post fields.\n\t\t$post_fields = array(\n\t\t\t'post_title'        => $post['post_title'],\n\t\t\t'post_date'         => $this->_convert_date( $post['post_date'] ),\n\t\t\t'post_date_gmt'     => $this->_convert_date_gmt( $post['post_date_gmt'], $post['post_date'] ),\n\t\t\t'post_modified'     => $this->_convert_date( $post['post_modified'] ),\n\t\t\t'post_modified_gmt' => $this->_convert_date_gmt( $post['post_modified_gmt'], $post['post_modified'] ),\n\t\t\t'post_status'       => $post['post_status'],\n\t\t\t'post_type'         => $post['post_type'],\n\t\t\t'post_name'         => $post['post_name'],\n\t\t\t'post_author'       => $post['post_author'],\n\t\t\t'post_password'     => $post['post_password'],\n\t\t\t'post_excerpt'      => $post['post_excerpt'],\n\t\t\t'post_content'      => $post['post_content'],\n\t\t\t'post_parent'       => strval( $post['post_parent'] ),\n\t\t\t'post_mime_type'    => $post['post_mime_type'],\n\t\t\t'link'              => post_permalink( $post['ID'] ),\n\t\t\t'guid'              => $post['guid'],\n\t\t\t'menu_order'        => intval( $post['menu_order'] ),\n\t\t\t'comment_status'    => $post['comment_status'],\n\t\t\t'ping_status'       => $post['ping_status'],\n\t\t\t'sticky'            => ( $post['post_type'] === 'post' && is_sticky( $post['ID'] ) ),\n\t\t);\n\n\t\t// Thumbnail.\n\t\t$post_fields['post_thumbnail'] = array();\n\t\t$thumbnail_id = get_post_thumbnail_id( $post['ID'] );\n\t\tif ( $thumbnail_id ) {\n\t\t\t$thumbnail_size = current_theme_supports('post-thumbnail') ? 'post-thumbnail' : 'thumbnail';\n\t\t\t$post_fields['post_thumbnail'] = $this->_prepare_media_item( get_post( $thumbnail_id ), $thumbnail_size );\n\t\t}\n\n\t\t// Consider future posts as published.\n\t\tif ( $post_fields['post_status'] === 'future' )\n\t\t\t$post_fields['post_status'] = 'publish';\n\n\t\t// Fill in blank post format.\n\t\t$post_fields['post_format'] = get_post_format( $post['ID'] );\n\t\tif ( empty( $post_fields['post_format'] ) )\n\t\t\t$post_fields['post_format'] = 'standard';\n\n\t\t// Merge requested $post_fields fields into $_post.\n\t\tif ( in_array( 'post', $fields ) ) {\n\t\t\t$_post = array_merge( $_post, $post_fields );\n\t\t} else {\n\t\t\t$requested_fields = array_intersect_key( $post_fields, array_flip( $fields ) );\n\t\t\t$_post = array_merge( $_post, $requested_fields );\n\t\t}\n\n\t\t$all_taxonomy_fields = in_array( 'taxonomies', $fields );\n\n\t\tif ( $all_taxonomy_fields || in_array( 'terms', $fields ) ) {\n\t\t\t$post_type_taxonomies = get_object_taxonomies( $post['post_type'], 'names' );\n\t\t\t$terms = wp_get_object_terms( $post['ID'], $post_type_taxonomies );\n\t\t\t$_post['terms'] = array();\n\t\t\tforeach ( $terms as $term ) {\n\t\t\t\t$_post['terms'][] = $this->_prepare_term( $term );\n\t\t\t}\n\t\t}\n\n\t\tif ( in_array( 'custom_fields', $fields ) )\n\t\t\t$_post['custom_fields'] = $this->get_custom_fields( $post['ID'] );\n\n\t\tif ( in_array( 'enclosure', $fields ) ) {\n\t\t\t$_post['enclosure'] = array();\n\t\t\t$enclosures = (array) get_post_meta( $post['ID'], 'enclosure' );\n\t\t\tif ( ! empty( $enclosures ) ) {\n\t\t\t\t$encdata = explode( \"\\n\", $enclosures[0] );\n\t\t\t\t$_post['enclosure']['url'] = trim( htmlspecialchars( $encdata[0] ) );\n\t\t\t\t$_post['enclosure']['length'] = (int) trim( $encdata[1] );\n\t\t\t\t$_post['enclosure']['type'] = trim( $encdata[2] );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared date for the given post.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array $_post  An array of modified post data.\n\t\t * @param array $post   An array of post data.\n\t\t * @param array $fields An array of post fields.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_post', $_post, $post, $fields );\n\t}\n\n\t/**\n\t * Prepares post data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $post_type Post type object.\n\t * @param array  $fields    The subset of post fields to return.\n\t * @return array The prepared post type data.\n\t */\n\tprotected function _prepare_post_type( $post_type, $fields ) {\n\t\t$_post_type = array(\n\t\t\t'name' => $post_type->name,\n\t\t\t'label' => $post_type->label,\n\t\t\t'hierarchical' => (bool) $post_type->hierarchical,\n\t\t\t'public' => (bool) $post_type->public,\n\t\t\t'show_ui' => (bool) $post_type->show_ui,\n\t\t\t'_builtin' => (bool) $post_type->_builtin,\n\t\t\t'has_archive' => (bool) $post_type->has_archive,\n\t\t\t'supports' => get_all_post_type_supports( $post_type->name ),\n\t\t);\n\n\t\tif ( in_array( 'labels', $fields ) ) {\n\t\t\t$_post_type['labels'] = (array) $post_type->labels;\n\t\t}\n\n\t\tif ( in_array( 'cap', $fields ) ) {\n\t\t\t$_post_type['cap'] = (array) $post_type->cap;\n\t\t\t$_post_type['map_meta_cap'] = (bool) $post_type->map_meta_cap;\n\t\t}\n\n\t\tif ( in_array( 'menu', $fields ) ) {\n\t\t\t$_post_type['menu_position'] = (int) $post_type->menu_position;\n\t\t\t$_post_type['menu_icon'] = $post_type->menu_icon;\n\t\t\t$_post_type['show_in_menu'] = (bool) $post_type->show_in_menu;\n\t\t}\n\n\t\tif ( in_array( 'taxonomies', $fields ) )\n\t\t\t$_post_type['taxonomies'] = get_object_taxonomies( $post_type->name, 'names' );\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared date for the given post type.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array  $_post_type An array of post type data.\n\t\t * @param object $post_type  Post type object.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_post_type', $_post_type, $post_type );\n\t}\n\n\t/**\n\t * Prepares media item data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $media_item     The unprepared media item data.\n\t * @param string $thumbnail_size The image size to use for the thumbnail URL.\n\t * @return array The prepared media item data.\n\t */\n\tprotected function _prepare_media_item( $media_item, $thumbnail_size = 'thumbnail' ) {\n\t\t$_media_item = array(\n\t\t\t'attachment_id'    => strval( $media_item->ID ),\n\t\t\t'date_created_gmt' => $this->_convert_date_gmt( $media_item->post_date_gmt, $media_item->post_date ),\n\t\t\t'parent'           => $media_item->post_parent,\n\t\t\t'link'             => wp_get_attachment_url( $media_item->ID ),\n\t\t\t'title'            => $media_item->post_title,\n\t\t\t'caption'          => $media_item->post_excerpt,\n\t\t\t'description'      => $media_item->post_content,\n\t\t\t'metadata'         => wp_get_attachment_metadata( $media_item->ID ),\n\t\t);\n\n\t\t$thumbnail_src = image_downsize( $media_item->ID, $thumbnail_size );\n\t\tif ( $thumbnail_src )\n\t\t\t$_media_item['thumbnail'] = $thumbnail_src[0];\n\t\telse\n\t\t\t$_media_item['thumbnail'] = $_media_item['link'];\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given media item.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array  $_media_item    An array of media item data.\n\t\t * @param object $media_item     Media item object.\n\t\t * @param string $thumbnail_size Image size.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_media_item', $_media_item, $media_item, $thumbnail_size );\n\t}\n\n\t/**\n\t * Prepares page data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $page The unprepared page data.\n\t * @return array The prepared page data.\n\t */\n\tprotected function _prepare_page( $page ) {\n\t\t// Get all of the page content and link.\n\t\t$full_page = get_extended( $page->post_content );\n\t\t$link = post_permalink( $page->ID );\n\n\t\t// Get info the page parent if there is one.\n\t\t$parent_title = \"\";\n\t\tif ( ! empty( $page->post_parent ) ) {\n\t\t\t$parent = get_post( $page->post_parent );\n\t\t\t$parent_title = $parent->post_title;\n\t\t}\n\n\t\t// Determine comment and ping settings.\n\t\t$allow_comments = comments_open( $page->ID ) ? 1 : 0;\n\t\t$allow_pings = pings_open( $page->ID ) ? 1 : 0;\n\n\t\t// Format page date.\n\t\t$page_date = $this->_convert_date( $page->post_date );\n\t\t$page_date_gmt = $this->_convert_date_gmt( $page->post_date_gmt, $page->post_date );\n\n\t\t// Pull the categories info together.\n\t\t$categories = array();\n\t\tif ( is_object_in_taxonomy( 'page', 'category' ) ) {\n\t\t\tforeach ( wp_get_post_categories( $page->ID ) as $cat_id ) {\n\t\t\t\t$categories[] = get_cat_name( $cat_id );\n\t\t\t}\n\t\t}\n\n\t\t// Get the author info.\n\t\t$author = get_userdata( $page->post_author );\n\n\t\t$page_template = get_page_template_slug( $page->ID );\n\t\tif ( empty( $page_template ) )\n\t\t\t$page_template = 'default';\n\n\t\t$_page = array(\n\t\t\t'dateCreated'            => $page_date,\n\t\t\t'userid'                 => $page->post_author,\n\t\t\t'page_id'                => $page->ID,\n\t\t\t'page_status'            => $page->post_status,\n\t\t\t'description'            => $full_page['main'],\n\t\t\t'title'                  => $page->post_title,\n\t\t\t'link'                   => $link,\n\t\t\t'permaLink'              => $link,\n\t\t\t'categories'             => $categories,\n\t\t\t'excerpt'                => $page->post_excerpt,\n\t\t\t'text_more'              => $full_page['extended'],\n\t\t\t'mt_allow_comments'      => $allow_comments,\n\t\t\t'mt_allow_pings'         => $allow_pings,\n\t\t\t'wp_slug'                => $page->post_name,\n\t\t\t'wp_password'            => $page->post_password,\n\t\t\t'wp_author'              => $author->display_name,\n\t\t\t'wp_page_parent_id'      => $page->post_parent,\n\t\t\t'wp_page_parent_title'   => $parent_title,\n\t\t\t'wp_page_order'          => $page->menu_order,\n\t\t\t'wp_author_id'           => (string) $author->ID,\n\t\t\t'wp_author_display_name' => $author->display_name,\n\t\t\t'date_created_gmt'       => $page_date_gmt,\n\t\t\t'custom_fields'          => $this->get_custom_fields( $page->ID ),\n\t\t\t'wp_page_template'       => $page_template\n\t\t);\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given page.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array   $_page An array of page data.\n\t\t * @param WP_Post $page  Page object.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_page', $_page, $page );\n\t}\n\n\t/**\n\t * Prepares comment data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $comment The unprepared comment data.\n\t * @return array The prepared comment data.\n\t */\n\tprotected function _prepare_comment( $comment ) {\n\t\t// Format page date.\n\t\t$comment_date_gmt = $this->_convert_date_gmt( $comment->comment_date_gmt, $comment->comment_date );\n\n\t\tif ( '0' == $comment->comment_approved ) {\n\t\t\t$comment_status = 'hold';\n\t\t} elseif ( 'spam' == $comment->comment_approved ) {\n\t\t\t$comment_status = 'spam';\n\t\t} elseif ( '1' == $comment->comment_approved ) {\n\t\t\t$comment_status = 'approve';\n\t\t} else {\n\t\t\t$comment_status = $comment->comment_approved;\n\t\t}\n\t\t$_comment = array(\n\t\t\t'date_created_gmt' => $comment_date_gmt,\n\t\t\t'user_id'          => $comment->user_id,\n\t\t\t'comment_id'       => $comment->comment_ID,\n\t\t\t'parent'           => $comment->comment_parent,\n\t\t\t'status'           => $comment_status,\n\t\t\t'content'          => $comment->comment_content,\n\t\t\t'link'             => get_comment_link($comment),\n\t\t\t'post_id'          => $comment->comment_post_ID,\n\t\t\t'post_title'       => get_the_title($comment->comment_post_ID),\n\t\t\t'author'           => $comment->comment_author,\n\t\t\t'author_url'       => $comment->comment_author_url,\n\t\t\t'author_email'     => $comment->comment_author_email,\n\t\t\t'author_ip'        => $comment->comment_author_IP,\n\t\t\t'type'             => $comment->comment_type,\n\t\t);\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given comment.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array  $_comment An array of prepared comment data.\n\t\t * @param object $comment  Comment object.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_comment', $_comment, $comment );\n\t}\n\n\t/**\n\t * Prepares user data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param WP_User $user   The unprepared user object.\n\t * @param array   $fields The subset of user fields to return.\n\t * @return array The prepared user data.\n\t */\n\tprotected function _prepare_user( $user, $fields ) {\n\t\t$_user = array( 'user_id' => strval( $user->ID ) );\n\n\t\t$user_fields = array(\n\t\t\t'username'          => $user->user_login,\n\t\t\t'first_name'        => $user->user_firstname,\n\t\t\t'last_name'         => $user->user_lastname,\n\t\t\t'registered'        => $this->_convert_date( $user->user_registered ),\n\t\t\t'bio'               => $user->user_description,\n\t\t\t'email'             => $user->user_email,\n\t\t\t'nickname'          => $user->nickname,\n\t\t\t'nicename'          => $user->user_nicename,\n\t\t\t'url'               => $user->user_url,\n\t\t\t'display_name'      => $user->display_name,\n\t\t\t'roles'             => $user->roles,\n\t\t);\n\n\t\tif ( in_array( 'all', $fields ) ) {\n\t\t\t$_user = array_merge( $_user, $user_fields );\n\t\t} else {\n\t\t\tif ( in_array( 'basic', $fields ) ) {\n\t\t\t\t$basic_fields = array( 'username', 'email', 'registered', 'display_name', 'nicename' );\n\t\t\t\t$fields = array_merge( $fields, $basic_fields );\n\t\t\t}\n\t\t\t$requested_fields = array_intersect_key( $user_fields, array_flip( $fields ) );\n\t\t\t$_user = array_merge( $_user, $requested_fields );\n\t\t}\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given user.\n\t\t *\n\t\t * @since 3.5.0\n\t\t *\n\t\t * @param array   $_user  An array of user data.\n\t\t * @param WP_User $user   User object.\n\t\t * @param array   $fields An array of user fields.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_user', $_user, $user, $fields );\n\t}\n\n\t/**\n\t * Create a new post for any registered post type.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @link http://en.wikipedia.org/wiki/RSS_enclosure for information on RSS enclosures.\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: top-level arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id        Blog ID (unused).\n\t *     @type string $username       Username.\n\t *     @type string $password       Password.\n\t *     @type array  $content_struct {\n\t *         Content struct for adding a new post. See wp_insert_post() for information on\n\t *         additional post fields\n\t *\n\t *         @type string $post_type      Post type. Default 'post'.\n\t *         @type string $post_status    Post status. Default 'draft'\n\t *         @type string $post_title     Post title.\n\t *         @type int    $post_author    Post author ID.\n\t *         @type string $post_excerpt   Post excerpt.\n\t *         @type string $post_content   Post content.\n\t *         @type string $post_date_gmt  Post date in GMT.\n\t *         @type string $post_date      Post date.\n\t *         @type string $post_password  Post password (20-character limit).\n\t *         @type string $comment_status Post comment enabled status. Accepts 'open' or 'closed'.\n\t *         @type string $ping_status    Post ping status. Accepts 'open' or 'closed'.\n\t *         @type bool   $sticky         Whether the post should be sticky. Automatically false if\n\t *                                      `$post_status` is 'private'.\n\t *         @type int    $post_thumbnail ID of an image to use as the post thumbnail/featured image.\n\t *         @type array  $custom_fields  Array of meta key/value pairs to add to the post.\n\t *         @type array  $terms          Associative array with taxonomy names as keys and arrays\n\t *                                      of term IDs as values.\n\t *         @type array  $terms_names    Associative array with taxonomy names as keys and arrays\n\t *                                      of term names as values.\n\t *         @type array  $enclosure      {\n\t *             Array of feed enclosure data to add to post meta.\n\t *\n\t *             @type string $url    URL for the feed enclosure.\n\t *             @type int    $length Size in bytes of the enclosure.\n\t *             @type string $type   Mime-type for the enclosure.\n\t *         }\n\t *     }\n\t * }\n\t * @return int|IXR_Error Post ID on success, IXR_Error instance otherwise.\n\t */\n\tpublic function wp_newPost( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t// convert the date field back to IXR form\n\t\tif ( isset( $content_struct['post_date'] ) && ! ( $content_struct['post_date'] instanceof IXR_Date ) ) {\n\t\t\t$content_struct['post_date'] = $this->_convert_date( $content_struct['post_date'] );\n\t\t}\n\n\t\t// ignore the existing GMT date if it is empty or a non-GMT date was supplied in $content_struct,\n\t\t// since _insert_post will ignore the non-GMT date if the GMT date is set\n\t\tif ( isset( $content_struct['post_date_gmt'] ) && ! ( $content_struct['post_date_gmt'] instanceof IXR_Date ) ) {\n\t\t\tif ( $content_struct['post_date_gmt'] == '0000-00-00 00:00:00' || isset( $content_struct['post_date'] ) ) {\n\t\t\t\tunset( $content_struct['post_date_gmt'] );\n\t\t\t} else {\n\t\t\t\t$content_struct['post_date_gmt'] = $this->_convert_date( $content_struct['post_date_gmt'] );\n\t\t\t}\n\t\t}\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newPost' );\n\n\t\tunset( $content_struct['ID'] );\n\n\t\treturn $this->_insert_post( $user, $content_struct );\n\t}\n\n\t/**\n\t * Helper method for filtering out elements from an array.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param int $count Number to compare to one.\n\t */\n\tprivate function _is_greater_than_one( $count ) {\n\t\treturn $count > 1;\n\t}\n\n\t/**\n\t * Encapsulate the logic for sticking a post\n\t * and determining if the user has permission to do so\n\t *\n\t * @since 4.3.0\n\t * @access private\n\t *\n\t * @param array $post_data\n\t * @param bool  $update\n\t * @return void|IXR_Error\n\t */\n\tprivate function _toggle_sticky( $post_data, $update = false ) {\n\t\t$post_type = get_post_type_object( $post_data['post_type'] );\n\n\t\t// Private and password-protected posts cannot be stickied.\n\t\tif ( 'private' === $post_data['post_status'] || ! empty( $post_data['post_password'] ) ) {\n\t\t\t// Error if the client tried to stick the post, otherwise, silently unstick.\n\t\t\tif ( ! empty( $post_data['sticky'] ) ) {\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot stick a private post.' ) );\n\t\t\t}\n\n\t\t\tif ( $update ) {\n\t\t\t\tunstick_post( $post_data['ID'] );\n\t\t\t}\n\t\t} elseif ( isset( $post_data['sticky'] ) )  {\n\t\t\tif ( ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to stick this post.' ) );\n\t\t\t}\n\n\t\t\t$sticky = wp_validate_boolean( $post_data['sticky'] );\n\t\t\tif ( $sticky ) {\n\t\t\t\tstick_post( $post_data['ID'] );\n\t\t\t} else {\n\t\t\t\tunstick_post( $post_data['ID'] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method for wp_newPost() and wp_editPost(), containing shared logic.\n\t *\n\t * @since 3.4.0\n\t * @access protected\n\t *\n\t * @see wp_insert_post()\n\t *\n\t * @param WP_User         $user           The post author if post_author isn't set in $content_struct.\n\t * @param array|IXR_Error $content_struct Post data to insert.\n\t * @return IXR_Error|string\n\t */\n\tprotected function _insert_post( $user, $content_struct ) {\n\t\t$defaults = array( 'post_status' => 'draft', 'post_type' => 'post', 'post_author' => 0,\n\t\t\t'post_password' => '', 'post_excerpt' => '', 'post_content' => '', 'post_title' => '' );\n\n\t\t$post_data = wp_parse_args( $content_struct, $defaults );\n\n\t\t$post_type = get_post_type_object( $post_data['post_type'] );\n\t\tif ( ! $post_type )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid post type' ) );\n\n\t\t$update = ! empty( $post_data['ID'] );\n\n\t\tif ( $update ) {\n\t\t\tif ( ! get_post( $post_data['ID'] ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Invalid post ID.' ) );\n\t\t\tif ( ! current_user_can( 'edit_post', $post_data['ID'] ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to edit this post.' ) );\n\t\t\tif ( $post_data['post_type'] != get_post_type( $post_data['ID'] ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'The post type may not be changed.' ) );\n\t\t} else {\n\t\t\tif ( ! current_user_can( $post_type->cap->create_posts ) || ! current_user_can( $post_type->cap->edit_posts ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to post on this site.' ) );\n\t\t}\n\n\t\tswitch ( $post_data['post_status'] ) {\n\t\t\tcase 'draft':\n\t\t\tcase 'pending':\n\t\t\t\tbreak;\n\t\t\tcase 'private':\n\t\t\t\tif ( ! current_user_can( $post_type->cap->publish_posts ) )\n\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to create private posts in this post type' ) );\n\t\t\t\tbreak;\n\t\t\tcase 'publish':\n\t\t\tcase 'future':\n\t\t\t\tif ( ! current_user_can( $post_type->cap->publish_posts ) )\n\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to publish posts in this post type' ) );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( ! get_post_status_object( $post_data['post_status'] ) )\n\t\t\t\t\t$post_data['post_status'] = 'draft';\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( ! empty( $post_data['post_password'] ) && ! current_user_can( $post_type->cap->publish_posts ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to create password protected posts in this post type' ) );\n\n\t\t$post_data['post_author'] = absint( $post_data['post_author'] );\n\t\tif ( ! empty( $post_data['post_author'] ) && $post_data['post_author'] != $user->ID ) {\n\t\t\tif ( ! current_user_can( $post_type->cap->edit_others_posts ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to create posts as this user.' ) );\n\n\t\t\t$author = get_userdata( $post_data['post_author'] );\n\n\t\t\tif ( ! $author )\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid author ID.' ) );\n\t\t} else {\n\t\t\t$post_data['post_author'] = $user->ID;\n\t\t}\n\n\t\tif ( isset( $post_data['comment_status'] ) && $post_data['comment_status'] != 'open' && $post_data['comment_status'] != 'closed' )\n\t\t\tunset( $post_data['comment_status'] );\n\n\t\tif ( isset( $post_data['ping_status'] ) && $post_data['ping_status'] != 'open' && $post_data['ping_status'] != 'closed' )\n\t\t\tunset( $post_data['ping_status'] );\n\n\t\t// Do some timestamp voodoo.\n\t\tif ( ! empty( $post_data['post_date_gmt'] ) ) {\n\t\t\t// We know this is supposed to be GMT, so we're going to slap that Z on there by force.\n\t\t\t$dateCreated = rtrim( $post_data['post_date_gmt']->getIso(), 'Z' ) . 'Z';\n\t\t} elseif ( ! empty( $post_data['post_date'] ) ) {\n\t\t\t$dateCreated = $post_data['post_date']->getIso();\n\t\t}\n\n\t\tif ( ! empty( $dateCreated ) ) {\n\t\t\t$post_data['post_date'] = get_date_from_gmt( iso8601_to_datetime( $dateCreated ) );\n\t\t\t$post_data['post_date_gmt'] = iso8601_to_datetime( $dateCreated, 'GMT' );\n\t\t}\n\n\t\tif ( ! isset( $post_data['ID'] ) )\n\t\t\t$post_data['ID'] = get_default_post_to_edit( $post_data['post_type'], true )->ID;\n\t\t$post_ID = $post_data['ID'];\n\n\t\tif ( $post_data['post_type'] == 'post' ) {\n\t\t\t$error = $this->_toggle_sticky( $post_data, $update );\n\t\t\tif ( $error ) {\n\t\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $post_data['post_thumbnail'] ) ) {\n\t\t\t// empty value deletes, non-empty value adds/updates.\n\t\t\tif ( ! $post_data['post_thumbnail'] )\n\t\t\t\tdelete_post_thumbnail( $post_ID );\n\t\t\telseif ( ! get_post( absint( $post_data['post_thumbnail'] ) ) )\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid attachment ID.' ) );\n\t\t\tset_post_thumbnail( $post_ID, $post_data['post_thumbnail'] );\n\t\t\tunset( $content_struct['post_thumbnail'] );\n\t\t}\n\n\t\tif ( isset( $post_data['custom_fields'] ) )\n\t\t\t$this->set_custom_fields( $post_ID, $post_data['custom_fields'] );\n\n\t\tif ( isset( $post_data['terms'] ) || isset( $post_data['terms_names'] ) ) {\n\t\t\t$post_type_taxonomies = get_object_taxonomies( $post_data['post_type'], 'objects' );\n\n\t\t\t// Accumulate term IDs from terms and terms_names.\n\t\t\t$terms = array();\n\n\t\t\t// First validate the terms specified by ID.\n\t\t\tif ( isset( $post_data['terms'] ) && is_array( $post_data['terms'] ) ) {\n\t\t\t\t$taxonomies = array_keys( $post_data['terms'] );\n\n\t\t\t\t// Validating term ids.\n\t\t\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t\t\tif ( ! array_key_exists( $taxonomy , $post_type_taxonomies ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, one of the given taxonomies is not supported by the post type.' ) );\n\n\t\t\t\t\tif ( ! current_user_can( $post_type_taxonomies[$taxonomy]->cap->assign_terms ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to assign a term to one of the given taxonomies.' ) );\n\n\t\t\t\t\t$term_ids = $post_data['terms'][$taxonomy];\n\t\t\t\t\t$terms[ $taxonomy ] = array();\n\t\t\t\t\tforeach ( $term_ids as $term_id ) {\n\t\t\t\t\t\t$term = get_term_by( 'id', $term_id, $taxonomy );\n\n\t\t\t\t\t\tif ( ! $term )\n\t\t\t\t\t\t\treturn new IXR_Error( 403, __( 'Invalid term ID' ) );\n\n\t\t\t\t\t\t$terms[$taxonomy][] = (int) $term_id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now validate terms specified by name.\n\t\t\tif ( isset( $post_data['terms_names'] ) && is_array( $post_data['terms_names'] ) ) {\n\t\t\t\t$taxonomies = array_keys( $post_data['terms_names'] );\n\n\t\t\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t\t\tif ( ! array_key_exists( $taxonomy , $post_type_taxonomies ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, one of the given taxonomies is not supported by the post type.' ) );\n\n\t\t\t\t\tif ( ! current_user_can( $post_type_taxonomies[$taxonomy]->cap->assign_terms ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to assign a term to one of the given taxonomies.' ) );\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For hierarchical taxonomies, we can't assign a term when multiple terms\n\t\t\t\t\t * in the hierarchy share the same name.\n\t\t\t\t\t */\n\t\t\t\t\t$ambiguous_terms = array();\n\t\t\t\t\tif ( is_taxonomy_hierarchical( $taxonomy ) ) {\n\t\t\t\t\t\t$tax_term_names = get_terms( $taxonomy, array( 'fields' => 'names', 'hide_empty' => false ) );\n\n\t\t\t\t\t\t// Count the number of terms with the same name.\n\t\t\t\t\t\t$tax_term_names_count = array_count_values( $tax_term_names );\n\n\t\t\t\t\t\t// Filter out non-ambiguous term names.\n\t\t\t\t\t\t$ambiguous_tax_term_counts = array_filter( $tax_term_names_count, array( $this, '_is_greater_than_one') );\n\n\t\t\t\t\t\t$ambiguous_terms = array_keys( $ambiguous_tax_term_counts );\n\t\t\t\t\t}\n\n\t\t\t\t\t$term_names = $post_data['terms_names'][$taxonomy];\n\t\t\t\t\tforeach ( $term_names as $term_name ) {\n\t\t\t\t\t\tif ( in_array( $term_name, $ambiguous_terms ) )\n\t\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Ambiguous term name used in a hierarchical taxonomy. Please use term ID instead.' ) );\n\n\t\t\t\t\t\t$term = get_term_by( 'name', $term_name, $taxonomy );\n\n\t\t\t\t\t\tif ( ! $term ) {\n\t\t\t\t\t\t\t// Term doesn't exist, so check that the user is allowed to create new terms.\n\t\t\t\t\t\t\tif ( ! current_user_can( $post_type_taxonomies[$taxonomy]->cap->edit_terms ) )\n\t\t\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to add a term to one of the given taxonomies.' ) );\n\n\t\t\t\t\t\t\t// Create the new term.\n\t\t\t\t\t\t\t$term_info = wp_insert_term( $term_name, $taxonomy );\n\t\t\t\t\t\t\tif ( is_wp_error( $term_info ) )\n\t\t\t\t\t\t\t\treturn new IXR_Error( 500, $term_info->get_error_message() );\n\n\t\t\t\t\t\t\t$terms[$taxonomy][] = (int) $term_info['term_id'];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$terms[$taxonomy][] = (int) $term->term_id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$post_data['tax_input'] = $terms;\n\t\t\tunset( $post_data['terms'], $post_data['terms_names'] );\n\t\t} else {\n\t\t\t// Do not allow direct submission of 'tax_input', clients must use 'terms' and/or 'terms_names'.\n\t\t\tunset( $post_data['tax_input'], $post_data['post_category'], $post_data['tags_input'] );\n\t\t}\n\n\t\tif ( isset( $post_data['post_format'] ) ) {\n\t\t\t$format = set_post_format( $post_ID, $post_data['post_format'] );\n\n\t\t\tif ( is_wp_error( $format ) )\n\t\t\t\treturn new IXR_Error( 500, $format->get_error_message() );\n\n\t\t\tunset( $post_data['post_format'] );\n\t\t}\n\n\t\t// Handle enclosures.\n\t\t$enclosure = isset( $post_data['enclosure'] ) ? $post_data['enclosure'] : null;\n\t\t$this->add_enclosure_if_new( $post_ID, $enclosure );\n\n\t\t$this->attach_uploads( $post_ID, $post_data['post_content'] );\n\n\t\t/**\n\t\t * Filter post data array to be inserted via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array $post_data      Parsed array of post data.\n\t\t * @param array $content_struct Post data array.\n\t\t */\n\t\t$post_data = apply_filters( 'xmlrpc_wp_insert_post_data', $post_data, $content_struct );\n\n\t\t$post_ID = $update ? wp_update_post( $post_data, true ) : wp_insert_post( $post_data, true );\n\t\tif ( is_wp_error( $post_ID ) )\n\t\t\treturn new IXR_Error( 500, $post_ID->get_error_message() );\n\n\t\tif ( ! $post_ID )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, your entry could not be posted. Something wrong happened.' ) );\n\n\t\treturn strval( $post_ID );\n\t}\n\n\t/**\n\t * Edit a post for any registered post type.\n\t *\n\t * The $content_struct parameter only needs to contain fields that\n\t * should be changed. All other fields will retain their existing values.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id        Blog ID (unused).\n\t *     @type string $username       Username.\n\t *     @type string $password       Password.\n\t *     @type int    $post_id        Post ID.\n\t *     @type array  $content_struct Extra content arguments.\n\t * }\n\t * @return true|IXR_Error True on success, IXR_Error on failure.\n\t */\n\tpublic function wp_editPost( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 5 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$post_id        = (int) $args[3];\n\t\t$content_struct = $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editPost' );\n\n\t\t$post = get_post( $post_id, ARRAY_A );\n\n\t\tif ( empty( $post['ID'] ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( isset( $content_struct['if_not_modified_since'] ) ) {\n\t\t\t// If the post has been modified since the date provided, return an error.\n\t\t\tif ( mysql2date( 'U', $post['post_modified_gmt'] ) > $content_struct['if_not_modified_since']->getTimestamp() ) {\n\t\t\t\treturn new IXR_Error( 409, __( 'There is a revision of this post that is more recent.' ) );\n\t\t\t}\n\t\t}\n\n\t\t// Convert the date field back to IXR form.\n\t\t$post['post_date'] = $this->_convert_date( $post['post_date'] );\n\n\t\t/*\n\t\t * Ignore the existing GMT date if it is empty or a non-GMT date was supplied in $content_struct,\n\t\t * since _insert_post() will ignore the non-GMT date if the GMT date is set.\n\t\t */\n\t\tif ( $post['post_date_gmt'] == '0000-00-00 00:00:00' || isset( $content_struct['post_date'] ) )\n\t\t\tunset( $post['post_date_gmt'] );\n\t\telse\n\t\t\t$post['post_date_gmt'] = $this->_convert_date( $post['post_date_gmt'] );\n\n\t\t$this->escape( $post );\n\t\t$merged_content_struct = array_merge( $post, $content_struct );\n\n\t\t$retval = $this->_insert_post( $user, $merged_content_struct );\n\t\tif ( $retval instanceof IXR_Error )\n\t\t\treturn $retval;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Delete a post for any registered post type.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_delete_post()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type int    $post_id  Post ID.\n\t * }\n\t * @return true|IXR_Error True on success, IXR_Error instance on failure.\n\t */\n\tpublic function wp_deletePost( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username   = $args[1];\n\t\t$password   = $args[2];\n\t\t$post_id    = (int) $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deletePost' );\n\n\t\t$post = get_post( $post_id, ARRAY_A );\n\t\tif ( empty( $post['ID'] ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'delete_post', $post_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to delete this post.' ) );\n\n\t\t$result = wp_delete_post( $post_id );\n\n\t\tif ( ! $result )\n\t\t\treturn new IXR_Error( 500, __( 'The post cannot be deleted.' ) );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieve a post.\n\t *\n\t * @since 3.4.0\n\t *\n\t * The optional $fields parameter specifies what fields will be included\n\t * in the response array. This should be a list of field names. 'post_id' will\n\t * always be included in the response regardless of the value of $fields.\n\t *\n\t * Instead of, or in addition to, individual field names, conceptual group\n\t * names can be used to specify multiple fields. The available conceptual\n\t * groups are 'post' (all basic fields), 'taxonomies', 'custom_fields',\n\t * and 'enclosure'.\n\t *\n\t * @see get_post()\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type int    $post_id  Post ID.\n\t *     @type array  $fields   The subset of post type fields to return.\n\t * }\n\t * @return array|IXR_Error Array contains (based on $fields parameter):\n\t *  - 'post_id'\n\t *  - 'post_title'\n\t *  - 'post_date'\n\t *  - 'post_date_gmt'\n\t *  - 'post_modified'\n\t *  - 'post_modified_gmt'\n\t *  - 'post_status'\n\t *  - 'post_type'\n\t *  - 'post_name'\n\t *  - 'post_author'\n\t *  - 'post_password'\n\t *  - 'post_excerpt'\n\t *  - 'post_content'\n\t *  - 'link'\n\t *  - 'comment_status'\n\t *  - 'ping_status'\n\t *  - 'sticky'\n\t *  - 'custom_fields'\n\t *  - 'terms'\n\t *  - 'categories'\n\t *  - 'tags'\n\t *  - 'enclosure'\n\t */\n\tpublic function wp_getPost( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$post_id  = (int) $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the list of post query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param array  $fields Array of post fields. Default array contains 'post', 'terms', and 'custom_fields'.\n\t\t\t * @param string $method Method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_post_fields', array( 'post', 'terms', 'custom_fields' ), 'wp.getPost' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPost' );\n\n\t\t$post = get_post( $post_id, ARRAY_A );\n\n\t\tif ( empty( $post['ID'] ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'edit_post', $post_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\n\t\treturn $this->_prepare_post( $post, $fields );\n\t}\n\n\t/**\n\t * Retrieve posts.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_get_recent_posts()\n\t * @see wp_getPost() for more on `$fields`\n\t * @see get_posts() for more on `$filter` values\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type array  $filter   Optional. Modifies the query used to retrieve posts. Accepts 'post_type',\n\t *                            'post_status', 'number', 'offset', 'orderby', and 'order'.\n\t *                            Default empty array.\n\t *     @type array  $fields   Optional. The subset of post type fields to return in the response array.\n\t * }\n\t * @return array|IXR_Error Array contains a collection of posts.\n\t */\n\tpublic function wp_getPosts( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$filter   = isset( $args[3] ) ? $args[3] : array();\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_post_fields', array( 'post', 'terms', 'custom_fields' ), 'wp.getPosts' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPosts' );\n\n\t\t$query = array();\n\n\t\tif ( isset( $filter['post_type'] ) ) {\n\t\t\t$post_type = get_post_type_object( $filter['post_type'] );\n\t\t\tif ( ! ( (bool) $post_type ) )\n\t\t\t\treturn new IXR_Error( 403, __( 'The post type specified is not valid' ) );\n\t\t} else {\n\t\t\t$post_type = get_post_type_object( 'post' );\n\t\t}\n\n\t\tif ( ! current_user_can( $post_type->cap->edit_posts ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to edit posts in this post type' ));\n\n\t\t$query['post_type'] = $post_type->name;\n\n\t\tif ( isset( $filter['post_status'] ) )\n\t\t\t$query['post_status'] = $filter['post_status'];\n\n\t\tif ( isset( $filter['number'] ) )\n\t\t\t$query['numberposts'] = absint( $filter['number'] );\n\n\t\tif ( isset( $filter['offset'] ) )\n\t\t\t$query['offset'] = absint( $filter['offset'] );\n\n\t\tif ( isset( $filter['orderby'] ) ) {\n\t\t\t$query['orderby'] = $filter['orderby'];\n\n\t\t\tif ( isset( $filter['order'] ) )\n\t\t\t\t$query['order'] = $filter['order'];\n\t\t}\n\n\t\tif ( isset( $filter['s'] ) ) {\n\t\t\t$query['s'] = $filter['s'];\n\t\t}\n\n\t\t$posts_list = wp_get_recent_posts( $query );\n\n\t\tif ( ! $posts_list )\n\t\t\treturn array();\n\n\t\t// Holds all the posts data.\n\t\t$struct = array();\n\n\t\tforeach ( $posts_list as $post ) {\n\t\t\tif ( ! current_user_can( 'edit_post', $post['ID'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$struct[] = $this->_prepare_post( $post, $fields );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Create a new term.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_insert_term()\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id        Blog ID (unused).\n\t *     @type string $username       Username.\n\t *     @type string $password       Password.\n\t *     @type array  $content_struct Content struct for adding a new term. The struct must contain\n\t *                                  the term 'name' and 'taxonomy'. Optional accepted values include\n\t *                                  'parent', 'description', and 'slug'.\n\t * }\n\t * @return int|IXR_Error The term ID on success, or an IXR_Error object on failure.\n\t */\n\tpublic function wp_newTerm( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newTerm' );\n\n\t\tif ( ! taxonomy_exists( $content_struct['taxonomy'] ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $content_struct['taxonomy'] );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->manage_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to create terms in this taxonomy.' ) );\n\n\t\t$taxonomy = (array) $taxonomy;\n\n\t\t// hold the data of the term\n\t\t$term_data = array();\n\n\t\t$term_data['name'] = trim( $content_struct['name'] );\n\t\tif ( empty( $term_data['name'] ) )\n\t\t\treturn new IXR_Error( 403, __( 'The term name cannot be empty.' ) );\n\n\t\tif ( isset( $content_struct['parent'] ) ) {\n\t\t\tif ( ! $taxonomy['hierarchical'] )\n\t\t\t\treturn new IXR_Error( 403, __( 'This taxonomy is not hierarchical.' ) );\n\n\t\t\t$parent_term_id = (int) $content_struct['parent'];\n\t\t\t$parent_term = get_term( $parent_term_id , $taxonomy['name'] );\n\n\t\t\tif ( is_wp_error( $parent_term ) )\n\t\t\t\treturn new IXR_Error( 500, $parent_term->get_error_message() );\n\n\t\t\tif ( ! $parent_term )\n\t\t\t\treturn new IXR_Error( 403, __( 'Parent term does not exist.' ) );\n\n\t\t\t$term_data['parent'] = $content_struct['parent'];\n\t\t}\n\n\t\tif ( isset( $content_struct['description'] ) )\n\t\t\t$term_data['description'] = $content_struct['description'];\n\n\t\tif ( isset( $content_struct['slug'] ) )\n\t\t\t$term_data['slug'] = $content_struct['slug'];\n\n\t\t$term = wp_insert_term( $term_data['name'] , $taxonomy['name'] , $term_data );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 500, __( 'Sorry, your term could not be created. Something wrong happened.' ) );\n\n\t\treturn strval( $term['term_id'] );\n\t}\n\n\t/**\n\t * Edit a term.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_update_term()\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id        Blog ID (unused).\n\t *     @type string $username       Username.\n\t *     @type string $password       Password.\n\t *     @type int    $term_id        Term ID.\n\t *     @type array  $content_struct Content struct for editing a term. The struct must contain the\n\t *                                  term ''taxonomy'. Optional accepted values include 'name', 'parent',\n\t *                                  'description', and 'slug'.\n\t * }\n\t * @return true|IXR_Error True on success, IXR_Error instance on failure.\n\t */\n\tpublic function wp_editTerm( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 5 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$term_id        = (int) $args[3];\n\t\t$content_struct = $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editTerm' );\n\n\t\tif ( ! taxonomy_exists( $content_struct['taxonomy'] ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $content_struct['taxonomy'] );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->edit_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to edit terms in this taxonomy.' ) );\n\n\t\t$taxonomy = (array) $taxonomy;\n\n\t\t// hold the data of the term\n\t\t$term_data = array();\n\n\t\t$term = get_term( $term_id , $content_struct['taxonomy'] );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid term ID' ) );\n\n\t\tif ( isset( $content_struct['name'] ) ) {\n\t\t\t$term_data['name'] = trim( $content_struct['name'] );\n\n\t\t\tif ( empty( $term_data['name'] ) )\n\t\t\t\treturn new IXR_Error( 403, __( 'The term name cannot be empty.' ) );\n\t\t}\n\n\t\tif ( isset( $content_struct['parent'] ) ) {\n\t\t\tif ( ! $taxonomy['hierarchical'] )\n\t\t\t\treturn new IXR_Error( 403, __( \"This taxonomy is not hierarchical so you can't set a parent.\" ) );\n\n\t\t\t$parent_term_id = (int) $content_struct['parent'];\n\t\t\t$parent_term = get_term( $parent_term_id , $taxonomy['name'] );\n\n\t\t\tif ( is_wp_error( $parent_term ) )\n\t\t\t\treturn new IXR_Error( 500, $parent_term->get_error_message() );\n\n\t\t\tif ( ! $parent_term )\n\t\t\t\treturn new IXR_Error( 403, __( 'Parent term does not exist.' ) );\n\n\t\t\t$term_data['parent'] = $content_struct['parent'];\n\t\t}\n\n\t\tif ( isset( $content_struct['description'] ) )\n\t\t\t$term_data['description'] = $content_struct['description'];\n\n\t\tif ( isset( $content_struct['slug'] ) )\n\t\t\t$term_data['slug'] = $content_struct['slug'];\n\n\t\t$term = wp_update_term( $term_id , $taxonomy['name'] , $term_data );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 500, __( 'Sorry, editing the term failed.' ) );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Delete a term.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_delete_term()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id      Blog ID (unused).\n\t *     @type string $username     Username.\n\t *     @type string $password     Password.\n\t *     @type string $taxnomy_name Taxonomy name.\n\t *     @type int    $term_id      Term ID.\n\t * }\n\t * @return bool|IXR_Error True on success, IXR_Error instance on failure.\n\t */\n\tpublic function wp_deleteTerm( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 5 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username           = $args[1];\n\t\t$password           = $args[2];\n\t\t$taxonomy           = $args[3];\n\t\t$term_id            = (int) $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deleteTerm' );\n\n\t\tif ( ! taxonomy_exists( $taxonomy ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $taxonomy );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->delete_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to delete terms in this taxonomy.' ) );\n\n\t\t$term = get_term( $term_id, $taxonomy->name );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid term ID' ) );\n\n\t\t$result = wp_delete_term( $term_id, $taxonomy->name );\n\n\t\tif ( is_wp_error( $result ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $result )\n\t\t\treturn new IXR_Error( 500, __( 'Sorry, deleting the term failed.' ) );\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Retrieve a term.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_term()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type string $taxnomy  Taxonomy name.\n\t *     @type string $term_id  Term ID.\n\t * }\n\t * @return array|IXR_Error IXR_Error on failure, array on success, containing:\n\t *  - 'term_id'\n\t *  - 'name'\n\t *  - 'slug'\n\t *  - 'term_group'\n\t *  - 'term_taxonomy_id'\n\t *  - 'taxonomy'\n\t *  - 'description'\n\t *  - 'parent'\n\t *  - 'count'\n\t */\n\tpublic function wp_getTerm( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 5 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username           = $args[1];\n\t\t$password           = $args[2];\n\t\t$taxonomy           = $args[3];\n\t\t$term_id            = (int) $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getTerm' );\n\n\t\tif ( ! taxonomy_exists( $taxonomy ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $taxonomy );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->assign_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to assign terms in this taxonomy.' ) );\n\n\t\t$term = get_term( $term_id , $taxonomy->name, ARRAY_A );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid term ID' ) );\n\n\t\treturn $this->_prepare_term( $term );\n\t}\n\n\t/**\n\t * Retrieve all terms for a taxonomy.\n\t *\n\t * @since 3.4.0\n\t *\n\t * The optional $filter parameter modifies the query used to retrieve terms.\n\t * Accepted keys are 'number', 'offset', 'orderby', 'order', 'hide_empty', and 'search'.\n\t *\n\t * @see get_terms()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type string $taxnomy  Taxonomy name.\n\t *     @type array  $filter   Optional. Modifies the query used to retrieve posts. Accepts 'number',\n\t *                            'offset', 'orderby', 'order', 'hide_empty', and 'search'. Default empty array.\n\t * }\n\t * @return array|IXR_Error An associative array of terms data on success, IXR_Error instance otherwise.\n\t */\n\tpublic function wp_getTerms( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$taxonomy       = $args[3];\n\t\t$filter         = isset( $args[4] ) ? $args[4] : array();\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getTerms' );\n\n\t\tif ( ! taxonomy_exists( $taxonomy ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $taxonomy );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->assign_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to assign terms in this taxonomy.' ) );\n\n\t\t$query = array();\n\n\t\tif ( isset( $filter['number'] ) )\n\t\t\t$query['number'] = absint( $filter['number'] );\n\n\t\tif ( isset( $filter['offset'] ) )\n\t\t\t$query['offset'] = absint( $filter['offset'] );\n\n\t\tif ( isset( $filter['orderby'] ) ) {\n\t\t\t$query['orderby'] = $filter['orderby'];\n\n\t\t\tif ( isset( $filter['order'] ) )\n\t\t\t\t$query['order'] = $filter['order'];\n\t\t}\n\n\t\tif ( isset( $filter['hide_empty'] ) )\n\t\t\t$query['hide_empty'] = $filter['hide_empty'];\n\t\telse\n\t\t\t$query['get'] = 'all';\n\n\t\tif ( isset( $filter['search'] ) )\n\t\t\t$query['search'] = $filter['search'];\n\n\t\t$terms = get_terms( $taxonomy->name, $query );\n\n\t\tif ( is_wp_error( $terms ) )\n\t\t\treturn new IXR_Error( 500, $terms->get_error_message() );\n\n\t\t$struct = array();\n\n\t\tforeach ( $terms as $term ) {\n\t\t\t$struct[] = $this->_prepare_term( $term );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve a taxonomy.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_taxonomy()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type string $taxnomy  Taxonomy name.\n\t *     @type array  $fields   Optional. Array of taxonomy fields to limit to in the return.\n\t *                            Accepts 'labels', 'cap', 'menu', and 'object_type'.\n\t *                            Default empty array.\n\t * }\n\t * @return array|IXR_Error An array of taxonomy data on success, IXR_Error instance otherwise.\n\t */\n\tpublic function wp_getTaxonomy( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$taxonomy = $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the taxonomy query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param array  $fields An array of taxonomy fields to retrieve.\n\t\t\t * @param string $method The method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_taxonomy_fields', array( 'labels', 'cap', 'object_type' ), 'wp.getTaxonomy' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getTaxonomy' );\n\n\t\tif ( ! taxonomy_exists( $taxonomy ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $taxonomy );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->assign_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to assign terms in this taxonomy.' ) );\n\n\t\treturn $this->_prepare_taxonomy( $taxonomy, $fields );\n\t}\n\n\t/**\n\t * Retrieve all taxonomies.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_taxonomies()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type array  $filter   Optional. An array of arguments for retrieving taxonomies.\n\t *     @type array  $fields   Optional. The subset of taxonomy fields to return.\n\t * }\n\t * @return array|IXR_Error An associative array of taxonomy data with returned fields determined\n\t *                         by `$fields`, or an IXR_Error instance on failure.\n\t */\n\tpublic function wp_getTaxonomies( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$filter   = isset( $args[3] ) ? $args[3] : array( 'public' => true );\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_taxonomy_fields', array( 'labels', 'cap', 'object_type' ), 'wp.getTaxonomies' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getTaxonomies' );\n\n\t\t$taxonomies = get_taxonomies( $filter, 'objects' );\n\n\t\t// holds all the taxonomy data\n\t\t$struct = array();\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t// capability check for post_types\n\t\t\tif ( ! current_user_can( $taxonomy->cap->assign_terms ) )\n\t\t\t\tcontinue;\n\n\t\t\t$struct[] = $this->_prepare_taxonomy( $taxonomy, $fields );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve a user.\n\t *\n\t * The optional $fields parameter specifies what fields will be included\n\t * in the response array. This should be a list of field names. 'user_id' will\n\t * always be included in the response regardless of the value of $fields.\n\t *\n\t * Instead of, or in addition to, individual field names, conceptual group\n\t * names can be used to specify multiple fields. The available conceptual\n\t * groups are 'basic' and 'all'.\n\t *\n\t * @uses get_userdata()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $user_id\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error Array contains (based on $fields parameter):\n\t *  - 'user_id'\n\t *  - 'username'\n\t *  - 'first_name'\n\t *  - 'last_name'\n\t *  - 'registered'\n\t *  - 'bio'\n\t *  - 'email'\n\t *  - 'nickname'\n\t *  - 'nicename'\n\t *  - 'url'\n\t *  - 'display_name'\n\t *  - 'roles'\n\t */\n\tpublic function wp_getUser( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$user_id  = (int) $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the default user query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.5.0\n\t\t\t *\n\t\t\t * @param array  $fields User query fields for given method. Default 'all'.\n\t\t\t * @param string $method The method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_user_fields', array( 'all' ), 'wp.getUser' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getUser' );\n\n\t\tif ( ! current_user_can( 'edit_user', $user_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit users.' ) );\n\n\t\t$user_data = get_userdata( $user_id );\n\n\t\tif ( ! $user_data )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid user ID.' ) );\n\n\t\treturn $this->_prepare_user( $user_data, $fields );\n\t}\n\n\t/**\n\t * Retrieve users.\n\t *\n\t * The optional $filter parameter modifies the query used to retrieve users.\n\t * Accepted keys are 'number' (default: 50), 'offset' (default: 0), 'role',\n\t * 'who', 'orderby', and 'order'.\n\t *\n\t * The optional $fields parameter specifies what fields will be included\n\t * in the response array.\n\t *\n\t * @uses get_users()\n\t * @see wp_getUser() for more on $fields and return values\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $filter (optional)\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error users data\n\t */\n\tpublic function wp_getUsers( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$filter   = isset( $args[3] ) ? $args[3] : array();\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_user_fields', array( 'all' ), 'wp.getUsers' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getUsers' );\n\n\t\tif ( ! current_user_can( 'list_users' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot list users.' ) );\n\n\t\t$query = array( 'fields' => 'all_with_meta' );\n\n\t\t$query['number'] = ( isset( $filter['number'] ) ) ? absint( $filter['number'] ) : 50;\n\t\t$query['offset'] = ( isset( $filter['offset'] ) ) ? absint( $filter['offset'] ) : 0;\n\n\t\tif ( isset( $filter['orderby'] ) ) {\n\t\t\t$query['orderby'] = $filter['orderby'];\n\n\t\t\tif ( isset( $filter['order'] ) )\n\t\t\t\t$query['order'] = $filter['order'];\n\t\t}\n\n\t\tif ( isset( $filter['role'] ) ) {\n\t\t\tif ( get_role( $filter['role'] ) === null )\n\t\t\t\treturn new IXR_Error( 403, __( 'The role specified is not valid' ) );\n\n\t\t\t$query['role'] = $filter['role'];\n\t\t}\n\n\t\tif ( isset( $filter['who'] ) ) {\n\t\t\t$query['who'] = $filter['who'];\n\t\t}\n\n\t\t$users = get_users( $query );\n\n\t\t$_users = array();\n\t\tforeach ( $users as $user_data ) {\n\t\t\tif ( current_user_can( 'edit_user', $user_data->ID ) )\n\t\t\t\t$_users[] = $this->_prepare_user( $user_data, $fields );\n\t\t}\n\t\treturn $_users;\n\t}\n\n\t/**\n\t * Retrieve information about the requesting user.\n\t *\n\t * @uses get_userdata()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error (@see wp_getUser)\n\t */\n\tpublic function wp_getProfile( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( isset( $args[3] ) ) {\n\t\t\t$fields = $args[3];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_user_fields', array( 'all' ), 'wp.getProfile' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getProfile' );\n\n\t\tif ( ! current_user_can( 'edit_user', $user->ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit your profile.' ) );\n\n\t\t$user_data = get_userdata( $user->ID );\n\n\t\treturn $this->_prepare_user( $user_data, $fields );\n\t}\n\n\t/**\n\t * Edit user's profile.\n\t *\n\t * @uses wp_update_user()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $content_struct It can optionally contain:\n\t *      - 'first_name'\n\t *      - 'last_name'\n\t *      - 'website'\n\t *      - 'display_name'\n\t *      - 'nickname'\n\t *      - 'nicename'\n\t *      - 'bio'\n\t * }\n\t * @return true|IXR_Error True, on success.\n\t */\n\tpublic function wp_editProfile( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editProfile' );\n\n\t\tif ( ! current_user_can( 'edit_user', $user->ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit your profile.' ) );\n\n\t\t// holds data of the user\n\t\t$user_data = array();\n\t\t$user_data['ID'] = $user->ID;\n\n\t\t// only set the user details if it was given\n\t\tif ( isset( $content_struct['first_name'] ) )\n\t\t\t$user_data['first_name'] = $content_struct['first_name'];\n\n\t\tif ( isset( $content_struct['last_name'] ) )\n\t\t\t$user_data['last_name'] = $content_struct['last_name'];\n\n\t\tif ( isset( $content_struct['url'] ) )\n\t\t\t$user_data['user_url'] = $content_struct['url'];\n\n\t\tif ( isset( $content_struct['display_name'] ) )\n\t\t\t$user_data['display_name'] = $content_struct['display_name'];\n\n\t\tif ( isset( $content_struct['nickname'] ) )\n\t\t\t$user_data['nickname'] = $content_struct['nickname'];\n\n\t\tif ( isset( $content_struct['nicename'] ) )\n\t\t\t$user_data['user_nicename'] = $content_struct['nicename'];\n\n\t\tif ( isset( $content_struct['bio'] ) )\n\t\t\t$user_data['description'] = $content_struct['bio'];\n\n\t\t$result = wp_update_user( $user_data );\n\n\t\tif ( is_wp_error( $result ) )\n\t\t\treturn new IXR_Error( 500, $result->get_error_message() );\n\n\t\tif ( ! $result )\n\t\t\treturn new IXR_Error( 500, __( 'Sorry, the user cannot be updated.' ) );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieve page.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $page_id\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPage( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$page_id  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) ) {\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t$page = get_post($page_id);\n\t\tif ( ! $page )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_page', $page_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this page.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPage' );\n\n\t\t// If we found the page then format the data.\n\t\tif ( $page->ID && ($page->post_type == 'page') ) {\n\t\t\treturn $this->_prepare_page( $page );\n\t\t}\n\t\t// If the page doesn't exist indicate that.\n\t\telse {\n\t\t\treturn new IXR_Error( 404, __( 'Sorry, no such page.' ) );\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve Pages.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $num_pages\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPages( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username  = $args[1];\n\t\t$password  = $args[2];\n\t\t$num_pages = isset($args[3]) ? (int) $args[3] : 10;\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_pages' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit pages.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPages' );\n\n\t\t$pages = get_posts( array('post_type' => 'page', 'post_status' => 'any', 'numberposts' => $num_pages) );\n\t\t$num_pages = count($pages);\n\n\t\t// If we have pages, put together their info.\n\t\tif ( $num_pages >= 1 ) {\n\t\t\t$pages_struct = array();\n\n\t\t\tforeach ($pages as $page) {\n\t\t\t\tif ( current_user_can( 'edit_page', $page->ID ) )\n\t\t\t\t\t$pages_struct[] = $this->_prepare_page( $page );\n\t\t\t}\n\n\t\t\treturn $pages_struct;\n\t\t}\n\n\t\treturn array();\n\t}\n\n\t/**\n\t * Create new page.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @see wp_xmlrpc_server::mw_newPost()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $content_struct\n\t * }\n\t * @return int|IXR_Error\n\t */\n\tpublic function wp_newPage( $args ) {\n\t\t// Items not escaped here will be escaped in newPost.\n\t\t$username = $this->escape( $args[1] );\n\t\t$password = $this->escape( $args[2] );\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newPage' );\n\n\t\t// Mark this as content for a page.\n\t\t$args[3][\"post_type\"] = 'page';\n\n\t\t// Let mw_newPost do all of the heavy lifting.\n\t\treturn $this->mw_newPost( $args );\n\t}\n\n\t/**\n\t * Delete page.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $page_id\n\t * }\n\t * @return true|IXR_Error True, if success.\n\t */\n\tpublic function wp_deletePage( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$page_id  = (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deletePage' );\n\n\t\t// Get the current page based on the page_id and\n\t\t// make sure it is a page and not a post.\n\t\t$actual_page = get_post($page_id, ARRAY_A);\n\t\tif ( !$actual_page || ($actual_page['post_type'] != 'page') )\n\t\t\treturn new IXR_Error( 404, __( 'Sorry, no such page.' ) );\n\n\t\t// Make sure the user can delete pages.\n\t\tif ( !current_user_can('delete_page', $page_id) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to delete this page.' ) );\n\n\t\t// Attempt to delete the page.\n\t\t$result = wp_delete_post($page_id);\n\t\tif ( !$result )\n\t\t\treturn new IXR_Error( 500, __( 'Failed to delete the page.' ) );\n\n\t\t/**\n\t\t * Fires after a page has been successfully deleted via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $page_id ID of the deleted page.\n\t\t * @param array $args    An array of arguments to delete the page.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_wp_deletePage', $page_id, $args );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Edit page.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $page_id\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type string $content\n\t *     @type string $publish\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_editPage( $args ) {\n\t\t// Items will be escaped in mw_editPost.\n\t\t$page_id  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\t\t$content  = $args[4];\n\t\t$publish  = $args[5];\n\n\t\t$escaped_username = $this->escape( $username );\n\t\t$escaped_password = $this->escape( $password );\n\n\t\tif ( !$user = $this->login( $escaped_username, $escaped_password ) ) {\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editPage' );\n\n\t\t// Get the page data and make sure it is a page.\n\t\t$actual_page = get_post($page_id, ARRAY_A);\n\t\tif ( !$actual_page || ($actual_page['post_type'] != 'page') )\n\t\t\treturn new IXR_Error( 404, __( 'Sorry, no such page.' ) );\n\n\t\t// Make sure the user is allowed to edit pages.\n\t\tif ( !current_user_can('edit_page', $page_id) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to edit this page.' ) );\n\n\t\t// Mark this as content for a page.\n\t\t$content['post_type'] = 'page';\n\n\t\t// Arrange args in the way mw_editPost understands.\n\t\t$args = array(\n\t\t\t$page_id,\n\t\t\t$username,\n\t\t\t$password,\n\t\t\t$content,\n\t\t\t$publish\n\t\t);\n\n\t\t// Let mw_editPost do all of the heavy lifting.\n\t\treturn $this->mw_editPost( $args );\n\t}\n\n\t/**\n\t * Retrieve page list.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPageList( $args ) {\n\t\tglobal $wpdb;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_pages' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit pages.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPageList' );\n\n\t\t// Get list of pages ids and titles\n\t\t$page_list = $wpdb->get_results(\"\n\t\t\tSELECT ID page_id,\n\t\t\t\tpost_title page_title,\n\t\t\t\tpost_parent page_parent_id,\n\t\t\t\tpost_date_gmt,\n\t\t\t\tpost_date,\n\t\t\t\tpost_status\n\t\t\tFROM {$wpdb->posts}\n\t\t\tWHERE post_type = 'page'\n\t\t\tORDER BY ID\n\t\t\");\n\n\t\t// The date needs to be formatted properly.\n\t\t$num_pages = count($page_list);\n\t\tfor ( $i = 0; $i < $num_pages; $i++ ) {\n\t\t\t$page_list[$i]->dateCreated = $this->_convert_date(  $page_list[$i]->post_date );\n\t\t\t$page_list[$i]->date_created_gmt = $this->_convert_date_gmt( $page_list[$i]->post_date_gmt, $page_list[$i]->post_date );\n\n\t\t\tunset($page_list[$i]->post_date_gmt);\n\t\t\tunset($page_list[$i]->post_date);\n\t\t\tunset($page_list[$i]->post_status);\n\t\t}\n\n\t\treturn $page_list;\n\t}\n\n\t/**\n\t * Retrieve authors list.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getAuthors( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can('edit_posts') )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit posts on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getAuthors' );\n\n\t\t$authors = array();\n\t\tforeach ( get_users( array( 'fields' => array('ID','user_login','display_name') ) ) as $user ) {\n\t\t\t$authors[] = array(\n\t\t\t\t'user_id'       => $user->ID,\n\t\t\t\t'user_login'    => $user->user_login,\n\t\t\t\t'display_name'  => $user->display_name\n\t\t\t);\n\t\t}\n\n\t\treturn $authors;\n\t}\n\n\t/**\n\t * Get list of all tags\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getTags( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view tags.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getKeywords' );\n\n\t\t$tags = array();\n\n\t\tif ( $all_tags = get_tags() ) {\n\t\t\tforeach( (array) $all_tags as $tag ) {\n\t\t\t\t$struct = array();\n\t\t\t\t$struct['tag_id']\t\t\t= $tag->term_id;\n\t\t\t\t$struct['name']\t\t\t\t= $tag->name;\n\t\t\t\t$struct['count']\t\t\t= $tag->count;\n\t\t\t\t$struct['slug']\t\t\t\t= $tag->slug;\n\t\t\t\t$struct['html_url']\t\t\t= esc_html( get_tag_link( $tag->term_id ) );\n\t\t\t\t$struct['rss_url']\t\t\t= esc_html( get_tag_feed_link( $tag->term_id ) );\n\n\t\t\t\t$tags[] = $struct;\n\t\t\t}\n\t\t}\n\n\t\treturn $tags;\n\t}\n\n\t/**\n\t * Create new category.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $category\n\t * }\n\t * @return int|IXR_Error Category ID.\n\t */\n\tpublic function wp_newCategory( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$category = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newCategory' );\n\n\t\t// Make sure the user is allowed to add a category.\n\t\tif ( !current_user_can('manage_categories') )\n\t\t\treturn new IXR_Error(401, __('Sorry, you do not have the right to add a category.'));\n\n\t\t// If no slug was provided make it empty so that\n\t\t// WordPress will generate one.\n\t\tif ( empty($category['slug']) )\n\t\t\t$category['slug'] = '';\n\n\t\t// If no parent_id was provided make it empty\n\t\t// so that it will be a top level page (no parent).\n\t\tif ( !isset($category['parent_id']) )\n\t\t\t$category['parent_id'] = '';\n\n\t\t// If no description was provided make it empty.\n\t\tif ( empty($category[\"description\"]) )\n\t\t\t$category[\"description\"] = \"\";\n\n\t\t$new_category = array(\n\t\t\t'cat_name'\t\t\t\t=> $category['name'],\n\t\t\t'category_nicename'\t\t=> $category['slug'],\n\t\t\t'category_parent'\t\t=> $category['parent_id'],\n\t\t\t'category_description'\t=> $category['description']\n\t\t);\n\n\t\t$cat_id = wp_insert_category($new_category, true);\n\t\tif ( is_wp_error( $cat_id ) ) {\n\t\t\tif ( 'term_exists' == $cat_id->get_error_code() )\n\t\t\t\treturn (int) $cat_id->get_error_data();\n\t\t\telse\n\t\t\t\treturn new IXR_Error(500, __('Sorry, the new category failed.'));\n\t\t} elseif ( ! $cat_id ) {\n\t\t\treturn new IXR_Error(500, __('Sorry, the new category failed.'));\n\t\t}\n\n\t\t/**\n\t\t * Fires after a new category has been successfully created via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $cat_id ID of the new category.\n\t\t * @param array $args   An array of new category arguments.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_wp_newCategory', $cat_id, $args );\n\n\t\treturn $cat_id;\n\t}\n\n\t/**\n\t * Remove category.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $category_id\n\t * }\n\t * @return bool|IXR_Error See {@link wp_delete_term()} for return info.\n\t */\n\tpublic function wp_deleteCategory( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username    = $args[1];\n\t\t$password    = $args[2];\n\t\t$category_id = (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deleteCategory' );\n\n\t\tif ( !current_user_can('manage_categories') )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to delete a category.' ) );\n\n\t\t$status = wp_delete_term( $category_id, 'category' );\n\n\t\tif ( true == $status ) {\n\t\t\t/**\n\t\t\t * Fires after a category has been successfully deleted via XML-RPC.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param int   $category_id ID of the deleted category.\n\t\t\t * @param array $args        An array of arguments to delete the category.\n\t\t\t */\n\t\t\tdo_action( 'xmlrpc_call_success_wp_deleteCategory', $category_id, $args );\n\t\t}\n\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Retrieve category list.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $category\n\t *     @type int    $max_results\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_suggestCategories( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username    = $args[1];\n\t\t$password    = $args[2];\n\t\t$category    = $args[3];\n\t\t$max_results = (int) $args[4];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view categories.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.suggestCategories' );\n\n\t\t$category_suggestions = array();\n\t\t$args = array('get' => 'all', 'number' => $max_results, 'name__like' => $category);\n\t\tforeach ( (array) get_categories($args) as $cat ) {\n\t\t\t$category_suggestions[] = array(\n\t\t\t\t'category_id'\t=> $cat->term_id,\n\t\t\t\t'category_name'\t=> $cat->name\n\t\t\t);\n\t\t}\n\n\t\treturn $category_suggestions;\n\t}\n\n\t/**\n\t * Retrieve comment.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $comment_id\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getComment($args) {\n\t\t$this->escape($args);\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$comment_id\t= (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getComment' );\n\n\t\tif ( ! $comment = get_comment($comment_id) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid comment ID.' ) );\n\n\t\treturn $this->_prepare_comment( $comment );\n\t}\n\n\t/**\n\t * Retrieve comments.\n\t *\n\t * Besides the common blog_id (unused), username, and password arguments, it takes a filter\n\t * array as last argument.\n\t *\n\t * Accepted 'filter' keys are 'status', 'post_id', 'offset', and 'number'.\n\t *\n\t * The defaults are as follows:\n\t * - 'status' - Default is ''. Filter by status (e.g., 'approve', 'hold')\n\t * - 'post_id' - Default is ''. The post where the comment is posted. Empty string shows all comments.\n\t * - 'number' - Default is 10. Total number of media items to retrieve.\n\t * - 'offset' - Default is 0. See {@link WP_Query::query()} for more.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $struct\n\t * }\n\t * @return array|IXR_Error Contains a collection of comments. See {@link wp_xmlrpc_server::wp_getComment()} for a description of each item contents\n\t */\n\tpublic function wp_getComments( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$struct\t  = isset( $args[3] ) ? $args[3] : array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit comments.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getComments' );\n\n\t\tif ( isset($struct['status']) )\n\t\t\t$status = $struct['status'];\n\t\telse\n\t\t\t$status = '';\n\n\t\t$post_id = '';\n\t\tif ( isset($struct['post_id']) )\n\t\t\t$post_id = absint($struct['post_id']);\n\n\t\t$offset = 0;\n\t\tif ( isset($struct['offset']) )\n\t\t\t$offset = absint($struct['offset']);\n\n\t\t$number = 10;\n\t\tif ( isset($struct['number']) )\n\t\t\t$number = absint($struct['number']);\n\n\t\t$comments = get_comments( array( 'status' => $status, 'post_id' => $post_id, 'offset' => $offset, 'number' => $number ) );\n\n\t\t$comments_struct = array();\n\t\tif ( is_array( $comments ) ) {\n\t\t\tforeach ( $comments as $comment ) {\n\t\t\t\t$comments_struct[] = $this->_prepare_comment( $comment );\n\t\t\t}\n\t\t}\n\n\t\treturn $comments_struct;\n\t}\n\n\t/**\n\t * Delete a comment.\n\t *\n\t * By default, the comment will be moved to the trash instead of deleted.\n\t * See {@link wp_delete_comment()} for more information on\n\t * this behavior.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $comment_ID\n\t * }\n\t * @return bool|IXR_Error {@link wp_delete_comment()}\n\t */\n\tpublic function wp_deleteComment($args) {\n\t\t$this->escape($args);\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$comment_ID\t= (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\tif ( ! get_comment($comment_ID) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid comment ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_comment', $comment_ID ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deleteComment' );\n\n\t\t$status = wp_delete_comment( $comment_ID );\n\n\t\tif ( $status ) {\n\t\t\t/**\n\t\t\t * Fires after a comment has been successfully deleted via XML-RPC.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param int   $comment_ID ID of the deleted comment.\n\t\t\t * @param array $args       An array of arguments to delete the comment.\n\t\t\t */\n\t\t\tdo_action( 'xmlrpc_call_success_wp_deleteComment', $comment_ID, $args );\n\t\t}\n\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Edit comment.\n\t *\n\t * Besides the common blog_id (unused), username, and password arguments, it takes a\n\t * comment_id integer and a content_struct array as last argument.\n\t *\n\t * The allowed keys in the content_struct array are:\n\t *  - 'author'\n\t *  - 'author_url'\n\t *  - 'author_email'\n\t *  - 'content'\n\t *  - 'date_created_gmt'\n\t *  - 'status'. Common statuses are 'approve', 'hold', 'spam'. See get_comment_statuses() for more details\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $comment_ID\n\t *     @type array  $content_struct\n\t * }\n\t * @return true|IXR_Error True, on success.\n\t */\n\tpublic function wp_editComment( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$comment_ID\t= (int) $args[3];\n\t\t$content_struct = $args[4];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\tif ( ! get_comment($comment_ID) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid comment ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_comment', $comment_ID ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editComment' );\n\n\t\tif ( isset($content_struct['status']) ) {\n\t\t\t$statuses = get_comment_statuses();\n\t\t\t$statuses = array_keys($statuses);\n\n\t\t\tif ( ! in_array($content_struct['status'], $statuses) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Invalid comment status.' ) );\n\t\t\t$comment_approved = $content_struct['status'];\n\t\t}\n\n\t\t// Do some timestamp voodoo\n\t\tif ( !empty( $content_struct['date_created_gmt'] ) ) {\n\t\t\t// We know this is supposed to be GMT, so we're going to slap that Z on there by force\n\t\t\t$dateCreated = rtrim( $content_struct['date_created_gmt']->getIso(), 'Z' ) . 'Z';\n\t\t\t$comment_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));\n\t\t\t$comment_date_gmt = iso8601_to_datetime($dateCreated, 'GMT');\n\t\t}\n\n\t\tif ( isset($content_struct['content']) )\n\t\t\t$comment_content = $content_struct['content'];\n\n\t\tif ( isset($content_struct['author']) )\n\t\t\t$comment_author = $content_struct['author'];\n\n\t\tif ( isset($content_struct['author_url']) )\n\t\t\t$comment_author_url = $content_struct['author_url'];\n\n\t\tif ( isset($content_struct['author_email']) )\n\t\t\t$comment_author_email = $content_struct['author_email'];\n\n\t\t// We've got all the data -- post it:\n\t\t$comment = compact('comment_ID', 'comment_content', 'comment_approved', 'comment_date', 'comment_date_gmt', 'comment_author', 'comment_author_email', 'comment_author_url');\n\n\t\t$result = wp_update_comment($comment);\n\t\tif ( is_wp_error( $result ) )\n\t\t\treturn new IXR_Error(500, $result->get_error_message());\n\n\t\tif ( !$result )\n\t\t\treturn new IXR_Error(500, __('Sorry, the comment could not be edited. Something wrong happened.'));\n\n\t\t/**\n\t\t * Fires after a comment has been successfully updated via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $comment_ID ID of the updated comment.\n\t\t * @param array $args       An array of arguments to update the comment.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_wp_editComment', $comment_ID, $args );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Create new comment.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int        $blog_id (unused)\n\t *     @type string     $username\n\t *     @type string     $password\n\t *     @type string|int $post\n\t *     @type array      $content_struct\n\t * }\n\t * @return int|IXR_Error {@link wp_new_comment()}\n\t */\n\tpublic function wp_newComment($args) {\n\t\t$this->escape($args);\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$post           = $args[3];\n\t\t$content_struct = $args[4];\n\n\t\t/**\n\t\t * Filter whether to allow anonymous comments over XML-RPC.\n\t\t *\n\t\t * @since 2.7.0\n\t\t *\n\t\t * @param bool $allow Whether to allow anonymous commenting via XML-RPC.\n\t\t *                    Default false.\n\t\t */\n\t\t$allow_anon = apply_filters( 'xmlrpc_allow_anonymous_comments', false );\n\n\t\t$user = $this->login($username, $password);\n\n\t\tif ( !$user ) {\n\t\t\t$logged_in = false;\n\t\t\tif ( $allow_anon && get_option('comment_registration') ) {\n\t\t\t\treturn new IXR_Error( 403, __( 'You must be registered to comment' ) );\n\t\t\t} elseif ( ! $allow_anon ) {\n\t\t\t\treturn $this->error;\n\t\t\t}\n\t\t} else {\n\t\t\t$logged_in = true;\n\t\t}\n\n\t\tif ( is_numeric($post) )\n\t\t\t$post_id = absint($post);\n\t\telse\n\t\t\t$post_id = url_to_postid($post);\n\n\t\tif ( ! $post_id )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! get_post($post_id) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\t$comment = array();\n\t\t$comment['comment_post_ID'] = $post_id;\n\n\t\tif ( $logged_in ) {\n\t\t\t$comment['comment_author'] = $this->escape( $user->display_name );\n\t\t\t$comment['comment_author_email'] = $this->escape( $user->user_email );\n\t\t\t$comment['comment_author_url'] = $this->escape( $user->user_url );\n\t\t\t$comment['user_ID'] = $user->ID;\n\t\t} else {\n\t\t\t$comment['comment_author'] = '';\n\t\t\tif ( isset($content_struct['author']) )\n\t\t\t\t$comment['comment_author'] = $content_struct['author'];\n\n\t\t\t$comment['comment_author_email'] = '';\n\t\t\tif ( isset($content_struct['author_email']) )\n\t\t\t\t$comment['comment_author_email'] = $content_struct['author_email'];\n\n\t\t\t$comment['comment_author_url'] = '';\n\t\t\tif ( isset($content_struct['author_url']) )\n\t\t\t\t$comment['comment_author_url'] = $content_struct['author_url'];\n\n\t\t\t$comment['user_ID'] = 0;\n\n\t\t\tif ( get_option('require_name_email') ) {\n\t\t\t\tif ( 6 > strlen($comment['comment_author_email']) || '' == $comment['comment_author'] )\n\t\t\t\t\treturn new IXR_Error( 403, __( 'Comment author name and email are required' ) );\n\t\t\t\telseif ( !is_email($comment['comment_author_email']) )\n\t\t\t\t\treturn new IXR_Error( 403, __( 'A valid email address is required' ) );\n\t\t\t}\n\t\t}\n\n\t\t$comment['comment_parent'] = isset($content_struct['comment_parent']) ? absint($content_struct['comment_parent']) : 0;\n\n\t\t$comment['comment_content'] =  isset($content_struct['content']) ? $content_struct['content'] : null;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newComment' );\n\n\t\t$comment_ID = wp_new_comment( $comment );\n\n\t\t/**\n\t\t * Fires after a new comment has been successfully created via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $comment_ID ID of the new comment.\n\t\t * @param array $args       An array of new comment arguments.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_wp_newComment', $comment_ID, $args );\n\n\t\treturn $comment_ID;\n\t}\n\n\t/**\n\t * Retrieve all of the comment status.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getCommentStatusList($args) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getCommentStatusList' );\n\n\t\treturn get_comment_statuses();\n\t}\n\n\t/**\n\t * Retrieve comment count.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $post_id\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getCommentCount( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$post_id\t= (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about comments.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getCommentCount' );\n\n\t\t$count = wp_count_comments( $post_id );\n\t\treturn array(\n\t\t\t'approved' => $count->approved,\n\t\t\t'awaiting_moderation' => $count->moderated,\n\t\t\t'spam' => $count->spam,\n\t\t\t'total_comments' => $count->total_comments\n\t\t);\n\t}\n\n\t/**\n\t * Retrieve post statuses.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPostStatusList( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPostStatusList' );\n\n\t\treturn get_post_statuses();\n\t}\n\n\t/**\n\t * Retrieve page statuses.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPageStatusList( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_pages' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPageStatusList' );\n\n\t\treturn get_page_statuses();\n\t}\n\n\t/**\n\t * Retrieve page templates.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPageTemplates( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_pages' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t$templates = get_page_templates();\n\t\t$templates['Default'] = 'default';\n\n\t\treturn $templates;\n\t}\n\n\t/**\n\t * Retrieve blog options.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $options\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getOptions( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$options\t= isset( $args[3] ) ? (array) $args[3] : array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t// If no specific options where asked for, return all of them\n\t\tif ( count( $options ) == 0 )\n\t\t\t$options = array_keys($this->blog_options);\n\n\t\treturn $this->_getOptions($options);\n\t}\n\n\t/**\n\t * Retrieve blog options value from list.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array $options Options to retrieve.\n\t * @return array\n\t */\n\tpublic function _getOptions($options) {\n\t\t$data = array();\n\t\t$can_manage = current_user_can( 'manage_options' );\n\t\tforeach ( $options as $option ) {\n\t\t\tif ( array_key_exists( $option, $this->blog_options ) ) {\n\t\t\t\t$data[$option] = $this->blog_options[$option];\n\t\t\t\t//Is the value static or dynamic?\n\t\t\t\tif ( isset( $data[$option]['option'] ) ) {\n\t\t\t\t\t$data[$option]['value'] = get_option( $data[$option]['option'] );\n\t\t\t\t\tunset($data[$option]['option']);\n\t\t\t\t}\n\n\t\t\t\tif ( ! $can_manage )\n\t\t\t\t\t$data[$option]['readonly'] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Update blog options.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $options\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_setOptions( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$options\t= (array) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'manage_options' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to update options.' ) );\n\n\t\t$option_names = array();\n\t\tforeach ( $options as $o_name => $o_value ) {\n\t\t\t$option_names[] = $o_name;\n\t\t\tif ( !array_key_exists( $o_name, $this->blog_options ) )\n\t\t\t\tcontinue;\n\n\t\t\tif ( $this->blog_options[$o_name]['readonly'] == true )\n\t\t\t\tcontinue;\n\n\t\t\tupdate_option( $this->blog_options[$o_name]['option'], wp_unslash( $o_value ) );\n\t\t}\n\n\t\t//Now return the updated values\n\t\treturn $this->_getOptions($option_names);\n\t}\n\n\t/**\n\t * Retrieve a media item by ID\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $attachment_id\n\t * }\n\t * @return array|IXR_Error Associative array contains:\n\t *  - 'date_created_gmt'\n\t *  - 'parent'\n\t *  - 'link'\n\t *  - 'thumbnail'\n\t *  - 'title'\n\t *  - 'caption'\n\t *  - 'description'\n\t *  - 'metadata'\n\t */\n\tpublic function wp_getMediaItem( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t\t= $args[1];\n\t\t$password\t\t= $args[2];\n\t\t$attachment_id\t= (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'upload_files' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You do not have permission to upload files.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getMediaItem' );\n\n\t\tif ( ! $attachment = get_post($attachment_id) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid attachment ID.' ) );\n\n\t\treturn $this->_prepare_media_item( $attachment );\n\t}\n\n\t/**\n\t * Retrieves a collection of media library items (or attachments)\n\t *\n\t * Besides the common blog_id (unused), username, and password arguments, it takes a filter\n\t * array as last argument.\n\t *\n\t * Accepted 'filter' keys are 'parent_id', 'mime_type', 'offset', and 'number'.\n\t *\n\t * The defaults are as follows:\n\t * - 'number' - Default is 5. Total number of media items to retrieve.\n\t * - 'offset' - Default is 0. See WP_Query::query() for more.\n\t * - 'parent_id' - Default is ''. The post where the media item is attached. Empty string shows all media items. 0 shows unattached media items.\n\t * - 'mime_type' - Default is ''. Filter by mime type (e.g., 'image/jpeg', 'application/pdf')\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $struct\n\t * }\n\t * @return array|IXR_Error Contains a collection of media items. See wp_xmlrpc_server::wp_getMediaItem() for a description of each item contents\n\t */\n\tpublic function wp_getMediaLibrary($args) {\n\t\t$this->escape($args);\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$struct\t\t= isset( $args[3] ) ? $args[3] : array() ;\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'upload_files' ) )\n\t\t\treturn new IXR_Error( 401, __( 'You do not have permission to upload files.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getMediaLibrary' );\n\n\t\t$parent_id = ( isset($struct['parent_id']) ) ? absint($struct['parent_id']) : '' ;\n\t\t$mime_type = ( isset($struct['mime_type']) ) ? $struct['mime_type'] : '' ;\n\t\t$offset = ( isset($struct['offset']) ) ? absint($struct['offset']) : 0 ;\n\t\t$number = ( isset($struct['number']) ) ? absint($struct['number']) : -1 ;\n\n\t\t$attachments = get_posts( array('post_type' => 'attachment', 'post_parent' => $parent_id, 'offset' => $offset, 'numberposts' => $number, 'post_mime_type' => $mime_type ) );\n\n\t\t$attachments_struct = array();\n\n\t\tforeach ($attachments as $attachment )\n\t\t\t$attachments_struct[] = $this->_prepare_media_item( $attachment );\n\n\t\treturn $attachments_struct;\n\t}\n\n\t/**\n\t * Retrieves a list of post formats used by the site.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error List of post formats, otherwise IXR_Error object.\n\t */\n\tpublic function wp_getPostFormats( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPostFormats' );\n\n\t\t$formats = get_post_format_strings();\n\n\t\t// find out if they want a list of currently supports formats\n\t\tif ( isset( $args[3] ) && is_array( $args[3] ) ) {\n\t\t\tif ( $args[3]['show-supported'] ) {\n\t\t\t\tif ( current_theme_supports( 'post-formats' ) ) {\n\t\t\t\t\t$supported = get_theme_support( 'post-formats' );\n\n\t\t\t\t\t$data = array();\n\t\t\t\t\t$data['all'] = $formats;\n\t\t\t\t\t$data['supported'] = $supported[0];\n\n\t\t\t\t\t$formats = $data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $formats;\n\t}\n\n\t/**\n\t * Retrieves a post type\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_post_type_object()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type string $post_type_name\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error Array contains:\n\t *  - 'labels'\n\t *  - 'description'\n\t *  - 'capability_type'\n\t *  - 'cap'\n\t *  - 'map_meta_cap'\n\t *  - 'hierarchical'\n\t *  - 'menu_position'\n\t *  - 'taxonomies'\n\t *  - 'supports'\n\t */\n\tpublic function wp_getPostType( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$post_type_name = $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the default query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param array  $fields An array of post type query fields for the given method.\n\t\t\t * @param string $method The method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_posttype_fields', array( 'labels', 'cap', 'taxonomies' ), 'wp.getPostType' );\n\t\t}\n\n\t\tif ( !$user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPostType' );\n\n\t\tif ( ! post_type_exists( $post_type_name ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid post type' ) );\n\n\t\t$post_type = get_post_type_object( $post_type_name );\n\n\t\tif ( ! current_user_can( $post_type->cap->edit_posts ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to edit this post type.' ) );\n\n\t\treturn $this->_prepare_post_type( $post_type, $fields );\n\t}\n\n\t/**\n\t * Retrieves a post types\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_post_types()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $filter (optional)\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPostTypes( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$filter   = isset( $args[3] ) ? $args[3] : array( 'public' => true );\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_posttype_fields', array( 'labels', 'cap', 'taxonomies' ), 'wp.getPostTypes' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPostTypes' );\n\n\t\t$post_types = get_post_types( $filter, 'objects' );\n\n\t\t$struct = array();\n\n\t\tforeach( $post_types as $post_type ) {\n\t\t\tif ( ! current_user_can( $post_type->cap->edit_posts ) )\n\t\t\t\tcontinue;\n\n\t\t\t$struct[$post_type->name] = $this->_prepare_post_type( $post_type, $fields );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve revisions for a specific post.\n\t *\n\t * @since 3.5.0\n\t *\n\t * The optional $fields parameter specifies what fields will be included\n\t * in the response array.\n\t *\n\t * @uses wp_get_post_revisions()\n\t * @see wp_getPost() for more on $fields\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $post_id\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error contains a collection of posts.\n\t */\n\tpublic function wp_getRevisions( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$post_id  = (int) $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the default revision query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.5.0\n\t\t\t *\n\t\t\t * @param array  $field  An array of revision query fields.\n\t\t\t * @param string $method The method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_revision_fields', array( 'post_date', 'post_date_gmt' ), 'wp.getRevisions' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getRevisions' );\n\n\t\tif ( ! $post = get_post( $post_id ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'edit_post', $post_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to edit posts.' ) );\n\n\t\t// Check if revisions are enabled.\n\t\tif ( ! wp_revisions_enabled( $post ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, revisions are disabled.' ) );\n\n\t\t$revisions = wp_get_post_revisions( $post_id );\n\n\t\tif ( ! $revisions )\n\t\t\treturn array();\n\n\t\t$struct = array();\n\n\t\tforeach ( $revisions as $revision ) {\n\t\t\tif ( ! current_user_can( 'read_post', $revision->ID ) )\n\t\t\t\tcontinue;\n\n\t\t\t// Skip autosaves\n\t\t\tif ( wp_is_post_autosave( $revision ) )\n\t\t\t\tcontinue;\n\n\t\t\t$struct[] = $this->_prepare_post( get_object_vars( $revision ), $fields );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Restore a post revision\n\t *\n\t * @since 3.5.0\n\t *\n\t * @uses wp_restore_post_revision()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $revision_id\n\t * }\n\t * @return bool|IXR_Error false if there was an error restoring, true if success.\n\t */\n\tpublic function wp_restoreRevision( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username    = $args[1];\n\t\t$password    = $args[2];\n\t\t$revision_id = (int) $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.restoreRevision' );\n\n\t\tif ( ! $revision = wp_get_post_revision( $revision_id ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( wp_is_post_autosave( $revision ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! $post = get_post( $revision->post_parent ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'edit_post', $revision->post_parent ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\n\t\t// Check if revisions are disabled.\n\t\tif ( ! wp_revisions_enabled( $post ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, revisions are disabled.' ) );\n\n\t\t$post = wp_restore_post_revision( $revision_id );\n\n\t\treturn (bool) $post;\n\t}\n\n\t/* Blogger API functions.\n\t * specs on http://plant.blogger.com/api and http://groups.yahoo.com/group/bloggerDev/\n\t */\n\n\t/**\n\t * Retrieve blogs that user owns.\n\t *\n\t * Will make more sense once we support multiple blogs.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function blogger_getUsersBlogs($args) {\n\t\tif ( is_multisite() )\n\t\t\treturn $this->_multisite_getUsersBlogs($args);\n\n\t\t$this->escape($args);\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.getUsersBlogs' );\n\n\t\t$is_admin = current_user_can('manage_options');\n\n\t\t$struct = array(\n\t\t\t'isAdmin'  => $is_admin,\n\t\t\t'url'      => get_option('home') . '/',\n\t\t\t'blogid'   => '1',\n\t\t\t'blogName' => get_option('blogname'),\n\t\t\t'xmlrpc'   => site_url( 'xmlrpc.php', 'rpc' ),\n\t\t);\n\n\t\treturn array($struct);\n\t}\n\n\t/**\n\t * Private function for retrieving a users blogs for multisite setups\n\t *\n\t * @access protected\n\t *\n\t * @return array|IXR_Error\n\t */\n\tprotected function _multisite_getUsersBlogs($args) {\n\t\t$current_blog = get_blog_details();\n\n\t\t$domain = $current_blog->domain;\n\t\t$path = $current_blog->path . 'xmlrpc.php';\n\n\t\t$rpc = new IXR_Client( set_url_scheme( \"http://{$domain}{$path}\" ) );\n\t\t$rpc->query('wp.getUsersBlogs', $args[1], $args[2]);\n\t\t$blogs = $rpc->getResponse();\n\n\t\tif ( isset($blogs['faultCode']) )\n\t\t\treturn new IXR_Error($blogs['faultCode'], $blogs['faultString']);\n\n\t\tif ( $_SERVER['HTTP_HOST'] == $domain && $_SERVER['REQUEST_URI'] == $path ) {\n\t\t\treturn $blogs;\n\t\t} else {\n\t\t\tforeach ( (array) $blogs as $blog ) {\n\t\t\t\tif ( strpos($blog['url'], $_SERVER['HTTP_HOST']) )\n\t\t\t\t\treturn array($blog);\n\t\t\t}\n\t\t\treturn array();\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve user's data.\n\t *\n\t * Gives your client some info about you, so you don't have to.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function blogger_getUserInfo( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have access to user data on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.getUserInfo' );\n\n\t\t$struct = array(\n\t\t\t'nickname'  => $user->nickname,\n\t\t\t'userid'    => $user->ID,\n\t\t\t'url'       => $user->user_url,\n\t\t\t'lastname'  => $user->last_name,\n\t\t\t'firstname' => $user->first_name\n\t\t);\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function blogger_getPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t$post_data = get_post($post_ID, ARRAY_A);\n\t\tif ( ! $post_data )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_post', $post_ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.getPost' );\n\n\t\t$categories = implode(',', wp_get_post_categories($post_ID));\n\n\t\t$content  = '<title>'.wp_unslash($post_data['post_title']).'</title>';\n\t\t$content .= '<category>'.$categories.'</category>';\n\t\t$content .= wp_unslash($post_data['post_content']);\n\n\t\t$struct = array(\n\t\t\t'userid'    => $post_data['post_author'],\n\t\t\t'dateCreated' => $this->_convert_date( $post_data['post_date'] ),\n\t\t\t'content'     => $content,\n\t\t\t'postid'  => (string) $post_data['ID']\n\t\t);\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve list of recent posts.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type string $appkey (unused)\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $numberposts (optional)\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function blogger_getRecentPosts( $args ) {\n\n\t\t$this->escape($args);\n\n\t\t// $args[0] = appkey - ignored\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\t\tif ( isset( $args[4] ) )\n\t\t\t$query = array( 'numberposts' => absint( $args[4] ) );\n\t\telse\n\t\t\t$query = array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( ! current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit posts on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.getRecentPosts' );\n\n\t\t$posts_list = wp_get_recent_posts( $query );\n\n\t\tif ( !$posts_list ) {\n\t\t\t$this->error = new IXR_Error(500, __('Either there are no posts, or something went wrong.'));\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t$recent_posts = array();\n\t\tforeach ($posts_list as $entry) {\n\t\t\tif ( !current_user_can( 'edit_post', $entry['ID'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$post_date  = $this->_convert_date( $entry['post_date'] );\n\t\t\t$categories = implode(',', wp_get_post_categories($entry['ID']));\n\n\t\t\t$content  = '<title>'.wp_unslash($entry['post_title']).'</title>';\n\t\t\t$content .= '<category>'.$categories.'</category>';\n\t\t\t$content .= wp_unslash($entry['post_content']);\n\n\t\t\t$recent_posts[] = array(\n\t\t\t\t'userid' => $entry['post_author'],\n\t\t\t\t'dateCreated' => $post_date,\n\t\t\t\t'content' => $content,\n\t\t\t\t'postid' => (string) $entry['ID'],\n\t\t\t);\n\t\t}\n\n\t\treturn $recent_posts;\n\t}\n\n\t/**\n\t * Deprecated.\n\t *\n\t * @since 1.5.0\n\t * @deprecated 3.5.0\n\t * @return IXR_Error\n\t */\n\tpublic function blogger_getTemplate($args) {\n\t\treturn new IXR_Error( 403, __('Sorry, that file cannot be edited.' ) );\n\t}\n\n\t/**\n\t * Deprecated.\n\t *\n\t * @since 1.5.0\n\t * @deprecated 3.5.0\n\t * @return IXR_Error\n\t */\n\tpublic function blogger_setTemplate($args) {\n\t\treturn new IXR_Error( 403, __('Sorry, that file cannot be edited.' ) );\n\t}\n\n\t/**\n\t * Create new post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type string $appkey (unused)\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type string $content\n\t *     @type string $publish\n\t * }\n\t * @return int|IXR_Error\n\t */\n\tpublic function blogger_newPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\t\t$content  = $args[4];\n\t\t$publish  = $args[5];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.newPost' );\n\n\t\t$cap = ($publish) ? 'publish_posts' : 'edit_posts';\n\t\tif ( ! current_user_can( get_post_type_object( 'post' )->cap->create_posts ) || !current_user_can($cap) )\n\t\t\treturn new IXR_Error(401, __('Sorry, you are not allowed to post on this site.'));\n\n\t\t$post_status = ($publish) ? 'publish' : 'draft';\n\n\t\t$post_author = $user->ID;\n\n\t\t$post_title = xmlrpc_getposttitle($content);\n\t\t$post_category = xmlrpc_getpostcategory($content);\n\t\t$post_content = xmlrpc_removepostdata($content);\n\n\t\t$post_date = current_time('mysql');\n\t\t$post_date_gmt = current_time('mysql', 1);\n\n\t\t$post_data = compact('post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_title', 'post_category', 'post_status');\n\n\t\t$post_ID = wp_insert_post($post_data);\n\t\tif ( is_wp_error( $post_ID ) )\n\t\t\treturn new IXR_Error(500, $post_ID->get_error_message());\n\n\t\tif ( !$post_ID )\n\t\t\treturn new IXR_Error(500, __('Sorry, your entry could not be posted. Something wrong happened.'));\n\n\t\t$this->attach_uploads( $post_ID, $post_content );\n\n\t\t/**\n\t\t * Fires after a new post has been successfully created via the XML-RPC Blogger API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the new post.\n\t\t * @param array $args    An array of new post arguments.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_blogger_newPost', $post_ID, $args );\n\n\t\treturn $post_ID;\n\t}\n\n\t/**\n\t * Edit a post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type string $content\n\t * }\n\t * @return true|IXR_Error true when done.\n\t */\n\tpublic function blogger_editPost( $args ) {\n\n\t\t$this->escape($args);\n\n\t\t$post_ID  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\t\t$content  = $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) ) {\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.editPost' );\n\n\t\t$actual_post = get_post( $post_ID, ARRAY_A );\n\n\t\tif ( ! $actual_post || $actual_post['post_type'] != 'post' ) {\n\t\t\treturn new IXR_Error( 404, __( 'Sorry, no such post.' ) );\n\t\t}\n\n\t\t$this->escape($actual_post);\n\n\t\tif ( ! current_user_can( 'edit_post', $post_ID ) ) {\n\t\t\treturn new IXR_Error(401, __('Sorry, you do not have the right to edit this post.'));\n\t\t}\n\t\tif ( 'publish' == $actual_post['post_status'] && ! current_user_can( 'publish_posts' ) ) {\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to publish this post.' ) );\n\t\t}\n\n\t\t$postdata = array();\n\t\t$postdata['ID'] = $actual_post['ID'];\n\t\t$postdata['post_content'] = xmlrpc_removepostdata( $content );\n\t\t$postdata['post_title'] = xmlrpc_getposttitle( $content );\n\t\t$postdata['post_category'] = xmlrpc_getpostcategory( $content );\n\t\t$postdata['post_status'] = $actual_post['post_status'];\n\t\t$postdata['post_excerpt'] = $actual_post['post_excerpt'];\n\n\t\t$result = wp_update_post( $postdata );\n\n\t\tif ( ! $result ) {\n\t\t\treturn new IXR_Error(500, __('For some strange yet very annoying reason, this post could not be edited.'));\n\t\t}\n\t\t$this->attach_uploads( $actual_post['ID'], $postdata['post_content'] );\n\n\t\t/**\n\t\t * Fires after a post has been successfully updated via the XML-RPC Blogger API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the updated post.\n\t\t * @param array $args    An array of arguments for the post to edit.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_blogger_editPost', $post_ID, $args );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Remove a post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return true|IXR_Error True when post is deleted.\n\t */\n\tpublic function blogger_deletePost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.deletePost' );\n\n\t\t$actual_post = get_post($post_ID,ARRAY_A);\n\n\t\tif ( !$actual_post || $actual_post['post_type'] != 'post' )\n\t\t\treturn new IXR_Error(404, __('Sorry, no such post.'));\n\n\t\tif ( !current_user_can('delete_post', $post_ID) )\n\t\t\treturn new IXR_Error(401, __('Sorry, you do not have the right to delete this post.'));\n\n\t\t$result = wp_delete_post($post_ID);\n\n\t\tif ( !$result )\n\t\t\treturn new IXR_Error(500, __('For some strange yet very annoying reason, this post could not be deleted.'));\n\n\t\t/**\n\t\t * Fires after a post has been successfully deleted via the XML-RPC Blogger API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the deleted post.\n\t\t * @param array $args    An array of arguments to delete the post.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_blogger_deletePost', $post_ID, $args );\n\n\t\treturn true;\n\t}\n\n\t/* MetaWeblog API functions\n\t * specs on wherever Dave Winer wants them to be\n\t */\n\n\t/**\n\t * Create a new post.\n\t *\n\t * The 'content_struct' argument must contain:\n\t *  - title\n\t *  - description\n\t *  - mt_excerpt\n\t *  - mt_text_more\n\t *  - mt_keywords\n\t *  - mt_tb_ping_urls\n\t *  - categories\n\t *\n\t * Also, it can optionally contain:\n\t *  - wp_slug\n\t *  - wp_password\n\t *  - wp_page_parent_id\n\t *  - wp_page_order\n\t *  - wp_author_id\n\t *  - post_status | page_status - can be 'draft', 'private', 'publish', or 'pending'\n\t *  - mt_allow_comments - can be 'open' or 'closed'\n\t *  - mt_allow_pings - can be 'open' or 'closed'\n\t *  - date_created_gmt\n\t *  - dateCreated\n\t *  - wp_post_thumbnail\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $content_struct\n\t *     @type int    $publish\n\t * }\n\t * @return int|IXR_Error\n\t */\n\tpublic function mw_newPost($args) {\n\t\t$this->escape($args);\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\t\t$publish        = isset( $args[4] ) ? $args[4] : 0;\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.newPost' );\n\n\t\t$page_template = '';\n\t\tif ( !empty( $content_struct['post_type'] ) ) {\n\t\t\tif ( $content_struct['post_type'] == 'page' ) {\n\t\t\t\tif ( $publish )\n\t\t\t\t\t$cap  = 'publish_pages';\n\t\t\t\telseif ( isset( $content_struct['page_status'] ) && 'publish' == $content_struct['page_status'] )\n\t\t\t\t\t$cap  = 'publish_pages';\n\t\t\t\telse\n\t\t\t\t\t$cap = 'edit_pages';\n\t\t\t\t$error_message = __( 'Sorry, you are not allowed to publish pages on this site.' );\n\t\t\t\t$post_type = 'page';\n\t\t\t\tif ( !empty( $content_struct['wp_page_template'] ) )\n\t\t\t\t\t$page_template = $content_struct['wp_page_template'];\n\t\t\t} elseif ( $content_struct['post_type'] == 'post' ) {\n\t\t\t\tif ( $publish )\n\t\t\t\t\t$cap  = 'publish_posts';\n\t\t\t\telseif ( isset( $content_struct['post_status'] ) && 'publish' == $content_struct['post_status'] )\n\t\t\t\t\t$cap  = 'publish_posts';\n\t\t\t\telse\n\t\t\t\t\t$cap = 'edit_posts';\n\t\t\t\t$error_message = __( 'Sorry, you are not allowed to publish posts on this site.' );\n\t\t\t\t$post_type = 'post';\n\t\t\t} else {\n\t\t\t\t// No other post_type values are allowed here\n\t\t\t\treturn new IXR_Error( 401, __( 'Invalid post type' ) );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( $publish )\n\t\t\t\t$cap  = 'publish_posts';\n\t\t\telseif ( isset( $content_struct['post_status'] ) && 'publish' == $content_struct['post_status'])\n\t\t\t\t$cap  = 'publish_posts';\n\t\t\telse\n\t\t\t\t$cap = 'edit_posts';\n\t\t\t$error_message = __( 'Sorry, you are not allowed to publish posts on this site.' );\n\t\t\t$post_type = 'post';\n\t\t}\n\n\t\tif ( ! current_user_can( get_post_type_object( $post_type )->cap->create_posts ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to publish posts on this site.' ) );\n\t\tif ( !current_user_can( $cap ) )\n\t\t\treturn new IXR_Error( 401, $error_message );\n\n\t\t// Check for a valid post format if one was given\n\t\tif ( isset( $content_struct['wp_post_format'] ) ) {\n\t\t\t$content_struct['wp_post_format'] = sanitize_key( $content_struct['wp_post_format'] );\n\t\t\tif ( !array_key_exists( $content_struct['wp_post_format'], get_post_format_strings() ) ) {\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid post format' ) );\n\t\t\t}\n\t\t}\n\n\t\t// Let WordPress generate the post_name (slug) unless\n\t\t// one has been provided.\n\t\t$post_name = \"\";\n\t\tif ( isset($content_struct['wp_slug']) )\n\t\t\t$post_name = $content_struct['wp_slug'];\n\n\t\t// Only use a password if one was given.\n\t\tif ( isset($content_struct['wp_password']) )\n\t\t\t$post_password = $content_struct['wp_password'];\n\n\t\t// Only set a post parent if one was provided.\n\t\tif ( isset($content_struct['wp_page_parent_id']) )\n\t\t\t$post_parent = $content_struct['wp_page_parent_id'];\n\n\t\t// Only set the menu_order if it was provided.\n\t\tif ( isset($content_struct['wp_page_order']) )\n\t\t\t$menu_order = $content_struct['wp_page_order'];\n\n\t\t$post_author = $user->ID;\n\n\t\t// If an author id was provided then use it instead.\n\t\tif ( isset( $content_struct['wp_author_id'] ) && ( $user->ID != $content_struct['wp_author_id'] ) ) {\n\t\t\tswitch ( $post_type ) {\n\t\t\t\tcase \"post\":\n\t\t\t\t\tif ( !current_user_can( 'edit_others_posts' ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to create posts as this user.' ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"page\":\n\t\t\t\t\tif ( !current_user_can( 'edit_others_pages' ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to create pages as this user.' ) );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn new IXR_Error( 401, __( 'Invalid post type' ) );\n\t\t\t}\n\t\t\t$author = get_userdata( $content_struct['wp_author_id'] );\n\t\t\tif ( ! $author )\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid author ID.' ) );\n\t\t\t$post_author = $content_struct['wp_author_id'];\n\t\t}\n\n\t\t$post_title = isset( $content_struct['title'] ) ? $content_struct['title'] : null;\n\t\t$post_content = isset( $content_struct['description'] ) ? $content_struct['description'] : null;\n\n\t\t$post_status = $publish ? 'publish' : 'draft';\n\n\t\tif ( isset( $content_struct[\"{$post_type}_status\"] ) ) {\n\t\t\tswitch ( $content_struct[\"{$post_type}_status\"] ) {\n\t\t\t\tcase 'draft':\n\t\t\t\tcase 'pending':\n\t\t\t\tcase 'private':\n\t\t\t\tcase 'publish':\n\t\t\t\t\t$post_status = $content_struct[\"{$post_type}_status\"];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$post_status = $publish ? 'publish' : 'draft';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$post_excerpt = isset($content_struct['mt_excerpt']) ? $content_struct['mt_excerpt'] : null;\n\t\t$post_more = isset($content_struct['mt_text_more']) ? $content_struct['mt_text_more'] : null;\n\n\t\t$tags_input = isset($content_struct['mt_keywords']) ? $content_struct['mt_keywords'] : null;\n\n\t\tif ( isset($content_struct['mt_allow_comments']) ) {\n\t\t\tif ( !is_numeric($content_struct['mt_allow_comments']) ) {\n\t\t\t\tswitch ( $content_struct['mt_allow_comments'] ) {\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t\t$comment_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'open':\n\t\t\t\t\t\t$comment_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch ( (int) $content_struct['mt_allow_comments'] ) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t$comment_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$comment_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t}\n\n\t\tif ( isset($content_struct['mt_allow_pings']) ) {\n\t\t\tif ( !is_numeric($content_struct['mt_allow_pings']) ) {\n\t\t\t\tswitch ( $content_struct['mt_allow_pings'] ) {\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t\t$ping_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'open':\n\t\t\t\t\t\t$ping_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch ( (int) $content_struct['mt_allow_pings'] ) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\t$ping_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$ping_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t}\n\n\t\tif ( $post_more )\n\t\t\t$post_content = $post_content . '<!--more-->' . $post_more;\n\n\t\t$to_ping = null;\n\t\tif ( isset( $content_struct['mt_tb_ping_urls'] ) ) {\n\t\t\t$to_ping = $content_struct['mt_tb_ping_urls'];\n\t\t\tif ( is_array($to_ping) )\n\t\t\t\t$to_ping = implode(' ', $to_ping);\n\t\t}\n\n\t\t// Do some timestamp voodoo\n\t\tif ( !empty( $content_struct['date_created_gmt'] ) )\n\t\t\t// We know this is supposed to be GMT, so we're going to slap that Z on there by force\n\t\t\t$dateCreated = rtrim( $content_struct['date_created_gmt']->getIso(), 'Z' ) . 'Z';\n\t\telseif ( !empty( $content_struct['dateCreated']) )\n\t\t\t$dateCreated = $content_struct['dateCreated']->getIso();\n\n\t\tif ( !empty( $dateCreated ) ) {\n\t\t\t$post_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));\n\t\t\t$post_date_gmt = iso8601_to_datetime($dateCreated, 'GMT');\n\t\t} else {\n\t\t\t$post_date = current_time('mysql');\n\t\t\t$post_date_gmt = current_time('mysql', 1);\n\t\t}\n\n\t\t$post_category = array();\n\t\tif ( isset( $content_struct['categories'] ) ) {\n\t\t\t$catnames = $content_struct['categories'];\n\n\t\t\tif ( is_array($catnames) ) {\n\t\t\t\tforeach ($catnames as $cat) {\n\t\t\t\t\t$post_category[] = get_cat_ID($cat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$postdata = compact('post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'comment_status', 'ping_status', 'to_ping', 'post_type', 'post_name', 'post_password', 'post_parent', 'menu_order', 'tags_input', 'page_template');\n\n\t\t$post_ID = $postdata['ID'] = get_default_post_to_edit( $post_type, true )->ID;\n\n\t\t// Only posts can be sticky\n\t\tif ( $post_type == 'post' && isset( $content_struct['sticky'] ) ) {\n\t\t\t$data = $postdata;\n\t\t\t$data['sticky'] = $content_struct['sticky'];\n\t\t\t$error = $this->_toggle_sticky( $data );\n\t\t\tif ( $error ) {\n\t\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\n\t\tif ( isset($content_struct['custom_fields']) )\n\t\t\t$this->set_custom_fields($post_ID, $content_struct['custom_fields']);\n\n\t\tif ( isset ( $content_struct['wp_post_thumbnail'] ) ) {\n\t\t\tif ( set_post_thumbnail( $post_ID, $content_struct['wp_post_thumbnail'] ) === false )\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid attachment ID.' ) );\n\n\t\t\tunset( $content_struct['wp_post_thumbnail'] );\n\t\t}\n\n\t\t// Handle enclosures\n\t\t$thisEnclosure = isset($content_struct['enclosure']) ? $content_struct['enclosure'] : null;\n\t\t$this->add_enclosure_if_new($post_ID, $thisEnclosure);\n\n\t\t$this->attach_uploads( $post_ID, $post_content );\n\n\t\t// Handle post formats if assigned, value is validated earlier\n\t\t// in this function\n\t\tif ( isset( $content_struct['wp_post_format'] ) )\n\t\t\tset_post_format( $post_ID, $content_struct['wp_post_format'] );\n\n\t\t$post_ID = wp_insert_post( $postdata, true );\n\t\tif ( is_wp_error( $post_ID ) )\n\t\t\treturn new IXR_Error(500, $post_ID->get_error_message());\n\n\t\tif ( !$post_ID )\n\t\t\treturn new IXR_Error(500, __('Sorry, your entry could not be posted. Something wrong happened.'));\n\n\t\t/**\n\t\t * Fires after a new post has been successfully created via the XML-RPC MovableType API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the new post.\n\t\t * @param array $args    An array of arguments to create the new post.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_mw_newPost', $post_ID, $args );\n\n\t\treturn strval($post_ID);\n\t}\n\n\t/**\n\t * @param integer $post_ID\n\t * @param array   $enclosure\n\t */\n\tpublic function add_enclosure_if_new( $post_ID, $enclosure ) {\n\t\tif ( is_array( $enclosure ) && isset( $enclosure['url'] ) && isset( $enclosure['length'] ) && isset( $enclosure['type'] ) ) {\n\t\t\t$encstring = $enclosure['url'] . \"\\n\" . $enclosure['length'] . \"\\n\" . $enclosure['type'] . \"\\n\";\n\t\t\t$found = false;\n\t\t\tif ( $enclosures = get_post_meta( $post_ID, 'enclosure' ) ) {\n\t\t\t\tforeach ( $enclosures as $enc ) {\n\t\t\t\t\t// This method used to omit the trailing new line. #23219\n\t\t\t\t\tif ( rtrim( $enc, \"\\n\" ) == rtrim( $encstring, \"\\n\" ) ) {\n\t\t\t\t\t\t$found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ! $found )\n\t\t\t\tadd_post_meta( $post_ID, 'enclosure', $encstring );\n\t\t}\n\t}\n\n\t/**\n\t * Attach upload to a post.\n\t *\n\t * @since 2.1.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param int $post_ID Post ID.\n\t * @param string $post_content Post Content for attachment.\n\t */\n\tpublic function attach_uploads( $post_ID, $post_content ) {\n\t\tglobal $wpdb;\n\n\t\t// find any unattached files\n\t\t$attachments = $wpdb->get_results( \"SELECT ID, guid FROM {$wpdb->posts} WHERE post_parent = '0' AND post_type = 'attachment'\" );\n\t\tif ( is_array( $attachments ) ) {\n\t\t\tforeach ( $attachments as $file ) {\n\t\t\t\tif ( ! empty( $file->guid ) && strpos( $post_content, $file->guid ) !== false )\n\t\t\t\t\t$wpdb->update($wpdb->posts, array('post_parent' => $post_ID), array('ID' => $file->ID) );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Edit a post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $content_struct\n\t *     @type int    $publish\n\t * }\n\t * @return bool|IXR_Error True on success.\n\t */\n\tpublic function mw_editPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID        = (int) $args[0];\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\t\t$publish        = isset( $args[4] ) ? $args[4] : 0;\n\n\t\tif ( ! $user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.editPost' );\n\n\t\t$postdata = get_post( $post_ID, ARRAY_A );\n\n\t\t/*\n\t\t * If there is no post data for the give post id, stop now and return an error.\n\t\t * Otherwise a new post will be created (which was the old behavior).\n\t\t */\n\t\tif ( ! $postdata || empty( $postdata[ 'ID' ] ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'edit_post', $post_ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to edit this post.' ) );\n\n\t\t// Use wp.editPost to edit post types other than post and page.\n\t\tif ( ! in_array( $postdata[ 'post_type' ], array( 'post', 'page' ) ) )\n\t\t\treturn new IXR_Error( 401, __( 'Invalid post type' ) );\n\n\t\t// Thwart attempt to change the post type.\n\t\tif ( ! empty( $content_struct[ 'post_type' ] ) && ( $content_struct['post_type'] != $postdata[ 'post_type' ] ) )\n\t\t\treturn new IXR_Error( 401, __( 'The post type may not be changed.' ) );\n\n\t\t// Check for a valid post format if one was given\n\t\tif ( isset( $content_struct['wp_post_format'] ) ) {\n\t\t\t$content_struct['wp_post_format'] = sanitize_key( $content_struct['wp_post_format'] );\n\t\t\tif ( !array_key_exists( $content_struct['wp_post_format'], get_post_format_strings() ) ) {\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid post format' ) );\n\t\t\t}\n\t\t}\n\n\t\t$this->escape($postdata);\n\n\t\t$ID = $postdata['ID'];\n\t\t$post_content = $postdata['post_content'];\n\t\t$post_title = $postdata['post_title'];\n\t\t$post_excerpt = $postdata['post_excerpt'];\n\t\t$post_password = $postdata['post_password'];\n\t\t$post_parent = $postdata['post_parent'];\n\t\t$post_type = $postdata['post_type'];\n\t\t$menu_order = $postdata['menu_order'];\n\n\t\t// Let WordPress manage slug if none was provided.\n\t\t$post_name = $postdata['post_name'];\n\t\tif ( isset($content_struct['wp_slug']) )\n\t\t\t$post_name = $content_struct['wp_slug'];\n\n\t\t// Only use a password if one was given.\n\t\tif ( isset($content_struct['wp_password']) )\n\t\t\t$post_password = $content_struct['wp_password'];\n\n\t\t// Only set a post parent if one was given.\n\t\tif ( isset($content_struct['wp_page_parent_id']) )\n\t\t\t$post_parent = $content_struct['wp_page_parent_id'];\n\n\t\t// Only set the menu_order if it was given.\n\t\tif ( isset($content_struct['wp_page_order']) )\n\t\t\t$menu_order = $content_struct['wp_page_order'];\n\n\t\t$page_template = null;\n\t\tif ( ! empty( $content_struct['wp_page_template'] ) && 'page' == $post_type )\n\t\t\t$page_template = $content_struct['wp_page_template'];\n\n\t\t$post_author = $postdata['post_author'];\n\n\t\t// Only set the post_author if one is set.\n\t\tif ( isset( $content_struct['wp_author_id'] ) ) {\n\t\t\t// Check permissions if attempting to switch author to or from another user.\n\t\t\tif ( $user->ID != $content_struct['wp_author_id'] || $user->ID != $post_author ) {\n\t\t\t\tswitch ( $post_type ) {\n\t\t\t\t\tcase 'post':\n\t\t\t\t\t\tif ( ! current_user_can( 'edit_others_posts' ) ) {\n\t\t\t\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to change the post author as this user.' ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'page':\n\t\t\t\t\t\tif ( ! current_user_can( 'edit_others_pages' ) ) {\n\t\t\t\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to change the page author as this user.' ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Invalid post type' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t$post_author = $content_struct['wp_author_id'];\n\t\t\t}\n\t\t}\n\n\t\tif ( isset($content_struct['mt_allow_comments']) ) {\n\t\t\tif ( !is_numeric($content_struct['mt_allow_comments']) ) {\n\t\t\t\tswitch ( $content_struct['mt_allow_comments'] ) {\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t\t$comment_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'open':\n\t\t\t\t\t\t$comment_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch ( (int) $content_struct['mt_allow_comments'] ) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t$comment_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$comment_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( isset($content_struct['mt_allow_pings']) ) {\n\t\t\tif ( !is_numeric($content_struct['mt_allow_pings']) ) {\n\t\t\t\tswitch ( $content_struct['mt_allow_pings'] ) {\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t\t$ping_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'open':\n\t\t\t\t\t\t$ping_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch ( (int) $content_struct[\"mt_allow_pings\"] ) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\t$ping_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$ping_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $content_struct['title'] ) )\n\t\t\t$post_title =  $content_struct['title'];\n\n\t\tif ( isset( $content_struct['description'] ) )\n\t\t\t$post_content = $content_struct['description'];\n\n\t\t$post_category = array();\n\t\tif ( isset( $content_struct['categories'] ) ) {\n\t\t\t$catnames = $content_struct['categories'];\n\t\t\tif ( is_array($catnames) ) {\n\t\t\t\tforeach ($catnames as $cat) {\n\t\t\t\t\t$post_category[] = get_cat_ID($cat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $content_struct['mt_excerpt'] ) )\n\t\t\t$post_excerpt =  $content_struct['mt_excerpt'];\n\n\t\t$post_more = isset( $content_struct['mt_text_more'] ) ? $content_struct['mt_text_more'] : null;\n\n\t\t$post_status = $publish ? 'publish' : 'draft';\n\t\tif ( isset( $content_struct[\"{$post_type}_status\"] ) ) {\n\t\t\tswitch( $content_struct[\"{$post_type}_status\"] ) {\n\t\t\t\tcase 'draft':\n\t\t\t\tcase 'pending':\n\t\t\t\tcase 'private':\n\t\t\t\tcase 'publish':\n\t\t\t\t\t$post_status = $content_struct[\"{$post_type}_status\"];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$post_status = $publish ? 'publish' : 'draft';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$tags_input = isset( $content_struct['mt_keywords'] ) ? $content_struct['mt_keywords'] : null;\n\n\t\tif ( ('publish' == $post_status) ) {\n\t\t\tif ( ( 'page' == $post_type ) && ! current_user_can( 'publish_pages' ) ) {\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to publish this page.' ) );\n\t\t\t} elseif ( ! current_user_can( 'publish_posts' ) ) {\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to publish this post.' ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( $post_more )\n\t\t\t$post_content = $post_content . \"<!--more-->\" . $post_more;\n\n\t\t$to_ping = null;\n\t\tif ( isset( $content_struct['mt_tb_ping_urls'] ) ) {\n\t\t\t$to_ping = $content_struct['mt_tb_ping_urls'];\n\t\t\tif ( is_array($to_ping) )\n\t\t\t\t$to_ping = implode(' ', $to_ping);\n\t\t}\n\n\t\t// Do some timestamp voodoo.\n\t\tif ( !empty( $content_struct['date_created_gmt'] ) )\n\t\t\t// We know this is supposed to be GMT, so we're going to slap that Z on there by force.\n\t\t\t$dateCreated = rtrim( $content_struct['date_created_gmt']->getIso(), 'Z' ) . 'Z';\n\t\telseif ( !empty( $content_struct['dateCreated']) )\n\t\t\t$dateCreated = $content_struct['dateCreated']->getIso();\n\n\t\tif ( !empty( $dateCreated ) ) {\n\t\t\t$post_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));\n\t\t\t$post_date_gmt = iso8601_to_datetime($dateCreated, 'GMT');\n\t\t} else {\n\t\t\t$post_date     = $postdata['post_date'];\n\t\t\t$post_date_gmt = $postdata['post_date_gmt'];\n\t\t}\n\n\t\t// We've got all the data -- post it.\n\t\t$newpost = compact('ID', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'comment_status', 'ping_status', 'post_date', 'post_date_gmt', 'to_ping', 'post_name', 'post_password', 'post_parent', 'menu_order', 'post_author', 'tags_input', 'page_template');\n\n\t\t$result = wp_update_post($newpost, true);\n\t\tif ( is_wp_error( $result ) )\n\t\t\treturn new IXR_Error(500, $result->get_error_message());\n\n\t\tif ( !$result )\n\t\t\treturn new IXR_Error(500, __('Sorry, your entry could not be edited. Something wrong happened.'));\n\n\t\t// Only posts can be sticky\n\t\tif ( $post_type == 'post' && isset( $content_struct['sticky'] ) ) {\n\t\t\t$data = $newpost;\n\t\t\t$data['sticky'] = $content_struct['sticky'];\n\t\t\t$data['post_type'] = 'post';\n\t\t\t$error = $this->_toggle_sticky( $data, true );\n\t\t\tif ( $error ) {\n\t\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\n\t\tif ( isset($content_struct['custom_fields']) )\n\t\t\t$this->set_custom_fields($post_ID, $content_struct['custom_fields']);\n\n\t\tif ( isset ( $content_struct['wp_post_thumbnail'] ) ) {\n\n\t\t\t// Empty value deletes, non-empty value adds/updates.\n\t\t\tif ( empty( $content_struct['wp_post_thumbnail'] ) ) {\n\t\t\t\tdelete_post_thumbnail( $post_ID );\n\t\t\t} else {\n\t\t\t\tif ( set_post_thumbnail( $post_ID, $content_struct['wp_post_thumbnail'] ) === false )\n\t\t\t\t\treturn new IXR_Error( 404, __( 'Invalid attachment ID.' ) );\n\t\t\t}\n\t\t\tunset( $content_struct['wp_post_thumbnail'] );\n\t\t}\n\n\t\t// Handle enclosures.\n\t\t$thisEnclosure = isset($content_struct['enclosure']) ? $content_struct['enclosure'] : null;\n\t\t$this->add_enclosure_if_new($post_ID, $thisEnclosure);\n\n\t\t$this->attach_uploads( $ID, $post_content );\n\n\t\t// Handle post formats if assigned, validation is handled earlier in this function.\n\t\tif ( isset( $content_struct['wp_post_format'] ) )\n\t\t\tset_post_format( $post_ID, $content_struct['wp_post_format'] );\n\n\t\t/**\n\t\t * Fires after a post has been successfully updated via the XML-RPC MovableType API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the updated post.\n\t\t * @param array $args    An array of arguments to update the post.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_mw_editPost', $post_ID, $args );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieve post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mw_getPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[0];\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t$postdata = get_post($post_ID, ARRAY_A);\n\t\tif ( ! $postdata )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_post', $post_ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.getPost' );\n\n\t\tif ($postdata['post_date'] != '') {\n\t\t\t$post_date = $this->_convert_date( $postdata['post_date'] );\n\t\t\t$post_date_gmt = $this->_convert_date_gmt( $postdata['post_date_gmt'],  $postdata['post_date'] );\n\t\t\t$post_modified = $this->_convert_date( $postdata['post_modified'] );\n\t\t\t$post_modified_gmt = $this->_convert_date_gmt( $postdata['post_modified_gmt'], $postdata['post_modified'] );\n\n\t\t\t$categories = array();\n\t\t\t$catids = wp_get_post_categories($post_ID);\n\t\t\tforeach($catids as $catid)\n\t\t\t\t$categories[] = get_cat_name($catid);\n\n\t\t\t$tagnames = array();\n\t\t\t$tags = wp_get_post_tags( $post_ID );\n\t\t\tif ( !empty( $tags ) ) {\n\t\t\t\tforeach ( $tags as $tag )\n\t\t\t\t\t$tagnames[] = $tag->name;\n\t\t\t\t$tagnames = implode( ', ', $tagnames );\n\t\t\t} else {\n\t\t\t\t$tagnames = '';\n\t\t\t}\n\n\t\t\t$post = get_extended($postdata['post_content']);\n\t\t\t$link = post_permalink($postdata['ID']);\n\n\t\t\t// Get the author info.\n\t\t\t$author = get_userdata($postdata['post_author']);\n\n\t\t\t$allow_comments = ('open' == $postdata['comment_status']) ? 1 : 0;\n\t\t\t$allow_pings = ('open' == $postdata['ping_status']) ? 1 : 0;\n\n\t\t\t// Consider future posts as published\n\t\t\tif ( $postdata['post_status'] === 'future' )\n\t\t\t\t$postdata['post_status'] = 'publish';\n\n\t\t\t// Get post format\n\t\t\t$post_format = get_post_format( $post_ID );\n\t\t\tif ( empty( $post_format ) )\n\t\t\t\t$post_format = 'standard';\n\n\t\t\t$sticky = false;\n\t\t\tif ( is_sticky( $post_ID ) )\n\t\t\t\t$sticky = true;\n\n\t\t\t$enclosure = array();\n\t\t\tforeach ( (array) get_post_custom($post_ID) as $key => $val) {\n\t\t\t\tif ($key == 'enclosure') {\n\t\t\t\t\tforeach ( (array) $val as $enc ) {\n\t\t\t\t\t\t$encdata = explode(\"\\n\", $enc);\n\t\t\t\t\t\t$enclosure['url'] = trim(htmlspecialchars($encdata[0]));\n\t\t\t\t\t\t$enclosure['length'] = (int) trim($encdata[1]);\n\t\t\t\t\t\t$enclosure['type'] = trim($encdata[2]);\n\t\t\t\t\t\tbreak 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$resp = array(\n\t\t\t\t'dateCreated' => $post_date,\n\t\t\t\t'userid' => $postdata['post_author'],\n\t\t\t\t'postid' => $postdata['ID'],\n\t\t\t\t'description' => $post['main'],\n\t\t\t\t'title' => $postdata['post_title'],\n\t\t\t\t'link' => $link,\n\t\t\t\t'permaLink' => $link,\n\t\t\t\t// commented out because no other tool seems to use this\n\t\t\t\t//\t      'content' => $entry['post_content'],\n\t\t\t\t'categories' => $categories,\n\t\t\t\t'mt_excerpt' => $postdata['post_excerpt'],\n\t\t\t\t'mt_text_more' => $post['extended'],\n\t\t\t\t'wp_more_text' => $post['more_text'],\n\t\t\t\t'mt_allow_comments' => $allow_comments,\n\t\t\t\t'mt_allow_pings' => $allow_pings,\n\t\t\t\t'mt_keywords' => $tagnames,\n\t\t\t\t'wp_slug' => $postdata['post_name'],\n\t\t\t\t'wp_password' => $postdata['post_password'],\n\t\t\t\t'wp_author_id' => (string) $author->ID,\n\t\t\t\t'wp_author_display_name' => $author->display_name,\n\t\t\t\t'date_created_gmt' => $post_date_gmt,\n\t\t\t\t'post_status' => $postdata['post_status'],\n\t\t\t\t'custom_fields' => $this->get_custom_fields($post_ID),\n\t\t\t\t'wp_post_format' => $post_format,\n\t\t\t\t'sticky' => $sticky,\n\t\t\t\t'date_modified' => $post_modified,\n\t\t\t\t'date_modified_gmt' => $post_modified_gmt\n\t\t\t);\n\n\t\t\tif ( !empty($enclosure) ) $resp['enclosure'] = $enclosure;\n\n\t\t\t$resp['wp_post_thumbnail'] = get_post_thumbnail_id( $postdata['ID'] );\n\n\t\t\treturn $resp;\n\t\t} else {\n\t\t\treturn new IXR_Error(404, __('Sorry, no such post.'));\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve list of recent posts.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $numberposts\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mw_getRecentPosts( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\tif ( isset( $args[3] ) )\n\t\t\t$query = array( 'numberposts' => absint( $args[3] ) );\n\t\telse\n\t\t\t$query = array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( ! current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit posts on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.getRecentPosts' );\n\n\t\t$posts_list = wp_get_recent_posts( $query );\n\n\t\tif ( !$posts_list )\n\t\t\treturn array();\n\n\t\t$recent_posts = array();\n\t\tforeach ($posts_list as $entry) {\n\t\t\tif ( !current_user_can( 'edit_post', $entry['ID'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$post_date = $this->_convert_date( $entry['post_date'] );\n\t\t\t$post_date_gmt = $this->_convert_date_gmt( $entry['post_date_gmt'], $entry['post_date'] );\n\t\t\t$post_modified = $this->_convert_date( $entry['post_modified'] );\n\t\t\t$post_modified_gmt = $this->_convert_date_gmt( $entry['post_modified_gmt'], $entry['post_modified'] );\n\n\t\t\t$categories = array();\n\t\t\t$catids = wp_get_post_categories($entry['ID']);\n\t\t\tforeach( $catids as $catid )\n\t\t\t\t$categories[] = get_cat_name($catid);\n\n\t\t\t$tagnames = array();\n\t\t\t$tags = wp_get_post_tags( $entry['ID'] );\n\t\t\tif ( !empty( $tags ) ) {\n\t\t\t\tforeach ( $tags as $tag ) {\n\t\t\t\t\t$tagnames[] = $tag->name;\n\t\t\t\t}\n\t\t\t\t$tagnames = implode( ', ', $tagnames );\n\t\t\t} else {\n\t\t\t\t$tagnames = '';\n\t\t\t}\n\n\t\t\t$post = get_extended($entry['post_content']);\n\t\t\t$link = post_permalink($entry['ID']);\n\n\t\t\t// Get the post author info.\n\t\t\t$author = get_userdata($entry['post_author']);\n\n\t\t\t$allow_comments = ('open' == $entry['comment_status']) ? 1 : 0;\n\t\t\t$allow_pings = ('open' == $entry['ping_status']) ? 1 : 0;\n\n\t\t\t// Consider future posts as published\n\t\t\tif ( $entry['post_status'] === 'future' )\n\t\t\t\t$entry['post_status'] = 'publish';\n\n\t\t\t// Get post format\n\t\t\t$post_format = get_post_format( $entry['ID'] );\n\t\t\tif ( empty( $post_format ) )\n\t\t\t\t$post_format = 'standard';\n\n\t\t\t$recent_posts[] = array(\n\t\t\t\t'dateCreated' => $post_date,\n\t\t\t\t'userid' => $entry['post_author'],\n\t\t\t\t'postid' => (string) $entry['ID'],\n\t\t\t\t'description' => $post['main'],\n\t\t\t\t'title' => $entry['post_title'],\n\t\t\t\t'link' => $link,\n\t\t\t\t'permaLink' => $link,\n\t\t\t\t// commented out because no other tool seems to use this\n\t\t\t\t// 'content' => $entry['post_content'],\n\t\t\t\t'categories' => $categories,\n\t\t\t\t'mt_excerpt' => $entry['post_excerpt'],\n\t\t\t\t'mt_text_more' => $post['extended'],\n\t\t\t\t'wp_more_text' => $post['more_text'],\n\t\t\t\t'mt_allow_comments' => $allow_comments,\n\t\t\t\t'mt_allow_pings' => $allow_pings,\n\t\t\t\t'mt_keywords' => $tagnames,\n\t\t\t\t'wp_slug' => $entry['post_name'],\n\t\t\t\t'wp_password' => $entry['post_password'],\n\t\t\t\t'wp_author_id' => (string) $author->ID,\n\t\t\t\t'wp_author_display_name' => $author->display_name,\n\t\t\t\t'date_created_gmt' => $post_date_gmt,\n\t\t\t\t'post_status' => $entry['post_status'],\n\t\t\t\t'custom_fields' => $this->get_custom_fields($entry['ID']),\n\t\t\t\t'wp_post_format' => $post_format,\n\t\t\t\t'date_modified' => $post_modified,\n\t\t\t\t'date_modified_gmt' => $post_modified_gmt,\n\t\t\t\t'sticky' => ( $entry['post_type'] === 'post' && is_sticky( $entry['ID'] ) ),\n\t\t\t\t'wp_post_thumbnail' => get_post_thumbnail_id( $entry['ID'] )\n\t\t\t);\n\t\t}\n\n\t\treturn $recent_posts;\n\t}\n\n\t/**\n\t * Retrieve the list of categories on a given blog.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mw_getCategories( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view categories.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.getCategories' );\n\n\t\t$categories_struct = array();\n\n\t\tif ( $cats = get_categories(array('get' => 'all')) ) {\n\t\t\tforeach ( $cats as $cat ) {\n\t\t\t\t$struct = array();\n\t\t\t\t$struct['categoryId'] = $cat->term_id;\n\t\t\t\t$struct['parentId'] = $cat->parent;\n\t\t\t\t$struct['description'] = $cat->name;\n\t\t\t\t$struct['categoryDescription'] = $cat->description;\n\t\t\t\t$struct['categoryName'] = $cat->name;\n\t\t\t\t$struct['htmlUrl'] = esc_html(get_category_link($cat->term_id));\n\t\t\t\t$struct['rssUrl'] = esc_html(get_category_feed_link($cat->term_id, 'rss2'));\n\n\t\t\t\t$categories_struct[] = $struct;\n\t\t\t}\n\t\t}\n\n\t\treturn $categories_struct;\n\t}\n\n\t/**\n\t * Uploads a file, following your settings.\n\t *\n\t * Adapted from a patch by Johann Richard.\n\t *\n\t * @link http://mycvs.org/archives/2004/06/30/file-upload-to-wordpress-in-ecto/\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $data\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mw_newMediaObject( $args ) {\n\t\tglobal $wpdb;\n\n\t\t$username = $this->escape( $args[1] );\n\t\t$password = $this->escape( $args[2] );\n\t\t$data     = $args[3];\n\n\t\t$name = sanitize_file_name( $data['name'] );\n\t\t$type = $data['type'];\n\t\t$bits = $data['bits'];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.newMediaObject' );\n\n\t\tif ( !current_user_can('upload_files') ) {\n\t\t\t$this->error = new IXR_Error( 401, __( 'You do not have permission to upload files.' ) );\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t/**\n\t\t * Filter whether to preempt the XML-RPC media upload.\n\t\t *\n\t\t * Passing a truthy value will effectively short-circuit the media upload,\n\t\t * returning that value as a 500 error instead.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param bool $error Whether to pre-empt the media upload. Default false.\n\t\t */\n\t\tif ( $upload_err = apply_filters( 'pre_upload_error', false ) ) {\n\t\t\treturn new IXR_Error( 500, $upload_err );\n\t\t}\n\n\t\tif ( !empty($data['overwrite']) && ($data['overwrite'] == true) ) {\n\t\t\t// Get postmeta info on the object.\n\t\t\t$old_file = $wpdb->get_row(\"\n\t\t\t\tSELECT ID\n\t\t\t\tFROM {$wpdb->posts}\n\t\t\t\tWHERE post_title = '{$name}'\n\t\t\t\t\tAND post_type = 'attachment'\n\t\t\t\");\n\n\t\t\t// Delete previous file.\n\t\t\twp_delete_attachment($old_file->ID);\n\n\t\t\t// Make sure the new name is different by pre-pending the\n\t\t\t// previous post id.\n\t\t\t$filename = preg_replace('/^wpid\\d+-/', '', $name);\n\t\t\t$name = \"wpid{$old_file->ID}-{$filename}\";\n\t\t}\n\n\t\t$upload = wp_upload_bits($name, null, $bits);\n\t\tif ( ! empty($upload['error']) ) {\n\t\t\t$errorString = sprintf(__('Could not write file %1$s (%2$s)'), $name, $upload['error']);\n\t\t\treturn new IXR_Error(500, $errorString);\n\t\t}\n\t\t// Construct the attachment array\n\t\t$post_id = 0;\n\t\tif ( ! empty( $data['post_id'] ) ) {\n\t\t\t$post_id = (int) $data['post_id'];\n\n\t\t\tif ( ! current_user_can( 'edit_post', $post_id ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\t\t}\n\t\t$attachment = array(\n\t\t\t'post_title' => $name,\n\t\t\t'post_content' => '',\n\t\t\t'post_type' => 'attachment',\n\t\t\t'post_parent' => $post_id,\n\t\t\t'post_mime_type' => $type,\n\t\t\t'guid' => $upload[ 'url' ]\n\t\t);\n\n\t\t// Save the data\n\t\t$id = wp_insert_attachment( $attachment, $upload[ 'file' ], $post_id );\n\t\twp_update_attachment_metadata( $id, wp_generate_attachment_metadata( $id, $upload['file'] ) );\n\n\t\t/**\n\t\t * Fires after a new attachment has been added via the XML-RPC MovableType API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $id   ID of the new attachment.\n\t\t * @param array $args An array of arguments to add the attachment.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_mw_newMediaObject', $id, $args );\n\n\t\t$struct = array(\n\t\t\t'id'   => strval( $id ),\n\t\t\t'file' => $name,\n\t\t\t'url'  => $upload[ 'url' ],\n\t\t\t'type' => $type\n\t\t);\n\n\t\t/** This filter is documented in wp-admin/includes/file.php */\n\t\treturn apply_filters( 'wp_handle_upload', $struct, 'upload' );\n\t}\n\n\t/* MovableType API functions\n\t * specs on http://www.movabletype.org/docs/mtmanual_programmatic.html\n\t */\n\n\t/**\n\t * Retrieve the post titles of recent posts.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $numberposts\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mt_getRecentPostTitles( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\tif ( isset( $args[3] ) )\n\t\t\t$query = array( 'numberposts' => absint( $args[3] ) );\n\t\telse\n\t\t\t$query = array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.getRecentPostTitles' );\n\n\t\t$posts_list = wp_get_recent_posts( $query );\n\n\t\tif ( !$posts_list ) {\n\t\t\t$this->error = new IXR_Error(500, __('Either there are no posts, or something went wrong.'));\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t$recent_posts = array();\n\n\t\tforeach ($posts_list as $entry) {\n\t\t\tif ( !current_user_can( 'edit_post', $entry['ID'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$post_date = $this->_convert_date( $entry['post_date'] );\n\t\t\t$post_date_gmt = $this->_convert_date_gmt( $entry['post_date_gmt'], $entry['post_date'] );\n\n\t\t\t$recent_posts[] = array(\n\t\t\t\t'dateCreated' => $post_date,\n\t\t\t\t'userid' => $entry['post_author'],\n\t\t\t\t'postid' => (string) $entry['ID'],\n\t\t\t\t'title' => $entry['post_title'],\n\t\t\t\t'post_status' => $entry['post_status'],\n\t\t\t\t'date_created_gmt' => $post_date_gmt\n\t\t\t);\n\t\t}\n\n\t\treturn $recent_posts;\n\t}\n\n\t/**\n\t * Retrieve list of all categories on blog.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mt_getCategoryList( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view categories.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.getCategoryList' );\n\n\t\t$categories_struct = array();\n\n\t\tif ( $cats = get_categories(array('hide_empty' => 0, 'hierarchical' => 0)) ) {\n\t\t\tforeach ( $cats as $cat ) {\n\t\t\t\t$struct = array();\n\t\t\t\t$struct['categoryId'] = $cat->term_id;\n\t\t\t\t$struct['categoryName'] = $cat->name;\n\n\t\t\t\t$categories_struct[] = $struct;\n\t\t\t}\n\t\t}\n\n\t\treturn $categories_struct;\n\t}\n\n\t/**\n\t * Retrieve post categories.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mt_getPostCategories( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[0];\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( ! get_post( $post_ID ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_post', $post_ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you can not edit this post.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.getPostCategories' );\n\n\t\t$categories = array();\n\t\t$catids = wp_get_post_categories(intval($post_ID));\n\t\t// first listed category will be the primary category\n\t\t$isPrimary = true;\n\t\tforeach ( $catids as $catid ) {\n\t\t\t$categories[] = array(\n\t\t\t\t'categoryName' => get_cat_name($catid),\n\t\t\t\t'categoryId' => (string) $catid,\n\t\t\t\t'isPrimary' => $isPrimary\n\t\t\t);\n\t\t\t$isPrimary = false;\n\t\t}\n\n\t\treturn $categories;\n\t}\n\n\t/**\n\t * Sets categories for a post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $categories\n\t * }\n\t * @return true|IXR_Error True on success.\n\t */\n\tpublic function mt_setPostCategories( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID    = (int) $args[0];\n\t\t$username   = $args[1];\n\t\t$password   = $args[2];\n\t\t$categories = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.setPostCategories' );\n\n\t\tif ( ! get_post( $post_ID ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can('edit_post', $post_ID) )\n\t\t\treturn new IXR_Error(401, __('Sorry, you cannot edit this post.'));\n\n\t\t$catids = array();\n\t\tforeach ( $categories as $cat ) {\n\t\t\t$catids[] = $cat['categoryId'];\n\t\t}\n\n\t\twp_set_post_categories($post_ID, $catids);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieve an array of methods supported by this server.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return array\n\t */\n\tpublic function mt_supportedMethods() {\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.supportedMethods' );\n\n\t\treturn array_keys( $this->methods );\n\t}\n\n\t/**\n\t * Retrieve an empty array because we don't support per-post text filters.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function mt_supportedTextFilters() {\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.supportedTextFilters' );\n\n\t\t/**\n\t\t * Filter the MoveableType text filters list for XML-RPC.\n\t\t *\n\t\t * @since 2.2.0\n\t\t *\n\t\t * @param array $filters An array of text filters.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_text_filters', array() );\n\t}\n\n\t/**\n\t * Retrieve trackbacks sent to a given post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param int $post_ID\n\t * @return array|IXR_Error\n\t */\n\tpublic function mt_getTrackbackPings( $post_ID ) {\n\t\tglobal $wpdb;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.getTrackbackPings' );\n\n\t\t$actual_post = get_post($post_ID, ARRAY_A);\n\n\t\tif ( !$actual_post )\n\t\t\treturn new IXR_Error(404, __('Sorry, no such post.'));\n\n\t\t$comments = $wpdb->get_results( $wpdb->prepare(\"SELECT comment_author_url, comment_content, comment_author_IP, comment_type FROM $wpdb->comments WHERE comment_post_ID = %d\", $post_ID) );\n\n\t\tif ( !$comments )\n\t\t\treturn array();\n\n\t\t$trackback_pings = array();\n\t\tforeach ( $comments as $comment ) {\n\t\t\tif ( 'trackback' == $comment->comment_type ) {\n\t\t\t\t$content = $comment->comment_content;\n\t\t\t\t$title = substr($content, 8, (strpos($content, '</strong>') - 8));\n\t\t\t\t$trackback_pings[] = array(\n\t\t\t\t\t'pingTitle' => $title,\n\t\t\t\t\t'pingURL'   => $comment->comment_author_url,\n\t\t\t\t\t'pingIP'    => $comment->comment_author_IP\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn $trackback_pings;\n\t}\n\n\t/**\n\t * Sets a post's publish status to 'publish'.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return int|IXR_Error\n\t */\n\tpublic function mt_publishPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[0];\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.publishPost' );\n\n\t\t$postdata = get_post($post_ID, ARRAY_A);\n\t\tif ( ! $postdata )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can('publish_posts') || !current_user_can('edit_post', $post_ID) )\n\t\t\treturn new IXR_Error(401, __('Sorry, you cannot publish this post.'));\n\n\t\t$postdata['post_status'] = 'publish';\n\n\t\t// retain old cats\n\t\t$cats = wp_get_post_categories($post_ID);\n\t\t$postdata['post_category'] = $cats;\n\t\t$this->escape($postdata);\n\n\t\treturn wp_update_post( $postdata );\n\t}\n\n\t/* PingBack functions\n\t * specs on www.hixie.ch/specs/pingback/pingback\n\t */\n\n\t/**\n\t * Retrieves a pingback and registers it.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global wpdb $wpdb\n\t * @global string $wp_version\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type string $pagelinkedfrom\n\t *     @type string $pagelinkedto\n\t * }\n\t * @return string|IXR_Error\n\t */\n\tpublic function pingback_ping( $args ) {\n\t\tglobal $wpdb, $wp_version;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'pingback.ping' );\n\n\t\t$this->escape( $args );\n\n\t\t$pagelinkedfrom = str_replace( '&amp;', '&', $args[0] );\n\t\t$pagelinkedto = str_replace( '&amp;', '&', $args[1] );\n\t\t$pagelinkedto = str_replace( '&', '&amp;', $pagelinkedto );\n\n\t\t/**\n\t\t * Filter the pingback source URI.\n\t\t *\n\t\t * @since 3.6.0\n\t\t *\n\t\t * @param string $pagelinkedfrom URI of the page linked from.\n\t\t * @param string $pagelinkedto   URI of the page linked to.\n\t\t */\n\t\t$pagelinkedfrom = apply_filters( 'pingback_ping_source_uri', $pagelinkedfrom, $pagelinkedto );\n\n\t\tif ( ! $pagelinkedfrom )\n\t\t\treturn $this->pingback_error( 0, __( 'A valid URL was not provided.' ) );\n\n\t\t// Check if the page linked to is in our site\n\t\t$pos1 = strpos($pagelinkedto, str_replace(array('http://www.','http://','https://www.','https://'), '', get_option('home')));\n\t\tif ( !$pos1 )\n\t\t\treturn $this->pingback_error( 0, __( 'Is there no link to us?' ) );\n\n\t\t// let's find which post is linked to\n\t\t// FIXME: does url_to_postid() cover all these cases already?\n\t\t//        if so, then let's use it and drop the old code.\n\t\t$urltest = parse_url($pagelinkedto);\n\t\tif ( $post_ID = url_to_postid($pagelinkedto) ) {\n\t\t\t// $way\n\t\t} elseif ( isset( $urltest['path'] ) && preg_match('#p/[0-9]{1,}#', $urltest['path'], $match) ) {\n\t\t\t// the path defines the post_ID (archives/p/XXXX)\n\t\t\t$blah = explode('/', $match[0]);\n\t\t\t$post_ID = (int) $blah[1];\n\t\t} elseif ( isset( $urltest['query'] ) && preg_match('#p=[0-9]{1,}#', $urltest['query'], $match) ) {\n\t\t\t// the querystring defines the post_ID (?p=XXXX)\n\t\t\t$blah = explode('=', $match[0]);\n\t\t\t$post_ID = (int) $blah[1];\n\t\t} elseif ( isset($urltest['fragment']) ) {\n\t\t\t// an #anchor is there, it's either...\n\t\t\tif ( intval($urltest['fragment']) ) {\n\t\t\t\t// ...an integer #XXXX (simplest case)\n\t\t\t\t$post_ID = (int) $urltest['fragment'];\n\t\t\t} elseif ( preg_match('/post-[0-9]+/',$urltest['fragment']) ) {\n\t\t\t\t// ...a post id in the form 'post-###'\n\t\t\t\t$post_ID = preg_replace('/[^0-9]+/', '', $urltest['fragment']);\n\t\t\t} elseif ( is_string($urltest['fragment']) ) {\n\t\t\t\t// ...or a string #title, a little more complicated\n\t\t\t\t$title = preg_replace('/[^a-z0-9]/i', '.', $urltest['fragment']);\n\t\t\t\t$sql = $wpdb->prepare(\"SELECT ID FROM $wpdb->posts WHERE post_title RLIKE %s\", $title );\n\t\t\t\tif (! ($post_ID = $wpdb->get_var($sql)) ) {\n\t\t\t\t\t// returning unknown error '0' is better than die()ing\n\t\t\t  \t\treturn $this->pingback_error( 0, '' );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// TODO: Attempt to extract a post ID from the given URL\n\t  \t\treturn $this->pingback_error( 33, __('The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.' ) );\n\t\t}\n\t\t$post_ID = (int) $post_ID;\n\n\t\t$post = get_post($post_ID);\n\n\t\tif ( !$post ) // Post_ID not found\n\t  \t\treturn $this->pingback_error( 33, __( 'The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.' ) );\n\n\t\tif ( $post_ID == url_to_postid($pagelinkedfrom) )\n\t\t\treturn $this->pingback_error( 0, __( 'The source URL and the target URL cannot both point to the same resource.' ) );\n\n\t\t// Check if pings are on\n\t\tif ( !pings_open($post) )\n\t  \t\treturn $this->pingback_error( 33, __( 'The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.' ) );\n\n\t\t// Let's check that the remote site didn't already pingback this entry\n\t\tif ( $wpdb->get_results( $wpdb->prepare(\"SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_author_url = %s\", $post_ID, $pagelinkedfrom) ) )\n\t\t\treturn $this->pingback_error( 48, __( 'The pingback has already been registered.' ) );\n\n\t\t// very stupid, but gives time to the 'from' server to publish !\n\t\tsleep(1);\n\n\t\t$remote_ip = preg_replace( '/[^0-9a-fA-F:., ]/', '', $_SERVER['REMOTE_ADDR'] );\n\n\t\t/** This filter is documented in wp-includes/class-http.php */\n\t\t$user_agent = apply_filters( 'http_headers_useragent', 'WordPress/' . $wp_version . '; ' . get_bloginfo( 'url' ) );\n\n\t\t// Let's check the remote site\n\t\t$http_api_args = array(\n\t\t\t'timeout' => 10,\n\t\t\t'redirection' => 0,\n\t\t\t'limit_response_size' => 153600, // 150 KB\n\t\t\t'user-agent' => \"$user_agent; verifying pingback from $remote_ip\",\n\t\t\t'headers' => array(\n\t\t\t\t'X-Pingback-Forwarded-For' => $remote_ip,\n\t\t\t),\n\t\t);\n\t\t$request = wp_safe_remote_get( $pagelinkedfrom, $http_api_args );\n\t\t$linea = wp_remote_retrieve_body( $request );\n\n\t\tif ( !$linea )\n\t\t\treturn $this->pingback_error( 16, __( 'The source URL does not exist.' ) );\n\n\t\t/**\n\t\t * Filter the pingback remote source.\n\t\t *\n\t\t * @since 2.5.0\n\t\t *\n\t\t * @param string $linea        Response object for the page linked from.\n\t\t * @param string $pagelinkedto URL of the page linked to.\n\t\t */\n\t\t$linea = apply_filters( 'pre_remote_source', $linea, $pagelinkedto );\n\n\t\t// Work around bug in strip_tags():\n\t\t$linea = str_replace('<!DOC', '<DOC', $linea);\n\t\t$linea = preg_replace( '/[\\r\\n\\t ]+/', ' ', $linea ); // normalize spaces\n\t\t$linea = preg_replace( \"/<\\/*(h1|h2|h3|h4|h5|h6|p|th|td|li|dt|dd|pre|caption|input|textarea|button|body)[^>]*>/\", \"\\n\\n\", $linea );\n\n\t\tpreg_match('|<title>([^<]*?)</title>|is', $linea, $matchtitle);\n\t\t$title = $matchtitle[1];\n\t\tif ( empty( $title ) )\n\t\t\treturn $this->pingback_error( 32, __('We cannot find a title on that page.' ) );\n\n\t\t$linea = strip_tags( $linea, '<a>' ); // just keep the tag we need\n\n\t\t$p = explode( \"\\n\\n\", $linea );\n\n\t\t$preg_target = preg_quote($pagelinkedto, '|');\n\n\t\tforeach ( $p as $para ) {\n\t\t\tif ( strpos($para, $pagelinkedto) !== false ) { // it exists, but is it a link?\n\t\t\t\tpreg_match(\"|<a[^>]+?\".$preg_target.\"[^>]*>([^>]+?)</a>|\", $para, $context);\n\n\t\t\t\t// If the URL isn't in a link context, keep looking\n\t\t\t\tif ( empty($context) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// We're going to use this fake tag to mark the context in a bit\n\t\t\t\t// the marker is needed in case the link text appears more than once in the paragraph\n\t\t\t\t$excerpt = preg_replace('|\\</?wpcontext\\>|', '', $para);\n\n\t\t\t\t// prevent really long link text\n\t\t\t\tif ( strlen($context[1]) > 100 )\n\t\t\t\t\t$context[1] = substr($context[1], 0, 100) . '&#8230;';\n\n\t\t\t\t$marker = '<wpcontext>'.$context[1].'</wpcontext>';    // set up our marker\n\t\t\t\t$excerpt= str_replace($context[0], $marker, $excerpt); // swap out the link for our marker\n\t\t\t\t$excerpt = strip_tags($excerpt, '<wpcontext>');        // strip all tags but our context marker\n\t\t\t\t$excerpt = trim($excerpt);\n\t\t\t\t$preg_marker = preg_quote($marker, '|');\n\t\t\t\t$excerpt = preg_replace(\"|.*?\\s(.{0,100}$preg_marker.{0,100})\\s.*|s\", '$1', $excerpt);\n\t\t\t\t$excerpt = strip_tags($excerpt); // YES, again, to remove the marker wrapper\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( empty($context) ) // Link to target not found\n\t\t\treturn $this->pingback_error( 17, __( 'The source URL does not contain a link to the target URL, and so cannot be used as a source.' ) );\n\n\t\t$pagelinkedfrom = str_replace('&', '&amp;', $pagelinkedfrom);\n\n\t\t$context = '[&#8230;] ' . esc_html( $excerpt ) . ' [&#8230;]';\n\t\t$pagelinkedfrom = $this->escape( $pagelinkedfrom );\n\n\t\t$comment_post_ID = (int) $post_ID;\n\t\t$comment_author = $title;\n\t\t$comment_author_email = '';\n\t\t$this->escape($comment_author);\n\t\t$comment_author_url = $pagelinkedfrom;\n\t\t$comment_content = $context;\n\t\t$this->escape($comment_content);\n\t\t$comment_type = 'pingback';\n\n\t\t$commentdata = compact('comment_post_ID', 'comment_author', 'comment_author_url', 'comment_author_email', 'comment_content', 'comment_type');\n\n\t\t$comment_ID = wp_new_comment($commentdata);\n\n\t\t/**\n\t\t * Fires after a post pingback has been sent.\n\t\t *\n\t\t * @since 0.71\n\t\t *\n\t\t * @param int $comment_ID Comment ID.\n\t\t */\n\t\tdo_action( 'pingback_post', $comment_ID );\n\n\t\treturn sprintf(__('Pingback from %1$s to %2$s registered. Keep the web talking! :-)'), $pagelinkedfrom, $pagelinkedto);\n\t}\n\n\t/**\n\t * Retrieve array of URLs that pingbacked the given URL.\n\t *\n\t * Specs on http://www.aquarionics.com/misc/archives/blogite/0198.html\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param string $url\n\t * @return array|IXR_Error\n\t */\n\tpublic function pingback_extensions_getPingbacks( $url ) {\n\t\tglobal $wpdb;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'pingback.extensions.getPingbacks' );\n\n\t\t$url = $this->escape( $url );\n\n\t\t$post_ID = url_to_postid($url);\n\t\tif ( !$post_ID ) {\n\t\t\t// We aren't sure that the resource is available and/or pingback enabled\n\t  \t\treturn $this->pingback_error( 33, __( 'The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.' ) );\n\t\t}\n\n\t\t$actual_post = get_post($post_ID, ARRAY_A);\n\n\t\tif ( !$actual_post ) {\n\t\t\t// No such post = resource not found\n\t  \t\treturn $this->pingback_error( 32, __('The specified target URL does not exist.' ) );\n\t\t}\n\n\t\t$comments = $wpdb->get_results( $wpdb->prepare(\"SELECT comment_author_url, comment_content, comment_author_IP, comment_type FROM $wpdb->comments WHERE comment_post_ID = %d\", $post_ID) );\n\n\t\tif ( !$comments )\n\t\t\treturn array();\n\n\t\t$pingbacks = array();\n\t\tforeach ( $comments as $comment ) {\n\t\t\tif ( 'pingback' == $comment->comment_type )\n\t\t\t\t$pingbacks[] = $comment->comment_author_url;\n\t\t}\n\n\t\treturn $pingbacks;\n\t}\n\n\t/**\n\t * @param integer $code\n\t * @param string $message\n\t * @return IXR_Error\n\t */\n\tprotected function pingback_error( $code, $message ) {\n\t\t/**\n\t\t * Filter the XML-RPC pingback error return.\n\t\t *\n\t\t * @since 3.5.1\n\t\t *\n\t\t * @param IXR_Error $error An IXR_Error object containing the error code and message.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_pingback_error', new IXR_Error( $code, $message ) );\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * XML-RPC protocol support for WordPress\n *\n * @package WordPress\n * @subpackage Publishing\n */\n\n/**\n * WordPress XMLRPC server implementation.\n *\n * Implements compatibility for Blogger API, MetaWeblog API, MovableType, and\n * pingback. Additional WordPress API for managing comments, pages, posts,\n * options, etc.\n *\n * As of WordPress 3.5.0, XML-RPC is enabled by default. It can be disabled\n * via the xmlrpc_enabled filter found in wp_xmlrpc_server::login().\n *\n * @package WordPress\n * @subpackage Publishing\n * @since 1.5.0\n */\nclass wp_xmlrpc_server extends IXR_Server {\n\t/**\n\t * Methods.\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $methods;\n\n\t/**\n\t * Blog options.\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $blog_options;\n\n\t/**\n\t * IXR_Error instance.\n\t *\n\t * @access public\n\t * @var IXR_Error\n\t */\n\tpublic $error;\n\n\t/**\n\t * Register all of the XMLRPC methods that XMLRPC server understands.\n\t *\n\t * Sets up server and method property. Passes XMLRPC\n\t * methods through the 'xmlrpc_methods' filter to allow plugins to extend\n\t * or replace XMLRPC methods.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function __construct() {\n\t\t$this->methods = array(\n\t\t\t// WordPress API\n\t\t\t'wp.getUsersBlogs'\t\t=> 'this:wp_getUsersBlogs',\n\t\t\t'wp.newPost'\t\t\t=> 'this:wp_newPost',\n\t\t\t'wp.editPost'\t\t\t=> 'this:wp_editPost',\n\t\t\t'wp.deletePost'\t\t\t=> 'this:wp_deletePost',\n\t\t\t'wp.getPost'\t\t\t=> 'this:wp_getPost',\n\t\t\t'wp.getPosts'\t\t\t=> 'this:wp_getPosts',\n\t\t\t'wp.newTerm'\t\t\t=> 'this:wp_newTerm',\n\t\t\t'wp.editTerm'\t\t\t=> 'this:wp_editTerm',\n\t\t\t'wp.deleteTerm'\t\t\t=> 'this:wp_deleteTerm',\n\t\t\t'wp.getTerm'\t\t\t=> 'this:wp_getTerm',\n\t\t\t'wp.getTerms'\t\t\t=> 'this:wp_getTerms',\n\t\t\t'wp.getTaxonomy'\t\t=> 'this:wp_getTaxonomy',\n\t\t\t'wp.getTaxonomies'\t\t=> 'this:wp_getTaxonomies',\n\t\t\t'wp.getUser'\t\t\t=> 'this:wp_getUser',\n\t\t\t'wp.getUsers'\t\t\t=> 'this:wp_getUsers',\n\t\t\t'wp.getProfile'\t\t\t=> 'this:wp_getProfile',\n\t\t\t'wp.editProfile'\t\t=> 'this:wp_editProfile',\n\t\t\t'wp.getPage'\t\t\t=> 'this:wp_getPage',\n\t\t\t'wp.getPages'\t\t\t=> 'this:wp_getPages',\n\t\t\t'wp.newPage'\t\t\t=> 'this:wp_newPage',\n\t\t\t'wp.deletePage'\t\t\t=> 'this:wp_deletePage',\n\t\t\t'wp.editPage'\t\t\t=> 'this:wp_editPage',\n\t\t\t'wp.getPageList'\t\t=> 'this:wp_getPageList',\n\t\t\t'wp.getAuthors'\t\t\t=> 'this:wp_getAuthors',\n\t\t\t'wp.getCategories'\t\t=> 'this:mw_getCategories',\t\t// Alias\n\t\t\t'wp.getTags'\t\t\t=> 'this:wp_getTags',\n\t\t\t'wp.newCategory'\t\t=> 'this:wp_newCategory',\n\t\t\t'wp.deleteCategory'\t\t=> 'this:wp_deleteCategory',\n\t\t\t'wp.suggestCategories'\t=> 'this:wp_suggestCategories',\n\t\t\t'wp.uploadFile'\t\t\t=> 'this:mw_newMediaObject',\t// Alias\n\t\t\t'wp.deleteFile'\t\t\t=> 'this:wp_deletePost',\t\t// Alias\n\t\t\t'wp.getCommentCount'\t=> 'this:wp_getCommentCount',\n\t\t\t'wp.getPostStatusList'\t=> 'this:wp_getPostStatusList',\n\t\t\t'wp.getPageStatusList'\t=> 'this:wp_getPageStatusList',\n\t\t\t'wp.getPageTemplates'\t=> 'this:wp_getPageTemplates',\n\t\t\t'wp.getOptions'\t\t\t=> 'this:wp_getOptions',\n\t\t\t'wp.setOptions'\t\t\t=> 'this:wp_setOptions',\n\t\t\t'wp.getComment'\t\t\t=> 'this:wp_getComment',\n\t\t\t'wp.getComments'\t\t=> 'this:wp_getComments',\n\t\t\t'wp.deleteComment'\t\t=> 'this:wp_deleteComment',\n\t\t\t'wp.editComment'\t\t=> 'this:wp_editComment',\n\t\t\t'wp.newComment'\t\t\t=> 'this:wp_newComment',\n\t\t\t'wp.getCommentStatusList' => 'this:wp_getCommentStatusList',\n\t\t\t'wp.getMediaItem'\t\t=> 'this:wp_getMediaItem',\n\t\t\t'wp.getMediaLibrary'\t=> 'this:wp_getMediaLibrary',\n\t\t\t'wp.getPostFormats'     => 'this:wp_getPostFormats',\n\t\t\t'wp.getPostType'\t\t=> 'this:wp_getPostType',\n\t\t\t'wp.getPostTypes'\t\t=> 'this:wp_getPostTypes',\n\t\t\t'wp.getRevisions'\t\t=> 'this:wp_getRevisions',\n\t\t\t'wp.restoreRevision'\t=> 'this:wp_restoreRevision',\n\n\t\t\t// Blogger API\n\t\t\t'blogger.getUsersBlogs' => 'this:blogger_getUsersBlogs',\n\t\t\t'blogger.getUserInfo' => 'this:blogger_getUserInfo',\n\t\t\t'blogger.getPost' => 'this:blogger_getPost',\n\t\t\t'blogger.getRecentPosts' => 'this:blogger_getRecentPosts',\n\t\t\t'blogger.newPost' => 'this:blogger_newPost',\n\t\t\t'blogger.editPost' => 'this:blogger_editPost',\n\t\t\t'blogger.deletePost' => 'this:blogger_deletePost',\n\n\t\t\t// MetaWeblog API (with MT extensions to structs)\n\t\t\t'metaWeblog.newPost' => 'this:mw_newPost',\n\t\t\t'metaWeblog.editPost' => 'this:mw_editPost',\n\t\t\t'metaWeblog.getPost' => 'this:mw_getPost',\n\t\t\t'metaWeblog.getRecentPosts' => 'this:mw_getRecentPosts',\n\t\t\t'metaWeblog.getCategories' => 'this:mw_getCategories',\n\t\t\t'metaWeblog.newMediaObject' => 'this:mw_newMediaObject',\n\n\t\t\t// MetaWeblog API aliases for Blogger API\n\t\t\t// see http://www.xmlrpc.com/stories/storyReader$2460\n\t\t\t'metaWeblog.deletePost' => 'this:blogger_deletePost',\n\t\t\t'metaWeblog.getUsersBlogs' => 'this:blogger_getUsersBlogs',\n\n\t\t\t// MovableType API\n\t\t\t'mt.getCategoryList' => 'this:mt_getCategoryList',\n\t\t\t'mt.getRecentPostTitles' => 'this:mt_getRecentPostTitles',\n\t\t\t'mt.getPostCategories' => 'this:mt_getPostCategories',\n\t\t\t'mt.setPostCategories' => 'this:mt_setPostCategories',\n\t\t\t'mt.supportedMethods' => 'this:mt_supportedMethods',\n\t\t\t'mt.supportedTextFilters' => 'this:mt_supportedTextFilters',\n\t\t\t'mt.getTrackbackPings' => 'this:mt_getTrackbackPings',\n\t\t\t'mt.publishPost' => 'this:mt_publishPost',\n\n\t\t\t// PingBack\n\t\t\t'pingback.ping' => 'this:pingback_ping',\n\t\t\t'pingback.extensions.getPingbacks' => 'this:pingback_extensions_getPingbacks',\n\n\t\t\t'demo.sayHello' => 'this:sayHello',\n\t\t\t'demo.addTwoNumbers' => 'this:addTwoNumbers'\n\t\t);\n\n\t\t$this->initialise_blog_option_info();\n\n\t\t/**\n\t\t * Filter the methods exposed by the XML-RPC server.\n\t\t *\n\t\t * This filter can be used to add new methods, and remove built-in methods.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param array $methods An array of XML-RPC methods.\n\t\t */\n\t\t$this->methods = apply_filters( 'xmlrpc_methods', $this->methods );\n\t}\n\n\t/**\n\t * Make private/protected methods readable for backwards compatibility.\n\t *\n\t * @since 4.0.0\n\t * @access public\n\t *\n\t * @param callable $name      Method to call.\n\t * @param array    $arguments Arguments to pass when calling.\n\t * @return array|IXR_Error|false Return value of the callback, false otherwise.\n\t */\n\tpublic function __call( $name, $arguments ) {\n\t\tif ( '_multisite_getUsersBlogs' === $name ) {\n\t\t\treturn call_user_func_array( array( $this, $name ), $arguments );\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @access public\n\t */\n\tpublic function serve_request() {\n\t\t$this->IXR_Server($this->methods);\n\t}\n\n\t/**\n\t * Test XMLRPC API by saying, \"Hello!\" to client.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return string Hello string response.\n\t */\n\tpublic function sayHello() {\n\t\treturn 'Hello!';\n\t}\n\n\t/**\n\t * Test XMLRPC API by adding two numbers for client.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int $number1 A number to add.\n\t *     @type int $number2 A second number to add.\n\t * }\n\t * @return int Sum of the two given numbers.\n\t */\n\tpublic function addTwoNumbers( $args ) {\n\t\t$number1 = $args[0];\n\t\t$number2 = $args[1];\n\t\treturn $number1 + $number2;\n\t}\n\n\t/**\n\t * Log user in.\n\t *\n\t * @since 2.8.0\n\t *\n\t * @param string $username User's username.\n\t * @param string $password User's password.\n\t * @return WP_User|bool WP_User object if authentication passed, false otherwise\n\t */\n\tpublic function login( $username, $password ) {\n\t\t/*\n\t\t * Respect old get_option() filters left for back-compat when the 'enable_xmlrpc'\n\t\t * option was deprecated in 3.5.0. Use the 'xmlrpc_enabled' hook instead.\n\t\t */\n\t\t$enabled = apply_filters( 'pre_option_enable_xmlrpc', false );\n\t\tif ( false === $enabled ) {\n\t\t\t$enabled = apply_filters( 'option_enable_xmlrpc', true );\n\t\t}\n\n\t\t/**\n\t\t * Filter whether XML-RPC is enabled.\n\t\t *\n\t\t * This is the proper filter for turning off XML-RPC.\n\t\t *\n\t\t * @since 3.5.0\n\t\t *\n\t\t * @param bool $enabled Whether XML-RPC is enabled. Default true.\n\t\t */\n\t\t$enabled = apply_filters( 'xmlrpc_enabled', $enabled );\n\n\t\tif ( ! $enabled ) {\n\t\t\t$this->error = new IXR_Error( 405, sprintf( __( 'XML-RPC services are disabled on this site.' ) ) );\n\t\t\treturn false;\n\t\t}\n\n\t\t$user = wp_authenticate($username, $password);\n\n\t\tif (is_wp_error($user)) {\n\t\t\t$this->error = new IXR_Error( 403, __( 'Incorrect username or password.' ) );\n\n\t\t\t/**\n\t\t\t * Filter the XML-RPC user login error message.\n\t\t\t *\n\t\t\t * @since 3.5.0\n\t\t\t *\n\t\t\t * @param string  $error The XML-RPC error message.\n\t\t\t * @param WP_User $user  WP_User object.\n\t\t\t */\n\t\t\t$this->error = apply_filters( 'xmlrpc_login_error', $this->error, $user );\n\t\t\treturn false;\n\t\t}\n\n\t\twp_set_current_user( $user->ID );\n\t\treturn $user;\n\t}\n\n\t/**\n\t * Check user's credentials. Deprecated.\n\t *\n\t * @since 1.5.0\n\t * @deprecated 2.8.0\n\t * @deprecated use wp_xmlrpc_server::login\n\t * @see wp_xmlrpc_server::login\n\t *\n\t * @param string $username User's username.\n\t * @param string $password User's password.\n\t * @return bool Whether authentication passed.\n\t */\n\tpublic function login_pass_ok( $username, $password ) {\n\t\treturn (bool) $this->login( $username, $password );\n\t}\n\n\t/**\n\t * Escape string or array of strings for database.\n\t *\n\t * @since 1.5.2\n\t *\n\t * @param string|array $data Escape single string or array of strings.\n\t * @return string|void Returns with string is passed, alters by-reference\n\t *                     when array is passed.\n\t */\n\tpublic function escape( &$data ) {\n\t\tif ( ! is_array( $data ) )\n\t\t\treturn wp_slash( $data );\n\n\t\tforeach ( $data as &$v ) {\n\t\t\tif ( is_array( $v ) )\n\t\t\t\t$this->escape( $v );\n\t\t\telseif ( ! is_object( $v ) )\n\t\t\t\t$v = wp_slash( $v );\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve custom fields for post.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param int $post_id Post ID.\n\t * @return array Custom fields, if exist.\n\t */\n\tpublic function get_custom_fields($post_id) {\n\t\t$post_id = (int) $post_id;\n\n\t\t$custom_fields = array();\n\n\t\tforeach ( (array) has_meta($post_id) as $meta ) {\n\t\t\t// Don't expose protected fields.\n\t\t\tif ( ! current_user_can( 'edit_post_meta', $post_id , $meta['meta_key'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$custom_fields[] = array(\n\t\t\t\t\"id\"    => $meta['meta_id'],\n\t\t\t\t\"key\"   => $meta['meta_key'],\n\t\t\t\t\"value\" => $meta['meta_value']\n\t\t\t);\n\t\t}\n\n\t\treturn $custom_fields;\n\t}\n\n\t/**\n\t * Set custom fields for post.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param int $post_id Post ID.\n\t * @param array $fields Custom fields.\n\t */\n\tpublic function set_custom_fields($post_id, $fields) {\n\t\t$post_id = (int) $post_id;\n\n\t\tforeach ( (array) $fields as $meta ) {\n\t\t\tif ( isset($meta['id']) ) {\n\t\t\t\t$meta['id'] = (int) $meta['id'];\n\t\t\t\t$pmeta = get_metadata_by_mid( 'post', $meta['id'] );\n\t\t\t\tif ( isset($meta['key']) ) {\n\t\t\t\t\t$meta['key'] = wp_unslash( $meta['key'] );\n\t\t\t\t\tif ( $meta['key'] !== $pmeta->meta_key )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t$meta['value'] = wp_unslash( $meta['value'] );\n\t\t\t\t\tif ( current_user_can( 'edit_post_meta', $post_id, $meta['key'] ) )\n\t\t\t\t\t\tupdate_metadata_by_mid( 'post', $meta['id'], $meta['value'] );\n\t\t\t\t} elseif ( current_user_can( 'delete_post_meta', $post_id, $pmeta->meta_key ) ) {\n\t\t\t\t\tdelete_metadata_by_mid( 'post', $meta['id'] );\n\t\t\t\t}\n\t\t\t} elseif ( current_user_can( 'add_post_meta', $post_id, wp_unslash( $meta['key'] ) ) ) {\n\t\t\t\tadd_post_meta( $post_id, $meta['key'], $meta['value'] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set up blog options property.\n\t *\n\t * Passes property through {@see 'xmlrpc_blog_options'} filter.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @global string $wp_version\n\t */\n\tpublic function initialise_blog_option_info() {\n\t\tglobal $wp_version;\n\n\t\t$this->blog_options = array(\n\t\t\t// Read only options\n\t\t\t'software_name'     => array(\n\t\t\t\t'desc'          => __( 'Software Name' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => 'WordPress'\n\t\t\t),\n\t\t\t'software_version'  => array(\n\t\t\t\t'desc'          => __( 'Software Version' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => $wp_version\n\t\t\t),\n\t\t\t'blog_url'          => array(\n\t\t\t\t'desc'          => __( 'WordPress Address (URL)' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'siteurl'\n\t\t\t),\n\t\t\t'home_url'          => array(\n\t\t\t\t'desc'          => __( 'Site Address (URL)' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'home'\n\t\t\t),\n\t\t\t'login_url'          => array(\n\t\t\t\t'desc'          => __( 'Login Address (URL)' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => wp_login_url( )\n\t\t\t),\n\t\t\t'admin_url'          => array(\n\t\t\t\t'desc'          => __( 'The URL to the admin area' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => get_admin_url( )\n\t\t\t),\n\t\t\t'image_default_link_type' => array(\n\t\t\t\t'desc'          => __( 'Image default link type' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'image_default_link_type'\n\t\t\t),\n\t\t\t'image_default_size' => array(\n\t\t\t\t'desc'          => __( 'Image default size' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'image_default_size'\n\t\t\t),\n\t\t\t'image_default_align' => array(\n\t\t\t\t'desc'          => __( 'Image default align' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'image_default_align'\n\t\t\t),\n\t\t\t'template'          => array(\n\t\t\t\t'desc'          => __( 'Template' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'template'\n\t\t\t),\n\t\t\t'stylesheet'        => array(\n\t\t\t\t'desc'          => __( 'Stylesheet' ),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'option'        => 'stylesheet'\n\t\t\t),\n\t\t\t'post_thumbnail'    => array(\n\t\t\t\t'desc'          => __('Post Thumbnail'),\n\t\t\t\t'readonly'      => true,\n\t\t\t\t'value'         => current_theme_supports( 'post-thumbnails' )\n\t\t\t),\n\n\t\t\t// Updatable options\n\t\t\t'time_zone'         => array(\n\t\t\t\t'desc'          => __( 'Time Zone' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'gmt_offset'\n\t\t\t),\n\t\t\t'blog_title'        => array(\n\t\t\t\t'desc'          => __( 'Site Title' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'blogname'\n\t\t\t),\n\t\t\t'blog_tagline'      => array(\n\t\t\t\t'desc'          => __( 'Site Tagline' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'blogdescription'\n\t\t\t),\n\t\t\t'date_format'       => array(\n\t\t\t\t'desc'          => __( 'Date Format' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'date_format'\n\t\t\t),\n\t\t\t'time_format'       => array(\n\t\t\t\t'desc'          => __( 'Time Format' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'time_format'\n\t\t\t),\n\t\t\t'users_can_register' => array(\n\t\t\t\t'desc'          => __( 'Allow new users to sign up' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'users_can_register'\n\t\t\t),\n\t\t\t'thumbnail_size_w'  => array(\n\t\t\t\t'desc'          => __( 'Thumbnail Width' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'thumbnail_size_w'\n\t\t\t),\n\t\t\t'thumbnail_size_h'  => array(\n\t\t\t\t'desc'          => __( 'Thumbnail Height' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'thumbnail_size_h'\n\t\t\t),\n\t\t\t'thumbnail_crop'    => array(\n\t\t\t\t'desc'          => __( 'Crop thumbnail to exact dimensions' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'thumbnail_crop'\n\t\t\t),\n\t\t\t'medium_size_w'     => array(\n\t\t\t\t'desc'          => __( 'Medium size image width' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'medium_size_w'\n\t\t\t),\n\t\t\t'medium_size_h'     => array(\n\t\t\t\t'desc'          => __( 'Medium size image height' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'medium_size_h'\n\t\t\t),\n\t\t\t'large_size_w'      => array(\n\t\t\t\t'desc'          => __( 'Large size image width' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'large_size_w'\n\t\t\t),\n\t\t\t'large_size_h'      => array(\n\t\t\t\t'desc'          => __( 'Large size image height' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'large_size_h'\n\t\t\t),\n\t\t\t'default_comment_status' => array(\n\t\t\t\t'desc'          => __( 'Allow people to post comments on new articles' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'default_comment_status'\n\t\t\t),\n\t\t\t'default_ping_status' => array(\n\t\t\t\t'desc'          => __( 'Allow link notifications from other blogs (pingbacks and trackbacks) on new articles' ),\n\t\t\t\t'readonly'      => false,\n\t\t\t\t'option'        => 'default_ping_status'\n\t\t\t)\n\t\t);\n\n\t\t/**\n\t\t * Filter the XML-RPC blog options property.\n\t\t *\n\t\t * @since 2.6.0\n\t\t *\n\t\t * @param array $blog_options An array of XML-RPC blog options.\n\t\t */\n\t\t$this->blog_options = apply_filters( 'xmlrpc_blog_options', $this->blog_options );\n\t}\n\n\t/**\n\t * Retrieve the blogs of the user.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t * }\n\t * @return array|IXR_Error Array contains:\n\t *  - 'isAdmin'\n\t *  - 'url'\n\t *  - 'blogid'\n\t *  - 'blogName'\n\t *  - 'xmlrpc' - url of xmlrpc endpoint\n\t */\n\tpublic function wp_getUsersBlogs( $args ) {\n\t\t// If this isn't on WPMU then just use blogger_getUsersBlogs\n\t\tif ( !is_multisite() ) {\n\t\t\tarray_unshift( $args, 1 );\n\t\t\treturn $this->blogger_getUsersBlogs( $args );\n\t\t}\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[0];\n\t\t$password = $args[1];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/**\n\t\t * Fires after the XML-RPC user has been authenticated but before the rest of\n\t\t * the method logic begins.\n\t\t *\n\t\t * All built-in XML-RPC methods use the action xmlrpc_call, with a parameter\n\t\t * equal to the method's name, e.g., wp.getUsersBlogs, wp.newPost, etc.\n\t\t *\n\t\t * @since 2.5.0\n\t\t *\n\t\t * @param string $name The method name.\n\t\t */\n\t\tdo_action( 'xmlrpc_call', 'wp.getUsersBlogs' );\n\n\t\t$blogs = (array) get_blogs_of_user( $user->ID );\n\t\t$struct = array();\n\n\t\tforeach ( $blogs as $blog ) {\n\t\t\t// Don't include blogs that aren't hosted at this site.\n\t\t\tif ( $blog->site_id != get_current_site()->id )\n\t\t\t\tcontinue;\n\n\t\t\t$blog_id = $blog->userblog_id;\n\n\t\t\tswitch_to_blog( $blog_id );\n\n\t\t\t$is_admin = current_user_can( 'manage_options' );\n\n\t\t\t$struct[] = array(\n\t\t\t\t'isAdmin'\t\t=> $is_admin,\n\t\t\t\t'url'\t\t\t=> home_url( '/' ),\n\t\t\t\t'blogid'\t\t=> (string) $blog_id,\n\t\t\t\t'blogName'\t\t=> get_option( 'blogname' ),\n\t\t\t\t'xmlrpc'\t\t=> site_url( 'xmlrpc.php', 'rpc' ),\n\t\t\t);\n\n\t\t\trestore_current_blog();\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Checks if the method received at least the minimum number of arguments.\n\t *\n\t * @since 3.4.0\n\t * @access protected\n\t *\n\t * @param string|array $args Sanitize single string or array of strings.\n\t * @param int $count         Minimum number of arguments.\n\t * @return bool if `$args` contains at least $count arguments.\n\t */\n\tprotected function minimum_args( $args, $count ) {\n\t\tif ( count( $args ) < $count ) {\n\t\t\t$this->error = new IXR_Error( 400, __( 'Insufficient arguments passed to this XML-RPC method.' ) );\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Prepares taxonomy data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $taxonomy The unprepared taxonomy data.\n\t * @param array $fields    The subset of taxonomy fields to return.\n\t * @return array The prepared taxonomy data.\n\t */\n\tprotected function _prepare_taxonomy( $taxonomy, $fields ) {\n\t\t$_taxonomy = array(\n\t\t\t'name' => $taxonomy->name,\n\t\t\t'label' => $taxonomy->label,\n\t\t\t'hierarchical' => (bool) $taxonomy->hierarchical,\n\t\t\t'public' => (bool) $taxonomy->public,\n\t\t\t'show_ui' => (bool) $taxonomy->show_ui,\n\t\t\t'_builtin' => (bool) $taxonomy->_builtin,\n\t\t);\n\n\t\tif ( in_array( 'labels', $fields ) )\n\t\t\t$_taxonomy['labels'] = (array) $taxonomy->labels;\n\n\t\tif ( in_array( 'cap', $fields ) )\n\t\t\t$_taxonomy['cap'] = (array) $taxonomy->cap;\n\n\t\tif ( in_array( 'menu', $fields ) )\n\t\t\t$_taxonomy['show_in_menu'] = (bool) $_taxonomy->show_in_menu;\n\n\t\tif ( in_array( 'object_type', $fields ) )\n\t\t\t$_taxonomy['object_type'] = array_unique( (array) $taxonomy->object_type );\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given taxonomy.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array  $_taxonomy An array of taxonomy data.\n\t\t * @param object $taxonomy  Taxonomy object.\n\t\t * @param array  $fields    The subset of taxonomy fields to return.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_taxonomy', $_taxonomy, $taxonomy, $fields );\n\t}\n\n\t/**\n\t * Prepares term data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param array|object $term The unprepared term data.\n\t * @return array The prepared term data.\n\t */\n\tprotected function _prepare_term( $term ) {\n\t\t$_term = $term;\n\t\tif ( ! is_array( $_term ) )\n\t\t\t$_term = get_object_vars( $_term );\n\n\t\t// For integers which may be larger than XML-RPC supports ensure we return strings.\n\t\t$_term['term_id'] = strval( $_term['term_id'] );\n\t\t$_term['term_group'] = strval( $_term['term_group'] );\n\t\t$_term['term_taxonomy_id'] = strval( $_term['term_taxonomy_id'] );\n\t\t$_term['parent'] = strval( $_term['parent'] );\n\n\t\t// Count we are happy to return as an integer because people really shouldn't use terms that much.\n\t\t$_term['count'] = intval( $_term['count'] );\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given term.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array        $_term An array of term data.\n\t\t * @param array|object $term  Term object or array.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_term', $_term, $term );\n\t}\n\n\t/**\n\t * Convert a WordPress date string to an IXR_Date object.\n\t *\n\t * @access protected\n\t *\n\t * @param string $date Date string to convert.\n\t * @return IXR_Date IXR_Date object.\n\t */\n\tprotected function _convert_date( $date ) {\n\t\tif ( $date === '0000-00-00 00:00:00' ) {\n\t\t\treturn new IXR_Date( '00000000T00:00:00Z' );\n\t\t}\n\t\treturn new IXR_Date( mysql2date( 'Ymd\\TH:i:s', $date, false ) );\n\t}\n\n\t/**\n\t * Convert a WordPress GMT date string to an IXR_Date object.\n\t *\n\t * @access protected\n\t *\n\t * @param string $date_gmt WordPress GMT date string.\n\t * @param string $date     Date string.\n\t * @return IXR_Date IXR_Date object.\n\t */\n\tprotected function _convert_date_gmt( $date_gmt, $date ) {\n\t\tif ( $date !== '0000-00-00 00:00:00' && $date_gmt === '0000-00-00 00:00:00' ) {\n\t\t\treturn new IXR_Date( get_gmt_from_date( mysql2date( 'Y-m-d H:i:s', $date, false ), 'Ymd\\TH:i:s' ) );\n\t\t}\n\t\treturn $this->_convert_date( $date_gmt );\n\t}\n\n\t/**\n\t * Prepares post data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param array $post   The unprepared post data.\n\t * @param array $fields The subset of post type fields to return.\n\t * @return array The prepared post data.\n\t */\n\tprotected function _prepare_post( $post, $fields ) {\n\t\t// Holds the data for this post. built up based on $fields.\n\t\t$_post = array( 'post_id' => strval( $post['ID'] ) );\n\n\t\t// Prepare common post fields.\n\t\t$post_fields = array(\n\t\t\t'post_title'        => $post['post_title'],\n\t\t\t'post_date'         => $this->_convert_date( $post['post_date'] ),\n\t\t\t'post_date_gmt'     => $this->_convert_date_gmt( $post['post_date_gmt'], $post['post_date'] ),\n\t\t\t'post_modified'     => $this->_convert_date( $post['post_modified'] ),\n\t\t\t'post_modified_gmt' => $this->_convert_date_gmt( $post['post_modified_gmt'], $post['post_modified'] ),\n\t\t\t'post_status'       => $post['post_status'],\n\t\t\t'post_type'         => $post['post_type'],\n\t\t\t'post_name'         => $post['post_name'],\n\t\t\t'post_author'       => $post['post_author'],\n\t\t\t'post_password'     => $post['post_password'],\n\t\t\t'post_excerpt'      => $post['post_excerpt'],\n\t\t\t'post_content'      => $post['post_content'],\n\t\t\t'post_parent'       => strval( $post['post_parent'] ),\n\t\t\t'post_mime_type'    => $post['post_mime_type'],\n\t\t\t'link'              => post_permalink( $post['ID'] ),\n\t\t\t'guid'              => $post['guid'],\n\t\t\t'menu_order'        => intval( $post['menu_order'] ),\n\t\t\t'comment_status'    => $post['comment_status'],\n\t\t\t'ping_status'       => $post['ping_status'],\n\t\t\t'sticky'            => ( $post['post_type'] === 'post' && is_sticky( $post['ID'] ) ),\n\t\t);\n\n\t\t// Thumbnail.\n\t\t$post_fields['post_thumbnail'] = array();\n\t\t$thumbnail_id = get_post_thumbnail_id( $post['ID'] );\n\t\tif ( $thumbnail_id ) {\n\t\t\t$thumbnail_size = current_theme_supports('post-thumbnail') ? 'post-thumbnail' : 'thumbnail';\n\t\t\t$post_fields['post_thumbnail'] = $this->_prepare_media_item( get_post( $thumbnail_id ), $thumbnail_size );\n\t\t}\n\n\t\t// Consider future posts as published.\n\t\tif ( $post_fields['post_status'] === 'future' )\n\t\t\t$post_fields['post_status'] = 'publish';\n\n\t\t// Fill in blank post format.\n\t\t$post_fields['post_format'] = get_post_format( $post['ID'] );\n\t\tif ( empty( $post_fields['post_format'] ) )\n\t\t\t$post_fields['post_format'] = 'standard';\n\n\t\t// Merge requested $post_fields fields into $_post.\n\t\tif ( in_array( 'post', $fields ) ) {\n\t\t\t$_post = array_merge( $_post, $post_fields );\n\t\t} else {\n\t\t\t$requested_fields = array_intersect_key( $post_fields, array_flip( $fields ) );\n\t\t\t$_post = array_merge( $_post, $requested_fields );\n\t\t}\n\n\t\t$all_taxonomy_fields = in_array( 'taxonomies', $fields );\n\n\t\tif ( $all_taxonomy_fields || in_array( 'terms', $fields ) ) {\n\t\t\t$post_type_taxonomies = get_object_taxonomies( $post['post_type'], 'names' );\n\t\t\t$terms = wp_get_object_terms( $post['ID'], $post_type_taxonomies );\n\t\t\t$_post['terms'] = array();\n\t\t\tforeach ( $terms as $term ) {\n\t\t\t\t$_post['terms'][] = $this->_prepare_term( $term );\n\t\t\t}\n\t\t}\n\n\t\tif ( in_array( 'custom_fields', $fields ) )\n\t\t\t$_post['custom_fields'] = $this->get_custom_fields( $post['ID'] );\n\n\t\tif ( in_array( 'enclosure', $fields ) ) {\n\t\t\t$_post['enclosure'] = array();\n\t\t\t$enclosures = (array) get_post_meta( $post['ID'], 'enclosure' );\n\t\t\tif ( ! empty( $enclosures ) ) {\n\t\t\t\t$encdata = explode( \"\\n\", $enclosures[0] );\n\t\t\t\t$_post['enclosure']['url'] = trim( htmlspecialchars( $encdata[0] ) );\n\t\t\t\t$_post['enclosure']['length'] = (int) trim( $encdata[1] );\n\t\t\t\t$_post['enclosure']['type'] = trim( $encdata[2] );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared date for the given post.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array $_post  An array of modified post data.\n\t\t * @param array $post   An array of post data.\n\t\t * @param array $fields An array of post fields.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_post', $_post, $post, $fields );\n\t}\n\n\t/**\n\t * Prepares post data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $post_type Post type object.\n\t * @param array  $fields    The subset of post fields to return.\n\t * @return array The prepared post type data.\n\t */\n\tprotected function _prepare_post_type( $post_type, $fields ) {\n\t\t$_post_type = array(\n\t\t\t'name' => $post_type->name,\n\t\t\t'label' => $post_type->label,\n\t\t\t'hierarchical' => (bool) $post_type->hierarchical,\n\t\t\t'public' => (bool) $post_type->public,\n\t\t\t'show_ui' => (bool) $post_type->show_ui,\n\t\t\t'_builtin' => (bool) $post_type->_builtin,\n\t\t\t'has_archive' => (bool) $post_type->has_archive,\n\t\t\t'supports' => get_all_post_type_supports( $post_type->name ),\n\t\t);\n\n\t\tif ( in_array( 'labels', $fields ) ) {\n\t\t\t$_post_type['labels'] = (array) $post_type->labels;\n\t\t}\n\n\t\tif ( in_array( 'cap', $fields ) ) {\n\t\t\t$_post_type['cap'] = (array) $post_type->cap;\n\t\t\t$_post_type['map_meta_cap'] = (bool) $post_type->map_meta_cap;\n\t\t}\n\n\t\tif ( in_array( 'menu', $fields ) ) {\n\t\t\t$_post_type['menu_position'] = (int) $post_type->menu_position;\n\t\t\t$_post_type['menu_icon'] = $post_type->menu_icon;\n\t\t\t$_post_type['show_in_menu'] = (bool) $post_type->show_in_menu;\n\t\t}\n\n\t\tif ( in_array( 'taxonomies', $fields ) )\n\t\t\t$_post_type['taxonomies'] = get_object_taxonomies( $post_type->name, 'names' );\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared date for the given post type.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array  $_post_type An array of post type data.\n\t\t * @param object $post_type  Post type object.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_post_type', $_post_type, $post_type );\n\t}\n\n\t/**\n\t * Prepares media item data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $media_item     The unprepared media item data.\n\t * @param string $thumbnail_size The image size to use for the thumbnail URL.\n\t * @return array The prepared media item data.\n\t */\n\tprotected function _prepare_media_item( $media_item, $thumbnail_size = 'thumbnail' ) {\n\t\t$_media_item = array(\n\t\t\t'attachment_id'    => strval( $media_item->ID ),\n\t\t\t'date_created_gmt' => $this->_convert_date_gmt( $media_item->post_date_gmt, $media_item->post_date ),\n\t\t\t'parent'           => $media_item->post_parent,\n\t\t\t'link'             => wp_get_attachment_url( $media_item->ID ),\n\t\t\t'title'            => $media_item->post_title,\n\t\t\t'caption'          => $media_item->post_excerpt,\n\t\t\t'description'      => $media_item->post_content,\n\t\t\t'metadata'         => wp_get_attachment_metadata( $media_item->ID ),\n\t\t);\n\n\t\t$thumbnail_src = image_downsize( $media_item->ID, $thumbnail_size );\n\t\tif ( $thumbnail_src )\n\t\t\t$_media_item['thumbnail'] = $thumbnail_src[0];\n\t\telse\n\t\t\t$_media_item['thumbnail'] = $_media_item['link'];\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given media item.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array  $_media_item    An array of media item data.\n\t\t * @param object $media_item     Media item object.\n\t\t * @param string $thumbnail_size Image size.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_media_item', $_media_item, $media_item, $thumbnail_size );\n\t}\n\n\t/**\n\t * Prepares page data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $page The unprepared page data.\n\t * @return array The prepared page data.\n\t */\n\tprotected function _prepare_page( $page ) {\n\t\t// Get all of the page content and link.\n\t\t$full_page = get_extended( $page->post_content );\n\t\t$link = post_permalink( $page->ID );\n\n\t\t// Get info the page parent if there is one.\n\t\t$parent_title = \"\";\n\t\tif ( ! empty( $page->post_parent ) ) {\n\t\t\t$parent = get_post( $page->post_parent );\n\t\t\t$parent_title = $parent->post_title;\n\t\t}\n\n\t\t// Determine comment and ping settings.\n\t\t$allow_comments = comments_open( $page->ID ) ? 1 : 0;\n\t\t$allow_pings = pings_open( $page->ID ) ? 1 : 0;\n\n\t\t// Format page date.\n\t\t$page_date = $this->_convert_date( $page->post_date );\n\t\t$page_date_gmt = $this->_convert_date_gmt( $page->post_date_gmt, $page->post_date );\n\n\t\t// Pull the categories info together.\n\t\t$categories = array();\n\t\tif ( is_object_in_taxonomy( 'page', 'category' ) ) {\n\t\t\tforeach ( wp_get_post_categories( $page->ID ) as $cat_id ) {\n\t\t\t\t$categories[] = get_cat_name( $cat_id );\n\t\t\t}\n\t\t}\n\n\t\t// Get the author info.\n\t\t$author = get_userdata( $page->post_author );\n\n\t\t$page_template = get_page_template_slug( $page->ID );\n\t\tif ( empty( $page_template ) )\n\t\t\t$page_template = 'default';\n\n\t\t$_page = array(\n\t\t\t'dateCreated'            => $page_date,\n\t\t\t'userid'                 => $page->post_author,\n\t\t\t'page_id'                => $page->ID,\n\t\t\t'page_status'            => $page->post_status,\n\t\t\t'description'            => $full_page['main'],\n\t\t\t'title'                  => $page->post_title,\n\t\t\t'link'                   => $link,\n\t\t\t'permaLink'              => $link,\n\t\t\t'categories'             => $categories,\n\t\t\t'excerpt'                => $page->post_excerpt,\n\t\t\t'text_more'              => $full_page['extended'],\n\t\t\t'mt_allow_comments'      => $allow_comments,\n\t\t\t'mt_allow_pings'         => $allow_pings,\n\t\t\t'wp_slug'                => $page->post_name,\n\t\t\t'wp_password'            => $page->post_password,\n\t\t\t'wp_author'              => $author->display_name,\n\t\t\t'wp_page_parent_id'      => $page->post_parent,\n\t\t\t'wp_page_parent_title'   => $parent_title,\n\t\t\t'wp_page_order'          => $page->menu_order,\n\t\t\t'wp_author_id'           => (string) $author->ID,\n\t\t\t'wp_author_display_name' => $author->display_name,\n\t\t\t'date_created_gmt'       => $page_date_gmt,\n\t\t\t'custom_fields'          => $this->get_custom_fields( $page->ID ),\n\t\t\t'wp_page_template'       => $page_template\n\t\t);\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given page.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array   $_page An array of page data.\n\t\t * @param WP_Post $page  Page object.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_page', $_page, $page );\n\t}\n\n\t/**\n\t * Prepares comment data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param object $comment The unprepared comment data.\n\t * @return array The prepared comment data.\n\t */\n\tprotected function _prepare_comment( $comment ) {\n\t\t// Format page date.\n\t\t$comment_date_gmt = $this->_convert_date_gmt( $comment->comment_date_gmt, $comment->comment_date );\n\n\t\tif ( '0' == $comment->comment_approved ) {\n\t\t\t$comment_status = 'hold';\n\t\t} elseif ( 'spam' == $comment->comment_approved ) {\n\t\t\t$comment_status = 'spam';\n\t\t} elseif ( '1' == $comment->comment_approved ) {\n\t\t\t$comment_status = 'approve';\n\t\t} else {\n\t\t\t$comment_status = $comment->comment_approved;\n\t\t}\n\t\t$_comment = array(\n\t\t\t'date_created_gmt' => $comment_date_gmt,\n\t\t\t'user_id'          => $comment->user_id,\n\t\t\t'comment_id'       => $comment->comment_ID,\n\t\t\t'parent'           => $comment->comment_parent,\n\t\t\t'status'           => $comment_status,\n\t\t\t'content'          => $comment->comment_content,\n\t\t\t'link'             => get_comment_link($comment),\n\t\t\t'post_id'          => $comment->comment_post_ID,\n\t\t\t'post_title'       => get_the_title($comment->comment_post_ID),\n\t\t\t'author'           => $comment->comment_author,\n\t\t\t'author_url'       => $comment->comment_author_url,\n\t\t\t'author_email'     => $comment->comment_author_email,\n\t\t\t'author_ip'        => $comment->comment_author_IP,\n\t\t\t'type'             => $comment->comment_type,\n\t\t);\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given comment.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array  $_comment An array of prepared comment data.\n\t\t * @param object $comment  Comment object.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_comment', $_comment, $comment );\n\t}\n\n\t/**\n\t * Prepares user data for return in an XML-RPC object.\n\t *\n\t * @access protected\n\t *\n\t * @param WP_User $user   The unprepared user object.\n\t * @param array   $fields The subset of user fields to return.\n\t * @return array The prepared user data.\n\t */\n\tprotected function _prepare_user( $user, $fields ) {\n\t\t$_user = array( 'user_id' => strval( $user->ID ) );\n\n\t\t$user_fields = array(\n\t\t\t'username'          => $user->user_login,\n\t\t\t'first_name'        => $user->user_firstname,\n\t\t\t'last_name'         => $user->user_lastname,\n\t\t\t'registered'        => $this->_convert_date( $user->user_registered ),\n\t\t\t'bio'               => $user->user_description,\n\t\t\t'email'             => $user->user_email,\n\t\t\t'nickname'          => $user->nickname,\n\t\t\t'nicename'          => $user->user_nicename,\n\t\t\t'url'               => $user->user_url,\n\t\t\t'display_name'      => $user->display_name,\n\t\t\t'roles'             => $user->roles,\n\t\t);\n\n\t\tif ( in_array( 'all', $fields ) ) {\n\t\t\t$_user = array_merge( $_user, $user_fields );\n\t\t} else {\n\t\t\tif ( in_array( 'basic', $fields ) ) {\n\t\t\t\t$basic_fields = array( 'username', 'email', 'registered', 'display_name', 'nicename' );\n\t\t\t\t$fields = array_merge( $fields, $basic_fields );\n\t\t\t}\n\t\t\t$requested_fields = array_intersect_key( $user_fields, array_flip( $fields ) );\n\t\t\t$_user = array_merge( $_user, $requested_fields );\n\t\t}\n\n\t\t/**\n\t\t * Filter XML-RPC-prepared data for the given user.\n\t\t *\n\t\t * @since 3.5.0\n\t\t *\n\t\t * @param array   $_user  An array of user data.\n\t\t * @param WP_User $user   User object.\n\t\t * @param array   $fields An array of user fields.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_prepare_user', $_user, $user, $fields );\n\t}\n\n\t/**\n\t * Create a new post for any registered post type.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @link http://en.wikipedia.org/wiki/RSS_enclosure for information on RSS enclosures.\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: top-level arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id        Blog ID (unused).\n\t *     @type string $username       Username.\n\t *     @type string $password       Password.\n\t *     @type array  $content_struct {\n\t *         Content struct for adding a new post. See wp_insert_post() for information on\n\t *         additional post fields\n\t *\n\t *         @type string $post_type      Post type. Default 'post'.\n\t *         @type string $post_status    Post status. Default 'draft'\n\t *         @type string $post_title     Post title.\n\t *         @type int    $post_author    Post author ID.\n\t *         @type string $post_excerpt   Post excerpt.\n\t *         @type string $post_content   Post content.\n\t *         @type string $post_date_gmt  Post date in GMT.\n\t *         @type string $post_date      Post date.\n\t *         @type string $post_password  Post password (20-character limit).\n\t *         @type string $comment_status Post comment enabled status. Accepts 'open' or 'closed'.\n\t *         @type string $ping_status    Post ping status. Accepts 'open' or 'closed'.\n\t *         @type bool   $sticky         Whether the post should be sticky. Automatically false if\n\t *                                      `$post_status` is 'private'.\n\t *         @type int    $post_thumbnail ID of an image to use as the post thumbnail/featured image.\n\t *         @type array  $custom_fields  Array of meta key/value pairs to add to the post.\n\t *         @type array  $terms          Associative array with taxonomy names as keys and arrays\n\t *                                      of term IDs as values.\n\t *         @type array  $terms_names    Associative array with taxonomy names as keys and arrays\n\t *                                      of term names as values.\n\t *         @type array  $enclosure      {\n\t *             Array of feed enclosure data to add to post meta.\n\t *\n\t *             @type string $url    URL for the feed enclosure.\n\t *             @type int    $length Size in bytes of the enclosure.\n\t *             @type string $type   Mime-type for the enclosure.\n\t *         }\n\t *     }\n\t * }\n\t * @return int|IXR_Error Post ID on success, IXR_Error instance otherwise.\n\t */\n\tpublic function wp_newPost( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t// convert the date field back to IXR form\n\t\tif ( isset( $content_struct['post_date'] ) && ! ( $content_struct['post_date'] instanceof IXR_Date ) ) {\n\t\t\t$content_struct['post_date'] = $this->_convert_date( $content_struct['post_date'] );\n\t\t}\n\n\t\t// ignore the existing GMT date if it is empty or a non-GMT date was supplied in $content_struct,\n\t\t// since _insert_post will ignore the non-GMT date if the GMT date is set\n\t\tif ( isset( $content_struct['post_date_gmt'] ) && ! ( $content_struct['post_date_gmt'] instanceof IXR_Date ) ) {\n\t\t\tif ( $content_struct['post_date_gmt'] == '0000-00-00 00:00:00' || isset( $content_struct['post_date'] ) ) {\n\t\t\t\tunset( $content_struct['post_date_gmt'] );\n\t\t\t} else {\n\t\t\t\t$content_struct['post_date_gmt'] = $this->_convert_date( $content_struct['post_date_gmt'] );\n\t\t\t}\n\t\t}\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newPost' );\n\n\t\tunset( $content_struct['ID'] );\n\n\t\treturn $this->_insert_post( $user, $content_struct );\n\t}\n\n\t/**\n\t * Helper method for filtering out elements from an array.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param int $count Number to compare to one.\n\t */\n\tprivate function _is_greater_than_one( $count ) {\n\t\treturn $count > 1;\n\t}\n\n\t/**\n\t * Encapsulate the logic for sticking a post\n\t * and determining if the user has permission to do so\n\t *\n\t * @since 4.3.0\n\t * @access private\n\t *\n\t * @param array $post_data\n\t * @param bool  $update\n\t * @return void|IXR_Error\n\t */\n\tprivate function _toggle_sticky( $post_data, $update = false ) {\n\t\t$post_type = get_post_type_object( $post_data['post_type'] );\n\n\t\t// Private and password-protected posts cannot be stickied.\n\t\tif ( 'private' === $post_data['post_status'] || ! empty( $post_data['post_password'] ) ) {\n\t\t\t// Error if the client tried to stick the post, otherwise, silently unstick.\n\t\t\tif ( ! empty( $post_data['sticky'] ) ) {\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot stick a private post.' ) );\n\t\t\t}\n\n\t\t\tif ( $update ) {\n\t\t\t\tunstick_post( $post_data['ID'] );\n\t\t\t}\n\t\t} elseif ( isset( $post_data['sticky'] ) )  {\n\t\t\tif ( ! current_user_can( $post_type->cap->edit_others_posts ) ) {\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to stick this post.' ) );\n\t\t\t}\n\n\t\t\t$sticky = wp_validate_boolean( $post_data['sticky'] );\n\t\t\tif ( $sticky ) {\n\t\t\t\tstick_post( $post_data['ID'] );\n\t\t\t} else {\n\t\t\t\tunstick_post( $post_data['ID'] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method for wp_newPost() and wp_editPost(), containing shared logic.\n\t *\n\t * @since 3.4.0\n\t * @access protected\n\t *\n\t * @see wp_insert_post()\n\t *\n\t * @param WP_User         $user           The post author if post_author isn't set in $content_struct.\n\t * @param array|IXR_Error $content_struct Post data to insert.\n\t * @return IXR_Error|string\n\t */\n\tprotected function _insert_post( $user, $content_struct ) {\n\t\t$defaults = array( 'post_status' => 'draft', 'post_type' => 'post', 'post_author' => 0,\n\t\t\t'post_password' => '', 'post_excerpt' => '', 'post_content' => '', 'post_title' => '' );\n\n\t\t$post_data = wp_parse_args( $content_struct, $defaults );\n\n\t\t$post_type = get_post_type_object( $post_data['post_type'] );\n\t\tif ( ! $post_type )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid post type' ) );\n\n\t\t$update = ! empty( $post_data['ID'] );\n\n\t\tif ( $update ) {\n\t\t\tif ( ! get_post( $post_data['ID'] ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Invalid post ID.' ) );\n\t\t\tif ( ! current_user_can( 'edit_post', $post_data['ID'] ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to edit this post.' ) );\n\t\t\tif ( $post_data['post_type'] != get_post_type( $post_data['ID'] ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'The post type may not be changed.' ) );\n\t\t} else {\n\t\t\tif ( ! current_user_can( $post_type->cap->create_posts ) || ! current_user_can( $post_type->cap->edit_posts ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to post on this site.' ) );\n\t\t}\n\n\t\tswitch ( $post_data['post_status'] ) {\n\t\t\tcase 'draft':\n\t\t\tcase 'pending':\n\t\t\t\tbreak;\n\t\t\tcase 'private':\n\t\t\t\tif ( ! current_user_can( $post_type->cap->publish_posts ) )\n\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to create private posts in this post type' ) );\n\t\t\t\tbreak;\n\t\t\tcase 'publish':\n\t\t\tcase 'future':\n\t\t\t\tif ( ! current_user_can( $post_type->cap->publish_posts ) )\n\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to publish posts in this post type' ) );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ( ! get_post_status_object( $post_data['post_status'] ) )\n\t\t\t\t\t$post_data['post_status'] = 'draft';\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( ! empty( $post_data['post_password'] ) && ! current_user_can( $post_type->cap->publish_posts ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to create password protected posts in this post type' ) );\n\n\t\t$post_data['post_author'] = absint( $post_data['post_author'] );\n\t\tif ( ! empty( $post_data['post_author'] ) && $post_data['post_author'] != $user->ID ) {\n\t\t\tif ( ! current_user_can( $post_type->cap->edit_others_posts ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to create posts as this user.' ) );\n\n\t\t\t$author = get_userdata( $post_data['post_author'] );\n\n\t\t\tif ( ! $author )\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid author ID.' ) );\n\t\t} else {\n\t\t\t$post_data['post_author'] = $user->ID;\n\t\t}\n\n\t\tif ( isset( $post_data['comment_status'] ) && $post_data['comment_status'] != 'open' && $post_data['comment_status'] != 'closed' )\n\t\t\tunset( $post_data['comment_status'] );\n\n\t\tif ( isset( $post_data['ping_status'] ) && $post_data['ping_status'] != 'open' && $post_data['ping_status'] != 'closed' )\n\t\t\tunset( $post_data['ping_status'] );\n\n\t\t// Do some timestamp voodoo.\n\t\tif ( ! empty( $post_data['post_date_gmt'] ) ) {\n\t\t\t// We know this is supposed to be GMT, so we're going to slap that Z on there by force.\n\t\t\t$dateCreated = rtrim( $post_data['post_date_gmt']->getIso(), 'Z' ) . 'Z';\n\t\t} elseif ( ! empty( $post_data['post_date'] ) ) {\n\t\t\t$dateCreated = $post_data['post_date']->getIso();\n\t\t}\n\n\t\tif ( ! empty( $dateCreated ) ) {\n\t\t\t$post_data['post_date'] = get_date_from_gmt( iso8601_to_datetime( $dateCreated ) );\n\t\t\t$post_data['post_date_gmt'] = iso8601_to_datetime( $dateCreated, 'GMT' );\n\t\t}\n\n\t\tif ( ! isset( $post_data['ID'] ) )\n\t\t\t$post_data['ID'] = get_default_post_to_edit( $post_data['post_type'], true )->ID;\n\t\t$post_ID = $post_data['ID'];\n\n\t\tif ( $post_data['post_type'] == 'post' ) {\n\t\t\t$error = $this->_toggle_sticky( $post_data, $update );\n\t\t\tif ( $error ) {\n\t\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $post_data['post_thumbnail'] ) ) {\n\t\t\t// empty value deletes, non-empty value adds/updates.\n\t\t\tif ( ! $post_data['post_thumbnail'] )\n\t\t\t\tdelete_post_thumbnail( $post_ID );\n\t\t\telseif ( ! get_post( absint( $post_data['post_thumbnail'] ) ) )\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid attachment ID.' ) );\n\t\t\tset_post_thumbnail( $post_ID, $post_data['post_thumbnail'] );\n\t\t\tunset( $content_struct['post_thumbnail'] );\n\t\t}\n\n\t\tif ( isset( $post_data['custom_fields'] ) )\n\t\t\t$this->set_custom_fields( $post_ID, $post_data['custom_fields'] );\n\n\t\tif ( isset( $post_data['terms'] ) || isset( $post_data['terms_names'] ) ) {\n\t\t\t$post_type_taxonomies = get_object_taxonomies( $post_data['post_type'], 'objects' );\n\n\t\t\t// Accumulate term IDs from terms and terms_names.\n\t\t\t$terms = array();\n\n\t\t\t// First validate the terms specified by ID.\n\t\t\tif ( isset( $post_data['terms'] ) && is_array( $post_data['terms'] ) ) {\n\t\t\t\t$taxonomies = array_keys( $post_data['terms'] );\n\n\t\t\t\t// Validating term ids.\n\t\t\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t\t\tif ( ! array_key_exists( $taxonomy , $post_type_taxonomies ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, one of the given taxonomies is not supported by the post type.' ) );\n\n\t\t\t\t\tif ( ! current_user_can( $post_type_taxonomies[$taxonomy]->cap->assign_terms ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to assign a term to one of the given taxonomies.' ) );\n\n\t\t\t\t\t$term_ids = $post_data['terms'][$taxonomy];\n\t\t\t\t\t$terms[ $taxonomy ] = array();\n\t\t\t\t\tforeach ( $term_ids as $term_id ) {\n\t\t\t\t\t\t$term = get_term_by( 'id', $term_id, $taxonomy );\n\n\t\t\t\t\t\tif ( ! $term )\n\t\t\t\t\t\t\treturn new IXR_Error( 403, __( 'Invalid term ID' ) );\n\n\t\t\t\t\t\t$terms[$taxonomy][] = (int) $term_id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now validate terms specified by name.\n\t\t\tif ( isset( $post_data['terms_names'] ) && is_array( $post_data['terms_names'] ) ) {\n\t\t\t\t$taxonomies = array_keys( $post_data['terms_names'] );\n\n\t\t\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t\t\tif ( ! array_key_exists( $taxonomy , $post_type_taxonomies ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, one of the given taxonomies is not supported by the post type.' ) );\n\n\t\t\t\t\tif ( ! current_user_can( $post_type_taxonomies[$taxonomy]->cap->assign_terms ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to assign a term to one of the given taxonomies.' ) );\n\n\t\t\t\t\t/*\n\t\t\t\t\t * For hierarchical taxonomies, we can't assign a term when multiple terms\n\t\t\t\t\t * in the hierarchy share the same name.\n\t\t\t\t\t */\n\t\t\t\t\t$ambiguous_terms = array();\n\t\t\t\t\tif ( is_taxonomy_hierarchical( $taxonomy ) ) {\n\t\t\t\t\t\t$tax_term_names = get_terms( $taxonomy, array( 'fields' => 'names', 'hide_empty' => false ) );\n\n\t\t\t\t\t\t// Count the number of terms with the same name.\n\t\t\t\t\t\t$tax_term_names_count = array_count_values( $tax_term_names );\n\n\t\t\t\t\t\t// Filter out non-ambiguous term names.\n\t\t\t\t\t\t$ambiguous_tax_term_counts = array_filter( $tax_term_names_count, array( $this, '_is_greater_than_one') );\n\n\t\t\t\t\t\t$ambiguous_terms = array_keys( $ambiguous_tax_term_counts );\n\t\t\t\t\t}\n\n\t\t\t\t\t$term_names = $post_data['terms_names'][$taxonomy];\n\t\t\t\t\tforeach ( $term_names as $term_name ) {\n\t\t\t\t\t\tif ( in_array( $term_name, $ambiguous_terms ) )\n\t\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Ambiguous term name used in a hierarchical taxonomy. Please use term ID instead.' ) );\n\n\t\t\t\t\t\t$term = get_term_by( 'name', $term_name, $taxonomy );\n\n\t\t\t\t\t\tif ( ! $term ) {\n\t\t\t\t\t\t\t// Term doesn't exist, so check that the user is allowed to create new terms.\n\t\t\t\t\t\t\tif ( ! current_user_can( $post_type_taxonomies[$taxonomy]->cap->edit_terms ) )\n\t\t\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to add a term to one of the given taxonomies.' ) );\n\n\t\t\t\t\t\t\t// Create the new term.\n\t\t\t\t\t\t\t$term_info = wp_insert_term( $term_name, $taxonomy );\n\t\t\t\t\t\t\tif ( is_wp_error( $term_info ) )\n\t\t\t\t\t\t\t\treturn new IXR_Error( 500, $term_info->get_error_message() );\n\n\t\t\t\t\t\t\t$terms[$taxonomy][] = (int) $term_info['term_id'];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$terms[$taxonomy][] = (int) $term->term_id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$post_data['tax_input'] = $terms;\n\t\t\tunset( $post_data['terms'], $post_data['terms_names'] );\n\t\t} else {\n\t\t\t// Do not allow direct submission of 'tax_input', clients must use 'terms' and/or 'terms_names'.\n\t\t\tunset( $post_data['tax_input'], $post_data['post_category'], $post_data['tags_input'] );\n\t\t}\n\n\t\tif ( isset( $post_data['post_format'] ) ) {\n\t\t\t$format = set_post_format( $post_ID, $post_data['post_format'] );\n\n\t\t\tif ( is_wp_error( $format ) )\n\t\t\t\treturn new IXR_Error( 500, $format->get_error_message() );\n\n\t\t\tunset( $post_data['post_format'] );\n\t\t}\n\n\t\t// Handle enclosures.\n\t\t$enclosure = isset( $post_data['enclosure'] ) ? $post_data['enclosure'] : null;\n\t\t$this->add_enclosure_if_new( $post_ID, $enclosure );\n\n\t\t$this->attach_uploads( $post_ID, $post_data['post_content'] );\n\n\t\t/**\n\t\t * Filter post data array to be inserted via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param array $post_data      Parsed array of post data.\n\t\t * @param array $content_struct Post data array.\n\t\t */\n\t\t$post_data = apply_filters( 'xmlrpc_wp_insert_post_data', $post_data, $content_struct );\n\n\t\t$post_ID = $update ? wp_update_post( $post_data, true ) : wp_insert_post( $post_data, true );\n\t\tif ( is_wp_error( $post_ID ) )\n\t\t\treturn new IXR_Error( 500, $post_ID->get_error_message() );\n\n\t\tif ( ! $post_ID )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, your entry could not be posted. Something wrong happened.' ) );\n\n\t\treturn strval( $post_ID );\n\t}\n\n\t/**\n\t * Edit a post for any registered post type.\n\t *\n\t * The $content_struct parameter only needs to contain fields that\n\t * should be changed. All other fields will retain their existing values.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id        Blog ID (unused).\n\t *     @type string $username       Username.\n\t *     @type string $password       Password.\n\t *     @type int    $post_id        Post ID.\n\t *     @type array  $content_struct Extra content arguments.\n\t * }\n\t * @return true|IXR_Error True on success, IXR_Error on failure.\n\t */\n\tpublic function wp_editPost( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 5 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$post_id        = (int) $args[3];\n\t\t$content_struct = $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editPost' );\n\n\t\t$post = get_post( $post_id, ARRAY_A );\n\n\t\tif ( empty( $post['ID'] ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( isset( $content_struct['if_not_modified_since'] ) ) {\n\t\t\t// If the post has been modified since the date provided, return an error.\n\t\t\tif ( mysql2date( 'U', $post['post_modified_gmt'] ) > $content_struct['if_not_modified_since']->getTimestamp() ) {\n\t\t\t\treturn new IXR_Error( 409, __( 'There is a revision of this post that is more recent.' ) );\n\t\t\t}\n\t\t}\n\n\t\t// Convert the date field back to IXR form.\n\t\t$post['post_date'] = $this->_convert_date( $post['post_date'] );\n\n\t\t/*\n\t\t * Ignore the existing GMT date if it is empty or a non-GMT date was supplied in $content_struct,\n\t\t * since _insert_post() will ignore the non-GMT date if the GMT date is set.\n\t\t */\n\t\tif ( $post['post_date_gmt'] == '0000-00-00 00:00:00' || isset( $content_struct['post_date'] ) )\n\t\t\tunset( $post['post_date_gmt'] );\n\t\telse\n\t\t\t$post['post_date_gmt'] = $this->_convert_date( $post['post_date_gmt'] );\n\n\t\t$this->escape( $post );\n\t\t$merged_content_struct = array_merge( $post, $content_struct );\n\n\t\t$retval = $this->_insert_post( $user, $merged_content_struct );\n\t\tif ( $retval instanceof IXR_Error )\n\t\t\treturn $retval;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Delete a post for any registered post type.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_delete_post()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type int    $post_id  Post ID.\n\t * }\n\t * @return true|IXR_Error True on success, IXR_Error instance on failure.\n\t */\n\tpublic function wp_deletePost( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username   = $args[1];\n\t\t$password   = $args[2];\n\t\t$post_id    = (int) $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deletePost' );\n\n\t\t$post = get_post( $post_id, ARRAY_A );\n\t\tif ( empty( $post['ID'] ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'delete_post', $post_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to delete this post.' ) );\n\n\t\t$result = wp_delete_post( $post_id );\n\n\t\tif ( ! $result )\n\t\t\treturn new IXR_Error( 500, __( 'The post cannot be deleted.' ) );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieve a post.\n\t *\n\t * @since 3.4.0\n\t *\n\t * The optional $fields parameter specifies what fields will be included\n\t * in the response array. This should be a list of field names. 'post_id' will\n\t * always be included in the response regardless of the value of $fields.\n\t *\n\t * Instead of, or in addition to, individual field names, conceptual group\n\t * names can be used to specify multiple fields. The available conceptual\n\t * groups are 'post' (all basic fields), 'taxonomies', 'custom_fields',\n\t * and 'enclosure'.\n\t *\n\t * @see get_post()\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type int    $post_id  Post ID.\n\t *     @type array  $fields   The subset of post type fields to return.\n\t * }\n\t * @return array|IXR_Error Array contains (based on $fields parameter):\n\t *  - 'post_id'\n\t *  - 'post_title'\n\t *  - 'post_date'\n\t *  - 'post_date_gmt'\n\t *  - 'post_modified'\n\t *  - 'post_modified_gmt'\n\t *  - 'post_status'\n\t *  - 'post_type'\n\t *  - 'post_name'\n\t *  - 'post_author'\n\t *  - 'post_password'\n\t *  - 'post_excerpt'\n\t *  - 'post_content'\n\t *  - 'link'\n\t *  - 'comment_status'\n\t *  - 'ping_status'\n\t *  - 'sticky'\n\t *  - 'custom_fields'\n\t *  - 'terms'\n\t *  - 'categories'\n\t *  - 'tags'\n\t *  - 'enclosure'\n\t */\n\tpublic function wp_getPost( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$post_id  = (int) $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the list of post query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param array  $fields Array of post fields. Default array contains 'post', 'terms', and 'custom_fields'.\n\t\t\t * @param string $method Method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_post_fields', array( 'post', 'terms', 'custom_fields' ), 'wp.getPost' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPost' );\n\n\t\t$post = get_post( $post_id, ARRAY_A );\n\n\t\tif ( empty( $post['ID'] ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'edit_post', $post_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\n\t\treturn $this->_prepare_post( $post, $fields );\n\t}\n\n\t/**\n\t * Retrieve posts.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_get_recent_posts()\n\t * @see wp_getPost() for more on `$fields`\n\t * @see get_posts() for more on `$filter` values\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type array  $filter   Optional. Modifies the query used to retrieve posts. Accepts 'post_type',\n\t *                            'post_status', 'number', 'offset', 'orderby', and 'order'.\n\t *                            Default empty array.\n\t *     @type array  $fields   Optional. The subset of post type fields to return in the response array.\n\t * }\n\t * @return array|IXR_Error Array contains a collection of posts.\n\t */\n\tpublic function wp_getPosts( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$filter   = isset( $args[3] ) ? $args[3] : array();\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_post_fields', array( 'post', 'terms', 'custom_fields' ), 'wp.getPosts' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPosts' );\n\n\t\t$query = array();\n\n\t\tif ( isset( $filter['post_type'] ) ) {\n\t\t\t$post_type = get_post_type_object( $filter['post_type'] );\n\t\t\tif ( ! ( (bool) $post_type ) )\n\t\t\t\treturn new IXR_Error( 403, __( 'The post type specified is not valid' ) );\n\t\t} else {\n\t\t\t$post_type = get_post_type_object( 'post' );\n\t\t}\n\n\t\tif ( ! current_user_can( $post_type->cap->edit_posts ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to edit posts in this post type' ));\n\n\t\t$query['post_type'] = $post_type->name;\n\n\t\tif ( isset( $filter['post_status'] ) )\n\t\t\t$query['post_status'] = $filter['post_status'];\n\n\t\tif ( isset( $filter['number'] ) )\n\t\t\t$query['numberposts'] = absint( $filter['number'] );\n\n\t\tif ( isset( $filter['offset'] ) )\n\t\t\t$query['offset'] = absint( $filter['offset'] );\n\n\t\tif ( isset( $filter['orderby'] ) ) {\n\t\t\t$query['orderby'] = $filter['orderby'];\n\n\t\t\tif ( isset( $filter['order'] ) )\n\t\t\t\t$query['order'] = $filter['order'];\n\t\t}\n\n\t\tif ( isset( $filter['s'] ) ) {\n\t\t\t$query['s'] = $filter['s'];\n\t\t}\n\n\t\t$posts_list = wp_get_recent_posts( $query );\n\n\t\tif ( ! $posts_list )\n\t\t\treturn array();\n\n\t\t// Holds all the posts data.\n\t\t$struct = array();\n\n\t\tforeach ( $posts_list as $post ) {\n\t\t\tif ( ! current_user_can( 'edit_post', $post['ID'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$struct[] = $this->_prepare_post( $post, $fields );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Create a new term.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_insert_term()\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id        Blog ID (unused).\n\t *     @type string $username       Username.\n\t *     @type string $password       Password.\n\t *     @type array  $content_struct Content struct for adding a new term. The struct must contain\n\t *                                  the term 'name' and 'taxonomy'. Optional accepted values include\n\t *                                  'parent', 'description', and 'slug'.\n\t * }\n\t * @return int|IXR_Error The term ID on success, or an IXR_Error object on failure.\n\t */\n\tpublic function wp_newTerm( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newTerm' );\n\n\t\tif ( ! taxonomy_exists( $content_struct['taxonomy'] ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $content_struct['taxonomy'] );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->manage_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to create terms in this taxonomy.' ) );\n\n\t\t$taxonomy = (array) $taxonomy;\n\n\t\t// hold the data of the term\n\t\t$term_data = array();\n\n\t\t$term_data['name'] = trim( $content_struct['name'] );\n\t\tif ( empty( $term_data['name'] ) )\n\t\t\treturn new IXR_Error( 403, __( 'The term name cannot be empty.' ) );\n\n\t\tif ( isset( $content_struct['parent'] ) ) {\n\t\t\tif ( ! $taxonomy['hierarchical'] )\n\t\t\t\treturn new IXR_Error( 403, __( 'This taxonomy is not hierarchical.' ) );\n\n\t\t\t$parent_term_id = (int) $content_struct['parent'];\n\t\t\t$parent_term = get_term( $parent_term_id , $taxonomy['name'] );\n\n\t\t\tif ( is_wp_error( $parent_term ) )\n\t\t\t\treturn new IXR_Error( 500, $parent_term->get_error_message() );\n\n\t\t\tif ( ! $parent_term )\n\t\t\t\treturn new IXR_Error( 403, __( 'Parent term does not exist.' ) );\n\n\t\t\t$term_data['parent'] = $content_struct['parent'];\n\t\t}\n\n\t\tif ( isset( $content_struct['description'] ) )\n\t\t\t$term_data['description'] = $content_struct['description'];\n\n\t\tif ( isset( $content_struct['slug'] ) )\n\t\t\t$term_data['slug'] = $content_struct['slug'];\n\n\t\t$term = wp_insert_term( $term_data['name'] , $taxonomy['name'] , $term_data );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 500, __( 'Sorry, your term could not be created. Something wrong happened.' ) );\n\n\t\treturn strval( $term['term_id'] );\n\t}\n\n\t/**\n\t * Edit a term.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_update_term()\n\t *\n\t * @param array $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id        Blog ID (unused).\n\t *     @type string $username       Username.\n\t *     @type string $password       Password.\n\t *     @type int    $term_id        Term ID.\n\t *     @type array  $content_struct Content struct for editing a term. The struct must contain the\n\t *                                  term ''taxonomy'. Optional accepted values include 'name', 'parent',\n\t *                                  'description', and 'slug'.\n\t * }\n\t * @return true|IXR_Error True on success, IXR_Error instance on failure.\n\t */\n\tpublic function wp_editTerm( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 5 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$term_id        = (int) $args[3];\n\t\t$content_struct = $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editTerm' );\n\n\t\tif ( ! taxonomy_exists( $content_struct['taxonomy'] ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $content_struct['taxonomy'] );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->edit_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to edit terms in this taxonomy.' ) );\n\n\t\t$taxonomy = (array) $taxonomy;\n\n\t\t// hold the data of the term\n\t\t$term_data = array();\n\n\t\t$term = get_term( $term_id , $content_struct['taxonomy'] );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid term ID' ) );\n\n\t\tif ( isset( $content_struct['name'] ) ) {\n\t\t\t$term_data['name'] = trim( $content_struct['name'] );\n\n\t\t\tif ( empty( $term_data['name'] ) )\n\t\t\t\treturn new IXR_Error( 403, __( 'The term name cannot be empty.' ) );\n\t\t}\n\n\t\tif ( isset( $content_struct['parent'] ) ) {\n\t\t\tif ( ! $taxonomy['hierarchical'] )\n\t\t\t\treturn new IXR_Error( 403, __( \"This taxonomy is not hierarchical so you can't set a parent.\" ) );\n\n\t\t\t$parent_term_id = (int) $content_struct['parent'];\n\t\t\t$parent_term = get_term( $parent_term_id , $taxonomy['name'] );\n\n\t\t\tif ( is_wp_error( $parent_term ) )\n\t\t\t\treturn new IXR_Error( 500, $parent_term->get_error_message() );\n\n\t\t\tif ( ! $parent_term )\n\t\t\t\treturn new IXR_Error( 403, __( 'Parent term does not exist.' ) );\n\n\t\t\t$term_data['parent'] = $content_struct['parent'];\n\t\t}\n\n\t\tif ( isset( $content_struct['description'] ) )\n\t\t\t$term_data['description'] = $content_struct['description'];\n\n\t\tif ( isset( $content_struct['slug'] ) )\n\t\t\t$term_data['slug'] = $content_struct['slug'];\n\n\t\t$term = wp_update_term( $term_id , $taxonomy['name'] , $term_data );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 500, __( 'Sorry, editing the term failed.' ) );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Delete a term.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see wp_delete_term()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id      Blog ID (unused).\n\t *     @type string $username     Username.\n\t *     @type string $password     Password.\n\t *     @type string $taxnomy_name Taxonomy name.\n\t *     @type int    $term_id      Term ID.\n\t * }\n\t * @return bool|IXR_Error True on success, IXR_Error instance on failure.\n\t */\n\tpublic function wp_deleteTerm( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 5 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username           = $args[1];\n\t\t$password           = $args[2];\n\t\t$taxonomy           = $args[3];\n\t\t$term_id            = (int) $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deleteTerm' );\n\n\t\tif ( ! taxonomy_exists( $taxonomy ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $taxonomy );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->delete_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to delete terms in this taxonomy.' ) );\n\n\t\t$term = get_term( $term_id, $taxonomy->name );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid term ID' ) );\n\n\t\t$result = wp_delete_term( $term_id, $taxonomy->name );\n\n\t\tif ( is_wp_error( $result ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $result )\n\t\t\treturn new IXR_Error( 500, __( 'Sorry, deleting the term failed.' ) );\n\n\t\treturn $result;\n\t}\n\n\t/**\n\t * Retrieve a term.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_term()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type string $taxnomy  Taxonomy name.\n\t *     @type string $term_id  Term ID.\n\t * }\n\t * @return array|IXR_Error IXR_Error on failure, array on success, containing:\n\t *  - 'term_id'\n\t *  - 'name'\n\t *  - 'slug'\n\t *  - 'term_group'\n\t *  - 'term_taxonomy_id'\n\t *  - 'taxonomy'\n\t *  - 'description'\n\t *  - 'parent'\n\t *  - 'count'\n\t */\n\tpublic function wp_getTerm( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 5 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username           = $args[1];\n\t\t$password           = $args[2];\n\t\t$taxonomy           = $args[3];\n\t\t$term_id            = (int) $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getTerm' );\n\n\t\tif ( ! taxonomy_exists( $taxonomy ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $taxonomy );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->assign_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to assign terms in this taxonomy.' ) );\n\n\t\t$term = get_term( $term_id , $taxonomy->name, ARRAY_A );\n\n\t\tif ( is_wp_error( $term ) )\n\t\t\treturn new IXR_Error( 500, $term->get_error_message() );\n\n\t\tif ( ! $term )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid term ID' ) );\n\n\t\treturn $this->_prepare_term( $term );\n\t}\n\n\t/**\n\t * Retrieve all terms for a taxonomy.\n\t *\n\t * @since 3.4.0\n\t *\n\t * The optional $filter parameter modifies the query used to retrieve terms.\n\t * Accepted keys are 'number', 'offset', 'orderby', 'order', 'hide_empty', and 'search'.\n\t *\n\t * @see get_terms()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type string $taxnomy  Taxonomy name.\n\t *     @type array  $filter   Optional. Modifies the query used to retrieve posts. Accepts 'number',\n\t *                            'offset', 'orderby', 'order', 'hide_empty', and 'search'. Default empty array.\n\t * }\n\t * @return array|IXR_Error An associative array of terms data on success, IXR_Error instance otherwise.\n\t */\n\tpublic function wp_getTerms( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$taxonomy       = $args[3];\n\t\t$filter         = isset( $args[4] ) ? $args[4] : array();\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getTerms' );\n\n\t\tif ( ! taxonomy_exists( $taxonomy ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $taxonomy );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->assign_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to assign terms in this taxonomy.' ) );\n\n\t\t$query = array();\n\n\t\tif ( isset( $filter['number'] ) )\n\t\t\t$query['number'] = absint( $filter['number'] );\n\n\t\tif ( isset( $filter['offset'] ) )\n\t\t\t$query['offset'] = absint( $filter['offset'] );\n\n\t\tif ( isset( $filter['orderby'] ) ) {\n\t\t\t$query['orderby'] = $filter['orderby'];\n\n\t\t\tif ( isset( $filter['order'] ) )\n\t\t\t\t$query['order'] = $filter['order'];\n\t\t}\n\n\t\tif ( isset( $filter['hide_empty'] ) )\n\t\t\t$query['hide_empty'] = $filter['hide_empty'];\n\t\telse\n\t\t\t$query['get'] = 'all';\n\n\t\tif ( isset( $filter['search'] ) )\n\t\t\t$query['search'] = $filter['search'];\n\n\t\t$terms = get_terms( $taxonomy->name, $query );\n\n\t\tif ( is_wp_error( $terms ) )\n\t\t\treturn new IXR_Error( 500, $terms->get_error_message() );\n\n\t\t$struct = array();\n\n\t\tforeach ( $terms as $term ) {\n\t\t\t$struct[] = $this->_prepare_term( $term );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve a taxonomy.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_taxonomy()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type string $taxnomy  Taxonomy name.\n\t *     @type array  $fields   Optional. Array of taxonomy fields to limit to in the return.\n\t *                            Accepts 'labels', 'cap', 'menu', and 'object_type'.\n\t *                            Default empty array.\n\t * }\n\t * @return array|IXR_Error An array of taxonomy data on success, IXR_Error instance otherwise.\n\t */\n\tpublic function wp_getTaxonomy( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$taxonomy = $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the taxonomy query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param array  $fields An array of taxonomy fields to retrieve.\n\t\t\t * @param string $method The method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_taxonomy_fields', array( 'labels', 'cap', 'object_type' ), 'wp.getTaxonomy' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getTaxonomy' );\n\n\t\tif ( ! taxonomy_exists( $taxonomy ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid taxonomy' ) );\n\n\t\t$taxonomy = get_taxonomy( $taxonomy );\n\n\t\tif ( ! current_user_can( $taxonomy->cap->assign_terms ) )\n\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to assign terms in this taxonomy.' ) );\n\n\t\treturn $this->_prepare_taxonomy( $taxonomy, $fields );\n\t}\n\n\t/**\n\t * Retrieve all taxonomies.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_taxonomies()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id  Blog ID (unused).\n\t *     @type string $username Username.\n\t *     @type string $password Password.\n\t *     @type array  $filter   Optional. An array of arguments for retrieving taxonomies.\n\t *     @type array  $fields   Optional. The subset of taxonomy fields to return.\n\t * }\n\t * @return array|IXR_Error An associative array of taxonomy data with returned fields determined\n\t *                         by `$fields`, or an IXR_Error instance on failure.\n\t */\n\tpublic function wp_getTaxonomies( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$filter   = isset( $args[3] ) ? $args[3] : array( 'public' => true );\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_taxonomy_fields', array( 'labels', 'cap', 'object_type' ), 'wp.getTaxonomies' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getTaxonomies' );\n\n\t\t$taxonomies = get_taxonomies( $filter, 'objects' );\n\n\t\t// holds all the taxonomy data\n\t\t$struct = array();\n\n\t\tforeach ( $taxonomies as $taxonomy ) {\n\t\t\t// capability check for post_types\n\t\t\tif ( ! current_user_can( $taxonomy->cap->assign_terms ) )\n\t\t\t\tcontinue;\n\n\t\t\t$struct[] = $this->_prepare_taxonomy( $taxonomy, $fields );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve a user.\n\t *\n\t * The optional $fields parameter specifies what fields will be included\n\t * in the response array. This should be a list of field names. 'user_id' will\n\t * always be included in the response regardless of the value of $fields.\n\t *\n\t * Instead of, or in addition to, individual field names, conceptual group\n\t * names can be used to specify multiple fields. The available conceptual\n\t * groups are 'basic' and 'all'.\n\t *\n\t * @uses get_userdata()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $user_id\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error Array contains (based on $fields parameter):\n\t *  - 'user_id'\n\t *  - 'username'\n\t *  - 'first_name'\n\t *  - 'last_name'\n\t *  - 'registered'\n\t *  - 'bio'\n\t *  - 'email'\n\t *  - 'nickname'\n\t *  - 'nicename'\n\t *  - 'url'\n\t *  - 'display_name'\n\t *  - 'roles'\n\t */\n\tpublic function wp_getUser( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$user_id  = (int) $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the default user query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.5.0\n\t\t\t *\n\t\t\t * @param array  $fields User query fields for given method. Default 'all'.\n\t\t\t * @param string $method The method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_user_fields', array( 'all' ), 'wp.getUser' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getUser' );\n\n\t\tif ( ! current_user_can( 'edit_user', $user_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit users.' ) );\n\n\t\t$user_data = get_userdata( $user_id );\n\n\t\tif ( ! $user_data )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid user ID.' ) );\n\n\t\treturn $this->_prepare_user( $user_data, $fields );\n\t}\n\n\t/**\n\t * Retrieve users.\n\t *\n\t * The optional $filter parameter modifies the query used to retrieve users.\n\t * Accepted keys are 'number' (default: 50), 'offset' (default: 0), 'role',\n\t * 'who', 'orderby', and 'order'.\n\t *\n\t * The optional $fields parameter specifies what fields will be included\n\t * in the response array.\n\t *\n\t * @uses get_users()\n\t * @see wp_getUser() for more on $fields and return values\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $filter (optional)\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error users data\n\t */\n\tpublic function wp_getUsers( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$filter   = isset( $args[3] ) ? $args[3] : array();\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_user_fields', array( 'all' ), 'wp.getUsers' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getUsers' );\n\n\t\tif ( ! current_user_can( 'list_users' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot list users.' ) );\n\n\t\t$query = array( 'fields' => 'all_with_meta' );\n\n\t\t$query['number'] = ( isset( $filter['number'] ) ) ? absint( $filter['number'] ) : 50;\n\t\t$query['offset'] = ( isset( $filter['offset'] ) ) ? absint( $filter['offset'] ) : 0;\n\n\t\tif ( isset( $filter['orderby'] ) ) {\n\t\t\t$query['orderby'] = $filter['orderby'];\n\n\t\t\tif ( isset( $filter['order'] ) )\n\t\t\t\t$query['order'] = $filter['order'];\n\t\t}\n\n\t\tif ( isset( $filter['role'] ) ) {\n\t\t\tif ( get_role( $filter['role'] ) === null )\n\t\t\t\treturn new IXR_Error( 403, __( 'The role specified is not valid' ) );\n\n\t\t\t$query['role'] = $filter['role'];\n\t\t}\n\n\t\tif ( isset( $filter['who'] ) ) {\n\t\t\t$query['who'] = $filter['who'];\n\t\t}\n\n\t\t$users = get_users( $query );\n\n\t\t$_users = array();\n\t\tforeach ( $users as $user_data ) {\n\t\t\tif ( current_user_can( 'edit_user', $user_data->ID ) )\n\t\t\t\t$_users[] = $this->_prepare_user( $user_data, $fields );\n\t\t}\n\t\treturn $_users;\n\t}\n\n\t/**\n\t * Retrieve information about the requesting user.\n\t *\n\t * @uses get_userdata()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error (@see wp_getUser)\n\t */\n\tpublic function wp_getProfile( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( isset( $args[3] ) ) {\n\t\t\t$fields = $args[3];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_user_fields', array( 'all' ), 'wp.getProfile' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getProfile' );\n\n\t\tif ( ! current_user_can( 'edit_user', $user->ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit your profile.' ) );\n\n\t\t$user_data = get_userdata( $user->ID );\n\n\t\treturn $this->_prepare_user( $user_data, $fields );\n\t}\n\n\t/**\n\t * Edit user's profile.\n\t *\n\t * @uses wp_update_user()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $content_struct It can optionally contain:\n\t *      - 'first_name'\n\t *      - 'last_name'\n\t *      - 'website'\n\t *      - 'display_name'\n\t *      - 'nickname'\n\t *      - 'nicename'\n\t *      - 'bio'\n\t * }\n\t * @return true|IXR_Error True, on success.\n\t */\n\tpublic function wp_editProfile( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editProfile' );\n\n\t\tif ( ! current_user_can( 'edit_user', $user->ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit your profile.' ) );\n\n\t\t// holds data of the user\n\t\t$user_data = array();\n\t\t$user_data['ID'] = $user->ID;\n\n\t\t// only set the user details if it was given\n\t\tif ( isset( $content_struct['first_name'] ) )\n\t\t\t$user_data['first_name'] = $content_struct['first_name'];\n\n\t\tif ( isset( $content_struct['last_name'] ) )\n\t\t\t$user_data['last_name'] = $content_struct['last_name'];\n\n\t\tif ( isset( $content_struct['url'] ) )\n\t\t\t$user_data['user_url'] = $content_struct['url'];\n\n\t\tif ( isset( $content_struct['display_name'] ) )\n\t\t\t$user_data['display_name'] = $content_struct['display_name'];\n\n\t\tif ( isset( $content_struct['nickname'] ) )\n\t\t\t$user_data['nickname'] = $content_struct['nickname'];\n\n\t\tif ( isset( $content_struct['nicename'] ) )\n\t\t\t$user_data['user_nicename'] = $content_struct['nicename'];\n\n\t\tif ( isset( $content_struct['bio'] ) )\n\t\t\t$user_data['description'] = $content_struct['bio'];\n\n\t\t$result = wp_update_user( $user_data );\n\n\t\tif ( is_wp_error( $result ) )\n\t\t\treturn new IXR_Error( 500, $result->get_error_message() );\n\n\t\tif ( ! $result )\n\t\t\treturn new IXR_Error( 500, __( 'Sorry, the user cannot be updated.' ) );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieve page.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $page_id\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPage( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$page_id  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) ) {\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t$page = get_post($page_id);\n\t\tif ( ! $page )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_page', $page_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this page.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPage' );\n\n\t\t// If we found the page then format the data.\n\t\tif ( $page->ID && ($page->post_type == 'page') ) {\n\t\t\treturn $this->_prepare_page( $page );\n\t\t}\n\t\t// If the page doesn't exist indicate that.\n\t\telse {\n\t\t\treturn new IXR_Error( 404, __( 'Sorry, no such page.' ) );\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve Pages.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $num_pages\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPages( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username  = $args[1];\n\t\t$password  = $args[2];\n\t\t$num_pages = isset($args[3]) ? (int) $args[3] : 10;\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_pages' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit pages.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPages' );\n\n\t\t$pages = get_posts( array('post_type' => 'page', 'post_status' => 'any', 'numberposts' => $num_pages) );\n\t\t$num_pages = count($pages);\n\n\t\t// If we have pages, put together their info.\n\t\tif ( $num_pages >= 1 ) {\n\t\t\t$pages_struct = array();\n\n\t\t\tforeach ($pages as $page) {\n\t\t\t\tif ( current_user_can( 'edit_page', $page->ID ) )\n\t\t\t\t\t$pages_struct[] = $this->_prepare_page( $page );\n\t\t\t}\n\n\t\t\treturn $pages_struct;\n\t\t}\n\n\t\treturn array();\n\t}\n\n\t/**\n\t * Create new page.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @see wp_xmlrpc_server::mw_newPost()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $content_struct\n\t * }\n\t * @return int|IXR_Error\n\t */\n\tpublic function wp_newPage( $args ) {\n\t\t// Items not escaped here will be escaped in newPost.\n\t\t$username = $this->escape( $args[1] );\n\t\t$password = $this->escape( $args[2] );\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newPage' );\n\n\t\t// Mark this as content for a page.\n\t\t$args[3][\"post_type\"] = 'page';\n\n\t\t// Let mw_newPost do all of the heavy lifting.\n\t\treturn $this->mw_newPost( $args );\n\t}\n\n\t/**\n\t * Delete page.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $page_id\n\t * }\n\t * @return true|IXR_Error True, if success.\n\t */\n\tpublic function wp_deletePage( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$page_id  = (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deletePage' );\n\n\t\t// Get the current page based on the page_id and\n\t\t// make sure it is a page and not a post.\n\t\t$actual_page = get_post($page_id, ARRAY_A);\n\t\tif ( !$actual_page || ($actual_page['post_type'] != 'page') )\n\t\t\treturn new IXR_Error( 404, __( 'Sorry, no such page.' ) );\n\n\t\t// Make sure the user can delete pages.\n\t\tif ( !current_user_can('delete_page', $page_id) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to delete this page.' ) );\n\n\t\t// Attempt to delete the page.\n\t\t$result = wp_delete_post($page_id);\n\t\tif ( !$result )\n\t\t\treturn new IXR_Error( 500, __( 'Failed to delete the page.' ) );\n\n\t\t/**\n\t\t * Fires after a page has been successfully deleted via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $page_id ID of the deleted page.\n\t\t * @param array $args    An array of arguments to delete the page.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_wp_deletePage', $page_id, $args );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Edit page.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $page_id\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type string $content\n\t *     @type string $publish\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_editPage( $args ) {\n\t\t// Items will be escaped in mw_editPost.\n\t\t$page_id  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\t\t$content  = $args[4];\n\t\t$publish  = $args[5];\n\n\t\t$escaped_username = $this->escape( $username );\n\t\t$escaped_password = $this->escape( $password );\n\n\t\tif ( !$user = $this->login( $escaped_username, $escaped_password ) ) {\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editPage' );\n\n\t\t// Get the page data and make sure it is a page.\n\t\t$actual_page = get_post($page_id, ARRAY_A);\n\t\tif ( !$actual_page || ($actual_page['post_type'] != 'page') )\n\t\t\treturn new IXR_Error( 404, __( 'Sorry, no such page.' ) );\n\n\t\t// Make sure the user is allowed to edit pages.\n\t\tif ( !current_user_can('edit_page', $page_id) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to edit this page.' ) );\n\n\t\t// Mark this as content for a page.\n\t\t$content['post_type'] = 'page';\n\n\t\t// Arrange args in the way mw_editPost understands.\n\t\t$args = array(\n\t\t\t$page_id,\n\t\t\t$username,\n\t\t\t$password,\n\t\t\t$content,\n\t\t\t$publish\n\t\t);\n\n\t\t// Let mw_editPost do all of the heavy lifting.\n\t\treturn $this->mw_editPost( $args );\n\t}\n\n\t/**\n\t * Retrieve page list.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPageList( $args ) {\n\t\tglobal $wpdb;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_pages' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit pages.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPageList' );\n\n\t\t// Get list of pages ids and titles\n\t\t$page_list = $wpdb->get_results(\"\n\t\t\tSELECT ID page_id,\n\t\t\t\tpost_title page_title,\n\t\t\t\tpost_parent page_parent_id,\n\t\t\t\tpost_date_gmt,\n\t\t\t\tpost_date,\n\t\t\t\tpost_status\n\t\t\tFROM {$wpdb->posts}\n\t\t\tWHERE post_type = 'page'\n\t\t\tORDER BY ID\n\t\t\");\n\n\t\t// The date needs to be formatted properly.\n\t\t$num_pages = count($page_list);\n\t\tfor ( $i = 0; $i < $num_pages; $i++ ) {\n\t\t\t$page_list[$i]->dateCreated = $this->_convert_date(  $page_list[$i]->post_date );\n\t\t\t$page_list[$i]->date_created_gmt = $this->_convert_date_gmt( $page_list[$i]->post_date_gmt, $page_list[$i]->post_date );\n\n\t\t\tunset($page_list[$i]->post_date_gmt);\n\t\t\tunset($page_list[$i]->post_date);\n\t\t\tunset($page_list[$i]->post_status);\n\t\t}\n\n\t\treturn $page_list;\n\t}\n\n\t/**\n\t * Retrieve authors list.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getAuthors( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can('edit_posts') )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit posts on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getAuthors' );\n\n\t\t$authors = array();\n\t\tforeach ( get_users( array( 'fields' => array('ID','user_login','display_name') ) ) as $user ) {\n\t\t\t$authors[] = array(\n\t\t\t\t'user_id'       => $user->ID,\n\t\t\t\t'user_login'    => $user->user_login,\n\t\t\t\t'display_name'  => $user->display_name\n\t\t\t);\n\t\t}\n\n\t\treturn $authors;\n\t}\n\n\t/**\n\t * Get list of all tags\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getTags( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view tags.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getKeywords' );\n\n\t\t$tags = array();\n\n\t\tif ( $all_tags = get_tags() ) {\n\t\t\tforeach( (array) $all_tags as $tag ) {\n\t\t\t\t$struct = array();\n\t\t\t\t$struct['tag_id']\t\t\t= $tag->term_id;\n\t\t\t\t$struct['name']\t\t\t\t= $tag->name;\n\t\t\t\t$struct['count']\t\t\t= $tag->count;\n\t\t\t\t$struct['slug']\t\t\t\t= $tag->slug;\n\t\t\t\t$struct['html_url']\t\t\t= esc_html( get_tag_link( $tag->term_id ) );\n\t\t\t\t$struct['rss_url']\t\t\t= esc_html( get_tag_feed_link( $tag->term_id ) );\n\n\t\t\t\t$tags[] = $struct;\n\t\t\t}\n\t\t}\n\n\t\treturn $tags;\n\t}\n\n\t/**\n\t * Create new category.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $category\n\t * }\n\t * @return int|IXR_Error Category ID.\n\t */\n\tpublic function wp_newCategory( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$category = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newCategory' );\n\n\t\t// Make sure the user is allowed to add a category.\n\t\tif ( !current_user_can('manage_categories') )\n\t\t\treturn new IXR_Error(401, __('Sorry, you do not have the right to add a category.'));\n\n\t\t// If no slug was provided make it empty so that\n\t\t// WordPress will generate one.\n\t\tif ( empty($category['slug']) )\n\t\t\t$category['slug'] = '';\n\n\t\t// If no parent_id was provided make it empty\n\t\t// so that it will be a top level page (no parent).\n\t\tif ( !isset($category['parent_id']) )\n\t\t\t$category['parent_id'] = '';\n\n\t\t// If no description was provided make it empty.\n\t\tif ( empty($category[\"description\"]) )\n\t\t\t$category[\"description\"] = \"\";\n\n\t\t$new_category = array(\n\t\t\t'cat_name'\t\t\t\t=> $category['name'],\n\t\t\t'category_nicename'\t\t=> $category['slug'],\n\t\t\t'category_parent'\t\t=> $category['parent_id'],\n\t\t\t'category_description'\t=> $category['description']\n\t\t);\n\n\t\t$cat_id = wp_insert_category($new_category, true);\n\t\tif ( is_wp_error( $cat_id ) ) {\n\t\t\tif ( 'term_exists' == $cat_id->get_error_code() )\n\t\t\t\treturn (int) $cat_id->get_error_data();\n\t\t\telse\n\t\t\t\treturn new IXR_Error(500, __('Sorry, the new category failed.'));\n\t\t} elseif ( ! $cat_id ) {\n\t\t\treturn new IXR_Error(500, __('Sorry, the new category failed.'));\n\t\t}\n\n\t\t/**\n\t\t * Fires after a new category has been successfully created via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $cat_id ID of the new category.\n\t\t * @param array $args   An array of new category arguments.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_wp_newCategory', $cat_id, $args );\n\n\t\treturn $cat_id;\n\t}\n\n\t/**\n\t * Remove category.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $category_id\n\t * }\n\t * @return bool|IXR_Error See {@link wp_delete_term()} for return info.\n\t */\n\tpublic function wp_deleteCategory( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username    = $args[1];\n\t\t$password    = $args[2];\n\t\t$category_id = (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deleteCategory' );\n\n\t\tif ( !current_user_can('manage_categories') )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to delete a category.' ) );\n\n\t\t$status = wp_delete_term( $category_id, 'category' );\n\n\t\tif ( true == $status ) {\n\t\t\t/**\n\t\t\t * Fires after a category has been successfully deleted via XML-RPC.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param int   $category_id ID of the deleted category.\n\t\t\t * @param array $args        An array of arguments to delete the category.\n\t\t\t */\n\t\t\tdo_action( 'xmlrpc_call_success_wp_deleteCategory', $category_id, $args );\n\t\t}\n\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Retrieve category list.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $category\n\t *     @type int    $max_results\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_suggestCategories( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username    = $args[1];\n\t\t$password    = $args[2];\n\t\t$category    = $args[3];\n\t\t$max_results = (int) $args[4];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view categories.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.suggestCategories' );\n\n\t\t$category_suggestions = array();\n\t\t$args = array('get' => 'all', 'number' => $max_results, 'name__like' => $category);\n\t\tforeach ( (array) get_categories($args) as $cat ) {\n\t\t\t$category_suggestions[] = array(\n\t\t\t\t'category_id'\t=> $cat->term_id,\n\t\t\t\t'category_name'\t=> $cat->name\n\t\t\t);\n\t\t}\n\n\t\treturn $category_suggestions;\n\t}\n\n\t/**\n\t * Retrieve comment.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $comment_id\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getComment($args) {\n\t\t$this->escape($args);\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$comment_id\t= (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getComment' );\n\n\t\tif ( ! $comment = get_comment($comment_id) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid comment ID.' ) );\n\n\t\treturn $this->_prepare_comment( $comment );\n\t}\n\n\t/**\n\t * Retrieve comments.\n\t *\n\t * Besides the common blog_id (unused), username, and password arguments, it takes a filter\n\t * array as last argument.\n\t *\n\t * Accepted 'filter' keys are 'status', 'post_id', 'offset', and 'number'.\n\t *\n\t * The defaults are as follows:\n\t * - 'status' - Default is ''. Filter by status (e.g., 'approve', 'hold')\n\t * - 'post_id' - Default is ''. The post where the comment is posted. Empty string shows all comments.\n\t * - 'number' - Default is 10. Total number of media items to retrieve.\n\t * - 'offset' - Default is 0. See {@link WP_Query::query()} for more.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $struct\n\t * }\n\t * @return array|IXR_Error Contains a collection of comments. See {@link wp_xmlrpc_server::wp_getComment()} for a description of each item contents\n\t */\n\tpublic function wp_getComments( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$struct\t  = isset( $args[3] ) ? $args[3] : array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit comments.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getComments' );\n\n\t\tif ( isset($struct['status']) )\n\t\t\t$status = $struct['status'];\n\t\telse\n\t\t\t$status = '';\n\n\t\t$post_id = '';\n\t\tif ( isset($struct['post_id']) )\n\t\t\t$post_id = absint($struct['post_id']);\n\n\t\t$offset = 0;\n\t\tif ( isset($struct['offset']) )\n\t\t\t$offset = absint($struct['offset']);\n\n\t\t$number = 10;\n\t\tif ( isset($struct['number']) )\n\t\t\t$number = absint($struct['number']);\n\n\t\t$comments = get_comments( array( 'status' => $status, 'post_id' => $post_id, 'offset' => $offset, 'number' => $number ) );\n\n\t\t$comments_struct = array();\n\t\tif ( is_array( $comments ) ) {\n\t\t\tforeach ( $comments as $comment ) {\n\t\t\t\t$comments_struct[] = $this->_prepare_comment( $comment );\n\t\t\t}\n\t\t}\n\n\t\treturn $comments_struct;\n\t}\n\n\t/**\n\t * Delete a comment.\n\t *\n\t * By default, the comment will be moved to the trash instead of deleted.\n\t * See {@link wp_delete_comment()} for more information on\n\t * this behavior.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $comment_ID\n\t * }\n\t * @return bool|IXR_Error {@link wp_delete_comment()}\n\t */\n\tpublic function wp_deleteComment($args) {\n\t\t$this->escape($args);\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$comment_ID\t= (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\tif ( ! get_comment($comment_ID) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid comment ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_comment', $comment_ID ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.deleteComment' );\n\n\t\t$status = wp_delete_comment( $comment_ID );\n\n\t\tif ( $status ) {\n\t\t\t/**\n\t\t\t * Fires after a comment has been successfully deleted via XML-RPC.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param int   $comment_ID ID of the deleted comment.\n\t\t\t * @param array $args       An array of arguments to delete the comment.\n\t\t\t */\n\t\t\tdo_action( 'xmlrpc_call_success_wp_deleteComment', $comment_ID, $args );\n\t\t}\n\n\t\treturn $status;\n\t}\n\n\t/**\n\t * Edit comment.\n\t *\n\t * Besides the common blog_id (unused), username, and password arguments, it takes a\n\t * comment_id integer and a content_struct array as last argument.\n\t *\n\t * The allowed keys in the content_struct array are:\n\t *  - 'author'\n\t *  - 'author_url'\n\t *  - 'author_email'\n\t *  - 'content'\n\t *  - 'date_created_gmt'\n\t *  - 'status'. Common statuses are 'approve', 'hold', 'spam'. See get_comment_statuses() for more details\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $comment_ID\n\t *     @type array  $content_struct\n\t * }\n\t * @return true|IXR_Error True, on success.\n\t */\n\tpublic function wp_editComment( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$comment_ID\t= (int) $args[3];\n\t\t$content_struct = $args[4];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\tif ( ! get_comment($comment_ID) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid comment ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_comment', $comment_ID ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to moderate comments on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.editComment' );\n\n\t\tif ( isset($content_struct['status']) ) {\n\t\t\t$statuses = get_comment_statuses();\n\t\t\t$statuses = array_keys($statuses);\n\n\t\t\tif ( ! in_array($content_struct['status'], $statuses) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Invalid comment status.' ) );\n\t\t\t$comment_approved = $content_struct['status'];\n\t\t}\n\n\t\t// Do some timestamp voodoo\n\t\tif ( !empty( $content_struct['date_created_gmt'] ) ) {\n\t\t\t// We know this is supposed to be GMT, so we're going to slap that Z on there by force\n\t\t\t$dateCreated = rtrim( $content_struct['date_created_gmt']->getIso(), 'Z' ) . 'Z';\n\t\t\t$comment_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));\n\t\t\t$comment_date_gmt = iso8601_to_datetime($dateCreated, 'GMT');\n\t\t}\n\n\t\tif ( isset($content_struct['content']) )\n\t\t\t$comment_content = $content_struct['content'];\n\n\t\tif ( isset($content_struct['author']) )\n\t\t\t$comment_author = $content_struct['author'];\n\n\t\tif ( isset($content_struct['author_url']) )\n\t\t\t$comment_author_url = $content_struct['author_url'];\n\n\t\tif ( isset($content_struct['author_email']) )\n\t\t\t$comment_author_email = $content_struct['author_email'];\n\n\t\t// We've got all the data -- post it:\n\t\t$comment = compact('comment_ID', 'comment_content', 'comment_approved', 'comment_date', 'comment_date_gmt', 'comment_author', 'comment_author_email', 'comment_author_url');\n\n\t\t$result = wp_update_comment($comment);\n\t\tif ( is_wp_error( $result ) )\n\t\t\treturn new IXR_Error(500, $result->get_error_message());\n\n\t\tif ( !$result )\n\t\t\treturn new IXR_Error(500, __('Sorry, the comment could not be edited. Something wrong happened.'));\n\n\t\t/**\n\t\t * Fires after a comment has been successfully updated via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $comment_ID ID of the updated comment.\n\t\t * @param array $args       An array of arguments to update the comment.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_wp_editComment', $comment_ID, $args );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Create new comment.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int        $blog_id (unused)\n\t *     @type string     $username\n\t *     @type string     $password\n\t *     @type string|int $post\n\t *     @type array      $content_struct\n\t * }\n\t * @return int|IXR_Error {@link wp_new_comment()}\n\t */\n\tpublic function wp_newComment($args) {\n\t\t$this->escape($args);\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$post           = $args[3];\n\t\t$content_struct = $args[4];\n\n\t\t/**\n\t\t * Filter whether to allow anonymous comments over XML-RPC.\n\t\t *\n\t\t * @since 2.7.0\n\t\t *\n\t\t * @param bool $allow Whether to allow anonymous commenting via XML-RPC.\n\t\t *                    Default false.\n\t\t */\n\t\t$allow_anon = apply_filters( 'xmlrpc_allow_anonymous_comments', false );\n\n\t\t$user = $this->login($username, $password);\n\n\t\tif ( !$user ) {\n\t\t\t$logged_in = false;\n\t\t\tif ( $allow_anon && get_option('comment_registration') ) {\n\t\t\t\treturn new IXR_Error( 403, __( 'You must be registered to comment' ) );\n\t\t\t} elseif ( ! $allow_anon ) {\n\t\t\t\treturn $this->error;\n\t\t\t}\n\t\t} else {\n\t\t\t$logged_in = true;\n\t\t}\n\n\t\tif ( is_numeric($post) )\n\t\t\t$post_id = absint($post);\n\t\telse\n\t\t\t$post_id = url_to_postid($post);\n\n\t\tif ( ! $post_id )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! get_post($post_id) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\t$comment = array();\n\t\t$comment['comment_post_ID'] = $post_id;\n\n\t\tif ( $logged_in ) {\n\t\t\t$comment['comment_author'] = $this->escape( $user->display_name );\n\t\t\t$comment['comment_author_email'] = $this->escape( $user->user_email );\n\t\t\t$comment['comment_author_url'] = $this->escape( $user->user_url );\n\t\t\t$comment['user_ID'] = $user->ID;\n\t\t} else {\n\t\t\t$comment['comment_author'] = '';\n\t\t\tif ( isset($content_struct['author']) )\n\t\t\t\t$comment['comment_author'] = $content_struct['author'];\n\n\t\t\t$comment['comment_author_email'] = '';\n\t\t\tif ( isset($content_struct['author_email']) )\n\t\t\t\t$comment['comment_author_email'] = $content_struct['author_email'];\n\n\t\t\t$comment['comment_author_url'] = '';\n\t\t\tif ( isset($content_struct['author_url']) )\n\t\t\t\t$comment['comment_author_url'] = $content_struct['author_url'];\n\n\t\t\t$comment['user_ID'] = 0;\n\n\t\t\tif ( get_option('require_name_email') ) {\n\t\t\t\tif ( 6 > strlen($comment['comment_author_email']) || '' == $comment['comment_author'] )\n\t\t\t\t\treturn new IXR_Error( 403, __( 'Comment author name and email are required' ) );\n\t\t\t\telseif ( !is_email($comment['comment_author_email']) )\n\t\t\t\t\treturn new IXR_Error( 403, __( 'A valid email address is required' ) );\n\t\t\t}\n\t\t}\n\n\t\t$comment['comment_parent'] = isset($content_struct['comment_parent']) ? absint($content_struct['comment_parent']) : 0;\n\n\t\t$comment['comment_content'] =  isset($content_struct['content']) ? $content_struct['content'] : null;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.newComment' );\n\n\t\t$comment_ID = wp_new_comment( $comment );\n\n\t\t/**\n\t\t * Fires after a new comment has been successfully created via XML-RPC.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $comment_ID ID of the new comment.\n\t\t * @param array $args       An array of new comment arguments.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_wp_newComment', $comment_ID, $args );\n\n\t\treturn $comment_ID;\n\t}\n\n\t/**\n\t * Retrieve all of the comment status.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getCommentStatusList($args) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'moderate_comments' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getCommentStatusList' );\n\n\t\treturn get_comment_statuses();\n\t}\n\n\t/**\n\t * Retrieve comment count.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $post_id\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getCommentCount( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$post_id\t= (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about comments.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getCommentCount' );\n\n\t\t$count = wp_count_comments( $post_id );\n\t\treturn array(\n\t\t\t'approved' => $count->approved,\n\t\t\t'awaiting_moderation' => $count->moderated,\n\t\t\t'spam' => $count->spam,\n\t\t\t'total_comments' => $count->total_comments\n\t\t);\n\t}\n\n\t/**\n\t * Retrieve post statuses.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPostStatusList( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPostStatusList' );\n\n\t\treturn get_post_statuses();\n\t}\n\n\t/**\n\t * Retrieve page statuses.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPageStatusList( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_pages' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPageStatusList' );\n\n\t\treturn get_page_statuses();\n\t}\n\n\t/**\n\t * Retrieve page templates.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPageTemplates( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_pages' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t$templates = get_page_templates();\n\t\t$templates['Default'] = 'default';\n\n\t\treturn $templates;\n\t}\n\n\t/**\n\t * Retrieve blog options.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $options\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getOptions( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$options\t= isset( $args[3] ) ? (array) $args[3] : array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t// If no specific options where asked for, return all of them\n\t\tif ( count( $options ) == 0 )\n\t\t\t$options = array_keys($this->blog_options);\n\n\t\treturn $this->_getOptions($options);\n\t}\n\n\t/**\n\t * Retrieve blog options value from list.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array $options Options to retrieve.\n\t * @return array\n\t */\n\tpublic function _getOptions($options) {\n\t\t$data = array();\n\t\t$can_manage = current_user_can( 'manage_options' );\n\t\tforeach ( $options as $option ) {\n\t\t\tif ( array_key_exists( $option, $this->blog_options ) ) {\n\t\t\t\t$data[$option] = $this->blog_options[$option];\n\t\t\t\t//Is the value static or dynamic?\n\t\t\t\tif ( isset( $data[$option]['option'] ) ) {\n\t\t\t\t\t$data[$option]['value'] = get_option( $data[$option]['option'] );\n\t\t\t\t\tunset($data[$option]['option']);\n\t\t\t\t}\n\n\t\t\t\tif ( ! $can_manage )\n\t\t\t\t\t$data[$option]['readonly'] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Update blog options.\n\t *\n\t * @since 2.6.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $options\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_setOptions( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$options\t= (array) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'manage_options' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed to update options.' ) );\n\n\t\t$option_names = array();\n\t\tforeach ( $options as $o_name => $o_value ) {\n\t\t\t$option_names[] = $o_name;\n\t\t\tif ( !array_key_exists( $o_name, $this->blog_options ) )\n\t\t\t\tcontinue;\n\n\t\t\tif ( $this->blog_options[$o_name]['readonly'] == true )\n\t\t\t\tcontinue;\n\n\t\t\tupdate_option( $this->blog_options[$o_name]['option'], wp_unslash( $o_value ) );\n\t\t}\n\n\t\t//Now return the updated values\n\t\treturn $this->_getOptions($option_names);\n\t}\n\n\t/**\n\t * Retrieve a media item by ID\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $attachment_id\n\t * }\n\t * @return array|IXR_Error Associative array contains:\n\t *  - 'date_created_gmt'\n\t *  - 'parent'\n\t *  - 'link'\n\t *  - 'thumbnail'\n\t *  - 'title'\n\t *  - 'caption'\n\t *  - 'description'\n\t *  - 'metadata'\n\t */\n\tpublic function wp_getMediaItem( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username\t\t= $args[1];\n\t\t$password\t\t= $args[2];\n\t\t$attachment_id\t= (int) $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'upload_files' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You do not have permission to upload files.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getMediaItem' );\n\n\t\tif ( ! $attachment = get_post($attachment_id) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid attachment ID.' ) );\n\n\t\treturn $this->_prepare_media_item( $attachment );\n\t}\n\n\t/**\n\t * Retrieves a collection of media library items (or attachments)\n\t *\n\t * Besides the common blog_id (unused), username, and password arguments, it takes a filter\n\t * array as last argument.\n\t *\n\t * Accepted 'filter' keys are 'parent_id', 'mime_type', 'offset', and 'number'.\n\t *\n\t * The defaults are as follows:\n\t * - 'number' - Default is 5. Total number of media items to retrieve.\n\t * - 'offset' - Default is 0. See WP_Query::query() for more.\n\t * - 'parent_id' - Default is ''. The post where the media item is attached. Empty string shows all media items. 0 shows unattached media items.\n\t * - 'mime_type' - Default is ''. Filter by mime type (e.g., 'image/jpeg', 'application/pdf')\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $struct\n\t * }\n\t * @return array|IXR_Error Contains a collection of media items. See wp_xmlrpc_server::wp_getMediaItem() for a description of each item contents\n\t */\n\tpublic function wp_getMediaLibrary($args) {\n\t\t$this->escape($args);\n\n\t\t$username\t= $args[1];\n\t\t$password\t= $args[2];\n\t\t$struct\t\t= isset( $args[3] ) ? $args[3] : array() ;\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'upload_files' ) )\n\t\t\treturn new IXR_Error( 401, __( 'You do not have permission to upload files.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getMediaLibrary' );\n\n\t\t$parent_id = ( isset($struct['parent_id']) ) ? absint($struct['parent_id']) : '' ;\n\t\t$mime_type = ( isset($struct['mime_type']) ) ? $struct['mime_type'] : '' ;\n\t\t$offset = ( isset($struct['offset']) ) ? absint($struct['offset']) : 0 ;\n\t\t$number = ( isset($struct['number']) ) ? absint($struct['number']) : -1 ;\n\n\t\t$attachments = get_posts( array('post_type' => 'attachment', 'post_parent' => $parent_id, 'offset' => $offset, 'numberposts' => $number, 'post_mime_type' => $mime_type ) );\n\n\t\t$attachments_struct = array();\n\n\t\tforeach ($attachments as $attachment )\n\t\t\t$attachments_struct[] = $this->_prepare_media_item( $attachment );\n\n\t\treturn $attachments_struct;\n\t}\n\n\t/**\n\t * Retrieves a list of post formats used by the site.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error List of post formats, otherwise IXR_Error object.\n\t */\n\tpublic function wp_getPostFormats( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 403, __( 'You are not allowed access to details about this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPostFormats' );\n\n\t\t$formats = get_post_format_strings();\n\n\t\t// find out if they want a list of currently supports formats\n\t\tif ( isset( $args[3] ) && is_array( $args[3] ) ) {\n\t\t\tif ( $args[3]['show-supported'] ) {\n\t\t\t\tif ( current_theme_supports( 'post-formats' ) ) {\n\t\t\t\t\t$supported = get_theme_support( 'post-formats' );\n\n\t\t\t\t\t$data = array();\n\t\t\t\t\t$data['all'] = $formats;\n\t\t\t\t\t$data['supported'] = $supported[0];\n\n\t\t\t\t\t$formats = $data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $formats;\n\t}\n\n\t/**\n\t * Retrieves a post type\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_post_type_object()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type string $post_type_name\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error Array contains:\n\t *  - 'labels'\n\t *  - 'description'\n\t *  - 'capability_type'\n\t *  - 'cap'\n\t *  - 'map_meta_cap'\n\t *  - 'hierarchical'\n\t *  - 'menu_position'\n\t *  - 'taxonomies'\n\t *  - 'supports'\n\t */\n\tpublic function wp_getPostType( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$post_type_name = $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the default query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.4.0\n\t\t\t *\n\t\t\t * @param array  $fields An array of post type query fields for the given method.\n\t\t\t * @param string $method The method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_posttype_fields', array( 'labels', 'cap', 'taxonomies' ), 'wp.getPostType' );\n\t\t}\n\n\t\tif ( !$user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPostType' );\n\n\t\tif ( ! post_type_exists( $post_type_name ) )\n\t\t\treturn new IXR_Error( 403, __( 'Invalid post type' ) );\n\n\t\t$post_type = get_post_type_object( $post_type_name );\n\n\t\tif ( ! current_user_can( $post_type->cap->edit_posts ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to edit this post type.' ) );\n\n\t\treturn $this->_prepare_post_type( $post_type, $fields );\n\t}\n\n\t/**\n\t * Retrieves a post types\n\t *\n\t * @since 3.4.0\n\t *\n\t * @see get_post_types()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $filter (optional)\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function wp_getPostTypes( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$filter   = isset( $args[3] ) ? $args[3] : array( 'public' => true );\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_posttype_fields', array( 'labels', 'cap', 'taxonomies' ), 'wp.getPostTypes' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getPostTypes' );\n\n\t\t$post_types = get_post_types( $filter, 'objects' );\n\n\t\t$struct = array();\n\n\t\tforeach( $post_types as $post_type ) {\n\t\t\tif ( ! current_user_can( $post_type->cap->edit_posts ) )\n\t\t\t\tcontinue;\n\n\t\t\t$struct[$post_type->name] = $this->_prepare_post_type( $post_type, $fields );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve revisions for a specific post.\n\t *\n\t * @since 3.5.0\n\t *\n\t * The optional $fields parameter specifies what fields will be included\n\t * in the response array.\n\t *\n\t * @uses wp_get_post_revisions()\n\t * @see wp_getPost() for more on $fields\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $post_id\n\t *     @type array  $fields (optional)\n\t * }\n\t * @return array|IXR_Error contains a collection of posts.\n\t */\n\tpublic function wp_getRevisions( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 4 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\t$post_id  = (int) $args[3];\n\n\t\tif ( isset( $args[4] ) ) {\n\t\t\t$fields = $args[4];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Filter the default revision query fields used by the given XML-RPC method.\n\t\t\t *\n\t\t\t * @since 3.5.0\n\t\t\t *\n\t\t\t * @param array  $field  An array of revision query fields.\n\t\t\t * @param string $method The method name.\n\t\t\t */\n\t\t\t$fields = apply_filters( 'xmlrpc_default_revision_fields', array( 'post_date', 'post_date_gmt' ), 'wp.getRevisions' );\n\t\t}\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.getRevisions' );\n\n\t\tif ( ! $post = get_post( $post_id ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'edit_post', $post_id ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to edit posts.' ) );\n\n\t\t// Check if revisions are enabled.\n\t\tif ( ! wp_revisions_enabled( $post ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, revisions are disabled.' ) );\n\n\t\t$revisions = wp_get_post_revisions( $post_id );\n\n\t\tif ( ! $revisions )\n\t\t\treturn array();\n\n\t\t$struct = array();\n\n\t\tforeach ( $revisions as $revision ) {\n\t\t\tif ( ! current_user_can( 'read_post', $revision->ID ) )\n\t\t\t\tcontinue;\n\n\t\t\t// Skip autosaves\n\t\t\tif ( wp_is_post_autosave( $revision ) )\n\t\t\t\tcontinue;\n\n\t\t\t$struct[] = $this->_prepare_post( get_object_vars( $revision ), $fields );\n\t\t}\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Restore a post revision\n\t *\n\t * @since 3.5.0\n\t *\n\t * @uses wp_restore_post_revision()\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $revision_id\n\t * }\n\t * @return bool|IXR_Error false if there was an error restoring, true if success.\n\t */\n\tpublic function wp_restoreRevision( $args ) {\n\t\tif ( ! $this->minimum_args( $args, 3 ) )\n\t\t\treturn $this->error;\n\n\t\t$this->escape( $args );\n\n\t\t$username    = $args[1];\n\t\t$password    = $args[2];\n\t\t$revision_id = (int) $args[3];\n\n\t\tif ( ! $user = $this->login( $username, $password ) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'wp.restoreRevision' );\n\n\t\tif ( ! $revision = wp_get_post_revision( $revision_id ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( wp_is_post_autosave( $revision ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! $post = get_post( $revision->post_parent ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'edit_post', $revision->post_parent ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\n\t\t// Check if revisions are disabled.\n\t\tif ( ! wp_revisions_enabled( $post ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, revisions are disabled.' ) );\n\n\t\t$post = wp_restore_post_revision( $revision_id );\n\n\t\treturn (bool) $post;\n\t}\n\n\t/* Blogger API functions.\n\t * specs on http://plant.blogger.com/api and http://groups.yahoo.com/group/bloggerDev/\n\t */\n\n\t/**\n\t * Retrieve blogs that user owns.\n\t *\n\t * Will make more sense once we support multiple blogs.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function blogger_getUsersBlogs($args) {\n\t\tif ( is_multisite() )\n\t\t\treturn $this->_multisite_getUsersBlogs($args);\n\n\t\t$this->escape($args);\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.getUsersBlogs' );\n\n\t\t$is_admin = current_user_can('manage_options');\n\n\t\t$struct = array(\n\t\t\t'isAdmin'  => $is_admin,\n\t\t\t'url'      => get_option('home') . '/',\n\t\t\t'blogid'   => '1',\n\t\t\t'blogName' => get_option('blogname'),\n\t\t\t'xmlrpc'   => site_url( 'xmlrpc.php', 'rpc' ),\n\t\t);\n\n\t\treturn array($struct);\n\t}\n\n\t/**\n\t * Private function for retrieving a users blogs for multisite setups\n\t *\n\t * @access protected\n\t *\n\t * @return array|IXR_Error\n\t */\n\tprotected function _multisite_getUsersBlogs($args) {\n\t\t$current_blog = get_blog_details();\n\n\t\t$domain = $current_blog->domain;\n\t\t$path = $current_blog->path . 'xmlrpc.php';\n\n\t\t$rpc = new IXR_Client( set_url_scheme( \"http://{$domain}{$path}\" ) );\n\t\t$rpc->query('wp.getUsersBlogs', $args[1], $args[2]);\n\t\t$blogs = $rpc->getResponse();\n\n\t\tif ( isset($blogs['faultCode']) )\n\t\t\treturn new IXR_Error($blogs['faultCode'], $blogs['faultString']);\n\n\t\tif ( $_SERVER['HTTP_HOST'] == $domain && $_SERVER['REQUEST_URI'] == $path ) {\n\t\t\treturn $blogs;\n\t\t} else {\n\t\t\tforeach ( (array) $blogs as $blog ) {\n\t\t\t\tif ( strpos($blog['url'], $_SERVER['HTTP_HOST']) )\n\t\t\t\t\treturn array($blog);\n\t\t\t}\n\t\t\treturn array();\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve user's data.\n\t *\n\t * Gives your client some info about you, so you don't have to.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function blogger_getUserInfo( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have access to user data on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.getUserInfo' );\n\n\t\t$struct = array(\n\t\t\t'nickname'  => $user->nickname,\n\t\t\t'userid'    => $user->ID,\n\t\t\t'url'       => $user->user_url,\n\t\t\t'lastname'  => $user->last_name,\n\t\t\t'firstname' => $user->first_name\n\t\t);\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function blogger_getPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t$post_data = get_post($post_ID, ARRAY_A);\n\t\tif ( ! $post_data )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_post', $post_ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.getPost' );\n\n\t\t$categories = implode(',', wp_get_post_categories($post_ID));\n\n\t\t$content  = '<title>'.wp_unslash($post_data['post_title']).'</title>';\n\t\t$content .= '<category>'.$categories.'</category>';\n\t\t$content .= wp_unslash($post_data['post_content']);\n\n\t\t$struct = array(\n\t\t\t'userid'    => $post_data['post_author'],\n\t\t\t'dateCreated' => $this->_convert_date( $post_data['post_date'] ),\n\t\t\t'content'     => $content,\n\t\t\t'postid'  => (string) $post_data['ID']\n\t\t);\n\n\t\treturn $struct;\n\t}\n\n\t/**\n\t * Retrieve list of recent posts.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type string $appkey (unused)\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $numberposts (optional)\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function blogger_getRecentPosts( $args ) {\n\n\t\t$this->escape($args);\n\n\t\t// $args[0] = appkey - ignored\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\t\tif ( isset( $args[4] ) )\n\t\t\t$query = array( 'numberposts' => absint( $args[4] ) );\n\t\telse\n\t\t\t$query = array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( ! current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit posts on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.getRecentPosts' );\n\n\t\t$posts_list = wp_get_recent_posts( $query );\n\n\t\tif ( !$posts_list ) {\n\t\t\t$this->error = new IXR_Error(500, __('Either there are no posts, or something went wrong.'));\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t$recent_posts = array();\n\t\tforeach ($posts_list as $entry) {\n\t\t\tif ( !current_user_can( 'edit_post', $entry['ID'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$post_date  = $this->_convert_date( $entry['post_date'] );\n\t\t\t$categories = implode(',', wp_get_post_categories($entry['ID']));\n\n\t\t\t$content  = '<title>'.wp_unslash($entry['post_title']).'</title>';\n\t\t\t$content .= '<category>'.$categories.'</category>';\n\t\t\t$content .= wp_unslash($entry['post_content']);\n\n\t\t\t$recent_posts[] = array(\n\t\t\t\t'userid' => $entry['post_author'],\n\t\t\t\t'dateCreated' => $post_date,\n\t\t\t\t'content' => $content,\n\t\t\t\t'postid' => (string) $entry['ID'],\n\t\t\t);\n\t\t}\n\n\t\treturn $recent_posts;\n\t}\n\n\t/**\n\t * Deprecated.\n\t *\n\t * @since 1.5.0\n\t * @deprecated 3.5.0\n\t * @return IXR_Error\n\t */\n\tpublic function blogger_getTemplate($args) {\n\t\treturn new IXR_Error( 403, __('Sorry, that file cannot be edited.' ) );\n\t}\n\n\t/**\n\t * Deprecated.\n\t *\n\t * @since 1.5.0\n\t * @deprecated 3.5.0\n\t * @return IXR_Error\n\t */\n\tpublic function blogger_setTemplate($args) {\n\t\treturn new IXR_Error( 403, __('Sorry, that file cannot be edited.' ) );\n\t}\n\n\t/**\n\t * Create new post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type string $appkey (unused)\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type string $content\n\t *     @type string $publish\n\t * }\n\t * @return int|IXR_Error\n\t */\n\tpublic function blogger_newPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\t\t$content  = $args[4];\n\t\t$publish  = $args[5];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.newPost' );\n\n\t\t$cap = ($publish) ? 'publish_posts' : 'edit_posts';\n\t\tif ( ! current_user_can( get_post_type_object( 'post' )->cap->create_posts ) || !current_user_can($cap) )\n\t\t\treturn new IXR_Error(401, __('Sorry, you are not allowed to post on this site.'));\n\n\t\t$post_status = ($publish) ? 'publish' : 'draft';\n\n\t\t$post_author = $user->ID;\n\n\t\t$post_title = xmlrpc_getposttitle($content);\n\t\t$post_category = xmlrpc_getpostcategory($content);\n\t\t$post_content = xmlrpc_removepostdata($content);\n\n\t\t$post_date = current_time('mysql');\n\t\t$post_date_gmt = current_time('mysql', 1);\n\n\t\t$post_data = compact('post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_title', 'post_category', 'post_status');\n\n\t\t$post_ID = wp_insert_post($post_data);\n\t\tif ( is_wp_error( $post_ID ) )\n\t\t\treturn new IXR_Error(500, $post_ID->get_error_message());\n\n\t\tif ( !$post_ID )\n\t\t\treturn new IXR_Error(500, __('Sorry, your entry could not be posted. Something wrong happened.'));\n\n\t\t$this->attach_uploads( $post_ID, $post_content );\n\n\t\t/**\n\t\t * Fires after a new post has been successfully created via the XML-RPC Blogger API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the new post.\n\t\t * @param array $args    An array of new post arguments.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_blogger_newPost', $post_ID, $args );\n\n\t\treturn $post_ID;\n\t}\n\n\t/**\n\t * Edit a post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type string $content\n\t * }\n\t * @return true|IXR_Error true when done.\n\t */\n\tpublic function blogger_editPost( $args ) {\n\n\t\t$this->escape($args);\n\n\t\t$post_ID  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\t\t$content  = $args[4];\n\n\t\tif ( ! $user = $this->login( $username, $password ) ) {\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.editPost' );\n\n\t\t$actual_post = get_post( $post_ID, ARRAY_A );\n\n\t\tif ( ! $actual_post || $actual_post['post_type'] != 'post' ) {\n\t\t\treturn new IXR_Error( 404, __( 'Sorry, no such post.' ) );\n\t\t}\n\n\t\t$this->escape($actual_post);\n\n\t\tif ( ! current_user_can( 'edit_post', $post_ID ) ) {\n\t\t\treturn new IXR_Error(401, __('Sorry, you do not have the right to edit this post.'));\n\t\t}\n\t\tif ( 'publish' == $actual_post['post_status'] && ! current_user_can( 'publish_posts' ) ) {\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to publish this post.' ) );\n\t\t}\n\n\t\t$postdata = array();\n\t\t$postdata['ID'] = $actual_post['ID'];\n\t\t$postdata['post_content'] = xmlrpc_removepostdata( $content );\n\t\t$postdata['post_title'] = xmlrpc_getposttitle( $content );\n\t\t$postdata['post_category'] = xmlrpc_getpostcategory( $content );\n\t\t$postdata['post_status'] = $actual_post['post_status'];\n\t\t$postdata['post_excerpt'] = $actual_post['post_excerpt'];\n\n\t\t$result = wp_update_post( $postdata );\n\n\t\tif ( ! $result ) {\n\t\t\treturn new IXR_Error(500, __('For some strange yet very annoying reason, this post could not be edited.'));\n\t\t}\n\t\t$this->attach_uploads( $actual_post['ID'], $postdata['post_content'] );\n\n\t\t/**\n\t\t * Fires after a post has been successfully updated via the XML-RPC Blogger API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the updated post.\n\t\t * @param array $args    An array of arguments for the post to edit.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_blogger_editPost', $post_ID, $args );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Remove a post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return true|IXR_Error True when post is deleted.\n\t */\n\tpublic function blogger_deletePost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[1];\n\t\t$username = $args[2];\n\t\t$password = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'blogger.deletePost' );\n\n\t\t$actual_post = get_post($post_ID,ARRAY_A);\n\n\t\tif ( !$actual_post || $actual_post['post_type'] != 'post' )\n\t\t\treturn new IXR_Error(404, __('Sorry, no such post.'));\n\n\t\tif ( !current_user_can('delete_post', $post_ID) )\n\t\t\treturn new IXR_Error(401, __('Sorry, you do not have the right to delete this post.'));\n\n\t\t$result = wp_delete_post($post_ID);\n\n\t\tif ( !$result )\n\t\t\treturn new IXR_Error(500, __('For some strange yet very annoying reason, this post could not be deleted.'));\n\n\t\t/**\n\t\t * Fires after a post has been successfully deleted via the XML-RPC Blogger API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the deleted post.\n\t\t * @param array $args    An array of arguments to delete the post.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_blogger_deletePost', $post_ID, $args );\n\n\t\treturn true;\n\t}\n\n\t/* MetaWeblog API functions\n\t * specs on wherever Dave Winer wants them to be\n\t */\n\n\t/**\n\t * Create a new post.\n\t *\n\t * The 'content_struct' argument must contain:\n\t *  - title\n\t *  - description\n\t *  - mt_excerpt\n\t *  - mt_text_more\n\t *  - mt_keywords\n\t *  - mt_tb_ping_urls\n\t *  - categories\n\t *\n\t * Also, it can optionally contain:\n\t *  - wp_slug\n\t *  - wp_password\n\t *  - wp_page_parent_id\n\t *  - wp_page_order\n\t *  - wp_author_id\n\t *  - post_status | page_status - can be 'draft', 'private', 'publish', or 'pending'\n\t *  - mt_allow_comments - can be 'open' or 'closed'\n\t *  - mt_allow_pings - can be 'open' or 'closed'\n\t *  - date_created_gmt\n\t *  - dateCreated\n\t *  - wp_post_thumbnail\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $content_struct\n\t *     @type int    $publish\n\t * }\n\t * @return int|IXR_Error\n\t */\n\tpublic function mw_newPost($args) {\n\t\t$this->escape($args);\n\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\t\t$publish        = isset( $args[4] ) ? $args[4] : 0;\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.newPost' );\n\n\t\t$page_template = '';\n\t\tif ( !empty( $content_struct['post_type'] ) ) {\n\t\t\tif ( $content_struct['post_type'] == 'page' ) {\n\t\t\t\tif ( $publish )\n\t\t\t\t\t$cap  = 'publish_pages';\n\t\t\t\telseif ( isset( $content_struct['page_status'] ) && 'publish' == $content_struct['page_status'] )\n\t\t\t\t\t$cap  = 'publish_pages';\n\t\t\t\telse\n\t\t\t\t\t$cap = 'edit_pages';\n\t\t\t\t$error_message = __( 'Sorry, you are not allowed to publish pages on this site.' );\n\t\t\t\t$post_type = 'page';\n\t\t\t\tif ( !empty( $content_struct['wp_page_template'] ) )\n\t\t\t\t\t$page_template = $content_struct['wp_page_template'];\n\t\t\t} elseif ( $content_struct['post_type'] == 'post' ) {\n\t\t\t\tif ( $publish )\n\t\t\t\t\t$cap  = 'publish_posts';\n\t\t\t\telseif ( isset( $content_struct['post_status'] ) && 'publish' == $content_struct['post_status'] )\n\t\t\t\t\t$cap  = 'publish_posts';\n\t\t\t\telse\n\t\t\t\t\t$cap = 'edit_posts';\n\t\t\t\t$error_message = __( 'Sorry, you are not allowed to publish posts on this site.' );\n\t\t\t\t$post_type = 'post';\n\t\t\t} else {\n\t\t\t\t// No other post_type values are allowed here\n\t\t\t\treturn new IXR_Error( 401, __( 'Invalid post type' ) );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( $publish )\n\t\t\t\t$cap  = 'publish_posts';\n\t\t\telseif ( isset( $content_struct['post_status'] ) && 'publish' == $content_struct['post_status'])\n\t\t\t\t$cap  = 'publish_posts';\n\t\t\telse\n\t\t\t\t$cap = 'edit_posts';\n\t\t\t$error_message = __( 'Sorry, you are not allowed to publish posts on this site.' );\n\t\t\t$post_type = 'post';\n\t\t}\n\n\t\tif ( ! current_user_can( get_post_type_object( $post_type )->cap->create_posts ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you are not allowed to publish posts on this site.' ) );\n\t\tif ( !current_user_can( $cap ) )\n\t\t\treturn new IXR_Error( 401, $error_message );\n\n\t\t// Check for a valid post format if one was given\n\t\tif ( isset( $content_struct['wp_post_format'] ) ) {\n\t\t\t$content_struct['wp_post_format'] = sanitize_key( $content_struct['wp_post_format'] );\n\t\t\tif ( !array_key_exists( $content_struct['wp_post_format'], get_post_format_strings() ) ) {\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid post format' ) );\n\t\t\t}\n\t\t}\n\n\t\t// Let WordPress generate the post_name (slug) unless\n\t\t// one has been provided.\n\t\t$post_name = \"\";\n\t\tif ( isset($content_struct['wp_slug']) )\n\t\t\t$post_name = $content_struct['wp_slug'];\n\n\t\t// Only use a password if one was given.\n\t\tif ( isset($content_struct['wp_password']) )\n\t\t\t$post_password = $content_struct['wp_password'];\n\n\t\t// Only set a post parent if one was provided.\n\t\tif ( isset($content_struct['wp_page_parent_id']) )\n\t\t\t$post_parent = $content_struct['wp_page_parent_id'];\n\n\t\t// Only set the menu_order if it was provided.\n\t\tif ( isset($content_struct['wp_page_order']) )\n\t\t\t$menu_order = $content_struct['wp_page_order'];\n\n\t\t$post_author = $user->ID;\n\n\t\t// If an author id was provided then use it instead.\n\t\tif ( isset( $content_struct['wp_author_id'] ) && ( $user->ID != $content_struct['wp_author_id'] ) ) {\n\t\t\tswitch ( $post_type ) {\n\t\t\t\tcase \"post\":\n\t\t\t\t\tif ( !current_user_can( 'edit_others_posts' ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to create posts as this user.' ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"page\":\n\t\t\t\t\tif ( !current_user_can( 'edit_others_pages' ) )\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to create pages as this user.' ) );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn new IXR_Error( 401, __( 'Invalid post type' ) );\n\t\t\t}\n\t\t\t$author = get_userdata( $content_struct['wp_author_id'] );\n\t\t\tif ( ! $author )\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid author ID.' ) );\n\t\t\t$post_author = $content_struct['wp_author_id'];\n\t\t}\n\n\t\t$post_title = isset( $content_struct['title'] ) ? $content_struct['title'] : null;\n\t\t$post_content = isset( $content_struct['description'] ) ? $content_struct['description'] : null;\n\n\t\t$post_status = $publish ? 'publish' : 'draft';\n\n\t\tif ( isset( $content_struct[\"{$post_type}_status\"] ) ) {\n\t\t\tswitch ( $content_struct[\"{$post_type}_status\"] ) {\n\t\t\t\tcase 'draft':\n\t\t\t\tcase 'pending':\n\t\t\t\tcase 'private':\n\t\t\t\tcase 'publish':\n\t\t\t\t\t$post_status = $content_struct[\"{$post_type}_status\"];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$post_status = $publish ? 'publish' : 'draft';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$post_excerpt = isset($content_struct['mt_excerpt']) ? $content_struct['mt_excerpt'] : null;\n\t\t$post_more = isset($content_struct['mt_text_more']) ? $content_struct['mt_text_more'] : null;\n\n\t\t$tags_input = isset($content_struct['mt_keywords']) ? $content_struct['mt_keywords'] : null;\n\n\t\tif ( isset($content_struct['mt_allow_comments']) ) {\n\t\t\tif ( !is_numeric($content_struct['mt_allow_comments']) ) {\n\t\t\t\tswitch ( $content_struct['mt_allow_comments'] ) {\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t\t$comment_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'open':\n\t\t\t\t\t\t$comment_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch ( (int) $content_struct['mt_allow_comments'] ) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t$comment_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$comment_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t}\n\n\t\tif ( isset($content_struct['mt_allow_pings']) ) {\n\t\t\tif ( !is_numeric($content_struct['mt_allow_pings']) ) {\n\t\t\t\tswitch ( $content_struct['mt_allow_pings'] ) {\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t\t$ping_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'open':\n\t\t\t\t\t\t$ping_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch ( (int) $content_struct['mt_allow_pings'] ) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\t$ping_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$ping_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t}\n\n\t\tif ( $post_more )\n\t\t\t$post_content = $post_content . '<!--more-->' . $post_more;\n\n\t\t$to_ping = null;\n\t\tif ( isset( $content_struct['mt_tb_ping_urls'] ) ) {\n\t\t\t$to_ping = $content_struct['mt_tb_ping_urls'];\n\t\t\tif ( is_array($to_ping) )\n\t\t\t\t$to_ping = implode(' ', $to_ping);\n\t\t}\n\n\t\t// Do some timestamp voodoo\n\t\tif ( !empty( $content_struct['date_created_gmt'] ) )\n\t\t\t// We know this is supposed to be GMT, so we're going to slap that Z on there by force\n\t\t\t$dateCreated = rtrim( $content_struct['date_created_gmt']->getIso(), 'Z' ) . 'Z';\n\t\telseif ( !empty( $content_struct['dateCreated']) )\n\t\t\t$dateCreated = $content_struct['dateCreated']->getIso();\n\n\t\tif ( !empty( $dateCreated ) ) {\n\t\t\t$post_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));\n\t\t\t$post_date_gmt = iso8601_to_datetime($dateCreated, 'GMT');\n\t\t} else {\n\t\t\t$post_date = current_time('mysql');\n\t\t\t$post_date_gmt = current_time('mysql', 1);\n\t\t}\n\n\t\t$post_category = array();\n\t\tif ( isset( $content_struct['categories'] ) ) {\n\t\t\t$catnames = $content_struct['categories'];\n\n\t\t\tif ( is_array($catnames) ) {\n\t\t\t\tforeach ($catnames as $cat) {\n\t\t\t\t\t$post_category[] = get_cat_ID($cat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$postdata = compact('post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'comment_status', 'ping_status', 'to_ping', 'post_type', 'post_name', 'post_password', 'post_parent', 'menu_order', 'tags_input', 'page_template');\n\n\t\t$post_ID = $postdata['ID'] = get_default_post_to_edit( $post_type, true )->ID;\n\n\t\t// Only posts can be sticky\n\t\tif ( $post_type == 'post' && isset( $content_struct['sticky'] ) ) {\n\t\t\t$data = $postdata;\n\t\t\t$data['sticky'] = $content_struct['sticky'];\n\t\t\t$error = $this->_toggle_sticky( $data );\n\t\t\tif ( $error ) {\n\t\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\n\t\tif ( isset($content_struct['custom_fields']) )\n\t\t\t$this->set_custom_fields($post_ID, $content_struct['custom_fields']);\n\n\t\tif ( isset ( $content_struct['wp_post_thumbnail'] ) ) {\n\t\t\tif ( set_post_thumbnail( $post_ID, $content_struct['wp_post_thumbnail'] ) === false )\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid attachment ID.' ) );\n\n\t\t\tunset( $content_struct['wp_post_thumbnail'] );\n\t\t}\n\n\t\t// Handle enclosures\n\t\t$thisEnclosure = isset($content_struct['enclosure']) ? $content_struct['enclosure'] : null;\n\t\t$this->add_enclosure_if_new($post_ID, $thisEnclosure);\n\n\t\t$this->attach_uploads( $post_ID, $post_content );\n\n\t\t// Handle post formats if assigned, value is validated earlier\n\t\t// in this function\n\t\tif ( isset( $content_struct['wp_post_format'] ) )\n\t\t\tset_post_format( $post_ID, $content_struct['wp_post_format'] );\n\n\t\t$post_ID = wp_insert_post( $postdata, true );\n\t\tif ( is_wp_error( $post_ID ) )\n\t\t\treturn new IXR_Error(500, $post_ID->get_error_message());\n\n\t\tif ( !$post_ID )\n\t\t\treturn new IXR_Error(500, __('Sorry, your entry could not be posted. Something wrong happened.'));\n\n\t\t/**\n\t\t * Fires after a new post has been successfully created via the XML-RPC MovableType API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the new post.\n\t\t * @param array $args    An array of arguments to create the new post.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_mw_newPost', $post_ID, $args );\n\n\t\treturn strval($post_ID);\n\t}\n\n\t/**\n\t * @param integer $post_ID\n\t * @param array   $enclosure\n\t */\n\tpublic function add_enclosure_if_new( $post_ID, $enclosure ) {\n\t\tif ( is_array( $enclosure ) && isset( $enclosure['url'] ) && isset( $enclosure['length'] ) && isset( $enclosure['type'] ) ) {\n\t\t\t$encstring = $enclosure['url'] . \"\\n\" . $enclosure['length'] . \"\\n\" . $enclosure['type'] . \"\\n\";\n\t\t\t$found = false;\n\t\t\tif ( $enclosures = get_post_meta( $post_ID, 'enclosure' ) ) {\n\t\t\t\tforeach ( $enclosures as $enc ) {\n\t\t\t\t\t// This method used to omit the trailing new line. #23219\n\t\t\t\t\tif ( rtrim( $enc, \"\\n\" ) == rtrim( $encstring, \"\\n\" ) ) {\n\t\t\t\t\t\t$found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ! $found )\n\t\t\t\tadd_post_meta( $post_ID, 'enclosure', $encstring );\n\t\t}\n\t}\n\n\t/**\n\t * Attach upload to a post.\n\t *\n\t * @since 2.1.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param int $post_ID Post ID.\n\t * @param string $post_content Post Content for attachment.\n\t */\n\tpublic function attach_uploads( $post_ID, $post_content ) {\n\t\tglobal $wpdb;\n\n\t\t// find any unattached files\n\t\t$attachments = $wpdb->get_results( \"SELECT ID, guid FROM {$wpdb->posts} WHERE post_parent = '0' AND post_type = 'attachment'\" );\n\t\tif ( is_array( $attachments ) ) {\n\t\t\tforeach ( $attachments as $file ) {\n\t\t\t\tif ( ! empty( $file->guid ) && strpos( $post_content, $file->guid ) !== false )\n\t\t\t\t\t$wpdb->update($wpdb->posts, array('post_parent' => $post_ID), array('ID' => $file->ID) );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Edit a post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $content_struct\n\t *     @type int    $publish\n\t * }\n\t * @return bool|IXR_Error True on success.\n\t */\n\tpublic function mw_editPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID        = (int) $args[0];\n\t\t$username       = $args[1];\n\t\t$password       = $args[2];\n\t\t$content_struct = $args[3];\n\t\t$publish        = isset( $args[4] ) ? $args[4] : 0;\n\n\t\tif ( ! $user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.editPost' );\n\n\t\t$postdata = get_post( $post_ID, ARRAY_A );\n\n\t\t/*\n\t\t * If there is no post data for the give post id, stop now and return an error.\n\t\t * Otherwise a new post will be created (which was the old behavior).\n\t\t */\n\t\tif ( ! $postdata || empty( $postdata[ 'ID' ] ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( ! current_user_can( 'edit_post', $post_ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to edit this post.' ) );\n\n\t\t// Use wp.editPost to edit post types other than post and page.\n\t\tif ( ! in_array( $postdata[ 'post_type' ], array( 'post', 'page' ) ) )\n\t\t\treturn new IXR_Error( 401, __( 'Invalid post type' ) );\n\n\t\t// Thwart attempt to change the post type.\n\t\tif ( ! empty( $content_struct[ 'post_type' ] ) && ( $content_struct['post_type'] != $postdata[ 'post_type' ] ) )\n\t\t\treturn new IXR_Error( 401, __( 'The post type may not be changed.' ) );\n\n\t\t// Check for a valid post format if one was given\n\t\tif ( isset( $content_struct['wp_post_format'] ) ) {\n\t\t\t$content_struct['wp_post_format'] = sanitize_key( $content_struct['wp_post_format'] );\n\t\t\tif ( !array_key_exists( $content_struct['wp_post_format'], get_post_format_strings() ) ) {\n\t\t\t\treturn new IXR_Error( 404, __( 'Invalid post format' ) );\n\t\t\t}\n\t\t}\n\n\t\t$this->escape($postdata);\n\n\t\t$ID = $postdata['ID'];\n\t\t$post_content = $postdata['post_content'];\n\t\t$post_title = $postdata['post_title'];\n\t\t$post_excerpt = $postdata['post_excerpt'];\n\t\t$post_password = $postdata['post_password'];\n\t\t$post_parent = $postdata['post_parent'];\n\t\t$post_type = $postdata['post_type'];\n\t\t$menu_order = $postdata['menu_order'];\n\n\t\t// Let WordPress manage slug if none was provided.\n\t\t$post_name = $postdata['post_name'];\n\t\tif ( isset($content_struct['wp_slug']) )\n\t\t\t$post_name = $content_struct['wp_slug'];\n\n\t\t// Only use a password if one was given.\n\t\tif ( isset($content_struct['wp_password']) )\n\t\t\t$post_password = $content_struct['wp_password'];\n\n\t\t// Only set a post parent if one was given.\n\t\tif ( isset($content_struct['wp_page_parent_id']) )\n\t\t\t$post_parent = $content_struct['wp_page_parent_id'];\n\n\t\t// Only set the menu_order if it was given.\n\t\tif ( isset($content_struct['wp_page_order']) )\n\t\t\t$menu_order = $content_struct['wp_page_order'];\n\n\t\t$page_template = null;\n\t\tif ( ! empty( $content_struct['wp_page_template'] ) && 'page' == $post_type )\n\t\t\t$page_template = $content_struct['wp_page_template'];\n\n\t\t$post_author = $postdata['post_author'];\n\n\t\t// Only set the post_author if one is set.\n\t\tif ( isset( $content_struct['wp_author_id'] ) ) {\n\t\t\t// Check permissions if attempting to switch author to or from another user.\n\t\t\tif ( $user->ID != $content_struct['wp_author_id'] || $user->ID != $post_author ) {\n\t\t\t\tswitch ( $post_type ) {\n\t\t\t\t\tcase 'post':\n\t\t\t\t\t\tif ( ! current_user_can( 'edit_others_posts' ) ) {\n\t\t\t\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to change the post author as this user.' ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'page':\n\t\t\t\t\t\tif ( ! current_user_can( 'edit_others_pages' ) ) {\n\t\t\t\t\t\t\treturn new IXR_Error( 401, __( 'You are not allowed to change the page author as this user.' ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn new IXR_Error( 401, __( 'Invalid post type' ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t$post_author = $content_struct['wp_author_id'];\n\t\t\t}\n\t\t}\n\n\t\tif ( isset($content_struct['mt_allow_comments']) ) {\n\t\t\tif ( !is_numeric($content_struct['mt_allow_comments']) ) {\n\t\t\t\tswitch ( $content_struct['mt_allow_comments'] ) {\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t\t$comment_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'open':\n\t\t\t\t\t\t$comment_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch ( (int) $content_struct['mt_allow_comments'] ) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t$comment_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$comment_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$comment_status = get_default_comment_status( $post_type );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( isset($content_struct['mt_allow_pings']) ) {\n\t\t\tif ( !is_numeric($content_struct['mt_allow_pings']) ) {\n\t\t\t\tswitch ( $content_struct['mt_allow_pings'] ) {\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t\t$ping_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'open':\n\t\t\t\t\t\t$ping_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch ( (int) $content_struct[\"mt_allow_pings\"] ) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\t$ping_status = 'closed';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t$ping_status = 'open';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$ping_status = get_default_comment_status( $post_type, 'pingback' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $content_struct['title'] ) )\n\t\t\t$post_title =  $content_struct['title'];\n\n\t\tif ( isset( $content_struct['description'] ) )\n\t\t\t$post_content = $content_struct['description'];\n\n\t\t$post_category = array();\n\t\tif ( isset( $content_struct['categories'] ) ) {\n\t\t\t$catnames = $content_struct['categories'];\n\t\t\tif ( is_array($catnames) ) {\n\t\t\t\tforeach ($catnames as $cat) {\n\t\t\t\t\t$post_category[] = get_cat_ID($cat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( isset( $content_struct['mt_excerpt'] ) )\n\t\t\t$post_excerpt =  $content_struct['mt_excerpt'];\n\n\t\t$post_more = isset( $content_struct['mt_text_more'] ) ? $content_struct['mt_text_more'] : null;\n\n\t\t$post_status = $publish ? 'publish' : 'draft';\n\t\tif ( isset( $content_struct[\"{$post_type}_status\"] ) ) {\n\t\t\tswitch( $content_struct[\"{$post_type}_status\"] ) {\n\t\t\t\tcase 'draft':\n\t\t\t\tcase 'pending':\n\t\t\t\tcase 'private':\n\t\t\t\tcase 'publish':\n\t\t\t\t\t$post_status = $content_struct[\"{$post_type}_status\"];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$post_status = $publish ? 'publish' : 'draft';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$tags_input = isset( $content_struct['mt_keywords'] ) ? $content_struct['mt_keywords'] : null;\n\n\t\tif ( 'publish' == $post_status || 'private' == $post_status ) {\n\t\t\tif ( 'page' == $post_type && ! current_user_can( 'publish_pages' ) ) {\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to publish this page.' ) );\n\t\t\t} elseif ( ! current_user_can( 'publish_posts' ) ) {\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you do not have the right to publish this post.' ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( $post_more )\n\t\t\t$post_content = $post_content . \"<!--more-->\" . $post_more;\n\n\t\t$to_ping = null;\n\t\tif ( isset( $content_struct['mt_tb_ping_urls'] ) ) {\n\t\t\t$to_ping = $content_struct['mt_tb_ping_urls'];\n\t\t\tif ( is_array($to_ping) )\n\t\t\t\t$to_ping = implode(' ', $to_ping);\n\t\t}\n\n\t\t// Do some timestamp voodoo.\n\t\tif ( !empty( $content_struct['date_created_gmt'] ) )\n\t\t\t// We know this is supposed to be GMT, so we're going to slap that Z on there by force.\n\t\t\t$dateCreated = rtrim( $content_struct['date_created_gmt']->getIso(), 'Z' ) . 'Z';\n\t\telseif ( !empty( $content_struct['dateCreated']) )\n\t\t\t$dateCreated = $content_struct['dateCreated']->getIso();\n\n\t\tif ( !empty( $dateCreated ) ) {\n\t\t\t$post_date = get_date_from_gmt(iso8601_to_datetime($dateCreated));\n\t\t\t$post_date_gmt = iso8601_to_datetime($dateCreated, 'GMT');\n\t\t} else {\n\t\t\t$post_date     = $postdata['post_date'];\n\t\t\t$post_date_gmt = $postdata['post_date_gmt'];\n\t\t}\n\n\t\t// We've got all the data -- post it.\n\t\t$newpost = compact('ID', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'comment_status', 'ping_status', 'post_date', 'post_date_gmt', 'to_ping', 'post_name', 'post_password', 'post_parent', 'menu_order', 'post_author', 'tags_input', 'page_template');\n\n\t\t$result = wp_update_post($newpost, true);\n\t\tif ( is_wp_error( $result ) )\n\t\t\treturn new IXR_Error(500, $result->get_error_message());\n\n\t\tif ( !$result )\n\t\t\treturn new IXR_Error(500, __('Sorry, your entry could not be edited. Something wrong happened.'));\n\n\t\t// Only posts can be sticky\n\t\tif ( $post_type == 'post' && isset( $content_struct['sticky'] ) ) {\n\t\t\t$data = $newpost;\n\t\t\t$data['sticky'] = $content_struct['sticky'];\n\t\t\t$data['post_type'] = 'post';\n\t\t\t$error = $this->_toggle_sticky( $data, true );\n\t\t\tif ( $error ) {\n\t\t\t\treturn $error;\n\t\t\t}\n\t\t}\n\n\t\tif ( isset($content_struct['custom_fields']) )\n\t\t\t$this->set_custom_fields($post_ID, $content_struct['custom_fields']);\n\n\t\tif ( isset ( $content_struct['wp_post_thumbnail'] ) ) {\n\n\t\t\t// Empty value deletes, non-empty value adds/updates.\n\t\t\tif ( empty( $content_struct['wp_post_thumbnail'] ) ) {\n\t\t\t\tdelete_post_thumbnail( $post_ID );\n\t\t\t} else {\n\t\t\t\tif ( set_post_thumbnail( $post_ID, $content_struct['wp_post_thumbnail'] ) === false )\n\t\t\t\t\treturn new IXR_Error( 404, __( 'Invalid attachment ID.' ) );\n\t\t\t}\n\t\t\tunset( $content_struct['wp_post_thumbnail'] );\n\t\t}\n\n\t\t// Handle enclosures.\n\t\t$thisEnclosure = isset($content_struct['enclosure']) ? $content_struct['enclosure'] : null;\n\t\t$this->add_enclosure_if_new($post_ID, $thisEnclosure);\n\n\t\t$this->attach_uploads( $ID, $post_content );\n\n\t\t// Handle post formats if assigned, validation is handled earlier in this function.\n\t\tif ( isset( $content_struct['wp_post_format'] ) )\n\t\t\tset_post_format( $post_ID, $content_struct['wp_post_format'] );\n\n\t\t/**\n\t\t * Fires after a post has been successfully updated via the XML-RPC MovableType API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $post_ID ID of the updated post.\n\t\t * @param array $args    An array of arguments to update the post.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_mw_editPost', $post_ID, $args );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieve post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mw_getPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[0];\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t$postdata = get_post($post_ID, ARRAY_A);\n\t\tif ( ! $postdata )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_post', $post_ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.getPost' );\n\n\t\tif ($postdata['post_date'] != '') {\n\t\t\t$post_date = $this->_convert_date( $postdata['post_date'] );\n\t\t\t$post_date_gmt = $this->_convert_date_gmt( $postdata['post_date_gmt'],  $postdata['post_date'] );\n\t\t\t$post_modified = $this->_convert_date( $postdata['post_modified'] );\n\t\t\t$post_modified_gmt = $this->_convert_date_gmt( $postdata['post_modified_gmt'], $postdata['post_modified'] );\n\n\t\t\t$categories = array();\n\t\t\t$catids = wp_get_post_categories($post_ID);\n\t\t\tforeach($catids as $catid)\n\t\t\t\t$categories[] = get_cat_name($catid);\n\n\t\t\t$tagnames = array();\n\t\t\t$tags = wp_get_post_tags( $post_ID );\n\t\t\tif ( !empty( $tags ) ) {\n\t\t\t\tforeach ( $tags as $tag )\n\t\t\t\t\t$tagnames[] = $tag->name;\n\t\t\t\t$tagnames = implode( ', ', $tagnames );\n\t\t\t} else {\n\t\t\t\t$tagnames = '';\n\t\t\t}\n\n\t\t\t$post = get_extended($postdata['post_content']);\n\t\t\t$link = post_permalink($postdata['ID']);\n\n\t\t\t// Get the author info.\n\t\t\t$author = get_userdata($postdata['post_author']);\n\n\t\t\t$allow_comments = ('open' == $postdata['comment_status']) ? 1 : 0;\n\t\t\t$allow_pings = ('open' == $postdata['ping_status']) ? 1 : 0;\n\n\t\t\t// Consider future posts as published\n\t\t\tif ( $postdata['post_status'] === 'future' )\n\t\t\t\t$postdata['post_status'] = 'publish';\n\n\t\t\t// Get post format\n\t\t\t$post_format = get_post_format( $post_ID );\n\t\t\tif ( empty( $post_format ) )\n\t\t\t\t$post_format = 'standard';\n\n\t\t\t$sticky = false;\n\t\t\tif ( is_sticky( $post_ID ) )\n\t\t\t\t$sticky = true;\n\n\t\t\t$enclosure = array();\n\t\t\tforeach ( (array) get_post_custom($post_ID) as $key => $val) {\n\t\t\t\tif ($key == 'enclosure') {\n\t\t\t\t\tforeach ( (array) $val as $enc ) {\n\t\t\t\t\t\t$encdata = explode(\"\\n\", $enc);\n\t\t\t\t\t\t$enclosure['url'] = trim(htmlspecialchars($encdata[0]));\n\t\t\t\t\t\t$enclosure['length'] = (int) trim($encdata[1]);\n\t\t\t\t\t\t$enclosure['type'] = trim($encdata[2]);\n\t\t\t\t\t\tbreak 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$resp = array(\n\t\t\t\t'dateCreated' => $post_date,\n\t\t\t\t'userid' => $postdata['post_author'],\n\t\t\t\t'postid' => $postdata['ID'],\n\t\t\t\t'description' => $post['main'],\n\t\t\t\t'title' => $postdata['post_title'],\n\t\t\t\t'link' => $link,\n\t\t\t\t'permaLink' => $link,\n\t\t\t\t// commented out because no other tool seems to use this\n\t\t\t\t//\t      'content' => $entry['post_content'],\n\t\t\t\t'categories' => $categories,\n\t\t\t\t'mt_excerpt' => $postdata['post_excerpt'],\n\t\t\t\t'mt_text_more' => $post['extended'],\n\t\t\t\t'wp_more_text' => $post['more_text'],\n\t\t\t\t'mt_allow_comments' => $allow_comments,\n\t\t\t\t'mt_allow_pings' => $allow_pings,\n\t\t\t\t'mt_keywords' => $tagnames,\n\t\t\t\t'wp_slug' => $postdata['post_name'],\n\t\t\t\t'wp_password' => $postdata['post_password'],\n\t\t\t\t'wp_author_id' => (string) $author->ID,\n\t\t\t\t'wp_author_display_name' => $author->display_name,\n\t\t\t\t'date_created_gmt' => $post_date_gmt,\n\t\t\t\t'post_status' => $postdata['post_status'],\n\t\t\t\t'custom_fields' => $this->get_custom_fields($post_ID),\n\t\t\t\t'wp_post_format' => $post_format,\n\t\t\t\t'sticky' => $sticky,\n\t\t\t\t'date_modified' => $post_modified,\n\t\t\t\t'date_modified_gmt' => $post_modified_gmt\n\t\t\t);\n\n\t\t\tif ( !empty($enclosure) ) $resp['enclosure'] = $enclosure;\n\n\t\t\t$resp['wp_post_thumbnail'] = get_post_thumbnail_id( $postdata['ID'] );\n\n\t\t\treturn $resp;\n\t\t} else {\n\t\t\treturn new IXR_Error(404, __('Sorry, no such post.'));\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve list of recent posts.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $numberposts\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mw_getRecentPosts( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\tif ( isset( $args[3] ) )\n\t\t\t$query = array( 'numberposts' => absint( $args[3] ) );\n\t\telse\n\t\t\t$query = array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( ! current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit posts on this site.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.getRecentPosts' );\n\n\t\t$posts_list = wp_get_recent_posts( $query );\n\n\t\tif ( !$posts_list )\n\t\t\treturn array();\n\n\t\t$recent_posts = array();\n\t\tforeach ($posts_list as $entry) {\n\t\t\tif ( !current_user_can( 'edit_post', $entry['ID'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$post_date = $this->_convert_date( $entry['post_date'] );\n\t\t\t$post_date_gmt = $this->_convert_date_gmt( $entry['post_date_gmt'], $entry['post_date'] );\n\t\t\t$post_modified = $this->_convert_date( $entry['post_modified'] );\n\t\t\t$post_modified_gmt = $this->_convert_date_gmt( $entry['post_modified_gmt'], $entry['post_modified'] );\n\n\t\t\t$categories = array();\n\t\t\t$catids = wp_get_post_categories($entry['ID']);\n\t\t\tforeach( $catids as $catid )\n\t\t\t\t$categories[] = get_cat_name($catid);\n\n\t\t\t$tagnames = array();\n\t\t\t$tags = wp_get_post_tags( $entry['ID'] );\n\t\t\tif ( !empty( $tags ) ) {\n\t\t\t\tforeach ( $tags as $tag ) {\n\t\t\t\t\t$tagnames[] = $tag->name;\n\t\t\t\t}\n\t\t\t\t$tagnames = implode( ', ', $tagnames );\n\t\t\t} else {\n\t\t\t\t$tagnames = '';\n\t\t\t}\n\n\t\t\t$post = get_extended($entry['post_content']);\n\t\t\t$link = post_permalink($entry['ID']);\n\n\t\t\t// Get the post author info.\n\t\t\t$author = get_userdata($entry['post_author']);\n\n\t\t\t$allow_comments = ('open' == $entry['comment_status']) ? 1 : 0;\n\t\t\t$allow_pings = ('open' == $entry['ping_status']) ? 1 : 0;\n\n\t\t\t// Consider future posts as published\n\t\t\tif ( $entry['post_status'] === 'future' )\n\t\t\t\t$entry['post_status'] = 'publish';\n\n\t\t\t// Get post format\n\t\t\t$post_format = get_post_format( $entry['ID'] );\n\t\t\tif ( empty( $post_format ) )\n\t\t\t\t$post_format = 'standard';\n\n\t\t\t$recent_posts[] = array(\n\t\t\t\t'dateCreated' => $post_date,\n\t\t\t\t'userid' => $entry['post_author'],\n\t\t\t\t'postid' => (string) $entry['ID'],\n\t\t\t\t'description' => $post['main'],\n\t\t\t\t'title' => $entry['post_title'],\n\t\t\t\t'link' => $link,\n\t\t\t\t'permaLink' => $link,\n\t\t\t\t// commented out because no other tool seems to use this\n\t\t\t\t// 'content' => $entry['post_content'],\n\t\t\t\t'categories' => $categories,\n\t\t\t\t'mt_excerpt' => $entry['post_excerpt'],\n\t\t\t\t'mt_text_more' => $post['extended'],\n\t\t\t\t'wp_more_text' => $post['more_text'],\n\t\t\t\t'mt_allow_comments' => $allow_comments,\n\t\t\t\t'mt_allow_pings' => $allow_pings,\n\t\t\t\t'mt_keywords' => $tagnames,\n\t\t\t\t'wp_slug' => $entry['post_name'],\n\t\t\t\t'wp_password' => $entry['post_password'],\n\t\t\t\t'wp_author_id' => (string) $author->ID,\n\t\t\t\t'wp_author_display_name' => $author->display_name,\n\t\t\t\t'date_created_gmt' => $post_date_gmt,\n\t\t\t\t'post_status' => $entry['post_status'],\n\t\t\t\t'custom_fields' => $this->get_custom_fields($entry['ID']),\n\t\t\t\t'wp_post_format' => $post_format,\n\t\t\t\t'date_modified' => $post_modified,\n\t\t\t\t'date_modified_gmt' => $post_modified_gmt,\n\t\t\t\t'sticky' => ( $entry['post_type'] === 'post' && is_sticky( $entry['ID'] ) ),\n\t\t\t\t'wp_post_thumbnail' => get_post_thumbnail_id( $entry['ID'] )\n\t\t\t);\n\t\t}\n\n\t\treturn $recent_posts;\n\t}\n\n\t/**\n\t * Retrieve the list of categories on a given blog.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mw_getCategories( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view categories.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.getCategories' );\n\n\t\t$categories_struct = array();\n\n\t\tif ( $cats = get_categories(array('get' => 'all')) ) {\n\t\t\tforeach ( $cats as $cat ) {\n\t\t\t\t$struct = array();\n\t\t\t\t$struct['categoryId'] = $cat->term_id;\n\t\t\t\t$struct['parentId'] = $cat->parent;\n\t\t\t\t$struct['description'] = $cat->name;\n\t\t\t\t$struct['categoryDescription'] = $cat->description;\n\t\t\t\t$struct['categoryName'] = $cat->name;\n\t\t\t\t$struct['htmlUrl'] = esc_html(get_category_link($cat->term_id));\n\t\t\t\t$struct['rssUrl'] = esc_html(get_category_feed_link($cat->term_id, 'rss2'));\n\n\t\t\t\t$categories_struct[] = $struct;\n\t\t\t}\n\t\t}\n\n\t\treturn $categories_struct;\n\t}\n\n\t/**\n\t * Uploads a file, following your settings.\n\t *\n\t * Adapted from a patch by Johann Richard.\n\t *\n\t * @link http://mycvs.org/archives/2004/06/30/file-upload-to-wordpress-in-ecto/\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $data\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mw_newMediaObject( $args ) {\n\t\tglobal $wpdb;\n\n\t\t$username = $this->escape( $args[1] );\n\t\t$password = $this->escape( $args[2] );\n\t\t$data     = $args[3];\n\n\t\t$name = sanitize_file_name( $data['name'] );\n\t\t$type = $data['type'];\n\t\t$bits = $data['bits'];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'metaWeblog.newMediaObject' );\n\n\t\tif ( !current_user_can('upload_files') ) {\n\t\t\t$this->error = new IXR_Error( 401, __( 'You do not have permission to upload files.' ) );\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t/**\n\t\t * Filter whether to preempt the XML-RPC media upload.\n\t\t *\n\t\t * Passing a truthy value will effectively short-circuit the media upload,\n\t\t * returning that value as a 500 error instead.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param bool $error Whether to pre-empt the media upload. Default false.\n\t\t */\n\t\tif ( $upload_err = apply_filters( 'pre_upload_error', false ) ) {\n\t\t\treturn new IXR_Error( 500, $upload_err );\n\t\t}\n\n\t\tif ( !empty($data['overwrite']) && ($data['overwrite'] == true) ) {\n\t\t\t// Get postmeta info on the object.\n\t\t\t$old_file = $wpdb->get_row(\"\n\t\t\t\tSELECT ID\n\t\t\t\tFROM {$wpdb->posts}\n\t\t\t\tWHERE post_title = '{$name}'\n\t\t\t\t\tAND post_type = 'attachment'\n\t\t\t\");\n\n\t\t\t// Delete previous file.\n\t\t\twp_delete_attachment($old_file->ID);\n\n\t\t\t// Make sure the new name is different by pre-pending the\n\t\t\t// previous post id.\n\t\t\t$filename = preg_replace('/^wpid\\d+-/', '', $name);\n\t\t\t$name = \"wpid{$old_file->ID}-{$filename}\";\n\t\t}\n\n\t\t$upload = wp_upload_bits($name, null, $bits);\n\t\tif ( ! empty($upload['error']) ) {\n\t\t\t$errorString = sprintf(__('Could not write file %1$s (%2$s)'), $name, $upload['error']);\n\t\t\treturn new IXR_Error(500, $errorString);\n\t\t}\n\t\t// Construct the attachment array\n\t\t$post_id = 0;\n\t\tif ( ! empty( $data['post_id'] ) ) {\n\t\t\t$post_id = (int) $data['post_id'];\n\n\t\t\tif ( ! current_user_can( 'edit_post', $post_id ) )\n\t\t\t\treturn new IXR_Error( 401, __( 'Sorry, you cannot edit this post.' ) );\n\t\t}\n\t\t$attachment = array(\n\t\t\t'post_title' => $name,\n\t\t\t'post_content' => '',\n\t\t\t'post_type' => 'attachment',\n\t\t\t'post_parent' => $post_id,\n\t\t\t'post_mime_type' => $type,\n\t\t\t'guid' => $upload[ 'url' ]\n\t\t);\n\n\t\t// Save the data\n\t\t$id = wp_insert_attachment( $attachment, $upload[ 'file' ], $post_id );\n\t\twp_update_attachment_metadata( $id, wp_generate_attachment_metadata( $id, $upload['file'] ) );\n\n\t\t/**\n\t\t * Fires after a new attachment has been added via the XML-RPC MovableType API.\n\t\t *\n\t\t * @since 3.4.0\n\t\t *\n\t\t * @param int   $id   ID of the new attachment.\n\t\t * @param array $args An array of arguments to add the attachment.\n\t\t */\n\t\tdo_action( 'xmlrpc_call_success_mw_newMediaObject', $id, $args );\n\n\t\t$struct = array(\n\t\t\t'id'   => strval( $id ),\n\t\t\t'file' => $name,\n\t\t\t'url'  => $upload[ 'url' ],\n\t\t\t'type' => $type\n\t\t);\n\n\t\t/** This filter is documented in wp-admin/includes/file.php */\n\t\treturn apply_filters( 'wp_handle_upload', $struct, 'upload' );\n\t}\n\n\t/* MovableType API functions\n\t * specs on http://www.movabletype.org/docs/mtmanual_programmatic.html\n\t */\n\n\t/**\n\t * Retrieve the post titles of recent posts.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type int    $numberposts\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mt_getRecentPostTitles( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\t\tif ( isset( $args[3] ) )\n\t\t\t$query = array( 'numberposts' => absint( $args[3] ) );\n\t\telse\n\t\t\t$query = array();\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.getRecentPostTitles' );\n\n\t\t$posts_list = wp_get_recent_posts( $query );\n\n\t\tif ( !$posts_list ) {\n\t\t\t$this->error = new IXR_Error(500, __('Either there are no posts, or something went wrong.'));\n\t\t\treturn $this->error;\n\t\t}\n\n\t\t$recent_posts = array();\n\n\t\tforeach ($posts_list as $entry) {\n\t\t\tif ( !current_user_can( 'edit_post', $entry['ID'] ) )\n\t\t\t\tcontinue;\n\n\t\t\t$post_date = $this->_convert_date( $entry['post_date'] );\n\t\t\t$post_date_gmt = $this->_convert_date_gmt( $entry['post_date_gmt'], $entry['post_date'] );\n\n\t\t\t$recent_posts[] = array(\n\t\t\t\t'dateCreated' => $post_date,\n\t\t\t\t'userid' => $entry['post_author'],\n\t\t\t\t'postid' => (string) $entry['ID'],\n\t\t\t\t'title' => $entry['post_title'],\n\t\t\t\t'post_status' => $entry['post_status'],\n\t\t\t\t'date_created_gmt' => $post_date_gmt\n\t\t\t);\n\t\t}\n\n\t\treturn $recent_posts;\n\t}\n\n\t/**\n\t * Retrieve list of all categories on blog.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $blog_id (unused)\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mt_getCategoryList( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( !current_user_can( 'edit_posts' ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you must be able to edit posts on this site in order to view categories.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.getCategoryList' );\n\n\t\t$categories_struct = array();\n\n\t\tif ( $cats = get_categories(array('hide_empty' => 0, 'hierarchical' => 0)) ) {\n\t\t\tforeach ( $cats as $cat ) {\n\t\t\t\t$struct = array();\n\t\t\t\t$struct['categoryId'] = $cat->term_id;\n\t\t\t\t$struct['categoryName'] = $cat->name;\n\n\t\t\t\t$categories_struct[] = $struct;\n\t\t\t}\n\t\t}\n\n\t\treturn $categories_struct;\n\t}\n\n\t/**\n\t * Retrieve post categories.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return array|IXR_Error\n\t */\n\tpublic function mt_getPostCategories( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[0];\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\tif ( ! get_post( $post_ID ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can( 'edit_post', $post_ID ) )\n\t\t\treturn new IXR_Error( 401, __( 'Sorry, you can not edit this post.' ) );\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.getPostCategories' );\n\n\t\t$categories = array();\n\t\t$catids = wp_get_post_categories(intval($post_ID));\n\t\t// first listed category will be the primary category\n\t\t$isPrimary = true;\n\t\tforeach ( $catids as $catid ) {\n\t\t\t$categories[] = array(\n\t\t\t\t'categoryName' => get_cat_name($catid),\n\t\t\t\t'categoryId' => (string) $catid,\n\t\t\t\t'isPrimary' => $isPrimary\n\t\t\t);\n\t\t\t$isPrimary = false;\n\t\t}\n\n\t\treturn $categories;\n\t}\n\n\t/**\n\t * Sets categories for a post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t *     @type array  $categories\n\t * }\n\t * @return true|IXR_Error True on success.\n\t */\n\tpublic function mt_setPostCategories( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID    = (int) $args[0];\n\t\t$username   = $args[1];\n\t\t$password   = $args[2];\n\t\t$categories = $args[3];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.setPostCategories' );\n\n\t\tif ( ! get_post( $post_ID ) )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can('edit_post', $post_ID) )\n\t\t\treturn new IXR_Error(401, __('Sorry, you cannot edit this post.'));\n\n\t\t$catids = array();\n\t\tforeach ( $categories as $cat ) {\n\t\t\t$catids[] = $cat['categoryId'];\n\t\t}\n\n\t\twp_set_post_categories($post_ID, $catids);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retrieve an array of methods supported by this server.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return array\n\t */\n\tpublic function mt_supportedMethods() {\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.supportedMethods' );\n\n\t\treturn array_keys( $this->methods );\n\t}\n\n\t/**\n\t * Retrieve an empty array because we don't support per-post text filters.\n\t *\n\t * @since 1.5.0\n\t */\n\tpublic function mt_supportedTextFilters() {\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.supportedTextFilters' );\n\n\t\t/**\n\t\t * Filter the MoveableType text filters list for XML-RPC.\n\t\t *\n\t\t * @since 2.2.0\n\t\t *\n\t\t * @param array $filters An array of text filters.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_text_filters', array() );\n\t}\n\n\t/**\n\t * Retrieve trackbacks sent to a given post.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param int $post_ID\n\t * @return array|IXR_Error\n\t */\n\tpublic function mt_getTrackbackPings( $post_ID ) {\n\t\tglobal $wpdb;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.getTrackbackPings' );\n\n\t\t$actual_post = get_post($post_ID, ARRAY_A);\n\n\t\tif ( !$actual_post )\n\t\t\treturn new IXR_Error(404, __('Sorry, no such post.'));\n\n\t\t$comments = $wpdb->get_results( $wpdb->prepare(\"SELECT comment_author_url, comment_content, comment_author_IP, comment_type FROM $wpdb->comments WHERE comment_post_ID = %d\", $post_ID) );\n\n\t\tif ( !$comments )\n\t\t\treturn array();\n\n\t\t$trackback_pings = array();\n\t\tforeach ( $comments as $comment ) {\n\t\t\tif ( 'trackback' == $comment->comment_type ) {\n\t\t\t\t$content = $comment->comment_content;\n\t\t\t\t$title = substr($content, 8, (strpos($content, '</strong>') - 8));\n\t\t\t\t$trackback_pings[] = array(\n\t\t\t\t\t'pingTitle' => $title,\n\t\t\t\t\t'pingURL'   => $comment->comment_author_url,\n\t\t\t\t\t'pingIP'    => $comment->comment_author_IP\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn $trackback_pings;\n\t}\n\n\t/**\n\t * Sets a post's publish status to 'publish'.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type int    $post_ID\n\t *     @type string $username\n\t *     @type string $password\n\t * }\n\t * @return int|IXR_Error\n\t */\n\tpublic function mt_publishPost( $args ) {\n\t\t$this->escape( $args );\n\n\t\t$post_ID  = (int) $args[0];\n\t\t$username = $args[1];\n\t\t$password = $args[2];\n\n\t\tif ( !$user = $this->login($username, $password) )\n\t\t\treturn $this->error;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'mt.publishPost' );\n\n\t\t$postdata = get_post($post_ID, ARRAY_A);\n\t\tif ( ! $postdata )\n\t\t\treturn new IXR_Error( 404, __( 'Invalid post ID.' ) );\n\n\t\tif ( !current_user_can('publish_posts') || !current_user_can('edit_post', $post_ID) )\n\t\t\treturn new IXR_Error(401, __('Sorry, you cannot publish this post.'));\n\n\t\t$postdata['post_status'] = 'publish';\n\n\t\t// retain old cats\n\t\t$cats = wp_get_post_categories($post_ID);\n\t\t$postdata['post_category'] = $cats;\n\t\t$this->escape($postdata);\n\n\t\treturn wp_update_post( $postdata );\n\t}\n\n\t/* PingBack functions\n\t * specs on www.hixie.ch/specs/pingback/pingback\n\t */\n\n\t/**\n\t * Retrieves a pingback and registers it.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global wpdb $wpdb\n\t * @global string $wp_version\n\t *\n\t * @param array  $args {\n\t *     Method arguments. Note: arguments must be ordered as documented.\n\t *\n\t *     @type string $pagelinkedfrom\n\t *     @type string $pagelinkedto\n\t * }\n\t * @return string|IXR_Error\n\t */\n\tpublic function pingback_ping( $args ) {\n\t\tglobal $wpdb, $wp_version;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'pingback.ping' );\n\n\t\t$this->escape( $args );\n\n\t\t$pagelinkedfrom = str_replace( '&amp;', '&', $args[0] );\n\t\t$pagelinkedto = str_replace( '&amp;', '&', $args[1] );\n\t\t$pagelinkedto = str_replace( '&', '&amp;', $pagelinkedto );\n\n\t\t/**\n\t\t * Filter the pingback source URI.\n\t\t *\n\t\t * @since 3.6.0\n\t\t *\n\t\t * @param string $pagelinkedfrom URI of the page linked from.\n\t\t * @param string $pagelinkedto   URI of the page linked to.\n\t\t */\n\t\t$pagelinkedfrom = apply_filters( 'pingback_ping_source_uri', $pagelinkedfrom, $pagelinkedto );\n\n\t\tif ( ! $pagelinkedfrom )\n\t\t\treturn $this->pingback_error( 0, __( 'A valid URL was not provided.' ) );\n\n\t\t// Check if the page linked to is in our site\n\t\t$pos1 = strpos($pagelinkedto, str_replace(array('http://www.','http://','https://www.','https://'), '', get_option('home')));\n\t\tif ( !$pos1 )\n\t\t\treturn $this->pingback_error( 0, __( 'Is there no link to us?' ) );\n\n\t\t// let's find which post is linked to\n\t\t// FIXME: does url_to_postid() cover all these cases already?\n\t\t//        if so, then let's use it and drop the old code.\n\t\t$urltest = parse_url($pagelinkedto);\n\t\tif ( $post_ID = url_to_postid($pagelinkedto) ) {\n\t\t\t// $way\n\t\t} elseif ( isset( $urltest['path'] ) && preg_match('#p/[0-9]{1,}#', $urltest['path'], $match) ) {\n\t\t\t// the path defines the post_ID (archives/p/XXXX)\n\t\t\t$blah = explode('/', $match[0]);\n\t\t\t$post_ID = (int) $blah[1];\n\t\t} elseif ( isset( $urltest['query'] ) && preg_match('#p=[0-9]{1,}#', $urltest['query'], $match) ) {\n\t\t\t// the querystring defines the post_ID (?p=XXXX)\n\t\t\t$blah = explode('=', $match[0]);\n\t\t\t$post_ID = (int) $blah[1];\n\t\t} elseif ( isset($urltest['fragment']) ) {\n\t\t\t// an #anchor is there, it's either...\n\t\t\tif ( intval($urltest['fragment']) ) {\n\t\t\t\t// ...an integer #XXXX (simplest case)\n\t\t\t\t$post_ID = (int) $urltest['fragment'];\n\t\t\t} elseif ( preg_match('/post-[0-9]+/',$urltest['fragment']) ) {\n\t\t\t\t// ...a post id in the form 'post-###'\n\t\t\t\t$post_ID = preg_replace('/[^0-9]+/', '', $urltest['fragment']);\n\t\t\t} elseif ( is_string($urltest['fragment']) ) {\n\t\t\t\t// ...or a string #title, a little more complicated\n\t\t\t\t$title = preg_replace('/[^a-z0-9]/i', '.', $urltest['fragment']);\n\t\t\t\t$sql = $wpdb->prepare(\"SELECT ID FROM $wpdb->posts WHERE post_title RLIKE %s\", $title );\n\t\t\t\tif (! ($post_ID = $wpdb->get_var($sql)) ) {\n\t\t\t\t\t// returning unknown error '0' is better than die()ing\n\t\t\t  \t\treturn $this->pingback_error( 0, '' );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// TODO: Attempt to extract a post ID from the given URL\n\t  \t\treturn $this->pingback_error( 33, __('The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.' ) );\n\t\t}\n\t\t$post_ID = (int) $post_ID;\n\n\t\t$post = get_post($post_ID);\n\n\t\tif ( !$post ) // Post_ID not found\n\t  \t\treturn $this->pingback_error( 33, __( 'The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.' ) );\n\n\t\tif ( $post_ID == url_to_postid($pagelinkedfrom) )\n\t\t\treturn $this->pingback_error( 0, __( 'The source URL and the target URL cannot both point to the same resource.' ) );\n\n\t\t// Check if pings are on\n\t\tif ( !pings_open($post) )\n\t  \t\treturn $this->pingback_error( 33, __( 'The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.' ) );\n\n\t\t// Let's check that the remote site didn't already pingback this entry\n\t\tif ( $wpdb->get_results( $wpdb->prepare(\"SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_author_url = %s\", $post_ID, $pagelinkedfrom) ) )\n\t\t\treturn $this->pingback_error( 48, __( 'The pingback has already been registered.' ) );\n\n\t\t// very stupid, but gives time to the 'from' server to publish !\n\t\tsleep(1);\n\n\t\t$remote_ip = preg_replace( '/[^0-9a-fA-F:., ]/', '', $_SERVER['REMOTE_ADDR'] );\n\n\t\t/** This filter is documented in wp-includes/class-http.php */\n\t\t$user_agent = apply_filters( 'http_headers_useragent', 'WordPress/' . $wp_version . '; ' . get_bloginfo( 'url' ) );\n\n\t\t// Let's check the remote site\n\t\t$http_api_args = array(\n\t\t\t'timeout' => 10,\n\t\t\t'redirection' => 0,\n\t\t\t'limit_response_size' => 153600, // 150 KB\n\t\t\t'user-agent' => \"$user_agent; verifying pingback from $remote_ip\",\n\t\t\t'headers' => array(\n\t\t\t\t'X-Pingback-Forwarded-For' => $remote_ip,\n\t\t\t),\n\t\t);\n\t\t$request = wp_safe_remote_get( $pagelinkedfrom, $http_api_args );\n\t\t$linea = wp_remote_retrieve_body( $request );\n\n\t\tif ( !$linea )\n\t\t\treturn $this->pingback_error( 16, __( 'The source URL does not exist.' ) );\n\n\t\t/**\n\t\t * Filter the pingback remote source.\n\t\t *\n\t\t * @since 2.5.0\n\t\t *\n\t\t * @param string $linea        Response object for the page linked from.\n\t\t * @param string $pagelinkedto URL of the page linked to.\n\t\t */\n\t\t$linea = apply_filters( 'pre_remote_source', $linea, $pagelinkedto );\n\n\t\t// Work around bug in strip_tags():\n\t\t$linea = str_replace('<!DOC', '<DOC', $linea);\n\t\t$linea = preg_replace( '/[\\r\\n\\t ]+/', ' ', $linea ); // normalize spaces\n\t\t$linea = preg_replace( \"/<\\/*(h1|h2|h3|h4|h5|h6|p|th|td|li|dt|dd|pre|caption|input|textarea|button|body)[^>]*>/\", \"\\n\\n\", $linea );\n\n\t\tpreg_match('|<title>([^<]*?)</title>|is', $linea, $matchtitle);\n\t\t$title = $matchtitle[1];\n\t\tif ( empty( $title ) )\n\t\t\treturn $this->pingback_error( 32, __('We cannot find a title on that page.' ) );\n\n\t\t$linea = strip_tags( $linea, '<a>' ); // just keep the tag we need\n\n\t\t$p = explode( \"\\n\\n\", $linea );\n\n\t\t$preg_target = preg_quote($pagelinkedto, '|');\n\n\t\tforeach ( $p as $para ) {\n\t\t\tif ( strpos($para, $pagelinkedto) !== false ) { // it exists, but is it a link?\n\t\t\t\tpreg_match(\"|<a[^>]+?\".$preg_target.\"[^>]*>([^>]+?)</a>|\", $para, $context);\n\n\t\t\t\t// If the URL isn't in a link context, keep looking\n\t\t\t\tif ( empty($context) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// We're going to use this fake tag to mark the context in a bit\n\t\t\t\t// the marker is needed in case the link text appears more than once in the paragraph\n\t\t\t\t$excerpt = preg_replace('|\\</?wpcontext\\>|', '', $para);\n\n\t\t\t\t// prevent really long link text\n\t\t\t\tif ( strlen($context[1]) > 100 )\n\t\t\t\t\t$context[1] = substr($context[1], 0, 100) . '&#8230;';\n\n\t\t\t\t$marker = '<wpcontext>'.$context[1].'</wpcontext>';    // set up our marker\n\t\t\t\t$excerpt= str_replace($context[0], $marker, $excerpt); // swap out the link for our marker\n\t\t\t\t$excerpt = strip_tags($excerpt, '<wpcontext>');        // strip all tags but our context marker\n\t\t\t\t$excerpt = trim($excerpt);\n\t\t\t\t$preg_marker = preg_quote($marker, '|');\n\t\t\t\t$excerpt = preg_replace(\"|.*?\\s(.{0,100}$preg_marker.{0,100})\\s.*|s\", '$1', $excerpt);\n\t\t\t\t$excerpt = strip_tags($excerpt); // YES, again, to remove the marker wrapper\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( empty($context) ) // Link to target not found\n\t\t\treturn $this->pingback_error( 17, __( 'The source URL does not contain a link to the target URL, and so cannot be used as a source.' ) );\n\n\t\t$pagelinkedfrom = str_replace('&', '&amp;', $pagelinkedfrom);\n\n\t\t$context = '[&#8230;] ' . esc_html( $excerpt ) . ' [&#8230;]';\n\t\t$pagelinkedfrom = $this->escape( $pagelinkedfrom );\n\n\t\t$comment_post_ID = (int) $post_ID;\n\t\t$comment_author = $title;\n\t\t$comment_author_email = '';\n\t\t$this->escape($comment_author);\n\t\t$comment_author_url = $pagelinkedfrom;\n\t\t$comment_content = $context;\n\t\t$this->escape($comment_content);\n\t\t$comment_type = 'pingback';\n\n\t\t$commentdata = compact('comment_post_ID', 'comment_author', 'comment_author_url', 'comment_author_email', 'comment_content', 'comment_type');\n\n\t\t$comment_ID = wp_new_comment($commentdata);\n\n\t\t/**\n\t\t * Fires after a post pingback has been sent.\n\t\t *\n\t\t * @since 0.71\n\t\t *\n\t\t * @param int $comment_ID Comment ID.\n\t\t */\n\t\tdo_action( 'pingback_post', $comment_ID );\n\n\t\treturn sprintf(__('Pingback from %1$s to %2$s registered. Keep the web talking! :-)'), $pagelinkedfrom, $pagelinkedto);\n\t}\n\n\t/**\n\t * Retrieve array of URLs that pingbacked the given URL.\n\t *\n\t * Specs on http://www.aquarionics.com/misc/archives/blogite/0198.html\n\t *\n\t * @since 1.5.0\n\t *\n\t * @global wpdb $wpdb\n\t *\n\t * @param string $url\n\t * @return array|IXR_Error\n\t */\n\tpublic function pingback_extensions_getPingbacks( $url ) {\n\t\tglobal $wpdb;\n\n\t\t/** This action is documented in wp-includes/class-wp-xmlrpc-server.php */\n\t\tdo_action( 'xmlrpc_call', 'pingback.extensions.getPingbacks' );\n\n\t\t$url = $this->escape( $url );\n\n\t\t$post_ID = url_to_postid($url);\n\t\tif ( !$post_ID ) {\n\t\t\t// We aren't sure that the resource is available and/or pingback enabled\n\t  \t\treturn $this->pingback_error( 33, __( 'The specified target URL cannot be used as a target. It either doesn&#8217;t exist, or it is not a pingback-enabled resource.' ) );\n\t\t}\n\n\t\t$actual_post = get_post($post_ID, ARRAY_A);\n\n\t\tif ( !$actual_post ) {\n\t\t\t// No such post = resource not found\n\t  \t\treturn $this->pingback_error( 32, __('The specified target URL does not exist.' ) );\n\t\t}\n\n\t\t$comments = $wpdb->get_results( $wpdb->prepare(\"SELECT comment_author_url, comment_content, comment_author_IP, comment_type FROM $wpdb->comments WHERE comment_post_ID = %d\", $post_ID) );\n\n\t\tif ( !$comments )\n\t\t\treturn array();\n\n\t\t$pingbacks = array();\n\t\tforeach ( $comments as $comment ) {\n\t\t\tif ( 'pingback' == $comment->comment_type )\n\t\t\t\t$pingbacks[] = $comment->comment_author_url;\n\t\t}\n\n\t\treturn $pingbacks;\n\t}\n\n\t/**\n\t * @param integer $code\n\t * @param string $message\n\t * @return IXR_Error\n\t */\n\tprotected function pingback_error( $code, $message ) {\n\t\t/**\n\t\t * Filter the XML-RPC pingback error return.\n\t\t *\n\t\t * @since 3.5.1\n\t\t *\n\t\t * @param IXR_Error $error An IXR_Error object containing the error code and message.\n\t\t */\n\t\treturn apply_filters( 'xmlrpc_pingback_error', new IXR_Error( $code, $message ) );\n\t}\n}\n"], "filenames": ["wp-includes/class-wp-xmlrpc-server.php"], "buggy_code_start_loc": [5237], "buggy_code_end_loc": [5239], "fixing_code_start_loc": [5237], "fixing_code_end_loc": [5239], "type": "CWE-264", "message": "The mw_editPost function in wp-includes/class-wp-xmlrpc-server.php in the XMLRPC subsystem in WordPress before 4.3.1 allows remote authenticated users to bypass intended access restrictions, and arrange for a private post to be published and sticky, via unspecified vectors.", "other": {"cve": {"id": "CVE-2015-5715", "sourceIdentifier": "cve@mitre.org", "published": "2016-05-22T01:59:02.617", "lastModified": "2017-11-04T01:29:06.990", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mw_editPost function in wp-includes/class-wp-xmlrpc-server.php in the XMLRPC subsystem in WordPress before 4.3.1 allows remote authenticated users to bypass intended access restrictions, and arrange for a private post to be published and sticky, via unspecified vectors."}, {"lang": "es", "value": "La funci\u00f3n mw_editPost en wp-includes/class-wp-xmlrpc-server.php en el subsistema XMLRPC en WordPress en versiones anteriores a 4.3.1 permite a usuarios remotos autenticados eludir las restricciones destinadas al acceso y disponer para una publicaci\u00f3n privada que sera publicada y adherida, a trav\u00e9s de vectores no especificados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.0", "matchCriteriaId": "398224EA-459C-49CF-9176-B144CA74A0F2"}]}]}], "references": [{"url": "http://www.debian.org/security/2015/dsa-3375", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2015/dsa-3383", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/76748", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1033979", "source": "cve@mitre.org"}, {"url": "https://codex.wordpress.org/Version_4.3.1", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/9c57f3a4291f2311ae05f22c10eedeb0f69337ab", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2015-5715", "source": "cve@mitre.org"}, {"url": "https://wordpress.org/news/2015/09/wordpress-4-3-1/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/8188", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/9c57f3a4291f2311ae05f22c10eedeb0f69337ab"}}