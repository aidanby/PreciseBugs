{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                             GGGG  IIIII  FFFFF                              %\n%                            G        I    F                                  %\n%                            G  GG    I    FFF                                %\n%                            G   G    I    F                                  %\n%                             GGG   IIIII  F                                  %\n%                                                                             %\n%                                                                             %\n%            Read/Write Compuserv Graphics Interchange Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Define declarations.\n*/\n#define MaximumLZWBits  12\n#define MaximumLZWCode  (1UL << MaximumLZWBits)\n\f\n/*\n  Typdef declarations.\n*/\ntypedef struct _LZWCodeInfo\n{\n  unsigned char\n    buffer[280];\n\n  size_t\n    count,\n    bit;\n\n  MagickBooleanType\n    eof;\n} LZWCodeInfo;\n\ntypedef struct _LZWStack\n{\n  size_t\n    *codes,\n    *index,\n    *top;\n} LZWStack;\n\ntypedef struct _LZWInfo\n{\n  Image\n    *image;\n\n  LZWStack\n    *stack;\n\n  MagickBooleanType\n    genesis;\n\n  size_t\n    data_size,\n    maximum_data_value,\n    clear_code,\n    end_code,\n    bits,\n    first_code,\n    last_code,\n    maximum_code,\n    slot,\n    *table[2];\n\n  LZWCodeInfo\n    code_info;\n} LZWInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic inline int\n  GetNextLZWCode(LZWInfo *,const size_t);\n\nstatic MagickBooleanType\n  WriteGIFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic ssize_t\n  ReadBlobBlock(Image *,unsigned char *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage uncompresses an image via GIF-coding.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,const ssize_t opacity)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o opacity:  The colormap index associated with the transparent color.\n%\n*/\n\nstatic LZWInfo *RelinquishLZWInfo(LZWInfo *lzw_info)\n{\n  if (lzw_info->table[0] != (size_t *) NULL)\n    lzw_info->table[0]=(size_t *) RelinquishMagickMemory(\n      lzw_info->table[0]);\n  if (lzw_info->table[1] != (size_t *) NULL)\n    lzw_info->table[1]=(size_t *) RelinquishMagickMemory(\n      lzw_info->table[1]);\n  if (lzw_info->stack != (LZWStack *) NULL)\n    {\n      if (lzw_info->stack->codes != (size_t *) NULL)\n        lzw_info->stack->codes=(size_t *) RelinquishMagickMemory(\n          lzw_info->stack->codes);\n      lzw_info->stack=(LZWStack *) RelinquishMagickMemory(lzw_info->stack);\n    }\n  lzw_info=(LZWInfo *) RelinquishMagickMemory(lzw_info);\n  return((LZWInfo *) NULL);\n}\n\nstatic inline void ResetLZWInfo(LZWInfo *lzw_info)\n{\n  size_t\n    one;\n\n  lzw_info->bits=lzw_info->data_size+1;\n  one=1;\n  lzw_info->maximum_code=one << lzw_info->bits;\n  lzw_info->slot=lzw_info->maximum_data_value+3;\n  lzw_info->genesis=MagickTrue;\n}\n\nstatic LZWInfo *AcquireLZWInfo(Image *image,const size_t data_size)\n{\n  LZWInfo\n    *lzw_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    one;\n\n  lzw_info=(LZWInfo *) AcquireMagickMemory(sizeof(*lzw_info));\n  if (lzw_info == (LZWInfo *) NULL)\n    return((LZWInfo *) NULL);\n  (void) ResetMagickMemory(lzw_info,0,sizeof(*lzw_info));\n  lzw_info->image=image;\n  lzw_info->data_size=data_size;\n  one=1;\n  lzw_info->maximum_data_value=(one << data_size)-1;\n  lzw_info->clear_code=lzw_info->maximum_data_value+1;\n  lzw_info->end_code=lzw_info->maximum_data_value+2;\n  lzw_info->table[0]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(**lzw_info->table));\n  lzw_info->table[1]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(**lzw_info->table));\n  if ((lzw_info->table[0] == (size_t *) NULL) ||\n      (lzw_info->table[1] == (size_t *) NULL))\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  for (i=0; i <= (ssize_t) lzw_info->maximum_data_value; i++)\n  {\n    lzw_info->table[0][i]=0;\n    lzw_info->table[1][i]=(size_t) i;\n  }\n  ResetLZWInfo(lzw_info);\n  lzw_info->code_info.buffer[0]='\\0';\n  lzw_info->code_info.buffer[1]='\\0';\n  lzw_info->code_info.count=2;\n  lzw_info->code_info.bit=8*lzw_info->code_info.count;\n  lzw_info->code_info.eof=MagickFalse;\n  lzw_info->genesis=MagickTrue;\n  lzw_info->stack=(LZWStack *) AcquireMagickMemory(sizeof(*lzw_info->stack));\n  if (lzw_info->stack == (LZWStack *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->codes=(size_t *) AcquireQuantumMemory(2UL*\n    MaximumLZWCode,sizeof(*lzw_info->stack->codes));\n  if (lzw_info->stack->codes == (size_t *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->index=lzw_info->stack->codes;\n  lzw_info->stack->top=lzw_info->stack->codes+2*MaximumLZWCode;\n  return(lzw_info);\n}\n\nstatic inline int GetNextLZWCode(LZWInfo *lzw_info,const size_t bits)\n{\n  int\n    code;\n\n  register ssize_t\n    i;\n\n  size_t\n    one;\n\n  while (((lzw_info->code_info.bit+bits) > (8*lzw_info->code_info.count)) &&\n         (lzw_info->code_info.eof == MagickFalse))\n  {\n    ssize_t\n      count;\n\n    lzw_info->code_info.buffer[0]=lzw_info->code_info.buffer[\n      lzw_info->code_info.count-2];\n    lzw_info->code_info.buffer[1]=lzw_info->code_info.buffer[\n      lzw_info->code_info.count-1];\n    lzw_info->code_info.bit-=8*(lzw_info->code_info.count-2);\n    lzw_info->code_info.count=2;\n    count=ReadBlobBlock(lzw_info->image,&lzw_info->code_info.buffer[\n      lzw_info->code_info.count]);\n    if (count > 0)\n      lzw_info->code_info.count+=count;\n    else\n      lzw_info->code_info.eof=MagickTrue;\n  }\n  if ((lzw_info->code_info.bit+bits) > (8*lzw_info->code_info.count))\n    return(-1);\n  code=0;\n  one=1;\n  for (i=0; i < (ssize_t) bits; i++)\n  {\n    code|=((lzw_info->code_info.buffer[lzw_info->code_info.bit/8] &\n      (one << (lzw_info->code_info.bit % 8))) != 0) << i;\n    lzw_info->code_info.bit++;\n  }\n  return(code);\n}\n\nstatic inline int PopLZWStack(LZWStack *stack_info)\n{\n  if (stack_info->index <= stack_info->codes)\n    return(-1);\n  stack_info->index--;\n  return((int) *stack_info->index);\n}\n\nstatic inline void PushLZWStack(LZWStack *stack_info,const size_t value)\n{\n  if (stack_info->index >= stack_info->top)\n    return;\n  *stack_info->index=value;\n  stack_info->index++;\n}\n\nstatic int ReadBlobLZWByte(LZWInfo *lzw_info)\n{\n  int\n    code;\n\n  size_t\n    one,\n    value;\n\n  ssize_t\n    count;\n\n  if (lzw_info->stack->index != lzw_info->stack->codes)\n    return(PopLZWStack(lzw_info->stack));\n  if (lzw_info->genesis != MagickFalse)\n    {\n      lzw_info->genesis=MagickFalse;\n      do\n      {\n        lzw_info->first_code=(size_t) GetNextLZWCode(lzw_info,lzw_info->bits);\n        lzw_info->last_code=lzw_info->first_code;\n      } while (lzw_info->first_code == lzw_info->clear_code);\n      return((int) lzw_info->first_code);\n    }\n  code=GetNextLZWCode(lzw_info,lzw_info->bits);\n  if (code < 0)\n    return(code);\n  if ((size_t) code == lzw_info->clear_code)\n    {\n      ResetLZWInfo(lzw_info);\n      return(ReadBlobLZWByte(lzw_info));\n    }\n  if ((size_t) code == lzw_info->end_code)\n    return(-1);\n  if ((size_t) code < lzw_info->slot)\n    value=(size_t) code;\n  else\n    {\n      PushLZWStack(lzw_info->stack,lzw_info->first_code);\n      value=lzw_info->last_code;\n    }\n  count=0;\n  while (value > lzw_info->maximum_data_value)\n  {\n    if ((size_t) count > MaximumLZWCode)\n      return(-1);\n    count++;\n    if ((size_t) value > MaximumLZWCode)\n      return(-1);\n    PushLZWStack(lzw_info->stack,lzw_info->table[1][value]);\n    value=lzw_info->table[0][value];\n  }\n  lzw_info->first_code=lzw_info->table[1][value];\n  PushLZWStack(lzw_info->stack,lzw_info->first_code);\n  one=1;\n  if (lzw_info->slot < MaximumLZWCode)\n    {\n      lzw_info->table[0][lzw_info->slot]=lzw_info->last_code;\n      lzw_info->table[1][lzw_info->slot]=lzw_info->first_code;\n      lzw_info->slot++;\n      if ((lzw_info->slot >= lzw_info->maximum_code) &&\n          (lzw_info->bits < MaximumLZWBits))\n        {\n          lzw_info->bits++;\n          lzw_info->maximum_code=one << lzw_info->bits;\n        }\n    }\n  lzw_info->last_code=(size_t) code;\n  return(PopLZWStack(lzw_info->stack));\n}\n\nstatic MagickBooleanType DecodeImage(Image *image,const ssize_t opacity,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  LZWInfo\n    *lzw_info;\n\n  size_t\n    pass;\n\n  ssize_t\n    index,\n    offset,\n    y;\n\n  unsigned char\n    data_size;\n\n  /*\n    Allocate decoder tables.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  data_size=(unsigned char) ReadBlobByte(image);\n  if (data_size > MaximumLZWBits)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  lzw_info=AcquireLZWInfo(image,data_size);\n  if (lzw_info == (LZWInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  pass=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; )\n    {\n      c=ReadBlobLZWByte(lzw_info);\n      if (c < 0)\n        break;\n      index=ConstrainColormapIndex(image,(ssize_t) c,exception);\n      SetPixelIndex(image,(Quantum) index,q);\n      SetPixelViaPixelInfo(image,image->colormap+index,q);\n      SetPixelAlpha(image,index == opacity ? TransparentAlpha : OpaqueAlpha,q);\n      x++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (x < (ssize_t) image->columns)\n      break;\n    if (image->interlace == NoInterlace)\n      offset++;\n    else\n      {\n        switch (pass)\n        {\n          case 0:\n          default:\n          {\n            offset+=8;\n            break;\n          }\n          case 1:\n          {\n            offset+=8;\n            break;\n          }\n          case 2:\n          {\n            offset+=4;\n            break;\n          }\n          case 3:\n          {\n            offset+=2;\n            break;\n          }\n        }\n      if ((pass == 0) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=4;\n        }\n      if ((pass == 1) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=2;\n        }\n      if ((pass == 2) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=1;\n        }\n    }\n  }\n  lzw_info=RelinquishLZWInfo(lzw_info);\n  if (y < (ssize_t) image->rows)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E n c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EncodeImage compresses an image via GIF-coding.\n%\n%  The format of the EncodeImage method is:\n%\n%      MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n%        const size_t data_size)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the address of a structure of type Image.\n%\n%    o data_size:  The number of bits in the compressed packet.\n%\n*/\nstatic MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n  const size_t data_size,ExceptionInfo *exception)\n{\n#define MaxCode(number_bits)  ((one << (number_bits))-1)\n#define MaxHashTable  5003\n#define MaxGIFBits  12UL\n#define MaxGIFTable  (1UL << MaxGIFBits)\n#define GIFOutputCode(code) \\\n{ \\\n  /*  \\\n    Emit a code. \\\n  */ \\\n  if (bits > 0) \\\n    datum|=(code) << bits; \\\n  else \\\n    datum=code; \\\n  bits+=number_bits; \\\n  while (bits >= 8) \\\n  { \\\n    /*  \\\n      Add a character to current packet. \\\n    */ \\\n    packet[length++]=(unsigned char) (datum & 0xff); \\\n    if (length >= 254) \\\n      { \\\n        (void) WriteBlobByte(image,(unsigned char) length); \\\n        (void) WriteBlob(image,length,packet); \\\n        length=0; \\\n      } \\\n    datum>>=8; \\\n    bits-=8; \\\n  } \\\n  if (free_code > max_code)  \\\n    { \\\n      number_bits++; \\\n      if (number_bits == MaxGIFBits) \\\n        max_code=MaxGIFTable; \\\n      else \\\n        max_code=MaxCode(number_bits); \\\n    } \\\n}\n\n  Quantum\n    index;\n\n  short\n    *hash_code,\n    *hash_prefix,\n    waiting_code;\n\n  size_t\n    bits,\n    clear_code,\n    datum,\n    end_of_information_code,\n    free_code,\n    length,\n    max_code,\n    next_pixel,\n    number_bits,\n    one,\n    pass;\n\n  ssize_t\n    displacement,\n    offset,\n    k,\n    y;\n\n  unsigned char\n    *packet,\n    *hash_suffix;\n\n  /*\n    Allocate encoder tables.\n  */\n  assert(image != (Image *) NULL);\n  one=1;\n  packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));\n  hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));\n  hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));\n  hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,\n    sizeof(*hash_suffix));\n  if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||\n      (hash_prefix == (short *) NULL) ||\n      (hash_suffix == (unsigned char *) NULL))\n    {\n      if (packet != (unsigned char *) NULL)\n        packet=(unsigned char *) RelinquishMagickMemory(packet);\n      if (hash_code != (short *) NULL)\n        hash_code=(short *) RelinquishMagickMemory(hash_code);\n      if (hash_prefix != (short *) NULL)\n        hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n      if (hash_suffix != (unsigned char *) NULL)\n        hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n      return(MagickFalse);\n    }\n  /*\n    Initialize GIF encoder.\n  */\n  (void) ResetMagickMemory(hash_code,0,MaxHashTable*sizeof(*hash_code));\n  (void) ResetMagickMemory(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));\n  (void) ResetMagickMemory(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));\n  number_bits=data_size;\n  max_code=MaxCode(number_bits);\n  clear_code=((short) one << (data_size-1));\n  end_of_information_code=clear_code+1;\n  free_code=clear_code+2;\n  length=0;\n  datum=0;\n  bits=0;\n  GIFOutputCode(clear_code);\n  /*\n    Encode pixels.\n  */\n  offset=0;\n  pass=0;\n  waiting_code=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,offset,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (y == 0)\n      {\n        waiting_code=(short) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n    for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)\n    {\n      /*\n        Probe hash table.\n      */\n      index=(Quantum) ((size_t) GetPixelIndex(image,p) & 0xff);\n      p+=GetPixelChannels(image);\n      k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);\n      if (k >= MaxHashTable)\n        k-=MaxHashTable;\n      next_pixel=MagickFalse;\n      displacement=1;\n      if (hash_code[k] > 0)\n        {\n          if ((hash_prefix[k] == waiting_code) &&\n              (hash_suffix[k] == (unsigned char) index))\n            {\n              waiting_code=hash_code[k];\n              continue;\n            }\n          if (k != 0)\n            displacement=MaxHashTable-k;\n          for ( ; ; )\n          {\n            k-=displacement;\n            if (k < 0)\n              k+=MaxHashTable;\n            if (hash_code[k] == 0)\n              break;\n            if ((hash_prefix[k] == waiting_code) &&\n                (hash_suffix[k] == (unsigned char) index))\n              {\n                waiting_code=hash_code[k];\n                next_pixel=MagickTrue;\n                break;\n              }\n          }\n          if (next_pixel != MagickFalse)\n            continue;\n        }\n      GIFOutputCode((size_t) waiting_code);\n      if (free_code < MaxGIFTable)\n        {\n          hash_code[k]=(short) free_code++;\n          hash_prefix[k]=waiting_code;\n          hash_suffix[k]=(unsigned char) index;\n        }\n      else\n        {\n          /*\n            Fill the hash table with empty entries.\n          */\n          for (k=0; k < MaxHashTable; k++)\n            hash_code[k]=0;\n          /*\n            Reset compressor and issue a clear code.\n          */\n          free_code=clear_code+2;\n          GIFOutputCode(clear_code);\n          number_bits=data_size;\n          max_code=MaxCode(number_bits);\n        }\n      waiting_code=(short) index;\n    }\n    if (image_info->interlace == NoInterlace)\n      offset++;\n    else\n      switch (pass)\n      {\n        case 0:\n        default:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=4;\n            }\n          break;\n        }\n        case 1:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=2;\n            }\n          break;\n        }\n        case 2:\n        {\n          offset+=4;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=1;\n            }\n          break;\n        }\n        case 3:\n        {\n          offset+=2;\n          break;\n        }\n      }\n  }\n  /*\n    Flush out the buffered code.\n  */\n  GIFOutputCode((size_t) waiting_code);\n  GIFOutputCode(end_of_information_code);\n  if (bits > 0)\n    {\n      /*\n        Add a character to current packet.\n      */\n      packet[length++]=(unsigned char) (datum & 0xff);\n      if (length >= 254)\n        {\n          (void) WriteBlobByte(image,(unsigned char) length);\n          (void) WriteBlob(image,length,packet);\n          length=0;\n        }\n    }\n  /*\n    Flush accumulated data.\n  */\n  if (length > 0)\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      (void) WriteBlob(image,length,packet);\n    }\n  /*\n    Free encoder memory.\n  */\n  hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n  hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n  hash_code=(short *) RelinquishMagickMemory(hash_code);\n  packet=(unsigned char *) RelinquishMagickMemory(packet);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s G I F                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsGIF() returns MagickTrue if the image format type, identified by the\n%  magick string, is GIF.\n%\n%  The format of the IsGIF method is:\n%\n%      MagickBooleanType IsGIF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsGIF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"GIF8\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b B l o c k                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobBlock() reads data from the image file and returns it.  The\n%  amount of data is determined by first reading a count byte.  The number\n%  of bytes read is returned.\n%\n%  The format of the ReadBlobBlock method is:\n%\n%      ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o data:  Specifies an area to place the information requested from\n%      the file.\n%\n*/\nstatic ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n{\n  ssize_t\n    count;\n\n  unsigned char\n    block_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(data != (unsigned char *) NULL);\n  count=ReadBlob(image,1,&block_count);\n  if (count != 1)\n    return(0);\n  count=ReadBlob(image,(size_t) block_count,data);\n  if (count != (ssize_t) block_count)\n    return(0);\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G I F I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGIFImage() reads a Compuserve Graphics image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGIFImage method is:\n%\n%      Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType PingGIFImage(Image *image,ExceptionInfo *exception)\n{\n  unsigned char\n    buffer[256],\n    length,\n    data_size;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (ReadBlob(image,1,&data_size) != 1)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  if (data_size > MaximumLZWBits)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  if (ReadBlob(image,1,&length) != 1)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  while (length != 0)\n  {\n    if (ReadBlob(image,length,buffer) != (ssize_t) length)\n      ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n    if (ReadBlob(image,1,&length) != 1)\n      ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  }\n  return(MagickTrue);\n}\n\nstatic Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))\n#define LSBFirstOrder(x,y)  (((y) << 8) | (x))\n\n  Image\n    *image,\n    *meta_image;\n\n  int\n    number_extensionss=0;\n\n  MagickBooleanType\n    status;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    delay,\n    dispose,\n    duration,\n    global_colors,\n    image_count,\n    iterations,\n    one;\n\n  ssize_t\n    count,\n    opacity;\n\n  unsigned char\n    background,\n    c,\n    flag,\n    *global_colormap,\n    buffer[257];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a GIF file.\n  */\n  count=ReadBlob(image,6,buffer);\n  if ((count != 6) || ((LocaleNCompare((char *) buffer,\"GIF87\",5) != 0) &&\n      (LocaleNCompare((char *) buffer,\"GIF89\",5) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  page.width=ReadBlobLSBShort(image);\n  page.height=ReadBlobLSBShort(image);\n  flag=(unsigned char) ReadBlobByte(image);\n  background=(unsigned char) ReadBlobByte(image);\n  c=(unsigned char) ReadBlobByte(image);  /* reserved */\n  one=1;\n  global_colors=one << (((size_t) flag & 0x07)+1);\n  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n    MagickMax(global_colors,256),3UL*sizeof(*global_colormap));\n  if (global_colormap == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (BitSet((int) flag,0x80) != 0)\n    {\n      count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);\n      if (count != (ssize_t) (3*global_colors))\n        {\n          global_colormap=(unsigned char *) RelinquishMagickMemory(\n            global_colormap);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n    }\n  delay=0;\n  dispose=0;\n  duration=0;\n  iterations=1;\n  opacity=(-1);\n  image_count=0;\n  meta_image=AcquireImage(image_info,exception);  /* metadata container */\n  for ( ; ; )\n  {\n    count=ReadBlob(image,1,&c);\n    if (count != 1)\n      break;\n    if (c == (unsigned char) ';')\n      break;  /* terminator */\n    if (c == (unsigned char) '!')\n      {\n        /*\n          GIF Extension block.\n        */\n        count=ReadBlob(image,1,&c);\n        if (count != 1)\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToReadExtensionBlock\");\n          }\n        switch (c)\n        {\n          case 0xf9:\n          {\n            /*\n              Read graphics control extension.\n            */\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            dispose=(size_t) (buffer[0] >> 2);\n            delay=(size_t) ((buffer[2] << 8) | buffer[1]);\n            if ((ssize_t) (buffer[0] & 0x01) == 0x01)\n              opacity=(ssize_t) buffer[3];\n            break;\n          }\n          case 0xfe:\n          {\n            char\n              *comments;\n\n            size_t\n              length;\n\n            /*\n              Read comment extension.\n            */\n            comments=AcquireString((char *) NULL);\n            for (length=0; ; length+=count)\n            {\n              count=(ssize_t) ReadBlobBlock(image,buffer);\n              if (count == 0)\n                break;\n              buffer[count]='\\0';\n              (void) ConcatenateString(&comments,(const char *) buffer);\n            }\n            (void) SetImageProperty(meta_image,\"comment\",comments,exception);\n            comments=DestroyString(comments);\n            break;\n          }\n          case 0xff:\n          {\n            MagickBooleanType\n              loop;\n\n            /*\n              Read Netscape Loop extension.\n            */\n            loop=MagickFalse;\n            if (ReadBlobBlock(image,buffer) != 0)\n              loop=LocaleNCompare((char *) buffer,\"NETSCAPE2.0\",11) == 0 ?\n                MagickTrue : MagickFalse;\n            if (loop != MagickFalse)\n              {\n                while (ReadBlobBlock(image,buffer) != 0)\n                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);\n                break;\n              }\n            else\n              {\n                char\n                  name[MagickPathExtent];\n\n                int\n                  block_length,\n                  info_length,\n                  reserved_length;\n\n                MagickBooleanType\n                  i8bim,\n                  icc,\n                  iptc,\n                  magick;\n\n                StringInfo\n                  *profile;\n\n                unsigned char\n                  *info;\n\n                /*\n                  Store GIF application extension as a generic profile.\n                */\n                icc=LocaleNCompare((char *) buffer,\"ICCRGBG1012\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                magick=LocaleNCompare((char *) buffer,\"ImageMagick\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                i8bim=LocaleNCompare((char *) buffer,\"MGK8BIM0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                iptc=LocaleNCompare((char *) buffer,\"MGKIPTC0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                number_extensionss++;\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Reading GIF application extension\");\n                info=(unsigned char *) AcquireQuantumMemory(255UL,\n                  sizeof(*info));\n                if (info == (unsigned char *) NULL)\n                  {\n                    meta_image=DestroyImage(meta_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                reserved_length=255;\n                for (info_length=0; ; )\n                {\n                  block_length=(int) ReadBlobBlock(image,&info[info_length]);\n                  if (block_length == 0)\n                    break;\n                  info_length+=block_length;\n                  if (info_length > (reserved_length-255))\n                    {\n                      reserved_length+=4096;\n                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)\n                        reserved_length,sizeof(*info));\n                      if (info == (unsigned char *) NULL)\n                        {\n                          meta_image=DestroyImage(meta_image);\n                          ThrowReaderException(ResourceLimitError,\n                            \"MemoryAllocationFailed\");\n                        }\n                    }\n                }\n                profile=BlobToStringInfo(info,(size_t) info_length);\n                if (profile == (StringInfo *) NULL)\n                  {\n                    meta_image=DestroyImage(meta_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if (i8bim != MagickFalse)\n                  (void) CopyMagickString(name,\"8bim\",sizeof(name));\n                else if (icc != MagickFalse)\n                  (void) CopyMagickString(name,\"icc\",sizeof(name));\n                else if (iptc != MagickFalse)\n                  (void) CopyMagickString(name,\"iptc\",sizeof(name));\n                else if (magick != MagickFalse)\n                  {\n                    (void) CopyMagickString(name,\"magick\",sizeof(name));\n                    meta_image->gamma=StringToDouble((char *) info+6,\n                      (char **) NULL);\n                  }\n                else\n                  (void) FormatLocaleString(name,sizeof(name),\"gif:%.11s\",\n                    buffer);\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                if (magick == MagickFalse)\n                  (void) SetImageProfile(meta_image,name,profile,exception);\n                profile=DestroyStringInfo(profile);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      profile name=%s\",name);\n              }\n            break;\n          }\n          default:\n          {\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            break;\n          }\n        }\n      }\n    if (c != (unsigned char) ',')\n      continue;\n    if (image_count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n      }\n    image_count++;\n    /*\n      Read image attributes.\n    */\n    meta_image->scene=image->scene;\n    (void) CloneImageProperties(image,meta_image);\n    DestroyImageProperties(meta_image);\n    (void) CloneImageProfiles(image,meta_image);\n    DestroyImageProfiles(meta_image);\n    image->storage_class=PseudoClass;\n    image->compression=LZWCompression;\n    page.x=(ssize_t) ReadBlobLSBShort(image);\n    page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    image->depth=8;\n    flag=(unsigned char) ReadBlobByte(image);\n    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;\n    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<\n      ((size_t) (flag & 0x07)+1);\n    if (opacity >= (ssize_t) image->colors)\n      opacity=(-1);\n    image->page.width=page.width;\n    image->page.height=page.height;\n    image->page.y=page.y;\n    image->page.x=page.x;\n    image->delay=delay;\n    image->ticks_per_second=100;\n    image->dispose=(DisposeType) dispose;\n    image->iterations=iterations;\n    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;\n    delay=0;\n    dispose=0;\n    if ((image->columns == 0) || (image->rows == 0))\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n      }\n    /*\n      Inititialize colormap.\n    */\n    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (BitSet((int) flag,0x80) == 0)\n      {\n        /*\n          Use global colormap.\n        */\n        p=global_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            {\n              image->colormap[i].alpha=(double) TransparentAlpha;\n              image->transparent_color=image->colormap[opacity];\n            }\n        }\n        image->background_color=image->colormap[MagickMin((ssize_t) background,\n          (ssize_t) image->colors-1)];\n      }\n    else\n      {\n        unsigned char\n          *colormap;\n\n        /*\n          Read local colormap.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*\n          sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);\n        if (count != (ssize_t) (3*image->colors))\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            image->colormap[i].alpha=(double) TransparentAlpha;\n        }\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    if (image->gamma == 1.0)\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)\n            break;\n        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? \n          GRAYColorspace : RGBColorspace,exception);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Decode image.\n    */\n    if (image_info->ping != MagickFalse)\n      status=PingGIFImage(image,exception);\n    else\n      status=DecodeImage(image,opacity,exception);\n    if ((image_info->ping == MagickFalse) && (status == MagickFalse))\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n    duration+=image->delay*image->iterations;\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    opacity=(-1);\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-\n      1,image->scene);\n    if (status == MagickFalse)\n      break;\n  }\n  image->duration=duration;\n  meta_image=DestroyImage(meta_image);\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r G I F I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterGIFImage() adds properties for the GIF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterGIFImage method is:\n%\n%      size_t RegisterGIFImage(void)\n%\n*/\nModuleExport size_t RegisterGIFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"GIF\",\"GIF\",\n    \"CompuServe graphics interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadGIFImage;\n  entry->encoder=(EncodeImageHandler *) WriteGIFImage;\n  entry->magick=(IsImageFormatHandler *) IsGIF;\n  entry->mime_type=ConstantString(\"image/gif\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"GIF\",\"GIF87\",\n    \"CompuServe graphics interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadGIFImage;\n  entry->encoder=(EncodeImageHandler *) WriteGIFImage;\n  entry->magick=(IsImageFormatHandler *) IsGIF;\n  entry->flags^=CoderAdjoinFlag;\n  entry->version=ConstantString(\"version 87a\");\n  entry->mime_type=ConstantString(\"image/gif\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r G I F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterGIFImage() removes format registrations made by the\n%  GIF module from the list of supported formats.\n%\n%  The format of the UnregisterGIFImage method is:\n%\n%      UnregisterGIFImage(void)\n%\n*/\nModuleExport void UnregisterGIFImage(void)\n{\n  (void) UnregisterMagickInfo(\"GIF\");\n  (void) UnregisterMagickInfo(\"GIF87\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G I F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGIFImage() writes an image to a file in the Compuserve Graphics\n%  image format.\n%\n%  The format of the WriteGIFImage method is:\n%\n%      MagickBooleanType WriteGIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGIFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    delay,\n    length,\n    one;\n\n  ssize_t\n    j,\n    opacity;\n\n  unsigned char\n    *colormap,\n    *global_colormap;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate colormap.\n  */\n  global_colormap=(unsigned char *) AcquireQuantumMemory(768UL,\n    sizeof(*global_colormap));\n  colormap=(unsigned char *) AcquireQuantumMemory(768UL,sizeof(*colormap));\n  if ((global_colormap == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (i=0; i < 768; i++)\n    colormap[i]=(unsigned char) 0;\n  /*\n    Write GIF header.\n  */\n  write_info=CloneImageInfo(image_info);\n  if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n    (void) WriteBlob(image,6,(unsigned char *) \"GIF89a\");\n  else\n    {\n      (void) WriteBlob(image,6,(unsigned char *) \"GIF87a\");\n      write_info->adjoin=MagickFalse;\n    }\n  /*\n    Determine image bounding box.\n  */\n  page.width=image->columns;\n  if (image->page.width > page.width)\n    page.width=image->page.width;\n  page.height=image->rows;\n  if (image->page.height > page.height)\n    page.height=image->page.height;\n  page.x=image->page.x;\n  page.y=image->page.y;\n  (void) WriteBlobLSBShort(image,(unsigned short) page.width);\n  (void) WriteBlobLSBShort(image,(unsigned short) page.height);\n  /*\n    Write images to file.\n  */\n  if ((write_info->adjoin != MagickFalse) &&\n      (GetNextImageInList(image) != (Image *) NULL))\n    write_info->interlace=NoInterlace;\n  scene=0;\n  one=1;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    opacity=(-1);\n    if (IsImageOpaque(image,exception) != MagickFalse)\n      {\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteType,exception);\n      }\n    else\n      {\n        double\n          alpha,\n          beta;\n\n        /*\n          Identify transparent colormap index.\n        */\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (image->colormap[i].alpha != OpaqueAlpha)\n            {\n              if (opacity < 0)\n                {\n                  opacity=i;\n                  continue;\n                }\n              alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n              beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n              if (alpha < beta)\n                opacity=i;\n            }\n        if (opacity == -1)\n          {\n            (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n            for (i=0; i < (ssize_t) image->colors; i++)\n              if (image->colormap[i].alpha != OpaqueAlpha)\n                {\n                  if (opacity < 0)\n                    {\n                      opacity=i;\n                      continue;\n                    }\n                  alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n                  beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n                  if (alpha < beta)\n                    opacity=i;\n                }\n          }\n        if (opacity >= 0)\n          {\n            image->colormap[opacity].red=image->transparent_color.red;\n            image->colormap[opacity].green=image->transparent_color.green;\n            image->colormap[opacity].blue=image->transparent_color.blue;\n          }\n      }\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (bits_per_pixel=1; bits_per_pixel < 8; bits_per_pixel++)\n      if ((one << bits_per_pixel) >= image->colors)\n        break;\n    q=colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n    }\n    for ( ; i < (ssize_t) (one << bits_per_pixel); i++)\n    {\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n    }\n    if ((GetPreviousImageInList(image) == (Image *) NULL) ||\n        (write_info->adjoin == MagickFalse))\n      {\n        /*\n          Write global colormap.\n        */\n        c=0x80;\n        c|=(8-1) << 4;  /* color resolution */\n        c|=(bits_per_pixel-1);   /* size of global colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        for (j=0; j < (ssize_t) image->colors; j++)\n          if (IsPixelInfoEquivalent(&image->background_color,image->colormap+j))\n            break;\n        (void) WriteBlobByte(image,(unsigned char)\n          (j == (ssize_t) image->colors ? 0 : j));  /* background color */\n        (void) WriteBlobByte(image,(unsigned char) 0x00);  /* reserved */\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n        for (j=0; j < 768; j++)\n          global_colormap[j]=colormap[j];\n      }\n    if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n      {\n        const char\n          *value;\n\n        /*\n          Write graphics control extension.\n        */\n        (void) WriteBlobByte(image,(unsigned char) 0x21);\n        (void) WriteBlobByte(image,(unsigned char) 0xf9);\n        (void) WriteBlobByte(image,(unsigned char) 0x04);\n        c=image->dispose << 2;\n        if (opacity >= 0)\n          c|=0x01;\n        (void) WriteBlobByte(image,(unsigned char) c);\n        delay=(size_t) (100*image->delay/MagickMax((size_t)\n          image->ticks_per_second,1));\n        (void) WriteBlobLSBShort(image,(unsigned short) delay);\n        (void) WriteBlobByte(image,(unsigned char) (opacity >= 0 ? opacity :\n          0));\n        (void) WriteBlobByte(image,(unsigned char) 0x00);\n        value=GetImageProperty(image,\"comment\",exception);\n        if ((LocaleCompare(write_info->magick,\"GIF87\") != 0) &&\n            (value != (const char *) NULL))\n          {\n            register const char \n              *p;\n\n            size_t\n              count;\n    \n            /*\n              Write comment extension.\n            */\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xfe);\n            for (p=value; *p != '\\0'; )\n            {\n              count=MagickMin(strlen(p),255);\n              (void) WriteBlobByte(image,(unsigned char) count);\n              for (i=0; i < (ssize_t) count; i++)\n                (void) WriteBlobByte(image,(unsigned char) *p++);\n            }\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((GetPreviousImageInList(image) == (Image *) NULL) &&\n            (GetNextImageInList(image) != (Image *) NULL) &&\n            (image->iterations != 1))\n          {\n            /*\n              Write Netscape Loop extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x03);\n            (void) WriteBlobByte(image,(unsigned char) 0x01);\n            (void) WriteBlobLSBShort(image,(unsigned short) image->iterations);\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((image->gamma != 1.0f/2.2f))\n          {\n            char\n              attributes[MagickPathExtent];\n\n            ssize_t\n              count;\n\n            /*\n              Write ImageMagick extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"ImageMagick\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"ImageMagick\");\n            count=FormatLocaleString(attributes,MagickPathExtent,\"gamma=%g\",\n              image->gamma);\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlob(image,(size_t) count,(unsigned char *) attributes);\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        ResetImageProfileIterator(image);\n        for ( ; ; )\n        {\n          char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          name=GetNextImageProfile(image);\n          if (name == (const char *) NULL)\n            break;\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0) ||\n                (LocaleCompare(name,\"IPTC\") == 0) ||\n                (LocaleCompare(name,\"8BIM\") == 0) ||\n                (LocaleNCompare(name,\"gif:\",4) == 0))\n            {\n               ssize_t\n                 offset;\n\n               unsigned char\n                 *datum;\n\n               datum=GetStringInfoDatum(profile);\n               length=GetStringInfoLength(profile);\n               (void) WriteBlobByte(image,(unsigned char) 0x21);\n               (void) WriteBlobByte(image,(unsigned char) 0xff);\n               (void) WriteBlobByte(image,(unsigned char) 0x0b);\n               if ((LocaleCompare(name,\"ICC\") == 0) ||\n                   (LocaleCompare(name,\"ICM\") == 0))\n                 {\n                   /*\n                     Write ICC extension.\n                   */\n                   (void) WriteBlob(image,11,(unsigned char *) \"ICCRGBG1012\");\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  Writing GIF Extension %s\",\"ICCRGBG1012\");\n                 }\n               else\n                 if ((LocaleCompare(name,\"IPTC\") == 0))\n                   {\n                     /*\n                       Write IPTC extension.\n                     */\n                     (void) WriteBlob(image,11,(unsigned char *) \"MGKIPTC0000\");\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"  Writing GIF Extension %s\",\"MGKIPTC0000\");\n                   }\n                 else\n                   if ((LocaleCompare(name,\"8BIM\") == 0))\n                     {\n                       /*\n                         Write 8BIM extension.\n                       */\n                        (void) WriteBlob(image,11,(unsigned char *)\n                          \"MGK8BIM0000\");\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing GIF Extension %s\",\"MGK8BIM0000\");\n                     }\n                   else\n                     {\n                       char\n                         extension[MagickPathExtent];\n\n                       /*\n                         Write generic extension.\n                       */\n                       (void) CopyMagickString(extension,name+4,\n                         sizeof(extension));\n                       (void) WriteBlob(image,11,(unsigned char *) extension);\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"  Writing GIF Extension %s\",name);\n                     }\n               offset=0;\n               while ((ssize_t) length > offset)\n               {\n                 size_t\n                   block_length;\n\n                 if ((length-offset) < 255)\n                   block_length=length-offset;\n                 else\n                   block_length=255;\n                 (void) WriteBlobByte(image,(unsigned char) block_length);\n                 (void) WriteBlob(image,(size_t) block_length,datum+offset);\n                 offset+=(ssize_t) block_length;\n               }\n               (void) WriteBlobByte(image,(unsigned char) 0x00);\n            }\n          }\n        }\n      }\n    (void) WriteBlobByte(image,',');  /* image separator */\n    /*\n      Write the image header.\n    */\n    page.x=image->page.x;\n    page.y=image->page.y;\n    if ((image->page.width != 0) && (image->page.height != 0))\n      page=image->page;\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.x < 0 ? 0 : page.x));\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.y < 0 ? 0 : page.y));\n    (void) WriteBlobLSBShort(image,(unsigned short) image->columns);\n    (void) WriteBlobLSBShort(image,(unsigned short) image->rows);\n    c=0x00;\n    if (write_info->interlace != NoInterlace)\n      c|=0x40;  /* pixel data is interlaced */\n    for (j=0; j < (ssize_t) (3*image->colors); j++)\n      if (colormap[j] != global_colormap[j])\n        break;\n    if (j == (ssize_t) (3*image->colors))\n      (void) WriteBlobByte(image,(unsigned char) c);\n    else\n      {\n        c|=0x80;\n        c|=(bits_per_pixel-1);   /* size of local colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n      }\n    /*\n      Write the image data.\n    */\n    c=(int) MagickMax(bits_per_pixel,2);\n    (void) WriteBlobByte(image,(unsigned char) c);\n    status=EncodeImage(write_info,image,(size_t) MagickMax(bits_per_pixel,2)+1,\n      exception);\n    if (status == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n        write_info=DestroyImageInfo(write_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) WriteBlobByte(image,(unsigned char) 0x00);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    scene++;\n    status=SetImageProgress(image,SaveImagesTag,scene,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (write_info->adjoin != MagickFalse);\n  (void) WriteBlobByte(image,';'); /* terminator */\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  write_info=DestroyImageInfo(write_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                             GGGG  IIIII  FFFFF                              %\n%                            G        I    F                                  %\n%                            G  GG    I    FFF                                %\n%                            G   G    I    F                                  %\n%                             GGG   IIIII  F                                  %\n%                                                                             %\n%                                                                             %\n%            Read/Write Compuserv Graphics Interchange Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Define declarations.\n*/\n#define MaximumLZWBits  12\n#define MaximumLZWCode  (1UL << MaximumLZWBits)\n\f\n/*\n  Typdef declarations.\n*/\ntypedef struct _LZWCodeInfo\n{\n  unsigned char\n    buffer[280];\n\n  size_t\n    count,\n    bit;\n\n  MagickBooleanType\n    eof;\n} LZWCodeInfo;\n\ntypedef struct _LZWStack\n{\n  size_t\n    *codes,\n    *index,\n    *top;\n} LZWStack;\n\ntypedef struct _LZWInfo\n{\n  Image\n    *image;\n\n  LZWStack\n    *stack;\n\n  MagickBooleanType\n    genesis;\n\n  size_t\n    data_size,\n    maximum_data_value,\n    clear_code,\n    end_code,\n    bits,\n    first_code,\n    last_code,\n    maximum_code,\n    slot,\n    *table[2];\n\n  LZWCodeInfo\n    code_info;\n} LZWInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic inline int\n  GetNextLZWCode(LZWInfo *,const size_t);\n\nstatic MagickBooleanType\n  WriteGIFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\nstatic ssize_t\n  ReadBlobBlock(Image *,unsigned char *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage uncompresses an image via GIF-coding.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,const ssize_t opacity)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o opacity:  The colormap index associated with the transparent color.\n%\n*/\n\nstatic LZWInfo *RelinquishLZWInfo(LZWInfo *lzw_info)\n{\n  if (lzw_info->table[0] != (size_t *) NULL)\n    lzw_info->table[0]=(size_t *) RelinquishMagickMemory(\n      lzw_info->table[0]);\n  if (lzw_info->table[1] != (size_t *) NULL)\n    lzw_info->table[1]=(size_t *) RelinquishMagickMemory(\n      lzw_info->table[1]);\n  if (lzw_info->stack != (LZWStack *) NULL)\n    {\n      if (lzw_info->stack->codes != (size_t *) NULL)\n        lzw_info->stack->codes=(size_t *) RelinquishMagickMemory(\n          lzw_info->stack->codes);\n      lzw_info->stack=(LZWStack *) RelinquishMagickMemory(lzw_info->stack);\n    }\n  lzw_info=(LZWInfo *) RelinquishMagickMemory(lzw_info);\n  return((LZWInfo *) NULL);\n}\n\nstatic inline void ResetLZWInfo(LZWInfo *lzw_info)\n{\n  size_t\n    one;\n\n  lzw_info->bits=lzw_info->data_size+1;\n  one=1;\n  lzw_info->maximum_code=one << lzw_info->bits;\n  lzw_info->slot=lzw_info->maximum_data_value+3;\n  lzw_info->genesis=MagickTrue;\n}\n\nstatic LZWInfo *AcquireLZWInfo(Image *image,const size_t data_size)\n{\n  LZWInfo\n    *lzw_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    one;\n\n  lzw_info=(LZWInfo *) AcquireMagickMemory(sizeof(*lzw_info));\n  if (lzw_info == (LZWInfo *) NULL)\n    return((LZWInfo *) NULL);\n  (void) ResetMagickMemory(lzw_info,0,sizeof(*lzw_info));\n  lzw_info->image=image;\n  lzw_info->data_size=data_size;\n  one=1;\n  lzw_info->maximum_data_value=(one << data_size)-1;\n  lzw_info->clear_code=lzw_info->maximum_data_value+1;\n  lzw_info->end_code=lzw_info->maximum_data_value+2;\n  lzw_info->table[0]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(**lzw_info->table));\n  lzw_info->table[1]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(**lzw_info->table));\n  if ((lzw_info->table[0] == (size_t *) NULL) ||\n      (lzw_info->table[1] == (size_t *) NULL))\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  for (i=0; i <= (ssize_t) lzw_info->maximum_data_value; i++)\n  {\n    lzw_info->table[0][i]=0;\n    lzw_info->table[1][i]=(size_t) i;\n  }\n  ResetLZWInfo(lzw_info);\n  lzw_info->code_info.buffer[0]='\\0';\n  lzw_info->code_info.buffer[1]='\\0';\n  lzw_info->code_info.count=2;\n  lzw_info->code_info.bit=8*lzw_info->code_info.count;\n  lzw_info->code_info.eof=MagickFalse;\n  lzw_info->genesis=MagickTrue;\n  lzw_info->stack=(LZWStack *) AcquireMagickMemory(sizeof(*lzw_info->stack));\n  if (lzw_info->stack == (LZWStack *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->codes=(size_t *) AcquireQuantumMemory(2UL*\n    MaximumLZWCode,sizeof(*lzw_info->stack->codes));\n  if (lzw_info->stack->codes == (size_t *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->index=lzw_info->stack->codes;\n  lzw_info->stack->top=lzw_info->stack->codes+2*MaximumLZWCode;\n  return(lzw_info);\n}\n\nstatic inline int GetNextLZWCode(LZWInfo *lzw_info,const size_t bits)\n{\n  int\n    code;\n\n  register ssize_t\n    i;\n\n  size_t\n    one;\n\n  while (((lzw_info->code_info.bit+bits) > (8*lzw_info->code_info.count)) &&\n         (lzw_info->code_info.eof == MagickFalse))\n  {\n    ssize_t\n      count;\n\n    lzw_info->code_info.buffer[0]=lzw_info->code_info.buffer[\n      lzw_info->code_info.count-2];\n    lzw_info->code_info.buffer[1]=lzw_info->code_info.buffer[\n      lzw_info->code_info.count-1];\n    lzw_info->code_info.bit-=8*(lzw_info->code_info.count-2);\n    lzw_info->code_info.count=2;\n    count=ReadBlobBlock(lzw_info->image,&lzw_info->code_info.buffer[\n      lzw_info->code_info.count]);\n    if (count > 0)\n      lzw_info->code_info.count+=count;\n    else\n      lzw_info->code_info.eof=MagickTrue;\n  }\n  if ((lzw_info->code_info.bit+bits) > (8*lzw_info->code_info.count))\n    return(-1);\n  code=0;\n  one=1;\n  for (i=0; i < (ssize_t) bits; i++)\n  {\n    code|=((lzw_info->code_info.buffer[lzw_info->code_info.bit/8] &\n      (one << (lzw_info->code_info.bit % 8))) != 0) << i;\n    lzw_info->code_info.bit++;\n  }\n  return(code);\n}\n\nstatic inline int PopLZWStack(LZWStack *stack_info)\n{\n  if (stack_info->index <= stack_info->codes)\n    return(-1);\n  stack_info->index--;\n  return((int) *stack_info->index);\n}\n\nstatic inline void PushLZWStack(LZWStack *stack_info,const size_t value)\n{\n  if (stack_info->index >= stack_info->top)\n    return;\n  *stack_info->index=value;\n  stack_info->index++;\n}\n\nstatic int ReadBlobLZWByte(LZWInfo *lzw_info)\n{\n  int\n    code;\n\n  size_t\n    one,\n    value;\n\n  ssize_t\n    count;\n\n  if (lzw_info->stack->index != lzw_info->stack->codes)\n    return(PopLZWStack(lzw_info->stack));\n  if (lzw_info->genesis != MagickFalse)\n    {\n      lzw_info->genesis=MagickFalse;\n      do\n      {\n        lzw_info->first_code=(size_t) GetNextLZWCode(lzw_info,lzw_info->bits);\n        lzw_info->last_code=lzw_info->first_code;\n      } while (lzw_info->first_code == lzw_info->clear_code);\n      return((int) lzw_info->first_code);\n    }\n  code=GetNextLZWCode(lzw_info,lzw_info->bits);\n  if (code < 0)\n    return(code);\n  if ((size_t) code == lzw_info->clear_code)\n    {\n      ResetLZWInfo(lzw_info);\n      return(ReadBlobLZWByte(lzw_info));\n    }\n  if ((size_t) code == lzw_info->end_code)\n    return(-1);\n  if ((size_t) code < lzw_info->slot)\n    value=(size_t) code;\n  else\n    {\n      PushLZWStack(lzw_info->stack,lzw_info->first_code);\n      value=lzw_info->last_code;\n    }\n  count=0;\n  while (value > lzw_info->maximum_data_value)\n  {\n    if ((size_t) count > MaximumLZWCode)\n      return(-1);\n    count++;\n    if ((size_t) value > MaximumLZWCode)\n      return(-1);\n    PushLZWStack(lzw_info->stack,lzw_info->table[1][value]);\n    value=lzw_info->table[0][value];\n  }\n  lzw_info->first_code=lzw_info->table[1][value];\n  PushLZWStack(lzw_info->stack,lzw_info->first_code);\n  one=1;\n  if (lzw_info->slot < MaximumLZWCode)\n    {\n      lzw_info->table[0][lzw_info->slot]=lzw_info->last_code;\n      lzw_info->table[1][lzw_info->slot]=lzw_info->first_code;\n      lzw_info->slot++;\n      if ((lzw_info->slot >= lzw_info->maximum_code) &&\n          (lzw_info->bits < MaximumLZWBits))\n        {\n          lzw_info->bits++;\n          lzw_info->maximum_code=one << lzw_info->bits;\n        }\n    }\n  lzw_info->last_code=(size_t) code;\n  return(PopLZWStack(lzw_info->stack));\n}\n\nstatic MagickBooleanType DecodeImage(Image *image,const ssize_t opacity,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  LZWInfo\n    *lzw_info;\n\n  size_t\n    pass;\n\n  ssize_t\n    index,\n    offset,\n    y;\n\n  unsigned char\n    data_size;\n\n  /*\n    Allocate decoder tables.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  data_size=(unsigned char) ReadBlobByte(image);\n  if (data_size > MaximumLZWBits)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  lzw_info=AcquireLZWInfo(image,data_size);\n  if (lzw_info == (LZWInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  pass=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; )\n    {\n      c=ReadBlobLZWByte(lzw_info);\n      if (c < 0)\n        break;\n      index=ConstrainColormapIndex(image,(ssize_t) c,exception);\n      SetPixelIndex(image,(Quantum) index,q);\n      SetPixelViaPixelInfo(image,image->colormap+index,q);\n      SetPixelAlpha(image,index == opacity ? TransparentAlpha : OpaqueAlpha,q);\n      x++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (x < (ssize_t) image->columns)\n      break;\n    if (image->interlace == NoInterlace)\n      offset++;\n    else\n      {\n        switch (pass)\n        {\n          case 0:\n          default:\n          {\n            offset+=8;\n            break;\n          }\n          case 1:\n          {\n            offset+=8;\n            break;\n          }\n          case 2:\n          {\n            offset+=4;\n            break;\n          }\n          case 3:\n          {\n            offset+=2;\n            break;\n          }\n        }\n      if ((pass == 0) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=4;\n        }\n      if ((pass == 1) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=2;\n        }\n      if ((pass == 2) && (offset >= (ssize_t) image->rows))\n        {\n          pass++;\n          offset=1;\n        }\n    }\n  }\n  lzw_info=RelinquishLZWInfo(lzw_info);\n  if (y < (ssize_t) image->rows)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E n c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EncodeImage compresses an image via GIF-coding.\n%\n%  The format of the EncodeImage method is:\n%\n%      MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n%        const size_t data_size)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the address of a structure of type Image.\n%\n%    o data_size:  The number of bits in the compressed packet.\n%\n*/\nstatic MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n  const size_t data_size,ExceptionInfo *exception)\n{\n#define MaxCode(number_bits)  ((one << (number_bits))-1)\n#define MaxHashTable  5003\n#define MaxGIFBits  12UL\n#define MaxGIFTable  (1UL << MaxGIFBits)\n#define GIFOutputCode(code) \\\n{ \\\n  /*  \\\n    Emit a code. \\\n  */ \\\n  if (bits > 0) \\\n    datum|=(code) << bits; \\\n  else \\\n    datum=code; \\\n  bits+=number_bits; \\\n  while (bits >= 8) \\\n  { \\\n    /*  \\\n      Add a character to current packet. \\\n    */ \\\n    packet[length++]=(unsigned char) (datum & 0xff); \\\n    if (length >= 254) \\\n      { \\\n        (void) WriteBlobByte(image,(unsigned char) length); \\\n        (void) WriteBlob(image,length,packet); \\\n        length=0; \\\n      } \\\n    datum>>=8; \\\n    bits-=8; \\\n  } \\\n  if (free_code > max_code)  \\\n    { \\\n      number_bits++; \\\n      if (number_bits == MaxGIFBits) \\\n        max_code=MaxGIFTable; \\\n      else \\\n        max_code=MaxCode(number_bits); \\\n    } \\\n}\n\n  Quantum\n    index;\n\n  short\n    *hash_code,\n    *hash_prefix,\n    waiting_code;\n\n  size_t\n    bits,\n    clear_code,\n    datum,\n    end_of_information_code,\n    free_code,\n    length,\n    max_code,\n    next_pixel,\n    number_bits,\n    one,\n    pass;\n\n  ssize_t\n    displacement,\n    offset,\n    k,\n    y;\n\n  unsigned char\n    *packet,\n    *hash_suffix;\n\n  /*\n    Allocate encoder tables.\n  */\n  assert(image != (Image *) NULL);\n  one=1;\n  packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));\n  hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));\n  hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));\n  hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,\n    sizeof(*hash_suffix));\n  if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||\n      (hash_prefix == (short *) NULL) ||\n      (hash_suffix == (unsigned char *) NULL))\n    {\n      if (packet != (unsigned char *) NULL)\n        packet=(unsigned char *) RelinquishMagickMemory(packet);\n      if (hash_code != (short *) NULL)\n        hash_code=(short *) RelinquishMagickMemory(hash_code);\n      if (hash_prefix != (short *) NULL)\n        hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n      if (hash_suffix != (unsigned char *) NULL)\n        hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n      return(MagickFalse);\n    }\n  /*\n    Initialize GIF encoder.\n  */\n  (void) ResetMagickMemory(hash_code,0,MaxHashTable*sizeof(*hash_code));\n  (void) ResetMagickMemory(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));\n  (void) ResetMagickMemory(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));\n  number_bits=data_size;\n  max_code=MaxCode(number_bits);\n  clear_code=((short) one << (data_size-1));\n  end_of_information_code=clear_code+1;\n  free_code=clear_code+2;\n  length=0;\n  datum=0;\n  bits=0;\n  GIFOutputCode(clear_code);\n  /*\n    Encode pixels.\n  */\n  offset=0;\n  pass=0;\n  waiting_code=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,offset,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (y == 0)\n      {\n        waiting_code=(short) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n    for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)\n    {\n      /*\n        Probe hash table.\n      */\n      index=(Quantum) ((size_t) GetPixelIndex(image,p) & 0xff);\n      p+=GetPixelChannels(image);\n      k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);\n      if (k >= MaxHashTable)\n        k-=MaxHashTable;\n      next_pixel=MagickFalse;\n      displacement=1;\n      if (hash_code[k] > 0)\n        {\n          if ((hash_prefix[k] == waiting_code) &&\n              (hash_suffix[k] == (unsigned char) index))\n            {\n              waiting_code=hash_code[k];\n              continue;\n            }\n          if (k != 0)\n            displacement=MaxHashTable-k;\n          for ( ; ; )\n          {\n            k-=displacement;\n            if (k < 0)\n              k+=MaxHashTable;\n            if (hash_code[k] == 0)\n              break;\n            if ((hash_prefix[k] == waiting_code) &&\n                (hash_suffix[k] == (unsigned char) index))\n              {\n                waiting_code=hash_code[k];\n                next_pixel=MagickTrue;\n                break;\n              }\n          }\n          if (next_pixel != MagickFalse)\n            continue;\n        }\n      GIFOutputCode((size_t) waiting_code);\n      if (free_code < MaxGIFTable)\n        {\n          hash_code[k]=(short) free_code++;\n          hash_prefix[k]=waiting_code;\n          hash_suffix[k]=(unsigned char) index;\n        }\n      else\n        {\n          /*\n            Fill the hash table with empty entries.\n          */\n          for (k=0; k < MaxHashTable; k++)\n            hash_code[k]=0;\n          /*\n            Reset compressor and issue a clear code.\n          */\n          free_code=clear_code+2;\n          GIFOutputCode(clear_code);\n          number_bits=data_size;\n          max_code=MaxCode(number_bits);\n        }\n      waiting_code=(short) index;\n    }\n    if (image_info->interlace == NoInterlace)\n      offset++;\n    else\n      switch (pass)\n      {\n        case 0:\n        default:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=4;\n            }\n          break;\n        }\n        case 1:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=2;\n            }\n          break;\n        }\n        case 2:\n        {\n          offset+=4;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=1;\n            }\n          break;\n        }\n        case 3:\n        {\n          offset+=2;\n          break;\n        }\n      }\n  }\n  /*\n    Flush out the buffered code.\n  */\n  GIFOutputCode((size_t) waiting_code);\n  GIFOutputCode(end_of_information_code);\n  if (bits > 0)\n    {\n      /*\n        Add a character to current packet.\n      */\n      packet[length++]=(unsigned char) (datum & 0xff);\n      if (length >= 254)\n        {\n          (void) WriteBlobByte(image,(unsigned char) length);\n          (void) WriteBlob(image,length,packet);\n          length=0;\n        }\n    }\n  /*\n    Flush accumulated data.\n  */\n  if (length > 0)\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      (void) WriteBlob(image,length,packet);\n    }\n  /*\n    Free encoder memory.\n  */\n  hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n  hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n  hash_code=(short *) RelinquishMagickMemory(hash_code);\n  packet=(unsigned char *) RelinquishMagickMemory(packet);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s G I F                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsGIF() returns MagickTrue if the image format type, identified by the\n%  magick string, is GIF.\n%\n%  The format of the IsGIF method is:\n%\n%      MagickBooleanType IsGIF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsGIF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"GIF8\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b B l o c k                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobBlock() reads data from the image file and returns it.  The\n%  amount of data is determined by first reading a count byte.  The number\n%  of bytes read is returned.\n%\n%  The format of the ReadBlobBlock method is:\n%\n%      ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o data:  Specifies an area to place the information requested from\n%      the file.\n%\n*/\nstatic ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n{\n  ssize_t\n    count;\n\n  unsigned char\n    block_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(data != (unsigned char *) NULL);\n  count=ReadBlob(image,1,&block_count);\n  if (count != 1)\n    return(0);\n  count=ReadBlob(image,(size_t) block_count,data);\n  if (count != (ssize_t) block_count)\n    return(0);\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G I F I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGIFImage() reads a Compuserve Graphics image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGIFImage method is:\n%\n%      Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType PingGIFImage(Image *image,ExceptionInfo *exception)\n{\n  unsigned char\n    buffer[256],\n    length,\n    data_size;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (ReadBlob(image,1,&data_size) != 1)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  if (data_size > MaximumLZWBits)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  if (ReadBlob(image,1,&length) != 1)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  while (length != 0)\n  {\n    if (ReadBlob(image,length,buffer) != (ssize_t) length)\n      ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n    if (ReadBlob(image,1,&length) != 1)\n      ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename);\n  }\n  return(MagickTrue);\n}\n\nstatic Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))\n#define LSBFirstOrder(x,y)  (((y) << 8) | (x))\n\n  Image\n    *image,\n    *meta_image;\n\n  int\n    number_extensionss=0;\n\n  MagickBooleanType\n    status;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    delay,\n    dispose,\n    duration,\n    global_colors,\n    image_count,\n    iterations,\n    one;\n\n  ssize_t\n    count,\n    opacity;\n\n  unsigned char\n    background,\n    c,\n    flag,\n    *global_colormap,\n    buffer[257];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a GIF file.\n  */\n  count=ReadBlob(image,6,buffer);\n  if ((count != 6) || ((LocaleNCompare((char *) buffer,\"GIF87\",5) != 0) &&\n      (LocaleNCompare((char *) buffer,\"GIF89\",5) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  page.width=ReadBlobLSBShort(image);\n  page.height=ReadBlobLSBShort(image);\n  flag=(unsigned char) ReadBlobByte(image);\n  background=(unsigned char) ReadBlobByte(image);\n  c=(unsigned char) ReadBlobByte(image);  /* reserved */\n  one=1;\n  global_colors=one << (((size_t) flag & 0x07)+1);\n  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n    MagickMax(global_colors,256),3UL*sizeof(*global_colormap));\n  if (global_colormap == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*\n    sizeof(*global_colormap));\n  if (BitSet((int) flag,0x80) != 0)\n    {\n      count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);\n      if (count != (ssize_t) (3*global_colors))\n        {\n          global_colormap=(unsigned char *) RelinquishMagickMemory(\n            global_colormap);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n    }\n  delay=0;\n  dispose=0;\n  duration=0;\n  iterations=1;\n  opacity=(-1);\n  image_count=0;\n  meta_image=AcquireImage(image_info,exception);  /* metadata container */\n  for ( ; ; )\n  {\n    count=ReadBlob(image,1,&c);\n    if (count != 1)\n      break;\n    if (c == (unsigned char) ';')\n      break;  /* terminator */\n    if (c == (unsigned char) '!')\n      {\n        /*\n          GIF Extension block.\n        */\n        count=ReadBlob(image,1,&c);\n        if (count != 1)\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToReadExtensionBlock\");\n          }\n        switch (c)\n        {\n          case 0xf9:\n          {\n            /*\n              Read graphics control extension.\n            */\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            dispose=(size_t) (buffer[0] >> 2);\n            delay=(size_t) ((buffer[2] << 8) | buffer[1]);\n            if ((ssize_t) (buffer[0] & 0x01) == 0x01)\n              opacity=(ssize_t) buffer[3];\n            break;\n          }\n          case 0xfe:\n          {\n            char\n              *comments;\n\n            size_t\n              length;\n\n            /*\n              Read comment extension.\n            */\n            comments=AcquireString((char *) NULL);\n            for (length=0; ; length+=count)\n            {\n              count=(ssize_t) ReadBlobBlock(image,buffer);\n              if (count == 0)\n                break;\n              buffer[count]='\\0';\n              (void) ConcatenateString(&comments,(const char *) buffer);\n            }\n            (void) SetImageProperty(meta_image,\"comment\",comments,exception);\n            comments=DestroyString(comments);\n            break;\n          }\n          case 0xff:\n          {\n            MagickBooleanType\n              loop;\n\n            /*\n              Read Netscape Loop extension.\n            */\n            loop=MagickFalse;\n            if (ReadBlobBlock(image,buffer) != 0)\n              loop=LocaleNCompare((char *) buffer,\"NETSCAPE2.0\",11) == 0 ?\n                MagickTrue : MagickFalse;\n            if (loop != MagickFalse)\n              {\n                while (ReadBlobBlock(image,buffer) != 0)\n                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);\n                break;\n              }\n            else\n              {\n                char\n                  name[MagickPathExtent];\n\n                int\n                  block_length,\n                  info_length,\n                  reserved_length;\n\n                MagickBooleanType\n                  i8bim,\n                  icc,\n                  iptc,\n                  magick;\n\n                StringInfo\n                  *profile;\n\n                unsigned char\n                  *info;\n\n                /*\n                  Store GIF application extension as a generic profile.\n                */\n                icc=LocaleNCompare((char *) buffer,\"ICCRGBG1012\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                magick=LocaleNCompare((char *) buffer,\"ImageMagick\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                i8bim=LocaleNCompare((char *) buffer,\"MGK8BIM0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                iptc=LocaleNCompare((char *) buffer,\"MGKIPTC0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                number_extensionss++;\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Reading GIF application extension\");\n                info=(unsigned char *) AcquireQuantumMemory(255UL,\n                  sizeof(*info));\n                if (info == (unsigned char *) NULL)\n                  {\n                    meta_image=DestroyImage(meta_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                reserved_length=255;\n                for (info_length=0; ; )\n                {\n                  block_length=(int) ReadBlobBlock(image,&info[info_length]);\n                  if (block_length == 0)\n                    break;\n                  info_length+=block_length;\n                  if (info_length > (reserved_length-255))\n                    {\n                      reserved_length+=4096;\n                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)\n                        reserved_length,sizeof(*info));\n                      if (info == (unsigned char *) NULL)\n                        {\n                          meta_image=DestroyImage(meta_image);\n                          ThrowReaderException(ResourceLimitError,\n                            \"MemoryAllocationFailed\");\n                        }\n                    }\n                }\n                profile=BlobToStringInfo(info,(size_t) info_length);\n                if (profile == (StringInfo *) NULL)\n                  {\n                    meta_image=DestroyImage(meta_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if (i8bim != MagickFalse)\n                  (void) CopyMagickString(name,\"8bim\",sizeof(name));\n                else if (icc != MagickFalse)\n                  (void) CopyMagickString(name,\"icc\",sizeof(name));\n                else if (iptc != MagickFalse)\n                  (void) CopyMagickString(name,\"iptc\",sizeof(name));\n                else if (magick != MagickFalse)\n                  {\n                    (void) CopyMagickString(name,\"magick\",sizeof(name));\n                    meta_image->gamma=StringToDouble((char *) info+6,\n                      (char **) NULL);\n                  }\n                else\n                  (void) FormatLocaleString(name,sizeof(name),\"gif:%.11s\",\n                    buffer);\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                if (magick == MagickFalse)\n                  (void) SetImageProfile(meta_image,name,profile,exception);\n                profile=DestroyStringInfo(profile);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      profile name=%s\",name);\n              }\n            break;\n          }\n          default:\n          {\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            break;\n          }\n        }\n      }\n    if (c != (unsigned char) ',')\n      continue;\n    if (image_count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n      }\n    image_count++;\n    /*\n      Read image attributes.\n    */\n    meta_image->scene=image->scene;\n    (void) CloneImageProperties(image,meta_image);\n    DestroyImageProperties(meta_image);\n    (void) CloneImageProfiles(image,meta_image);\n    DestroyImageProfiles(meta_image);\n    image->storage_class=PseudoClass;\n    image->compression=LZWCompression;\n    page.x=(ssize_t) ReadBlobLSBShort(image);\n    page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    image->depth=8;\n    flag=(unsigned char) ReadBlobByte(image);\n    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;\n    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<\n      ((size_t) (flag & 0x07)+1);\n    if (opacity >= (ssize_t) image->colors)\n      opacity=(-1);\n    image->page.width=page.width;\n    image->page.height=page.height;\n    image->page.y=page.y;\n    image->page.x=page.x;\n    image->delay=delay;\n    image->ticks_per_second=100;\n    image->dispose=(DisposeType) dispose;\n    image->iterations=iterations;\n    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;\n    delay=0;\n    dispose=0;\n    if ((image->columns == 0) || (image->rows == 0))\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n      }\n    /*\n      Inititialize colormap.\n    */\n    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (BitSet((int) flag,0x80) == 0)\n      {\n        /*\n          Use global colormap.\n        */\n        p=global_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            {\n              image->colormap[i].alpha=(double) TransparentAlpha;\n              image->transparent_color=image->colormap[opacity];\n            }\n        }\n        image->background_color=image->colormap[MagickMin((ssize_t) background,\n          (ssize_t) image->colors-1)];\n      }\n    else\n      {\n        unsigned char\n          *colormap;\n\n        /*\n          Read local colormap.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*\n          sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);\n        if (count != (ssize_t) (3*image->colors))\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            image->colormap[i].alpha=(double) TransparentAlpha;\n        }\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    if (image->gamma == 1.0)\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)\n            break;\n        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? \n          GRAYColorspace : RGBColorspace,exception);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Decode image.\n    */\n    if (image_info->ping != MagickFalse)\n      status=PingGIFImage(image,exception);\n    else\n      status=DecodeImage(image,opacity,exception);\n    if ((image_info->ping == MagickFalse) && (status == MagickFalse))\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n    duration+=image->delay*image->iterations;\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    opacity=(-1);\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-\n      1,image->scene);\n    if (status == MagickFalse)\n      break;\n  }\n  image->duration=duration;\n  meta_image=DestroyImage(meta_image);\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r G I F I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterGIFImage() adds properties for the GIF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterGIFImage method is:\n%\n%      size_t RegisterGIFImage(void)\n%\n*/\nModuleExport size_t RegisterGIFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"GIF\",\"GIF\",\n    \"CompuServe graphics interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadGIFImage;\n  entry->encoder=(EncodeImageHandler *) WriteGIFImage;\n  entry->magick=(IsImageFormatHandler *) IsGIF;\n  entry->mime_type=ConstantString(\"image/gif\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"GIF\",\"GIF87\",\n    \"CompuServe graphics interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadGIFImage;\n  entry->encoder=(EncodeImageHandler *) WriteGIFImage;\n  entry->magick=(IsImageFormatHandler *) IsGIF;\n  entry->flags^=CoderAdjoinFlag;\n  entry->version=ConstantString(\"version 87a\");\n  entry->mime_type=ConstantString(\"image/gif\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r G I F I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterGIFImage() removes format registrations made by the\n%  GIF module from the list of supported formats.\n%\n%  The format of the UnregisterGIFImage method is:\n%\n%      UnregisterGIFImage(void)\n%\n*/\nModuleExport void UnregisterGIFImage(void)\n{\n  (void) UnregisterMagickInfo(\"GIF\");\n  (void) UnregisterMagickInfo(\"GIF87\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G I F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGIFImage() writes an image to a file in the Compuserve Graphics\n%  image format.\n%\n%  The format of the WriteGIFImage method is:\n%\n%      MagickBooleanType WriteGIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGIFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    delay,\n    length,\n    one;\n\n  ssize_t\n    j,\n    opacity;\n\n  unsigned char\n    *colormap,\n    *global_colormap;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate colormap.\n  */\n  global_colormap=(unsigned char *) AcquireQuantumMemory(768UL,\n    sizeof(*global_colormap));\n  colormap=(unsigned char *) AcquireQuantumMemory(768UL,sizeof(*colormap));\n  if ((global_colormap == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (i=0; i < 768; i++)\n    colormap[i]=(unsigned char) 0;\n  /*\n    Write GIF header.\n  */\n  write_info=CloneImageInfo(image_info);\n  if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n    (void) WriteBlob(image,6,(unsigned char *) \"GIF89a\");\n  else\n    {\n      (void) WriteBlob(image,6,(unsigned char *) \"GIF87a\");\n      write_info->adjoin=MagickFalse;\n    }\n  /*\n    Determine image bounding box.\n  */\n  page.width=image->columns;\n  if (image->page.width > page.width)\n    page.width=image->page.width;\n  page.height=image->rows;\n  if (image->page.height > page.height)\n    page.height=image->page.height;\n  page.x=image->page.x;\n  page.y=image->page.y;\n  (void) WriteBlobLSBShort(image,(unsigned short) page.width);\n  (void) WriteBlobLSBShort(image,(unsigned short) page.height);\n  /*\n    Write images to file.\n  */\n  if ((write_info->adjoin != MagickFalse) &&\n      (GetNextImageInList(image) != (Image *) NULL))\n    write_info->interlace=NoInterlace;\n  scene=0;\n  one=1;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    opacity=(-1);\n    if (IsImageOpaque(image,exception) != MagickFalse)\n      {\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteType,exception);\n      }\n    else\n      {\n        double\n          alpha,\n          beta;\n\n        /*\n          Identify transparent colormap index.\n        */\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (image->colormap[i].alpha != OpaqueAlpha)\n            {\n              if (opacity < 0)\n                {\n                  opacity=i;\n                  continue;\n                }\n              alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n              beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n              if (alpha < beta)\n                opacity=i;\n            }\n        if (opacity == -1)\n          {\n            (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n            for (i=0; i < (ssize_t) image->colors; i++)\n              if (image->colormap[i].alpha != OpaqueAlpha)\n                {\n                  if (opacity < 0)\n                    {\n                      opacity=i;\n                      continue;\n                    }\n                  alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n                  beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n                  if (alpha < beta)\n                    opacity=i;\n                }\n          }\n        if (opacity >= 0)\n          {\n            image->colormap[opacity].red=image->transparent_color.red;\n            image->colormap[opacity].green=image->transparent_color.green;\n            image->colormap[opacity].blue=image->transparent_color.blue;\n          }\n      }\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (bits_per_pixel=1; bits_per_pixel < 8; bits_per_pixel++)\n      if ((one << bits_per_pixel) >= image->colors)\n        break;\n    q=colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n    }\n    for ( ; i < (ssize_t) (one << bits_per_pixel); i++)\n    {\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n    }\n    if ((GetPreviousImageInList(image) == (Image *) NULL) ||\n        (write_info->adjoin == MagickFalse))\n      {\n        /*\n          Write global colormap.\n        */\n        c=0x80;\n        c|=(8-1) << 4;  /* color resolution */\n        c|=(bits_per_pixel-1);   /* size of global colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        for (j=0; j < (ssize_t) image->colors; j++)\n          if (IsPixelInfoEquivalent(&image->background_color,image->colormap+j))\n            break;\n        (void) WriteBlobByte(image,(unsigned char)\n          (j == (ssize_t) image->colors ? 0 : j));  /* background color */\n        (void) WriteBlobByte(image,(unsigned char) 0x00);  /* reserved */\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n        for (j=0; j < 768; j++)\n          global_colormap[j]=colormap[j];\n      }\n    if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n      {\n        const char\n          *value;\n\n        /*\n          Write graphics control extension.\n        */\n        (void) WriteBlobByte(image,(unsigned char) 0x21);\n        (void) WriteBlobByte(image,(unsigned char) 0xf9);\n        (void) WriteBlobByte(image,(unsigned char) 0x04);\n        c=image->dispose << 2;\n        if (opacity >= 0)\n          c|=0x01;\n        (void) WriteBlobByte(image,(unsigned char) c);\n        delay=(size_t) (100*image->delay/MagickMax((size_t)\n          image->ticks_per_second,1));\n        (void) WriteBlobLSBShort(image,(unsigned short) delay);\n        (void) WriteBlobByte(image,(unsigned char) (opacity >= 0 ? opacity :\n          0));\n        (void) WriteBlobByte(image,(unsigned char) 0x00);\n        value=GetImageProperty(image,\"comment\",exception);\n        if ((LocaleCompare(write_info->magick,\"GIF87\") != 0) &&\n            (value != (const char *) NULL))\n          {\n            register const char \n              *p;\n\n            size_t\n              count;\n    \n            /*\n              Write comment extension.\n            */\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xfe);\n            for (p=value; *p != '\\0'; )\n            {\n              count=MagickMin(strlen(p),255);\n              (void) WriteBlobByte(image,(unsigned char) count);\n              for (i=0; i < (ssize_t) count; i++)\n                (void) WriteBlobByte(image,(unsigned char) *p++);\n            }\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((GetPreviousImageInList(image) == (Image *) NULL) &&\n            (GetNextImageInList(image) != (Image *) NULL) &&\n            (image->iterations != 1))\n          {\n            /*\n              Write Netscape Loop extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x03);\n            (void) WriteBlobByte(image,(unsigned char) 0x01);\n            (void) WriteBlobLSBShort(image,(unsigned short) image->iterations);\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((image->gamma != 1.0f/2.2f))\n          {\n            char\n              attributes[MagickPathExtent];\n\n            ssize_t\n              count;\n\n            /*\n              Write ImageMagick extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"ImageMagick\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"ImageMagick\");\n            count=FormatLocaleString(attributes,MagickPathExtent,\"gamma=%g\",\n              image->gamma);\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlob(image,(size_t) count,(unsigned char *) attributes);\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        ResetImageProfileIterator(image);\n        for ( ; ; )\n        {\n          char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          name=GetNextImageProfile(image);\n          if (name == (const char *) NULL)\n            break;\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0) ||\n                (LocaleCompare(name,\"IPTC\") == 0) ||\n                (LocaleCompare(name,\"8BIM\") == 0) ||\n                (LocaleNCompare(name,\"gif:\",4) == 0))\n            {\n               ssize_t\n                 offset;\n\n               unsigned char\n                 *datum;\n\n               datum=GetStringInfoDatum(profile);\n               length=GetStringInfoLength(profile);\n               (void) WriteBlobByte(image,(unsigned char) 0x21);\n               (void) WriteBlobByte(image,(unsigned char) 0xff);\n               (void) WriteBlobByte(image,(unsigned char) 0x0b);\n               if ((LocaleCompare(name,\"ICC\") == 0) ||\n                   (LocaleCompare(name,\"ICM\") == 0))\n                 {\n                   /*\n                     Write ICC extension.\n                   */\n                   (void) WriteBlob(image,11,(unsigned char *) \"ICCRGBG1012\");\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  Writing GIF Extension %s\",\"ICCRGBG1012\");\n                 }\n               else\n                 if ((LocaleCompare(name,\"IPTC\") == 0))\n                   {\n                     /*\n                       Write IPTC extension.\n                     */\n                     (void) WriteBlob(image,11,(unsigned char *) \"MGKIPTC0000\");\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"  Writing GIF Extension %s\",\"MGKIPTC0000\");\n                   }\n                 else\n                   if ((LocaleCompare(name,\"8BIM\") == 0))\n                     {\n                       /*\n                         Write 8BIM extension.\n                       */\n                        (void) WriteBlob(image,11,(unsigned char *)\n                          \"MGK8BIM0000\");\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing GIF Extension %s\",\"MGK8BIM0000\");\n                     }\n                   else\n                     {\n                       char\n                         extension[MagickPathExtent];\n\n                       /*\n                         Write generic extension.\n                       */\n                       (void) CopyMagickString(extension,name+4,\n                         sizeof(extension));\n                       (void) WriteBlob(image,11,(unsigned char *) extension);\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"  Writing GIF Extension %s\",name);\n                     }\n               offset=0;\n               while ((ssize_t) length > offset)\n               {\n                 size_t\n                   block_length;\n\n                 if ((length-offset) < 255)\n                   block_length=length-offset;\n                 else\n                   block_length=255;\n                 (void) WriteBlobByte(image,(unsigned char) block_length);\n                 (void) WriteBlob(image,(size_t) block_length,datum+offset);\n                 offset+=(ssize_t) block_length;\n               }\n               (void) WriteBlobByte(image,(unsigned char) 0x00);\n            }\n          }\n        }\n      }\n    (void) WriteBlobByte(image,',');  /* image separator */\n    /*\n      Write the image header.\n    */\n    page.x=image->page.x;\n    page.y=image->page.y;\n    if ((image->page.width != 0) && (image->page.height != 0))\n      page=image->page;\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.x < 0 ? 0 : page.x));\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.y < 0 ? 0 : page.y));\n    (void) WriteBlobLSBShort(image,(unsigned short) image->columns);\n    (void) WriteBlobLSBShort(image,(unsigned short) image->rows);\n    c=0x00;\n    if (write_info->interlace != NoInterlace)\n      c|=0x40;  /* pixel data is interlaced */\n    for (j=0; j < (ssize_t) (3*image->colors); j++)\n      if (colormap[j] != global_colormap[j])\n        break;\n    if (j == (ssize_t) (3*image->colors))\n      (void) WriteBlobByte(image,(unsigned char) c);\n    else\n      {\n        c|=0x80;\n        c|=(bits_per_pixel-1);   /* size of local colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n      }\n    /*\n      Write the image data.\n    */\n    c=(int) MagickMax(bits_per_pixel,2);\n    (void) WriteBlobByte(image,(unsigned char) c);\n    status=EncodeImage(write_info,image,(size_t) MagickMax(bits_per_pixel,2)+1,\n      exception);\n    if (status == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n        write_info=DestroyImageInfo(write_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) WriteBlobByte(image,(unsigned char) 0x00);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    scene++;\n    status=SetImageProgress(image,SaveImagesTag,scene,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (write_info->adjoin != MagickFalse);\n  (void) WriteBlobByte(image,';'); /* terminator */\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  write_info=DestroyImageInfo(write_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/gif.c"], "buggy_code_start_loc": [1029], "buggy_code_end_loc": [1029], "fixing_code_start_loc": [1030], "fixing_code_end_loc": [1032], "type": "CWE-200", "message": "ReadGIFImage in coders/gif.c in ImageMagick 7.0.6-1 and GraphicsMagick 1.3.26 leaves the palette uninitialized when processing a GIF file that has neither a global nor local palette. If the affected product is used as a library loaded into a process that operates on interesting data, this data sometimes can be leaked via the uninitialized palette.", "other": {"cve": {"id": "CVE-2017-15277", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-12T08:29:00.290", "lastModified": "2018-10-18T10:29:13.013", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ReadGIFImage in coders/gif.c in ImageMagick 7.0.6-1 and GraphicsMagick 1.3.26 leaves the palette uninitialized when processing a GIF file that has neither a global nor local palette. If the affected product is used as a library loaded into a process that operates on interesting data, this data sometimes can be leaked via the uninitialized palette."}, {"lang": "es", "value": "ReadGIFImage en coders/gif.c en ImageMagick 7.0.6-1 y GraphicsMagick 1.3.26 deja sin inicializar la paleta cuando se procesa un archivo GIF que no tiene ni una paleta global ni una local. Si el producto afectado se utiliza como una librer\u00eda cargada en un proceso que opera en datos de inter\u00e9s, estos datos pueden filtrarse a veces mediante la paleta no inicializada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:graphicsmagick:graphicsmagick:1.3.26:*:*:*:*:*:*:*", "matchCriteriaId": "4C227898-C6EC-41BE-A3AD-229FFD8B86D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-1:*:*:*:*:*:*:*", "matchCriteriaId": "72A6252A-35A7-4D74-AF0E-0A7B4B12B146"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/9fd10cf630832b36a588c1545d8736539b2f1fb5", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/592", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/neex/gifoeb", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00002.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3681-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4232-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2017/dsa-4032", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2017/dsa-4040", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4321", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/9fd10cf630832b36a588c1545d8736539b2f1fb5"}}