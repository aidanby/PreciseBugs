{"buggy_code": ["/*\n *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#include <stdio.h>\n\n#include <climits>\n#include <vector>\n#include \"third_party/googletest/src/include/gtest/gtest.h\"\n#include \"test/codec_factory.h\"\n#include \"test/encode_test_driver.h\"\n#include \"test/i420_video_source.h\"\n#include \"test/video_source.h\"\n#include \"test/util.h\"\n\n// Enable(1) or Disable(0) writing of the compressed bitstream.\n#define WRITE_COMPRESSED_STREAM 0\n\nnamespace {\n\n#if WRITE_COMPRESSED_STREAM\nstatic void mem_put_le16(char *const mem, const unsigned int val) {\n  mem[0] = val;\n  mem[1] = val >> 8;\n}\n\nstatic void mem_put_le32(char *const mem, const unsigned int val) {\n  mem[0] = val;\n  mem[1] = val >> 8;\n  mem[2] = val >> 16;\n  mem[3] = val >> 24;\n}\n\nstatic void write_ivf_file_header(const vpx_codec_enc_cfg_t *const cfg,\n                                  int frame_cnt, FILE *const outfile) {\n  char header[32];\n\n  header[0] = 'D';\n  header[1] = 'K';\n  header[2] = 'I';\n  header[3] = 'F';\n  mem_put_le16(header + 4, 0);                    /* version */\n  mem_put_le16(header + 6, 32);                   /* headersize */\n  mem_put_le32(header + 8, 0x30395056);           /* fourcc (vp9) */\n  mem_put_le16(header + 12, cfg->g_w);            /* width */\n  mem_put_le16(header + 14, cfg->g_h);            /* height */\n  mem_put_le32(header + 16, cfg->g_timebase.den); /* rate */\n  mem_put_le32(header + 20, cfg->g_timebase.num); /* scale */\n  mem_put_le32(header + 24, frame_cnt);           /* length */\n  mem_put_le32(header + 28, 0);                   /* unused */\n\n  (void)fwrite(header, 1, 32, outfile);\n}\n\nstatic void write_ivf_frame_size(FILE *const outfile, const size_t size) {\n  char header[4];\n  mem_put_le32(header, static_cast<unsigned int>(size));\n  (void)fwrite(header, 1, 4, outfile);\n}\n\nstatic void write_ivf_frame_header(const vpx_codec_cx_pkt_t *const pkt,\n                                   FILE *const outfile) {\n  char header[12];\n  vpx_codec_pts_t pts;\n\n  if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return;\n\n  pts = pkt->data.frame.pts;\n  mem_put_le32(header, static_cast<unsigned int>(pkt->data.frame.sz));\n  mem_put_le32(header + 4, pts & 0xFFFFFFFF);\n  mem_put_le32(header + 8, pts >> 32);\n\n  (void)fwrite(header, 1, 12, outfile);\n}\n#endif  // WRITE_COMPRESSED_STREAM\n\nconst unsigned int kInitialWidth = 320;\nconst unsigned int kInitialHeight = 240;\n\nstruct FrameInfo {\n  FrameInfo(vpx_codec_pts_t _pts, unsigned int _w, unsigned int _h)\n      : pts(_pts), w(_w), h(_h) {}\n\n  vpx_codec_pts_t pts;\n  unsigned int w;\n  unsigned int h;\n};\n\nvoid ScaleForFrameNumber(unsigned int frame, unsigned int initial_w,\n                         unsigned int initial_h, unsigned int *w,\n                         unsigned int *h, bool flag_codec,\n                         bool smaller_width_larger_size_) {\n  *w = initial_w;\n  *h = initial_h;\n\n  if (smaller_width_larger_size_) {\n    if (frame < 30) {\n      return;\n    }\n    if (frame < 100) {\n      *w = initial_w * 7 / 10;\n      *h = initial_h * 16 / 10;\n      return;\n    }\n    return;\n  }\n  if (frame < 10) {\n    return;\n  }\n  if (frame < 20) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 30) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 40) {\n    return;\n  }\n  if (frame < 50) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 60) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 70) {\n    return;\n  }\n  if (frame < 80) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 90) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 100) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 110) {\n    return;\n  }\n  if (frame < 120) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 130) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 140) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 150) {\n    return;\n  }\n  if (frame < 160) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 170) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 180) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 190) {\n    return;\n  }\n  if (frame < 200) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 210) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 220) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 230) {\n    return;\n  }\n  if (frame < 240) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 250) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 260) {\n    return;\n  }\n  // Go down very low.\n  if (frame < 270) {\n    *w = initial_w / 4;\n    *h = initial_h / 4;\n    return;\n  }\n  if (flag_codec == 1) {\n    // Cases that only works for VP9.\n    // For VP9: Swap width and height of original.\n    if (frame < 320) {\n      return;\n    }\n  }\n}\n\nclass ResizingVideoSource : public ::libvpx_test::DummyVideoSource {\n public:\n  ResizingVideoSource() {\n    SetSize(kInitialWidth, kInitialHeight);\n    limit_ = 350;\n    smaller_width_larger_size_ = false;\n  }\n  bool flag_codec_;\n  bool smaller_width_larger_size_;\n  ~ResizingVideoSource() override = default;\n\n protected:\n  void Next() override {\n    ++frame_;\n    unsigned int width = 0;\n    unsigned int height = 0;\n    ScaleForFrameNumber(frame_, kInitialWidth, kInitialHeight, &width, &height,\n                        flag_codec_, smaller_width_larger_size_);\n    SetSize(width, height);\n    FillFrame();\n  }\n};\n\nclass ResizeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  ResizeTest() : EncoderTest(GET_PARAM(0)) {}\n\n  ~ResizeTest() override = default;\n\n  void SetUp() override {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n  }\n\n  void FramePktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    ASSERT_NE(static_cast<int>(pkt->data.frame.width[0]), 0);\n    ASSERT_NE(static_cast<int>(pkt->data.frame.height[0]), 0);\n    encode_frame_width_.push_back(pkt->data.frame.width[0]);\n    encode_frame_height_.push_back(pkt->data.frame.height[0]);\n  }\n\n  unsigned int GetFrameWidth(size_t idx) const {\n    return encode_frame_width_[idx];\n  }\n\n  unsigned int GetFrameHeight(size_t idx) const {\n    return encode_frame_height_[idx];\n  }\n\n  void DecompressedFrameHook(const vpx_image_t &img,\n                             vpx_codec_pts_t pts) override {\n    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));\n  }\n\n  std::vector<FrameInfo> frame_info_list_;\n  std::vector<unsigned int> encode_frame_width_;\n  std::vector<unsigned int> encode_frame_height_;\n};\n\nTEST_P(ResizeTest, TestExternalResizeWorks) {\n  ResizingVideoSource video;\n  video.flag_codec_ = false;\n  video.smaller_width_larger_size_ = false;\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    const size_t idx = info - frame_info_list_.begin();\n    ASSERT_EQ(info->w, GetFrameWidth(idx));\n    ASSERT_EQ(info->h, GetFrameHeight(idx));\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n  }\n}\n\nconst unsigned int kStepDownFrame = 3;\nconst unsigned int kStepUpFrame = 6;\n\nclass ResizeInternalTest : public ResizeTest {\n protected:\n#if WRITE_COMPRESSED_STREAM\n  ResizeInternalTest()\n      : ResizeTest(), frame0_psnr_(0.0), outfile_(nullptr), out_frames_(0) {}\n#else\n  ResizeInternalTest() : ResizeTest(), frame0_psnr_(0.0) {}\n#endif\n\n  ~ResizeInternalTest() override = default;\n\n  void BeginPassHook(unsigned int /*pass*/) override {\n#if WRITE_COMPRESSED_STREAM\n    outfile_ = fopen(\"vp90-2-05-resize.ivf\", \"wb\");\n#endif\n  }\n\n  void EndPassHook() override {\n#if WRITE_COMPRESSED_STREAM\n    if (outfile_) {\n      if (!fseek(outfile_, 0, SEEK_SET))\n        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n      fclose(outfile_);\n      outfile_ = nullptr;\n    }\n#endif\n  }\n\n  void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                          libvpx_test::Encoder *encoder) override {\n    if (change_config_) {\n      int new_q = 60;\n      if (video->frame() == 0) {\n        struct vpx_scaling_mode mode = { VP8E_ONETWO, VP8E_ONETWO };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n      if (video->frame() == 1) {\n        struct vpx_scaling_mode mode = { VP8E_NORMAL, VP8E_NORMAL };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n        cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = new_q;\n        encoder->Config(&cfg_);\n      }\n    } else {\n      if (video->frame() == kStepDownFrame) {\n        struct vpx_scaling_mode mode = { VP8E_FOURFIVE, VP8E_THREEFIVE };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n      if (video->frame() == kStepUpFrame) {\n        struct vpx_scaling_mode mode = { VP8E_NORMAL, VP8E_NORMAL };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n    }\n  }\n\n  void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    if (frame0_psnr_ == 0.) frame0_psnr_ = pkt->data.psnr.psnr[0];\n    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n  }\n\n#if WRITE_COMPRESSED_STREAM\n  void FramePktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) write_ivf_file_header(&cfg_, 0, outfile_);\n\n    // Write frame header and data.\n    write_ivf_frame_header(pkt, outfile_);\n    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n  }\n#endif\n\n  double frame0_psnr_;\n  bool change_config_;\n#if WRITE_COMPRESSED_STREAM\n  FILE *outfile_;\n  unsigned int out_frames_;\n#endif\n};\n\nTEST_P(ResizeInternalTest, TestInternalResizeWorks) {\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 10);\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  change_config_ = false;\n\n  // q picked such that initial keyframe on this clip is ~30dB PSNR\n  cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = 48;\n\n  // If the number of frames being encoded is smaller than g_lag_in_frames\n  // the encoded frame is unavailable using the current API. Comparing\n  // frames to detect mismatch would then not be possible. Set\n  // g_lag_in_frames = 0 to get around this.\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const vpx_codec_pts_t pts = info->pts;\n    if (pts >= kStepDownFrame && pts < kStepUpFrame) {\n      ASSERT_EQ(282U, info->w) << \"Frame \" << pts << \" had unexpected width\";\n      ASSERT_EQ(173U, info->h) << \"Frame \" << pts << \" had unexpected height\";\n    } else {\n      EXPECT_EQ(352U, info->w) << \"Frame \" << pts << \" had unexpected width\";\n      EXPECT_EQ(288U, info->h) << \"Frame \" << pts << \" had unexpected height\";\n    }\n  }\n}\n\nTEST_P(ResizeInternalTest, TestInternalResizeChangeConfig) {\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 10);\n  cfg_.g_w = 352;\n  cfg_.g_h = 288;\n  change_config_ = true;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}\n\nclass ResizeRealtimeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  ResizeRealtimeTest() : EncoderTest(GET_PARAM(0)) {}\n  ~ResizeRealtimeTest() override = default;\n\n  void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                          libvpx_test::Encoder *encoder) override {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_AQ_MODE, 3);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n    }\n\n    if (change_bitrate_ && video->frame() == 120) {\n      change_bitrate_ = false;\n      cfg_.rc_target_bitrate = 500;\n      encoder->Config(&cfg_);\n    }\n  }\n\n  void SetUp() override {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n  }\n\n  void DecompressedFrameHook(const vpx_image_t &img,\n                             vpx_codec_pts_t pts) override {\n    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));\n  }\n\n  void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2) override {\n    double mismatch_psnr = compute_psnr(img1, img2);\n    mismatch_psnr_ += mismatch_psnr;\n    ++mismatch_nframes_;\n  }\n\n  void FramePktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    ASSERT_NE(static_cast<int>(pkt->data.frame.width[0]), 0);\n    ASSERT_NE(static_cast<int>(pkt->data.frame.height[0]), 0);\n    encode_frame_width_.push_back(pkt->data.frame.width[0]);\n    encode_frame_height_.push_back(pkt->data.frame.height[0]);\n  }\n\n  unsigned int GetMismatchFrames() { return mismatch_nframes_; }\n\n  unsigned int GetFrameWidth(size_t idx) const {\n    return encode_frame_width_[idx];\n  }\n\n  unsigned int GetFrameHeight(size_t idx) const {\n    return encode_frame_height_[idx];\n  }\n\n  void DefaultConfig() {\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_min_quantizer = 2;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_undershoot_pct = 50;\n    cfg_.rc_overshoot_pct = 50;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.kf_mode = VPX_KF_AUTO;\n    cfg_.g_lag_in_frames = 0;\n    cfg_.kf_min_dist = cfg_.kf_max_dist = 3000;\n    // Enable dropped frames.\n    cfg_.rc_dropframe_thresh = 1;\n    // Enable error_resilience mode.\n    cfg_.g_error_resilient = 1;\n    // Enable dynamic resizing.\n    cfg_.rc_resize_allowed = 1;\n    // Run at low bitrate.\n    cfg_.rc_target_bitrate = 200;\n  }\n\n  std::vector<FrameInfo> frame_info_list_;\n  int set_cpu_used_;\n  bool change_bitrate_;\n  double mismatch_psnr_;\n  int mismatch_nframes_;\n  std::vector<unsigned int> encode_frame_width_;\n  std::vector<unsigned int> encode_frame_height_;\n};\n\nTEST_P(ResizeRealtimeTest, TestExternalResizeWorks) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = false;\n  DefaultConfig();\n  // Disable internal resize for this test.\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}\n\n// TODO(https://crbug.com/webm/1642): This causes a segfault in\n// init_encode_frame_mb_context().\nTEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  // Disable internal resize for this test.\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}\n\n// Verify the dynamic resizer behavior for real time, 1 pass CBR mode.\n// Run at low bitrate, with resize_allowed = 1, and verify that we get\n// one resize down event.\nTEST_P(ResizeRealtimeTest, TestInternalResizeDown) {\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 299);\n  DefaultConfig();\n  cfg_.g_w = 640;\n  cfg_.g_h = 480;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  unsigned int last_w = cfg_.g_w;\n  unsigned int last_h = cfg_.g_h;\n  int resize_count = 0;\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    if (info->w != last_w || info->h != last_h) {\n      // Verify that resize down occurs.\n      ASSERT_LT(info->w, last_w);\n      ASSERT_LT(info->h, last_h);\n      last_w = info->w;\n      last_h = info->h;\n      resize_count++;\n    }\n  }\n\n#if CONFIG_VP9_DECODER\n  // Verify that we get 1 resize down event in this test.\n  ASSERT_EQ(1, resize_count) << \"Resizing should occur.\";\n  EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n#else\n  printf(\"Warning: VP9 decoder unavailable, unable to check resize count!\\n\");\n#endif\n}\n\n// Verify the dynamic resizer behavior for real time, 1 pass CBR mode.\n// Start at low target bitrate, raise the bitrate in the middle of the clip,\n// scaling-up should occur after bitrate changed.\nTEST_P(ResizeRealtimeTest, TestInternalResizeDownUpChangeBitRate) {\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  DefaultConfig();\n  cfg_.g_w = 640;\n  cfg_.g_h = 480;\n  change_bitrate_ = true;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  // Disable dropped frames.\n  cfg_.rc_dropframe_thresh = 0;\n  // Starting bitrate low.\n  cfg_.rc_target_bitrate = 80;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  unsigned int last_w = cfg_.g_w;\n  unsigned int last_h = cfg_.g_h;\n  int resize_count = 0;\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const size_t idx = info - frame_info_list_.begin();\n    ASSERT_EQ(info->w, GetFrameWidth(idx));\n    ASSERT_EQ(info->h, GetFrameHeight(idx));\n    if (info->w != last_w || info->h != last_h) {\n      resize_count++;\n      if (resize_count <= 2) {\n        // Verify that resize down occurs.\n        ASSERT_LT(info->w, last_w);\n        ASSERT_LT(info->h, last_h);\n      } else if (resize_count > 2) {\n        // Verify that resize up occurs.\n        ASSERT_GT(info->w, last_w);\n        ASSERT_GT(info->h, last_h);\n      }\n      last_w = info->w;\n      last_h = info->h;\n    }\n  }\n\n#if CONFIG_VP9_DECODER\n  // Verify that we get 4 resize events in this test.\n  ASSERT_EQ(resize_count, 4) << \"Resizing should occur twice.\";\n  EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n#else\n  printf(\"Warning: VP9 decoder unavailable, unable to check resize count!\\n\");\n#endif\n}\n\nvpx_img_fmt_t CspForFrameNumber(int frame) {\n  if (frame < 10) return VPX_IMG_FMT_I420;\n  if (frame < 20) return VPX_IMG_FMT_I444;\n  return VPX_IMG_FMT_I420;\n}\n\nclass ResizeCspTest : public ResizeTest {\n protected:\n#if WRITE_COMPRESSED_STREAM\n  ResizeCspTest()\n      : ResizeTest(), frame0_psnr_(0.0), outfile_(nullptr), out_frames_(0) {}\n#else\n  ResizeCspTest() : ResizeTest(), frame0_psnr_(0.0) {}\n#endif\n\n  ~ResizeCspTest() override = default;\n\n  void BeginPassHook(unsigned int /*pass*/) override {\n#if WRITE_COMPRESSED_STREAM\n    outfile_ = fopen(\"vp91-2-05-cspchape.ivf\", \"wb\");\n#endif\n  }\n\n  void EndPassHook() override {\n#if WRITE_COMPRESSED_STREAM\n    if (outfile_) {\n      if (!fseek(outfile_, 0, SEEK_SET))\n        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n      fclose(outfile_);\n      outfile_ = nullptr;\n    }\n#endif\n  }\n\n  void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                          libvpx_test::Encoder *encoder) override {\n    if (CspForFrameNumber(video->frame()) != VPX_IMG_FMT_I420 &&\n        cfg_.g_profile != 1) {\n      cfg_.g_profile = 1;\n      encoder->Config(&cfg_);\n    }\n    if (CspForFrameNumber(video->frame()) == VPX_IMG_FMT_I420 &&\n        cfg_.g_profile != 0) {\n      cfg_.g_profile = 0;\n      encoder->Config(&cfg_);\n    }\n  }\n\n  void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    if (frame0_psnr_ == 0.) frame0_psnr_ = pkt->data.psnr.psnr[0];\n    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n  }\n\n#if WRITE_COMPRESSED_STREAM\n  void FramePktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) write_ivf_file_header(&cfg_, 0, outfile_);\n\n    // Write frame header and data.\n    write_ivf_frame_header(pkt, outfile_);\n    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n  }\n#endif\n\n  double frame0_psnr_;\n#if WRITE_COMPRESSED_STREAM\n  FILE *outfile_;\n  unsigned int out_frames_;\n#endif\n};\n\nclass ResizingCspVideoSource : public ::libvpx_test::DummyVideoSource {\n public:\n  ResizingCspVideoSource() {\n    SetSize(kInitialWidth, kInitialHeight);\n    limit_ = 30;\n  }\n\n  ~ResizingCspVideoSource() override = default;\n\n protected:\n  void Next() override {\n    ++frame_;\n    SetImageFormat(CspForFrameNumber(frame_));\n    FillFrame();\n  }\n};\n\nTEST_P(ResizeCspTest, TestResizeCspWorks) {\n  ResizingCspVideoSource video;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = 48;\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}\n\nVP8_INSTANTIATE_TEST_SUITE(ResizeTest, ONE_PASS_TEST_MODES);\nVP9_INSTANTIATE_TEST_SUITE(ResizeTest, ONE_PASS_TEST_MODES);\nVP9_INSTANTIATE_TEST_SUITE(ResizeInternalTest,\n                           ::testing::Values(::libvpx_test::kOnePassBest));\nVP9_INSTANTIATE_TEST_SUITE(ResizeRealtimeTest,\n                           ::testing::Values(::libvpx_test::kRealTime),\n                           ::testing::Range(5, 9));\nVP9_INSTANTIATE_TEST_SUITE(ResizeCspTest,\n                           ::testing::Values(::libvpx_test::kRealTime));\n}  // namespace\n", "/*\n *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n\n#include \"./vpx_config.h\"\n#include \"vpx_mem/vpx_mem.h\"\n\n#include \"vp9/common/vp9_alloccommon.h\"\n#include \"vp9/common/vp9_blockd.h\"\n#include \"vp9/common/vp9_entropymode.h\"\n#include \"vp9/common/vp9_entropymv.h\"\n#include \"vp9/common/vp9_onyxc_int.h\"\n\nvoid vp9_set_mi_size(int *mi_rows, int *mi_cols, int *mi_stride, int width,\n                     int height) {\n  const int aligned_width = ALIGN_POWER_OF_TWO(width, MI_SIZE_LOG2);\n  const int aligned_height = ALIGN_POWER_OF_TWO(height, MI_SIZE_LOG2);\n  *mi_cols = aligned_width >> MI_SIZE_LOG2;\n  *mi_rows = aligned_height >> MI_SIZE_LOG2;\n  *mi_stride = calc_mi_size(*mi_cols);\n}\n\nvoid vp9_set_mb_size(int *mb_rows, int *mb_cols, int *mb_num, int mi_rows,\n                     int mi_cols) {\n  *mb_cols = (mi_cols + 1) >> 1;\n  *mb_rows = (mi_rows + 1) >> 1;\n  *mb_num = (*mb_rows) * (*mb_cols);\n}\n\nvoid vp9_set_mb_mi(VP9_COMMON *cm, int width, int height) {\n  vp9_set_mi_size(&cm->mi_rows, &cm->mi_cols, &cm->mi_stride, width, height);\n  vp9_set_mb_size(&cm->mb_rows, &cm->mb_cols, &cm->MBs, cm->mi_rows,\n                  cm->mi_cols);\n}\n\nstatic int alloc_seg_map(VP9_COMMON *cm, int seg_map_size) {\n  int i;\n\n  for (i = 0; i < NUM_PING_PONG_BUFFERS; ++i) {\n    cm->seg_map_array[i] = (uint8_t *)vpx_calloc(seg_map_size, 1);\n    if (cm->seg_map_array[i] == NULL) return 1;\n  }\n  cm->seg_map_alloc_size = seg_map_size;\n\n  // Init the index.\n  cm->seg_map_idx = 0;\n  cm->prev_seg_map_idx = 1;\n\n  cm->current_frame_seg_map = cm->seg_map_array[cm->seg_map_idx];\n  cm->last_frame_seg_map = cm->seg_map_array[cm->prev_seg_map_idx];\n\n  return 0;\n}\n\nstatic void free_seg_map(VP9_COMMON *cm) {\n  int i;\n\n  for (i = 0; i < NUM_PING_PONG_BUFFERS; ++i) {\n    vpx_free(cm->seg_map_array[i]);\n    cm->seg_map_array[i] = NULL;\n  }\n  cm->seg_map_alloc_size = 0;\n\n  cm->current_frame_seg_map = NULL;\n  cm->last_frame_seg_map = NULL;\n}\n\nvoid vp9_free_ref_frame_buffers(BufferPool *pool) {\n  int i;\n\n  if (!pool) return;\n\n  for (i = 0; i < FRAME_BUFFERS; ++i) {\n    if (!pool->frame_bufs[i].released &&\n        pool->frame_bufs[i].raw_frame_buffer.data != NULL) {\n      pool->release_fb_cb(pool->cb_priv, &pool->frame_bufs[i].raw_frame_buffer);\n      pool->frame_bufs[i].ref_count = 0;\n      pool->frame_bufs[i].released = 1;\n    }\n    vpx_free(pool->frame_bufs[i].mvs);\n    pool->frame_bufs[i].mvs = NULL;\n    vpx_free_frame_buffer(&pool->frame_bufs[i].buf);\n  }\n}\n\nvoid vp9_free_postproc_buffers(VP9_COMMON *cm) {\n#if CONFIG_VP9_POSTPROC\n  vpx_free_frame_buffer(&cm->post_proc_buffer);\n  vpx_free_frame_buffer(&cm->post_proc_buffer_int);\n  vpx_free(cm->postproc_state.limits);\n  cm->postproc_state.limits = NULL;\n  vpx_free(cm->postproc_state.generated_noise);\n  cm->postproc_state.generated_noise = NULL;\n#else\n  (void)cm;\n#endif\n}\n\nvoid vp9_free_context_buffers(VP9_COMMON *cm) {\n  if (cm->free_mi) cm->free_mi(cm);\n  free_seg_map(cm);\n  vpx_free(cm->above_context);\n  cm->above_context = NULL;\n  vpx_free(cm->above_seg_context);\n  cm->above_seg_context = NULL;\n  cm->above_context_alloc_cols = 0;\n  vpx_free(cm->lf.lfm);\n  cm->lf.lfm = NULL;\n}\n\nint vp9_alloc_loop_filter(VP9_COMMON *cm) {\n  vpx_free(cm->lf.lfm);\n  // Each lfm holds bit masks for all the 8x8 blocks in a 64x64 region.  The\n  // stride and rows are rounded up / truncated to a multiple of 8.\n  cm->lf.lfm_stride = (cm->mi_cols + (MI_BLOCK_SIZE - 1)) >> 3;\n  cm->lf.lfm = (LOOP_FILTER_MASK *)vpx_calloc(\n      ((cm->mi_rows + (MI_BLOCK_SIZE - 1)) >> 3) * cm->lf.lfm_stride,\n      sizeof(*cm->lf.lfm));\n  if (!cm->lf.lfm) return 1;\n  return 0;\n}\n\nint vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}\n\nvoid vp9_remove_common(VP9_COMMON *cm) {\n#if CONFIG_VP9_POSTPROC\n  vp9_free_postproc_buffers(cm);\n#endif\n  vp9_free_context_buffers(cm);\n\n  vpx_free(cm->fc);\n  cm->fc = NULL;\n  vpx_free(cm->frame_contexts);\n  cm->frame_contexts = NULL;\n}\n\nvoid vp9_init_context_buffers(VP9_COMMON *cm) {\n  cm->setup_mi(cm);\n  if (cm->last_frame_seg_map)\n    memset(cm->last_frame_seg_map, 0, cm->mi_rows * cm->mi_cols);\n}\n\nvoid vp9_swap_current_and_last_seg_map(VP9_COMMON *cm) {\n  // Swap indices.\n  const int tmp = cm->seg_map_idx;\n  cm->seg_map_idx = cm->prev_seg_map_idx;\n  cm->prev_seg_map_idx = tmp;\n\n  cm->current_frame_seg_map = cm->seg_map_array[cm->seg_map_idx];\n  cm->last_frame_seg_map = cm->seg_map_array[cm->prev_seg_map_idx];\n}\n", "/*\n * Copyright (c) 2010 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"./vp9_rtcd.h\"\n#include \"./vpx_config.h\"\n#include \"./vpx_dsp_rtcd.h\"\n#include \"./vpx_scale_rtcd.h\"\n#include \"vpx_dsp/psnr.h\"\n#include \"vpx_dsp/vpx_dsp_common.h\"\n#include \"vpx_dsp/vpx_filter.h\"\n#if CONFIG_INTERNAL_STATS\n#include \"vpx_dsp/ssim.h\"\n#endif\n#include \"vpx_ports/mem.h\"\n#include \"vpx_ports/system_state.h\"\n#include \"vpx_ports/vpx_once.h\"\n#include \"vpx_ports/vpx_timer.h\"\n#if CONFIG_BITSTREAM_DEBUG || CONFIG_MISMATCH_DEBUG\n#include \"vpx_util/vpx_debug_util.h\"\n#endif  // CONFIG_BITSTREAM_DEBUG || CONFIG_MISMATCH_DEBUG\n\n#include \"vp9/common/vp9_alloccommon.h\"\n#include \"vp9/common/vp9_filter.h\"\n#include \"vp9/common/vp9_idct.h\"\n#if CONFIG_VP9_POSTPROC\n#include \"vp9/common/vp9_postproc.h\"\n#endif\n#include \"vp9/common/vp9_reconinter.h\"\n#include \"vp9/common/vp9_reconintra.h\"\n#include \"vp9/common/vp9_tile_common.h\"\n\n#if !CONFIG_REALTIME_ONLY\n#include \"vp9/encoder/vp9_alt_ref_aq.h\"\n#include \"vp9/encoder/vp9_aq_360.h\"\n#include \"vp9/encoder/vp9_aq_complexity.h\"\n#endif\n#include \"vp9/encoder/vp9_aq_cyclicrefresh.h\"\n#if !CONFIG_REALTIME_ONLY\n#include \"vp9/encoder/vp9_aq_variance.h\"\n#endif\n#include \"vp9/encoder/vp9_bitstream.h\"\n#if CONFIG_INTERNAL_STATS\n#include \"vp9/encoder/vp9_blockiness.h\"\n#endif\n#include \"vp9/encoder/vp9_context_tree.h\"\n#include \"vp9/encoder/vp9_encodeframe.h\"\n#include \"vp9/encoder/vp9_encodemb.h\"\n#include \"vp9/encoder/vp9_encodemv.h\"\n#include \"vp9/encoder/vp9_encoder.h\"\n#include \"vp9/encoder/vp9_ethread.h\"\n#include \"vp9/encoder/vp9_extend.h\"\n#include \"vp9/encoder/vp9_firstpass.h\"\n#include \"vp9/encoder/vp9_mbgraph.h\"\n#if CONFIG_NON_GREEDY_MV\n#include \"vp9/encoder/vp9_mcomp.h\"\n#endif\n#include \"vp9/encoder/vp9_multi_thread.h\"\n#include \"vp9/encoder/vp9_noise_estimate.h\"\n#include \"vp9/encoder/vp9_picklpf.h\"\n#include \"vp9/encoder/vp9_ratectrl.h\"\n#include \"vp9/encoder/vp9_rd.h\"\n#include \"vp9/encoder/vp9_resize.h\"\n#include \"vp9/encoder/vp9_segmentation.h\"\n#include \"vp9/encoder/vp9_skin_detection.h\"\n#include \"vp9/encoder/vp9_speed_features.h\"\n#include \"vp9/encoder/vp9_svc_layercontext.h\"\n#include \"vp9/encoder/vp9_temporal_filter.h\"\n#include \"vp9/encoder/vp9_tpl_model.h\"\n#include \"vp9/vp9_cx_iface.h\"\n\n#include \"vpx/vpx_ext_ratectrl.h\"\n\n#define AM_SEGMENT_ID_INACTIVE 7\n#define AM_SEGMENT_ID_ACTIVE 0\n\n// Whether to use high precision mv for altref computation.\n#define ALTREF_HIGH_PRECISION_MV 1\n\n// Q threshold for high precision mv. Choose a very high value for now so that\n// HIGH_PRECISION is always chosen.\n#define HIGH_PRECISION_MV_QTHRESH 200\n\n#define FRAME_SIZE_FACTOR 128  // empirical params for context model threshold\n#define FRAME_RATE_FACTOR 8\n\n#ifdef OUTPUT_YUV_DENOISED\nFILE *yuv_denoised_file = NULL;\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\nstatic FILE *yuv_skinmap_file = NULL;\n#endif\n#ifdef OUTPUT_YUV_REC\nFILE *yuv_rec_file;\n#endif\n#ifdef OUTPUT_YUV_SVC_SRC\nFILE *yuv_svc_src[3] = { NULL, NULL, NULL };\n#endif\n\n#if 0\nFILE *framepsnr;\nFILE *kf_list;\nFILE *keyfile;\n#endif\n\n#ifdef ENABLE_KF_DENOISE\n// Test condition for spatial denoise of source.\nstatic int is_spatial_denoise_enabled(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n\n  return (oxcf->pass != 1) && !is_lossless_requested(&cpi->oxcf) &&\n         frame_is_intra_only(cm);\n}\n#endif\n\n#if !CONFIG_REALTIME_ONLY\n// compute adaptive threshold for skip recoding\nstatic int compute_context_model_thresh(const VP9_COMP *const cpi) {\n  const VP9_COMMON *const cm = &cpi->common;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  const int frame_size = (cm->width * cm->height) >> 10;\n  const int bitrate = (int)(oxcf->target_bandwidth >> 10);\n  const int qindex_factor = cm->base_qindex + (MAXQ >> 1);\n\n  // This equation makes the threshold adaptive to frame size.\n  // Coding gain obtained by recoding comes from alternate frames of large\n  // content change. We skip recoding if the difference of previous and current\n  // frame context probability model is less than a certain threshold.\n  // The first component is the most critical part to guarantee adaptivity.\n  // Other parameters are estimated based on normal setting of hd resolution\n  // parameters. e.g. frame_size = 1920x1080, bitrate = 8000, qindex_factor < 50\n  const int thresh =\n      ((FRAME_SIZE_FACTOR * frame_size - FRAME_RATE_FACTOR * bitrate) *\n       qindex_factor) >>\n      9;\n\n  return thresh;\n}\n\n// compute the total cost difference between current\n// and previous frame context prob model.\nstatic int compute_context_model_diff(const VP9_COMMON *const cm) {\n  const FRAME_CONTEXT *const pre_fc =\n      &cm->frame_contexts[cm->frame_context_idx];\n  const FRAME_CONTEXT *const cur_fc = cm->fc;\n  const FRAME_COUNTS *counts = &cm->counts;\n  vpx_prob pre_last_prob, cur_last_prob;\n  int diff = 0;\n  int i, j, k, l, m, n;\n\n  // y_mode_prob\n  for (i = 0; i < BLOCK_SIZE_GROUPS; ++i) {\n    for (j = 0; j < INTRA_MODES - 1; ++j) {\n      diff += (int)counts->y_mode[i][j] *\n              (pre_fc->y_mode_prob[i][j] - cur_fc->y_mode_prob[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->y_mode_prob[i][INTRA_MODES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->y_mode_prob[i][INTRA_MODES - 2];\n\n    diff += (int)counts->y_mode[i][INTRA_MODES - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // uv_mode_prob\n  for (i = 0; i < INTRA_MODES; ++i) {\n    for (j = 0; j < INTRA_MODES - 1; ++j) {\n      diff += (int)counts->uv_mode[i][j] *\n              (pre_fc->uv_mode_prob[i][j] - cur_fc->uv_mode_prob[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->uv_mode_prob[i][INTRA_MODES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->uv_mode_prob[i][INTRA_MODES - 2];\n\n    diff += (int)counts->uv_mode[i][INTRA_MODES - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // partition_prob\n  for (i = 0; i < PARTITION_CONTEXTS; ++i) {\n    for (j = 0; j < PARTITION_TYPES - 1; ++j) {\n      diff += (int)counts->partition[i][j] *\n              (pre_fc->partition_prob[i][j] - cur_fc->partition_prob[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->partition_prob[i][PARTITION_TYPES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->partition_prob[i][PARTITION_TYPES - 2];\n\n    diff += (int)counts->partition[i][PARTITION_TYPES - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // coef_probs\n  for (i = 0; i < TX_SIZES; ++i) {\n    for (j = 0; j < PLANE_TYPES; ++j) {\n      for (k = 0; k < REF_TYPES; ++k) {\n        for (l = 0; l < COEF_BANDS; ++l) {\n          for (m = 0; m < BAND_COEFF_CONTEXTS(l); ++m) {\n            for (n = 0; n < UNCONSTRAINED_NODES; ++n) {\n              diff += (int)counts->coef[i][j][k][l][m][n] *\n                      (pre_fc->coef_probs[i][j][k][l][m][n] -\n                       cur_fc->coef_probs[i][j][k][l][m][n]);\n            }\n\n            pre_last_prob =\n                MAX_PROB -\n                pre_fc->coef_probs[i][j][k][l][m][UNCONSTRAINED_NODES - 1];\n            cur_last_prob =\n                MAX_PROB -\n                cur_fc->coef_probs[i][j][k][l][m][UNCONSTRAINED_NODES - 1];\n\n            diff += (int)counts->coef[i][j][k][l][m][UNCONSTRAINED_NODES] *\n                    (pre_last_prob - cur_last_prob);\n          }\n        }\n      }\n    }\n  }\n\n  // switchable_interp_prob\n  for (i = 0; i < SWITCHABLE_FILTER_CONTEXTS; ++i) {\n    for (j = 0; j < SWITCHABLE_FILTERS - 1; ++j) {\n      diff += (int)counts->switchable_interp[i][j] *\n              (pre_fc->switchable_interp_prob[i][j] -\n               cur_fc->switchable_interp_prob[i][j]);\n    }\n    pre_last_prob =\n        MAX_PROB - pre_fc->switchable_interp_prob[i][SWITCHABLE_FILTERS - 2];\n    cur_last_prob =\n        MAX_PROB - cur_fc->switchable_interp_prob[i][SWITCHABLE_FILTERS - 2];\n\n    diff += (int)counts->switchable_interp[i][SWITCHABLE_FILTERS - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // inter_mode_probs\n  for (i = 0; i < INTER_MODE_CONTEXTS; ++i) {\n    for (j = 0; j < INTER_MODES - 1; ++j) {\n      diff += (int)counts->inter_mode[i][j] *\n              (pre_fc->inter_mode_probs[i][j] - cur_fc->inter_mode_probs[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->inter_mode_probs[i][INTER_MODES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->inter_mode_probs[i][INTER_MODES - 2];\n\n    diff += (int)counts->inter_mode[i][INTER_MODES - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // intra_inter_prob\n  for (i = 0; i < INTRA_INTER_CONTEXTS; ++i) {\n    diff += (int)counts->intra_inter[i][0] *\n            (pre_fc->intra_inter_prob[i] - cur_fc->intra_inter_prob[i]);\n\n    pre_last_prob = MAX_PROB - pre_fc->intra_inter_prob[i];\n    cur_last_prob = MAX_PROB - cur_fc->intra_inter_prob[i];\n\n    diff += (int)counts->intra_inter[i][1] * (pre_last_prob - cur_last_prob);\n  }\n\n  // comp_inter_prob\n  for (i = 0; i < COMP_INTER_CONTEXTS; ++i) {\n    diff += (int)counts->comp_inter[i][0] *\n            (pre_fc->comp_inter_prob[i] - cur_fc->comp_inter_prob[i]);\n\n    pre_last_prob = MAX_PROB - pre_fc->comp_inter_prob[i];\n    cur_last_prob = MAX_PROB - cur_fc->comp_inter_prob[i];\n\n    diff += (int)counts->comp_inter[i][1] * (pre_last_prob - cur_last_prob);\n  }\n\n  // single_ref_prob\n  for (i = 0; i < REF_CONTEXTS; ++i) {\n    for (j = 0; j < 2; ++j) {\n      diff += (int)counts->single_ref[i][j][0] *\n              (pre_fc->single_ref_prob[i][j] - cur_fc->single_ref_prob[i][j]);\n\n      pre_last_prob = MAX_PROB - pre_fc->single_ref_prob[i][j];\n      cur_last_prob = MAX_PROB - cur_fc->single_ref_prob[i][j];\n\n      diff +=\n          (int)counts->single_ref[i][j][1] * (pre_last_prob - cur_last_prob);\n    }\n  }\n\n  // comp_ref_prob\n  for (i = 0; i < REF_CONTEXTS; ++i) {\n    diff += (int)counts->comp_ref[i][0] *\n            (pre_fc->comp_ref_prob[i] - cur_fc->comp_ref_prob[i]);\n\n    pre_last_prob = MAX_PROB - pre_fc->comp_ref_prob[i];\n    cur_last_prob = MAX_PROB - cur_fc->comp_ref_prob[i];\n\n    diff += (int)counts->comp_ref[i][1] * (pre_last_prob - cur_last_prob);\n  }\n\n  // tx_probs\n  for (i = 0; i < TX_SIZE_CONTEXTS; ++i) {\n    // p32x32\n    for (j = 0; j < TX_SIZES - 1; ++j) {\n      diff += (int)counts->tx.p32x32[i][j] *\n              (pre_fc->tx_probs.p32x32[i][j] - cur_fc->tx_probs.p32x32[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->tx_probs.p32x32[i][TX_SIZES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->tx_probs.p32x32[i][TX_SIZES - 2];\n\n    diff += (int)counts->tx.p32x32[i][TX_SIZES - 1] *\n            (pre_last_prob - cur_last_prob);\n\n    // p16x16\n    for (j = 0; j < TX_SIZES - 2; ++j) {\n      diff += (int)counts->tx.p16x16[i][j] *\n              (pre_fc->tx_probs.p16x16[i][j] - cur_fc->tx_probs.p16x16[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->tx_probs.p16x16[i][TX_SIZES - 3];\n    cur_last_prob = MAX_PROB - cur_fc->tx_probs.p16x16[i][TX_SIZES - 3];\n\n    diff += (int)counts->tx.p16x16[i][TX_SIZES - 2] *\n            (pre_last_prob - cur_last_prob);\n\n    // p8x8\n    for (j = 0; j < TX_SIZES - 3; ++j) {\n      diff += (int)counts->tx.p8x8[i][j] *\n              (pre_fc->tx_probs.p8x8[i][j] - cur_fc->tx_probs.p8x8[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->tx_probs.p8x8[i][TX_SIZES - 4];\n    cur_last_prob = MAX_PROB - cur_fc->tx_probs.p8x8[i][TX_SIZES - 4];\n\n    diff +=\n        (int)counts->tx.p8x8[i][TX_SIZES - 3] * (pre_last_prob - cur_last_prob);\n  }\n\n  // skip_probs\n  for (i = 0; i < SKIP_CONTEXTS; ++i) {\n    diff += (int)counts->skip[i][0] *\n            (pre_fc->skip_probs[i] - cur_fc->skip_probs[i]);\n\n    pre_last_prob = MAX_PROB - pre_fc->skip_probs[i];\n    cur_last_prob = MAX_PROB - cur_fc->skip_probs[i];\n\n    diff += (int)counts->skip[i][1] * (pre_last_prob - cur_last_prob);\n  }\n\n  // mv\n  for (i = 0; i < MV_JOINTS - 1; ++i) {\n    diff += (int)counts->mv.joints[i] *\n            (pre_fc->nmvc.joints[i] - cur_fc->nmvc.joints[i]);\n  }\n  pre_last_prob = MAX_PROB - pre_fc->nmvc.joints[MV_JOINTS - 2];\n  cur_last_prob = MAX_PROB - cur_fc->nmvc.joints[MV_JOINTS - 2];\n\n  diff +=\n      (int)counts->mv.joints[MV_JOINTS - 1] * (pre_last_prob - cur_last_prob);\n\n  for (i = 0; i < 2; ++i) {\n    const nmv_component_counts *nmv_count = &counts->mv.comps[i];\n    const nmv_component *pre_nmv_prob = &pre_fc->nmvc.comps[i];\n    const nmv_component *cur_nmv_prob = &cur_fc->nmvc.comps[i];\n\n    // sign\n    diff += (int)nmv_count->sign[0] * (pre_nmv_prob->sign - cur_nmv_prob->sign);\n\n    pre_last_prob = MAX_PROB - pre_nmv_prob->sign;\n    cur_last_prob = MAX_PROB - cur_nmv_prob->sign;\n\n    diff += (int)nmv_count->sign[1] * (pre_last_prob - cur_last_prob);\n\n    // classes\n    for (j = 0; j < MV_CLASSES - 1; ++j) {\n      diff += (int)nmv_count->classes[j] *\n              (pre_nmv_prob->classes[j] - cur_nmv_prob->classes[j]);\n    }\n    pre_last_prob = MAX_PROB - pre_nmv_prob->classes[MV_CLASSES - 2];\n    cur_last_prob = MAX_PROB - cur_nmv_prob->classes[MV_CLASSES - 2];\n\n    diff += (int)nmv_count->classes[MV_CLASSES - 1] *\n            (pre_last_prob - cur_last_prob);\n\n    // class0\n    for (j = 0; j < CLASS0_SIZE - 1; ++j) {\n      diff += (int)nmv_count->class0[j] *\n              (pre_nmv_prob->class0[j] - cur_nmv_prob->class0[j]);\n    }\n    pre_last_prob = MAX_PROB - pre_nmv_prob->class0[CLASS0_SIZE - 2];\n    cur_last_prob = MAX_PROB - cur_nmv_prob->class0[CLASS0_SIZE - 2];\n\n    diff += (int)nmv_count->class0[CLASS0_SIZE - 1] *\n            (pre_last_prob - cur_last_prob);\n\n    // bits\n    for (j = 0; j < MV_OFFSET_BITS; ++j) {\n      diff += (int)nmv_count->bits[j][0] *\n              (pre_nmv_prob->bits[j] - cur_nmv_prob->bits[j]);\n\n      pre_last_prob = MAX_PROB - pre_nmv_prob->bits[j];\n      cur_last_prob = MAX_PROB - cur_nmv_prob->bits[j];\n\n      diff += (int)nmv_count->bits[j][1] * (pre_last_prob - cur_last_prob);\n    }\n\n    // class0_fp\n    for (j = 0; j < CLASS0_SIZE; ++j) {\n      for (k = 0; k < MV_FP_SIZE - 1; ++k) {\n        diff += (int)nmv_count->class0_fp[j][k] *\n                (pre_nmv_prob->class0_fp[j][k] - cur_nmv_prob->class0_fp[j][k]);\n      }\n      pre_last_prob = MAX_PROB - pre_nmv_prob->class0_fp[j][MV_FP_SIZE - 2];\n      cur_last_prob = MAX_PROB - cur_nmv_prob->class0_fp[j][MV_FP_SIZE - 2];\n\n      diff += (int)nmv_count->class0_fp[j][MV_FP_SIZE - 1] *\n              (pre_last_prob - cur_last_prob);\n    }\n\n    // fp\n    for (j = 0; j < MV_FP_SIZE - 1; ++j) {\n      diff +=\n          (int)nmv_count->fp[j] * (pre_nmv_prob->fp[j] - cur_nmv_prob->fp[j]);\n    }\n    pre_last_prob = MAX_PROB - pre_nmv_prob->fp[MV_FP_SIZE - 2];\n    cur_last_prob = MAX_PROB - cur_nmv_prob->fp[MV_FP_SIZE - 2];\n\n    diff +=\n        (int)nmv_count->fp[MV_FP_SIZE - 1] * (pre_last_prob - cur_last_prob);\n\n    // class0_hp\n    diff += (int)nmv_count->class0_hp[0] *\n            (pre_nmv_prob->class0_hp - cur_nmv_prob->class0_hp);\n\n    pre_last_prob = MAX_PROB - pre_nmv_prob->class0_hp;\n    cur_last_prob = MAX_PROB - cur_nmv_prob->class0_hp;\n\n    diff += (int)nmv_count->class0_hp[1] * (pre_last_prob - cur_last_prob);\n\n    // hp\n    diff += (int)nmv_count->hp[0] * (pre_nmv_prob->hp - cur_nmv_prob->hp);\n\n    pre_last_prob = MAX_PROB - pre_nmv_prob->hp;\n    cur_last_prob = MAX_PROB - cur_nmv_prob->hp;\n\n    diff += (int)nmv_count->hp[1] * (pre_last_prob - cur_last_prob);\n  }\n\n  return -diff;\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\n// Test for whether to calculate metrics for the frame.\nstatic int is_psnr_calc_enabled(const VP9_COMP *cpi) {\n  const VP9_COMMON *const cm = &cpi->common;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n\n  return cpi->b_calculate_psnr && (oxcf->pass != 1) && cm->show_frame;\n}\n\n/* clang-format off */\nconst Vp9LevelSpec vp9_level_defs[VP9_LEVELS] = {\n  //         sample rate    size   breadth  bitrate  cpb\n  { LEVEL_1,   829440,      36864,    512,   200,    400,    2, 1,  4,  8 },\n  { LEVEL_1_1, 2764800,     73728,    768,   800,    1000,   2, 1,  4,  8 },\n  { LEVEL_2,   4608000,     122880,   960,   1800,   1500,   2, 1,  4,  8 },\n  { LEVEL_2_1, 9216000,     245760,   1344,  3600,   2800,   2, 2,  4,  8 },\n  { LEVEL_3,   20736000,    552960,   2048,  7200,   6000,   2, 4,  4,  8 },\n  { LEVEL_3_1, 36864000,    983040,   2752,  12000,  10000,  2, 4,  4,  8 },\n  { LEVEL_4,   83558400,    2228224,  4160,  18000,  16000,  4, 4,  4,  8 },\n  { LEVEL_4_1, 160432128,   2228224,  4160,  30000,  18000,  4, 4,  5,  6 },\n  { LEVEL_5,   311951360,   8912896,  8384,  60000,  36000,  6, 8,  6,  4 },\n  { LEVEL_5_1, 588251136,   8912896,  8384,  120000, 46000,  8, 8,  10, 4 },\n  // TODO(huisu): update max_cpb_size for level 5_2 ~ 6_2 when\n  // they are finalized (currently tentative).\n  { LEVEL_5_2, 1176502272,  8912896,  8384,  180000, 90000,  8, 8,  10, 4 },\n  { LEVEL_6,   1176502272,  35651584, 16832, 180000, 90000,  8, 16, 10, 4 },\n  { LEVEL_6_1, 2353004544u, 35651584, 16832, 240000, 180000, 8, 16, 10, 4 },\n  { LEVEL_6_2, 4706009088u, 35651584, 16832, 480000, 360000, 8, 16, 10, 4 },\n};\n/* clang-format on */\n\nstatic const char *level_fail_messages[TARGET_LEVEL_FAIL_IDS] = {\n  \"The average bit-rate is too high.\",\n  \"The picture size is too large.\",\n  \"The picture width/height is too large.\",\n  \"The luma sample rate is too large.\",\n  \"The CPB size is too large.\",\n  \"The compression ratio is too small\",\n  \"Too many column tiles are used.\",\n  \"The alt-ref distance is too small.\",\n  \"Too many reference buffers are used.\"\n};\n\nstatic INLINE void Scale2Ratio(VPX_SCALING_MODE mode, int *hr, int *hs) {\n  switch (mode) {\n    case VP8E_NORMAL:\n      *hr = 1;\n      *hs = 1;\n      break;\n    case VP8E_FOURFIVE:\n      *hr = 4;\n      *hs = 5;\n      break;\n    case VP8E_THREEFIVE:\n      *hr = 3;\n      *hs = 5;\n      break;\n    default:\n      assert(mode == VP8E_ONETWO);\n      *hr = 1;\n      *hs = 2;\n      break;\n  }\n}\n\n// Mark all inactive blocks as active. Other segmentation features may be set\n// so memset cannot be used, instead only inactive blocks should be reset.\nstatic void suppress_active_map(VP9_COMP *cpi) {\n  unsigned char *const seg_map = cpi->segmentation_map;\n\n  if (cpi->active_map.enabled || cpi->active_map.update) {\n    const int rows = cpi->common.mi_rows;\n    const int cols = cpi->common.mi_cols;\n    int i;\n\n    for (i = 0; i < rows * cols; ++i)\n      if (seg_map[i] == AM_SEGMENT_ID_INACTIVE)\n        seg_map[i] = AM_SEGMENT_ID_ACTIVE;\n  }\n}\n\nstatic void apply_active_map(VP9_COMP *cpi) {\n  struct segmentation *const seg = &cpi->common.seg;\n  unsigned char *const seg_map = cpi->segmentation_map;\n  const unsigned char *const active_map = cpi->active_map.map;\n  int i;\n\n  assert(AM_SEGMENT_ID_ACTIVE == CR_SEGMENT_ID_BASE);\n\n  if (frame_is_intra_only(&cpi->common)) {\n    cpi->active_map.enabled = 0;\n    cpi->active_map.update = 1;\n  }\n\n  if (cpi->active_map.update) {\n    if (cpi->active_map.enabled) {\n      for (i = 0; i < cpi->common.mi_rows * cpi->common.mi_cols; ++i)\n        if (seg_map[i] == AM_SEGMENT_ID_ACTIVE) seg_map[i] = active_map[i];\n      vp9_enable_segmentation(seg);\n      vp9_enable_segfeature(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_SKIP);\n      vp9_enable_segfeature(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_ALT_LF);\n      // Setting the data to -MAX_LOOP_FILTER will result in the computed loop\n      // filter level being zero regardless of the value of seg->abs_delta.\n      vp9_set_segdata(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_ALT_LF,\n                      -MAX_LOOP_FILTER);\n    } else {\n      vp9_disable_segfeature(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_SKIP);\n      vp9_disable_segfeature(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_ALT_LF);\n      if (seg->enabled) {\n        seg->update_data = 1;\n        seg->update_map = 1;\n      }\n    }\n    cpi->active_map.update = 0;\n  }\n}\n\nstatic void apply_roi_map(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  struct segmentation *const seg = &cm->seg;\n  vpx_roi_map_t *roi = &cpi->roi;\n  const int *delta_q = roi->delta_q;\n  const int *delta_lf = roi->delta_lf;\n  const int *skip = roi->skip;\n  int ref_frame[8];\n  int internal_delta_q[MAX_SEGMENTS];\n  int i;\n\n  // TODO(jianj): Investigate why ROI not working in speed < 5 or in non\n  // realtime mode.\n  if (cpi->oxcf.mode != REALTIME || cpi->oxcf.speed < 5) return;\n  if (!roi->enabled) return;\n\n  memcpy(&ref_frame, roi->ref_frame, sizeof(ref_frame));\n\n  vp9_enable_segmentation(seg);\n  vp9_clearall_segfeatures(seg);\n  // Select delta coding method;\n  seg->abs_delta = SEGMENT_DELTADATA;\n\n  memcpy(cpi->segmentation_map, roi->roi_map, (cm->mi_rows * cm->mi_cols));\n\n  for (i = 0; i < MAX_SEGMENTS; ++i) {\n    // Translate the external delta q values to internal values.\n    internal_delta_q[i] = vp9_quantizer_to_qindex(abs(delta_q[i]));\n    if (delta_q[i] < 0) internal_delta_q[i] = -internal_delta_q[i];\n    vp9_disable_segfeature(seg, i, SEG_LVL_ALT_Q);\n    vp9_disable_segfeature(seg, i, SEG_LVL_ALT_LF);\n    if (internal_delta_q[i] != 0) {\n      vp9_enable_segfeature(seg, i, SEG_LVL_ALT_Q);\n      vp9_set_segdata(seg, i, SEG_LVL_ALT_Q, internal_delta_q[i]);\n    }\n    if (delta_lf[i] != 0) {\n      vp9_enable_segfeature(seg, i, SEG_LVL_ALT_LF);\n      vp9_set_segdata(seg, i, SEG_LVL_ALT_LF, delta_lf[i]);\n    }\n    if (skip[i] != 0) {\n      vp9_enable_segfeature(seg, i, SEG_LVL_SKIP);\n      vp9_set_segdata(seg, i, SEG_LVL_SKIP, 0);\n    }\n    if (ref_frame[i] >= 0) {\n      int valid_ref = 1;\n      // ALTREF is not used as reference for nonrd_pickmode with 0 lag.\n      if (ref_frame[i] == ALTREF_FRAME && cpi->sf.use_nonrd_pick_mode)\n        valid_ref = 0;\n      // If GOLDEN is selected, make sure it's set as reference.\n      if (ref_frame[i] == GOLDEN_FRAME &&\n          !(cpi->ref_frame_flags & ref_frame_to_flag(ref_frame[i]))) {\n        valid_ref = 0;\n      }\n      // GOLDEN was updated in previous encoded frame, so GOLDEN and LAST are\n      // same reference.\n      if (ref_frame[i] == GOLDEN_FRAME && cpi->rc.frames_since_golden == 0)\n        ref_frame[i] = LAST_FRAME;\n      if (valid_ref) {\n        vp9_enable_segfeature(seg, i, SEG_LVL_REF_FRAME);\n        vp9_set_segdata(seg, i, SEG_LVL_REF_FRAME, ref_frame[i]);\n      }\n    }\n  }\n  roi->enabled = 1;\n}\n\nstatic void init_level_info(Vp9LevelInfo *level_info) {\n  Vp9LevelStats *const level_stats = &level_info->level_stats;\n  Vp9LevelSpec *const level_spec = &level_info->level_spec;\n\n  memset(level_stats, 0, sizeof(*level_stats));\n  memset(level_spec, 0, sizeof(*level_spec));\n  level_spec->level = LEVEL_UNKNOWN;\n  level_spec->min_altref_distance = INT_MAX;\n}\n\nstatic int check_seg_range(int seg_data[8], int range) {\n  int i;\n  for (i = 0; i < 8; ++i) {\n    // Note abs() alone can't be used as the behavior of abs(INT_MIN) is\n    // undefined.\n    if (seg_data[i] > range || seg_data[i] < -range) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nVP9_LEVEL vp9_get_level(const Vp9LevelSpec *const level_spec) {\n  int i;\n  const Vp9LevelSpec *this_level;\n\n  vpx_clear_system_state();\n\n  for (i = 0; i < VP9_LEVELS; ++i) {\n    this_level = &vp9_level_defs[i];\n    if ((double)level_spec->max_luma_sample_rate >\n            (double)this_level->max_luma_sample_rate *\n                (1 + SAMPLE_RATE_GRACE_P) ||\n        level_spec->max_luma_picture_size > this_level->max_luma_picture_size ||\n        level_spec->max_luma_picture_breadth >\n            this_level->max_luma_picture_breadth ||\n        level_spec->average_bitrate > this_level->average_bitrate ||\n        level_spec->max_cpb_size > this_level->max_cpb_size ||\n        level_spec->compression_ratio < this_level->compression_ratio ||\n        level_spec->max_col_tiles > this_level->max_col_tiles ||\n        level_spec->min_altref_distance < this_level->min_altref_distance ||\n        level_spec->max_ref_frame_buffers > this_level->max_ref_frame_buffers)\n      continue;\n    break;\n  }\n  return (i == VP9_LEVELS) ? LEVEL_UNKNOWN : vp9_level_defs[i].level;\n}\n\nvpx_codec_err_t vp9_set_roi_map(VP9_COMP *cpi, unsigned char *map,\n                                unsigned int rows, unsigned int cols,\n                                int delta_q[8], int delta_lf[8], int skip[8],\n                                int ref_frame[8]) {\n  VP9_COMMON *cm = &cpi->common;\n  vpx_roi_map_t *roi = &cpi->roi;\n  const int range = 63;\n  const int ref_frame_range = 3;  // Alt-ref\n  const int skip_range = 1;\n  const int frame_rows = cpi->common.mi_rows;\n  const int frame_cols = cpi->common.mi_cols;\n\n  // Check number of rows and columns match\n  if (frame_rows != (int)rows || frame_cols != (int)cols) {\n    return VPX_CODEC_INVALID_PARAM;\n  }\n\n  if (!check_seg_range(delta_q, range) || !check_seg_range(delta_lf, range) ||\n      !check_seg_range(ref_frame, ref_frame_range) ||\n      !check_seg_range(skip, skip_range))\n    return VPX_CODEC_INVALID_PARAM;\n\n  // Also disable segmentation if no deltas are specified.\n  if (!map ||\n      (!(delta_q[0] | delta_q[1] | delta_q[2] | delta_q[3] | delta_q[4] |\n         delta_q[5] | delta_q[6] | delta_q[7] | delta_lf[0] | delta_lf[1] |\n         delta_lf[2] | delta_lf[3] | delta_lf[4] | delta_lf[5] | delta_lf[6] |\n         delta_lf[7] | skip[0] | skip[1] | skip[2] | skip[3] | skip[4] |\n         skip[5] | skip[6] | skip[7]) &&\n       (ref_frame[0] == -1 && ref_frame[1] == -1 && ref_frame[2] == -1 &&\n        ref_frame[3] == -1 && ref_frame[4] == -1 && ref_frame[5] == -1 &&\n        ref_frame[6] == -1 && ref_frame[7] == -1))) {\n    vp9_disable_segmentation(&cm->seg);\n    cpi->roi.enabled = 0;\n    return VPX_CODEC_OK;\n  }\n\n  if (roi->roi_map) {\n    vpx_free(roi->roi_map);\n    roi->roi_map = NULL;\n  }\n  roi->roi_map = vpx_malloc(rows * cols);\n  if (!roi->roi_map) return VPX_CODEC_MEM_ERROR;\n\n  // Copy to ROI structure in the compressor.\n  memcpy(roi->roi_map, map, rows * cols);\n  memcpy(&roi->delta_q, delta_q, MAX_SEGMENTS * sizeof(delta_q[0]));\n  memcpy(&roi->delta_lf, delta_lf, MAX_SEGMENTS * sizeof(delta_lf[0]));\n  memcpy(&roi->skip, skip, MAX_SEGMENTS * sizeof(skip[0]));\n  memcpy(&roi->ref_frame, ref_frame, MAX_SEGMENTS * sizeof(ref_frame[0]));\n  roi->enabled = 1;\n  roi->rows = rows;\n  roi->cols = cols;\n\n  return VPX_CODEC_OK;\n}\n\nint vp9_set_active_map(VP9_COMP *cpi, unsigned char *new_map_16x16, int rows,\n                       int cols) {\n  if (rows == cpi->common.mb_rows && cols == cpi->common.mb_cols) {\n    unsigned char *const active_map_8x8 = cpi->active_map.map;\n    const int mi_rows = cpi->common.mi_rows;\n    const int mi_cols = cpi->common.mi_cols;\n    cpi->active_map.update = 1;\n    if (new_map_16x16) {\n      int r, c;\n      for (r = 0; r < mi_rows; ++r) {\n        for (c = 0; c < mi_cols; ++c) {\n          active_map_8x8[r * mi_cols + c] =\n              new_map_16x16[(r >> 1) * cols + (c >> 1)]\n                  ? AM_SEGMENT_ID_ACTIVE\n                  : AM_SEGMENT_ID_INACTIVE;\n        }\n      }\n      cpi->active_map.enabled = 1;\n    } else {\n      cpi->active_map.enabled = 0;\n    }\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint vp9_get_active_map(VP9_COMP *cpi, unsigned char *new_map_16x16, int rows,\n                       int cols) {\n  if (rows == cpi->common.mb_rows && cols == cpi->common.mb_cols &&\n      new_map_16x16) {\n    unsigned char *const seg_map_8x8 = cpi->segmentation_map;\n    const int mi_rows = cpi->common.mi_rows;\n    const int mi_cols = cpi->common.mi_cols;\n    memset(new_map_16x16, !cpi->active_map.enabled, rows * cols);\n    if (cpi->active_map.enabled) {\n      int r, c;\n      for (r = 0; r < mi_rows; ++r) {\n        for (c = 0; c < mi_cols; ++c) {\n          // Cyclic refresh segments are considered active despite not having\n          // AM_SEGMENT_ID_ACTIVE\n          new_map_16x16[(r >> 1) * cols + (c >> 1)] |=\n              seg_map_8x8[r * mi_cols + c] != AM_SEGMENT_ID_INACTIVE;\n        }\n      }\n    }\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nvoid vp9_set_high_precision_mv(VP9_COMP *cpi, int allow_high_precision_mv) {\n  MACROBLOCK *const mb = &cpi->td.mb;\n  cpi->common.allow_high_precision_mv = allow_high_precision_mv;\n  if (cpi->common.allow_high_precision_mv) {\n    mb->mvcost = mb->nmvcost_hp;\n    mb->mvsadcost = mb->nmvsadcost_hp;\n  } else {\n    mb->mvcost = mb->nmvcost;\n    mb->mvsadcost = mb->nmvsadcost;\n  }\n}\n\nstatic void setup_frame(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  // Set up entropy context depending on frame type. The decoder mandates\n  // the use of the default context, index 0, for keyframes and inter\n  // frames where the error_resilient_mode or intra_only flag is set. For\n  // other inter-frames the encoder currently uses only two contexts;\n  // context 1 for ALTREF frames and context 0 for the others.\n  if (frame_is_intra_only(cm) || cm->error_resilient_mode) {\n    vp9_setup_past_independence(cm);\n  } else {\n    if (!cpi->use_svc) cm->frame_context_idx = cpi->refresh_alt_ref_frame;\n  }\n\n  // TODO(jingning): Overwrite the frame_context_idx index in multi-layer ARF\n  // case. Need some further investigation on if we could apply this to single\n  // layer ARF case as well.\n  if (cpi->multi_layer_arf && !cpi->use_svc) {\n    GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n    const int gf_group_index = gf_group->index;\n    const int boost_frame =\n        !cpi->rc.is_src_frame_alt_ref &&\n        (cpi->refresh_golden_frame || cpi->refresh_alt_ref_frame);\n\n    // frame_context_idx           Frame Type\n    //        0              Intra only frame, base layer ARF\n    //        1              ARFs with layer depth = 2,3\n    //        2              ARFs with layer depth > 3\n    //        3              Non-boosted frames\n    if (frame_is_intra_only(cm)) {\n      cm->frame_context_idx = 0;\n    } else if (boost_frame) {\n      if (gf_group->rf_level[gf_group_index] == GF_ARF_STD)\n        cm->frame_context_idx = 0;\n      else if (gf_group->layer_depth[gf_group_index] <= 3)\n        cm->frame_context_idx = 1;\n      else\n        cm->frame_context_idx = 2;\n    } else {\n      cm->frame_context_idx = 3;\n    }\n  }\n\n  if (cm->frame_type == KEY_FRAME) {\n    cpi->refresh_golden_frame = 1;\n    cpi->refresh_alt_ref_frame = 1;\n    vp9_zero(cpi->interp_filter_selected);\n  } else {\n    *cm->fc = cm->frame_contexts[cm->frame_context_idx];\n    vp9_zero(cpi->interp_filter_selected[0]);\n  }\n}\n\nstatic void vp9_enc_setup_mi(VP9_COMMON *cm) {\n  int i;\n  cm->mi = cm->mip + cm->mi_stride + 1;\n  memset(cm->mip, 0, cm->mi_stride * (cm->mi_rows + 1) * sizeof(*cm->mip));\n  cm->prev_mi = cm->prev_mip + cm->mi_stride + 1;\n  // Clear top border row\n  memset(cm->prev_mip, 0, sizeof(*cm->prev_mip) * cm->mi_stride);\n  // Clear left border column\n  for (i = 1; i < cm->mi_rows + 1; ++i)\n    memset(&cm->prev_mip[i * cm->mi_stride], 0, sizeof(*cm->prev_mip));\n\n  cm->mi_grid_visible = cm->mi_grid_base + cm->mi_stride + 1;\n  cm->prev_mi_grid_visible = cm->prev_mi_grid_base + cm->mi_stride + 1;\n\n  memset(cm->mi_grid_base, 0,\n         cm->mi_stride * (cm->mi_rows + 1) * sizeof(*cm->mi_grid_base));\n}\n\nstatic int vp9_enc_alloc_mi(VP9_COMMON *cm, int mi_size) {\n  cm->mip = vpx_calloc(mi_size, sizeof(*cm->mip));\n  if (!cm->mip) return 1;\n  cm->prev_mip = vpx_calloc(mi_size, sizeof(*cm->prev_mip));\n  if (!cm->prev_mip) return 1;\n  cm->mi_alloc_size = mi_size;\n\n  cm->mi_grid_base = (MODE_INFO **)vpx_calloc(mi_size, sizeof(MODE_INFO *));\n  if (!cm->mi_grid_base) return 1;\n  cm->prev_mi_grid_base =\n      (MODE_INFO **)vpx_calloc(mi_size, sizeof(MODE_INFO *));\n  if (!cm->prev_mi_grid_base) return 1;\n\n  return 0;\n}\n\nstatic void vp9_enc_free_mi(VP9_COMMON *cm) {\n  vpx_free(cm->mip);\n  cm->mip = NULL;\n  vpx_free(cm->prev_mip);\n  cm->prev_mip = NULL;\n  vpx_free(cm->mi_grid_base);\n  cm->mi_grid_base = NULL;\n  vpx_free(cm->prev_mi_grid_base);\n  cm->prev_mi_grid_base = NULL;\n  cm->mi_alloc_size = 0;\n}\n\nstatic void vp9_swap_mi_and_prev_mi(VP9_COMMON *cm) {\n  // Current mip will be the prev_mip for the next frame.\n  MODE_INFO **temp_base = cm->prev_mi_grid_base;\n  MODE_INFO *temp = cm->prev_mip;\n\n  // Skip update prev_mi frame in show_existing_frame mode.\n  if (cm->show_existing_frame) return;\n\n  cm->prev_mip = cm->mip;\n  cm->mip = temp;\n\n  // Update the upper left visible macroblock ptrs.\n  cm->mi = cm->mip + cm->mi_stride + 1;\n  cm->prev_mi = cm->prev_mip + cm->mi_stride + 1;\n\n  cm->prev_mi_grid_base = cm->mi_grid_base;\n  cm->mi_grid_base = temp_base;\n  cm->mi_grid_visible = cm->mi_grid_base + cm->mi_stride + 1;\n  cm->prev_mi_grid_visible = cm->prev_mi_grid_base + cm->mi_stride + 1;\n}\n\nstatic void initialize_enc(void) {\n  vp9_rtcd();\n  vpx_dsp_rtcd();\n  vpx_scale_rtcd();\n  vp9_init_intra_predictors();\n  vp9_init_me_luts();\n  vp9_rc_init_minq_luts();\n  vp9_entropy_mv_init();\n#if !CONFIG_REALTIME_ONLY\n  vp9_temporal_filter_init();\n#endif\n}\n\nvoid vp9_initialize_enc(void) { once(initialize_enc); }\n\nstatic void dealloc_compressor_data(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  int i;\n\n  vpx_free(cpi->mbmi_ext_base);\n  cpi->mbmi_ext_base = NULL;\n\n  vpx_free(cpi->tile_data);\n  cpi->tile_data = NULL;\n\n  vpx_free(cpi->segmentation_map);\n  cpi->segmentation_map = NULL;\n  vpx_free(cpi->coding_context.last_frame_seg_map_copy);\n  cpi->coding_context.last_frame_seg_map_copy = NULL;\n\n  vpx_free(cpi->nmvcosts[0]);\n  vpx_free(cpi->nmvcosts[1]);\n  cpi->nmvcosts[0] = NULL;\n  cpi->nmvcosts[1] = NULL;\n\n  vpx_free(cpi->nmvcosts_hp[0]);\n  vpx_free(cpi->nmvcosts_hp[1]);\n  cpi->nmvcosts_hp[0] = NULL;\n  cpi->nmvcosts_hp[1] = NULL;\n\n  vpx_free(cpi->nmvsadcosts[0]);\n  vpx_free(cpi->nmvsadcosts[1]);\n  cpi->nmvsadcosts[0] = NULL;\n  cpi->nmvsadcosts[1] = NULL;\n\n  vpx_free(cpi->nmvsadcosts_hp[0]);\n  vpx_free(cpi->nmvsadcosts_hp[1]);\n  cpi->nmvsadcosts_hp[0] = NULL;\n  cpi->nmvsadcosts_hp[1] = NULL;\n\n  vpx_free(cpi->skin_map);\n  cpi->skin_map = NULL;\n\n  vpx_free(cpi->prev_partition);\n  cpi->prev_partition = NULL;\n\n  vpx_free(cpi->svc.prev_partition_svc);\n  cpi->svc.prev_partition_svc = NULL;\n\n  vpx_free(cpi->prev_segment_id);\n  cpi->prev_segment_id = NULL;\n\n  vpx_free(cpi->prev_variance_low);\n  cpi->prev_variance_low = NULL;\n\n  vpx_free(cpi->copied_frame_cnt);\n  cpi->copied_frame_cnt = NULL;\n\n  vpx_free(cpi->content_state_sb_fd);\n  cpi->content_state_sb_fd = NULL;\n\n  vpx_free(cpi->count_arf_frame_usage);\n  cpi->count_arf_frame_usage = NULL;\n  vpx_free(cpi->count_lastgolden_frame_usage);\n  cpi->count_lastgolden_frame_usage = NULL;\n\n  vp9_cyclic_refresh_free(cpi->cyclic_refresh);\n  cpi->cyclic_refresh = NULL;\n\n  vpx_free(cpi->active_map.map);\n  cpi->active_map.map = NULL;\n\n  vpx_free(cpi->roi.roi_map);\n  cpi->roi.roi_map = NULL;\n\n  vpx_free(cpi->consec_zero_mv);\n  cpi->consec_zero_mv = NULL;\n\n  vpx_free(cpi->mb_wiener_variance);\n  cpi->mb_wiener_variance = NULL;\n\n  vpx_free(cpi->mi_ssim_rdmult_scaling_factors);\n  cpi->mi_ssim_rdmult_scaling_factors = NULL;\n\n#if CONFIG_RATE_CTRL\n  if (cpi->oxcf.use_simple_encode_api) {\n    free_partition_info(cpi);\n    free_motion_vector_info(cpi);\n    free_fp_motion_vector_info(cpi);\n    free_tpl_stats_info(cpi);\n  }\n#endif\n\n  vp9_free_ref_frame_buffers(cm->buffer_pool);\n#if CONFIG_VP9_POSTPROC\n  vp9_free_postproc_buffers(cm);\n#endif\n  vp9_free_context_buffers(cm);\n\n  vpx_free_frame_buffer(&cpi->last_frame_uf);\n  vpx_free_frame_buffer(&cpi->scaled_source);\n  vpx_free_frame_buffer(&cpi->scaled_last_source);\n  vpx_free_frame_buffer(&cpi->alt_ref_buffer);\n#ifdef ENABLE_KF_DENOISE\n  vpx_free_frame_buffer(&cpi->raw_unscaled_source);\n  vpx_free_frame_buffer(&cpi->raw_scaled_source);\n#endif\n\n  vp9_lookahead_destroy(cpi->lookahead);\n\n  vpx_free(cpi->tile_tok[0][0]);\n  cpi->tile_tok[0][0] = 0;\n\n  vpx_free(cpi->tplist[0][0]);\n  cpi->tplist[0][0] = NULL;\n\n  vp9_free_pc_tree(&cpi->td);\n\n  for (i = 0; i < cpi->svc.number_spatial_layers; ++i) {\n    LAYER_CONTEXT *const lc = &cpi->svc.layer_context[i];\n    vpx_free(lc->rc_twopass_stats_in.buf);\n    lc->rc_twopass_stats_in.buf = NULL;\n    lc->rc_twopass_stats_in.sz = 0;\n  }\n\n  if (cpi->source_diff_var != NULL) {\n    vpx_free(cpi->source_diff_var);\n    cpi->source_diff_var = NULL;\n  }\n\n  for (i = 0; i < MAX_LAG_BUFFERS; ++i) {\n    vpx_free_frame_buffer(&cpi->svc.scaled_frames[i]);\n  }\n  memset(&cpi->svc.scaled_frames[0], 0,\n         MAX_LAG_BUFFERS * sizeof(cpi->svc.scaled_frames[0]));\n\n  vpx_free_frame_buffer(&cpi->svc.scaled_temp);\n  memset(&cpi->svc.scaled_temp, 0, sizeof(cpi->svc.scaled_temp));\n\n  vpx_free_frame_buffer(&cpi->svc.empty_frame.img);\n  memset(&cpi->svc.empty_frame, 0, sizeof(cpi->svc.empty_frame));\n\n  vp9_free_svc_cyclic_refresh(cpi);\n}\n\nstatic void save_coding_context(VP9_COMP *cpi) {\n  CODING_CONTEXT *const cc = &cpi->coding_context;\n  VP9_COMMON *cm = &cpi->common;\n\n  // Stores a snapshot of key state variables which can subsequently be\n  // restored with a call to vp9_restore_coding_context. These functions are\n  // intended for use in a re-code loop in vp9_compress_frame where the\n  // quantizer value is adjusted between loop iterations.\n  vp9_copy(cc->nmvjointcost, cpi->td.mb.nmvjointcost);\n\n  memcpy(cc->nmvcosts[0], cpi->nmvcosts[0],\n         MV_VALS * sizeof(*cpi->nmvcosts[0]));\n  memcpy(cc->nmvcosts[1], cpi->nmvcosts[1],\n         MV_VALS * sizeof(*cpi->nmvcosts[1]));\n  memcpy(cc->nmvcosts_hp[0], cpi->nmvcosts_hp[0],\n         MV_VALS * sizeof(*cpi->nmvcosts_hp[0]));\n  memcpy(cc->nmvcosts_hp[1], cpi->nmvcosts_hp[1],\n         MV_VALS * sizeof(*cpi->nmvcosts_hp[1]));\n\n  vp9_copy(cc->segment_pred_probs, cm->seg.pred_probs);\n\n  memcpy(cpi->coding_context.last_frame_seg_map_copy, cm->last_frame_seg_map,\n         (cm->mi_rows * cm->mi_cols));\n\n  vp9_copy(cc->last_ref_lf_deltas, cm->lf.last_ref_deltas);\n  vp9_copy(cc->last_mode_lf_deltas, cm->lf.last_mode_deltas);\n\n  cc->fc = *cm->fc;\n}\n\nstatic void restore_coding_context(VP9_COMP *cpi) {\n  CODING_CONTEXT *const cc = &cpi->coding_context;\n  VP9_COMMON *cm = &cpi->common;\n\n  // Restore key state variables to the snapshot state stored in the\n  // previous call to vp9_save_coding_context.\n  vp9_copy(cpi->td.mb.nmvjointcost, cc->nmvjointcost);\n\n  memcpy(cpi->nmvcosts[0], cc->nmvcosts[0], MV_VALS * sizeof(*cc->nmvcosts[0]));\n  memcpy(cpi->nmvcosts[1], cc->nmvcosts[1], MV_VALS * sizeof(*cc->nmvcosts[1]));\n  memcpy(cpi->nmvcosts_hp[0], cc->nmvcosts_hp[0],\n         MV_VALS * sizeof(*cc->nmvcosts_hp[0]));\n  memcpy(cpi->nmvcosts_hp[1], cc->nmvcosts_hp[1],\n         MV_VALS * sizeof(*cc->nmvcosts_hp[1]));\n\n  vp9_copy(cm->seg.pred_probs, cc->segment_pred_probs);\n\n  memcpy(cm->last_frame_seg_map, cpi->coding_context.last_frame_seg_map_copy,\n         (cm->mi_rows * cm->mi_cols));\n\n  vp9_copy(cm->lf.last_ref_deltas, cc->last_ref_lf_deltas);\n  vp9_copy(cm->lf.last_mode_deltas, cc->last_mode_lf_deltas);\n\n  *cm->fc = cc->fc;\n}\n\n#if !CONFIG_REALTIME_ONLY\nstatic void configure_static_seg_features(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  const RATE_CONTROL *const rc = &cpi->rc;\n  struct segmentation *const seg = &cm->seg;\n\n  int high_q = (int)(rc->avg_q > 48.0);\n  int qi_delta;\n\n  // Disable and clear down for KF\n  if (cm->frame_type == KEY_FRAME) {\n    // Clear down the global segmentation map\n    memset(cpi->segmentation_map, 0, cm->mi_rows * cm->mi_cols);\n    seg->update_map = 0;\n    seg->update_data = 0;\n    cpi->static_mb_pct = 0;\n\n    // Disable segmentation\n    vp9_disable_segmentation(seg);\n\n    // Clear down the segment features.\n    vp9_clearall_segfeatures(seg);\n  } else if (cpi->refresh_alt_ref_frame) {\n    // If this is an alt ref frame\n    // Clear down the global segmentation map\n    memset(cpi->segmentation_map, 0, cm->mi_rows * cm->mi_cols);\n    seg->update_map = 0;\n    seg->update_data = 0;\n    cpi->static_mb_pct = 0;\n\n    // Disable segmentation and individual segment features by default\n    vp9_disable_segmentation(seg);\n    vp9_clearall_segfeatures(seg);\n\n    // Scan frames from current to arf frame.\n    // This function re-enables segmentation if appropriate.\n    vp9_update_mbgraph_stats(cpi);\n\n    // If segmentation was enabled set those features needed for the\n    // arf itself.\n    if (seg->enabled) {\n      seg->update_map = 1;\n      seg->update_data = 1;\n\n      qi_delta =\n          vp9_compute_qdelta(rc, rc->avg_q, rc->avg_q * 0.875, cm->bit_depth);\n      vp9_set_segdata(seg, 1, SEG_LVL_ALT_Q, qi_delta - 2);\n      vp9_set_segdata(seg, 1, SEG_LVL_ALT_LF, -2);\n\n      vp9_enable_segfeature(seg, 1, SEG_LVL_ALT_Q);\n      vp9_enable_segfeature(seg, 1, SEG_LVL_ALT_LF);\n\n      // Where relevant assume segment data is delta data\n      seg->abs_delta = SEGMENT_DELTADATA;\n    }\n  } else if (seg->enabled) {\n    // All other frames if segmentation has been enabled\n\n    // First normal frame in a valid gf or alt ref group\n    if (rc->frames_since_golden == 0) {\n      // Set up segment features for normal frames in an arf group\n      if (rc->source_alt_ref_active) {\n        seg->update_map = 0;\n        seg->update_data = 1;\n        seg->abs_delta = SEGMENT_DELTADATA;\n\n        qi_delta =\n            vp9_compute_qdelta(rc, rc->avg_q, rc->avg_q * 1.125, cm->bit_depth);\n        vp9_set_segdata(seg, 1, SEG_LVL_ALT_Q, qi_delta + 2);\n        vp9_enable_segfeature(seg, 1, SEG_LVL_ALT_Q);\n\n        vp9_set_segdata(seg, 1, SEG_LVL_ALT_LF, -2);\n        vp9_enable_segfeature(seg, 1, SEG_LVL_ALT_LF);\n\n        // Segment coding disabled for compred testing\n        if (high_q || (cpi->static_mb_pct == 100)) {\n          vp9_set_segdata(seg, 1, SEG_LVL_REF_FRAME, ALTREF_FRAME);\n          vp9_enable_segfeature(seg, 1, SEG_LVL_REF_FRAME);\n          vp9_enable_segfeature(seg, 1, SEG_LVL_SKIP);\n        }\n      } else {\n        // Disable segmentation and clear down features if alt ref\n        // is not active for this group\n\n        vp9_disable_segmentation(seg);\n\n        memset(cpi->segmentation_map, 0, cm->mi_rows * cm->mi_cols);\n\n        seg->update_map = 0;\n        seg->update_data = 0;\n\n        vp9_clearall_segfeatures(seg);\n      }\n    } else if (rc->is_src_frame_alt_ref) {\n      // Special case where we are coding over the top of a previous\n      // alt ref frame.\n      // Segment coding disabled for compred testing\n\n      // Enable ref frame features for segment 0 as well\n      vp9_enable_segfeature(seg, 0, SEG_LVL_REF_FRAME);\n      vp9_enable_segfeature(seg, 1, SEG_LVL_REF_FRAME);\n\n      // All mbs should use ALTREF_FRAME\n      vp9_clear_segdata(seg, 0, SEG_LVL_REF_FRAME);\n      vp9_set_segdata(seg, 0, SEG_LVL_REF_FRAME, ALTREF_FRAME);\n      vp9_clear_segdata(seg, 1, SEG_LVL_REF_FRAME);\n      vp9_set_segdata(seg, 1, SEG_LVL_REF_FRAME, ALTREF_FRAME);\n\n      // Skip all MBs if high Q (0,0 mv and skip coeffs)\n      if (high_q) {\n        vp9_enable_segfeature(seg, 0, SEG_LVL_SKIP);\n        vp9_enable_segfeature(seg, 1, SEG_LVL_SKIP);\n      }\n      // Enable data update\n      seg->update_data = 1;\n    } else {\n      // All other frames.\n\n      // No updates.. leave things as they are.\n      seg->update_map = 0;\n      seg->update_data = 0;\n    }\n  }\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void update_reference_segmentation_map(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  MODE_INFO **mi_8x8_ptr = cm->mi_grid_visible;\n  uint8_t *cache_ptr = cm->last_frame_seg_map;\n  int row, col;\n\n  for (row = 0; row < cm->mi_rows; row++) {\n    MODE_INFO **mi_8x8 = mi_8x8_ptr;\n    uint8_t *cache = cache_ptr;\n    for (col = 0; col < cm->mi_cols; col++, mi_8x8++, cache++)\n      cache[0] = mi_8x8[0]->segment_id;\n    mi_8x8_ptr += cm->mi_stride;\n    cache_ptr += cm->mi_cols;\n  }\n}\n\nstatic void alloc_raw_frame_buffers(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  const VP9EncoderConfig *oxcf = &cpi->oxcf;\n\n  if (!cpi->lookahead)\n    cpi->lookahead = vp9_lookahead_init(oxcf->width, oxcf->height,\n                                        cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                                        cm->use_highbitdepth,\n#endif\n                                        oxcf->lag_in_frames);\n  if (!cpi->lookahead)\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate lag buffers\");\n\n  // TODO(agrange) Check if ARF is enabled and skip allocation if not.\n  if (vpx_realloc_frame_buffer(&cpi->alt_ref_buffer, oxcf->width, oxcf->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate altref buffer\");\n}\n\nstatic void alloc_util_frame_buffers(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  if (vpx_realloc_frame_buffer(&cpi->last_frame_uf, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate last frame buffer\");\n\n  if (vpx_realloc_frame_buffer(&cpi->scaled_source, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate scaled source buffer\");\n\n  // For 1 pass cbr: allocate scaled_frame that may be used as an intermediate\n  // buffer for a 2 stage down-sampling: two stages of 1:2 down-sampling for a\n  // target of 1/4x1/4. number_spatial_layers must be greater than 2.\n  if (is_one_pass_svc(cpi) && !cpi->svc.scaled_temp_is_alloc &&\n      cpi->svc.number_spatial_layers > 2) {\n    cpi->svc.scaled_temp_is_alloc = 1;\n    if (vpx_realloc_frame_buffer(\n            &cpi->svc.scaled_temp, cm->width >> 1, cm->height >> 1,\n            cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n            cm->use_highbitdepth,\n#endif\n            VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment, NULL, NULL, NULL))\n      vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                         \"Failed to allocate scaled_frame for svc \");\n  }\n\n  if (vpx_realloc_frame_buffer(&cpi->scaled_last_source, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate scaled last source buffer\");\n#ifdef ENABLE_KF_DENOISE\n  if (vpx_realloc_frame_buffer(&cpi->raw_unscaled_source, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate unscaled raw source frame buffer\");\n\n  if (vpx_realloc_frame_buffer(&cpi->raw_scaled_source, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate scaled raw source frame buffer\");\n#endif\n}\n\nstatic void alloc_context_buffers_ext(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  int mi_size = cm->mi_cols * cm->mi_rows;\n\n  CHECK_MEM_ERROR(&cm->error, cpi->mbmi_ext_base,\n                  vpx_calloc(mi_size, sizeof(*cpi->mbmi_ext_base)));\n}\n\nstatic void alloc_compressor_data(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  int sb_rows;\n\n  if (vp9_alloc_context_buffers(cm, cm->width, cm->height)) {\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate context buffers\");\n  }\n\n  alloc_context_buffers_ext(cpi);\n\n  vpx_free(cpi->tile_tok[0][0]);\n\n  {\n    unsigned int tokens = get_token_alloc(cm->mb_rows, cm->mb_cols);\n    CHECK_MEM_ERROR(&cm->error, cpi->tile_tok[0][0],\n                    vpx_calloc(tokens, sizeof(*cpi->tile_tok[0][0])));\n  }\n\n  sb_rows = mi_cols_aligned_to_sb(cm->mi_rows) >> MI_BLOCK_SIZE_LOG2;\n  vpx_free(cpi->tplist[0][0]);\n  CHECK_MEM_ERROR(\n      &cm->error, cpi->tplist[0][0],\n      vpx_calloc(sb_rows * 4 * (1 << 6), sizeof(*cpi->tplist[0][0])));\n\n  vp9_setup_pc_tree(&cpi->common, &cpi->td);\n}\n\nvoid vp9_new_framerate(VP9_COMP *cpi, double framerate) {\n  cpi->framerate = framerate < 0.1 ? 30 : framerate;\n  vp9_rc_update_framerate(cpi);\n}\n\nstatic void set_tile_limits(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n\n  int min_log2_tile_cols, max_log2_tile_cols;\n  vp9_get_tile_n_bits(cm->mi_cols, &min_log2_tile_cols, &max_log2_tile_cols);\n\n  cm->log2_tile_cols =\n      clamp(cpi->oxcf.tile_columns, min_log2_tile_cols, max_log2_tile_cols);\n  cm->log2_tile_rows = cpi->oxcf.tile_rows;\n\n  if (cpi->oxcf.target_level == LEVEL_AUTO) {\n    const int level_tile_cols =\n        log_tile_cols_from_picsize_level(cpi->common.width, cpi->common.height);\n    if (cm->log2_tile_cols > level_tile_cols) {\n      cm->log2_tile_cols = VPXMAX(level_tile_cols, min_log2_tile_cols);\n    }\n  }\n}\n\nstatic void update_frame_size(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  MACROBLOCKD *const xd = &cpi->td.mb.e_mbd;\n\n  vp9_set_mb_mi(cm, cm->width, cm->height);\n  vp9_init_context_buffers(cm);\n  vp9_init_macroblockd(cm, xd, NULL);\n  cpi->td.mb.mbmi_ext_base = cpi->mbmi_ext_base;\n  memset(cpi->mbmi_ext_base, 0,\n         cm->mi_rows * cm->mi_cols * sizeof(*cpi->mbmi_ext_base));\n\n  set_tile_limits(cpi);\n}\n\nstatic void init_buffer_indices(VP9_COMP *cpi) {\n  int ref_frame;\n\n  for (ref_frame = 0; ref_frame < REF_FRAMES; ++ref_frame)\n    cpi->ref_fb_idx[ref_frame] = ref_frame;\n\n  cpi->lst_fb_idx = cpi->ref_fb_idx[LAST_FRAME - 1];\n  cpi->gld_fb_idx = cpi->ref_fb_idx[GOLDEN_FRAME - 1];\n  cpi->alt_fb_idx = cpi->ref_fb_idx[ALTREF_FRAME - 1];\n}\n\nstatic void init_level_constraint(LevelConstraint *lc) {\n  lc->level_index = -1;\n  lc->max_cpb_size = INT_MAX;\n  lc->max_frame_size = INT_MAX;\n  lc->fail_flag = 0;\n}\n\nstatic void set_level_constraint(LevelConstraint *ls, int8_t level_index) {\n  vpx_clear_system_state();\n  ls->level_index = level_index;\n  if (level_index >= 0) {\n    ls->max_cpb_size = vp9_level_defs[level_index].max_cpb_size * (double)1000;\n  }\n}\n\nstatic void init_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n\n  cpi->oxcf = *oxcf;\n  cpi->framerate = oxcf->init_framerate;\n  cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cm->use_highbitdepth = oxcf->use_highbitdepth;\n#endif\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  cm->width = oxcf->width;\n  cm->height = oxcf->height;\n  alloc_compressor_data(cpi);\n\n  cpi->svc.temporal_layering_mode = oxcf->temporal_layering_mode;\n\n  // Single thread case: use counts in common.\n  cpi->td.counts = &cm->counts;\n\n  // Spatial scalability.\n  cpi->svc.number_spatial_layers = oxcf->ss_number_layers;\n  // Temporal scalability.\n  cpi->svc.number_temporal_layers = oxcf->ts_number_layers;\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_init_layer_context(cpi);\n  }\n\n  // change includes all joint functionality\n  vp9_change_config(cpi, oxcf);\n\n  cpi->static_mb_pct = 0;\n  cpi->ref_frame_flags = 0;\n\n  init_buffer_indices(cpi);\n\n  vp9_noise_estimate_init(&cpi->noise_estimate, cm->width, cm->height);\n  cpi->fixed_qp_onepass = 0;\n}\n\nvoid vp9_check_reset_rc_flag(VP9_COMP *cpi) {\n  RATE_CONTROL *rc = &cpi->rc;\n\n  if (cpi->common.current_video_frame >\n      (unsigned int)cpi->svc.number_spatial_layers) {\n    if (cpi->use_svc) {\n      vp9_svc_check_reset_layer_rc_flag(cpi);\n    } else {\n      if (rc->avg_frame_bandwidth > (3 * rc->last_avg_frame_bandwidth >> 1) ||\n          rc->avg_frame_bandwidth < (rc->last_avg_frame_bandwidth >> 1)) {\n        rc->rc_1_frame = 0;\n        rc->rc_2_frame = 0;\n        rc->bits_off_target = rc->optimal_buffer_level;\n        rc->buffer_level = rc->optimal_buffer_level;\n      }\n    }\n  }\n}\n\nvoid vp9_set_rc_buffer_sizes(VP9_COMP *cpi) {\n  RATE_CONTROL *rc = &cpi->rc;\n  const VP9EncoderConfig *oxcf = &cpi->oxcf;\n\n  const int64_t bandwidth = oxcf->target_bandwidth;\n  const int64_t starting = oxcf->starting_buffer_level_ms;\n  const int64_t optimal = oxcf->optimal_buffer_level_ms;\n  const int64_t maximum = oxcf->maximum_buffer_size_ms;\n\n  rc->starting_buffer_level = starting * bandwidth / 1000;\n  rc->optimal_buffer_level =\n      (optimal == 0) ? bandwidth / 8 : optimal * bandwidth / 1000;\n  rc->maximum_buffer_size =\n      (maximum == 0) ? bandwidth / 8 : maximum * bandwidth / 1000;\n\n  // Under a configuration change, where maximum_buffer_size may change,\n  // keep buffer level clipped to the maximum allowed buffer size.\n  rc->bits_off_target = VPXMIN(rc->bits_off_target, rc->maximum_buffer_size);\n  rc->buffer_level = VPXMIN(rc->buffer_level, rc->maximum_buffer_size);\n}\n\n#if CONFIG_VP9_HIGHBITDEPTH\n#define HIGHBD_BFP(BT, SDF, SDSF, SDAF, VF, SVF, SVAF, SDX4DF, SDSX4DF) \\\n  cpi->fn_ptr[BT].sdf = SDF;                                            \\\n  cpi->fn_ptr[BT].sdsf = SDSF;                                          \\\n  cpi->fn_ptr[BT].sdaf = SDAF;                                          \\\n  cpi->fn_ptr[BT].vf = VF;                                              \\\n  cpi->fn_ptr[BT].svf = SVF;                                            \\\n  cpi->fn_ptr[BT].svaf = SVAF;                                          \\\n  cpi->fn_ptr[BT].sdx4df = SDX4DF;                                      \\\n  cpi->fn_ptr[BT].sdsx4df = SDSX4DF;\n\n#define MAKE_BFP_SAD_WRAPPER(fnname)                                           \\\n  static unsigned int fnname##_bits8(const uint8_t *src_ptr,                   \\\n                                     int source_stride,                        \\\n                                     const uint8_t *ref_ptr, int ref_stride) { \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride);                \\\n  }                                                                            \\\n  static unsigned int fnname##_bits10(                                         \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride) {                                                        \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride) >> 2;           \\\n  }                                                                            \\\n  static unsigned int fnname##_bits12(                                         \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride) {                                                        \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride) >> 4;           \\\n  }\n\n#define MAKE_BFP_SADAVG_WRAPPER(fnname)                                        \\\n  static unsigned int fnname##_bits8(                                          \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride, const uint8_t *second_pred) {                            \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride, second_pred);   \\\n  }                                                                            \\\n  static unsigned int fnname##_bits10(                                         \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride, const uint8_t *second_pred) {                            \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride, second_pred) >> \\\n           2;                                                                  \\\n  }                                                                            \\\n  static unsigned int fnname##_bits12(                                         \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride, const uint8_t *second_pred) {                            \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride, second_pred) >> \\\n           4;                                                                  \\\n  }\n\n#define MAKE_BFP_SAD4D_WRAPPER(fnname)                                        \\\n  static void fnname##_bits8(const uint8_t *src_ptr, int source_stride,       \\\n                             const uint8_t *const ref_ptr[], int ref_stride,  \\\n                             unsigned int *sad_array) {                       \\\n    fnname(src_ptr, source_stride, ref_ptr, ref_stride, sad_array);           \\\n  }                                                                           \\\n  static void fnname##_bits10(const uint8_t *src_ptr, int source_stride,      \\\n                              const uint8_t *const ref_ptr[], int ref_stride, \\\n                              unsigned int *sad_array) {                      \\\n    int i;                                                                    \\\n    fnname(src_ptr, source_stride, ref_ptr, ref_stride, sad_array);           \\\n    for (i = 0; i < 4; i++) sad_array[i] >>= 2;                               \\\n  }                                                                           \\\n  static void fnname##_bits12(const uint8_t *src_ptr, int source_stride,      \\\n                              const uint8_t *const ref_ptr[], int ref_stride, \\\n                              unsigned int *sad_array) {                      \\\n    int i;                                                                    \\\n    fnname(src_ptr, source_stride, ref_ptr, ref_stride, sad_array);           \\\n    for (i = 0; i < 4; i++) sad_array[i] >>= 4;                               \\\n  }\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad32x16)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_32x16)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad32x16_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad32x16x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_32x16x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad16x32)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_16x32)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad16x32_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad16x32x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_16x32x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad64x32)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_64x32)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad64x32_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad64x32x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_64x32x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad32x64)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_32x64)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad32x64_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad32x64x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_32x64x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad32x32)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_32x32)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad32x32_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad32x32x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_32x32x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad64x64)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_64x64)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad64x64_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad64x64x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_64x64x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad16x16)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_16x16)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad16x16_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad16x16x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_16x16x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad16x8)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_16x8)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad16x8_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad16x8x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_16x8x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad8x16)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_8x16)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad8x16_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad8x16x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_8x16x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad8x8)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_8x8)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad8x8_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad8x8x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_8x8x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad8x4)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_8x4)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad8x4_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad8x4x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_8x4x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad4x8)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_4x8)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad4x8_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad4x8x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_4x8x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad4x4)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_4x4)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad4x4_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad4x4x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_4x4x4d)\n\nstatic void highbd_set_var_fns(VP9_COMP *const cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  if (cm->use_highbitdepth) {\n    switch (cm->bit_depth) {\n      case VPX_BITS_8:\n        HIGHBD_BFP(\n            BLOCK_32X16, vpx_highbd_sad32x16_bits8,\n            vpx_highbd_sad_skip_32x16_bits8, vpx_highbd_sad32x16_avg_bits8,\n            vpx_highbd_8_variance32x16, vpx_highbd_8_sub_pixel_variance32x16,\n            vpx_highbd_8_sub_pixel_avg_variance32x16,\n            vpx_highbd_sad32x16x4d_bits8, vpx_highbd_sad_skip_32x16x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_16X32, vpx_highbd_sad16x32_bits8,\n            vpx_highbd_sad_skip_16x32_bits8, vpx_highbd_sad16x32_avg_bits8,\n            vpx_highbd_8_variance16x32, vpx_highbd_8_sub_pixel_variance16x32,\n            vpx_highbd_8_sub_pixel_avg_variance16x32,\n            vpx_highbd_sad16x32x4d_bits8, vpx_highbd_sad_skip_16x32x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_64X32, vpx_highbd_sad64x32_bits8,\n            vpx_highbd_sad_skip_64x32_bits8, vpx_highbd_sad64x32_avg_bits8,\n            vpx_highbd_8_variance64x32, vpx_highbd_8_sub_pixel_variance64x32,\n            vpx_highbd_8_sub_pixel_avg_variance64x32,\n            vpx_highbd_sad64x32x4d_bits8, vpx_highbd_sad_skip_64x32x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_32X64, vpx_highbd_sad32x64_bits8,\n            vpx_highbd_sad_skip_32x64_bits8, vpx_highbd_sad32x64_avg_bits8,\n            vpx_highbd_8_variance32x64, vpx_highbd_8_sub_pixel_variance32x64,\n            vpx_highbd_8_sub_pixel_avg_variance32x64,\n            vpx_highbd_sad32x64x4d_bits8, vpx_highbd_sad_skip_32x64x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_32X32, vpx_highbd_sad32x32_bits8,\n            vpx_highbd_sad_skip_32x32_bits8, vpx_highbd_sad32x32_avg_bits8,\n            vpx_highbd_8_variance32x32, vpx_highbd_8_sub_pixel_variance32x32,\n            vpx_highbd_8_sub_pixel_avg_variance32x32,\n            vpx_highbd_sad32x32x4d_bits8, vpx_highbd_sad_skip_32x32x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_64X64, vpx_highbd_sad64x64_bits8,\n            vpx_highbd_sad_skip_64x64_bits8, vpx_highbd_sad64x64_avg_bits8,\n            vpx_highbd_8_variance64x64, vpx_highbd_8_sub_pixel_variance64x64,\n            vpx_highbd_8_sub_pixel_avg_variance64x64,\n            vpx_highbd_sad64x64x4d_bits8, vpx_highbd_sad_skip_64x64x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_16X16, vpx_highbd_sad16x16_bits8,\n            vpx_highbd_sad_skip_16x16_bits8, vpx_highbd_sad16x16_avg_bits8,\n            vpx_highbd_8_variance16x16, vpx_highbd_8_sub_pixel_variance16x16,\n            vpx_highbd_8_sub_pixel_avg_variance16x16,\n            vpx_highbd_sad16x16x4d_bits8, vpx_highbd_sad_skip_16x16x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_16X8, vpx_highbd_sad16x8_bits8,\n            vpx_highbd_sad_skip_16x8_bits8, vpx_highbd_sad16x8_avg_bits8,\n            vpx_highbd_8_variance16x8, vpx_highbd_8_sub_pixel_variance16x8,\n            vpx_highbd_8_sub_pixel_avg_variance16x8,\n            vpx_highbd_sad16x8x4d_bits8, vpx_highbd_sad_skip_16x8x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_8X16, vpx_highbd_sad8x16_bits8,\n            vpx_highbd_sad_skip_8x16_bits8, vpx_highbd_sad8x16_avg_bits8,\n            vpx_highbd_8_variance8x16, vpx_highbd_8_sub_pixel_variance8x16,\n            vpx_highbd_8_sub_pixel_avg_variance8x16,\n            vpx_highbd_sad8x16x4d_bits8, vpx_highbd_sad_skip_8x16x4d_bits8)\n\n        HIGHBD_BFP(BLOCK_8X8, vpx_highbd_sad8x8_bits8,\n                   vpx_highbd_sad_skip_8x8_bits8, vpx_highbd_sad8x8_avg_bits8,\n                   vpx_highbd_8_variance8x8, vpx_highbd_8_sub_pixel_variance8x8,\n                   vpx_highbd_8_sub_pixel_avg_variance8x8,\n                   vpx_highbd_sad8x8x4d_bits8, vpx_highbd_sad_skip_8x8x4d_bits8)\n\n        HIGHBD_BFP(BLOCK_8X4, vpx_highbd_sad8x4_bits8,\n                   vpx_highbd_sad_skip_8x4_bits8, vpx_highbd_sad8x4_avg_bits8,\n                   vpx_highbd_8_variance8x4, vpx_highbd_8_sub_pixel_variance8x4,\n                   vpx_highbd_8_sub_pixel_avg_variance8x4,\n                   vpx_highbd_sad8x4x4d_bits8, vpx_highbd_sad_skip_8x4x4d_bits8)\n\n        HIGHBD_BFP(BLOCK_4X8, vpx_highbd_sad4x8_bits8,\n                   vpx_highbd_sad_skip_4x8_bits8, vpx_highbd_sad4x8_avg_bits8,\n                   vpx_highbd_8_variance4x8, vpx_highbd_8_sub_pixel_variance4x8,\n                   vpx_highbd_8_sub_pixel_avg_variance4x8,\n                   vpx_highbd_sad4x8x4d_bits8, vpx_highbd_sad_skip_4x8x4d_bits8)\n\n        HIGHBD_BFP(BLOCK_4X4, vpx_highbd_sad4x4_bits8,\n                   vpx_highbd_sad_skip_4x4_bits8, vpx_highbd_sad4x4_avg_bits8,\n                   vpx_highbd_8_variance4x4, vpx_highbd_8_sub_pixel_variance4x4,\n                   vpx_highbd_8_sub_pixel_avg_variance4x4,\n                   vpx_highbd_sad4x4x4d_bits8, vpx_highbd_sad_skip_4x4x4d_bits8)\n        break;\n\n      case VPX_BITS_10:\n        HIGHBD_BFP(\n            BLOCK_32X16, vpx_highbd_sad32x16_bits10,\n            vpx_highbd_sad_skip_32x16_bits10, vpx_highbd_sad32x16_avg_bits10,\n            vpx_highbd_10_variance32x16, vpx_highbd_10_sub_pixel_variance32x16,\n            vpx_highbd_10_sub_pixel_avg_variance32x16,\n            vpx_highbd_sad32x16x4d_bits10, vpx_highbd_sad_skip_32x16x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_16X32, vpx_highbd_sad16x32_bits10,\n            vpx_highbd_sad_skip_16x32_bits10, vpx_highbd_sad16x32_avg_bits10,\n            vpx_highbd_10_variance16x32, vpx_highbd_10_sub_pixel_variance16x32,\n            vpx_highbd_10_sub_pixel_avg_variance16x32,\n            vpx_highbd_sad16x32x4d_bits10, vpx_highbd_sad_skip_16x32x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_64X32, vpx_highbd_sad64x32_bits10,\n            vpx_highbd_sad_skip_64x32_bits10, vpx_highbd_sad64x32_avg_bits10,\n            vpx_highbd_10_variance64x32, vpx_highbd_10_sub_pixel_variance64x32,\n            vpx_highbd_10_sub_pixel_avg_variance64x32,\n            vpx_highbd_sad64x32x4d_bits10, vpx_highbd_sad_skip_64x32x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_32X64, vpx_highbd_sad32x64_bits10,\n            vpx_highbd_sad_skip_32x64_bits10, vpx_highbd_sad32x64_avg_bits10,\n            vpx_highbd_10_variance32x64, vpx_highbd_10_sub_pixel_variance32x64,\n            vpx_highbd_10_sub_pixel_avg_variance32x64,\n            vpx_highbd_sad32x64x4d_bits10, vpx_highbd_sad_skip_32x64x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_32X32, vpx_highbd_sad32x32_bits10,\n            vpx_highbd_sad_skip_32x32_bits10, vpx_highbd_sad32x32_avg_bits10,\n            vpx_highbd_10_variance32x32, vpx_highbd_10_sub_pixel_variance32x32,\n            vpx_highbd_10_sub_pixel_avg_variance32x32,\n            vpx_highbd_sad32x32x4d_bits10, vpx_highbd_sad_skip_32x32x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_64X64, vpx_highbd_sad64x64_bits10,\n            vpx_highbd_sad_skip_64x64_bits10, vpx_highbd_sad64x64_avg_bits10,\n            vpx_highbd_10_variance64x64, vpx_highbd_10_sub_pixel_variance64x64,\n            vpx_highbd_10_sub_pixel_avg_variance64x64,\n            vpx_highbd_sad64x64x4d_bits10, vpx_highbd_sad_skip_64x64x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_16X16, vpx_highbd_sad16x16_bits10,\n            vpx_highbd_sad_skip_16x16_bits10, vpx_highbd_sad16x16_avg_bits10,\n            vpx_highbd_10_variance16x16, vpx_highbd_10_sub_pixel_variance16x16,\n            vpx_highbd_10_sub_pixel_avg_variance16x16,\n            vpx_highbd_sad16x16x4d_bits10, vpx_highbd_sad_skip_16x16x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_16X8, vpx_highbd_sad16x8_bits10,\n            vpx_highbd_sad_skip_16x8_bits10, vpx_highbd_sad16x8_avg_bits10,\n            vpx_highbd_10_variance16x8, vpx_highbd_10_sub_pixel_variance16x8,\n            vpx_highbd_10_sub_pixel_avg_variance16x8,\n            vpx_highbd_sad16x8x4d_bits10, vpx_highbd_sad_skip_16x8x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_8X16, vpx_highbd_sad8x16_bits10,\n            vpx_highbd_sad_skip_8x16_bits10, vpx_highbd_sad8x16_avg_bits10,\n            vpx_highbd_10_variance8x16, vpx_highbd_10_sub_pixel_variance8x16,\n            vpx_highbd_10_sub_pixel_avg_variance8x16,\n            vpx_highbd_sad8x16x4d_bits10, vpx_highbd_sad_skip_8x16x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_8X8, vpx_highbd_sad8x8_bits10, vpx_highbd_sad_skip_8x8_bits10,\n            vpx_highbd_sad8x8_avg_bits10, vpx_highbd_10_variance8x8,\n            vpx_highbd_10_sub_pixel_variance8x8,\n            vpx_highbd_10_sub_pixel_avg_variance8x8,\n            vpx_highbd_sad8x8x4d_bits10, vpx_highbd_sad_skip_8x8x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_8X4, vpx_highbd_sad8x4_bits10, vpx_highbd_sad_skip_8x4_bits10,\n            vpx_highbd_sad8x4_avg_bits10, vpx_highbd_10_variance8x4,\n            vpx_highbd_10_sub_pixel_variance8x4,\n            vpx_highbd_10_sub_pixel_avg_variance8x4,\n            vpx_highbd_sad8x4x4d_bits10, vpx_highbd_sad_skip_8x4x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_4X8, vpx_highbd_sad4x8_bits10, vpx_highbd_sad_skip_4x8_bits10,\n            vpx_highbd_sad4x8_avg_bits10, vpx_highbd_10_variance4x8,\n            vpx_highbd_10_sub_pixel_variance4x8,\n            vpx_highbd_10_sub_pixel_avg_variance4x8,\n            vpx_highbd_sad4x8x4d_bits10, vpx_highbd_sad_skip_4x8x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_4X4, vpx_highbd_sad4x4_bits10, vpx_highbd_sad_skip_4x4_bits10,\n            vpx_highbd_sad4x4_avg_bits10, vpx_highbd_10_variance4x4,\n            vpx_highbd_10_sub_pixel_variance4x4,\n            vpx_highbd_10_sub_pixel_avg_variance4x4,\n            vpx_highbd_sad4x4x4d_bits10, vpx_highbd_sad_skip_4x4x4d_bits10)\n        break;\n\n      default:\n        assert(cm->bit_depth == VPX_BITS_12);\n        HIGHBD_BFP(\n            BLOCK_32X16, vpx_highbd_sad32x16_bits12,\n            vpx_highbd_sad_skip_32x16_bits12, vpx_highbd_sad32x16_avg_bits12,\n            vpx_highbd_12_variance32x16, vpx_highbd_12_sub_pixel_variance32x16,\n            vpx_highbd_12_sub_pixel_avg_variance32x16,\n            vpx_highbd_sad32x16x4d_bits12, vpx_highbd_sad_skip_32x16x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_16X32, vpx_highbd_sad16x32_bits12,\n            vpx_highbd_sad_skip_16x32_bits12, vpx_highbd_sad16x32_avg_bits12,\n            vpx_highbd_12_variance16x32, vpx_highbd_12_sub_pixel_variance16x32,\n            vpx_highbd_12_sub_pixel_avg_variance16x32,\n            vpx_highbd_sad16x32x4d_bits12, vpx_highbd_sad_skip_16x32x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_64X32, vpx_highbd_sad64x32_bits12,\n            vpx_highbd_sad_skip_64x32_bits12, vpx_highbd_sad64x32_avg_bits12,\n            vpx_highbd_12_variance64x32, vpx_highbd_12_sub_pixel_variance64x32,\n            vpx_highbd_12_sub_pixel_avg_variance64x32,\n            vpx_highbd_sad64x32x4d_bits12, vpx_highbd_sad_skip_64x32x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_32X64, vpx_highbd_sad32x64_bits12,\n            vpx_highbd_sad_skip_32x64_bits12, vpx_highbd_sad32x64_avg_bits12,\n            vpx_highbd_12_variance32x64, vpx_highbd_12_sub_pixel_variance32x64,\n            vpx_highbd_12_sub_pixel_avg_variance32x64,\n            vpx_highbd_sad32x64x4d_bits12, vpx_highbd_sad_skip_32x64x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_32X32, vpx_highbd_sad32x32_bits12,\n            vpx_highbd_sad_skip_32x32_bits12, vpx_highbd_sad32x32_avg_bits12,\n            vpx_highbd_12_variance32x32, vpx_highbd_12_sub_pixel_variance32x32,\n            vpx_highbd_12_sub_pixel_avg_variance32x32,\n            vpx_highbd_sad32x32x4d_bits12, vpx_highbd_sad_skip_32x32x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_64X64, vpx_highbd_sad64x64_bits12,\n            vpx_highbd_sad_skip_64x64_bits12, vpx_highbd_sad64x64_avg_bits12,\n            vpx_highbd_12_variance64x64, vpx_highbd_12_sub_pixel_variance64x64,\n            vpx_highbd_12_sub_pixel_avg_variance64x64,\n            vpx_highbd_sad64x64x4d_bits12, vpx_highbd_sad_skip_64x64x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_16X16, vpx_highbd_sad16x16_bits12,\n            vpx_highbd_sad_skip_16x16_bits12, vpx_highbd_sad16x16_avg_bits12,\n            vpx_highbd_12_variance16x16, vpx_highbd_12_sub_pixel_variance16x16,\n            vpx_highbd_12_sub_pixel_avg_variance16x16,\n            vpx_highbd_sad16x16x4d_bits12, vpx_highbd_sad_skip_16x16x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_16X8, vpx_highbd_sad16x8_bits12,\n            vpx_highbd_sad_skip_16x8_bits12, vpx_highbd_sad16x8_avg_bits12,\n            vpx_highbd_12_variance16x8, vpx_highbd_12_sub_pixel_variance16x8,\n            vpx_highbd_12_sub_pixel_avg_variance16x8,\n            vpx_highbd_sad16x8x4d_bits12, vpx_highbd_sad_skip_16x8x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_8X16, vpx_highbd_sad8x16_bits12,\n            vpx_highbd_sad_skip_8x16_bits12, vpx_highbd_sad8x16_avg_bits12,\n            vpx_highbd_12_variance8x16, vpx_highbd_12_sub_pixel_variance8x16,\n            vpx_highbd_12_sub_pixel_avg_variance8x16,\n            vpx_highbd_sad8x16x4d_bits12, vpx_highbd_sad_skip_8x16x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_8X8, vpx_highbd_sad8x8_bits12, vpx_highbd_sad_skip_8x8_bits12,\n            vpx_highbd_sad8x8_avg_bits12, vpx_highbd_12_variance8x8,\n            vpx_highbd_12_sub_pixel_variance8x8,\n            vpx_highbd_12_sub_pixel_avg_variance8x8,\n            vpx_highbd_sad8x8x4d_bits12, vpx_highbd_sad_skip_8x8x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_8X4, vpx_highbd_sad8x4_bits12, vpx_highbd_sad_skip_8x4_bits12,\n            vpx_highbd_sad8x4_avg_bits12, vpx_highbd_12_variance8x4,\n            vpx_highbd_12_sub_pixel_variance8x4,\n            vpx_highbd_12_sub_pixel_avg_variance8x4,\n            vpx_highbd_sad8x4x4d_bits12, vpx_highbd_sad_skip_8x4x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_4X8, vpx_highbd_sad4x8_bits12, vpx_highbd_sad_skip_4x8_bits12,\n            vpx_highbd_sad4x8_avg_bits12, vpx_highbd_12_variance4x8,\n            vpx_highbd_12_sub_pixel_variance4x8,\n            vpx_highbd_12_sub_pixel_avg_variance4x8,\n            vpx_highbd_sad4x8x4d_bits12, vpx_highbd_sad_skip_4x8x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_4X4, vpx_highbd_sad4x4_bits12, vpx_highbd_sad_skip_4x4_bits12,\n            vpx_highbd_sad4x4_avg_bits12, vpx_highbd_12_variance4x4,\n            vpx_highbd_12_sub_pixel_variance4x4,\n            vpx_highbd_12_sub_pixel_avg_variance4x4,\n            vpx_highbd_sad4x4x4d_bits12, vpx_highbd_sad_skip_4x4x4d_bits12)\n        break;\n    }\n  }\n}\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\nstatic void realloc_segmentation_maps(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n\n  // Create the encoder segmentation map and set all entries to 0\n  vpx_free(cpi->segmentation_map);\n  CHECK_MEM_ERROR(&cm->error, cpi->segmentation_map,\n                  vpx_calloc(cm->mi_rows * cm->mi_cols, 1));\n\n  // Create a map used for cyclic background refresh.\n  if (cpi->cyclic_refresh) vp9_cyclic_refresh_free(cpi->cyclic_refresh);\n  CHECK_MEM_ERROR(&cm->error, cpi->cyclic_refresh,\n                  vp9_cyclic_refresh_alloc(cm->mi_rows, cm->mi_cols));\n\n  // Create a map used to mark inactive areas.\n  vpx_free(cpi->active_map.map);\n  CHECK_MEM_ERROR(&cm->error, cpi->active_map.map,\n                  vpx_calloc(cm->mi_rows * cm->mi_cols, 1));\n\n  // And a place holder structure is the coding context\n  // for use if we want to save and restore it\n  vpx_free(cpi->coding_context.last_frame_seg_map_copy);\n  CHECK_MEM_ERROR(&cm->error, cpi->coding_context.last_frame_seg_map_copy,\n                  vpx_calloc(cm->mi_rows * cm->mi_cols, 1));\n}\n\nstatic void alloc_copy_partition_data(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  if (cpi->prev_partition == NULL) {\n    CHECK_MEM_ERROR(&cm->error, cpi->prev_partition,\n                    (BLOCK_SIZE *)vpx_calloc(cm->mi_stride * cm->mi_rows,\n                                             sizeof(*cpi->prev_partition)));\n  }\n  if (cpi->prev_segment_id == NULL) {\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->prev_segment_id,\n        (int8_t *)vpx_calloc((cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1),\n                             sizeof(*cpi->prev_segment_id)));\n  }\n  if (cpi->prev_variance_low == NULL) {\n    CHECK_MEM_ERROR(&cm->error, cpi->prev_variance_low,\n                    (uint8_t *)vpx_calloc(\n                        (cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1) * 25,\n                        sizeof(*cpi->prev_variance_low)));\n  }\n  if (cpi->copied_frame_cnt == NULL) {\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->copied_frame_cnt,\n        (uint8_t *)vpx_calloc((cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1),\n                              sizeof(*cpi->copied_frame_cnt)));\n  }\n}\n\nvoid vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int last_w = cpi->oxcf.width;\n  int last_h = cpi->oxcf.height;\n\n  vp9_init_quantizer(cpi);\n  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  if (cm->profile <= PROFILE_1)\n    assert(cm->bit_depth == VPX_BITS_8);\n  else\n    assert(cm->bit_depth > VPX_BITS_8);\n\n  cpi->oxcf = *oxcf;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {\n    rc->baseline_gf_interval = FIXED_GF_INTERVAL;\n  } else {\n    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;\n  }\n\n  cpi->refresh_golden_frame = 0;\n  cpi->refresh_last_frame = 1;\n  cm->refresh_frame_context = 1;\n  cm->reset_frame_context = 0;\n\n  vp9_reset_segment_features(&cm->seg);\n  vp9_set_high_precision_mv(cpi, 0);\n\n  {\n    int i;\n\n    for (i = 0; i < MAX_SEGMENTS; i++)\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n  }\n  cpi->encode_breakout = cpi->oxcf.encode_breakout;\n\n  vp9_set_rc_buffer_sizes(cpi);\n\n  // Set up frame rate and related parameters rate control values.\n  vp9_new_framerate(cpi, cpi->framerate);\n\n  // Set absolute upper and lower quality limits\n  rc->worst_quality = cpi->oxcf.worst_allowed_q;\n  rc->best_quality = cpi->oxcf.best_allowed_q;\n\n  cm->interp_filter = cpi->sf.default_interp_filter;\n\n  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {\n    cm->render_width = cpi->oxcf.render_width;\n    cm->render_height = cpi->oxcf.render_height;\n  } else {\n    cm->render_width = cpi->oxcf.width;\n    cm->render_height = cpi->oxcf.height;\n  }\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    memset(cpi->consec_zero_mv, 0,\n           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_update_layer_context_change_config(cpi,\n                                           (int)cpi->oxcf.target_bandwidth);\n  }\n\n  vp9_check_reset_rc_flag(cpi);\n\n  cpi->alt_ref_source = NULL;\n  rc->is_src_frame_alt_ref = 0;\n\n#if 0\n  // Experimental RD Code\n  cpi->frame_distortion = 0;\n  cpi->last_frame_distortion = 0;\n#endif\n\n  set_tile_limits(cpi);\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n  cpi->ext_refresh_frame_context_pending = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  vp9_set_row_mt(cpi);\n}\n\n/***********************************************************************\n * Read before modifying 'cal_nmvjointsadcost' or 'cal_nmvsadcosts'    *\n ***********************************************************************\n * The following 2 functions ('cal_nmvjointsadcost' and                *\n * 'cal_nmvsadcosts') are used to calculate cost lookup tables         *\n * used by 'vp9_diamond_search_sad'. The C implementation of the       *\n * function is generic, but the NEON intrinsics optimised version      *\n * relies on the following properties of the computed tables:          *\n * For cal_nmvjointsadcost:                                            *\n *   - mvjointsadcost[1] == mvjointsadcost[2] == mvjointsadcost[3]     *\n * For cal_nmvsadcosts:                                                *\n *   - For all i: mvsadcost[0][i] == mvsadcost[1][i]                   *\n *         (Equal costs for both components)                           *\n *   - For all i: mvsadcost[0][i] == mvsadcost[0][-i]                  *\n *         (Cost function is even)                                     *\n * If these do not hold, then the NEON optimised version of the        *\n * 'vp9_diamond_search_sad' function cannot be used as it is, in which *\n * case you can revert to using the C function instead.                *\n ***********************************************************************/\n\nstatic void cal_nmvjointsadcost(int *mvjointsadcost) {\n  /*********************************************************************\n   * Warning: Read the comments above before modifying this function   *\n   *********************************************************************/\n  mvjointsadcost[0] = 600;\n  mvjointsadcost[1] = 300;\n  mvjointsadcost[2] = 300;\n  mvjointsadcost[3] = 300;\n}\n\nstatic void cal_nmvsadcosts(int *mvsadcost[2]) {\n  /*********************************************************************\n   * Warning: Read the comments above before modifying this function   *\n   *********************************************************************/\n  int i = 1;\n\n  mvsadcost[0][0] = 0;\n  mvsadcost[1][0] = 0;\n\n  do {\n    double z = 256 * (2 * (log2f(8 * i) + .6));\n    mvsadcost[0][i] = (int)z;\n    mvsadcost[1][i] = (int)z;\n    mvsadcost[0][-i] = (int)z;\n    mvsadcost[1][-i] = (int)z;\n  } while (++i <= MV_MAX);\n}\n\nstatic void cal_nmvsadcosts_hp(int *mvsadcost[2]) {\n  int i = 1;\n\n  mvsadcost[0][0] = 0;\n  mvsadcost[1][0] = 0;\n\n  do {\n    double z = 256 * (2 * (log2f(8 * i) + .6));\n    mvsadcost[0][i] = (int)z;\n    mvsadcost[1][i] = (int)z;\n    mvsadcost[0][-i] = (int)z;\n    mvsadcost[1][-i] = (int)z;\n  } while (++i <= MV_MAX);\n}\n\nstatic void init_ref_frame_bufs(VP9_COMMON *cm) {\n  int i;\n  BufferPool *const pool = cm->buffer_pool;\n  cm->new_fb_idx = INVALID_IDX;\n  for (i = 0; i < REF_FRAMES; ++i) {\n    cm->ref_frame_map[i] = INVALID_IDX;\n  }\n  for (i = 0; i < FRAME_BUFFERS; ++i) {\n    pool->frame_bufs[i].ref_count = 0;\n  }\n}\n\nstatic void update_initial_width(VP9_COMP *cpi, int use_highbitdepth,\n                                 int subsampling_x, int subsampling_y) {\n  VP9_COMMON *const cm = &cpi->common;\n#if !CONFIG_VP9_HIGHBITDEPTH\n  (void)use_highbitdepth;\n  assert(use_highbitdepth == 0);\n#endif\n\n  if (!cpi->initial_width ||\n#if CONFIG_VP9_HIGHBITDEPTH\n      cm->use_highbitdepth != use_highbitdepth ||\n#endif\n      cm->subsampling_x != subsampling_x ||\n      cm->subsampling_y != subsampling_y) {\n    cm->subsampling_x = subsampling_x;\n    cm->subsampling_y = subsampling_y;\n#if CONFIG_VP9_HIGHBITDEPTH\n    cm->use_highbitdepth = use_highbitdepth;\n#endif\n    alloc_util_frame_buffers(cpi);\n    cpi->initial_width = cm->width;\n    cpi->initial_height = cm->height;\n    cpi->initial_mbs = cm->MBs;\n  }\n}\n\n// TODO(angiebird): Check whether we can move this function to vpx_image.c\nstatic INLINE void vpx_img_chroma_subsampling(vpx_img_fmt_t fmt,\n                                              unsigned int *subsampling_x,\n                                              unsigned int *subsampling_y) {\n  switch (fmt) {\n    case VPX_IMG_FMT_I420:\n    case VPX_IMG_FMT_YV12:\n    case VPX_IMG_FMT_NV12:\n    case VPX_IMG_FMT_I422:\n    case VPX_IMG_FMT_I42016:\n    case VPX_IMG_FMT_I42216: *subsampling_x = 1; break;\n    default: *subsampling_x = 0; break;\n  }\n\n  switch (fmt) {\n    case VPX_IMG_FMT_I420:\n    case VPX_IMG_FMT_I440:\n    case VPX_IMG_FMT_YV12:\n    case VPX_IMG_FMT_NV12:\n    case VPX_IMG_FMT_I42016:\n    case VPX_IMG_FMT_I44016: *subsampling_y = 1; break;\n    default: *subsampling_y = 0; break;\n  }\n}\n\n// TODO(angiebird): Check whether we can move this function to vpx_image.c\nstatic INLINE int vpx_img_use_highbitdepth(vpx_img_fmt_t fmt) {\n  return fmt & VPX_IMG_FMT_HIGHBITDEPTH;\n}\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\nstatic void setup_denoiser_buffer(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  if (cpi->oxcf.noise_sensitivity > 0 &&\n      !cpi->denoiser.frame_buffer_initialized) {\n    if (vp9_denoiser_alloc(cm, &cpi->svc, &cpi->denoiser, cpi->use_svc,\n                           cpi->oxcf.noise_sensitivity, cm->width, cm->height,\n                           cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                           cm->use_highbitdepth,\n#endif\n                           VP9_ENC_BORDER_IN_PIXELS))\n      vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                         \"Failed to allocate denoiser\");\n  }\n}\n#endif\n\nvoid vp9_update_compressor_with_img_fmt(VP9_COMP *cpi, vpx_img_fmt_t img_fmt) {\n  const VP9EncoderConfig *oxcf = &cpi->oxcf;\n  unsigned int subsampling_x, subsampling_y;\n  const int use_highbitdepth = vpx_img_use_highbitdepth(img_fmt);\n  vpx_img_chroma_subsampling(img_fmt, &subsampling_x, &subsampling_y);\n\n  update_initial_width(cpi, use_highbitdepth, subsampling_x, subsampling_y);\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  setup_denoiser_buffer(cpi);\n#endif\n\n  assert(cpi->lookahead == NULL);\n  cpi->lookahead = vp9_lookahead_init(oxcf->width, oxcf->height, subsampling_x,\n                                      subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                                      use_highbitdepth,\n#endif\n                                      oxcf->lag_in_frames);\n  alloc_raw_frame_buffers(cpi);\n}\n\nVP9_COMP *vp9_create_compressor(const VP9EncoderConfig *oxcf,\n                                BufferPool *const pool) {\n  unsigned int i;\n  VP9_COMP *volatile const cpi = vpx_memalign(32, sizeof(VP9_COMP));\n  VP9_COMMON *volatile const cm = cpi != NULL ? &cpi->common : NULL;\n\n  if (!cm) return NULL;\n\n  vp9_zero(*cpi);\n\n  if (setjmp(cm->error.jmp)) {\n    cm->error.setjmp = 0;\n    vp9_remove_compressor(cpi);\n    return 0;\n  }\n\n  cm->error.setjmp = 1;\n  cm->alloc_mi = vp9_enc_alloc_mi;\n  cm->free_mi = vp9_enc_free_mi;\n  cm->setup_mi = vp9_enc_setup_mi;\n\n  CHECK_MEM_ERROR(&cm->error, cm->fc,\n                  (FRAME_CONTEXT *)vpx_calloc(1, sizeof(*cm->fc)));\n  CHECK_MEM_ERROR(\n      &cm->error, cm->frame_contexts,\n      (FRAME_CONTEXT *)vpx_calloc(FRAME_CONTEXTS, sizeof(*cm->frame_contexts)));\n\n  cpi->compute_frame_low_motion_onepass = 1;\n  cpi->use_svc = 0;\n  cpi->resize_state = ORIG;\n  cpi->external_resize = 0;\n  cpi->resize_avg_qp = 0;\n  cpi->resize_buffer_underflow = 0;\n  cpi->use_skin_detection = 0;\n  cpi->common.buffer_pool = pool;\n  init_ref_frame_bufs(cm);\n\n  cpi->force_update_segmentation = 0;\n\n  init_config(cpi, oxcf);\n  cpi->frame_info = vp9_get_frame_info(oxcf);\n\n  vp9_rc_init(&cpi->oxcf, oxcf->pass, &cpi->rc);\n  vp9_init_rd_parameters(cpi);\n\n  init_frame_indexes(cm);\n  cpi->tile_data = NULL;\n\n  realloc_segmentation_maps(cpi);\n\n  CHECK_MEM_ERROR(\n      &cm->error, cpi->skin_map,\n      vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n\n#if !CONFIG_REALTIME_ONLY\n  CHECK_MEM_ERROR(&cm->error, cpi->alt_ref_aq, vp9_alt_ref_aq_create());\n#endif\n\n  CHECK_MEM_ERROR(\n      &cm->error, cpi->consec_zero_mv,\n      vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvcosts[0],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvcosts[0])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvcosts[1],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvcosts[1])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvcosts_hp[0],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvcosts_hp[0])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvcosts_hp[1],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvcosts_hp[1])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvsadcosts[0],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvsadcosts[0])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvsadcosts[1],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvsadcosts[1])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvsadcosts_hp[0],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvsadcosts_hp[0])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvsadcosts_hp[1],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvsadcosts_hp[1])));\n\n  for (i = 0; i < (sizeof(cpi->mbgraph_stats) / sizeof(cpi->mbgraph_stats[0]));\n       i++) {\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->mbgraph_stats[i].mb_stats,\n        vpx_calloc(cm->MBs * sizeof(*cpi->mbgraph_stats[i].mb_stats), 1));\n  }\n\n  cpi->refresh_alt_ref_frame = 0;\n  cpi->b_calculate_psnr = CONFIG_INTERNAL_STATS;\n\n  init_level_info(&cpi->level_info);\n  init_level_constraint(&cpi->level_constraint);\n\n#if CONFIG_INTERNAL_STATS\n  cpi->b_calculate_blockiness = 1;\n  cpi->b_calculate_consistency = 1;\n  cpi->total_inconsistency = 0;\n  cpi->psnr.worst = 100.0;\n  cpi->worst_ssim = 100.0;\n\n  cpi->count = 0;\n  cpi->bytes = 0;\n\n  if (cpi->b_calculate_psnr) {\n    cpi->total_sq_error = 0;\n    cpi->total_samples = 0;\n\n    cpi->totalp_sq_error = 0;\n    cpi->totalp_samples = 0;\n\n    cpi->tot_recode_hits = 0;\n    cpi->summed_quality = 0;\n    cpi->summed_weights = 0;\n    cpi->summedp_quality = 0;\n    cpi->summedp_weights = 0;\n  }\n\n  cpi->fastssim.worst = 100.0;\n\n  cpi->psnrhvs.worst = 100.0;\n\n  if (cpi->b_calculate_blockiness) {\n    cpi->total_blockiness = 0;\n    cpi->worst_blockiness = 0.0;\n  }\n\n  if (cpi->b_calculate_consistency) {\n    CHECK_MEM_ERROR(&cm->error, cpi->ssim_vars,\n                    vpx_calloc(cpi->common.mi_rows * cpi->common.mi_cols,\n                               sizeof(*cpi->ssim_vars) * 4));\n    cpi->worst_consistency = 100.0;\n  } else {\n    cpi->ssim_vars = NULL;\n  }\n\n#endif\n\n  cpi->first_time_stamp_ever = INT64_MAX;\n\n  /*********************************************************************\n   * Warning: Read the comments around 'cal_nmvjointsadcost' and       *\n   * 'cal_nmvsadcosts' before modifying how these tables are computed. *\n   *********************************************************************/\n  cal_nmvjointsadcost(cpi->td.mb.nmvjointsadcost);\n  cpi->td.mb.nmvcost[0] = &cpi->nmvcosts[0][MV_MAX];\n  cpi->td.mb.nmvcost[1] = &cpi->nmvcosts[1][MV_MAX];\n  cpi->td.mb.nmvsadcost[0] = &cpi->nmvsadcosts[0][MV_MAX];\n  cpi->td.mb.nmvsadcost[1] = &cpi->nmvsadcosts[1][MV_MAX];\n  cal_nmvsadcosts(cpi->td.mb.nmvsadcost);\n\n  cpi->td.mb.nmvcost_hp[0] = &cpi->nmvcosts_hp[0][MV_MAX];\n  cpi->td.mb.nmvcost_hp[1] = &cpi->nmvcosts_hp[1][MV_MAX];\n  cpi->td.mb.nmvsadcost_hp[0] = &cpi->nmvsadcosts_hp[0][MV_MAX];\n  cpi->td.mb.nmvsadcost_hp[1] = &cpi->nmvsadcosts_hp[1][MV_MAX];\n  cal_nmvsadcosts_hp(cpi->td.mb.nmvsadcost_hp);\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n#ifdef OUTPUT_YUV_DENOISED\n  yuv_denoised_file = fopen(\"denoised.yuv\", \"ab\");\n#endif\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  yuv_skinmap_file = fopen(\"skinmap.yuv\", \"wb\");\n#endif\n#ifdef OUTPUT_YUV_REC\n  yuv_rec_file = fopen(\"rec.yuv\", \"wb\");\n#endif\n#ifdef OUTPUT_YUV_SVC_SRC\n  yuv_svc_src[0] = fopen(\"svc_src_0.yuv\", \"wb\");\n  yuv_svc_src[1] = fopen(\"svc_src_1.yuv\", \"wb\");\n  yuv_svc_src[2] = fopen(\"svc_src_2.yuv\", \"wb\");\n#endif\n\n#if 0\n  framepsnr = fopen(\"framepsnr.stt\", \"a\");\n  kf_list = fopen(\"kf_list.stt\", \"w\");\n#endif\n\n  cpi->allow_encode_breakout = ENCODE_BREAKOUT_ENABLED;\n\n  {\n    vpx_codec_err_t codec_status = vp9_extrc_init(&cpi->ext_ratectrl);\n    if (codec_status != VPX_CODEC_OK) {\n      vpx_internal_error(&cm->error, codec_status, \"vp9_extrc_init() failed\");\n    }\n  }\n\n#if !CONFIG_REALTIME_ONLY\n  if (oxcf->pass == 1) {\n    vp9_init_first_pass(cpi);\n  } else if (oxcf->pass == 2) {\n    const size_t packet_sz = sizeof(FIRSTPASS_STATS);\n    const int packets = (int)(oxcf->two_pass_stats_in.sz / packet_sz);\n\n    if (cpi->svc.number_spatial_layers > 1 ||\n        cpi->svc.number_temporal_layers > 1) {\n      FIRSTPASS_STATS *const stats = oxcf->two_pass_stats_in.buf;\n      FIRSTPASS_STATS *stats_copy[VPX_SS_MAX_LAYERS] = { 0 };\n      int n;\n\n      for (n = 0; n < oxcf->ss_number_layers; ++n) {\n        FIRSTPASS_STATS *const last_packet_for_layer =\n            &stats[packets - oxcf->ss_number_layers + n];\n        const int layer_id = (int)last_packet_for_layer->spatial_layer_id;\n        const int packets_in_layer = (int)last_packet_for_layer->count + 1;\n        if (layer_id >= 0 && layer_id < oxcf->ss_number_layers) {\n          int num_frames;\n          LAYER_CONTEXT *const lc = &cpi->svc.layer_context[layer_id];\n\n          vpx_free(lc->rc_twopass_stats_in.buf);\n\n          lc->rc_twopass_stats_in.sz = packets_in_layer * packet_sz;\n          CHECK_MEM_ERROR(&cm->error, lc->rc_twopass_stats_in.buf,\n                          vpx_malloc(lc->rc_twopass_stats_in.sz));\n          lc->twopass.stats_in_start = lc->rc_twopass_stats_in.buf;\n          lc->twopass.stats_in = lc->twopass.stats_in_start;\n          lc->twopass.stats_in_end =\n              lc->twopass.stats_in_start + packets_in_layer - 1;\n          // Note the last packet is cumulative first pass stats.\n          // So the number of frames is packet number minus one\n          num_frames = packets_in_layer - 1;\n          fps_init_first_pass_info(&lc->twopass.first_pass_info,\n                                   lc->rc_twopass_stats_in.buf, num_frames);\n          stats_copy[layer_id] = lc->rc_twopass_stats_in.buf;\n        }\n      }\n\n      for (n = 0; n < packets; ++n) {\n        const int layer_id = (int)stats[n].spatial_layer_id;\n        if (layer_id >= 0 && layer_id < oxcf->ss_number_layers &&\n            stats_copy[layer_id] != NULL) {\n          *stats_copy[layer_id] = stats[n];\n          ++stats_copy[layer_id];\n        }\n      }\n\n      vp9_init_second_pass_spatial_svc(cpi);\n    } else {\n      int num_frames;\n\n      cpi->twopass.stats_in_start = oxcf->two_pass_stats_in.buf;\n      cpi->twopass.stats_in = cpi->twopass.stats_in_start;\n      cpi->twopass.stats_in_end = &cpi->twopass.stats_in[packets - 1];\n      // Note the last packet is cumulative first pass stats.\n      // So the number of frames is packet number minus one\n      num_frames = packets - 1;\n      fps_init_first_pass_info(&cpi->twopass.first_pass_info,\n                               oxcf->two_pass_stats_in.buf, num_frames);\n\n      vp9_init_second_pass(cpi);\n    }\n  }\n#endif  // !CONFIG_REALTIME_ONLY\n\n  cpi->mb_wiener_var_cols = 0;\n  cpi->mb_wiener_var_rows = 0;\n  cpi->mb_wiener_variance = NULL;\n\n  vp9_set_speed_features_framesize_independent(cpi, oxcf->speed);\n  vp9_set_speed_features_framesize_dependent(cpi, oxcf->speed);\n\n  {\n    const int bsize = BLOCK_16X16;\n    const int w = num_8x8_blocks_wide_lookup[bsize];\n    const int h = num_8x8_blocks_high_lookup[bsize];\n    const int num_cols = (cm->mi_cols + w - 1) / w;\n    const int num_rows = (cm->mi_rows + h - 1) / h;\n    CHECK_MEM_ERROR(&cm->error, cpi->mi_ssim_rdmult_scaling_factors,\n                    vpx_calloc(num_rows * num_cols,\n                               sizeof(*cpi->mi_ssim_rdmult_scaling_factors)));\n  }\n\n  cpi->kmeans_data_arr_alloc = 0;\n#if CONFIG_NON_GREEDY_MV\n  cpi->tpl_ready = 0;\n#endif  // CONFIG_NON_GREEDY_MV\n  for (i = 0; i < MAX_ARF_GOP_SIZE; ++i) {\n    cpi->tpl_stats[i].tpl_stats_ptr = NULL;\n  }\n\n  // Allocate memory to store variances for a frame.\n  CHECK_MEM_ERROR(&cm->error, cpi->source_diff_var,\n                  vpx_calloc(cm->MBs, sizeof(cpi->source_diff_var)));\n  cpi->source_var_thresh = 0;\n  cpi->frames_till_next_var_check = 0;\n#define BFP(BT, SDF, SDSF, SDAF, VF, SVF, SVAF, SDX4DF, SDSX4DF) \\\n  cpi->fn_ptr[BT].sdf = SDF;                                     \\\n  cpi->fn_ptr[BT].sdsf = SDSF;                                   \\\n  cpi->fn_ptr[BT].sdaf = SDAF;                                   \\\n  cpi->fn_ptr[BT].vf = VF;                                       \\\n  cpi->fn_ptr[BT].svf = SVF;                                     \\\n  cpi->fn_ptr[BT].svaf = SVAF;                                   \\\n  cpi->fn_ptr[BT].sdx4df = SDX4DF;                               \\\n  cpi->fn_ptr[BT].sdsx4df = SDSX4DF;\n\n  BFP(BLOCK_32X16, vpx_sad32x16, vpx_sad_skip_32x16, vpx_sad32x16_avg,\n      vpx_variance32x16, vpx_sub_pixel_variance32x16,\n      vpx_sub_pixel_avg_variance32x16, vpx_sad32x16x4d, vpx_sad_skip_32x16x4d)\n\n  BFP(BLOCK_16X32, vpx_sad16x32, vpx_sad_skip_16x32, vpx_sad16x32_avg,\n      vpx_variance16x32, vpx_sub_pixel_variance16x32,\n      vpx_sub_pixel_avg_variance16x32, vpx_sad16x32x4d, vpx_sad_skip_16x32x4d)\n\n  BFP(BLOCK_64X32, vpx_sad64x32, vpx_sad_skip_64x32, vpx_sad64x32_avg,\n      vpx_variance64x32, vpx_sub_pixel_variance64x32,\n      vpx_sub_pixel_avg_variance64x32, vpx_sad64x32x4d, vpx_sad_skip_64x32x4d)\n\n  BFP(BLOCK_32X64, vpx_sad32x64, vpx_sad_skip_32x64, vpx_sad32x64_avg,\n      vpx_variance32x64, vpx_sub_pixel_variance32x64,\n      vpx_sub_pixel_avg_variance32x64, vpx_sad32x64x4d, vpx_sad_skip_32x64x4d)\n\n  BFP(BLOCK_32X32, vpx_sad32x32, vpx_sad_skip_32x32, vpx_sad32x32_avg,\n      vpx_variance32x32, vpx_sub_pixel_variance32x32,\n      vpx_sub_pixel_avg_variance32x32, vpx_sad32x32x4d, vpx_sad_skip_32x32x4d)\n\n  BFP(BLOCK_64X64, vpx_sad64x64, vpx_sad_skip_64x64, vpx_sad64x64_avg,\n      vpx_variance64x64, vpx_sub_pixel_variance64x64,\n      vpx_sub_pixel_avg_variance64x64, vpx_sad64x64x4d, vpx_sad_skip_64x64x4d)\n\n  BFP(BLOCK_16X16, vpx_sad16x16, vpx_sad_skip_16x16, vpx_sad16x16_avg,\n      vpx_variance16x16, vpx_sub_pixel_variance16x16,\n      vpx_sub_pixel_avg_variance16x16, vpx_sad16x16x4d, vpx_sad_skip_16x16x4d)\n\n  BFP(BLOCK_16X8, vpx_sad16x8, vpx_sad_skip_16x8, vpx_sad16x8_avg,\n      vpx_variance16x8, vpx_sub_pixel_variance16x8,\n      vpx_sub_pixel_avg_variance16x8, vpx_sad16x8x4d, vpx_sad_skip_16x8x4d)\n\n  BFP(BLOCK_8X16, vpx_sad8x16, vpx_sad_skip_8x16, vpx_sad8x16_avg,\n      vpx_variance8x16, vpx_sub_pixel_variance8x16,\n      vpx_sub_pixel_avg_variance8x16, vpx_sad8x16x4d, vpx_sad_skip_8x16x4d)\n\n  BFP(BLOCK_8X8, vpx_sad8x8, vpx_sad_skip_8x8, vpx_sad8x8_avg, vpx_variance8x8,\n      vpx_sub_pixel_variance8x8, vpx_sub_pixel_avg_variance8x8, vpx_sad8x8x4d,\n      vpx_sad_skip_8x8x4d)\n\n  BFP(BLOCK_8X4, vpx_sad8x4, vpx_sad_skip_8x4, vpx_sad8x4_avg, vpx_variance8x4,\n      vpx_sub_pixel_variance8x4, vpx_sub_pixel_avg_variance8x4, vpx_sad8x4x4d,\n      vpx_sad_skip_8x4x4d)\n\n  BFP(BLOCK_4X8, vpx_sad4x8, vpx_sad_skip_4x8, vpx_sad4x8_avg, vpx_variance4x8,\n      vpx_sub_pixel_variance4x8, vpx_sub_pixel_avg_variance4x8, vpx_sad4x8x4d,\n      vpx_sad_skip_4x8x4d)\n\n  BFP(BLOCK_4X4, vpx_sad4x4, vpx_sad_skip_4x4, vpx_sad4x4_avg, vpx_variance4x4,\n      vpx_sub_pixel_variance4x4, vpx_sub_pixel_avg_variance4x4, vpx_sad4x4x4d,\n      vpx_sad_skip_4x4x4d)\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  /* vp9_init_quantizer() is first called here. Add check in\n   * vp9_frame_init_quantizer() so that vp9_init_quantizer is only\n   * called later when needed. This will avoid unnecessary calls of\n   * vp9_init_quantizer() for every frame.\n   */\n  vp9_init_quantizer(cpi);\n\n  vp9_loop_filter_init(cm);\n\n  // Set up the unit scaling factor used during motion search.\n#if CONFIG_VP9_HIGHBITDEPTH\n  vp9_setup_scale_factors_for_frame(&cpi->me_sf, cm->width, cm->height,\n                                    cm->width, cm->height,\n                                    cm->use_highbitdepth);\n#else\n  vp9_setup_scale_factors_for_frame(&cpi->me_sf, cm->width, cm->height,\n                                    cm->width, cm->height);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.me_sf = &cpi->me_sf;\n\n  cm->error.setjmp = 0;\n\n#if CONFIG_RATE_CTRL\n  encode_command_init(&cpi->encode_command);\n  if (oxcf->use_simple_encode_api) {\n    partition_info_init(cpi);\n    motion_vector_info_init(cpi);\n    fp_motion_vector_info_init(cpi);\n    tpl_stats_info_init(cpi);\n  }\n#endif\n\n  return cpi;\n}\n\n#if CONFIG_INTERNAL_STATS\n#define SNPRINT(H, T) snprintf((H) + strlen(H), sizeof(H) - strlen(H), (T))\n\n#define SNPRINT2(H, T, V) \\\n  snprintf((H) + strlen(H), sizeof(H) - strlen(H), (T), (V))\n#endif  // CONFIG_INTERNAL_STATS\n\nvoid vp9_remove_compressor(VP9_COMP *cpi) {\n  VP9_COMMON *cm;\n  unsigned int i;\n\n  if (!cpi) return;\n\n#if CONFIG_INTERNAL_STATS\n  vpx_free(cpi->ssim_vars);\n#endif\n\n  cm = &cpi->common;\n  if (cm->current_video_frame > 0) {\n#if CONFIG_INTERNAL_STATS\n    vpx_clear_system_state();\n\n    if (cpi->oxcf.pass != 1) {\n      char headings[512] = { 0 };\n      char results[512] = { 0 };\n      FILE *f = fopen(\"opsnr.stt\", \"a\");\n      double time_encoded =\n          (cpi->last_end_time_stamp_seen - cpi->first_time_stamp_ever) /\n          10000000.000;\n      double total_encode_time =\n          (cpi->time_receive_data + cpi->time_compress_data) / 1000.000;\n      const double dr =\n          (double)cpi->bytes * (double)8 / (double)1000 / time_encoded;\n      const double peak = (double)((1 << cpi->oxcf.input_bit_depth) - 1);\n      const double target_rate = (double)cpi->oxcf.target_bandwidth / 1000;\n      const double rate_err = ((100.0 * (dr - target_rate)) / target_rate);\n\n      if (cpi->b_calculate_psnr) {\n        const double total_psnr = vpx_sse_to_psnr(\n            (double)cpi->total_samples, peak, (double)cpi->total_sq_error);\n        const double totalp_psnr = vpx_sse_to_psnr(\n            (double)cpi->totalp_samples, peak, (double)cpi->totalp_sq_error);\n        const double total_ssim =\n            100 * pow(cpi->summed_quality / cpi->summed_weights, 8.0);\n        const double totalp_ssim =\n            100 * pow(cpi->summedp_quality / cpi->summedp_weights, 8.0);\n\n        snprintf(headings, sizeof(headings),\n                 \"Bitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\tGLPsnrP\\t\"\n                 \"VPXSSIM\\tVPSSIMP\\tFASTSIM\\tPSNRHVS\\t\"\n                 \"WstPsnr\\tWstSsim\\tWstFast\\tWstHVS\\t\"\n                 \"AVPsnrY\\tAPsnrCb\\tAPsnrCr\");\n        snprintf(results, sizeof(results),\n                 \"%7.2f\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                 \"%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                 \"%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                 \"%7.3f\\t%7.3f\\t%7.3f\",\n                 dr, cpi->psnr.stat[ALL] / cpi->count, total_psnr,\n                 cpi->psnrp.stat[ALL] / cpi->count, totalp_psnr, total_ssim,\n                 totalp_ssim, cpi->fastssim.stat[ALL] / cpi->count,\n                 cpi->psnrhvs.stat[ALL] / cpi->count, cpi->psnr.worst,\n                 cpi->worst_ssim, cpi->fastssim.worst, cpi->psnrhvs.worst,\n                 cpi->psnr.stat[Y] / cpi->count, cpi->psnr.stat[U] / cpi->count,\n                 cpi->psnr.stat[V] / cpi->count);\n\n        if (cpi->b_calculate_blockiness) {\n          SNPRINT(headings, \"\\t  Block\\tWstBlck\");\n          SNPRINT2(results, \"\\t%7.3f\", cpi->total_blockiness / cpi->count);\n          SNPRINT2(results, \"\\t%7.3f\", cpi->worst_blockiness);\n        }\n\n        if (cpi->b_calculate_consistency) {\n          double consistency =\n              vpx_sse_to_psnr((double)cpi->totalp_samples, peak,\n                              (double)cpi->total_inconsistency);\n\n          SNPRINT(headings, \"\\tConsist\\tWstCons\");\n          SNPRINT2(results, \"\\t%7.3f\", consistency);\n          SNPRINT2(results, \"\\t%7.3f\", cpi->worst_consistency);\n        }\n\n        SNPRINT(headings, \"\\t    Time\\tRcErr\\tAbsErr\");\n        SNPRINT2(results, \"\\t%8.0f\", total_encode_time);\n        SNPRINT2(results, \"\\t%7.2f\", rate_err);\n        SNPRINT2(results, \"\\t%7.2f\", fabs(rate_err));\n\n        fprintf(f, \"%s\\tAPsnr611\\n\", headings);\n        fprintf(\n            f, \"%s\\t%7.3f\\n\", results,\n            (6 * cpi->psnr.stat[Y] + cpi->psnr.stat[U] + cpi->psnr.stat[V]) /\n                (cpi->count * 8));\n      }\n\n      fclose(f);\n    }\n#endif\n\n#if 0\n    {\n      printf(\"\\n_pick_loop_filter_level:%d\\n\", cpi->time_pick_lpf / 1000);\n      printf(\"\\n_frames receive_data encod_mb_row compress_frame  Total\\n\");\n      printf(\"%6d %10ld %10ld %10ld %10ld\\n\", cpi->common.current_video_frame,\n             cpi->time_receive_data / 1000, cpi->time_encode_sb_row / 1000,\n             cpi->time_compress_data / 1000,\n             (cpi->time_receive_data + cpi->time_compress_data) / 1000);\n    }\n#endif\n  }\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  vp9_denoiser_free(&(cpi->denoiser));\n#endif\n\n  if (cpi->kmeans_data_arr_alloc) {\n#if CONFIG_MULTITHREAD\n    pthread_mutex_destroy(&cpi->kmeans_mutex);\n#endif\n    vpx_free(cpi->kmeans_data_arr);\n  }\n\n  vp9_free_tpl_buffer(cpi);\n\n  vp9_loop_filter_dealloc(&cpi->lf_row_sync);\n  vp9_bitstream_encode_tiles_buffer_dealloc(cpi);\n  vp9_row_mt_mem_dealloc(cpi);\n  vp9_encode_free_mt_data(cpi);\n\n#if !CONFIG_REALTIME_ONLY\n  vp9_alt_ref_aq_destroy(cpi->alt_ref_aq);\n#endif\n\n  dealloc_compressor_data(cpi);\n\n  for (i = 0; i < sizeof(cpi->mbgraph_stats) / sizeof(cpi->mbgraph_stats[0]);\n       ++i) {\n    vpx_free(cpi->mbgraph_stats[i].mb_stats);\n  }\n\n  vp9_extrc_delete(&cpi->ext_ratectrl);\n\n  // Help detect use after free of the error detail string.\n  memset(cm->error.detail, 'A', sizeof(cm->error.detail) - 1);\n  cm->error.detail[sizeof(cm->error.detail) - 1] = '\\0';\n\n  vp9_remove_common(cm);\n  vp9_free_ref_frame_buffers(cm->buffer_pool);\n#if CONFIG_VP9_POSTPROC\n  vp9_free_postproc_buffers(cm);\n#endif\n  vpx_free(cpi);\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n#ifdef OUTPUT_YUV_DENOISED\n  fclose(yuv_denoised_file);\n#endif\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  fclose(yuv_skinmap_file);\n#endif\n#ifdef OUTPUT_YUV_REC\n  fclose(yuv_rec_file);\n#endif\n#ifdef OUTPUT_YUV_SVC_SRC\n  fclose(yuv_svc_src[0]);\n  fclose(yuv_svc_src[1]);\n  fclose(yuv_svc_src[2]);\n#endif\n\n#if 0\n\n  if (keyfile)\n    fclose(keyfile);\n\n  if (framepsnr)\n    fclose(framepsnr);\n\n  if (kf_list)\n    fclose(kf_list);\n\n#endif\n}\n\nint vp9_get_psnr(const VP9_COMP *cpi, PSNR_STATS *psnr) {\n  if (is_psnr_calc_enabled(cpi)) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    vpx_calc_highbd_psnr(cpi->raw_source_frame, cpi->common.frame_to_show, psnr,\n                         cpi->td.mb.e_mbd.bd, cpi->oxcf.input_bit_depth);\n#else\n    vpx_calc_psnr(cpi->raw_source_frame, cpi->common.frame_to_show, psnr);\n#endif\n    return 1;\n  } else {\n    vp9_zero(*psnr);\n    return 0;\n  }\n}\n\nint vp9_use_as_reference(VP9_COMP *cpi, int ref_frame_flags) {\n  if (ref_frame_flags > 7) return -1;\n\n  cpi->ref_frame_flags = ref_frame_flags;\n  return 0;\n}\n\nvoid vp9_update_reference(VP9_COMP *cpi, int ref_frame_flags) {\n  cpi->ext_refresh_golden_frame = (ref_frame_flags & VP9_GOLD_FLAG) != 0;\n  cpi->ext_refresh_alt_ref_frame = (ref_frame_flags & VP9_ALT_FLAG) != 0;\n  cpi->ext_refresh_last_frame = (ref_frame_flags & VP9_LAST_FLAG) != 0;\n  cpi->ext_refresh_frame_flags_pending = 1;\n}\n\nstatic YV12_BUFFER_CONFIG *get_vp9_ref_frame_buffer(\n    VP9_COMP *cpi, VP9_REFFRAME ref_frame_flag) {\n  MV_REFERENCE_FRAME ref_frame = NO_REF_FRAME;\n  if (ref_frame_flag == VP9_LAST_FLAG)\n    ref_frame = LAST_FRAME;\n  else if (ref_frame_flag == VP9_GOLD_FLAG)\n    ref_frame = GOLDEN_FRAME;\n  else if (ref_frame_flag == VP9_ALT_FLAG)\n    ref_frame = ALTREF_FRAME;\n\n  return ref_frame == NO_REF_FRAME ? NULL\n                                   : get_ref_frame_buffer(cpi, ref_frame);\n}\n\nint vp9_copy_reference_enc(VP9_COMP *cpi, VP9_REFFRAME ref_frame_flag,\n                           YV12_BUFFER_CONFIG *sd) {\n  YV12_BUFFER_CONFIG *cfg = get_vp9_ref_frame_buffer(cpi, ref_frame_flag);\n  if (cfg) {\n    vpx_yv12_copy_frame(cfg, sd);\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint vp9_set_reference_enc(VP9_COMP *cpi, VP9_REFFRAME ref_frame_flag,\n                          YV12_BUFFER_CONFIG *sd) {\n  YV12_BUFFER_CONFIG *cfg = get_vp9_ref_frame_buffer(cpi, ref_frame_flag);\n  if (cfg) {\n    vpx_yv12_copy_frame(sd, cfg);\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint vp9_update_entropy(VP9_COMP *cpi, int update) {\n  cpi->ext_refresh_frame_context = update;\n  cpi->ext_refresh_frame_context_pending = 1;\n  return 0;\n}\n\n#ifdef OUTPUT_YUV_REC\nvoid vp9_write_yuv_rec_frame(VP9_COMMON *cm) {\n  YV12_BUFFER_CONFIG *s = cm->frame_to_show;\n  uint8_t *src = s->y_buffer;\n  int h = cm->height;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  if (s->flags & YV12_FLAG_HIGHBITDEPTH) {\n    uint16_t *src16 = CONVERT_TO_SHORTPTR(s->y_buffer);\n\n    do {\n      fwrite(src16, s->y_width, 2, yuv_rec_file);\n      src16 += s->y_stride;\n    } while (--h);\n\n    src16 = CONVERT_TO_SHORTPTR(s->u_buffer);\n    h = s->uv_height;\n\n    do {\n      fwrite(src16, s->uv_width, 2, yuv_rec_file);\n      src16 += s->uv_stride;\n    } while (--h);\n\n    src16 = CONVERT_TO_SHORTPTR(s->v_buffer);\n    h = s->uv_height;\n\n    do {\n      fwrite(src16, s->uv_width, 2, yuv_rec_file);\n      src16 += s->uv_stride;\n    } while (--h);\n\n    fflush(yuv_rec_file);\n    return;\n  }\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  do {\n    fwrite(src, s->y_width, 1, yuv_rec_file);\n    src += s->y_stride;\n  } while (--h);\n\n  src = s->u_buffer;\n  h = s->uv_height;\n\n  do {\n    fwrite(src, s->uv_width, 1, yuv_rec_file);\n    src += s->uv_stride;\n  } while (--h);\n\n  src = s->v_buffer;\n  h = s->uv_height;\n\n  do {\n    fwrite(src, s->uv_width, 1, yuv_rec_file);\n    src += s->uv_stride;\n  } while (--h);\n\n  fflush(yuv_rec_file);\n}\n#endif\n\n#if CONFIG_VP9_HIGHBITDEPTH\nstatic void scale_and_extend_frame_nonnormative(const YV12_BUFFER_CONFIG *src,\n                                                YV12_BUFFER_CONFIG *dst,\n                                                int bd) {\n#else\nstatic void scale_and_extend_frame_nonnormative(const YV12_BUFFER_CONFIG *src,\n                                                YV12_BUFFER_CONFIG *dst) {\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  // TODO(dkovalev): replace YV12_BUFFER_CONFIG with vpx_image_t\n  int i;\n  const uint8_t *const srcs[3] = { src->y_buffer, src->u_buffer,\n                                   src->v_buffer };\n  const int src_strides[3] = { src->y_stride, src->uv_stride, src->uv_stride };\n  const int src_widths[3] = { src->y_crop_width, src->uv_crop_width,\n                              src->uv_crop_width };\n  const int src_heights[3] = { src->y_crop_height, src->uv_crop_height,\n                               src->uv_crop_height };\n  uint8_t *const dsts[3] = { dst->y_buffer, dst->u_buffer, dst->v_buffer };\n  const int dst_strides[3] = { dst->y_stride, dst->uv_stride, dst->uv_stride };\n  const int dst_widths[3] = { dst->y_crop_width, dst->uv_crop_width,\n                              dst->uv_crop_width };\n  const int dst_heights[3] = { dst->y_crop_height, dst->uv_crop_height,\n                               dst->uv_crop_height };\n\n  for (i = 0; i < MAX_MB_PLANE; ++i) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (src->flags & YV12_FLAG_HIGHBITDEPTH) {\n      vp9_highbd_resize_plane(srcs[i], src_heights[i], src_widths[i],\n                              src_strides[i], dsts[i], dst_heights[i],\n                              dst_widths[i], dst_strides[i], bd);\n    } else {\n      vp9_resize_plane(srcs[i], src_heights[i], src_widths[i], src_strides[i],\n                       dsts[i], dst_heights[i], dst_widths[i], dst_strides[i]);\n    }\n#else\n    vp9_resize_plane(srcs[i], src_heights[i], src_widths[i], src_strides[i],\n                     dsts[i], dst_heights[i], dst_widths[i], dst_strides[i]);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  }\n  vpx_extend_frame_borders(dst);\n}\n\n#if CONFIG_VP9_HIGHBITDEPTH\nstatic void scale_and_extend_frame(const YV12_BUFFER_CONFIG *src,\n                                   YV12_BUFFER_CONFIG *dst, int bd,\n                                   INTERP_FILTER filter_type,\n                                   int phase_scaler) {\n  const int src_w = src->y_crop_width;\n  const int src_h = src->y_crop_height;\n  const int dst_w = dst->y_crop_width;\n  const int dst_h = dst->y_crop_height;\n  const uint8_t *const srcs[3] = { src->y_buffer, src->u_buffer,\n                                   src->v_buffer };\n  const int src_strides[3] = { src->y_stride, src->uv_stride, src->uv_stride };\n  uint8_t *const dsts[3] = { dst->y_buffer, dst->u_buffer, dst->v_buffer };\n  const int dst_strides[3] = { dst->y_stride, dst->uv_stride, dst->uv_stride };\n  const InterpKernel *const kernel = vp9_filter_kernels[filter_type];\n  int x, y, i;\n\n  for (i = 0; i < MAX_MB_PLANE; ++i) {\n    const int factor = (i == 0 || i == 3 ? 1 : 2);\n    const int src_stride = src_strides[i];\n    const int dst_stride = dst_strides[i];\n    for (y = 0; y < dst_h; y += 16) {\n      const int y_q4 = y * (16 / factor) * src_h / dst_h + phase_scaler;\n      for (x = 0; x < dst_w; x += 16) {\n        const int x_q4 = x * (16 / factor) * src_w / dst_w + phase_scaler;\n        const uint8_t *src_ptr = srcs[i] +\n                                 (y / factor) * src_h / dst_h * src_stride +\n                                 (x / factor) * src_w / dst_w;\n        uint8_t *dst_ptr = dsts[i] + (y / factor) * dst_stride + (x / factor);\n\n        if (src->flags & YV12_FLAG_HIGHBITDEPTH) {\n          vpx_highbd_convolve8(CONVERT_TO_SHORTPTR(src_ptr), src_stride,\n                               CONVERT_TO_SHORTPTR(dst_ptr), dst_stride, kernel,\n                               x_q4 & 0xf, 16 * src_w / dst_w, y_q4 & 0xf,\n                               16 * src_h / dst_h, 16 / factor, 16 / factor,\n                               bd);\n        } else {\n          vpx_scaled_2d(src_ptr, src_stride, dst_ptr, dst_stride, kernel,\n                        x_q4 & 0xf, 16 * src_w / dst_w, y_q4 & 0xf,\n                        16 * src_h / dst_h, 16 / factor, 16 / factor);\n        }\n      }\n    }\n  }\n\n  vpx_extend_frame_borders(dst);\n}\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n#if !CONFIG_REALTIME_ONLY\nstatic int scale_down(VP9_COMP *cpi, int q) {\n  RATE_CONTROL *const rc = &cpi->rc;\n  GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n  int scale = 0;\n  assert(frame_is_kf_gf_arf(cpi));\n\n  if (rc->frame_size_selector == UNSCALED &&\n      q >= rc->rf_level_maxq[gf_group->rf_level[gf_group->index]]) {\n    const int max_size_thresh =\n        (int)(rate_thresh_mult[SCALE_STEP1] *\n              VPXMAX(rc->this_frame_target, rc->avg_frame_bandwidth));\n    scale = rc->projected_frame_size > max_size_thresh ? 1 : 0;\n  }\n  return scale;\n}\n\nstatic int big_rate_miss_high_threshold(VP9_COMP *cpi) {\n  const RATE_CONTROL *const rc = &cpi->rc;\n  int big_miss_high;\n\n  if (frame_is_kf_gf_arf(cpi))\n    big_miss_high = rc->this_frame_target * 3 / 2;\n  else\n    big_miss_high = rc->this_frame_target * 2;\n\n  return big_miss_high;\n}\n\nstatic int big_rate_miss(VP9_COMP *cpi) {\n  const RATE_CONTROL *const rc = &cpi->rc;\n  int big_miss_high;\n  int big_miss_low;\n\n  // Ignore for overlay frames\n  if (rc->is_src_frame_alt_ref) {\n    return 0;\n  } else {\n    big_miss_low = (rc->this_frame_target / 2);\n    big_miss_high = big_rate_miss_high_threshold(cpi);\n\n    return (rc->projected_frame_size > big_miss_high) ||\n           (rc->projected_frame_size < big_miss_low);\n  }\n}\n\n// test in two pass for the first\nstatic int two_pass_first_group_inter(VP9_COMP *cpi) {\n  if (cpi->oxcf.pass == 2) {\n    TWO_PASS *const twopass = &cpi->twopass;\n    GF_GROUP *const gf_group = &twopass->gf_group;\n    const int gfg_index = gf_group->index;\n\n    if (gfg_index == 0) return gf_group->update_type[gfg_index] == LF_UPDATE;\n    return gf_group->update_type[gfg_index - 1] != LF_UPDATE &&\n           gf_group->update_type[gfg_index] == LF_UPDATE;\n  } else {\n    return 0;\n  }\n}\n\n// Function to test for conditions that indicate we should loop\n// back and recode a frame.\nstatic int recode_loop_test(VP9_COMP *cpi, int high_limit, int low_limit, int q,\n                            int maxq, int minq) {\n  const RATE_CONTROL *const rc = &cpi->rc;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  const int frame_is_kfgfarf = frame_is_kf_gf_arf(cpi);\n  int force_recode = 0;\n\n  if ((rc->projected_frame_size >= rc->max_frame_bandwidth) ||\n      big_rate_miss(cpi) || (cpi->sf.recode_loop == ALLOW_RECODE) ||\n      (two_pass_first_group_inter(cpi) &&\n       (cpi->sf.recode_loop == ALLOW_RECODE_FIRST)) ||\n      (frame_is_kfgfarf && (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF))) {\n    if (frame_is_kfgfarf && (oxcf->resize_mode == RESIZE_DYNAMIC) &&\n        scale_down(cpi, q)) {\n      // Code this group at a lower resolution.\n      cpi->resize_pending = 1;\n      return 1;\n    }\n\n    // Force recode for extreme overshoot.\n    if ((rc->projected_frame_size >= rc->max_frame_bandwidth) ||\n        (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF &&\n         rc->projected_frame_size >= big_rate_miss_high_threshold(cpi))) {\n      return 1;\n    }\n\n    // TODO(agrange) high_limit could be greater than the scale-down threshold.\n    if ((rc->projected_frame_size > high_limit && q < maxq) ||\n        (rc->projected_frame_size < low_limit && q > minq)) {\n      force_recode = 1;\n    } else if (cpi->oxcf.rc_mode == VPX_CQ) {\n      // Deal with frame undershoot and whether or not we are\n      // below the automatically set cq level.\n      if (q > oxcf->cq_level &&\n          rc->projected_frame_size < ((rc->this_frame_target * 7) >> 3)) {\n        force_recode = 1;\n      }\n    }\n  }\n  return force_recode;\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void update_ref_frames(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  BufferPool *const pool = cm->buffer_pool;\n  GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n\n  if (cpi->rc.show_arf_as_gld) {\n    int tmp = cpi->alt_fb_idx;\n    cpi->alt_fb_idx = cpi->gld_fb_idx;\n    cpi->gld_fb_idx = tmp;\n  } else if (cm->show_existing_frame) {\n    // Pop ARF.\n    cpi->lst_fb_idx = cpi->alt_fb_idx;\n    cpi->alt_fb_idx =\n        stack_pop(gf_group->arf_index_stack, gf_group->stack_size);\n    --gf_group->stack_size;\n  }\n\n  // At this point the new frame has been encoded.\n  // If any buffer copy / swapping is signaled it should be done here.\n  if (cm->frame_type == KEY_FRAME) {\n    ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->gld_fb_idx],\n               cm->new_fb_idx);\n    ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->alt_fb_idx],\n               cm->new_fb_idx);\n  } else if (vp9_preserve_existing_gf(cpi)) {\n    // We have decided to preserve the previously existing golden frame as our\n    // new ARF frame. However, in the short term in function\n    // vp9_get_refresh_mask() we left it in the GF slot and, if\n    // we're updating the GF with the current decoded frame, we save it to the\n    // ARF slot instead.\n    // We now have to update the ARF with the current frame and swap gld_fb_idx\n    // and alt_fb_idx so that, overall, we've stored the old GF in the new ARF\n    // slot and, if we're updating the GF, the current frame becomes the new GF.\n    int tmp;\n\n    ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->alt_fb_idx],\n               cm->new_fb_idx);\n\n    tmp = cpi->alt_fb_idx;\n    cpi->alt_fb_idx = cpi->gld_fb_idx;\n    cpi->gld_fb_idx = tmp;\n  } else { /* For non key/golden frames */\n    if (cpi->refresh_alt_ref_frame) {\n      int arf_idx = gf_group->top_arf_idx;\n\n      // Push new ARF into stack.\n      stack_push(gf_group->arf_index_stack, cpi->alt_fb_idx,\n                 gf_group->stack_size);\n      ++gf_group->stack_size;\n\n      assert(arf_idx < REF_FRAMES);\n\n      ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[arf_idx], cm->new_fb_idx);\n      memcpy(cpi->interp_filter_selected[ALTREF_FRAME],\n             cpi->interp_filter_selected[0],\n             sizeof(cpi->interp_filter_selected[0]));\n\n      cpi->alt_fb_idx = arf_idx;\n    }\n\n    if (cpi->refresh_golden_frame) {\n      ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->gld_fb_idx],\n                 cm->new_fb_idx);\n      if (!cpi->rc.is_src_frame_alt_ref)\n        memcpy(cpi->interp_filter_selected[GOLDEN_FRAME],\n               cpi->interp_filter_selected[0],\n               sizeof(cpi->interp_filter_selected[0]));\n      else\n        memcpy(cpi->interp_filter_selected[GOLDEN_FRAME],\n               cpi->interp_filter_selected[ALTREF_FRAME],\n               sizeof(cpi->interp_filter_selected[ALTREF_FRAME]));\n    }\n  }\n\n  if (cpi->refresh_last_frame) {\n    ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->lst_fb_idx],\n               cm->new_fb_idx);\n    if (!cpi->rc.is_src_frame_alt_ref)\n      memcpy(cpi->interp_filter_selected[LAST_FRAME],\n             cpi->interp_filter_selected[0],\n             sizeof(cpi->interp_filter_selected[0]));\n  }\n\n  if (gf_group->update_type[gf_group->index] == MID_OVERLAY_UPDATE) {\n    cpi->alt_fb_idx =\n        stack_pop(gf_group->arf_index_stack, gf_group->stack_size);\n    --gf_group->stack_size;\n  }\n}\n\nvoid vp9_update_reference_frames(VP9_COMP *cpi) {\n  update_ref_frames(cpi);\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  vp9_denoiser_update_ref_frame(cpi);\n#endif\n\n  if (is_one_pass_svc(cpi)) vp9_svc_update_ref_frame(cpi);\n}\n\nstatic void loopfilter_frame(VP9_COMP *cpi, VP9_COMMON *cm) {\n  MACROBLOCKD *xd = &cpi->td.mb.e_mbd;\n  struct loopfilter *lf = &cm->lf;\n  int is_reference_frame =\n      (cm->frame_type == KEY_FRAME || cpi->refresh_last_frame ||\n       cpi->refresh_golden_frame || cpi->refresh_alt_ref_frame);\n  if (cpi->use_svc &&\n      cpi->svc.temporal_layering_mode == VP9E_TEMPORAL_LAYERING_MODE_BYPASS)\n    is_reference_frame = !cpi->svc.non_reference_frame;\n\n  // Skip loop filter in show_existing_frame mode.\n  if (cm->show_existing_frame) {\n    lf->filter_level = 0;\n    return;\n  }\n\n  if (cpi->loopfilter_ctrl == NO_LOOPFILTER ||\n      (!is_reference_frame && cpi->loopfilter_ctrl == LOOPFILTER_REFERENCE)) {\n    lf->filter_level = 0;\n    vpx_extend_frame_inner_borders(cm->frame_to_show);\n    return;\n  }\n\n  if (xd->lossless) {\n    lf->filter_level = 0;\n    lf->last_filt_level = 0;\n  } else {\n    struct vpx_usec_timer timer;\n\n    vpx_clear_system_state();\n\n    vpx_usec_timer_start(&timer);\n\n    if (!cpi->rc.is_src_frame_alt_ref) {\n      if ((cpi->common.frame_type == KEY_FRAME) &&\n          (!cpi->rc.this_key_frame_forced)) {\n        lf->last_filt_level = 0;\n      }\n      vp9_pick_filter_level(cpi->Source, cpi, cpi->sf.lpf_pick);\n      lf->last_filt_level = lf->filter_level;\n    } else {\n      lf->filter_level = 0;\n    }\n\n    vpx_usec_timer_mark(&timer);\n    cpi->time_pick_lpf += vpx_usec_timer_elapsed(&timer);\n  }\n\n  if (lf->filter_level > 0 && is_reference_frame) {\n    vp9_build_mask_frame(cm, lf->filter_level, 0);\n\n    if (cpi->num_workers > 1)\n      vp9_loop_filter_frame_mt(cm->frame_to_show, cm, xd->plane,\n                               lf->filter_level, 0, 0, cpi->workers,\n                               cpi->num_workers, &cpi->lf_row_sync);\n    else\n      vp9_loop_filter_frame(cm->frame_to_show, cm, xd, lf->filter_level, 0, 0);\n  }\n\n  vpx_extend_frame_inner_borders(cm->frame_to_show);\n}\n\nvoid vp9_scale_references(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  MV_REFERENCE_FRAME ref_frame;\n  const VP9_REFFRAME ref_mask[3] = { VP9_LAST_FLAG, VP9_GOLD_FLAG,\n                                     VP9_ALT_FLAG };\n\n  for (ref_frame = LAST_FRAME; ref_frame <= ALTREF_FRAME; ++ref_frame) {\n    // Need to convert from VP9_REFFRAME to index into ref_mask (subtract 1).\n    if (cpi->ref_frame_flags & ref_mask[ref_frame - 1]) {\n      BufferPool *const pool = cm->buffer_pool;\n      const YV12_BUFFER_CONFIG *const ref =\n          get_ref_frame_buffer(cpi, ref_frame);\n\n      if (ref == NULL) {\n        cpi->scaled_ref_idx[ref_frame - 1] = INVALID_IDX;\n        continue;\n      }\n\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (ref->y_crop_width != cm->width || ref->y_crop_height != cm->height) {\n        RefCntBuffer *new_fb_ptr = NULL;\n        int force_scaling = 0;\n        int new_fb = cpi->scaled_ref_idx[ref_frame - 1];\n        if (new_fb == INVALID_IDX) {\n          new_fb = get_free_fb(cm);\n          force_scaling = 1;\n        }\n        if (new_fb == INVALID_IDX) return;\n        new_fb_ptr = &pool->frame_bufs[new_fb];\n        if (force_scaling || new_fb_ptr->buf.y_crop_width != cm->width ||\n            new_fb_ptr->buf.y_crop_height != cm->height) {\n          if (vpx_realloc_frame_buffer(&new_fb_ptr->buf, cm->width, cm->height,\n                                       cm->subsampling_x, cm->subsampling_y,\n                                       cm->use_highbitdepth,\n                                       VP9_ENC_BORDER_IN_PIXELS,\n                                       cm->byte_alignment, NULL, NULL, NULL))\n            vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                               \"Failed to allocate frame buffer\");\n          scale_and_extend_frame(ref, &new_fb_ptr->buf, (int)cm->bit_depth,\n                                 EIGHTTAP, 0);\n          cpi->scaled_ref_idx[ref_frame - 1] = new_fb;\n          alloc_frame_mvs(cm, new_fb);\n        }\n#else\n      if (ref->y_crop_width != cm->width || ref->y_crop_height != cm->height) {\n        RefCntBuffer *new_fb_ptr = NULL;\n        int force_scaling = 0;\n        int new_fb = cpi->scaled_ref_idx[ref_frame - 1];\n        if (new_fb == INVALID_IDX) {\n          new_fb = get_free_fb(cm);\n          force_scaling = 1;\n        }\n        if (new_fb == INVALID_IDX) return;\n        new_fb_ptr = &pool->frame_bufs[new_fb];\n        if (force_scaling || new_fb_ptr->buf.y_crop_width != cm->width ||\n            new_fb_ptr->buf.y_crop_height != cm->height) {\n          if (vpx_realloc_frame_buffer(&new_fb_ptr->buf, cm->width, cm->height,\n                                       cm->subsampling_x, cm->subsampling_y,\n                                       VP9_ENC_BORDER_IN_PIXELS,\n                                       cm->byte_alignment, NULL, NULL, NULL))\n            vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                               \"Failed to allocate frame buffer\");\n          vp9_scale_and_extend_frame(ref, &new_fb_ptr->buf, EIGHTTAP, 0);\n          cpi->scaled_ref_idx[ref_frame - 1] = new_fb;\n          alloc_frame_mvs(cm, new_fb);\n        }\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        int buf_idx;\n        RefCntBuffer *buf = NULL;\n        if (cpi->oxcf.pass == 0 && !cpi->use_svc) {\n          // Check for release of scaled reference.\n          buf_idx = cpi->scaled_ref_idx[ref_frame - 1];\n          if (buf_idx != INVALID_IDX) {\n            buf = &pool->frame_bufs[buf_idx];\n            --buf->ref_count;\n            cpi->scaled_ref_idx[ref_frame - 1] = INVALID_IDX;\n          }\n        }\n        buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);\n        buf = &pool->frame_bufs[buf_idx];\n        buf->buf.y_crop_width = ref->y_crop_width;\n        buf->buf.y_crop_height = ref->y_crop_height;\n        cpi->scaled_ref_idx[ref_frame - 1] = buf_idx;\n        ++buf->ref_count;\n      }\n    } else {\n      if (cpi->oxcf.pass != 0 || cpi->use_svc)\n        cpi->scaled_ref_idx[ref_frame - 1] = INVALID_IDX;\n    }\n  }\n}\n\nstatic void release_scaled_references(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  int i;\n  if (cpi->oxcf.pass == 0 && !cpi->use_svc) {\n    // Only release scaled references under certain conditions:\n    // if reference will be updated, or if scaled reference has same resolution.\n    int refresh[3];\n    refresh[0] = (cpi->refresh_last_frame) ? 1 : 0;\n    refresh[1] = (cpi->refresh_golden_frame) ? 1 : 0;\n    refresh[2] = (cpi->refresh_alt_ref_frame) ? 1 : 0;\n    for (i = LAST_FRAME; i <= ALTREF_FRAME; ++i) {\n      const int idx = cpi->scaled_ref_idx[i - 1];\n      if (idx != INVALID_IDX) {\n        RefCntBuffer *const buf = &cm->buffer_pool->frame_bufs[idx];\n        const YV12_BUFFER_CONFIG *const ref = get_ref_frame_buffer(cpi, i);\n        if (refresh[i - 1] || (buf->buf.y_crop_width == ref->y_crop_width &&\n                               buf->buf.y_crop_height == ref->y_crop_height)) {\n          --buf->ref_count;\n          cpi->scaled_ref_idx[i - 1] = INVALID_IDX;\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < REFS_PER_FRAME; ++i) {\n      const int idx = cpi->scaled_ref_idx[i];\n      if (idx != INVALID_IDX) {\n        RefCntBuffer *const buf = &cm->buffer_pool->frame_bufs[idx];\n        --buf->ref_count;\n        cpi->scaled_ref_idx[i] = INVALID_IDX;\n      }\n    }\n  }\n}\n\nstatic void full_to_model_count(unsigned int *model_count,\n                                unsigned int *full_count) {\n  int n;\n  model_count[ZERO_TOKEN] = full_count[ZERO_TOKEN];\n  model_count[ONE_TOKEN] = full_count[ONE_TOKEN];\n  model_count[TWO_TOKEN] = full_count[TWO_TOKEN];\n  for (n = THREE_TOKEN; n < EOB_TOKEN; ++n)\n    model_count[TWO_TOKEN] += full_count[n];\n  model_count[EOB_MODEL_TOKEN] = full_count[EOB_TOKEN];\n}\n\nstatic void full_to_model_counts(vp9_coeff_count_model *model_count,\n                                 vp9_coeff_count *full_count) {\n  int i, j, k, l;\n\n  for (i = 0; i < PLANE_TYPES; ++i)\n    for (j = 0; j < REF_TYPES; ++j)\n      for (k = 0; k < COEF_BANDS; ++k)\n        for (l = 0; l < BAND_COEFF_CONTEXTS(k); ++l)\n          full_to_model_count(model_count[i][j][k][l], full_count[i][j][k][l]);\n}\n\n#if 0 && CONFIG_INTERNAL_STATS\nstatic void output_frame_level_debug_stats(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  FILE *const f = fopen(\"tmp.stt\", cm->current_video_frame ? \"a\" : \"w\");\n  int64_t recon_err;\n\n  vpx_clear_system_state();\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  if (cm->use_highbitdepth) {\n    recon_err = vpx_highbd_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n  } else {\n    recon_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n  }\n#else\n  recon_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n\n  if (cpi->twopass.total_left_stats.coded_error != 0.0) {\n    double dc_quant_devisor;\n#if CONFIG_VP9_HIGHBITDEPTH\n    switch (cm->bit_depth) {\n      case VPX_BITS_8:\n        dc_quant_devisor = 4.0;\n        break;\n      case VPX_BITS_10:\n        dc_quant_devisor = 16.0;\n        break;\n      default:\n        assert(cm->bit_depth == VPX_BITS_12);\n        dc_quant_devisor = 64.0;\n        break;\n    }\n#else\n    dc_quant_devisor = 4.0;\n#endif\n\n    if (!cm->current_video_frame) {\n      fprintf(f, \"frame, width, height, last ts, last end ts, \"\n          \"source_alt_ref_pending, source_alt_ref_active, \"\n          \"this_frame_target, projected_frame_size, \"\n          \"projected_frame_size / MBs, \"\n          \"projected_frame_size - this_frame_target, \"\n          \"vbr_bits_off_target, vbr_bits_off_target_fast, \"\n          \"twopass.extend_minq, twopass.extend_minq_fast, \"\n          \"total_target_vs_actual, \"\n          \"starting_buffer_level - bits_off_target, \"\n          \"total_actual_bits, base_qindex, q for base_qindex, \"\n          \"dc quant, q for active_worst_quality, avg_q, q for oxcf.cq_level, \"\n          \"refresh_last_frame, refresh_golden_frame, refresh_alt_ref_frame, \"\n          \"frame_type, gfu_boost, \"\n          \"twopass.bits_left, \"\n          \"twopass.total_left_stats.coded_error, \"\n          \"twopass.bits_left / (1 + twopass.total_left_stats.coded_error), \"\n          \"tot_recode_hits, recon_err, kf_boost, \"\n          \"twopass.kf_zeromotion_pct, twopass.fr_content_type, \"\n          \"filter_level, seg.aq_av_offset\\n\");\n    }\n\n    fprintf(f, \"%10u, %d, %d, %10\"PRId64\", %10\"PRId64\", %d, %d, %10d, %10d, \"\n        \"%10d, %10d, %10\"PRId64\", %10\"PRId64\", %5d, %5d, %10\"PRId64\", \"\n        \"%10\"PRId64\", %10\"PRId64\", %10d, %7.2lf, %7.2lf, %7.2lf, %7.2lf, \"\n        \"%7.2lf, %6d, %6d, %5d, %5d, %5d, %10\"PRId64\", %10.3lf, %10lf, %8u, \"\n        \"%10\"PRId64\", %10d, %10d, %10d, %10d, %10d\\n\",\n        cpi->common.current_video_frame,\n        cm->width, cm->height,\n        cpi->last_time_stamp_seen,\n        cpi->last_end_time_stamp_seen,\n        cpi->rc.source_alt_ref_pending,\n        cpi->rc.source_alt_ref_active,\n        cpi->rc.this_frame_target,\n        cpi->rc.projected_frame_size,\n        cpi->rc.projected_frame_size / cpi->common.MBs,\n        (cpi->rc.projected_frame_size - cpi->rc.this_frame_target),\n        cpi->rc.vbr_bits_off_target,\n        cpi->rc.vbr_bits_off_target_fast,\n        cpi->twopass.extend_minq,\n        cpi->twopass.extend_minq_fast,\n        cpi->rc.total_target_vs_actual,\n        (cpi->rc.starting_buffer_level - cpi->rc.bits_off_target),\n        cpi->rc.total_actual_bits, cm->base_qindex,\n        vp9_convert_qindex_to_q(cm->base_qindex, cm->bit_depth),\n        (double)vp9_dc_quant(cm->base_qindex, 0, cm->bit_depth) /\n            dc_quant_devisor,\n        vp9_convert_qindex_to_q(cpi->twopass.active_worst_quality,\n                                cm->bit_depth),\n        cpi->rc.avg_q,\n        vp9_convert_qindex_to_q(cpi->oxcf.cq_level, cm->bit_depth),\n        cpi->refresh_last_frame, cpi->refresh_golden_frame,\n        cpi->refresh_alt_ref_frame, cm->frame_type, cpi->rc.gfu_boost,\n        cpi->twopass.bits_left,\n        cpi->twopass.total_left_stats.coded_error,\n        cpi->twopass.bits_left /\n            (1 + cpi->twopass.total_left_stats.coded_error),\n        cpi->tot_recode_hits, recon_err, cpi->rc.kf_boost,\n        cpi->twopass.kf_zeromotion_pct,\n        cpi->twopass.fr_content_type,\n        cm->lf.filter_level,\n        cm->seg.aq_av_offset);\n  }\n  fclose(f);\n\n  if (0) {\n    FILE *const fmodes = fopen(\"Modes.stt\", \"a\");\n    int i;\n\n    fprintf(fmodes, \"%6d:%1d:%1d:%1d \", cpi->common.current_video_frame,\n            cm->frame_type, cpi->refresh_golden_frame,\n            cpi->refresh_alt_ref_frame);\n\n    for (i = 0; i < MAX_MODES; ++i)\n      fprintf(fmodes, \"%5d \", cpi->mode_chosen_counts[i]);\n\n    fprintf(fmodes, \"\\n\");\n\n    fclose(fmodes);\n  }\n}\n#endif\n\nstatic void set_mv_search_params(VP9_COMP *cpi) {\n  const VP9_COMMON *const cm = &cpi->common;\n  const unsigned int max_mv_def = VPXMIN(cm->width, cm->height);\n\n  // Default based on max resolution.\n  cpi->mv_step_param = vp9_init_search_range(max_mv_def);\n\n  if (cpi->sf.mv.auto_mv_step_size) {\n    if (frame_is_intra_only(cm)) {\n      // Initialize max_mv_magnitude for use in the first INTER frame\n      // after a key/intra-only frame.\n      cpi->max_mv_magnitude = max_mv_def;\n    } else {\n      if (cm->show_frame) {\n        // Allow mv_steps to correspond to twice the max mv magnitude found\n        // in the previous frame, capped by the default max_mv_magnitude based\n        // on resolution.\n        cpi->mv_step_param = vp9_init_search_range(\n            VPXMIN(max_mv_def, 2 * cpi->max_mv_magnitude));\n      }\n      cpi->max_mv_magnitude = 0;\n    }\n  }\n}\n\nstatic void set_size_independent_vars(VP9_COMP *cpi) {\n  vp9_set_speed_features_framesize_independent(cpi, cpi->oxcf.speed);\n  vp9_set_rd_speed_thresholds(cpi);\n  vp9_set_rd_speed_thresholds_sub8x8(cpi);\n  cpi->common.interp_filter = cpi->sf.default_interp_filter;\n}\n\nstatic void set_size_dependent_vars(VP9_COMP *cpi, int *q, int *bottom_index,\n                                    int *top_index) {\n  VP9_COMMON *const cm = &cpi->common;\n\n  // Setup variables that depend on the dimensions of the frame.\n  vp9_set_speed_features_framesize_dependent(cpi, cpi->oxcf.speed);\n\n  // Decide q and q bounds.\n  *q = vp9_rc_pick_q_and_bounds(cpi, bottom_index, top_index);\n\n  if (cpi->oxcf.rc_mode == VPX_CBR && cpi->rc.force_max_q) {\n    *q = cpi->rc.worst_quality;\n    cpi->rc.force_max_q = 0;\n  }\n\n  if (cpi->use_svc) {\n    cpi->svc.base_qindex[cpi->svc.spatial_layer_id] = *q;\n  }\n\n  if (!frame_is_intra_only(cm)) {\n    vp9_set_high_precision_mv(cpi, (*q) < HIGH_PRECISION_MV_QTHRESH);\n  }\n\n#if !CONFIG_REALTIME_ONLY\n  // Configure experimental use of segmentation for enhanced coding of\n  // static regions if indicated.\n  // Only allowed in the second pass of a two pass encode, as it requires\n  // lagged coding, and if the relevant speed feature flag is set.\n  if (cpi->oxcf.pass == 2 && cpi->sf.static_segmentation)\n    configure_static_seg_features(cpi);\n#endif  // !CONFIG_REALTIME_ONLY\n\n#if CONFIG_VP9_POSTPROC && !(CONFIG_VP9_TEMPORAL_DENOISING)\n  if (cpi->oxcf.noise_sensitivity > 0) {\n    int l = 0;\n    switch (cpi->oxcf.noise_sensitivity) {\n      case 1: l = 20; break;\n      case 2: l = 40; break;\n      case 3: l = 60; break;\n      case 4:\n      case 5: l = 100; break;\n      case 6: l = 150; break;\n    }\n    if (!cpi->common.postproc_state.limits) {\n      CHECK_MEM_ERROR(&cm->error, cpi->common.postproc_state.limits,\n                      vpx_calloc(cpi->un_scaled_source->y_width,\n                                 sizeof(*cpi->common.postproc_state.limits)));\n    }\n    vp9_denoise(&cpi->common, cpi->Source, cpi->Source, l,\n                cpi->common.postproc_state.limits);\n  }\n#endif  // CONFIG_VP9_POSTPROC\n}\n\nstatic void init_motion_estimation(VP9_COMP *cpi) {\n  int y_stride = cpi->scaled_source.y_stride;\n\n  if (cpi->sf.mv.search_method == NSTEP) {\n    vp9_init3smotion_compensation(&cpi->ss_cfg, y_stride);\n  } else if (cpi->sf.mv.search_method == DIAMOND) {\n    vp9_init_dsmotion_compensation(&cpi->ss_cfg, y_stride);\n  }\n}\n\nstatic void set_frame_size(VP9_COMP *cpi) {\n  int ref_frame;\n  VP9_COMMON *const cm = &cpi->common;\n  VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  MACROBLOCKD *const xd = &cpi->td.mb.e_mbd;\n\n#if !CONFIG_REALTIME_ONLY\n  if (oxcf->pass == 2 && oxcf->rc_mode == VPX_VBR &&\n      ((oxcf->resize_mode == RESIZE_FIXED && cm->current_video_frame == 0) ||\n       (oxcf->resize_mode == RESIZE_DYNAMIC && cpi->resize_pending))) {\n    calculate_coded_size(cpi, &oxcf->scaled_frame_width,\n                         &oxcf->scaled_frame_height);\n\n    // There has been a change in frame size.\n    vp9_set_size_literal(cpi, oxcf->scaled_frame_width,\n                         oxcf->scaled_frame_height);\n  }\n#endif  // !CONFIG_REALTIME_ONLY\n\n  if (oxcf->pass == 0 && oxcf->rc_mode == VPX_CBR &&\n      oxcf->resize_mode == RESIZE_DYNAMIC && cpi->resize_pending != 0) {\n    // For SVC scaled width/height will have been set (svc->resize_set=1)\n    // in get_svc_params based on the layer width/height.\n    if (!cpi->use_svc || !cpi->svc.resize_set) {\n      oxcf->scaled_frame_width =\n          (oxcf->width * cpi->resize_scale_num) / cpi->resize_scale_den;\n      oxcf->scaled_frame_height =\n          (oxcf->height * cpi->resize_scale_num) / cpi->resize_scale_den;\n      // There has been a change in frame size.\n      vp9_set_size_literal(cpi, oxcf->scaled_frame_width,\n                           oxcf->scaled_frame_height);\n    }\n\n    // TODO(agrange) Scale cpi->max_mv_magnitude if frame-size has changed.\n    set_mv_search_params(cpi);\n\n    vp9_noise_estimate_init(&cpi->noise_estimate, cm->width, cm->height);\n#if CONFIG_VP9_TEMPORAL_DENOISING\n    // Reset the denoiser on the resized frame.\n    if (cpi->oxcf.noise_sensitivity > 0) {\n      vp9_denoiser_free(&(cpi->denoiser));\n      setup_denoiser_buffer(cpi);\n      // Dynamic resize is only triggered for non-SVC, so we can force\n      // golden frame update here as temporary fix to denoiser.\n      cpi->refresh_golden_frame = 1;\n    }\n#endif\n  }\n\n  if ((oxcf->pass == 2) && !cpi->use_svc) {\n    vp9_set_target_rate(cpi);\n  }\n\n  alloc_frame_mvs(cm, cm->new_fb_idx);\n\n  // Reset the frame pointers to the current frame size.\n  if (vpx_realloc_frame_buffer(get_frame_new_buffer(cm), cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate frame buffer\");\n\n  alloc_util_frame_buffers(cpi);\n  init_motion_estimation(cpi);\n\n  for (ref_frame = LAST_FRAME; ref_frame <= ALTREF_FRAME; ++ref_frame) {\n    RefBuffer *const ref_buf = &cm->frame_refs[ref_frame - 1];\n    const int buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);\n\n    ref_buf->idx = buf_idx;\n\n    if (buf_idx != INVALID_IDX) {\n      YV12_BUFFER_CONFIG *const buf = &cm->buffer_pool->frame_bufs[buf_idx].buf;\n      ref_buf->buf = buf;\n#if CONFIG_VP9_HIGHBITDEPTH\n      vp9_setup_scale_factors_for_frame(\n          &ref_buf->sf, buf->y_crop_width, buf->y_crop_height, cm->width,\n          cm->height, (buf->flags & YV12_FLAG_HIGHBITDEPTH) ? 1 : 0);\n#else\n      vp9_setup_scale_factors_for_frame(&ref_buf->sf, buf->y_crop_width,\n                                        buf->y_crop_height, cm->width,\n                                        cm->height);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      if (vp9_is_scaled(&ref_buf->sf)) vpx_extend_frame_borders(buf);\n    } else {\n      ref_buf->buf = NULL;\n    }\n  }\n\n  set_ref_ptrs(cm, xd, LAST_FRAME, LAST_FRAME);\n}\n\nstatic void save_encode_params(VP9_COMP *cpi) {\n  int tile_idx;\n  int i, j;\n  TileDataEnc *tile_data;\n  RD_OPT *rd_opt = &cpi->rd;\n  for (i = 0; i < MAX_REF_FRAMES; i++) {\n    for (j = 0; j < REFERENCE_MODES; j++)\n      rd_opt->prediction_type_threshes_prev[i][j] =\n          rd_opt->prediction_type_threshes[i][j];\n\n    for (j = 0; j < SWITCHABLE_FILTER_CONTEXTS; j++)\n      rd_opt->filter_threshes_prev[i][j] = rd_opt->filter_threshes[i][j];\n  }\n\n  for (tile_idx = 0; tile_idx < cpi->allocated_tiles; tile_idx++) {\n    assert(cpi->tile_data);\n    tile_data = &cpi->tile_data[tile_idx];\n    vp9_copy(tile_data->thresh_freq_fact_prev, tile_data->thresh_freq_fact);\n  }\n}\n\nstatic INLINE void set_raw_source_frame(VP9_COMP *cpi) {\n#ifdef ENABLE_KF_DENOISE\n  if (is_spatial_denoise_enabled(cpi)) {\n    cpi->raw_source_frame = vp9_scale_if_required(\n        cm, &cpi->raw_unscaled_source, &cpi->raw_scaled_source,\n        (oxcf->pass == 0), EIGHTTAP, 0);\n  } else {\n    cpi->raw_source_frame = cpi->Source;\n  }\n#else\n  cpi->raw_source_frame = cpi->Source;\n#endif\n}\n\nstatic int encode_without_recode_loop(VP9_COMP *cpi, size_t *size,\n                                      uint8_t *dest) {\n  VP9_COMMON *const cm = &cpi->common;\n  SVC *const svc = &cpi->svc;\n  int q = 0, bottom_index = 0, top_index = 0;\n  int no_drop_scene_change = 0;\n  const INTERP_FILTER filter_scaler =\n      (is_one_pass_svc(cpi))\n          ? svc->downsample_filter_type[svc->spatial_layer_id]\n          : EIGHTTAP;\n  const int phase_scaler =\n      (is_one_pass_svc(cpi))\n          ? svc->downsample_filter_phase[svc->spatial_layer_id]\n          : 0;\n\n  if (cm->show_existing_frame) {\n    cpi->rc.this_frame_target = 0;\n    if (is_psnr_calc_enabled(cpi)) set_raw_source_frame(cpi);\n    return 1;\n  }\n\n  svc->time_stamp_prev[svc->spatial_layer_id] = svc->time_stamp_superframe;\n\n  // Flag to check if its valid to compute the source sad (used for\n  // scene detection and for superblock content state in CBR mode).\n  // The flag may get reset below based on SVC or resizing state.\n  cpi->compute_source_sad_onepass = cpi->oxcf.mode == REALTIME;\n\n  vpx_clear_system_state();\n\n  set_frame_size(cpi);\n\n  if (is_one_pass_svc(cpi) &&\n      cpi->un_scaled_source->y_width == cm->width << 2 &&\n      cpi->un_scaled_source->y_height == cm->height << 2 &&\n      svc->scaled_temp.y_width == cm->width << 1 &&\n      svc->scaled_temp.y_height == cm->height << 1) {\n    // For svc, if it is a 1/4x1/4 downscaling, do a two-stage scaling to take\n    // advantage of the 1:2 optimized scaler. In the process, the 1/2x1/2\n    // result will be saved in scaled_temp and might be used later.\n    const INTERP_FILTER filter_scaler2 = svc->downsample_filter_type[1];\n    const int phase_scaler2 = svc->downsample_filter_phase[1];\n    cpi->Source = vp9_svc_twostage_scale(\n        cm, cpi->un_scaled_source, &cpi->scaled_source, &svc->scaled_temp,\n        filter_scaler, phase_scaler, filter_scaler2, phase_scaler2);\n    svc->scaled_one_half = 1;\n  } else if (is_one_pass_svc(cpi) &&\n             cpi->un_scaled_source->y_width == cm->width << 1 &&\n             cpi->un_scaled_source->y_height == cm->height << 1 &&\n             svc->scaled_one_half) {\n    // If the spatial layer is 1/2x1/2 and the scaling is already done in the\n    // two-stage scaling, use the result directly.\n    cpi->Source = &svc->scaled_temp;\n    svc->scaled_one_half = 0;\n  } else {\n    cpi->Source = vp9_scale_if_required(\n        cm, cpi->un_scaled_source, &cpi->scaled_source, (cpi->oxcf.pass == 0),\n        filter_scaler, phase_scaler);\n  }\n#ifdef OUTPUT_YUV_SVC_SRC\n  // Write out at most 3 spatial layers.\n  if (is_one_pass_svc(cpi) && svc->spatial_layer_id < 3) {\n    vpx_write_yuv_frame(yuv_svc_src[svc->spatial_layer_id], cpi->Source);\n  }\n#endif\n  // Unfiltered raw source used in metrics calculation if the source\n  // has been filtered.\n  if (is_psnr_calc_enabled(cpi)) {\n#ifdef ENABLE_KF_DENOISE\n    if (is_spatial_denoise_enabled(cpi)) {\n      cpi->raw_source_frame = vp9_scale_if_required(\n          cm, &cpi->raw_unscaled_source, &cpi->raw_scaled_source,\n          (cpi->oxcf.pass == 0), EIGHTTAP, phase_scaler);\n    } else {\n      cpi->raw_source_frame = cpi->Source;\n    }\n#else\n    cpi->raw_source_frame = cpi->Source;\n#endif\n  }\n\n  if ((cpi->use_svc &&\n       (svc->spatial_layer_id < svc->number_spatial_layers - 1 ||\n        svc->temporal_layer_id < svc->number_temporal_layers - 1 ||\n        svc->current_superframe < 1)) ||\n      cpi->resize_pending || cpi->resize_state || cpi->external_resize ||\n      cpi->resize_state != ORIG) {\n    cpi->compute_source_sad_onepass = 0;\n    if (cpi->content_state_sb_fd != NULL)\n      memset(cpi->content_state_sb_fd, 0,\n             (cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1) *\n                 sizeof(*cpi->content_state_sb_fd));\n  }\n\n  // Avoid scaling last_source unless its needed.\n  // Last source is needed if avg_source_sad() is used, or if\n  // partition_search_type == SOURCE_VAR_BASED_PARTITION, or if noise\n  // estimation is enabled.\n  if (cpi->unscaled_last_source != NULL &&\n      (cpi->oxcf.content == VP9E_CONTENT_SCREEN ||\n       (cpi->oxcf.pass == 0 && cpi->oxcf.rc_mode == VPX_VBR &&\n        cpi->oxcf.mode == REALTIME && cpi->oxcf.speed >= 5) ||\n       cpi->sf.partition_search_type == SOURCE_VAR_BASED_PARTITION ||\n       (cpi->noise_estimate.enabled && !cpi->oxcf.noise_sensitivity) ||\n       cpi->compute_source_sad_onepass))\n    cpi->Last_Source = vp9_scale_if_required(\n        cm, cpi->unscaled_last_source, &cpi->scaled_last_source,\n        (cpi->oxcf.pass == 0), EIGHTTAP, 0);\n\n  if (cpi->Last_Source == NULL ||\n      cpi->Last_Source->y_width != cpi->Source->y_width ||\n      cpi->Last_Source->y_height != cpi->Source->y_height)\n    cpi->compute_source_sad_onepass = 0;\n\n  if (frame_is_intra_only(cm) || cpi->resize_pending != 0) {\n    memset(cpi->consec_zero_mv, 0,\n           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n  }\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity > 0 && cpi->use_svc)\n    vp9_denoiser_reset_on_first_frame(cpi);\n#endif\n\n  // Scene detection is always used for VBR mode or screen-content case.\n  // For other cases (e.g., CBR mode) use it for 5 <= speed < 8 for now\n  // (need to check encoding time cost for doing this for speed 8).\n  cpi->rc.high_source_sad = 0;\n  cpi->rc.hybrid_intra_scene_change = 0;\n  cpi->rc.re_encode_maxq_scene_change = 0;\n  if (cm->show_frame && cpi->oxcf.mode == REALTIME &&\n      (cpi->oxcf.rc_mode == VPX_VBR ||\n       cpi->oxcf.content == VP9E_CONTENT_SCREEN ||\n       (cpi->oxcf.speed >= 5 && cpi->oxcf.speed < 8)))\n    vp9_scene_detection_onepass(cpi);\n\n  if (svc->spatial_layer_id == svc->first_spatial_layer_to_encode) {\n    svc->high_source_sad_superframe = cpi->rc.high_source_sad;\n    svc->high_num_blocks_with_motion = cpi->rc.high_num_blocks_with_motion;\n    // On scene change reset temporal layer pattern to TL0.\n    // Note that if the base/lower spatial layers are skipped: instead of\n    // inserting base layer here, we force max-q for the next superframe\n    // with lower spatial layers: this is done in vp9_encodedframe_overshoot()\n    // when max-q is decided for the current layer.\n    // Only do this reset for bypass/flexible mode.\n    if (svc->high_source_sad_superframe && svc->temporal_layer_id > 0 &&\n        svc->temporal_layering_mode == VP9E_TEMPORAL_LAYERING_MODE_BYPASS) {\n      // rc->high_source_sad will get reset so copy it to restore it.\n      int tmp_high_source_sad = cpi->rc.high_source_sad;\n      vp9_svc_reset_temporal_layers(cpi, cm->frame_type == KEY_FRAME);\n      cpi->rc.high_source_sad = tmp_high_source_sad;\n    }\n  }\n\n  vp9_update_noise_estimate(cpi);\n\n  // For 1 pass CBR, check if we are dropping this frame.\n  // Never drop on key frame, if base layer is key for svc,\n  // on scene change, or if superframe has layer sync.\n  if ((cpi->rc.high_source_sad || svc->high_source_sad_superframe) &&\n      !(cpi->rc.use_post_encode_drop && svc->last_layer_dropped[0]))\n    no_drop_scene_change = 1;\n  if (cpi->oxcf.pass == 0 && cpi->oxcf.rc_mode == VPX_CBR &&\n      !frame_is_intra_only(cm) && !no_drop_scene_change &&\n      !svc->superframe_has_layer_sync &&\n      (!cpi->use_svc ||\n       !svc->layer_context[svc->temporal_layer_id].is_key_frame)) {\n    if (vp9_rc_drop_frame(cpi)) return 0;\n  }\n\n  // For 1 pass SVC, only ZEROMV is allowed for spatial reference frame\n  // when svc->force_zero_mode_spatial_ref = 1. Under those conditions we can\n  // avoid this frame-level upsampling (for non intra_only frames).\n  // For SVC single_layer mode, dynamic resize is allowed and we need to\n  // scale references for this case.\n  if (frame_is_intra_only(cm) == 0 &&\n      ((svc->single_layer_svc && cpi->oxcf.resize_mode == RESIZE_DYNAMIC) ||\n       !(is_one_pass_svc(cpi) && svc->force_zero_mode_spatial_ref))) {\n    vp9_scale_references(cpi);\n  }\n\n  set_size_independent_vars(cpi);\n  set_size_dependent_vars(cpi, &q, &bottom_index, &top_index);\n\n  // search method and step parameter might be changed in speed settings.\n  init_motion_estimation(cpi);\n\n  if (cpi->sf.copy_partition_flag) alloc_copy_partition_data(cpi);\n\n  if (cpi->sf.svc_use_lowres_part &&\n      svc->spatial_layer_id == svc->number_spatial_layers - 2) {\n    if (svc->prev_partition_svc == NULL) {\n      CHECK_MEM_ERROR(\n          &cm->error, svc->prev_partition_svc,\n          (BLOCK_SIZE *)vpx_calloc(cm->mi_stride * cm->mi_rows,\n                                   sizeof(*svc->prev_partition_svc)));\n    }\n  }\n\n  // TODO(jianj): Look into issue of skin detection with high bitdepth.\n  if (cm->bit_depth == 8 && cpi->oxcf.speed >= 5 && cpi->oxcf.pass == 0 &&\n      cpi->oxcf.rc_mode == VPX_CBR &&\n      cpi->oxcf.content != VP9E_CONTENT_SCREEN &&\n      cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {\n    cpi->use_skin_detection = 1;\n  }\n\n  // Enable post encode frame dropping for CBR on non key frame, when\n  // ext_use_post_encode_drop is specified by user.\n  cpi->rc.use_post_encode_drop = cpi->rc.ext_use_post_encode_drop &&\n                                 cpi->oxcf.rc_mode == VPX_CBR &&\n                                 cm->frame_type != KEY_FRAME;\n\n  vp9_set_quantizer(cpi, q);\n  vp9_set_variance_partition_thresholds(cpi, q, 0);\n\n  setup_frame(cpi);\n\n  suppress_active_map(cpi);\n\n  if (cpi->use_svc) {\n    // On non-zero spatial layer, check for disabling inter-layer\n    // prediction.\n    if (svc->spatial_layer_id > 0) vp9_svc_constrain_inter_layer_pred(cpi);\n    vp9_svc_assert_constraints_pattern(cpi);\n  }\n\n  if (cpi->rc.last_post_encode_dropped_scene_change) {\n    cpi->rc.high_source_sad = 1;\n    svc->high_source_sad_superframe = 1;\n    // For now disable use_source_sad since Last_Source will not be the previous\n    // encoded but the dropped one.\n    cpi->sf.use_source_sad = 0;\n    cpi->rc.last_post_encode_dropped_scene_change = 0;\n  }\n  // Check if this high_source_sad (scene/slide change) frame should be\n  // encoded at high/max QP, and if so, set the q and adjust some rate\n  // control parameters.\n  if (cpi->sf.overshoot_detection_cbr_rt == FAST_DETECTION_MAXQ &&\n      (cpi->rc.high_source_sad ||\n       (cpi->use_svc && svc->high_source_sad_superframe))) {\n    if (vp9_encodedframe_overshoot(cpi, -1, &q)) {\n      vp9_set_quantizer(cpi, q);\n      vp9_set_variance_partition_thresholds(cpi, q, 0);\n    }\n  }\n\n#if !CONFIG_REALTIME_ONLY\n  // Variance adaptive and in frame q adjustment experiments are mutually\n  // exclusive.\n  if (cpi->oxcf.aq_mode == VARIANCE_AQ) {\n    vp9_vaq_frame_setup(cpi);\n  } else if (cpi->oxcf.aq_mode == EQUATOR360_AQ) {\n    vp9_360aq_frame_setup(cpi);\n  } else if (cpi->oxcf.aq_mode == COMPLEXITY_AQ) {\n    vp9_setup_in_frame_q_adj(cpi);\n  } else if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ) {\n    // it may be pretty bad for rate-control,\n    // and I should handle it somehow\n    vp9_alt_ref_aq_setup_map(cpi->alt_ref_aq, cpi);\n  } else {\n#endif\n    // If ROI is enabled and skip feature is used for segmentation, apply cyclic\n    // refresh but not apply ROI for skip for the first 20 frames (defined by\n    // FRAMES_NO_SKIPPING_AFTER_KEY) after key frame to improve quality.\n    if (cpi->roi.enabled && !frame_is_intra_only(cm)) {\n      if (cpi->roi.skip[BACKGROUND_SEG_SKIP_ID]) {\n        if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n          vp9_cyclic_refresh_setup(cpi);\n        if (cpi->rc.frames_since_key > FRAMES_NO_SKIPPING_AFTER_KEY)\n          apply_roi_map(cpi);\n      } else {\n        apply_roi_map(cpi);\n      }\n    } else if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {\n      vp9_cyclic_refresh_setup(cpi);\n    }\n\n#if !CONFIG_REALTIME_ONLY\n  }\n#endif\n\n  apply_active_map(cpi);\n\n  vp9_encode_frame(cpi);\n\n  // Check if we should re-encode this frame at high Q because of high\n  // overshoot based on the encoded frame size. Only for frames where\n  // high temporal-source SAD is detected.\n  // For SVC: all spatial layers are checked for re-encoding.\n  if (cpi->sf.overshoot_detection_cbr_rt == RE_ENCODE_MAXQ &&\n      (cpi->rc.high_source_sad ||\n       (cpi->use_svc && svc->high_source_sad_superframe))) {\n    int frame_size = 0;\n    // Get an estimate of the encoded frame size.\n    save_coding_context(cpi);\n    vp9_pack_bitstream(cpi, dest, size);\n    restore_coding_context(cpi);\n    frame_size = (int)(*size) << 3;\n    // Check if encoded frame will overshoot too much, and if so, set the q and\n    // adjust some rate control parameters, and return to re-encode the frame.\n    if (vp9_encodedframe_overshoot(cpi, frame_size, &q)) {\n      vpx_clear_system_state();\n      vp9_set_quantizer(cpi, q);\n      vp9_set_variance_partition_thresholds(cpi, q, 0);\n      suppress_active_map(cpi);\n      // Turn-off cyclic refresh for re-encoded frame.\n      if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {\n        CYCLIC_REFRESH *const cr = cpi->cyclic_refresh;\n        unsigned char *const seg_map = cpi->segmentation_map;\n        memset(seg_map, 0, cm->mi_rows * cm->mi_cols);\n        memset(cr->last_coded_q_map, MAXQ,\n               cm->mi_rows * cm->mi_cols * sizeof(*cr->last_coded_q_map));\n        cr->sb_index = 0;\n        vp9_disable_segmentation(&cm->seg);\n      }\n      apply_active_map(cpi);\n      vp9_encode_frame(cpi);\n    }\n  }\n\n  // Update some stats from cyclic refresh, and check for golden frame update.\n  if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ && cm->seg.enabled &&\n      !frame_is_intra_only(cm) && cpi->cyclic_refresh->content_mode)\n    vp9_cyclic_refresh_postencode(cpi);\n\n  // Update the skip mb flag probabilities based on the distribution\n  // seen in the last encoder iteration.\n  // update_base_skip_probs(cpi);\n  vpx_clear_system_state();\n  return 1;\n}\n\nstatic int get_ref_frame_flags(const VP9_COMP *cpi) {\n  const int *const map = cpi->common.ref_frame_map;\n  const int gold_is_last = map[cpi->gld_fb_idx] == map[cpi->lst_fb_idx];\n  const int alt_is_last = map[cpi->alt_fb_idx] == map[cpi->lst_fb_idx];\n  const int gold_is_alt = map[cpi->gld_fb_idx] == map[cpi->alt_fb_idx];\n  int flags = VP9_ALT_FLAG | VP9_GOLD_FLAG | VP9_LAST_FLAG;\n\n  if (gold_is_last) flags &= ~VP9_GOLD_FLAG;\n\n  if (cpi->rc.frames_till_gf_update_due == INT_MAX &&\n      (cpi->svc.number_temporal_layers == 1 &&\n       cpi->svc.number_spatial_layers == 1))\n    flags &= ~VP9_GOLD_FLAG;\n\n  if (alt_is_last) flags &= ~VP9_ALT_FLAG;\n\n  if (gold_is_alt) flags &= ~VP9_ALT_FLAG;\n\n  return flags;\n}\n\n#if !CONFIG_REALTIME_ONLY\n#define MAX_QSTEP_ADJ 4\nstatic int get_qstep_adj(int rate_excess, int rate_limit) {\n  int qstep =\n      rate_limit ? ((rate_excess + rate_limit / 2) / rate_limit) : INT_MAX;\n  return VPXMIN(qstep, MAX_QSTEP_ADJ);\n}\n\n#if CONFIG_RATE_CTRL\nstatic void init_rq_history(RATE_QINDEX_HISTORY *rq_history) {\n  rq_history->recode_count = 0;\n  rq_history->q_index_high = 255;\n  rq_history->q_index_low = 0;\n}\n\nstatic void update_rq_history(RATE_QINDEX_HISTORY *rq_history, int target_bits,\n                              int actual_bits, int q_index) {\n  rq_history->q_index_history[rq_history->recode_count] = q_index;\n  rq_history->rate_history[rq_history->recode_count] = actual_bits;\n  if (actual_bits <= target_bits) {\n    rq_history->q_index_high = q_index;\n  }\n  if (actual_bits >= target_bits) {\n    rq_history->q_index_low = q_index;\n  }\n  rq_history->recode_count += 1;\n}\n\nstatic int guess_q_index_from_model(const RATE_QSTEP_MODEL *rq_model,\n                                    int target_bits) {\n  // The model predicts bits as follows.\n  // target_bits = bias - ratio * log2(q_step)\n  // Given the target_bits, we compute the q_step as follows.\n  double q_step;\n  assert(rq_model->ratio > 0);\n  q_step = pow(2.0, (rq_model->bias - target_bits) / rq_model->ratio);\n  // TODO(angiebird): Make this function support highbitdepth.\n  return vp9_convert_q_to_qindex(q_step, VPX_BITS_8);\n}\n\nstatic int guess_q_index_linear(int prev_q_index, int target_bits,\n                                int actual_bits, int gap) {\n  int q_index = prev_q_index;\n  if (actual_bits < target_bits) {\n    q_index -= gap;\n    q_index = VPXMAX(q_index, 0);\n  } else {\n    q_index += gap;\n    q_index = VPXMIN(q_index, 255);\n  }\n  return q_index;\n}\n\nstatic double get_bits_percent_diff(int target_bits, int actual_bits) {\n  double diff;\n  target_bits = VPXMAX(target_bits, 1);\n  diff = abs(target_bits - actual_bits) * 1. / target_bits;\n  return diff * 100;\n}\n\nstatic int rq_model_predict_q_index(const RATE_QSTEP_MODEL *rq_model,\n                                    const RATE_QINDEX_HISTORY *rq_history,\n                                    int target_bits) {\n  int q_index = 128;\n  if (rq_history->recode_count > 0) {\n    const int actual_bits =\n        rq_history->rate_history[rq_history->recode_count - 1];\n    const int prev_q_index =\n        rq_history->q_index_history[rq_history->recode_count - 1];\n    const double percent_diff = get_bits_percent_diff(target_bits, actual_bits);\n    if (percent_diff > 50) {\n      // Binary search.\n      // When the actual_bits and target_bits are far apart, binary search\n      // q_index is faster.\n      q_index = (rq_history->q_index_low + rq_history->q_index_high) / 2;\n    } else {\n      if (rq_model->ready) {\n        q_index = guess_q_index_from_model(rq_model, target_bits);\n      } else {\n        // TODO(angiebird): Find a better way to set the gap.\n        q_index =\n            guess_q_index_linear(prev_q_index, target_bits, actual_bits, 20);\n      }\n    }\n  } else {\n    if (rq_model->ready) {\n      q_index = guess_q_index_from_model(rq_model, target_bits);\n    }\n  }\n\n  assert(rq_history->q_index_low <= rq_history->q_index_high);\n  if (q_index <= rq_history->q_index_low) {\n    q_index = rq_history->q_index_low + 1;\n  }\n  if (q_index >= rq_history->q_index_high) {\n    q_index = rq_history->q_index_high - 1;\n  }\n  return q_index;\n}\n\nstatic void rq_model_update(const RATE_QINDEX_HISTORY *rq_history,\n                            int target_bits, RATE_QSTEP_MODEL *rq_model) {\n  const int recode_count = rq_history->recode_count;\n  const double delta = 0.00001;\n  if (recode_count >= 2) {\n    const int q_index1 = rq_history->q_index_history[recode_count - 2];\n    const int q_index2 = rq_history->q_index_history[recode_count - 1];\n    const int r1 = rq_history->rate_history[recode_count - 2];\n    const int r2 = rq_history->rate_history[recode_count - 1];\n    int valid = 0;\n    // lower q_index should yield higher bit rate\n    if (q_index1 < q_index2) {\n      valid = r1 > r2;\n    } else if (q_index1 > q_index2) {\n      valid = r1 < r2;\n    }\n    // Only update the model when the q_index and rate behave normally.\n    if (valid) {\n      // Fit the ratio and bias of rq_model based on last two recode histories.\n      const double s1 = vp9_convert_qindex_to_q(q_index1, VPX_BITS_8);\n      const double s2 = vp9_convert_qindex_to_q(q_index2, VPX_BITS_8);\n      if (fabs(log2(s1) - log2(s2)) > delta) {\n        rq_model->ratio = (r2 - r1) / (log2(s1) - log2(s2));\n        rq_model->bias = r1 + (rq_model->ratio) * log2(s1);\n        if (rq_model->ratio > delta && rq_model->bias > delta) {\n          rq_model->ready = 1;\n        }\n      }\n    }\n  } else if (recode_count == 1) {\n    if (rq_model->ready) {\n      // Update the ratio only when the initial model exists and we only have\n      // one recode history.\n      const int prev_q = rq_history->q_index_history[recode_count - 1];\n      const double prev_q_step = vp9_convert_qindex_to_q(prev_q, VPX_BITS_8);\n      if (fabs(log2(prev_q_step)) > delta) {\n        const int actual_bits = rq_history->rate_history[recode_count - 1];\n        rq_model->ratio =\n            rq_model->ratio + (target_bits - actual_bits) / log2(prev_q_step);\n      }\n    }\n  }\n}\n#endif  // CONFIG_RATE_CTRL\n\nstatic void encode_with_recode_loop(VP9_COMP *cpi, size_t *size, uint8_t *dest\n#if CONFIG_RATE_CTRL\n                                    ,\n                                    RATE_QINDEX_HISTORY *rq_history\n#endif  // CONFIG_RATE_CTRL\n) {\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int bottom_index, top_index;\n  int loop_count = 0;\n  int loop_at_this_size = 0;\n  int loop = 0;\n  int overshoot_seen = 0;\n  int undershoot_seen = 0;\n  int frame_over_shoot_limit;\n  int frame_under_shoot_limit;\n  int q = 0, q_low = 0, q_high = 0;\n  int enable_acl;\n#ifdef AGGRESSIVE_VBR\n  int qrange_adj = 1;\n#endif\n\n  // A flag which indicates whether we are recoding the current frame\n  // when the current frame size is larger than the max frame size in the\n  // external rate control model.\n  // This flag doesn't have any impact when external rate control is not used.\n  int ext_rc_recode = 0;\n  // Maximal frame size allowed by the external rate control.\n  // case: 0, we ignore the max frame size limit, and encode with the qindex\n  // passed in by the external rate control model.\n  // If the external qindex is VPX_DEFAULT_Q, libvpx will pick a qindex\n  // and may recode if undershoot/overshoot is seen.\n  // If the external qindex is not VPX_DEFAULT_Q, we force no recode.\n  // case: -1, we take libvpx's decision for the max frame size, as well as\n  // the recode decision.\n  // Otherwise: if a specific size is given, libvpx's recode decision\n  // will respect the given size.\n  int ext_rc_max_frame_size = 0;\n  // Use VP9's decision of qindex. This flag is in use only in external rate\n  // control model to help determine whether to recode when\n  // |ext_rc_max_frame_size| is 0.\n  int ext_rc_use_default_q = 1;\n  const int orig_rc_max_frame_bandwidth = rc->max_frame_bandwidth;\n\n#if CONFIG_RATE_CTRL\n  RATE_QSTEP_MODEL *rq_model;\n  {\n    const FRAME_UPDATE_TYPE update_type =\n        cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index];\n    const ENCODE_FRAME_TYPE frame_type = get_encode_frame_type(update_type);\n    rq_model = &cpi->rq_model[frame_type];\n  }\n  init_rq_history(rq_history);\n#endif  // CONFIG_RATE_CTRL\n\n  if (cm->show_existing_frame) {\n    rc->this_frame_target = 0;\n    if (is_psnr_calc_enabled(cpi)) set_raw_source_frame(cpi);\n    return;\n  }\n\n  set_size_independent_vars(cpi);\n\n  enable_acl = cpi->sf.allow_acl ? (cm->frame_type == KEY_FRAME) ||\n                                       (cpi->twopass.gf_group.index == 1)\n                                 : 0;\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  printf(\"\\n Encoding a frame: \\n\");\n#endif\n  do {\n    vpx_clear_system_state();\n\n    set_frame_size(cpi);\n\n    if (loop_count == 0 || cpi->resize_pending != 0) {\n      set_size_dependent_vars(cpi, &q, &bottom_index, &top_index);\n\n#ifdef AGGRESSIVE_VBR\n      if (two_pass_first_group_inter(cpi)) {\n        // Adjustment limits for min and max q\n        qrange_adj = VPXMAX(1, (top_index - bottom_index) / 2);\n\n        bottom_index =\n            VPXMAX(bottom_index - qrange_adj / 2, oxcf->best_allowed_q);\n        top_index = VPXMIN(oxcf->worst_allowed_q, top_index + qrange_adj / 2);\n      }\n#endif\n      // TODO(agrange) Scale cpi->max_mv_magnitude if frame-size has changed.\n      set_mv_search_params(cpi);\n\n      // Reset the loop state for new frame size.\n      overshoot_seen = 0;\n      undershoot_seen = 0;\n\n      // Reconfiguration for change in frame size has concluded.\n      cpi->resize_pending = 0;\n\n      q_low = bottom_index;\n      q_high = top_index;\n\n      loop_at_this_size = 0;\n    }\n\n    // Decide frame size bounds first time through.\n    if (loop_count == 0) {\n      vp9_rc_compute_frame_size_bounds(cpi, rc->this_frame_target,\n                                       &frame_under_shoot_limit,\n                                       &frame_over_shoot_limit);\n    }\n\n    cpi->Source =\n        vp9_scale_if_required(cm, cpi->un_scaled_source, &cpi->scaled_source,\n                              (oxcf->pass == 0), EIGHTTAP, 0);\n\n    // Unfiltered raw source used in metrics calculation if the source\n    // has been filtered.\n    if (is_psnr_calc_enabled(cpi)) {\n#ifdef ENABLE_KF_DENOISE\n      if (is_spatial_denoise_enabled(cpi)) {\n        cpi->raw_source_frame = vp9_scale_if_required(\n            cm, &cpi->raw_unscaled_source, &cpi->raw_scaled_source,\n            (oxcf->pass == 0), EIGHTTAP, 0);\n      } else {\n        cpi->raw_source_frame = cpi->Source;\n      }\n#else\n      cpi->raw_source_frame = cpi->Source;\n#endif\n    }\n\n    if (cpi->unscaled_last_source != NULL)\n      cpi->Last_Source = vp9_scale_if_required(cm, cpi->unscaled_last_source,\n                                               &cpi->scaled_last_source,\n                                               (oxcf->pass == 0), EIGHTTAP, 0);\n\n    if (frame_is_intra_only(cm) == 0) {\n      if (loop_count > 0) {\n        release_scaled_references(cpi);\n      }\n      vp9_scale_references(cpi);\n    }\n\n#if CONFIG_RATE_CTRL\n    // TODO(angiebird): This is a hack for making sure the encoder use the\n    // external_quantize_index exactly. Avoid this kind of hack later.\n    if (cpi->oxcf.use_simple_encode_api) {\n      if (cpi->encode_command.use_external_target_frame_bits) {\n        q = rq_model_predict_q_index(rq_model, rq_history,\n                                     rc->this_frame_target);\n      }\n      if (cpi->encode_command.use_external_quantize_index) {\n        q = cpi->encode_command.external_quantize_index;\n      }\n    }\n#endif  // CONFIG_RATE_CTRL\n    if (cpi->ext_ratectrl.ready && !ext_rc_recode &&\n        (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_QP) != 0 &&\n        cpi->ext_ratectrl.funcs.get_encodeframe_decision != NULL) {\n      vpx_codec_err_t codec_status;\n      const GF_GROUP *gf_group = &cpi->twopass.gf_group;\n      vpx_rc_encodeframe_decision_t encode_frame_decision;\n      FRAME_UPDATE_TYPE update_type = gf_group->update_type[gf_group->index];\n      const int ref_frame_flags = get_ref_frame_flags(cpi);\n      RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];\n      const RefCntBuffer *curr_frame_buf =\n          get_ref_cnt_buffer(cm, cm->new_fb_idx);\n      // index 0 of a gf group is always KEY/OVERLAY/GOLDEN.\n      // index 1 refers to the first encoding frame in a gf group.\n      // Therefore if it is ARF_UPDATE, it means this gf group uses alt ref.\n      // See function define_gf_group_structure().\n      const int use_alt_ref = gf_group->update_type[1] == ARF_UPDATE;\n      get_ref_frame_bufs(cpi, ref_frame_bufs);\n      codec_status = vp9_extrc_get_encodeframe_decision(\n          &cpi->ext_ratectrl, curr_frame_buf->frame_index,\n          cm->current_frame_coding_index, gf_group->index, update_type,\n          gf_group->gf_group_size, use_alt_ref, ref_frame_bufs, ref_frame_flags,\n          &encode_frame_decision);\n      if (codec_status != VPX_CODEC_OK) {\n        vpx_internal_error(&cm->error, codec_status,\n                           \"vp9_extrc_get_encodeframe_decision() failed\");\n      }\n      // If the external model recommends a reserved value, we use\n      // libvpx's default q.\n      if (encode_frame_decision.q_index != VPX_DEFAULT_Q) {\n        q = encode_frame_decision.q_index;\n        ext_rc_use_default_q = 0;\n      }\n      ext_rc_max_frame_size = encode_frame_decision.max_frame_size;\n    }\n\n    vp9_set_quantizer(cpi, q);\n\n    if (loop_count == 0) setup_frame(cpi);\n\n    // Variance adaptive and in frame q adjustment experiments are mutually\n    // exclusive.\n    if (oxcf->aq_mode == VARIANCE_AQ) {\n      vp9_vaq_frame_setup(cpi);\n    } else if (oxcf->aq_mode == EQUATOR360_AQ) {\n      vp9_360aq_frame_setup(cpi);\n    } else if (oxcf->aq_mode == COMPLEXITY_AQ) {\n      vp9_setup_in_frame_q_adj(cpi);\n    } else if (oxcf->aq_mode == LOOKAHEAD_AQ) {\n      vp9_alt_ref_aq_setup_map(cpi->alt_ref_aq, cpi);\n    } else if (oxcf->aq_mode == PSNR_AQ) {\n      vp9_psnr_aq_mode_setup(&cm->seg);\n    }\n\n    vp9_encode_frame(cpi);\n\n    // Update the skip mb flag probabilities based on the distribution\n    // seen in the last encoder iteration.\n    // update_base_skip_probs(cpi);\n\n    vpx_clear_system_state();\n\n    // Dummy pack of the bitstream using up to date stats to get an\n    // accurate estimate of output frame size to determine if we need\n    // to recode.\n    if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF) {\n      save_coding_context(cpi);\n      if (!cpi->sf.use_nonrd_pick_mode) vp9_pack_bitstream(cpi, dest, size);\n\n      rc->projected_frame_size = (int)(*size) << 3;\n\n      if (frame_over_shoot_limit == 0) frame_over_shoot_limit = 1;\n    }\n\n    if (cpi->ext_ratectrl.ready &&\n        (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_QP) != 0) {\n      // In general, for the external rate control, we take the qindex provided\n      // as input and encode the frame with this qindex faithfully. However,\n      // in some extreme scenarios, the provided qindex leads to a massive\n      // overshoot of frame size. In this case, we fall back to VP9's decision\n      // to pick a new qindex and recode the frame. We return the new qindex\n      // through the API to the external model.\n      if (ext_rc_max_frame_size == 0) {\n        if (!ext_rc_use_default_q) break;\n      } else if (ext_rc_max_frame_size == -1) {\n        // Do nothing, fall back to libvpx's recode decision.\n      } else {\n        // Change the max frame size, used in libvpx's recode decision.\n        rc->max_frame_bandwidth = ext_rc_max_frame_size;\n      }\n      ext_rc_recode = 1;\n    }\n#if CONFIG_RATE_CTRL\n    if (cpi->oxcf.use_simple_encode_api) {\n      // This part needs to be after save_coding_context() because\n      // restore_coding_context will be called in the end of this function.\n      // TODO(angiebird): This is a hack for making sure the encoder use the\n      // external_quantize_index exactly. Avoid this kind of hack later.\n      if (cpi->encode_command.use_external_quantize_index) {\n        break;\n      }\n\n      if (cpi->encode_command.use_external_target_frame_bits) {\n        const double percent_diff = get_bits_percent_diff(\n            rc->this_frame_target, rc->projected_frame_size);\n        update_rq_history(rq_history, rc->this_frame_target,\n                          rc->projected_frame_size, q);\n        loop_count += 1;\n\n        rq_model_update(rq_history, rc->this_frame_target, rq_model);\n\n        // Check if we hit the target bitrate.\n        if (percent_diff <=\n                cpi->encode_command.target_frame_bits_error_percent ||\n            rq_history->recode_count >= RATE_CTRL_MAX_RECODE_NUM ||\n            rq_history->q_index_low >= rq_history->q_index_high) {\n          break;\n        }\n\n        loop = 1;\n        restore_coding_context(cpi);\n        continue;\n      }\n    }\n#endif  // CONFIG_RATE_CTRL\n\n    if (oxcf->rc_mode == VPX_Q) {\n      loop = 0;\n    } else {\n      if ((cm->frame_type == KEY_FRAME) && rc->this_key_frame_forced &&\n          (rc->projected_frame_size < rc->max_frame_bandwidth)) {\n        int last_q = q;\n        int64_t kf_err;\n\n        int64_t high_err_target = cpi->ambient_err;\n        int64_t low_err_target = cpi->ambient_err >> 1;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n        if (cm->use_highbitdepth) {\n          kf_err = vpx_highbd_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n        } else {\n          kf_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n        }\n#else\n        kf_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n        // Prevent possible divide by zero error below for perfect KF\n        kf_err += !kf_err;\n\n        // The key frame is not good enough or we can afford\n        // to make it better without undue risk of popping.\n        if ((kf_err > high_err_target &&\n             rc->projected_frame_size <= frame_over_shoot_limit) ||\n            (kf_err > low_err_target &&\n             rc->projected_frame_size <= frame_under_shoot_limit)) {\n          // Lower q_high\n          q_high = q > q_low ? q - 1 : q_low;\n\n          // Adjust Q\n          q = (int)((q * high_err_target) / kf_err);\n          q = VPXMIN(q, (q_high + q_low) >> 1);\n        } else if (kf_err < low_err_target &&\n                   rc->projected_frame_size >= frame_under_shoot_limit) {\n          // The key frame is much better than the previous frame\n          // Raise q_low\n          q_low = q < q_high ? q + 1 : q_high;\n\n          // Adjust Q\n          q = (int)((q * low_err_target) / kf_err);\n          q = VPXMIN(q, (q_high + q_low + 1) >> 1);\n        }\n\n        // Clamp Q to upper and lower limits:\n        q = clamp(q, q_low, q_high);\n\n        loop = q != last_q;\n      } else if (recode_loop_test(cpi, frame_over_shoot_limit,\n                                  frame_under_shoot_limit, q,\n                                  VPXMAX(q_high, top_index), bottom_index)) {\n        // Is the projected frame size out of range and are we allowed\n        // to attempt to recode.\n        int last_q = q;\n        int retries = 0;\n        int qstep;\n\n        if (cpi->resize_pending == 1) {\n          // Change in frame size so go back around the recode loop.\n          cpi->rc.frame_size_selector =\n              SCALE_STEP1 - cpi->rc.frame_size_selector;\n          cpi->rc.next_frame_size_selector = cpi->rc.frame_size_selector;\n\n#if CONFIG_INTERNAL_STATS\n          ++cpi->tot_recode_hits;\n#endif\n          ++loop_count;\n          loop = 1;\n          continue;\n        }\n\n        // Frame size out of permitted range:\n        // Update correction factor & compute new Q to try...\n\n        // Frame is too large\n        if (rc->projected_frame_size > rc->this_frame_target) {\n          // Special case if the projected size is > the max allowed.\n          if ((q == q_high) &&\n              ((rc->projected_frame_size >= rc->max_frame_bandwidth) ||\n               (!rc->is_src_frame_alt_ref &&\n                (rc->projected_frame_size >=\n                 big_rate_miss_high_threshold(cpi))))) {\n            int max_rate = VPXMAX(1, VPXMIN(rc->max_frame_bandwidth,\n                                            big_rate_miss_high_threshold(cpi)));\n            double q_val_high;\n            q_val_high = vp9_convert_qindex_to_q(q_high, cm->bit_depth);\n            q_val_high =\n                q_val_high * ((double)rc->projected_frame_size / max_rate);\n            q_high = vp9_convert_q_to_qindex(q_val_high, cm->bit_depth);\n            q_high = clamp(q_high, rc->best_quality, rc->worst_quality);\n          }\n\n          // Raise Qlow as to at least the current value\n          qstep =\n              get_qstep_adj(rc->projected_frame_size, rc->this_frame_target);\n          q_low = VPXMIN(q + qstep, q_high);\n\n          if (undershoot_seen || loop_at_this_size > 1) {\n            // Update rate_correction_factor unless\n            vp9_rc_update_rate_correction_factors(cpi);\n\n            q = (q_high + q_low + 1) / 2;\n          } else {\n            // Update rate_correction_factor unless\n            vp9_rc_update_rate_correction_factors(cpi);\n\n            q = vp9_rc_regulate_q(cpi, rc->this_frame_target, bottom_index,\n                                  VPXMAX(q_high, top_index));\n\n            while (q < q_low && retries < 10) {\n              vp9_rc_update_rate_correction_factors(cpi);\n              q = vp9_rc_regulate_q(cpi, rc->this_frame_target, bottom_index,\n                                    VPXMAX(q_high, top_index));\n              retries++;\n            }\n          }\n\n          overshoot_seen = 1;\n        } else {\n          // Frame is too small\n          qstep =\n              get_qstep_adj(rc->this_frame_target, rc->projected_frame_size);\n          q_high = VPXMAX(q - qstep, q_low);\n\n          if (overshoot_seen || loop_at_this_size > 1) {\n            vp9_rc_update_rate_correction_factors(cpi);\n            q = (q_high + q_low) / 2;\n          } else {\n            vp9_rc_update_rate_correction_factors(cpi);\n            q = vp9_rc_regulate_q(cpi, rc->this_frame_target,\n                                  VPXMIN(q_low, bottom_index), top_index);\n            // Special case reset for qlow for constrained quality.\n            // This should only trigger where there is very substantial\n            // undershoot on a frame and the auto cq level is above\n            // the user passed in value.\n            if (oxcf->rc_mode == VPX_CQ && q < q_low) {\n              q_low = q;\n            }\n\n            while (q > q_high && retries < 10) {\n              vp9_rc_update_rate_correction_factors(cpi);\n              q = vp9_rc_regulate_q(cpi, rc->this_frame_target,\n                                    VPXMIN(q_low, bottom_index), top_index);\n              retries++;\n            }\n          }\n          undershoot_seen = 1;\n        }\n\n        // Clamp Q to upper and lower limits:\n        q = clamp(q, q_low, q_high);\n\n        loop = (q != last_q);\n      } else {\n        loop = 0;\n      }\n    }\n\n    // Special case for overlay frame.\n    if (rc->is_src_frame_alt_ref &&\n        rc->projected_frame_size < rc->max_frame_bandwidth)\n      loop = 0;\n\n    if (loop) {\n      ++loop_count;\n      ++loop_at_this_size;\n\n#if CONFIG_INTERNAL_STATS\n      ++cpi->tot_recode_hits;\n#endif\n    }\n\n    if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF)\n      if (loop) restore_coding_context(cpi);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    if (loop) printf(\"\\n Recoding:\");\n#endif\n  } while (loop);\n\n  rc->max_frame_bandwidth = orig_rc_max_frame_bandwidth;\n\n#ifdef AGGRESSIVE_VBR\n  if (two_pass_first_group_inter(cpi)) {\n    cpi->twopass.active_worst_quality =\n        VPXMIN(q + qrange_adj, oxcf->worst_allowed_q);\n  } else if (!frame_is_kf_gf_arf(cpi)) {\n#else\n  if (!frame_is_kf_gf_arf(cpi)) {\n#endif\n    // Have we been forced to adapt Q outside the expected range by an extreme\n    // rate miss. If so adjust the active maxQ for the subsequent frames.\n    if (!rc->is_src_frame_alt_ref && (q > cpi->twopass.active_worst_quality)) {\n      cpi->twopass.active_worst_quality = q;\n    } else if (oxcf->vbr_corpus_complexity && q == q_low &&\n               rc->projected_frame_size < rc->this_frame_target) {\n      cpi->twopass.active_worst_quality =\n          VPXMAX(q, cpi->twopass.active_worst_quality - 1);\n    }\n  }\n\n  if (enable_acl) {\n    // Skip recoding, if model diff is below threshold\n    const int thresh = compute_context_model_thresh(cpi);\n    const int diff = compute_context_model_diff(cm);\n    if (diff >= thresh) {\n      vp9_encode_frame(cpi);\n    }\n  }\n  if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF) {\n    vpx_clear_system_state();\n    restore_coding_context(cpi);\n  }\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void set_ext_overrides(VP9_COMP *cpi) {\n  // Overrides the defaults with the externally supplied values with\n  // vp9_update_reference() and vp9_update_entropy() calls\n  // Note: The overrides are valid only for the next frame passed\n  // to encode_frame_to_data_rate() function\n  if (cpi->ext_refresh_frame_context_pending) {\n    cpi->common.refresh_frame_context = cpi->ext_refresh_frame_context;\n    cpi->ext_refresh_frame_context_pending = 0;\n  }\n  if (cpi->ext_refresh_frame_flags_pending) {\n    cpi->refresh_last_frame = cpi->ext_refresh_last_frame;\n    cpi->refresh_golden_frame = cpi->ext_refresh_golden_frame;\n    cpi->refresh_alt_ref_frame = cpi->ext_refresh_alt_ref_frame;\n  }\n}\n\nYV12_BUFFER_CONFIG *vp9_svc_twostage_scale(\n    VP9_COMMON *cm, YV12_BUFFER_CONFIG *unscaled, YV12_BUFFER_CONFIG *scaled,\n    YV12_BUFFER_CONFIG *scaled_temp, INTERP_FILTER filter_type,\n    int phase_scaler, INTERP_FILTER filter_type2, int phase_scaler2) {\n  if (cm->mi_cols * MI_SIZE != unscaled->y_width ||\n      cm->mi_rows * MI_SIZE != unscaled->y_height) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (cm->bit_depth == VPX_BITS_8) {\n      vp9_scale_and_extend_frame(unscaled, scaled_temp, filter_type2,\n                                 phase_scaler2);\n      vp9_scale_and_extend_frame(scaled_temp, scaled, filter_type,\n                                 phase_scaler);\n    } else {\n      scale_and_extend_frame(unscaled, scaled_temp, (int)cm->bit_depth,\n                             filter_type2, phase_scaler2);\n      scale_and_extend_frame(scaled_temp, scaled, (int)cm->bit_depth,\n                             filter_type, phase_scaler);\n    }\n#else\n    vp9_scale_and_extend_frame(unscaled, scaled_temp, filter_type2,\n                               phase_scaler2);\n    vp9_scale_and_extend_frame(scaled_temp, scaled, filter_type, phase_scaler);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    return scaled;\n  } else {\n    return unscaled;\n  }\n}\n\nYV12_BUFFER_CONFIG *vp9_scale_if_required(\n    VP9_COMMON *cm, YV12_BUFFER_CONFIG *unscaled, YV12_BUFFER_CONFIG *scaled,\n    int use_normative_scaler, INTERP_FILTER filter_type, int phase_scaler) {\n  if (cm->mi_cols * MI_SIZE != unscaled->y_width ||\n      cm->mi_rows * MI_SIZE != unscaled->y_height) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (use_normative_scaler && unscaled->y_width <= (scaled->y_width << 1) &&\n        unscaled->y_height <= (scaled->y_height << 1))\n      if (cm->bit_depth == VPX_BITS_8)\n        vp9_scale_and_extend_frame(unscaled, scaled, filter_type, phase_scaler);\n      else\n        scale_and_extend_frame(unscaled, scaled, (int)cm->bit_depth,\n                               filter_type, phase_scaler);\n    else\n      scale_and_extend_frame_nonnormative(unscaled, scaled, (int)cm->bit_depth);\n#else\n    if (use_normative_scaler && unscaled->y_width <= (scaled->y_width << 1) &&\n        unscaled->y_height <= (scaled->y_height << 1))\n      vp9_scale_and_extend_frame(unscaled, scaled, filter_type, phase_scaler);\n    else\n      scale_and_extend_frame_nonnormative(unscaled, scaled);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    return scaled;\n  } else {\n    return unscaled;\n  }\n}\n\nstatic void set_ref_sign_bias(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  RefCntBuffer *const ref_buffer = get_ref_cnt_buffer(cm, cm->new_fb_idx);\n  const int cur_frame_index = ref_buffer->frame_index;\n  MV_REFERENCE_FRAME ref_frame;\n\n  for (ref_frame = LAST_FRAME; ref_frame < MAX_REF_FRAMES; ++ref_frame) {\n    const int buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);\n    const RefCntBuffer *const ref_cnt_buf =\n        get_ref_cnt_buffer(&cpi->common, buf_idx);\n    if (ref_cnt_buf) {\n      cm->ref_frame_sign_bias[ref_frame] =\n          cur_frame_index < ref_cnt_buf->frame_index;\n    }\n  }\n}\n\nstatic int setup_interp_filter_search_mask(VP9_COMP *cpi) {\n  INTERP_FILTER ifilter;\n  int ref_total[MAX_REF_FRAMES] = { 0 };\n  MV_REFERENCE_FRAME ref;\n  int mask = 0;\n  if (cpi->common.last_frame_type == KEY_FRAME || cpi->refresh_alt_ref_frame)\n    return mask;\n  for (ref = LAST_FRAME; ref <= ALTREF_FRAME; ++ref)\n    for (ifilter = EIGHTTAP; ifilter <= EIGHTTAP_SHARP; ++ifilter)\n      ref_total[ref] += cpi->interp_filter_selected[ref][ifilter];\n\n  for (ifilter = EIGHTTAP; ifilter <= EIGHTTAP_SHARP; ++ifilter) {\n    if ((ref_total[LAST_FRAME] &&\n         cpi->interp_filter_selected[LAST_FRAME][ifilter] == 0) &&\n        (ref_total[GOLDEN_FRAME] == 0 ||\n         cpi->interp_filter_selected[GOLDEN_FRAME][ifilter] * 50 <\n             ref_total[GOLDEN_FRAME]) &&\n        (ref_total[ALTREF_FRAME] == 0 ||\n         cpi->interp_filter_selected[ALTREF_FRAME][ifilter] * 50 <\n             ref_total[ALTREF_FRAME]))\n      mask |= 1 << ifilter;\n  }\n  return mask;\n}\n\n#ifdef ENABLE_KF_DENOISE\n// Baseline kernel weights for denoise\nstatic uint8_t dn_kernel_3[9] = { 1, 2, 1, 2, 4, 2, 1, 2, 1 };\nstatic uint8_t dn_kernel_5[25] = { 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 4,\n                                   2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1 };\n\nstatic INLINE void add_denoise_point(int centre_val, int data_val, int thresh,\n                                     uint8_t point_weight, int *sum_val,\n                                     int *sum_weight) {\n  if (abs(centre_val - data_val) <= thresh) {\n    *sum_weight += point_weight;\n    *sum_val += (int)data_val * (int)point_weight;\n  }\n}\n\nstatic void spatial_denoise_point(uint8_t *src_ptr, const int stride,\n                                  const int strength) {\n  int sum_weight = 0;\n  int sum_val = 0;\n  int thresh = strength;\n  int kernel_size = 5;\n  int half_k_size = 2;\n  int i, j;\n  int max_diff = 0;\n  uint8_t *tmp_ptr;\n  uint8_t *kernel_ptr;\n\n  // Find the maximum deviation from the source point in the locale.\n  tmp_ptr = src_ptr - (stride * (half_k_size + 1)) - (half_k_size + 1);\n  for (i = 0; i < kernel_size + 2; ++i) {\n    for (j = 0; j < kernel_size + 2; ++j) {\n      max_diff = VPXMAX(max_diff, abs((int)*src_ptr - (int)tmp_ptr[j]));\n    }\n    tmp_ptr += stride;\n  }\n\n  // Select the kernel size.\n  if (max_diff > (strength + (strength >> 1))) {\n    kernel_size = 3;\n    half_k_size = 1;\n    thresh = thresh >> 1;\n  }\n  kernel_ptr = (kernel_size == 3) ? dn_kernel_3 : dn_kernel_5;\n\n  // Apply the kernel\n  tmp_ptr = src_ptr - (stride * half_k_size) - half_k_size;\n  for (i = 0; i < kernel_size; ++i) {\n    for (j = 0; j < kernel_size; ++j) {\n      add_denoise_point((int)*src_ptr, (int)tmp_ptr[j], thresh, *kernel_ptr,\n                        &sum_val, &sum_weight);\n      ++kernel_ptr;\n    }\n    tmp_ptr += stride;\n  }\n\n  // Update the source value with the new filtered value\n  *src_ptr = (uint8_t)((sum_val + (sum_weight >> 1)) / sum_weight);\n}\n\n#if CONFIG_VP9_HIGHBITDEPTH\nstatic void highbd_spatial_denoise_point(uint16_t *src_ptr, const int stride,\n                                         const int strength) {\n  int sum_weight = 0;\n  int sum_val = 0;\n  int thresh = strength;\n  int kernel_size = 5;\n  int half_k_size = 2;\n  int i, j;\n  int max_diff = 0;\n  uint16_t *tmp_ptr;\n  uint8_t *kernel_ptr;\n\n  // Find the maximum deviation from the source point in the locale.\n  tmp_ptr = src_ptr - (stride * (half_k_size + 1)) - (half_k_size + 1);\n  for (i = 0; i < kernel_size + 2; ++i) {\n    for (j = 0; j < kernel_size + 2; ++j) {\n      max_diff = VPXMAX(max_diff, abs((int)src_ptr - (int)tmp_ptr[j]));\n    }\n    tmp_ptr += stride;\n  }\n\n  // Select the kernel size.\n  if (max_diff > (strength + (strength >> 1))) {\n    kernel_size = 3;\n    half_k_size = 1;\n    thresh = thresh >> 1;\n  }\n  kernel_ptr = (kernel_size == 3) ? dn_kernel_3 : dn_kernel_5;\n\n  // Apply the kernel\n  tmp_ptr = src_ptr - (stride * half_k_size) - half_k_size;\n  for (i = 0; i < kernel_size; ++i) {\n    for (j = 0; j < kernel_size; ++j) {\n      add_denoise_point((int)*src_ptr, (int)tmp_ptr[j], thresh, *kernel_ptr,\n                        &sum_val, &sum_weight);\n      ++kernel_ptr;\n    }\n    tmp_ptr += stride;\n  }\n\n  // Update the source value with the new filtered value\n  *src_ptr = (uint16_t)((sum_val + (sum_weight >> 1)) / sum_weight);\n}\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n// Apply thresholded spatial noise suppression to a given buffer.\nstatic void spatial_denoise_buffer(VP9_COMP *cpi, uint8_t *buffer,\n                                   const int stride, const int width,\n                                   const int height, const int strength) {\n  VP9_COMMON *const cm = &cpi->common;\n  uint8_t *src_ptr = buffer;\n  int row;\n  int col;\n\n  for (row = 0; row < height; ++row) {\n    for (col = 0; col < width; ++col) {\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (cm->use_highbitdepth)\n        highbd_spatial_denoise_point(CONVERT_TO_SHORTPTR(&src_ptr[col]), stride,\n                                     strength);\n      else\n        spatial_denoise_point(&src_ptr[col], stride, strength);\n#else\n      spatial_denoise_point(&src_ptr[col], stride, strength);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n    src_ptr += stride;\n  }\n}\n\n// Apply thresholded spatial noise suppression to source.\nstatic void spatial_denoise_frame(VP9_COMP *cpi) {\n  YV12_BUFFER_CONFIG *src = cpi->Source;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  TWO_PASS *const twopass = &cpi->twopass;\n  VP9_COMMON *const cm = &cpi->common;\n\n  // Base the filter strength on the current active max Q.\n  const int q = (int)(vp9_convert_qindex_to_q(twopass->active_worst_quality,\n                                              cm->bit_depth));\n  int strength =\n      VPXMAX(oxcf->arnr_strength >> 2, VPXMIN(oxcf->arnr_strength, (q >> 4)));\n\n  // Denoise each of Y,U and V buffers.\n  spatial_denoise_buffer(cpi, src->y_buffer, src->y_stride, src->y_width,\n                         src->y_height, strength);\n\n  strength += (strength >> 1);\n  spatial_denoise_buffer(cpi, src->u_buffer, src->uv_stride, src->uv_width,\n                         src->uv_height, strength << 1);\n\n  spatial_denoise_buffer(cpi, src->v_buffer, src->uv_stride, src->uv_width,\n                         src->uv_height, strength << 1);\n}\n#endif  // ENABLE_KF_DENOISE\n\n#if !CONFIG_REALTIME_ONLY\nstatic void vp9_try_disable_lookahead_aq(VP9_COMP *cpi, size_t *size,\n                                         uint8_t *dest) {\n  if (cpi->common.seg.enabled)\n    if (ALT_REF_AQ_PROTECT_GAIN) {\n      size_t nsize = *size;\n      int overhead;\n\n      // TODO(yuryg): optimize this, as\n      // we don't really need to repack\n\n      save_coding_context(cpi);\n      vp9_disable_segmentation(&cpi->common.seg);\n      vp9_pack_bitstream(cpi, dest, &nsize);\n      restore_coding_context(cpi);\n\n      overhead = (int)*size - (int)nsize;\n\n      if (vp9_alt_ref_aq_disable_if(cpi->alt_ref_aq, overhead, (int)*size))\n        vp9_encode_frame(cpi);\n      else\n        vp9_enable_segmentation(&cpi->common.seg);\n    }\n}\n#endif\n\nstatic void set_frame_index(VP9_COMP *cpi, VP9_COMMON *cm) {\n  RefCntBuffer *const ref_buffer = get_ref_cnt_buffer(cm, cm->new_fb_idx);\n\n  if (ref_buffer) {\n    const GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n    ref_buffer->frame_index =\n        cm->current_video_frame + gf_group->arf_src_offset[gf_group->index];\n    ref_buffer->frame_coding_index = cm->current_frame_coding_index;\n  }\n}\n\nstatic void set_mb_ssim_rdmult_scaling(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  ThreadData *td = &cpi->td;\n  MACROBLOCK *x = &td->mb;\n  MACROBLOCKD *xd = &x->e_mbd;\n  uint8_t *y_buffer = cpi->Source->y_buffer;\n  const int y_stride = cpi->Source->y_stride;\n  const int block_size = BLOCK_16X16;\n\n  const int num_8x8_w = num_8x8_blocks_wide_lookup[block_size];\n  const int num_8x8_h = num_8x8_blocks_high_lookup[block_size];\n  const int num_cols = (cm->mi_cols + num_8x8_w - 1) / num_8x8_w;\n  const int num_rows = (cm->mi_rows + num_8x8_h - 1) / num_8x8_h;\n  double log_sum = 0.0;\n  int row, col;\n\n  // Loop through each 64x64 block.\n  for (row = 0; row < num_rows; ++row) {\n    for (col = 0; col < num_cols; ++col) {\n      int mi_row, mi_col;\n      double var = 0.0, num_of_var = 0.0;\n      const int index = row * num_cols + col;\n\n      for (mi_row = row * num_8x8_h;\n           mi_row < cm->mi_rows && mi_row < (row + 1) * num_8x8_h; ++mi_row) {\n        for (mi_col = col * num_8x8_w;\n             mi_col < cm->mi_cols && mi_col < (col + 1) * num_8x8_w; ++mi_col) {\n          struct buf_2d buf;\n          const int row_offset_y = mi_row << 3;\n          const int col_offset_y = mi_col << 3;\n\n          buf.buf = y_buffer + row_offset_y * y_stride + col_offset_y;\n          buf.stride = y_stride;\n\n          // In order to make SSIM_VAR_SCALE in a same scale for both 8 bit\n          // and high bit videos, the variance needs to be divided by 2.0 or\n          // 64.0 separately.\n          // TODO(sdeng): need to tune for 12bit videos.\n#if CONFIG_VP9_HIGHBITDEPTH\n          if (cpi->Source->flags & YV12_FLAG_HIGHBITDEPTH)\n            var += vp9_high_get_sby_variance(cpi, &buf, BLOCK_8X8, xd->bd);\n          else\n#endif\n            var += vp9_get_sby_variance(cpi, &buf, BLOCK_8X8);\n\n          num_of_var += 1.0;\n        }\n      }\n      var = var / num_of_var / 64.0;\n\n      // Curve fitting with an exponential model on all 16x16 blocks from the\n      // Midres dataset.\n      var = 67.035434 * (1 - exp(-0.0021489 * var)) + 17.492222;\n      cpi->mi_ssim_rdmult_scaling_factors[index] = var;\n      log_sum += log(var);\n    }\n  }\n  log_sum = exp(log_sum / (double)(num_rows * num_cols));\n\n  for (row = 0; row < num_rows; ++row) {\n    for (col = 0; col < num_cols; ++col) {\n      const int index = row * num_cols + col;\n      cpi->mi_ssim_rdmult_scaling_factors[index] /= log_sum;\n    }\n  }\n\n  (void)xd;\n}\n\n// Process the wiener variance in 16x16 block basis.\nstatic int qsort_comp(const void *elem1, const void *elem2) {\n  int a = *((const int *)elem1);\n  int b = *((const int *)elem2);\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nstatic void init_mb_wiener_var_buffer(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n\n  if (cpi->mb_wiener_variance && cpi->mb_wiener_var_rows >= cm->mb_rows &&\n      cpi->mb_wiener_var_cols >= cm->mb_cols)\n    return;\n\n  vpx_free(cpi->mb_wiener_variance);\n  cpi->mb_wiener_variance = NULL;\n\n  CHECK_MEM_ERROR(\n      &cm->error, cpi->mb_wiener_variance,\n      vpx_calloc(cm->mb_rows * cm->mb_cols, sizeof(*cpi->mb_wiener_variance)));\n  cpi->mb_wiener_var_rows = cm->mb_rows;\n  cpi->mb_wiener_var_cols = cm->mb_cols;\n}\n\nstatic void set_mb_wiener_variance(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  uint8_t *buffer = cpi->Source->y_buffer;\n  int buf_stride = cpi->Source->y_stride;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  ThreadData *td = &cpi->td;\n  MACROBLOCK *x = &td->mb;\n  MACROBLOCKD *xd = &x->e_mbd;\n  DECLARE_ALIGNED(16, uint16_t, zero_pred16[32 * 32]);\n  DECLARE_ALIGNED(16, uint8_t, zero_pred8[32 * 32]);\n  uint8_t *zero_pred;\n#else\n  DECLARE_ALIGNED(16, uint8_t, zero_pred[32 * 32]);\n#endif\n\n  DECLARE_ALIGNED(16, int16_t, src_diff[32 * 32]);\n  DECLARE_ALIGNED(16, tran_low_t, coeff[32 * 32]);\n\n  int mb_row, mb_col, count = 0;\n  // Hard coded operating block size\n  const int block_size = 16;\n  const int coeff_count = block_size * block_size;\n  const TX_SIZE tx_size = TX_16X16;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  xd->cur_buf = cpi->Source;\n  if (xd->cur_buf->flags & YV12_FLAG_HIGHBITDEPTH) {\n    zero_pred = CONVERT_TO_BYTEPTR(zero_pred16);\n    memset(zero_pred16, 0, sizeof(*zero_pred16) * coeff_count);\n  } else {\n    zero_pred = zero_pred8;\n    memset(zero_pred8, 0, sizeof(*zero_pred8) * coeff_count);\n  }\n#else\n  memset(zero_pred, 0, sizeof(*zero_pred) * coeff_count);\n#endif\n\n  cpi->norm_wiener_variance = 0;\n\n  for (mb_row = 0; mb_row < cm->mb_rows; ++mb_row) {\n    for (mb_col = 0; mb_col < cm->mb_cols; ++mb_col) {\n      int idx;\n      int16_t median_val = 0;\n      uint8_t *mb_buffer =\n          buffer + mb_row * block_size * buf_stride + mb_col * block_size;\n      int64_t wiener_variance = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (xd->cur_buf->flags & YV12_FLAG_HIGHBITDEPTH) {\n        vpx_highbd_subtract_block(block_size, block_size, src_diff, block_size,\n                                  mb_buffer, buf_stride, zero_pred, block_size,\n                                  xd->bd);\n        vp9_highbd_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);\n      } else {\n        vpx_subtract_block(block_size, block_size, src_diff, block_size,\n                           mb_buffer, buf_stride, zero_pred, block_size);\n        vp9_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);\n      }\n#else\n      vpx_subtract_block(block_size, block_size, src_diff, block_size,\n                         mb_buffer, buf_stride, zero_pred, block_size);\n      vp9_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n      coeff[0] = 0;\n      for (idx = 1; idx < coeff_count; ++idx) coeff[idx] = abs(coeff[idx]);\n\n      qsort(coeff, coeff_count - 1, sizeof(*coeff), qsort_comp);\n\n      // Noise level estimation\n      median_val = coeff[coeff_count / 2];\n\n      // Wiener filter\n      for (idx = 1; idx < coeff_count; ++idx) {\n        int64_t sqr_coeff = (int64_t)coeff[idx] * coeff[idx];\n        int64_t tmp_coeff = (int64_t)coeff[idx];\n        if (median_val) {\n          tmp_coeff = (sqr_coeff * coeff[idx]) /\n                      (sqr_coeff + (int64_t)median_val * median_val);\n        }\n        wiener_variance += tmp_coeff * tmp_coeff;\n      }\n      cpi->mb_wiener_variance[mb_row * cm->mb_cols + mb_col] =\n          wiener_variance / coeff_count;\n      cpi->norm_wiener_variance +=\n          cpi->mb_wiener_variance[mb_row * cm->mb_cols + mb_col];\n      ++count;\n    }\n  }\n\n  if (count) cpi->norm_wiener_variance /= count;\n  cpi->norm_wiener_variance = VPXMAX(1, cpi->norm_wiener_variance);\n}\n\n#if !CONFIG_REALTIME_ONLY\nstatic void update_encode_frame_result_basic(\n    FRAME_UPDATE_TYPE update_type, int show_idx, int quantize_index,\n    ENCODE_FRAME_RESULT *encode_frame_result) {\n  encode_frame_result->show_idx = show_idx;\n  encode_frame_result->update_type = update_type;\n  encode_frame_result->quantize_index = quantize_index;\n}\n\n#if CONFIG_RATE_CTRL\nstatic void yv12_buffer_to_image_buffer(const YV12_BUFFER_CONFIG *yv12_buffer,\n                                        IMAGE_BUFFER *image_buffer) {\n  const uint8_t *src_buf_ls[3] = { yv12_buffer->y_buffer, yv12_buffer->u_buffer,\n                                   yv12_buffer->v_buffer };\n  const int src_stride_ls[3] = { yv12_buffer->y_stride, yv12_buffer->uv_stride,\n                                 yv12_buffer->uv_stride };\n  const int w_ls[3] = { yv12_buffer->y_crop_width, yv12_buffer->uv_crop_width,\n                        yv12_buffer->uv_crop_width };\n  const int h_ls[3] = { yv12_buffer->y_crop_height, yv12_buffer->uv_crop_height,\n                        yv12_buffer->uv_crop_height };\n  int plane;\n  for (plane = 0; plane < 3; ++plane) {\n    const int src_stride = src_stride_ls[plane];\n    const int w = w_ls[plane];\n    const int h = h_ls[plane];\n    const uint8_t *src_buf = src_buf_ls[plane];\n    uint8_t *dst_buf = image_buffer->plane_buffer[plane];\n    int r;\n    assert(image_buffer->plane_width[plane] == w);\n    assert(image_buffer->plane_height[plane] == h);\n    for (r = 0; r < h; ++r) {\n      memcpy(dst_buf, src_buf, sizeof(*src_buf) * w);\n      src_buf += src_stride;\n      dst_buf += w;\n    }\n  }\n}\n// This function will update extra information specific for simple_encode APIs\nstatic void update_encode_frame_result_simple_encode(\n    int ref_frame_flags, FRAME_UPDATE_TYPE update_type,\n    const YV12_BUFFER_CONFIG *source_frame, const RefCntBuffer *coded_frame_buf,\n    RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES], int quantize_index,\n    uint32_t bit_depth, uint32_t input_bit_depth, const FRAME_COUNTS *counts,\n    const PARTITION_INFO *partition_info,\n    const MOTION_VECTOR_INFO *motion_vector_info,\n    const TplDepStats *tpl_stats_info,\n    ENCODE_FRAME_RESULT *encode_frame_result) {\n  PSNR_STATS psnr;\n  update_encode_frame_result_basic(update_type, coded_frame_buf->frame_index,\n                                   quantize_index, encode_frame_result);\n#if CONFIG_VP9_HIGHBITDEPTH\n  vpx_calc_highbd_psnr(source_frame, &coded_frame_buf->buf, &psnr, bit_depth,\n                       input_bit_depth);\n#else   // CONFIG_VP9_HIGHBITDEPTH\n  (void)bit_depth;\n  (void)input_bit_depth;\n  vpx_calc_psnr(source_frame, &coded_frame_buf->buf, &psnr);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  encode_frame_result->frame_coding_index = coded_frame_buf->frame_coding_index;\n\n  vp9_get_ref_frame_info(update_type, ref_frame_flags, ref_frame_bufs,\n                         encode_frame_result->ref_frame_coding_indexes,\n                         encode_frame_result->ref_frame_valid_list);\n\n  encode_frame_result->psnr = psnr.psnr[0];\n  encode_frame_result->sse = psnr.sse[0];\n  encode_frame_result->frame_counts = *counts;\n  encode_frame_result->partition_info = partition_info;\n  encode_frame_result->motion_vector_info = motion_vector_info;\n  encode_frame_result->tpl_stats_info = tpl_stats_info;\n  if (encode_frame_result->coded_frame.allocated) {\n    yv12_buffer_to_image_buffer(&coded_frame_buf->buf,\n                                &encode_frame_result->coded_frame);\n  }\n}\n#endif  // CONFIG_RATE_CTRL\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void encode_frame_to_data_rate(\n    VP9_COMP *cpi, size_t *size, uint8_t *dest, unsigned int *frame_flags,\n    ENCODE_FRAME_RESULT *encode_frame_result) {\n  VP9_COMMON *const cm = &cpi->common;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  struct segmentation *const seg = &cm->seg;\n  TX_SIZE t;\n\n  // SVC: skip encoding of enhancement layer if the layer target bandwidth = 0.\n  // No need to set svc.skip_enhancement_layer if whole superframe will be\n  // dropped.\n  if (cpi->use_svc && cpi->svc.spatial_layer_id > 0 &&\n      cpi->oxcf.target_bandwidth == 0 &&\n      !(cpi->svc.framedrop_mode != LAYER_DROP &&\n        (cpi->svc.framedrop_mode != CONSTRAINED_FROM_ABOVE_DROP ||\n         cpi->svc\n             .force_drop_constrained_from_above[cpi->svc.number_spatial_layers -\n                                                1]) &&\n        cpi->svc.drop_spatial_layer[0])) {\n    cpi->svc.skip_enhancement_layer = 1;\n    vp9_rc_postencode_update_drop_frame(cpi);\n    cpi->ext_refresh_frame_flags_pending = 0;\n    cpi->last_frame_dropped = 1;\n    cpi->svc.last_layer_dropped[cpi->svc.spatial_layer_id] = 1;\n    cpi->svc.drop_spatial_layer[cpi->svc.spatial_layer_id] = 1;\n    vp9_inc_frame_in_layer(cpi);\n    return;\n  }\n\n  set_ext_overrides(cpi);\n  vpx_clear_system_state();\n\n#ifdef ENABLE_KF_DENOISE\n  // Spatial denoise of key frame.\n  if (is_spatial_denoise_enabled(cpi)) spatial_denoise_frame(cpi);\n#endif\n\n  if (cm->show_existing_frame == 0) {\n    // Update frame index\n    set_frame_index(cpi, cm);\n\n    // Set the arf sign bias for this frame.\n    set_ref_sign_bias(cpi);\n  }\n\n  // Set default state for segment based loop filter update flags.\n  cm->lf.mode_ref_delta_update = 0;\n\n  if (cpi->oxcf.pass == 2 && cpi->sf.adaptive_interp_filter_search)\n    cpi->sf.interp_filter_search_mask = setup_interp_filter_search_mask(cpi);\n\n  // Set various flags etc to special state if it is a key frame.\n  if (frame_is_intra_only(cm)) {\n    // Reset the loop filter deltas and segmentation map.\n    vp9_reset_segment_features(&cm->seg);\n\n    // If segmentation is enabled force a map update for key frames.\n    if (seg->enabled) {\n      seg->update_map = 1;\n      seg->update_data = 1;\n    }\n\n    // The alternate reference frame cannot be active for a key frame.\n    cpi->rc.source_alt_ref_active = 0;\n\n    cm->error_resilient_mode = oxcf->error_resilient_mode;\n    cm->frame_parallel_decoding_mode = oxcf->frame_parallel_decoding_mode;\n\n    // By default, encoder assumes decoder can use prev_mi.\n    if (cm->error_resilient_mode) {\n      cm->frame_parallel_decoding_mode = 1;\n      cm->reset_frame_context = 0;\n      cm->refresh_frame_context = 0;\n    } else if (cm->intra_only) {\n      // Only reset the current context.\n      cm->reset_frame_context = 2;\n    }\n  }\n\n  if (oxcf->tuning == VP8_TUNE_SSIM) set_mb_ssim_rdmult_scaling(cpi);\n\n  if (oxcf->aq_mode == PERCEPTUAL_AQ) {\n    init_mb_wiener_var_buffer(cpi);\n    set_mb_wiener_variance(cpi);\n  }\n\n  vpx_clear_system_state();\n\n#if CONFIG_INTERNAL_STATS\n  memset(cpi->mode_chosen_counts, 0,\n         MAX_MODES * sizeof(*cpi->mode_chosen_counts));\n#endif\n  // Backup to ensure consistency between recodes\n  save_encode_params(cpi);\n  if (cpi->ext_ratectrl.ready &&\n      (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_RDMULT) != 0 &&\n      cpi->ext_ratectrl.funcs.get_frame_rdmult != NULL) {\n    vpx_codec_err_t codec_status;\n    const GF_GROUP *gf_group = &cpi->twopass.gf_group;\n    FRAME_UPDATE_TYPE update_type = gf_group->update_type[gf_group->index];\n    const int ref_frame_flags = get_ref_frame_flags(cpi);\n    RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];\n    const RefCntBuffer *curr_frame_buf = get_ref_cnt_buffer(cm, cm->new_fb_idx);\n    // index 0 of a gf group is always KEY/OVERLAY/GOLDEN.\n    // index 1 refers to the first encoding frame in a gf group.\n    // Therefore if it is ARF_UPDATE, it means this gf group uses alt ref.\n    // See function define_gf_group_structure().\n    const int use_alt_ref = gf_group->update_type[1] == ARF_UPDATE;\n    int ext_rdmult = VPX_DEFAULT_RDMULT;\n    get_ref_frame_bufs(cpi, ref_frame_bufs);\n    codec_status = vp9_extrc_get_frame_rdmult(\n        &cpi->ext_ratectrl, curr_frame_buf->frame_index,\n        cm->current_frame_coding_index, gf_group->index, update_type,\n        gf_group->gf_group_size, use_alt_ref, ref_frame_bufs, ref_frame_flags,\n        &ext_rdmult);\n    if (codec_status != VPX_CODEC_OK) {\n      vpx_internal_error(&cm->error, codec_status,\n                         \"vp9_extrc_get_frame_rdmult() failed\");\n    }\n    cpi->ext_ratectrl.ext_rdmult = ext_rdmult;\n  }\n\n  if (cpi->sf.recode_loop == DISALLOW_RECODE) {\n    if (!encode_without_recode_loop(cpi, size, dest)) return;\n  } else {\n#if !CONFIG_REALTIME_ONLY\n#if CONFIG_RATE_CTRL\n    encode_with_recode_loop(cpi, size, dest, &encode_frame_result->rq_history);\n#else  // CONFIG_RATE_CTRL\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    start_timing(cpi, encode_with_recode_loop_time);\n#endif\n    encode_with_recode_loop(cpi, size, dest);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    end_timing(cpi, encode_with_recode_loop_time);\n#endif\n#endif  // CONFIG_RATE_CTRL\n#endif  // !CONFIG_REALTIME_ONLY\n  }\n\n  // TODO(jingning): When using show existing frame mode, we assume that the\n  // current ARF will be directly used as the final reconstructed frame. This is\n  // an encoder control scheme. One could in principle explore other\n  // possibilities to arrange the reference frame buffer and their coding order.\n  if (cm->show_existing_frame) {\n    ref_cnt_fb(cm->buffer_pool->frame_bufs, &cm->new_fb_idx,\n               cm->ref_frame_map[cpi->alt_fb_idx]);\n  }\n\n#if !CONFIG_REALTIME_ONLY\n  // Disable segmentation if it decrease rate/distortion ratio\n  if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ)\n    vp9_try_disable_lookahead_aq(cpi, size, dest);\n#endif\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n#ifdef OUTPUT_YUV_DENOISED\n  if (oxcf->noise_sensitivity > 0 && denoise_svc(cpi)) {\n    vpx_write_yuv_frame(yuv_denoised_file,\n                        &cpi->denoiser.running_avg_y[INTRA_FRAME]);\n  }\n#endif\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  if (cpi->common.current_video_frame > 1) {\n    vp9_output_skin_map(cpi, yuv_skinmap_file);\n  }\n#endif\n\n  // Special case code to reduce pulsing when key frames are forced at a\n  // fixed interval. Note the reconstruction error if it is the frame before\n  // the force key frame\n  if (cpi->rc.next_key_frame_forced && cpi->rc.frames_to_key == 1) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (cm->use_highbitdepth) {\n      cpi->ambient_err =\n          vpx_highbd_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n    } else {\n      cpi->ambient_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n    }\n#else\n    cpi->ambient_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  }\n\n  // If the encoder forced a KEY_FRAME decision\n  if (cm->frame_type == KEY_FRAME) cpi->refresh_last_frame = 1;\n\n  cm->frame_to_show = get_frame_new_buffer(cm);\n  cm->frame_to_show->color_space = cm->color_space;\n  cm->frame_to_show->color_range = cm->color_range;\n  cm->frame_to_show->render_width = cm->render_width;\n  cm->frame_to_show->render_height = cm->render_height;\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  start_timing(cpi, loopfilter_frame_time);\n#endif\n  // Pick the loop filter level for the frame.\n  loopfilter_frame(cpi, cm);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  end_timing(cpi, loopfilter_frame_time);\n#endif\n\n  if (cpi->rc.use_post_encode_drop) save_coding_context(cpi);\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  start_timing(cpi, vp9_pack_bitstream_time);\n#endif\n  // build the bitstream\n  vp9_pack_bitstream(cpi, dest, size);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  end_timing(cpi, vp9_pack_bitstream_time);\n#endif\n\n  if (cpi->ext_ratectrl.ready &&\n      cpi->ext_ratectrl.funcs.update_encodeframe_result != NULL) {\n    const RefCntBuffer *coded_frame_buf =\n        get_ref_cnt_buffer(cm, cm->new_fb_idx);\n    vpx_codec_err_t codec_status = vp9_extrc_update_encodeframe_result(\n        &cpi->ext_ratectrl, (*size) << 3, cpi->Source, &coded_frame_buf->buf,\n        cm->bit_depth, cpi->oxcf.input_bit_depth, cm->base_qindex);\n    if (codec_status != VPX_CODEC_OK) {\n      vpx_internal_error(&cm->error, codec_status,\n                         \"vp9_extrc_update_encodeframe_result() failed\");\n    }\n  }\n#if CONFIG_REALTIME_ONLY\n  (void)encode_frame_result;\n  assert(encode_frame_result == NULL);\n#else  // CONFIG_REALTIME_ONLY\n  if (encode_frame_result != NULL) {\n    const RefCntBuffer *coded_frame_buf =\n        get_ref_cnt_buffer(cm, cm->new_fb_idx);\n    RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];\n    FRAME_UPDATE_TYPE update_type =\n        cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index];\n    int quantize_index = vp9_get_quantizer(cpi);\n    get_ref_frame_bufs(cpi, ref_frame_bufs);\n    // update_encode_frame_result() depends on twopass.gf_group.index and\n    // cm->new_fb_idx, cpi->Source, cpi->lst_fb_idx, cpi->gld_fb_idx and\n    // cpi->alt_fb_idx are updated for current frame and have\n    // not been updated for the next frame yet.\n    // The update locations are as follows.\n    // 1) twopass.gf_group.index is initialized at define_gf_group by vp9_zero()\n    // for the first frame in the gf_group and is updated for the next frame at\n    // vp9_twopass_postencode_update().\n    // 2) cpi->Source is updated at the beginning of vp9_get_compressed_data()\n    // 3) cm->new_fb_idx is updated at the beginning of\n    // vp9_get_compressed_data() by get_free_fb(cm).\n    // 4) cpi->lst_fb_idx/gld_fb_idx/alt_fb_idx will be updated for the next\n    // frame at vp9_update_reference_frames().\n    // This function needs to be called before vp9_update_reference_frames().\n    // TODO(angiebird): Improve the codebase to make the update of frame\n    // dependent variables more robust.\n\n    update_encode_frame_result_basic(update_type, coded_frame_buf->frame_index,\n                                     quantize_index, encode_frame_result);\n#if CONFIG_RATE_CTRL\n    if (cpi->oxcf.use_simple_encode_api) {\n      const int ref_frame_flags = get_ref_frame_flags(cpi);\n      update_encode_frame_result_simple_encode(\n          ref_frame_flags,\n          cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index],\n          cpi->Source, coded_frame_buf, ref_frame_bufs, quantize_index,\n          cm->bit_depth, cpi->oxcf.input_bit_depth, cpi->td.counts,\n          cpi->partition_info, cpi->motion_vector_info, cpi->tpl_stats_info,\n          encode_frame_result);\n    }\n#endif  // CONFIG_RATE_CTRL\n  }\n#endif  // CONFIG_REALTIME_ONLY\n\n  if (cpi->rc.use_post_encode_drop && cm->base_qindex < cpi->rc.worst_quality &&\n      cpi->svc.spatial_layer_id == 0 && post_encode_drop_cbr(cpi, size)) {\n    restore_coding_context(cpi);\n    return;\n  }\n\n  cpi->last_frame_dropped = 0;\n  cpi->svc.last_layer_dropped[cpi->svc.spatial_layer_id] = 0;\n  if (cpi->svc.spatial_layer_id == cpi->svc.number_spatial_layers - 1)\n    cpi->svc.num_encoded_top_layer++;\n\n  // Keep track of the frame buffer index updated/refreshed for the\n  // current encoded TL0 superframe.\n  if (cpi->svc.temporal_layer_id == 0) {\n    if (cpi->refresh_last_frame)\n      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->lst_fb_idx;\n    else if (cpi->refresh_golden_frame)\n      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->gld_fb_idx;\n    else if (cpi->refresh_alt_ref_frame)\n      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->alt_fb_idx;\n  }\n\n  if (cm->seg.update_map) update_reference_segmentation_map(cpi);\n\n  if (frame_is_intra_only(cm) == 0) {\n    release_scaled_references(cpi);\n  }\n  vp9_update_reference_frames(cpi);\n\n  if (!cm->show_existing_frame) {\n    for (t = TX_4X4; t <= TX_32X32; ++t) {\n      full_to_model_counts(cpi->td.counts->coef[t],\n                           cpi->td.rd_counts.coef_counts[t]);\n    }\n\n    if (!cm->error_resilient_mode && !cm->frame_parallel_decoding_mode) {\n      if (!frame_is_intra_only(cm)) {\n        vp9_adapt_mode_probs(cm);\n        vp9_adapt_mv_probs(cm, cm->allow_high_precision_mv);\n      }\n      vp9_adapt_coef_probs(cm);\n    }\n  }\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  if (cpi->refresh_golden_frame == 1)\n    cpi->frame_flags |= FRAMEFLAGS_GOLDEN;\n  else\n    cpi->frame_flags &= ~FRAMEFLAGS_GOLDEN;\n\n  if (cpi->refresh_alt_ref_frame == 1)\n    cpi->frame_flags |= FRAMEFLAGS_ALTREF;\n  else\n    cpi->frame_flags &= ~FRAMEFLAGS_ALTREF;\n\n  cpi->ref_frame_flags = get_ref_frame_flags(cpi);\n\n  cm->last_frame_type = cm->frame_type;\n\n  vp9_rc_postencode_update(cpi, *size);\n\n  if (cpi->compute_frame_low_motion_onepass && oxcf->pass == 0 &&\n      !frame_is_intra_only(cm) &&\n      (!cpi->use_svc ||\n       (cpi->use_svc &&\n        !cpi->svc.layer_context[cpi->svc.temporal_layer_id].is_key_frame &&\n        cpi->svc.spatial_layer_id == cpi->svc.number_spatial_layers - 1))) {\n    vp9_compute_frame_low_motion(cpi);\n  }\n\n  *size = VPXMAX(1, *size);\n\n#if 0\n  output_frame_level_debug_stats(cpi);\n#endif\n\n  if (cm->frame_type == KEY_FRAME) {\n    // Tell the caller that the frame was coded as a key frame\n    *frame_flags = cpi->frame_flags | FRAMEFLAGS_KEY;\n  } else {\n    *frame_flags = cpi->frame_flags & ~FRAMEFLAGS_KEY;\n  }\n\n  // Clear the one shot update flags for segmentation map and mode/ref loop\n  // filter deltas.\n  cm->seg.update_map = 0;\n  cm->seg.update_data = 0;\n  cm->lf.mode_ref_delta_update = 0;\n\n  // keep track of the last coded dimensions\n  cm->last_width = cm->width;\n  cm->last_height = cm->height;\n\n  // reset to normal state now that we are done.\n  if (!cm->show_existing_frame) {\n    cm->last_show_frame = cm->show_frame;\n    cm->prev_frame = cm->cur_frame;\n  }\n\n  if (cm->show_frame) {\n    vp9_swap_mi_and_prev_mi(cm);\n    if (cpi->use_svc) vp9_inc_frame_in_layer(cpi);\n  }\n  update_frame_indexes(cm, cm->show_frame);\n\n  if (cpi->use_svc) {\n    cpi->svc\n        .layer_context[cpi->svc.spatial_layer_id *\n                           cpi->svc.number_temporal_layers +\n                       cpi->svc.temporal_layer_id]\n        .last_frame_type = cm->frame_type;\n    // Reset layer_sync back to 0 for next frame.\n    cpi->svc.spatial_layer_sync[cpi->svc.spatial_layer_id] = 0;\n  }\n\n  cpi->force_update_segmentation = 0;\n\n#if !CONFIG_REALTIME_ONLY\n  if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ)\n    vp9_alt_ref_aq_unset_all(cpi->alt_ref_aq, cpi);\n#endif\n\n  cpi->svc.previous_frame_is_intra_only = cm->intra_only;\n  cpi->svc.set_intra_only_frame = 0;\n}\n\nstatic void SvcEncode(VP9_COMP *cpi, size_t *size, uint8_t *dest,\n                      unsigned int *frame_flags) {\n  vp9_rc_get_svc_params(cpi);\n  encode_frame_to_data_rate(cpi, size, dest, frame_flags,\n                            /*encode_frame_result = */ NULL);\n}\n\nstatic void Pass0Encode(VP9_COMP *cpi, size_t *size, uint8_t *dest,\n                        unsigned int *frame_flags) {\n  if (cpi->oxcf.rc_mode == VPX_CBR) {\n    vp9_rc_get_one_pass_cbr_params(cpi);\n  } else {\n    vp9_rc_get_one_pass_vbr_params(cpi);\n  }\n  encode_frame_to_data_rate(cpi, size, dest, frame_flags,\n                            /*encode_frame_result = */ NULL);\n}\n\n#if !CONFIG_REALTIME_ONLY\nstatic void Pass2Encode(VP9_COMP *cpi, size_t *size, uint8_t *dest,\n                        unsigned int *frame_flags,\n                        ENCODE_FRAME_RESULT *encode_frame_result) {\n  cpi->allow_encode_breakout = ENCODE_BREAKOUT_ENABLED;\n#if CONFIG_MISMATCH_DEBUG\n  mismatch_move_frame_idx_w();\n#endif\n  encode_frame_to_data_rate(cpi, size, dest, frame_flags, encode_frame_result);\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nint vp9_receive_raw_frame(VP9_COMP *cpi, vpx_enc_frame_flags_t frame_flags,\n                          YV12_BUFFER_CONFIG *sd, int64_t time_stamp,\n                          int64_t end_time) {\n  VP9_COMMON *const cm = &cpi->common;\n  struct vpx_usec_timer timer;\n  int res = 0;\n  const int subsampling_x = sd->subsampling_x;\n  const int subsampling_y = sd->subsampling_y;\n#if CONFIG_VP9_HIGHBITDEPTH\n  const int use_highbitdepth = (sd->flags & YV12_FLAG_HIGHBITDEPTH) != 0;\n#else\n  const int use_highbitdepth = 0;\n#endif\n\n  update_initial_width(cpi, use_highbitdepth, subsampling_x, subsampling_y);\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  setup_denoiser_buffer(cpi);\n#endif\n\n  alloc_raw_frame_buffers(cpi);\n\n  vpx_usec_timer_start(&timer);\n\n  if (vp9_lookahead_push(cpi->lookahead, sd, time_stamp, end_time,\n                         use_highbitdepth, frame_flags))\n    res = -1;\n  vpx_usec_timer_mark(&timer);\n  cpi->time_receive_data += vpx_usec_timer_elapsed(&timer);\n\n  if ((cm->profile == PROFILE_0 || cm->profile == PROFILE_2) &&\n      (subsampling_x != 1 || subsampling_y != 1)) {\n    vpx_internal_error(&cm->error, VPX_CODEC_INVALID_PARAM,\n                       \"Non-4:2:0 color format requires profile 1 or 3\");\n    res = -1;\n  }\n  if ((cm->profile == PROFILE_1 || cm->profile == PROFILE_3) &&\n      (subsampling_x == 1 && subsampling_y == 1)) {\n    vpx_internal_error(&cm->error, VPX_CODEC_INVALID_PARAM,\n                       \"4:2:0 color format requires profile 0 or 2\");\n    res = -1;\n  }\n\n  return res;\n}\n\nstatic int frame_is_reference(const VP9_COMP *cpi) {\n  const VP9_COMMON *cm = &cpi->common;\n\n  return cm->frame_type == KEY_FRAME || cpi->refresh_last_frame ||\n         cpi->refresh_golden_frame || cpi->refresh_alt_ref_frame ||\n         cm->refresh_frame_context || cm->lf.mode_ref_delta_update ||\n         cm->seg.update_map || cm->seg.update_data;\n}\n\nstatic void adjust_frame_rate(VP9_COMP *cpi,\n                              const struct lookahead_entry *source) {\n  int64_t this_duration;\n  int step = 0;\n\n  if (source->ts_start == cpi->first_time_stamp_ever) {\n    this_duration = source->ts_end - source->ts_start;\n    step = 1;\n  } else {\n    int64_t last_duration =\n        cpi->last_end_time_stamp_seen - cpi->last_time_stamp_seen;\n\n    this_duration = source->ts_end - cpi->last_end_time_stamp_seen;\n\n    // do a step update if the duration changes by 10%\n    if (last_duration)\n      step = (int)((this_duration - last_duration) * 10 / last_duration);\n  }\n\n  if (this_duration) {\n    if (step) {\n      vp9_new_framerate(cpi, 10000000.0 / this_duration);\n    } else {\n      // Average this frame's rate into the last second's average\n      // frame rate. If we haven't seen 1 second yet, then average\n      // over the whole interval seen.\n      const double interval = VPXMIN(\n          (double)(source->ts_end - cpi->first_time_stamp_ever), 10000000.0);\n      double avg_duration = 10000000.0 / cpi->framerate;\n      avg_duration *= (interval - avg_duration + this_duration);\n      avg_duration /= interval;\n\n      vp9_new_framerate(cpi, 10000000.0 / avg_duration);\n    }\n  }\n  cpi->last_time_stamp_seen = source->ts_start;\n  cpi->last_end_time_stamp_seen = source->ts_end;\n}\n\n// Returns 0 if this is not an alt ref else the offset of the source frame\n// used as the arf midpoint.\nstatic int get_arf_src_index(VP9_COMP *cpi) {\n  RATE_CONTROL *const rc = &cpi->rc;\n  int arf_src_index = 0;\n  if (is_altref_enabled(cpi)) {\n    if (cpi->oxcf.pass == 2) {\n      const GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n      if (gf_group->update_type[gf_group->index] == ARF_UPDATE) {\n        arf_src_index = gf_group->arf_src_offset[gf_group->index];\n      }\n    } else if (rc->source_alt_ref_pending) {\n      arf_src_index = rc->frames_till_gf_update_due;\n    }\n  }\n  return arf_src_index;\n}\n\nstatic void check_src_altref(VP9_COMP *cpi,\n                             const struct lookahead_entry *source) {\n  RATE_CONTROL *const rc = &cpi->rc;\n\n  if (cpi->oxcf.pass == 2) {\n    const GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n    rc->is_src_frame_alt_ref =\n        (gf_group->update_type[gf_group->index] == OVERLAY_UPDATE);\n  } else {\n    rc->is_src_frame_alt_ref =\n        cpi->alt_ref_source && (source == cpi->alt_ref_source);\n  }\n\n  if (rc->is_src_frame_alt_ref) {\n    // Current frame is an ARF overlay frame.\n    cpi->alt_ref_source = NULL;\n\n    // Don't refresh the last buffer for an ARF overlay frame. It will\n    // become the GF so preserve last as an alternative prediction option.\n    cpi->refresh_last_frame = 0;\n  }\n}\n\n#if CONFIG_INTERNAL_STATS\nstatic void adjust_image_stat(double y, double u, double v, double all,\n                              ImageStat *s) {\n  s->stat[Y] += y;\n  s->stat[U] += u;\n  s->stat[V] += v;\n  s->stat[ALL] += all;\n  s->worst = VPXMIN(s->worst, all);\n}\n#endif  // CONFIG_INTERNAL_STATS\n\n// Adjust the maximum allowable frame size for the target level.\nstatic void level_rc_framerate(VP9_COMP *cpi, int arf_src_index) {\n  RATE_CONTROL *const rc = &cpi->rc;\n  LevelConstraint *const ls = &cpi->level_constraint;\n  VP9_COMMON *const cm = &cpi->common;\n  const double max_cpb_size = ls->max_cpb_size;\n  vpx_clear_system_state();\n  rc->max_frame_bandwidth = VPXMIN(rc->max_frame_bandwidth, ls->max_frame_size);\n  if (frame_is_intra_only(cm)) {\n    rc->max_frame_bandwidth =\n        VPXMIN(rc->max_frame_bandwidth, (int)(max_cpb_size * 0.5));\n  } else if (arf_src_index > 0) {\n    rc->max_frame_bandwidth =\n        VPXMIN(rc->max_frame_bandwidth, (int)(max_cpb_size * 0.4));\n  } else {\n    rc->max_frame_bandwidth =\n        VPXMIN(rc->max_frame_bandwidth, (int)(max_cpb_size * 0.2));\n  }\n}\n\nstatic void update_level_info(VP9_COMP *cpi, size_t *size, int arf_src_index) {\n  VP9_COMMON *const cm = &cpi->common;\n  Vp9LevelInfo *const level_info = &cpi->level_info;\n  Vp9LevelSpec *const level_spec = &level_info->level_spec;\n  Vp9LevelStats *const level_stats = &level_info->level_stats;\n  int i, idx;\n  uint64_t luma_samples, dur_end;\n  const uint32_t luma_pic_size = cm->width * cm->height;\n  const uint32_t luma_pic_breadth = VPXMAX(cm->width, cm->height);\n  LevelConstraint *const level_constraint = &cpi->level_constraint;\n  const int8_t level_index = level_constraint->level_index;\n  double cpb_data_size;\n\n  vpx_clear_system_state();\n\n  // update level_stats\n  level_stats->total_compressed_size += *size;\n  if (cm->show_frame) {\n    level_stats->total_uncompressed_size +=\n        luma_pic_size +\n        2 * (luma_pic_size >> (cm->subsampling_x + cm->subsampling_y));\n    level_stats->time_encoded =\n        (cpi->last_end_time_stamp_seen - cpi->first_time_stamp_ever) /\n        (double)TICKS_PER_SEC;\n  }\n\n  if (arf_src_index > 0) {\n    if (!level_stats->seen_first_altref) {\n      level_stats->seen_first_altref = 1;\n    } else if (level_stats->frames_since_last_altref <\n               level_spec->min_altref_distance) {\n      level_spec->min_altref_distance = level_stats->frames_since_last_altref;\n    }\n    level_stats->frames_since_last_altref = 0;\n  } else {\n    ++level_stats->frames_since_last_altref;\n  }\n\n  if (level_stats->frame_window_buffer.len < FRAME_WINDOW_SIZE - 1) {\n    idx = (level_stats->frame_window_buffer.start +\n           level_stats->frame_window_buffer.len++) %\n          FRAME_WINDOW_SIZE;\n  } else {\n    idx = level_stats->frame_window_buffer.start;\n    level_stats->frame_window_buffer.start = (idx + 1) % FRAME_WINDOW_SIZE;\n  }\n  level_stats->frame_window_buffer.buf[idx].ts = cpi->last_time_stamp_seen;\n  level_stats->frame_window_buffer.buf[idx].size = (uint32_t)(*size);\n  level_stats->frame_window_buffer.buf[idx].luma_samples = luma_pic_size;\n\n  if (cm->frame_type == KEY_FRAME) {\n    level_stats->ref_refresh_map = 0;\n  } else {\n    int count = 0;\n    level_stats->ref_refresh_map |= vp9_get_refresh_mask(cpi);\n    // Also need to consider the case where the encoder refers to a buffer\n    // that has been implicitly refreshed after encoding a keyframe.\n    if (!cm->intra_only) {\n      level_stats->ref_refresh_map |= (1 << cpi->lst_fb_idx);\n      level_stats->ref_refresh_map |= (1 << cpi->gld_fb_idx);\n      level_stats->ref_refresh_map |= (1 << cpi->alt_fb_idx);\n    }\n    for (i = 0; i < REF_FRAMES; ++i) {\n      count += (level_stats->ref_refresh_map >> i) & 1;\n    }\n    if (count > level_spec->max_ref_frame_buffers) {\n      level_spec->max_ref_frame_buffers = count;\n    }\n  }\n\n  // update average_bitrate\n  level_spec->average_bitrate = (double)level_stats->total_compressed_size /\n                                125.0 / level_stats->time_encoded;\n\n  // update max_luma_sample_rate\n  luma_samples = 0;\n  for (i = 0; i < level_stats->frame_window_buffer.len; ++i) {\n    idx = (level_stats->frame_window_buffer.start +\n           level_stats->frame_window_buffer.len - 1 - i) %\n          FRAME_WINDOW_SIZE;\n    if (i == 0) {\n      dur_end = level_stats->frame_window_buffer.buf[idx].ts;\n    }\n    if (dur_end - level_stats->frame_window_buffer.buf[idx].ts >=\n        TICKS_PER_SEC) {\n      break;\n    }\n    luma_samples += level_stats->frame_window_buffer.buf[idx].luma_samples;\n  }\n  if (luma_samples > level_spec->max_luma_sample_rate) {\n    level_spec->max_luma_sample_rate = luma_samples;\n  }\n\n  // update max_cpb_size\n  cpb_data_size = 0;\n  for (i = 0; i < CPB_WINDOW_SIZE; ++i) {\n    if (i >= level_stats->frame_window_buffer.len) break;\n    idx = (level_stats->frame_window_buffer.start +\n           level_stats->frame_window_buffer.len - 1 - i) %\n          FRAME_WINDOW_SIZE;\n    cpb_data_size += level_stats->frame_window_buffer.buf[idx].size;\n  }\n  cpb_data_size = cpb_data_size / 125.0;\n  if (cpb_data_size > level_spec->max_cpb_size) {\n    level_spec->max_cpb_size = cpb_data_size;\n  }\n\n  // update max_luma_picture_size\n  if (luma_pic_size > level_spec->max_luma_picture_size) {\n    level_spec->max_luma_picture_size = luma_pic_size;\n  }\n\n  // update max_luma_picture_breadth\n  if (luma_pic_breadth > level_spec->max_luma_picture_breadth) {\n    level_spec->max_luma_picture_breadth = luma_pic_breadth;\n  }\n\n  // update compression_ratio\n  level_spec->compression_ratio = (double)level_stats->total_uncompressed_size *\n                                  cm->bit_depth /\n                                  level_stats->total_compressed_size / 8.0;\n\n  // update max_col_tiles\n  if (level_spec->max_col_tiles < (1 << cm->log2_tile_cols)) {\n    level_spec->max_col_tiles = (1 << cm->log2_tile_cols);\n  }\n\n  if (level_index >= 0 && level_constraint->fail_flag == 0) {\n    if (level_spec->max_luma_picture_size >\n        vp9_level_defs[level_index].max_luma_picture_size) {\n      level_constraint->fail_flag |= (1 << LUMA_PIC_SIZE_TOO_LARGE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[LUMA_PIC_SIZE_TOO_LARGE]);\n    }\n\n    if (level_spec->max_luma_picture_breadth >\n        vp9_level_defs[level_index].max_luma_picture_breadth) {\n      level_constraint->fail_flag |= (1 << LUMA_PIC_BREADTH_TOO_LARGE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[LUMA_PIC_BREADTH_TOO_LARGE]);\n    }\n\n    if ((double)level_spec->max_luma_sample_rate >\n        (double)vp9_level_defs[level_index].max_luma_sample_rate *\n            (1 + SAMPLE_RATE_GRACE_P)) {\n      level_constraint->fail_flag |= (1 << LUMA_SAMPLE_RATE_TOO_LARGE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[LUMA_SAMPLE_RATE_TOO_LARGE]);\n    }\n\n    if (level_spec->max_col_tiles > vp9_level_defs[level_index].max_col_tiles) {\n      level_constraint->fail_flag |= (1 << TOO_MANY_COLUMN_TILE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[TOO_MANY_COLUMN_TILE]);\n    }\n\n    if (level_spec->min_altref_distance <\n        vp9_level_defs[level_index].min_altref_distance) {\n      level_constraint->fail_flag |= (1 << ALTREF_DIST_TOO_SMALL);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[ALTREF_DIST_TOO_SMALL]);\n    }\n\n    if (level_spec->max_ref_frame_buffers >\n        vp9_level_defs[level_index].max_ref_frame_buffers) {\n      level_constraint->fail_flag |= (1 << TOO_MANY_REF_BUFFER);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[TOO_MANY_REF_BUFFER]);\n    }\n\n    if (level_spec->max_cpb_size > vp9_level_defs[level_index].max_cpb_size) {\n      level_constraint->fail_flag |= (1 << CPB_TOO_LARGE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[CPB_TOO_LARGE]);\n    }\n\n    // Set an upper bound for the next frame size. It will be used in\n    // level_rc_framerate() before encoding the next frame.\n    cpb_data_size = 0;\n    for (i = 0; i < CPB_WINDOW_SIZE - 1; ++i) {\n      if (i >= level_stats->frame_window_buffer.len) break;\n      idx = (level_stats->frame_window_buffer.start +\n             level_stats->frame_window_buffer.len - 1 - i) %\n            FRAME_WINDOW_SIZE;\n      cpb_data_size += level_stats->frame_window_buffer.buf[idx].size;\n    }\n    cpb_data_size = cpb_data_size / 125.0;\n    level_constraint->max_frame_size =\n        (int)((vp9_level_defs[level_index].max_cpb_size - cpb_data_size) *\n              1000.0);\n    if (level_stats->frame_window_buffer.len < CPB_WINDOW_SIZE - 1)\n      level_constraint->max_frame_size >>= 1;\n  }\n}\n\nvoid vp9_get_ref_frame_info(FRAME_UPDATE_TYPE update_type, int ref_frame_flags,\n                            RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES],\n                            int *ref_frame_coding_indexes,\n                            int *ref_frame_valid_list) {\n  if (update_type != KF_UPDATE) {\n    const VP9_REFFRAME inter_ref_flags[MAX_INTER_REF_FRAMES] = { VP9_LAST_FLAG,\n                                                                 VP9_GOLD_FLAG,\n                                                                 VP9_ALT_FLAG };\n    int i;\n    for (i = 0; i < MAX_INTER_REF_FRAMES; ++i) {\n      assert(ref_frame_bufs[i] != NULL);\n      ref_frame_coding_indexes[i] = ref_frame_bufs[i]->frame_coding_index;\n      ref_frame_valid_list[i] = (ref_frame_flags & inter_ref_flags[i]) != 0;\n    }\n  } else {\n    // No reference frame is available when this is a key frame.\n    int i;\n    for (i = 0; i < MAX_INTER_REF_FRAMES; ++i) {\n      ref_frame_coding_indexes[i] = -1;\n      ref_frame_valid_list[i] = 0;\n    }\n  }\n}\n\nvoid vp9_init_encode_frame_result(ENCODE_FRAME_RESULT *encode_frame_result) {\n  encode_frame_result->show_idx = -1;  // Actual encoding doesn't happen.\n#if CONFIG_RATE_CTRL\n  encode_frame_result->frame_coding_index = -1;\n  vp9_zero(encode_frame_result->coded_frame);\n  encode_frame_result->coded_frame.allocated = 0;\n  init_rq_history(&encode_frame_result->rq_history);\n#endif  // CONFIG_RATE_CTRL\n}\n\nint vp9_get_compressed_data(VP9_COMP *cpi, unsigned int *frame_flags,\n                            size_t *size, uint8_t *dest, int64_t *time_stamp,\n                            int64_t *time_end, int flush,\n                            ENCODE_FRAME_RESULT *encode_frame_result) {\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  VP9_COMMON *const cm = &cpi->common;\n  BufferPool *const pool = cm->buffer_pool;\n  RATE_CONTROL *const rc = &cpi->rc;\n  struct vpx_usec_timer cmptimer;\n  YV12_BUFFER_CONFIG *force_src_buffer = NULL;\n  struct lookahead_entry *last_source = NULL;\n  struct lookahead_entry *source = NULL;\n  int arf_src_index;\n  const int gf_group_index = cpi->twopass.gf_group.index;\n  int i;\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  if (oxcf->pass == 2) start_timing(cpi, vp9_get_compressed_data_time);\n#endif\n\n  if (is_one_pass_svc(cpi)) {\n    vp9_one_pass_svc_start_layer(cpi);\n  }\n\n  vpx_usec_timer_start(&cmptimer);\n\n  vp9_set_high_precision_mv(cpi, ALTREF_HIGH_PRECISION_MV);\n\n  // Is multi-arf enabled.\n  // Note that at the moment multi_arf is only configured for 2 pass VBR and\n  // will not work properly with svc.\n  // Enable the Jingning's new \"multi_layer_arf\" code if \"enable_auto_arf\"\n  // is greater than or equal to 2.\n  if ((oxcf->pass == 2) && !cpi->use_svc && (cpi->oxcf.enable_auto_arf >= 2))\n    cpi->multi_layer_arf = 1;\n  else\n    cpi->multi_layer_arf = 0;\n\n  // Normal defaults\n  cm->reset_frame_context = 0;\n  cm->refresh_frame_context = 1;\n  if (!is_one_pass_svc(cpi)) {\n    cpi->refresh_last_frame = 1;\n    cpi->refresh_golden_frame = 0;\n    cpi->refresh_alt_ref_frame = 0;\n  }\n\n  // Should we encode an arf frame.\n  arf_src_index = get_arf_src_index(cpi);\n\n  if (arf_src_index) {\n    for (i = 0; i <= arf_src_index; ++i) {\n      struct lookahead_entry *e = vp9_lookahead_peek(cpi->lookahead, i);\n      // Avoid creating an alt-ref if there's a forced keyframe pending.\n      if (e == NULL) {\n        break;\n      } else if (e->flags == VPX_EFLAG_FORCE_KF) {\n        arf_src_index = 0;\n        flush = 1;\n        break;\n      }\n    }\n  }\n\n  // Clear arf index stack before group of pictures processing starts.\n  if (gf_group_index == 1) {\n    stack_init(cpi->twopass.gf_group.arf_index_stack, MAX_LAG_BUFFERS * 2);\n    cpi->twopass.gf_group.stack_size = 0;\n  }\n\n  if (arf_src_index) {\n    assert(arf_src_index <= rc->frames_to_key);\n    if ((source = vp9_lookahead_peek(cpi->lookahead, arf_src_index)) != NULL) {\n      cpi->alt_ref_source = source;\n\n#if !CONFIG_REALTIME_ONLY\n      if ((oxcf->mode != REALTIME) && (oxcf->arnr_max_frames > 0) &&\n          (oxcf->arnr_strength > 0)) {\n        int bitrate = cpi->rc.avg_frame_bandwidth / 40;\n        int not_low_bitrate = bitrate > ALT_REF_AQ_LOW_BITRATE_BOUNDARY;\n\n        int not_last_frame = (cpi->lookahead->sz - arf_src_index > 1);\n        not_last_frame |= ALT_REF_AQ_APPLY_TO_LAST_FRAME;\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n        start_timing(cpi, vp9_temporal_filter_time);\n#endif\n        // Produce the filtered ARF frame.\n        vp9_temporal_filter(cpi, arf_src_index);\n        vpx_extend_frame_borders(&cpi->alt_ref_buffer);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n        end_timing(cpi, vp9_temporal_filter_time);\n#endif\n\n        // for small bitrates segmentation overhead usually\n        // eats all bitrate gain from enabling delta quantizers\n        if (cpi->oxcf.alt_ref_aq != 0 && not_low_bitrate && not_last_frame)\n          vp9_alt_ref_aq_setup_mode(cpi->alt_ref_aq, cpi);\n\n        force_src_buffer = &cpi->alt_ref_buffer;\n      }\n#endif\n      cm->show_frame = 0;\n      cm->intra_only = 0;\n      cpi->refresh_alt_ref_frame = 1;\n      cpi->refresh_golden_frame = 0;\n      cpi->refresh_last_frame = 0;\n      rc->is_src_frame_alt_ref = 0;\n      rc->source_alt_ref_pending = 0;\n    } else {\n      rc->source_alt_ref_pending = 0;\n    }\n  }\n\n  if (!source) {\n    // Get last frame source.\n    if (cm->current_video_frame > 0) {\n      if ((last_source = vp9_lookahead_peek(cpi->lookahead, -1)) == NULL)\n        return -1;\n    }\n\n    // Read in the source frame.\n    if (cpi->use_svc || cpi->svc.set_intra_only_frame)\n      source = vp9_svc_lookahead_pop(cpi, cpi->lookahead, flush);\n    else\n      source = vp9_lookahead_pop(cpi->lookahead, flush);\n\n    if (source != NULL) {\n      cm->show_frame = 1;\n      cm->intra_only = 0;\n      // If the flags indicate intra frame, but if the current picture is for\n      // spatial layer above first_spatial_layer_to_encode, it should not be an\n      // intra picture.\n      if ((source->flags & VPX_EFLAG_FORCE_KF) && cpi->use_svc &&\n          cpi->svc.spatial_layer_id > cpi->svc.first_spatial_layer_to_encode) {\n        source->flags &= ~(unsigned int)(VPX_EFLAG_FORCE_KF);\n      }\n\n      // Check to see if the frame should be encoded as an arf overlay.\n      check_src_altref(cpi, source);\n    }\n  }\n\n  if (source) {\n    cpi->un_scaled_source = cpi->Source =\n        force_src_buffer ? force_src_buffer : &source->img;\n\n#ifdef ENABLE_KF_DENOISE\n    // Copy of raw source for metrics calculation.\n    if (is_psnr_calc_enabled(cpi))\n      vp9_copy_and_extend_frame(cpi->Source, &cpi->raw_unscaled_source);\n#endif\n\n    cpi->unscaled_last_source = last_source != NULL ? &last_source->img : NULL;\n\n    *time_stamp = source->ts_start;\n    *time_end = source->ts_end;\n    *frame_flags = (source->flags & VPX_EFLAG_FORCE_KF) ? FRAMEFLAGS_KEY : 0;\n  } else {\n    *size = 0;\n    return -1;\n  }\n\n  if (source->ts_start < cpi->first_time_stamp_ever) {\n    cpi->first_time_stamp_ever = source->ts_start;\n    cpi->last_end_time_stamp_seen = source->ts_start;\n  }\n\n  // Clear down mmx registers\n  vpx_clear_system_state();\n\n  // adjust frame rates based on timestamps given\n  if (cm->show_frame) {\n    if (cpi->use_svc && cpi->svc.use_set_ref_frame_config &&\n        cpi->svc.duration[cpi->svc.spatial_layer_id] > 0)\n      vp9_svc_adjust_frame_rate(cpi);\n    else\n      adjust_frame_rate(cpi, source);\n  }\n\n  if (is_one_pass_svc(cpi)) {\n    vp9_update_temporal_layer_framerate(cpi);\n    vp9_restore_layer_context(cpi);\n  }\n\n  // Find a free buffer for the new frame, releasing the reference previously\n  // held.\n  if (cm->new_fb_idx != INVALID_IDX) {\n    --pool->frame_bufs[cm->new_fb_idx].ref_count;\n  }\n  cm->new_fb_idx = get_free_fb(cm);\n\n  if (cm->new_fb_idx == INVALID_IDX) return -1;\n  cm->cur_frame = &pool->frame_bufs[cm->new_fb_idx];\n  // If the frame buffer for current frame is the same as previous frame, MV in\n  // the base layer shouldn't be used as it'll cause data race.\n  if (cpi->svc.spatial_layer_id > 0 && cm->cur_frame == cm->prev_frame) {\n    cpi->svc.use_base_mv = 0;\n  }\n  // Start with a 0 size frame.\n  *size = 0;\n\n  cpi->frame_flags = *frame_flags;\n\n#if !CONFIG_REALTIME_ONLY\n  if ((oxcf->pass == 2) && !cpi->use_svc) {\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    start_timing(cpi, vp9_rc_get_second_pass_params_time);\n#endif\n    vp9_rc_get_second_pass_params(cpi);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    end_timing(cpi, vp9_rc_get_second_pass_params_time);\n#endif\n  } else if (oxcf->pass == 1) {\n    set_frame_size(cpi);\n  }\n#endif  // !CONFIG_REALTIME_ONLY\n\n  if (oxcf->pass != 1 && cpi->level_constraint.level_index >= 0 &&\n      cpi->level_constraint.fail_flag == 0)\n    level_rc_framerate(cpi, arf_src_index);\n\n  if (cpi->oxcf.pass != 0 || cpi->use_svc || frame_is_intra_only(cm) == 1) {\n    for (i = 0; i < REFS_PER_FRAME; ++i) cpi->scaled_ref_idx[i] = INVALID_IDX;\n  }\n\n  if (cpi->kmeans_data_arr_alloc == 0) {\n    const int mi_cols = mi_cols_aligned_to_sb(cm->mi_cols);\n    const int mi_rows = mi_cols_aligned_to_sb(cm->mi_rows);\n#if CONFIG_MULTITHREAD\n    pthread_mutex_init(&cpi->kmeans_mutex, NULL);\n#endif\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->kmeans_data_arr,\n        vpx_calloc(mi_rows * mi_cols, sizeof(*cpi->kmeans_data_arr)));\n    cpi->kmeans_data_stride = mi_cols;\n    cpi->kmeans_data_arr_alloc = 1;\n  }\n\n#if CONFIG_NON_GREEDY_MV\n  {\n    const int mi_cols = mi_cols_aligned_to_sb(cm->mi_cols);\n    const int mi_rows = mi_cols_aligned_to_sb(cm->mi_rows);\n    Status status = vp9_alloc_motion_field_info(\n        &cpi->motion_field_info, MAX_ARF_GOP_SIZE, mi_rows, mi_cols);\n    if (status == STATUS_FAILED) {\n      vpx_internal_error(&(cm)->error, VPX_CODEC_MEM_ERROR,\n                         \"vp9_alloc_motion_field_info failed\");\n    }\n  }\n#endif  // CONFIG_NON_GREEDY_MV\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  start_timing(cpi, setup_tpl_stats_time);\n#endif\n  if (gf_group_index == 1 &&\n      cpi->twopass.gf_group.update_type[gf_group_index] == ARF_UPDATE &&\n      cpi->sf.enable_tpl_model) {\n    vp9_init_tpl_buffer(cpi);\n    vp9_estimate_qp_gop(cpi);\n    vp9_setup_tpl_stats(cpi);\n  }\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  end_timing(cpi, setup_tpl_stats_time);\n#endif\n\n#if CONFIG_BITSTREAM_DEBUG\n  assert(cpi->oxcf.max_threads == 0 &&\n         \"bitstream debug tool does not support multithreading\");\n  bitstream_queue_record_write();\n#endif\n#if CONFIG_BITSTREAM_DEBUG || CONFIG_MISMATCH_DEBUG\n  bitstream_queue_set_frame_write(cm->current_video_frame * 2 + cm->show_frame);\n#endif\n\n  cpi->td.mb.fp_src_pred = 0;\n#if CONFIG_REALTIME_ONLY\n  (void)encode_frame_result;\n  if (cpi->use_svc) {\n    SvcEncode(cpi, size, dest, frame_flags);\n  } else {\n    // One pass encode\n    Pass0Encode(cpi, size, dest, frame_flags);\n  }\n#else  // !CONFIG_REALTIME_ONLY\n  if (oxcf->pass == 1 && !cpi->use_svc) {\n    const int lossless = is_lossless_requested(oxcf);\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (cpi->oxcf.use_highbitdepth)\n      cpi->td.mb.fwd_txfm4x4 =\n          lossless ? vp9_highbd_fwht4x4 : vpx_highbd_fdct4x4;\n    else\n      cpi->td.mb.fwd_txfm4x4 = lossless ? vp9_fwht4x4 : vpx_fdct4x4;\n    cpi->td.mb.highbd_inv_txfm_add =\n        lossless ? vp9_highbd_iwht4x4_add : vp9_highbd_idct4x4_add;\n#else\n    cpi->td.mb.fwd_txfm4x4 = lossless ? vp9_fwht4x4 : vpx_fdct4x4;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    cpi->td.mb.inv_txfm_add = lossless ? vp9_iwht4x4_add : vp9_idct4x4_add;\n    vp9_first_pass(cpi, source);\n  } else if (oxcf->pass == 2 && !cpi->use_svc) {\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    // Accumulate 2nd pass time in 2-pass case.\n    start_timing(cpi, Pass2Encode_time);\n#endif\n    Pass2Encode(cpi, size, dest, frame_flags, encode_frame_result);\n    vp9_twopass_postencode_update(cpi);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    end_timing(cpi, Pass2Encode_time);\n#endif\n  } else if (cpi->use_svc) {\n    SvcEncode(cpi, size, dest, frame_flags);\n  } else {\n    // One pass encode\n    Pass0Encode(cpi, size, dest, frame_flags);\n  }\n#endif  // CONFIG_REALTIME_ONLY\n\n  if (cm->show_frame) cm->cur_show_frame_fb_idx = cm->new_fb_idx;\n\n  if (cm->refresh_frame_context)\n    cm->frame_contexts[cm->frame_context_idx] = *cm->fc;\n\n  // No frame encoded, or frame was dropped, release scaled references.\n  if ((*size == 0) && (frame_is_intra_only(cm) == 0)) {\n    release_scaled_references(cpi);\n  }\n\n  if (*size > 0) {\n    cpi->droppable = !frame_is_reference(cpi);\n  }\n\n  // Save layer specific state.\n  if (is_one_pass_svc(cpi) || ((cpi->svc.number_temporal_layers > 1 ||\n                                cpi->svc.number_spatial_layers > 1) &&\n                               oxcf->pass == 2)) {\n    vp9_save_layer_context(cpi);\n  }\n\n  if (cpi->svc.spatial_layer_id == cpi->svc.number_spatial_layers - 1)\n    cpi->fixed_qp_onepass = 0;\n\n  vpx_usec_timer_mark(&cmptimer);\n  cpi->time_compress_data += vpx_usec_timer_elapsed(&cmptimer);\n\n  if (cpi->keep_level_stats && oxcf->pass != 1)\n    update_level_info(cpi, size, arf_src_index);\n\n#if CONFIG_INTERNAL_STATS\n\n  if (oxcf->pass != 1 && !cpi->last_frame_dropped) {\n    double samples = 0.0;\n    cpi->bytes += (int)(*size);\n\n    if (cm->show_frame) {\n      uint32_t bit_depth = 8;\n      uint32_t in_bit_depth = 8;\n      cpi->count++;\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (cm->use_highbitdepth) {\n        in_bit_depth = cpi->oxcf.input_bit_depth;\n        bit_depth = cm->bit_depth;\n      }\n#endif\n\n      if (cpi->b_calculate_psnr) {\n        YV12_BUFFER_CONFIG *orig = cpi->raw_source_frame;\n        YV12_BUFFER_CONFIG *recon = cpi->common.frame_to_show;\n        YV12_BUFFER_CONFIG *pp = &cm->post_proc_buffer;\n        PSNR_STATS psnr;\n#if CONFIG_VP9_HIGHBITDEPTH\n        vpx_calc_highbd_psnr(orig, recon, &psnr, cpi->td.mb.e_mbd.bd,\n                             in_bit_depth);\n#else\n        vpx_calc_psnr(orig, recon, &psnr);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n        adjust_image_stat(psnr.psnr[1], psnr.psnr[2], psnr.psnr[3],\n                          psnr.psnr[0], &cpi->psnr);\n        cpi->total_sq_error += psnr.sse[0];\n        cpi->total_samples += psnr.samples[0];\n        samples = psnr.samples[0];\n\n        {\n          PSNR_STATS psnr2;\n          double frame_ssim2 = 0, weight = 0;\n#if CONFIG_VP9_POSTPROC\n          if (vpx_alloc_frame_buffer(\n                  pp, recon->y_crop_width, recon->y_crop_height,\n                  cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                  cm->use_highbitdepth,\n#endif\n                  VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment) < 0) {\n            vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                               \"Failed to allocate post processing buffer\");\n          }\n          {\n            vp9_ppflags_t ppflags;\n            ppflags.post_proc_flag = VP9D_DEBLOCK;\n            ppflags.deblocking_level = 0;  // not used in vp9_post_proc_frame()\n            ppflags.noise_level = 0;       // not used in vp9_post_proc_frame()\n            vp9_post_proc_frame(cm, pp, &ppflags,\n                                cpi->un_scaled_source->y_width);\n          }\n#endif\n          vpx_clear_system_state();\n\n#if CONFIG_VP9_HIGHBITDEPTH\n          vpx_calc_highbd_psnr(orig, pp, &psnr2, cpi->td.mb.e_mbd.bd,\n                               cpi->oxcf.input_bit_depth);\n#else\n          vpx_calc_psnr(orig, pp, &psnr2);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n          cpi->totalp_sq_error += psnr2.sse[0];\n          cpi->totalp_samples += psnr2.samples[0];\n          adjust_image_stat(psnr2.psnr[1], psnr2.psnr[2], psnr2.psnr[3],\n                            psnr2.psnr[0], &cpi->psnrp);\n\n#if CONFIG_VP9_HIGHBITDEPTH\n          if (cm->use_highbitdepth) {\n            frame_ssim2 = vpx_highbd_calc_ssim(orig, recon, &weight, bit_depth,\n                                               in_bit_depth);\n          } else {\n            frame_ssim2 = vpx_calc_ssim(orig, recon, &weight);\n          }\n#else\n          frame_ssim2 = vpx_calc_ssim(orig, recon, &weight);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n          cpi->worst_ssim = VPXMIN(cpi->worst_ssim, frame_ssim2);\n          cpi->summed_quality += frame_ssim2 * weight;\n          cpi->summed_weights += weight;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n          if (cm->use_highbitdepth) {\n            frame_ssim2 = vpx_highbd_calc_ssim(orig, pp, &weight, bit_depth,\n                                               in_bit_depth);\n          } else {\n            frame_ssim2 = vpx_calc_ssim(orig, pp, &weight);\n          }\n#else\n          frame_ssim2 = vpx_calc_ssim(orig, pp, &weight);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n          cpi->summedp_quality += frame_ssim2 * weight;\n          cpi->summedp_weights += weight;\n#if 0\n          if (cm->show_frame) {\n            FILE *f = fopen(\"q_used.stt\", \"a\");\n            fprintf(f, \"%5d : Y%f7.3:U%f7.3:V%f7.3:F%f7.3:S%7.3f\\n\",\n                    cpi->common.current_video_frame, psnr2.psnr[1],\n                    psnr2.psnr[2], psnr2.psnr[3], psnr2.psnr[0], frame_ssim2);\n            fclose(f);\n          }\n#endif\n        }\n      }\n      if (cpi->b_calculate_blockiness) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        if (!cm->use_highbitdepth)\n#endif\n        {\n          double frame_blockiness = vp9_get_blockiness(\n              cpi->Source->y_buffer, cpi->Source->y_stride,\n              cm->frame_to_show->y_buffer, cm->frame_to_show->y_stride,\n              cpi->Source->y_width, cpi->Source->y_height);\n          cpi->worst_blockiness =\n              VPXMAX(cpi->worst_blockiness, frame_blockiness);\n          cpi->total_blockiness += frame_blockiness;\n        }\n      }\n\n      if (cpi->b_calculate_consistency) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        if (!cm->use_highbitdepth)\n#endif\n        {\n          double this_inconsistency = vpx_get_ssim_metrics(\n              cpi->Source->y_buffer, cpi->Source->y_stride,\n              cm->frame_to_show->y_buffer, cm->frame_to_show->y_stride,\n              cpi->Source->y_width, cpi->Source->y_height, cpi->ssim_vars,\n              &cpi->metrics, 1);\n\n          const double peak = (double)((1 << cpi->oxcf.input_bit_depth) - 1);\n          double consistency =\n              vpx_sse_to_psnr(samples, peak, (double)cpi->total_inconsistency);\n          if (consistency > 0.0)\n            cpi->worst_consistency =\n                VPXMIN(cpi->worst_consistency, consistency);\n          cpi->total_inconsistency += this_inconsistency;\n        }\n      }\n\n      {\n        double y, u, v, frame_all;\n        frame_all = vpx_calc_fastssim(cpi->Source, cm->frame_to_show, &y, &u,\n                                      &v, bit_depth, in_bit_depth);\n        adjust_image_stat(y, u, v, frame_all, &cpi->fastssim);\n      }\n      {\n        double y, u, v, frame_all;\n        frame_all = vpx_psnrhvs(cpi->Source, cm->frame_to_show, &y, &u, &v,\n                                bit_depth, in_bit_depth);\n        adjust_image_stat(y, u, v, frame_all, &cpi->psnrhvs);\n      }\n    }\n  }\n\n#endif\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  if (oxcf->pass == 2) end_timing(cpi, vp9_get_compressed_data_time);\n\n  // Print out timing information.\n  // Note: Use \"cpi->frame_component_time[0] > 100 us\" to avoid showing of\n  // show_existing_frame and lag-in-frames.\n  //  if (cpi->frame_component_time[0] > 100)\n  if (oxcf->pass == 2) {\n    uint64_t frame_total = 0, total = 0;\n    int i;\n\n    fprintf(stderr,\n            \"\\n Frame number: %d, Frame type: %s, Show Frame: %d, Q: %d\\n\",\n            cm->current_video_frame, get_frame_type_enum(cm->frame_type),\n            cm->show_frame, cm->base_qindex);\n    for (i = 0; i < kTimingComponents; i++) {\n      cpi->component_time[i] += cpi->frame_component_time[i];\n      // Use vp9_get_compressed_data_time (i = 0) as the total time.\n      if (i == 0) {\n        frame_total = cpi->frame_component_time[0];\n        total = cpi->component_time[0];\n      }\n      fprintf(stderr,\n              \" %50s:  %15\" PRId64 \" us [%6.2f%%] (total: %15\" PRId64\n              \" us [%6.2f%%])\\n\",\n              get_component_name(i), cpi->frame_component_time[i],\n              (float)((float)cpi->frame_component_time[i] * 100.0 /\n                      (float)frame_total),\n              cpi->component_time[i],\n              (float)((float)cpi->component_time[i] * 100.0 / (float)total));\n      cpi->frame_component_time[i] = 0;\n    }\n  }\n#endif\n\n  if (is_one_pass_svc(cpi)) {\n    if (cm->show_frame) {\n      ++cpi->svc.spatial_layer_to_encode;\n      if (cpi->svc.spatial_layer_to_encode >= cpi->svc.number_spatial_layers)\n        cpi->svc.spatial_layer_to_encode = 0;\n    }\n  }\n\n  vpx_clear_system_state();\n  return 0;\n}\n\nint vp9_get_preview_raw_frame(VP9_COMP *cpi, YV12_BUFFER_CONFIG *dest,\n                              vp9_ppflags_t *flags) {\n  VP9_COMMON *cm = &cpi->common;\n#if !CONFIG_VP9_POSTPROC\n  (void)flags;\n#endif\n\n  if (!cm->show_frame) {\n    return -1;\n  } else {\n    int ret;\n#if CONFIG_VP9_POSTPROC\n    ret = vp9_post_proc_frame(cm, dest, flags, cpi->un_scaled_source->y_width);\n#else\n    if (cm->frame_to_show) {\n      *dest = *cm->frame_to_show;\n      dest->y_width = cm->width;\n      dest->y_height = cm->height;\n      dest->uv_width = cm->width >> cm->subsampling_x;\n      dest->uv_height = cm->height >> cm->subsampling_y;\n      ret = 0;\n    } else {\n      ret = -1;\n    }\n#endif  // !CONFIG_VP9_POSTPROC\n    vpx_clear_system_state();\n    return ret;\n  }\n}\n\nint vp9_set_internal_size(VP9_COMP *cpi, VPX_SCALING_MODE horiz_mode,\n                          VPX_SCALING_MODE vert_mode) {\n  VP9_COMMON *cm = &cpi->common;\n  int hr = 0, hs = 0, vr = 0, vs = 0;\n\n  if (horiz_mode > VP8E_ONETWO || vert_mode > VP8E_ONETWO) return -1;\n\n  Scale2Ratio(horiz_mode, &hr, &hs);\n  Scale2Ratio(vert_mode, &vr, &vs);\n\n  // always go to the next whole number\n  cm->width = (hs - 1 + cpi->oxcf.width * hr) / hs;\n  cm->height = (vs - 1 + cpi->oxcf.height * vr) / vs;\n  if (cm->current_video_frame) {\n    assert(cm->width <= cpi->initial_width);\n    assert(cm->height <= cpi->initial_height);\n  }\n\n  update_frame_size(cpi);\n\n  return 0;\n}\n\nint vp9_set_size_literal(VP9_COMP *cpi, unsigned int width,\n                         unsigned int height) {\n  VP9_COMMON *cm = &cpi->common;\n#if CONFIG_VP9_HIGHBITDEPTH\n  update_initial_width(cpi, cm->use_highbitdepth, cpi->common.subsampling_x,\n                       cpi->common.subsampling_y);\n#else\n  update_initial_width(cpi, 0, cpi->common.subsampling_x,\n                       cpi->common.subsampling_y);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  setup_denoiser_buffer(cpi);\n#endif\n  alloc_raw_frame_buffers(cpi);\n  if (width) {\n    cm->width = width;\n    if (cm->width > cpi->initial_width) {\n      cm->width = cpi->initial_width;\n      printf(\"Warning: Desired width too large, changed to %d\\n\", cm->width);\n    }\n  }\n\n  if (height) {\n    cm->height = height;\n    if (cm->height > cpi->initial_height) {\n      cm->height = cpi->initial_height;\n      printf(\"Warning: Desired height too large, changed to %d\\n\", cm->height);\n    }\n  }\n  assert(cm->width <= cpi->initial_width);\n  assert(cm->height <= cpi->initial_height);\n\n  update_frame_size(cpi);\n\n  return 0;\n}\n\nvoid vp9_set_svc(VP9_COMP *cpi, int use_svc) {\n  cpi->use_svc = use_svc;\n  return;\n}\n\nint vp9_get_quantizer(const VP9_COMP *cpi) { return cpi->common.base_qindex; }\n\nvoid vp9_apply_encoding_flags(VP9_COMP *cpi, vpx_enc_frame_flags_t flags) {\n  if (flags &\n      (VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF)) {\n    int ref = 7;\n\n    if (flags & VP8_EFLAG_NO_REF_LAST) ref ^= VP9_LAST_FLAG;\n\n    if (flags & VP8_EFLAG_NO_REF_GF) ref ^= VP9_GOLD_FLAG;\n\n    if (flags & VP8_EFLAG_NO_REF_ARF) ref ^= VP9_ALT_FLAG;\n\n    vp9_use_as_reference(cpi, ref);\n  }\n\n  if (flags &\n      (VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n       VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF)) {\n    int upd = 7;\n\n    if (flags & VP8_EFLAG_NO_UPD_LAST) upd ^= VP9_LAST_FLAG;\n\n    if (flags & VP8_EFLAG_NO_UPD_GF) upd ^= VP9_GOLD_FLAG;\n\n    if (flags & VP8_EFLAG_NO_UPD_ARF) upd ^= VP9_ALT_FLAG;\n\n    vp9_update_reference(cpi, upd);\n  }\n\n  if (flags & VP8_EFLAG_NO_UPD_ENTROPY) {\n    vp9_update_entropy(cpi, 0);\n  }\n}\n\nvoid vp9_set_row_mt(VP9_COMP *cpi) {\n  // Enable row based multi-threading for supported modes of encoding\n  cpi->row_mt = 0;\n  if (((cpi->oxcf.mode == GOOD || cpi->oxcf.mode == BEST) &&\n       cpi->oxcf.speed < 5 && cpi->oxcf.pass == 1) &&\n      cpi->oxcf.row_mt && !cpi->use_svc)\n    cpi->row_mt = 1;\n\n  if (cpi->oxcf.mode == GOOD && cpi->oxcf.speed < 5 &&\n      (cpi->oxcf.pass == 0 || cpi->oxcf.pass == 2) && cpi->oxcf.row_mt &&\n      !cpi->use_svc)\n    cpi->row_mt = 1;\n\n  // In realtime mode, enable row based multi-threading for all the speed levels\n  // where non-rd path is used.\n  if (cpi->oxcf.mode == REALTIME && cpi->oxcf.speed >= 5 && cpi->oxcf.row_mt) {\n    cpi->row_mt = 1;\n  }\n\n  if (cpi->row_mt)\n    cpi->row_mt_bit_exact = 1;\n  else\n    cpi->row_mt_bit_exact = 0;\n}\n"], "fixing_code": ["/*\n *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#include <stdio.h>\n\n#include <climits>\n#include <vector>\n#include \"third_party/googletest/src/include/gtest/gtest.h\"\n#include \"test/codec_factory.h\"\n#include \"test/encode_test_driver.h\"\n#include \"test/i420_video_source.h\"\n#include \"test/video_source.h\"\n#include \"test/util.h\"\n\n// Enable(1) or Disable(0) writing of the compressed bitstream.\n#define WRITE_COMPRESSED_STREAM 0\n\nnamespace {\n\n#if WRITE_COMPRESSED_STREAM\nstatic void mem_put_le16(char *const mem, const unsigned int val) {\n  mem[0] = val;\n  mem[1] = val >> 8;\n}\n\nstatic void mem_put_le32(char *const mem, const unsigned int val) {\n  mem[0] = val;\n  mem[1] = val >> 8;\n  mem[2] = val >> 16;\n  mem[3] = val >> 24;\n}\n\nstatic void write_ivf_file_header(const vpx_codec_enc_cfg_t *const cfg,\n                                  int frame_cnt, FILE *const outfile) {\n  char header[32];\n\n  header[0] = 'D';\n  header[1] = 'K';\n  header[2] = 'I';\n  header[3] = 'F';\n  mem_put_le16(header + 4, 0);                    /* version */\n  mem_put_le16(header + 6, 32);                   /* headersize */\n  mem_put_le32(header + 8, 0x30395056);           /* fourcc (vp9) */\n  mem_put_le16(header + 12, cfg->g_w);            /* width */\n  mem_put_le16(header + 14, cfg->g_h);            /* height */\n  mem_put_le32(header + 16, cfg->g_timebase.den); /* rate */\n  mem_put_le32(header + 20, cfg->g_timebase.num); /* scale */\n  mem_put_le32(header + 24, frame_cnt);           /* length */\n  mem_put_le32(header + 28, 0);                   /* unused */\n\n  (void)fwrite(header, 1, 32, outfile);\n}\n\nstatic void write_ivf_frame_size(FILE *const outfile, const size_t size) {\n  char header[4];\n  mem_put_le32(header, static_cast<unsigned int>(size));\n  (void)fwrite(header, 1, 4, outfile);\n}\n\nstatic void write_ivf_frame_header(const vpx_codec_cx_pkt_t *const pkt,\n                                   FILE *const outfile) {\n  char header[12];\n  vpx_codec_pts_t pts;\n\n  if (pkt->kind != VPX_CODEC_CX_FRAME_PKT) return;\n\n  pts = pkt->data.frame.pts;\n  mem_put_le32(header, static_cast<unsigned int>(pkt->data.frame.sz));\n  mem_put_le32(header + 4, pts & 0xFFFFFFFF);\n  mem_put_le32(header + 8, pts >> 32);\n\n  (void)fwrite(header, 1, 12, outfile);\n}\n#endif  // WRITE_COMPRESSED_STREAM\n\nconst unsigned int kInitialWidth = 320;\nconst unsigned int kInitialHeight = 240;\n\nstruct FrameInfo {\n  FrameInfo(vpx_codec_pts_t _pts, unsigned int _w, unsigned int _h)\n      : pts(_pts), w(_w), h(_h) {}\n\n  vpx_codec_pts_t pts;\n  unsigned int w;\n  unsigned int h;\n};\n\nvoid ScaleForFrameNumber(unsigned int frame, unsigned int initial_w,\n                         unsigned int initial_h, unsigned int *w,\n                         unsigned int *h, bool flag_codec,\n                         bool smaller_width_larger_size_) {\n  *w = initial_w;\n  *h = initial_h;\n\n  if (smaller_width_larger_size_) {\n    if (frame < 30) {\n      return;\n    }\n    *w = initial_w * 7 / 10;\n    *h = initial_h * 16 / 10;\n    return;\n  }\n  if (frame < 10) {\n    return;\n  }\n  if (frame < 20) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 30) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 40) {\n    return;\n  }\n  if (frame < 50) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 60) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 70) {\n    return;\n  }\n  if (frame < 80) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 90) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 100) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 110) {\n    return;\n  }\n  if (frame < 120) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 130) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 140) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 150) {\n    return;\n  }\n  if (frame < 160) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 170) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 180) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 190) {\n    return;\n  }\n  if (frame < 200) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 210) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 220) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 230) {\n    return;\n  }\n  if (frame < 240) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 250) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 260) {\n    return;\n  }\n  // Go down very low.\n  if (frame < 270) {\n    *w = initial_w / 4;\n    *h = initial_h / 4;\n    return;\n  }\n  if (flag_codec == 1) {\n    // Cases that only works for VP9.\n    // For VP9: Swap width and height of original.\n    if (frame < 320) {\n      return;\n    }\n  }\n}\n\nclass ResizingVideoSource : public ::libvpx_test::DummyVideoSource {\n public:\n  ResizingVideoSource() {\n    SetSize(kInitialWidth, kInitialHeight);\n    limit_ = 350;\n    smaller_width_larger_size_ = false;\n  }\n  bool flag_codec_;\n  bool smaller_width_larger_size_;\n  ~ResizingVideoSource() override = default;\n\n protected:\n  void Next() override {\n    ++frame_;\n    unsigned int width = 0;\n    unsigned int height = 0;\n    ScaleForFrameNumber(frame_, kInitialWidth, kInitialHeight, &width, &height,\n                        flag_codec_, smaller_width_larger_size_);\n    SetSize(width, height);\n    FillFrame();\n  }\n};\n\nclass ResizeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWithParam<libvpx_test::TestMode> {\n protected:\n  ResizeTest() : EncoderTest(GET_PARAM(0)) {}\n\n  ~ResizeTest() override = default;\n\n  void SetUp() override {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n  }\n\n  void FramePktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    ASSERT_NE(static_cast<int>(pkt->data.frame.width[0]), 0);\n    ASSERT_NE(static_cast<int>(pkt->data.frame.height[0]), 0);\n    encode_frame_width_.push_back(pkt->data.frame.width[0]);\n    encode_frame_height_.push_back(pkt->data.frame.height[0]);\n  }\n\n  unsigned int GetFrameWidth(size_t idx) const {\n    return encode_frame_width_[idx];\n  }\n\n  unsigned int GetFrameHeight(size_t idx) const {\n    return encode_frame_height_[idx];\n  }\n\n  void DecompressedFrameHook(const vpx_image_t &img,\n                             vpx_codec_pts_t pts) override {\n    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));\n  }\n\n  std::vector<FrameInfo> frame_info_list_;\n  std::vector<unsigned int> encode_frame_width_;\n  std::vector<unsigned int> encode_frame_height_;\n};\n\nTEST_P(ResizeTest, TestExternalResizeWorks) {\n  ResizingVideoSource video;\n  video.flag_codec_ = false;\n  video.smaller_width_larger_size_ = false;\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    const size_t idx = info - frame_info_list_.begin();\n    ASSERT_EQ(info->w, GetFrameWidth(idx));\n    ASSERT_EQ(info->h, GetFrameHeight(idx));\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n  }\n}\n\nconst unsigned int kStepDownFrame = 3;\nconst unsigned int kStepUpFrame = 6;\n\nclass ResizeInternalTest : public ResizeTest {\n protected:\n#if WRITE_COMPRESSED_STREAM\n  ResizeInternalTest()\n      : ResizeTest(), frame0_psnr_(0.0), outfile_(nullptr), out_frames_(0) {}\n#else\n  ResizeInternalTest() : ResizeTest(), frame0_psnr_(0.0) {}\n#endif\n\n  ~ResizeInternalTest() override = default;\n\n  void BeginPassHook(unsigned int /*pass*/) override {\n#if WRITE_COMPRESSED_STREAM\n    outfile_ = fopen(\"vp90-2-05-resize.ivf\", \"wb\");\n#endif\n  }\n\n  void EndPassHook() override {\n#if WRITE_COMPRESSED_STREAM\n    if (outfile_) {\n      if (!fseek(outfile_, 0, SEEK_SET))\n        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n      fclose(outfile_);\n      outfile_ = nullptr;\n    }\n#endif\n  }\n\n  void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                          libvpx_test::Encoder *encoder) override {\n    if (change_config_) {\n      int new_q = 60;\n      if (video->frame() == 0) {\n        struct vpx_scaling_mode mode = { VP8E_ONETWO, VP8E_ONETWO };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n      if (video->frame() == 1) {\n        struct vpx_scaling_mode mode = { VP8E_NORMAL, VP8E_NORMAL };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n        cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = new_q;\n        encoder->Config(&cfg_);\n      }\n    } else {\n      if (video->frame() == kStepDownFrame) {\n        struct vpx_scaling_mode mode = { VP8E_FOURFIVE, VP8E_THREEFIVE };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n      if (video->frame() == kStepUpFrame) {\n        struct vpx_scaling_mode mode = { VP8E_NORMAL, VP8E_NORMAL };\n        encoder->Control(VP8E_SET_SCALEMODE, &mode);\n      }\n    }\n  }\n\n  void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    if (frame0_psnr_ == 0.) frame0_psnr_ = pkt->data.psnr.psnr[0];\n    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n  }\n\n#if WRITE_COMPRESSED_STREAM\n  void FramePktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) write_ivf_file_header(&cfg_, 0, outfile_);\n\n    // Write frame header and data.\n    write_ivf_frame_header(pkt, outfile_);\n    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n  }\n#endif\n\n  double frame0_psnr_;\n  bool change_config_;\n#if WRITE_COMPRESSED_STREAM\n  FILE *outfile_;\n  unsigned int out_frames_;\n#endif\n};\n\nTEST_P(ResizeInternalTest, TestInternalResizeWorks) {\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 10);\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  change_config_ = false;\n\n  // q picked such that initial keyframe on this clip is ~30dB PSNR\n  cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = 48;\n\n  // If the number of frames being encoded is smaller than g_lag_in_frames\n  // the encoded frame is unavailable using the current API. Comparing\n  // frames to detect mismatch would then not be possible. Set\n  // g_lag_in_frames = 0 to get around this.\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const vpx_codec_pts_t pts = info->pts;\n    if (pts >= kStepDownFrame && pts < kStepUpFrame) {\n      ASSERT_EQ(282U, info->w) << \"Frame \" << pts << \" had unexpected width\";\n      ASSERT_EQ(173U, info->h) << \"Frame \" << pts << \" had unexpected height\";\n    } else {\n      EXPECT_EQ(352U, info->w) << \"Frame \" << pts << \" had unexpected width\";\n      EXPECT_EQ(288U, info->h) << \"Frame \" << pts << \" had unexpected height\";\n    }\n  }\n}\n\nTEST_P(ResizeInternalTest, TestInternalResizeChangeConfig) {\n  ::libvpx_test::I420VideoSource video(\"hantro_collage_w352h288.yuv\", 352, 288,\n                                       30, 1, 0, 10);\n  cfg_.g_w = 352;\n  cfg_.g_h = 288;\n  change_config_ = true;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}\n\nclass ResizeRealtimeTest\n    : public ::libvpx_test::EncoderTest,\n      public ::libvpx_test::CodecTestWith2Params<libvpx_test::TestMode, int> {\n protected:\n  ResizeRealtimeTest() : EncoderTest(GET_PARAM(0)) {}\n  ~ResizeRealtimeTest() override = default;\n\n  void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                          libvpx_test::Encoder *encoder) override {\n    if (video->frame() == 0) {\n      encoder->Control(VP9E_SET_AQ_MODE, 3);\n      encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n    }\n\n    if (change_bitrate_ && video->frame() == 120) {\n      change_bitrate_ = false;\n      cfg_.rc_target_bitrate = 500;\n      encoder->Config(&cfg_);\n    }\n  }\n\n  void SetUp() override {\n    InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n  }\n\n  void DecompressedFrameHook(const vpx_image_t &img,\n                             vpx_codec_pts_t pts) override {\n    frame_info_list_.push_back(FrameInfo(pts, img.d_w, img.d_h));\n  }\n\n  void MismatchHook(const vpx_image_t *img1, const vpx_image_t *img2) override {\n    double mismatch_psnr = compute_psnr(img1, img2);\n    mismatch_psnr_ += mismatch_psnr;\n    ++mismatch_nframes_;\n  }\n\n  void FramePktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    ASSERT_NE(static_cast<int>(pkt->data.frame.width[0]), 0);\n    ASSERT_NE(static_cast<int>(pkt->data.frame.height[0]), 0);\n    encode_frame_width_.push_back(pkt->data.frame.width[0]);\n    encode_frame_height_.push_back(pkt->data.frame.height[0]);\n  }\n\n  unsigned int GetMismatchFrames() { return mismatch_nframes_; }\n\n  unsigned int GetFrameWidth(size_t idx) const {\n    return encode_frame_width_[idx];\n  }\n\n  unsigned int GetFrameHeight(size_t idx) const {\n    return encode_frame_height_[idx];\n  }\n\n  void DefaultConfig() {\n    cfg_.rc_buf_initial_sz = 500;\n    cfg_.rc_buf_optimal_sz = 600;\n    cfg_.rc_buf_sz = 1000;\n    cfg_.rc_min_quantizer = 2;\n    cfg_.rc_max_quantizer = 56;\n    cfg_.rc_undershoot_pct = 50;\n    cfg_.rc_overshoot_pct = 50;\n    cfg_.rc_end_usage = VPX_CBR;\n    cfg_.kf_mode = VPX_KF_AUTO;\n    cfg_.g_lag_in_frames = 0;\n    cfg_.kf_min_dist = cfg_.kf_max_dist = 3000;\n    // Enable dropped frames.\n    cfg_.rc_dropframe_thresh = 1;\n    // Enable error_resilience mode.\n    cfg_.g_error_resilient = 1;\n    // Enable dynamic resizing.\n    cfg_.rc_resize_allowed = 1;\n    // Run at low bitrate.\n    cfg_.rc_target_bitrate = 200;\n  }\n\n  std::vector<FrameInfo> frame_info_list_;\n  int set_cpu_used_;\n  bool change_bitrate_;\n  double mismatch_psnr_;\n  int mismatch_nframes_;\n  std::vector<unsigned int> encode_frame_width_;\n  std::vector<unsigned int> encode_frame_height_;\n};\n\nTEST_P(ResizeRealtimeTest, TestExternalResizeWorks) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = false;\n  DefaultConfig();\n  // Disable internal resize for this test.\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}\n\nTEST_P(ResizeRealtimeTest, TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  // Disable internal resize for this test.\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}\n\n// Verify the dynamic resizer behavior for real time, 1 pass CBR mode.\n// Run at low bitrate, with resize_allowed = 1, and verify that we get\n// one resize down event.\nTEST_P(ResizeRealtimeTest, TestInternalResizeDown) {\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 299);\n  DefaultConfig();\n  cfg_.g_w = 640;\n  cfg_.g_h = 480;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  unsigned int last_w = cfg_.g_w;\n  unsigned int last_h = cfg_.g_h;\n  int resize_count = 0;\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    if (info->w != last_w || info->h != last_h) {\n      // Verify that resize down occurs.\n      ASSERT_LT(info->w, last_w);\n      ASSERT_LT(info->h, last_h);\n      last_w = info->w;\n      last_h = info->h;\n      resize_count++;\n    }\n  }\n\n#if CONFIG_VP9_DECODER\n  // Verify that we get 1 resize down event in this test.\n  ASSERT_EQ(1, resize_count) << \"Resizing should occur.\";\n  EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n#else\n  printf(\"Warning: VP9 decoder unavailable, unable to check resize count!\\n\");\n#endif\n}\n\n// Verify the dynamic resizer behavior for real time, 1 pass CBR mode.\n// Start at low target bitrate, raise the bitrate in the middle of the clip,\n// scaling-up should occur after bitrate changed.\nTEST_P(ResizeRealtimeTest, TestInternalResizeDownUpChangeBitRate) {\n  ::libvpx_test::I420VideoSource video(\"niklas_640_480_30.yuv\", 640, 480, 30, 1,\n                                       0, 400);\n  DefaultConfig();\n  cfg_.g_w = 640;\n  cfg_.g_h = 480;\n  change_bitrate_ = true;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  // Disable dropped frames.\n  cfg_.rc_dropframe_thresh = 0;\n  // Starting bitrate low.\n  cfg_.rc_target_bitrate = 80;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n\n  unsigned int last_w = cfg_.g_w;\n  unsigned int last_h = cfg_.g_h;\n  int resize_count = 0;\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const size_t idx = info - frame_info_list_.begin();\n    ASSERT_EQ(info->w, GetFrameWidth(idx));\n    ASSERT_EQ(info->h, GetFrameHeight(idx));\n    if (info->w != last_w || info->h != last_h) {\n      resize_count++;\n      if (resize_count <= 2) {\n        // Verify that resize down occurs.\n        ASSERT_LT(info->w, last_w);\n        ASSERT_LT(info->h, last_h);\n      } else if (resize_count > 2) {\n        // Verify that resize up occurs.\n        ASSERT_GT(info->w, last_w);\n        ASSERT_GT(info->h, last_h);\n      }\n      last_w = info->w;\n      last_h = info->h;\n    }\n  }\n\n#if CONFIG_VP9_DECODER\n  // Verify that we get 4 resize events in this test.\n  ASSERT_EQ(resize_count, 4) << \"Resizing should occur twice.\";\n  EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n#else\n  printf(\"Warning: VP9 decoder unavailable, unable to check resize count!\\n\");\n#endif\n}\n\nvpx_img_fmt_t CspForFrameNumber(int frame) {\n  if (frame < 10) return VPX_IMG_FMT_I420;\n  if (frame < 20) return VPX_IMG_FMT_I444;\n  return VPX_IMG_FMT_I420;\n}\n\nclass ResizeCspTest : public ResizeTest {\n protected:\n#if WRITE_COMPRESSED_STREAM\n  ResizeCspTest()\n      : ResizeTest(), frame0_psnr_(0.0), outfile_(nullptr), out_frames_(0) {}\n#else\n  ResizeCspTest() : ResizeTest(), frame0_psnr_(0.0) {}\n#endif\n\n  ~ResizeCspTest() override = default;\n\n  void BeginPassHook(unsigned int /*pass*/) override {\n#if WRITE_COMPRESSED_STREAM\n    outfile_ = fopen(\"vp91-2-05-cspchape.ivf\", \"wb\");\n#endif\n  }\n\n  void EndPassHook() override {\n#if WRITE_COMPRESSED_STREAM\n    if (outfile_) {\n      if (!fseek(outfile_, 0, SEEK_SET))\n        write_ivf_file_header(&cfg_, out_frames_, outfile_);\n      fclose(outfile_);\n      outfile_ = nullptr;\n    }\n#endif\n  }\n\n  void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                          libvpx_test::Encoder *encoder) override {\n    if (CspForFrameNumber(video->frame()) != VPX_IMG_FMT_I420 &&\n        cfg_.g_profile != 1) {\n      cfg_.g_profile = 1;\n      encoder->Config(&cfg_);\n    }\n    if (CspForFrameNumber(video->frame()) == VPX_IMG_FMT_I420 &&\n        cfg_.g_profile != 0) {\n      cfg_.g_profile = 0;\n      encoder->Config(&cfg_);\n    }\n  }\n\n  void PSNRPktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    if (frame0_psnr_ == 0.) frame0_psnr_ = pkt->data.psnr.psnr[0];\n    EXPECT_NEAR(pkt->data.psnr.psnr[0], frame0_psnr_, 2.0);\n  }\n\n#if WRITE_COMPRESSED_STREAM\n  void FramePktHook(const vpx_codec_cx_pkt_t *pkt) override {\n    ++out_frames_;\n\n    // Write initial file header if first frame.\n    if (pkt->data.frame.pts == 0) write_ivf_file_header(&cfg_, 0, outfile_);\n\n    // Write frame header and data.\n    write_ivf_frame_header(pkt, outfile_);\n    (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n  }\n#endif\n\n  double frame0_psnr_;\n#if WRITE_COMPRESSED_STREAM\n  FILE *outfile_;\n  unsigned int out_frames_;\n#endif\n};\n\nclass ResizingCspVideoSource : public ::libvpx_test::DummyVideoSource {\n public:\n  ResizingCspVideoSource() {\n    SetSize(kInitialWidth, kInitialHeight);\n    limit_ = 30;\n  }\n\n  ~ResizingCspVideoSource() override = default;\n\n protected:\n  void Next() override {\n    ++frame_;\n    SetImageFormat(CspForFrameNumber(frame_));\n    FillFrame();\n  }\n};\n\nTEST_P(ResizeCspTest, TestResizeCspWorks) {\n  ResizingCspVideoSource video;\n  init_flags_ = VPX_CODEC_USE_PSNR;\n  cfg_.rc_min_quantizer = cfg_.rc_max_quantizer = 48;\n  cfg_.g_lag_in_frames = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n}\n\nVP8_INSTANTIATE_TEST_SUITE(ResizeTest, ONE_PASS_TEST_MODES);\nVP9_INSTANTIATE_TEST_SUITE(ResizeTest, ONE_PASS_TEST_MODES);\nVP9_INSTANTIATE_TEST_SUITE(ResizeInternalTest,\n                           ::testing::Values(::libvpx_test::kOnePassBest));\nVP9_INSTANTIATE_TEST_SUITE(ResizeRealtimeTest,\n                           ::testing::Values(::libvpx_test::kRealTime),\n                           ::testing::Range(5, 9));\nVP9_INSTANTIATE_TEST_SUITE(ResizeCspTest,\n                           ::testing::Values(::libvpx_test::kRealTime));\n}  // namespace\n", "/*\n *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n\n#include \"./vpx_config.h\"\n#include \"vpx_mem/vpx_mem.h\"\n\n#include \"vp9/common/vp9_alloccommon.h\"\n#include \"vp9/common/vp9_blockd.h\"\n#include \"vp9/common/vp9_entropymode.h\"\n#include \"vp9/common/vp9_entropymv.h\"\n#include \"vp9/common/vp9_onyxc_int.h\"\n\nvoid vp9_set_mi_size(int *mi_rows, int *mi_cols, int *mi_stride, int width,\n                     int height) {\n  const int aligned_width = ALIGN_POWER_OF_TWO(width, MI_SIZE_LOG2);\n  const int aligned_height = ALIGN_POWER_OF_TWO(height, MI_SIZE_LOG2);\n  *mi_cols = aligned_width >> MI_SIZE_LOG2;\n  *mi_rows = aligned_height >> MI_SIZE_LOG2;\n  *mi_stride = calc_mi_size(*mi_cols);\n}\n\nvoid vp9_set_mb_size(int *mb_rows, int *mb_cols, int *mb_num, int mi_rows,\n                     int mi_cols) {\n  *mb_cols = (mi_cols + 1) >> 1;\n  *mb_rows = (mi_rows + 1) >> 1;\n  *mb_num = (*mb_rows) * (*mb_cols);\n}\n\nvoid vp9_set_mb_mi(VP9_COMMON *cm, int width, int height) {\n  vp9_set_mi_size(&cm->mi_rows, &cm->mi_cols, &cm->mi_stride, width, height);\n  vp9_set_mb_size(&cm->mb_rows, &cm->mb_cols, &cm->MBs, cm->mi_rows,\n                  cm->mi_cols);\n}\n\nstatic int alloc_seg_map(VP9_COMMON *cm, int seg_map_size) {\n  int i;\n\n  for (i = 0; i < NUM_PING_PONG_BUFFERS; ++i) {\n    cm->seg_map_array[i] = (uint8_t *)vpx_calloc(seg_map_size, 1);\n    if (cm->seg_map_array[i] == NULL) return 1;\n  }\n  cm->seg_map_alloc_size = seg_map_size;\n\n  // Init the index.\n  cm->seg_map_idx = 0;\n  cm->prev_seg_map_idx = 1;\n\n  cm->current_frame_seg_map = cm->seg_map_array[cm->seg_map_idx];\n  cm->last_frame_seg_map = cm->seg_map_array[cm->prev_seg_map_idx];\n\n  return 0;\n}\n\nstatic void free_seg_map(VP9_COMMON *cm) {\n  int i;\n\n  for (i = 0; i < NUM_PING_PONG_BUFFERS; ++i) {\n    vpx_free(cm->seg_map_array[i]);\n    cm->seg_map_array[i] = NULL;\n  }\n  cm->seg_map_alloc_size = 0;\n\n  cm->current_frame_seg_map = NULL;\n  cm->last_frame_seg_map = NULL;\n}\n\nvoid vp9_free_ref_frame_buffers(BufferPool *pool) {\n  int i;\n\n  if (!pool) return;\n\n  for (i = 0; i < FRAME_BUFFERS; ++i) {\n    if (!pool->frame_bufs[i].released &&\n        pool->frame_bufs[i].raw_frame_buffer.data != NULL) {\n      pool->release_fb_cb(pool->cb_priv, &pool->frame_bufs[i].raw_frame_buffer);\n      pool->frame_bufs[i].ref_count = 0;\n      pool->frame_bufs[i].released = 1;\n    }\n    vpx_free(pool->frame_bufs[i].mvs);\n    pool->frame_bufs[i].mvs = NULL;\n    vpx_free_frame_buffer(&pool->frame_bufs[i].buf);\n  }\n}\n\nvoid vp9_free_postproc_buffers(VP9_COMMON *cm) {\n#if CONFIG_VP9_POSTPROC\n  vpx_free_frame_buffer(&cm->post_proc_buffer);\n  vpx_free_frame_buffer(&cm->post_proc_buffer_int);\n  vpx_free(cm->postproc_state.limits);\n  cm->postproc_state.limits = NULL;\n  vpx_free(cm->postproc_state.generated_noise);\n  cm->postproc_state.generated_noise = NULL;\n#else\n  (void)cm;\n#endif\n}\n\nvoid vp9_free_context_buffers(VP9_COMMON *cm) {\n  if (cm->free_mi) cm->free_mi(cm);\n  free_seg_map(cm);\n  vpx_free(cm->above_context);\n  cm->above_context = NULL;\n  vpx_free(cm->above_seg_context);\n  cm->above_seg_context = NULL;\n  cm->above_context_alloc_cols = 0;\n  vpx_free(cm->lf.lfm);\n  cm->lf.lfm = NULL;\n}\n\nint vp9_alloc_loop_filter(VP9_COMMON *cm) {\n  vpx_free(cm->lf.lfm);\n  // Each lfm holds bit masks for all the 8x8 blocks in a 64x64 region.  The\n  // stride and rows are rounded up / truncated to a multiple of 8.\n  cm->lf.lfm_stride = (cm->mi_cols + (MI_BLOCK_SIZE - 1)) >> 3;\n  cm->lf.lfm = (LOOP_FILTER_MASK *)vpx_calloc(\n      ((cm->mi_rows + (MI_BLOCK_SIZE - 1)) >> 3) * cm->lf.lfm_stride,\n      sizeof(*cm->lf.lfm));\n  if (!cm->lf.lfm) return 1;\n  return 0;\n}\n\nint vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}\n\nvoid vp9_remove_common(VP9_COMMON *cm) {\n#if CONFIG_VP9_POSTPROC\n  vp9_free_postproc_buffers(cm);\n#endif\n  vp9_free_context_buffers(cm);\n\n  vpx_free(cm->fc);\n  cm->fc = NULL;\n  vpx_free(cm->frame_contexts);\n  cm->frame_contexts = NULL;\n}\n\nvoid vp9_init_context_buffers(VP9_COMMON *cm) {\n  cm->setup_mi(cm);\n  if (cm->last_frame_seg_map)\n    memset(cm->last_frame_seg_map, 0, cm->mi_rows * cm->mi_cols);\n}\n\nvoid vp9_swap_current_and_last_seg_map(VP9_COMMON *cm) {\n  // Swap indices.\n  const int tmp = cm->seg_map_idx;\n  cm->seg_map_idx = cm->prev_seg_map_idx;\n  cm->prev_seg_map_idx = tmp;\n\n  cm->current_frame_seg_map = cm->seg_map_array[cm->seg_map_idx];\n  cm->last_frame_seg_map = cm->seg_map_array[cm->prev_seg_map_idx];\n}\n", "/*\n * Copyright (c) 2010 The WebM project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree. An additional intellectual property rights grant can be found\n *  in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"./vp9_rtcd.h\"\n#include \"./vpx_config.h\"\n#include \"./vpx_dsp_rtcd.h\"\n#include \"./vpx_scale_rtcd.h\"\n#include \"vpx_dsp/psnr.h\"\n#include \"vpx_dsp/vpx_dsp_common.h\"\n#include \"vpx_dsp/vpx_filter.h\"\n#if CONFIG_INTERNAL_STATS\n#include \"vpx_dsp/ssim.h\"\n#endif\n#include \"vpx_ports/mem.h\"\n#include \"vpx_ports/system_state.h\"\n#include \"vpx_ports/vpx_once.h\"\n#include \"vpx_ports/vpx_timer.h\"\n#if CONFIG_BITSTREAM_DEBUG || CONFIG_MISMATCH_DEBUG\n#include \"vpx_util/vpx_debug_util.h\"\n#endif  // CONFIG_BITSTREAM_DEBUG || CONFIG_MISMATCH_DEBUG\n\n#include \"vp9/common/vp9_alloccommon.h\"\n#include \"vp9/common/vp9_filter.h\"\n#include \"vp9/common/vp9_idct.h\"\n#if CONFIG_VP9_POSTPROC\n#include \"vp9/common/vp9_postproc.h\"\n#endif\n#include \"vp9/common/vp9_reconinter.h\"\n#include \"vp9/common/vp9_reconintra.h\"\n#include \"vp9/common/vp9_tile_common.h\"\n\n#if !CONFIG_REALTIME_ONLY\n#include \"vp9/encoder/vp9_alt_ref_aq.h\"\n#include \"vp9/encoder/vp9_aq_360.h\"\n#include \"vp9/encoder/vp9_aq_complexity.h\"\n#endif\n#include \"vp9/encoder/vp9_aq_cyclicrefresh.h\"\n#if !CONFIG_REALTIME_ONLY\n#include \"vp9/encoder/vp9_aq_variance.h\"\n#endif\n#include \"vp9/encoder/vp9_bitstream.h\"\n#if CONFIG_INTERNAL_STATS\n#include \"vp9/encoder/vp9_blockiness.h\"\n#endif\n#include \"vp9/encoder/vp9_context_tree.h\"\n#include \"vp9/encoder/vp9_encodeframe.h\"\n#include \"vp9/encoder/vp9_encodemb.h\"\n#include \"vp9/encoder/vp9_encodemv.h\"\n#include \"vp9/encoder/vp9_encoder.h\"\n#include \"vp9/encoder/vp9_ethread.h\"\n#include \"vp9/encoder/vp9_extend.h\"\n#include \"vp9/encoder/vp9_firstpass.h\"\n#include \"vp9/encoder/vp9_mbgraph.h\"\n#if CONFIG_NON_GREEDY_MV\n#include \"vp9/encoder/vp9_mcomp.h\"\n#endif\n#include \"vp9/encoder/vp9_multi_thread.h\"\n#include \"vp9/encoder/vp9_noise_estimate.h\"\n#include \"vp9/encoder/vp9_picklpf.h\"\n#include \"vp9/encoder/vp9_ratectrl.h\"\n#include \"vp9/encoder/vp9_rd.h\"\n#include \"vp9/encoder/vp9_resize.h\"\n#include \"vp9/encoder/vp9_segmentation.h\"\n#include \"vp9/encoder/vp9_skin_detection.h\"\n#include \"vp9/encoder/vp9_speed_features.h\"\n#include \"vp9/encoder/vp9_svc_layercontext.h\"\n#include \"vp9/encoder/vp9_temporal_filter.h\"\n#include \"vp9/encoder/vp9_tpl_model.h\"\n#include \"vp9/vp9_cx_iface.h\"\n\n#include \"vpx/vpx_ext_ratectrl.h\"\n\n#define AM_SEGMENT_ID_INACTIVE 7\n#define AM_SEGMENT_ID_ACTIVE 0\n\n// Whether to use high precision mv for altref computation.\n#define ALTREF_HIGH_PRECISION_MV 1\n\n// Q threshold for high precision mv. Choose a very high value for now so that\n// HIGH_PRECISION is always chosen.\n#define HIGH_PRECISION_MV_QTHRESH 200\n\n#define FRAME_SIZE_FACTOR 128  // empirical params for context model threshold\n#define FRAME_RATE_FACTOR 8\n\n#ifdef OUTPUT_YUV_DENOISED\nFILE *yuv_denoised_file = NULL;\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\nstatic FILE *yuv_skinmap_file = NULL;\n#endif\n#ifdef OUTPUT_YUV_REC\nFILE *yuv_rec_file;\n#endif\n#ifdef OUTPUT_YUV_SVC_SRC\nFILE *yuv_svc_src[3] = { NULL, NULL, NULL };\n#endif\n\n#if 0\nFILE *framepsnr;\nFILE *kf_list;\nFILE *keyfile;\n#endif\n\n#ifdef ENABLE_KF_DENOISE\n// Test condition for spatial denoise of source.\nstatic int is_spatial_denoise_enabled(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n\n  return (oxcf->pass != 1) && !is_lossless_requested(&cpi->oxcf) &&\n         frame_is_intra_only(cm);\n}\n#endif\n\n#if !CONFIG_REALTIME_ONLY\n// compute adaptive threshold for skip recoding\nstatic int compute_context_model_thresh(const VP9_COMP *const cpi) {\n  const VP9_COMMON *const cm = &cpi->common;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  const int frame_size = (cm->width * cm->height) >> 10;\n  const int bitrate = (int)(oxcf->target_bandwidth >> 10);\n  const int qindex_factor = cm->base_qindex + (MAXQ >> 1);\n\n  // This equation makes the threshold adaptive to frame size.\n  // Coding gain obtained by recoding comes from alternate frames of large\n  // content change. We skip recoding if the difference of previous and current\n  // frame context probability model is less than a certain threshold.\n  // The first component is the most critical part to guarantee adaptivity.\n  // Other parameters are estimated based on normal setting of hd resolution\n  // parameters. e.g. frame_size = 1920x1080, bitrate = 8000, qindex_factor < 50\n  const int thresh =\n      ((FRAME_SIZE_FACTOR * frame_size - FRAME_RATE_FACTOR * bitrate) *\n       qindex_factor) >>\n      9;\n\n  return thresh;\n}\n\n// compute the total cost difference between current\n// and previous frame context prob model.\nstatic int compute_context_model_diff(const VP9_COMMON *const cm) {\n  const FRAME_CONTEXT *const pre_fc =\n      &cm->frame_contexts[cm->frame_context_idx];\n  const FRAME_CONTEXT *const cur_fc = cm->fc;\n  const FRAME_COUNTS *counts = &cm->counts;\n  vpx_prob pre_last_prob, cur_last_prob;\n  int diff = 0;\n  int i, j, k, l, m, n;\n\n  // y_mode_prob\n  for (i = 0; i < BLOCK_SIZE_GROUPS; ++i) {\n    for (j = 0; j < INTRA_MODES - 1; ++j) {\n      diff += (int)counts->y_mode[i][j] *\n              (pre_fc->y_mode_prob[i][j] - cur_fc->y_mode_prob[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->y_mode_prob[i][INTRA_MODES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->y_mode_prob[i][INTRA_MODES - 2];\n\n    diff += (int)counts->y_mode[i][INTRA_MODES - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // uv_mode_prob\n  for (i = 0; i < INTRA_MODES; ++i) {\n    for (j = 0; j < INTRA_MODES - 1; ++j) {\n      diff += (int)counts->uv_mode[i][j] *\n              (pre_fc->uv_mode_prob[i][j] - cur_fc->uv_mode_prob[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->uv_mode_prob[i][INTRA_MODES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->uv_mode_prob[i][INTRA_MODES - 2];\n\n    diff += (int)counts->uv_mode[i][INTRA_MODES - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // partition_prob\n  for (i = 0; i < PARTITION_CONTEXTS; ++i) {\n    for (j = 0; j < PARTITION_TYPES - 1; ++j) {\n      diff += (int)counts->partition[i][j] *\n              (pre_fc->partition_prob[i][j] - cur_fc->partition_prob[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->partition_prob[i][PARTITION_TYPES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->partition_prob[i][PARTITION_TYPES - 2];\n\n    diff += (int)counts->partition[i][PARTITION_TYPES - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // coef_probs\n  for (i = 0; i < TX_SIZES; ++i) {\n    for (j = 0; j < PLANE_TYPES; ++j) {\n      for (k = 0; k < REF_TYPES; ++k) {\n        for (l = 0; l < COEF_BANDS; ++l) {\n          for (m = 0; m < BAND_COEFF_CONTEXTS(l); ++m) {\n            for (n = 0; n < UNCONSTRAINED_NODES; ++n) {\n              diff += (int)counts->coef[i][j][k][l][m][n] *\n                      (pre_fc->coef_probs[i][j][k][l][m][n] -\n                       cur_fc->coef_probs[i][j][k][l][m][n]);\n            }\n\n            pre_last_prob =\n                MAX_PROB -\n                pre_fc->coef_probs[i][j][k][l][m][UNCONSTRAINED_NODES - 1];\n            cur_last_prob =\n                MAX_PROB -\n                cur_fc->coef_probs[i][j][k][l][m][UNCONSTRAINED_NODES - 1];\n\n            diff += (int)counts->coef[i][j][k][l][m][UNCONSTRAINED_NODES] *\n                    (pre_last_prob - cur_last_prob);\n          }\n        }\n      }\n    }\n  }\n\n  // switchable_interp_prob\n  for (i = 0; i < SWITCHABLE_FILTER_CONTEXTS; ++i) {\n    for (j = 0; j < SWITCHABLE_FILTERS - 1; ++j) {\n      diff += (int)counts->switchable_interp[i][j] *\n              (pre_fc->switchable_interp_prob[i][j] -\n               cur_fc->switchable_interp_prob[i][j]);\n    }\n    pre_last_prob =\n        MAX_PROB - pre_fc->switchable_interp_prob[i][SWITCHABLE_FILTERS - 2];\n    cur_last_prob =\n        MAX_PROB - cur_fc->switchable_interp_prob[i][SWITCHABLE_FILTERS - 2];\n\n    diff += (int)counts->switchable_interp[i][SWITCHABLE_FILTERS - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // inter_mode_probs\n  for (i = 0; i < INTER_MODE_CONTEXTS; ++i) {\n    for (j = 0; j < INTER_MODES - 1; ++j) {\n      diff += (int)counts->inter_mode[i][j] *\n              (pre_fc->inter_mode_probs[i][j] - cur_fc->inter_mode_probs[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->inter_mode_probs[i][INTER_MODES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->inter_mode_probs[i][INTER_MODES - 2];\n\n    diff += (int)counts->inter_mode[i][INTER_MODES - 1] *\n            (pre_last_prob - cur_last_prob);\n  }\n\n  // intra_inter_prob\n  for (i = 0; i < INTRA_INTER_CONTEXTS; ++i) {\n    diff += (int)counts->intra_inter[i][0] *\n            (pre_fc->intra_inter_prob[i] - cur_fc->intra_inter_prob[i]);\n\n    pre_last_prob = MAX_PROB - pre_fc->intra_inter_prob[i];\n    cur_last_prob = MAX_PROB - cur_fc->intra_inter_prob[i];\n\n    diff += (int)counts->intra_inter[i][1] * (pre_last_prob - cur_last_prob);\n  }\n\n  // comp_inter_prob\n  for (i = 0; i < COMP_INTER_CONTEXTS; ++i) {\n    diff += (int)counts->comp_inter[i][0] *\n            (pre_fc->comp_inter_prob[i] - cur_fc->comp_inter_prob[i]);\n\n    pre_last_prob = MAX_PROB - pre_fc->comp_inter_prob[i];\n    cur_last_prob = MAX_PROB - cur_fc->comp_inter_prob[i];\n\n    diff += (int)counts->comp_inter[i][1] * (pre_last_prob - cur_last_prob);\n  }\n\n  // single_ref_prob\n  for (i = 0; i < REF_CONTEXTS; ++i) {\n    for (j = 0; j < 2; ++j) {\n      diff += (int)counts->single_ref[i][j][0] *\n              (pre_fc->single_ref_prob[i][j] - cur_fc->single_ref_prob[i][j]);\n\n      pre_last_prob = MAX_PROB - pre_fc->single_ref_prob[i][j];\n      cur_last_prob = MAX_PROB - cur_fc->single_ref_prob[i][j];\n\n      diff +=\n          (int)counts->single_ref[i][j][1] * (pre_last_prob - cur_last_prob);\n    }\n  }\n\n  // comp_ref_prob\n  for (i = 0; i < REF_CONTEXTS; ++i) {\n    diff += (int)counts->comp_ref[i][0] *\n            (pre_fc->comp_ref_prob[i] - cur_fc->comp_ref_prob[i]);\n\n    pre_last_prob = MAX_PROB - pre_fc->comp_ref_prob[i];\n    cur_last_prob = MAX_PROB - cur_fc->comp_ref_prob[i];\n\n    diff += (int)counts->comp_ref[i][1] * (pre_last_prob - cur_last_prob);\n  }\n\n  // tx_probs\n  for (i = 0; i < TX_SIZE_CONTEXTS; ++i) {\n    // p32x32\n    for (j = 0; j < TX_SIZES - 1; ++j) {\n      diff += (int)counts->tx.p32x32[i][j] *\n              (pre_fc->tx_probs.p32x32[i][j] - cur_fc->tx_probs.p32x32[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->tx_probs.p32x32[i][TX_SIZES - 2];\n    cur_last_prob = MAX_PROB - cur_fc->tx_probs.p32x32[i][TX_SIZES - 2];\n\n    diff += (int)counts->tx.p32x32[i][TX_SIZES - 1] *\n            (pre_last_prob - cur_last_prob);\n\n    // p16x16\n    for (j = 0; j < TX_SIZES - 2; ++j) {\n      diff += (int)counts->tx.p16x16[i][j] *\n              (pre_fc->tx_probs.p16x16[i][j] - cur_fc->tx_probs.p16x16[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->tx_probs.p16x16[i][TX_SIZES - 3];\n    cur_last_prob = MAX_PROB - cur_fc->tx_probs.p16x16[i][TX_SIZES - 3];\n\n    diff += (int)counts->tx.p16x16[i][TX_SIZES - 2] *\n            (pre_last_prob - cur_last_prob);\n\n    // p8x8\n    for (j = 0; j < TX_SIZES - 3; ++j) {\n      diff += (int)counts->tx.p8x8[i][j] *\n              (pre_fc->tx_probs.p8x8[i][j] - cur_fc->tx_probs.p8x8[i][j]);\n    }\n    pre_last_prob = MAX_PROB - pre_fc->tx_probs.p8x8[i][TX_SIZES - 4];\n    cur_last_prob = MAX_PROB - cur_fc->tx_probs.p8x8[i][TX_SIZES - 4];\n\n    diff +=\n        (int)counts->tx.p8x8[i][TX_SIZES - 3] * (pre_last_prob - cur_last_prob);\n  }\n\n  // skip_probs\n  for (i = 0; i < SKIP_CONTEXTS; ++i) {\n    diff += (int)counts->skip[i][0] *\n            (pre_fc->skip_probs[i] - cur_fc->skip_probs[i]);\n\n    pre_last_prob = MAX_PROB - pre_fc->skip_probs[i];\n    cur_last_prob = MAX_PROB - cur_fc->skip_probs[i];\n\n    diff += (int)counts->skip[i][1] * (pre_last_prob - cur_last_prob);\n  }\n\n  // mv\n  for (i = 0; i < MV_JOINTS - 1; ++i) {\n    diff += (int)counts->mv.joints[i] *\n            (pre_fc->nmvc.joints[i] - cur_fc->nmvc.joints[i]);\n  }\n  pre_last_prob = MAX_PROB - pre_fc->nmvc.joints[MV_JOINTS - 2];\n  cur_last_prob = MAX_PROB - cur_fc->nmvc.joints[MV_JOINTS - 2];\n\n  diff +=\n      (int)counts->mv.joints[MV_JOINTS - 1] * (pre_last_prob - cur_last_prob);\n\n  for (i = 0; i < 2; ++i) {\n    const nmv_component_counts *nmv_count = &counts->mv.comps[i];\n    const nmv_component *pre_nmv_prob = &pre_fc->nmvc.comps[i];\n    const nmv_component *cur_nmv_prob = &cur_fc->nmvc.comps[i];\n\n    // sign\n    diff += (int)nmv_count->sign[0] * (pre_nmv_prob->sign - cur_nmv_prob->sign);\n\n    pre_last_prob = MAX_PROB - pre_nmv_prob->sign;\n    cur_last_prob = MAX_PROB - cur_nmv_prob->sign;\n\n    diff += (int)nmv_count->sign[1] * (pre_last_prob - cur_last_prob);\n\n    // classes\n    for (j = 0; j < MV_CLASSES - 1; ++j) {\n      diff += (int)nmv_count->classes[j] *\n              (pre_nmv_prob->classes[j] - cur_nmv_prob->classes[j]);\n    }\n    pre_last_prob = MAX_PROB - pre_nmv_prob->classes[MV_CLASSES - 2];\n    cur_last_prob = MAX_PROB - cur_nmv_prob->classes[MV_CLASSES - 2];\n\n    diff += (int)nmv_count->classes[MV_CLASSES - 1] *\n            (pre_last_prob - cur_last_prob);\n\n    // class0\n    for (j = 0; j < CLASS0_SIZE - 1; ++j) {\n      diff += (int)nmv_count->class0[j] *\n              (pre_nmv_prob->class0[j] - cur_nmv_prob->class0[j]);\n    }\n    pre_last_prob = MAX_PROB - pre_nmv_prob->class0[CLASS0_SIZE - 2];\n    cur_last_prob = MAX_PROB - cur_nmv_prob->class0[CLASS0_SIZE - 2];\n\n    diff += (int)nmv_count->class0[CLASS0_SIZE - 1] *\n            (pre_last_prob - cur_last_prob);\n\n    // bits\n    for (j = 0; j < MV_OFFSET_BITS; ++j) {\n      diff += (int)nmv_count->bits[j][0] *\n              (pre_nmv_prob->bits[j] - cur_nmv_prob->bits[j]);\n\n      pre_last_prob = MAX_PROB - pre_nmv_prob->bits[j];\n      cur_last_prob = MAX_PROB - cur_nmv_prob->bits[j];\n\n      diff += (int)nmv_count->bits[j][1] * (pre_last_prob - cur_last_prob);\n    }\n\n    // class0_fp\n    for (j = 0; j < CLASS0_SIZE; ++j) {\n      for (k = 0; k < MV_FP_SIZE - 1; ++k) {\n        diff += (int)nmv_count->class0_fp[j][k] *\n                (pre_nmv_prob->class0_fp[j][k] - cur_nmv_prob->class0_fp[j][k]);\n      }\n      pre_last_prob = MAX_PROB - pre_nmv_prob->class0_fp[j][MV_FP_SIZE - 2];\n      cur_last_prob = MAX_PROB - cur_nmv_prob->class0_fp[j][MV_FP_SIZE - 2];\n\n      diff += (int)nmv_count->class0_fp[j][MV_FP_SIZE - 1] *\n              (pre_last_prob - cur_last_prob);\n    }\n\n    // fp\n    for (j = 0; j < MV_FP_SIZE - 1; ++j) {\n      diff +=\n          (int)nmv_count->fp[j] * (pre_nmv_prob->fp[j] - cur_nmv_prob->fp[j]);\n    }\n    pre_last_prob = MAX_PROB - pre_nmv_prob->fp[MV_FP_SIZE - 2];\n    cur_last_prob = MAX_PROB - cur_nmv_prob->fp[MV_FP_SIZE - 2];\n\n    diff +=\n        (int)nmv_count->fp[MV_FP_SIZE - 1] * (pre_last_prob - cur_last_prob);\n\n    // class0_hp\n    diff += (int)nmv_count->class0_hp[0] *\n            (pre_nmv_prob->class0_hp - cur_nmv_prob->class0_hp);\n\n    pre_last_prob = MAX_PROB - pre_nmv_prob->class0_hp;\n    cur_last_prob = MAX_PROB - cur_nmv_prob->class0_hp;\n\n    diff += (int)nmv_count->class0_hp[1] * (pre_last_prob - cur_last_prob);\n\n    // hp\n    diff += (int)nmv_count->hp[0] * (pre_nmv_prob->hp - cur_nmv_prob->hp);\n\n    pre_last_prob = MAX_PROB - pre_nmv_prob->hp;\n    cur_last_prob = MAX_PROB - cur_nmv_prob->hp;\n\n    diff += (int)nmv_count->hp[1] * (pre_last_prob - cur_last_prob);\n  }\n\n  return -diff;\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\n// Test for whether to calculate metrics for the frame.\nstatic int is_psnr_calc_enabled(const VP9_COMP *cpi) {\n  const VP9_COMMON *const cm = &cpi->common;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n\n  return cpi->b_calculate_psnr && (oxcf->pass != 1) && cm->show_frame;\n}\n\n/* clang-format off */\nconst Vp9LevelSpec vp9_level_defs[VP9_LEVELS] = {\n  //         sample rate    size   breadth  bitrate  cpb\n  { LEVEL_1,   829440,      36864,    512,   200,    400,    2, 1,  4,  8 },\n  { LEVEL_1_1, 2764800,     73728,    768,   800,    1000,   2, 1,  4,  8 },\n  { LEVEL_2,   4608000,     122880,   960,   1800,   1500,   2, 1,  4,  8 },\n  { LEVEL_2_1, 9216000,     245760,   1344,  3600,   2800,   2, 2,  4,  8 },\n  { LEVEL_3,   20736000,    552960,   2048,  7200,   6000,   2, 4,  4,  8 },\n  { LEVEL_3_1, 36864000,    983040,   2752,  12000,  10000,  2, 4,  4,  8 },\n  { LEVEL_4,   83558400,    2228224,  4160,  18000,  16000,  4, 4,  4,  8 },\n  { LEVEL_4_1, 160432128,   2228224,  4160,  30000,  18000,  4, 4,  5,  6 },\n  { LEVEL_5,   311951360,   8912896,  8384,  60000,  36000,  6, 8,  6,  4 },\n  { LEVEL_5_1, 588251136,   8912896,  8384,  120000, 46000,  8, 8,  10, 4 },\n  // TODO(huisu): update max_cpb_size for level 5_2 ~ 6_2 when\n  // they are finalized (currently tentative).\n  { LEVEL_5_2, 1176502272,  8912896,  8384,  180000, 90000,  8, 8,  10, 4 },\n  { LEVEL_6,   1176502272,  35651584, 16832, 180000, 90000,  8, 16, 10, 4 },\n  { LEVEL_6_1, 2353004544u, 35651584, 16832, 240000, 180000, 8, 16, 10, 4 },\n  { LEVEL_6_2, 4706009088u, 35651584, 16832, 480000, 360000, 8, 16, 10, 4 },\n};\n/* clang-format on */\n\nstatic const char *level_fail_messages[TARGET_LEVEL_FAIL_IDS] = {\n  \"The average bit-rate is too high.\",\n  \"The picture size is too large.\",\n  \"The picture width/height is too large.\",\n  \"The luma sample rate is too large.\",\n  \"The CPB size is too large.\",\n  \"The compression ratio is too small\",\n  \"Too many column tiles are used.\",\n  \"The alt-ref distance is too small.\",\n  \"Too many reference buffers are used.\"\n};\n\nstatic INLINE void Scale2Ratio(VPX_SCALING_MODE mode, int *hr, int *hs) {\n  switch (mode) {\n    case VP8E_NORMAL:\n      *hr = 1;\n      *hs = 1;\n      break;\n    case VP8E_FOURFIVE:\n      *hr = 4;\n      *hs = 5;\n      break;\n    case VP8E_THREEFIVE:\n      *hr = 3;\n      *hs = 5;\n      break;\n    default:\n      assert(mode == VP8E_ONETWO);\n      *hr = 1;\n      *hs = 2;\n      break;\n  }\n}\n\n// Mark all inactive blocks as active. Other segmentation features may be set\n// so memset cannot be used, instead only inactive blocks should be reset.\nstatic void suppress_active_map(VP9_COMP *cpi) {\n  unsigned char *const seg_map = cpi->segmentation_map;\n\n  if (cpi->active_map.enabled || cpi->active_map.update) {\n    const int rows = cpi->common.mi_rows;\n    const int cols = cpi->common.mi_cols;\n    int i;\n\n    for (i = 0; i < rows * cols; ++i)\n      if (seg_map[i] == AM_SEGMENT_ID_INACTIVE)\n        seg_map[i] = AM_SEGMENT_ID_ACTIVE;\n  }\n}\n\nstatic void apply_active_map(VP9_COMP *cpi) {\n  struct segmentation *const seg = &cpi->common.seg;\n  unsigned char *const seg_map = cpi->segmentation_map;\n  const unsigned char *const active_map = cpi->active_map.map;\n  int i;\n\n  assert(AM_SEGMENT_ID_ACTIVE == CR_SEGMENT_ID_BASE);\n\n  if (frame_is_intra_only(&cpi->common)) {\n    cpi->active_map.enabled = 0;\n    cpi->active_map.update = 1;\n  }\n\n  if (cpi->active_map.update) {\n    if (cpi->active_map.enabled) {\n      for (i = 0; i < cpi->common.mi_rows * cpi->common.mi_cols; ++i)\n        if (seg_map[i] == AM_SEGMENT_ID_ACTIVE) seg_map[i] = active_map[i];\n      vp9_enable_segmentation(seg);\n      vp9_enable_segfeature(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_SKIP);\n      vp9_enable_segfeature(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_ALT_LF);\n      // Setting the data to -MAX_LOOP_FILTER will result in the computed loop\n      // filter level being zero regardless of the value of seg->abs_delta.\n      vp9_set_segdata(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_ALT_LF,\n                      -MAX_LOOP_FILTER);\n    } else {\n      vp9_disable_segfeature(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_SKIP);\n      vp9_disable_segfeature(seg, AM_SEGMENT_ID_INACTIVE, SEG_LVL_ALT_LF);\n      if (seg->enabled) {\n        seg->update_data = 1;\n        seg->update_map = 1;\n      }\n    }\n    cpi->active_map.update = 0;\n  }\n}\n\nstatic void apply_roi_map(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  struct segmentation *const seg = &cm->seg;\n  vpx_roi_map_t *roi = &cpi->roi;\n  const int *delta_q = roi->delta_q;\n  const int *delta_lf = roi->delta_lf;\n  const int *skip = roi->skip;\n  int ref_frame[8];\n  int internal_delta_q[MAX_SEGMENTS];\n  int i;\n\n  // TODO(jianj): Investigate why ROI not working in speed < 5 or in non\n  // realtime mode.\n  if (cpi->oxcf.mode != REALTIME || cpi->oxcf.speed < 5) return;\n  if (!roi->enabled) return;\n\n  memcpy(&ref_frame, roi->ref_frame, sizeof(ref_frame));\n\n  vp9_enable_segmentation(seg);\n  vp9_clearall_segfeatures(seg);\n  // Select delta coding method;\n  seg->abs_delta = SEGMENT_DELTADATA;\n\n  memcpy(cpi->segmentation_map, roi->roi_map, (cm->mi_rows * cm->mi_cols));\n\n  for (i = 0; i < MAX_SEGMENTS; ++i) {\n    // Translate the external delta q values to internal values.\n    internal_delta_q[i] = vp9_quantizer_to_qindex(abs(delta_q[i]));\n    if (delta_q[i] < 0) internal_delta_q[i] = -internal_delta_q[i];\n    vp9_disable_segfeature(seg, i, SEG_LVL_ALT_Q);\n    vp9_disable_segfeature(seg, i, SEG_LVL_ALT_LF);\n    if (internal_delta_q[i] != 0) {\n      vp9_enable_segfeature(seg, i, SEG_LVL_ALT_Q);\n      vp9_set_segdata(seg, i, SEG_LVL_ALT_Q, internal_delta_q[i]);\n    }\n    if (delta_lf[i] != 0) {\n      vp9_enable_segfeature(seg, i, SEG_LVL_ALT_LF);\n      vp9_set_segdata(seg, i, SEG_LVL_ALT_LF, delta_lf[i]);\n    }\n    if (skip[i] != 0) {\n      vp9_enable_segfeature(seg, i, SEG_LVL_SKIP);\n      vp9_set_segdata(seg, i, SEG_LVL_SKIP, 0);\n    }\n    if (ref_frame[i] >= 0) {\n      int valid_ref = 1;\n      // ALTREF is not used as reference for nonrd_pickmode with 0 lag.\n      if (ref_frame[i] == ALTREF_FRAME && cpi->sf.use_nonrd_pick_mode)\n        valid_ref = 0;\n      // If GOLDEN is selected, make sure it's set as reference.\n      if (ref_frame[i] == GOLDEN_FRAME &&\n          !(cpi->ref_frame_flags & ref_frame_to_flag(ref_frame[i]))) {\n        valid_ref = 0;\n      }\n      // GOLDEN was updated in previous encoded frame, so GOLDEN and LAST are\n      // same reference.\n      if (ref_frame[i] == GOLDEN_FRAME && cpi->rc.frames_since_golden == 0)\n        ref_frame[i] = LAST_FRAME;\n      if (valid_ref) {\n        vp9_enable_segfeature(seg, i, SEG_LVL_REF_FRAME);\n        vp9_set_segdata(seg, i, SEG_LVL_REF_FRAME, ref_frame[i]);\n      }\n    }\n  }\n  roi->enabled = 1;\n}\n\nstatic void init_level_info(Vp9LevelInfo *level_info) {\n  Vp9LevelStats *const level_stats = &level_info->level_stats;\n  Vp9LevelSpec *const level_spec = &level_info->level_spec;\n\n  memset(level_stats, 0, sizeof(*level_stats));\n  memset(level_spec, 0, sizeof(*level_spec));\n  level_spec->level = LEVEL_UNKNOWN;\n  level_spec->min_altref_distance = INT_MAX;\n}\n\nstatic int check_seg_range(int seg_data[8], int range) {\n  int i;\n  for (i = 0; i < 8; ++i) {\n    // Note abs() alone can't be used as the behavior of abs(INT_MIN) is\n    // undefined.\n    if (seg_data[i] > range || seg_data[i] < -range) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nVP9_LEVEL vp9_get_level(const Vp9LevelSpec *const level_spec) {\n  int i;\n  const Vp9LevelSpec *this_level;\n\n  vpx_clear_system_state();\n\n  for (i = 0; i < VP9_LEVELS; ++i) {\n    this_level = &vp9_level_defs[i];\n    if ((double)level_spec->max_luma_sample_rate >\n            (double)this_level->max_luma_sample_rate *\n                (1 + SAMPLE_RATE_GRACE_P) ||\n        level_spec->max_luma_picture_size > this_level->max_luma_picture_size ||\n        level_spec->max_luma_picture_breadth >\n            this_level->max_luma_picture_breadth ||\n        level_spec->average_bitrate > this_level->average_bitrate ||\n        level_spec->max_cpb_size > this_level->max_cpb_size ||\n        level_spec->compression_ratio < this_level->compression_ratio ||\n        level_spec->max_col_tiles > this_level->max_col_tiles ||\n        level_spec->min_altref_distance < this_level->min_altref_distance ||\n        level_spec->max_ref_frame_buffers > this_level->max_ref_frame_buffers)\n      continue;\n    break;\n  }\n  return (i == VP9_LEVELS) ? LEVEL_UNKNOWN : vp9_level_defs[i].level;\n}\n\nvpx_codec_err_t vp9_set_roi_map(VP9_COMP *cpi, unsigned char *map,\n                                unsigned int rows, unsigned int cols,\n                                int delta_q[8], int delta_lf[8], int skip[8],\n                                int ref_frame[8]) {\n  VP9_COMMON *cm = &cpi->common;\n  vpx_roi_map_t *roi = &cpi->roi;\n  const int range = 63;\n  const int ref_frame_range = 3;  // Alt-ref\n  const int skip_range = 1;\n  const int frame_rows = cpi->common.mi_rows;\n  const int frame_cols = cpi->common.mi_cols;\n\n  // Check number of rows and columns match\n  if (frame_rows != (int)rows || frame_cols != (int)cols) {\n    return VPX_CODEC_INVALID_PARAM;\n  }\n\n  if (!check_seg_range(delta_q, range) || !check_seg_range(delta_lf, range) ||\n      !check_seg_range(ref_frame, ref_frame_range) ||\n      !check_seg_range(skip, skip_range))\n    return VPX_CODEC_INVALID_PARAM;\n\n  // Also disable segmentation if no deltas are specified.\n  if (!map ||\n      (!(delta_q[0] | delta_q[1] | delta_q[2] | delta_q[3] | delta_q[4] |\n         delta_q[5] | delta_q[6] | delta_q[7] | delta_lf[0] | delta_lf[1] |\n         delta_lf[2] | delta_lf[3] | delta_lf[4] | delta_lf[5] | delta_lf[6] |\n         delta_lf[7] | skip[0] | skip[1] | skip[2] | skip[3] | skip[4] |\n         skip[5] | skip[6] | skip[7]) &&\n       (ref_frame[0] == -1 && ref_frame[1] == -1 && ref_frame[2] == -1 &&\n        ref_frame[3] == -1 && ref_frame[4] == -1 && ref_frame[5] == -1 &&\n        ref_frame[6] == -1 && ref_frame[7] == -1))) {\n    vp9_disable_segmentation(&cm->seg);\n    cpi->roi.enabled = 0;\n    return VPX_CODEC_OK;\n  }\n\n  if (roi->roi_map) {\n    vpx_free(roi->roi_map);\n    roi->roi_map = NULL;\n  }\n  roi->roi_map = vpx_malloc(rows * cols);\n  if (!roi->roi_map) return VPX_CODEC_MEM_ERROR;\n\n  // Copy to ROI structure in the compressor.\n  memcpy(roi->roi_map, map, rows * cols);\n  memcpy(&roi->delta_q, delta_q, MAX_SEGMENTS * sizeof(delta_q[0]));\n  memcpy(&roi->delta_lf, delta_lf, MAX_SEGMENTS * sizeof(delta_lf[0]));\n  memcpy(&roi->skip, skip, MAX_SEGMENTS * sizeof(skip[0]));\n  memcpy(&roi->ref_frame, ref_frame, MAX_SEGMENTS * sizeof(ref_frame[0]));\n  roi->enabled = 1;\n  roi->rows = rows;\n  roi->cols = cols;\n\n  return VPX_CODEC_OK;\n}\n\nint vp9_set_active_map(VP9_COMP *cpi, unsigned char *new_map_16x16, int rows,\n                       int cols) {\n  if (rows == cpi->common.mb_rows && cols == cpi->common.mb_cols) {\n    unsigned char *const active_map_8x8 = cpi->active_map.map;\n    const int mi_rows = cpi->common.mi_rows;\n    const int mi_cols = cpi->common.mi_cols;\n    cpi->active_map.update = 1;\n    if (new_map_16x16) {\n      int r, c;\n      for (r = 0; r < mi_rows; ++r) {\n        for (c = 0; c < mi_cols; ++c) {\n          active_map_8x8[r * mi_cols + c] =\n              new_map_16x16[(r >> 1) * cols + (c >> 1)]\n                  ? AM_SEGMENT_ID_ACTIVE\n                  : AM_SEGMENT_ID_INACTIVE;\n        }\n      }\n      cpi->active_map.enabled = 1;\n    } else {\n      cpi->active_map.enabled = 0;\n    }\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint vp9_get_active_map(VP9_COMP *cpi, unsigned char *new_map_16x16, int rows,\n                       int cols) {\n  if (rows == cpi->common.mb_rows && cols == cpi->common.mb_cols &&\n      new_map_16x16) {\n    unsigned char *const seg_map_8x8 = cpi->segmentation_map;\n    const int mi_rows = cpi->common.mi_rows;\n    const int mi_cols = cpi->common.mi_cols;\n    memset(new_map_16x16, !cpi->active_map.enabled, rows * cols);\n    if (cpi->active_map.enabled) {\n      int r, c;\n      for (r = 0; r < mi_rows; ++r) {\n        for (c = 0; c < mi_cols; ++c) {\n          // Cyclic refresh segments are considered active despite not having\n          // AM_SEGMENT_ID_ACTIVE\n          new_map_16x16[(r >> 1) * cols + (c >> 1)] |=\n              seg_map_8x8[r * mi_cols + c] != AM_SEGMENT_ID_INACTIVE;\n        }\n      }\n    }\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nvoid vp9_set_high_precision_mv(VP9_COMP *cpi, int allow_high_precision_mv) {\n  MACROBLOCK *const mb = &cpi->td.mb;\n  cpi->common.allow_high_precision_mv = allow_high_precision_mv;\n  if (cpi->common.allow_high_precision_mv) {\n    mb->mvcost = mb->nmvcost_hp;\n    mb->mvsadcost = mb->nmvsadcost_hp;\n  } else {\n    mb->mvcost = mb->nmvcost;\n    mb->mvsadcost = mb->nmvsadcost;\n  }\n}\n\nstatic void setup_frame(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  // Set up entropy context depending on frame type. The decoder mandates\n  // the use of the default context, index 0, for keyframes and inter\n  // frames where the error_resilient_mode or intra_only flag is set. For\n  // other inter-frames the encoder currently uses only two contexts;\n  // context 1 for ALTREF frames and context 0 for the others.\n  if (frame_is_intra_only(cm) || cm->error_resilient_mode) {\n    vp9_setup_past_independence(cm);\n  } else {\n    if (!cpi->use_svc) cm->frame_context_idx = cpi->refresh_alt_ref_frame;\n  }\n\n  // TODO(jingning): Overwrite the frame_context_idx index in multi-layer ARF\n  // case. Need some further investigation on if we could apply this to single\n  // layer ARF case as well.\n  if (cpi->multi_layer_arf && !cpi->use_svc) {\n    GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n    const int gf_group_index = gf_group->index;\n    const int boost_frame =\n        !cpi->rc.is_src_frame_alt_ref &&\n        (cpi->refresh_golden_frame || cpi->refresh_alt_ref_frame);\n\n    // frame_context_idx           Frame Type\n    //        0              Intra only frame, base layer ARF\n    //        1              ARFs with layer depth = 2,3\n    //        2              ARFs with layer depth > 3\n    //        3              Non-boosted frames\n    if (frame_is_intra_only(cm)) {\n      cm->frame_context_idx = 0;\n    } else if (boost_frame) {\n      if (gf_group->rf_level[gf_group_index] == GF_ARF_STD)\n        cm->frame_context_idx = 0;\n      else if (gf_group->layer_depth[gf_group_index] <= 3)\n        cm->frame_context_idx = 1;\n      else\n        cm->frame_context_idx = 2;\n    } else {\n      cm->frame_context_idx = 3;\n    }\n  }\n\n  if (cm->frame_type == KEY_FRAME) {\n    cpi->refresh_golden_frame = 1;\n    cpi->refresh_alt_ref_frame = 1;\n    vp9_zero(cpi->interp_filter_selected);\n  } else {\n    *cm->fc = cm->frame_contexts[cm->frame_context_idx];\n    vp9_zero(cpi->interp_filter_selected[0]);\n  }\n}\n\nstatic void vp9_enc_setup_mi(VP9_COMMON *cm) {\n  int i;\n  cm->mi = cm->mip + cm->mi_stride + 1;\n  memset(cm->mip, 0, cm->mi_stride * (cm->mi_rows + 1) * sizeof(*cm->mip));\n  cm->prev_mi = cm->prev_mip + cm->mi_stride + 1;\n  // Clear top border row\n  memset(cm->prev_mip, 0, sizeof(*cm->prev_mip) * cm->mi_stride);\n  // Clear left border column\n  for (i = 1; i < cm->mi_rows + 1; ++i)\n    memset(&cm->prev_mip[i * cm->mi_stride], 0, sizeof(*cm->prev_mip));\n\n  cm->mi_grid_visible = cm->mi_grid_base + cm->mi_stride + 1;\n  cm->prev_mi_grid_visible = cm->prev_mi_grid_base + cm->mi_stride + 1;\n\n  memset(cm->mi_grid_base, 0,\n         cm->mi_stride * (cm->mi_rows + 1) * sizeof(*cm->mi_grid_base));\n}\n\nstatic int vp9_enc_alloc_mi(VP9_COMMON *cm, int mi_size) {\n  cm->mip = vpx_calloc(mi_size, sizeof(*cm->mip));\n  if (!cm->mip) return 1;\n  cm->prev_mip = vpx_calloc(mi_size, sizeof(*cm->prev_mip));\n  if (!cm->prev_mip) return 1;\n  cm->mi_alloc_size = mi_size;\n\n  cm->mi_grid_base = (MODE_INFO **)vpx_calloc(mi_size, sizeof(MODE_INFO *));\n  if (!cm->mi_grid_base) return 1;\n  cm->prev_mi_grid_base =\n      (MODE_INFO **)vpx_calloc(mi_size, sizeof(MODE_INFO *));\n  if (!cm->prev_mi_grid_base) return 1;\n\n  return 0;\n}\n\nstatic void vp9_enc_free_mi(VP9_COMMON *cm) {\n  vpx_free(cm->mip);\n  cm->mip = NULL;\n  vpx_free(cm->prev_mip);\n  cm->prev_mip = NULL;\n  vpx_free(cm->mi_grid_base);\n  cm->mi_grid_base = NULL;\n  vpx_free(cm->prev_mi_grid_base);\n  cm->prev_mi_grid_base = NULL;\n  cm->mi_alloc_size = 0;\n}\n\nstatic void vp9_swap_mi_and_prev_mi(VP9_COMMON *cm) {\n  // Current mip will be the prev_mip for the next frame.\n  MODE_INFO **temp_base = cm->prev_mi_grid_base;\n  MODE_INFO *temp = cm->prev_mip;\n\n  // Skip update prev_mi frame in show_existing_frame mode.\n  if (cm->show_existing_frame) return;\n\n  cm->prev_mip = cm->mip;\n  cm->mip = temp;\n\n  // Update the upper left visible macroblock ptrs.\n  cm->mi = cm->mip + cm->mi_stride + 1;\n  cm->prev_mi = cm->prev_mip + cm->mi_stride + 1;\n\n  cm->prev_mi_grid_base = cm->mi_grid_base;\n  cm->mi_grid_base = temp_base;\n  cm->mi_grid_visible = cm->mi_grid_base + cm->mi_stride + 1;\n  cm->prev_mi_grid_visible = cm->prev_mi_grid_base + cm->mi_stride + 1;\n}\n\nstatic void initialize_enc(void) {\n  vp9_rtcd();\n  vpx_dsp_rtcd();\n  vpx_scale_rtcd();\n  vp9_init_intra_predictors();\n  vp9_init_me_luts();\n  vp9_rc_init_minq_luts();\n  vp9_entropy_mv_init();\n#if !CONFIG_REALTIME_ONLY\n  vp9_temporal_filter_init();\n#endif\n}\n\nvoid vp9_initialize_enc(void) { once(initialize_enc); }\n\nstatic void dealloc_compressor_data(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  int i;\n\n  vpx_free(cpi->mbmi_ext_base);\n  cpi->mbmi_ext_base = NULL;\n\n  vpx_free(cpi->tile_data);\n  cpi->tile_data = NULL;\n\n  vpx_free(cpi->segmentation_map);\n  cpi->segmentation_map = NULL;\n  vpx_free(cpi->coding_context.last_frame_seg_map_copy);\n  cpi->coding_context.last_frame_seg_map_copy = NULL;\n\n  vpx_free(cpi->nmvcosts[0]);\n  vpx_free(cpi->nmvcosts[1]);\n  cpi->nmvcosts[0] = NULL;\n  cpi->nmvcosts[1] = NULL;\n\n  vpx_free(cpi->nmvcosts_hp[0]);\n  vpx_free(cpi->nmvcosts_hp[1]);\n  cpi->nmvcosts_hp[0] = NULL;\n  cpi->nmvcosts_hp[1] = NULL;\n\n  vpx_free(cpi->nmvsadcosts[0]);\n  vpx_free(cpi->nmvsadcosts[1]);\n  cpi->nmvsadcosts[0] = NULL;\n  cpi->nmvsadcosts[1] = NULL;\n\n  vpx_free(cpi->nmvsadcosts_hp[0]);\n  vpx_free(cpi->nmvsadcosts_hp[1]);\n  cpi->nmvsadcosts_hp[0] = NULL;\n  cpi->nmvsadcosts_hp[1] = NULL;\n\n  vpx_free(cpi->skin_map);\n  cpi->skin_map = NULL;\n\n  vpx_free(cpi->prev_partition);\n  cpi->prev_partition = NULL;\n\n  vpx_free(cpi->svc.prev_partition_svc);\n  cpi->svc.prev_partition_svc = NULL;\n\n  vpx_free(cpi->prev_segment_id);\n  cpi->prev_segment_id = NULL;\n\n  vpx_free(cpi->prev_variance_low);\n  cpi->prev_variance_low = NULL;\n\n  vpx_free(cpi->copied_frame_cnt);\n  cpi->copied_frame_cnt = NULL;\n\n  vpx_free(cpi->content_state_sb_fd);\n  cpi->content_state_sb_fd = NULL;\n\n  vpx_free(cpi->count_arf_frame_usage);\n  cpi->count_arf_frame_usage = NULL;\n  vpx_free(cpi->count_lastgolden_frame_usage);\n  cpi->count_lastgolden_frame_usage = NULL;\n\n  vp9_cyclic_refresh_free(cpi->cyclic_refresh);\n  cpi->cyclic_refresh = NULL;\n\n  vpx_free(cpi->active_map.map);\n  cpi->active_map.map = NULL;\n\n  vpx_free(cpi->roi.roi_map);\n  cpi->roi.roi_map = NULL;\n\n  vpx_free(cpi->consec_zero_mv);\n  cpi->consec_zero_mv = NULL;\n\n  vpx_free(cpi->mb_wiener_variance);\n  cpi->mb_wiener_variance = NULL;\n\n  vpx_free(cpi->mi_ssim_rdmult_scaling_factors);\n  cpi->mi_ssim_rdmult_scaling_factors = NULL;\n\n#if CONFIG_RATE_CTRL\n  if (cpi->oxcf.use_simple_encode_api) {\n    free_partition_info(cpi);\n    free_motion_vector_info(cpi);\n    free_fp_motion_vector_info(cpi);\n    free_tpl_stats_info(cpi);\n  }\n#endif\n\n  vp9_free_ref_frame_buffers(cm->buffer_pool);\n#if CONFIG_VP9_POSTPROC\n  vp9_free_postproc_buffers(cm);\n#endif\n  vp9_free_context_buffers(cm);\n\n  vpx_free_frame_buffer(&cpi->last_frame_uf);\n  vpx_free_frame_buffer(&cpi->scaled_source);\n  vpx_free_frame_buffer(&cpi->scaled_last_source);\n  vpx_free_frame_buffer(&cpi->alt_ref_buffer);\n#ifdef ENABLE_KF_DENOISE\n  vpx_free_frame_buffer(&cpi->raw_unscaled_source);\n  vpx_free_frame_buffer(&cpi->raw_scaled_source);\n#endif\n\n  vp9_lookahead_destroy(cpi->lookahead);\n\n  vpx_free(cpi->tile_tok[0][0]);\n  cpi->tile_tok[0][0] = 0;\n\n  vpx_free(cpi->tplist[0][0]);\n  cpi->tplist[0][0] = NULL;\n\n  vp9_free_pc_tree(&cpi->td);\n\n  for (i = 0; i < cpi->svc.number_spatial_layers; ++i) {\n    LAYER_CONTEXT *const lc = &cpi->svc.layer_context[i];\n    vpx_free(lc->rc_twopass_stats_in.buf);\n    lc->rc_twopass_stats_in.buf = NULL;\n    lc->rc_twopass_stats_in.sz = 0;\n  }\n\n  if (cpi->source_diff_var != NULL) {\n    vpx_free(cpi->source_diff_var);\n    cpi->source_diff_var = NULL;\n  }\n\n  for (i = 0; i < MAX_LAG_BUFFERS; ++i) {\n    vpx_free_frame_buffer(&cpi->svc.scaled_frames[i]);\n  }\n  memset(&cpi->svc.scaled_frames[0], 0,\n         MAX_LAG_BUFFERS * sizeof(cpi->svc.scaled_frames[0]));\n\n  vpx_free_frame_buffer(&cpi->svc.scaled_temp);\n  memset(&cpi->svc.scaled_temp, 0, sizeof(cpi->svc.scaled_temp));\n\n  vpx_free_frame_buffer(&cpi->svc.empty_frame.img);\n  memset(&cpi->svc.empty_frame, 0, sizeof(cpi->svc.empty_frame));\n\n  vp9_free_svc_cyclic_refresh(cpi);\n}\n\nstatic void save_coding_context(VP9_COMP *cpi) {\n  CODING_CONTEXT *const cc = &cpi->coding_context;\n  VP9_COMMON *cm = &cpi->common;\n\n  // Stores a snapshot of key state variables which can subsequently be\n  // restored with a call to vp9_restore_coding_context. These functions are\n  // intended for use in a re-code loop in vp9_compress_frame where the\n  // quantizer value is adjusted between loop iterations.\n  vp9_copy(cc->nmvjointcost, cpi->td.mb.nmvjointcost);\n\n  memcpy(cc->nmvcosts[0], cpi->nmvcosts[0],\n         MV_VALS * sizeof(*cpi->nmvcosts[0]));\n  memcpy(cc->nmvcosts[1], cpi->nmvcosts[1],\n         MV_VALS * sizeof(*cpi->nmvcosts[1]));\n  memcpy(cc->nmvcosts_hp[0], cpi->nmvcosts_hp[0],\n         MV_VALS * sizeof(*cpi->nmvcosts_hp[0]));\n  memcpy(cc->nmvcosts_hp[1], cpi->nmvcosts_hp[1],\n         MV_VALS * sizeof(*cpi->nmvcosts_hp[1]));\n\n  vp9_copy(cc->segment_pred_probs, cm->seg.pred_probs);\n\n  memcpy(cpi->coding_context.last_frame_seg_map_copy, cm->last_frame_seg_map,\n         (cm->mi_rows * cm->mi_cols));\n\n  vp9_copy(cc->last_ref_lf_deltas, cm->lf.last_ref_deltas);\n  vp9_copy(cc->last_mode_lf_deltas, cm->lf.last_mode_deltas);\n\n  cc->fc = *cm->fc;\n}\n\nstatic void restore_coding_context(VP9_COMP *cpi) {\n  CODING_CONTEXT *const cc = &cpi->coding_context;\n  VP9_COMMON *cm = &cpi->common;\n\n  // Restore key state variables to the snapshot state stored in the\n  // previous call to vp9_save_coding_context.\n  vp9_copy(cpi->td.mb.nmvjointcost, cc->nmvjointcost);\n\n  memcpy(cpi->nmvcosts[0], cc->nmvcosts[0], MV_VALS * sizeof(*cc->nmvcosts[0]));\n  memcpy(cpi->nmvcosts[1], cc->nmvcosts[1], MV_VALS * sizeof(*cc->nmvcosts[1]));\n  memcpy(cpi->nmvcosts_hp[0], cc->nmvcosts_hp[0],\n         MV_VALS * sizeof(*cc->nmvcosts_hp[0]));\n  memcpy(cpi->nmvcosts_hp[1], cc->nmvcosts_hp[1],\n         MV_VALS * sizeof(*cc->nmvcosts_hp[1]));\n\n  vp9_copy(cm->seg.pred_probs, cc->segment_pred_probs);\n\n  memcpy(cm->last_frame_seg_map, cpi->coding_context.last_frame_seg_map_copy,\n         (cm->mi_rows * cm->mi_cols));\n\n  vp9_copy(cm->lf.last_ref_deltas, cc->last_ref_lf_deltas);\n  vp9_copy(cm->lf.last_mode_deltas, cc->last_mode_lf_deltas);\n\n  *cm->fc = cc->fc;\n}\n\n#if !CONFIG_REALTIME_ONLY\nstatic void configure_static_seg_features(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  const RATE_CONTROL *const rc = &cpi->rc;\n  struct segmentation *const seg = &cm->seg;\n\n  int high_q = (int)(rc->avg_q > 48.0);\n  int qi_delta;\n\n  // Disable and clear down for KF\n  if (cm->frame_type == KEY_FRAME) {\n    // Clear down the global segmentation map\n    memset(cpi->segmentation_map, 0, cm->mi_rows * cm->mi_cols);\n    seg->update_map = 0;\n    seg->update_data = 0;\n    cpi->static_mb_pct = 0;\n\n    // Disable segmentation\n    vp9_disable_segmentation(seg);\n\n    // Clear down the segment features.\n    vp9_clearall_segfeatures(seg);\n  } else if (cpi->refresh_alt_ref_frame) {\n    // If this is an alt ref frame\n    // Clear down the global segmentation map\n    memset(cpi->segmentation_map, 0, cm->mi_rows * cm->mi_cols);\n    seg->update_map = 0;\n    seg->update_data = 0;\n    cpi->static_mb_pct = 0;\n\n    // Disable segmentation and individual segment features by default\n    vp9_disable_segmentation(seg);\n    vp9_clearall_segfeatures(seg);\n\n    // Scan frames from current to arf frame.\n    // This function re-enables segmentation if appropriate.\n    vp9_update_mbgraph_stats(cpi);\n\n    // If segmentation was enabled set those features needed for the\n    // arf itself.\n    if (seg->enabled) {\n      seg->update_map = 1;\n      seg->update_data = 1;\n\n      qi_delta =\n          vp9_compute_qdelta(rc, rc->avg_q, rc->avg_q * 0.875, cm->bit_depth);\n      vp9_set_segdata(seg, 1, SEG_LVL_ALT_Q, qi_delta - 2);\n      vp9_set_segdata(seg, 1, SEG_LVL_ALT_LF, -2);\n\n      vp9_enable_segfeature(seg, 1, SEG_LVL_ALT_Q);\n      vp9_enable_segfeature(seg, 1, SEG_LVL_ALT_LF);\n\n      // Where relevant assume segment data is delta data\n      seg->abs_delta = SEGMENT_DELTADATA;\n    }\n  } else if (seg->enabled) {\n    // All other frames if segmentation has been enabled\n\n    // First normal frame in a valid gf or alt ref group\n    if (rc->frames_since_golden == 0) {\n      // Set up segment features for normal frames in an arf group\n      if (rc->source_alt_ref_active) {\n        seg->update_map = 0;\n        seg->update_data = 1;\n        seg->abs_delta = SEGMENT_DELTADATA;\n\n        qi_delta =\n            vp9_compute_qdelta(rc, rc->avg_q, rc->avg_q * 1.125, cm->bit_depth);\n        vp9_set_segdata(seg, 1, SEG_LVL_ALT_Q, qi_delta + 2);\n        vp9_enable_segfeature(seg, 1, SEG_LVL_ALT_Q);\n\n        vp9_set_segdata(seg, 1, SEG_LVL_ALT_LF, -2);\n        vp9_enable_segfeature(seg, 1, SEG_LVL_ALT_LF);\n\n        // Segment coding disabled for compred testing\n        if (high_q || (cpi->static_mb_pct == 100)) {\n          vp9_set_segdata(seg, 1, SEG_LVL_REF_FRAME, ALTREF_FRAME);\n          vp9_enable_segfeature(seg, 1, SEG_LVL_REF_FRAME);\n          vp9_enable_segfeature(seg, 1, SEG_LVL_SKIP);\n        }\n      } else {\n        // Disable segmentation and clear down features if alt ref\n        // is not active for this group\n\n        vp9_disable_segmentation(seg);\n\n        memset(cpi->segmentation_map, 0, cm->mi_rows * cm->mi_cols);\n\n        seg->update_map = 0;\n        seg->update_data = 0;\n\n        vp9_clearall_segfeatures(seg);\n      }\n    } else if (rc->is_src_frame_alt_ref) {\n      // Special case where we are coding over the top of a previous\n      // alt ref frame.\n      // Segment coding disabled for compred testing\n\n      // Enable ref frame features for segment 0 as well\n      vp9_enable_segfeature(seg, 0, SEG_LVL_REF_FRAME);\n      vp9_enable_segfeature(seg, 1, SEG_LVL_REF_FRAME);\n\n      // All mbs should use ALTREF_FRAME\n      vp9_clear_segdata(seg, 0, SEG_LVL_REF_FRAME);\n      vp9_set_segdata(seg, 0, SEG_LVL_REF_FRAME, ALTREF_FRAME);\n      vp9_clear_segdata(seg, 1, SEG_LVL_REF_FRAME);\n      vp9_set_segdata(seg, 1, SEG_LVL_REF_FRAME, ALTREF_FRAME);\n\n      // Skip all MBs if high Q (0,0 mv and skip coeffs)\n      if (high_q) {\n        vp9_enable_segfeature(seg, 0, SEG_LVL_SKIP);\n        vp9_enable_segfeature(seg, 1, SEG_LVL_SKIP);\n      }\n      // Enable data update\n      seg->update_data = 1;\n    } else {\n      // All other frames.\n\n      // No updates.. leave things as they are.\n      seg->update_map = 0;\n      seg->update_data = 0;\n    }\n  }\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void update_reference_segmentation_map(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  MODE_INFO **mi_8x8_ptr = cm->mi_grid_visible;\n  uint8_t *cache_ptr = cm->last_frame_seg_map;\n  int row, col;\n\n  for (row = 0; row < cm->mi_rows; row++) {\n    MODE_INFO **mi_8x8 = mi_8x8_ptr;\n    uint8_t *cache = cache_ptr;\n    for (col = 0; col < cm->mi_cols; col++, mi_8x8++, cache++)\n      cache[0] = mi_8x8[0]->segment_id;\n    mi_8x8_ptr += cm->mi_stride;\n    cache_ptr += cm->mi_cols;\n  }\n}\n\nstatic void alloc_raw_frame_buffers(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  const VP9EncoderConfig *oxcf = &cpi->oxcf;\n\n  if (!cpi->lookahead)\n    cpi->lookahead = vp9_lookahead_init(oxcf->width, oxcf->height,\n                                        cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                                        cm->use_highbitdepth,\n#endif\n                                        oxcf->lag_in_frames);\n  if (!cpi->lookahead)\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate lag buffers\");\n\n  // TODO(agrange) Check if ARF is enabled and skip allocation if not.\n  if (vpx_realloc_frame_buffer(&cpi->alt_ref_buffer, oxcf->width, oxcf->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate altref buffer\");\n}\n\nstatic void alloc_util_frame_buffers(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  if (vpx_realloc_frame_buffer(&cpi->last_frame_uf, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate last frame buffer\");\n\n  if (vpx_realloc_frame_buffer(&cpi->scaled_source, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate scaled source buffer\");\n\n  // For 1 pass cbr: allocate scaled_frame that may be used as an intermediate\n  // buffer for a 2 stage down-sampling: two stages of 1:2 down-sampling for a\n  // target of 1/4x1/4. number_spatial_layers must be greater than 2.\n  if (is_one_pass_svc(cpi) && !cpi->svc.scaled_temp_is_alloc &&\n      cpi->svc.number_spatial_layers > 2) {\n    cpi->svc.scaled_temp_is_alloc = 1;\n    if (vpx_realloc_frame_buffer(\n            &cpi->svc.scaled_temp, cm->width >> 1, cm->height >> 1,\n            cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n            cm->use_highbitdepth,\n#endif\n            VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment, NULL, NULL, NULL))\n      vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                         \"Failed to allocate scaled_frame for svc \");\n  }\n\n  if (vpx_realloc_frame_buffer(&cpi->scaled_last_source, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate scaled last source buffer\");\n#ifdef ENABLE_KF_DENOISE\n  if (vpx_realloc_frame_buffer(&cpi->raw_unscaled_source, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate unscaled raw source frame buffer\");\n\n  if (vpx_realloc_frame_buffer(&cpi->raw_scaled_source, cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate scaled raw source frame buffer\");\n#endif\n}\n\nstatic void alloc_context_buffers_ext(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  int mi_size = cm->mi_cols * cm->mi_rows;\n\n  CHECK_MEM_ERROR(&cm->error, cpi->mbmi_ext_base,\n                  vpx_calloc(mi_size, sizeof(*cpi->mbmi_ext_base)));\n}\n\nstatic void alloc_compressor_data(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  int sb_rows;\n\n  if (vp9_alloc_context_buffers(cm, cm->width, cm->height)) {\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate context buffers\");\n  }\n\n  alloc_context_buffers_ext(cpi);\n\n  vpx_free(cpi->tile_tok[0][0]);\n\n  {\n    unsigned int tokens = get_token_alloc(cm->mb_rows, cm->mb_cols);\n    CHECK_MEM_ERROR(&cm->error, cpi->tile_tok[0][0],\n                    vpx_calloc(tokens, sizeof(*cpi->tile_tok[0][0])));\n  }\n\n  sb_rows = mi_cols_aligned_to_sb(cm->mi_rows) >> MI_BLOCK_SIZE_LOG2;\n  vpx_free(cpi->tplist[0][0]);\n  CHECK_MEM_ERROR(\n      &cm->error, cpi->tplist[0][0],\n      vpx_calloc(sb_rows * 4 * (1 << 6), sizeof(*cpi->tplist[0][0])));\n\n  vp9_setup_pc_tree(&cpi->common, &cpi->td);\n}\n\nvoid vp9_new_framerate(VP9_COMP *cpi, double framerate) {\n  cpi->framerate = framerate < 0.1 ? 30 : framerate;\n  vp9_rc_update_framerate(cpi);\n}\n\nstatic void set_tile_limits(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n\n  int min_log2_tile_cols, max_log2_tile_cols;\n  vp9_get_tile_n_bits(cm->mi_cols, &min_log2_tile_cols, &max_log2_tile_cols);\n\n  cm->log2_tile_cols =\n      clamp(cpi->oxcf.tile_columns, min_log2_tile_cols, max_log2_tile_cols);\n  cm->log2_tile_rows = cpi->oxcf.tile_rows;\n\n  if (cpi->oxcf.target_level == LEVEL_AUTO) {\n    const int level_tile_cols =\n        log_tile_cols_from_picsize_level(cpi->common.width, cpi->common.height);\n    if (cm->log2_tile_cols > level_tile_cols) {\n      cm->log2_tile_cols = VPXMAX(level_tile_cols, min_log2_tile_cols);\n    }\n  }\n}\n\nstatic void update_frame_size(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  MACROBLOCKD *const xd = &cpi->td.mb.e_mbd;\n\n  vp9_set_mb_mi(cm, cm->width, cm->height);\n  vp9_init_context_buffers(cm);\n  vp9_init_macroblockd(cm, xd, NULL);\n  cpi->td.mb.mbmi_ext_base = cpi->mbmi_ext_base;\n  memset(cpi->mbmi_ext_base, 0,\n         cm->mi_rows * cm->mi_cols * sizeof(*cpi->mbmi_ext_base));\n\n  set_tile_limits(cpi);\n}\n\nstatic void init_buffer_indices(VP9_COMP *cpi) {\n  int ref_frame;\n\n  for (ref_frame = 0; ref_frame < REF_FRAMES; ++ref_frame)\n    cpi->ref_fb_idx[ref_frame] = ref_frame;\n\n  cpi->lst_fb_idx = cpi->ref_fb_idx[LAST_FRAME - 1];\n  cpi->gld_fb_idx = cpi->ref_fb_idx[GOLDEN_FRAME - 1];\n  cpi->alt_fb_idx = cpi->ref_fb_idx[ALTREF_FRAME - 1];\n}\n\nstatic void init_level_constraint(LevelConstraint *lc) {\n  lc->level_index = -1;\n  lc->max_cpb_size = INT_MAX;\n  lc->max_frame_size = INT_MAX;\n  lc->fail_flag = 0;\n}\n\nstatic void set_level_constraint(LevelConstraint *ls, int8_t level_index) {\n  vpx_clear_system_state();\n  ls->level_index = level_index;\n  if (level_index >= 0) {\n    ls->max_cpb_size = vp9_level_defs[level_index].max_cpb_size * (double)1000;\n  }\n}\n\nstatic void init_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n\n  cpi->oxcf = *oxcf;\n  cpi->framerate = oxcf->init_framerate;\n  cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cm->use_highbitdepth = oxcf->use_highbitdepth;\n#endif\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  cm->width = oxcf->width;\n  cm->height = oxcf->height;\n  alloc_compressor_data(cpi);\n\n  cpi->svc.temporal_layering_mode = oxcf->temporal_layering_mode;\n\n  // Single thread case: use counts in common.\n  cpi->td.counts = &cm->counts;\n\n  // Spatial scalability.\n  cpi->svc.number_spatial_layers = oxcf->ss_number_layers;\n  // Temporal scalability.\n  cpi->svc.number_temporal_layers = oxcf->ts_number_layers;\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_init_layer_context(cpi);\n  }\n\n  // change includes all joint functionality\n  vp9_change_config(cpi, oxcf);\n\n  cpi->static_mb_pct = 0;\n  cpi->ref_frame_flags = 0;\n\n  init_buffer_indices(cpi);\n\n  vp9_noise_estimate_init(&cpi->noise_estimate, cm->width, cm->height);\n  cpi->fixed_qp_onepass = 0;\n}\n\nvoid vp9_check_reset_rc_flag(VP9_COMP *cpi) {\n  RATE_CONTROL *rc = &cpi->rc;\n\n  if (cpi->common.current_video_frame >\n      (unsigned int)cpi->svc.number_spatial_layers) {\n    if (cpi->use_svc) {\n      vp9_svc_check_reset_layer_rc_flag(cpi);\n    } else {\n      if (rc->avg_frame_bandwidth > (3 * rc->last_avg_frame_bandwidth >> 1) ||\n          rc->avg_frame_bandwidth < (rc->last_avg_frame_bandwidth >> 1)) {\n        rc->rc_1_frame = 0;\n        rc->rc_2_frame = 0;\n        rc->bits_off_target = rc->optimal_buffer_level;\n        rc->buffer_level = rc->optimal_buffer_level;\n      }\n    }\n  }\n}\n\nvoid vp9_set_rc_buffer_sizes(VP9_COMP *cpi) {\n  RATE_CONTROL *rc = &cpi->rc;\n  const VP9EncoderConfig *oxcf = &cpi->oxcf;\n\n  const int64_t bandwidth = oxcf->target_bandwidth;\n  const int64_t starting = oxcf->starting_buffer_level_ms;\n  const int64_t optimal = oxcf->optimal_buffer_level_ms;\n  const int64_t maximum = oxcf->maximum_buffer_size_ms;\n\n  rc->starting_buffer_level = starting * bandwidth / 1000;\n  rc->optimal_buffer_level =\n      (optimal == 0) ? bandwidth / 8 : optimal * bandwidth / 1000;\n  rc->maximum_buffer_size =\n      (maximum == 0) ? bandwidth / 8 : maximum * bandwidth / 1000;\n\n  // Under a configuration change, where maximum_buffer_size may change,\n  // keep buffer level clipped to the maximum allowed buffer size.\n  rc->bits_off_target = VPXMIN(rc->bits_off_target, rc->maximum_buffer_size);\n  rc->buffer_level = VPXMIN(rc->buffer_level, rc->maximum_buffer_size);\n}\n\n#if CONFIG_VP9_HIGHBITDEPTH\n#define HIGHBD_BFP(BT, SDF, SDSF, SDAF, VF, SVF, SVAF, SDX4DF, SDSX4DF) \\\n  cpi->fn_ptr[BT].sdf = SDF;                                            \\\n  cpi->fn_ptr[BT].sdsf = SDSF;                                          \\\n  cpi->fn_ptr[BT].sdaf = SDAF;                                          \\\n  cpi->fn_ptr[BT].vf = VF;                                              \\\n  cpi->fn_ptr[BT].svf = SVF;                                            \\\n  cpi->fn_ptr[BT].svaf = SVAF;                                          \\\n  cpi->fn_ptr[BT].sdx4df = SDX4DF;                                      \\\n  cpi->fn_ptr[BT].sdsx4df = SDSX4DF;\n\n#define MAKE_BFP_SAD_WRAPPER(fnname)                                           \\\n  static unsigned int fnname##_bits8(const uint8_t *src_ptr,                   \\\n                                     int source_stride,                        \\\n                                     const uint8_t *ref_ptr, int ref_stride) { \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride);                \\\n  }                                                                            \\\n  static unsigned int fnname##_bits10(                                         \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride) {                                                        \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride) >> 2;           \\\n  }                                                                            \\\n  static unsigned int fnname##_bits12(                                         \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride) {                                                        \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride) >> 4;           \\\n  }\n\n#define MAKE_BFP_SADAVG_WRAPPER(fnname)                                        \\\n  static unsigned int fnname##_bits8(                                          \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride, const uint8_t *second_pred) {                            \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride, second_pred);   \\\n  }                                                                            \\\n  static unsigned int fnname##_bits10(                                         \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride, const uint8_t *second_pred) {                            \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride, second_pred) >> \\\n           2;                                                                  \\\n  }                                                                            \\\n  static unsigned int fnname##_bits12(                                         \\\n      const uint8_t *src_ptr, int source_stride, const uint8_t *ref_ptr,       \\\n      int ref_stride, const uint8_t *second_pred) {                            \\\n    return fnname(src_ptr, source_stride, ref_ptr, ref_stride, second_pred) >> \\\n           4;                                                                  \\\n  }\n\n#define MAKE_BFP_SAD4D_WRAPPER(fnname)                                        \\\n  static void fnname##_bits8(const uint8_t *src_ptr, int source_stride,       \\\n                             const uint8_t *const ref_ptr[], int ref_stride,  \\\n                             unsigned int *sad_array) {                       \\\n    fnname(src_ptr, source_stride, ref_ptr, ref_stride, sad_array);           \\\n  }                                                                           \\\n  static void fnname##_bits10(const uint8_t *src_ptr, int source_stride,      \\\n                              const uint8_t *const ref_ptr[], int ref_stride, \\\n                              unsigned int *sad_array) {                      \\\n    int i;                                                                    \\\n    fnname(src_ptr, source_stride, ref_ptr, ref_stride, sad_array);           \\\n    for (i = 0; i < 4; i++) sad_array[i] >>= 2;                               \\\n  }                                                                           \\\n  static void fnname##_bits12(const uint8_t *src_ptr, int source_stride,      \\\n                              const uint8_t *const ref_ptr[], int ref_stride, \\\n                              unsigned int *sad_array) {                      \\\n    int i;                                                                    \\\n    fnname(src_ptr, source_stride, ref_ptr, ref_stride, sad_array);           \\\n    for (i = 0; i < 4; i++) sad_array[i] >>= 4;                               \\\n  }\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad32x16)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_32x16)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad32x16_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad32x16x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_32x16x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad16x32)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_16x32)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad16x32_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad16x32x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_16x32x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad64x32)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_64x32)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad64x32_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad64x32x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_64x32x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad32x64)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_32x64)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad32x64_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad32x64x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_32x64x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad32x32)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_32x32)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad32x32_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad32x32x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_32x32x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad64x64)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_64x64)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad64x64_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad64x64x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_64x64x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad16x16)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_16x16)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad16x16_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad16x16x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_16x16x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad16x8)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_16x8)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad16x8_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad16x8x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_16x8x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad8x16)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_8x16)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad8x16_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad8x16x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_8x16x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad8x8)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_8x8)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad8x8_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad8x8x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_8x8x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad8x4)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_8x4)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad8x4_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad8x4x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_8x4x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad4x8)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_4x8)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad4x8_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad4x8x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_4x8x4d)\n\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad4x4)\nMAKE_BFP_SAD_WRAPPER(vpx_highbd_sad_skip_4x4)\nMAKE_BFP_SADAVG_WRAPPER(vpx_highbd_sad4x4_avg)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad4x4x4d)\nMAKE_BFP_SAD4D_WRAPPER(vpx_highbd_sad_skip_4x4x4d)\n\nstatic void highbd_set_var_fns(VP9_COMP *const cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  if (cm->use_highbitdepth) {\n    switch (cm->bit_depth) {\n      case VPX_BITS_8:\n        HIGHBD_BFP(\n            BLOCK_32X16, vpx_highbd_sad32x16_bits8,\n            vpx_highbd_sad_skip_32x16_bits8, vpx_highbd_sad32x16_avg_bits8,\n            vpx_highbd_8_variance32x16, vpx_highbd_8_sub_pixel_variance32x16,\n            vpx_highbd_8_sub_pixel_avg_variance32x16,\n            vpx_highbd_sad32x16x4d_bits8, vpx_highbd_sad_skip_32x16x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_16X32, vpx_highbd_sad16x32_bits8,\n            vpx_highbd_sad_skip_16x32_bits8, vpx_highbd_sad16x32_avg_bits8,\n            vpx_highbd_8_variance16x32, vpx_highbd_8_sub_pixel_variance16x32,\n            vpx_highbd_8_sub_pixel_avg_variance16x32,\n            vpx_highbd_sad16x32x4d_bits8, vpx_highbd_sad_skip_16x32x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_64X32, vpx_highbd_sad64x32_bits8,\n            vpx_highbd_sad_skip_64x32_bits8, vpx_highbd_sad64x32_avg_bits8,\n            vpx_highbd_8_variance64x32, vpx_highbd_8_sub_pixel_variance64x32,\n            vpx_highbd_8_sub_pixel_avg_variance64x32,\n            vpx_highbd_sad64x32x4d_bits8, vpx_highbd_sad_skip_64x32x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_32X64, vpx_highbd_sad32x64_bits8,\n            vpx_highbd_sad_skip_32x64_bits8, vpx_highbd_sad32x64_avg_bits8,\n            vpx_highbd_8_variance32x64, vpx_highbd_8_sub_pixel_variance32x64,\n            vpx_highbd_8_sub_pixel_avg_variance32x64,\n            vpx_highbd_sad32x64x4d_bits8, vpx_highbd_sad_skip_32x64x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_32X32, vpx_highbd_sad32x32_bits8,\n            vpx_highbd_sad_skip_32x32_bits8, vpx_highbd_sad32x32_avg_bits8,\n            vpx_highbd_8_variance32x32, vpx_highbd_8_sub_pixel_variance32x32,\n            vpx_highbd_8_sub_pixel_avg_variance32x32,\n            vpx_highbd_sad32x32x4d_bits8, vpx_highbd_sad_skip_32x32x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_64X64, vpx_highbd_sad64x64_bits8,\n            vpx_highbd_sad_skip_64x64_bits8, vpx_highbd_sad64x64_avg_bits8,\n            vpx_highbd_8_variance64x64, vpx_highbd_8_sub_pixel_variance64x64,\n            vpx_highbd_8_sub_pixel_avg_variance64x64,\n            vpx_highbd_sad64x64x4d_bits8, vpx_highbd_sad_skip_64x64x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_16X16, vpx_highbd_sad16x16_bits8,\n            vpx_highbd_sad_skip_16x16_bits8, vpx_highbd_sad16x16_avg_bits8,\n            vpx_highbd_8_variance16x16, vpx_highbd_8_sub_pixel_variance16x16,\n            vpx_highbd_8_sub_pixel_avg_variance16x16,\n            vpx_highbd_sad16x16x4d_bits8, vpx_highbd_sad_skip_16x16x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_16X8, vpx_highbd_sad16x8_bits8,\n            vpx_highbd_sad_skip_16x8_bits8, vpx_highbd_sad16x8_avg_bits8,\n            vpx_highbd_8_variance16x8, vpx_highbd_8_sub_pixel_variance16x8,\n            vpx_highbd_8_sub_pixel_avg_variance16x8,\n            vpx_highbd_sad16x8x4d_bits8, vpx_highbd_sad_skip_16x8x4d_bits8)\n\n        HIGHBD_BFP(\n            BLOCK_8X16, vpx_highbd_sad8x16_bits8,\n            vpx_highbd_sad_skip_8x16_bits8, vpx_highbd_sad8x16_avg_bits8,\n            vpx_highbd_8_variance8x16, vpx_highbd_8_sub_pixel_variance8x16,\n            vpx_highbd_8_sub_pixel_avg_variance8x16,\n            vpx_highbd_sad8x16x4d_bits8, vpx_highbd_sad_skip_8x16x4d_bits8)\n\n        HIGHBD_BFP(BLOCK_8X8, vpx_highbd_sad8x8_bits8,\n                   vpx_highbd_sad_skip_8x8_bits8, vpx_highbd_sad8x8_avg_bits8,\n                   vpx_highbd_8_variance8x8, vpx_highbd_8_sub_pixel_variance8x8,\n                   vpx_highbd_8_sub_pixel_avg_variance8x8,\n                   vpx_highbd_sad8x8x4d_bits8, vpx_highbd_sad_skip_8x8x4d_bits8)\n\n        HIGHBD_BFP(BLOCK_8X4, vpx_highbd_sad8x4_bits8,\n                   vpx_highbd_sad_skip_8x4_bits8, vpx_highbd_sad8x4_avg_bits8,\n                   vpx_highbd_8_variance8x4, vpx_highbd_8_sub_pixel_variance8x4,\n                   vpx_highbd_8_sub_pixel_avg_variance8x4,\n                   vpx_highbd_sad8x4x4d_bits8, vpx_highbd_sad_skip_8x4x4d_bits8)\n\n        HIGHBD_BFP(BLOCK_4X8, vpx_highbd_sad4x8_bits8,\n                   vpx_highbd_sad_skip_4x8_bits8, vpx_highbd_sad4x8_avg_bits8,\n                   vpx_highbd_8_variance4x8, vpx_highbd_8_sub_pixel_variance4x8,\n                   vpx_highbd_8_sub_pixel_avg_variance4x8,\n                   vpx_highbd_sad4x8x4d_bits8, vpx_highbd_sad_skip_4x8x4d_bits8)\n\n        HIGHBD_BFP(BLOCK_4X4, vpx_highbd_sad4x4_bits8,\n                   vpx_highbd_sad_skip_4x4_bits8, vpx_highbd_sad4x4_avg_bits8,\n                   vpx_highbd_8_variance4x4, vpx_highbd_8_sub_pixel_variance4x4,\n                   vpx_highbd_8_sub_pixel_avg_variance4x4,\n                   vpx_highbd_sad4x4x4d_bits8, vpx_highbd_sad_skip_4x4x4d_bits8)\n        break;\n\n      case VPX_BITS_10:\n        HIGHBD_BFP(\n            BLOCK_32X16, vpx_highbd_sad32x16_bits10,\n            vpx_highbd_sad_skip_32x16_bits10, vpx_highbd_sad32x16_avg_bits10,\n            vpx_highbd_10_variance32x16, vpx_highbd_10_sub_pixel_variance32x16,\n            vpx_highbd_10_sub_pixel_avg_variance32x16,\n            vpx_highbd_sad32x16x4d_bits10, vpx_highbd_sad_skip_32x16x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_16X32, vpx_highbd_sad16x32_bits10,\n            vpx_highbd_sad_skip_16x32_bits10, vpx_highbd_sad16x32_avg_bits10,\n            vpx_highbd_10_variance16x32, vpx_highbd_10_sub_pixel_variance16x32,\n            vpx_highbd_10_sub_pixel_avg_variance16x32,\n            vpx_highbd_sad16x32x4d_bits10, vpx_highbd_sad_skip_16x32x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_64X32, vpx_highbd_sad64x32_bits10,\n            vpx_highbd_sad_skip_64x32_bits10, vpx_highbd_sad64x32_avg_bits10,\n            vpx_highbd_10_variance64x32, vpx_highbd_10_sub_pixel_variance64x32,\n            vpx_highbd_10_sub_pixel_avg_variance64x32,\n            vpx_highbd_sad64x32x4d_bits10, vpx_highbd_sad_skip_64x32x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_32X64, vpx_highbd_sad32x64_bits10,\n            vpx_highbd_sad_skip_32x64_bits10, vpx_highbd_sad32x64_avg_bits10,\n            vpx_highbd_10_variance32x64, vpx_highbd_10_sub_pixel_variance32x64,\n            vpx_highbd_10_sub_pixel_avg_variance32x64,\n            vpx_highbd_sad32x64x4d_bits10, vpx_highbd_sad_skip_32x64x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_32X32, vpx_highbd_sad32x32_bits10,\n            vpx_highbd_sad_skip_32x32_bits10, vpx_highbd_sad32x32_avg_bits10,\n            vpx_highbd_10_variance32x32, vpx_highbd_10_sub_pixel_variance32x32,\n            vpx_highbd_10_sub_pixel_avg_variance32x32,\n            vpx_highbd_sad32x32x4d_bits10, vpx_highbd_sad_skip_32x32x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_64X64, vpx_highbd_sad64x64_bits10,\n            vpx_highbd_sad_skip_64x64_bits10, vpx_highbd_sad64x64_avg_bits10,\n            vpx_highbd_10_variance64x64, vpx_highbd_10_sub_pixel_variance64x64,\n            vpx_highbd_10_sub_pixel_avg_variance64x64,\n            vpx_highbd_sad64x64x4d_bits10, vpx_highbd_sad_skip_64x64x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_16X16, vpx_highbd_sad16x16_bits10,\n            vpx_highbd_sad_skip_16x16_bits10, vpx_highbd_sad16x16_avg_bits10,\n            vpx_highbd_10_variance16x16, vpx_highbd_10_sub_pixel_variance16x16,\n            vpx_highbd_10_sub_pixel_avg_variance16x16,\n            vpx_highbd_sad16x16x4d_bits10, vpx_highbd_sad_skip_16x16x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_16X8, vpx_highbd_sad16x8_bits10,\n            vpx_highbd_sad_skip_16x8_bits10, vpx_highbd_sad16x8_avg_bits10,\n            vpx_highbd_10_variance16x8, vpx_highbd_10_sub_pixel_variance16x8,\n            vpx_highbd_10_sub_pixel_avg_variance16x8,\n            vpx_highbd_sad16x8x4d_bits10, vpx_highbd_sad_skip_16x8x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_8X16, vpx_highbd_sad8x16_bits10,\n            vpx_highbd_sad_skip_8x16_bits10, vpx_highbd_sad8x16_avg_bits10,\n            vpx_highbd_10_variance8x16, vpx_highbd_10_sub_pixel_variance8x16,\n            vpx_highbd_10_sub_pixel_avg_variance8x16,\n            vpx_highbd_sad8x16x4d_bits10, vpx_highbd_sad_skip_8x16x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_8X8, vpx_highbd_sad8x8_bits10, vpx_highbd_sad_skip_8x8_bits10,\n            vpx_highbd_sad8x8_avg_bits10, vpx_highbd_10_variance8x8,\n            vpx_highbd_10_sub_pixel_variance8x8,\n            vpx_highbd_10_sub_pixel_avg_variance8x8,\n            vpx_highbd_sad8x8x4d_bits10, vpx_highbd_sad_skip_8x8x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_8X4, vpx_highbd_sad8x4_bits10, vpx_highbd_sad_skip_8x4_bits10,\n            vpx_highbd_sad8x4_avg_bits10, vpx_highbd_10_variance8x4,\n            vpx_highbd_10_sub_pixel_variance8x4,\n            vpx_highbd_10_sub_pixel_avg_variance8x4,\n            vpx_highbd_sad8x4x4d_bits10, vpx_highbd_sad_skip_8x4x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_4X8, vpx_highbd_sad4x8_bits10, vpx_highbd_sad_skip_4x8_bits10,\n            vpx_highbd_sad4x8_avg_bits10, vpx_highbd_10_variance4x8,\n            vpx_highbd_10_sub_pixel_variance4x8,\n            vpx_highbd_10_sub_pixel_avg_variance4x8,\n            vpx_highbd_sad4x8x4d_bits10, vpx_highbd_sad_skip_4x8x4d_bits10)\n\n        HIGHBD_BFP(\n            BLOCK_4X4, vpx_highbd_sad4x4_bits10, vpx_highbd_sad_skip_4x4_bits10,\n            vpx_highbd_sad4x4_avg_bits10, vpx_highbd_10_variance4x4,\n            vpx_highbd_10_sub_pixel_variance4x4,\n            vpx_highbd_10_sub_pixel_avg_variance4x4,\n            vpx_highbd_sad4x4x4d_bits10, vpx_highbd_sad_skip_4x4x4d_bits10)\n        break;\n\n      default:\n        assert(cm->bit_depth == VPX_BITS_12);\n        HIGHBD_BFP(\n            BLOCK_32X16, vpx_highbd_sad32x16_bits12,\n            vpx_highbd_sad_skip_32x16_bits12, vpx_highbd_sad32x16_avg_bits12,\n            vpx_highbd_12_variance32x16, vpx_highbd_12_sub_pixel_variance32x16,\n            vpx_highbd_12_sub_pixel_avg_variance32x16,\n            vpx_highbd_sad32x16x4d_bits12, vpx_highbd_sad_skip_32x16x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_16X32, vpx_highbd_sad16x32_bits12,\n            vpx_highbd_sad_skip_16x32_bits12, vpx_highbd_sad16x32_avg_bits12,\n            vpx_highbd_12_variance16x32, vpx_highbd_12_sub_pixel_variance16x32,\n            vpx_highbd_12_sub_pixel_avg_variance16x32,\n            vpx_highbd_sad16x32x4d_bits12, vpx_highbd_sad_skip_16x32x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_64X32, vpx_highbd_sad64x32_bits12,\n            vpx_highbd_sad_skip_64x32_bits12, vpx_highbd_sad64x32_avg_bits12,\n            vpx_highbd_12_variance64x32, vpx_highbd_12_sub_pixel_variance64x32,\n            vpx_highbd_12_sub_pixel_avg_variance64x32,\n            vpx_highbd_sad64x32x4d_bits12, vpx_highbd_sad_skip_64x32x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_32X64, vpx_highbd_sad32x64_bits12,\n            vpx_highbd_sad_skip_32x64_bits12, vpx_highbd_sad32x64_avg_bits12,\n            vpx_highbd_12_variance32x64, vpx_highbd_12_sub_pixel_variance32x64,\n            vpx_highbd_12_sub_pixel_avg_variance32x64,\n            vpx_highbd_sad32x64x4d_bits12, vpx_highbd_sad_skip_32x64x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_32X32, vpx_highbd_sad32x32_bits12,\n            vpx_highbd_sad_skip_32x32_bits12, vpx_highbd_sad32x32_avg_bits12,\n            vpx_highbd_12_variance32x32, vpx_highbd_12_sub_pixel_variance32x32,\n            vpx_highbd_12_sub_pixel_avg_variance32x32,\n            vpx_highbd_sad32x32x4d_bits12, vpx_highbd_sad_skip_32x32x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_64X64, vpx_highbd_sad64x64_bits12,\n            vpx_highbd_sad_skip_64x64_bits12, vpx_highbd_sad64x64_avg_bits12,\n            vpx_highbd_12_variance64x64, vpx_highbd_12_sub_pixel_variance64x64,\n            vpx_highbd_12_sub_pixel_avg_variance64x64,\n            vpx_highbd_sad64x64x4d_bits12, vpx_highbd_sad_skip_64x64x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_16X16, vpx_highbd_sad16x16_bits12,\n            vpx_highbd_sad_skip_16x16_bits12, vpx_highbd_sad16x16_avg_bits12,\n            vpx_highbd_12_variance16x16, vpx_highbd_12_sub_pixel_variance16x16,\n            vpx_highbd_12_sub_pixel_avg_variance16x16,\n            vpx_highbd_sad16x16x4d_bits12, vpx_highbd_sad_skip_16x16x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_16X8, vpx_highbd_sad16x8_bits12,\n            vpx_highbd_sad_skip_16x8_bits12, vpx_highbd_sad16x8_avg_bits12,\n            vpx_highbd_12_variance16x8, vpx_highbd_12_sub_pixel_variance16x8,\n            vpx_highbd_12_sub_pixel_avg_variance16x8,\n            vpx_highbd_sad16x8x4d_bits12, vpx_highbd_sad_skip_16x8x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_8X16, vpx_highbd_sad8x16_bits12,\n            vpx_highbd_sad_skip_8x16_bits12, vpx_highbd_sad8x16_avg_bits12,\n            vpx_highbd_12_variance8x16, vpx_highbd_12_sub_pixel_variance8x16,\n            vpx_highbd_12_sub_pixel_avg_variance8x16,\n            vpx_highbd_sad8x16x4d_bits12, vpx_highbd_sad_skip_8x16x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_8X8, vpx_highbd_sad8x8_bits12, vpx_highbd_sad_skip_8x8_bits12,\n            vpx_highbd_sad8x8_avg_bits12, vpx_highbd_12_variance8x8,\n            vpx_highbd_12_sub_pixel_variance8x8,\n            vpx_highbd_12_sub_pixel_avg_variance8x8,\n            vpx_highbd_sad8x8x4d_bits12, vpx_highbd_sad_skip_8x8x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_8X4, vpx_highbd_sad8x4_bits12, vpx_highbd_sad_skip_8x4_bits12,\n            vpx_highbd_sad8x4_avg_bits12, vpx_highbd_12_variance8x4,\n            vpx_highbd_12_sub_pixel_variance8x4,\n            vpx_highbd_12_sub_pixel_avg_variance8x4,\n            vpx_highbd_sad8x4x4d_bits12, vpx_highbd_sad_skip_8x4x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_4X8, vpx_highbd_sad4x8_bits12, vpx_highbd_sad_skip_4x8_bits12,\n            vpx_highbd_sad4x8_avg_bits12, vpx_highbd_12_variance4x8,\n            vpx_highbd_12_sub_pixel_variance4x8,\n            vpx_highbd_12_sub_pixel_avg_variance4x8,\n            vpx_highbd_sad4x8x4d_bits12, vpx_highbd_sad_skip_4x8x4d_bits12)\n\n        HIGHBD_BFP(\n            BLOCK_4X4, vpx_highbd_sad4x4_bits12, vpx_highbd_sad_skip_4x4_bits12,\n            vpx_highbd_sad4x4_avg_bits12, vpx_highbd_12_variance4x4,\n            vpx_highbd_12_sub_pixel_variance4x4,\n            vpx_highbd_12_sub_pixel_avg_variance4x4,\n            vpx_highbd_sad4x4x4d_bits12, vpx_highbd_sad_skip_4x4x4d_bits12)\n        break;\n    }\n  }\n}\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\nstatic void realloc_segmentation_maps(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n\n  // Create the encoder segmentation map and set all entries to 0\n  vpx_free(cpi->segmentation_map);\n  CHECK_MEM_ERROR(&cm->error, cpi->segmentation_map,\n                  vpx_calloc(cm->mi_rows * cm->mi_cols, 1));\n\n  // Create a map used for cyclic background refresh.\n  if (cpi->cyclic_refresh) vp9_cyclic_refresh_free(cpi->cyclic_refresh);\n  CHECK_MEM_ERROR(&cm->error, cpi->cyclic_refresh,\n                  vp9_cyclic_refresh_alloc(cm->mi_rows, cm->mi_cols));\n\n  // Create a map used to mark inactive areas.\n  vpx_free(cpi->active_map.map);\n  CHECK_MEM_ERROR(&cm->error, cpi->active_map.map,\n                  vpx_calloc(cm->mi_rows * cm->mi_cols, 1));\n\n  // And a place holder structure is the coding context\n  // for use if we want to save and restore it\n  vpx_free(cpi->coding_context.last_frame_seg_map_copy);\n  CHECK_MEM_ERROR(&cm->error, cpi->coding_context.last_frame_seg_map_copy,\n                  vpx_calloc(cm->mi_rows * cm->mi_cols, 1));\n}\n\nstatic void alloc_copy_partition_data(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  if (cpi->prev_partition == NULL) {\n    CHECK_MEM_ERROR(&cm->error, cpi->prev_partition,\n                    (BLOCK_SIZE *)vpx_calloc(cm->mi_stride * cm->mi_rows,\n                                             sizeof(*cpi->prev_partition)));\n  }\n  if (cpi->prev_segment_id == NULL) {\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->prev_segment_id,\n        (int8_t *)vpx_calloc((cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1),\n                             sizeof(*cpi->prev_segment_id)));\n  }\n  if (cpi->prev_variance_low == NULL) {\n    CHECK_MEM_ERROR(&cm->error, cpi->prev_variance_low,\n                    (uint8_t *)vpx_calloc(\n                        (cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1) * 25,\n                        sizeof(*cpi->prev_variance_low)));\n  }\n  if (cpi->copied_frame_cnt == NULL) {\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->copied_frame_cnt,\n        (uint8_t *)vpx_calloc((cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1),\n                              sizeof(*cpi->copied_frame_cnt)));\n  }\n}\n\nstatic void free_copy_partition_data(VP9_COMP *cpi) {\n  vpx_free(cpi->prev_partition);\n  cpi->prev_partition = NULL;\n  vpx_free(cpi->prev_segment_id);\n  cpi->prev_segment_id = NULL;\n  vpx_free(cpi->prev_variance_low);\n  cpi->prev_variance_low = NULL;\n  vpx_free(cpi->copied_frame_cnt);\n  cpi->copied_frame_cnt = NULL;\n}\n\nvoid vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int last_w = cpi->oxcf.width;\n  int last_h = cpi->oxcf.height;\n\n  vp9_init_quantizer(cpi);\n  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  if (cm->profile <= PROFILE_1)\n    assert(cm->bit_depth == VPX_BITS_8);\n  else\n    assert(cm->bit_depth > VPX_BITS_8);\n\n  cpi->oxcf = *oxcf;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {\n    rc->baseline_gf_interval = FIXED_GF_INTERVAL;\n  } else {\n    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;\n  }\n\n  cpi->refresh_golden_frame = 0;\n  cpi->refresh_last_frame = 1;\n  cm->refresh_frame_context = 1;\n  cm->reset_frame_context = 0;\n\n  vp9_reset_segment_features(&cm->seg);\n  vp9_set_high_precision_mv(cpi, 0);\n\n  {\n    int i;\n\n    for (i = 0; i < MAX_SEGMENTS; i++)\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n  }\n  cpi->encode_breakout = cpi->oxcf.encode_breakout;\n\n  vp9_set_rc_buffer_sizes(cpi);\n\n  // Set up frame rate and related parameters rate control values.\n  vp9_new_framerate(cpi, cpi->framerate);\n\n  // Set absolute upper and lower quality limits\n  rc->worst_quality = cpi->oxcf.worst_allowed_q;\n  rc->best_quality = cpi->oxcf.best_allowed_q;\n\n  cm->interp_filter = cpi->sf.default_interp_filter;\n\n  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {\n    cm->render_width = cpi->oxcf.render_width;\n    cm->render_height = cpi->oxcf.render_height;\n  } else {\n    cm->render_width = cpi->oxcf.width;\n    cm->render_height = cpi->oxcf.height;\n  }\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      vp9_free_pc_tree(&cpi->td);\n      vpx_free(cpi->mbmi_ext_base);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    vpx_free(cpi->consec_zero_mv);\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->consec_zero_mv,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n\n    vpx_free(cpi->skin_map);\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->skin_map,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n\n    free_copy_partition_data(cpi);\n    alloc_copy_partition_data(cpi);\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_update_layer_context_change_config(cpi,\n                                           (int)cpi->oxcf.target_bandwidth);\n  }\n\n  vp9_check_reset_rc_flag(cpi);\n\n  cpi->alt_ref_source = NULL;\n  rc->is_src_frame_alt_ref = 0;\n\n#if 0\n  // Experimental RD Code\n  cpi->frame_distortion = 0;\n  cpi->last_frame_distortion = 0;\n#endif\n\n  set_tile_limits(cpi);\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n  cpi->ext_refresh_frame_context_pending = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  vp9_set_row_mt(cpi);\n}\n\n/***********************************************************************\n * Read before modifying 'cal_nmvjointsadcost' or 'cal_nmvsadcosts'    *\n ***********************************************************************\n * The following 2 functions ('cal_nmvjointsadcost' and                *\n * 'cal_nmvsadcosts') are used to calculate cost lookup tables         *\n * used by 'vp9_diamond_search_sad'. The C implementation of the       *\n * function is generic, but the NEON intrinsics optimised version      *\n * relies on the following properties of the computed tables:          *\n * For cal_nmvjointsadcost:                                            *\n *   - mvjointsadcost[1] == mvjointsadcost[2] == mvjointsadcost[3]     *\n * For cal_nmvsadcosts:                                                *\n *   - For all i: mvsadcost[0][i] == mvsadcost[1][i]                   *\n *         (Equal costs for both components)                           *\n *   - For all i: mvsadcost[0][i] == mvsadcost[0][-i]                  *\n *         (Cost function is even)                                     *\n * If these do not hold, then the NEON optimised version of the        *\n * 'vp9_diamond_search_sad' function cannot be used as it is, in which *\n * case you can revert to using the C function instead.                *\n ***********************************************************************/\n\nstatic void cal_nmvjointsadcost(int *mvjointsadcost) {\n  /*********************************************************************\n   * Warning: Read the comments above before modifying this function   *\n   *********************************************************************/\n  mvjointsadcost[0] = 600;\n  mvjointsadcost[1] = 300;\n  mvjointsadcost[2] = 300;\n  mvjointsadcost[3] = 300;\n}\n\nstatic void cal_nmvsadcosts(int *mvsadcost[2]) {\n  /*********************************************************************\n   * Warning: Read the comments above before modifying this function   *\n   *********************************************************************/\n  int i = 1;\n\n  mvsadcost[0][0] = 0;\n  mvsadcost[1][0] = 0;\n\n  do {\n    double z = 256 * (2 * (log2f(8 * i) + .6));\n    mvsadcost[0][i] = (int)z;\n    mvsadcost[1][i] = (int)z;\n    mvsadcost[0][-i] = (int)z;\n    mvsadcost[1][-i] = (int)z;\n  } while (++i <= MV_MAX);\n}\n\nstatic void cal_nmvsadcosts_hp(int *mvsadcost[2]) {\n  int i = 1;\n\n  mvsadcost[0][0] = 0;\n  mvsadcost[1][0] = 0;\n\n  do {\n    double z = 256 * (2 * (log2f(8 * i) + .6));\n    mvsadcost[0][i] = (int)z;\n    mvsadcost[1][i] = (int)z;\n    mvsadcost[0][-i] = (int)z;\n    mvsadcost[1][-i] = (int)z;\n  } while (++i <= MV_MAX);\n}\n\nstatic void init_ref_frame_bufs(VP9_COMMON *cm) {\n  int i;\n  BufferPool *const pool = cm->buffer_pool;\n  cm->new_fb_idx = INVALID_IDX;\n  for (i = 0; i < REF_FRAMES; ++i) {\n    cm->ref_frame_map[i] = INVALID_IDX;\n  }\n  for (i = 0; i < FRAME_BUFFERS; ++i) {\n    pool->frame_bufs[i].ref_count = 0;\n  }\n}\n\nstatic void update_initial_width(VP9_COMP *cpi, int use_highbitdepth,\n                                 int subsampling_x, int subsampling_y) {\n  VP9_COMMON *const cm = &cpi->common;\n#if !CONFIG_VP9_HIGHBITDEPTH\n  (void)use_highbitdepth;\n  assert(use_highbitdepth == 0);\n#endif\n\n  if (!cpi->initial_width ||\n#if CONFIG_VP9_HIGHBITDEPTH\n      cm->use_highbitdepth != use_highbitdepth ||\n#endif\n      cm->subsampling_x != subsampling_x ||\n      cm->subsampling_y != subsampling_y) {\n    cm->subsampling_x = subsampling_x;\n    cm->subsampling_y = subsampling_y;\n#if CONFIG_VP9_HIGHBITDEPTH\n    cm->use_highbitdepth = use_highbitdepth;\n#endif\n    alloc_util_frame_buffers(cpi);\n    cpi->initial_width = cm->width;\n    cpi->initial_height = cm->height;\n    cpi->initial_mbs = cm->MBs;\n  }\n}\n\n// TODO(angiebird): Check whether we can move this function to vpx_image.c\nstatic INLINE void vpx_img_chroma_subsampling(vpx_img_fmt_t fmt,\n                                              unsigned int *subsampling_x,\n                                              unsigned int *subsampling_y) {\n  switch (fmt) {\n    case VPX_IMG_FMT_I420:\n    case VPX_IMG_FMT_YV12:\n    case VPX_IMG_FMT_NV12:\n    case VPX_IMG_FMT_I422:\n    case VPX_IMG_FMT_I42016:\n    case VPX_IMG_FMT_I42216: *subsampling_x = 1; break;\n    default: *subsampling_x = 0; break;\n  }\n\n  switch (fmt) {\n    case VPX_IMG_FMT_I420:\n    case VPX_IMG_FMT_I440:\n    case VPX_IMG_FMT_YV12:\n    case VPX_IMG_FMT_NV12:\n    case VPX_IMG_FMT_I42016:\n    case VPX_IMG_FMT_I44016: *subsampling_y = 1; break;\n    default: *subsampling_y = 0; break;\n  }\n}\n\n// TODO(angiebird): Check whether we can move this function to vpx_image.c\nstatic INLINE int vpx_img_use_highbitdepth(vpx_img_fmt_t fmt) {\n  return fmt & VPX_IMG_FMT_HIGHBITDEPTH;\n}\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\nstatic void setup_denoiser_buffer(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  if (cpi->oxcf.noise_sensitivity > 0 &&\n      !cpi->denoiser.frame_buffer_initialized) {\n    if (vp9_denoiser_alloc(cm, &cpi->svc, &cpi->denoiser, cpi->use_svc,\n                           cpi->oxcf.noise_sensitivity, cm->width, cm->height,\n                           cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                           cm->use_highbitdepth,\n#endif\n                           VP9_ENC_BORDER_IN_PIXELS))\n      vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                         \"Failed to allocate denoiser\");\n  }\n}\n#endif\n\nvoid vp9_update_compressor_with_img_fmt(VP9_COMP *cpi, vpx_img_fmt_t img_fmt) {\n  const VP9EncoderConfig *oxcf = &cpi->oxcf;\n  unsigned int subsampling_x, subsampling_y;\n  const int use_highbitdepth = vpx_img_use_highbitdepth(img_fmt);\n  vpx_img_chroma_subsampling(img_fmt, &subsampling_x, &subsampling_y);\n\n  update_initial_width(cpi, use_highbitdepth, subsampling_x, subsampling_y);\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  setup_denoiser_buffer(cpi);\n#endif\n\n  assert(cpi->lookahead == NULL);\n  cpi->lookahead = vp9_lookahead_init(oxcf->width, oxcf->height, subsampling_x,\n                                      subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                                      use_highbitdepth,\n#endif\n                                      oxcf->lag_in_frames);\n  alloc_raw_frame_buffers(cpi);\n}\n\nVP9_COMP *vp9_create_compressor(const VP9EncoderConfig *oxcf,\n                                BufferPool *const pool) {\n  unsigned int i;\n  VP9_COMP *volatile const cpi = vpx_memalign(32, sizeof(VP9_COMP));\n  VP9_COMMON *volatile const cm = cpi != NULL ? &cpi->common : NULL;\n\n  if (!cm) return NULL;\n\n  vp9_zero(*cpi);\n\n  if (setjmp(cm->error.jmp)) {\n    cm->error.setjmp = 0;\n    vp9_remove_compressor(cpi);\n    return 0;\n  }\n\n  cm->error.setjmp = 1;\n  cm->alloc_mi = vp9_enc_alloc_mi;\n  cm->free_mi = vp9_enc_free_mi;\n  cm->setup_mi = vp9_enc_setup_mi;\n\n  CHECK_MEM_ERROR(&cm->error, cm->fc,\n                  (FRAME_CONTEXT *)vpx_calloc(1, sizeof(*cm->fc)));\n  CHECK_MEM_ERROR(\n      &cm->error, cm->frame_contexts,\n      (FRAME_CONTEXT *)vpx_calloc(FRAME_CONTEXTS, sizeof(*cm->frame_contexts)));\n\n  cpi->compute_frame_low_motion_onepass = 1;\n  cpi->use_svc = 0;\n  cpi->resize_state = ORIG;\n  cpi->external_resize = 0;\n  cpi->resize_avg_qp = 0;\n  cpi->resize_buffer_underflow = 0;\n  cpi->use_skin_detection = 0;\n  cpi->common.buffer_pool = pool;\n  init_ref_frame_bufs(cm);\n\n  cpi->force_update_segmentation = 0;\n\n  init_config(cpi, oxcf);\n  cpi->frame_info = vp9_get_frame_info(oxcf);\n\n  vp9_rc_init(&cpi->oxcf, oxcf->pass, &cpi->rc);\n  vp9_init_rd_parameters(cpi);\n\n  init_frame_indexes(cm);\n  cpi->tile_data = NULL;\n\n  realloc_segmentation_maps(cpi);\n\n  CHECK_MEM_ERROR(\n      &cm->error, cpi->skin_map,\n      vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n\n#if !CONFIG_REALTIME_ONLY\n  CHECK_MEM_ERROR(&cm->error, cpi->alt_ref_aq, vp9_alt_ref_aq_create());\n#endif\n\n  CHECK_MEM_ERROR(\n      &cm->error, cpi->consec_zero_mv,\n      vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvcosts[0],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvcosts[0])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvcosts[1],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvcosts[1])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvcosts_hp[0],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvcosts_hp[0])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvcosts_hp[1],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvcosts_hp[1])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvsadcosts[0],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvsadcosts[0])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvsadcosts[1],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvsadcosts[1])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvsadcosts_hp[0],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvsadcosts_hp[0])));\n  CHECK_MEM_ERROR(&cm->error, cpi->nmvsadcosts_hp[1],\n                  vpx_calloc(MV_VALS, sizeof(*cpi->nmvsadcosts_hp[1])));\n\n  for (i = 0; i < (sizeof(cpi->mbgraph_stats) / sizeof(cpi->mbgraph_stats[0]));\n       i++) {\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->mbgraph_stats[i].mb_stats,\n        vpx_calloc(cm->MBs * sizeof(*cpi->mbgraph_stats[i].mb_stats), 1));\n  }\n\n  cpi->refresh_alt_ref_frame = 0;\n  cpi->b_calculate_psnr = CONFIG_INTERNAL_STATS;\n\n  init_level_info(&cpi->level_info);\n  init_level_constraint(&cpi->level_constraint);\n\n#if CONFIG_INTERNAL_STATS\n  cpi->b_calculate_blockiness = 1;\n  cpi->b_calculate_consistency = 1;\n  cpi->total_inconsistency = 0;\n  cpi->psnr.worst = 100.0;\n  cpi->worst_ssim = 100.0;\n\n  cpi->count = 0;\n  cpi->bytes = 0;\n\n  if (cpi->b_calculate_psnr) {\n    cpi->total_sq_error = 0;\n    cpi->total_samples = 0;\n\n    cpi->totalp_sq_error = 0;\n    cpi->totalp_samples = 0;\n\n    cpi->tot_recode_hits = 0;\n    cpi->summed_quality = 0;\n    cpi->summed_weights = 0;\n    cpi->summedp_quality = 0;\n    cpi->summedp_weights = 0;\n  }\n\n  cpi->fastssim.worst = 100.0;\n\n  cpi->psnrhvs.worst = 100.0;\n\n  if (cpi->b_calculate_blockiness) {\n    cpi->total_blockiness = 0;\n    cpi->worst_blockiness = 0.0;\n  }\n\n  if (cpi->b_calculate_consistency) {\n    CHECK_MEM_ERROR(&cm->error, cpi->ssim_vars,\n                    vpx_calloc(cpi->common.mi_rows * cpi->common.mi_cols,\n                               sizeof(*cpi->ssim_vars) * 4));\n    cpi->worst_consistency = 100.0;\n  } else {\n    cpi->ssim_vars = NULL;\n  }\n\n#endif\n\n  cpi->first_time_stamp_ever = INT64_MAX;\n\n  /*********************************************************************\n   * Warning: Read the comments around 'cal_nmvjointsadcost' and       *\n   * 'cal_nmvsadcosts' before modifying how these tables are computed. *\n   *********************************************************************/\n  cal_nmvjointsadcost(cpi->td.mb.nmvjointsadcost);\n  cpi->td.mb.nmvcost[0] = &cpi->nmvcosts[0][MV_MAX];\n  cpi->td.mb.nmvcost[1] = &cpi->nmvcosts[1][MV_MAX];\n  cpi->td.mb.nmvsadcost[0] = &cpi->nmvsadcosts[0][MV_MAX];\n  cpi->td.mb.nmvsadcost[1] = &cpi->nmvsadcosts[1][MV_MAX];\n  cal_nmvsadcosts(cpi->td.mb.nmvsadcost);\n\n  cpi->td.mb.nmvcost_hp[0] = &cpi->nmvcosts_hp[0][MV_MAX];\n  cpi->td.mb.nmvcost_hp[1] = &cpi->nmvcosts_hp[1][MV_MAX];\n  cpi->td.mb.nmvsadcost_hp[0] = &cpi->nmvsadcosts_hp[0][MV_MAX];\n  cpi->td.mb.nmvsadcost_hp[1] = &cpi->nmvsadcosts_hp[1][MV_MAX];\n  cal_nmvsadcosts_hp(cpi->td.mb.nmvsadcost_hp);\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n#ifdef OUTPUT_YUV_DENOISED\n  yuv_denoised_file = fopen(\"denoised.yuv\", \"ab\");\n#endif\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  yuv_skinmap_file = fopen(\"skinmap.yuv\", \"wb\");\n#endif\n#ifdef OUTPUT_YUV_REC\n  yuv_rec_file = fopen(\"rec.yuv\", \"wb\");\n#endif\n#ifdef OUTPUT_YUV_SVC_SRC\n  yuv_svc_src[0] = fopen(\"svc_src_0.yuv\", \"wb\");\n  yuv_svc_src[1] = fopen(\"svc_src_1.yuv\", \"wb\");\n  yuv_svc_src[2] = fopen(\"svc_src_2.yuv\", \"wb\");\n#endif\n\n#if 0\n  framepsnr = fopen(\"framepsnr.stt\", \"a\");\n  kf_list = fopen(\"kf_list.stt\", \"w\");\n#endif\n\n  cpi->allow_encode_breakout = ENCODE_BREAKOUT_ENABLED;\n\n  {\n    vpx_codec_err_t codec_status = vp9_extrc_init(&cpi->ext_ratectrl);\n    if (codec_status != VPX_CODEC_OK) {\n      vpx_internal_error(&cm->error, codec_status, \"vp9_extrc_init() failed\");\n    }\n  }\n\n#if !CONFIG_REALTIME_ONLY\n  if (oxcf->pass == 1) {\n    vp9_init_first_pass(cpi);\n  } else if (oxcf->pass == 2) {\n    const size_t packet_sz = sizeof(FIRSTPASS_STATS);\n    const int packets = (int)(oxcf->two_pass_stats_in.sz / packet_sz);\n\n    if (cpi->svc.number_spatial_layers > 1 ||\n        cpi->svc.number_temporal_layers > 1) {\n      FIRSTPASS_STATS *const stats = oxcf->two_pass_stats_in.buf;\n      FIRSTPASS_STATS *stats_copy[VPX_SS_MAX_LAYERS] = { 0 };\n      int n;\n\n      for (n = 0; n < oxcf->ss_number_layers; ++n) {\n        FIRSTPASS_STATS *const last_packet_for_layer =\n            &stats[packets - oxcf->ss_number_layers + n];\n        const int layer_id = (int)last_packet_for_layer->spatial_layer_id;\n        const int packets_in_layer = (int)last_packet_for_layer->count + 1;\n        if (layer_id >= 0 && layer_id < oxcf->ss_number_layers) {\n          int num_frames;\n          LAYER_CONTEXT *const lc = &cpi->svc.layer_context[layer_id];\n\n          vpx_free(lc->rc_twopass_stats_in.buf);\n\n          lc->rc_twopass_stats_in.sz = packets_in_layer * packet_sz;\n          CHECK_MEM_ERROR(&cm->error, lc->rc_twopass_stats_in.buf,\n                          vpx_malloc(lc->rc_twopass_stats_in.sz));\n          lc->twopass.stats_in_start = lc->rc_twopass_stats_in.buf;\n          lc->twopass.stats_in = lc->twopass.stats_in_start;\n          lc->twopass.stats_in_end =\n              lc->twopass.stats_in_start + packets_in_layer - 1;\n          // Note the last packet is cumulative first pass stats.\n          // So the number of frames is packet number minus one\n          num_frames = packets_in_layer - 1;\n          fps_init_first_pass_info(&lc->twopass.first_pass_info,\n                                   lc->rc_twopass_stats_in.buf, num_frames);\n          stats_copy[layer_id] = lc->rc_twopass_stats_in.buf;\n        }\n      }\n\n      for (n = 0; n < packets; ++n) {\n        const int layer_id = (int)stats[n].spatial_layer_id;\n        if (layer_id >= 0 && layer_id < oxcf->ss_number_layers &&\n            stats_copy[layer_id] != NULL) {\n          *stats_copy[layer_id] = stats[n];\n          ++stats_copy[layer_id];\n        }\n      }\n\n      vp9_init_second_pass_spatial_svc(cpi);\n    } else {\n      int num_frames;\n\n      cpi->twopass.stats_in_start = oxcf->two_pass_stats_in.buf;\n      cpi->twopass.stats_in = cpi->twopass.stats_in_start;\n      cpi->twopass.stats_in_end = &cpi->twopass.stats_in[packets - 1];\n      // Note the last packet is cumulative first pass stats.\n      // So the number of frames is packet number minus one\n      num_frames = packets - 1;\n      fps_init_first_pass_info(&cpi->twopass.first_pass_info,\n                               oxcf->two_pass_stats_in.buf, num_frames);\n\n      vp9_init_second_pass(cpi);\n    }\n  }\n#endif  // !CONFIG_REALTIME_ONLY\n\n  cpi->mb_wiener_var_cols = 0;\n  cpi->mb_wiener_var_rows = 0;\n  cpi->mb_wiener_variance = NULL;\n\n  vp9_set_speed_features_framesize_independent(cpi, oxcf->speed);\n  vp9_set_speed_features_framesize_dependent(cpi, oxcf->speed);\n\n  {\n    const int bsize = BLOCK_16X16;\n    const int w = num_8x8_blocks_wide_lookup[bsize];\n    const int h = num_8x8_blocks_high_lookup[bsize];\n    const int num_cols = (cm->mi_cols + w - 1) / w;\n    const int num_rows = (cm->mi_rows + h - 1) / h;\n    CHECK_MEM_ERROR(&cm->error, cpi->mi_ssim_rdmult_scaling_factors,\n                    vpx_calloc(num_rows * num_cols,\n                               sizeof(*cpi->mi_ssim_rdmult_scaling_factors)));\n  }\n\n  cpi->kmeans_data_arr_alloc = 0;\n#if CONFIG_NON_GREEDY_MV\n  cpi->tpl_ready = 0;\n#endif  // CONFIG_NON_GREEDY_MV\n  for (i = 0; i < MAX_ARF_GOP_SIZE; ++i) {\n    cpi->tpl_stats[i].tpl_stats_ptr = NULL;\n  }\n\n  // Allocate memory to store variances for a frame.\n  CHECK_MEM_ERROR(&cm->error, cpi->source_diff_var,\n                  vpx_calloc(cm->MBs, sizeof(cpi->source_diff_var)));\n  cpi->source_var_thresh = 0;\n  cpi->frames_till_next_var_check = 0;\n#define BFP(BT, SDF, SDSF, SDAF, VF, SVF, SVAF, SDX4DF, SDSX4DF) \\\n  cpi->fn_ptr[BT].sdf = SDF;                                     \\\n  cpi->fn_ptr[BT].sdsf = SDSF;                                   \\\n  cpi->fn_ptr[BT].sdaf = SDAF;                                   \\\n  cpi->fn_ptr[BT].vf = VF;                                       \\\n  cpi->fn_ptr[BT].svf = SVF;                                     \\\n  cpi->fn_ptr[BT].svaf = SVAF;                                   \\\n  cpi->fn_ptr[BT].sdx4df = SDX4DF;                               \\\n  cpi->fn_ptr[BT].sdsx4df = SDSX4DF;\n\n  BFP(BLOCK_32X16, vpx_sad32x16, vpx_sad_skip_32x16, vpx_sad32x16_avg,\n      vpx_variance32x16, vpx_sub_pixel_variance32x16,\n      vpx_sub_pixel_avg_variance32x16, vpx_sad32x16x4d, vpx_sad_skip_32x16x4d)\n\n  BFP(BLOCK_16X32, vpx_sad16x32, vpx_sad_skip_16x32, vpx_sad16x32_avg,\n      vpx_variance16x32, vpx_sub_pixel_variance16x32,\n      vpx_sub_pixel_avg_variance16x32, vpx_sad16x32x4d, vpx_sad_skip_16x32x4d)\n\n  BFP(BLOCK_64X32, vpx_sad64x32, vpx_sad_skip_64x32, vpx_sad64x32_avg,\n      vpx_variance64x32, vpx_sub_pixel_variance64x32,\n      vpx_sub_pixel_avg_variance64x32, vpx_sad64x32x4d, vpx_sad_skip_64x32x4d)\n\n  BFP(BLOCK_32X64, vpx_sad32x64, vpx_sad_skip_32x64, vpx_sad32x64_avg,\n      vpx_variance32x64, vpx_sub_pixel_variance32x64,\n      vpx_sub_pixel_avg_variance32x64, vpx_sad32x64x4d, vpx_sad_skip_32x64x4d)\n\n  BFP(BLOCK_32X32, vpx_sad32x32, vpx_sad_skip_32x32, vpx_sad32x32_avg,\n      vpx_variance32x32, vpx_sub_pixel_variance32x32,\n      vpx_sub_pixel_avg_variance32x32, vpx_sad32x32x4d, vpx_sad_skip_32x32x4d)\n\n  BFP(BLOCK_64X64, vpx_sad64x64, vpx_sad_skip_64x64, vpx_sad64x64_avg,\n      vpx_variance64x64, vpx_sub_pixel_variance64x64,\n      vpx_sub_pixel_avg_variance64x64, vpx_sad64x64x4d, vpx_sad_skip_64x64x4d)\n\n  BFP(BLOCK_16X16, vpx_sad16x16, vpx_sad_skip_16x16, vpx_sad16x16_avg,\n      vpx_variance16x16, vpx_sub_pixel_variance16x16,\n      vpx_sub_pixel_avg_variance16x16, vpx_sad16x16x4d, vpx_sad_skip_16x16x4d)\n\n  BFP(BLOCK_16X8, vpx_sad16x8, vpx_sad_skip_16x8, vpx_sad16x8_avg,\n      vpx_variance16x8, vpx_sub_pixel_variance16x8,\n      vpx_sub_pixel_avg_variance16x8, vpx_sad16x8x4d, vpx_sad_skip_16x8x4d)\n\n  BFP(BLOCK_8X16, vpx_sad8x16, vpx_sad_skip_8x16, vpx_sad8x16_avg,\n      vpx_variance8x16, vpx_sub_pixel_variance8x16,\n      vpx_sub_pixel_avg_variance8x16, vpx_sad8x16x4d, vpx_sad_skip_8x16x4d)\n\n  BFP(BLOCK_8X8, vpx_sad8x8, vpx_sad_skip_8x8, vpx_sad8x8_avg, vpx_variance8x8,\n      vpx_sub_pixel_variance8x8, vpx_sub_pixel_avg_variance8x8, vpx_sad8x8x4d,\n      vpx_sad_skip_8x8x4d)\n\n  BFP(BLOCK_8X4, vpx_sad8x4, vpx_sad_skip_8x4, vpx_sad8x4_avg, vpx_variance8x4,\n      vpx_sub_pixel_variance8x4, vpx_sub_pixel_avg_variance8x4, vpx_sad8x4x4d,\n      vpx_sad_skip_8x4x4d)\n\n  BFP(BLOCK_4X8, vpx_sad4x8, vpx_sad_skip_4x8, vpx_sad4x8_avg, vpx_variance4x8,\n      vpx_sub_pixel_variance4x8, vpx_sub_pixel_avg_variance4x8, vpx_sad4x8x4d,\n      vpx_sad_skip_4x8x4d)\n\n  BFP(BLOCK_4X4, vpx_sad4x4, vpx_sad_skip_4x4, vpx_sad4x4_avg, vpx_variance4x4,\n      vpx_sub_pixel_variance4x4, vpx_sub_pixel_avg_variance4x4, vpx_sad4x4x4d,\n      vpx_sad_skip_4x4x4d)\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  /* vp9_init_quantizer() is first called here. Add check in\n   * vp9_frame_init_quantizer() so that vp9_init_quantizer is only\n   * called later when needed. This will avoid unnecessary calls of\n   * vp9_init_quantizer() for every frame.\n   */\n  vp9_init_quantizer(cpi);\n\n  vp9_loop_filter_init(cm);\n\n  // Set up the unit scaling factor used during motion search.\n#if CONFIG_VP9_HIGHBITDEPTH\n  vp9_setup_scale_factors_for_frame(&cpi->me_sf, cm->width, cm->height,\n                                    cm->width, cm->height,\n                                    cm->use_highbitdepth);\n#else\n  vp9_setup_scale_factors_for_frame(&cpi->me_sf, cm->width, cm->height,\n                                    cm->width, cm->height);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.me_sf = &cpi->me_sf;\n\n  cm->error.setjmp = 0;\n\n#if CONFIG_RATE_CTRL\n  encode_command_init(&cpi->encode_command);\n  if (oxcf->use_simple_encode_api) {\n    partition_info_init(cpi);\n    motion_vector_info_init(cpi);\n    fp_motion_vector_info_init(cpi);\n    tpl_stats_info_init(cpi);\n  }\n#endif\n\n  return cpi;\n}\n\n#if CONFIG_INTERNAL_STATS\n#define SNPRINT(H, T) snprintf((H) + strlen(H), sizeof(H) - strlen(H), (T))\n\n#define SNPRINT2(H, T, V) \\\n  snprintf((H) + strlen(H), sizeof(H) - strlen(H), (T), (V))\n#endif  // CONFIG_INTERNAL_STATS\n\nvoid vp9_remove_compressor(VP9_COMP *cpi) {\n  VP9_COMMON *cm;\n  unsigned int i;\n\n  if (!cpi) return;\n\n#if CONFIG_INTERNAL_STATS\n  vpx_free(cpi->ssim_vars);\n#endif\n\n  cm = &cpi->common;\n  if (cm->current_video_frame > 0) {\n#if CONFIG_INTERNAL_STATS\n    vpx_clear_system_state();\n\n    if (cpi->oxcf.pass != 1) {\n      char headings[512] = { 0 };\n      char results[512] = { 0 };\n      FILE *f = fopen(\"opsnr.stt\", \"a\");\n      double time_encoded =\n          (cpi->last_end_time_stamp_seen - cpi->first_time_stamp_ever) /\n          10000000.000;\n      double total_encode_time =\n          (cpi->time_receive_data + cpi->time_compress_data) / 1000.000;\n      const double dr =\n          (double)cpi->bytes * (double)8 / (double)1000 / time_encoded;\n      const double peak = (double)((1 << cpi->oxcf.input_bit_depth) - 1);\n      const double target_rate = (double)cpi->oxcf.target_bandwidth / 1000;\n      const double rate_err = ((100.0 * (dr - target_rate)) / target_rate);\n\n      if (cpi->b_calculate_psnr) {\n        const double total_psnr = vpx_sse_to_psnr(\n            (double)cpi->total_samples, peak, (double)cpi->total_sq_error);\n        const double totalp_psnr = vpx_sse_to_psnr(\n            (double)cpi->totalp_samples, peak, (double)cpi->totalp_sq_error);\n        const double total_ssim =\n            100 * pow(cpi->summed_quality / cpi->summed_weights, 8.0);\n        const double totalp_ssim =\n            100 * pow(cpi->summedp_quality / cpi->summedp_weights, 8.0);\n\n        snprintf(headings, sizeof(headings),\n                 \"Bitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\tGLPsnrP\\t\"\n                 \"VPXSSIM\\tVPSSIMP\\tFASTSIM\\tPSNRHVS\\t\"\n                 \"WstPsnr\\tWstSsim\\tWstFast\\tWstHVS\\t\"\n                 \"AVPsnrY\\tAPsnrCb\\tAPsnrCr\");\n        snprintf(results, sizeof(results),\n                 \"%7.2f\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                 \"%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                 \"%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t\"\n                 \"%7.3f\\t%7.3f\\t%7.3f\",\n                 dr, cpi->psnr.stat[ALL] / cpi->count, total_psnr,\n                 cpi->psnrp.stat[ALL] / cpi->count, totalp_psnr, total_ssim,\n                 totalp_ssim, cpi->fastssim.stat[ALL] / cpi->count,\n                 cpi->psnrhvs.stat[ALL] / cpi->count, cpi->psnr.worst,\n                 cpi->worst_ssim, cpi->fastssim.worst, cpi->psnrhvs.worst,\n                 cpi->psnr.stat[Y] / cpi->count, cpi->psnr.stat[U] / cpi->count,\n                 cpi->psnr.stat[V] / cpi->count);\n\n        if (cpi->b_calculate_blockiness) {\n          SNPRINT(headings, \"\\t  Block\\tWstBlck\");\n          SNPRINT2(results, \"\\t%7.3f\", cpi->total_blockiness / cpi->count);\n          SNPRINT2(results, \"\\t%7.3f\", cpi->worst_blockiness);\n        }\n\n        if (cpi->b_calculate_consistency) {\n          double consistency =\n              vpx_sse_to_psnr((double)cpi->totalp_samples, peak,\n                              (double)cpi->total_inconsistency);\n\n          SNPRINT(headings, \"\\tConsist\\tWstCons\");\n          SNPRINT2(results, \"\\t%7.3f\", consistency);\n          SNPRINT2(results, \"\\t%7.3f\", cpi->worst_consistency);\n        }\n\n        SNPRINT(headings, \"\\t    Time\\tRcErr\\tAbsErr\");\n        SNPRINT2(results, \"\\t%8.0f\", total_encode_time);\n        SNPRINT2(results, \"\\t%7.2f\", rate_err);\n        SNPRINT2(results, \"\\t%7.2f\", fabs(rate_err));\n\n        fprintf(f, \"%s\\tAPsnr611\\n\", headings);\n        fprintf(\n            f, \"%s\\t%7.3f\\n\", results,\n            (6 * cpi->psnr.stat[Y] + cpi->psnr.stat[U] + cpi->psnr.stat[V]) /\n                (cpi->count * 8));\n      }\n\n      fclose(f);\n    }\n#endif\n\n#if 0\n    {\n      printf(\"\\n_pick_loop_filter_level:%d\\n\", cpi->time_pick_lpf / 1000);\n      printf(\"\\n_frames receive_data encod_mb_row compress_frame  Total\\n\");\n      printf(\"%6d %10ld %10ld %10ld %10ld\\n\", cpi->common.current_video_frame,\n             cpi->time_receive_data / 1000, cpi->time_encode_sb_row / 1000,\n             cpi->time_compress_data / 1000,\n             (cpi->time_receive_data + cpi->time_compress_data) / 1000);\n    }\n#endif\n  }\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  vp9_denoiser_free(&(cpi->denoiser));\n#endif\n\n  if (cpi->kmeans_data_arr_alloc) {\n#if CONFIG_MULTITHREAD\n    pthread_mutex_destroy(&cpi->kmeans_mutex);\n#endif\n    vpx_free(cpi->kmeans_data_arr);\n  }\n\n  vp9_free_tpl_buffer(cpi);\n\n  vp9_loop_filter_dealloc(&cpi->lf_row_sync);\n  vp9_bitstream_encode_tiles_buffer_dealloc(cpi);\n  vp9_row_mt_mem_dealloc(cpi);\n  vp9_encode_free_mt_data(cpi);\n\n#if !CONFIG_REALTIME_ONLY\n  vp9_alt_ref_aq_destroy(cpi->alt_ref_aq);\n#endif\n\n  dealloc_compressor_data(cpi);\n\n  for (i = 0; i < sizeof(cpi->mbgraph_stats) / sizeof(cpi->mbgraph_stats[0]);\n       ++i) {\n    vpx_free(cpi->mbgraph_stats[i].mb_stats);\n  }\n\n  vp9_extrc_delete(&cpi->ext_ratectrl);\n\n  // Help detect use after free of the error detail string.\n  memset(cm->error.detail, 'A', sizeof(cm->error.detail) - 1);\n  cm->error.detail[sizeof(cm->error.detail) - 1] = '\\0';\n\n  vp9_remove_common(cm);\n  vp9_free_ref_frame_buffers(cm->buffer_pool);\n#if CONFIG_VP9_POSTPROC\n  vp9_free_postproc_buffers(cm);\n#endif\n  vpx_free(cpi);\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n#ifdef OUTPUT_YUV_DENOISED\n  fclose(yuv_denoised_file);\n#endif\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  fclose(yuv_skinmap_file);\n#endif\n#ifdef OUTPUT_YUV_REC\n  fclose(yuv_rec_file);\n#endif\n#ifdef OUTPUT_YUV_SVC_SRC\n  fclose(yuv_svc_src[0]);\n  fclose(yuv_svc_src[1]);\n  fclose(yuv_svc_src[2]);\n#endif\n\n#if 0\n\n  if (keyfile)\n    fclose(keyfile);\n\n  if (framepsnr)\n    fclose(framepsnr);\n\n  if (kf_list)\n    fclose(kf_list);\n\n#endif\n}\n\nint vp9_get_psnr(const VP9_COMP *cpi, PSNR_STATS *psnr) {\n  if (is_psnr_calc_enabled(cpi)) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    vpx_calc_highbd_psnr(cpi->raw_source_frame, cpi->common.frame_to_show, psnr,\n                         cpi->td.mb.e_mbd.bd, cpi->oxcf.input_bit_depth);\n#else\n    vpx_calc_psnr(cpi->raw_source_frame, cpi->common.frame_to_show, psnr);\n#endif\n    return 1;\n  } else {\n    vp9_zero(*psnr);\n    return 0;\n  }\n}\n\nint vp9_use_as_reference(VP9_COMP *cpi, int ref_frame_flags) {\n  if (ref_frame_flags > 7) return -1;\n\n  cpi->ref_frame_flags = ref_frame_flags;\n  return 0;\n}\n\nvoid vp9_update_reference(VP9_COMP *cpi, int ref_frame_flags) {\n  cpi->ext_refresh_golden_frame = (ref_frame_flags & VP9_GOLD_FLAG) != 0;\n  cpi->ext_refresh_alt_ref_frame = (ref_frame_flags & VP9_ALT_FLAG) != 0;\n  cpi->ext_refresh_last_frame = (ref_frame_flags & VP9_LAST_FLAG) != 0;\n  cpi->ext_refresh_frame_flags_pending = 1;\n}\n\nstatic YV12_BUFFER_CONFIG *get_vp9_ref_frame_buffer(\n    VP9_COMP *cpi, VP9_REFFRAME ref_frame_flag) {\n  MV_REFERENCE_FRAME ref_frame = NO_REF_FRAME;\n  if (ref_frame_flag == VP9_LAST_FLAG)\n    ref_frame = LAST_FRAME;\n  else if (ref_frame_flag == VP9_GOLD_FLAG)\n    ref_frame = GOLDEN_FRAME;\n  else if (ref_frame_flag == VP9_ALT_FLAG)\n    ref_frame = ALTREF_FRAME;\n\n  return ref_frame == NO_REF_FRAME ? NULL\n                                   : get_ref_frame_buffer(cpi, ref_frame);\n}\n\nint vp9_copy_reference_enc(VP9_COMP *cpi, VP9_REFFRAME ref_frame_flag,\n                           YV12_BUFFER_CONFIG *sd) {\n  YV12_BUFFER_CONFIG *cfg = get_vp9_ref_frame_buffer(cpi, ref_frame_flag);\n  if (cfg) {\n    vpx_yv12_copy_frame(cfg, sd);\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint vp9_set_reference_enc(VP9_COMP *cpi, VP9_REFFRAME ref_frame_flag,\n                          YV12_BUFFER_CONFIG *sd) {\n  YV12_BUFFER_CONFIG *cfg = get_vp9_ref_frame_buffer(cpi, ref_frame_flag);\n  if (cfg) {\n    vpx_yv12_copy_frame(sd, cfg);\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint vp9_update_entropy(VP9_COMP *cpi, int update) {\n  cpi->ext_refresh_frame_context = update;\n  cpi->ext_refresh_frame_context_pending = 1;\n  return 0;\n}\n\n#ifdef OUTPUT_YUV_REC\nvoid vp9_write_yuv_rec_frame(VP9_COMMON *cm) {\n  YV12_BUFFER_CONFIG *s = cm->frame_to_show;\n  uint8_t *src = s->y_buffer;\n  int h = cm->height;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  if (s->flags & YV12_FLAG_HIGHBITDEPTH) {\n    uint16_t *src16 = CONVERT_TO_SHORTPTR(s->y_buffer);\n\n    do {\n      fwrite(src16, s->y_width, 2, yuv_rec_file);\n      src16 += s->y_stride;\n    } while (--h);\n\n    src16 = CONVERT_TO_SHORTPTR(s->u_buffer);\n    h = s->uv_height;\n\n    do {\n      fwrite(src16, s->uv_width, 2, yuv_rec_file);\n      src16 += s->uv_stride;\n    } while (--h);\n\n    src16 = CONVERT_TO_SHORTPTR(s->v_buffer);\n    h = s->uv_height;\n\n    do {\n      fwrite(src16, s->uv_width, 2, yuv_rec_file);\n      src16 += s->uv_stride;\n    } while (--h);\n\n    fflush(yuv_rec_file);\n    return;\n  }\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  do {\n    fwrite(src, s->y_width, 1, yuv_rec_file);\n    src += s->y_stride;\n  } while (--h);\n\n  src = s->u_buffer;\n  h = s->uv_height;\n\n  do {\n    fwrite(src, s->uv_width, 1, yuv_rec_file);\n    src += s->uv_stride;\n  } while (--h);\n\n  src = s->v_buffer;\n  h = s->uv_height;\n\n  do {\n    fwrite(src, s->uv_width, 1, yuv_rec_file);\n    src += s->uv_stride;\n  } while (--h);\n\n  fflush(yuv_rec_file);\n}\n#endif\n\n#if CONFIG_VP9_HIGHBITDEPTH\nstatic void scale_and_extend_frame_nonnormative(const YV12_BUFFER_CONFIG *src,\n                                                YV12_BUFFER_CONFIG *dst,\n                                                int bd) {\n#else\nstatic void scale_and_extend_frame_nonnormative(const YV12_BUFFER_CONFIG *src,\n                                                YV12_BUFFER_CONFIG *dst) {\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  // TODO(dkovalev): replace YV12_BUFFER_CONFIG with vpx_image_t\n  int i;\n  const uint8_t *const srcs[3] = { src->y_buffer, src->u_buffer,\n                                   src->v_buffer };\n  const int src_strides[3] = { src->y_stride, src->uv_stride, src->uv_stride };\n  const int src_widths[3] = { src->y_crop_width, src->uv_crop_width,\n                              src->uv_crop_width };\n  const int src_heights[3] = { src->y_crop_height, src->uv_crop_height,\n                               src->uv_crop_height };\n  uint8_t *const dsts[3] = { dst->y_buffer, dst->u_buffer, dst->v_buffer };\n  const int dst_strides[3] = { dst->y_stride, dst->uv_stride, dst->uv_stride };\n  const int dst_widths[3] = { dst->y_crop_width, dst->uv_crop_width,\n                              dst->uv_crop_width };\n  const int dst_heights[3] = { dst->y_crop_height, dst->uv_crop_height,\n                               dst->uv_crop_height };\n\n  for (i = 0; i < MAX_MB_PLANE; ++i) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (src->flags & YV12_FLAG_HIGHBITDEPTH) {\n      vp9_highbd_resize_plane(srcs[i], src_heights[i], src_widths[i],\n                              src_strides[i], dsts[i], dst_heights[i],\n                              dst_widths[i], dst_strides[i], bd);\n    } else {\n      vp9_resize_plane(srcs[i], src_heights[i], src_widths[i], src_strides[i],\n                       dsts[i], dst_heights[i], dst_widths[i], dst_strides[i]);\n    }\n#else\n    vp9_resize_plane(srcs[i], src_heights[i], src_widths[i], src_strides[i],\n                     dsts[i], dst_heights[i], dst_widths[i], dst_strides[i]);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  }\n  vpx_extend_frame_borders(dst);\n}\n\n#if CONFIG_VP9_HIGHBITDEPTH\nstatic void scale_and_extend_frame(const YV12_BUFFER_CONFIG *src,\n                                   YV12_BUFFER_CONFIG *dst, int bd,\n                                   INTERP_FILTER filter_type,\n                                   int phase_scaler) {\n  const int src_w = src->y_crop_width;\n  const int src_h = src->y_crop_height;\n  const int dst_w = dst->y_crop_width;\n  const int dst_h = dst->y_crop_height;\n  const uint8_t *const srcs[3] = { src->y_buffer, src->u_buffer,\n                                   src->v_buffer };\n  const int src_strides[3] = { src->y_stride, src->uv_stride, src->uv_stride };\n  uint8_t *const dsts[3] = { dst->y_buffer, dst->u_buffer, dst->v_buffer };\n  const int dst_strides[3] = { dst->y_stride, dst->uv_stride, dst->uv_stride };\n  const InterpKernel *const kernel = vp9_filter_kernels[filter_type];\n  int x, y, i;\n\n  for (i = 0; i < MAX_MB_PLANE; ++i) {\n    const int factor = (i == 0 || i == 3 ? 1 : 2);\n    const int src_stride = src_strides[i];\n    const int dst_stride = dst_strides[i];\n    for (y = 0; y < dst_h; y += 16) {\n      const int y_q4 = y * (16 / factor) * src_h / dst_h + phase_scaler;\n      for (x = 0; x < dst_w; x += 16) {\n        const int x_q4 = x * (16 / factor) * src_w / dst_w + phase_scaler;\n        const uint8_t *src_ptr = srcs[i] +\n                                 (y / factor) * src_h / dst_h * src_stride +\n                                 (x / factor) * src_w / dst_w;\n        uint8_t *dst_ptr = dsts[i] + (y / factor) * dst_stride + (x / factor);\n\n        if (src->flags & YV12_FLAG_HIGHBITDEPTH) {\n          vpx_highbd_convolve8(CONVERT_TO_SHORTPTR(src_ptr), src_stride,\n                               CONVERT_TO_SHORTPTR(dst_ptr), dst_stride, kernel,\n                               x_q4 & 0xf, 16 * src_w / dst_w, y_q4 & 0xf,\n                               16 * src_h / dst_h, 16 / factor, 16 / factor,\n                               bd);\n        } else {\n          vpx_scaled_2d(src_ptr, src_stride, dst_ptr, dst_stride, kernel,\n                        x_q4 & 0xf, 16 * src_w / dst_w, y_q4 & 0xf,\n                        16 * src_h / dst_h, 16 / factor, 16 / factor);\n        }\n      }\n    }\n  }\n\n  vpx_extend_frame_borders(dst);\n}\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n#if !CONFIG_REALTIME_ONLY\nstatic int scale_down(VP9_COMP *cpi, int q) {\n  RATE_CONTROL *const rc = &cpi->rc;\n  GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n  int scale = 0;\n  assert(frame_is_kf_gf_arf(cpi));\n\n  if (rc->frame_size_selector == UNSCALED &&\n      q >= rc->rf_level_maxq[gf_group->rf_level[gf_group->index]]) {\n    const int max_size_thresh =\n        (int)(rate_thresh_mult[SCALE_STEP1] *\n              VPXMAX(rc->this_frame_target, rc->avg_frame_bandwidth));\n    scale = rc->projected_frame_size > max_size_thresh ? 1 : 0;\n  }\n  return scale;\n}\n\nstatic int big_rate_miss_high_threshold(VP9_COMP *cpi) {\n  const RATE_CONTROL *const rc = &cpi->rc;\n  int big_miss_high;\n\n  if (frame_is_kf_gf_arf(cpi))\n    big_miss_high = rc->this_frame_target * 3 / 2;\n  else\n    big_miss_high = rc->this_frame_target * 2;\n\n  return big_miss_high;\n}\n\nstatic int big_rate_miss(VP9_COMP *cpi) {\n  const RATE_CONTROL *const rc = &cpi->rc;\n  int big_miss_high;\n  int big_miss_low;\n\n  // Ignore for overlay frames\n  if (rc->is_src_frame_alt_ref) {\n    return 0;\n  } else {\n    big_miss_low = (rc->this_frame_target / 2);\n    big_miss_high = big_rate_miss_high_threshold(cpi);\n\n    return (rc->projected_frame_size > big_miss_high) ||\n           (rc->projected_frame_size < big_miss_low);\n  }\n}\n\n// test in two pass for the first\nstatic int two_pass_first_group_inter(VP9_COMP *cpi) {\n  if (cpi->oxcf.pass == 2) {\n    TWO_PASS *const twopass = &cpi->twopass;\n    GF_GROUP *const gf_group = &twopass->gf_group;\n    const int gfg_index = gf_group->index;\n\n    if (gfg_index == 0) return gf_group->update_type[gfg_index] == LF_UPDATE;\n    return gf_group->update_type[gfg_index - 1] != LF_UPDATE &&\n           gf_group->update_type[gfg_index] == LF_UPDATE;\n  } else {\n    return 0;\n  }\n}\n\n// Function to test for conditions that indicate we should loop\n// back and recode a frame.\nstatic int recode_loop_test(VP9_COMP *cpi, int high_limit, int low_limit, int q,\n                            int maxq, int minq) {\n  const RATE_CONTROL *const rc = &cpi->rc;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  const int frame_is_kfgfarf = frame_is_kf_gf_arf(cpi);\n  int force_recode = 0;\n\n  if ((rc->projected_frame_size >= rc->max_frame_bandwidth) ||\n      big_rate_miss(cpi) || (cpi->sf.recode_loop == ALLOW_RECODE) ||\n      (two_pass_first_group_inter(cpi) &&\n       (cpi->sf.recode_loop == ALLOW_RECODE_FIRST)) ||\n      (frame_is_kfgfarf && (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF))) {\n    if (frame_is_kfgfarf && (oxcf->resize_mode == RESIZE_DYNAMIC) &&\n        scale_down(cpi, q)) {\n      // Code this group at a lower resolution.\n      cpi->resize_pending = 1;\n      return 1;\n    }\n\n    // Force recode for extreme overshoot.\n    if ((rc->projected_frame_size >= rc->max_frame_bandwidth) ||\n        (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF &&\n         rc->projected_frame_size >= big_rate_miss_high_threshold(cpi))) {\n      return 1;\n    }\n\n    // TODO(agrange) high_limit could be greater than the scale-down threshold.\n    if ((rc->projected_frame_size > high_limit && q < maxq) ||\n        (rc->projected_frame_size < low_limit && q > minq)) {\n      force_recode = 1;\n    } else if (cpi->oxcf.rc_mode == VPX_CQ) {\n      // Deal with frame undershoot and whether or not we are\n      // below the automatically set cq level.\n      if (q > oxcf->cq_level &&\n          rc->projected_frame_size < ((rc->this_frame_target * 7) >> 3)) {\n        force_recode = 1;\n      }\n    }\n  }\n  return force_recode;\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void update_ref_frames(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  BufferPool *const pool = cm->buffer_pool;\n  GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n\n  if (cpi->rc.show_arf_as_gld) {\n    int tmp = cpi->alt_fb_idx;\n    cpi->alt_fb_idx = cpi->gld_fb_idx;\n    cpi->gld_fb_idx = tmp;\n  } else if (cm->show_existing_frame) {\n    // Pop ARF.\n    cpi->lst_fb_idx = cpi->alt_fb_idx;\n    cpi->alt_fb_idx =\n        stack_pop(gf_group->arf_index_stack, gf_group->stack_size);\n    --gf_group->stack_size;\n  }\n\n  // At this point the new frame has been encoded.\n  // If any buffer copy / swapping is signaled it should be done here.\n  if (cm->frame_type == KEY_FRAME) {\n    ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->gld_fb_idx],\n               cm->new_fb_idx);\n    ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->alt_fb_idx],\n               cm->new_fb_idx);\n  } else if (vp9_preserve_existing_gf(cpi)) {\n    // We have decided to preserve the previously existing golden frame as our\n    // new ARF frame. However, in the short term in function\n    // vp9_get_refresh_mask() we left it in the GF slot and, if\n    // we're updating the GF with the current decoded frame, we save it to the\n    // ARF slot instead.\n    // We now have to update the ARF with the current frame and swap gld_fb_idx\n    // and alt_fb_idx so that, overall, we've stored the old GF in the new ARF\n    // slot and, if we're updating the GF, the current frame becomes the new GF.\n    int tmp;\n\n    ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->alt_fb_idx],\n               cm->new_fb_idx);\n\n    tmp = cpi->alt_fb_idx;\n    cpi->alt_fb_idx = cpi->gld_fb_idx;\n    cpi->gld_fb_idx = tmp;\n  } else { /* For non key/golden frames */\n    if (cpi->refresh_alt_ref_frame) {\n      int arf_idx = gf_group->top_arf_idx;\n\n      // Push new ARF into stack.\n      stack_push(gf_group->arf_index_stack, cpi->alt_fb_idx,\n                 gf_group->stack_size);\n      ++gf_group->stack_size;\n\n      assert(arf_idx < REF_FRAMES);\n\n      ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[arf_idx], cm->new_fb_idx);\n      memcpy(cpi->interp_filter_selected[ALTREF_FRAME],\n             cpi->interp_filter_selected[0],\n             sizeof(cpi->interp_filter_selected[0]));\n\n      cpi->alt_fb_idx = arf_idx;\n    }\n\n    if (cpi->refresh_golden_frame) {\n      ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->gld_fb_idx],\n                 cm->new_fb_idx);\n      if (!cpi->rc.is_src_frame_alt_ref)\n        memcpy(cpi->interp_filter_selected[GOLDEN_FRAME],\n               cpi->interp_filter_selected[0],\n               sizeof(cpi->interp_filter_selected[0]));\n      else\n        memcpy(cpi->interp_filter_selected[GOLDEN_FRAME],\n               cpi->interp_filter_selected[ALTREF_FRAME],\n               sizeof(cpi->interp_filter_selected[ALTREF_FRAME]));\n    }\n  }\n\n  if (cpi->refresh_last_frame) {\n    ref_cnt_fb(pool->frame_bufs, &cm->ref_frame_map[cpi->lst_fb_idx],\n               cm->new_fb_idx);\n    if (!cpi->rc.is_src_frame_alt_ref)\n      memcpy(cpi->interp_filter_selected[LAST_FRAME],\n             cpi->interp_filter_selected[0],\n             sizeof(cpi->interp_filter_selected[0]));\n  }\n\n  if (gf_group->update_type[gf_group->index] == MID_OVERLAY_UPDATE) {\n    cpi->alt_fb_idx =\n        stack_pop(gf_group->arf_index_stack, gf_group->stack_size);\n    --gf_group->stack_size;\n  }\n}\n\nvoid vp9_update_reference_frames(VP9_COMP *cpi) {\n  update_ref_frames(cpi);\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  vp9_denoiser_update_ref_frame(cpi);\n#endif\n\n  if (is_one_pass_svc(cpi)) vp9_svc_update_ref_frame(cpi);\n}\n\nstatic void loopfilter_frame(VP9_COMP *cpi, VP9_COMMON *cm) {\n  MACROBLOCKD *xd = &cpi->td.mb.e_mbd;\n  struct loopfilter *lf = &cm->lf;\n  int is_reference_frame =\n      (cm->frame_type == KEY_FRAME || cpi->refresh_last_frame ||\n       cpi->refresh_golden_frame || cpi->refresh_alt_ref_frame);\n  if (cpi->use_svc &&\n      cpi->svc.temporal_layering_mode == VP9E_TEMPORAL_LAYERING_MODE_BYPASS)\n    is_reference_frame = !cpi->svc.non_reference_frame;\n\n  // Skip loop filter in show_existing_frame mode.\n  if (cm->show_existing_frame) {\n    lf->filter_level = 0;\n    return;\n  }\n\n  if (cpi->loopfilter_ctrl == NO_LOOPFILTER ||\n      (!is_reference_frame && cpi->loopfilter_ctrl == LOOPFILTER_REFERENCE)) {\n    lf->filter_level = 0;\n    vpx_extend_frame_inner_borders(cm->frame_to_show);\n    return;\n  }\n\n  if (xd->lossless) {\n    lf->filter_level = 0;\n    lf->last_filt_level = 0;\n  } else {\n    struct vpx_usec_timer timer;\n\n    vpx_clear_system_state();\n\n    vpx_usec_timer_start(&timer);\n\n    if (!cpi->rc.is_src_frame_alt_ref) {\n      if ((cpi->common.frame_type == KEY_FRAME) &&\n          (!cpi->rc.this_key_frame_forced)) {\n        lf->last_filt_level = 0;\n      }\n      vp9_pick_filter_level(cpi->Source, cpi, cpi->sf.lpf_pick);\n      lf->last_filt_level = lf->filter_level;\n    } else {\n      lf->filter_level = 0;\n    }\n\n    vpx_usec_timer_mark(&timer);\n    cpi->time_pick_lpf += vpx_usec_timer_elapsed(&timer);\n  }\n\n  if (lf->filter_level > 0 && is_reference_frame) {\n    vp9_build_mask_frame(cm, lf->filter_level, 0);\n\n    if (cpi->num_workers > 1)\n      vp9_loop_filter_frame_mt(cm->frame_to_show, cm, xd->plane,\n                               lf->filter_level, 0, 0, cpi->workers,\n                               cpi->num_workers, &cpi->lf_row_sync);\n    else\n      vp9_loop_filter_frame(cm->frame_to_show, cm, xd, lf->filter_level, 0, 0);\n  }\n\n  vpx_extend_frame_inner_borders(cm->frame_to_show);\n}\n\nvoid vp9_scale_references(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  MV_REFERENCE_FRAME ref_frame;\n  const VP9_REFFRAME ref_mask[3] = { VP9_LAST_FLAG, VP9_GOLD_FLAG,\n                                     VP9_ALT_FLAG };\n\n  for (ref_frame = LAST_FRAME; ref_frame <= ALTREF_FRAME; ++ref_frame) {\n    // Need to convert from VP9_REFFRAME to index into ref_mask (subtract 1).\n    if (cpi->ref_frame_flags & ref_mask[ref_frame - 1]) {\n      BufferPool *const pool = cm->buffer_pool;\n      const YV12_BUFFER_CONFIG *const ref =\n          get_ref_frame_buffer(cpi, ref_frame);\n\n      if (ref == NULL) {\n        cpi->scaled_ref_idx[ref_frame - 1] = INVALID_IDX;\n        continue;\n      }\n\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (ref->y_crop_width != cm->width || ref->y_crop_height != cm->height) {\n        RefCntBuffer *new_fb_ptr = NULL;\n        int force_scaling = 0;\n        int new_fb = cpi->scaled_ref_idx[ref_frame - 1];\n        if (new_fb == INVALID_IDX) {\n          new_fb = get_free_fb(cm);\n          force_scaling = 1;\n        }\n        if (new_fb == INVALID_IDX) return;\n        new_fb_ptr = &pool->frame_bufs[new_fb];\n        if (force_scaling || new_fb_ptr->buf.y_crop_width != cm->width ||\n            new_fb_ptr->buf.y_crop_height != cm->height) {\n          if (vpx_realloc_frame_buffer(&new_fb_ptr->buf, cm->width, cm->height,\n                                       cm->subsampling_x, cm->subsampling_y,\n                                       cm->use_highbitdepth,\n                                       VP9_ENC_BORDER_IN_PIXELS,\n                                       cm->byte_alignment, NULL, NULL, NULL))\n            vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                               \"Failed to allocate frame buffer\");\n          scale_and_extend_frame(ref, &new_fb_ptr->buf, (int)cm->bit_depth,\n                                 EIGHTTAP, 0);\n          cpi->scaled_ref_idx[ref_frame - 1] = new_fb;\n          alloc_frame_mvs(cm, new_fb);\n        }\n#else\n      if (ref->y_crop_width != cm->width || ref->y_crop_height != cm->height) {\n        RefCntBuffer *new_fb_ptr = NULL;\n        int force_scaling = 0;\n        int new_fb = cpi->scaled_ref_idx[ref_frame - 1];\n        if (new_fb == INVALID_IDX) {\n          new_fb = get_free_fb(cm);\n          force_scaling = 1;\n        }\n        if (new_fb == INVALID_IDX) return;\n        new_fb_ptr = &pool->frame_bufs[new_fb];\n        if (force_scaling || new_fb_ptr->buf.y_crop_width != cm->width ||\n            new_fb_ptr->buf.y_crop_height != cm->height) {\n          if (vpx_realloc_frame_buffer(&new_fb_ptr->buf, cm->width, cm->height,\n                                       cm->subsampling_x, cm->subsampling_y,\n                                       VP9_ENC_BORDER_IN_PIXELS,\n                                       cm->byte_alignment, NULL, NULL, NULL))\n            vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                               \"Failed to allocate frame buffer\");\n          vp9_scale_and_extend_frame(ref, &new_fb_ptr->buf, EIGHTTAP, 0);\n          cpi->scaled_ref_idx[ref_frame - 1] = new_fb;\n          alloc_frame_mvs(cm, new_fb);\n        }\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      } else {\n        int buf_idx;\n        RefCntBuffer *buf = NULL;\n        if (cpi->oxcf.pass == 0 && !cpi->use_svc) {\n          // Check for release of scaled reference.\n          buf_idx = cpi->scaled_ref_idx[ref_frame - 1];\n          if (buf_idx != INVALID_IDX) {\n            buf = &pool->frame_bufs[buf_idx];\n            --buf->ref_count;\n            cpi->scaled_ref_idx[ref_frame - 1] = INVALID_IDX;\n          }\n        }\n        buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);\n        buf = &pool->frame_bufs[buf_idx];\n        buf->buf.y_crop_width = ref->y_crop_width;\n        buf->buf.y_crop_height = ref->y_crop_height;\n        cpi->scaled_ref_idx[ref_frame - 1] = buf_idx;\n        ++buf->ref_count;\n      }\n    } else {\n      if (cpi->oxcf.pass != 0 || cpi->use_svc)\n        cpi->scaled_ref_idx[ref_frame - 1] = INVALID_IDX;\n    }\n  }\n}\n\nstatic void release_scaled_references(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  int i;\n  if (cpi->oxcf.pass == 0 && !cpi->use_svc) {\n    // Only release scaled references under certain conditions:\n    // if reference will be updated, or if scaled reference has same resolution.\n    int refresh[3];\n    refresh[0] = (cpi->refresh_last_frame) ? 1 : 0;\n    refresh[1] = (cpi->refresh_golden_frame) ? 1 : 0;\n    refresh[2] = (cpi->refresh_alt_ref_frame) ? 1 : 0;\n    for (i = LAST_FRAME; i <= ALTREF_FRAME; ++i) {\n      const int idx = cpi->scaled_ref_idx[i - 1];\n      if (idx != INVALID_IDX) {\n        RefCntBuffer *const buf = &cm->buffer_pool->frame_bufs[idx];\n        const YV12_BUFFER_CONFIG *const ref = get_ref_frame_buffer(cpi, i);\n        if (refresh[i - 1] || (buf->buf.y_crop_width == ref->y_crop_width &&\n                               buf->buf.y_crop_height == ref->y_crop_height)) {\n          --buf->ref_count;\n          cpi->scaled_ref_idx[i - 1] = INVALID_IDX;\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < REFS_PER_FRAME; ++i) {\n      const int idx = cpi->scaled_ref_idx[i];\n      if (idx != INVALID_IDX) {\n        RefCntBuffer *const buf = &cm->buffer_pool->frame_bufs[idx];\n        --buf->ref_count;\n        cpi->scaled_ref_idx[i] = INVALID_IDX;\n      }\n    }\n  }\n}\n\nstatic void full_to_model_count(unsigned int *model_count,\n                                unsigned int *full_count) {\n  int n;\n  model_count[ZERO_TOKEN] = full_count[ZERO_TOKEN];\n  model_count[ONE_TOKEN] = full_count[ONE_TOKEN];\n  model_count[TWO_TOKEN] = full_count[TWO_TOKEN];\n  for (n = THREE_TOKEN; n < EOB_TOKEN; ++n)\n    model_count[TWO_TOKEN] += full_count[n];\n  model_count[EOB_MODEL_TOKEN] = full_count[EOB_TOKEN];\n}\n\nstatic void full_to_model_counts(vp9_coeff_count_model *model_count,\n                                 vp9_coeff_count *full_count) {\n  int i, j, k, l;\n\n  for (i = 0; i < PLANE_TYPES; ++i)\n    for (j = 0; j < REF_TYPES; ++j)\n      for (k = 0; k < COEF_BANDS; ++k)\n        for (l = 0; l < BAND_COEFF_CONTEXTS(k); ++l)\n          full_to_model_count(model_count[i][j][k][l], full_count[i][j][k][l]);\n}\n\n#if 0 && CONFIG_INTERNAL_STATS\nstatic void output_frame_level_debug_stats(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  FILE *const f = fopen(\"tmp.stt\", cm->current_video_frame ? \"a\" : \"w\");\n  int64_t recon_err;\n\n  vpx_clear_system_state();\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  if (cm->use_highbitdepth) {\n    recon_err = vpx_highbd_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n  } else {\n    recon_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n  }\n#else\n  recon_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n\n  if (cpi->twopass.total_left_stats.coded_error != 0.0) {\n    double dc_quant_devisor;\n#if CONFIG_VP9_HIGHBITDEPTH\n    switch (cm->bit_depth) {\n      case VPX_BITS_8:\n        dc_quant_devisor = 4.0;\n        break;\n      case VPX_BITS_10:\n        dc_quant_devisor = 16.0;\n        break;\n      default:\n        assert(cm->bit_depth == VPX_BITS_12);\n        dc_quant_devisor = 64.0;\n        break;\n    }\n#else\n    dc_quant_devisor = 4.0;\n#endif\n\n    if (!cm->current_video_frame) {\n      fprintf(f, \"frame, width, height, last ts, last end ts, \"\n          \"source_alt_ref_pending, source_alt_ref_active, \"\n          \"this_frame_target, projected_frame_size, \"\n          \"projected_frame_size / MBs, \"\n          \"projected_frame_size - this_frame_target, \"\n          \"vbr_bits_off_target, vbr_bits_off_target_fast, \"\n          \"twopass.extend_minq, twopass.extend_minq_fast, \"\n          \"total_target_vs_actual, \"\n          \"starting_buffer_level - bits_off_target, \"\n          \"total_actual_bits, base_qindex, q for base_qindex, \"\n          \"dc quant, q for active_worst_quality, avg_q, q for oxcf.cq_level, \"\n          \"refresh_last_frame, refresh_golden_frame, refresh_alt_ref_frame, \"\n          \"frame_type, gfu_boost, \"\n          \"twopass.bits_left, \"\n          \"twopass.total_left_stats.coded_error, \"\n          \"twopass.bits_left / (1 + twopass.total_left_stats.coded_error), \"\n          \"tot_recode_hits, recon_err, kf_boost, \"\n          \"twopass.kf_zeromotion_pct, twopass.fr_content_type, \"\n          \"filter_level, seg.aq_av_offset\\n\");\n    }\n\n    fprintf(f, \"%10u, %d, %d, %10\"PRId64\", %10\"PRId64\", %d, %d, %10d, %10d, \"\n        \"%10d, %10d, %10\"PRId64\", %10\"PRId64\", %5d, %5d, %10\"PRId64\", \"\n        \"%10\"PRId64\", %10\"PRId64\", %10d, %7.2lf, %7.2lf, %7.2lf, %7.2lf, \"\n        \"%7.2lf, %6d, %6d, %5d, %5d, %5d, %10\"PRId64\", %10.3lf, %10lf, %8u, \"\n        \"%10\"PRId64\", %10d, %10d, %10d, %10d, %10d\\n\",\n        cpi->common.current_video_frame,\n        cm->width, cm->height,\n        cpi->last_time_stamp_seen,\n        cpi->last_end_time_stamp_seen,\n        cpi->rc.source_alt_ref_pending,\n        cpi->rc.source_alt_ref_active,\n        cpi->rc.this_frame_target,\n        cpi->rc.projected_frame_size,\n        cpi->rc.projected_frame_size / cpi->common.MBs,\n        (cpi->rc.projected_frame_size - cpi->rc.this_frame_target),\n        cpi->rc.vbr_bits_off_target,\n        cpi->rc.vbr_bits_off_target_fast,\n        cpi->twopass.extend_minq,\n        cpi->twopass.extend_minq_fast,\n        cpi->rc.total_target_vs_actual,\n        (cpi->rc.starting_buffer_level - cpi->rc.bits_off_target),\n        cpi->rc.total_actual_bits, cm->base_qindex,\n        vp9_convert_qindex_to_q(cm->base_qindex, cm->bit_depth),\n        (double)vp9_dc_quant(cm->base_qindex, 0, cm->bit_depth) /\n            dc_quant_devisor,\n        vp9_convert_qindex_to_q(cpi->twopass.active_worst_quality,\n                                cm->bit_depth),\n        cpi->rc.avg_q,\n        vp9_convert_qindex_to_q(cpi->oxcf.cq_level, cm->bit_depth),\n        cpi->refresh_last_frame, cpi->refresh_golden_frame,\n        cpi->refresh_alt_ref_frame, cm->frame_type, cpi->rc.gfu_boost,\n        cpi->twopass.bits_left,\n        cpi->twopass.total_left_stats.coded_error,\n        cpi->twopass.bits_left /\n            (1 + cpi->twopass.total_left_stats.coded_error),\n        cpi->tot_recode_hits, recon_err, cpi->rc.kf_boost,\n        cpi->twopass.kf_zeromotion_pct,\n        cpi->twopass.fr_content_type,\n        cm->lf.filter_level,\n        cm->seg.aq_av_offset);\n  }\n  fclose(f);\n\n  if (0) {\n    FILE *const fmodes = fopen(\"Modes.stt\", \"a\");\n    int i;\n\n    fprintf(fmodes, \"%6d:%1d:%1d:%1d \", cpi->common.current_video_frame,\n            cm->frame_type, cpi->refresh_golden_frame,\n            cpi->refresh_alt_ref_frame);\n\n    for (i = 0; i < MAX_MODES; ++i)\n      fprintf(fmodes, \"%5d \", cpi->mode_chosen_counts[i]);\n\n    fprintf(fmodes, \"\\n\");\n\n    fclose(fmodes);\n  }\n}\n#endif\n\nstatic void set_mv_search_params(VP9_COMP *cpi) {\n  const VP9_COMMON *const cm = &cpi->common;\n  const unsigned int max_mv_def = VPXMIN(cm->width, cm->height);\n\n  // Default based on max resolution.\n  cpi->mv_step_param = vp9_init_search_range(max_mv_def);\n\n  if (cpi->sf.mv.auto_mv_step_size) {\n    if (frame_is_intra_only(cm)) {\n      // Initialize max_mv_magnitude for use in the first INTER frame\n      // after a key/intra-only frame.\n      cpi->max_mv_magnitude = max_mv_def;\n    } else {\n      if (cm->show_frame) {\n        // Allow mv_steps to correspond to twice the max mv magnitude found\n        // in the previous frame, capped by the default max_mv_magnitude based\n        // on resolution.\n        cpi->mv_step_param = vp9_init_search_range(\n            VPXMIN(max_mv_def, 2 * cpi->max_mv_magnitude));\n      }\n      cpi->max_mv_magnitude = 0;\n    }\n  }\n}\n\nstatic void set_size_independent_vars(VP9_COMP *cpi) {\n  vp9_set_speed_features_framesize_independent(cpi, cpi->oxcf.speed);\n  vp9_set_rd_speed_thresholds(cpi);\n  vp9_set_rd_speed_thresholds_sub8x8(cpi);\n  cpi->common.interp_filter = cpi->sf.default_interp_filter;\n}\n\nstatic void set_size_dependent_vars(VP9_COMP *cpi, int *q, int *bottom_index,\n                                    int *top_index) {\n  VP9_COMMON *const cm = &cpi->common;\n\n  // Setup variables that depend on the dimensions of the frame.\n  vp9_set_speed_features_framesize_dependent(cpi, cpi->oxcf.speed);\n\n  // Decide q and q bounds.\n  *q = vp9_rc_pick_q_and_bounds(cpi, bottom_index, top_index);\n\n  if (cpi->oxcf.rc_mode == VPX_CBR && cpi->rc.force_max_q) {\n    *q = cpi->rc.worst_quality;\n    cpi->rc.force_max_q = 0;\n  }\n\n  if (cpi->use_svc) {\n    cpi->svc.base_qindex[cpi->svc.spatial_layer_id] = *q;\n  }\n\n  if (!frame_is_intra_only(cm)) {\n    vp9_set_high_precision_mv(cpi, (*q) < HIGH_PRECISION_MV_QTHRESH);\n  }\n\n#if !CONFIG_REALTIME_ONLY\n  // Configure experimental use of segmentation for enhanced coding of\n  // static regions if indicated.\n  // Only allowed in the second pass of a two pass encode, as it requires\n  // lagged coding, and if the relevant speed feature flag is set.\n  if (cpi->oxcf.pass == 2 && cpi->sf.static_segmentation)\n    configure_static_seg_features(cpi);\n#endif  // !CONFIG_REALTIME_ONLY\n\n#if CONFIG_VP9_POSTPROC && !(CONFIG_VP9_TEMPORAL_DENOISING)\n  if (cpi->oxcf.noise_sensitivity > 0) {\n    int l = 0;\n    switch (cpi->oxcf.noise_sensitivity) {\n      case 1: l = 20; break;\n      case 2: l = 40; break;\n      case 3: l = 60; break;\n      case 4:\n      case 5: l = 100; break;\n      case 6: l = 150; break;\n    }\n    if (!cpi->common.postproc_state.limits) {\n      CHECK_MEM_ERROR(&cm->error, cpi->common.postproc_state.limits,\n                      vpx_calloc(cpi->un_scaled_source->y_width,\n                                 sizeof(*cpi->common.postproc_state.limits)));\n    }\n    vp9_denoise(&cpi->common, cpi->Source, cpi->Source, l,\n                cpi->common.postproc_state.limits);\n  }\n#endif  // CONFIG_VP9_POSTPROC\n}\n\nstatic void init_motion_estimation(VP9_COMP *cpi) {\n  int y_stride = cpi->scaled_source.y_stride;\n\n  if (cpi->sf.mv.search_method == NSTEP) {\n    vp9_init3smotion_compensation(&cpi->ss_cfg, y_stride);\n  } else if (cpi->sf.mv.search_method == DIAMOND) {\n    vp9_init_dsmotion_compensation(&cpi->ss_cfg, y_stride);\n  }\n}\n\nstatic void set_frame_size(VP9_COMP *cpi) {\n  int ref_frame;\n  VP9_COMMON *const cm = &cpi->common;\n  VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  MACROBLOCKD *const xd = &cpi->td.mb.e_mbd;\n\n#if !CONFIG_REALTIME_ONLY\n  if (oxcf->pass == 2 && oxcf->rc_mode == VPX_VBR &&\n      ((oxcf->resize_mode == RESIZE_FIXED && cm->current_video_frame == 0) ||\n       (oxcf->resize_mode == RESIZE_DYNAMIC && cpi->resize_pending))) {\n    calculate_coded_size(cpi, &oxcf->scaled_frame_width,\n                         &oxcf->scaled_frame_height);\n\n    // There has been a change in frame size.\n    vp9_set_size_literal(cpi, oxcf->scaled_frame_width,\n                         oxcf->scaled_frame_height);\n  }\n#endif  // !CONFIG_REALTIME_ONLY\n\n  if (oxcf->pass == 0 && oxcf->rc_mode == VPX_CBR &&\n      oxcf->resize_mode == RESIZE_DYNAMIC && cpi->resize_pending != 0) {\n    // For SVC scaled width/height will have been set (svc->resize_set=1)\n    // in get_svc_params based on the layer width/height.\n    if (!cpi->use_svc || !cpi->svc.resize_set) {\n      oxcf->scaled_frame_width =\n          (oxcf->width * cpi->resize_scale_num) / cpi->resize_scale_den;\n      oxcf->scaled_frame_height =\n          (oxcf->height * cpi->resize_scale_num) / cpi->resize_scale_den;\n      // There has been a change in frame size.\n      vp9_set_size_literal(cpi, oxcf->scaled_frame_width,\n                           oxcf->scaled_frame_height);\n    }\n\n    // TODO(agrange) Scale cpi->max_mv_magnitude if frame-size has changed.\n    set_mv_search_params(cpi);\n\n    vp9_noise_estimate_init(&cpi->noise_estimate, cm->width, cm->height);\n#if CONFIG_VP9_TEMPORAL_DENOISING\n    // Reset the denoiser on the resized frame.\n    if (cpi->oxcf.noise_sensitivity > 0) {\n      vp9_denoiser_free(&(cpi->denoiser));\n      setup_denoiser_buffer(cpi);\n      // Dynamic resize is only triggered for non-SVC, so we can force\n      // golden frame update here as temporary fix to denoiser.\n      cpi->refresh_golden_frame = 1;\n    }\n#endif\n  }\n\n  if ((oxcf->pass == 2) && !cpi->use_svc) {\n    vp9_set_target_rate(cpi);\n  }\n\n  alloc_frame_mvs(cm, cm->new_fb_idx);\n\n  // Reset the frame pointers to the current frame size.\n  if (vpx_realloc_frame_buffer(get_frame_new_buffer(cm), cm->width, cm->height,\n                               cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                               cm->use_highbitdepth,\n#endif\n                               VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment,\n                               NULL, NULL, NULL))\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Failed to allocate frame buffer\");\n\n  alloc_util_frame_buffers(cpi);\n  init_motion_estimation(cpi);\n\n  for (ref_frame = LAST_FRAME; ref_frame <= ALTREF_FRAME; ++ref_frame) {\n    RefBuffer *const ref_buf = &cm->frame_refs[ref_frame - 1];\n    const int buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);\n\n    ref_buf->idx = buf_idx;\n\n    if (buf_idx != INVALID_IDX) {\n      YV12_BUFFER_CONFIG *const buf = &cm->buffer_pool->frame_bufs[buf_idx].buf;\n      ref_buf->buf = buf;\n#if CONFIG_VP9_HIGHBITDEPTH\n      vp9_setup_scale_factors_for_frame(\n          &ref_buf->sf, buf->y_crop_width, buf->y_crop_height, cm->width,\n          cm->height, (buf->flags & YV12_FLAG_HIGHBITDEPTH) ? 1 : 0);\n#else\n      vp9_setup_scale_factors_for_frame(&ref_buf->sf, buf->y_crop_width,\n                                        buf->y_crop_height, cm->width,\n                                        cm->height);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n      if (vp9_is_scaled(&ref_buf->sf)) vpx_extend_frame_borders(buf);\n    } else {\n      ref_buf->buf = NULL;\n    }\n  }\n\n  set_ref_ptrs(cm, xd, LAST_FRAME, LAST_FRAME);\n}\n\nstatic void save_encode_params(VP9_COMP *cpi) {\n  int tile_idx;\n  int i, j;\n  TileDataEnc *tile_data;\n  RD_OPT *rd_opt = &cpi->rd;\n  for (i = 0; i < MAX_REF_FRAMES; i++) {\n    for (j = 0; j < REFERENCE_MODES; j++)\n      rd_opt->prediction_type_threshes_prev[i][j] =\n          rd_opt->prediction_type_threshes[i][j];\n\n    for (j = 0; j < SWITCHABLE_FILTER_CONTEXTS; j++)\n      rd_opt->filter_threshes_prev[i][j] = rd_opt->filter_threshes[i][j];\n  }\n\n  for (tile_idx = 0; tile_idx < cpi->allocated_tiles; tile_idx++) {\n    assert(cpi->tile_data);\n    tile_data = &cpi->tile_data[tile_idx];\n    vp9_copy(tile_data->thresh_freq_fact_prev, tile_data->thresh_freq_fact);\n  }\n}\n\nstatic INLINE void set_raw_source_frame(VP9_COMP *cpi) {\n#ifdef ENABLE_KF_DENOISE\n  if (is_spatial_denoise_enabled(cpi)) {\n    cpi->raw_source_frame = vp9_scale_if_required(\n        cm, &cpi->raw_unscaled_source, &cpi->raw_scaled_source,\n        (oxcf->pass == 0), EIGHTTAP, 0);\n  } else {\n    cpi->raw_source_frame = cpi->Source;\n  }\n#else\n  cpi->raw_source_frame = cpi->Source;\n#endif\n}\n\nstatic int encode_without_recode_loop(VP9_COMP *cpi, size_t *size,\n                                      uint8_t *dest) {\n  VP9_COMMON *const cm = &cpi->common;\n  SVC *const svc = &cpi->svc;\n  int q = 0, bottom_index = 0, top_index = 0;\n  int no_drop_scene_change = 0;\n  const INTERP_FILTER filter_scaler =\n      (is_one_pass_svc(cpi))\n          ? svc->downsample_filter_type[svc->spatial_layer_id]\n          : EIGHTTAP;\n  const int phase_scaler =\n      (is_one_pass_svc(cpi))\n          ? svc->downsample_filter_phase[svc->spatial_layer_id]\n          : 0;\n\n  if (cm->show_existing_frame) {\n    cpi->rc.this_frame_target = 0;\n    if (is_psnr_calc_enabled(cpi)) set_raw_source_frame(cpi);\n    return 1;\n  }\n\n  svc->time_stamp_prev[svc->spatial_layer_id] = svc->time_stamp_superframe;\n\n  // Flag to check if its valid to compute the source sad (used for\n  // scene detection and for superblock content state in CBR mode).\n  // The flag may get reset below based on SVC or resizing state.\n  cpi->compute_source_sad_onepass = cpi->oxcf.mode == REALTIME;\n\n  vpx_clear_system_state();\n\n  set_frame_size(cpi);\n\n  if (is_one_pass_svc(cpi) &&\n      cpi->un_scaled_source->y_width == cm->width << 2 &&\n      cpi->un_scaled_source->y_height == cm->height << 2 &&\n      svc->scaled_temp.y_width == cm->width << 1 &&\n      svc->scaled_temp.y_height == cm->height << 1) {\n    // For svc, if it is a 1/4x1/4 downscaling, do a two-stage scaling to take\n    // advantage of the 1:2 optimized scaler. In the process, the 1/2x1/2\n    // result will be saved in scaled_temp and might be used later.\n    const INTERP_FILTER filter_scaler2 = svc->downsample_filter_type[1];\n    const int phase_scaler2 = svc->downsample_filter_phase[1];\n    cpi->Source = vp9_svc_twostage_scale(\n        cm, cpi->un_scaled_source, &cpi->scaled_source, &svc->scaled_temp,\n        filter_scaler, phase_scaler, filter_scaler2, phase_scaler2);\n    svc->scaled_one_half = 1;\n  } else if (is_one_pass_svc(cpi) &&\n             cpi->un_scaled_source->y_width == cm->width << 1 &&\n             cpi->un_scaled_source->y_height == cm->height << 1 &&\n             svc->scaled_one_half) {\n    // If the spatial layer is 1/2x1/2 and the scaling is already done in the\n    // two-stage scaling, use the result directly.\n    cpi->Source = &svc->scaled_temp;\n    svc->scaled_one_half = 0;\n  } else {\n    cpi->Source = vp9_scale_if_required(\n        cm, cpi->un_scaled_source, &cpi->scaled_source, (cpi->oxcf.pass == 0),\n        filter_scaler, phase_scaler);\n  }\n#ifdef OUTPUT_YUV_SVC_SRC\n  // Write out at most 3 spatial layers.\n  if (is_one_pass_svc(cpi) && svc->spatial_layer_id < 3) {\n    vpx_write_yuv_frame(yuv_svc_src[svc->spatial_layer_id], cpi->Source);\n  }\n#endif\n  // Unfiltered raw source used in metrics calculation if the source\n  // has been filtered.\n  if (is_psnr_calc_enabled(cpi)) {\n#ifdef ENABLE_KF_DENOISE\n    if (is_spatial_denoise_enabled(cpi)) {\n      cpi->raw_source_frame = vp9_scale_if_required(\n          cm, &cpi->raw_unscaled_source, &cpi->raw_scaled_source,\n          (cpi->oxcf.pass == 0), EIGHTTAP, phase_scaler);\n    } else {\n      cpi->raw_source_frame = cpi->Source;\n    }\n#else\n    cpi->raw_source_frame = cpi->Source;\n#endif\n  }\n\n  if ((cpi->use_svc &&\n       (svc->spatial_layer_id < svc->number_spatial_layers - 1 ||\n        svc->temporal_layer_id < svc->number_temporal_layers - 1 ||\n        svc->current_superframe < 1)) ||\n      cpi->resize_pending || cpi->resize_state || cpi->external_resize ||\n      cpi->resize_state != ORIG) {\n    cpi->compute_source_sad_onepass = 0;\n    if (cpi->content_state_sb_fd != NULL)\n      memset(cpi->content_state_sb_fd, 0,\n             (cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1) *\n                 sizeof(*cpi->content_state_sb_fd));\n  }\n\n  // Avoid scaling last_source unless its needed.\n  // Last source is needed if avg_source_sad() is used, or if\n  // partition_search_type == SOURCE_VAR_BASED_PARTITION, or if noise\n  // estimation is enabled.\n  if (cpi->unscaled_last_source != NULL &&\n      (cpi->oxcf.content == VP9E_CONTENT_SCREEN ||\n       (cpi->oxcf.pass == 0 && cpi->oxcf.rc_mode == VPX_VBR &&\n        cpi->oxcf.mode == REALTIME && cpi->oxcf.speed >= 5) ||\n       cpi->sf.partition_search_type == SOURCE_VAR_BASED_PARTITION ||\n       (cpi->noise_estimate.enabled && !cpi->oxcf.noise_sensitivity) ||\n       cpi->compute_source_sad_onepass))\n    cpi->Last_Source = vp9_scale_if_required(\n        cm, cpi->unscaled_last_source, &cpi->scaled_last_source,\n        (cpi->oxcf.pass == 0), EIGHTTAP, 0);\n\n  if (cpi->Last_Source == NULL ||\n      cpi->Last_Source->y_width != cpi->Source->y_width ||\n      cpi->Last_Source->y_height != cpi->Source->y_height)\n    cpi->compute_source_sad_onepass = 0;\n\n  if (frame_is_intra_only(cm) || cpi->resize_pending != 0) {\n    memset(cpi->consec_zero_mv, 0,\n           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n  }\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity > 0 && cpi->use_svc)\n    vp9_denoiser_reset_on_first_frame(cpi);\n#endif\n\n  // Scene detection is always used for VBR mode or screen-content case.\n  // For other cases (e.g., CBR mode) use it for 5 <= speed < 8 for now\n  // (need to check encoding time cost for doing this for speed 8).\n  cpi->rc.high_source_sad = 0;\n  cpi->rc.hybrid_intra_scene_change = 0;\n  cpi->rc.re_encode_maxq_scene_change = 0;\n  if (cm->show_frame && cpi->oxcf.mode == REALTIME &&\n      (cpi->oxcf.rc_mode == VPX_VBR ||\n       cpi->oxcf.content == VP9E_CONTENT_SCREEN ||\n       (cpi->oxcf.speed >= 5 && cpi->oxcf.speed < 8)))\n    vp9_scene_detection_onepass(cpi);\n\n  if (svc->spatial_layer_id == svc->first_spatial_layer_to_encode) {\n    svc->high_source_sad_superframe = cpi->rc.high_source_sad;\n    svc->high_num_blocks_with_motion = cpi->rc.high_num_blocks_with_motion;\n    // On scene change reset temporal layer pattern to TL0.\n    // Note that if the base/lower spatial layers are skipped: instead of\n    // inserting base layer here, we force max-q for the next superframe\n    // with lower spatial layers: this is done in vp9_encodedframe_overshoot()\n    // when max-q is decided for the current layer.\n    // Only do this reset for bypass/flexible mode.\n    if (svc->high_source_sad_superframe && svc->temporal_layer_id > 0 &&\n        svc->temporal_layering_mode == VP9E_TEMPORAL_LAYERING_MODE_BYPASS) {\n      // rc->high_source_sad will get reset so copy it to restore it.\n      int tmp_high_source_sad = cpi->rc.high_source_sad;\n      vp9_svc_reset_temporal_layers(cpi, cm->frame_type == KEY_FRAME);\n      cpi->rc.high_source_sad = tmp_high_source_sad;\n    }\n  }\n\n  vp9_update_noise_estimate(cpi);\n\n  // For 1 pass CBR, check if we are dropping this frame.\n  // Never drop on key frame, if base layer is key for svc,\n  // on scene change, or if superframe has layer sync.\n  if ((cpi->rc.high_source_sad || svc->high_source_sad_superframe) &&\n      !(cpi->rc.use_post_encode_drop && svc->last_layer_dropped[0]))\n    no_drop_scene_change = 1;\n  if (cpi->oxcf.pass == 0 && cpi->oxcf.rc_mode == VPX_CBR &&\n      !frame_is_intra_only(cm) && !no_drop_scene_change &&\n      !svc->superframe_has_layer_sync &&\n      (!cpi->use_svc ||\n       !svc->layer_context[svc->temporal_layer_id].is_key_frame)) {\n    if (vp9_rc_drop_frame(cpi)) return 0;\n  }\n\n  // For 1 pass SVC, only ZEROMV is allowed for spatial reference frame\n  // when svc->force_zero_mode_spatial_ref = 1. Under those conditions we can\n  // avoid this frame-level upsampling (for non intra_only frames).\n  // For SVC single_layer mode, dynamic resize is allowed and we need to\n  // scale references for this case.\n  if (frame_is_intra_only(cm) == 0 &&\n      ((svc->single_layer_svc && cpi->oxcf.resize_mode == RESIZE_DYNAMIC) ||\n       !(is_one_pass_svc(cpi) && svc->force_zero_mode_spatial_ref))) {\n    vp9_scale_references(cpi);\n  }\n\n  set_size_independent_vars(cpi);\n  set_size_dependent_vars(cpi, &q, &bottom_index, &top_index);\n\n  // search method and step parameter might be changed in speed settings.\n  init_motion_estimation(cpi);\n\n  if (cpi->sf.copy_partition_flag) alloc_copy_partition_data(cpi);\n\n  if (cpi->sf.svc_use_lowres_part &&\n      svc->spatial_layer_id == svc->number_spatial_layers - 2) {\n    if (svc->prev_partition_svc == NULL) {\n      CHECK_MEM_ERROR(\n          &cm->error, svc->prev_partition_svc,\n          (BLOCK_SIZE *)vpx_calloc(cm->mi_stride * cm->mi_rows,\n                                   sizeof(*svc->prev_partition_svc)));\n    }\n  }\n\n  // TODO(jianj): Look into issue of skin detection with high bitdepth.\n  if (cm->bit_depth == 8 && cpi->oxcf.speed >= 5 && cpi->oxcf.pass == 0 &&\n      cpi->oxcf.rc_mode == VPX_CBR &&\n      cpi->oxcf.content != VP9E_CONTENT_SCREEN &&\n      cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {\n    cpi->use_skin_detection = 1;\n  }\n\n  // Enable post encode frame dropping for CBR on non key frame, when\n  // ext_use_post_encode_drop is specified by user.\n  cpi->rc.use_post_encode_drop = cpi->rc.ext_use_post_encode_drop &&\n                                 cpi->oxcf.rc_mode == VPX_CBR &&\n                                 cm->frame_type != KEY_FRAME;\n\n  vp9_set_quantizer(cpi, q);\n  vp9_set_variance_partition_thresholds(cpi, q, 0);\n\n  setup_frame(cpi);\n\n  suppress_active_map(cpi);\n\n  if (cpi->use_svc) {\n    // On non-zero spatial layer, check for disabling inter-layer\n    // prediction.\n    if (svc->spatial_layer_id > 0) vp9_svc_constrain_inter_layer_pred(cpi);\n    vp9_svc_assert_constraints_pattern(cpi);\n  }\n\n  if (cpi->rc.last_post_encode_dropped_scene_change) {\n    cpi->rc.high_source_sad = 1;\n    svc->high_source_sad_superframe = 1;\n    // For now disable use_source_sad since Last_Source will not be the previous\n    // encoded but the dropped one.\n    cpi->sf.use_source_sad = 0;\n    cpi->rc.last_post_encode_dropped_scene_change = 0;\n  }\n  // Check if this high_source_sad (scene/slide change) frame should be\n  // encoded at high/max QP, and if so, set the q and adjust some rate\n  // control parameters.\n  if (cpi->sf.overshoot_detection_cbr_rt == FAST_DETECTION_MAXQ &&\n      (cpi->rc.high_source_sad ||\n       (cpi->use_svc && svc->high_source_sad_superframe))) {\n    if (vp9_encodedframe_overshoot(cpi, -1, &q)) {\n      vp9_set_quantizer(cpi, q);\n      vp9_set_variance_partition_thresholds(cpi, q, 0);\n    }\n  }\n\n#if !CONFIG_REALTIME_ONLY\n  // Variance adaptive and in frame q adjustment experiments are mutually\n  // exclusive.\n  if (cpi->oxcf.aq_mode == VARIANCE_AQ) {\n    vp9_vaq_frame_setup(cpi);\n  } else if (cpi->oxcf.aq_mode == EQUATOR360_AQ) {\n    vp9_360aq_frame_setup(cpi);\n  } else if (cpi->oxcf.aq_mode == COMPLEXITY_AQ) {\n    vp9_setup_in_frame_q_adj(cpi);\n  } else if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ) {\n    // it may be pretty bad for rate-control,\n    // and I should handle it somehow\n    vp9_alt_ref_aq_setup_map(cpi->alt_ref_aq, cpi);\n  } else {\n#endif\n    // If ROI is enabled and skip feature is used for segmentation, apply cyclic\n    // refresh but not apply ROI for skip for the first 20 frames (defined by\n    // FRAMES_NO_SKIPPING_AFTER_KEY) after key frame to improve quality.\n    if (cpi->roi.enabled && !frame_is_intra_only(cm)) {\n      if (cpi->roi.skip[BACKGROUND_SEG_SKIP_ID]) {\n        if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n          vp9_cyclic_refresh_setup(cpi);\n        if (cpi->rc.frames_since_key > FRAMES_NO_SKIPPING_AFTER_KEY)\n          apply_roi_map(cpi);\n      } else {\n        apply_roi_map(cpi);\n      }\n    } else if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {\n      vp9_cyclic_refresh_setup(cpi);\n    }\n\n#if !CONFIG_REALTIME_ONLY\n  }\n#endif\n\n  apply_active_map(cpi);\n\n  vp9_encode_frame(cpi);\n\n  // Check if we should re-encode this frame at high Q because of high\n  // overshoot based on the encoded frame size. Only for frames where\n  // high temporal-source SAD is detected.\n  // For SVC: all spatial layers are checked for re-encoding.\n  if (cpi->sf.overshoot_detection_cbr_rt == RE_ENCODE_MAXQ &&\n      (cpi->rc.high_source_sad ||\n       (cpi->use_svc && svc->high_source_sad_superframe))) {\n    int frame_size = 0;\n    // Get an estimate of the encoded frame size.\n    save_coding_context(cpi);\n    vp9_pack_bitstream(cpi, dest, size);\n    restore_coding_context(cpi);\n    frame_size = (int)(*size) << 3;\n    // Check if encoded frame will overshoot too much, and if so, set the q and\n    // adjust some rate control parameters, and return to re-encode the frame.\n    if (vp9_encodedframe_overshoot(cpi, frame_size, &q)) {\n      vpx_clear_system_state();\n      vp9_set_quantizer(cpi, q);\n      vp9_set_variance_partition_thresholds(cpi, q, 0);\n      suppress_active_map(cpi);\n      // Turn-off cyclic refresh for re-encoded frame.\n      if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {\n        CYCLIC_REFRESH *const cr = cpi->cyclic_refresh;\n        unsigned char *const seg_map = cpi->segmentation_map;\n        memset(seg_map, 0, cm->mi_rows * cm->mi_cols);\n        memset(cr->last_coded_q_map, MAXQ,\n               cm->mi_rows * cm->mi_cols * sizeof(*cr->last_coded_q_map));\n        cr->sb_index = 0;\n        vp9_disable_segmentation(&cm->seg);\n      }\n      apply_active_map(cpi);\n      vp9_encode_frame(cpi);\n    }\n  }\n\n  // Update some stats from cyclic refresh, and check for golden frame update.\n  if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ && cm->seg.enabled &&\n      !frame_is_intra_only(cm) && cpi->cyclic_refresh->content_mode)\n    vp9_cyclic_refresh_postencode(cpi);\n\n  // Update the skip mb flag probabilities based on the distribution\n  // seen in the last encoder iteration.\n  // update_base_skip_probs(cpi);\n  vpx_clear_system_state();\n  return 1;\n}\n\nstatic int get_ref_frame_flags(const VP9_COMP *cpi) {\n  const int *const map = cpi->common.ref_frame_map;\n  const int gold_is_last = map[cpi->gld_fb_idx] == map[cpi->lst_fb_idx];\n  const int alt_is_last = map[cpi->alt_fb_idx] == map[cpi->lst_fb_idx];\n  const int gold_is_alt = map[cpi->gld_fb_idx] == map[cpi->alt_fb_idx];\n  int flags = VP9_ALT_FLAG | VP9_GOLD_FLAG | VP9_LAST_FLAG;\n\n  if (gold_is_last) flags &= ~VP9_GOLD_FLAG;\n\n  if (cpi->rc.frames_till_gf_update_due == INT_MAX &&\n      (cpi->svc.number_temporal_layers == 1 &&\n       cpi->svc.number_spatial_layers == 1))\n    flags &= ~VP9_GOLD_FLAG;\n\n  if (alt_is_last) flags &= ~VP9_ALT_FLAG;\n\n  if (gold_is_alt) flags &= ~VP9_ALT_FLAG;\n\n  return flags;\n}\n\n#if !CONFIG_REALTIME_ONLY\n#define MAX_QSTEP_ADJ 4\nstatic int get_qstep_adj(int rate_excess, int rate_limit) {\n  int qstep =\n      rate_limit ? ((rate_excess + rate_limit / 2) / rate_limit) : INT_MAX;\n  return VPXMIN(qstep, MAX_QSTEP_ADJ);\n}\n\n#if CONFIG_RATE_CTRL\nstatic void init_rq_history(RATE_QINDEX_HISTORY *rq_history) {\n  rq_history->recode_count = 0;\n  rq_history->q_index_high = 255;\n  rq_history->q_index_low = 0;\n}\n\nstatic void update_rq_history(RATE_QINDEX_HISTORY *rq_history, int target_bits,\n                              int actual_bits, int q_index) {\n  rq_history->q_index_history[rq_history->recode_count] = q_index;\n  rq_history->rate_history[rq_history->recode_count] = actual_bits;\n  if (actual_bits <= target_bits) {\n    rq_history->q_index_high = q_index;\n  }\n  if (actual_bits >= target_bits) {\n    rq_history->q_index_low = q_index;\n  }\n  rq_history->recode_count += 1;\n}\n\nstatic int guess_q_index_from_model(const RATE_QSTEP_MODEL *rq_model,\n                                    int target_bits) {\n  // The model predicts bits as follows.\n  // target_bits = bias - ratio * log2(q_step)\n  // Given the target_bits, we compute the q_step as follows.\n  double q_step;\n  assert(rq_model->ratio > 0);\n  q_step = pow(2.0, (rq_model->bias - target_bits) / rq_model->ratio);\n  // TODO(angiebird): Make this function support highbitdepth.\n  return vp9_convert_q_to_qindex(q_step, VPX_BITS_8);\n}\n\nstatic int guess_q_index_linear(int prev_q_index, int target_bits,\n                                int actual_bits, int gap) {\n  int q_index = prev_q_index;\n  if (actual_bits < target_bits) {\n    q_index -= gap;\n    q_index = VPXMAX(q_index, 0);\n  } else {\n    q_index += gap;\n    q_index = VPXMIN(q_index, 255);\n  }\n  return q_index;\n}\n\nstatic double get_bits_percent_diff(int target_bits, int actual_bits) {\n  double diff;\n  target_bits = VPXMAX(target_bits, 1);\n  diff = abs(target_bits - actual_bits) * 1. / target_bits;\n  return diff * 100;\n}\n\nstatic int rq_model_predict_q_index(const RATE_QSTEP_MODEL *rq_model,\n                                    const RATE_QINDEX_HISTORY *rq_history,\n                                    int target_bits) {\n  int q_index = 128;\n  if (rq_history->recode_count > 0) {\n    const int actual_bits =\n        rq_history->rate_history[rq_history->recode_count - 1];\n    const int prev_q_index =\n        rq_history->q_index_history[rq_history->recode_count - 1];\n    const double percent_diff = get_bits_percent_diff(target_bits, actual_bits);\n    if (percent_diff > 50) {\n      // Binary search.\n      // When the actual_bits and target_bits are far apart, binary search\n      // q_index is faster.\n      q_index = (rq_history->q_index_low + rq_history->q_index_high) / 2;\n    } else {\n      if (rq_model->ready) {\n        q_index = guess_q_index_from_model(rq_model, target_bits);\n      } else {\n        // TODO(angiebird): Find a better way to set the gap.\n        q_index =\n            guess_q_index_linear(prev_q_index, target_bits, actual_bits, 20);\n      }\n    }\n  } else {\n    if (rq_model->ready) {\n      q_index = guess_q_index_from_model(rq_model, target_bits);\n    }\n  }\n\n  assert(rq_history->q_index_low <= rq_history->q_index_high);\n  if (q_index <= rq_history->q_index_low) {\n    q_index = rq_history->q_index_low + 1;\n  }\n  if (q_index >= rq_history->q_index_high) {\n    q_index = rq_history->q_index_high - 1;\n  }\n  return q_index;\n}\n\nstatic void rq_model_update(const RATE_QINDEX_HISTORY *rq_history,\n                            int target_bits, RATE_QSTEP_MODEL *rq_model) {\n  const int recode_count = rq_history->recode_count;\n  const double delta = 0.00001;\n  if (recode_count >= 2) {\n    const int q_index1 = rq_history->q_index_history[recode_count - 2];\n    const int q_index2 = rq_history->q_index_history[recode_count - 1];\n    const int r1 = rq_history->rate_history[recode_count - 2];\n    const int r2 = rq_history->rate_history[recode_count - 1];\n    int valid = 0;\n    // lower q_index should yield higher bit rate\n    if (q_index1 < q_index2) {\n      valid = r1 > r2;\n    } else if (q_index1 > q_index2) {\n      valid = r1 < r2;\n    }\n    // Only update the model when the q_index and rate behave normally.\n    if (valid) {\n      // Fit the ratio and bias of rq_model based on last two recode histories.\n      const double s1 = vp9_convert_qindex_to_q(q_index1, VPX_BITS_8);\n      const double s2 = vp9_convert_qindex_to_q(q_index2, VPX_BITS_8);\n      if (fabs(log2(s1) - log2(s2)) > delta) {\n        rq_model->ratio = (r2 - r1) / (log2(s1) - log2(s2));\n        rq_model->bias = r1 + (rq_model->ratio) * log2(s1);\n        if (rq_model->ratio > delta && rq_model->bias > delta) {\n          rq_model->ready = 1;\n        }\n      }\n    }\n  } else if (recode_count == 1) {\n    if (rq_model->ready) {\n      // Update the ratio only when the initial model exists and we only have\n      // one recode history.\n      const int prev_q = rq_history->q_index_history[recode_count - 1];\n      const double prev_q_step = vp9_convert_qindex_to_q(prev_q, VPX_BITS_8);\n      if (fabs(log2(prev_q_step)) > delta) {\n        const int actual_bits = rq_history->rate_history[recode_count - 1];\n        rq_model->ratio =\n            rq_model->ratio + (target_bits - actual_bits) / log2(prev_q_step);\n      }\n    }\n  }\n}\n#endif  // CONFIG_RATE_CTRL\n\nstatic void encode_with_recode_loop(VP9_COMP *cpi, size_t *size, uint8_t *dest\n#if CONFIG_RATE_CTRL\n                                    ,\n                                    RATE_QINDEX_HISTORY *rq_history\n#endif  // CONFIG_RATE_CTRL\n) {\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int bottom_index, top_index;\n  int loop_count = 0;\n  int loop_at_this_size = 0;\n  int loop = 0;\n  int overshoot_seen = 0;\n  int undershoot_seen = 0;\n  int frame_over_shoot_limit;\n  int frame_under_shoot_limit;\n  int q = 0, q_low = 0, q_high = 0;\n  int enable_acl;\n#ifdef AGGRESSIVE_VBR\n  int qrange_adj = 1;\n#endif\n\n  // A flag which indicates whether we are recoding the current frame\n  // when the current frame size is larger than the max frame size in the\n  // external rate control model.\n  // This flag doesn't have any impact when external rate control is not used.\n  int ext_rc_recode = 0;\n  // Maximal frame size allowed by the external rate control.\n  // case: 0, we ignore the max frame size limit, and encode with the qindex\n  // passed in by the external rate control model.\n  // If the external qindex is VPX_DEFAULT_Q, libvpx will pick a qindex\n  // and may recode if undershoot/overshoot is seen.\n  // If the external qindex is not VPX_DEFAULT_Q, we force no recode.\n  // case: -1, we take libvpx's decision for the max frame size, as well as\n  // the recode decision.\n  // Otherwise: if a specific size is given, libvpx's recode decision\n  // will respect the given size.\n  int ext_rc_max_frame_size = 0;\n  // Use VP9's decision of qindex. This flag is in use only in external rate\n  // control model to help determine whether to recode when\n  // |ext_rc_max_frame_size| is 0.\n  int ext_rc_use_default_q = 1;\n  const int orig_rc_max_frame_bandwidth = rc->max_frame_bandwidth;\n\n#if CONFIG_RATE_CTRL\n  RATE_QSTEP_MODEL *rq_model;\n  {\n    const FRAME_UPDATE_TYPE update_type =\n        cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index];\n    const ENCODE_FRAME_TYPE frame_type = get_encode_frame_type(update_type);\n    rq_model = &cpi->rq_model[frame_type];\n  }\n  init_rq_history(rq_history);\n#endif  // CONFIG_RATE_CTRL\n\n  if (cm->show_existing_frame) {\n    rc->this_frame_target = 0;\n    if (is_psnr_calc_enabled(cpi)) set_raw_source_frame(cpi);\n    return;\n  }\n\n  set_size_independent_vars(cpi);\n\n  enable_acl = cpi->sf.allow_acl ? (cm->frame_type == KEY_FRAME) ||\n                                       (cpi->twopass.gf_group.index == 1)\n                                 : 0;\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  printf(\"\\n Encoding a frame: \\n\");\n#endif\n  do {\n    vpx_clear_system_state();\n\n    set_frame_size(cpi);\n\n    if (loop_count == 0 || cpi->resize_pending != 0) {\n      set_size_dependent_vars(cpi, &q, &bottom_index, &top_index);\n\n#ifdef AGGRESSIVE_VBR\n      if (two_pass_first_group_inter(cpi)) {\n        // Adjustment limits for min and max q\n        qrange_adj = VPXMAX(1, (top_index - bottom_index) / 2);\n\n        bottom_index =\n            VPXMAX(bottom_index - qrange_adj / 2, oxcf->best_allowed_q);\n        top_index = VPXMIN(oxcf->worst_allowed_q, top_index + qrange_adj / 2);\n      }\n#endif\n      // TODO(agrange) Scale cpi->max_mv_magnitude if frame-size has changed.\n      set_mv_search_params(cpi);\n\n      // Reset the loop state for new frame size.\n      overshoot_seen = 0;\n      undershoot_seen = 0;\n\n      // Reconfiguration for change in frame size has concluded.\n      cpi->resize_pending = 0;\n\n      q_low = bottom_index;\n      q_high = top_index;\n\n      loop_at_this_size = 0;\n    }\n\n    // Decide frame size bounds first time through.\n    if (loop_count == 0) {\n      vp9_rc_compute_frame_size_bounds(cpi, rc->this_frame_target,\n                                       &frame_under_shoot_limit,\n                                       &frame_over_shoot_limit);\n    }\n\n    cpi->Source =\n        vp9_scale_if_required(cm, cpi->un_scaled_source, &cpi->scaled_source,\n                              (oxcf->pass == 0), EIGHTTAP, 0);\n\n    // Unfiltered raw source used in metrics calculation if the source\n    // has been filtered.\n    if (is_psnr_calc_enabled(cpi)) {\n#ifdef ENABLE_KF_DENOISE\n      if (is_spatial_denoise_enabled(cpi)) {\n        cpi->raw_source_frame = vp9_scale_if_required(\n            cm, &cpi->raw_unscaled_source, &cpi->raw_scaled_source,\n            (oxcf->pass == 0), EIGHTTAP, 0);\n      } else {\n        cpi->raw_source_frame = cpi->Source;\n      }\n#else\n      cpi->raw_source_frame = cpi->Source;\n#endif\n    }\n\n    if (cpi->unscaled_last_source != NULL)\n      cpi->Last_Source = vp9_scale_if_required(cm, cpi->unscaled_last_source,\n                                               &cpi->scaled_last_source,\n                                               (oxcf->pass == 0), EIGHTTAP, 0);\n\n    if (frame_is_intra_only(cm) == 0) {\n      if (loop_count > 0) {\n        release_scaled_references(cpi);\n      }\n      vp9_scale_references(cpi);\n    }\n\n#if CONFIG_RATE_CTRL\n    // TODO(angiebird): This is a hack for making sure the encoder use the\n    // external_quantize_index exactly. Avoid this kind of hack later.\n    if (cpi->oxcf.use_simple_encode_api) {\n      if (cpi->encode_command.use_external_target_frame_bits) {\n        q = rq_model_predict_q_index(rq_model, rq_history,\n                                     rc->this_frame_target);\n      }\n      if (cpi->encode_command.use_external_quantize_index) {\n        q = cpi->encode_command.external_quantize_index;\n      }\n    }\n#endif  // CONFIG_RATE_CTRL\n    if (cpi->ext_ratectrl.ready && !ext_rc_recode &&\n        (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_QP) != 0 &&\n        cpi->ext_ratectrl.funcs.get_encodeframe_decision != NULL) {\n      vpx_codec_err_t codec_status;\n      const GF_GROUP *gf_group = &cpi->twopass.gf_group;\n      vpx_rc_encodeframe_decision_t encode_frame_decision;\n      FRAME_UPDATE_TYPE update_type = gf_group->update_type[gf_group->index];\n      const int ref_frame_flags = get_ref_frame_flags(cpi);\n      RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];\n      const RefCntBuffer *curr_frame_buf =\n          get_ref_cnt_buffer(cm, cm->new_fb_idx);\n      // index 0 of a gf group is always KEY/OVERLAY/GOLDEN.\n      // index 1 refers to the first encoding frame in a gf group.\n      // Therefore if it is ARF_UPDATE, it means this gf group uses alt ref.\n      // See function define_gf_group_structure().\n      const int use_alt_ref = gf_group->update_type[1] == ARF_UPDATE;\n      get_ref_frame_bufs(cpi, ref_frame_bufs);\n      codec_status = vp9_extrc_get_encodeframe_decision(\n          &cpi->ext_ratectrl, curr_frame_buf->frame_index,\n          cm->current_frame_coding_index, gf_group->index, update_type,\n          gf_group->gf_group_size, use_alt_ref, ref_frame_bufs, ref_frame_flags,\n          &encode_frame_decision);\n      if (codec_status != VPX_CODEC_OK) {\n        vpx_internal_error(&cm->error, codec_status,\n                           \"vp9_extrc_get_encodeframe_decision() failed\");\n      }\n      // If the external model recommends a reserved value, we use\n      // libvpx's default q.\n      if (encode_frame_decision.q_index != VPX_DEFAULT_Q) {\n        q = encode_frame_decision.q_index;\n        ext_rc_use_default_q = 0;\n      }\n      ext_rc_max_frame_size = encode_frame_decision.max_frame_size;\n    }\n\n    vp9_set_quantizer(cpi, q);\n\n    if (loop_count == 0) setup_frame(cpi);\n\n    // Variance adaptive and in frame q adjustment experiments are mutually\n    // exclusive.\n    if (oxcf->aq_mode == VARIANCE_AQ) {\n      vp9_vaq_frame_setup(cpi);\n    } else if (oxcf->aq_mode == EQUATOR360_AQ) {\n      vp9_360aq_frame_setup(cpi);\n    } else if (oxcf->aq_mode == COMPLEXITY_AQ) {\n      vp9_setup_in_frame_q_adj(cpi);\n    } else if (oxcf->aq_mode == LOOKAHEAD_AQ) {\n      vp9_alt_ref_aq_setup_map(cpi->alt_ref_aq, cpi);\n    } else if (oxcf->aq_mode == PSNR_AQ) {\n      vp9_psnr_aq_mode_setup(&cm->seg);\n    }\n\n    vp9_encode_frame(cpi);\n\n    // Update the skip mb flag probabilities based on the distribution\n    // seen in the last encoder iteration.\n    // update_base_skip_probs(cpi);\n\n    vpx_clear_system_state();\n\n    // Dummy pack of the bitstream using up to date stats to get an\n    // accurate estimate of output frame size to determine if we need\n    // to recode.\n    if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF) {\n      save_coding_context(cpi);\n      if (!cpi->sf.use_nonrd_pick_mode) vp9_pack_bitstream(cpi, dest, size);\n\n      rc->projected_frame_size = (int)(*size) << 3;\n\n      if (frame_over_shoot_limit == 0) frame_over_shoot_limit = 1;\n    }\n\n    if (cpi->ext_ratectrl.ready &&\n        (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_QP) != 0) {\n      // In general, for the external rate control, we take the qindex provided\n      // as input and encode the frame with this qindex faithfully. However,\n      // in some extreme scenarios, the provided qindex leads to a massive\n      // overshoot of frame size. In this case, we fall back to VP9's decision\n      // to pick a new qindex and recode the frame. We return the new qindex\n      // through the API to the external model.\n      if (ext_rc_max_frame_size == 0) {\n        if (!ext_rc_use_default_q) break;\n      } else if (ext_rc_max_frame_size == -1) {\n        // Do nothing, fall back to libvpx's recode decision.\n      } else {\n        // Change the max frame size, used in libvpx's recode decision.\n        rc->max_frame_bandwidth = ext_rc_max_frame_size;\n      }\n      ext_rc_recode = 1;\n    }\n#if CONFIG_RATE_CTRL\n    if (cpi->oxcf.use_simple_encode_api) {\n      // This part needs to be after save_coding_context() because\n      // restore_coding_context will be called in the end of this function.\n      // TODO(angiebird): This is a hack for making sure the encoder use the\n      // external_quantize_index exactly. Avoid this kind of hack later.\n      if (cpi->encode_command.use_external_quantize_index) {\n        break;\n      }\n\n      if (cpi->encode_command.use_external_target_frame_bits) {\n        const double percent_diff = get_bits_percent_diff(\n            rc->this_frame_target, rc->projected_frame_size);\n        update_rq_history(rq_history, rc->this_frame_target,\n                          rc->projected_frame_size, q);\n        loop_count += 1;\n\n        rq_model_update(rq_history, rc->this_frame_target, rq_model);\n\n        // Check if we hit the target bitrate.\n        if (percent_diff <=\n                cpi->encode_command.target_frame_bits_error_percent ||\n            rq_history->recode_count >= RATE_CTRL_MAX_RECODE_NUM ||\n            rq_history->q_index_low >= rq_history->q_index_high) {\n          break;\n        }\n\n        loop = 1;\n        restore_coding_context(cpi);\n        continue;\n      }\n    }\n#endif  // CONFIG_RATE_CTRL\n\n    if (oxcf->rc_mode == VPX_Q) {\n      loop = 0;\n    } else {\n      if ((cm->frame_type == KEY_FRAME) && rc->this_key_frame_forced &&\n          (rc->projected_frame_size < rc->max_frame_bandwidth)) {\n        int last_q = q;\n        int64_t kf_err;\n\n        int64_t high_err_target = cpi->ambient_err;\n        int64_t low_err_target = cpi->ambient_err >> 1;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n        if (cm->use_highbitdepth) {\n          kf_err = vpx_highbd_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n        } else {\n          kf_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n        }\n#else\n        kf_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n        // Prevent possible divide by zero error below for perfect KF\n        kf_err += !kf_err;\n\n        // The key frame is not good enough or we can afford\n        // to make it better without undue risk of popping.\n        if ((kf_err > high_err_target &&\n             rc->projected_frame_size <= frame_over_shoot_limit) ||\n            (kf_err > low_err_target &&\n             rc->projected_frame_size <= frame_under_shoot_limit)) {\n          // Lower q_high\n          q_high = q > q_low ? q - 1 : q_low;\n\n          // Adjust Q\n          q = (int)((q * high_err_target) / kf_err);\n          q = VPXMIN(q, (q_high + q_low) >> 1);\n        } else if (kf_err < low_err_target &&\n                   rc->projected_frame_size >= frame_under_shoot_limit) {\n          // The key frame is much better than the previous frame\n          // Raise q_low\n          q_low = q < q_high ? q + 1 : q_high;\n\n          // Adjust Q\n          q = (int)((q * low_err_target) / kf_err);\n          q = VPXMIN(q, (q_high + q_low + 1) >> 1);\n        }\n\n        // Clamp Q to upper and lower limits:\n        q = clamp(q, q_low, q_high);\n\n        loop = q != last_q;\n      } else if (recode_loop_test(cpi, frame_over_shoot_limit,\n                                  frame_under_shoot_limit, q,\n                                  VPXMAX(q_high, top_index), bottom_index)) {\n        // Is the projected frame size out of range and are we allowed\n        // to attempt to recode.\n        int last_q = q;\n        int retries = 0;\n        int qstep;\n\n        if (cpi->resize_pending == 1) {\n          // Change in frame size so go back around the recode loop.\n          cpi->rc.frame_size_selector =\n              SCALE_STEP1 - cpi->rc.frame_size_selector;\n          cpi->rc.next_frame_size_selector = cpi->rc.frame_size_selector;\n\n#if CONFIG_INTERNAL_STATS\n          ++cpi->tot_recode_hits;\n#endif\n          ++loop_count;\n          loop = 1;\n          continue;\n        }\n\n        // Frame size out of permitted range:\n        // Update correction factor & compute new Q to try...\n\n        // Frame is too large\n        if (rc->projected_frame_size > rc->this_frame_target) {\n          // Special case if the projected size is > the max allowed.\n          if ((q == q_high) &&\n              ((rc->projected_frame_size >= rc->max_frame_bandwidth) ||\n               (!rc->is_src_frame_alt_ref &&\n                (rc->projected_frame_size >=\n                 big_rate_miss_high_threshold(cpi))))) {\n            int max_rate = VPXMAX(1, VPXMIN(rc->max_frame_bandwidth,\n                                            big_rate_miss_high_threshold(cpi)));\n            double q_val_high;\n            q_val_high = vp9_convert_qindex_to_q(q_high, cm->bit_depth);\n            q_val_high =\n                q_val_high * ((double)rc->projected_frame_size / max_rate);\n            q_high = vp9_convert_q_to_qindex(q_val_high, cm->bit_depth);\n            q_high = clamp(q_high, rc->best_quality, rc->worst_quality);\n          }\n\n          // Raise Qlow as to at least the current value\n          qstep =\n              get_qstep_adj(rc->projected_frame_size, rc->this_frame_target);\n          q_low = VPXMIN(q + qstep, q_high);\n\n          if (undershoot_seen || loop_at_this_size > 1) {\n            // Update rate_correction_factor unless\n            vp9_rc_update_rate_correction_factors(cpi);\n\n            q = (q_high + q_low + 1) / 2;\n          } else {\n            // Update rate_correction_factor unless\n            vp9_rc_update_rate_correction_factors(cpi);\n\n            q = vp9_rc_regulate_q(cpi, rc->this_frame_target, bottom_index,\n                                  VPXMAX(q_high, top_index));\n\n            while (q < q_low && retries < 10) {\n              vp9_rc_update_rate_correction_factors(cpi);\n              q = vp9_rc_regulate_q(cpi, rc->this_frame_target, bottom_index,\n                                    VPXMAX(q_high, top_index));\n              retries++;\n            }\n          }\n\n          overshoot_seen = 1;\n        } else {\n          // Frame is too small\n          qstep =\n              get_qstep_adj(rc->this_frame_target, rc->projected_frame_size);\n          q_high = VPXMAX(q - qstep, q_low);\n\n          if (overshoot_seen || loop_at_this_size > 1) {\n            vp9_rc_update_rate_correction_factors(cpi);\n            q = (q_high + q_low) / 2;\n          } else {\n            vp9_rc_update_rate_correction_factors(cpi);\n            q = vp9_rc_regulate_q(cpi, rc->this_frame_target,\n                                  VPXMIN(q_low, bottom_index), top_index);\n            // Special case reset for qlow for constrained quality.\n            // This should only trigger where there is very substantial\n            // undershoot on a frame and the auto cq level is above\n            // the user passed in value.\n            if (oxcf->rc_mode == VPX_CQ && q < q_low) {\n              q_low = q;\n            }\n\n            while (q > q_high && retries < 10) {\n              vp9_rc_update_rate_correction_factors(cpi);\n              q = vp9_rc_regulate_q(cpi, rc->this_frame_target,\n                                    VPXMIN(q_low, bottom_index), top_index);\n              retries++;\n            }\n          }\n          undershoot_seen = 1;\n        }\n\n        // Clamp Q to upper and lower limits:\n        q = clamp(q, q_low, q_high);\n\n        loop = (q != last_q);\n      } else {\n        loop = 0;\n      }\n    }\n\n    // Special case for overlay frame.\n    if (rc->is_src_frame_alt_ref &&\n        rc->projected_frame_size < rc->max_frame_bandwidth)\n      loop = 0;\n\n    if (loop) {\n      ++loop_count;\n      ++loop_at_this_size;\n\n#if CONFIG_INTERNAL_STATS\n      ++cpi->tot_recode_hits;\n#endif\n    }\n\n    if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF)\n      if (loop) restore_coding_context(cpi);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    if (loop) printf(\"\\n Recoding:\");\n#endif\n  } while (loop);\n\n  rc->max_frame_bandwidth = orig_rc_max_frame_bandwidth;\n\n#ifdef AGGRESSIVE_VBR\n  if (two_pass_first_group_inter(cpi)) {\n    cpi->twopass.active_worst_quality =\n        VPXMIN(q + qrange_adj, oxcf->worst_allowed_q);\n  } else if (!frame_is_kf_gf_arf(cpi)) {\n#else\n  if (!frame_is_kf_gf_arf(cpi)) {\n#endif\n    // Have we been forced to adapt Q outside the expected range by an extreme\n    // rate miss. If so adjust the active maxQ for the subsequent frames.\n    if (!rc->is_src_frame_alt_ref && (q > cpi->twopass.active_worst_quality)) {\n      cpi->twopass.active_worst_quality = q;\n    } else if (oxcf->vbr_corpus_complexity && q == q_low &&\n               rc->projected_frame_size < rc->this_frame_target) {\n      cpi->twopass.active_worst_quality =\n          VPXMAX(q, cpi->twopass.active_worst_quality - 1);\n    }\n  }\n\n  if (enable_acl) {\n    // Skip recoding, if model diff is below threshold\n    const int thresh = compute_context_model_thresh(cpi);\n    const int diff = compute_context_model_diff(cm);\n    if (diff >= thresh) {\n      vp9_encode_frame(cpi);\n    }\n  }\n  if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF) {\n    vpx_clear_system_state();\n    restore_coding_context(cpi);\n  }\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void set_ext_overrides(VP9_COMP *cpi) {\n  // Overrides the defaults with the externally supplied values with\n  // vp9_update_reference() and vp9_update_entropy() calls\n  // Note: The overrides are valid only for the next frame passed\n  // to encode_frame_to_data_rate() function\n  if (cpi->ext_refresh_frame_context_pending) {\n    cpi->common.refresh_frame_context = cpi->ext_refresh_frame_context;\n    cpi->ext_refresh_frame_context_pending = 0;\n  }\n  if (cpi->ext_refresh_frame_flags_pending) {\n    cpi->refresh_last_frame = cpi->ext_refresh_last_frame;\n    cpi->refresh_golden_frame = cpi->ext_refresh_golden_frame;\n    cpi->refresh_alt_ref_frame = cpi->ext_refresh_alt_ref_frame;\n  }\n}\n\nYV12_BUFFER_CONFIG *vp9_svc_twostage_scale(\n    VP9_COMMON *cm, YV12_BUFFER_CONFIG *unscaled, YV12_BUFFER_CONFIG *scaled,\n    YV12_BUFFER_CONFIG *scaled_temp, INTERP_FILTER filter_type,\n    int phase_scaler, INTERP_FILTER filter_type2, int phase_scaler2) {\n  if (cm->mi_cols * MI_SIZE != unscaled->y_width ||\n      cm->mi_rows * MI_SIZE != unscaled->y_height) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (cm->bit_depth == VPX_BITS_8) {\n      vp9_scale_and_extend_frame(unscaled, scaled_temp, filter_type2,\n                                 phase_scaler2);\n      vp9_scale_and_extend_frame(scaled_temp, scaled, filter_type,\n                                 phase_scaler);\n    } else {\n      scale_and_extend_frame(unscaled, scaled_temp, (int)cm->bit_depth,\n                             filter_type2, phase_scaler2);\n      scale_and_extend_frame(scaled_temp, scaled, (int)cm->bit_depth,\n                             filter_type, phase_scaler);\n    }\n#else\n    vp9_scale_and_extend_frame(unscaled, scaled_temp, filter_type2,\n                               phase_scaler2);\n    vp9_scale_and_extend_frame(scaled_temp, scaled, filter_type, phase_scaler);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    return scaled;\n  } else {\n    return unscaled;\n  }\n}\n\nYV12_BUFFER_CONFIG *vp9_scale_if_required(\n    VP9_COMMON *cm, YV12_BUFFER_CONFIG *unscaled, YV12_BUFFER_CONFIG *scaled,\n    int use_normative_scaler, INTERP_FILTER filter_type, int phase_scaler) {\n  if (cm->mi_cols * MI_SIZE != unscaled->y_width ||\n      cm->mi_rows * MI_SIZE != unscaled->y_height) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (use_normative_scaler && unscaled->y_width <= (scaled->y_width << 1) &&\n        unscaled->y_height <= (scaled->y_height << 1))\n      if (cm->bit_depth == VPX_BITS_8)\n        vp9_scale_and_extend_frame(unscaled, scaled, filter_type, phase_scaler);\n      else\n        scale_and_extend_frame(unscaled, scaled, (int)cm->bit_depth,\n                               filter_type, phase_scaler);\n    else\n      scale_and_extend_frame_nonnormative(unscaled, scaled, (int)cm->bit_depth);\n#else\n    if (use_normative_scaler && unscaled->y_width <= (scaled->y_width << 1) &&\n        unscaled->y_height <= (scaled->y_height << 1))\n      vp9_scale_and_extend_frame(unscaled, scaled, filter_type, phase_scaler);\n    else\n      scale_and_extend_frame_nonnormative(unscaled, scaled);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    return scaled;\n  } else {\n    return unscaled;\n  }\n}\n\nstatic void set_ref_sign_bias(VP9_COMP *cpi) {\n  VP9_COMMON *const cm = &cpi->common;\n  RefCntBuffer *const ref_buffer = get_ref_cnt_buffer(cm, cm->new_fb_idx);\n  const int cur_frame_index = ref_buffer->frame_index;\n  MV_REFERENCE_FRAME ref_frame;\n\n  for (ref_frame = LAST_FRAME; ref_frame < MAX_REF_FRAMES; ++ref_frame) {\n    const int buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);\n    const RefCntBuffer *const ref_cnt_buf =\n        get_ref_cnt_buffer(&cpi->common, buf_idx);\n    if (ref_cnt_buf) {\n      cm->ref_frame_sign_bias[ref_frame] =\n          cur_frame_index < ref_cnt_buf->frame_index;\n    }\n  }\n}\n\nstatic int setup_interp_filter_search_mask(VP9_COMP *cpi) {\n  INTERP_FILTER ifilter;\n  int ref_total[MAX_REF_FRAMES] = { 0 };\n  MV_REFERENCE_FRAME ref;\n  int mask = 0;\n  if (cpi->common.last_frame_type == KEY_FRAME || cpi->refresh_alt_ref_frame)\n    return mask;\n  for (ref = LAST_FRAME; ref <= ALTREF_FRAME; ++ref)\n    for (ifilter = EIGHTTAP; ifilter <= EIGHTTAP_SHARP; ++ifilter)\n      ref_total[ref] += cpi->interp_filter_selected[ref][ifilter];\n\n  for (ifilter = EIGHTTAP; ifilter <= EIGHTTAP_SHARP; ++ifilter) {\n    if ((ref_total[LAST_FRAME] &&\n         cpi->interp_filter_selected[LAST_FRAME][ifilter] == 0) &&\n        (ref_total[GOLDEN_FRAME] == 0 ||\n         cpi->interp_filter_selected[GOLDEN_FRAME][ifilter] * 50 <\n             ref_total[GOLDEN_FRAME]) &&\n        (ref_total[ALTREF_FRAME] == 0 ||\n         cpi->interp_filter_selected[ALTREF_FRAME][ifilter] * 50 <\n             ref_total[ALTREF_FRAME]))\n      mask |= 1 << ifilter;\n  }\n  return mask;\n}\n\n#ifdef ENABLE_KF_DENOISE\n// Baseline kernel weights for denoise\nstatic uint8_t dn_kernel_3[9] = { 1, 2, 1, 2, 4, 2, 1, 2, 1 };\nstatic uint8_t dn_kernel_5[25] = { 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 4,\n                                   2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1 };\n\nstatic INLINE void add_denoise_point(int centre_val, int data_val, int thresh,\n                                     uint8_t point_weight, int *sum_val,\n                                     int *sum_weight) {\n  if (abs(centre_val - data_val) <= thresh) {\n    *sum_weight += point_weight;\n    *sum_val += (int)data_val * (int)point_weight;\n  }\n}\n\nstatic void spatial_denoise_point(uint8_t *src_ptr, const int stride,\n                                  const int strength) {\n  int sum_weight = 0;\n  int sum_val = 0;\n  int thresh = strength;\n  int kernel_size = 5;\n  int half_k_size = 2;\n  int i, j;\n  int max_diff = 0;\n  uint8_t *tmp_ptr;\n  uint8_t *kernel_ptr;\n\n  // Find the maximum deviation from the source point in the locale.\n  tmp_ptr = src_ptr - (stride * (half_k_size + 1)) - (half_k_size + 1);\n  for (i = 0; i < kernel_size + 2; ++i) {\n    for (j = 0; j < kernel_size + 2; ++j) {\n      max_diff = VPXMAX(max_diff, abs((int)*src_ptr - (int)tmp_ptr[j]));\n    }\n    tmp_ptr += stride;\n  }\n\n  // Select the kernel size.\n  if (max_diff > (strength + (strength >> 1))) {\n    kernel_size = 3;\n    half_k_size = 1;\n    thresh = thresh >> 1;\n  }\n  kernel_ptr = (kernel_size == 3) ? dn_kernel_3 : dn_kernel_5;\n\n  // Apply the kernel\n  tmp_ptr = src_ptr - (stride * half_k_size) - half_k_size;\n  for (i = 0; i < kernel_size; ++i) {\n    for (j = 0; j < kernel_size; ++j) {\n      add_denoise_point((int)*src_ptr, (int)tmp_ptr[j], thresh, *kernel_ptr,\n                        &sum_val, &sum_weight);\n      ++kernel_ptr;\n    }\n    tmp_ptr += stride;\n  }\n\n  // Update the source value with the new filtered value\n  *src_ptr = (uint8_t)((sum_val + (sum_weight >> 1)) / sum_weight);\n}\n\n#if CONFIG_VP9_HIGHBITDEPTH\nstatic void highbd_spatial_denoise_point(uint16_t *src_ptr, const int stride,\n                                         const int strength) {\n  int sum_weight = 0;\n  int sum_val = 0;\n  int thresh = strength;\n  int kernel_size = 5;\n  int half_k_size = 2;\n  int i, j;\n  int max_diff = 0;\n  uint16_t *tmp_ptr;\n  uint8_t *kernel_ptr;\n\n  // Find the maximum deviation from the source point in the locale.\n  tmp_ptr = src_ptr - (stride * (half_k_size + 1)) - (half_k_size + 1);\n  for (i = 0; i < kernel_size + 2; ++i) {\n    for (j = 0; j < kernel_size + 2; ++j) {\n      max_diff = VPXMAX(max_diff, abs((int)src_ptr - (int)tmp_ptr[j]));\n    }\n    tmp_ptr += stride;\n  }\n\n  // Select the kernel size.\n  if (max_diff > (strength + (strength >> 1))) {\n    kernel_size = 3;\n    half_k_size = 1;\n    thresh = thresh >> 1;\n  }\n  kernel_ptr = (kernel_size == 3) ? dn_kernel_3 : dn_kernel_5;\n\n  // Apply the kernel\n  tmp_ptr = src_ptr - (stride * half_k_size) - half_k_size;\n  for (i = 0; i < kernel_size; ++i) {\n    for (j = 0; j < kernel_size; ++j) {\n      add_denoise_point((int)*src_ptr, (int)tmp_ptr[j], thresh, *kernel_ptr,\n                        &sum_val, &sum_weight);\n      ++kernel_ptr;\n    }\n    tmp_ptr += stride;\n  }\n\n  // Update the source value with the new filtered value\n  *src_ptr = (uint16_t)((sum_val + (sum_weight >> 1)) / sum_weight);\n}\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n// Apply thresholded spatial noise suppression to a given buffer.\nstatic void spatial_denoise_buffer(VP9_COMP *cpi, uint8_t *buffer,\n                                   const int stride, const int width,\n                                   const int height, const int strength) {\n  VP9_COMMON *const cm = &cpi->common;\n  uint8_t *src_ptr = buffer;\n  int row;\n  int col;\n\n  for (row = 0; row < height; ++row) {\n    for (col = 0; col < width; ++col) {\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (cm->use_highbitdepth)\n        highbd_spatial_denoise_point(CONVERT_TO_SHORTPTR(&src_ptr[col]), stride,\n                                     strength);\n      else\n        spatial_denoise_point(&src_ptr[col], stride, strength);\n#else\n      spatial_denoise_point(&src_ptr[col], stride, strength);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    }\n    src_ptr += stride;\n  }\n}\n\n// Apply thresholded spatial noise suppression to source.\nstatic void spatial_denoise_frame(VP9_COMP *cpi) {\n  YV12_BUFFER_CONFIG *src = cpi->Source;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  TWO_PASS *const twopass = &cpi->twopass;\n  VP9_COMMON *const cm = &cpi->common;\n\n  // Base the filter strength on the current active max Q.\n  const int q = (int)(vp9_convert_qindex_to_q(twopass->active_worst_quality,\n                                              cm->bit_depth));\n  int strength =\n      VPXMAX(oxcf->arnr_strength >> 2, VPXMIN(oxcf->arnr_strength, (q >> 4)));\n\n  // Denoise each of Y,U and V buffers.\n  spatial_denoise_buffer(cpi, src->y_buffer, src->y_stride, src->y_width,\n                         src->y_height, strength);\n\n  strength += (strength >> 1);\n  spatial_denoise_buffer(cpi, src->u_buffer, src->uv_stride, src->uv_width,\n                         src->uv_height, strength << 1);\n\n  spatial_denoise_buffer(cpi, src->v_buffer, src->uv_stride, src->uv_width,\n                         src->uv_height, strength << 1);\n}\n#endif  // ENABLE_KF_DENOISE\n\n#if !CONFIG_REALTIME_ONLY\nstatic void vp9_try_disable_lookahead_aq(VP9_COMP *cpi, size_t *size,\n                                         uint8_t *dest) {\n  if (cpi->common.seg.enabled)\n    if (ALT_REF_AQ_PROTECT_GAIN) {\n      size_t nsize = *size;\n      int overhead;\n\n      // TODO(yuryg): optimize this, as\n      // we don't really need to repack\n\n      save_coding_context(cpi);\n      vp9_disable_segmentation(&cpi->common.seg);\n      vp9_pack_bitstream(cpi, dest, &nsize);\n      restore_coding_context(cpi);\n\n      overhead = (int)*size - (int)nsize;\n\n      if (vp9_alt_ref_aq_disable_if(cpi->alt_ref_aq, overhead, (int)*size))\n        vp9_encode_frame(cpi);\n      else\n        vp9_enable_segmentation(&cpi->common.seg);\n    }\n}\n#endif\n\nstatic void set_frame_index(VP9_COMP *cpi, VP9_COMMON *cm) {\n  RefCntBuffer *const ref_buffer = get_ref_cnt_buffer(cm, cm->new_fb_idx);\n\n  if (ref_buffer) {\n    const GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n    ref_buffer->frame_index =\n        cm->current_video_frame + gf_group->arf_src_offset[gf_group->index];\n    ref_buffer->frame_coding_index = cm->current_frame_coding_index;\n  }\n}\n\nstatic void set_mb_ssim_rdmult_scaling(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  ThreadData *td = &cpi->td;\n  MACROBLOCK *x = &td->mb;\n  MACROBLOCKD *xd = &x->e_mbd;\n  uint8_t *y_buffer = cpi->Source->y_buffer;\n  const int y_stride = cpi->Source->y_stride;\n  const int block_size = BLOCK_16X16;\n\n  const int num_8x8_w = num_8x8_blocks_wide_lookup[block_size];\n  const int num_8x8_h = num_8x8_blocks_high_lookup[block_size];\n  const int num_cols = (cm->mi_cols + num_8x8_w - 1) / num_8x8_w;\n  const int num_rows = (cm->mi_rows + num_8x8_h - 1) / num_8x8_h;\n  double log_sum = 0.0;\n  int row, col;\n\n  // Loop through each 64x64 block.\n  for (row = 0; row < num_rows; ++row) {\n    for (col = 0; col < num_cols; ++col) {\n      int mi_row, mi_col;\n      double var = 0.0, num_of_var = 0.0;\n      const int index = row * num_cols + col;\n\n      for (mi_row = row * num_8x8_h;\n           mi_row < cm->mi_rows && mi_row < (row + 1) * num_8x8_h; ++mi_row) {\n        for (mi_col = col * num_8x8_w;\n             mi_col < cm->mi_cols && mi_col < (col + 1) * num_8x8_w; ++mi_col) {\n          struct buf_2d buf;\n          const int row_offset_y = mi_row << 3;\n          const int col_offset_y = mi_col << 3;\n\n          buf.buf = y_buffer + row_offset_y * y_stride + col_offset_y;\n          buf.stride = y_stride;\n\n          // In order to make SSIM_VAR_SCALE in a same scale for both 8 bit\n          // and high bit videos, the variance needs to be divided by 2.0 or\n          // 64.0 separately.\n          // TODO(sdeng): need to tune for 12bit videos.\n#if CONFIG_VP9_HIGHBITDEPTH\n          if (cpi->Source->flags & YV12_FLAG_HIGHBITDEPTH)\n            var += vp9_high_get_sby_variance(cpi, &buf, BLOCK_8X8, xd->bd);\n          else\n#endif\n            var += vp9_get_sby_variance(cpi, &buf, BLOCK_8X8);\n\n          num_of_var += 1.0;\n        }\n      }\n      var = var / num_of_var / 64.0;\n\n      // Curve fitting with an exponential model on all 16x16 blocks from the\n      // Midres dataset.\n      var = 67.035434 * (1 - exp(-0.0021489 * var)) + 17.492222;\n      cpi->mi_ssim_rdmult_scaling_factors[index] = var;\n      log_sum += log(var);\n    }\n  }\n  log_sum = exp(log_sum / (double)(num_rows * num_cols));\n\n  for (row = 0; row < num_rows; ++row) {\n    for (col = 0; col < num_cols; ++col) {\n      const int index = row * num_cols + col;\n      cpi->mi_ssim_rdmult_scaling_factors[index] /= log_sum;\n    }\n  }\n\n  (void)xd;\n}\n\n// Process the wiener variance in 16x16 block basis.\nstatic int qsort_comp(const void *elem1, const void *elem2) {\n  int a = *((const int *)elem1);\n  int b = *((const int *)elem2);\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return 0;\n}\n\nstatic void init_mb_wiener_var_buffer(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n\n  if (cpi->mb_wiener_variance && cpi->mb_wiener_var_rows >= cm->mb_rows &&\n      cpi->mb_wiener_var_cols >= cm->mb_cols)\n    return;\n\n  vpx_free(cpi->mb_wiener_variance);\n  cpi->mb_wiener_variance = NULL;\n\n  CHECK_MEM_ERROR(\n      &cm->error, cpi->mb_wiener_variance,\n      vpx_calloc(cm->mb_rows * cm->mb_cols, sizeof(*cpi->mb_wiener_variance)));\n  cpi->mb_wiener_var_rows = cm->mb_rows;\n  cpi->mb_wiener_var_cols = cm->mb_cols;\n}\n\nstatic void set_mb_wiener_variance(VP9_COMP *cpi) {\n  VP9_COMMON *cm = &cpi->common;\n  uint8_t *buffer = cpi->Source->y_buffer;\n  int buf_stride = cpi->Source->y_stride;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  ThreadData *td = &cpi->td;\n  MACROBLOCK *x = &td->mb;\n  MACROBLOCKD *xd = &x->e_mbd;\n  DECLARE_ALIGNED(16, uint16_t, zero_pred16[32 * 32]);\n  DECLARE_ALIGNED(16, uint8_t, zero_pred8[32 * 32]);\n  uint8_t *zero_pred;\n#else\n  DECLARE_ALIGNED(16, uint8_t, zero_pred[32 * 32]);\n#endif\n\n  DECLARE_ALIGNED(16, int16_t, src_diff[32 * 32]);\n  DECLARE_ALIGNED(16, tran_low_t, coeff[32 * 32]);\n\n  int mb_row, mb_col, count = 0;\n  // Hard coded operating block size\n  const int block_size = 16;\n  const int coeff_count = block_size * block_size;\n  const TX_SIZE tx_size = TX_16X16;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  xd->cur_buf = cpi->Source;\n  if (xd->cur_buf->flags & YV12_FLAG_HIGHBITDEPTH) {\n    zero_pred = CONVERT_TO_BYTEPTR(zero_pred16);\n    memset(zero_pred16, 0, sizeof(*zero_pred16) * coeff_count);\n  } else {\n    zero_pred = zero_pred8;\n    memset(zero_pred8, 0, sizeof(*zero_pred8) * coeff_count);\n  }\n#else\n  memset(zero_pred, 0, sizeof(*zero_pred) * coeff_count);\n#endif\n\n  cpi->norm_wiener_variance = 0;\n\n  for (mb_row = 0; mb_row < cm->mb_rows; ++mb_row) {\n    for (mb_col = 0; mb_col < cm->mb_cols; ++mb_col) {\n      int idx;\n      int16_t median_val = 0;\n      uint8_t *mb_buffer =\n          buffer + mb_row * block_size * buf_stride + mb_col * block_size;\n      int64_t wiener_variance = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (xd->cur_buf->flags & YV12_FLAG_HIGHBITDEPTH) {\n        vpx_highbd_subtract_block(block_size, block_size, src_diff, block_size,\n                                  mb_buffer, buf_stride, zero_pred, block_size,\n                                  xd->bd);\n        vp9_highbd_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);\n      } else {\n        vpx_subtract_block(block_size, block_size, src_diff, block_size,\n                           mb_buffer, buf_stride, zero_pred, block_size);\n        vp9_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);\n      }\n#else\n      vpx_subtract_block(block_size, block_size, src_diff, block_size,\n                         mb_buffer, buf_stride, zero_pred, block_size);\n      vp9_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n      coeff[0] = 0;\n      for (idx = 1; idx < coeff_count; ++idx) coeff[idx] = abs(coeff[idx]);\n\n      qsort(coeff, coeff_count - 1, sizeof(*coeff), qsort_comp);\n\n      // Noise level estimation\n      median_val = coeff[coeff_count / 2];\n\n      // Wiener filter\n      for (idx = 1; idx < coeff_count; ++idx) {\n        int64_t sqr_coeff = (int64_t)coeff[idx] * coeff[idx];\n        int64_t tmp_coeff = (int64_t)coeff[idx];\n        if (median_val) {\n          tmp_coeff = (sqr_coeff * coeff[idx]) /\n                      (sqr_coeff + (int64_t)median_val * median_val);\n        }\n        wiener_variance += tmp_coeff * tmp_coeff;\n      }\n      cpi->mb_wiener_variance[mb_row * cm->mb_cols + mb_col] =\n          wiener_variance / coeff_count;\n      cpi->norm_wiener_variance +=\n          cpi->mb_wiener_variance[mb_row * cm->mb_cols + mb_col];\n      ++count;\n    }\n  }\n\n  if (count) cpi->norm_wiener_variance /= count;\n  cpi->norm_wiener_variance = VPXMAX(1, cpi->norm_wiener_variance);\n}\n\n#if !CONFIG_REALTIME_ONLY\nstatic void update_encode_frame_result_basic(\n    FRAME_UPDATE_TYPE update_type, int show_idx, int quantize_index,\n    ENCODE_FRAME_RESULT *encode_frame_result) {\n  encode_frame_result->show_idx = show_idx;\n  encode_frame_result->update_type = update_type;\n  encode_frame_result->quantize_index = quantize_index;\n}\n\n#if CONFIG_RATE_CTRL\nstatic void yv12_buffer_to_image_buffer(const YV12_BUFFER_CONFIG *yv12_buffer,\n                                        IMAGE_BUFFER *image_buffer) {\n  const uint8_t *src_buf_ls[3] = { yv12_buffer->y_buffer, yv12_buffer->u_buffer,\n                                   yv12_buffer->v_buffer };\n  const int src_stride_ls[3] = { yv12_buffer->y_stride, yv12_buffer->uv_stride,\n                                 yv12_buffer->uv_stride };\n  const int w_ls[3] = { yv12_buffer->y_crop_width, yv12_buffer->uv_crop_width,\n                        yv12_buffer->uv_crop_width };\n  const int h_ls[3] = { yv12_buffer->y_crop_height, yv12_buffer->uv_crop_height,\n                        yv12_buffer->uv_crop_height };\n  int plane;\n  for (plane = 0; plane < 3; ++plane) {\n    const int src_stride = src_stride_ls[plane];\n    const int w = w_ls[plane];\n    const int h = h_ls[plane];\n    const uint8_t *src_buf = src_buf_ls[plane];\n    uint8_t *dst_buf = image_buffer->plane_buffer[plane];\n    int r;\n    assert(image_buffer->plane_width[plane] == w);\n    assert(image_buffer->plane_height[plane] == h);\n    for (r = 0; r < h; ++r) {\n      memcpy(dst_buf, src_buf, sizeof(*src_buf) * w);\n      src_buf += src_stride;\n      dst_buf += w;\n    }\n  }\n}\n// This function will update extra information specific for simple_encode APIs\nstatic void update_encode_frame_result_simple_encode(\n    int ref_frame_flags, FRAME_UPDATE_TYPE update_type,\n    const YV12_BUFFER_CONFIG *source_frame, const RefCntBuffer *coded_frame_buf,\n    RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES], int quantize_index,\n    uint32_t bit_depth, uint32_t input_bit_depth, const FRAME_COUNTS *counts,\n    const PARTITION_INFO *partition_info,\n    const MOTION_VECTOR_INFO *motion_vector_info,\n    const TplDepStats *tpl_stats_info,\n    ENCODE_FRAME_RESULT *encode_frame_result) {\n  PSNR_STATS psnr;\n  update_encode_frame_result_basic(update_type, coded_frame_buf->frame_index,\n                                   quantize_index, encode_frame_result);\n#if CONFIG_VP9_HIGHBITDEPTH\n  vpx_calc_highbd_psnr(source_frame, &coded_frame_buf->buf, &psnr, bit_depth,\n                       input_bit_depth);\n#else   // CONFIG_VP9_HIGHBITDEPTH\n  (void)bit_depth;\n  (void)input_bit_depth;\n  vpx_calc_psnr(source_frame, &coded_frame_buf->buf, &psnr);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  encode_frame_result->frame_coding_index = coded_frame_buf->frame_coding_index;\n\n  vp9_get_ref_frame_info(update_type, ref_frame_flags, ref_frame_bufs,\n                         encode_frame_result->ref_frame_coding_indexes,\n                         encode_frame_result->ref_frame_valid_list);\n\n  encode_frame_result->psnr = psnr.psnr[0];\n  encode_frame_result->sse = psnr.sse[0];\n  encode_frame_result->frame_counts = *counts;\n  encode_frame_result->partition_info = partition_info;\n  encode_frame_result->motion_vector_info = motion_vector_info;\n  encode_frame_result->tpl_stats_info = tpl_stats_info;\n  if (encode_frame_result->coded_frame.allocated) {\n    yv12_buffer_to_image_buffer(&coded_frame_buf->buf,\n                                &encode_frame_result->coded_frame);\n  }\n}\n#endif  // CONFIG_RATE_CTRL\n#endif  // !CONFIG_REALTIME_ONLY\n\nstatic void encode_frame_to_data_rate(\n    VP9_COMP *cpi, size_t *size, uint8_t *dest, unsigned int *frame_flags,\n    ENCODE_FRAME_RESULT *encode_frame_result) {\n  VP9_COMMON *const cm = &cpi->common;\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  struct segmentation *const seg = &cm->seg;\n  TX_SIZE t;\n\n  // SVC: skip encoding of enhancement layer if the layer target bandwidth = 0.\n  // No need to set svc.skip_enhancement_layer if whole superframe will be\n  // dropped.\n  if (cpi->use_svc && cpi->svc.spatial_layer_id > 0 &&\n      cpi->oxcf.target_bandwidth == 0 &&\n      !(cpi->svc.framedrop_mode != LAYER_DROP &&\n        (cpi->svc.framedrop_mode != CONSTRAINED_FROM_ABOVE_DROP ||\n         cpi->svc\n             .force_drop_constrained_from_above[cpi->svc.number_spatial_layers -\n                                                1]) &&\n        cpi->svc.drop_spatial_layer[0])) {\n    cpi->svc.skip_enhancement_layer = 1;\n    vp9_rc_postencode_update_drop_frame(cpi);\n    cpi->ext_refresh_frame_flags_pending = 0;\n    cpi->last_frame_dropped = 1;\n    cpi->svc.last_layer_dropped[cpi->svc.spatial_layer_id] = 1;\n    cpi->svc.drop_spatial_layer[cpi->svc.spatial_layer_id] = 1;\n    vp9_inc_frame_in_layer(cpi);\n    return;\n  }\n\n  set_ext_overrides(cpi);\n  vpx_clear_system_state();\n\n#ifdef ENABLE_KF_DENOISE\n  // Spatial denoise of key frame.\n  if (is_spatial_denoise_enabled(cpi)) spatial_denoise_frame(cpi);\n#endif\n\n  if (cm->show_existing_frame == 0) {\n    // Update frame index\n    set_frame_index(cpi, cm);\n\n    // Set the arf sign bias for this frame.\n    set_ref_sign_bias(cpi);\n  }\n\n  // Set default state for segment based loop filter update flags.\n  cm->lf.mode_ref_delta_update = 0;\n\n  if (cpi->oxcf.pass == 2 && cpi->sf.adaptive_interp_filter_search)\n    cpi->sf.interp_filter_search_mask = setup_interp_filter_search_mask(cpi);\n\n  // Set various flags etc to special state if it is a key frame.\n  if (frame_is_intra_only(cm)) {\n    // Reset the loop filter deltas and segmentation map.\n    vp9_reset_segment_features(&cm->seg);\n\n    // If segmentation is enabled force a map update for key frames.\n    if (seg->enabled) {\n      seg->update_map = 1;\n      seg->update_data = 1;\n    }\n\n    // The alternate reference frame cannot be active for a key frame.\n    cpi->rc.source_alt_ref_active = 0;\n\n    cm->error_resilient_mode = oxcf->error_resilient_mode;\n    cm->frame_parallel_decoding_mode = oxcf->frame_parallel_decoding_mode;\n\n    // By default, encoder assumes decoder can use prev_mi.\n    if (cm->error_resilient_mode) {\n      cm->frame_parallel_decoding_mode = 1;\n      cm->reset_frame_context = 0;\n      cm->refresh_frame_context = 0;\n    } else if (cm->intra_only) {\n      // Only reset the current context.\n      cm->reset_frame_context = 2;\n    }\n  }\n\n  if (oxcf->tuning == VP8_TUNE_SSIM) set_mb_ssim_rdmult_scaling(cpi);\n\n  if (oxcf->aq_mode == PERCEPTUAL_AQ) {\n    init_mb_wiener_var_buffer(cpi);\n    set_mb_wiener_variance(cpi);\n  }\n\n  vpx_clear_system_state();\n\n#if CONFIG_INTERNAL_STATS\n  memset(cpi->mode_chosen_counts, 0,\n         MAX_MODES * sizeof(*cpi->mode_chosen_counts));\n#endif\n  // Backup to ensure consistency between recodes\n  save_encode_params(cpi);\n  if (cpi->ext_ratectrl.ready &&\n      (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_RDMULT) != 0 &&\n      cpi->ext_ratectrl.funcs.get_frame_rdmult != NULL) {\n    vpx_codec_err_t codec_status;\n    const GF_GROUP *gf_group = &cpi->twopass.gf_group;\n    FRAME_UPDATE_TYPE update_type = gf_group->update_type[gf_group->index];\n    const int ref_frame_flags = get_ref_frame_flags(cpi);\n    RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];\n    const RefCntBuffer *curr_frame_buf = get_ref_cnt_buffer(cm, cm->new_fb_idx);\n    // index 0 of a gf group is always KEY/OVERLAY/GOLDEN.\n    // index 1 refers to the first encoding frame in a gf group.\n    // Therefore if it is ARF_UPDATE, it means this gf group uses alt ref.\n    // See function define_gf_group_structure().\n    const int use_alt_ref = gf_group->update_type[1] == ARF_UPDATE;\n    int ext_rdmult = VPX_DEFAULT_RDMULT;\n    get_ref_frame_bufs(cpi, ref_frame_bufs);\n    codec_status = vp9_extrc_get_frame_rdmult(\n        &cpi->ext_ratectrl, curr_frame_buf->frame_index,\n        cm->current_frame_coding_index, gf_group->index, update_type,\n        gf_group->gf_group_size, use_alt_ref, ref_frame_bufs, ref_frame_flags,\n        &ext_rdmult);\n    if (codec_status != VPX_CODEC_OK) {\n      vpx_internal_error(&cm->error, codec_status,\n                         \"vp9_extrc_get_frame_rdmult() failed\");\n    }\n    cpi->ext_ratectrl.ext_rdmult = ext_rdmult;\n  }\n\n  if (cpi->sf.recode_loop == DISALLOW_RECODE) {\n    if (!encode_without_recode_loop(cpi, size, dest)) return;\n  } else {\n#if !CONFIG_REALTIME_ONLY\n#if CONFIG_RATE_CTRL\n    encode_with_recode_loop(cpi, size, dest, &encode_frame_result->rq_history);\n#else  // CONFIG_RATE_CTRL\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    start_timing(cpi, encode_with_recode_loop_time);\n#endif\n    encode_with_recode_loop(cpi, size, dest);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    end_timing(cpi, encode_with_recode_loop_time);\n#endif\n#endif  // CONFIG_RATE_CTRL\n#endif  // !CONFIG_REALTIME_ONLY\n  }\n\n  // TODO(jingning): When using show existing frame mode, we assume that the\n  // current ARF will be directly used as the final reconstructed frame. This is\n  // an encoder control scheme. One could in principle explore other\n  // possibilities to arrange the reference frame buffer and their coding order.\n  if (cm->show_existing_frame) {\n    ref_cnt_fb(cm->buffer_pool->frame_bufs, &cm->new_fb_idx,\n               cm->ref_frame_map[cpi->alt_fb_idx]);\n  }\n\n#if !CONFIG_REALTIME_ONLY\n  // Disable segmentation if it decrease rate/distortion ratio\n  if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ)\n    vp9_try_disable_lookahead_aq(cpi, size, dest);\n#endif\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n#ifdef OUTPUT_YUV_DENOISED\n  if (oxcf->noise_sensitivity > 0 && denoise_svc(cpi)) {\n    vpx_write_yuv_frame(yuv_denoised_file,\n                        &cpi->denoiser.running_avg_y[INTRA_FRAME]);\n  }\n#endif\n#endif\n#ifdef OUTPUT_YUV_SKINMAP\n  if (cpi->common.current_video_frame > 1) {\n    vp9_output_skin_map(cpi, yuv_skinmap_file);\n  }\n#endif\n\n  // Special case code to reduce pulsing when key frames are forced at a\n  // fixed interval. Note the reconstruction error if it is the frame before\n  // the force key frame\n  if (cpi->rc.next_key_frame_forced && cpi->rc.frames_to_key == 1) {\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (cm->use_highbitdepth) {\n      cpi->ambient_err =\n          vpx_highbd_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n    } else {\n      cpi->ambient_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n    }\n#else\n    cpi->ambient_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n  }\n\n  // If the encoder forced a KEY_FRAME decision\n  if (cm->frame_type == KEY_FRAME) cpi->refresh_last_frame = 1;\n\n  cm->frame_to_show = get_frame_new_buffer(cm);\n  cm->frame_to_show->color_space = cm->color_space;\n  cm->frame_to_show->color_range = cm->color_range;\n  cm->frame_to_show->render_width = cm->render_width;\n  cm->frame_to_show->render_height = cm->render_height;\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  start_timing(cpi, loopfilter_frame_time);\n#endif\n  // Pick the loop filter level for the frame.\n  loopfilter_frame(cpi, cm);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  end_timing(cpi, loopfilter_frame_time);\n#endif\n\n  if (cpi->rc.use_post_encode_drop) save_coding_context(cpi);\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  start_timing(cpi, vp9_pack_bitstream_time);\n#endif\n  // build the bitstream\n  vp9_pack_bitstream(cpi, dest, size);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  end_timing(cpi, vp9_pack_bitstream_time);\n#endif\n\n  if (cpi->ext_ratectrl.ready &&\n      cpi->ext_ratectrl.funcs.update_encodeframe_result != NULL) {\n    const RefCntBuffer *coded_frame_buf =\n        get_ref_cnt_buffer(cm, cm->new_fb_idx);\n    vpx_codec_err_t codec_status = vp9_extrc_update_encodeframe_result(\n        &cpi->ext_ratectrl, (*size) << 3, cpi->Source, &coded_frame_buf->buf,\n        cm->bit_depth, cpi->oxcf.input_bit_depth, cm->base_qindex);\n    if (codec_status != VPX_CODEC_OK) {\n      vpx_internal_error(&cm->error, codec_status,\n                         \"vp9_extrc_update_encodeframe_result() failed\");\n    }\n  }\n#if CONFIG_REALTIME_ONLY\n  (void)encode_frame_result;\n  assert(encode_frame_result == NULL);\n#else  // CONFIG_REALTIME_ONLY\n  if (encode_frame_result != NULL) {\n    const RefCntBuffer *coded_frame_buf =\n        get_ref_cnt_buffer(cm, cm->new_fb_idx);\n    RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];\n    FRAME_UPDATE_TYPE update_type =\n        cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index];\n    int quantize_index = vp9_get_quantizer(cpi);\n    get_ref_frame_bufs(cpi, ref_frame_bufs);\n    // update_encode_frame_result() depends on twopass.gf_group.index and\n    // cm->new_fb_idx, cpi->Source, cpi->lst_fb_idx, cpi->gld_fb_idx and\n    // cpi->alt_fb_idx are updated for current frame and have\n    // not been updated for the next frame yet.\n    // The update locations are as follows.\n    // 1) twopass.gf_group.index is initialized at define_gf_group by vp9_zero()\n    // for the first frame in the gf_group and is updated for the next frame at\n    // vp9_twopass_postencode_update().\n    // 2) cpi->Source is updated at the beginning of vp9_get_compressed_data()\n    // 3) cm->new_fb_idx is updated at the beginning of\n    // vp9_get_compressed_data() by get_free_fb(cm).\n    // 4) cpi->lst_fb_idx/gld_fb_idx/alt_fb_idx will be updated for the next\n    // frame at vp9_update_reference_frames().\n    // This function needs to be called before vp9_update_reference_frames().\n    // TODO(angiebird): Improve the codebase to make the update of frame\n    // dependent variables more robust.\n\n    update_encode_frame_result_basic(update_type, coded_frame_buf->frame_index,\n                                     quantize_index, encode_frame_result);\n#if CONFIG_RATE_CTRL\n    if (cpi->oxcf.use_simple_encode_api) {\n      const int ref_frame_flags = get_ref_frame_flags(cpi);\n      update_encode_frame_result_simple_encode(\n          ref_frame_flags,\n          cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index],\n          cpi->Source, coded_frame_buf, ref_frame_bufs, quantize_index,\n          cm->bit_depth, cpi->oxcf.input_bit_depth, cpi->td.counts,\n          cpi->partition_info, cpi->motion_vector_info, cpi->tpl_stats_info,\n          encode_frame_result);\n    }\n#endif  // CONFIG_RATE_CTRL\n  }\n#endif  // CONFIG_REALTIME_ONLY\n\n  if (cpi->rc.use_post_encode_drop && cm->base_qindex < cpi->rc.worst_quality &&\n      cpi->svc.spatial_layer_id == 0 && post_encode_drop_cbr(cpi, size)) {\n    restore_coding_context(cpi);\n    return;\n  }\n\n  cpi->last_frame_dropped = 0;\n  cpi->svc.last_layer_dropped[cpi->svc.spatial_layer_id] = 0;\n  if (cpi->svc.spatial_layer_id == cpi->svc.number_spatial_layers - 1)\n    cpi->svc.num_encoded_top_layer++;\n\n  // Keep track of the frame buffer index updated/refreshed for the\n  // current encoded TL0 superframe.\n  if (cpi->svc.temporal_layer_id == 0) {\n    if (cpi->refresh_last_frame)\n      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->lst_fb_idx;\n    else if (cpi->refresh_golden_frame)\n      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->gld_fb_idx;\n    else if (cpi->refresh_alt_ref_frame)\n      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->alt_fb_idx;\n  }\n\n  if (cm->seg.update_map) update_reference_segmentation_map(cpi);\n\n  if (frame_is_intra_only(cm) == 0) {\n    release_scaled_references(cpi);\n  }\n  vp9_update_reference_frames(cpi);\n\n  if (!cm->show_existing_frame) {\n    for (t = TX_4X4; t <= TX_32X32; ++t) {\n      full_to_model_counts(cpi->td.counts->coef[t],\n                           cpi->td.rd_counts.coef_counts[t]);\n    }\n\n    if (!cm->error_resilient_mode && !cm->frame_parallel_decoding_mode) {\n      if (!frame_is_intra_only(cm)) {\n        vp9_adapt_mode_probs(cm);\n        vp9_adapt_mv_probs(cm, cm->allow_high_precision_mv);\n      }\n      vp9_adapt_coef_probs(cm);\n    }\n  }\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  if (cpi->refresh_golden_frame == 1)\n    cpi->frame_flags |= FRAMEFLAGS_GOLDEN;\n  else\n    cpi->frame_flags &= ~FRAMEFLAGS_GOLDEN;\n\n  if (cpi->refresh_alt_ref_frame == 1)\n    cpi->frame_flags |= FRAMEFLAGS_ALTREF;\n  else\n    cpi->frame_flags &= ~FRAMEFLAGS_ALTREF;\n\n  cpi->ref_frame_flags = get_ref_frame_flags(cpi);\n\n  cm->last_frame_type = cm->frame_type;\n\n  vp9_rc_postencode_update(cpi, *size);\n\n  if (cpi->compute_frame_low_motion_onepass && oxcf->pass == 0 &&\n      !frame_is_intra_only(cm) &&\n      (!cpi->use_svc ||\n       (cpi->use_svc &&\n        !cpi->svc.layer_context[cpi->svc.temporal_layer_id].is_key_frame &&\n        cpi->svc.spatial_layer_id == cpi->svc.number_spatial_layers - 1))) {\n    vp9_compute_frame_low_motion(cpi);\n  }\n\n  *size = VPXMAX(1, *size);\n\n#if 0\n  output_frame_level_debug_stats(cpi);\n#endif\n\n  if (cm->frame_type == KEY_FRAME) {\n    // Tell the caller that the frame was coded as a key frame\n    *frame_flags = cpi->frame_flags | FRAMEFLAGS_KEY;\n  } else {\n    *frame_flags = cpi->frame_flags & ~FRAMEFLAGS_KEY;\n  }\n\n  // Clear the one shot update flags for segmentation map and mode/ref loop\n  // filter deltas.\n  cm->seg.update_map = 0;\n  cm->seg.update_data = 0;\n  cm->lf.mode_ref_delta_update = 0;\n\n  // keep track of the last coded dimensions\n  cm->last_width = cm->width;\n  cm->last_height = cm->height;\n\n  // reset to normal state now that we are done.\n  if (!cm->show_existing_frame) {\n    cm->last_show_frame = cm->show_frame;\n    cm->prev_frame = cm->cur_frame;\n  }\n\n  if (cm->show_frame) {\n    vp9_swap_mi_and_prev_mi(cm);\n    if (cpi->use_svc) vp9_inc_frame_in_layer(cpi);\n  }\n  update_frame_indexes(cm, cm->show_frame);\n\n  if (cpi->use_svc) {\n    cpi->svc\n        .layer_context[cpi->svc.spatial_layer_id *\n                           cpi->svc.number_temporal_layers +\n                       cpi->svc.temporal_layer_id]\n        .last_frame_type = cm->frame_type;\n    // Reset layer_sync back to 0 for next frame.\n    cpi->svc.spatial_layer_sync[cpi->svc.spatial_layer_id] = 0;\n  }\n\n  cpi->force_update_segmentation = 0;\n\n#if !CONFIG_REALTIME_ONLY\n  if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ)\n    vp9_alt_ref_aq_unset_all(cpi->alt_ref_aq, cpi);\n#endif\n\n  cpi->svc.previous_frame_is_intra_only = cm->intra_only;\n  cpi->svc.set_intra_only_frame = 0;\n}\n\nstatic void SvcEncode(VP9_COMP *cpi, size_t *size, uint8_t *dest,\n                      unsigned int *frame_flags) {\n  vp9_rc_get_svc_params(cpi);\n  encode_frame_to_data_rate(cpi, size, dest, frame_flags,\n                            /*encode_frame_result = */ NULL);\n}\n\nstatic void Pass0Encode(VP9_COMP *cpi, size_t *size, uint8_t *dest,\n                        unsigned int *frame_flags) {\n  if (cpi->oxcf.rc_mode == VPX_CBR) {\n    vp9_rc_get_one_pass_cbr_params(cpi);\n  } else {\n    vp9_rc_get_one_pass_vbr_params(cpi);\n  }\n  encode_frame_to_data_rate(cpi, size, dest, frame_flags,\n                            /*encode_frame_result = */ NULL);\n}\n\n#if !CONFIG_REALTIME_ONLY\nstatic void Pass2Encode(VP9_COMP *cpi, size_t *size, uint8_t *dest,\n                        unsigned int *frame_flags,\n                        ENCODE_FRAME_RESULT *encode_frame_result) {\n  cpi->allow_encode_breakout = ENCODE_BREAKOUT_ENABLED;\n#if CONFIG_MISMATCH_DEBUG\n  mismatch_move_frame_idx_w();\n#endif\n  encode_frame_to_data_rate(cpi, size, dest, frame_flags, encode_frame_result);\n}\n#endif  // !CONFIG_REALTIME_ONLY\n\nint vp9_receive_raw_frame(VP9_COMP *cpi, vpx_enc_frame_flags_t frame_flags,\n                          YV12_BUFFER_CONFIG *sd, int64_t time_stamp,\n                          int64_t end_time) {\n  VP9_COMMON *const cm = &cpi->common;\n  struct vpx_usec_timer timer;\n  int res = 0;\n  const int subsampling_x = sd->subsampling_x;\n  const int subsampling_y = sd->subsampling_y;\n#if CONFIG_VP9_HIGHBITDEPTH\n  const int use_highbitdepth = (sd->flags & YV12_FLAG_HIGHBITDEPTH) != 0;\n#else\n  const int use_highbitdepth = 0;\n#endif\n\n  update_initial_width(cpi, use_highbitdepth, subsampling_x, subsampling_y);\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  setup_denoiser_buffer(cpi);\n#endif\n\n  alloc_raw_frame_buffers(cpi);\n\n  vpx_usec_timer_start(&timer);\n\n  if (vp9_lookahead_push(cpi->lookahead, sd, time_stamp, end_time,\n                         use_highbitdepth, frame_flags))\n    res = -1;\n  vpx_usec_timer_mark(&timer);\n  cpi->time_receive_data += vpx_usec_timer_elapsed(&timer);\n\n  if ((cm->profile == PROFILE_0 || cm->profile == PROFILE_2) &&\n      (subsampling_x != 1 || subsampling_y != 1)) {\n    vpx_internal_error(&cm->error, VPX_CODEC_INVALID_PARAM,\n                       \"Non-4:2:0 color format requires profile 1 or 3\");\n    res = -1;\n  }\n  if ((cm->profile == PROFILE_1 || cm->profile == PROFILE_3) &&\n      (subsampling_x == 1 && subsampling_y == 1)) {\n    vpx_internal_error(&cm->error, VPX_CODEC_INVALID_PARAM,\n                       \"4:2:0 color format requires profile 0 or 2\");\n    res = -1;\n  }\n\n  return res;\n}\n\nstatic int frame_is_reference(const VP9_COMP *cpi) {\n  const VP9_COMMON *cm = &cpi->common;\n\n  return cm->frame_type == KEY_FRAME || cpi->refresh_last_frame ||\n         cpi->refresh_golden_frame || cpi->refresh_alt_ref_frame ||\n         cm->refresh_frame_context || cm->lf.mode_ref_delta_update ||\n         cm->seg.update_map || cm->seg.update_data;\n}\n\nstatic void adjust_frame_rate(VP9_COMP *cpi,\n                              const struct lookahead_entry *source) {\n  int64_t this_duration;\n  int step = 0;\n\n  if (source->ts_start == cpi->first_time_stamp_ever) {\n    this_duration = source->ts_end - source->ts_start;\n    step = 1;\n  } else {\n    int64_t last_duration =\n        cpi->last_end_time_stamp_seen - cpi->last_time_stamp_seen;\n\n    this_duration = source->ts_end - cpi->last_end_time_stamp_seen;\n\n    // do a step update if the duration changes by 10%\n    if (last_duration)\n      step = (int)((this_duration - last_duration) * 10 / last_duration);\n  }\n\n  if (this_duration) {\n    if (step) {\n      vp9_new_framerate(cpi, 10000000.0 / this_duration);\n    } else {\n      // Average this frame's rate into the last second's average\n      // frame rate. If we haven't seen 1 second yet, then average\n      // over the whole interval seen.\n      const double interval = VPXMIN(\n          (double)(source->ts_end - cpi->first_time_stamp_ever), 10000000.0);\n      double avg_duration = 10000000.0 / cpi->framerate;\n      avg_duration *= (interval - avg_duration + this_duration);\n      avg_duration /= interval;\n\n      vp9_new_framerate(cpi, 10000000.0 / avg_duration);\n    }\n  }\n  cpi->last_time_stamp_seen = source->ts_start;\n  cpi->last_end_time_stamp_seen = source->ts_end;\n}\n\n// Returns 0 if this is not an alt ref else the offset of the source frame\n// used as the arf midpoint.\nstatic int get_arf_src_index(VP9_COMP *cpi) {\n  RATE_CONTROL *const rc = &cpi->rc;\n  int arf_src_index = 0;\n  if (is_altref_enabled(cpi)) {\n    if (cpi->oxcf.pass == 2) {\n      const GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n      if (gf_group->update_type[gf_group->index] == ARF_UPDATE) {\n        arf_src_index = gf_group->arf_src_offset[gf_group->index];\n      }\n    } else if (rc->source_alt_ref_pending) {\n      arf_src_index = rc->frames_till_gf_update_due;\n    }\n  }\n  return arf_src_index;\n}\n\nstatic void check_src_altref(VP9_COMP *cpi,\n                             const struct lookahead_entry *source) {\n  RATE_CONTROL *const rc = &cpi->rc;\n\n  if (cpi->oxcf.pass == 2) {\n    const GF_GROUP *const gf_group = &cpi->twopass.gf_group;\n    rc->is_src_frame_alt_ref =\n        (gf_group->update_type[gf_group->index] == OVERLAY_UPDATE);\n  } else {\n    rc->is_src_frame_alt_ref =\n        cpi->alt_ref_source && (source == cpi->alt_ref_source);\n  }\n\n  if (rc->is_src_frame_alt_ref) {\n    // Current frame is an ARF overlay frame.\n    cpi->alt_ref_source = NULL;\n\n    // Don't refresh the last buffer for an ARF overlay frame. It will\n    // become the GF so preserve last as an alternative prediction option.\n    cpi->refresh_last_frame = 0;\n  }\n}\n\n#if CONFIG_INTERNAL_STATS\nstatic void adjust_image_stat(double y, double u, double v, double all,\n                              ImageStat *s) {\n  s->stat[Y] += y;\n  s->stat[U] += u;\n  s->stat[V] += v;\n  s->stat[ALL] += all;\n  s->worst = VPXMIN(s->worst, all);\n}\n#endif  // CONFIG_INTERNAL_STATS\n\n// Adjust the maximum allowable frame size for the target level.\nstatic void level_rc_framerate(VP9_COMP *cpi, int arf_src_index) {\n  RATE_CONTROL *const rc = &cpi->rc;\n  LevelConstraint *const ls = &cpi->level_constraint;\n  VP9_COMMON *const cm = &cpi->common;\n  const double max_cpb_size = ls->max_cpb_size;\n  vpx_clear_system_state();\n  rc->max_frame_bandwidth = VPXMIN(rc->max_frame_bandwidth, ls->max_frame_size);\n  if (frame_is_intra_only(cm)) {\n    rc->max_frame_bandwidth =\n        VPXMIN(rc->max_frame_bandwidth, (int)(max_cpb_size * 0.5));\n  } else if (arf_src_index > 0) {\n    rc->max_frame_bandwidth =\n        VPXMIN(rc->max_frame_bandwidth, (int)(max_cpb_size * 0.4));\n  } else {\n    rc->max_frame_bandwidth =\n        VPXMIN(rc->max_frame_bandwidth, (int)(max_cpb_size * 0.2));\n  }\n}\n\nstatic void update_level_info(VP9_COMP *cpi, size_t *size, int arf_src_index) {\n  VP9_COMMON *const cm = &cpi->common;\n  Vp9LevelInfo *const level_info = &cpi->level_info;\n  Vp9LevelSpec *const level_spec = &level_info->level_spec;\n  Vp9LevelStats *const level_stats = &level_info->level_stats;\n  int i, idx;\n  uint64_t luma_samples, dur_end;\n  const uint32_t luma_pic_size = cm->width * cm->height;\n  const uint32_t luma_pic_breadth = VPXMAX(cm->width, cm->height);\n  LevelConstraint *const level_constraint = &cpi->level_constraint;\n  const int8_t level_index = level_constraint->level_index;\n  double cpb_data_size;\n\n  vpx_clear_system_state();\n\n  // update level_stats\n  level_stats->total_compressed_size += *size;\n  if (cm->show_frame) {\n    level_stats->total_uncompressed_size +=\n        luma_pic_size +\n        2 * (luma_pic_size >> (cm->subsampling_x + cm->subsampling_y));\n    level_stats->time_encoded =\n        (cpi->last_end_time_stamp_seen - cpi->first_time_stamp_ever) /\n        (double)TICKS_PER_SEC;\n  }\n\n  if (arf_src_index > 0) {\n    if (!level_stats->seen_first_altref) {\n      level_stats->seen_first_altref = 1;\n    } else if (level_stats->frames_since_last_altref <\n               level_spec->min_altref_distance) {\n      level_spec->min_altref_distance = level_stats->frames_since_last_altref;\n    }\n    level_stats->frames_since_last_altref = 0;\n  } else {\n    ++level_stats->frames_since_last_altref;\n  }\n\n  if (level_stats->frame_window_buffer.len < FRAME_WINDOW_SIZE - 1) {\n    idx = (level_stats->frame_window_buffer.start +\n           level_stats->frame_window_buffer.len++) %\n          FRAME_WINDOW_SIZE;\n  } else {\n    idx = level_stats->frame_window_buffer.start;\n    level_stats->frame_window_buffer.start = (idx + 1) % FRAME_WINDOW_SIZE;\n  }\n  level_stats->frame_window_buffer.buf[idx].ts = cpi->last_time_stamp_seen;\n  level_stats->frame_window_buffer.buf[idx].size = (uint32_t)(*size);\n  level_stats->frame_window_buffer.buf[idx].luma_samples = luma_pic_size;\n\n  if (cm->frame_type == KEY_FRAME) {\n    level_stats->ref_refresh_map = 0;\n  } else {\n    int count = 0;\n    level_stats->ref_refresh_map |= vp9_get_refresh_mask(cpi);\n    // Also need to consider the case where the encoder refers to a buffer\n    // that has been implicitly refreshed after encoding a keyframe.\n    if (!cm->intra_only) {\n      level_stats->ref_refresh_map |= (1 << cpi->lst_fb_idx);\n      level_stats->ref_refresh_map |= (1 << cpi->gld_fb_idx);\n      level_stats->ref_refresh_map |= (1 << cpi->alt_fb_idx);\n    }\n    for (i = 0; i < REF_FRAMES; ++i) {\n      count += (level_stats->ref_refresh_map >> i) & 1;\n    }\n    if (count > level_spec->max_ref_frame_buffers) {\n      level_spec->max_ref_frame_buffers = count;\n    }\n  }\n\n  // update average_bitrate\n  level_spec->average_bitrate = (double)level_stats->total_compressed_size /\n                                125.0 / level_stats->time_encoded;\n\n  // update max_luma_sample_rate\n  luma_samples = 0;\n  for (i = 0; i < level_stats->frame_window_buffer.len; ++i) {\n    idx = (level_stats->frame_window_buffer.start +\n           level_stats->frame_window_buffer.len - 1 - i) %\n          FRAME_WINDOW_SIZE;\n    if (i == 0) {\n      dur_end = level_stats->frame_window_buffer.buf[idx].ts;\n    }\n    if (dur_end - level_stats->frame_window_buffer.buf[idx].ts >=\n        TICKS_PER_SEC) {\n      break;\n    }\n    luma_samples += level_stats->frame_window_buffer.buf[idx].luma_samples;\n  }\n  if (luma_samples > level_spec->max_luma_sample_rate) {\n    level_spec->max_luma_sample_rate = luma_samples;\n  }\n\n  // update max_cpb_size\n  cpb_data_size = 0;\n  for (i = 0; i < CPB_WINDOW_SIZE; ++i) {\n    if (i >= level_stats->frame_window_buffer.len) break;\n    idx = (level_stats->frame_window_buffer.start +\n           level_stats->frame_window_buffer.len - 1 - i) %\n          FRAME_WINDOW_SIZE;\n    cpb_data_size += level_stats->frame_window_buffer.buf[idx].size;\n  }\n  cpb_data_size = cpb_data_size / 125.0;\n  if (cpb_data_size > level_spec->max_cpb_size) {\n    level_spec->max_cpb_size = cpb_data_size;\n  }\n\n  // update max_luma_picture_size\n  if (luma_pic_size > level_spec->max_luma_picture_size) {\n    level_spec->max_luma_picture_size = luma_pic_size;\n  }\n\n  // update max_luma_picture_breadth\n  if (luma_pic_breadth > level_spec->max_luma_picture_breadth) {\n    level_spec->max_luma_picture_breadth = luma_pic_breadth;\n  }\n\n  // update compression_ratio\n  level_spec->compression_ratio = (double)level_stats->total_uncompressed_size *\n                                  cm->bit_depth /\n                                  level_stats->total_compressed_size / 8.0;\n\n  // update max_col_tiles\n  if (level_spec->max_col_tiles < (1 << cm->log2_tile_cols)) {\n    level_spec->max_col_tiles = (1 << cm->log2_tile_cols);\n  }\n\n  if (level_index >= 0 && level_constraint->fail_flag == 0) {\n    if (level_spec->max_luma_picture_size >\n        vp9_level_defs[level_index].max_luma_picture_size) {\n      level_constraint->fail_flag |= (1 << LUMA_PIC_SIZE_TOO_LARGE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[LUMA_PIC_SIZE_TOO_LARGE]);\n    }\n\n    if (level_spec->max_luma_picture_breadth >\n        vp9_level_defs[level_index].max_luma_picture_breadth) {\n      level_constraint->fail_flag |= (1 << LUMA_PIC_BREADTH_TOO_LARGE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[LUMA_PIC_BREADTH_TOO_LARGE]);\n    }\n\n    if ((double)level_spec->max_luma_sample_rate >\n        (double)vp9_level_defs[level_index].max_luma_sample_rate *\n            (1 + SAMPLE_RATE_GRACE_P)) {\n      level_constraint->fail_flag |= (1 << LUMA_SAMPLE_RATE_TOO_LARGE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[LUMA_SAMPLE_RATE_TOO_LARGE]);\n    }\n\n    if (level_spec->max_col_tiles > vp9_level_defs[level_index].max_col_tiles) {\n      level_constraint->fail_flag |= (1 << TOO_MANY_COLUMN_TILE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[TOO_MANY_COLUMN_TILE]);\n    }\n\n    if (level_spec->min_altref_distance <\n        vp9_level_defs[level_index].min_altref_distance) {\n      level_constraint->fail_flag |= (1 << ALTREF_DIST_TOO_SMALL);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[ALTREF_DIST_TOO_SMALL]);\n    }\n\n    if (level_spec->max_ref_frame_buffers >\n        vp9_level_defs[level_index].max_ref_frame_buffers) {\n      level_constraint->fail_flag |= (1 << TOO_MANY_REF_BUFFER);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[TOO_MANY_REF_BUFFER]);\n    }\n\n    if (level_spec->max_cpb_size > vp9_level_defs[level_index].max_cpb_size) {\n      level_constraint->fail_flag |= (1 << CPB_TOO_LARGE);\n      vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                         \"Failed to encode to the target level %d. %s\",\n                         vp9_level_defs[level_index].level,\n                         level_fail_messages[CPB_TOO_LARGE]);\n    }\n\n    // Set an upper bound for the next frame size. It will be used in\n    // level_rc_framerate() before encoding the next frame.\n    cpb_data_size = 0;\n    for (i = 0; i < CPB_WINDOW_SIZE - 1; ++i) {\n      if (i >= level_stats->frame_window_buffer.len) break;\n      idx = (level_stats->frame_window_buffer.start +\n             level_stats->frame_window_buffer.len - 1 - i) %\n            FRAME_WINDOW_SIZE;\n      cpb_data_size += level_stats->frame_window_buffer.buf[idx].size;\n    }\n    cpb_data_size = cpb_data_size / 125.0;\n    level_constraint->max_frame_size =\n        (int)((vp9_level_defs[level_index].max_cpb_size - cpb_data_size) *\n              1000.0);\n    if (level_stats->frame_window_buffer.len < CPB_WINDOW_SIZE - 1)\n      level_constraint->max_frame_size >>= 1;\n  }\n}\n\nvoid vp9_get_ref_frame_info(FRAME_UPDATE_TYPE update_type, int ref_frame_flags,\n                            RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES],\n                            int *ref_frame_coding_indexes,\n                            int *ref_frame_valid_list) {\n  if (update_type != KF_UPDATE) {\n    const VP9_REFFRAME inter_ref_flags[MAX_INTER_REF_FRAMES] = { VP9_LAST_FLAG,\n                                                                 VP9_GOLD_FLAG,\n                                                                 VP9_ALT_FLAG };\n    int i;\n    for (i = 0; i < MAX_INTER_REF_FRAMES; ++i) {\n      assert(ref_frame_bufs[i] != NULL);\n      ref_frame_coding_indexes[i] = ref_frame_bufs[i]->frame_coding_index;\n      ref_frame_valid_list[i] = (ref_frame_flags & inter_ref_flags[i]) != 0;\n    }\n  } else {\n    // No reference frame is available when this is a key frame.\n    int i;\n    for (i = 0; i < MAX_INTER_REF_FRAMES; ++i) {\n      ref_frame_coding_indexes[i] = -1;\n      ref_frame_valid_list[i] = 0;\n    }\n  }\n}\n\nvoid vp9_init_encode_frame_result(ENCODE_FRAME_RESULT *encode_frame_result) {\n  encode_frame_result->show_idx = -1;  // Actual encoding doesn't happen.\n#if CONFIG_RATE_CTRL\n  encode_frame_result->frame_coding_index = -1;\n  vp9_zero(encode_frame_result->coded_frame);\n  encode_frame_result->coded_frame.allocated = 0;\n  init_rq_history(&encode_frame_result->rq_history);\n#endif  // CONFIG_RATE_CTRL\n}\n\nint vp9_get_compressed_data(VP9_COMP *cpi, unsigned int *frame_flags,\n                            size_t *size, uint8_t *dest, int64_t *time_stamp,\n                            int64_t *time_end, int flush,\n                            ENCODE_FRAME_RESULT *encode_frame_result) {\n  const VP9EncoderConfig *const oxcf = &cpi->oxcf;\n  VP9_COMMON *const cm = &cpi->common;\n  BufferPool *const pool = cm->buffer_pool;\n  RATE_CONTROL *const rc = &cpi->rc;\n  struct vpx_usec_timer cmptimer;\n  YV12_BUFFER_CONFIG *force_src_buffer = NULL;\n  struct lookahead_entry *last_source = NULL;\n  struct lookahead_entry *source = NULL;\n  int arf_src_index;\n  const int gf_group_index = cpi->twopass.gf_group.index;\n  int i;\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  if (oxcf->pass == 2) start_timing(cpi, vp9_get_compressed_data_time);\n#endif\n\n  if (is_one_pass_svc(cpi)) {\n    vp9_one_pass_svc_start_layer(cpi);\n  }\n\n  vpx_usec_timer_start(&cmptimer);\n\n  vp9_set_high_precision_mv(cpi, ALTREF_HIGH_PRECISION_MV);\n\n  // Is multi-arf enabled.\n  // Note that at the moment multi_arf is only configured for 2 pass VBR and\n  // will not work properly with svc.\n  // Enable the Jingning's new \"multi_layer_arf\" code if \"enable_auto_arf\"\n  // is greater than or equal to 2.\n  if ((oxcf->pass == 2) && !cpi->use_svc && (cpi->oxcf.enable_auto_arf >= 2))\n    cpi->multi_layer_arf = 1;\n  else\n    cpi->multi_layer_arf = 0;\n\n  // Normal defaults\n  cm->reset_frame_context = 0;\n  cm->refresh_frame_context = 1;\n  if (!is_one_pass_svc(cpi)) {\n    cpi->refresh_last_frame = 1;\n    cpi->refresh_golden_frame = 0;\n    cpi->refresh_alt_ref_frame = 0;\n  }\n\n  // Should we encode an arf frame.\n  arf_src_index = get_arf_src_index(cpi);\n\n  if (arf_src_index) {\n    for (i = 0; i <= arf_src_index; ++i) {\n      struct lookahead_entry *e = vp9_lookahead_peek(cpi->lookahead, i);\n      // Avoid creating an alt-ref if there's a forced keyframe pending.\n      if (e == NULL) {\n        break;\n      } else if (e->flags == VPX_EFLAG_FORCE_KF) {\n        arf_src_index = 0;\n        flush = 1;\n        break;\n      }\n    }\n  }\n\n  // Clear arf index stack before group of pictures processing starts.\n  if (gf_group_index == 1) {\n    stack_init(cpi->twopass.gf_group.arf_index_stack, MAX_LAG_BUFFERS * 2);\n    cpi->twopass.gf_group.stack_size = 0;\n  }\n\n  if (arf_src_index) {\n    assert(arf_src_index <= rc->frames_to_key);\n    if ((source = vp9_lookahead_peek(cpi->lookahead, arf_src_index)) != NULL) {\n      cpi->alt_ref_source = source;\n\n#if !CONFIG_REALTIME_ONLY\n      if ((oxcf->mode != REALTIME) && (oxcf->arnr_max_frames > 0) &&\n          (oxcf->arnr_strength > 0)) {\n        int bitrate = cpi->rc.avg_frame_bandwidth / 40;\n        int not_low_bitrate = bitrate > ALT_REF_AQ_LOW_BITRATE_BOUNDARY;\n\n        int not_last_frame = (cpi->lookahead->sz - arf_src_index > 1);\n        not_last_frame |= ALT_REF_AQ_APPLY_TO_LAST_FRAME;\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n        start_timing(cpi, vp9_temporal_filter_time);\n#endif\n        // Produce the filtered ARF frame.\n        vp9_temporal_filter(cpi, arf_src_index);\n        vpx_extend_frame_borders(&cpi->alt_ref_buffer);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n        end_timing(cpi, vp9_temporal_filter_time);\n#endif\n\n        // for small bitrates segmentation overhead usually\n        // eats all bitrate gain from enabling delta quantizers\n        if (cpi->oxcf.alt_ref_aq != 0 && not_low_bitrate && not_last_frame)\n          vp9_alt_ref_aq_setup_mode(cpi->alt_ref_aq, cpi);\n\n        force_src_buffer = &cpi->alt_ref_buffer;\n      }\n#endif\n      cm->show_frame = 0;\n      cm->intra_only = 0;\n      cpi->refresh_alt_ref_frame = 1;\n      cpi->refresh_golden_frame = 0;\n      cpi->refresh_last_frame = 0;\n      rc->is_src_frame_alt_ref = 0;\n      rc->source_alt_ref_pending = 0;\n    } else {\n      rc->source_alt_ref_pending = 0;\n    }\n  }\n\n  if (!source) {\n    // Get last frame source.\n    if (cm->current_video_frame > 0) {\n      if ((last_source = vp9_lookahead_peek(cpi->lookahead, -1)) == NULL)\n        return -1;\n    }\n\n    // Read in the source frame.\n    if (cpi->use_svc || cpi->svc.set_intra_only_frame)\n      source = vp9_svc_lookahead_pop(cpi, cpi->lookahead, flush);\n    else\n      source = vp9_lookahead_pop(cpi->lookahead, flush);\n\n    if (source != NULL) {\n      cm->show_frame = 1;\n      cm->intra_only = 0;\n      // If the flags indicate intra frame, but if the current picture is for\n      // spatial layer above first_spatial_layer_to_encode, it should not be an\n      // intra picture.\n      if ((source->flags & VPX_EFLAG_FORCE_KF) && cpi->use_svc &&\n          cpi->svc.spatial_layer_id > cpi->svc.first_spatial_layer_to_encode) {\n        source->flags &= ~(unsigned int)(VPX_EFLAG_FORCE_KF);\n      }\n\n      // Check to see if the frame should be encoded as an arf overlay.\n      check_src_altref(cpi, source);\n    }\n  }\n\n  if (source) {\n    cpi->un_scaled_source = cpi->Source =\n        force_src_buffer ? force_src_buffer : &source->img;\n\n#ifdef ENABLE_KF_DENOISE\n    // Copy of raw source for metrics calculation.\n    if (is_psnr_calc_enabled(cpi))\n      vp9_copy_and_extend_frame(cpi->Source, &cpi->raw_unscaled_source);\n#endif\n\n    cpi->unscaled_last_source = last_source != NULL ? &last_source->img : NULL;\n\n    *time_stamp = source->ts_start;\n    *time_end = source->ts_end;\n    *frame_flags = (source->flags & VPX_EFLAG_FORCE_KF) ? FRAMEFLAGS_KEY : 0;\n  } else {\n    *size = 0;\n    return -1;\n  }\n\n  if (source->ts_start < cpi->first_time_stamp_ever) {\n    cpi->first_time_stamp_ever = source->ts_start;\n    cpi->last_end_time_stamp_seen = source->ts_start;\n  }\n\n  // Clear down mmx registers\n  vpx_clear_system_state();\n\n  // adjust frame rates based on timestamps given\n  if (cm->show_frame) {\n    if (cpi->use_svc && cpi->svc.use_set_ref_frame_config &&\n        cpi->svc.duration[cpi->svc.spatial_layer_id] > 0)\n      vp9_svc_adjust_frame_rate(cpi);\n    else\n      adjust_frame_rate(cpi, source);\n  }\n\n  if (is_one_pass_svc(cpi)) {\n    vp9_update_temporal_layer_framerate(cpi);\n    vp9_restore_layer_context(cpi);\n  }\n\n  // Find a free buffer for the new frame, releasing the reference previously\n  // held.\n  if (cm->new_fb_idx != INVALID_IDX) {\n    --pool->frame_bufs[cm->new_fb_idx].ref_count;\n  }\n  cm->new_fb_idx = get_free_fb(cm);\n\n  if (cm->new_fb_idx == INVALID_IDX) return -1;\n  cm->cur_frame = &pool->frame_bufs[cm->new_fb_idx];\n  // If the frame buffer for current frame is the same as previous frame, MV in\n  // the base layer shouldn't be used as it'll cause data race.\n  if (cpi->svc.spatial_layer_id > 0 && cm->cur_frame == cm->prev_frame) {\n    cpi->svc.use_base_mv = 0;\n  }\n  // Start with a 0 size frame.\n  *size = 0;\n\n  cpi->frame_flags = *frame_flags;\n\n#if !CONFIG_REALTIME_ONLY\n  if ((oxcf->pass == 2) && !cpi->use_svc) {\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    start_timing(cpi, vp9_rc_get_second_pass_params_time);\n#endif\n    vp9_rc_get_second_pass_params(cpi);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    end_timing(cpi, vp9_rc_get_second_pass_params_time);\n#endif\n  } else if (oxcf->pass == 1) {\n    set_frame_size(cpi);\n  }\n#endif  // !CONFIG_REALTIME_ONLY\n\n  if (oxcf->pass != 1 && cpi->level_constraint.level_index >= 0 &&\n      cpi->level_constraint.fail_flag == 0)\n    level_rc_framerate(cpi, arf_src_index);\n\n  if (cpi->oxcf.pass != 0 || cpi->use_svc || frame_is_intra_only(cm) == 1) {\n    for (i = 0; i < REFS_PER_FRAME; ++i) cpi->scaled_ref_idx[i] = INVALID_IDX;\n  }\n\n  if (cpi->kmeans_data_arr_alloc == 0) {\n    const int mi_cols = mi_cols_aligned_to_sb(cm->mi_cols);\n    const int mi_rows = mi_cols_aligned_to_sb(cm->mi_rows);\n#if CONFIG_MULTITHREAD\n    pthread_mutex_init(&cpi->kmeans_mutex, NULL);\n#endif\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->kmeans_data_arr,\n        vpx_calloc(mi_rows * mi_cols, sizeof(*cpi->kmeans_data_arr)));\n    cpi->kmeans_data_stride = mi_cols;\n    cpi->kmeans_data_arr_alloc = 1;\n  }\n\n#if CONFIG_NON_GREEDY_MV\n  {\n    const int mi_cols = mi_cols_aligned_to_sb(cm->mi_cols);\n    const int mi_rows = mi_cols_aligned_to_sb(cm->mi_rows);\n    Status status = vp9_alloc_motion_field_info(\n        &cpi->motion_field_info, MAX_ARF_GOP_SIZE, mi_rows, mi_cols);\n    if (status == STATUS_FAILED) {\n      vpx_internal_error(&(cm)->error, VPX_CODEC_MEM_ERROR,\n                         \"vp9_alloc_motion_field_info failed\");\n    }\n  }\n#endif  // CONFIG_NON_GREEDY_MV\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  start_timing(cpi, setup_tpl_stats_time);\n#endif\n  if (gf_group_index == 1 &&\n      cpi->twopass.gf_group.update_type[gf_group_index] == ARF_UPDATE &&\n      cpi->sf.enable_tpl_model) {\n    vp9_init_tpl_buffer(cpi);\n    vp9_estimate_qp_gop(cpi);\n    vp9_setup_tpl_stats(cpi);\n  }\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  end_timing(cpi, setup_tpl_stats_time);\n#endif\n\n#if CONFIG_BITSTREAM_DEBUG\n  assert(cpi->oxcf.max_threads == 0 &&\n         \"bitstream debug tool does not support multithreading\");\n  bitstream_queue_record_write();\n#endif\n#if CONFIG_BITSTREAM_DEBUG || CONFIG_MISMATCH_DEBUG\n  bitstream_queue_set_frame_write(cm->current_video_frame * 2 + cm->show_frame);\n#endif\n\n  cpi->td.mb.fp_src_pred = 0;\n#if CONFIG_REALTIME_ONLY\n  (void)encode_frame_result;\n  if (cpi->use_svc) {\n    SvcEncode(cpi, size, dest, frame_flags);\n  } else {\n    // One pass encode\n    Pass0Encode(cpi, size, dest, frame_flags);\n  }\n#else  // !CONFIG_REALTIME_ONLY\n  if (oxcf->pass == 1 && !cpi->use_svc) {\n    const int lossless = is_lossless_requested(oxcf);\n#if CONFIG_VP9_HIGHBITDEPTH\n    if (cpi->oxcf.use_highbitdepth)\n      cpi->td.mb.fwd_txfm4x4 =\n          lossless ? vp9_highbd_fwht4x4 : vpx_highbd_fdct4x4;\n    else\n      cpi->td.mb.fwd_txfm4x4 = lossless ? vp9_fwht4x4 : vpx_fdct4x4;\n    cpi->td.mb.highbd_inv_txfm_add =\n        lossless ? vp9_highbd_iwht4x4_add : vp9_highbd_idct4x4_add;\n#else\n    cpi->td.mb.fwd_txfm4x4 = lossless ? vp9_fwht4x4 : vpx_fdct4x4;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n    cpi->td.mb.inv_txfm_add = lossless ? vp9_iwht4x4_add : vp9_idct4x4_add;\n    vp9_first_pass(cpi, source);\n  } else if (oxcf->pass == 2 && !cpi->use_svc) {\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    // Accumulate 2nd pass time in 2-pass case.\n    start_timing(cpi, Pass2Encode_time);\n#endif\n    Pass2Encode(cpi, size, dest, frame_flags, encode_frame_result);\n    vp9_twopass_postencode_update(cpi);\n#if CONFIG_COLLECT_COMPONENT_TIMING\n    end_timing(cpi, Pass2Encode_time);\n#endif\n  } else if (cpi->use_svc) {\n    SvcEncode(cpi, size, dest, frame_flags);\n  } else {\n    // One pass encode\n    Pass0Encode(cpi, size, dest, frame_flags);\n  }\n#endif  // CONFIG_REALTIME_ONLY\n\n  if (cm->show_frame) cm->cur_show_frame_fb_idx = cm->new_fb_idx;\n\n  if (cm->refresh_frame_context)\n    cm->frame_contexts[cm->frame_context_idx] = *cm->fc;\n\n  // No frame encoded, or frame was dropped, release scaled references.\n  if ((*size == 0) && (frame_is_intra_only(cm) == 0)) {\n    release_scaled_references(cpi);\n  }\n\n  if (*size > 0) {\n    cpi->droppable = !frame_is_reference(cpi);\n  }\n\n  // Save layer specific state.\n  if (is_one_pass_svc(cpi) || ((cpi->svc.number_temporal_layers > 1 ||\n                                cpi->svc.number_spatial_layers > 1) &&\n                               oxcf->pass == 2)) {\n    vp9_save_layer_context(cpi);\n  }\n\n  if (cpi->svc.spatial_layer_id == cpi->svc.number_spatial_layers - 1)\n    cpi->fixed_qp_onepass = 0;\n\n  vpx_usec_timer_mark(&cmptimer);\n  cpi->time_compress_data += vpx_usec_timer_elapsed(&cmptimer);\n\n  if (cpi->keep_level_stats && oxcf->pass != 1)\n    update_level_info(cpi, size, arf_src_index);\n\n#if CONFIG_INTERNAL_STATS\n\n  if (oxcf->pass != 1 && !cpi->last_frame_dropped) {\n    double samples = 0.0;\n    cpi->bytes += (int)(*size);\n\n    if (cm->show_frame) {\n      uint32_t bit_depth = 8;\n      uint32_t in_bit_depth = 8;\n      cpi->count++;\n#if CONFIG_VP9_HIGHBITDEPTH\n      if (cm->use_highbitdepth) {\n        in_bit_depth = cpi->oxcf.input_bit_depth;\n        bit_depth = cm->bit_depth;\n      }\n#endif\n\n      if (cpi->b_calculate_psnr) {\n        YV12_BUFFER_CONFIG *orig = cpi->raw_source_frame;\n        YV12_BUFFER_CONFIG *recon = cpi->common.frame_to_show;\n        YV12_BUFFER_CONFIG *pp = &cm->post_proc_buffer;\n        PSNR_STATS psnr;\n#if CONFIG_VP9_HIGHBITDEPTH\n        vpx_calc_highbd_psnr(orig, recon, &psnr, cpi->td.mb.e_mbd.bd,\n                             in_bit_depth);\n#else\n        vpx_calc_psnr(orig, recon, &psnr);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n        adjust_image_stat(psnr.psnr[1], psnr.psnr[2], psnr.psnr[3],\n                          psnr.psnr[0], &cpi->psnr);\n        cpi->total_sq_error += psnr.sse[0];\n        cpi->total_samples += psnr.samples[0];\n        samples = psnr.samples[0];\n\n        {\n          PSNR_STATS psnr2;\n          double frame_ssim2 = 0, weight = 0;\n#if CONFIG_VP9_POSTPROC\n          if (vpx_alloc_frame_buffer(\n                  pp, recon->y_crop_width, recon->y_crop_height,\n                  cm->subsampling_x, cm->subsampling_y,\n#if CONFIG_VP9_HIGHBITDEPTH\n                  cm->use_highbitdepth,\n#endif\n                  VP9_ENC_BORDER_IN_PIXELS, cm->byte_alignment) < 0) {\n            vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                               \"Failed to allocate post processing buffer\");\n          }\n          {\n            vp9_ppflags_t ppflags;\n            ppflags.post_proc_flag = VP9D_DEBLOCK;\n            ppflags.deblocking_level = 0;  // not used in vp9_post_proc_frame()\n            ppflags.noise_level = 0;       // not used in vp9_post_proc_frame()\n            vp9_post_proc_frame(cm, pp, &ppflags,\n                                cpi->un_scaled_source->y_width);\n          }\n#endif\n          vpx_clear_system_state();\n\n#if CONFIG_VP9_HIGHBITDEPTH\n          vpx_calc_highbd_psnr(orig, pp, &psnr2, cpi->td.mb.e_mbd.bd,\n                               cpi->oxcf.input_bit_depth);\n#else\n          vpx_calc_psnr(orig, pp, &psnr2);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n          cpi->totalp_sq_error += psnr2.sse[0];\n          cpi->totalp_samples += psnr2.samples[0];\n          adjust_image_stat(psnr2.psnr[1], psnr2.psnr[2], psnr2.psnr[3],\n                            psnr2.psnr[0], &cpi->psnrp);\n\n#if CONFIG_VP9_HIGHBITDEPTH\n          if (cm->use_highbitdepth) {\n            frame_ssim2 = vpx_highbd_calc_ssim(orig, recon, &weight, bit_depth,\n                                               in_bit_depth);\n          } else {\n            frame_ssim2 = vpx_calc_ssim(orig, recon, &weight);\n          }\n#else\n          frame_ssim2 = vpx_calc_ssim(orig, recon, &weight);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n          cpi->worst_ssim = VPXMIN(cpi->worst_ssim, frame_ssim2);\n          cpi->summed_quality += frame_ssim2 * weight;\n          cpi->summed_weights += weight;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n          if (cm->use_highbitdepth) {\n            frame_ssim2 = vpx_highbd_calc_ssim(orig, pp, &weight, bit_depth,\n                                               in_bit_depth);\n          } else {\n            frame_ssim2 = vpx_calc_ssim(orig, pp, &weight);\n          }\n#else\n          frame_ssim2 = vpx_calc_ssim(orig, pp, &weight);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n          cpi->summedp_quality += frame_ssim2 * weight;\n          cpi->summedp_weights += weight;\n#if 0\n          if (cm->show_frame) {\n            FILE *f = fopen(\"q_used.stt\", \"a\");\n            fprintf(f, \"%5d : Y%f7.3:U%f7.3:V%f7.3:F%f7.3:S%7.3f\\n\",\n                    cpi->common.current_video_frame, psnr2.psnr[1],\n                    psnr2.psnr[2], psnr2.psnr[3], psnr2.psnr[0], frame_ssim2);\n            fclose(f);\n          }\n#endif\n        }\n      }\n      if (cpi->b_calculate_blockiness) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        if (!cm->use_highbitdepth)\n#endif\n        {\n          double frame_blockiness = vp9_get_blockiness(\n              cpi->Source->y_buffer, cpi->Source->y_stride,\n              cm->frame_to_show->y_buffer, cm->frame_to_show->y_stride,\n              cpi->Source->y_width, cpi->Source->y_height);\n          cpi->worst_blockiness =\n              VPXMAX(cpi->worst_blockiness, frame_blockiness);\n          cpi->total_blockiness += frame_blockiness;\n        }\n      }\n\n      if (cpi->b_calculate_consistency) {\n#if CONFIG_VP9_HIGHBITDEPTH\n        if (!cm->use_highbitdepth)\n#endif\n        {\n          double this_inconsistency = vpx_get_ssim_metrics(\n              cpi->Source->y_buffer, cpi->Source->y_stride,\n              cm->frame_to_show->y_buffer, cm->frame_to_show->y_stride,\n              cpi->Source->y_width, cpi->Source->y_height, cpi->ssim_vars,\n              &cpi->metrics, 1);\n\n          const double peak = (double)((1 << cpi->oxcf.input_bit_depth) - 1);\n          double consistency =\n              vpx_sse_to_psnr(samples, peak, (double)cpi->total_inconsistency);\n          if (consistency > 0.0)\n            cpi->worst_consistency =\n                VPXMIN(cpi->worst_consistency, consistency);\n          cpi->total_inconsistency += this_inconsistency;\n        }\n      }\n\n      {\n        double y, u, v, frame_all;\n        frame_all = vpx_calc_fastssim(cpi->Source, cm->frame_to_show, &y, &u,\n                                      &v, bit_depth, in_bit_depth);\n        adjust_image_stat(y, u, v, frame_all, &cpi->fastssim);\n      }\n      {\n        double y, u, v, frame_all;\n        frame_all = vpx_psnrhvs(cpi->Source, cm->frame_to_show, &y, &u, &v,\n                                bit_depth, in_bit_depth);\n        adjust_image_stat(y, u, v, frame_all, &cpi->psnrhvs);\n      }\n    }\n  }\n\n#endif\n\n#if CONFIG_COLLECT_COMPONENT_TIMING\n  if (oxcf->pass == 2) end_timing(cpi, vp9_get_compressed_data_time);\n\n  // Print out timing information.\n  // Note: Use \"cpi->frame_component_time[0] > 100 us\" to avoid showing of\n  // show_existing_frame and lag-in-frames.\n  //  if (cpi->frame_component_time[0] > 100)\n  if (oxcf->pass == 2) {\n    uint64_t frame_total = 0, total = 0;\n    int i;\n\n    fprintf(stderr,\n            \"\\n Frame number: %d, Frame type: %s, Show Frame: %d, Q: %d\\n\",\n            cm->current_video_frame, get_frame_type_enum(cm->frame_type),\n            cm->show_frame, cm->base_qindex);\n    for (i = 0; i < kTimingComponents; i++) {\n      cpi->component_time[i] += cpi->frame_component_time[i];\n      // Use vp9_get_compressed_data_time (i = 0) as the total time.\n      if (i == 0) {\n        frame_total = cpi->frame_component_time[0];\n        total = cpi->component_time[0];\n      }\n      fprintf(stderr,\n              \" %50s:  %15\" PRId64 \" us [%6.2f%%] (total: %15\" PRId64\n              \" us [%6.2f%%])\\n\",\n              get_component_name(i), cpi->frame_component_time[i],\n              (float)((float)cpi->frame_component_time[i] * 100.0 /\n                      (float)frame_total),\n              cpi->component_time[i],\n              (float)((float)cpi->component_time[i] * 100.0 / (float)total));\n      cpi->frame_component_time[i] = 0;\n    }\n  }\n#endif\n\n  if (is_one_pass_svc(cpi)) {\n    if (cm->show_frame) {\n      ++cpi->svc.spatial_layer_to_encode;\n      if (cpi->svc.spatial_layer_to_encode >= cpi->svc.number_spatial_layers)\n        cpi->svc.spatial_layer_to_encode = 0;\n    }\n  }\n\n  vpx_clear_system_state();\n  return 0;\n}\n\nint vp9_get_preview_raw_frame(VP9_COMP *cpi, YV12_BUFFER_CONFIG *dest,\n                              vp9_ppflags_t *flags) {\n  VP9_COMMON *cm = &cpi->common;\n#if !CONFIG_VP9_POSTPROC\n  (void)flags;\n#endif\n\n  if (!cm->show_frame) {\n    return -1;\n  } else {\n    int ret;\n#if CONFIG_VP9_POSTPROC\n    ret = vp9_post_proc_frame(cm, dest, flags, cpi->un_scaled_source->y_width);\n#else\n    if (cm->frame_to_show) {\n      *dest = *cm->frame_to_show;\n      dest->y_width = cm->width;\n      dest->y_height = cm->height;\n      dest->uv_width = cm->width >> cm->subsampling_x;\n      dest->uv_height = cm->height >> cm->subsampling_y;\n      ret = 0;\n    } else {\n      ret = -1;\n    }\n#endif  // !CONFIG_VP9_POSTPROC\n    vpx_clear_system_state();\n    return ret;\n  }\n}\n\nint vp9_set_internal_size(VP9_COMP *cpi, VPX_SCALING_MODE horiz_mode,\n                          VPX_SCALING_MODE vert_mode) {\n  VP9_COMMON *cm = &cpi->common;\n  int hr = 0, hs = 0, vr = 0, vs = 0;\n\n  if (horiz_mode > VP8E_ONETWO || vert_mode > VP8E_ONETWO) return -1;\n\n  Scale2Ratio(horiz_mode, &hr, &hs);\n  Scale2Ratio(vert_mode, &vr, &vs);\n\n  // always go to the next whole number\n  cm->width = (hs - 1 + cpi->oxcf.width * hr) / hs;\n  cm->height = (vs - 1 + cpi->oxcf.height * vr) / vs;\n  if (cm->current_video_frame) {\n    assert(cm->width <= cpi->initial_width);\n    assert(cm->height <= cpi->initial_height);\n  }\n\n  update_frame_size(cpi);\n\n  return 0;\n}\n\nint vp9_set_size_literal(VP9_COMP *cpi, unsigned int width,\n                         unsigned int height) {\n  VP9_COMMON *cm = &cpi->common;\n#if CONFIG_VP9_HIGHBITDEPTH\n  update_initial_width(cpi, cm->use_highbitdepth, cpi->common.subsampling_x,\n                       cpi->common.subsampling_y);\n#else\n  update_initial_width(cpi, 0, cpi->common.subsampling_x,\n                       cpi->common.subsampling_y);\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n#if CONFIG_VP9_TEMPORAL_DENOISING\n  setup_denoiser_buffer(cpi);\n#endif\n  alloc_raw_frame_buffers(cpi);\n  if (width) {\n    cm->width = width;\n    if (cm->width > cpi->initial_width) {\n      cm->width = cpi->initial_width;\n      printf(\"Warning: Desired width too large, changed to %d\\n\", cm->width);\n    }\n  }\n\n  if (height) {\n    cm->height = height;\n    if (cm->height > cpi->initial_height) {\n      cm->height = cpi->initial_height;\n      printf(\"Warning: Desired height too large, changed to %d\\n\", cm->height);\n    }\n  }\n  assert(cm->width <= cpi->initial_width);\n  assert(cm->height <= cpi->initial_height);\n\n  update_frame_size(cpi);\n\n  return 0;\n}\n\nvoid vp9_set_svc(VP9_COMP *cpi, int use_svc) {\n  cpi->use_svc = use_svc;\n  return;\n}\n\nint vp9_get_quantizer(const VP9_COMP *cpi) { return cpi->common.base_qindex; }\n\nvoid vp9_apply_encoding_flags(VP9_COMP *cpi, vpx_enc_frame_flags_t flags) {\n  if (flags &\n      (VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF)) {\n    int ref = 7;\n\n    if (flags & VP8_EFLAG_NO_REF_LAST) ref ^= VP9_LAST_FLAG;\n\n    if (flags & VP8_EFLAG_NO_REF_GF) ref ^= VP9_GOLD_FLAG;\n\n    if (flags & VP8_EFLAG_NO_REF_ARF) ref ^= VP9_ALT_FLAG;\n\n    vp9_use_as_reference(cpi, ref);\n  }\n\n  if (flags &\n      (VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF |\n       VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF)) {\n    int upd = 7;\n\n    if (flags & VP8_EFLAG_NO_UPD_LAST) upd ^= VP9_LAST_FLAG;\n\n    if (flags & VP8_EFLAG_NO_UPD_GF) upd ^= VP9_GOLD_FLAG;\n\n    if (flags & VP8_EFLAG_NO_UPD_ARF) upd ^= VP9_ALT_FLAG;\n\n    vp9_update_reference(cpi, upd);\n  }\n\n  if (flags & VP8_EFLAG_NO_UPD_ENTROPY) {\n    vp9_update_entropy(cpi, 0);\n  }\n}\n\nvoid vp9_set_row_mt(VP9_COMP *cpi) {\n  // Enable row based multi-threading for supported modes of encoding\n  cpi->row_mt = 0;\n  if (((cpi->oxcf.mode == GOOD || cpi->oxcf.mode == BEST) &&\n       cpi->oxcf.speed < 5 && cpi->oxcf.pass == 1) &&\n      cpi->oxcf.row_mt && !cpi->use_svc)\n    cpi->row_mt = 1;\n\n  if (cpi->oxcf.mode == GOOD && cpi->oxcf.speed < 5 &&\n      (cpi->oxcf.pass == 0 || cpi->oxcf.pass == 2) && cpi->oxcf.row_mt &&\n      !cpi->use_svc)\n    cpi->row_mt = 1;\n\n  // In realtime mode, enable row based multi-threading for all the speed levels\n  // where non-rd path is used.\n  if (cpi->oxcf.mode == REALTIME && cpi->oxcf.speed >= 5 && cpi->oxcf.row_mt) {\n    cpi->row_mt = 1;\n  }\n\n  if (cpi->row_mt)\n    cpi->row_mt_bit_exact = 1;\n  else\n    cpi->row_mt_bit_exact = 0;\n}\n"], "filenames": ["test/resize_test.cc", "vp9/common/vp9_alloccommon.c", "vp9/encoder/vp9_encoder.c"], "buggy_code_start_loc": [105, 138, 2049], "buggy_code_end_loc": [565, 156, 2149], "fixing_code_start_loc": [105, 137, 2050], "fixing_code_end_loc": [560, 156, 2172], "type": "CWE-755", "message": "VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.", "other": {"cve": {"id": "CVE-2023-44488", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-30T20:15:10.200", "lastModified": "2023-11-16T01:37:32.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding."}, {"lang": "es", "value": "VP9 en libvpx anterior a 1.13.1 maneja mal las anchuras, lo que provoca un bloqueo relacionado con la codificaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webmproject:libvpx:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.1", "matchCriteriaId": "385F58CC-4AA0-4C41-9394-C9481586689E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "46D69DCC-AE4D-4EA5-861C-D60951444C6C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/09/30/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2241806", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/webmproject/libvpx/commit/263682c9a29395055f3b3afe2d97be1828a6223f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/webmproject/libvpx/commit/df9fd9d5b7325060b2b921558a1eb20ca7880937", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/webmproject/libvpx/compare/v1.13.0...v1.13.1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/webmproject/libvpx/releases/tag/v1.13.1", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TE7F54W5O5RS4ZMAAC7YK3CZWQXIDSKB/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202310-04", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5518", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/webmproject/libvpx/commit/263682c9a29395055f3b3afe2d97be1828a6223f"}}