{"buggy_code": ["/* Copyright 2014, Kenneth MacKay. Licensed under the BSD 2-clause license. */\n\n#include \"uECC.h\"\n#include \"uECC_vli.h\"\n\n#ifndef uECC_RNG_MAX_TRIES\n    #define uECC_RNG_MAX_TRIES 64\n#endif\n\n#if uECC_ENABLE_VLI_API\n    #define uECC_VLI_API\n#else\n    #define uECC_VLI_API static\n#endif\n\n#define CONCATX(a, ...) a ## __VA_ARGS__\n#define CONCAT(a, ...) CONCATX(a, __VA_ARGS__)\n\n#define STRX(a) #a\n#define STR(a) STRX(a)\n\n#define EVAL(...)  EVAL1(EVAL1(EVAL1(EVAL1(__VA_ARGS__))))\n#define EVAL1(...) EVAL2(EVAL2(EVAL2(EVAL2(__VA_ARGS__))))\n#define EVAL2(...) EVAL3(EVAL3(EVAL3(EVAL3(__VA_ARGS__))))\n#define EVAL3(...) EVAL4(EVAL4(EVAL4(EVAL4(__VA_ARGS__))))\n#define EVAL4(...) __VA_ARGS__\n\n#define DEC_1  0\n#define DEC_2  1\n#define DEC_3  2\n#define DEC_4  3\n#define DEC_5  4\n#define DEC_6  5\n#define DEC_7  6\n#define DEC_8  7\n#define DEC_9  8\n#define DEC_10 9\n#define DEC_11 10\n#define DEC_12 11\n#define DEC_13 12\n#define DEC_14 13\n#define DEC_15 14\n#define DEC_16 15\n#define DEC_17 16\n#define DEC_18 17\n#define DEC_19 18\n#define DEC_20 19\n#define DEC_21 20\n#define DEC_22 21\n#define DEC_23 22\n#define DEC_24 23\n#define DEC_25 24\n#define DEC_26 25\n#define DEC_27 26\n#define DEC_28 27\n#define DEC_29 28\n#define DEC_30 29\n#define DEC_31 30\n#define DEC_32 31\n\n#define DEC(N) CONCAT(DEC_, N)\n\n#define SECOND_ARG(_, val, ...) val\n#define SOME_CHECK_0 ~, 0\n#define GET_SECOND_ARG(...) SECOND_ARG(__VA_ARGS__, SOME,)\n#define SOME_OR_0(N) GET_SECOND_ARG(CONCAT(SOME_CHECK_, N))\n\n#define EMPTY(...)\n#define DEFER(...) __VA_ARGS__ EMPTY()\n\n#define REPEAT_NAME_0() REPEAT_0\n#define REPEAT_NAME_SOME() REPEAT_SOME\n#define REPEAT_0(...)\n#define REPEAT_SOME(N, stuff) DEFER(CONCAT(REPEAT_NAME_, SOME_OR_0(DEC(N))))()(DEC(N), stuff) stuff\n#define REPEAT(N, stuff) EVAL(REPEAT_SOME(N, stuff))\n\n#define REPEATM_NAME_0() REPEATM_0\n#define REPEATM_NAME_SOME() REPEATM_SOME\n#define REPEATM_0(...)\n#define REPEATM_SOME(N, macro) macro(N) \\\n    DEFER(CONCAT(REPEATM_NAME_, SOME_OR_0(DEC(N))))()(DEC(N), macro)\n#define REPEATM(N, macro) EVAL(REPEATM_SOME(N, macro))\n\n#include \"platform-specific.inc\"\n\n#if (uECC_WORD_SIZE == 1)\n    #if uECC_SUPPORTS_secp160r1\n        #define uECC_MAX_WORDS 21 /* Due to the size of curve_n. */\n    #endif\n    #if uECC_SUPPORTS_secp192r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 24\n    #endif\n    #if uECC_SUPPORTS_secp224r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 28\n    #endif\n    #if (uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1)\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 32\n    #endif\n#elif (uECC_WORD_SIZE == 4)\n    #if uECC_SUPPORTS_secp160r1\n        #define uECC_MAX_WORDS 6 /* Due to the size of curve_n. */\n    #endif\n    #if uECC_SUPPORTS_secp192r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 6\n    #endif\n    #if uECC_SUPPORTS_secp224r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 7\n    #endif\n    #if (uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1)\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 8\n    #endif\n#elif (uECC_WORD_SIZE == 8)\n    #if uECC_SUPPORTS_secp160r1\n        #define uECC_MAX_WORDS 3\n    #endif\n    #if uECC_SUPPORTS_secp192r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 3\n    #endif\n    #if uECC_SUPPORTS_secp224r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 4\n    #endif\n    #if (uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1)\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 4\n    #endif\n#endif /* uECC_WORD_SIZE */\n\n#define BITS_TO_WORDS(num_bits) ((num_bits + ((uECC_WORD_SIZE * 8) - 1)) / (uECC_WORD_SIZE * 8))\n#define BITS_TO_BYTES(num_bits) ((num_bits + 7) / 8)\n\nstruct uECC_Curve_t {\n    wordcount_t num_words;\n    wordcount_t num_bytes;\n    bitcount_t num_n_bits;\n    uECC_word_t p[uECC_MAX_WORDS];\n    uECC_word_t n[uECC_MAX_WORDS];\n    uECC_word_t G[uECC_MAX_WORDS * 2];\n    uECC_word_t b[uECC_MAX_WORDS];\n    void (*double_jacobian)(uECC_word_t * X1,\n                            uECC_word_t * Y1,\n                            uECC_word_t * Z1,\n                            uECC_Curve curve);\n#if uECC_SUPPORT_COMPRESSED_POINT\n    void (*mod_sqrt)(uECC_word_t *a, uECC_Curve curve);\n#endif\n    void (*x_side)(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve);\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    void (*mmod_fast)(uECC_word_t *result, uECC_word_t *product);\n#endif\n};\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\nstatic void bcopy(uint8_t *dst,\n                  const uint8_t *src,\n                  unsigned num_bytes) {\n    while (0 != num_bytes) {\n        num_bytes--;\n        dst[num_bytes] = src[num_bytes];\n    }\n}\n#endif\n\nstatic cmpresult_t uECC_vli_cmp_unsafe(const uECC_word_t *left,\n                                       const uECC_word_t *right,\n                                       wordcount_t num_words);\n\n#if (uECC_PLATFORM == uECC_arm || uECC_PLATFORM == uECC_arm_thumb || \\\n        uECC_PLATFORM == uECC_arm_thumb2)\n    #include \"asm_arm.inc\"\n#endif\n\n#if (uECC_PLATFORM == uECC_avr)\n    #include \"asm_avr.inc\"\n#endif\n\n#if default_RNG_defined\nstatic uECC_RNG_Function g_rng_function = &default_RNG;\n#else\nstatic uECC_RNG_Function g_rng_function = 0;\n#endif\n\nvoid uECC_set_rng(uECC_RNG_Function rng_function) {\n    g_rng_function = rng_function;\n}\n\nuECC_RNG_Function uECC_get_rng(void) {\n    return g_rng_function;\n}\n\nint uECC_curve_private_key_size(uECC_Curve curve) {\n    return BITS_TO_BYTES(curve->num_n_bits);\n}\n\nint uECC_curve_public_key_size(uECC_Curve curve) {\n    return 2 * curve->num_bytes;\n}\n\n#if !asm_clear\nuECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) {\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        vli[i] = 0;\n    }\n}\n#endif /* !asm_clear */\n\n/* Constant-time comparison to zero - secure way to compare long integers */\n/* Returns 1 if vli == 0, 0 otherwise. */\nuECC_VLI_API uECC_word_t uECC_vli_isZero(const uECC_word_t *vli, wordcount_t num_words) {\n    uECC_word_t bits = 0;\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        bits |= vli[i];\n    }\n    return (bits == 0);\n}\n\n/* Returns nonzero if bit 'bit' of vli is set. */\nuECC_VLI_API uECC_word_t uECC_vli_testBit(const uECC_word_t *vli, bitcount_t bit) {\n    return (vli[bit >> uECC_WORD_BITS_SHIFT] & ((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));\n}\n\n/* Counts the number of words in vli. */\nstatic wordcount_t vli_numDigits(const uECC_word_t *vli, const wordcount_t max_words) {\n    wordcount_t i;\n    /* Search from the end until we find a non-zero digit.\n       We do it in reverse because we expect that most digits will be nonzero. */\n    for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {\n    }\n\n    return (i + 1);\n}\n\n/* Counts the number of bits required to represent vli. */\nuECC_VLI_API bitcount_t uECC_vli_numBits(const uECC_word_t *vli, const wordcount_t max_words) {\n    uECC_word_t i;\n    uECC_word_t digit;\n\n    wordcount_t num_digits = vli_numDigits(vli, max_words);\n    if (num_digits == 0) {\n        return 0;\n    }\n\n    digit = vli[num_digits - 1];\n    for (i = 0; digit; ++i) {\n        digit >>= 1;\n    }\n\n    return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);\n}\n\n/* Sets dest = src. */\n#if !asm_set\nuECC_VLI_API void uECC_vli_set(uECC_word_t *dest, const uECC_word_t *src, wordcount_t num_words) {\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        dest[i] = src[i];\n    }\n}\n#endif /* !asm_set */\n\n/* Returns sign of left - right. */\nstatic cmpresult_t uECC_vli_cmp_unsafe(const uECC_word_t *left,\n                                       const uECC_word_t *right,\n                                       wordcount_t num_words) {\n    wordcount_t i;\n    for (i = num_words - 1; i >= 0; --i) {\n        if (left[i] > right[i]) {\n            return 1;\n        } else if (left[i] < right[i]) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\n/* Constant-time comparison function - secure way to compare long integers */\n/* Returns one if left == right, zero otherwise. */\nuECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,\n                                        const uECC_word_t *right,\n                                        wordcount_t num_words) {\n    uECC_word_t diff = 0;\n    wordcount_t i;\n    for (i = num_words - 1; i >= 0; --i) {\n        diff |= (left[i] ^ right[i]);\n    }\n    return (diff == 0);\n}\n\nuECC_VLI_API uECC_word_t uECC_vli_sub(uECC_word_t *result,\n                                      const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words);\n\n/* Returns sign of left - right, in constant time. */\nuECC_VLI_API cmpresult_t uECC_vli_cmp(const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words) {\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);\n    uECC_word_t equal = uECC_vli_isZero(tmp, num_words);\n    return (!equal - 2 * neg);\n}\n\n/* Computes vli = vli >> 1. */\n#if !asm_rshift1\nuECC_VLI_API void uECC_vli_rshift1(uECC_word_t *vli, wordcount_t num_words) {\n    uECC_word_t *end = vli;\n    uECC_word_t carry = 0;\n\n    vli += num_words;\n    while (vli-- > end) {\n        uECC_word_t temp = *vli;\n        *vli = (temp >> 1) | carry;\n        carry = temp << (uECC_WORD_BITS - 1);\n    }\n}\n#endif /* !asm_rshift1 */\n\n/* Computes result = left + right, returning carry. Can modify in place. */\n#if !asm_add\nuECC_VLI_API uECC_word_t uECC_vli_add(uECC_word_t *result,\n                                      const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words) {\n    uECC_word_t carry = 0;\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        uECC_word_t sum = left[i] + right[i] + carry;\n        if (sum != left[i]) {\n            carry = (sum < left[i]);\n        }\n        result[i] = sum;\n    }\n    return carry;\n}\n#endif /* !asm_add */\n\n/* Computes result = left - right, returning borrow. Can modify in place. */\n#if !asm_sub\nuECC_VLI_API uECC_word_t uECC_vli_sub(uECC_word_t *result,\n                                      const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words) {\n    uECC_word_t borrow = 0;\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        uECC_word_t diff = left[i] - right[i] - borrow;\n        if (diff != left[i]) {\n            borrow = (diff > left[i]);\n        }\n        result[i] = diff;\n    }\n    return borrow;\n}\n#endif /* !asm_sub */\n\n#if !asm_mult || (uECC_SQUARE_FUNC && !asm_square) || \\\n    (uECC_SUPPORTS_secp256k1 && (uECC_OPTIMIZATION_LEVEL > 0) && \\\n        ((uECC_WORD_SIZE == 1) || (uECC_WORD_SIZE == 8)))\nstatic void muladd(uECC_word_t a,\n                   uECC_word_t b,\n                   uECC_word_t *r0,\n                   uECC_word_t *r1,\n                   uECC_word_t *r2) {\n#if uECC_WORD_SIZE == 8 && !SUPPORTS_INT128\n    uint64_t a0 = a & 0xffffffffull;\n    uint64_t a1 = a >> 32;\n    uint64_t b0 = b & 0xffffffffull;\n    uint64_t b1 = b >> 32;\n\n    uint64_t i0 = a0 * b0;\n    uint64_t i1 = a0 * b1;\n    uint64_t i2 = a1 * b0;\n    uint64_t i3 = a1 * b1;\n\n    uint64_t p0, p1;\n\n    i2 += (i0 >> 32);\n    i2 += i1;\n    if (i2 < i1) { /* overflow */\n        i3 += 0x100000000ull;\n    }\n\n    p0 = (i0 & 0xffffffffull) | (i2 << 32);\n    p1 = i3 + (i2 >> 32);\n\n    *r0 += p0;\n    *r1 += (p1 + (*r0 < p0));\n    *r2 += ((*r1 < p1) || (*r1 == p1 && *r0 < p0));\n#else\n    uECC_dword_t p = (uECC_dword_t)a * b;\n    uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;\n    r01 += p;\n    *r2 += (r01 < p);\n    *r1 = r01 >> uECC_WORD_BITS;\n    *r0 = (uECC_word_t)r01;\n#endif\n}\n#endif /* muladd needed */\n\n#if !asm_mult\nuECC_VLI_API void uECC_vli_mult(uECC_word_t *result,\n                                const uECC_word_t *left,\n                                const uECC_word_t *right,\n                                wordcount_t num_words) {\n    uECC_word_t r0 = 0;\n    uECC_word_t r1 = 0;\n    uECC_word_t r2 = 0;\n    wordcount_t i, k;\n\n    /* Compute each digit of result in sequence, maintaining the carries. */\n    for (k = 0; k < num_words; ++k) {\n        for (i = 0; i <= k; ++i) {\n            muladd(left[i], right[k - i], &r0, &r1, &r2);\n        }\n        result[k] = r0;\n        r0 = r1;\n        r1 = r2;\n        r2 = 0;\n    }\n    for (k = num_words; k < num_words * 2 - 1; ++k) {\n        for (i = (k + 1) - num_words; i < num_words; ++i) {\n            muladd(left[i], right[k - i], &r0, &r1, &r2);\n        }\n        result[k] = r0;\n        r0 = r1;\n        r1 = r2;\n        r2 = 0;\n    }\n    result[num_words * 2 - 1] = r0;\n}\n#endif /* !asm_mult */\n\n#if uECC_SQUARE_FUNC\n\n#if !asm_square\nstatic void mul2add(uECC_word_t a,\n                    uECC_word_t b,\n                    uECC_word_t *r0,\n                    uECC_word_t *r1,\n                    uECC_word_t *r2) {\n#if uECC_WORD_SIZE == 8 && !SUPPORTS_INT128\n    uint64_t a0 = a & 0xffffffffull;\n    uint64_t a1 = a >> 32;\n    uint64_t b0 = b & 0xffffffffull;\n    uint64_t b1 = b >> 32;\n\n    uint64_t i0 = a0 * b0;\n    uint64_t i1 = a0 * b1;\n    uint64_t i2 = a1 * b0;\n    uint64_t i3 = a1 * b1;\n\n    uint64_t p0, p1;\n\n    i2 += (i0 >> 32);\n    i2 += i1;\n    if (i2 < i1)\n    { /* overflow */\n        i3 += 0x100000000ull;\n    }\n\n    p0 = (i0 & 0xffffffffull) | (i2 << 32);\n    p1 = i3 + (i2 >> 32);\n\n    *r2 += (p1 >> 63);\n    p1 = (p1 << 1) | (p0 >> 63);\n    p0 <<= 1;\n\n    *r0 += p0;\n    *r1 += (p1 + (*r0 < p0));\n    *r2 += ((*r1 < p1) || (*r1 == p1 && *r0 < p0));\n#else\n    uECC_dword_t p = (uECC_dword_t)a * b;\n    uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;\n    *r2 += (p >> (uECC_WORD_BITS * 2 - 1));\n    p *= 2;\n    r01 += p;\n    *r2 += (r01 < p);\n    *r1 = r01 >> uECC_WORD_BITS;\n    *r0 = (uECC_word_t)r01;\n#endif\n}\n\nuECC_VLI_API void uECC_vli_square(uECC_word_t *result,\n                                  const uECC_word_t *left,\n                                  wordcount_t num_words) {\n    uECC_word_t r0 = 0;\n    uECC_word_t r1 = 0;\n    uECC_word_t r2 = 0;\n\n    wordcount_t i, k;\n\n    for (k = 0; k < num_words * 2 - 1; ++k) {\n        uECC_word_t min = (k < num_words ? 0 : (k + 1) - num_words);\n        for (i = min; i <= k && i <= k - i; ++i) {\n            if (i < k-i) {\n                mul2add(left[i], left[k - i], &r0, &r1, &r2);\n            } else {\n                muladd(left[i], left[k - i], &r0, &r1, &r2);\n            }\n        }\n        result[k] = r0;\n        r0 = r1;\n        r1 = r2;\n        r2 = 0;\n    }\n\n    result[num_words * 2 - 1] = r0;\n}\n#endif /* !asm_square */\n\n#else /* uECC_SQUARE_FUNC */\n\n#if uECC_ENABLE_VLI_API\nuECC_VLI_API void uECC_vli_square(uECC_word_t *result,\n                                  const uECC_word_t *left,\n                                  wordcount_t num_words) {\n    uECC_vli_mult(result, left, left, num_words);\n}\n#endif /* uECC_ENABLE_VLI_API */\n\n#endif /* uECC_SQUARE_FUNC */\n\n/* Computes result = (left + right) % mod.\n   Assumes that left < mod and right < mod, and that result does not overlap mod. */\nuECC_VLI_API void uECC_vli_modAdd(uECC_word_t *result,\n                                  const uECC_word_t *left,\n                                  const uECC_word_t *right,\n                                  const uECC_word_t *mod,\n                                  wordcount_t num_words) {\n    uECC_word_t carry = uECC_vli_add(result, left, right, num_words);\n    if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {\n        /* result > mod (result = mod + remainder), so subtract mod to get remainder. */\n        uECC_vli_sub(result, result, mod, num_words);\n    }\n}\n\n/* Computes result = (left - right) % mod.\n   Assumes that left < mod and right < mod, and that result does not overlap mod. */\nuECC_VLI_API void uECC_vli_modSub(uECC_word_t *result,\n                                  const uECC_word_t *left,\n                                  const uECC_word_t *right,\n                                  const uECC_word_t *mod,\n                                  wordcount_t num_words) {\n    uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);\n    if (l_borrow) {\n        /* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,\n           we can get the correct result from result + mod (with overflow). */\n        uECC_vli_add(result, result, mod, num_words);\n    }\n}\n\n/* Computes result = product % mod, where product is 2N words long. */\n/* Currently only designed to work for curve_p or curve_n. */\nuECC_VLI_API void uECC_vli_mmod(uECC_word_t *result,\n                                uECC_word_t *product,\n                                const uECC_word_t *mod,\n                                wordcount_t num_words) {\n    uECC_word_t mod_multiple[2 * uECC_MAX_WORDS];\n    uECC_word_t tmp[2 * uECC_MAX_WORDS];\n    uECC_word_t *v[2] = {tmp, product};\n    uECC_word_t index;\n\n    /* Shift mod so its highest set bit is at the maximum position. */\n    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);\n    wordcount_t word_shift = shift / uECC_WORD_BITS;\n    wordcount_t bit_shift = shift % uECC_WORD_BITS;\n    uECC_word_t carry = 0;\n    uECC_vli_clear(mod_multiple, word_shift);\n    if (bit_shift > 0) {\n        for(index = 0; index < (uECC_word_t)num_words; ++index) {\n            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;\n            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);\n        }\n    } else {\n        uECC_vli_set(mod_multiple + word_shift, mod, num_words);\n    }\n\n    for (index = 1; shift >= 0; --shift) {\n        uECC_word_t borrow = 0;\n        wordcount_t i;\n        for (i = 0; i < num_words * 2; ++i) {\n            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;\n            if (diff != v[index][i]) {\n                borrow = (diff > v[index][i]);\n            }\n            v[1 - index][i] = diff;\n        }\n        index = !(index ^ borrow); /* Swap the index if there was no borrow */\n        uECC_vli_rshift1(mod_multiple, num_words);\n        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);\n        uECC_vli_rshift1(mod_multiple + num_words, num_words);\n    }\n    uECC_vli_set(result, v[index], num_words);\n}\n\n/* Computes result = (left * right) % mod. */\nuECC_VLI_API void uECC_vli_modMult(uECC_word_t *result,\n                                   const uECC_word_t *left,\n                                   const uECC_word_t *right,\n                                   const uECC_word_t *mod,\n                                   wordcount_t num_words) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_mult(product, left, right, num_words);\n    uECC_vli_mmod(result, product, mod, num_words);\n}\n\nuECC_VLI_API void uECC_vli_modMult_fast(uECC_word_t *result,\n                                        const uECC_word_t *left,\n                                        const uECC_word_t *right,\n                                        uECC_Curve curve) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_mult(product, left, right, curve->num_words);\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    curve->mmod_fast(result, product);\n#else\n    uECC_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}\n\n#if uECC_SQUARE_FUNC\n\n#if uECC_ENABLE_VLI_API\n/* Computes result = left^2 % mod. */\nuECC_VLI_API void uECC_vli_modSquare(uECC_word_t *result,\n                                     const uECC_word_t *left,\n                                     const uECC_word_t *mod,\n                                     wordcount_t num_words) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_square(product, left, num_words);\n    uECC_vli_mmod(result, product, mod, num_words);\n}\n#endif /* uECC_ENABLE_VLI_API */\n\nuECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,\n                                          const uECC_word_t *left,\n                                          uECC_Curve curve) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_square(product, left, curve->num_words);\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    curve->mmod_fast(result, product);\n#else\n    uECC_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}\n\n#else /* uECC_SQUARE_FUNC */\n\n#if uECC_ENABLE_VLI_API\nuECC_VLI_API void uECC_vli_modSquare(uECC_word_t *result,\n                                     const uECC_word_t *left,\n                                     const uECC_word_t *mod,\n                                     wordcount_t num_words) {\n    uECC_vli_modMult(result, left, left, mod, num_words);\n}\n#endif /* uECC_ENABLE_VLI_API */\n\nuECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,\n                                          const uECC_word_t *left,\n                                          uECC_Curve curve) {\n    uECC_vli_modMult_fast(result, left, left, curve);\n}\n\n#endif /* uECC_SQUARE_FUNC */\n\n#define EVEN(vli) (!(vli[0] & 1))\nstatic void vli_modInv_update(uECC_word_t *uv,\n                              const uECC_word_t *mod,\n                              wordcount_t num_words) {\n    uECC_word_t carry = 0;\n    if (!EVEN(uv)) {\n        carry = uECC_vli_add(uv, uv, mod, num_words);\n    }\n    uECC_vli_rshift1(uv, num_words);\n    if (carry) {\n        uv[num_words - 1] |= HIGH_BIT_SET;\n    }\n}\n\n/* Computes result = (1 / input) % mod. All VLIs are the same size.\n   See \"From Euclid's GCD to Montgomery Multiplication to the Great Divide\" */\nuECC_VLI_API void uECC_vli_modInv(uECC_word_t *result,\n                                  const uECC_word_t *input,\n                                  const uECC_word_t *mod,\n                                  wordcount_t num_words) {\n    uECC_word_t a[uECC_MAX_WORDS], b[uECC_MAX_WORDS], u[uECC_MAX_WORDS], v[uECC_MAX_WORDS];\n    cmpresult_t cmpResult;\n\n    if (uECC_vli_isZero(input, num_words)) {\n        uECC_vli_clear(result, num_words);\n        return;\n    }\n\n    uECC_vli_set(a, input, num_words);\n    uECC_vli_set(b, mod, num_words);\n    uECC_vli_clear(u, num_words);\n    u[0] = 1;\n    uECC_vli_clear(v, num_words);\n    while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {\n        if (EVEN(a)) {\n            uECC_vli_rshift1(a, num_words);\n            vli_modInv_update(u, mod, num_words);\n        } else if (EVEN(b)) {\n            uECC_vli_rshift1(b, num_words);\n            vli_modInv_update(v, mod, num_words);\n        } else if (cmpResult > 0) {\n            uECC_vli_sub(a, a, b, num_words);\n            uECC_vli_rshift1(a, num_words);\n            if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {\n                uECC_vli_add(u, u, mod, num_words);\n            }\n            uECC_vli_sub(u, u, v, num_words);\n            vli_modInv_update(u, mod, num_words);\n        } else {\n            uECC_vli_sub(b, b, a, num_words);\n            uECC_vli_rshift1(b, num_words);\n            if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {\n                uECC_vli_add(v, v, mod, num_words);\n            }\n            uECC_vli_sub(v, v, u, num_words);\n            vli_modInv_update(v, mod, num_words);\n        }\n    }\n    uECC_vli_set(result, u, num_words);\n}\n\n/* ------ Point operations ------ */\n\n#include \"curve-specific.inc\"\n\n/* Returns 1 if 'point' is the point at infinity, 0 otherwise. */\n#define EccPoint_isZero(point, curve) uECC_vli_isZero((point), (curve)->num_words * 2)\n\n/* Point multiplication algorithm using Montgomery's ladder with co-Z coordinates.\nFrom http://eprint.iacr.org/2011/338.pdf\n*/\n\n/* Modify (x1, y1) => (x1 * z^2, y1 * z^3) */\nstatic void apply_z(uECC_word_t * X1,\n                    uECC_word_t * Y1,\n                    const uECC_word_t * const Z,\n                    uECC_Curve curve) {\n    uECC_word_t t1[uECC_MAX_WORDS];\n\n    uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */\n    uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */\n    uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */\n    uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */\n}\n\n/* P = (x1, y1) => 2P, (x2, y2) => P' */\nstatic void XYcZ_initial_double(uECC_word_t * X1,\n                                uECC_word_t * Y1,\n                                uECC_word_t * X2,\n                                uECC_word_t * Y2,\n                                const uECC_word_t * const initial_Z,\n                                uECC_Curve curve) {\n    uECC_word_t z[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n    if (initial_Z) {\n        uECC_vli_set(z, initial_Z, num_words);\n    } else {\n        uECC_vli_clear(z, num_words);\n        z[0] = 1;\n    }\n\n    uECC_vli_set(X2, X1, num_words);\n    uECC_vli_set(Y2, Y1, num_words);\n\n    apply_z(X1, Y1, z, curve);\n    curve->double_jacobian(X1, Y1, z, curve);\n    apply_z(X2, Y2, z, curve);\n}\n\n/* Input P = (x1, y1, Z), Q = (x2, y2, Z)\n   Output P' = (x1', y1', Z3), P + Q = (x3, y3, Z3)\n   or P => P', Q => P + Q\n*/\nstatic void XYcZ_add(uECC_word_t * X1,\n                     uECC_word_t * Y1,\n                     uECC_word_t * X2,\n                     uECC_word_t * Y2,\n                     uECC_Curve curve) {\n    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */\n    uECC_word_t t5[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n\n    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */\n    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */\n    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */\n    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */\n    uECC_vli_modSquare_fast(t5, Y2, curve);                  /* t5 = (y2 - y1)^2 = D */\n\n    uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */\n    uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */\n    uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */\n    uECC_vli_modMult_fast(Y1, Y1, X2, curve);                /* t2 = y1*(C - B) */\n    uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */\n    uECC_vli_modMult_fast(Y2, Y2, X2, curve);                /* t4 = (y2 - y1)*(B - x3) */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */\n\n    uECC_vli_set(X2, t5, num_words);\n}\n\n/* Input P = (x1, y1, Z), Q = (x2, y2, Z)\n   Output P + Q = (x3, y3, Z3), P - Q = (x3', y3', Z3)\n   or P => P - Q, Q => P + Q\n*/\nstatic void XYcZ_addC(uECC_word_t * X1,\n                      uECC_word_t * Y1,\n                      uECC_word_t * X2,\n                      uECC_word_t * Y2,\n                      uECC_Curve curve) {\n    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */\n    uECC_word_t t5[uECC_MAX_WORDS];\n    uECC_word_t t6[uECC_MAX_WORDS];\n    uECC_word_t t7[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n\n    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */\n    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */\n    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */\n    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */\n    uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */\n\n    uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */\n    uECC_vli_modMult_fast(Y1, Y1, t6, curve);                /* t2 = y1 * (C - B) = E */\n    uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */\n    uECC_vli_modSquare_fast(X2, Y2, curve);                  /* t3 = (y2 - y1)^2 = D */\n    uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */\n\n    uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */\n    uECC_vli_modMult_fast(Y2, Y2, t7, curve);                /* t4 = (y2 - y1)*(B - x3) */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = (y2 - y1)*(B - x3) - E = y3 */\n\n    uECC_vli_modSquare_fast(t7, t5, curve);                  /* t7 = (y2 + y1)^2 = F */\n    uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */\n    uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */\n    uECC_vli_modMult_fast(t6, t6, t5, curve);                /* t6 = (y2+y1)*(x3' - B) */\n    uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words); /* t2 = (y2+y1)*(x3' - B) - E = y3' */\n\n    uECC_vli_set(X1, t7, num_words);\n}\n\n/* result may overlap point. */\nstatic void EccPoint_mult(uECC_word_t * result,\n                          const uECC_word_t * point,\n                          const uECC_word_t * scalar,\n                          const uECC_word_t * initial_Z,\n                          bitcount_t num_bits,\n                          uECC_Curve curve) {\n    /* R0 and R1 */\n    uECC_word_t Rx[2][uECC_MAX_WORDS];\n    uECC_word_t Ry[2][uECC_MAX_WORDS];\n    uECC_word_t z[uECC_MAX_WORDS];\n    bitcount_t i;\n    uECC_word_t nb;\n    wordcount_t num_words = curve->num_words;\n\n    uECC_vli_set(Rx[1], point, num_words);\n    uECC_vli_set(Ry[1], point + num_words, num_words);\n\n    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);\n\n    for (i = num_bits - 2; i > 0; --i) {\n        nb = !uECC_vli_testBit(scalar, i);\n        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);\n        XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);\n    }\n\n    nb = !uECC_vli_testBit(scalar, 0);\n    XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);\n\n    /* Find final 1/Z value. */\n    uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */\n    uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve);               /* Yb * (X1 - X0) */\n    uECC_vli_modMult_fast(z, z, point, curve);                    /* xP * Yb * (X1 - X0) */\n    uECC_vli_modInv(z, z, curve->p, num_words);            /* 1 / (xP * Yb * (X1 - X0)) */\n    /* yP / (xP * Yb * (X1 - X0)) */\n    uECC_vli_modMult_fast(z, z, point + num_words, curve);\n    uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve); /* Xb * yP / (xP * Yb * (X1 - X0)) */\n    /* End 1/Z calculation */\n\n    XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);\n    apply_z(Rx[0], Ry[0], z, curve);\n\n    uECC_vli_set(result, Rx[0], num_words);\n    uECC_vli_set(result + num_words, Ry[0], num_words);\n}\n\nstatic uECC_word_t regularize_k(const uECC_word_t * const k,\n                                uECC_word_t *k0,\n                                uECC_word_t *k1,\n                                uECC_Curve curve) {\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||\n        (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&\n         uECC_vli_testBit(k0, num_n_bits));\n    uECC_vli_add(k1, k0, curve->n, num_n_words);\n    return carry;\n}\n\nstatic uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,\n                                               uECC_word_t *private_key,\n                                               uECC_Curve curve) {\n    uECC_word_t tmp1[uECC_MAX_WORDS];\n    uECC_word_t tmp2[uECC_MAX_WORDS];\n    uECC_word_t *p2[2] = {tmp1, tmp2};\n    uECC_word_t carry;\n\n    /* Regularize the bitcount for the private key so that attackers cannot use a side channel\n       attack to learn the number of leading zeros. */\n    carry = regularize_k(private_key, tmp1, tmp2, curve);\n\n    EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);\n\n    if (EccPoint_isZero(result, curve)) {\n        return 0;\n    }\n    return 1;\n}\n\n#if uECC_WORD_SIZE == 1\n\nuECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes,\n                                         int num_bytes,\n                                         const uint8_t *native) {\n    wordcount_t i;\n    for (i = 0; i < num_bytes; ++i) {\n        bytes[i] = native[(num_bytes - 1) - i];\n    }\n}\n\nuECC_VLI_API void uECC_vli_bytesToNative(uint8_t *native,\n                                         const uint8_t *bytes,\n                                         int num_bytes) {\n    uECC_vli_nativeToBytes(native, num_bytes, bytes);\n}\n\n#else\n\nuECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes,\n                                         int num_bytes,\n                                         const uECC_word_t *native) {\n    wordcount_t i;\n    for (i = 0; i < num_bytes; ++i) {\n        unsigned b = num_bytes - 1 - i;\n        bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));\n    }\n}\n\nuECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,\n                                         const uint8_t *bytes,\n                                         int num_bytes) {\n    wordcount_t i;\n    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);\n    for (i = 0; i < num_bytes; ++i) {\n        unsigned b = num_bytes - 1 - i;\n        native[b / uECC_WORD_SIZE] |=\n            (uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));\n    }\n}\n\n#endif /* uECC_WORD_SIZE */\n\n/* Generates a random integer in the range 0 < random < top.\n   Both random and top have num_words words. */\nuECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,\n                                          const uECC_word_t *top,\n                                          wordcount_t num_words) {\n    uECC_word_t mask = (uECC_word_t)-1;\n    uECC_word_t tries;\n    bitcount_t num_bits = uECC_vli_numBits(top, num_words);\n\n    if (!g_rng_function) {\n        return 0;\n    }\n\n    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {\n        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {\n            return 0;\n\t    }\n        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));\n        if (!uECC_vli_isZero(random, num_words) &&\n\t\t        uECC_vli_cmp(top, random, num_words) == 1) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint uECC_make_key(uint8_t *public_key,\n                  uint8_t *private_key,\n                  uECC_Curve curve) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *_private = (uECC_word_t *)private_key;\n    uECC_word_t *_public = (uECC_word_t *)public_key;\n#else\n    uECC_word_t _private[uECC_MAX_WORDS];\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t tries;\n\n    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {\n        if (!uECC_generate_random_int(_private, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {\n            return 0;\n        }\n\n        if (EccPoint_compute_public_key(_public, _private, curve)) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n            uECC_vli_nativeToBytes(private_key, BITS_TO_BYTES(curve->num_n_bits), _private);\n            uECC_vli_nativeToBytes(public_key, curve->num_bytes, _public);\n            uECC_vli_nativeToBytes(\n                public_key + curve->num_bytes, curve->num_bytes, _public + curve->num_words);\n#endif\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint uECC_shared_secret(const uint8_t *public_key,\n                       const uint8_t *private_key,\n                       uint8_t *secret,\n                       uECC_Curve curve) {\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n    uECC_word_t _private[uECC_MAX_WORDS];\n\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t *p2[2] = {_private, tmp};\n    uECC_word_t *initial_Z = 0;\n    uECC_word_t carry;\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_bytes = curve->num_bytes;\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) _private, private_key, num_bytes);\n    bcopy((uint8_t *) _public, public_key, num_bytes*2);\n#else\n    uECC_vli_bytesToNative(_private, private_key, BITS_TO_BYTES(curve->num_n_bits));\n    uECC_vli_bytesToNative(_public, public_key, num_bytes);\n    uECC_vli_bytesToNative(_public + num_words, public_key + num_bytes, num_bytes);\n#endif\n\n    /* Regularize the bitcount for the private key so that attackers cannot use a side channel\n       attack to learn the number of leading zeros. */\n    carry = regularize_k(_private, _private, tmp, curve);\n\n    /* If an RNG function was specified, try to get a random initial Z value to improve\n       protection against side-channel attacks. */\n    if (g_rng_function) {\n        if (!uECC_generate_random_int(p2[carry], curve->p, num_words)) {\n            return 0;\n        }\n        initial_Z = p2[carry];\n    }\n\n    EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1, curve);\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) secret, (uint8_t *) _public, num_bytes);\n#else\n    uECC_vli_nativeToBytes(secret, num_bytes, _public);\n#endif\n    return !EccPoint_isZero(_public, curve);\n}\n\n#if uECC_SUPPORT_COMPRESSED_POINT\nvoid uECC_compress(const uint8_t *public_key, uint8_t *compressed, uECC_Curve curve) {\n    wordcount_t i;\n    for (i = 0; i < curve->num_bytes; ++i) {\n        compressed[i+1] = public_key[i];\n    }\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    compressed[0] = 2 + (public_key[curve->num_bytes] & 0x01);\n#else\n    compressed[0] = 2 + (public_key[curve->num_bytes * 2 - 1] & 0x01);\n#endif\n}\n\nvoid uECC_decompress(const uint8_t *compressed, uint8_t *public_key, uECC_Curve curve) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *point = (uECC_word_t *)public_key;\n#else\n    uECC_word_t point[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t *y = point + curve->num_words;\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy(public_key, compressed+1, curve->num_bytes);\n#else\n    uECC_vli_bytesToNative(point, compressed + 1, curve->num_bytes);\n#endif\n    curve->x_side(y, point, curve);\n    curve->mod_sqrt(y, curve);\n\n    if ((y[0] & 0x01) != (compressed[0] & 0x01)) {\n        uECC_vli_sub(y, curve->p, y, curve->num_words);\n    }\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(public_key, curve->num_bytes, point);\n    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);\n#endif\n}\n#endif /* uECC_SUPPORT_COMPRESSED_POINT */\n\nuECC_VLI_API int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {\n    uECC_word_t tmp1[uECC_MAX_WORDS];\n    uECC_word_t tmp2[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n\n    /* The point at infinity is invalid. */\n    if (EccPoint_isZero(point, curve)) {\n        return 0;\n    }\n\n    /* x and y must be smaller than p. */\n    if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||\n            uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {\n        return 0;\n    }\n\n    uECC_vli_modSquare_fast(tmp1, point + num_words, curve);\n    curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */\n\n    /* Make sure that y^2 == x^3 + ax + b */\n    return (int)(uECC_vli_equal(tmp1, tmp2, num_words));\n}\n\nint uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *_public = (uECC_word_t *)public_key;\n#else\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);\n    uECC_vli_bytesToNative(\n        _public + curve->num_words, public_key + curve->num_bytes, curve->num_bytes);\n#endif\n    return uECC_valid_point(_public, curve);\n}\n\nint uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *_private = (uECC_word_t *)private_key;\n    uECC_word_t *_public = (uECC_word_t *)public_key;\n#else\n    uECC_word_t _private[uECC_MAX_WORDS];\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_bytesToNative(_private, private_key, BITS_TO_BYTES(curve->num_n_bits));\n#endif\n\n    /* Make sure the private key is in the range [1, n-1]. */\n    if (uECC_vli_isZero(_private, BITS_TO_WORDS(curve->num_n_bits))) {\n        return 0;\n    }\n\n    if (uECC_vli_cmp(curve->n, _private, BITS_TO_WORDS(curve->num_n_bits)) != 1) {\n        return 0;\n    }\n\n    /* Compute public key. */\n    if (!EccPoint_compute_public_key(_public, _private, curve)) {\n        return 0;\n    }\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(public_key, curve->num_bytes, _public);\n    uECC_vli_nativeToBytes(\n        public_key + curve->num_bytes, curve->num_bytes, _public + curve->num_words);\n#endif\n    return 1;\n}\n\n\n/* -------- ECDSA code -------- */\n\nstatic void bits2int(uECC_word_t *native,\n                     const uint8_t *bits,\n                     unsigned bits_size,\n                     uECC_Curve curve) {\n    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);\n    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    int shift;\n    uECC_word_t carry;\n    uECC_word_t *ptr;\n\n    if (bits_size > num_n_bytes) {\n        bits_size = num_n_bytes;\n    }\n\n    uECC_vli_clear(native, num_n_words);\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) native, bits, bits_size);\n#else\n    uECC_vli_bytesToNative(native, bits, bits_size);\n#endif    \n    if (bits_size * 8 <= (unsigned)curve->num_n_bits) {\n        return;\n    }\n    shift = bits_size * 8 - curve->num_n_bits;\n    carry = 0;\n    ptr = native + num_n_words;\n    while (ptr-- > native) {\n        uECC_word_t temp = *ptr;\n        *ptr = (temp >> shift) | carry;\n        carry = temp << (uECC_WORD_BITS - shift);\n    }\n\n    /* Reduce mod curve_n */\n    if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {\n        uECC_vli_sub(native, native, curve->n, num_n_words);\n    }\n}\n\nstatic int uECC_sign_with_k(const uint8_t *private_key,\n                            const uint8_t *message_hash,\n                            unsigned hash_size,\n                            uECC_word_t *k,\n                            uint8_t *signature,\n                            uECC_Curve curve) {\n\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t s[uECC_MAX_WORDS];\n    uECC_word_t *k2[2] = {tmp, s};\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *p = (uECC_word_t *)signature;\n#else\n    uECC_word_t p[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t carry;\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n\n    /* Make sure 0 < k < curve_n */\n    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {\n        return 0;\n    }\n\n    carry = regularize_k(k, tmp, s, curve);\n    EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);\n    if (uECC_vli_isZero(p, num_words)) {\n        return 0;\n    }\n\n    /* If an RNG function was specified, get a random number\n       to prevent side channel analysis of k. */\n    if (!g_rng_function) {\n        uECC_vli_clear(tmp, num_n_words);\n        tmp[0] = 1;\n    } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {\n        return 0;\n    }\n\n    /* Prevent side channel analysis of uECC_vli_modInv() to determine\n       bits of k / the private key by premultiplying by a random number */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */\n    uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) tmp, private_key, BITS_TO_BYTES(curve->num_n_bits));\n#else\n    uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); /* tmp = d */\n#endif\n\n    s[num_n_words - 1] = 0;\n    uECC_vli_set(s, p, num_words);\n    uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */\n\n    bits2int(tmp, message_hash, hash_size, curve);\n    uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */\n    uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */\n    if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {\n        return 0;\n    }\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes);\n#else\n    uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);\n#endif    \n    return 1;\n}\n\nint uECC_sign(const uint8_t *private_key,\n              const uint8_t *message_hash,\n              unsigned hash_size,\n              uint8_t *signature,\n              uECC_Curve curve) {\n    uECC_word_t k[uECC_MAX_WORDS];\n    uECC_word_t tries;\n\n    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {\n        if (!uECC_generate_random_int(k, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {\n            return 0;\n        }\n\n        if (uECC_sign_with_k(private_key, message_hash, hash_size, k, signature, curve)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* Compute an HMAC using K as a key (as in RFC 6979). Note that K is always\n   the same size as the hash result size. */\nstatic void HMAC_init(const uECC_HashContext *hash_context, const uint8_t *K) {\n    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;\n    unsigned i;\n    for (i = 0; i < hash_context->result_size; ++i)\n        pad[i] = K[i] ^ 0x36;\n    for (; i < hash_context->block_size; ++i)\n        pad[i] = 0x36;\n\n    hash_context->init_hash(hash_context);\n    hash_context->update_hash(hash_context, pad, hash_context->block_size);\n}\n\nstatic void HMAC_update(const uECC_HashContext *hash_context,\n                        const uint8_t *message,\n                        unsigned message_size) {\n    hash_context->update_hash(hash_context, message, message_size);\n}\n\nstatic void HMAC_finish(const uECC_HashContext *hash_context,\n                        const uint8_t *K,\n                        uint8_t *result) {\n    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;\n    unsigned i;\n    for (i = 0; i < hash_context->result_size; ++i)\n        pad[i] = K[i] ^ 0x5c;\n    for (; i < hash_context->block_size; ++i)\n        pad[i] = 0x5c;\n\n    hash_context->finish_hash(hash_context, result);\n\n    hash_context->init_hash(hash_context);\n    hash_context->update_hash(hash_context, pad, hash_context->block_size);\n    hash_context->update_hash(hash_context, result, hash_context->result_size);\n    hash_context->finish_hash(hash_context, result);\n}\n\n/* V = HMAC_K(V) */\nstatic void update_V(const uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {\n    HMAC_init(hash_context, K);\n    HMAC_update(hash_context, V, hash_context->result_size);\n    HMAC_finish(hash_context, K, V);\n}\n\n/* Deterministic signing, similar to RFC 6979. Differences are:\n    * We just use H(m) directly rather than bits2octets(H(m))\n      (it is not reduced modulo curve_n).\n    * We generate a value for k (aka T) directly rather than converting endianness.\n\n   Layout of hash_context->tmp: <K> | <V> | (1 byte overlapped 0x00 or 0x01) / <HMAC pad> */\nint uECC_sign_deterministic(const uint8_t *private_key,\n                            const uint8_t *message_hash,\n                            unsigned hash_size,\n                            const uECC_HashContext *hash_context,\n                            uint8_t *signature,\n                            uECC_Curve curve) {\n    uint8_t *K = hash_context->tmp;\n    uint8_t *V = K + hash_context->result_size;\n    wordcount_t num_bytes = curve->num_bytes;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n    uECC_word_t tries;\n    unsigned i;\n    for (i = 0; i < hash_context->result_size; ++i) {\n        V[i] = 0x01;\n        K[i] = 0;\n    }\n\n    /* K = HMAC_K(V || 0x00 || int2octets(x) || h(m)) */\n    HMAC_init(hash_context, K);\n    V[hash_context->result_size] = 0x00;\n    HMAC_update(hash_context, V, hash_context->result_size + 1);\n    HMAC_update(hash_context, private_key, num_bytes);\n    HMAC_update(hash_context, message_hash, hash_size);\n    HMAC_finish(hash_context, K, K);\n\n    update_V(hash_context, K, V);\n\n    /* K = HMAC_K(V || 0x01 || int2octets(x) || h(m)) */\n    HMAC_init(hash_context, K);\n    V[hash_context->result_size] = 0x01;\n    HMAC_update(hash_context, V, hash_context->result_size + 1);\n    HMAC_update(hash_context, private_key, num_bytes);\n    HMAC_update(hash_context, message_hash, hash_size);\n    HMAC_finish(hash_context, K, K);\n\n    update_V(hash_context, K, V);\n\n    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {\n        uECC_word_t T[uECC_MAX_WORDS];\n        uint8_t *T_ptr = (uint8_t *)T;\n        wordcount_t T_bytes = 0;\n        for (;;) {\n            update_V(hash_context, K, V);\n            for (i = 0; i < hash_context->result_size; ++i) {\n                T_ptr[T_bytes++] = V[i];\n                if (T_bytes >= num_n_words * uECC_WORD_SIZE) {\n                    goto filled;\n                }\n            }\n        }\n    filled:\n        if ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8 > num_n_bits) {\n            uECC_word_t mask = (uECC_word_t)-1;\n            T[num_n_words - 1] &=\n                mask >> ((bitcount_t)(num_n_words * uECC_WORD_SIZE * 8 - num_n_bits));\n        }\n\n        if (uECC_sign_with_k(private_key, message_hash, hash_size, T, signature, curve)) {\n            return 1;\n        }\n\n        /* K = HMAC_K(V || 0x00) */\n        HMAC_init(hash_context, K);\n        V[hash_context->result_size] = 0x00;\n        HMAC_update(hash_context, V, hash_context->result_size + 1);\n        HMAC_finish(hash_context, K, K);\n\n        update_V(hash_context, K, V);\n    }\n    return 0;\n}\n\nstatic bitcount_t smax(bitcount_t a, bitcount_t b) {\n    return (a > b ? a : b);\n}\n\nint uECC_verify(const uint8_t *public_key,\n                const uint8_t *message_hash,\n                unsigned hash_size,\n                const uint8_t *signature,\n                uECC_Curve curve) {\n    uECC_word_t u1[uECC_MAX_WORDS], u2[uECC_MAX_WORDS];\n    uECC_word_t z[uECC_MAX_WORDS];\n    uECC_word_t sum[uECC_MAX_WORDS * 2];\n    uECC_word_t rx[uECC_MAX_WORDS];\n    uECC_word_t ry[uECC_MAX_WORDS];\n    uECC_word_t tx[uECC_MAX_WORDS];\n    uECC_word_t ty[uECC_MAX_WORDS];\n    uECC_word_t tz[uECC_MAX_WORDS];\n    const uECC_word_t *points[4];\n    const uECC_word_t *point;\n    bitcount_t num_bits;\n    bitcount_t i;\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *_public = (uECC_word_t *)public_key;\n#else\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n#endif    \n    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n\n    rx[num_n_words - 1] = 0;\n    r[num_n_words - 1] = 0;\n    s[num_n_words - 1] = 0;\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) r, signature, curve->num_bytes);\n    bcopy((uint8_t *) s, signature + curve->num_bytes, curve->num_bytes);\n#else\n    uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);\n    uECC_vli_bytesToNative(\n        _public + num_words, public_key + curve->num_bytes, curve->num_bytes);\n    uECC_vli_bytesToNative(r, signature, curve->num_bytes);\n    uECC_vli_bytesToNative(s, signature + curve->num_bytes, curve->num_bytes);\n#endif\n\n    /* r, s must not be 0. */\n    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {\n        return 0;\n    }\n\n    /* r, s must be < n. */\n    if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||\n            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {\n        return 0;\n    }\n\n    /* Calculate u1 and u2. */\n    uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */\n    u1[num_n_words - 1] = 0;\n    bits2int(u1, message_hash, hash_size, curve);\n    uECC_vli_modMult(u1, u1, z, curve->n, num_n_words); /* u1 = e/s */\n    uECC_vli_modMult(u2, r, z, curve->n, num_n_words); /* u2 = r/s */\n\n    /* Calculate sum = G + Q. */\n    uECC_vli_set(sum, _public, num_words);\n    uECC_vli_set(sum + num_words, _public + num_words, num_words);\n    uECC_vli_set(tx, curve->G, num_words);\n    uECC_vli_set(ty, curve->G + num_words, num_words);\n    uECC_vli_modSub(z, sum, tx, curve->p, num_words); /* z = x2 - x1 */\n    XYcZ_add(tx, ty, sum, sum + num_words, curve);\n    uECC_vli_modInv(z, z, curve->p, num_words); /* z = 1/z */\n    apply_z(sum, sum + num_words, z, curve);\n\n    /* Use Shamir's trick to calculate u1*G + u2*Q */\n    points[0] = 0;\n    points[1] = curve->G;\n    points[2] = _public;\n    points[3] = sum;\n    num_bits = smax(uECC_vli_numBits(u1, num_n_words),\n                    uECC_vli_numBits(u2, num_n_words));\n\n    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |\n                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];\n    uECC_vli_set(rx, point, num_words);\n    uECC_vli_set(ry, point + num_words, num_words);\n    uECC_vli_clear(z, num_words);\n    z[0] = 1;\n\n    for (i = num_bits - 2; i >= 0; --i) {\n        uECC_word_t index;\n        curve->double_jacobian(rx, ry, z, curve);\n\n        index = (!!uECC_vli_testBit(u1, i)) | ((!!uECC_vli_testBit(u2, i)) << 1);\n        point = points[index];\n        if (point) {\n            uECC_vli_set(tx, point, num_words);\n            uECC_vli_set(ty, point + num_words, num_words);\n            apply_z(tx, ty, z, curve);\n            uECC_vli_modSub(tz, rx, tx, curve->p, num_words); /* Z = x2 - x1 */\n            XYcZ_add(tx, ty, rx, ry, curve);\n            uECC_vli_modMult_fast(z, z, tz, curve);\n        }\n    }\n\n    uECC_vli_modInv(z, z, curve->p, num_words); /* Z = 1/Z */\n    apply_z(rx, ry, z, curve);\n\n    /* v = x1 (mod n) */\n    if (uECC_vli_cmp_unsafe(curve->n, rx, num_n_words) != 1) {\n        uECC_vli_sub(rx, rx, curve->n, num_n_words);\n    }\n\n    /* Accept only if v == r. */\n    return (int)(uECC_vli_equal(rx, r, num_words));\n}\n\n#if uECC_ENABLE_VLI_API\n\nunsigned uECC_curve_num_words(uECC_Curve curve) {\n    return curve->num_words;\n}\n\nunsigned uECC_curve_num_bytes(uECC_Curve curve) {\n    return curve->num_bytes;\n}\n\nunsigned uECC_curve_num_bits(uECC_Curve curve) {\n    return curve->num_bytes * 8;\n}\n\nunsigned uECC_curve_num_n_words(uECC_Curve curve) {\n    return BITS_TO_WORDS(curve->num_n_bits);\n}\n\nunsigned uECC_curve_num_n_bytes(uECC_Curve curve) {\n    return BITS_TO_BYTES(curve->num_n_bits);\n}\n\nunsigned uECC_curve_num_n_bits(uECC_Curve curve) {\n    return curve->num_n_bits;\n}\n\nconst uECC_word_t *uECC_curve_p(uECC_Curve curve) {\n    return curve->p;\n}\n\nconst uECC_word_t *uECC_curve_n(uECC_Curve curve) {\n    return curve->n;\n}\n\nconst uECC_word_t *uECC_curve_G(uECC_Curve curve) {\n    return curve->G;\n}\n\nconst uECC_word_t *uECC_curve_b(uECC_Curve curve) {\n    return curve->b;\n}\n\n#if uECC_SUPPORT_COMPRESSED_POINT\nvoid uECC_vli_mod_sqrt(uECC_word_t *a, uECC_Curve curve) {\n    curve->mod_sqrt(a, curve);\n}\n#endif\n\nvoid uECC_vli_mmod_fast(uECC_word_t *result, uECC_word_t *product, uECC_Curve curve) {\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    curve->mmod_fast(result, product);\n#else\n    uECC_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}\n\nvoid uECC_point_mult(uECC_word_t *result,\n                     const uECC_word_t *point,\n                     const uECC_word_t *scalar,\n                     uECC_Curve curve) {\n    uECC_word_t tmp1[uECC_MAX_WORDS];\n    uECC_word_t tmp2[uECC_MAX_WORDS];\n    uECC_word_t *p2[2] = {tmp1, tmp2};\n    uECC_word_t carry = regularize_k(scalar, tmp1, tmp2, curve);\n\n    EccPoint_mult(result, point, p2[!carry], 0, curve->num_n_bits + 1, curve);\n}\n\n#endif /* uECC_ENABLE_VLI_API */\n"], "fixing_code": ["/* Copyright 2014, Kenneth MacKay. Licensed under the BSD 2-clause license. */\n\n#include \"uECC.h\"\n#include \"uECC_vli.h\"\n\n#ifndef uECC_RNG_MAX_TRIES\n    #define uECC_RNG_MAX_TRIES 64\n#endif\n\n#if uECC_ENABLE_VLI_API\n    #define uECC_VLI_API\n#else\n    #define uECC_VLI_API static\n#endif\n\n#define CONCATX(a, ...) a ## __VA_ARGS__\n#define CONCAT(a, ...) CONCATX(a, __VA_ARGS__)\n\n#define STRX(a) #a\n#define STR(a) STRX(a)\n\n#define EVAL(...)  EVAL1(EVAL1(EVAL1(EVAL1(__VA_ARGS__))))\n#define EVAL1(...) EVAL2(EVAL2(EVAL2(EVAL2(__VA_ARGS__))))\n#define EVAL2(...) EVAL3(EVAL3(EVAL3(EVAL3(__VA_ARGS__))))\n#define EVAL3(...) EVAL4(EVAL4(EVAL4(EVAL4(__VA_ARGS__))))\n#define EVAL4(...) __VA_ARGS__\n\n#define DEC_1  0\n#define DEC_2  1\n#define DEC_3  2\n#define DEC_4  3\n#define DEC_5  4\n#define DEC_6  5\n#define DEC_7  6\n#define DEC_8  7\n#define DEC_9  8\n#define DEC_10 9\n#define DEC_11 10\n#define DEC_12 11\n#define DEC_13 12\n#define DEC_14 13\n#define DEC_15 14\n#define DEC_16 15\n#define DEC_17 16\n#define DEC_18 17\n#define DEC_19 18\n#define DEC_20 19\n#define DEC_21 20\n#define DEC_22 21\n#define DEC_23 22\n#define DEC_24 23\n#define DEC_25 24\n#define DEC_26 25\n#define DEC_27 26\n#define DEC_28 27\n#define DEC_29 28\n#define DEC_30 29\n#define DEC_31 30\n#define DEC_32 31\n\n#define DEC(N) CONCAT(DEC_, N)\n\n#define SECOND_ARG(_, val, ...) val\n#define SOME_CHECK_0 ~, 0\n#define GET_SECOND_ARG(...) SECOND_ARG(__VA_ARGS__, SOME,)\n#define SOME_OR_0(N) GET_SECOND_ARG(CONCAT(SOME_CHECK_, N))\n\n#define EMPTY(...)\n#define DEFER(...) __VA_ARGS__ EMPTY()\n\n#define REPEAT_NAME_0() REPEAT_0\n#define REPEAT_NAME_SOME() REPEAT_SOME\n#define REPEAT_0(...)\n#define REPEAT_SOME(N, stuff) DEFER(CONCAT(REPEAT_NAME_, SOME_OR_0(DEC(N))))()(DEC(N), stuff) stuff\n#define REPEAT(N, stuff) EVAL(REPEAT_SOME(N, stuff))\n\n#define REPEATM_NAME_0() REPEATM_0\n#define REPEATM_NAME_SOME() REPEATM_SOME\n#define REPEATM_0(...)\n#define REPEATM_SOME(N, macro) macro(N) \\\n    DEFER(CONCAT(REPEATM_NAME_, SOME_OR_0(DEC(N))))()(DEC(N), macro)\n#define REPEATM(N, macro) EVAL(REPEATM_SOME(N, macro))\n\n#include \"platform-specific.inc\"\n\n#if (uECC_WORD_SIZE == 1)\n    #if uECC_SUPPORTS_secp160r1\n        #define uECC_MAX_WORDS 21 /* Due to the size of curve_n. */\n    #endif\n    #if uECC_SUPPORTS_secp192r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 24\n    #endif\n    #if uECC_SUPPORTS_secp224r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 28\n    #endif\n    #if (uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1)\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 32\n    #endif\n#elif (uECC_WORD_SIZE == 4)\n    #if uECC_SUPPORTS_secp160r1\n        #define uECC_MAX_WORDS 6 /* Due to the size of curve_n. */\n    #endif\n    #if uECC_SUPPORTS_secp192r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 6\n    #endif\n    #if uECC_SUPPORTS_secp224r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 7\n    #endif\n    #if (uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1)\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 8\n    #endif\n#elif (uECC_WORD_SIZE == 8)\n    #if uECC_SUPPORTS_secp160r1\n        #define uECC_MAX_WORDS 3\n    #endif\n    #if uECC_SUPPORTS_secp192r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 3\n    #endif\n    #if uECC_SUPPORTS_secp224r1\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 4\n    #endif\n    #if (uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1)\n        #undef uECC_MAX_WORDS\n        #define uECC_MAX_WORDS 4\n    #endif\n#endif /* uECC_WORD_SIZE */\n\n#define BITS_TO_WORDS(num_bits) ((num_bits + ((uECC_WORD_SIZE * 8) - 1)) / (uECC_WORD_SIZE * 8))\n#define BITS_TO_BYTES(num_bits) ((num_bits + 7) / 8)\n\nstruct uECC_Curve_t {\n    wordcount_t num_words;\n    wordcount_t num_bytes;\n    bitcount_t num_n_bits;\n    uECC_word_t p[uECC_MAX_WORDS];\n    uECC_word_t n[uECC_MAX_WORDS];\n    uECC_word_t G[uECC_MAX_WORDS * 2];\n    uECC_word_t b[uECC_MAX_WORDS];\n    void (*double_jacobian)(uECC_word_t * X1,\n                            uECC_word_t * Y1,\n                            uECC_word_t * Z1,\n                            uECC_Curve curve);\n#if uECC_SUPPORT_COMPRESSED_POINT\n    void (*mod_sqrt)(uECC_word_t *a, uECC_Curve curve);\n#endif\n    void (*x_side)(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve);\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    void (*mmod_fast)(uECC_word_t *result, uECC_word_t *product);\n#endif\n};\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\nstatic void bcopy(uint8_t *dst,\n                  const uint8_t *src,\n                  unsigned num_bytes) {\n    while (0 != num_bytes) {\n        num_bytes--;\n        dst[num_bytes] = src[num_bytes];\n    }\n}\n#endif\n\nstatic cmpresult_t uECC_vli_cmp_unsafe(const uECC_word_t *left,\n                                       const uECC_word_t *right,\n                                       wordcount_t num_words);\n\n#if (uECC_PLATFORM == uECC_arm || uECC_PLATFORM == uECC_arm_thumb || \\\n        uECC_PLATFORM == uECC_arm_thumb2)\n    #include \"asm_arm.inc\"\n#endif\n\n#if (uECC_PLATFORM == uECC_avr)\n    #include \"asm_avr.inc\"\n#endif\n\n#if default_RNG_defined\nstatic uECC_RNG_Function g_rng_function = &default_RNG;\n#else\nstatic uECC_RNG_Function g_rng_function = 0;\n#endif\n\nvoid uECC_set_rng(uECC_RNG_Function rng_function) {\n    g_rng_function = rng_function;\n}\n\nuECC_RNG_Function uECC_get_rng(void) {\n    return g_rng_function;\n}\n\nint uECC_curve_private_key_size(uECC_Curve curve) {\n    return BITS_TO_BYTES(curve->num_n_bits);\n}\n\nint uECC_curve_public_key_size(uECC_Curve curve) {\n    return 2 * curve->num_bytes;\n}\n\n#if !asm_clear\nuECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) {\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        vli[i] = 0;\n    }\n}\n#endif /* !asm_clear */\n\n/* Constant-time comparison to zero - secure way to compare long integers */\n/* Returns 1 if vli == 0, 0 otherwise. */\nuECC_VLI_API uECC_word_t uECC_vli_isZero(const uECC_word_t *vli, wordcount_t num_words) {\n    uECC_word_t bits = 0;\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        bits |= vli[i];\n    }\n    return (bits == 0);\n}\n\n/* Returns nonzero if bit 'bit' of vli is set. */\nuECC_VLI_API uECC_word_t uECC_vli_testBit(const uECC_word_t *vli, bitcount_t bit) {\n    return (vli[bit >> uECC_WORD_BITS_SHIFT] & ((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));\n}\n\n/* Counts the number of words in vli. */\nstatic wordcount_t vli_numDigits(const uECC_word_t *vli, const wordcount_t max_words) {\n    wordcount_t i;\n    /* Search from the end until we find a non-zero digit.\n       We do it in reverse because we expect that most digits will be nonzero. */\n    for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {\n    }\n\n    return (i + 1);\n}\n\n/* Counts the number of bits required to represent vli. */\nuECC_VLI_API bitcount_t uECC_vli_numBits(const uECC_word_t *vli, const wordcount_t max_words) {\n    uECC_word_t i;\n    uECC_word_t digit;\n\n    wordcount_t num_digits = vli_numDigits(vli, max_words);\n    if (num_digits == 0) {\n        return 0;\n    }\n\n    digit = vli[num_digits - 1];\n    for (i = 0; digit; ++i) {\n        digit >>= 1;\n    }\n\n    return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);\n}\n\n/* Sets dest = src. */\n#if !asm_set\nuECC_VLI_API void uECC_vli_set(uECC_word_t *dest, const uECC_word_t *src, wordcount_t num_words) {\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        dest[i] = src[i];\n    }\n}\n#endif /* !asm_set */\n\n/* Returns sign of left - right. */\nstatic cmpresult_t uECC_vli_cmp_unsafe(const uECC_word_t *left,\n                                       const uECC_word_t *right,\n                                       wordcount_t num_words) {\n    wordcount_t i;\n    for (i = num_words - 1; i >= 0; --i) {\n        if (left[i] > right[i]) {\n            return 1;\n        } else if (left[i] < right[i]) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\n/* Constant-time comparison function - secure way to compare long integers */\n/* Returns one if left == right, zero otherwise. */\nuECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,\n                                        const uECC_word_t *right,\n                                        wordcount_t num_words) {\n    uECC_word_t diff = 0;\n    wordcount_t i;\n    for (i = num_words - 1; i >= 0; --i) {\n        diff |= (left[i] ^ right[i]);\n    }\n    return (diff == 0);\n}\n\nuECC_VLI_API uECC_word_t uECC_vli_sub(uECC_word_t *result,\n                                      const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words);\n\n/* Returns sign of left - right, in constant time. */\nuECC_VLI_API cmpresult_t uECC_vli_cmp(const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words) {\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);\n    uECC_word_t equal = uECC_vli_isZero(tmp, num_words);\n    return (!equal - 2 * neg);\n}\n\n/* Computes vli = vli >> 1. */\n#if !asm_rshift1\nuECC_VLI_API void uECC_vli_rshift1(uECC_word_t *vli, wordcount_t num_words) {\n    uECC_word_t *end = vli;\n    uECC_word_t carry = 0;\n\n    vli += num_words;\n    while (vli-- > end) {\n        uECC_word_t temp = *vli;\n        *vli = (temp >> 1) | carry;\n        carry = temp << (uECC_WORD_BITS - 1);\n    }\n}\n#endif /* !asm_rshift1 */\n\n/* Computes result = left + right, returning carry. Can modify in place. */\n#if !asm_add\nuECC_VLI_API uECC_word_t uECC_vli_add(uECC_word_t *result,\n                                      const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words) {\n    uECC_word_t carry = 0;\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        uECC_word_t sum = left[i] + right[i] + carry;\n        if (sum != left[i]) {\n            carry = (sum < left[i]);\n        }\n        result[i] = sum;\n    }\n    return carry;\n}\n#endif /* !asm_add */\n\n/* Computes result = left - right, returning borrow. Can modify in place. */\n#if !asm_sub\nuECC_VLI_API uECC_word_t uECC_vli_sub(uECC_word_t *result,\n                                      const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words) {\n    uECC_word_t borrow = 0;\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        uECC_word_t diff = left[i] - right[i] - borrow;\n        if (diff != left[i]) {\n            borrow = (diff > left[i]);\n        }\n        result[i] = diff;\n    }\n    return borrow;\n}\n#endif /* !asm_sub */\n\n#if !asm_mult || (uECC_SQUARE_FUNC && !asm_square) || \\\n    (uECC_SUPPORTS_secp256k1 && (uECC_OPTIMIZATION_LEVEL > 0) && \\\n        ((uECC_WORD_SIZE == 1) || (uECC_WORD_SIZE == 8)))\nstatic void muladd(uECC_word_t a,\n                   uECC_word_t b,\n                   uECC_word_t *r0,\n                   uECC_word_t *r1,\n                   uECC_word_t *r2) {\n#if uECC_WORD_SIZE == 8 && !SUPPORTS_INT128\n    uint64_t a0 = a & 0xffffffffull;\n    uint64_t a1 = a >> 32;\n    uint64_t b0 = b & 0xffffffffull;\n    uint64_t b1 = b >> 32;\n\n    uint64_t i0 = a0 * b0;\n    uint64_t i1 = a0 * b1;\n    uint64_t i2 = a1 * b0;\n    uint64_t i3 = a1 * b1;\n\n    uint64_t p0, p1;\n\n    i2 += (i0 >> 32);\n    i2 += i1;\n    if (i2 < i1) { /* overflow */\n        i3 += 0x100000000ull;\n    }\n\n    p0 = (i0 & 0xffffffffull) | (i2 << 32);\n    p1 = i3 + (i2 >> 32);\n\n    *r0 += p0;\n    *r1 += (p1 + (*r0 < p0));\n    *r2 += ((*r1 < p1) || (*r1 == p1 && *r0 < p0));\n#else\n    uECC_dword_t p = (uECC_dword_t)a * b;\n    uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;\n    r01 += p;\n    *r2 += (r01 < p);\n    *r1 = r01 >> uECC_WORD_BITS;\n    *r0 = (uECC_word_t)r01;\n#endif\n}\n#endif /* muladd needed */\n\n#if !asm_mult\nuECC_VLI_API void uECC_vli_mult(uECC_word_t *result,\n                                const uECC_word_t *left,\n                                const uECC_word_t *right,\n                                wordcount_t num_words) {\n    uECC_word_t r0 = 0;\n    uECC_word_t r1 = 0;\n    uECC_word_t r2 = 0;\n    wordcount_t i, k;\n\n    /* Compute each digit of result in sequence, maintaining the carries. */\n    for (k = 0; k < num_words; ++k) {\n        for (i = 0; i <= k; ++i) {\n            muladd(left[i], right[k - i], &r0, &r1, &r2);\n        }\n        result[k] = r0;\n        r0 = r1;\n        r1 = r2;\n        r2 = 0;\n    }\n    for (k = num_words; k < num_words * 2 - 1; ++k) {\n        for (i = (k + 1) - num_words; i < num_words; ++i) {\n            muladd(left[i], right[k - i], &r0, &r1, &r2);\n        }\n        result[k] = r0;\n        r0 = r1;\n        r1 = r2;\n        r2 = 0;\n    }\n    result[num_words * 2 - 1] = r0;\n}\n#endif /* !asm_mult */\n\n#if uECC_SQUARE_FUNC\n\n#if !asm_square\nstatic void mul2add(uECC_word_t a,\n                    uECC_word_t b,\n                    uECC_word_t *r0,\n                    uECC_word_t *r1,\n                    uECC_word_t *r2) {\n#if uECC_WORD_SIZE == 8 && !SUPPORTS_INT128\n    uint64_t a0 = a & 0xffffffffull;\n    uint64_t a1 = a >> 32;\n    uint64_t b0 = b & 0xffffffffull;\n    uint64_t b1 = b >> 32;\n\n    uint64_t i0 = a0 * b0;\n    uint64_t i1 = a0 * b1;\n    uint64_t i2 = a1 * b0;\n    uint64_t i3 = a1 * b1;\n\n    uint64_t p0, p1;\n\n    i2 += (i0 >> 32);\n    i2 += i1;\n    if (i2 < i1)\n    { /* overflow */\n        i3 += 0x100000000ull;\n    }\n\n    p0 = (i0 & 0xffffffffull) | (i2 << 32);\n    p1 = i3 + (i2 >> 32);\n\n    *r2 += (p1 >> 63);\n    p1 = (p1 << 1) | (p0 >> 63);\n    p0 <<= 1;\n\n    *r0 += p0;\n    *r1 += (p1 + (*r0 < p0));\n    *r2 += ((*r1 < p1) || (*r1 == p1 && *r0 < p0));\n#else\n    uECC_dword_t p = (uECC_dword_t)a * b;\n    uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;\n    *r2 += (p >> (uECC_WORD_BITS * 2 - 1));\n    p *= 2;\n    r01 += p;\n    *r2 += (r01 < p);\n    *r1 = r01 >> uECC_WORD_BITS;\n    *r0 = (uECC_word_t)r01;\n#endif\n}\n\nuECC_VLI_API void uECC_vli_square(uECC_word_t *result,\n                                  const uECC_word_t *left,\n                                  wordcount_t num_words) {\n    uECC_word_t r0 = 0;\n    uECC_word_t r1 = 0;\n    uECC_word_t r2 = 0;\n\n    wordcount_t i, k;\n\n    for (k = 0; k < num_words * 2 - 1; ++k) {\n        uECC_word_t min = (k < num_words ? 0 : (k + 1) - num_words);\n        for (i = min; i <= k && i <= k - i; ++i) {\n            if (i < k-i) {\n                mul2add(left[i], left[k - i], &r0, &r1, &r2);\n            } else {\n                muladd(left[i], left[k - i], &r0, &r1, &r2);\n            }\n        }\n        result[k] = r0;\n        r0 = r1;\n        r1 = r2;\n        r2 = 0;\n    }\n\n    result[num_words * 2 - 1] = r0;\n}\n#endif /* !asm_square */\n\n#else /* uECC_SQUARE_FUNC */\n\n#if uECC_ENABLE_VLI_API\nuECC_VLI_API void uECC_vli_square(uECC_word_t *result,\n                                  const uECC_word_t *left,\n                                  wordcount_t num_words) {\n    uECC_vli_mult(result, left, left, num_words);\n}\n#endif /* uECC_ENABLE_VLI_API */\n\n#endif /* uECC_SQUARE_FUNC */\n\n/* Computes result = (left + right) % mod.\n   Assumes that left < mod and right < mod, and that result does not overlap mod. */\nuECC_VLI_API void uECC_vli_modAdd(uECC_word_t *result,\n                                  const uECC_word_t *left,\n                                  const uECC_word_t *right,\n                                  const uECC_word_t *mod,\n                                  wordcount_t num_words) {\n    uECC_word_t carry = uECC_vli_add(result, left, right, num_words);\n    if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {\n        /* result > mod (result = mod + remainder), so subtract mod to get remainder. */\n        uECC_vli_sub(result, result, mod, num_words);\n    }\n}\n\n/* Computes result = (left - right) % mod.\n   Assumes that left < mod and right < mod, and that result does not overlap mod. */\nuECC_VLI_API void uECC_vli_modSub(uECC_word_t *result,\n                                  const uECC_word_t *left,\n                                  const uECC_word_t *right,\n                                  const uECC_word_t *mod,\n                                  wordcount_t num_words) {\n    uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);\n    if (l_borrow) {\n        /* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,\n           we can get the correct result from result + mod (with overflow). */\n        uECC_vli_add(result, result, mod, num_words);\n    }\n}\n\n/* Computes result = product % mod, where product is 2N words long. */\n/* Currently only designed to work for curve_p or curve_n. */\nuECC_VLI_API void uECC_vli_mmod(uECC_word_t *result,\n                                uECC_word_t *product,\n                                const uECC_word_t *mod,\n                                wordcount_t num_words) {\n    uECC_word_t mod_multiple[2 * uECC_MAX_WORDS];\n    uECC_word_t tmp[2 * uECC_MAX_WORDS];\n    uECC_word_t *v[2] = {tmp, product};\n    uECC_word_t index;\n\n    /* Shift mod so its highest set bit is at the maximum position. */\n    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);\n    wordcount_t word_shift = shift / uECC_WORD_BITS;\n    wordcount_t bit_shift = shift % uECC_WORD_BITS;\n    uECC_word_t carry = 0;\n    uECC_vli_clear(mod_multiple, word_shift);\n    if (bit_shift > 0) {\n        for(index = 0; index < (uECC_word_t)num_words; ++index) {\n            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;\n            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);\n        }\n    } else {\n        uECC_vli_set(mod_multiple + word_shift, mod, num_words);\n    }\n\n    for (index = 1; shift >= 0; --shift) {\n        uECC_word_t borrow = 0;\n        wordcount_t i;\n        for (i = 0; i < num_words * 2; ++i) {\n            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;\n            if (diff != v[index][i]) {\n                borrow = (diff > v[index][i]);\n            }\n            v[1 - index][i] = diff;\n        }\n        index = !(index ^ borrow); /* Swap the index if there was no borrow */\n        uECC_vli_rshift1(mod_multiple, num_words);\n        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);\n        uECC_vli_rshift1(mod_multiple + num_words, num_words);\n    }\n    uECC_vli_set(result, v[index], num_words);\n}\n\n/* Computes result = (left * right) % mod. */\nuECC_VLI_API void uECC_vli_modMult(uECC_word_t *result,\n                                   const uECC_word_t *left,\n                                   const uECC_word_t *right,\n                                   const uECC_word_t *mod,\n                                   wordcount_t num_words) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_mult(product, left, right, num_words);\n    uECC_vli_mmod(result, product, mod, num_words);\n}\n\nuECC_VLI_API void uECC_vli_modMult_fast(uECC_word_t *result,\n                                        const uECC_word_t *left,\n                                        const uECC_word_t *right,\n                                        uECC_Curve curve) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_mult(product, left, right, curve->num_words);\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    curve->mmod_fast(result, product);\n#else\n    uECC_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}\n\n#if uECC_SQUARE_FUNC\n\n#if uECC_ENABLE_VLI_API\n/* Computes result = left^2 % mod. */\nuECC_VLI_API void uECC_vli_modSquare(uECC_word_t *result,\n                                     const uECC_word_t *left,\n                                     const uECC_word_t *mod,\n                                     wordcount_t num_words) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_square(product, left, num_words);\n    uECC_vli_mmod(result, product, mod, num_words);\n}\n#endif /* uECC_ENABLE_VLI_API */\n\nuECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,\n                                          const uECC_word_t *left,\n                                          uECC_Curve curve) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_square(product, left, curve->num_words);\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    curve->mmod_fast(result, product);\n#else\n    uECC_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}\n\n#else /* uECC_SQUARE_FUNC */\n\n#if uECC_ENABLE_VLI_API\nuECC_VLI_API void uECC_vli_modSquare(uECC_word_t *result,\n                                     const uECC_word_t *left,\n                                     const uECC_word_t *mod,\n                                     wordcount_t num_words) {\n    uECC_vli_modMult(result, left, left, mod, num_words);\n}\n#endif /* uECC_ENABLE_VLI_API */\n\nuECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,\n                                          const uECC_word_t *left,\n                                          uECC_Curve curve) {\n    uECC_vli_modMult_fast(result, left, left, curve);\n}\n\n#endif /* uECC_SQUARE_FUNC */\n\n#define EVEN(vli) (!(vli[0] & 1))\nstatic void vli_modInv_update(uECC_word_t *uv,\n                              const uECC_word_t *mod,\n                              wordcount_t num_words) {\n    uECC_word_t carry = 0;\n    if (!EVEN(uv)) {\n        carry = uECC_vli_add(uv, uv, mod, num_words);\n    }\n    uECC_vli_rshift1(uv, num_words);\n    if (carry) {\n        uv[num_words - 1] |= HIGH_BIT_SET;\n    }\n}\n\n/* Computes result = (1 / input) % mod. All VLIs are the same size.\n   See \"From Euclid's GCD to Montgomery Multiplication to the Great Divide\" */\nuECC_VLI_API void uECC_vli_modInv(uECC_word_t *result,\n                                  const uECC_word_t *input,\n                                  const uECC_word_t *mod,\n                                  wordcount_t num_words) {\n    uECC_word_t a[uECC_MAX_WORDS], b[uECC_MAX_WORDS], u[uECC_MAX_WORDS], v[uECC_MAX_WORDS];\n    cmpresult_t cmpResult;\n\n    if (uECC_vli_isZero(input, num_words)) {\n        uECC_vli_clear(result, num_words);\n        return;\n    }\n\n    uECC_vli_set(a, input, num_words);\n    uECC_vli_set(b, mod, num_words);\n    uECC_vli_clear(u, num_words);\n    u[0] = 1;\n    uECC_vli_clear(v, num_words);\n    while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {\n        if (EVEN(a)) {\n            uECC_vli_rshift1(a, num_words);\n            vli_modInv_update(u, mod, num_words);\n        } else if (EVEN(b)) {\n            uECC_vli_rshift1(b, num_words);\n            vli_modInv_update(v, mod, num_words);\n        } else if (cmpResult > 0) {\n            uECC_vli_sub(a, a, b, num_words);\n            uECC_vli_rshift1(a, num_words);\n            if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {\n                uECC_vli_add(u, u, mod, num_words);\n            }\n            uECC_vli_sub(u, u, v, num_words);\n            vli_modInv_update(u, mod, num_words);\n        } else {\n            uECC_vli_sub(b, b, a, num_words);\n            uECC_vli_rshift1(b, num_words);\n            if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {\n                uECC_vli_add(v, v, mod, num_words);\n            }\n            uECC_vli_sub(v, v, u, num_words);\n            vli_modInv_update(v, mod, num_words);\n        }\n    }\n    uECC_vli_set(result, u, num_words);\n}\n\n/* ------ Point operations ------ */\n\n#include \"curve-specific.inc\"\n\n/* Returns 1 if 'point' is the point at infinity, 0 otherwise. */\n#define EccPoint_isZero(point, curve) uECC_vli_isZero((point), (curve)->num_words * 2)\n\n/* Point multiplication algorithm using Montgomery's ladder with co-Z coordinates.\nFrom http://eprint.iacr.org/2011/338.pdf\n*/\n\n/* Modify (x1, y1) => (x1 * z^2, y1 * z^3) */\nstatic void apply_z(uECC_word_t * X1,\n                    uECC_word_t * Y1,\n                    const uECC_word_t * const Z,\n                    uECC_Curve curve) {\n    uECC_word_t t1[uECC_MAX_WORDS];\n\n    uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */\n    uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */\n    uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */\n    uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */\n}\n\n/* P = (x1, y1) => 2P, (x2, y2) => P' */\nstatic void XYcZ_initial_double(uECC_word_t * X1,\n                                uECC_word_t * Y1,\n                                uECC_word_t * X2,\n                                uECC_word_t * Y2,\n                                const uECC_word_t * const initial_Z,\n                                uECC_Curve curve) {\n    uECC_word_t z[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n    if (initial_Z) {\n        uECC_vli_set(z, initial_Z, num_words);\n    } else {\n        uECC_vli_clear(z, num_words);\n        z[0] = 1;\n    }\n\n    uECC_vli_set(X2, X1, num_words);\n    uECC_vli_set(Y2, Y1, num_words);\n\n    apply_z(X1, Y1, z, curve);\n    curve->double_jacobian(X1, Y1, z, curve);\n    apply_z(X2, Y2, z, curve);\n}\n\n/* Input P = (x1, y1, Z), Q = (x2, y2, Z)\n   Output P' = (x1', y1', Z3), P + Q = (x3, y3, Z3)\n   or P => P', Q => P + Q\n*/\nstatic void XYcZ_add(uECC_word_t * X1,\n                     uECC_word_t * Y1,\n                     uECC_word_t * X2,\n                     uECC_word_t * Y2,\n                     uECC_Curve curve) {\n    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */\n    uECC_word_t t5[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n\n    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */\n    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */\n    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */\n    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */\n    uECC_vli_modSquare_fast(t5, Y2, curve);                  /* t5 = (y2 - y1)^2 = D */\n\n    uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */\n    uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */\n    uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */\n    uECC_vli_modMult_fast(Y1, Y1, X2, curve);                /* t2 = y1*(C - B) */\n    uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */\n    uECC_vli_modMult_fast(Y2, Y2, X2, curve);                /* t4 = (y2 - y1)*(B - x3) */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */\n\n    uECC_vli_set(X2, t5, num_words);\n}\n\n/* Input P = (x1, y1, Z), Q = (x2, y2, Z)\n   Output P + Q = (x3, y3, Z3), P - Q = (x3', y3', Z3)\n   or P => P - Q, Q => P + Q\n*/\nstatic void XYcZ_addC(uECC_word_t * X1,\n                      uECC_word_t * Y1,\n                      uECC_word_t * X2,\n                      uECC_word_t * Y2,\n                      uECC_Curve curve) {\n    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */\n    uECC_word_t t5[uECC_MAX_WORDS];\n    uECC_word_t t6[uECC_MAX_WORDS];\n    uECC_word_t t7[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n\n    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */\n    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */\n    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */\n    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */\n    uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */\n\n    uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */\n    uECC_vli_modMult_fast(Y1, Y1, t6, curve);                /* t2 = y1 * (C - B) = E */\n    uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */\n    uECC_vli_modSquare_fast(X2, Y2, curve);                  /* t3 = (y2 - y1)^2 = D */\n    uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */\n\n    uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */\n    uECC_vli_modMult_fast(Y2, Y2, t7, curve);                /* t4 = (y2 - y1)*(B - x3) */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = (y2 - y1)*(B - x3) - E = y3 */\n\n    uECC_vli_modSquare_fast(t7, t5, curve);                  /* t7 = (y2 + y1)^2 = F */\n    uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */\n    uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */\n    uECC_vli_modMult_fast(t6, t6, t5, curve);                /* t6 = (y2+y1)*(x3' - B) */\n    uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words); /* t2 = (y2+y1)*(x3' - B) - E = y3' */\n\n    uECC_vli_set(X1, t7, num_words);\n}\n\n/* result may overlap point. */\nstatic void EccPoint_mult(uECC_word_t * result,\n                          const uECC_word_t * point,\n                          const uECC_word_t * scalar,\n                          const uECC_word_t * initial_Z,\n                          bitcount_t num_bits,\n                          uECC_Curve curve) {\n    /* R0 and R1 */\n    uECC_word_t Rx[2][uECC_MAX_WORDS];\n    uECC_word_t Ry[2][uECC_MAX_WORDS];\n    uECC_word_t z[uECC_MAX_WORDS];\n    bitcount_t i;\n    uECC_word_t nb;\n    wordcount_t num_words = curve->num_words;\n\n    uECC_vli_set(Rx[1], point, num_words);\n    uECC_vli_set(Ry[1], point + num_words, num_words);\n\n    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);\n\n    for (i = num_bits - 2; i > 0; --i) {\n        nb = !uECC_vli_testBit(scalar, i);\n        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);\n        XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);\n    }\n\n    nb = !uECC_vli_testBit(scalar, 0);\n    XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);\n\n    /* Find final 1/Z value. */\n    uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */\n    uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve);               /* Yb * (X1 - X0) */\n    uECC_vli_modMult_fast(z, z, point, curve);                    /* xP * Yb * (X1 - X0) */\n    uECC_vli_modInv(z, z, curve->p, num_words);            /* 1 / (xP * Yb * (X1 - X0)) */\n    /* yP / (xP * Yb * (X1 - X0)) */\n    uECC_vli_modMult_fast(z, z, point + num_words, curve);\n    uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve); /* Xb * yP / (xP * Yb * (X1 - X0)) */\n    /* End 1/Z calculation */\n\n    XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);\n    apply_z(Rx[0], Ry[0], z, curve);\n\n    uECC_vli_set(result, Rx[0], num_words);\n    uECC_vli_set(result + num_words, Ry[0], num_words);\n}\n\nstatic uECC_word_t regularize_k(const uECC_word_t * const k,\n                                uECC_word_t *k0,\n                                uECC_word_t *k1,\n                                uECC_Curve curve) {\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||\n        (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&\n         uECC_vli_testBit(k0, num_n_bits));\n    uECC_vli_add(k1, k0, curve->n, num_n_words);\n    return carry;\n}\n\nstatic uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,\n                                               uECC_word_t *private_key,\n                                               uECC_Curve curve) {\n    uECC_word_t tmp1[uECC_MAX_WORDS];\n    uECC_word_t tmp2[uECC_MAX_WORDS];\n    uECC_word_t *p2[2] = {tmp1, tmp2};\n    uECC_word_t carry;\n\n    /* Regularize the bitcount for the private key so that attackers cannot use a side channel\n       attack to learn the number of leading zeros. */\n    carry = regularize_k(private_key, tmp1, tmp2, curve);\n\n    EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);\n\n    if (EccPoint_isZero(result, curve)) {\n        return 0;\n    }\n    return 1;\n}\n\n#if uECC_WORD_SIZE == 1\n\nuECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes,\n                                         int num_bytes,\n                                         const uint8_t *native) {\n    wordcount_t i;\n    for (i = 0; i < num_bytes; ++i) {\n        bytes[i] = native[(num_bytes - 1) - i];\n    }\n}\n\nuECC_VLI_API void uECC_vli_bytesToNative(uint8_t *native,\n                                         const uint8_t *bytes,\n                                         int num_bytes) {\n    uECC_vli_nativeToBytes(native, num_bytes, bytes);\n}\n\n#else\n\nuECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes,\n                                         int num_bytes,\n                                         const uECC_word_t *native) {\n    wordcount_t i;\n    for (i = 0; i < num_bytes; ++i) {\n        unsigned b = num_bytes - 1 - i;\n        bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));\n    }\n}\n\nuECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,\n                                         const uint8_t *bytes,\n                                         int num_bytes) {\n    wordcount_t i;\n    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);\n    for (i = 0; i < num_bytes; ++i) {\n        unsigned b = num_bytes - 1 - i;\n        native[b / uECC_WORD_SIZE] |=\n            (uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));\n    }\n}\n\n#endif /* uECC_WORD_SIZE */\n\n/* Generates a random integer in the range 0 < random < top.\n   Both random and top have num_words words. */\nuECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,\n                                          const uECC_word_t *top,\n                                          wordcount_t num_words) {\n    uECC_word_t mask = (uECC_word_t)-1;\n    uECC_word_t tries;\n    bitcount_t num_bits = uECC_vli_numBits(top, num_words);\n\n    if (!g_rng_function) {\n        return 0;\n    }\n\n    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {\n        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {\n            return 0;\n\t    }\n        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));\n        if (!uECC_vli_isZero(random, num_words) &&\n\t\t        uECC_vli_cmp(top, random, num_words) == 1) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint uECC_make_key(uint8_t *public_key,\n                  uint8_t *private_key,\n                  uECC_Curve curve) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *_private = (uECC_word_t *)private_key;\n    uECC_word_t *_public = (uECC_word_t *)public_key;\n#else\n    uECC_word_t _private[uECC_MAX_WORDS];\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t tries;\n\n    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {\n        if (!uECC_generate_random_int(_private, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {\n            return 0;\n        }\n\n        if (EccPoint_compute_public_key(_public, _private, curve)) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n            uECC_vli_nativeToBytes(private_key, BITS_TO_BYTES(curve->num_n_bits), _private);\n            uECC_vli_nativeToBytes(public_key, curve->num_bytes, _public);\n            uECC_vli_nativeToBytes(\n                public_key + curve->num_bytes, curve->num_bytes, _public + curve->num_words);\n#endif\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint uECC_shared_secret(const uint8_t *public_key,\n                       const uint8_t *private_key,\n                       uint8_t *secret,\n                       uECC_Curve curve) {\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n    uECC_word_t _private[uECC_MAX_WORDS];\n\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t *p2[2] = {_private, tmp};\n    uECC_word_t *initial_Z = 0;\n    uECC_word_t carry;\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_bytes = curve->num_bytes;\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) _private, private_key, num_bytes);\n    bcopy((uint8_t *) _public, public_key, num_bytes*2);\n#else\n    uECC_vli_bytesToNative(_private, private_key, BITS_TO_BYTES(curve->num_n_bits));\n    uECC_vli_bytesToNative(_public, public_key, num_bytes);\n    uECC_vli_bytesToNative(_public + num_words, public_key + num_bytes, num_bytes);\n#endif\n\n    /* Regularize the bitcount for the private key so that attackers cannot use a side channel\n       attack to learn the number of leading zeros. */\n    carry = regularize_k(_private, _private, tmp, curve);\n\n    /* If an RNG function was specified, try to get a random initial Z value to improve\n       protection against side-channel attacks. */\n    if (g_rng_function) {\n        if (!uECC_generate_random_int(p2[carry], curve->p, num_words)) {\n            return 0;\n        }\n        initial_Z = p2[carry];\n    }\n\n    EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1, curve);\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) secret, (uint8_t *) _public, num_bytes);\n#else\n    uECC_vli_nativeToBytes(secret, num_bytes, _public);\n#endif\n    return !EccPoint_isZero(_public, curve);\n}\n\n#if uECC_SUPPORT_COMPRESSED_POINT\nvoid uECC_compress(const uint8_t *public_key, uint8_t *compressed, uECC_Curve curve) {\n    wordcount_t i;\n    for (i = 0; i < curve->num_bytes; ++i) {\n        compressed[i+1] = public_key[i];\n    }\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    compressed[0] = 2 + (public_key[curve->num_bytes] & 0x01);\n#else\n    compressed[0] = 2 + (public_key[curve->num_bytes * 2 - 1] & 0x01);\n#endif\n}\n\nvoid uECC_decompress(const uint8_t *compressed, uint8_t *public_key, uECC_Curve curve) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *point = (uECC_word_t *)public_key;\n#else\n    uECC_word_t point[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t *y = point + curve->num_words;\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy(public_key, compressed+1, curve->num_bytes);\n#else\n    uECC_vli_bytesToNative(point, compressed + 1, curve->num_bytes);\n#endif\n    curve->x_side(y, point, curve);\n    curve->mod_sqrt(y, curve);\n\n    if ((y[0] & 0x01) != (compressed[0] & 0x01)) {\n        uECC_vli_sub(y, curve->p, y, curve->num_words);\n    }\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(public_key, curve->num_bytes, point);\n    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);\n#endif\n}\n#endif /* uECC_SUPPORT_COMPRESSED_POINT */\n\nuECC_VLI_API int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {\n    uECC_word_t tmp1[uECC_MAX_WORDS];\n    uECC_word_t tmp2[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n\n    /* The point at infinity is invalid. */\n    if (EccPoint_isZero(point, curve)) {\n        return 0;\n    }\n\n    /* x and y must be smaller than p. */\n    if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||\n            uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {\n        return 0;\n    }\n\n    uECC_vli_modSquare_fast(tmp1, point + num_words, curve);\n    curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */\n\n    /* Make sure that y^2 == x^3 + ax + b */\n    return (int)(uECC_vli_equal(tmp1, tmp2, num_words));\n}\n\nint uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *_public = (uECC_word_t *)public_key;\n#else\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);\n    uECC_vli_bytesToNative(\n        _public + curve->num_words, public_key + curve->num_bytes, curve->num_bytes);\n#endif\n    return uECC_valid_point(_public, curve);\n}\n\nint uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve) {\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *_private = (uECC_word_t *)private_key;\n    uECC_word_t *_public = (uECC_word_t *)public_key;\n#else\n    uECC_word_t _private[uECC_MAX_WORDS];\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_bytesToNative(_private, private_key, BITS_TO_BYTES(curve->num_n_bits));\n#endif\n\n    /* Make sure the private key is in the range [1, n-1]. */\n    if (uECC_vli_isZero(_private, BITS_TO_WORDS(curve->num_n_bits))) {\n        return 0;\n    }\n\n    if (uECC_vli_cmp(curve->n, _private, BITS_TO_WORDS(curve->num_n_bits)) != 1) {\n        return 0;\n    }\n\n    /* Compute public key. */\n    if (!EccPoint_compute_public_key(_public, _private, curve)) {\n        return 0;\n    }\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(public_key, curve->num_bytes, _public);\n    uECC_vli_nativeToBytes(\n        public_key + curve->num_bytes, curve->num_bytes, _public + curve->num_words);\n#endif\n    return 1;\n}\n\n\n/* -------- ECDSA code -------- */\n\nstatic void bits2int(uECC_word_t *native,\n                     const uint8_t *bits,\n                     unsigned bits_size,\n                     uECC_Curve curve) {\n    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);\n    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    int shift;\n    uECC_word_t carry;\n    uECC_word_t *ptr;\n\n    if (bits_size > num_n_bytes) {\n        bits_size = num_n_bytes;\n    }\n\n    uECC_vli_clear(native, num_n_words);\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) native, bits, bits_size);\n#else\n    uECC_vli_bytesToNative(native, bits, bits_size);\n#endif\n    if (bits_size * 8 <= (unsigned)curve->num_n_bits) {\n        return;\n    }\n    shift = bits_size * 8 - curve->num_n_bits;\n    carry = 0;\n    ptr = native + num_n_words;\n    while (ptr-- > native) {\n        uECC_word_t temp = *ptr;\n        *ptr = (temp >> shift) | carry;\n        carry = temp << (uECC_WORD_BITS - shift);\n    }\n\n    /* Reduce mod curve_n */\n    if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {\n        uECC_vli_sub(native, native, curve->n, num_n_words);\n    }\n}\n\nstatic int uECC_sign_with_k(const uint8_t *private_key,\n                            const uint8_t *message_hash,\n                            unsigned hash_size,\n                            uECC_word_t *k,\n                            uint8_t *signature,\n                            uECC_Curve curve) {\n\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t s[uECC_MAX_WORDS];\n    uECC_word_t *k2[2] = {tmp, s};\n    uECC_word_t *initial_Z = 0;\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *p = (uECC_word_t *)signature;\n#else\n    uECC_word_t p[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t carry;\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n\n    /* Make sure 0 < k < curve_n */\n    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {\n        return 0;\n    }\n\n    carry = regularize_k(k, tmp, s, curve);\n    /* If an RNG function was specified, try to get a random initial Z value to improve\n       protection against side-channel attacks. */\n    if (g_rng_function) {\n        if (!uECC_generate_random_int(k2[carry], curve->p, num_words)) {\n            return 0;\n        }\n        initial_Z = k2[carry];\n    }\n    EccPoint_mult(p, curve->G, k2[!carry], initial_Z, num_n_bits + 1, curve);\n    if (uECC_vli_isZero(p, num_words)) {\n        return 0;\n    }\n\n    /* If an RNG function was specified, get a random number\n       to prevent side channel analysis of k. */\n    if (!g_rng_function) {\n        uECC_vli_clear(tmp, num_n_words);\n        tmp[0] = 1;\n    } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {\n        return 0;\n    }\n\n    /* Prevent side channel analysis of uECC_vli_modInv() to determine\n       bits of k / the private key by premultiplying by a random number */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */\n    uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) tmp, private_key, BITS_TO_BYTES(curve->num_n_bits));\n#else\n    uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); /* tmp = d */\n#endif\n\n    s[num_n_words - 1] = 0;\n    uECC_vli_set(s, p, num_words);\n    uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */\n\n    bits2int(tmp, message_hash, hash_size, curve);\n    uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */\n    uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */\n    if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {\n        return 0;\n    }\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes);\n#else\n    uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);\n#endif\n    return 1;\n}\n\nint uECC_sign(const uint8_t *private_key,\n              const uint8_t *message_hash,\n              unsigned hash_size,\n              uint8_t *signature,\n              uECC_Curve curve) {\n    uECC_word_t k[uECC_MAX_WORDS];\n    uECC_word_t tries;\n\n    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {\n        if (!uECC_generate_random_int(k, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {\n            return 0;\n        }\n\n        if (uECC_sign_with_k(private_key, message_hash, hash_size, k, signature, curve)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* Compute an HMAC using K as a key (as in RFC 6979). Note that K is always\n   the same size as the hash result size. */\nstatic void HMAC_init(const uECC_HashContext *hash_context, const uint8_t *K) {\n    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;\n    unsigned i;\n    for (i = 0; i < hash_context->result_size; ++i)\n        pad[i] = K[i] ^ 0x36;\n    for (; i < hash_context->block_size; ++i)\n        pad[i] = 0x36;\n\n    hash_context->init_hash(hash_context);\n    hash_context->update_hash(hash_context, pad, hash_context->block_size);\n}\n\nstatic void HMAC_update(const uECC_HashContext *hash_context,\n                        const uint8_t *message,\n                        unsigned message_size) {\n    hash_context->update_hash(hash_context, message, message_size);\n}\n\nstatic void HMAC_finish(const uECC_HashContext *hash_context,\n                        const uint8_t *K,\n                        uint8_t *result) {\n    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;\n    unsigned i;\n    for (i = 0; i < hash_context->result_size; ++i)\n        pad[i] = K[i] ^ 0x5c;\n    for (; i < hash_context->block_size; ++i)\n        pad[i] = 0x5c;\n\n    hash_context->finish_hash(hash_context, result);\n\n    hash_context->init_hash(hash_context);\n    hash_context->update_hash(hash_context, pad, hash_context->block_size);\n    hash_context->update_hash(hash_context, result, hash_context->result_size);\n    hash_context->finish_hash(hash_context, result);\n}\n\n/* V = HMAC_K(V) */\nstatic void update_V(const uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {\n    HMAC_init(hash_context, K);\n    HMAC_update(hash_context, V, hash_context->result_size);\n    HMAC_finish(hash_context, K, V);\n}\n\n/* Deterministic signing, similar to RFC 6979. Differences are:\n    * We just use H(m) directly rather than bits2octets(H(m))\n      (it is not reduced modulo curve_n).\n    * We generate a value for k (aka T) directly rather than converting endianness.\n\n   Layout of hash_context->tmp: <K> | <V> | (1 byte overlapped 0x00 or 0x01) / <HMAC pad> */\nint uECC_sign_deterministic(const uint8_t *private_key,\n                            const uint8_t *message_hash,\n                            unsigned hash_size,\n                            const uECC_HashContext *hash_context,\n                            uint8_t *signature,\n                            uECC_Curve curve) {\n    uint8_t *K = hash_context->tmp;\n    uint8_t *V = K + hash_context->result_size;\n    wordcount_t num_bytes = curve->num_bytes;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n    uECC_word_t tries;\n    unsigned i;\n    for (i = 0; i < hash_context->result_size; ++i) {\n        V[i] = 0x01;\n        K[i] = 0;\n    }\n\n    /* K = HMAC_K(V || 0x00 || int2octets(x) || h(m)) */\n    HMAC_init(hash_context, K);\n    V[hash_context->result_size] = 0x00;\n    HMAC_update(hash_context, V, hash_context->result_size + 1);\n    HMAC_update(hash_context, private_key, num_bytes);\n    HMAC_update(hash_context, message_hash, hash_size);\n    HMAC_finish(hash_context, K, K);\n\n    update_V(hash_context, K, V);\n\n    /* K = HMAC_K(V || 0x01 || int2octets(x) || h(m)) */\n    HMAC_init(hash_context, K);\n    V[hash_context->result_size] = 0x01;\n    HMAC_update(hash_context, V, hash_context->result_size + 1);\n    HMAC_update(hash_context, private_key, num_bytes);\n    HMAC_update(hash_context, message_hash, hash_size);\n    HMAC_finish(hash_context, K, K);\n\n    update_V(hash_context, K, V);\n\n    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {\n        uECC_word_t T[uECC_MAX_WORDS];\n        uint8_t *T_ptr = (uint8_t *)T;\n        wordcount_t T_bytes = 0;\n        for (;;) {\n            update_V(hash_context, K, V);\n            for (i = 0; i < hash_context->result_size; ++i) {\n                T_ptr[T_bytes++] = V[i];\n                if (T_bytes >= num_n_words * uECC_WORD_SIZE) {\n                    goto filled;\n                }\n            }\n        }\n    filled:\n        if ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8 > num_n_bits) {\n            uECC_word_t mask = (uECC_word_t)-1;\n            T[num_n_words - 1] &=\n                mask >> ((bitcount_t)(num_n_words * uECC_WORD_SIZE * 8 - num_n_bits));\n        }\n\n        if (uECC_sign_with_k(private_key, message_hash, hash_size, T, signature, curve)) {\n            return 1;\n        }\n\n        /* K = HMAC_K(V || 0x00) */\n        HMAC_init(hash_context, K);\n        V[hash_context->result_size] = 0x00;\n        HMAC_update(hash_context, V, hash_context->result_size + 1);\n        HMAC_finish(hash_context, K, K);\n\n        update_V(hash_context, K, V);\n    }\n    return 0;\n}\n\nstatic bitcount_t smax(bitcount_t a, bitcount_t b) {\n    return (a > b ? a : b);\n}\n\nint uECC_verify(const uint8_t *public_key,\n                const uint8_t *message_hash,\n                unsigned hash_size,\n                const uint8_t *signature,\n                uECC_Curve curve) {\n    uECC_word_t u1[uECC_MAX_WORDS], u2[uECC_MAX_WORDS];\n    uECC_word_t z[uECC_MAX_WORDS];\n    uECC_word_t sum[uECC_MAX_WORDS * 2];\n    uECC_word_t rx[uECC_MAX_WORDS];\n    uECC_word_t ry[uECC_MAX_WORDS];\n    uECC_word_t tx[uECC_MAX_WORDS];\n    uECC_word_t ty[uECC_MAX_WORDS];\n    uECC_word_t tz[uECC_MAX_WORDS];\n    const uECC_word_t *points[4];\n    const uECC_word_t *point;\n    bitcount_t num_bits;\n    bitcount_t i;\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *_public = (uECC_word_t *)public_key;\n#else\n    uECC_word_t _public[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n\n    rx[num_n_words - 1] = 0;\n    r[num_n_words - 1] = 0;\n    s[num_n_words - 1] = 0;\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) r, signature, curve->num_bytes);\n    bcopy((uint8_t *) s, signature + curve->num_bytes, curve->num_bytes);\n#else\n    uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);\n    uECC_vli_bytesToNative(\n        _public + num_words, public_key + curve->num_bytes, curve->num_bytes);\n    uECC_vli_bytesToNative(r, signature, curve->num_bytes);\n    uECC_vli_bytesToNative(s, signature + curve->num_bytes, curve->num_bytes);\n#endif\n\n    /* r, s must not be 0. */\n    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {\n        return 0;\n    }\n\n    /* r, s must be < n. */\n    if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||\n            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {\n        return 0;\n    }\n\n    /* Calculate u1 and u2. */\n    uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */\n    u1[num_n_words - 1] = 0;\n    bits2int(u1, message_hash, hash_size, curve);\n    uECC_vli_modMult(u1, u1, z, curve->n, num_n_words); /* u1 = e/s */\n    uECC_vli_modMult(u2, r, z, curve->n, num_n_words); /* u2 = r/s */\n\n    /* Calculate sum = G + Q. */\n    uECC_vli_set(sum, _public, num_words);\n    uECC_vli_set(sum + num_words, _public + num_words, num_words);\n    uECC_vli_set(tx, curve->G, num_words);\n    uECC_vli_set(ty, curve->G + num_words, num_words);\n    uECC_vli_modSub(z, sum, tx, curve->p, num_words); /* z = x2 - x1 */\n    XYcZ_add(tx, ty, sum, sum + num_words, curve);\n    uECC_vli_modInv(z, z, curve->p, num_words); /* z = 1/z */\n    apply_z(sum, sum + num_words, z, curve);\n\n    /* Use Shamir's trick to calculate u1*G + u2*Q */\n    points[0] = 0;\n    points[1] = curve->G;\n    points[2] = _public;\n    points[3] = sum;\n    num_bits = smax(uECC_vli_numBits(u1, num_n_words),\n                    uECC_vli_numBits(u2, num_n_words));\n\n    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |\n                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];\n    uECC_vli_set(rx, point, num_words);\n    uECC_vli_set(ry, point + num_words, num_words);\n    uECC_vli_clear(z, num_words);\n    z[0] = 1;\n\n    for (i = num_bits - 2; i >= 0; --i) {\n        uECC_word_t index;\n        curve->double_jacobian(rx, ry, z, curve);\n\n        index = (!!uECC_vli_testBit(u1, i)) | ((!!uECC_vli_testBit(u2, i)) << 1);\n        point = points[index];\n        if (point) {\n            uECC_vli_set(tx, point, num_words);\n            uECC_vli_set(ty, point + num_words, num_words);\n            apply_z(tx, ty, z, curve);\n            uECC_vli_modSub(tz, rx, tx, curve->p, num_words); /* Z = x2 - x1 */\n            XYcZ_add(tx, ty, rx, ry, curve);\n            uECC_vli_modMult_fast(z, z, tz, curve);\n        }\n    }\n\n    uECC_vli_modInv(z, z, curve->p, num_words); /* Z = 1/Z */\n    apply_z(rx, ry, z, curve);\n\n    /* v = x1 (mod n) */\n    if (uECC_vli_cmp_unsafe(curve->n, rx, num_n_words) != 1) {\n        uECC_vli_sub(rx, rx, curve->n, num_n_words);\n    }\n\n    /* Accept only if v == r. */\n    return (int)(uECC_vli_equal(rx, r, num_words));\n}\n\n#if uECC_ENABLE_VLI_API\n\nunsigned uECC_curve_num_words(uECC_Curve curve) {\n    return curve->num_words;\n}\n\nunsigned uECC_curve_num_bytes(uECC_Curve curve) {\n    return curve->num_bytes;\n}\n\nunsigned uECC_curve_num_bits(uECC_Curve curve) {\n    return curve->num_bytes * 8;\n}\n\nunsigned uECC_curve_num_n_words(uECC_Curve curve) {\n    return BITS_TO_WORDS(curve->num_n_bits);\n}\n\nunsigned uECC_curve_num_n_bytes(uECC_Curve curve) {\n    return BITS_TO_BYTES(curve->num_n_bits);\n}\n\nunsigned uECC_curve_num_n_bits(uECC_Curve curve) {\n    return curve->num_n_bits;\n}\n\nconst uECC_word_t *uECC_curve_p(uECC_Curve curve) {\n    return curve->p;\n}\n\nconst uECC_word_t *uECC_curve_n(uECC_Curve curve) {\n    return curve->n;\n}\n\nconst uECC_word_t *uECC_curve_G(uECC_Curve curve) {\n    return curve->G;\n}\n\nconst uECC_word_t *uECC_curve_b(uECC_Curve curve) {\n    return curve->b;\n}\n\n#if uECC_SUPPORT_COMPRESSED_POINT\nvoid uECC_vli_mod_sqrt(uECC_word_t *a, uECC_Curve curve) {\n    curve->mod_sqrt(a, curve);\n}\n#endif\n\nvoid uECC_vli_mmod_fast(uECC_word_t *result, uECC_word_t *product, uECC_Curve curve) {\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    curve->mmod_fast(result, product);\n#else\n    uECC_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}\n\nvoid uECC_point_mult(uECC_word_t *result,\n                     const uECC_word_t *point,\n                     const uECC_word_t *scalar,\n                     uECC_Curve curve) {\n    uECC_word_t tmp1[uECC_MAX_WORDS];\n    uECC_word_t tmp2[uECC_MAX_WORDS];\n    uECC_word_t *p2[2] = {tmp1, tmp2};\n    uECC_word_t carry = regularize_k(scalar, tmp1, tmp2, curve);\n\n    EccPoint_mult(result, point, p2[!carry], 0, curve->num_n_bits + 1, curve);\n}\n\n#endif /* uECC_ENABLE_VLI_API */\n"], "filenames": ["uECC.c"], "buggy_code_start_loc": [1213], "buggy_code_end_loc": [1476], "fixing_code_start_loc": [1213], "fixing_code_end_loc": [1485], "type": "NVD-CWE-noinfo", "message": "The ECDSA operation of the micro-ecc library 1.0 is vulnerable to simple power analysis attacks which allows an adversary to extract the private ECC key.", "other": {"cve": {"id": "CVE-2020-27209", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-20T21:15:07.653", "lastModified": "2021-05-27T18:21:37.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ECDSA operation of the micro-ecc library 1.0 is vulnerable to simple power analysis attacks which allows an adversary to extract the private ECC key."}, {"lang": "es", "value": "La operaci\u00f3n ECDSA de la biblioteca micro-ecc versi\u00f3n 1.0 es vulnerable a ataques de an\u00e1lisis de energ\u00eda simple que permiten a un adversario extraer la clave ECC privada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:micro-ecc_project:micro-ecc:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "30CAFFC3-13D5-4864-8F8E-9407DDA24148"}]}]}], "references": [{"url": "https://eprint.iacr.org/2021/640", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/kmackay/micro-ecc/commit/1b5f5cea5145c96dd8791b9b2c41424fc74c2172", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kmackay/micro-ecc/releases", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.aisec.fraunhofer.de/de/das-institut/wissenschaftliche-exzellenz/security-and-trust-in-open-source-security-tokens.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.aisec.fraunhofer.de/en/FirmwareProtection.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kmackay/micro-ecc/commit/1b5f5cea5145c96dd8791b9b2c41424fc74c2172"}}