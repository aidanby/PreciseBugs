{"buggy_code": ["/*\n * Copyright \u00a9 2014-2019 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <gio/gdesktopappinfo.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/vfs.h>\n#include <sys/personality.h>\n#include <grp.h>\n#include <unistd.h>\n#include <gio/gunixfdlist.h>\n#ifdef HAVE_DCONF\n#include <dconf/dconf.h>\n#endif\n#ifdef HAVE_LIBMALCONTENT\n#include <libmalcontent/malcontent.h>\n#endif\n\n#include \"flatpak-syscalls-private.h\"\n\n#ifdef ENABLE_SECCOMP\n#include <seccomp.h>\n#endif\n\n#ifdef ENABLE_XAUTH\n#include <X11/Xauth.h>\n#endif\n\n#include <glib/gi18n-lib.h>\n\n#include <gio/gio.h>\n#include \"libglnx/libglnx.h\"\n\n#include \"flatpak-run-private.h\"\n#include \"flatpak-proxy.h\"\n#include \"flatpak-utils-base-private.h\"\n#include \"flatpak-dir-private.h\"\n#include \"flatpak-instance-private.h\"\n#include \"flatpak-systemd-dbus-generated.h\"\n#include \"flatpak-document-dbus-generated.h\"\n#include \"flatpak-error.h\"\n#include \"session-helper/flatpak-session-helper.h\"\n\n#define DEFAULT_SHELL \"/bin/sh\"\n\nconst char * const abs_usrmerged_dirs[] =\n{\n  \"/bin\",\n  \"/lib\",\n  \"/lib32\",\n  \"/lib64\",\n  \"/sbin\",\n  NULL\n};\nconst char * const *flatpak_abs_usrmerged_dirs = abs_usrmerged_dirs;\n\nstatic char *\nextract_unix_path_from_dbus_address (const char *address)\n{\n  const char *path, *path_end;\n\n  if (address == NULL)\n    return NULL;\n\n  if (!g_str_has_prefix (address, \"unix:\"))\n    return NULL;\n\n  path = strstr (address, \"path=\");\n  if (path == NULL)\n    return NULL;\n  path += strlen (\"path=\");\n  path_end = path;\n  while (*path_end != 0 && *path_end != ',')\n    path_end++;\n\n  return g_strndup (path, path_end - path);\n}\n\n#ifdef ENABLE_XAUTH\nstatic gboolean\nauth_streq (char *str,\n            char *au_str,\n            int   au_len)\n{\n  return au_len == strlen (str) && memcmp (str, au_str, au_len) == 0;\n}\n\nstatic gboolean\nxauth_entry_should_propagate (Xauth *xa,\n                              char  *hostname,\n                              char  *number)\n{\n  /* ensure entry isn't for remote access */\n  if (xa->family != FamilyLocal && xa->family != FamilyWild)\n    return FALSE;\n\n  /* ensure entry is for this machine */\n  if (xa->family == FamilyLocal && !auth_streq (hostname, xa->address, xa->address_length))\n    {\n      /* OpenSUSE inherits the hostname value from DHCP without updating\n       * its X11 authentication cookie. The old hostname value can still\n       * be found in the environment variable XAUTHLOCALHOSTNAME.\n       * For reference:\n       * https://bugzilla.opensuse.org/show_bug.cgi?id=262309\n       * For this reason if we have a cookie whose address is equal to the\n       * variable XAUTHLOCALHOSTNAME, we still need to propagate it, but\n       * we also need to change its address to `unames.nodename`.\n       */\n      const char *xauth_local_hostname;\n      xauth_local_hostname = g_getenv (\"XAUTHLOCALHOSTNAME\");\n      if (xauth_local_hostname == NULL)\n        return FALSE;\n\n      if (!auth_streq ((char *) xauth_local_hostname, xa->address, xa->address_length))\n        return FALSE;\n    }\n\n  /* ensure entry is for this session */\n  if (xa->number != NULL && !auth_streq (number, xa->number, xa->number_length))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic void\nwrite_xauth (char *number, FILE *output)\n{\n  Xauth *xa, local_xa;\n  char *filename;\n  FILE *f;\n  struct utsname unames;\n\n  if (uname (&unames))\n    {\n      g_warning (\"uname failed\");\n      return;\n    }\n\n  filename = XauFileName ();\n  f = fopen (filename, \"rb\");\n  if (f == NULL)\n    return;\n\n  while (TRUE)\n    {\n      xa = XauReadAuth (f);\n      if (xa == NULL)\n        break;\n      if (xauth_entry_should_propagate (xa, unames.nodename, number))\n        {\n          local_xa = *xa;\n          if (local_xa.number)\n            {\n              local_xa.number = \"99\";\n              local_xa.number_length = 2;\n            }\n\n          if (local_xa.family == FamilyLocal &&\n              !auth_streq (unames.nodename, local_xa.address, local_xa.address_length))\n            {\n              /* If we decided to propagate this cookie, but its address\n               * doesn't match `unames.nodename`, we need to change it or\n               * inside the container it will not work.\n               */\n              local_xa.address = unames.nodename;\n              local_xa.address_length = strlen (local_xa.address);\n            }\n\n          if (!XauWriteAuth (output, &local_xa))\n            g_warning (\"xauth write error\");\n        }\n\n      XauDisposeAuth (xa);\n    }\n\n  fclose (f);\n}\n#endif /* ENABLE_XAUTH */\n\nstatic void\nflatpak_run_add_x11_args (FlatpakBwrap *bwrap,\n                          gboolean      allowed)\n{\n  g_autofree char *x11_socket = NULL;\n  const char *display;\n\n  /* Always cover /tmp/.X11-unix, that way we never see the host one in case\n   * we have access to the host /tmp. If you request X access we'll put the right\n   * thing in this anyway.\n   *\n   * We need to be a bit careful here, because there are two situations in\n   * which potentially hostile processes have access to /tmp and could\n   * create symlinks, which in principle could cause us to create the\n   * directory and mount the tmpfs at the target of the symlink instead\n   * of in the intended place:\n   *\n   * - With --filesystem=/tmp, it's the host /tmp - but because of the\n   *   special historical status of /tmp/.X11-unix, we can assume that\n   *   it is pre-created by the host system before user code gets to run.\n   *\n   * - When /tmp is shared between all instances of the same app ID,\n   *   in principle the app has control over what's in /tmp, but in\n   *   practice it can't interfere with /tmp/.X11-unix, because we do\n   *   this unconditionally - therefore by the time app code runs,\n   *   /tmp/.X11-unix is already a mount point, meaning the app cannot\n   *   rename or delete it.\n   */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--tmpfs\", \"/tmp/.X11-unix\",\n                          NULL);\n\n  if (!allowed)\n    {\n      flatpak_bwrap_unset_env (bwrap, \"DISPLAY\");\n      return;\n    }\n\n  g_debug (\"Allowing x11 access\");\n\n  display = g_getenv (\"DISPLAY\");\n  if (display && display[0] == ':' && g_ascii_isdigit (display[1]))\n    {\n      const char *display_nr = &display[1];\n      const char *display_nr_end = display_nr;\n      g_autofree char *d = NULL;\n\n      while (g_ascii_isdigit (*display_nr_end))\n        display_nr_end++;\n\n      d = g_strndup (display_nr, display_nr_end - display_nr);\n      x11_socket = g_strdup_printf (\"/tmp/.X11-unix/X%s\", d);\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", x11_socket, \"/tmp/.X11-unix/X99\",\n                              NULL);\n      flatpak_bwrap_set_env (bwrap, \"DISPLAY\", \":99.0\", TRUE);\n\n#ifdef ENABLE_XAUTH\n      g_auto(GLnxTmpfile) xauth_tmpf  = { 0, };\n\n      if (glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &xauth_tmpf, NULL))\n        {\n          FILE *output = fdopen (xauth_tmpf.fd, \"wb\");\n          if (output != NULL)\n            {\n              /* fd is now owned by output, steal it from the tmpfile */\n              int tmp_fd = dup (glnx_steal_fd (&xauth_tmpf.fd));\n              if (tmp_fd != -1)\n                {\n                  static const char dest[] = \"/run/flatpak/Xauthority\";\n\n                  write_xauth (d, output);\n                  flatpak_bwrap_add_args_data_fd (bwrap, \"--ro-bind-data\", tmp_fd, dest);\n\n                  flatpak_bwrap_set_env (bwrap, \"XAUTHORITY\", dest, TRUE);\n                }\n\n              fclose (output);\n\n              if (tmp_fd != -1)\n                lseek (tmp_fd, 0, SEEK_SET);\n            }\n        }\n#endif\n    }\n  else\n    {\n      flatpak_bwrap_unset_env (bwrap, \"DISPLAY\");\n    }\n}\n\nstatic gboolean\nflatpak_run_add_wayland_args (FlatpakBwrap *bwrap)\n{\n  const char *wayland_display;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *wayland_socket = NULL;\n  g_autofree char *sandbox_wayland_socket = NULL;\n  gboolean res = FALSE;\n  struct stat statbuf;\n\n  wayland_display = g_getenv (\"WAYLAND_DISPLAY\");\n  if (!wayland_display)\n    wayland_display = \"wayland-0\";\n\n  wayland_socket = g_build_filename (user_runtime_dir, wayland_display, NULL);\n\n  if (!g_str_has_prefix (wayland_display, \"wayland-\") ||\n      strchr (wayland_display, '/') != NULL)\n    {\n      wayland_display = \"wayland-0\";\n      flatpak_bwrap_set_env (bwrap, \"WAYLAND_DISPLAY\", wayland_display, TRUE);\n    }\n\n  sandbox_wayland_socket = g_strdup_printf (\"/run/flatpak/%s\", wayland_display);\n\n  if (stat (wayland_socket, &statbuf) == 0 &&\n      (statbuf.st_mode & S_IFMT) == S_IFSOCK)\n    {\n      res = TRUE;\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", wayland_socket, sandbox_wayland_socket,\n                              NULL);\n      flatpak_bwrap_add_runtime_dir_member (bwrap, wayland_display);\n    }\n  return res;\n}\n\nstatic void\nflatpak_run_add_ssh_args (FlatpakBwrap *bwrap)\n{\n  static const char sandbox_auth_socket[] = \"/run/flatpak/ssh-auth\";\n  const char * auth_socket;\n\n  auth_socket = g_getenv (\"SSH_AUTH_SOCK\");\n\n  if (!auth_socket)\n    return; /* ssh agent not present */\n\n  if (!g_file_test (auth_socket, G_FILE_TEST_EXISTS))\n    {\n      /* Let's clean it up, so that the application will not try to connect */\n      flatpak_bwrap_unset_env (bwrap, \"SSH_AUTH_SOCK\");\n      return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", auth_socket, sandbox_auth_socket,\n                          NULL);\n  flatpak_bwrap_set_env (bwrap, \"SSH_AUTH_SOCK\", sandbox_auth_socket, TRUE);\n}\n\nstatic void\nflatpak_run_add_pcsc_args (FlatpakBwrap *bwrap)\n{\n  const char * pcsc_socket;\n  const char * sandbox_pcsc_socket = \"/run/pcscd/pcscd.comm\";\n\n  pcsc_socket = g_getenv (\"PCSCLITE_CSOCK_NAME\");\n  if (pcsc_socket)\n    {\n      if (!g_file_test (pcsc_socket, G_FILE_TEST_EXISTS))\n        {\n          flatpak_bwrap_unset_env (bwrap, \"PCSCLITE_CSOCK_NAME\");\n          return;\n        }\n    }\n  else\n    {\n      pcsc_socket = \"/run/pcscd/pcscd.comm\";\n      if (!g_file_test (pcsc_socket, G_FILE_TEST_EXISTS))\n        return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", pcsc_socket, sandbox_pcsc_socket,\n                          NULL);\n  flatpak_bwrap_set_env (bwrap, \"PCSCLITE_CSOCK_NAME\", sandbox_pcsc_socket, TRUE);\n}\n\nstatic gboolean\nflatpak_run_cups_check_server_is_socket (const char *server)\n{\n  if (g_str_has_prefix (server, \"/\") && strstr (server, \":\") == NULL)\n    return TRUE;\n\n  return FALSE;\n}\n\n/* Try to find a default server from a cups confguration file */\nstatic char *\nflatpak_run_get_cups_server_name_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"CUPS configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n\n      g_strchug (line);\n\n      if ((*line  == '\\0') || (*line == '#'))\n        continue;\n\n      g_auto(GStrv) tokens = g_strsplit (line, \" \", 2);\n\n      if ((tokens[0] != NULL) && (tokens[1] != NULL))\n        {\n          if (strcmp (\"ServerName\", tokens[0]) == 0)\n            {\n              g_strchug (tokens[1]);\n\n              if (flatpak_run_cups_check_server_is_socket (tokens[1]))\n                return g_strdup (tokens[1]);\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic char *\nflatpak_run_get_cups_server_name (void)\n{\n  g_autofree char * cups_server = NULL;\n  g_autofree char * cups_config_path = NULL;\n\n  /* TODO\n   * we don't currently support cups servers located on the network, if such\n   * server is detected, we simply ignore it and in the worst case we fallback\n   * to the default socket\n   */\n  cups_server = g_strdup (g_getenv (\"CUPS_SERVER\"));\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n\n  cups_config_path = g_build_filename (g_get_home_dir (), \".cups/client.conf\", NULL);\n  cups_server = flatpak_run_get_cups_server_name_config (cups_config_path);\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n\n  cups_server = flatpak_run_get_cups_server_name_config (\"/etc/cups/client.conf\");\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n\n  // Fallback to default socket\n  return g_strdup (\"/var/run/cups/cups.sock\");\n}\n\nstatic void\nflatpak_run_add_cups_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char * sandbox_server_name = g_strdup (\"/var/run/cups/cups.sock\");\n  g_autofree char * cups_server_name = flatpak_run_get_cups_server_name ();\n\n  if (!g_file_test (cups_server_name, G_FILE_TEST_EXISTS))\n    {\n      g_debug (\"Could not find CUPS server\");\n      return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", cups_server_name, sandbox_server_name,\n                          NULL);\n}\n\n/* Try to find a default server from a pulseaudio confguration file */\nstatic char *\nflatpak_run_get_pulseaudio_server_user_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"Pulseaudio user configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n\n      g_strchug (line);\n\n      if ((*line  == '\\0') || (*line == ';') || (*line == '#'))\n        continue;\n\n      if (g_str_has_prefix (line, \".include \"))\n        {\n          g_autofree char *rec_path = g_strdup (line + 9);\n          g_strstrip (rec_path);\n          char *found = flatpak_run_get_pulseaudio_server_user_config (rec_path);\n          if (found)\n            return found;\n        }\n      else if (g_str_has_prefix (line, \"[\"))\n        {\n          return NULL;\n        }\n      else\n        {\n          g_auto(GStrv) tokens = g_strsplit (line, \"=\", 2);\n\n          if ((tokens[0] != NULL) && (tokens[1] != NULL))\n            {\n              g_strchomp (tokens[0]);\n              if (strcmp (\"default-server\", tokens[0]) == 0)\n                {\n                  g_strstrip (tokens[1]);\n                  g_debug (\"Found pulseaudio socket from configuration file '%s': %s\", path, tokens[1]);\n                  return g_strdup (tokens[1]);\n                }\n            }\n        }\n    }\n\n  return NULL;\n}\n\nstatic char *\nflatpak_run_get_pulseaudio_server (void)\n{\n  const char * pulse_clientconfig;\n  char *pulse_server;\n  g_autofree char *pulse_user_config = NULL;\n\n  pulse_server = g_strdup (g_getenv (\"PULSE_SERVER\"));\n  if (pulse_server)\n    return pulse_server;\n\n  pulse_clientconfig = g_getenv (\"PULSE_CLIENTCONFIG\");\n  if (pulse_clientconfig)\n    return flatpak_run_get_pulseaudio_server_user_config (pulse_clientconfig);\n\n  pulse_user_config = g_build_filename (g_get_user_config_dir (), \"pulse/client.conf\", NULL);\n  pulse_server = flatpak_run_get_pulseaudio_server_user_config (pulse_user_config);\n  if (pulse_server)\n    return pulse_server;\n\n  pulse_server = flatpak_run_get_pulseaudio_server_user_config (\"/etc/pulse/client.conf\");\n  if (pulse_server)\n    return pulse_server;\n\n  return NULL;\n}\n\nstatic char *\nflatpak_run_parse_pulse_server (const char *value)\n{\n  g_auto(GStrv) servers = g_strsplit (value, \" \", 0);\n  gsize i;\n\n  for (i = 0; servers[i] != NULL; i++)\n    {\n      const char *server = servers[i];\n      if (g_str_has_prefix (server, \"{\"))\n        {\n          const char * closing = strstr (server, \"}\");\n          if (closing == NULL)\n            continue;\n          server = closing + 1;\n        }\n      if (g_str_has_prefix (server, \"unix:\"))\n        return g_strdup (server + 5);\n    }\n\n  return NULL;\n}\n\n/*\n * Get the machine ID as used by PulseAudio. This is the systemd/D-Bus\n * machine ID, or failing that, the hostname.\n */\nstatic char *\nflatpak_run_get_pulse_machine_id (void)\n{\n  static const char * const machine_ids[] =\n  {\n    \"/etc/machine-id\",\n    \"/var/lib/dbus/machine-id\",\n  };\n  gsize i;\n\n  for (i = 0; i < G_N_ELEMENTS (machine_ids); i++)\n    {\n      g_autofree char *ret = NULL;\n\n      if (g_file_get_contents (machine_ids[i], &ret, NULL, NULL))\n        {\n          gsize j;\n\n          g_strstrip (ret);\n\n          for (j = 0; ret[j] != '\\0'; j++)\n            {\n              if (!g_ascii_isxdigit (ret[j]))\n                break;\n            }\n\n          if (ret[0] != '\\0' && ret[j] == '\\0')\n            return g_steal_pointer (&ret);\n        }\n    }\n\n  return g_strdup (g_get_host_name ());\n}\n\n/*\n * Get the directory used by PulseAudio for its configuration.\n */\nstatic char *\nflatpak_run_get_pulse_home (void)\n{\n  /* Legacy path ~/.pulse is tried first, for compatibility */\n  {\n    const char *parent = g_get_home_dir ();\n    g_autofree char *ret = g_build_filename (parent, \".pulse\", NULL);\n\n    if (g_file_test (ret, G_FILE_TEST_IS_DIR))\n      return g_steal_pointer (&ret);\n  }\n\n  /* The more modern path, usually ~/.config/pulse */\n  {\n    const char *parent = g_get_user_config_dir ();\n    /* Usually ~/.config/pulse */\n    g_autofree char *ret = g_build_filename (parent, \"pulse\", NULL);\n\n    if (g_file_test (ret, G_FILE_TEST_IS_DIR))\n      return g_steal_pointer (&ret);\n  }\n\n  return NULL;\n}\n\n/*\n * Get the runtime directory used by PulseAudio for its socket.\n */\nstatic char *\nflatpak_run_get_pulse_runtime_dir (void)\n{\n  const char *val = NULL;\n\n  val = g_getenv (\"PULSE_RUNTIME_PATH\");\n\n  if (val != NULL)\n    return realpath (val, NULL);\n\n  {\n    const char *user_runtime_dir = g_get_user_runtime_dir ();\n\n    if (user_runtime_dir != NULL)\n      {\n        g_autofree char *dir = g_build_filename (user_runtime_dir, \"pulse\", NULL);\n\n        if (g_file_test (dir, G_FILE_TEST_IS_DIR))\n          return realpath (dir, NULL);\n      }\n  }\n\n  {\n    g_autofree char *pulse_home = flatpak_run_get_pulse_home ();\n    g_autofree char *machine_id = flatpak_run_get_pulse_machine_id ();\n\n    if (pulse_home != NULL && machine_id != NULL)\n      {\n        /* This is usually a symlink, but we take its realpath() anyway */\n        g_autofree char *dir = g_strdup_printf (\"%s/%s-runtime\", pulse_home, machine_id);\n\n        if (g_file_test (dir, G_FILE_TEST_IS_DIR))\n          return realpath (dir, NULL);\n      }\n  }\n\n  return NULL;\n}\n\nstatic void\nflatpak_run_add_pulseaudio_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *pulseaudio_server = flatpak_run_get_pulseaudio_server ();\n  g_autofree char *pulseaudio_socket = NULL;\n  g_autofree char *pulse_runtime_dir = flatpak_run_get_pulse_runtime_dir ();\n\n  if (pulseaudio_server)\n    pulseaudio_socket = flatpak_run_parse_pulse_server (pulseaudio_server);\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = g_build_filename (pulse_runtime_dir, \"native\", NULL);\n\n      if (!g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = realpath (\"/var/run/pulse/native\", NULL);\n\n      if (pulseaudio_socket && !g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  flatpak_bwrap_unset_env (bwrap, \"PULSE_SERVER\");\n\n  if (pulseaudio_socket && g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n    {\n      static const char sandbox_socket_path[] = \"/run/flatpak/pulse/native\";\n      static const char pulse_server[] = \"unix:/run/flatpak/pulse/native\";\n      static const char config_path[] = \"/run/flatpak/pulse/config\";\n      gboolean share_shm = FALSE; /* TODO: When do we add this? */\n      g_autofree char *client_config = g_strdup_printf (\"enable-shm=%s\\n\", share_shm ? \"yes\" : \"no\");\n\n      /* FIXME - error handling */\n      if (!flatpak_bwrap_add_args_data (bwrap, \"pulseaudio\", client_config, -1, config_path, NULL))\n        return;\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", pulseaudio_socket, sandbox_socket_path,\n                              NULL);\n\n      flatpak_bwrap_set_env (bwrap, \"PULSE_SERVER\", pulse_server, TRUE);\n      flatpak_bwrap_set_env (bwrap, \"PULSE_CLIENTCONFIG\", config_path, TRUE);\n      flatpak_bwrap_add_runtime_dir_member (bwrap, \"pulse\");\n    }\n  else\n    g_debug (\"Could not find pulseaudio socket\");\n\n  /* Also allow ALSA access. This was added in 1.8, and is not ideally named. However,\n   * since the practical permission of ALSA and PulseAudio are essentially the same, and\n   * since we don't want to add more permissions for something we plan to replace with\n   * portals/pipewire going forward we reinterpret pulseaudio to also mean ALSA.\n   */\n  if (g_file_test (\"/dev/snd\", G_FILE_TEST_IS_DIR))\n    flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/snd\", \"/dev/snd\", NULL);\n}\n\nstatic void\nflatpak_run_add_resolved_args (FlatpakBwrap *bwrap)\n{\n  const char *resolved_socket = \"/run/systemd/resolve/io.systemd.Resolve\";\n\n  if (g_file_test (resolved_socket, G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--bind\", resolved_socket, resolved_socket, NULL);\n}\n\nstatic void\nflatpak_run_add_journal_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *journal_socket_socket = g_strdup (\"/run/systemd/journal/socket\");\n  g_autofree char *journal_stdout_socket = g_strdup (\"/run/systemd/journal/stdout\");\n\n  if (g_file_test (journal_socket_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_socket_socket, journal_socket_socket,\n                              NULL);\n    }\n  if (g_file_test (journal_stdout_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_stdout_socket, journal_stdout_socket,\n                              NULL);\n    }\n}\n\nstatic char *\ncreate_proxy_socket (char *template)\n{\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy\", NULL);\n  g_autofree char *proxy_socket = g_build_filename (proxy_socket_dir, template, NULL);\n  int fd;\n\n  if (!glnx_shutil_mkdir_p_at (AT_FDCWD, proxy_socket_dir, 0755, NULL, NULL))\n    return NULL;\n\n  fd = g_mkstemp (proxy_socket);\n  if (fd == -1)\n    return NULL;\n\n  close (fd);\n\n  return g_steal_pointer (&proxy_socket);\n}\n\nstatic gboolean\nflatpak_run_add_system_dbus_args (FlatpakBwrap   *app_bwrap,\n                                  FlatpakBwrap   *proxy_arg_bwrap,\n                                  FlatpakContext *context,\n                                  FlatpakRunFlags flags)\n{\n  gboolean unrestricted, no_proxy;\n  const char *dbus_address = g_getenv (\"DBUS_SYSTEM_BUS_ADDRESS\");\n  g_autofree char *real_dbus_address = NULL;\n  g_autofree char *dbus_system_socket = NULL;\n\n  unrestricted = (context->sockets & FLATPAK_CONTEXT_SOCKET_SYSTEM_BUS) != 0;\n  if (unrestricted)\n    g_debug (\"Allowing system-dbus access\");\n\n  no_proxy = (flags & FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY) != 0;\n\n  if (dbus_address != NULL)\n    dbus_system_socket = extract_unix_path_from_dbus_address (dbus_address);\n  else if (g_file_test (\"/var/run/dbus/system_bus_socket\", G_FILE_TEST_EXISTS))\n    dbus_system_socket = g_strdup (\"/var/run/dbus/system_bus_socket\");\n\n  if (dbus_system_socket != NULL && unrestricted)\n    {\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", dbus_system_socket, \"/run/dbus/system_bus_socket\",\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SYSTEM_BUS_ADDRESS\", \"unix:path=/run/dbus/system_bus_socket\", TRUE);\n\n      return TRUE;\n    }\n  else if (!no_proxy && flatpak_context_get_needs_system_bus_proxy (context))\n    {\n      g_autofree char *proxy_socket = create_proxy_socket (\"system-bus-proxy-XXXXXX\");\n\n      if (proxy_socket == NULL)\n        return FALSE;\n\n      if (dbus_address)\n        real_dbus_address = g_strdup (dbus_address);\n      else\n        real_dbus_address = g_strdup_printf (\"unix:path=%s\", dbus_system_socket);\n\n      flatpak_bwrap_add_args (proxy_arg_bwrap, real_dbus_address, proxy_socket, NULL);\n\n      if (!unrestricted)\n        flatpak_context_add_bus_filters (context, NULL, FALSE, flags & FLATPAK_RUN_FLAG_SANDBOX, proxy_arg_bwrap);\n\n      if ((flags & FLATPAK_RUN_FLAG_LOG_SYSTEM_BUS) != 0)\n        flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", proxy_socket, \"/run/dbus/system_bus_socket\",\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SYSTEM_BUS_ADDRESS\", \"unix:path=/run/dbus/system_bus_socket\", TRUE);\n\n      return TRUE;\n    }\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_run_add_session_dbus_args (FlatpakBwrap   *app_bwrap,\n                                   FlatpakBwrap   *proxy_arg_bwrap,\n                                   FlatpakContext *context,\n                                   FlatpakRunFlags flags,\n                                   const char     *app_id)\n{\n  static const char sandbox_socket_path[] = \"/run/flatpak/bus\";\n  static const char sandbox_dbus_address[] = \"unix:path=/run/flatpak/bus\";\n  gboolean unrestricted, no_proxy;\n  const char *dbus_address = g_getenv (\"DBUS_SESSION_BUS_ADDRESS\");\n  g_autofree char *dbus_session_socket = NULL;\n\n  unrestricted = (context->sockets & FLATPAK_CONTEXT_SOCKET_SESSION_BUS) != 0;\n\n  if (dbus_address != NULL)\n    {\n      dbus_session_socket = extract_unix_path_from_dbus_address (dbus_address);\n    }\n  else\n    {\n      g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n      struct stat statbuf;\n\n      dbus_session_socket = g_build_filename (user_runtime_dir, \"bus\", NULL);\n\n      if (stat (dbus_session_socket, &statbuf) < 0\n          || (statbuf.st_mode & S_IFMT) != S_IFSOCK\n          || statbuf.st_uid != getuid ())\n        return FALSE;\n    }\n\n  if (unrestricted)\n    g_debug (\"Allowing session-dbus access\");\n\n  no_proxy = (flags & FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY) != 0;\n\n  if (dbus_session_socket != NULL && unrestricted)\n    {\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", dbus_session_socket, sandbox_socket_path,\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SESSION_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n      flatpak_bwrap_add_runtime_dir_member (app_bwrap, \"bus\");\n\n      return TRUE;\n    }\n  else if (!no_proxy && dbus_address != NULL)\n    {\n      g_autofree char *proxy_socket = create_proxy_socket (\"session-bus-proxy-XXXXXX\");\n\n      if (proxy_socket == NULL)\n        return FALSE;\n\n      flatpak_bwrap_add_args (proxy_arg_bwrap, dbus_address, proxy_socket, NULL);\n\n      if (!unrestricted)\n        {\n          flatpak_context_add_bus_filters (context, app_id, TRUE, flags & FLATPAK_RUN_FLAG_SANDBOX, proxy_arg_bwrap);\n\n          /* Allow calling any interface+method on all portals, but only receive broadcasts under /org/desktop/portal */\n          flatpak_bwrap_add_arg (proxy_arg_bwrap,\n                                 \"--call=org.freedesktop.portal.*=*\");\n          flatpak_bwrap_add_arg (proxy_arg_bwrap,\n                                 \"--broadcast=org.freedesktop.portal.*=@/org/freedesktop/portal/*\");\n        }\n\n      if ((flags & FLATPAK_RUN_FLAG_LOG_SESSION_BUS) != 0)\n        flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SESSION_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n      flatpak_bwrap_add_runtime_dir_member (app_bwrap, \"bus\");\n\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_run_add_a11y_dbus_args (FlatpakBwrap   *app_bwrap,\n                                FlatpakBwrap   *proxy_arg_bwrap,\n                                FlatpakContext *context,\n                                FlatpakRunFlags flags)\n{\n  static const char sandbox_socket_path[] = \"/run/flatpak/at-spi-bus\";\n  static const char sandbox_dbus_address[] = \"unix:path=/run/flatpak/at-spi-bus\";\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *a11y_address = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDBusMessage) reply = NULL;\n  g_autoptr(GDBusMessage) msg = NULL;\n  g_autofree char *proxy_socket = NULL;\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY) != 0)\n    return FALSE;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus == NULL)\n    return FALSE;\n\n  msg = g_dbus_message_new_method_call (\"org.a11y.Bus\", \"/org/a11y/bus\", \"org.a11y.Bus\", \"GetAddress\");\n  g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n  reply =\n    g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                    G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                    30000,\n                                                    NULL,\n                                                    NULL,\n                                                    NULL);\n  if (reply)\n    {\n      if (g_dbus_message_to_gerror (reply, &local_error))\n        {\n          if (!g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n            g_message (\"Can't find a11y bus: %s\", local_error->message);\n        }\n      else\n        {\n          g_variant_get (g_dbus_message_get_body (reply),\n                         \"(s)\", &a11y_address);\n        }\n    }\n\n  if (!a11y_address)\n    return FALSE;\n\n  proxy_socket = create_proxy_socket (\"a11y-bus-proxy-XXXXXX\");\n  if (proxy_socket == NULL)\n    return FALSE;\n\n  flatpak_bwrap_add_args (proxy_arg_bwrap,\n                          a11y_address,\n                          proxy_socket, \"--filter\", \"--sloppy-names\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Embed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Unembed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Registry.GetRegisteredEvents@/org/a11y/atspi/registry\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetKeystrokeListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetDeviceEventListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersSync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersAsync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          NULL);\n\n  if ((flags & FLATPAK_RUN_FLAG_LOG_A11Y_BUS) != 0)\n    flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n  flatpak_bwrap_add_args (app_bwrap,\n                          \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                          NULL);\n  flatpak_bwrap_set_env (app_bwrap, \"AT_SPI_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n  return TRUE;\n}\n\n/* This wraps the argv in a bwrap call, primary to allow the\n   command to be run with a proper /.flatpak-info with data\n   taken from app_info_path */\nstatic gboolean\nadd_bwrap_wrapper (FlatpakBwrap *bwrap,\n                   const char   *app_info_path,\n                   GError      **error)\n{\n  glnx_autofd int app_info_fd = -1;\n  g_auto(GLnxDirFdIterator) dir_iter = { 0 };\n  struct dirent *dent;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy/\", NULL);\n\n  app_info_fd = open (app_info_path, O_RDONLY | O_CLOEXEC);\n  if (app_info_fd == -1)\n    return glnx_throw_errno_prefix (error, _(\"Failed to open app info file\"));\n\n  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, \"/\", FALSE, &dir_iter, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  while (TRUE)\n    {\n      glnx_autofd int o_path_fd = -1;\n      struct statfs stfs;\n\n      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dir_iter, &dent, NULL, error))\n        return FALSE;\n\n      if (dent == NULL)\n        break;\n\n      if (strcmp (dent->d_name, \".flatpak-info\") == 0)\n        continue;\n\n      /* O_PATH + fstatfs is the magic that we need to statfs without automounting the target */\n      o_path_fd = openat (dir_iter.fd, dent->d_name, O_PATH | O_NOFOLLOW | O_CLOEXEC);\n      if (o_path_fd == -1 || fstatfs (o_path_fd, &stfs) != 0 || stfs.f_type == AUTOFS_SUPER_MAGIC)\n        continue; /* AUTOFS mounts are risky and can cause us to block (see issue #1633), so ignore it. Its unlikely the proxy needs such a directory. */\n\n      if (dent->d_type == DT_DIR)\n        {\n          if (strcmp (dent->d_name, \"tmp\") == 0 ||\n              strcmp (dent->d_name, \"var\") == 0 ||\n              strcmp (dent->d_name, \"run\") == 0)\n            flatpak_bwrap_add_arg (bwrap, \"--bind\");\n          else\n            flatpak_bwrap_add_arg (bwrap, \"--ro-bind\");\n\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n      else if (dent->d_type == DT_LNK)\n        {\n          g_autofree gchar *target = NULL;\n\n          target = glnx_readlinkat_malloc (dir_iter.fd, dent->d_name,\n                                           NULL, error);\n          if (target == NULL)\n            return FALSE;\n          flatpak_bwrap_add_args (bwrap, \"--symlink\", target, NULL);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n    }\n\n  flatpak_bwrap_add_args (bwrap, \"--bind\", proxy_socket_dir, proxy_socket_dir, NULL);\n\n  /* This is a file rather than a bind mount, because it will then\n     not be unmounted from the namespace when the namespace dies. */\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--file\", glnx_steal_fd (&app_info_fd), \"/.flatpak-info\");\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nstart_dbus_proxy (FlatpakBwrap *app_bwrap,\n                  FlatpakBwrap *proxy_arg_bwrap,\n                  const char   *app_info_path,\n                  GError      **error)\n{\n  char x = 'x';\n  const char *proxy;\n  g_autofree char *commandline = NULL;\n  g_autoptr(FlatpakBwrap) proxy_bwrap = NULL;\n  int sync_fds[2] = {-1, -1};\n  int proxy_start_index;\n\n  proxy_bwrap = flatpak_bwrap_new (NULL);\n\n  if (!add_bwrap_wrapper (proxy_bwrap, app_info_path, error))\n    return FALSE;\n\n  proxy = g_getenv (\"FLATPAK_DBUSPROXY\");\n  if (proxy == NULL)\n    proxy = DBUSPROXY;\n\n  flatpak_bwrap_add_arg (proxy_bwrap, proxy);\n\n  proxy_start_index = proxy_bwrap->argv->len;\n\n  if (pipe2 (sync_fds, O_CLOEXEC) < 0)\n    {\n      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                           _(\"Unable to create sync pipe\"));\n      return FALSE;\n    }\n\n  /* read end goes to app */\n  flatpak_bwrap_add_args_data_fd (app_bwrap, \"--sync-fd\", sync_fds[0], NULL);\n\n  /* write end goes to proxy */\n  flatpak_bwrap_add_fd (proxy_bwrap, sync_fds[1]);\n  flatpak_bwrap_add_arg_printf (proxy_bwrap, \"--fd=%d\", sync_fds[1]);\n\n  /* Note: This steals the fds from proxy_arg_bwrap */\n  flatpak_bwrap_append_bwrap (proxy_bwrap, proxy_arg_bwrap);\n\n  if (!flatpak_bwrap_bundle_args (proxy_bwrap, proxy_start_index, -1, TRUE, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (proxy_bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) proxy_bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async (NULL,\n                      (char **) proxy_bwrap->argv->pdata,\n                      NULL,\n                      G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                      flatpak_bwrap_child_setup_cb, proxy_bwrap->fds,\n                      NULL, error))\n    return FALSE;\n\n  /* The write end can be closed now, otherwise the read below will hang of xdg-dbus-proxy\n     fails to start. */\n  g_clear_pointer (&proxy_bwrap, flatpak_bwrap_free);\n\n  /* Sync with proxy, i.e. wait until its listening on the sockets */\n  if (read (sync_fds[0], &x, 1) != 1)\n    {\n      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                           _(\"Failed to sync with dbus proxy\"));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic int\nflatpak_extension_compare_by_path (gconstpointer _a,\n                                   gconstpointer _b)\n{\n  const FlatpakExtension *a = _a;\n  const FlatpakExtension *b = _b;\n\n  return g_strcmp0 (a->directory, b->directory);\n}\n\nvoid\nflatpak_run_extend_ld_path (FlatpakBwrap *bwrap,\n                            const char *prepend,\n                            const char *append)\n{\n  g_autoptr(GString) ld_library_path = g_string_new (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"));\n\n  if (prepend != NULL && *prepend != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_prepend (ld_library_path, \":\");\n\n      g_string_prepend (ld_library_path, prepend);\n    }\n\n  if (append != NULL && *append != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_append (ld_library_path, \":\");\n\n      g_string_append (ld_library_path, append);\n    }\n\n  flatpak_bwrap_set_env (bwrap, \"LD_LIBRARY_PATH\", ld_library_path->str, TRUE);\n}\n\ngboolean\nflatpak_run_add_extension_args (FlatpakBwrap      *bwrap,\n                                GKeyFile          *metakey,\n                                FlatpakDecomposed *ref,\n                                gboolean           use_ld_so_cache,\n                                const char        *target_path,\n                                char             **extensions_out,\n                                char             **ld_path_out,\n                                GCancellable      *cancellable,\n                                GError           **error)\n{\n  g_autoptr(GString) used_extensions = g_string_new (\"\");\n  GList *extensions, *path_sorted_extensions, *l;\n  g_autoptr(GString) ld_library_path = g_string_new (\"\");\n  int count = 0;\n  g_autoptr(GHashTable) mounted_tmpfs =\n    g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autoptr(GHashTable) created_symlink =\n    g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *arch = flatpak_decomposed_dup_arch (ref);\n  const char *branch = flatpak_decomposed_get_branch (ref);\n\n  g_return_val_if_fail (target_path != NULL, FALSE);\n\n  extensions = flatpak_list_extensions (metakey, arch, branch);\n\n  /* First we apply all the bindings, they are sorted alphabetically in order for parent directory\n     to be mounted before child directories */\n  path_sorted_extensions = g_list_copy (extensions);\n  path_sorted_extensions = g_list_sort (path_sorted_extensions, flatpak_extension_compare_by_path);\n\n  for (l = path_sorted_extensions; l != NULL; l = l->next)\n    {\n      FlatpakExtension *ext = l->data;\n      g_autofree char *directory = g_build_filename (target_path, ext->directory, NULL);\n      g_autofree char *full_directory = g_build_filename (directory, ext->subdir_suffix, NULL);\n      g_autofree char *ref_file = g_build_filename (full_directory, \".ref\", NULL);\n      g_autofree char *real_ref = g_build_filename (ext->files_path, ext->directory, \".ref\", NULL);\n\n      if (ext->needs_tmpfs)\n        {\n          g_autofree char *parent = g_path_get_dirname (directory);\n\n          if (g_hash_table_lookup (mounted_tmpfs, parent) == NULL)\n            {\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--tmpfs\", parent,\n                                      NULL);\n              g_hash_table_insert (mounted_tmpfs, g_steal_pointer (&parent), \"mounted\");\n            }\n        }\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", ext->files_path, full_directory,\n                              NULL);\n\n      if (g_file_test (real_ref, G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--lock-file\", ref_file,\n                                NULL);\n    }\n\n  g_list_free (path_sorted_extensions);\n\n  /* Then apply library directories and file merging, in extension prio order */\n\n  for (l = extensions; l != NULL; l = l->next)\n    {\n      FlatpakExtension *ext = l->data;\n      g_autofree char *directory = g_build_filename (target_path, ext->directory, NULL);\n      g_autofree char *full_directory = g_build_filename (directory, ext->subdir_suffix, NULL);\n      int i;\n\n      if (used_extensions->len > 0)\n        g_string_append (used_extensions, \";\");\n      g_string_append (used_extensions, ext->installed_id);\n      g_string_append (used_extensions, \"=\");\n      if (ext->commit != NULL)\n        g_string_append (used_extensions, ext->commit);\n      else\n        g_string_append (used_extensions, \"local\");\n\n      if (ext->add_ld_path)\n        {\n          g_autofree char *ld_path = g_build_filename (full_directory, ext->add_ld_path, NULL);\n\n          if (use_ld_so_cache)\n            {\n              g_autofree char *contents = g_strconcat (ld_path, \"\\n\", NULL);\n              /* We prepend app or runtime and a counter in order to get the include order correct for the conf files */\n              g_autofree char *ld_so_conf_file = g_strdup_printf (\"%s-%03d-%s.conf\", flatpak_decomposed_get_kind_str (ref), ++count, ext->installed_id);\n              g_autofree char *ld_so_conf_file_path = g_build_filename (\"/run/flatpak/ld.so.conf.d\", ld_so_conf_file, NULL);\n\n              if (!flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                                contents, -1, ld_so_conf_file_path, error))\n                return FALSE;\n            }\n          else\n            {\n              if (ld_library_path->len != 0)\n                g_string_append (ld_library_path, \":\");\n              g_string_append (ld_library_path, ld_path);\n            }\n        }\n\n      for (i = 0; ext->merge_dirs != NULL && ext->merge_dirs[i] != NULL; i++)\n        {\n          g_autofree char *parent = g_path_get_dirname (directory);\n          g_autofree char *merge_dir = g_build_filename (parent, ext->merge_dirs[i], NULL);\n          g_autofree char *source_dir = g_build_filename (ext->files_path, ext->merge_dirs[i], NULL);\n          g_auto(GLnxDirFdIterator) source_iter = { 0 };\n          struct dirent *dent;\n\n          if (glnx_dirfd_iterator_init_at (AT_FDCWD, source_dir, TRUE, &source_iter, NULL))\n            {\n              while (glnx_dirfd_iterator_next_dent (&source_iter, &dent, NULL, NULL) && dent != NULL)\n                {\n                  g_autofree char *symlink_path = g_build_filename (merge_dir, dent->d_name, NULL);\n                  /* Only create the first, because extensions are listed in prio order */\n                  if (g_hash_table_lookup (created_symlink, symlink_path) == NULL)\n                    {\n                      g_autofree char *symlink = g_build_filename (directory, ext->merge_dirs[i], dent->d_name, NULL);\n                      flatpak_bwrap_add_args (bwrap,\n                                              \"--symlink\", symlink, symlink_path,\n                                              NULL);\n                      g_hash_table_insert (created_symlink, g_steal_pointer (&symlink_path), \"created\");\n                    }\n                }\n            }\n        }\n    }\n\n  g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n\n  if (extensions_out)\n    *extensions_out = g_string_free (g_steal_pointer (&used_extensions), FALSE);\n\n  if (ld_path_out)\n    *ld_path_out = g_string_free (g_steal_pointer (&ld_library_path), FALSE);\n\n  return TRUE;\n}\n\n/*\n * @per_app_dir_lock_fd: If >= 0, make use of per-app directories in\n *  the host's XDG_RUNTIME_DIR to share /tmp between instances.\n */\ngboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  int              per_app_dir_lock_fd,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  g_autofree char *xdg_dirs_conf = NULL;\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n  gboolean home_access = FALSE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n            {\n              /* Don't do anything special: include shm in the\n               * shared /dev. The host and all sandboxes and subsandboxes\n               * all share /dev/shm */\n            }\n          else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)\n                   && per_app_dir_lock_fd >= 0)\n            {\n              g_autofree char *shared_dev_shm = NULL;\n\n              /* The host and the original sandbox have separate /dev/shm,\n               * but we want other instances to be able to share /dev/shm with\n               * the first sandbox (except for subsandboxes run with\n               * flatpak-spawn --sandbox, which will have their own). */\n              if (!flatpak_instance_ensure_per_app_dev_shm (app_id,\n                                                            per_app_dir_lock_fd,\n                                                            &shared_dev_shm,\n                                                            error))\n                return FALSE;\n\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--bind\", shared_dev_shm, \"/dev/shm\",\n                                      NULL);\n            }\n          else\n            {\n              /* The host, the original sandbox and each subsandbox\n               * each have a separate /dev/shm. */\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--tmpfs\", \"/dev/shm\",\n                                      NULL);\n            }\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                {\n                  flatpak_bwrap_add_args (bwrap,\n                                          \"--bind\", \"/run/shm\", \"/run/shm\",\n                                          NULL);\n                }\n              else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)\n                       && per_app_dir_lock_fd >= 0)\n                {\n                  g_autofree char *shared_dev_shm = NULL;\n\n                  /* The host and the original sandbox have separate /dev/shm,\n                   * but we want other instances to be able to share /dev/shm,\n                   * except for flatpak-spawn --subsandbox. */\n                  if (!flatpak_instance_ensure_per_app_dev_shm (app_id,\n                                                                per_app_dir_lock_fd,\n                                                                &shared_dev_shm,\n                                                                error))\n                    return FALSE;\n\n                  flatpak_bwrap_add_args (bwrap,\n                                          \"--bind\", shared_dev_shm, \"/run/shm\",\n                                          NULL);\n                }\n              else\n                {\n                  flatpak_bwrap_add_args (bwrap,\n                                          \"--dir\", \"/run/shm\",\n                                          NULL);\n                }\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n      else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)\n               && per_app_dir_lock_fd >= 0)\n        {\n          g_autofree char *shared_dev_shm = NULL;\n\n          if (!flatpak_instance_ensure_per_app_dev_shm (app_id,\n                                                        per_app_dir_lock_fd,\n                                                        &shared_dev_shm,\n                                                        error))\n            return FALSE;\n\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--bind\", shared_dev_shm, \"/dev/shm\",\n                                  NULL);\n        }\n    }\n\n  exports = flatpak_context_get_exports_full (context,\n                                              app_id_dir, previous_app_id_dirs,\n                                              TRUE, TRUE,\n                                              &xdg_dirs_conf, &home_access);\n\n  if (flatpak_exports_path_is_visible (exports, \"/tmp\"))\n    {\n      /* The original sandbox and any subsandboxes are both already\n       * going to share /tmp with the host, so by transitivity they will\n       * also share it with each other, and with all other instances. */\n    }\n  else if (per_app_dir_lock_fd >= 0 && !sandboxed)\n    {\n      g_autofree char *shared_tmp = NULL;\n\n      /* The host and the original sandbox have separate /tmp,\n       * but we want other instances to be able to share /tmp with the\n       * first sandbox, unless they were created by\n       * flatpak-spawn --sandbox.\n       *\n       * In apply_extra and `flatpak build`, per_app_dir_lock_fd is\n       * negative and we skip this. */\n      if (!flatpak_instance_ensure_per_app_tmp (app_id,\n                                                per_app_dir_lock_fd,\n                                                &shared_tmp,\n                                                error))\n        return FALSE;\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--bind\", shared_tmp, \"/tmp\",\n                              NULL);\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir,\n                                           exports, xdg_dirs_conf, home_access);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}\n\ntypedef struct\n{\n  const char *env;\n  const char *val;\n} ExportData;\n\nstatic const ExportData default_exports[] = {\n  {\"PATH\", \"/app/bin:/usr/bin\"},\n  /* We always want to unset LD_LIBRARY_PATH to avoid inheriting weird\n   * dependencies from the host. But if not using ld.so.cache this is\n   * later set. */\n  {\"LD_LIBRARY_PATH\", NULL},\n  {\"XDG_CONFIG_DIRS\", \"/app/etc/xdg:/etc/xdg\"},\n  {\"XDG_DATA_DIRS\", \"/app/share:/usr/share\"},\n  {\"SHELL\", \"/bin/sh\"},\n  {\"TMPDIR\", NULL}, /* Unset TMPDIR as it may not exist in the sandbox */\n  /* We always use /run/user/UID, even if the user's XDG_RUNTIME_DIR\n   * outside the sandbox is somewhere else. Don't allow a different\n   * setting from outside the sandbox to overwrite this. */\n  {\"XDG_RUNTIME_DIR\", NULL},\n\n  /* Some env vars are common enough and will affect the sandbox badly\n     if set on the host. We clear these always. */\n  {\"PYTHONPATH\", NULL},\n  {\"PERLLIB\", NULL},\n  {\"PERL5LIB\", NULL},\n  {\"XCURSOR_PATH\", NULL},\n};\n\nstatic const ExportData no_ld_so_cache_exports[] = {\n  {\"LD_LIBRARY_PATH\", \"/app/lib\"},\n};\n\nstatic const ExportData devel_exports[] = {\n  {\"ACLOCAL_PATH\", \"/app/share/aclocal\"},\n  {\"C_INCLUDE_PATH\", \"/app/include\"},\n  {\"CPLUS_INCLUDE_PATH\", \"/app/include\"},\n  {\"LDFLAGS\", \"-L/app/lib \"},\n  {\"PKG_CONFIG_PATH\", \"/app/lib/pkgconfig:/app/share/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig\"},\n  {\"LC_ALL\", \"en_US.utf8\"},\n};\n\nstatic void\nadd_exports (GPtrArray        *env_array,\n             const ExportData *exports,\n             gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      if (exports[i].val)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", exports[i].env, exports[i].val));\n    }\n}\n\nchar **\nflatpak_run_get_minimal_env (gboolean devel, gboolean use_ld_so_cache)\n{\n  GPtrArray *env_array;\n  static const char * const copy[] = {\n    \"PWD\",\n    \"GDMSESSION\",\n    \"XDG_CURRENT_DESKTOP\",\n    \"XDG_SESSION_DESKTOP\",\n    \"DESKTOP_SESSION\",\n    \"EMAIL_ADDRESS\",\n    \"HOME\",\n    \"HOSTNAME\",\n    \"LOGNAME\",\n    \"REAL_NAME\",\n    \"TERM\",\n    \"USER\",\n    \"USERNAME\",\n  };\n  static const char * const copy_nodevel[] = {\n    \"LANG\",\n    \"LANGUAGE\",\n    \"LC_ALL\",\n    \"LC_ADDRESS\",\n    \"LC_COLLATE\",\n    \"LC_CTYPE\",\n    \"LC_IDENTIFICATION\",\n    \"LC_MEASUREMENT\",\n    \"LC_MESSAGES\",\n    \"LC_MONETARY\",\n    \"LC_NAME\",\n    \"LC_NUMERIC\",\n    \"LC_PAPER\",\n    \"LC_TELEPHONE\",\n    \"LC_TIME\",\n  };\n  int i;\n\n  env_array = g_ptr_array_new_with_free_func (g_free);\n\n  add_exports (env_array, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    add_exports (env_array, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n\n  if (devel)\n    add_exports (env_array, devel_exports, G_N_ELEMENTS (devel_exports));\n\n  for (i = 0; i < G_N_ELEMENTS (copy); i++)\n    {\n      const char *current = g_getenv (copy[i]);\n      if (current)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy[i], current));\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (copy_nodevel); i++)\n        {\n          const char *current = g_getenv (copy_nodevel[i]);\n          if (current)\n            g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy_nodevel[i], current));\n        }\n    }\n\n  g_ptr_array_add (env_array, NULL);\n  return (char **) g_ptr_array_free (env_array, FALSE);\n}\n\nstatic char **\napply_exports (char            **envp,\n               const ExportData *exports,\n               gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      const char *value = exports[i].val;\n\n      if (value)\n        envp = g_environ_setenv (envp, exports[i].env, value, TRUE);\n      else\n        envp = g_environ_unsetenv (envp, exports[i].env);\n    }\n\n  return envp;\n}\n\nvoid\nflatpak_run_apply_env_default (FlatpakBwrap *bwrap, gboolean use_ld_so_cache)\n{\n  bwrap->envp = apply_exports (bwrap->envp, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    bwrap->envp = apply_exports (bwrap->envp, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n}\n\nstatic void\nflatpak_run_apply_env_prompt (FlatpakBwrap *bwrap, const char *app_id)\n{\n  /* A custom shell prompt. FLATPAK_ID is always set.\n   * PS1 can be overwritten by runtime metadata or by --env overrides\n   */\n  flatpak_bwrap_set_env (bwrap, \"FLATPAK_ID\", app_id, TRUE);\n  flatpak_bwrap_set_env (bwrap, \"PS1\", \"[\ud83d\udce6 $FLATPAK_ID \\\\W]\\\\$ \", FALSE);\n}\n\nvoid\nflatpak_run_apply_env_appid (FlatpakBwrap *bwrap,\n                             GFile        *app_dir)\n{\n  g_autoptr(GFile) app_dir_data = NULL;\n  g_autoptr(GFile) app_dir_config = NULL;\n  g_autoptr(GFile) app_dir_cache = NULL;\n\n  app_dir_data = g_file_get_child (app_dir, \"data\");\n  app_dir_config = g_file_get_child (app_dir, \"config\");\n  app_dir_cache = g_file_get_child (app_dir, \"cache\");\n  flatpak_bwrap_set_env (bwrap, \"XDG_DATA_HOME\", flatpak_file_get_path_cached (app_dir_data), TRUE);\n  flatpak_bwrap_set_env (bwrap, \"XDG_CONFIG_HOME\", flatpak_file_get_path_cached (app_dir_config), TRUE);\n  flatpak_bwrap_set_env (bwrap, \"XDG_CACHE_HOME\", flatpak_file_get_path_cached (app_dir_cache), TRUE);\n\n  if (g_getenv (\"XDG_DATA_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_DATA_HOME\", g_getenv (\"XDG_DATA_HOME\"), TRUE);\n  if (g_getenv (\"XDG_CONFIG_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_CONFIG_HOME\", g_getenv (\"XDG_CONFIG_HOME\"), TRUE);\n  if (g_getenv (\"XDG_CACHE_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_CACHE_HOME\", g_getenv (\"XDG_CACHE_HOME\"), TRUE);\n}\n\nvoid\nflatpak_run_apply_env_vars (FlatpakBwrap *bwrap, FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *var = key;\n      const char *val = value;\n\n      if (val)\n        flatpak_bwrap_set_env (bwrap, var, val, TRUE);\n      else\n        flatpak_bwrap_unset_env (bwrap, var);\n    }\n}\n\nGFile *\nflatpak_get_data_dir (const char *app_id)\n{\n  g_autoptr(GFile) home = g_file_new_for_path (g_get_home_dir ());\n  g_autoptr(GFile) var_app = g_file_resolve_relative_path (home, \".var/app\");\n\n  return g_file_get_child (var_app, app_id);\n}\n\ngboolean\nflatpak_ensure_data_dir (GFile        *app_id_dir,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  g_autoptr(GFile) data_dir = g_file_get_child (app_id_dir, \"data\");\n  g_autoptr(GFile) cache_dir = g_file_get_child (app_id_dir, \"cache\");\n  g_autoptr(GFile) fontconfig_cache_dir = g_file_get_child (cache_dir, \"fontconfig\");\n  g_autoptr(GFile) tmp_dir = g_file_get_child (cache_dir, \"tmp\");\n  g_autoptr(GFile) config_dir = g_file_get_child (app_id_dir, \"config\");\n\n  if (!flatpak_mkdir_p (data_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (fontconfig_cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (tmp_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (config_dir, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstruct JobData\n{\n  char      *job;\n  GMainLoop *main_loop;\n};\n\nstatic void\njob_removed_cb (SystemdManager *manager,\n                guint32         id,\n                char           *job,\n                char           *unit,\n                char           *result,\n                struct JobData *data)\n{\n  if (strcmp (job, data->job) == 0)\n    g_main_loop_quit (data->main_loop);\n}\n\nstatic gchar *\nsystemd_unit_name_escape (const gchar *in)\n{\n  /* Adapted from systemd source */\n  GString * const str = g_string_sized_new (strlen (in));\n\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}\n\ngboolean\nflatpak_run_in_transient_unit (const char *appid, GError **error)\n{\n  g_autoptr(GDBusConnection) conn = NULL;\n  g_autofree char *path = NULL;\n  g_autofree char *address = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *appid_escaped = NULL;\n  g_autofree char *job = NULL;\n  SystemdManager *manager = NULL;\n  GVariantBuilder builder;\n  GVariant *properties = NULL;\n  GVariant *aux = NULL;\n  guint32 pid;\n  GMainLoop *main_loop = NULL;\n  struct JobData data;\n  gboolean res = FALSE;\n  g_autoptr(GMainContextPopDefault) main_context = NULL;\n\n  path = g_strdup_printf (\"/run/user/%d/systemd/private\", getuid ());\n\n  if (!g_file_test (path, G_FILE_TEST_EXISTS))\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                               _(\"No systemd user session available, cgroups not available\"));\n\n  main_context = flatpak_main_context_new_default ();\n  main_loop = g_main_loop_new (main_context, FALSE);\n\n  address = g_strconcat (\"unix:path=\", path, NULL);\n\n  conn = g_dbus_connection_new_for_address_sync (address,\n                                                 G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT,\n                                                 NULL,\n                                                 NULL, error);\n  if (!conn)\n    goto out;\n\n  manager = systemd_manager_proxy_new_sync (conn,\n                                            G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,\n                                            NULL,\n                                            \"/org/freedesktop/systemd1\",\n                                            NULL, error);\n  if (!manager)\n    goto out;\n\n  appid_escaped = systemd_unit_name_escape (appid);\n  name = g_strdup_printf (\"app-flatpak-%s-%d.scope\", appid_escaped, getpid ());\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a(sv)\"));\n\n  pid = getpid ();\n  g_variant_builder_add (&builder, \"(sv)\",\n                         \"PIDs\",\n                         g_variant_new_fixed_array (G_VARIANT_TYPE (\"u\"),\n                                                    &pid, 1, sizeof (guint32))\n                        );\n\n  properties = g_variant_builder_end (&builder);\n\n  aux = g_variant_new_array (G_VARIANT_TYPE (\"(sa(sv))\"), NULL, 0);\n\n  if (!systemd_manager_call_start_transient_unit_sync (manager,\n                                                       name,\n                                                       \"fail\",\n                                                       properties,\n                                                       aux,\n                                                       &job,\n                                                       NULL,\n                                                       error))\n    goto out;\n\n  data.job = job;\n  data.main_loop = main_loop;\n  g_signal_connect (manager, \"job-removed\", G_CALLBACK (job_removed_cb), &data);\n\n  g_main_loop_run (main_loop);\n\n  res = TRUE;\n\nout:\n  if (main_loop)\n    g_main_loop_unref (main_loop);\n  if (manager)\n    g_object_unref (manager);\n\n  return res;\n}\n\nstatic void\nadd_font_path_args (FlatpakBwrap *bwrap)\n{\n  g_autoptr(GString) xml_snippet = g_string_new (\"\");\n  gchar *path_build_tmp = NULL;\n  g_autoptr(GFile) user_font1 = NULL;\n  g_autoptr(GFile) user_font2 = NULL;\n  g_autoptr(GFile) user_font_cache = NULL;\n  g_auto(GStrv) system_cache_dirs = NULL;\n  gboolean found_cache = FALSE;\n  int i;\n\n\n  g_string_append (xml_snippet,\n                   \"<?xml version=\\\"1.0\\\"?>\\n\"\n                   \"<!DOCTYPE fontconfig SYSTEM \\\"fonts.dtd\\\">\\n\"\n                   \"<fontconfig>\\n\");\n\n  if (g_file_test (SYSTEM_FONTS_DIR, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", SYSTEM_FONTS_DIR, \"/run/host/fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/fonts</remap-dir>\\n\",\n                              SYSTEM_FONTS_DIR);\n    }\n\n  if (g_file_test (\"/usr/local/share/fonts\", G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", \"/usr/local/share/fonts\", \"/run/host/local-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/local-fonts</remap-dir>\\n\",\n                              \"/usr/local/share/fonts\");\n    }\n\n  system_cache_dirs = g_strsplit (SYSTEM_FONT_CACHE_DIRS, \":\", 0);\n  for (i = 0; system_cache_dirs[i] != NULL; i++)\n    {\n      if (g_file_test (system_cache_dirs[i], G_FILE_TEST_EXISTS))\n        {\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--ro-bind\", system_cache_dirs[i], \"/run/host/fonts-cache\",\n                                  NULL);\n          found_cache = TRUE;\n          break;\n        }\n    }\n\n  if (!found_cache)\n    {\n      /* We ensure these directories are never writable, or fontconfig\n         will use them to write the default cache */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--tmpfs\", \"/run/host/fonts-cache\",\n                              \"--remount-ro\", \"/run/host/fonts-cache\",\n                              NULL);\n    }\n\n  path_build_tmp = g_build_filename (g_get_user_data_dir (), \"fonts\", NULL);\n  user_font1 = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  path_build_tmp = g_build_filename (g_get_home_dir (), \".fonts\", NULL);\n  user_font2 = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  if (g_file_query_exists (user_font1, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font1), \"/run/host/user-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/user-fonts</remap-dir>\\n\",\n                              flatpak_file_get_path_cached (user_font1));\n    }\n  else if (g_file_query_exists (user_font2, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font2), \"/run/host/user-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/user-fonts</remap-dir>\\n\",\n                              flatpak_file_get_path_cached (user_font2));\n    }\n\n  path_build_tmp = g_build_filename (g_get_user_cache_dir (), \"fontconfig\", NULL);\n  user_font_cache = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  if (g_file_query_exists (user_font_cache, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font_cache), \"/run/host/user-fonts-cache\",\n                              NULL);\n    }\n  else\n    {\n      /* We ensure these directories are never writable, or fontconfig\n         will use them to write the default cache */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--tmpfs\", \"/run/host/user-fonts-cache\",\n                              \"--remount-ro\", \"/run/host/user-fonts-cache\",\n                              NULL);\n    }\n\n  g_string_append (xml_snippet,\n                   \"</fontconfig>\\n\");\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"font-dirs.xml\", xml_snippet->str, xml_snippet->len, \"/run/host/font-dirs.xml\", NULL))\n    g_warning (\"Unable to add fontconfig data snippet\");\n}\n\nstatic void\nadd_icon_path_args (FlatpakBwrap *bwrap)\n{\n  g_autofree gchar *user_icons_path = NULL;\n  g_autoptr(GFile) user_icons = NULL;\n\n  if (g_file_test (\"/usr/share/icons\", G_FILE_TEST_IS_DIR))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", \"/usr/share/icons\", \"/run/host/share/icons\",\n                              NULL);\n    }\n\n  user_icons_path = g_build_filename (g_get_user_data_dir (), \"icons\", NULL);\n  user_icons = g_file_new_for_path (user_icons_path);\n  if (g_file_query_exists (user_icons, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_icons), \"/run/host/user-share/icons\",\n                              NULL);\n    }\n}\n\nFlatpakContext *\nflatpak_app_compute_permissions (GKeyFile *app_metadata,\n                                 GKeyFile *runtime_metadata,\n                                 GError  **error)\n{\n  g_autoptr(FlatpakContext) app_context = NULL;\n\n  app_context = flatpak_context_new ();\n\n  if (runtime_metadata != NULL)\n    {\n      if (!flatpak_context_load_metadata (app_context, runtime_metadata, error))\n        return NULL;\n\n      /* Don't inherit any permissions from the runtime, only things like env vars. */\n      flatpak_context_reset_permissions (app_context);\n    }\n\n  if (app_metadata != NULL &&\n      !flatpak_context_load_metadata (app_context, app_metadata, error))\n    return NULL;\n\n  return g_steal_pointer (&app_context);\n}\n\n#ifdef HAVE_DCONF\n\nstatic void\nadd_dconf_key_to_keyfile (GKeyFile      *keyfile,\n                          DConfClient   *client,\n                          const char    *key,\n                          DConfReadFlags flags)\n{\n  g_autofree char *group = g_path_get_dirname (key);\n  g_autofree char *k = g_path_get_basename (key);\n  GVariant *value = dconf_client_read_full (client, key, flags, NULL);\n\n  if (value)\n    {\n      g_autofree char *val = g_variant_print (value, TRUE);\n      g_key_file_set_value (keyfile, group + 1, k, val);\n    }\n}\n\nstatic void\nadd_dconf_dir_to_keyfile (GKeyFile      *keyfile,\n                          DConfClient   *client,\n                          const char    *dir,\n                          DConfReadFlags flags)\n{\n  g_auto(GStrv) keys = NULL;\n  int i;\n\n  keys = dconf_client_list (client, dir, NULL);\n  for (i = 0; keys[i]; i++)\n    {\n      g_autofree char *k = g_strconcat (dir, keys[i], NULL);\n      if (dconf_is_dir (k, NULL))\n        add_dconf_dir_to_keyfile (keyfile, client, k, flags);\n      else if (dconf_is_key (k, NULL))\n        add_dconf_key_to_keyfile (keyfile, client, k, flags);\n    }\n}\n\nstatic void\nadd_dconf_locks_to_list (GString     *s,\n                         DConfClient *client,\n                         const char  *dir)\n{\n  g_auto(GStrv) locks = NULL;\n  int i;\n\n  locks = dconf_client_list_locks (client, dir, NULL);\n  for (i = 0; locks[i]; i++)\n    {\n      g_string_append (s, locks[i]);\n      g_string_append_c (s, '\\n');\n    }\n}\n\n#endif /* HAVE_DCONF */\n\nstatic void\nget_dconf_data (const char  *app_id,\n                const char **paths,\n                const char  *migrate_path,\n                char       **defaults,\n                gsize       *defaults_size,\n                char       **values,\n                gsize       *values_size,\n                char       **locks,\n                gsize       *locks_size)\n{\n#ifdef HAVE_DCONF\n  DConfClient *client = NULL;\n  g_autofree char *prefix = NULL;\n#endif\n  g_autoptr(GKeyFile) defaults_data = NULL;\n  g_autoptr(GKeyFile) values_data = NULL;\n  g_autoptr(GString) locks_data = NULL;\n\n  defaults_data = g_key_file_new ();\n  values_data = g_key_file_new ();\n  locks_data = g_string_new (\"\");\n\n#ifdef HAVE_DCONF\n\n  client = dconf_client_new ();\n\n  prefix = flatpak_dconf_path_for_app_id (app_id);\n\n  if (migrate_path)\n    {\n      g_debug (\"Add values in dir '%s', prefix is '%s'\", migrate_path, prefix);\n      if (flatpak_dconf_path_is_similar (migrate_path, prefix))\n        add_dconf_dir_to_keyfile (values_data, client, migrate_path, DCONF_READ_USER_VALUE);\n      else\n        g_warning (\"Ignoring D-Conf migrate-path setting %s\", migrate_path);\n    }\n\n  g_debug (\"Add defaults in dir %s\", prefix);\n  add_dconf_dir_to_keyfile (defaults_data, client, prefix, DCONF_READ_DEFAULT_VALUE);\n\n  g_debug (\"Add locks in dir %s\", prefix);\n  add_dconf_locks_to_list (locks_data, client, prefix);\n\n  /* We allow extra paths for defaults and locks, but not for user values */\n  if (paths)\n    {\n      int i;\n      for (i = 0; paths[i]; i++)\n        {\n          if (dconf_is_dir (paths[i], NULL))\n            {\n              g_debug (\"Add defaults in dir %s\", paths[i]);\n              add_dconf_dir_to_keyfile (defaults_data, client, paths[i], DCONF_READ_DEFAULT_VALUE);\n\n              g_debug (\"Add locks in dir %s\", paths[i]);\n              add_dconf_locks_to_list (locks_data, client, paths[i]);\n            }\n          else if (dconf_is_key (paths[i], NULL))\n            {\n              g_debug (\"Add individual key %s\", paths[i]);\n              add_dconf_key_to_keyfile (defaults_data, client, paths[i], DCONF_READ_DEFAULT_VALUE);\n              add_dconf_key_to_keyfile (values_data, client, paths[i], DCONF_READ_USER_VALUE);\n            }\n          else\n            {\n              g_warning (\"Ignoring settings path '%s': neither dir nor key\", paths[i]);\n            }\n        }\n    }\n#endif\n\n  *defaults = g_key_file_to_data (defaults_data, defaults_size, NULL);\n  *values = g_key_file_to_data (values_data, values_size, NULL);\n  *locks_size = locks_data->len;\n  *locks = g_string_free (g_steal_pointer (&locks_data), FALSE);\n\n#ifdef HAVE_DCONF\n  g_object_unref (client);\n#endif\n}\n\nstatic gboolean\nflatpak_run_add_dconf_args (FlatpakBwrap *bwrap,\n                            const char   *app_id,\n                            GKeyFile     *metakey,\n                            GError      **error)\n{\n  g_auto(GStrv) paths = NULL;\n  g_autofree char *migrate_path = NULL;\n  g_autofree char *defaults = NULL;\n  g_autofree char *values = NULL;\n  g_autofree char *locks = NULL;\n  gsize defaults_size;\n  gsize values_size;\n  gsize locks_size;\n\n  if (metakey)\n    {\n      paths = g_key_file_get_string_list (metakey,\n                                          FLATPAK_METADATA_GROUP_DCONF,\n                                          FLATPAK_METADATA_KEY_DCONF_PATHS,\n                                          NULL, NULL);\n      migrate_path = g_key_file_get_string (metakey,\n                                            FLATPAK_METADATA_GROUP_DCONF,\n                                            FLATPAK_METADATA_KEY_DCONF_MIGRATE_PATH,\n                                            NULL);\n    }\n\n  get_dconf_data (app_id,\n                  (const char **) paths,\n                  migrate_path,\n                  &defaults, &defaults_size,\n                  &values, &values_size,\n                  &locks, &locks_size);\n\n  if (defaults_size != 0 &&\n      !flatpak_bwrap_add_args_data (bwrap,\n                                    \"dconf-defaults\",\n                                    defaults, defaults_size,\n                                    \"/etc/glib-2.0/settings/defaults\",\n                                    error))\n    return FALSE;\n\n  if (locks_size != 0 &&\n      !flatpak_bwrap_add_args_data (bwrap,\n                                    \"dconf-locks\",\n                                    locks, locks_size,\n                                    \"/etc/glib-2.0/settings/locks\",\n                                    error))\n    return FALSE;\n\n  /* We do a one-time conversion of existing dconf settings to a keyfile.\n   * Only do that once the app stops requesting dconf access.\n   */\n  if (migrate_path)\n    {\n      g_autofree char *filename = NULL;\n\n      filename = g_build_filename (g_get_home_dir (),\n                                   \".var/app\", app_id,\n                                   \"config/glib-2.0/settings/keyfile\",\n                                   NULL);\n\n      g_debug (\"writing D-Conf values to %s\", filename);\n\n      if (values_size != 0 && !g_file_test (filename, G_FILE_TEST_EXISTS))\n        {\n          g_autofree char *dir = g_path_get_dirname (filename);\n\n          if (g_mkdir_with_parents (dir, 0700) == -1)\n            {\n              g_warning (\"failed creating dirs for %s\", filename);\n              return FALSE;\n            }\n\n          if (!g_file_set_contents (filename, values, values_size, error))\n            {\n              g_warning (\"failed writing %s\", filename);\n              return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_add_app_info_args (FlatpakBwrap       *bwrap,\n                               GFile              *app_files,\n                               GFile              *original_app_files,\n                               GBytes             *app_deploy_data,\n                               const char         *app_extensions,\n                               GFile              *runtime_files,\n                               GFile              *original_runtime_files,\n                               GBytes             *runtime_deploy_data,\n                               const char         *runtime_extensions,\n                               const char         *app_id,\n                               const char         *app_branch,\n                               FlatpakDecomposed  *runtime_ref,\n                               GFile              *app_id_dir,\n                               FlatpakContext     *final_app_context,\n                               FlatpakContext     *cmdline_context,\n                               gboolean            sandbox,\n                               gboolean            build,\n                               gboolean            devel,\n                               char              **app_info_path_out,\n                               int                 instance_id_fd,\n                               char              **instance_id_host_dir_out,\n                               GError             **error)\n{\n  g_autofree char *info_path = NULL;\n  g_autofree char *bwrapinfo_path = NULL;\n  int fd, fd2, fd3;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree char *runtime_path = NULL;\n  const char *group;\n  g_autofree char *instance_id = NULL;\n  glnx_autofd int lock_fd = -1;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autofree char *instance_id_sandbox_dir = NULL;\n  g_autofree char *instance_id_lock_file = NULL;\n  g_autofree char *arch = flatpak_decomposed_dup_arch (runtime_ref);\n\n  g_return_val_if_fail (app_id != NULL, FALSE);\n\n  instance_id = flatpak_instance_allocate_id (&instance_id_host_dir, &lock_fd);\n  if (instance_id == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Unable to allocate instance id\"));\n\n  instance_id_sandbox_dir = g_strdup_printf (\"/run/flatpak/.flatpak/%s\", instance_id);\n  instance_id_lock_file = g_build_filename (instance_id_sandbox_dir, \".ref\", NULL);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\",\n                          instance_id_host_dir,\n                          instance_id_sandbox_dir,\n                          \"--lock-file\",\n                          instance_id_lock_file,\n                          NULL);\n  flatpak_bwrap_add_runtime_dir_member (bwrap, \".flatpak\");\n  /* Keep the .ref lock held until we've started bwrap to avoid races */\n  flatpak_bwrap_add_noinherit_fd (bwrap, glnx_steal_fd (&lock_fd));\n\n  info_path = g_build_filename (instance_id_host_dir, \"info\", NULL);\n\n  keyfile = g_key_file_new ();\n\n  if (original_app_files)\n    group = FLATPAK_METADATA_GROUP_APPLICATION;\n  else\n    group = FLATPAK_METADATA_GROUP_RUNTIME;\n\n  g_key_file_set_string (keyfile, group, FLATPAK_METADATA_KEY_NAME, app_id);\n  g_key_file_set_string (keyfile, group, FLATPAK_METADATA_KEY_RUNTIME,\n                         flatpak_decomposed_get_ref (runtime_ref));\n\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_INSTANCE_ID, instance_id);\n  if (app_id_dir)\n    {\n      g_autofree char *instance_path = g_file_get_path (app_id_dir);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_INSTANCE_PATH, instance_path);\n    }\n\n  if (app_files)\n    {\n      g_autofree char *app_path = g_file_get_path (app_files);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_APP_PATH, app_path);\n    }\n\n  if (original_app_files != NULL && original_app_files != app_files)\n    {\n      g_autofree char *app_path = g_file_get_path (original_app_files);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_ORIGINAL_APP_PATH, app_path);\n    }\n\n  if (app_deploy_data)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_APP_COMMIT, flatpak_deploy_data_get_commit (app_deploy_data));\n  if (app_extensions && *app_extensions != 0)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_APP_EXTENSIONS, app_extensions);\n  runtime_path = g_file_get_path (runtime_files);\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_RUNTIME_PATH, runtime_path);\n\n  if (runtime_files != original_runtime_files)\n    {\n      g_autofree char *path = g_file_get_path (original_runtime_files);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_ORIGINAL_RUNTIME_PATH, path);\n    }\n\n  if (runtime_deploy_data)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_RUNTIME_COMMIT, flatpak_deploy_data_get_commit (runtime_deploy_data));\n  if (runtime_extensions && *runtime_extensions != 0)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_RUNTIME_EXTENSIONS, runtime_extensions);\n  if (app_branch != NULL)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_BRANCH, app_branch);\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_ARCH, arch);\n\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_FLATPAK_VERSION, PACKAGE_VERSION);\n\n  if ((final_app_context->sockets & FLATPAK_CONTEXT_SOCKET_SESSION_BUS) == 0)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SESSION_BUS_PROXY, TRUE);\n\n  if ((final_app_context->sockets & FLATPAK_CONTEXT_SOCKET_SYSTEM_BUS) == 0)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SYSTEM_BUS_PROXY, TRUE);\n\n  if (sandbox)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SANDBOX, TRUE);\n  if (build)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_BUILD, TRUE);\n  if (devel)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_DEVEL, TRUE);\n\n  if (cmdline_context)\n    {\n      g_autoptr(GPtrArray) cmdline_args = g_ptr_array_new_with_free_func (g_free);\n      flatpak_context_to_args (cmdline_context, cmdline_args);\n      if (cmdline_args->len > 0)\n        {\n          g_key_file_set_string_list (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_EXTRA_ARGS,\n                                      (const char * const *) cmdline_args->pdata,\n                                      cmdline_args->len);\n        }\n    }\n\n  flatpak_context_save_metadata (final_app_context, TRUE, keyfile);\n\n  if (!g_key_file_save_to_file (keyfile, info_path, error))\n    return FALSE;\n\n  /* We want to create a file on /.flatpak-info that the app cannot modify, which\n     we do by creating a read-only bind mount. This way one can openat()\n     /proc/$pid/root, and if that succeeds use openat via that to find the\n     unfakable .flatpak-info file. However, there is a tiny race in that if\n     you manage to open /proc/$pid/root, but then the pid dies, then\n     every mount but the root is unmounted in the namespace, so the\n     .flatpak-info will be empty. We fix this by first creating a real file\n     with the real info in, then bind-mounting on top of that, the same info.\n     This way even if the bind-mount is unmounted we can find the real data.\n   */\n\n  fd = open (info_path, O_RDONLY);\n  if (fd == -1)\n    {\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open flatpak-info file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  fd2 = open (info_path, O_RDONLY);\n  if (fd2 == -1)\n    {\n      close (fd);\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open flatpak-info file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--file\", fd, \"/.flatpak-info\");\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--ro-bind-data\", fd2, \"/.flatpak-info\");\n\n  /* Tell the application that it's running under Flatpak in a generic way. */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--setenv\", \"container\", \"flatpak\",\n                          NULL);\n  if (!flatpak_bwrap_add_args_data (bwrap,\n                                    \"container-manager\",\n                                    \"flatpak\\n\", -1,\n                                    \"/run/host/container-manager\",\n                                    error))\n    return FALSE;\n\n  bwrapinfo_path = g_build_filename (instance_id_host_dir, \"bwrapinfo.json\", NULL);\n  fd3 = open (bwrapinfo_path, O_RDWR | O_CREAT, 0644);\n  if (fd3 == -1)\n    {\n      close (fd);\n      close (fd2);\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open bwrapinfo.json file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  /* NOTE: It is important that this takes place after bwrapinfo.json is created,\n     otherwise start notifications in the portal may not work. */\n  if (instance_id_fd != -1)\n    {\n      gsize instance_id_position = 0;\n      gsize instance_id_size = strlen (instance_id);\n\n      while (instance_id_size > 0)\n        {\n          gssize bytes_written = write (instance_id_fd, instance_id + instance_id_position, instance_id_size);\n          if (G_UNLIKELY (bytes_written <= 0))\n            {\n              int errsv = bytes_written == -1 ? errno : ENOSPC;\n              if (errsv == EINTR)\n                continue;\n\n              close (fd);\n              close (fd2);\n              close (fd3);\n\n              g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                           _(\"Failed to write to instance id fd: %s\"), g_strerror (errsv));\n              return FALSE;\n            }\n\n          instance_id_position += bytes_written;\n          instance_id_size -= bytes_written;\n        }\n\n      close (instance_id_fd);\n    }\n\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--info-fd\", fd3, NULL);\n\n  if (app_info_path_out != NULL)\n    *app_info_path_out = g_strdup_printf (\"/proc/self/fd/%d\", fd);\n\n  if (instance_id_host_dir_out != NULL)\n    *instance_id_host_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n\nstatic void\nadd_tzdata_args (FlatpakBwrap *bwrap,\n                 GFile *runtime_files)\n{\n  g_autofree char *raw_timezone = flatpak_get_timezone ();\n  g_autofree char *timezone_content = g_strdup_printf (\"%s\\n\", raw_timezone);\n  g_autofree char *localtime_content = g_strconcat (\"../usr/share/zoneinfo/\", raw_timezone, NULL);\n  g_autoptr(GFile) runtime_zoneinfo = NULL;\n\n  if (runtime_files)\n    runtime_zoneinfo = g_file_resolve_relative_path (runtime_files, \"share/zoneinfo\");\n\n  /* Check for runtime /usr/share/zoneinfo */\n  if (runtime_zoneinfo != NULL && g_file_query_exists (runtime_zoneinfo, NULL))\n    {\n      /* Check for host /usr/share/zoneinfo */\n      if (g_file_test (\"/usr/share/zoneinfo\", G_FILE_TEST_IS_DIR))\n        {\n          /* Here we assume the host timezone file exist in the host data */\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--ro-bind\", \"/usr/share/zoneinfo\", \"/usr/share/zoneinfo\",\n                                  \"--symlink\", localtime_content, \"/etc/localtime\",\n                                  NULL);\n        }\n      else\n        {\n          g_autoptr(GFile) runtime_tzfile = g_file_resolve_relative_path (runtime_zoneinfo, raw_timezone);\n\n          /* Check if host timezone file exist in the runtime tzdata */\n          if (g_file_query_exists (runtime_tzfile, NULL))\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--symlink\", localtime_content, \"/etc/localtime\",\n                                    NULL);\n        }\n    }\n\n  flatpak_bwrap_add_args_data (bwrap, \"timezone\",\n                               timezone_content, -1, \"/etc/timezone\",\n                               NULL);\n}\n\nstatic void\nadd_monitor_path_args (gboolean      use_session_helper,\n                       FlatpakBwrap *bwrap)\n{\n  g_autoptr(AutoFlatpakSessionHelper) session_helper = NULL;\n  g_autofree char *monitor_path = NULL;\n  g_autofree char *pkcs11_socket_path = NULL;\n  g_autoptr(GVariant) session_data = NULL;\n\n  if (use_session_helper)\n    {\n      session_helper =\n        flatpak_session_helper_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION,\n                                                       G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES | G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS,\n                                                       FLATPAK_SESSION_HELPER_BUS_NAME,\n                                                       FLATPAK_SESSION_HELPER_PATH,\n                                                       NULL, NULL);\n    }\n\n  if (session_helper &&\n      flatpak_session_helper_call_request_session_sync (session_helper,\n                                                        &session_data,\n                                                        NULL, NULL))\n    {\n      if (g_variant_lookup (session_data, \"path\", \"s\", &monitor_path))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", monitor_path, \"/run/host/monitor\",\n                                \"--symlink\", \"/run/host/monitor/resolv.conf\", \"/etc/resolv.conf\",\n                                \"--symlink\", \"/run/host/monitor/host.conf\", \"/etc/host.conf\",\n                                \"--symlink\", \"/run/host/monitor/hosts\", \"/etc/hosts\",\n                                \"--symlink\", \"/run/host/monitor/gai.conf\", \"/etc/gai.conf\",\n                                NULL);\n\n      if (g_variant_lookup (session_data, \"pkcs11-socket\", \"s\", &pkcs11_socket_path))\n        {\n          static const char sandbox_pkcs11_socket_path[] = \"/run/flatpak/p11-kit/pkcs11\";\n          const char *trusted_module_contents =\n            \"# This overrides the runtime p11-kit-trusted module with a client one talking to the trust module on the host\\n\"\n            \"module: p11-kit-client.so\\n\";\n\n          if (flatpak_bwrap_add_args_data (bwrap, \"p11-kit-trust.module\",\n                                           trusted_module_contents, -1,\n                                           \"/etc/pkcs11/modules/p11-kit-trust.module\", NULL))\n            {\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--ro-bind\", pkcs11_socket_path, sandbox_pkcs11_socket_path,\n                                      NULL);\n              flatpak_bwrap_unset_env (bwrap, \"P11_KIT_SERVER_ADDRESS\");\n              flatpak_bwrap_add_runtime_dir_member (bwrap, \"p11-kit\");\n            }\n        }\n    }\n  else\n    {\n      if (g_file_test (\"/etc/resolv.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/resolv.conf\", \"/etc/resolv.conf\",\n                                NULL);\n      if (g_file_test (\"/etc/host.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/host.conf\", \"/etc/host.conf\",\n                                NULL);\n      if (g_file_test (\"/etc/hosts\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/hosts\", \"/etc/hosts\",\n                                NULL);\n      if (g_file_test (\"/etc/gai.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/gai.conf\", \"/etc/gai.conf\",\n                                NULL);\n    }\n}\n\nstatic void\nadd_document_portal_args (FlatpakBwrap *bwrap,\n                          const char   *app_id,\n                          char        **out_mount_path)\n{\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *doc_mount_path = NULL;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GDBusMessage) reply = NULL;\n      g_autoptr(GDBusMessage) msg =\n        g_dbus_message_new_method_call (\"org.freedesktop.portal.Documents\",\n                                        \"/org/freedesktop/portal/documents\",\n                                        \"org.freedesktop.portal.Documents\",\n                                        \"GetMountPoint\");\n      g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n      reply =\n        g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                        G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                        30000,\n                                                        NULL,\n                                                        NULL,\n                                                        NULL);\n      if (reply)\n        {\n          if (g_dbus_message_to_gerror (reply, &local_error))\n            {\n              if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n                g_debug (\"Document portal not available, not mounting /run/flatpak/doc\");\n              else\n                g_message (\"Can't get document portal: %s\", local_error->message);\n            }\n          else\n            {\n              static const char dst_path[] = \"/run/flatpak/doc\";\n              g_autofree char *src_path = NULL;\n              g_variant_get (g_dbus_message_get_body (reply),\n                             \"(^ay)\", &doc_mount_path);\n\n              src_path = g_strdup_printf (\"%s/by-app/%s\",\n                                          doc_mount_path, app_id);\n              flatpak_bwrap_add_args (bwrap, \"--bind\", src_path, dst_path, NULL);\n              flatpak_bwrap_add_runtime_dir_member (bwrap, \"doc\");\n            }\n        }\n    }\n\n  *out_mount_path = g_steal_pointer (&doc_mount_path);\n}\n\n#ifdef ENABLE_SECCOMP\nstatic const uint32_t seccomp_x86_64_extra_arches[] = { SCMP_ARCH_X86, 0, };\n\n#ifdef SCMP_ARCH_AARCH64\nstatic const uint32_t seccomp_aarch64_extra_arches[] = { SCMP_ARCH_ARM, 0 };\n#endif\n\nstatic inline void\ncleanup_seccomp (void *p)\n{\n  scmp_filter_ctx *pp = (scmp_filter_ctx *) p;\n\n  if (*pp)\n    seccomp_release (*pp);\n}\n\nstatic gboolean\nsetup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blocklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key), EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy), EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n     * the flags are OK, so we have no choice but to block clone3().\n     * Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q; see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3), ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's no\n     * legitimate reason to do these in the sandbox, so block all of them\n     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q) */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr), ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n          (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blocklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}\n#endif\n\nstatic void\nflatpak_run_setup_usr_links (FlatpakBwrap *bwrap,\n                             GFile        *runtime_files,\n                             const char   *sysroot)\n{\n  int i;\n\n  if (runtime_files == NULL)\n    return;\n\n  for (i = 0; flatpak_abs_usrmerged_dirs[i] != NULL; i++)\n    {\n      const char *subdir = flatpak_abs_usrmerged_dirs[i];\n      g_autoptr(GFile) runtime_subdir = NULL;\n\n      g_assert (subdir[0] == '/');\n      /* Skip the '/' when using as a subdirectory of the runtime */\n      runtime_subdir = g_file_get_child (runtime_files, subdir + 1);\n\n      if (g_file_query_exists (runtime_subdir, NULL))\n        {\n          g_autofree char *link = g_strconcat (\"usr\", subdir, NULL);\n          g_autofree char *create = NULL;\n\n          if (sysroot != NULL)\n            create = g_strconcat (sysroot, subdir, NULL);\n          else\n            create = g_strdup (subdir);\n\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--symlink\", link, create,\n                                  NULL);\n        }\n      else\n        {\n          g_debug (\"%s does not exist\",\n                   flatpak_file_get_path_cached (runtime_subdir));\n        }\n    }\n}\n\ngboolean\nflatpak_run_setup_base_argv (FlatpakBwrap   *bwrap,\n                             GFile          *runtime_files,\n                             GFile          *app_id_dir,\n                             const char     *arch,\n                             FlatpakRunFlags flags,\n                             GError        **error)\n{\n  g_autofree char *run_dir = NULL;\n  g_autofree char *passwd_contents = NULL;\n  g_autoptr(GString) group_contents = NULL;\n  const char *pkcs11_conf_contents = NULL;\n  struct group *g;\n  gulong pers;\n  gid_t gid = getgid ();\n  g_autoptr(GFile) etc = NULL;\n\n  run_dir = g_strdup_printf (\"/run/user/%d\", getuid ());\n\n  passwd_contents = g_strdup_printf (\"%s:x:%d:%d:%s:%s:%s\\n\"\n                                     \"nfsnobody:x:65534:65534:Unmapped user:/:/sbin/nologin\\n\",\n                                     g_get_user_name (),\n                                     getuid (), gid,\n                                     g_get_real_name (),\n                                     g_get_home_dir (),\n                                     DEFAULT_SHELL);\n\n  group_contents = g_string_new (\"\");\n  g = getgrgid (gid);\n  /* if NULL, the primary group is not known outside the container, so\n   * it might as well stay unknown inside the container... */\n  if (g != NULL)\n    g_string_append_printf (group_contents, \"%s:x:%d:%s\\n\",\n                            g->gr_name, gid, g_get_user_name ());\n  g_string_append (group_contents, \"nfsnobody:x:65534:\\n\");\n\n  pkcs11_conf_contents =\n    \"# Disable user pkcs11 config, because the host modules don't work in the runtime\\n\"\n    \"user-config: none\\n\";\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_PROC) == 0)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--proc\", \"/proc\",\n                            NULL);\n\n  if (!(flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS))\n    flatpak_bwrap_add_arg (bwrap, \"--unshare-pid\");\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--dir\", \"/tmp\",\n                          \"--dir\", \"/var/tmp\",\n                          \"--dir\", \"/run/host\",\n                          \"--dir\", run_dir,\n                          \"--setenv\", \"XDG_RUNTIME_DIR\", run_dir,\n                          \"--symlink\", \"../run\", \"/var/run\",\n                          \"--ro-bind\", \"/sys/block\", \"/sys/block\",\n                          \"--ro-bind\", \"/sys/bus\", \"/sys/bus\",\n                          \"--ro-bind\", \"/sys/class\", \"/sys/class\",\n                          \"--ro-bind\", \"/sys/dev\", \"/sys/dev\",\n                          \"--ro-bind\", \"/sys/devices\", \"/sys/devices\",\n                          \"--ro-bind-try\", \"/proc/self/ns/user\", \"/run/.userns\",\n                          /* glib uses this like /etc/timezone */\n                          \"--symlink\", \"/etc/timezone\", \"/var/db/zoneinfo\",\n                          NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_DIE_WITH_PARENT)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--die-with-parent\",\n                            NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/usr/etc\",\n                            \"--symlink\", \"usr/etc\", \"/etc\",\n                            NULL);\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"passwd\", passwd_contents, -1, \"/etc/passwd\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"group\", group_contents->str, -1, \"/etc/group\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"pkcs11.conf\", pkcs11_conf_contents, -1, \"/etc/pkcs11/pkcs11.conf\", error))\n    return FALSE;\n\n  if (g_file_test (\"/etc/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/etc/machine-id\", \"/etc/machine-id\", NULL);\n  else if (g_file_test (\"/var/lib/dbus/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/var/lib/dbus/machine-id\", \"/etc/machine-id\", NULL);\n\n  if (runtime_files)\n    etc = g_file_get_child (runtime_files, \"etc\");\n  if (etc != NULL &&\n      (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0 &&\n      g_file_query_exists (etc, NULL))\n    {\n      g_auto(GLnxDirFdIterator) dfd_iter = { 0, };\n      struct dirent *dent;\n      gboolean inited;\n\n      inited = glnx_dirfd_iterator_init_at (AT_FDCWD, flatpak_file_get_path_cached (etc), FALSE, &dfd_iter, NULL);\n\n      while (inited)\n        {\n          g_autofree char *src = NULL;\n          g_autofree char *dest = NULL;\n\n          if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dfd_iter, &dent, NULL, NULL) || dent == NULL)\n            break;\n\n          if (strcmp (dent->d_name, \"passwd\") == 0 ||\n              strcmp (dent->d_name, \"group\") == 0 ||\n              strcmp (dent->d_name, \"machine-id\") == 0 ||\n              strcmp (dent->d_name, \"resolv.conf\") == 0 ||\n              strcmp (dent->d_name, \"host.conf\") == 0 ||\n              strcmp (dent->d_name, \"hosts\") == 0 ||\n              strcmp (dent->d_name, \"gai.conf\") == 0 ||\n              strcmp (dent->d_name, \"localtime\") == 0 ||\n              strcmp (dent->d_name, \"timezone\") == 0 ||\n              strcmp (dent->d_name, \"pkcs11\") == 0)\n            continue;\n\n          src = g_build_filename (flatpak_file_get_path_cached (etc), dent->d_name, NULL);\n          dest = g_build_filename (\"/etc\", dent->d_name, NULL);\n          if (dent->d_type == DT_LNK)\n            {\n              g_autofree char *target = NULL;\n\n              target = glnx_readlinkat_malloc (dfd_iter.fd, dent->d_name,\n                                               NULL, error);\n              if (target == NULL)\n                return FALSE;\n\n              flatpak_bwrap_add_args (bwrap, \"--symlink\", target, dest, NULL);\n            }\n          else\n            {\n              flatpak_bwrap_add_args (bwrap, \"--ro-bind\", src, dest, NULL);\n            }\n        }\n    }\n\n  if (app_id_dir != NULL)\n    {\n      g_autoptr(GFile) app_cache_dir = g_file_get_child (app_id_dir, \"cache\");\n      g_autoptr(GFile) app_tmp_dir = g_file_get_child (app_cache_dir, \"tmp\");\n      g_autoptr(GFile) app_data_dir = g_file_get_child (app_id_dir, \"data\");\n      g_autoptr(GFile) app_config_dir = g_file_get_child (app_id_dir, \"config\");\n\n      flatpak_bwrap_add_args (bwrap,\n                              /* These are nice to have as a fixed path */\n                              \"--bind\", flatpak_file_get_path_cached (app_cache_dir), \"/var/cache\",\n                              \"--bind\", flatpak_file_get_path_cached (app_data_dir), \"/var/data\",\n                              \"--bind\", flatpak_file_get_path_cached (app_config_dir), \"/var/config\",\n                              \"--bind\", flatpak_file_get_path_cached (app_tmp_dir), \"/var/tmp\",\n                              NULL);\n    }\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files, NULL);\n\n  add_tzdata_args (bwrap, runtime_files);\n\n  pers = PER_LINUX;\n\n  if ((flags & FLATPAK_RUN_FLAG_SET_PERSONALITY) &&\n      flatpak_is_linux32_arch (arch))\n    {\n      g_debug (\"Setting personality linux32\");\n      pers = PER_LINUX32;\n    }\n\n  /* Always set the personallity, and clear all weird flags */\n  personality (pers);\n\n#ifdef ENABLE_SECCOMP\n  if (!setup_seccomp (bwrap, arch, pers, flags, error))\n    return FALSE;\n#endif\n\n  if ((flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0)\n    add_monitor_path_args ((flags & FLATPAK_RUN_FLAG_NO_SESSION_HELPER) == 0, bwrap);\n\n  return TRUE;\n}\n\nstatic gboolean\nforward_file (XdpDbusDocuments *documents,\n              const char       *app_id,\n              const char       *file,\n              char            **out_doc_id,\n              GError          **error)\n{\n  int fd, fd_id;\n  g_autofree char *doc_id = NULL;\n  g_autoptr(GUnixFDList) fd_list = NULL;\n  const char *perms[] = { \"read\", \"write\", NULL };\n\n  fd = open (file, O_PATH | O_CLOEXEC);\n  if (fd == -1)\n    return flatpak_fail (error, _(\"Failed to open \u2018%s\u2019\"), file);\n\n  fd_list = g_unix_fd_list_new ();\n  fd_id = g_unix_fd_list_append (fd_list, fd, error);\n  close (fd);\n\n  if (!xdp_dbus_documents_call_add_sync (documents,\n                                         g_variant_new (\"h\", fd_id),\n                                         TRUE, /* reuse */\n                                         FALSE, /* not persistent */\n                                         fd_list,\n                                         &doc_id,\n                                         NULL,\n                                         NULL,\n                                         error))\n    {\n      if (error)\n        g_dbus_error_strip_remote_error (*error);\n      return FALSE;\n    }\n\n  if (!xdp_dbus_documents_call_grant_permissions_sync (documents,\n                                                       doc_id,\n                                                       app_id,\n                                                       perms,\n                                                       NULL,\n                                                       error))\n    {\n      if (error)\n        g_dbus_error_strip_remote_error (*error);\n      return FALSE;\n    }\n\n  *out_doc_id = g_steal_pointer (&doc_id);\n\n  return TRUE;\n}\n\nstatic gboolean\nadd_rest_args (FlatpakBwrap   *bwrap,\n               const char     *app_id,\n               FlatpakExports *exports,\n               gboolean        file_forwarding,\n               const char     *doc_mount_path,\n               char           *args[],\n               int             n_args,\n               GError        **error)\n{\n  g_autoptr(XdpDbusDocuments) documents = NULL;\n  gboolean forwarding = FALSE;\n  gboolean forwarding_uri = FALSE;\n  gboolean can_forward = TRUE;\n  int i;\n\n  if (file_forwarding && doc_mount_path == NULL)\n    {\n      g_message (\"Can't get document portal mount path\");\n      can_forward = FALSE;\n    }\n  else if (file_forwarding)\n    {\n      g_autoptr(GError) local_error = NULL;\n\n      documents = xdp_dbus_documents_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION, 0,\n                                                             \"org.freedesktop.portal.Documents\",\n                                                             \"/org/freedesktop/portal/documents\",\n                                                             NULL,\n                                                             &local_error);\n      if (documents == NULL)\n        {\n          g_message (\"Can't get document portal: %s\", local_error->message);\n          can_forward = FALSE;\n        }\n    }\n\n  for (i = 0; i < n_args; i++)\n    {\n      g_autoptr(GFile) file = NULL;\n\n      if (file_forwarding &&\n          (strcmp (args[i], \"@@\") == 0 ||\n           strcmp (args[i], \"@@u\") == 0))\n        {\n          forwarding_uri = strcmp (args[i], \"@@u\") == 0;\n          forwarding = !forwarding;\n          continue;\n        }\n\n      if (can_forward && forwarding)\n        {\n          if (forwarding_uri)\n            {\n              if (g_str_has_prefix (args[i], \"file:\"))\n                file = g_file_new_for_uri (args[i]);\n              else if (G_IS_DIR_SEPARATOR (args[i][0]))\n                file = g_file_new_for_path (args[i]);\n            }\n          else\n            file = g_file_new_for_path (args[i]);\n        }\n\n      if (file && !flatpak_exports_path_is_visible (exports,\n                                                    flatpak_file_get_path_cached (file)))\n        {\n          g_autofree char *doc_id = NULL;\n          g_autofree char *basename = NULL;\n          g_autofree char *doc_path = NULL;\n          if (!forward_file (documents, app_id, flatpak_file_get_path_cached (file),\n                             &doc_id, error))\n            return FALSE;\n\n          basename = g_file_get_basename (file);\n          doc_path = g_build_filename (doc_mount_path, doc_id, basename, NULL);\n\n          if (forwarding_uri)\n            {\n              g_autofree char *path = doc_path;\n              doc_path = g_filename_to_uri (path, NULL, NULL);\n              /* This should never fail */\n              g_assert (doc_path != NULL);\n            }\n\n          g_debug (\"Forwarding file '%s' as '%s' to %s\", args[i], doc_path, app_id);\n          flatpak_bwrap_add_arg (bwrap, doc_path);\n        }\n      else\n        flatpak_bwrap_add_arg (bwrap, args[i]);\n    }\n\n  return TRUE;\n}\n\nFlatpakContext *\nflatpak_context_load_for_deploy (FlatpakDeploy *deploy,\n                                 GError       **error)\n{\n  g_autoptr(FlatpakContext) context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n  context = flatpak_app_compute_permissions (metakey, NULL, error);\n  if (context == NULL)\n    return NULL;\n\n  overrides = flatpak_deploy_get_overrides (deploy);\n  flatpak_context_merge (context, overrides);\n\n  return g_steal_pointer (&context);\n}\n\nstatic char *\ncalculate_ld_cache_checksum (GBytes   *app_deploy_data,\n                             GBytes   *runtime_deploy_data,\n                             const char *app_extensions,\n                             const char *runtime_extensions)\n{\n  g_autoptr(GChecksum) ld_so_checksum = g_checksum_new (G_CHECKSUM_SHA256);\n  if (app_deploy_data)\n    g_checksum_update (ld_so_checksum, (guchar *) flatpak_deploy_data_get_commit (app_deploy_data), -1);\n  g_checksum_update (ld_so_checksum, (guchar *) flatpak_deploy_data_get_commit (runtime_deploy_data), -1);\n  if (app_extensions)\n    g_checksum_update (ld_so_checksum, (guchar *) app_extensions, -1);\n  if (runtime_extensions)\n    g_checksum_update (ld_so_checksum, (guchar *) runtime_extensions, -1);\n\n  return g_strdup (g_checksum_get_string (ld_so_checksum));\n}\n\nstatic gboolean\nadd_ld_so_conf (FlatpakBwrap *bwrap,\n                GError      **error)\n{\n  const char *contents =\n    \"include /run/flatpak/ld.so.conf.d/app-*.conf\\n\"\n    \"include /app/etc/ld.so.conf\\n\"\n    \"/app/lib\\n\"\n    \"include /run/flatpak/ld.so.conf.d/runtime-*.conf\\n\";\n\n  return flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                      contents, -1, \"/etc/ld.so.conf\", error);\n}\n\nstatic int\nregenerate_ld_cache (GPtrArray    *base_argv_array,\n                     GArray       *base_fd_array,\n                     GFile        *app_id_dir,\n                     const char   *checksum,\n                     GFile        *runtime_files,\n                     gboolean      generate_ld_so_conf,\n                     GCancellable *cancellable,\n                     GError      **error)\n{\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  g_autoptr(GArray) combined_fd_array = NULL;\n  g_autoptr(GFile) ld_so_cache = NULL;\n  g_autoptr(GFile) ld_so_cache_tmp = NULL;\n  g_autofree char *sandbox_cache_path = NULL;\n  g_autofree char *tmp_basename = NULL;\n  g_auto(GStrv) minimal_envp = NULL;\n  g_autofree char *commandline = NULL;\n  int exit_status;\n  glnx_autofd int ld_so_fd = -1;\n  g_autoptr(GFile) ld_so_dir = NULL;\n\n  if (app_id_dir)\n    ld_so_dir = g_file_get_child (app_id_dir, \".ld.so\");\n  else\n    {\n      g_autoptr(GFile) base_dir = g_file_new_for_path (g_get_user_cache_dir ());\n      ld_so_dir = g_file_resolve_relative_path (base_dir, \"flatpak/ld.so\");\n    }\n\n  ld_so_cache = g_file_get_child (ld_so_dir, checksum);\n  ld_so_fd = open (flatpak_file_get_path_cached (ld_so_cache), O_RDONLY);\n  if (ld_so_fd >= 0)\n    return glnx_steal_fd (&ld_so_fd);\n\n  g_debug (\"Regenerating ld.so.cache %s\", flatpak_file_get_path_cached (ld_so_cache));\n\n  if (!flatpak_mkdir_p (ld_so_dir, cancellable, error))\n    return FALSE;\n\n  minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);\n  bwrap = flatpak_bwrap_new (minimal_envp);\n\n  flatpak_bwrap_append_args (bwrap, base_argv_array);\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files, NULL);\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return -1;\n    }\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--symlink\", \"../usr/etc/ld.so.conf\", \"/etc/ld.so.conf\",\n                            NULL);\n\n  tmp_basename = g_strconcat (checksum, \".XXXXXX\", NULL);\n  glnx_gen_temp_name (tmp_basename);\n\n  sandbox_cache_path = g_build_filename (\"/run/ld-so-cache-dir\", tmp_basename, NULL);\n  ld_so_cache_tmp = g_file_get_child (ld_so_dir, tmp_basename);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--unshare-pid\",\n                          \"--unshare-ipc\",\n                          \"--unshare-net\",\n                          \"--proc\", \"/proc\",\n                          \"--dev\", \"/dev\",\n                          \"--bind\", flatpak_file_get_path_cached (ld_so_dir), \"/run/ld-so-cache-dir\",\n                          NULL);\n  flatpak_bwrap_sort_envp (bwrap);\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return -1;\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"ldconfig\", \"-X\", \"-C\", sandbox_cache_path, NULL);\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running: '%s'\", commandline);\n\n  combined_fd_array = g_array_new (FALSE, TRUE, sizeof (int));\n  g_array_append_vals (combined_fd_array, base_fd_array->data, base_fd_array->len);\n  g_array_append_vals (combined_fd_array, bwrap->fds->data, bwrap->fds->len);\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_sync (NULL,\n                     (char **) bwrap->argv->pdata,\n                     bwrap->envp,\n                     G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                     flatpak_bwrap_child_setup_cb, combined_fd_array,\n                     NULL, NULL,\n                     &exit_status,\n                     error))\n    return -1;\n\n  if (!WIFEXITED (exit_status) || WEXITSTATUS (exit_status) != 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                          _(\"ldconfig failed, exit status %d\"), exit_status);\n      return -1;\n    }\n\n  ld_so_fd = open (flatpak_file_get_path_cached (ld_so_cache_tmp), O_RDONLY);\n  if (ld_so_fd < 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Can't open generated ld.so.cache\"));\n      return -1;\n    }\n\n  if (app_id_dir == NULL)\n    {\n      /* For runs without an app id dir we always regenerate the ld.so.cache */\n      unlink (flatpak_file_get_path_cached (ld_so_cache_tmp));\n    }\n  else\n    {\n      g_autoptr(GFile) active = g_file_get_child (ld_so_dir, \"active\");\n\n      /* For app-dirs we keep one checksum alive, by pointing the active symlink to it */\n\n      /* Rename to known name, possibly overwriting existing ref if race */\n      if (rename (flatpak_file_get_path_cached (ld_so_cache_tmp), flatpak_file_get_path_cached (ld_so_cache)) == -1)\n        {\n          glnx_set_error_from_errno (error);\n          return -1;\n        }\n\n      if (!flatpak_switch_symlink_and_remove (flatpak_file_get_path_cached (active),\n                                              checksum, error))\n        return -1;\n    }\n\n  return glnx_steal_fd (&ld_so_fd);\n}\n\n/* Check that this user is actually allowed to run this app. When running\n * from the gnome-initial-setup session, an app filter might not be available. */\nstatic gboolean\ncheck_parental_controls (FlatpakDecomposed *app_ref,\n                         FlatpakDeploy     *deploy,\n                         GCancellable      *cancellable,\n                         GError           **error)\n{\n#ifdef HAVE_LIBMALCONTENT\n  g_autoptr(MctManager) manager = NULL;\n  g_autoptr(MctAppFilter) app_filter = NULL;\n  g_autoptr(GDBusConnection) system_bus = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDesktopAppInfo) app_info = NULL;\n  gboolean allowed = FALSE;\n\n  system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, error);\n  if (system_bus == NULL)\n    return FALSE;\n\n  manager = mct_manager_new (system_bus);\n  app_filter = mct_manager_get_app_filter (manager, getuid (),\n                                           MCT_GET_APP_FILTER_FLAGS_INTERACTIVE,\n                                           cancellable, &local_error);\n  if (g_error_matches (local_error, MCT_APP_FILTER_ERROR, MCT_APP_FILTER_ERROR_DISABLED))\n    {\n      g_debug (\"Skipping parental controls check for %s since parental \"\n               \"controls are disabled globally\", flatpak_decomposed_get_ref (app_ref));\n      return TRUE;\n    }\n  else if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN) ||\n           g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_NAME_HAS_NO_OWNER))\n    {\n      g_debug (\"Skipping parental controls check for %s since a required \"\n               \"service was not found\", flatpak_decomposed_get_ref (app_ref));\n      return TRUE;\n    }\n  else if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  /* Always filter by app ID. Additionally, filter by app info (which runs\n   * multiple checks, including whether the app ID, executable path and\n   * content types are allowed) if available. If the flatpak contains\n   * multiple .desktop files, we use the main one. The app ID check is\n   * always done, as the binary executed by `flatpak run` isn\u2019t necessarily\n   * extracted from a .desktop file. */\n  allowed = mct_app_filter_is_flatpak_ref_allowed (app_filter, flatpak_decomposed_get_ref (app_ref));\n\n  /* Look up the app\u2019s main .desktop file. */\n  if (deploy != NULL && allowed)\n    {\n      g_autoptr(GFile) deploy_dir = NULL;\n      const char *deploy_path;\n      g_autofree char *desktop_file_name = NULL;\n      g_autofree char *desktop_file_path = NULL;\n      g_autofree char *app_id = flatpak_decomposed_dup_id (app_ref);\n\n      deploy_dir = flatpak_deploy_get_dir (deploy);\n      deploy_path = flatpak_file_get_path_cached (deploy_dir);\n\n      desktop_file_name = g_strconcat (app_id, \".desktop\", NULL);\n      desktop_file_path = g_build_path (G_DIR_SEPARATOR_S,\n                                        deploy_path,\n                                        \"export\",\n                                        \"share\",\n                                        \"applications\",\n                                        desktop_file_name,\n                                        NULL);\n      app_info = g_desktop_app_info_new_from_filename (desktop_file_path);\n    }\n\n  if (app_info != NULL)\n    allowed = allowed && mct_app_filter_is_appinfo_allowed (app_filter,\n                                                            G_APP_INFO (app_info));\n\n  if (!allowed)\n    return flatpak_fail_error (error, FLATPAK_ERROR_PERMISSION_DENIED,\n                               /* Translators: The placeholder is for an app ref. */\n                               _(\"Running %s is not allowed by the policy set by your administrator\"),\n                               flatpak_decomposed_get_ref (app_ref));\n#endif  /* HAVE_LIBMALCONTENT */\n\n  return TRUE;\n}\n\nstatic int\nopen_namespace_fd_if_needed (const char *path,\n                             const char *other_path) {\n  struct stat s, other_s;\n\n  if (stat (path, &s) != 0)\n    return -1; /* No such namespace, ignore */\n\n  if (stat (other_path, &other_s) != 0)\n    return -1; /* No such namespace, ignore */\n\n  /* setns calls fail if the process is already in the desired namespace, hence the\n     check here to ensure the namespaces are different. */\n  if (s.st_ino != other_s.st_ino)\n    return open (path, O_RDONLY|O_CLOEXEC);\n\n  return -1;\n}\n\nstatic gboolean\ncheck_sudo (GError **error)\n{\n  const char *sudo_command_env = g_getenv (\"SUDO_COMMAND\");\n  g_auto(GStrv) split_command = NULL;\n\n  /* This check exists to stop accidental usage of `sudo flatpak run`\n     and is not to prevent running as root.\n   */\n\n  if (!sudo_command_env)\n    return TRUE;\n\n  /* SUDO_COMMAND could be a value like `/usr/bin/flatpak run foo` */\n  split_command = g_strsplit (sudo_command_env, \" \", 2);\n  if (g_str_has_suffix (split_command[0], \"flatpak\"))\n    return flatpak_fail_error (error, FLATPAK_ERROR, _(\"\\\"flatpak run\\\" is not intended to be run as `sudo flatpak run`, use `sudo -i` or `su -l` instead and invoke \\\"flatpak run\\\" from inside the new shell\"));\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 const char        *custom_app_path,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 const char        *custom_usr_path,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) original_app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) original_runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \"/bin/sh\";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *app_ld_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *runtime_ld_path = NULL;\n  g_autofree char *checksum = NULL;\n  glnx_autofd int per_app_dir_lock_fd = -1;\n  g_autofree char *per_app_dir_lock_path = NULL;\n  g_autofree char *shared_xdg_runtime_dir = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  const char *app_target_path = \"/app\";\n  const char *runtime_target_path = \"/usr\";\n  struct stat s;\n\n  g_return_val_if_fail (app_ref != NULL, FALSE);\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  g_return_val_if_fail (app_id != NULL, FALSE);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n  g_return_val_if_fail (app_arch != NULL, FALSE);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \"/\", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  original_runtime_files = flatpak_deploy_get_files (runtime_deploy);\n\n  if (custom_usr_path != NULL)\n    {\n      runtime_files = g_file_new_for_path (custom_usr_path);\n      /* Mount the original runtime below here instead of /usr */\n      runtime_target_path = \"/run/parent/usr\";\n    }\n  else\n    {\n      runtime_files = g_object_ref (original_runtime_files);\n    }\n\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \"bin/ldconfig\");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  /* We can't use the ld.so cache if we are using a custom /usr or /app,\n   * because we don't have a unique ID for the /usr or /app, so we can't\n   * do cache-invalidation correctly. The caller can either build their\n   * own ld.so.cache before supplying us with the runtime, or supply\n   * their own LD_LIBRARY_PATH. */\n  if (custom_usr_path != NULL || custom_app_path != NULL)\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      original_app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\"Failed to migrate from %s: %s\"), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\"Failed to migrate old app data directory %s to new name %s: %s\"),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\"Failed to create symlink while migrating %s: %s\"),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  if (custom_app_path != NULL)\n    {\n      if (strcmp (custom_app_path, \"\") == 0)\n        app_files = NULL;\n      else\n        app_files = g_file_new_for_path (custom_app_path);\n\n      /* Mount the original app below here */\n      app_target_path = \"/run/parent/app\";\n    }\n  else if (original_app_files != NULL)\n    {\n      app_files = g_object_ref (original_app_files);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \"sandbox\");\n      flatpak_bwrap_set_env (bwrap, \"FLATPAK_SANDBOX_DIR\", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                          NULL);\n\n  if (runtime_files == original_runtime_files)\n    {\n      /* All true Flatpak runtimes have files/.ref */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--lock-file\", \"/usr/.ref\",\n                              NULL);\n    }\n  else\n    {\n      g_autoptr(GFile) runtime_child = NULL;\n\n      runtime_child = g_file_get_child (runtime_files, \".ref\");\n\n      /* Lock ${usr}/.ref if it exists */\n      if (g_file_query_exists (runtime_child, NULL))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--lock-file\", \"/usr/.ref\",\n                                NULL);\n\n      /* Put the real Flatpak runtime in /run/parent, so that the\n       * replacement /usr can have symlinks into /run/parent in order\n       * to use the Flatpak runtime's graphics drivers etc. if desired */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\",\n                              flatpak_file_get_path_cached (original_runtime_files),\n                              \"/run/parent/usr\",\n                              \"--lock-file\", \"/run/parent/usr/.ref\",\n                              NULL);\n      flatpak_run_setup_usr_links (bwrap, original_runtime_files,\n                                   \"/run/parent\");\n\n      g_clear_object (&runtime_child);\n      runtime_child = g_file_get_child (original_runtime_files, \"etc\");\n\n      if (g_file_query_exists (runtime_child, NULL))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--symlink\", \"usr/etc\", \"/run/parent/etc\",\n                                NULL);\n    }\n\n  if (app_files != NULL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                              NULL);\n\n      if (app_files == original_app_files)\n        {\n          /* All true Flatpak apps have files/.ref */\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--lock-file\", \"/app/.ref\",\n                                  NULL);\n        }\n      else\n        {\n          g_autoptr(GFile) app_child = NULL;\n\n          app_child = g_file_get_child (app_files, \".ref\");\n\n          /* Lock ${app}/.ref if it exists */\n          if (g_file_query_exists (app_child, NULL))\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--lock-file\", \"/app/.ref\",\n                                    NULL);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dir\", \"/app\",\n                              NULL);\n    }\n\n  if (original_app_files != NULL && app_files != original_app_files)\n    {\n      /* Put the real Flatpak app in /run/parent/app */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\",\n                              flatpak_file_get_path_cached (original_app_files),\n                              \"/run/parent/app\",\n                              \"--lock-file\", \"/run/parent/app/.ref\",\n                              NULL);\n    }\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref,\n                                       use_ld_so_cache, app_target_path,\n                                       &app_extensions, &app_ld_path,\n                                       cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref,\n                                       use_ld_so_cache, runtime_target_path,\n                                       &runtime_extensions, &runtime_ld_path,\n                                       cancellable, error))\n    return FALSE;\n\n  if (custom_usr_path == NULL)\n    flatpak_run_extend_ld_path (bwrap, NULL, runtime_ld_path);\n\n  if (custom_app_path == NULL)\n    flatpak_run_extend_ld_path (bwrap, app_ld_path, NULL);\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \"etc/ld.so.conf\");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \"--ro-bind-data\");\n      flatpak_bwrap_add_arg_printf (bwrap, \"%d\", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \"/etc/ld.so.cache\");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, original_app_files, app_deploy_data, app_extensions,\n                                      runtime_files, original_runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!sandboxed)\n    {\n      if (!flatpak_instance_ensure_per_app_dir (app_id,\n                                                &per_app_dir_lock_fd,\n                                                &per_app_dir_lock_path,\n                                                error))\n        return FALSE;\n\n      if (!flatpak_instance_ensure_per_app_xdg_runtime_dir (app_id,\n                                                            per_app_dir_lock_fd,\n                                                            &shared_xdg_runtime_dir,\n                                                            error))\n        return FALSE;\n\n      flatpak_bwrap_add_arg (bwrap, \"--bind\");\n      flatpak_bwrap_add_arg (bwrap, shared_xdg_runtime_dir);\n      flatpak_bwrap_add_arg_printf (bwrap, \"/run/user/%d\", getuid ());\n    }\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         per_app_dir_lock_fd,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if (per_app_dir_lock_path != NULL)\n    {\n      static const char lock[] = \"/run/flatpak/per-app-dirs-ref\";\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", per_app_dir_lock_path, lock,\n                              \"--lock-file\", lock,\n                              NULL);\n    }\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \"--symlink\", \"/app/lib/debug/source\", \"/run/build\",\n                          \"--symlink\", \"/usr/lib/debug/source\", \"/run/build-runtime\",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \"--chdir\", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \"No parent pid specified\");\n\n      userns_path = g_strdup_printf (\"/proc/%d/root/run/.userns\", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \"/proc/self/ns/user\");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \"--userns\", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\"/proc/%d/ns/user\", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \"--userns2\", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\"/proc/%d/ns/pid\", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \"--pidns\", pidns_fd, NULL);\n    }\n\n  flatpak_bwrap_populate_runtime_dir (bwrap, shared_xdg_runtime_dir);\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  flatpak_bwrap_sort_envp (bwrap);\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  /* Hold onto the lock until we execute bwrap */\n  flatpak_bwrap_add_noinherit_fd (bwrap, glnx_steal_fd (&per_app_dir_lock_fd));\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\"Unable to start app\"));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2014-2019 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <gio/gdesktopappinfo.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/vfs.h>\n#include <sys/personality.h>\n#include <grp.h>\n#include <unistd.h>\n#include <gio/gunixfdlist.h>\n#ifdef HAVE_DCONF\n#include <dconf/dconf.h>\n#endif\n#ifdef HAVE_LIBMALCONTENT\n#include <libmalcontent/malcontent.h>\n#endif\n\n#include \"flatpak-syscalls-private.h\"\n\n#ifdef ENABLE_SECCOMP\n#include <seccomp.h>\n#endif\n\n#ifdef ENABLE_XAUTH\n#include <X11/Xauth.h>\n#endif\n\n#include <glib/gi18n-lib.h>\n\n#include <gio/gio.h>\n#include \"libglnx/libglnx.h\"\n\n#include \"flatpak-run-private.h\"\n#include \"flatpak-proxy.h\"\n#include \"flatpak-utils-base-private.h\"\n#include \"flatpak-dir-private.h\"\n#include \"flatpak-instance-private.h\"\n#include \"flatpak-systemd-dbus-generated.h\"\n#include \"flatpak-document-dbus-generated.h\"\n#include \"flatpak-error.h\"\n#include \"session-helper/flatpak-session-helper.h\"\n\n#define DEFAULT_SHELL \"/bin/sh\"\n\nconst char * const abs_usrmerged_dirs[] =\n{\n  \"/bin\",\n  \"/lib\",\n  \"/lib32\",\n  \"/lib64\",\n  \"/sbin\",\n  NULL\n};\nconst char * const *flatpak_abs_usrmerged_dirs = abs_usrmerged_dirs;\n\nstatic char *\nextract_unix_path_from_dbus_address (const char *address)\n{\n  const char *path, *path_end;\n\n  if (address == NULL)\n    return NULL;\n\n  if (!g_str_has_prefix (address, \"unix:\"))\n    return NULL;\n\n  path = strstr (address, \"path=\");\n  if (path == NULL)\n    return NULL;\n  path += strlen (\"path=\");\n  path_end = path;\n  while (*path_end != 0 && *path_end != ',')\n    path_end++;\n\n  return g_strndup (path, path_end - path);\n}\n\n#ifdef ENABLE_XAUTH\nstatic gboolean\nauth_streq (char *str,\n            char *au_str,\n            int   au_len)\n{\n  return au_len == strlen (str) && memcmp (str, au_str, au_len) == 0;\n}\n\nstatic gboolean\nxauth_entry_should_propagate (Xauth *xa,\n                              char  *hostname,\n                              char  *number)\n{\n  /* ensure entry isn't for remote access */\n  if (xa->family != FamilyLocal && xa->family != FamilyWild)\n    return FALSE;\n\n  /* ensure entry is for this machine */\n  if (xa->family == FamilyLocal && !auth_streq (hostname, xa->address, xa->address_length))\n    {\n      /* OpenSUSE inherits the hostname value from DHCP without updating\n       * its X11 authentication cookie. The old hostname value can still\n       * be found in the environment variable XAUTHLOCALHOSTNAME.\n       * For reference:\n       * https://bugzilla.opensuse.org/show_bug.cgi?id=262309\n       * For this reason if we have a cookie whose address is equal to the\n       * variable XAUTHLOCALHOSTNAME, we still need to propagate it, but\n       * we also need to change its address to `unames.nodename`.\n       */\n      const char *xauth_local_hostname;\n      xauth_local_hostname = g_getenv (\"XAUTHLOCALHOSTNAME\");\n      if (xauth_local_hostname == NULL)\n        return FALSE;\n\n      if (!auth_streq ((char *) xauth_local_hostname, xa->address, xa->address_length))\n        return FALSE;\n    }\n\n  /* ensure entry is for this session */\n  if (xa->number != NULL && !auth_streq (number, xa->number, xa->number_length))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic void\nwrite_xauth (char *number, FILE *output)\n{\n  Xauth *xa, local_xa;\n  char *filename;\n  FILE *f;\n  struct utsname unames;\n\n  if (uname (&unames))\n    {\n      g_warning (\"uname failed\");\n      return;\n    }\n\n  filename = XauFileName ();\n  f = fopen (filename, \"rb\");\n  if (f == NULL)\n    return;\n\n  while (TRUE)\n    {\n      xa = XauReadAuth (f);\n      if (xa == NULL)\n        break;\n      if (xauth_entry_should_propagate (xa, unames.nodename, number))\n        {\n          local_xa = *xa;\n          if (local_xa.number)\n            {\n              local_xa.number = \"99\";\n              local_xa.number_length = 2;\n            }\n\n          if (local_xa.family == FamilyLocal &&\n              !auth_streq (unames.nodename, local_xa.address, local_xa.address_length))\n            {\n              /* If we decided to propagate this cookie, but its address\n               * doesn't match `unames.nodename`, we need to change it or\n               * inside the container it will not work.\n               */\n              local_xa.address = unames.nodename;\n              local_xa.address_length = strlen (local_xa.address);\n            }\n\n          if (!XauWriteAuth (output, &local_xa))\n            g_warning (\"xauth write error\");\n        }\n\n      XauDisposeAuth (xa);\n    }\n\n  fclose (f);\n}\n#endif /* ENABLE_XAUTH */\n\nstatic void\nflatpak_run_add_x11_args (FlatpakBwrap *bwrap,\n                          gboolean      allowed)\n{\n  g_autofree char *x11_socket = NULL;\n  const char *display;\n\n  /* Always cover /tmp/.X11-unix, that way we never see the host one in case\n   * we have access to the host /tmp. If you request X access we'll put the right\n   * thing in this anyway.\n   *\n   * We need to be a bit careful here, because there are two situations in\n   * which potentially hostile processes have access to /tmp and could\n   * create symlinks, which in principle could cause us to create the\n   * directory and mount the tmpfs at the target of the symlink instead\n   * of in the intended place:\n   *\n   * - With --filesystem=/tmp, it's the host /tmp - but because of the\n   *   special historical status of /tmp/.X11-unix, we can assume that\n   *   it is pre-created by the host system before user code gets to run.\n   *\n   * - When /tmp is shared between all instances of the same app ID,\n   *   in principle the app has control over what's in /tmp, but in\n   *   practice it can't interfere with /tmp/.X11-unix, because we do\n   *   this unconditionally - therefore by the time app code runs,\n   *   /tmp/.X11-unix is already a mount point, meaning the app cannot\n   *   rename or delete it.\n   */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--tmpfs\", \"/tmp/.X11-unix\",\n                          NULL);\n\n  if (!allowed)\n    {\n      flatpak_bwrap_unset_env (bwrap, \"DISPLAY\");\n      return;\n    }\n\n  g_debug (\"Allowing x11 access\");\n\n  display = g_getenv (\"DISPLAY\");\n  if (display && display[0] == ':' && g_ascii_isdigit (display[1]))\n    {\n      const char *display_nr = &display[1];\n      const char *display_nr_end = display_nr;\n      g_autofree char *d = NULL;\n\n      while (g_ascii_isdigit (*display_nr_end))\n        display_nr_end++;\n\n      d = g_strndup (display_nr, display_nr_end - display_nr);\n      x11_socket = g_strdup_printf (\"/tmp/.X11-unix/X%s\", d);\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", x11_socket, \"/tmp/.X11-unix/X99\",\n                              NULL);\n      flatpak_bwrap_set_env (bwrap, \"DISPLAY\", \":99.0\", TRUE);\n\n#ifdef ENABLE_XAUTH\n      g_auto(GLnxTmpfile) xauth_tmpf  = { 0, };\n\n      if (glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &xauth_tmpf, NULL))\n        {\n          FILE *output = fdopen (xauth_tmpf.fd, \"wb\");\n          if (output != NULL)\n            {\n              /* fd is now owned by output, steal it from the tmpfile */\n              int tmp_fd = dup (glnx_steal_fd (&xauth_tmpf.fd));\n              if (tmp_fd != -1)\n                {\n                  static const char dest[] = \"/run/flatpak/Xauthority\";\n\n                  write_xauth (d, output);\n                  flatpak_bwrap_add_args_data_fd (bwrap, \"--ro-bind-data\", tmp_fd, dest);\n\n                  flatpak_bwrap_set_env (bwrap, \"XAUTHORITY\", dest, TRUE);\n                }\n\n              fclose (output);\n\n              if (tmp_fd != -1)\n                lseek (tmp_fd, 0, SEEK_SET);\n            }\n        }\n#endif\n    }\n  else\n    {\n      flatpak_bwrap_unset_env (bwrap, \"DISPLAY\");\n    }\n}\n\nstatic gboolean\nflatpak_run_add_wayland_args (FlatpakBwrap *bwrap)\n{\n  const char *wayland_display;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *wayland_socket = NULL;\n  g_autofree char *sandbox_wayland_socket = NULL;\n  gboolean res = FALSE;\n  struct stat statbuf;\n\n  wayland_display = g_getenv (\"WAYLAND_DISPLAY\");\n  if (!wayland_display)\n    wayland_display = \"wayland-0\";\n\n  wayland_socket = g_build_filename (user_runtime_dir, wayland_display, NULL);\n\n  if (!g_str_has_prefix (wayland_display, \"wayland-\") ||\n      strchr (wayland_display, '/') != NULL)\n    {\n      wayland_display = \"wayland-0\";\n      flatpak_bwrap_set_env (bwrap, \"WAYLAND_DISPLAY\", wayland_display, TRUE);\n    }\n\n  sandbox_wayland_socket = g_strdup_printf (\"/run/flatpak/%s\", wayland_display);\n\n  if (stat (wayland_socket, &statbuf) == 0 &&\n      (statbuf.st_mode & S_IFMT) == S_IFSOCK)\n    {\n      res = TRUE;\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", wayland_socket, sandbox_wayland_socket,\n                              NULL);\n      flatpak_bwrap_add_runtime_dir_member (bwrap, wayland_display);\n    }\n  return res;\n}\n\nstatic void\nflatpak_run_add_ssh_args (FlatpakBwrap *bwrap)\n{\n  static const char sandbox_auth_socket[] = \"/run/flatpak/ssh-auth\";\n  const char * auth_socket;\n\n  auth_socket = g_getenv (\"SSH_AUTH_SOCK\");\n\n  if (!auth_socket)\n    return; /* ssh agent not present */\n\n  if (!g_file_test (auth_socket, G_FILE_TEST_EXISTS))\n    {\n      /* Let's clean it up, so that the application will not try to connect */\n      flatpak_bwrap_unset_env (bwrap, \"SSH_AUTH_SOCK\");\n      return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", auth_socket, sandbox_auth_socket,\n                          NULL);\n  flatpak_bwrap_set_env (bwrap, \"SSH_AUTH_SOCK\", sandbox_auth_socket, TRUE);\n}\n\nstatic void\nflatpak_run_add_pcsc_args (FlatpakBwrap *bwrap)\n{\n  const char * pcsc_socket;\n  const char * sandbox_pcsc_socket = \"/run/pcscd/pcscd.comm\";\n\n  pcsc_socket = g_getenv (\"PCSCLITE_CSOCK_NAME\");\n  if (pcsc_socket)\n    {\n      if (!g_file_test (pcsc_socket, G_FILE_TEST_EXISTS))\n        {\n          flatpak_bwrap_unset_env (bwrap, \"PCSCLITE_CSOCK_NAME\");\n          return;\n        }\n    }\n  else\n    {\n      pcsc_socket = \"/run/pcscd/pcscd.comm\";\n      if (!g_file_test (pcsc_socket, G_FILE_TEST_EXISTS))\n        return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", pcsc_socket, sandbox_pcsc_socket,\n                          NULL);\n  flatpak_bwrap_set_env (bwrap, \"PCSCLITE_CSOCK_NAME\", sandbox_pcsc_socket, TRUE);\n}\n\nstatic gboolean\nflatpak_run_cups_check_server_is_socket (const char *server)\n{\n  if (g_str_has_prefix (server, \"/\") && strstr (server, \":\") == NULL)\n    return TRUE;\n\n  return FALSE;\n}\n\n/* Try to find a default server from a cups confguration file */\nstatic char *\nflatpak_run_get_cups_server_name_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"CUPS configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n\n      g_strchug (line);\n\n      if ((*line  == '\\0') || (*line == '#'))\n        continue;\n\n      g_auto(GStrv) tokens = g_strsplit (line, \" \", 2);\n\n      if ((tokens[0] != NULL) && (tokens[1] != NULL))\n        {\n          if (strcmp (\"ServerName\", tokens[0]) == 0)\n            {\n              g_strchug (tokens[1]);\n\n              if (flatpak_run_cups_check_server_is_socket (tokens[1]))\n                return g_strdup (tokens[1]);\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic char *\nflatpak_run_get_cups_server_name (void)\n{\n  g_autofree char * cups_server = NULL;\n  g_autofree char * cups_config_path = NULL;\n\n  /* TODO\n   * we don't currently support cups servers located on the network, if such\n   * server is detected, we simply ignore it and in the worst case we fallback\n   * to the default socket\n   */\n  cups_server = g_strdup (g_getenv (\"CUPS_SERVER\"));\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n\n  cups_config_path = g_build_filename (g_get_home_dir (), \".cups/client.conf\", NULL);\n  cups_server = flatpak_run_get_cups_server_name_config (cups_config_path);\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n\n  cups_server = flatpak_run_get_cups_server_name_config (\"/etc/cups/client.conf\");\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n\n  // Fallback to default socket\n  return g_strdup (\"/var/run/cups/cups.sock\");\n}\n\nstatic void\nflatpak_run_add_cups_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char * sandbox_server_name = g_strdup (\"/var/run/cups/cups.sock\");\n  g_autofree char * cups_server_name = flatpak_run_get_cups_server_name ();\n\n  if (!g_file_test (cups_server_name, G_FILE_TEST_EXISTS))\n    {\n      g_debug (\"Could not find CUPS server\");\n      return;\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", cups_server_name, sandbox_server_name,\n                          NULL);\n}\n\n/* Try to find a default server from a pulseaudio confguration file */\nstatic char *\nflatpak_run_get_pulseaudio_server_user_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"Pulseaudio user configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n\n      g_strchug (line);\n\n      if ((*line  == '\\0') || (*line == ';') || (*line == '#'))\n        continue;\n\n      if (g_str_has_prefix (line, \".include \"))\n        {\n          g_autofree char *rec_path = g_strdup (line + 9);\n          g_strstrip (rec_path);\n          char *found = flatpak_run_get_pulseaudio_server_user_config (rec_path);\n          if (found)\n            return found;\n        }\n      else if (g_str_has_prefix (line, \"[\"))\n        {\n          return NULL;\n        }\n      else\n        {\n          g_auto(GStrv) tokens = g_strsplit (line, \"=\", 2);\n\n          if ((tokens[0] != NULL) && (tokens[1] != NULL))\n            {\n              g_strchomp (tokens[0]);\n              if (strcmp (\"default-server\", tokens[0]) == 0)\n                {\n                  g_strstrip (tokens[1]);\n                  g_debug (\"Found pulseaudio socket from configuration file '%s': %s\", path, tokens[1]);\n                  return g_strdup (tokens[1]);\n                }\n            }\n        }\n    }\n\n  return NULL;\n}\n\nstatic char *\nflatpak_run_get_pulseaudio_server (void)\n{\n  const char * pulse_clientconfig;\n  char *pulse_server;\n  g_autofree char *pulse_user_config = NULL;\n\n  pulse_server = g_strdup (g_getenv (\"PULSE_SERVER\"));\n  if (pulse_server)\n    return pulse_server;\n\n  pulse_clientconfig = g_getenv (\"PULSE_CLIENTCONFIG\");\n  if (pulse_clientconfig)\n    return flatpak_run_get_pulseaudio_server_user_config (pulse_clientconfig);\n\n  pulse_user_config = g_build_filename (g_get_user_config_dir (), \"pulse/client.conf\", NULL);\n  pulse_server = flatpak_run_get_pulseaudio_server_user_config (pulse_user_config);\n  if (pulse_server)\n    return pulse_server;\n\n  pulse_server = flatpak_run_get_pulseaudio_server_user_config (\"/etc/pulse/client.conf\");\n  if (pulse_server)\n    return pulse_server;\n\n  return NULL;\n}\n\nstatic char *\nflatpak_run_parse_pulse_server (const char *value)\n{\n  g_auto(GStrv) servers = g_strsplit (value, \" \", 0);\n  gsize i;\n\n  for (i = 0; servers[i] != NULL; i++)\n    {\n      const char *server = servers[i];\n      if (g_str_has_prefix (server, \"{\"))\n        {\n          const char * closing = strstr (server, \"}\");\n          if (closing == NULL)\n            continue;\n          server = closing + 1;\n        }\n      if (g_str_has_prefix (server, \"unix:\"))\n        return g_strdup (server + 5);\n    }\n\n  return NULL;\n}\n\n/*\n * Get the machine ID as used by PulseAudio. This is the systemd/D-Bus\n * machine ID, or failing that, the hostname.\n */\nstatic char *\nflatpak_run_get_pulse_machine_id (void)\n{\n  static const char * const machine_ids[] =\n  {\n    \"/etc/machine-id\",\n    \"/var/lib/dbus/machine-id\",\n  };\n  gsize i;\n\n  for (i = 0; i < G_N_ELEMENTS (machine_ids); i++)\n    {\n      g_autofree char *ret = NULL;\n\n      if (g_file_get_contents (machine_ids[i], &ret, NULL, NULL))\n        {\n          gsize j;\n\n          g_strstrip (ret);\n\n          for (j = 0; ret[j] != '\\0'; j++)\n            {\n              if (!g_ascii_isxdigit (ret[j]))\n                break;\n            }\n\n          if (ret[0] != '\\0' && ret[j] == '\\0')\n            return g_steal_pointer (&ret);\n        }\n    }\n\n  return g_strdup (g_get_host_name ());\n}\n\n/*\n * Get the directory used by PulseAudio for its configuration.\n */\nstatic char *\nflatpak_run_get_pulse_home (void)\n{\n  /* Legacy path ~/.pulse is tried first, for compatibility */\n  {\n    const char *parent = g_get_home_dir ();\n    g_autofree char *ret = g_build_filename (parent, \".pulse\", NULL);\n\n    if (g_file_test (ret, G_FILE_TEST_IS_DIR))\n      return g_steal_pointer (&ret);\n  }\n\n  /* The more modern path, usually ~/.config/pulse */\n  {\n    const char *parent = g_get_user_config_dir ();\n    /* Usually ~/.config/pulse */\n    g_autofree char *ret = g_build_filename (parent, \"pulse\", NULL);\n\n    if (g_file_test (ret, G_FILE_TEST_IS_DIR))\n      return g_steal_pointer (&ret);\n  }\n\n  return NULL;\n}\n\n/*\n * Get the runtime directory used by PulseAudio for its socket.\n */\nstatic char *\nflatpak_run_get_pulse_runtime_dir (void)\n{\n  const char *val = NULL;\n\n  val = g_getenv (\"PULSE_RUNTIME_PATH\");\n\n  if (val != NULL)\n    return realpath (val, NULL);\n\n  {\n    const char *user_runtime_dir = g_get_user_runtime_dir ();\n\n    if (user_runtime_dir != NULL)\n      {\n        g_autofree char *dir = g_build_filename (user_runtime_dir, \"pulse\", NULL);\n\n        if (g_file_test (dir, G_FILE_TEST_IS_DIR))\n          return realpath (dir, NULL);\n      }\n  }\n\n  {\n    g_autofree char *pulse_home = flatpak_run_get_pulse_home ();\n    g_autofree char *machine_id = flatpak_run_get_pulse_machine_id ();\n\n    if (pulse_home != NULL && machine_id != NULL)\n      {\n        /* This is usually a symlink, but we take its realpath() anyway */\n        g_autofree char *dir = g_strdup_printf (\"%s/%s-runtime\", pulse_home, machine_id);\n\n        if (g_file_test (dir, G_FILE_TEST_IS_DIR))\n          return realpath (dir, NULL);\n      }\n  }\n\n  return NULL;\n}\n\nstatic void\nflatpak_run_add_pulseaudio_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *pulseaudio_server = flatpak_run_get_pulseaudio_server ();\n  g_autofree char *pulseaudio_socket = NULL;\n  g_autofree char *pulse_runtime_dir = flatpak_run_get_pulse_runtime_dir ();\n\n  if (pulseaudio_server)\n    pulseaudio_socket = flatpak_run_parse_pulse_server (pulseaudio_server);\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = g_build_filename (pulse_runtime_dir, \"native\", NULL);\n\n      if (!g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  if (!pulseaudio_socket)\n    {\n      pulseaudio_socket = realpath (\"/var/run/pulse/native\", NULL);\n\n      if (pulseaudio_socket && !g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n        g_clear_pointer (&pulseaudio_socket, g_free);\n    }\n\n  flatpak_bwrap_unset_env (bwrap, \"PULSE_SERVER\");\n\n  if (pulseaudio_socket && g_file_test (pulseaudio_socket, G_FILE_TEST_EXISTS))\n    {\n      static const char sandbox_socket_path[] = \"/run/flatpak/pulse/native\";\n      static const char pulse_server[] = \"unix:/run/flatpak/pulse/native\";\n      static const char config_path[] = \"/run/flatpak/pulse/config\";\n      gboolean share_shm = FALSE; /* TODO: When do we add this? */\n      g_autofree char *client_config = g_strdup_printf (\"enable-shm=%s\\n\", share_shm ? \"yes\" : \"no\");\n\n      /* FIXME - error handling */\n      if (!flatpak_bwrap_add_args_data (bwrap, \"pulseaudio\", client_config, -1, config_path, NULL))\n        return;\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", pulseaudio_socket, sandbox_socket_path,\n                              NULL);\n\n      flatpak_bwrap_set_env (bwrap, \"PULSE_SERVER\", pulse_server, TRUE);\n      flatpak_bwrap_set_env (bwrap, \"PULSE_CLIENTCONFIG\", config_path, TRUE);\n      flatpak_bwrap_add_runtime_dir_member (bwrap, \"pulse\");\n    }\n  else\n    g_debug (\"Could not find pulseaudio socket\");\n\n  /* Also allow ALSA access. This was added in 1.8, and is not ideally named. However,\n   * since the practical permission of ALSA and PulseAudio are essentially the same, and\n   * since we don't want to add more permissions for something we plan to replace with\n   * portals/pipewire going forward we reinterpret pulseaudio to also mean ALSA.\n   */\n  if (g_file_test (\"/dev/snd\", G_FILE_TEST_IS_DIR))\n    flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/snd\", \"/dev/snd\", NULL);\n}\n\nstatic void\nflatpak_run_add_resolved_args (FlatpakBwrap *bwrap)\n{\n  const char *resolved_socket = \"/run/systemd/resolve/io.systemd.Resolve\";\n\n  if (g_file_test (resolved_socket, G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--bind\", resolved_socket, resolved_socket, NULL);\n}\n\nstatic void\nflatpak_run_add_journal_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *journal_socket_socket = g_strdup (\"/run/systemd/journal/socket\");\n  g_autofree char *journal_stdout_socket = g_strdup (\"/run/systemd/journal/stdout\");\n\n  if (g_file_test (journal_socket_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_socket_socket, journal_socket_socket,\n                              NULL);\n    }\n  if (g_file_test (journal_stdout_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_stdout_socket, journal_stdout_socket,\n                              NULL);\n    }\n}\n\nstatic char *\ncreate_proxy_socket (char *template)\n{\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy\", NULL);\n  g_autofree char *proxy_socket = g_build_filename (proxy_socket_dir, template, NULL);\n  int fd;\n\n  if (!glnx_shutil_mkdir_p_at (AT_FDCWD, proxy_socket_dir, 0755, NULL, NULL))\n    return NULL;\n\n  fd = g_mkstemp (proxy_socket);\n  if (fd == -1)\n    return NULL;\n\n  close (fd);\n\n  return g_steal_pointer (&proxy_socket);\n}\n\nstatic gboolean\nflatpak_run_add_system_dbus_args (FlatpakBwrap   *app_bwrap,\n                                  FlatpakBwrap   *proxy_arg_bwrap,\n                                  FlatpakContext *context,\n                                  FlatpakRunFlags flags)\n{\n  gboolean unrestricted, no_proxy;\n  const char *dbus_address = g_getenv (\"DBUS_SYSTEM_BUS_ADDRESS\");\n  g_autofree char *real_dbus_address = NULL;\n  g_autofree char *dbus_system_socket = NULL;\n\n  unrestricted = (context->sockets & FLATPAK_CONTEXT_SOCKET_SYSTEM_BUS) != 0;\n  if (unrestricted)\n    g_debug (\"Allowing system-dbus access\");\n\n  no_proxy = (flags & FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY) != 0;\n\n  if (dbus_address != NULL)\n    dbus_system_socket = extract_unix_path_from_dbus_address (dbus_address);\n  else if (g_file_test (\"/var/run/dbus/system_bus_socket\", G_FILE_TEST_EXISTS))\n    dbus_system_socket = g_strdup (\"/var/run/dbus/system_bus_socket\");\n\n  if (dbus_system_socket != NULL && unrestricted)\n    {\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", dbus_system_socket, \"/run/dbus/system_bus_socket\",\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SYSTEM_BUS_ADDRESS\", \"unix:path=/run/dbus/system_bus_socket\", TRUE);\n\n      return TRUE;\n    }\n  else if (!no_proxy && flatpak_context_get_needs_system_bus_proxy (context))\n    {\n      g_autofree char *proxy_socket = create_proxy_socket (\"system-bus-proxy-XXXXXX\");\n\n      if (proxy_socket == NULL)\n        return FALSE;\n\n      if (dbus_address)\n        real_dbus_address = g_strdup (dbus_address);\n      else\n        real_dbus_address = g_strdup_printf (\"unix:path=%s\", dbus_system_socket);\n\n      flatpak_bwrap_add_args (proxy_arg_bwrap, real_dbus_address, proxy_socket, NULL);\n\n      if (!unrestricted)\n        flatpak_context_add_bus_filters (context, NULL, FALSE, flags & FLATPAK_RUN_FLAG_SANDBOX, proxy_arg_bwrap);\n\n      if ((flags & FLATPAK_RUN_FLAG_LOG_SYSTEM_BUS) != 0)\n        flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", proxy_socket, \"/run/dbus/system_bus_socket\",\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SYSTEM_BUS_ADDRESS\", \"unix:path=/run/dbus/system_bus_socket\", TRUE);\n\n      return TRUE;\n    }\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_run_add_session_dbus_args (FlatpakBwrap   *app_bwrap,\n                                   FlatpakBwrap   *proxy_arg_bwrap,\n                                   FlatpakContext *context,\n                                   FlatpakRunFlags flags,\n                                   const char     *app_id)\n{\n  static const char sandbox_socket_path[] = \"/run/flatpak/bus\";\n  static const char sandbox_dbus_address[] = \"unix:path=/run/flatpak/bus\";\n  gboolean unrestricted, no_proxy;\n  const char *dbus_address = g_getenv (\"DBUS_SESSION_BUS_ADDRESS\");\n  g_autofree char *dbus_session_socket = NULL;\n\n  unrestricted = (context->sockets & FLATPAK_CONTEXT_SOCKET_SESSION_BUS) != 0;\n\n  if (dbus_address != NULL)\n    {\n      dbus_session_socket = extract_unix_path_from_dbus_address (dbus_address);\n    }\n  else\n    {\n      g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n      struct stat statbuf;\n\n      dbus_session_socket = g_build_filename (user_runtime_dir, \"bus\", NULL);\n\n      if (stat (dbus_session_socket, &statbuf) < 0\n          || (statbuf.st_mode & S_IFMT) != S_IFSOCK\n          || statbuf.st_uid != getuid ())\n        return FALSE;\n    }\n\n  if (unrestricted)\n    g_debug (\"Allowing session-dbus access\");\n\n  no_proxy = (flags & FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY) != 0;\n\n  if (dbus_session_socket != NULL && unrestricted)\n    {\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", dbus_session_socket, sandbox_socket_path,\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SESSION_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n      flatpak_bwrap_add_runtime_dir_member (app_bwrap, \"bus\");\n\n      return TRUE;\n    }\n  else if (!no_proxy && dbus_address != NULL)\n    {\n      g_autofree char *proxy_socket = create_proxy_socket (\"session-bus-proxy-XXXXXX\");\n\n      if (proxy_socket == NULL)\n        return FALSE;\n\n      flatpak_bwrap_add_args (proxy_arg_bwrap, dbus_address, proxy_socket, NULL);\n\n      if (!unrestricted)\n        {\n          flatpak_context_add_bus_filters (context, app_id, TRUE, flags & FLATPAK_RUN_FLAG_SANDBOX, proxy_arg_bwrap);\n\n          /* Allow calling any interface+method on all portals, but only receive broadcasts under /org/desktop/portal */\n          flatpak_bwrap_add_arg (proxy_arg_bwrap,\n                                 \"--call=org.freedesktop.portal.*=*\");\n          flatpak_bwrap_add_arg (proxy_arg_bwrap,\n                                 \"--broadcast=org.freedesktop.portal.*=@/org/freedesktop/portal/*\");\n        }\n\n      if ((flags & FLATPAK_RUN_FLAG_LOG_SESSION_BUS) != 0)\n        flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n      flatpak_bwrap_add_args (app_bwrap,\n                              \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                              NULL);\n      flatpak_bwrap_set_env (app_bwrap, \"DBUS_SESSION_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n      flatpak_bwrap_add_runtime_dir_member (app_bwrap, \"bus\");\n\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_run_add_a11y_dbus_args (FlatpakBwrap   *app_bwrap,\n                                FlatpakBwrap   *proxy_arg_bwrap,\n                                FlatpakContext *context,\n                                FlatpakRunFlags flags)\n{\n  static const char sandbox_socket_path[] = \"/run/flatpak/at-spi-bus\";\n  static const char sandbox_dbus_address[] = \"unix:path=/run/flatpak/at-spi-bus\";\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *a11y_address = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDBusMessage) reply = NULL;\n  g_autoptr(GDBusMessage) msg = NULL;\n  g_autofree char *proxy_socket = NULL;\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY) != 0)\n    return FALSE;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus == NULL)\n    return FALSE;\n\n  msg = g_dbus_message_new_method_call (\"org.a11y.Bus\", \"/org/a11y/bus\", \"org.a11y.Bus\", \"GetAddress\");\n  g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n  reply =\n    g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                    G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                    30000,\n                                                    NULL,\n                                                    NULL,\n                                                    NULL);\n  if (reply)\n    {\n      if (g_dbus_message_to_gerror (reply, &local_error))\n        {\n          if (!g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n            g_message (\"Can't find a11y bus: %s\", local_error->message);\n        }\n      else\n        {\n          g_variant_get (g_dbus_message_get_body (reply),\n                         \"(s)\", &a11y_address);\n        }\n    }\n\n  if (!a11y_address)\n    return FALSE;\n\n  proxy_socket = create_proxy_socket (\"a11y-bus-proxy-XXXXXX\");\n  if (proxy_socket == NULL)\n    return FALSE;\n\n  flatpak_bwrap_add_args (proxy_arg_bwrap,\n                          a11y_address,\n                          proxy_socket, \"--filter\", \"--sloppy-names\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Embed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Socket.Unembed@/org/a11y/atspi/accessible/root\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.Registry.GetRegisteredEvents@/org/a11y/atspi/registry\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetKeystrokeListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.GetDeviceEventListeners@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersSync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          \"--call=org.a11y.atspi.Registry=org.a11y.atspi.DeviceEventController.NotifyListenersAsync@/org/a11y/atspi/registry/deviceeventcontroller\",\n                          NULL);\n\n  if ((flags & FLATPAK_RUN_FLAG_LOG_A11Y_BUS) != 0)\n    flatpak_bwrap_add_args (proxy_arg_bwrap, \"--log\", NULL);\n\n  flatpak_bwrap_add_args (app_bwrap,\n                          \"--ro-bind\", proxy_socket, sandbox_socket_path,\n                          NULL);\n  flatpak_bwrap_set_env (app_bwrap, \"AT_SPI_BUS_ADDRESS\", sandbox_dbus_address, TRUE);\n\n  return TRUE;\n}\n\n/* This wraps the argv in a bwrap call, primary to allow the\n   command to be run with a proper /.flatpak-info with data\n   taken from app_info_path */\nstatic gboolean\nadd_bwrap_wrapper (FlatpakBwrap *bwrap,\n                   const char   *app_info_path,\n                   GError      **error)\n{\n  glnx_autofd int app_info_fd = -1;\n  g_auto(GLnxDirFdIterator) dir_iter = { 0 };\n  struct dirent *dent;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy/\", NULL);\n\n  app_info_fd = open (app_info_path, O_RDONLY | O_CLOEXEC);\n  if (app_info_fd == -1)\n    return glnx_throw_errno_prefix (error, _(\"Failed to open app info file\"));\n\n  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, \"/\", FALSE, &dir_iter, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  while (TRUE)\n    {\n      glnx_autofd int o_path_fd = -1;\n      struct statfs stfs;\n\n      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dir_iter, &dent, NULL, error))\n        return FALSE;\n\n      if (dent == NULL)\n        break;\n\n      if (strcmp (dent->d_name, \".flatpak-info\") == 0)\n        continue;\n\n      /* O_PATH + fstatfs is the magic that we need to statfs without automounting the target */\n      o_path_fd = openat (dir_iter.fd, dent->d_name, O_PATH | O_NOFOLLOW | O_CLOEXEC);\n      if (o_path_fd == -1 || fstatfs (o_path_fd, &stfs) != 0 || stfs.f_type == AUTOFS_SUPER_MAGIC)\n        continue; /* AUTOFS mounts are risky and can cause us to block (see issue #1633), so ignore it. Its unlikely the proxy needs such a directory. */\n\n      if (dent->d_type == DT_DIR)\n        {\n          if (strcmp (dent->d_name, \"tmp\") == 0 ||\n              strcmp (dent->d_name, \"var\") == 0 ||\n              strcmp (dent->d_name, \"run\") == 0)\n            flatpak_bwrap_add_arg (bwrap, \"--bind\");\n          else\n            flatpak_bwrap_add_arg (bwrap, \"--ro-bind\");\n\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n      else if (dent->d_type == DT_LNK)\n        {\n          g_autofree gchar *target = NULL;\n\n          target = glnx_readlinkat_malloc (dir_iter.fd, dent->d_name,\n                                           NULL, error);\n          if (target == NULL)\n            return FALSE;\n          flatpak_bwrap_add_args (bwrap, \"--symlink\", target, NULL);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n    }\n\n  flatpak_bwrap_add_args (bwrap, \"--bind\", proxy_socket_dir, proxy_socket_dir, NULL);\n\n  /* This is a file rather than a bind mount, because it will then\n     not be unmounted from the namespace when the namespace dies. */\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--file\", glnx_steal_fd (&app_info_fd), \"/.flatpak-info\");\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nstart_dbus_proxy (FlatpakBwrap *app_bwrap,\n                  FlatpakBwrap *proxy_arg_bwrap,\n                  const char   *app_info_path,\n                  GError      **error)\n{\n  char x = 'x';\n  const char *proxy;\n  g_autofree char *commandline = NULL;\n  g_autoptr(FlatpakBwrap) proxy_bwrap = NULL;\n  int sync_fds[2] = {-1, -1};\n  int proxy_start_index;\n\n  proxy_bwrap = flatpak_bwrap_new (NULL);\n\n  if (!add_bwrap_wrapper (proxy_bwrap, app_info_path, error))\n    return FALSE;\n\n  proxy = g_getenv (\"FLATPAK_DBUSPROXY\");\n  if (proxy == NULL)\n    proxy = DBUSPROXY;\n\n  flatpak_bwrap_add_arg (proxy_bwrap, proxy);\n\n  proxy_start_index = proxy_bwrap->argv->len;\n\n  if (pipe2 (sync_fds, O_CLOEXEC) < 0)\n    {\n      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                           _(\"Unable to create sync pipe\"));\n      return FALSE;\n    }\n\n  /* read end goes to app */\n  flatpak_bwrap_add_args_data_fd (app_bwrap, \"--sync-fd\", sync_fds[0], NULL);\n\n  /* write end goes to proxy */\n  flatpak_bwrap_add_fd (proxy_bwrap, sync_fds[1]);\n  flatpak_bwrap_add_arg_printf (proxy_bwrap, \"--fd=%d\", sync_fds[1]);\n\n  /* Note: This steals the fds from proxy_arg_bwrap */\n  flatpak_bwrap_append_bwrap (proxy_bwrap, proxy_arg_bwrap);\n\n  if (!flatpak_bwrap_bundle_args (proxy_bwrap, proxy_start_index, -1, TRUE, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (proxy_bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) proxy_bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async (NULL,\n                      (char **) proxy_bwrap->argv->pdata,\n                      NULL,\n                      G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                      flatpak_bwrap_child_setup_cb, proxy_bwrap->fds,\n                      NULL, error))\n    return FALSE;\n\n  /* The write end can be closed now, otherwise the read below will hang of xdg-dbus-proxy\n     fails to start. */\n  g_clear_pointer (&proxy_bwrap, flatpak_bwrap_free);\n\n  /* Sync with proxy, i.e. wait until its listening on the sockets */\n  if (read (sync_fds[0], &x, 1) != 1)\n    {\n      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                           _(\"Failed to sync with dbus proxy\"));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic int\nflatpak_extension_compare_by_path (gconstpointer _a,\n                                   gconstpointer _b)\n{\n  const FlatpakExtension *a = _a;\n  const FlatpakExtension *b = _b;\n\n  return g_strcmp0 (a->directory, b->directory);\n}\n\nvoid\nflatpak_run_extend_ld_path (FlatpakBwrap *bwrap,\n                            const char *prepend,\n                            const char *append)\n{\n  g_autoptr(GString) ld_library_path = g_string_new (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"));\n\n  if (prepend != NULL && *prepend != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_prepend (ld_library_path, \":\");\n\n      g_string_prepend (ld_library_path, prepend);\n    }\n\n  if (append != NULL && *append != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_append (ld_library_path, \":\");\n\n      g_string_append (ld_library_path, append);\n    }\n\n  flatpak_bwrap_set_env (bwrap, \"LD_LIBRARY_PATH\", ld_library_path->str, TRUE);\n}\n\ngboolean\nflatpak_run_add_extension_args (FlatpakBwrap      *bwrap,\n                                GKeyFile          *metakey,\n                                FlatpakDecomposed *ref,\n                                gboolean           use_ld_so_cache,\n                                const char        *target_path,\n                                char             **extensions_out,\n                                char             **ld_path_out,\n                                GCancellable      *cancellable,\n                                GError           **error)\n{\n  g_autoptr(GString) used_extensions = g_string_new (\"\");\n  GList *extensions, *path_sorted_extensions, *l;\n  g_autoptr(GString) ld_library_path = g_string_new (\"\");\n  int count = 0;\n  g_autoptr(GHashTable) mounted_tmpfs =\n    g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autoptr(GHashTable) created_symlink =\n    g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *arch = flatpak_decomposed_dup_arch (ref);\n  const char *branch = flatpak_decomposed_get_branch (ref);\n\n  g_return_val_if_fail (target_path != NULL, FALSE);\n\n  extensions = flatpak_list_extensions (metakey, arch, branch);\n\n  /* First we apply all the bindings, they are sorted alphabetically in order for parent directory\n     to be mounted before child directories */\n  path_sorted_extensions = g_list_copy (extensions);\n  path_sorted_extensions = g_list_sort (path_sorted_extensions, flatpak_extension_compare_by_path);\n\n  for (l = path_sorted_extensions; l != NULL; l = l->next)\n    {\n      FlatpakExtension *ext = l->data;\n      g_autofree char *directory = g_build_filename (target_path, ext->directory, NULL);\n      g_autofree char *full_directory = g_build_filename (directory, ext->subdir_suffix, NULL);\n      g_autofree char *ref_file = g_build_filename (full_directory, \".ref\", NULL);\n      g_autofree char *real_ref = g_build_filename (ext->files_path, ext->directory, \".ref\", NULL);\n\n      if (ext->needs_tmpfs)\n        {\n          g_autofree char *parent = g_path_get_dirname (directory);\n\n          if (g_hash_table_lookup (mounted_tmpfs, parent) == NULL)\n            {\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--tmpfs\", parent,\n                                      NULL);\n              g_hash_table_insert (mounted_tmpfs, g_steal_pointer (&parent), \"mounted\");\n            }\n        }\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", ext->files_path, full_directory,\n                              NULL);\n\n      if (g_file_test (real_ref, G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--lock-file\", ref_file,\n                                NULL);\n    }\n\n  g_list_free (path_sorted_extensions);\n\n  /* Then apply library directories and file merging, in extension prio order */\n\n  for (l = extensions; l != NULL; l = l->next)\n    {\n      FlatpakExtension *ext = l->data;\n      g_autofree char *directory = g_build_filename (target_path, ext->directory, NULL);\n      g_autofree char *full_directory = g_build_filename (directory, ext->subdir_suffix, NULL);\n      int i;\n\n      if (used_extensions->len > 0)\n        g_string_append (used_extensions, \";\");\n      g_string_append (used_extensions, ext->installed_id);\n      g_string_append (used_extensions, \"=\");\n      if (ext->commit != NULL)\n        g_string_append (used_extensions, ext->commit);\n      else\n        g_string_append (used_extensions, \"local\");\n\n      if (ext->add_ld_path)\n        {\n          g_autofree char *ld_path = g_build_filename (full_directory, ext->add_ld_path, NULL);\n\n          if (use_ld_so_cache)\n            {\n              g_autofree char *contents = g_strconcat (ld_path, \"\\n\", NULL);\n              /* We prepend app or runtime and a counter in order to get the include order correct for the conf files */\n              g_autofree char *ld_so_conf_file = g_strdup_printf (\"%s-%03d-%s.conf\", flatpak_decomposed_get_kind_str (ref), ++count, ext->installed_id);\n              g_autofree char *ld_so_conf_file_path = g_build_filename (\"/run/flatpak/ld.so.conf.d\", ld_so_conf_file, NULL);\n\n              if (!flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                                contents, -1, ld_so_conf_file_path, error))\n                return FALSE;\n            }\n          else\n            {\n              if (ld_library_path->len != 0)\n                g_string_append (ld_library_path, \":\");\n              g_string_append (ld_library_path, ld_path);\n            }\n        }\n\n      for (i = 0; ext->merge_dirs != NULL && ext->merge_dirs[i] != NULL; i++)\n        {\n          g_autofree char *parent = g_path_get_dirname (directory);\n          g_autofree char *merge_dir = g_build_filename (parent, ext->merge_dirs[i], NULL);\n          g_autofree char *source_dir = g_build_filename (ext->files_path, ext->merge_dirs[i], NULL);\n          g_auto(GLnxDirFdIterator) source_iter = { 0 };\n          struct dirent *dent;\n\n          if (glnx_dirfd_iterator_init_at (AT_FDCWD, source_dir, TRUE, &source_iter, NULL))\n            {\n              while (glnx_dirfd_iterator_next_dent (&source_iter, &dent, NULL, NULL) && dent != NULL)\n                {\n                  g_autofree char *symlink_path = g_build_filename (merge_dir, dent->d_name, NULL);\n                  /* Only create the first, because extensions are listed in prio order */\n                  if (g_hash_table_lookup (created_symlink, symlink_path) == NULL)\n                    {\n                      g_autofree char *symlink = g_build_filename (directory, ext->merge_dirs[i], dent->d_name, NULL);\n                      flatpak_bwrap_add_args (bwrap,\n                                              \"--symlink\", symlink, symlink_path,\n                                              NULL);\n                      g_hash_table_insert (created_symlink, g_steal_pointer (&symlink_path), \"created\");\n                    }\n                }\n            }\n        }\n    }\n\n  g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n\n  if (extensions_out)\n    *extensions_out = g_string_free (g_steal_pointer (&used_extensions), FALSE);\n\n  if (ld_path_out)\n    *ld_path_out = g_string_free (g_steal_pointer (&ld_library_path), FALSE);\n\n  return TRUE;\n}\n\n/*\n * @per_app_dir_lock_fd: If >= 0, make use of per-app directories in\n *  the host's XDG_RUNTIME_DIR to share /tmp between instances.\n */\ngboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  int              per_app_dir_lock_fd,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  g_autofree char *xdg_dirs_conf = NULL;\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n  gboolean home_access = FALSE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n            {\n              /* Don't do anything special: include shm in the\n               * shared /dev. The host and all sandboxes and subsandboxes\n               * all share /dev/shm */\n            }\n          else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)\n                   && per_app_dir_lock_fd >= 0)\n            {\n              g_autofree char *shared_dev_shm = NULL;\n\n              /* The host and the original sandbox have separate /dev/shm,\n               * but we want other instances to be able to share /dev/shm with\n               * the first sandbox (except for subsandboxes run with\n               * flatpak-spawn --sandbox, which will have their own). */\n              if (!flatpak_instance_ensure_per_app_dev_shm (app_id,\n                                                            per_app_dir_lock_fd,\n                                                            &shared_dev_shm,\n                                                            error))\n                return FALSE;\n\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--bind\", shared_dev_shm, \"/dev/shm\",\n                                      NULL);\n            }\n          else\n            {\n              /* The host, the original sandbox and each subsandbox\n               * each have a separate /dev/shm. */\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--tmpfs\", \"/dev/shm\",\n                                      NULL);\n            }\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                {\n                  flatpak_bwrap_add_args (bwrap,\n                                          \"--bind\", \"/run/shm\", \"/run/shm\",\n                                          NULL);\n                }\n              else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)\n                       && per_app_dir_lock_fd >= 0)\n                {\n                  g_autofree char *shared_dev_shm = NULL;\n\n                  /* The host and the original sandbox have separate /dev/shm,\n                   * but we want other instances to be able to share /dev/shm,\n                   * except for flatpak-spawn --subsandbox. */\n                  if (!flatpak_instance_ensure_per_app_dev_shm (app_id,\n                                                                per_app_dir_lock_fd,\n                                                                &shared_dev_shm,\n                                                                error))\n                    return FALSE;\n\n                  flatpak_bwrap_add_args (bwrap,\n                                          \"--bind\", shared_dev_shm, \"/run/shm\",\n                                          NULL);\n                }\n              else\n                {\n                  flatpak_bwrap_add_args (bwrap,\n                                          \"--dir\", \"/run/shm\",\n                                          NULL);\n                }\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n      else if ((context->features & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)\n               && per_app_dir_lock_fd >= 0)\n        {\n          g_autofree char *shared_dev_shm = NULL;\n\n          if (!flatpak_instance_ensure_per_app_dev_shm (app_id,\n                                                        per_app_dir_lock_fd,\n                                                        &shared_dev_shm,\n                                                        error))\n            return FALSE;\n\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--bind\", shared_dev_shm, \"/dev/shm\",\n                                  NULL);\n        }\n    }\n\n  exports = flatpak_context_get_exports_full (context,\n                                              app_id_dir, previous_app_id_dirs,\n                                              TRUE, TRUE,\n                                              &xdg_dirs_conf, &home_access);\n\n  if (flatpak_exports_path_is_visible (exports, \"/tmp\"))\n    {\n      /* The original sandbox and any subsandboxes are both already\n       * going to share /tmp with the host, so by transitivity they will\n       * also share it with each other, and with all other instances. */\n    }\n  else if (per_app_dir_lock_fd >= 0 && !sandboxed)\n    {\n      g_autofree char *shared_tmp = NULL;\n\n      /* The host and the original sandbox have separate /tmp,\n       * but we want other instances to be able to share /tmp with the\n       * first sandbox, unless they were created by\n       * flatpak-spawn --sandbox.\n       *\n       * In apply_extra and `flatpak build`, per_app_dir_lock_fd is\n       * negative and we skip this. */\n      if (!flatpak_instance_ensure_per_app_tmp (app_id,\n                                                per_app_dir_lock_fd,\n                                                &shared_tmp,\n                                                error))\n        return FALSE;\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--bind\", shared_tmp, \"/tmp\",\n                              NULL);\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir,\n                                           exports, xdg_dirs_conf, home_access);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}\n\ntypedef struct\n{\n  const char *env;\n  const char *val;\n} ExportData;\n\nstatic const ExportData default_exports[] = {\n  {\"PATH\", \"/app/bin:/usr/bin\"},\n  /* We always want to unset LD_LIBRARY_PATH to avoid inheriting weird\n   * dependencies from the host. But if not using ld.so.cache this is\n   * later set. */\n  {\"LD_LIBRARY_PATH\", NULL},\n  {\"XDG_CONFIG_DIRS\", \"/app/etc/xdg:/etc/xdg\"},\n  {\"XDG_DATA_DIRS\", \"/app/share:/usr/share\"},\n  {\"SHELL\", \"/bin/sh\"},\n  {\"TMPDIR\", NULL}, /* Unset TMPDIR as it may not exist in the sandbox */\n  /* We always use /run/user/UID, even if the user's XDG_RUNTIME_DIR\n   * outside the sandbox is somewhere else. Don't allow a different\n   * setting from outside the sandbox to overwrite this. */\n  {\"XDG_RUNTIME_DIR\", NULL},\n\n  /* Some env vars are common enough and will affect the sandbox badly\n     if set on the host. We clear these always. */\n  {\"PYTHONPATH\", NULL},\n  {\"PERLLIB\", NULL},\n  {\"PERL5LIB\", NULL},\n  {\"XCURSOR_PATH\", NULL},\n};\n\nstatic const ExportData no_ld_so_cache_exports[] = {\n  {\"LD_LIBRARY_PATH\", \"/app/lib\"},\n};\n\nstatic const ExportData devel_exports[] = {\n  {\"ACLOCAL_PATH\", \"/app/share/aclocal\"},\n  {\"C_INCLUDE_PATH\", \"/app/include\"},\n  {\"CPLUS_INCLUDE_PATH\", \"/app/include\"},\n  {\"LDFLAGS\", \"-L/app/lib \"},\n  {\"PKG_CONFIG_PATH\", \"/app/lib/pkgconfig:/app/share/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig\"},\n  {\"LC_ALL\", \"en_US.utf8\"},\n};\n\nstatic void\nadd_exports (GPtrArray        *env_array,\n             const ExportData *exports,\n             gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      if (exports[i].val)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", exports[i].env, exports[i].val));\n    }\n}\n\nchar **\nflatpak_run_get_minimal_env (gboolean devel, gboolean use_ld_so_cache)\n{\n  GPtrArray *env_array;\n  static const char * const copy[] = {\n    \"PWD\",\n    \"GDMSESSION\",\n    \"XDG_CURRENT_DESKTOP\",\n    \"XDG_SESSION_DESKTOP\",\n    \"DESKTOP_SESSION\",\n    \"EMAIL_ADDRESS\",\n    \"HOME\",\n    \"HOSTNAME\",\n    \"LOGNAME\",\n    \"REAL_NAME\",\n    \"TERM\",\n    \"USER\",\n    \"USERNAME\",\n  };\n  static const char * const copy_nodevel[] = {\n    \"LANG\",\n    \"LANGUAGE\",\n    \"LC_ALL\",\n    \"LC_ADDRESS\",\n    \"LC_COLLATE\",\n    \"LC_CTYPE\",\n    \"LC_IDENTIFICATION\",\n    \"LC_MEASUREMENT\",\n    \"LC_MESSAGES\",\n    \"LC_MONETARY\",\n    \"LC_NAME\",\n    \"LC_NUMERIC\",\n    \"LC_PAPER\",\n    \"LC_TELEPHONE\",\n    \"LC_TIME\",\n  };\n  int i;\n\n  env_array = g_ptr_array_new_with_free_func (g_free);\n\n  add_exports (env_array, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    add_exports (env_array, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n\n  if (devel)\n    add_exports (env_array, devel_exports, G_N_ELEMENTS (devel_exports));\n\n  for (i = 0; i < G_N_ELEMENTS (copy); i++)\n    {\n      const char *current = g_getenv (copy[i]);\n      if (current)\n        g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy[i], current));\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (copy_nodevel); i++)\n        {\n          const char *current = g_getenv (copy_nodevel[i]);\n          if (current)\n            g_ptr_array_add (env_array, g_strdup_printf (\"%s=%s\", copy_nodevel[i], current));\n        }\n    }\n\n  g_ptr_array_add (env_array, NULL);\n  return (char **) g_ptr_array_free (env_array, FALSE);\n}\n\nstatic char **\napply_exports (char            **envp,\n               const ExportData *exports,\n               gsize             n_exports)\n{\n  int i;\n\n  for (i = 0; i < n_exports; i++)\n    {\n      const char *value = exports[i].val;\n\n      if (value)\n        envp = g_environ_setenv (envp, exports[i].env, value, TRUE);\n      else\n        envp = g_environ_unsetenv (envp, exports[i].env);\n    }\n\n  return envp;\n}\n\nvoid\nflatpak_run_apply_env_default (FlatpakBwrap *bwrap, gboolean use_ld_so_cache)\n{\n  bwrap->envp = apply_exports (bwrap->envp, default_exports, G_N_ELEMENTS (default_exports));\n\n  if (!use_ld_so_cache)\n    bwrap->envp = apply_exports (bwrap->envp, no_ld_so_cache_exports, G_N_ELEMENTS (no_ld_so_cache_exports));\n}\n\nstatic void\nflatpak_run_apply_env_prompt (FlatpakBwrap *bwrap, const char *app_id)\n{\n  /* A custom shell prompt. FLATPAK_ID is always set.\n   * PS1 can be overwritten by runtime metadata or by --env overrides\n   */\n  flatpak_bwrap_set_env (bwrap, \"FLATPAK_ID\", app_id, TRUE);\n  flatpak_bwrap_set_env (bwrap, \"PS1\", \"[\ud83d\udce6 $FLATPAK_ID \\\\W]\\\\$ \", FALSE);\n}\n\nvoid\nflatpak_run_apply_env_appid (FlatpakBwrap *bwrap,\n                             GFile        *app_dir)\n{\n  g_autoptr(GFile) app_dir_data = NULL;\n  g_autoptr(GFile) app_dir_config = NULL;\n  g_autoptr(GFile) app_dir_cache = NULL;\n\n  app_dir_data = g_file_get_child (app_dir, \"data\");\n  app_dir_config = g_file_get_child (app_dir, \"config\");\n  app_dir_cache = g_file_get_child (app_dir, \"cache\");\n  flatpak_bwrap_set_env (bwrap, \"XDG_DATA_HOME\", flatpak_file_get_path_cached (app_dir_data), TRUE);\n  flatpak_bwrap_set_env (bwrap, \"XDG_CONFIG_HOME\", flatpak_file_get_path_cached (app_dir_config), TRUE);\n  flatpak_bwrap_set_env (bwrap, \"XDG_CACHE_HOME\", flatpak_file_get_path_cached (app_dir_cache), TRUE);\n\n  if (g_getenv (\"XDG_DATA_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_DATA_HOME\", g_getenv (\"XDG_DATA_HOME\"), TRUE);\n  if (g_getenv (\"XDG_CONFIG_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_CONFIG_HOME\", g_getenv (\"XDG_CONFIG_HOME\"), TRUE);\n  if (g_getenv (\"XDG_CACHE_HOME\"))\n    flatpak_bwrap_set_env (bwrap, \"HOST_XDG_CACHE_HOME\", g_getenv (\"XDG_CACHE_HOME\"), TRUE);\n}\n\nvoid\nflatpak_run_apply_env_vars (FlatpakBwrap *bwrap, FlatpakContext *context)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  g_hash_table_iter_init (&iter, context->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *var = key;\n      const char *val = value;\n\n      if (val)\n        flatpak_bwrap_set_env (bwrap, var, val, TRUE);\n      else\n        flatpak_bwrap_unset_env (bwrap, var);\n    }\n}\n\nGFile *\nflatpak_get_data_dir (const char *app_id)\n{\n  g_autoptr(GFile) home = g_file_new_for_path (g_get_home_dir ());\n  g_autoptr(GFile) var_app = g_file_resolve_relative_path (home, \".var/app\");\n\n  return g_file_get_child (var_app, app_id);\n}\n\ngboolean\nflatpak_ensure_data_dir (GFile        *app_id_dir,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  g_autoptr(GFile) data_dir = g_file_get_child (app_id_dir, \"data\");\n  g_autoptr(GFile) cache_dir = g_file_get_child (app_id_dir, \"cache\");\n  g_autoptr(GFile) fontconfig_cache_dir = g_file_get_child (cache_dir, \"fontconfig\");\n  g_autoptr(GFile) tmp_dir = g_file_get_child (cache_dir, \"tmp\");\n  g_autoptr(GFile) config_dir = g_file_get_child (app_id_dir, \"config\");\n\n  if (!flatpak_mkdir_p (data_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (fontconfig_cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (tmp_dir, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_mkdir_p (config_dir, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstruct JobData\n{\n  char      *job;\n  GMainLoop *main_loop;\n};\n\nstatic void\njob_removed_cb (SystemdManager *manager,\n                guint32         id,\n                char           *job,\n                char           *unit,\n                char           *result,\n                struct JobData *data)\n{\n  if (strcmp (job, data->job) == 0)\n    g_main_loop_quit (data->main_loop);\n}\n\nstatic gchar *\nsystemd_unit_name_escape (const gchar *in)\n{\n  /* Adapted from systemd source */\n  GString * const str = g_string_sized_new (strlen (in));\n\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}\n\ngboolean\nflatpak_run_in_transient_unit (const char *appid, GError **error)\n{\n  g_autoptr(GDBusConnection) conn = NULL;\n  g_autofree char *path = NULL;\n  g_autofree char *address = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *appid_escaped = NULL;\n  g_autofree char *job = NULL;\n  SystemdManager *manager = NULL;\n  GVariantBuilder builder;\n  GVariant *properties = NULL;\n  GVariant *aux = NULL;\n  guint32 pid;\n  GMainLoop *main_loop = NULL;\n  struct JobData data;\n  gboolean res = FALSE;\n  g_autoptr(GMainContextPopDefault) main_context = NULL;\n\n  path = g_strdup_printf (\"/run/user/%d/systemd/private\", getuid ());\n\n  if (!g_file_test (path, G_FILE_TEST_EXISTS))\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                               _(\"No systemd user session available, cgroups not available\"));\n\n  main_context = flatpak_main_context_new_default ();\n  main_loop = g_main_loop_new (main_context, FALSE);\n\n  address = g_strconcat (\"unix:path=\", path, NULL);\n\n  conn = g_dbus_connection_new_for_address_sync (address,\n                                                 G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT,\n                                                 NULL,\n                                                 NULL, error);\n  if (!conn)\n    goto out;\n\n  manager = systemd_manager_proxy_new_sync (conn,\n                                            G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,\n                                            NULL,\n                                            \"/org/freedesktop/systemd1\",\n                                            NULL, error);\n  if (!manager)\n    goto out;\n\n  appid_escaped = systemd_unit_name_escape (appid);\n  name = g_strdup_printf (\"app-flatpak-%s-%d.scope\", appid_escaped, getpid ());\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a(sv)\"));\n\n  pid = getpid ();\n  g_variant_builder_add (&builder, \"(sv)\",\n                         \"PIDs\",\n                         g_variant_new_fixed_array (G_VARIANT_TYPE (\"u\"),\n                                                    &pid, 1, sizeof (guint32))\n                        );\n\n  properties = g_variant_builder_end (&builder);\n\n  aux = g_variant_new_array (G_VARIANT_TYPE (\"(sa(sv))\"), NULL, 0);\n\n  if (!systemd_manager_call_start_transient_unit_sync (manager,\n                                                       name,\n                                                       \"fail\",\n                                                       properties,\n                                                       aux,\n                                                       &job,\n                                                       NULL,\n                                                       error))\n    goto out;\n\n  data.job = job;\n  data.main_loop = main_loop;\n  g_signal_connect (manager, \"job-removed\", G_CALLBACK (job_removed_cb), &data);\n\n  g_main_loop_run (main_loop);\n\n  res = TRUE;\n\nout:\n  if (main_loop)\n    g_main_loop_unref (main_loop);\n  if (manager)\n    g_object_unref (manager);\n\n  return res;\n}\n\nstatic void\nadd_font_path_args (FlatpakBwrap *bwrap)\n{\n  g_autoptr(GString) xml_snippet = g_string_new (\"\");\n  gchar *path_build_tmp = NULL;\n  g_autoptr(GFile) user_font1 = NULL;\n  g_autoptr(GFile) user_font2 = NULL;\n  g_autoptr(GFile) user_font_cache = NULL;\n  g_auto(GStrv) system_cache_dirs = NULL;\n  gboolean found_cache = FALSE;\n  int i;\n\n\n  g_string_append (xml_snippet,\n                   \"<?xml version=\\\"1.0\\\"?>\\n\"\n                   \"<!DOCTYPE fontconfig SYSTEM \\\"fonts.dtd\\\">\\n\"\n                   \"<fontconfig>\\n\");\n\n  if (g_file_test (SYSTEM_FONTS_DIR, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", SYSTEM_FONTS_DIR, \"/run/host/fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/fonts</remap-dir>\\n\",\n                              SYSTEM_FONTS_DIR);\n    }\n\n  if (g_file_test (\"/usr/local/share/fonts\", G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", \"/usr/local/share/fonts\", \"/run/host/local-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/local-fonts</remap-dir>\\n\",\n                              \"/usr/local/share/fonts\");\n    }\n\n  system_cache_dirs = g_strsplit (SYSTEM_FONT_CACHE_DIRS, \":\", 0);\n  for (i = 0; system_cache_dirs[i] != NULL; i++)\n    {\n      if (g_file_test (system_cache_dirs[i], G_FILE_TEST_EXISTS))\n        {\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--ro-bind\", system_cache_dirs[i], \"/run/host/fonts-cache\",\n                                  NULL);\n          found_cache = TRUE;\n          break;\n        }\n    }\n\n  if (!found_cache)\n    {\n      /* We ensure these directories are never writable, or fontconfig\n         will use them to write the default cache */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--tmpfs\", \"/run/host/fonts-cache\",\n                              \"--remount-ro\", \"/run/host/fonts-cache\",\n                              NULL);\n    }\n\n  path_build_tmp = g_build_filename (g_get_user_data_dir (), \"fonts\", NULL);\n  user_font1 = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  path_build_tmp = g_build_filename (g_get_home_dir (), \".fonts\", NULL);\n  user_font2 = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  if (g_file_query_exists (user_font1, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font1), \"/run/host/user-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/user-fonts</remap-dir>\\n\",\n                              flatpak_file_get_path_cached (user_font1));\n    }\n  else if (g_file_query_exists (user_font2, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font2), \"/run/host/user-fonts\",\n                              NULL);\n      g_string_append_printf (xml_snippet,\n                              \"\\t<remap-dir as-path=\\\"%s\\\">/run/host/user-fonts</remap-dir>\\n\",\n                              flatpak_file_get_path_cached (user_font2));\n    }\n\n  path_build_tmp = g_build_filename (g_get_user_cache_dir (), \"fontconfig\", NULL);\n  user_font_cache = g_file_new_for_path (path_build_tmp);\n  g_clear_pointer (&path_build_tmp, g_free);\n\n  if (g_file_query_exists (user_font_cache, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_font_cache), \"/run/host/user-fonts-cache\",\n                              NULL);\n    }\n  else\n    {\n      /* We ensure these directories are never writable, or fontconfig\n         will use them to write the default cache */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--tmpfs\", \"/run/host/user-fonts-cache\",\n                              \"--remount-ro\", \"/run/host/user-fonts-cache\",\n                              NULL);\n    }\n\n  g_string_append (xml_snippet,\n                   \"</fontconfig>\\n\");\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"font-dirs.xml\", xml_snippet->str, xml_snippet->len, \"/run/host/font-dirs.xml\", NULL))\n    g_warning (\"Unable to add fontconfig data snippet\");\n}\n\nstatic void\nadd_icon_path_args (FlatpakBwrap *bwrap)\n{\n  g_autofree gchar *user_icons_path = NULL;\n  g_autoptr(GFile) user_icons = NULL;\n\n  if (g_file_test (\"/usr/share/icons\", G_FILE_TEST_IS_DIR))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", \"/usr/share/icons\", \"/run/host/share/icons\",\n                              NULL);\n    }\n\n  user_icons_path = g_build_filename (g_get_user_data_dir (), \"icons\", NULL);\n  user_icons = g_file_new_for_path (user_icons_path);\n  if (g_file_query_exists (user_icons, NULL))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (user_icons), \"/run/host/user-share/icons\",\n                              NULL);\n    }\n}\n\nFlatpakContext *\nflatpak_app_compute_permissions (GKeyFile *app_metadata,\n                                 GKeyFile *runtime_metadata,\n                                 GError  **error)\n{\n  g_autoptr(FlatpakContext) app_context = NULL;\n\n  app_context = flatpak_context_new ();\n\n  if (runtime_metadata != NULL)\n    {\n      if (!flatpak_context_load_metadata (app_context, runtime_metadata, error))\n        return NULL;\n\n      /* Don't inherit any permissions from the runtime, only things like env vars. */\n      flatpak_context_reset_permissions (app_context);\n    }\n\n  if (app_metadata != NULL &&\n      !flatpak_context_load_metadata (app_context, app_metadata, error))\n    return NULL;\n\n  return g_steal_pointer (&app_context);\n}\n\n#ifdef HAVE_DCONF\n\nstatic void\nadd_dconf_key_to_keyfile (GKeyFile      *keyfile,\n                          DConfClient   *client,\n                          const char    *key,\n                          DConfReadFlags flags)\n{\n  g_autofree char *group = g_path_get_dirname (key);\n  g_autofree char *k = g_path_get_basename (key);\n  GVariant *value = dconf_client_read_full (client, key, flags, NULL);\n\n  if (value)\n    {\n      g_autofree char *val = g_variant_print (value, TRUE);\n      g_key_file_set_value (keyfile, group + 1, k, val);\n    }\n}\n\nstatic void\nadd_dconf_dir_to_keyfile (GKeyFile      *keyfile,\n                          DConfClient   *client,\n                          const char    *dir,\n                          DConfReadFlags flags)\n{\n  g_auto(GStrv) keys = NULL;\n  int i;\n\n  keys = dconf_client_list (client, dir, NULL);\n  for (i = 0; keys[i]; i++)\n    {\n      g_autofree char *k = g_strconcat (dir, keys[i], NULL);\n      if (dconf_is_dir (k, NULL))\n        add_dconf_dir_to_keyfile (keyfile, client, k, flags);\n      else if (dconf_is_key (k, NULL))\n        add_dconf_key_to_keyfile (keyfile, client, k, flags);\n    }\n}\n\nstatic void\nadd_dconf_locks_to_list (GString     *s,\n                         DConfClient *client,\n                         const char  *dir)\n{\n  g_auto(GStrv) locks = NULL;\n  int i;\n\n  locks = dconf_client_list_locks (client, dir, NULL);\n  for (i = 0; locks[i]; i++)\n    {\n      g_string_append (s, locks[i]);\n      g_string_append_c (s, '\\n');\n    }\n}\n\n#endif /* HAVE_DCONF */\n\nstatic void\nget_dconf_data (const char  *app_id,\n                const char **paths,\n                const char  *migrate_path,\n                char       **defaults,\n                gsize       *defaults_size,\n                char       **values,\n                gsize       *values_size,\n                char       **locks,\n                gsize       *locks_size)\n{\n#ifdef HAVE_DCONF\n  DConfClient *client = NULL;\n  g_autofree char *prefix = NULL;\n#endif\n  g_autoptr(GKeyFile) defaults_data = NULL;\n  g_autoptr(GKeyFile) values_data = NULL;\n  g_autoptr(GString) locks_data = NULL;\n\n  defaults_data = g_key_file_new ();\n  values_data = g_key_file_new ();\n  locks_data = g_string_new (\"\");\n\n#ifdef HAVE_DCONF\n\n  client = dconf_client_new ();\n\n  prefix = flatpak_dconf_path_for_app_id (app_id);\n\n  if (migrate_path)\n    {\n      g_debug (\"Add values in dir '%s', prefix is '%s'\", migrate_path, prefix);\n      if (flatpak_dconf_path_is_similar (migrate_path, prefix))\n        add_dconf_dir_to_keyfile (values_data, client, migrate_path, DCONF_READ_USER_VALUE);\n      else\n        g_warning (\"Ignoring D-Conf migrate-path setting %s\", migrate_path);\n    }\n\n  g_debug (\"Add defaults in dir %s\", prefix);\n  add_dconf_dir_to_keyfile (defaults_data, client, prefix, DCONF_READ_DEFAULT_VALUE);\n\n  g_debug (\"Add locks in dir %s\", prefix);\n  add_dconf_locks_to_list (locks_data, client, prefix);\n\n  /* We allow extra paths for defaults and locks, but not for user values */\n  if (paths)\n    {\n      int i;\n      for (i = 0; paths[i]; i++)\n        {\n          if (dconf_is_dir (paths[i], NULL))\n            {\n              g_debug (\"Add defaults in dir %s\", paths[i]);\n              add_dconf_dir_to_keyfile (defaults_data, client, paths[i], DCONF_READ_DEFAULT_VALUE);\n\n              g_debug (\"Add locks in dir %s\", paths[i]);\n              add_dconf_locks_to_list (locks_data, client, paths[i]);\n            }\n          else if (dconf_is_key (paths[i], NULL))\n            {\n              g_debug (\"Add individual key %s\", paths[i]);\n              add_dconf_key_to_keyfile (defaults_data, client, paths[i], DCONF_READ_DEFAULT_VALUE);\n              add_dconf_key_to_keyfile (values_data, client, paths[i], DCONF_READ_USER_VALUE);\n            }\n          else\n            {\n              g_warning (\"Ignoring settings path '%s': neither dir nor key\", paths[i]);\n            }\n        }\n    }\n#endif\n\n  *defaults = g_key_file_to_data (defaults_data, defaults_size, NULL);\n  *values = g_key_file_to_data (values_data, values_size, NULL);\n  *locks_size = locks_data->len;\n  *locks = g_string_free (g_steal_pointer (&locks_data), FALSE);\n\n#ifdef HAVE_DCONF\n  g_object_unref (client);\n#endif\n}\n\nstatic gboolean\nflatpak_run_add_dconf_args (FlatpakBwrap *bwrap,\n                            const char   *app_id,\n                            GKeyFile     *metakey,\n                            GError      **error)\n{\n  g_auto(GStrv) paths = NULL;\n  g_autofree char *migrate_path = NULL;\n  g_autofree char *defaults = NULL;\n  g_autofree char *values = NULL;\n  g_autofree char *locks = NULL;\n  gsize defaults_size;\n  gsize values_size;\n  gsize locks_size;\n\n  if (metakey)\n    {\n      paths = g_key_file_get_string_list (metakey,\n                                          FLATPAK_METADATA_GROUP_DCONF,\n                                          FLATPAK_METADATA_KEY_DCONF_PATHS,\n                                          NULL, NULL);\n      migrate_path = g_key_file_get_string (metakey,\n                                            FLATPAK_METADATA_GROUP_DCONF,\n                                            FLATPAK_METADATA_KEY_DCONF_MIGRATE_PATH,\n                                            NULL);\n    }\n\n  get_dconf_data (app_id,\n                  (const char **) paths,\n                  migrate_path,\n                  &defaults, &defaults_size,\n                  &values, &values_size,\n                  &locks, &locks_size);\n\n  if (defaults_size != 0 &&\n      !flatpak_bwrap_add_args_data (bwrap,\n                                    \"dconf-defaults\",\n                                    defaults, defaults_size,\n                                    \"/etc/glib-2.0/settings/defaults\",\n                                    error))\n    return FALSE;\n\n  if (locks_size != 0 &&\n      !flatpak_bwrap_add_args_data (bwrap,\n                                    \"dconf-locks\",\n                                    locks, locks_size,\n                                    \"/etc/glib-2.0/settings/locks\",\n                                    error))\n    return FALSE;\n\n  /* We do a one-time conversion of existing dconf settings to a keyfile.\n   * Only do that once the app stops requesting dconf access.\n   */\n  if (migrate_path)\n    {\n      g_autofree char *filename = NULL;\n\n      filename = g_build_filename (g_get_home_dir (),\n                                   \".var/app\", app_id,\n                                   \"config/glib-2.0/settings/keyfile\",\n                                   NULL);\n\n      g_debug (\"writing D-Conf values to %s\", filename);\n\n      if (values_size != 0 && !g_file_test (filename, G_FILE_TEST_EXISTS))\n        {\n          g_autofree char *dir = g_path_get_dirname (filename);\n\n          if (g_mkdir_with_parents (dir, 0700) == -1)\n            {\n              g_warning (\"failed creating dirs for %s\", filename);\n              return FALSE;\n            }\n\n          if (!g_file_set_contents (filename, values, values_size, error))\n            {\n              g_warning (\"failed writing %s\", filename);\n              return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_add_app_info_args (FlatpakBwrap       *bwrap,\n                               GFile              *app_files,\n                               GFile              *original_app_files,\n                               GBytes             *app_deploy_data,\n                               const char         *app_extensions,\n                               GFile              *runtime_files,\n                               GFile              *original_runtime_files,\n                               GBytes             *runtime_deploy_data,\n                               const char         *runtime_extensions,\n                               const char         *app_id,\n                               const char         *app_branch,\n                               FlatpakDecomposed  *runtime_ref,\n                               GFile              *app_id_dir,\n                               FlatpakContext     *final_app_context,\n                               FlatpakContext     *cmdline_context,\n                               gboolean            sandbox,\n                               gboolean            build,\n                               gboolean            devel,\n                               char              **app_info_path_out,\n                               int                 instance_id_fd,\n                               char              **instance_id_host_dir_out,\n                               GError             **error)\n{\n  g_autofree char *info_path = NULL;\n  g_autofree char *bwrapinfo_path = NULL;\n  int fd, fd2, fd3;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree char *runtime_path = NULL;\n  const char *group;\n  g_autofree char *instance_id = NULL;\n  glnx_autofd int lock_fd = -1;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autofree char *instance_id_sandbox_dir = NULL;\n  g_autofree char *instance_id_lock_file = NULL;\n  g_autofree char *arch = flatpak_decomposed_dup_arch (runtime_ref);\n\n  g_return_val_if_fail (app_id != NULL, FALSE);\n\n  instance_id = flatpak_instance_allocate_id (&instance_id_host_dir, &lock_fd);\n  if (instance_id == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Unable to allocate instance id\"));\n\n  instance_id_sandbox_dir = g_strdup_printf (\"/run/flatpak/.flatpak/%s\", instance_id);\n  instance_id_lock_file = g_build_filename (instance_id_sandbox_dir, \".ref\", NULL);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\",\n                          instance_id_host_dir,\n                          instance_id_sandbox_dir,\n                          \"--lock-file\",\n                          instance_id_lock_file,\n                          NULL);\n  flatpak_bwrap_add_runtime_dir_member (bwrap, \".flatpak\");\n  /* Keep the .ref lock held until we've started bwrap to avoid races */\n  flatpak_bwrap_add_noinherit_fd (bwrap, glnx_steal_fd (&lock_fd));\n\n  info_path = g_build_filename (instance_id_host_dir, \"info\", NULL);\n\n  keyfile = g_key_file_new ();\n\n  if (original_app_files)\n    group = FLATPAK_METADATA_GROUP_APPLICATION;\n  else\n    group = FLATPAK_METADATA_GROUP_RUNTIME;\n\n  g_key_file_set_string (keyfile, group, FLATPAK_METADATA_KEY_NAME, app_id);\n  g_key_file_set_string (keyfile, group, FLATPAK_METADATA_KEY_RUNTIME,\n                         flatpak_decomposed_get_ref (runtime_ref));\n\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_INSTANCE_ID, instance_id);\n  if (app_id_dir)\n    {\n      g_autofree char *instance_path = g_file_get_path (app_id_dir);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_INSTANCE_PATH, instance_path);\n    }\n\n  if (app_files)\n    {\n      g_autofree char *app_path = g_file_get_path (app_files);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_APP_PATH, app_path);\n    }\n\n  if (original_app_files != NULL && original_app_files != app_files)\n    {\n      g_autofree char *app_path = g_file_get_path (original_app_files);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_ORIGINAL_APP_PATH, app_path);\n    }\n\n  if (app_deploy_data)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_APP_COMMIT, flatpak_deploy_data_get_commit (app_deploy_data));\n  if (app_extensions && *app_extensions != 0)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_APP_EXTENSIONS, app_extensions);\n  runtime_path = g_file_get_path (runtime_files);\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_RUNTIME_PATH, runtime_path);\n\n  if (runtime_files != original_runtime_files)\n    {\n      g_autofree char *path = g_file_get_path (original_runtime_files);\n      g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                             FLATPAK_METADATA_KEY_ORIGINAL_RUNTIME_PATH, path);\n    }\n\n  if (runtime_deploy_data)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_RUNTIME_COMMIT, flatpak_deploy_data_get_commit (runtime_deploy_data));\n  if (runtime_extensions && *runtime_extensions != 0)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_RUNTIME_EXTENSIONS, runtime_extensions);\n  if (app_branch != NULL)\n    g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                           FLATPAK_METADATA_KEY_BRANCH, app_branch);\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_ARCH, arch);\n\n  g_key_file_set_string (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                         FLATPAK_METADATA_KEY_FLATPAK_VERSION, PACKAGE_VERSION);\n\n  if ((final_app_context->sockets & FLATPAK_CONTEXT_SOCKET_SESSION_BUS) == 0)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SESSION_BUS_PROXY, TRUE);\n\n  if ((final_app_context->sockets & FLATPAK_CONTEXT_SOCKET_SYSTEM_BUS) == 0)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SYSTEM_BUS_PROXY, TRUE);\n\n  if (sandbox)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_SANDBOX, TRUE);\n  if (build)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_BUILD, TRUE);\n  if (devel)\n    g_key_file_set_boolean (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                            FLATPAK_METADATA_KEY_DEVEL, TRUE);\n\n  if (cmdline_context)\n    {\n      g_autoptr(GPtrArray) cmdline_args = g_ptr_array_new_with_free_func (g_free);\n      flatpak_context_to_args (cmdline_context, cmdline_args);\n      if (cmdline_args->len > 0)\n        {\n          g_key_file_set_string_list (keyfile, FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_EXTRA_ARGS,\n                                      (const char * const *) cmdline_args->pdata,\n                                      cmdline_args->len);\n        }\n    }\n\n  flatpak_context_save_metadata (final_app_context, TRUE, keyfile);\n\n  if (!g_key_file_save_to_file (keyfile, info_path, error))\n    return FALSE;\n\n  /* We want to create a file on /.flatpak-info that the app cannot modify, which\n     we do by creating a read-only bind mount. This way one can openat()\n     /proc/$pid/root, and if that succeeds use openat via that to find the\n     unfakable .flatpak-info file. However, there is a tiny race in that if\n     you manage to open /proc/$pid/root, but then the pid dies, then\n     every mount but the root is unmounted in the namespace, so the\n     .flatpak-info will be empty. We fix this by first creating a real file\n     with the real info in, then bind-mounting on top of that, the same info.\n     This way even if the bind-mount is unmounted we can find the real data.\n   */\n\n  fd = open (info_path, O_RDONLY);\n  if (fd == -1)\n    {\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open flatpak-info file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  fd2 = open (info_path, O_RDONLY);\n  if (fd2 == -1)\n    {\n      close (fd);\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open flatpak-info file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--file\", fd, \"/.flatpak-info\");\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--ro-bind-data\", fd2, \"/.flatpak-info\");\n\n  /* Tell the application that it's running under Flatpak in a generic way. */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--setenv\", \"container\", \"flatpak\",\n                          NULL);\n  if (!flatpak_bwrap_add_args_data (bwrap,\n                                    \"container-manager\",\n                                    \"flatpak\\n\", -1,\n                                    \"/run/host/container-manager\",\n                                    error))\n    return FALSE;\n\n  bwrapinfo_path = g_build_filename (instance_id_host_dir, \"bwrapinfo.json\", NULL);\n  fd3 = open (bwrapinfo_path, O_RDWR | O_CREAT, 0644);\n  if (fd3 == -1)\n    {\n      close (fd);\n      close (fd2);\n      int errsv = errno;\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                   _(\"Failed to open bwrapinfo.json file: %s\"), g_strerror (errsv));\n      return FALSE;\n    }\n\n  /* NOTE: It is important that this takes place after bwrapinfo.json is created,\n     otherwise start notifications in the portal may not work. */\n  if (instance_id_fd != -1)\n    {\n      gsize instance_id_position = 0;\n      gsize instance_id_size = strlen (instance_id);\n\n      while (instance_id_size > 0)\n        {\n          gssize bytes_written = write (instance_id_fd, instance_id + instance_id_position, instance_id_size);\n          if (G_UNLIKELY (bytes_written <= 0))\n            {\n              int errsv = bytes_written == -1 ? errno : ENOSPC;\n              if (errsv == EINTR)\n                continue;\n\n              close (fd);\n              close (fd2);\n              close (fd3);\n\n              g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),\n                           _(\"Failed to write to instance id fd: %s\"), g_strerror (errsv));\n              return FALSE;\n            }\n\n          instance_id_position += bytes_written;\n          instance_id_size -= bytes_written;\n        }\n\n      close (instance_id_fd);\n    }\n\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--info-fd\", fd3, NULL);\n\n  if (app_info_path_out != NULL)\n    *app_info_path_out = g_strdup_printf (\"/proc/self/fd/%d\", fd);\n\n  if (instance_id_host_dir_out != NULL)\n    *instance_id_host_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n\nstatic void\nadd_tzdata_args (FlatpakBwrap *bwrap,\n                 GFile *runtime_files)\n{\n  g_autofree char *raw_timezone = flatpak_get_timezone ();\n  g_autofree char *timezone_content = g_strdup_printf (\"%s\\n\", raw_timezone);\n  g_autofree char *localtime_content = g_strconcat (\"../usr/share/zoneinfo/\", raw_timezone, NULL);\n  g_autoptr(GFile) runtime_zoneinfo = NULL;\n\n  if (runtime_files)\n    runtime_zoneinfo = g_file_resolve_relative_path (runtime_files, \"share/zoneinfo\");\n\n  /* Check for runtime /usr/share/zoneinfo */\n  if (runtime_zoneinfo != NULL && g_file_query_exists (runtime_zoneinfo, NULL))\n    {\n      /* Check for host /usr/share/zoneinfo */\n      if (g_file_test (\"/usr/share/zoneinfo\", G_FILE_TEST_IS_DIR))\n        {\n          /* Here we assume the host timezone file exist in the host data */\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--ro-bind\", \"/usr/share/zoneinfo\", \"/usr/share/zoneinfo\",\n                                  \"--symlink\", localtime_content, \"/etc/localtime\",\n                                  NULL);\n        }\n      else\n        {\n          g_autoptr(GFile) runtime_tzfile = g_file_resolve_relative_path (runtime_zoneinfo, raw_timezone);\n\n          /* Check if host timezone file exist in the runtime tzdata */\n          if (g_file_query_exists (runtime_tzfile, NULL))\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--symlink\", localtime_content, \"/etc/localtime\",\n                                    NULL);\n        }\n    }\n\n  flatpak_bwrap_add_args_data (bwrap, \"timezone\",\n                               timezone_content, -1, \"/etc/timezone\",\n                               NULL);\n}\n\nstatic void\nadd_monitor_path_args (gboolean      use_session_helper,\n                       FlatpakBwrap *bwrap)\n{\n  g_autoptr(AutoFlatpakSessionHelper) session_helper = NULL;\n  g_autofree char *monitor_path = NULL;\n  g_autofree char *pkcs11_socket_path = NULL;\n  g_autoptr(GVariant) session_data = NULL;\n\n  if (use_session_helper)\n    {\n      session_helper =\n        flatpak_session_helper_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION,\n                                                       G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES | G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS,\n                                                       FLATPAK_SESSION_HELPER_BUS_NAME,\n                                                       FLATPAK_SESSION_HELPER_PATH,\n                                                       NULL, NULL);\n    }\n\n  if (session_helper &&\n      flatpak_session_helper_call_request_session_sync (session_helper,\n                                                        &session_data,\n                                                        NULL, NULL))\n    {\n      if (g_variant_lookup (session_data, \"path\", \"s\", &monitor_path))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", monitor_path, \"/run/host/monitor\",\n                                \"--symlink\", \"/run/host/monitor/resolv.conf\", \"/etc/resolv.conf\",\n                                \"--symlink\", \"/run/host/monitor/host.conf\", \"/etc/host.conf\",\n                                \"--symlink\", \"/run/host/monitor/hosts\", \"/etc/hosts\",\n                                \"--symlink\", \"/run/host/monitor/gai.conf\", \"/etc/gai.conf\",\n                                NULL);\n\n      if (g_variant_lookup (session_data, \"pkcs11-socket\", \"s\", &pkcs11_socket_path))\n        {\n          static const char sandbox_pkcs11_socket_path[] = \"/run/flatpak/p11-kit/pkcs11\";\n          const char *trusted_module_contents =\n            \"# This overrides the runtime p11-kit-trusted module with a client one talking to the trust module on the host\\n\"\n            \"module: p11-kit-client.so\\n\";\n\n          if (flatpak_bwrap_add_args_data (bwrap, \"p11-kit-trust.module\",\n                                           trusted_module_contents, -1,\n                                           \"/etc/pkcs11/modules/p11-kit-trust.module\", NULL))\n            {\n              flatpak_bwrap_add_args (bwrap,\n                                      \"--ro-bind\", pkcs11_socket_path, sandbox_pkcs11_socket_path,\n                                      NULL);\n              flatpak_bwrap_unset_env (bwrap, \"P11_KIT_SERVER_ADDRESS\");\n              flatpak_bwrap_add_runtime_dir_member (bwrap, \"p11-kit\");\n            }\n        }\n    }\n  else\n    {\n      if (g_file_test (\"/etc/resolv.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/resolv.conf\", \"/etc/resolv.conf\",\n                                NULL);\n      if (g_file_test (\"/etc/host.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/host.conf\", \"/etc/host.conf\",\n                                NULL);\n      if (g_file_test (\"/etc/hosts\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/hosts\", \"/etc/hosts\",\n                                NULL);\n      if (g_file_test (\"/etc/gai.conf\", G_FILE_TEST_EXISTS))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--ro-bind\", \"/etc/gai.conf\", \"/etc/gai.conf\",\n                                NULL);\n    }\n}\n\nstatic void\nadd_document_portal_args (FlatpakBwrap *bwrap,\n                          const char   *app_id,\n                          char        **out_mount_path)\n{\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *doc_mount_path = NULL;\n\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GDBusMessage) reply = NULL;\n      g_autoptr(GDBusMessage) msg =\n        g_dbus_message_new_method_call (\"org.freedesktop.portal.Documents\",\n                                        \"/org/freedesktop/portal/documents\",\n                                        \"org.freedesktop.portal.Documents\",\n                                        \"GetMountPoint\");\n      g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n      reply =\n        g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                        G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                        30000,\n                                                        NULL,\n                                                        NULL,\n                                                        NULL);\n      if (reply)\n        {\n          if (g_dbus_message_to_gerror (reply, &local_error))\n            {\n              if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n                g_debug (\"Document portal not available, not mounting /run/flatpak/doc\");\n              else\n                g_message (\"Can't get document portal: %s\", local_error->message);\n            }\n          else\n            {\n              static const char dst_path[] = \"/run/flatpak/doc\";\n              g_autofree char *src_path = NULL;\n              g_variant_get (g_dbus_message_get_body (reply),\n                             \"(^ay)\", &doc_mount_path);\n\n              src_path = g_strdup_printf (\"%s/by-app/%s\",\n                                          doc_mount_path, app_id);\n              flatpak_bwrap_add_args (bwrap, \"--bind\", src_path, dst_path, NULL);\n              flatpak_bwrap_add_runtime_dir_member (bwrap, \"doc\");\n            }\n        }\n    }\n\n  *out_mount_path = g_steal_pointer (&doc_mount_path);\n}\n\n#ifdef ENABLE_SECCOMP\nstatic const uint32_t seccomp_x86_64_extra_arches[] = { SCMP_ARCH_X86, 0, };\n\n#ifdef SCMP_ARCH_AARCH64\nstatic const uint32_t seccomp_aarch64_extra_arches[] = { SCMP_ARCH_ARM, 0 };\n#endif\n\nstatic inline void\ncleanup_seccomp (void *p)\n{\n  scmp_filter_ctx *pp = (scmp_filter_ctx *) p;\n\n  if (*pp)\n    seccomp_release (*pp);\n}\n\nstatic gboolean\nsetup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blocklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key), EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy), EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (umount), EPERM},\n    {SCMP_SYS (umount2), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n     * the flags are OK, so we have no choice but to block clone3().\n     * Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q; see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3), ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's no\n     * legitimate reason to do these in the sandbox, so block all of them\n     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q) */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr), ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n          (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blocklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}\n#endif\n\nstatic void\nflatpak_run_setup_usr_links (FlatpakBwrap *bwrap,\n                             GFile        *runtime_files,\n                             const char   *sysroot)\n{\n  int i;\n\n  if (runtime_files == NULL)\n    return;\n\n  for (i = 0; flatpak_abs_usrmerged_dirs[i] != NULL; i++)\n    {\n      const char *subdir = flatpak_abs_usrmerged_dirs[i];\n      g_autoptr(GFile) runtime_subdir = NULL;\n\n      g_assert (subdir[0] == '/');\n      /* Skip the '/' when using as a subdirectory of the runtime */\n      runtime_subdir = g_file_get_child (runtime_files, subdir + 1);\n\n      if (g_file_query_exists (runtime_subdir, NULL))\n        {\n          g_autofree char *link = g_strconcat (\"usr\", subdir, NULL);\n          g_autofree char *create = NULL;\n\n          if (sysroot != NULL)\n            create = g_strconcat (sysroot, subdir, NULL);\n          else\n            create = g_strdup (subdir);\n\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--symlink\", link, create,\n                                  NULL);\n        }\n      else\n        {\n          g_debug (\"%s does not exist\",\n                   flatpak_file_get_path_cached (runtime_subdir));\n        }\n    }\n}\n\ngboolean\nflatpak_run_setup_base_argv (FlatpakBwrap   *bwrap,\n                             GFile          *runtime_files,\n                             GFile          *app_id_dir,\n                             const char     *arch,\n                             FlatpakRunFlags flags,\n                             GError        **error)\n{\n  g_autofree char *run_dir = NULL;\n  g_autofree char *passwd_contents = NULL;\n  g_autoptr(GString) group_contents = NULL;\n  const char *pkcs11_conf_contents = NULL;\n  struct group *g;\n  gulong pers;\n  gid_t gid = getgid ();\n  g_autoptr(GFile) etc = NULL;\n\n  run_dir = g_strdup_printf (\"/run/user/%d\", getuid ());\n\n  passwd_contents = g_strdup_printf (\"%s:x:%d:%d:%s:%s:%s\\n\"\n                                     \"nfsnobody:x:65534:65534:Unmapped user:/:/sbin/nologin\\n\",\n                                     g_get_user_name (),\n                                     getuid (), gid,\n                                     g_get_real_name (),\n                                     g_get_home_dir (),\n                                     DEFAULT_SHELL);\n\n  group_contents = g_string_new (\"\");\n  g = getgrgid (gid);\n  /* if NULL, the primary group is not known outside the container, so\n   * it might as well stay unknown inside the container... */\n  if (g != NULL)\n    g_string_append_printf (group_contents, \"%s:x:%d:%s\\n\",\n                            g->gr_name, gid, g_get_user_name ());\n  g_string_append (group_contents, \"nfsnobody:x:65534:\\n\");\n\n  pkcs11_conf_contents =\n    \"# Disable user pkcs11 config, because the host modules don't work in the runtime\\n\"\n    \"user-config: none\\n\";\n\n  if ((flags & FLATPAK_RUN_FLAG_NO_PROC) == 0)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--proc\", \"/proc\",\n                            NULL);\n\n  if (!(flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS))\n    flatpak_bwrap_add_arg (bwrap, \"--unshare-pid\");\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--dir\", \"/tmp\",\n                          \"--dir\", \"/var/tmp\",\n                          \"--dir\", \"/run/host\",\n                          \"--dir\", run_dir,\n                          \"--setenv\", \"XDG_RUNTIME_DIR\", run_dir,\n                          \"--symlink\", \"../run\", \"/var/run\",\n                          \"--ro-bind\", \"/sys/block\", \"/sys/block\",\n                          \"--ro-bind\", \"/sys/bus\", \"/sys/bus\",\n                          \"--ro-bind\", \"/sys/class\", \"/sys/class\",\n                          \"--ro-bind\", \"/sys/dev\", \"/sys/dev\",\n                          \"--ro-bind\", \"/sys/devices\", \"/sys/devices\",\n                          \"--ro-bind-try\", \"/proc/self/ns/user\", \"/run/.userns\",\n                          /* glib uses this like /etc/timezone */\n                          \"--symlink\", \"/etc/timezone\", \"/var/db/zoneinfo\",\n                          NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_DIE_WITH_PARENT)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--die-with-parent\",\n                            NULL);\n\n  if (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/usr/etc\",\n                            \"--symlink\", \"usr/etc\", \"/etc\",\n                            NULL);\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"passwd\", passwd_contents, -1, \"/etc/passwd\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"group\", group_contents->str, -1, \"/etc/group\", error))\n    return FALSE;\n\n  if (!flatpak_bwrap_add_args_data (bwrap, \"pkcs11.conf\", pkcs11_conf_contents, -1, \"/etc/pkcs11/pkcs11.conf\", error))\n    return FALSE;\n\n  if (g_file_test (\"/etc/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/etc/machine-id\", \"/etc/machine-id\", NULL);\n  else if (g_file_test (\"/var/lib/dbus/machine-id\", G_FILE_TEST_EXISTS))\n    flatpak_bwrap_add_args (bwrap, \"--ro-bind\", \"/var/lib/dbus/machine-id\", \"/etc/machine-id\", NULL);\n\n  if (runtime_files)\n    etc = g_file_get_child (runtime_files, \"etc\");\n  if (etc != NULL &&\n      (flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0 &&\n      g_file_query_exists (etc, NULL))\n    {\n      g_auto(GLnxDirFdIterator) dfd_iter = { 0, };\n      struct dirent *dent;\n      gboolean inited;\n\n      inited = glnx_dirfd_iterator_init_at (AT_FDCWD, flatpak_file_get_path_cached (etc), FALSE, &dfd_iter, NULL);\n\n      while (inited)\n        {\n          g_autofree char *src = NULL;\n          g_autofree char *dest = NULL;\n\n          if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dfd_iter, &dent, NULL, NULL) || dent == NULL)\n            break;\n\n          if (strcmp (dent->d_name, \"passwd\") == 0 ||\n              strcmp (dent->d_name, \"group\") == 0 ||\n              strcmp (dent->d_name, \"machine-id\") == 0 ||\n              strcmp (dent->d_name, \"resolv.conf\") == 0 ||\n              strcmp (dent->d_name, \"host.conf\") == 0 ||\n              strcmp (dent->d_name, \"hosts\") == 0 ||\n              strcmp (dent->d_name, \"gai.conf\") == 0 ||\n              strcmp (dent->d_name, \"localtime\") == 0 ||\n              strcmp (dent->d_name, \"timezone\") == 0 ||\n              strcmp (dent->d_name, \"pkcs11\") == 0)\n            continue;\n\n          src = g_build_filename (flatpak_file_get_path_cached (etc), dent->d_name, NULL);\n          dest = g_build_filename (\"/etc\", dent->d_name, NULL);\n          if (dent->d_type == DT_LNK)\n            {\n              g_autofree char *target = NULL;\n\n              target = glnx_readlinkat_malloc (dfd_iter.fd, dent->d_name,\n                                               NULL, error);\n              if (target == NULL)\n                return FALSE;\n\n              flatpak_bwrap_add_args (bwrap, \"--symlink\", target, dest, NULL);\n            }\n          else\n            {\n              flatpak_bwrap_add_args (bwrap, \"--ro-bind\", src, dest, NULL);\n            }\n        }\n    }\n\n  if (app_id_dir != NULL)\n    {\n      g_autoptr(GFile) app_cache_dir = g_file_get_child (app_id_dir, \"cache\");\n      g_autoptr(GFile) app_tmp_dir = g_file_get_child (app_cache_dir, \"tmp\");\n      g_autoptr(GFile) app_data_dir = g_file_get_child (app_id_dir, \"data\");\n      g_autoptr(GFile) app_config_dir = g_file_get_child (app_id_dir, \"config\");\n\n      flatpak_bwrap_add_args (bwrap,\n                              /* These are nice to have as a fixed path */\n                              \"--bind\", flatpak_file_get_path_cached (app_cache_dir), \"/var/cache\",\n                              \"--bind\", flatpak_file_get_path_cached (app_data_dir), \"/var/data\",\n                              \"--bind\", flatpak_file_get_path_cached (app_config_dir), \"/var/config\",\n                              \"--bind\", flatpak_file_get_path_cached (app_tmp_dir), \"/var/tmp\",\n                              NULL);\n    }\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files, NULL);\n\n  add_tzdata_args (bwrap, runtime_files);\n\n  pers = PER_LINUX;\n\n  if ((flags & FLATPAK_RUN_FLAG_SET_PERSONALITY) &&\n      flatpak_is_linux32_arch (arch))\n    {\n      g_debug (\"Setting personality linux32\");\n      pers = PER_LINUX32;\n    }\n\n  /* Always set the personallity, and clear all weird flags */\n  personality (pers);\n\n#ifdef ENABLE_SECCOMP\n  if (!setup_seccomp (bwrap, arch, pers, flags, error))\n    return FALSE;\n#endif\n\n  if ((flags & FLATPAK_RUN_FLAG_WRITABLE_ETC) == 0)\n    add_monitor_path_args ((flags & FLATPAK_RUN_FLAG_NO_SESSION_HELPER) == 0, bwrap);\n\n  return TRUE;\n}\n\nstatic gboolean\nforward_file (XdpDbusDocuments *documents,\n              const char       *app_id,\n              const char       *file,\n              char            **out_doc_id,\n              GError          **error)\n{\n  int fd, fd_id;\n  g_autofree char *doc_id = NULL;\n  g_autoptr(GUnixFDList) fd_list = NULL;\n  const char *perms[] = { \"read\", \"write\", NULL };\n\n  fd = open (file, O_PATH | O_CLOEXEC);\n  if (fd == -1)\n    return flatpak_fail (error, _(\"Failed to open \u2018%s\u2019\"), file);\n\n  fd_list = g_unix_fd_list_new ();\n  fd_id = g_unix_fd_list_append (fd_list, fd, error);\n  close (fd);\n\n  if (!xdp_dbus_documents_call_add_sync (documents,\n                                         g_variant_new (\"h\", fd_id),\n                                         TRUE, /* reuse */\n                                         FALSE, /* not persistent */\n                                         fd_list,\n                                         &doc_id,\n                                         NULL,\n                                         NULL,\n                                         error))\n    {\n      if (error)\n        g_dbus_error_strip_remote_error (*error);\n      return FALSE;\n    }\n\n  if (!xdp_dbus_documents_call_grant_permissions_sync (documents,\n                                                       doc_id,\n                                                       app_id,\n                                                       perms,\n                                                       NULL,\n                                                       error))\n    {\n      if (error)\n        g_dbus_error_strip_remote_error (*error);\n      return FALSE;\n    }\n\n  *out_doc_id = g_steal_pointer (&doc_id);\n\n  return TRUE;\n}\n\nstatic gboolean\nadd_rest_args (FlatpakBwrap   *bwrap,\n               const char     *app_id,\n               FlatpakExports *exports,\n               gboolean        file_forwarding,\n               const char     *doc_mount_path,\n               char           *args[],\n               int             n_args,\n               GError        **error)\n{\n  g_autoptr(XdpDbusDocuments) documents = NULL;\n  gboolean forwarding = FALSE;\n  gboolean forwarding_uri = FALSE;\n  gboolean can_forward = TRUE;\n  int i;\n\n  if (file_forwarding && doc_mount_path == NULL)\n    {\n      g_message (\"Can't get document portal mount path\");\n      can_forward = FALSE;\n    }\n  else if (file_forwarding)\n    {\n      g_autoptr(GError) local_error = NULL;\n\n      documents = xdp_dbus_documents_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION, 0,\n                                                             \"org.freedesktop.portal.Documents\",\n                                                             \"/org/freedesktop/portal/documents\",\n                                                             NULL,\n                                                             &local_error);\n      if (documents == NULL)\n        {\n          g_message (\"Can't get document portal: %s\", local_error->message);\n          can_forward = FALSE;\n        }\n    }\n\n  for (i = 0; i < n_args; i++)\n    {\n      g_autoptr(GFile) file = NULL;\n\n      if (file_forwarding &&\n          (strcmp (args[i], \"@@\") == 0 ||\n           strcmp (args[i], \"@@u\") == 0))\n        {\n          forwarding_uri = strcmp (args[i], \"@@u\") == 0;\n          forwarding = !forwarding;\n          continue;\n        }\n\n      if (can_forward && forwarding)\n        {\n          if (forwarding_uri)\n            {\n              if (g_str_has_prefix (args[i], \"file:\"))\n                file = g_file_new_for_uri (args[i]);\n              else if (G_IS_DIR_SEPARATOR (args[i][0]))\n                file = g_file_new_for_path (args[i]);\n            }\n          else\n            file = g_file_new_for_path (args[i]);\n        }\n\n      if (file && !flatpak_exports_path_is_visible (exports,\n                                                    flatpak_file_get_path_cached (file)))\n        {\n          g_autofree char *doc_id = NULL;\n          g_autofree char *basename = NULL;\n          g_autofree char *doc_path = NULL;\n          if (!forward_file (documents, app_id, flatpak_file_get_path_cached (file),\n                             &doc_id, error))\n            return FALSE;\n\n          basename = g_file_get_basename (file);\n          doc_path = g_build_filename (doc_mount_path, doc_id, basename, NULL);\n\n          if (forwarding_uri)\n            {\n              g_autofree char *path = doc_path;\n              doc_path = g_filename_to_uri (path, NULL, NULL);\n              /* This should never fail */\n              g_assert (doc_path != NULL);\n            }\n\n          g_debug (\"Forwarding file '%s' as '%s' to %s\", args[i], doc_path, app_id);\n          flatpak_bwrap_add_arg (bwrap, doc_path);\n        }\n      else\n        flatpak_bwrap_add_arg (bwrap, args[i]);\n    }\n\n  return TRUE;\n}\n\nFlatpakContext *\nflatpak_context_load_for_deploy (FlatpakDeploy *deploy,\n                                 GError       **error)\n{\n  g_autoptr(FlatpakContext) context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n  context = flatpak_app_compute_permissions (metakey, NULL, error);\n  if (context == NULL)\n    return NULL;\n\n  overrides = flatpak_deploy_get_overrides (deploy);\n  flatpak_context_merge (context, overrides);\n\n  return g_steal_pointer (&context);\n}\n\nstatic char *\ncalculate_ld_cache_checksum (GBytes   *app_deploy_data,\n                             GBytes   *runtime_deploy_data,\n                             const char *app_extensions,\n                             const char *runtime_extensions)\n{\n  g_autoptr(GChecksum) ld_so_checksum = g_checksum_new (G_CHECKSUM_SHA256);\n  if (app_deploy_data)\n    g_checksum_update (ld_so_checksum, (guchar *) flatpak_deploy_data_get_commit (app_deploy_data), -1);\n  g_checksum_update (ld_so_checksum, (guchar *) flatpak_deploy_data_get_commit (runtime_deploy_data), -1);\n  if (app_extensions)\n    g_checksum_update (ld_so_checksum, (guchar *) app_extensions, -1);\n  if (runtime_extensions)\n    g_checksum_update (ld_so_checksum, (guchar *) runtime_extensions, -1);\n\n  return g_strdup (g_checksum_get_string (ld_so_checksum));\n}\n\nstatic gboolean\nadd_ld_so_conf (FlatpakBwrap *bwrap,\n                GError      **error)\n{\n  const char *contents =\n    \"include /run/flatpak/ld.so.conf.d/app-*.conf\\n\"\n    \"include /app/etc/ld.so.conf\\n\"\n    \"/app/lib\\n\"\n    \"include /run/flatpak/ld.so.conf.d/runtime-*.conf\\n\";\n\n  return flatpak_bwrap_add_args_data (bwrap, \"ld-so-conf\",\n                                      contents, -1, \"/etc/ld.so.conf\", error);\n}\n\nstatic int\nregenerate_ld_cache (GPtrArray    *base_argv_array,\n                     GArray       *base_fd_array,\n                     GFile        *app_id_dir,\n                     const char   *checksum,\n                     GFile        *runtime_files,\n                     gboolean      generate_ld_so_conf,\n                     GCancellable *cancellable,\n                     GError      **error)\n{\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  g_autoptr(GArray) combined_fd_array = NULL;\n  g_autoptr(GFile) ld_so_cache = NULL;\n  g_autoptr(GFile) ld_so_cache_tmp = NULL;\n  g_autofree char *sandbox_cache_path = NULL;\n  g_autofree char *tmp_basename = NULL;\n  g_auto(GStrv) minimal_envp = NULL;\n  g_autofree char *commandline = NULL;\n  int exit_status;\n  glnx_autofd int ld_so_fd = -1;\n  g_autoptr(GFile) ld_so_dir = NULL;\n\n  if (app_id_dir)\n    ld_so_dir = g_file_get_child (app_id_dir, \".ld.so\");\n  else\n    {\n      g_autoptr(GFile) base_dir = g_file_new_for_path (g_get_user_cache_dir ());\n      ld_so_dir = g_file_resolve_relative_path (base_dir, \"flatpak/ld.so\");\n    }\n\n  ld_so_cache = g_file_get_child (ld_so_dir, checksum);\n  ld_so_fd = open (flatpak_file_get_path_cached (ld_so_cache), O_RDONLY);\n  if (ld_so_fd >= 0)\n    return glnx_steal_fd (&ld_so_fd);\n\n  g_debug (\"Regenerating ld.so.cache %s\", flatpak_file_get_path_cached (ld_so_cache));\n\n  if (!flatpak_mkdir_p (ld_so_dir, cancellable, error))\n    return FALSE;\n\n  minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);\n  bwrap = flatpak_bwrap_new (minimal_envp);\n\n  flatpak_bwrap_append_args (bwrap, base_argv_array);\n\n  flatpak_run_setup_usr_links (bwrap, runtime_files, NULL);\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return -1;\n    }\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--symlink\", \"../usr/etc/ld.so.conf\", \"/etc/ld.so.conf\",\n                            NULL);\n\n  tmp_basename = g_strconcat (checksum, \".XXXXXX\", NULL);\n  glnx_gen_temp_name (tmp_basename);\n\n  sandbox_cache_path = g_build_filename (\"/run/ld-so-cache-dir\", tmp_basename, NULL);\n  ld_so_cache_tmp = g_file_get_child (ld_so_dir, tmp_basename);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--unshare-pid\",\n                          \"--unshare-ipc\",\n                          \"--unshare-net\",\n                          \"--proc\", \"/proc\",\n                          \"--dev\", \"/dev\",\n                          \"--bind\", flatpak_file_get_path_cached (ld_so_dir), \"/run/ld-so-cache-dir\",\n                          NULL);\n  flatpak_bwrap_sort_envp (bwrap);\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return -1;\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"ldconfig\", \"-X\", \"-C\", sandbox_cache_path, NULL);\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running: '%s'\", commandline);\n\n  combined_fd_array = g_array_new (FALSE, TRUE, sizeof (int));\n  g_array_append_vals (combined_fd_array, base_fd_array->data, base_fd_array->len);\n  g_array_append_vals (combined_fd_array, bwrap->fds->data, bwrap->fds->len);\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_sync (NULL,\n                     (char **) bwrap->argv->pdata,\n                     bwrap->envp,\n                     G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                     flatpak_bwrap_child_setup_cb, combined_fd_array,\n                     NULL, NULL,\n                     &exit_status,\n                     error))\n    return -1;\n\n  if (!WIFEXITED (exit_status) || WEXITSTATUS (exit_status) != 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED,\n                          _(\"ldconfig failed, exit status %d\"), exit_status);\n      return -1;\n    }\n\n  ld_so_fd = open (flatpak_file_get_path_cached (ld_so_cache_tmp), O_RDONLY);\n  if (ld_so_fd < 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Can't open generated ld.so.cache\"));\n      return -1;\n    }\n\n  if (app_id_dir == NULL)\n    {\n      /* For runs without an app id dir we always regenerate the ld.so.cache */\n      unlink (flatpak_file_get_path_cached (ld_so_cache_tmp));\n    }\n  else\n    {\n      g_autoptr(GFile) active = g_file_get_child (ld_so_dir, \"active\");\n\n      /* For app-dirs we keep one checksum alive, by pointing the active symlink to it */\n\n      /* Rename to known name, possibly overwriting existing ref if race */\n      if (rename (flatpak_file_get_path_cached (ld_so_cache_tmp), flatpak_file_get_path_cached (ld_so_cache)) == -1)\n        {\n          glnx_set_error_from_errno (error);\n          return -1;\n        }\n\n      if (!flatpak_switch_symlink_and_remove (flatpak_file_get_path_cached (active),\n                                              checksum, error))\n        return -1;\n    }\n\n  return glnx_steal_fd (&ld_so_fd);\n}\n\n/* Check that this user is actually allowed to run this app. When running\n * from the gnome-initial-setup session, an app filter might not be available. */\nstatic gboolean\ncheck_parental_controls (FlatpakDecomposed *app_ref,\n                         FlatpakDeploy     *deploy,\n                         GCancellable      *cancellable,\n                         GError           **error)\n{\n#ifdef HAVE_LIBMALCONTENT\n  g_autoptr(MctManager) manager = NULL;\n  g_autoptr(MctAppFilter) app_filter = NULL;\n  g_autoptr(GDBusConnection) system_bus = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GDesktopAppInfo) app_info = NULL;\n  gboolean allowed = FALSE;\n\n  system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, error);\n  if (system_bus == NULL)\n    return FALSE;\n\n  manager = mct_manager_new (system_bus);\n  app_filter = mct_manager_get_app_filter (manager, getuid (),\n                                           MCT_GET_APP_FILTER_FLAGS_INTERACTIVE,\n                                           cancellable, &local_error);\n  if (g_error_matches (local_error, MCT_APP_FILTER_ERROR, MCT_APP_FILTER_ERROR_DISABLED))\n    {\n      g_debug (\"Skipping parental controls check for %s since parental \"\n               \"controls are disabled globally\", flatpak_decomposed_get_ref (app_ref));\n      return TRUE;\n    }\n  else if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN) ||\n           g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_NAME_HAS_NO_OWNER))\n    {\n      g_debug (\"Skipping parental controls check for %s since a required \"\n               \"service was not found\", flatpak_decomposed_get_ref (app_ref));\n      return TRUE;\n    }\n  else if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  /* Always filter by app ID. Additionally, filter by app info (which runs\n   * multiple checks, including whether the app ID, executable path and\n   * content types are allowed) if available. If the flatpak contains\n   * multiple .desktop files, we use the main one. The app ID check is\n   * always done, as the binary executed by `flatpak run` isn\u2019t necessarily\n   * extracted from a .desktop file. */\n  allowed = mct_app_filter_is_flatpak_ref_allowed (app_filter, flatpak_decomposed_get_ref (app_ref));\n\n  /* Look up the app\u2019s main .desktop file. */\n  if (deploy != NULL && allowed)\n    {\n      g_autoptr(GFile) deploy_dir = NULL;\n      const char *deploy_path;\n      g_autofree char *desktop_file_name = NULL;\n      g_autofree char *desktop_file_path = NULL;\n      g_autofree char *app_id = flatpak_decomposed_dup_id (app_ref);\n\n      deploy_dir = flatpak_deploy_get_dir (deploy);\n      deploy_path = flatpak_file_get_path_cached (deploy_dir);\n\n      desktop_file_name = g_strconcat (app_id, \".desktop\", NULL);\n      desktop_file_path = g_build_path (G_DIR_SEPARATOR_S,\n                                        deploy_path,\n                                        \"export\",\n                                        \"share\",\n                                        \"applications\",\n                                        desktop_file_name,\n                                        NULL);\n      app_info = g_desktop_app_info_new_from_filename (desktop_file_path);\n    }\n\n  if (app_info != NULL)\n    allowed = allowed && mct_app_filter_is_appinfo_allowed (app_filter,\n                                                            G_APP_INFO (app_info));\n\n  if (!allowed)\n    return flatpak_fail_error (error, FLATPAK_ERROR_PERMISSION_DENIED,\n                               /* Translators: The placeholder is for an app ref. */\n                               _(\"Running %s is not allowed by the policy set by your administrator\"),\n                               flatpak_decomposed_get_ref (app_ref));\n#endif  /* HAVE_LIBMALCONTENT */\n\n  return TRUE;\n}\n\nstatic int\nopen_namespace_fd_if_needed (const char *path,\n                             const char *other_path) {\n  struct stat s, other_s;\n\n  if (stat (path, &s) != 0)\n    return -1; /* No such namespace, ignore */\n\n  if (stat (other_path, &other_s) != 0)\n    return -1; /* No such namespace, ignore */\n\n  /* setns calls fail if the process is already in the desired namespace, hence the\n     check here to ensure the namespaces are different. */\n  if (s.st_ino != other_s.st_ino)\n    return open (path, O_RDONLY|O_CLOEXEC);\n\n  return -1;\n}\n\nstatic gboolean\ncheck_sudo (GError **error)\n{\n  const char *sudo_command_env = g_getenv (\"SUDO_COMMAND\");\n  g_auto(GStrv) split_command = NULL;\n\n  /* This check exists to stop accidental usage of `sudo flatpak run`\n     and is not to prevent running as root.\n   */\n\n  if (!sudo_command_env)\n    return TRUE;\n\n  /* SUDO_COMMAND could be a value like `/usr/bin/flatpak run foo` */\n  split_command = g_strsplit (sudo_command_env, \" \", 2);\n  if (g_str_has_suffix (split_command[0], \"flatpak\"))\n    return flatpak_fail_error (error, FLATPAK_ERROR, _(\"\\\"flatpak run\\\" is not intended to be run as `sudo flatpak run`, use `sudo -i` or `su -l` instead and invoke \\\"flatpak run\\\" from inside the new shell\"));\n\n  return TRUE;\n}\n\ngboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 const char        *custom_app_path,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 const char        *custom_usr_path,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) original_app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) original_runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \"/bin/sh\";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *app_ld_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *runtime_ld_path = NULL;\n  g_autofree char *checksum = NULL;\n  glnx_autofd int per_app_dir_lock_fd = -1;\n  g_autofree char *per_app_dir_lock_path = NULL;\n  g_autofree char *shared_xdg_runtime_dir = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  const char *app_target_path = \"/app\";\n  const char *runtime_target_path = \"/usr\";\n  struct stat s;\n\n  g_return_val_if_fail (app_ref != NULL, FALSE);\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  g_return_val_if_fail (app_id != NULL, FALSE);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n  g_return_val_if_fail (app_arch != NULL, FALSE);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \"/\", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  original_runtime_files = flatpak_deploy_get_files (runtime_deploy);\n\n  if (custom_usr_path != NULL)\n    {\n      runtime_files = g_file_new_for_path (custom_usr_path);\n      /* Mount the original runtime below here instead of /usr */\n      runtime_target_path = \"/run/parent/usr\";\n    }\n  else\n    {\n      runtime_files = g_object_ref (original_runtime_files);\n    }\n\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \"bin/ldconfig\");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  /* We can't use the ld.so cache if we are using a custom /usr or /app,\n   * because we don't have a unique ID for the /usr or /app, so we can't\n   * do cache-invalidation correctly. The caller can either build their\n   * own ld.so.cache before supplying us with the runtime, or supply\n   * their own LD_LIBRARY_PATH. */\n  if (custom_usr_path != NULL || custom_app_path != NULL)\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      original_app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\"Failed to migrate from %s: %s\"), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\"Failed to migrate old app data directory %s to new name %s: %s\"),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\"Failed to create symlink while migrating %s: %s\"),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  if (custom_app_path != NULL)\n    {\n      if (strcmp (custom_app_path, \"\") == 0)\n        app_files = NULL;\n      else\n        app_files = g_file_new_for_path (custom_app_path);\n\n      /* Mount the original app below here */\n      app_target_path = \"/run/parent/app\";\n    }\n  else if (original_app_files != NULL)\n    {\n      app_files = g_object_ref (original_app_files);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \"sandbox\");\n      flatpak_bwrap_set_env (bwrap, \"FLATPAK_SANDBOX_DIR\", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                          NULL);\n\n  if (runtime_files == original_runtime_files)\n    {\n      /* All true Flatpak runtimes have files/.ref */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--lock-file\", \"/usr/.ref\",\n                              NULL);\n    }\n  else\n    {\n      g_autoptr(GFile) runtime_child = NULL;\n\n      runtime_child = g_file_get_child (runtime_files, \".ref\");\n\n      /* Lock ${usr}/.ref if it exists */\n      if (g_file_query_exists (runtime_child, NULL))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--lock-file\", \"/usr/.ref\",\n                                NULL);\n\n      /* Put the real Flatpak runtime in /run/parent, so that the\n       * replacement /usr can have symlinks into /run/parent in order\n       * to use the Flatpak runtime's graphics drivers etc. if desired */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\",\n                              flatpak_file_get_path_cached (original_runtime_files),\n                              \"/run/parent/usr\",\n                              \"--lock-file\", \"/run/parent/usr/.ref\",\n                              NULL);\n      flatpak_run_setup_usr_links (bwrap, original_runtime_files,\n                                   \"/run/parent\");\n\n      g_clear_object (&runtime_child);\n      runtime_child = g_file_get_child (original_runtime_files, \"etc\");\n\n      if (g_file_query_exists (runtime_child, NULL))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--symlink\", \"usr/etc\", \"/run/parent/etc\",\n                                NULL);\n    }\n\n  if (app_files != NULL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                              NULL);\n\n      if (app_files == original_app_files)\n        {\n          /* All true Flatpak apps have files/.ref */\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--lock-file\", \"/app/.ref\",\n                                  NULL);\n        }\n      else\n        {\n          g_autoptr(GFile) app_child = NULL;\n\n          app_child = g_file_get_child (app_files, \".ref\");\n\n          /* Lock ${app}/.ref if it exists */\n          if (g_file_query_exists (app_child, NULL))\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--lock-file\", \"/app/.ref\",\n                                    NULL);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dir\", \"/app\",\n                              NULL);\n    }\n\n  if (original_app_files != NULL && app_files != original_app_files)\n    {\n      /* Put the real Flatpak app in /run/parent/app */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\",\n                              flatpak_file_get_path_cached (original_app_files),\n                              \"/run/parent/app\",\n                              \"--lock-file\", \"/run/parent/app/.ref\",\n                              NULL);\n    }\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref,\n                                       use_ld_so_cache, app_target_path,\n                                       &app_extensions, &app_ld_path,\n                                       cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref,\n                                       use_ld_so_cache, runtime_target_path,\n                                       &runtime_extensions, &runtime_ld_path,\n                                       cancellable, error))\n    return FALSE;\n\n  if (custom_usr_path == NULL)\n    flatpak_run_extend_ld_path (bwrap, NULL, runtime_ld_path);\n\n  if (custom_app_path == NULL)\n    flatpak_run_extend_ld_path (bwrap, app_ld_path, NULL);\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \"etc/ld.so.conf\");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \"--ro-bind-data\");\n      flatpak_bwrap_add_arg_printf (bwrap, \"%d\", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \"/etc/ld.so.cache\");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, original_app_files, app_deploy_data, app_extensions,\n                                      runtime_files, original_runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!sandboxed)\n    {\n      if (!flatpak_instance_ensure_per_app_dir (app_id,\n                                                &per_app_dir_lock_fd,\n                                                &per_app_dir_lock_path,\n                                                error))\n        return FALSE;\n\n      if (!flatpak_instance_ensure_per_app_xdg_runtime_dir (app_id,\n                                                            per_app_dir_lock_fd,\n                                                            &shared_xdg_runtime_dir,\n                                                            error))\n        return FALSE;\n\n      flatpak_bwrap_add_arg (bwrap, \"--bind\");\n      flatpak_bwrap_add_arg (bwrap, shared_xdg_runtime_dir);\n      flatpak_bwrap_add_arg_printf (bwrap, \"/run/user/%d\", getuid ());\n    }\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         per_app_dir_lock_fd,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if (per_app_dir_lock_path != NULL)\n    {\n      static const char lock[] = \"/run/flatpak/per-app-dirs-ref\";\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", per_app_dir_lock_path, lock,\n                              \"--lock-file\", lock,\n                              NULL);\n    }\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \"--symlink\", \"/app/lib/debug/source\", \"/run/build\",\n                          \"--symlink\", \"/usr/lib/debug/source\", \"/run/build-runtime\",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \"--chdir\", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \"No parent pid specified\");\n\n      userns_path = g_strdup_printf (\"/proc/%d/root/run/.userns\", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \"/proc/self/ns/user\");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \"--userns\", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\"/proc/%d/ns/user\", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \"--userns2\", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\"/proc/%d/ns/pid\", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \"--pidns\", pidns_fd, NULL);\n    }\n\n  flatpak_bwrap_populate_runtime_dir (bwrap, shared_xdg_runtime_dir);\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  flatpak_bwrap_sort_envp (bwrap);\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  /* Hold onto the lock until we execute bwrap */\n  flatpak_bwrap_add_noinherit_fd (bwrap, glnx_steal_fd (&per_app_dir_lock_fd));\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\"Unable to start app\"));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n"], "filenames": ["common/flatpak-run.c"], "buggy_code_start_loc": [2936], "buggy_code_end_loc": [2936], "fixing_code_start_loc": [2937], "fixing_code_end_loc": [2939], "type": "CWE-20", "message": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version.", "other": {"cve": {"id": "CVE-2021-41133", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-08T14:15:08.723", "lastModified": "2021-12-04T03:04:35.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.4 and 1.12.0, Flatpak apps with direct access to AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can trick portals and other host-OS services into treating the Flatpak app as though it was an ordinary, non-sandboxed host-OS process. They can do this by manipulating the VFS using recent mount-related syscalls that are not blocked by Flatpak's denylist seccomp filter, in order to substitute a crafted `/.flatpak-info` or make that file disappear entirely. Flatpak apps that act as clients for AF_UNIX sockets such as those used by Wayland, Pipewire or pipewire-pulse can escalate the privileges that the corresponding services will believe the Flatpak app has. Note that protocols that operate entirely over the D-Bus session bus (user bus), system bus or accessibility bus are not affected by this. This is due to the use of a proxy process `xdg-dbus-proxy`, whose VFS cannot be manipulated by the Flatpak app, when interacting with these buses. Patches exist for versions 1.10.4 and 1.12.0, and as of time of publication, a patch for version 1.8.2 is being planned. There are no workarounds aside from upgrading to a patched version."}, {"lang": "es", "value": "Flatpak es un sistema para construir, distribuir y ejecutar aplicaciones de escritorio en sandbox en Linux. En versiones anteriores a 1.10.4 y 1.12.0, las aplicaciones Flatpak con acceso directo a los sockets AF_UNIX, como los usados por Wayland, Pipewire o pipewire-pulse, pueden enga\u00f1ar a los portales y otros servicios del sistema operativo anfitri\u00f3n para que traten la aplicaci\u00f3n Flatpak como si fuera un proceso ordinario del Sistema Operativo anfitri\u00f3n sin sandbox. Pueden hacer esto al manipular el VFS usando recientes llamadas al sistema relacionadas con el montaje que no est\u00e1n bloqueadas por el filtro seccomp de Flatpak, para sustituir un \"/.flatpak-info\" dise\u00f1ado o hacer que ese archivo desaparezca por completo. Las aplicaciones Flatpak que act\u00faan como clientes de sockets AF_UNIX como los usados por Wayland, Pipewire o pipewire-pulse pueden escalar los privilegios que los servicios correspondientes creer\u00e1n que presenta la aplicaci\u00f3n Flatpak. Ten en cuenta que los protocolos que operan completamente sobre el bus de sesi\u00f3n D-Bus (bus de usuario), el bus de sistema o el bus de accesibilidad no est\u00e1n afectados por esto. Esto es debido al uso de un proceso proxy \"xdg-dbus-proxy\", cuyo VFS no puede ser manipulado por la app Flatpak, cuando interact\u00faa con estos buses. Se presentan parches para las versiones 1.10.4 y 1.12.0, y en el momento de la publicaci\u00f3n, se est\u00e1 planeando un parche para la versi\u00f3n 1.8.2. No se presentan soluciones aparte de la actualizaci\u00f3n a una versi\u00f3n parcheada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.2", "matchCriteriaId": "69BAD0B1-DDB3-46FE-8AEB-BF7203829E07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.10.0", "versionEndExcluding": "1.10.4", "matchCriteriaId": "E8521E68-800E-4633-9A6D-2CDDA84B77F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.11.1", "versionEndExcluding": "1.12.1", "matchCriteriaId": "00DC4C26-B1FD-4244-85CD-8507B0BFD961"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/10/26/9", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/1330662f33a55e88bfe18e76de28b7922d91a999", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/26b12484eb8a6219b9e7aa287b298a894b2f34ca", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/462fca2c666e0cd2b60d6d2593a7216a83047aaf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/4c34815784e9ffda5733225c7d95824f96375e36", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/89ae9fe74c6d445bb1b3a40e568d77cf5de47e48", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/9766ee05b1425db397d2cf23afd24c7f6146a69f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/a10f52a7565c549612c92b8e736a6698a53db330", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/e26ac7586c392b5eb35ff4609fe232c52523b2cf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/security/advisories/GHSA-67h7-w3jq-vh4q", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R5656ONDP2MGKIJMKEC7N2NXCV27WGTC/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/T5DKCYRC6MFSTFCUP4DELCOUUP3SFEFX/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4984", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flatpak/flatpak/commit/1330662f33a55e88bfe18e76de28b7922d91a999"}}